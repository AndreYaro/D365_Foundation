<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventModelType</Name>
	<SourceCode>
		<Declaration><![CDATA[
abstract class InventModelType
{
    RecordSortedList    physicalSettlementList;
    // <GEERU>
    InventTransCurrency_RU inventTransCurrency;
    // </GEERU>
    #ISOcountryRegionCodes


}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addCostTransVariance</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Serves as the entry point for the standard cost processing that is called for each
    ///    <c>inventTrans</c> record.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The <c>inventTrans</c> record that is currently processed.
    /// </param>
    /// <param name="_inventMovement">
    ///    The <c>inventMovement</c> class that is currently processed.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher that is currently processed.
    /// </param>
    /// <param name="_transDate">
    ///    The <c>transDate</c> that is used for this process.
    /// </param>
    /// <param name="_costTransState">
    ///    An <c>inventCostTransState</c> Enum that indicates if it is a financial or physical update process.
    /// </param>
    /// <param name="_isReturn">
    ///    A Boolean flag that indicates if this method is called during a return process; optional.
    /// </param>
    /// <param name="_inventTransOrig">
    ///    The <c>inventTrans</c> record that is returned; optional.
    /// </param>
    public void addCostTransVariance(
        InventTrans             _inventTrans,
        InventMovement          _inventMovement,
        Voucher                 _voucher,
        TransDate               _transDate,
        InventCostTransState    _costTransState,
        boolean                 _isReturn = false,
        InventTrans             _inventTransOrig = null)
    {
        CostInventoryEvent event = CostInventoryEvent::newInventoryEvent(_costTransState, _inventTrans);
        event.addInventTrans(_costTransState, _inventTrans);

        if (_inventMovement)
        {
            event.parmInventTransId(_inventMovement.transId());
        }

        CostEventProcessor::add(event);
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustCostTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Serves as the entry point for the standard cost processing of adjustments that is called for each
    ///    <c>inventTrans</c> record.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The <c>inventTrans</c> record that is currently processed.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher that is currently processed.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher that is currently processed.
    /// </param>
    /// <param name="_transDate">
    ///    The <c>transDate</c> that is used for this process.
    /// </param>
    /// <param name="_adjustment">
    ///    The <c>costAmount</c> to be added as a variance.
    /// </param>
    /// <param name="_inventCostTransVarianceList">
    ///    The <c>inventCostTransVarianceList</c> that should be used for the adjustment; optional.
    /// </param>
    /// <param name="_inventAdjustmentSpec">
    ///    Specifies how the adjustment is summarized in general ledger. The default is total.
    /// </param>
    /// <param name="_inventTransCurrency">
    /// The transaction currency: primary (default) or secondary - used for Dual Warehousing
    /// </param>
    /// <remarks>
    ///    This method was not implemented as abstract in order to keep the changes on the existing system as
    ///    small as possible. Therefore it contains only a return and no other logic.
    ///    The logic is currently
    ///    only implemented in the <c>inventModelType_StdCost</c> child class.
    /// </remarks>

    public void adjustCostTrans(
        InventTrans                 _inventTrans,
        LedgerVoucher               _ledgerVoucher,
        Voucher                     _voucher,
        TransDate                   _transDate,
        CostAmount                  _adjustment,
        InventCostTransVarianceList _inventCostTransVarianceList = null,
        InventAdjustmentSpec        _inventAdjustmentSpec = InventAdjustmentSpec::Total,       
        InventTransCurrency_RU      _inventTransCurrency  = InventTransCurrency_RU::PrimaryCur)
    {
        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowOnhandAdjustment</Name>
				<Source><![CDATA[
    public boolean allowOnhandAdjustment()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowTransactionAdjustment</Name>
				<Source><![CDATA[
    public boolean allowTransactionAdjustment(
        InventTrans         _inventTrans = null,
        InventTransOrigin   _inventTransOrigin = _inventTrans.inventTransOrigin())
    {
        if (_inventTrans)
        {
            if (_inventTransOrigin.isTransfer())
            {
                return false;
            }

            if (_inventTrans.useReturnTransToSyncCostPrice(_inventTransOrigin.ReferenceCategory))
            {
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheFinancialOnhandOnFinancialUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the financial update of the inventory transactions should cache the financial on-hand inventory.
    /// </summary>
    /// <returns>
    /// true if the financial update of the inventory transactions should cache the financial on-hand inventory; otherwise, false.
    /// </returns>
    public boolean cacheFinancialOnhandOnFinancialUpdate()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheFinancialOnhandOnPhysicalUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the physical update of the inventory transactions should cache the financial on-hand inventory.
    /// </summary>
    /// <returns>
    /// true if the physical update of the inventory transactions should cache the financial on-hand inventory; otherwise, false.
    /// </returns>
    public boolean cacheFinancialOnhandOnPhysicalUpdate()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventOnHand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the inventory on hand is valid.
    /// </summary>
    /// <param name="_inventOnhand">
    /// The <c>inventOnHand</c> object.
    /// </param>
    /// <param name="_checkOnly">
    /// If true, no exceptions will be thrown.
    /// </param>
    /// <returns>
    /// true if the inventory on-hand is valid; otherwise, false.
    /// </returns>
    /// <exception cref="Exception::UpdateConflict">
    /// The inventory on-hand is invalid because of a update conflict.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// The inventory on-hand is invalid because of an error.
    /// </exception>
    /// <remarks>
    /// The check is implemented to make sure calculations done in parallel do not conflict.
    /// An example of a conflict is when two parallel standard cost transactions see the same
    /// on hand values and both determine to round the inventory value. For standard cost,
    /// the on hand check validates that the standard cost times the on hand quantity is equal
    /// to the on hand inventory value.
    /// </remarks>
    public boolean checkInventOnHand(InventOnhand _inventOnhand, boolean _checkOnly = false)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNewDimensionGroupsForItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the suggested new dimension groups can be used for the specified item.
    /// </summary>
    /// <param name="_inventDimGroupSetupOrig">
    ///    The original set of dimension groups for the item.
    /// </param>
    /// <param name="_inventDimGroupSetupNew">
    ///    The suggested set of new dimension groups for the item.
    /// </param>
    /// <param name="_itemId">
    ///    The item for which the validation is performed.
    /// </param>
    /// <param name="_modelGroupId">
    ///    The inventory model group for the item.
    /// </param>
    /// <returns>
    ///    true if validation is successful; otherwise, false.
    /// </returns>
    public boolean checkNewDimensionGroupsForItem(
        InventDimGroupSetup         _inventDimGroupSetupOrig,
        InventDimGroupSetup         _inventDimGroupSetupNew,
        ItemId                      _itemId,
        InventModelGroupId          _modelGroupId)
    {
        InventDimParm           inventDimParmFinancialFrom;
        InventDimParm           inventDimParmFinancialTo;
        InventDimParm           inventDimParmPhysicalFrom;
        InventDimParm           inventDimParmPhysicalTo;

        InventTrans             inventTrans;

        _inventDimGroupSetupOrig.inventDimParmActiveFinancialInventory(inventDimParmFinancialFrom);
        _inventDimGroupSetupNew.inventDimParmActiveFinancialInventory(inventDimParmFinancialTo);

        if (!InventDimParm::isInventDimParmEqual(inventDimParmFinancialFrom,inventDimParmFinancialTo))
        {
            if (!InventCostActiveNonFinTransfValidate::constructWithParm(this.mustBeClosed()).validateFinancialDimModified(_itemId))
            {
                return false;
            }

            //if financial dimensions are added or removed then no physical transactions are allowed and all financial transactions must be closed
            select firstonly RecId from inventTrans
                where   inventTrans.ItemId          == _itemId
                    &&  inventTrans.ValueOpen       == InventTransOpen::Yes
                    &&  inventTrans.StatusIssue     <= StatusIssue::Deducted
                    &&  inventTrans.StatusReceipt   <= StatusReceipt::Received;

            if (inventTrans.RecId)
            {
                return checkFailed("@SYS97800");
            }
        }

        _inventDimGroupSetupOrig.inventDimParmActivePhysicalInventory(inventDimParmPhysicalFrom);
        _inventDimGroupSetupNew.inventDimParmActivePhysicalInventory(inventDimParmPhysicalTo);

        if (!InventDimParm::isInventDimParmEqual(inventDimParmPhysicalFrom,inventDimParmPhysicalTo))
        {
            if (!InventCostActiveNonFinTransfValidate::constructWithParm(this.mustBeClosed()).validatePhysicalDimModified(_inventDimGroupSetupOrig, _itemId))
            {
                return false;
            }

            InventModelGroup inventModelGroup = InventModelGroup::find(_modelGroupId);
            // if model group doesn't allow negative inventory we should not allow changing to a dimension group which creates such a situation
            if (!inventModelGroup.NegativePhysical)
            {
                //if physical dimensions are different then check if all on hands are non-negative
                return this.checkNotNegativeOnHand(_itemId, _modelGroupId, _inventDimGroupSetupNew, true);
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNewModelGroupId</Name>
				<Source><![CDATA[
    protected boolean checkNewModelGroupId(InventModelGroupItem _inventModelGroupItem)
    {
        if (!_inventModelGroupItem.RecId || !_inventModelGroupItem.orig() || _inventModelGroupItem.orig().ModelGroupId == _inventModelGroupItem.ModelGroupId)
        {
            return true;
        }

        if (!InventTable::find(_inventModelGroupItem.ItemId).hasInventTrans())
        {
            return true;
        }

        InventModelGroup inventModelGroup = _inventModelGroupItem.modelGroup();
        // if model group doesn't allow negative inventory we should not allow changing to a dimension group which creates such a situation
        if (inventModelGroup.NegativePhysical)
        {
            return true;
        }

        return this.checkNotNegativeOnHand(_inventModelGroupItem.ItemId, _inventModelGroupItem.ModelGroupId, InventDimGroupSetup::newItemId(_inventModelGroupItem.ItemId), true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNotNegativeOnHand</Name>
				<Source><![CDATA[
    public boolean checkNotNegativeOnHand(
        ItemId                      _itemId,
        InventModelGroupId          _modelGroupId,
        InventDimGroupSetup         _inventDimGroupSetup,
        boolean                     _stopOnFirstError = true)
    {
        InventDimParm           inventDimParmPhysicalTo;
        InventDim               inventDimCriteria;
        InventDimParm           inventDimParmCriteria;

        // if model group doesn't allow negative inventory we should not allow changing to a dimension group which creates such a situation
        inventDimParmCriteria.ItemIdFlag = NoYes::Yes;
        _inventDimGroupSetup.inventDimParmActivePhysicalInventory(inventDimParmPhysicalTo);
        inventDimParmPhysicalTo.ItemIdFlag = NoYes::Yes;

        if (WHSInventEnabled::exist(_itemId))
        {
            InventDimOnHand inventDimOnHandReserved = InventDimOnHand::newAvailPhysical(_itemId, inventDimCriteria, inventDimParmCriteria, InventDimOnHandLevel::DimParm, inventDimParmPhysicalTo);
            if (!this.checkNegativeQty(inventDimOnHandReserved, _itemId, _modelGroupId, _stopOnFirstError))
            {
                return false;
            }
        }
        InventDimOnHand inventDimOnHand = InventDimOnHand_Physical::newPhysical(_itemId, inventDimCriteria, inventDimParmCriteria, InventDimOnHandLevel::DimParm, inventDimParmPhysicalTo);

        return this.checkNegativeQty(inventDimOnHand, _itemId, _modelGroupId, _stopOnFirstError);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNegativeQty</Name>
				<Source><![CDATA[
    private boolean checkNegativeQty(InventDimOnHand _inventDimOnHand, ItemId _itemId, InventModelGroupId _modelGroupId, boolean _stopOnFirstError = true)
    {
        boolean anyError = false;
        InventDimOnHandIterator inventDimOnHandIterator = _inventDimOnHand.onHandIterator();
        while (inventDimOnHandIterator.more())
        {
            InventDimOnHandMember inventDimOnHandMember = inventDimOnHandIterator.value();
            InventQty qty = inventDimOnHandMember.parmInventQty();
            if (qty < 0)
            {
                InventDim inventDim = InventDim::find(inventDimOnHandMember.parmInventDimId());
                checkFailed(strFmt("@SYS313298", _modelGroupId, _itemId, qty, inventDim.preFix()));
                if (_stopOnFirstError)
                {
                    return false;
                }
                anyError = true;
            }
            inventDimOnHandIterator.next();
        }

        return !anyError;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costPricePcs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine the cost for one piece.
    /// </summary>
    /// <param name="_inventSum">
    /// The <c>inventSum</c> record to determine the cost for.
    /// </param>
    /// <param name="_inventModelGroup">
    /// The <c>inventModelGroup</c> record related to the item.
    /// </param>
    /// <param name="_onHandOnly">
    /// If true; return 0 if the on-hand quantity or values is less than or equal zero. The parameter is ignored if the inventory model doesn't use a estimated cost.
    /// </param>
    /// <param name="_priceDate">
    /// The date for the cost (only used for standard cost).
    /// </param>
    /// <returns>
    /// The cost for one piece.
    /// </returns>
    /// <remarks>
    /// The owner dimension is used when retrieving the correct cost price. In case the specified item is owner enabled the owner dimension must be specified.
    /// </remarks>
    public CostPrice costPricePcs(
        InventSum           _inventSum,
        InventModelGroup    _inventModelGroup,
        boolean             _onHandOnly = false,
        PriceDate           _priceDate  = maxDate())
    {
        CostAmount value = (_inventSum.PostedValue) + (_inventModelGroup.InclPhysicalValueInCost ? (_inventSum.PhysicalValue           ) : 0);
        InventQty qty = (_inventSum.PostedQty  ) + (_inventModelGroup.InclPhysicalValueInCost ? (_inventSum.Received - _inventSum.Deducted) : 0);

        if (_onHandOnly)
        {
            if (qty <= 0 || value <= 0)
            {
                return 0;
            }
        }
        else
        {
            if (qty <= 0 || value <= 0 || _inventModelGroup.StandardCost)
            {
                return InventTable::findCostPcsPrice(_inventSum.ItemId, _inventSum.InventDimId, _inventSum.inventDim(), _priceDate);
            }
        }

        return value / qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedPhysicalValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Get the estimated physical value for an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The <c>inventTrans</c> record for which to get the estimated physical value.
    /// </param>
    /// <param name="_inventOnhand">
    ///    The <c>InventOnHand</c> object.
    /// </param>
    /// <param name="_updateNow">
    ///    The <c>InventUpdate</c> object.
    /// </param>
    /// <returns>
    ///    The estimated physical value for the inventory transaction.
    /// </returns>
    public CostAmount estimatedPhysicalValue(
        InventTrans     _inventTrans,
        InventOnhand    _inventOnhand,
        InventUpdate    _updateNow)
    {
        return _updateNow.movement().estimatedPhysicalValuePublic(_inventTrans, _inventOnhand, _updateNow);
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeCostTransVariance</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Serves as the entry point for the standard cost processing that is called only one time for an
    ///    instance of an <c>inventMovement</c> class after all the <c>inventTrans</c> records have been
    ///    processed.
    /// </summary>
    /// <returns>
    ///    The <c>false</c> boolean.
    /// </returns>
    /// <param name="_inventMovement">
    ///    The <c>inventMovement</c> class that is currently processed.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The <c>ledgerVoucher</c> object for the postings must be created
    /// </param>
    /// <param name="_costTransState">
    ///    An <c>inventCostTransState</c> enumeration that indicates whether it is a financial or physical
    ///    update process.
    /// </param>
    /// <param name="_isReturn">
    ///    A Boolean flag that indicates if this method is called during a return process; optional.
    /// </param>
    /// <remarks>
    ///    This method was not implemented as abstract in order to keep the changes on the existing system as
    ///    small as possible. Therefore it contains only a return and no other logic.The logic is currently
    ///    only implemented in the <c>inventModelType_StdCost</c> child class.
    /// </remarks>
    public boolean finalizeCostTransVariance(
        InventMovement        _inventMovement,
        LedgerVoucher         _ledgerVoucher,
        InventCostTransState  _costTransState,
        boolean               _isReturn = false)
    {
        // <GEERU>
        return false;
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeCostTransVarianceSecCur_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Entry point for the standard cost processing that is called only once for a instance of a <c>inventMovement</c> class, after all
    /// the inventTrans records have been processed.
    /// </summary>
    /// <param name="_inventMovement">
    /// The <c>inventMovement</c> class, that is currently processed.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The ledgerVoucher object for that the postings needs to be created
    /// </param>
    /// <param name="_costTransState">
    /// The inventCostTransState Enum states, if it is a financial or physical update process.
    /// </param>
    /// <param name="_secondary">
    /// True, if primary model is also "Standard cost" and thus primary cost variances are already finalized.
    /// </param>
    /// <param name="_isReturn">
    /// A boolean flag, if this method is called during a retrun process.
    /// </param>
    /// <returns>
    /// Returns boolean flag of successful cost variance processing.
    /// </returns>
    /// <remarks>
    /// This method was not implemented as abstract, to keep the
    /// changes on the existing system as small as possible. Therefore it is just
    /// containing a return and no other logic.
    /// The logic is currently only implemented in the <c>inventModelType_StdCost</c> child class.
    /// </remarks>

    public boolean finalizeCostTransVarianceSecCur_RU(InventMovement        _inventMovement,      
                                                      LedgerVoucher         _ledgerVoucher,       
                                                      InventCostTransState  _costTransState,      
                                                      boolean               _secondary,           
                                                      boolean               _isReturn = false)    
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialIssueCostValue</Name>
				<Source><![CDATA[
    public CostAmount financialIssueCostValue(
        InventMovement   _inventMovement,
        InventTrans      _inventTrans,
        InventOnhand     _inventOnhand)
    {
        return _inventMovement.financialIssueCostValue(_inventTrans, _inventOnhand);
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialIssueCostValueSecCur_RU</Name>
				<Source><![CDATA[
    public CostAmount financialIssueCostValueSecCur_RU(
        InventMovement   _inventMovement,
        InventTrans      _inventTrans,
        InventOnhand     _inventOnhand)
    {
        return _inventMovement.financialIssueCostValueSecCur_RU(_inventTrans, _inventOnhand);
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialReceiptCostValue</Name>
				<Source><![CDATA[
    public CostAmount financialReceiptCostValue(
        InventMovement  _inventMovement,
        InventTrans     _inventTrans,
        int             _returnMode)
    {
        CostAmount      returnValue;
        InventQty       returnQty;

        if (_inventTrans.Qty <= 0)
        {
            throw error(strFmt("@SYS22828",funcName()));
        }

        if (_inventTrans.ReturnInventTransOrigin && (_returnMode || (_inventMovement.isReturned(_inventTrans.Qty))))
        {

            [returnQty,returnValue] = _inventMovement.calcReturnCostValue(_inventTrans);

            if (! returnQty)
            {
                throw error("@SYS53016");
            }

            return CurrencyExchangeHelper::amount(_inventTrans.Qty * returnValue / returnQty);
        }
        return _inventTrans.CostAmountPosted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialReceiptCostValueSecCur_RU</Name>
				<Source><![CDATA[
    public CostAmount financialReceiptCostValueSecCur_RU(
        InventMovement  _inventMovement,
        InventTrans     _inventTrans,
        int             _returnMode)
    {
        CostAmount  returnValue, returnValueSecCur;
        InventQty   returnQty;

        if (_inventTrans.Qty <= 0)
        {
            throw error(strFmt("@SYS22828", funcName()));
        }

        if (_inventTrans.ReturnInventTransOrigin && (_returnMode || (_inventMovement.isReturned(_inventTrans.Qty))))
        {
            [ returnQty, returnValue, returnValueSecCur ] = InventTransOrigin::calcReturnCostValue(_inventTrans.ReturnInventTransOrigin, _inventTrans.InventTransOrigin);

            if (!returnQty)
            {
                throw error("@SYS53016");
            }

            return CurrencyExchangeHelper::amount(_inventTrans.Qty * returnValueSecCur / returnQty, CompanyInfoHelper::secondaryCurrency_RU());
        }

        return _inventTrans.CostAmountSecCurPosted_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWarningItemDimCostPriceOff</Name>
				<Source><![CDATA[
    protected str getWarningItemDimCostPriceOff()
    {
        return "@SYS111320";
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCostTransVariance</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Serves as the entry point for the standard cost processing that is called only one time for an
    ///    instance of a <c>inventMovement</c> class.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The <c>inventMovement</c> class that is currently processed.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher that is currently processed.
    /// </param>
    /// <param name="_transDate">
    ///    The <c>transDate</c> that is used for this process.
    /// </param>
    /// <param name="_costTransState">
    ///    An <c>inventCostTransState</c> enumeration that indicates whether it is a financial or physical
    ///    update process.
    /// </param>
    /// <param name="_isReturn">
    ///    A Boolean flag that indicates whether this method is called during a return process; optional.
    /// </param>
    /// <remarks>
    ///    This method was not implemented as abstract in order to keep the changes on the existing system as
    ///    small as possible. Therefore it contains only a return and no other logic.The logic is currently
    ///    only implemented in the <c>inventModelType_StdCost</c> child class.
    /// </remarks>

    public void initCostTransVariance(
        InventMovement        _inventMovement,
        Voucher               _voucher,
        TransDate             _transDate,
        InventCostTransState  _costTransState,
        boolean               _isReturn = false)
    {
        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostMovement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the global instance of the <c>inventCostMovement</c> class.
    /// </summary>
    /// <returns>
    ///    The global instance of the <c>inventCostMovement</c> class.
    /// </returns>
    /// <remarks>
    ///    The instance must have been initialized earlier by calling the
    ///    <c>inventModelType_StdCost.initCostTransVariance</c> method.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    This method is not implemented as abstract in order to keep the changes to the existing system
    ///    small. Currently this method is overridden in the <c>inventModelType_stdCost</c> class.
    /// </exception>

    public InventCostMovement inventCostMovement()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostPriceMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the cost for an item.
    /// </summary>
    /// <param name="_inventTable">
    /// The <c>InventTable</c> record for the item.
    /// </param>
    /// <param name="_inventDimId">
    /// The <c>InventDimID</c> to retrieve the cost for.
    /// </param>
    /// <param name="_inventTableModuleInvent">
    /// The <c>InventTableModule</c> record to retrieve the cost for; optional. Set this parameter for better performance if available.
    /// </param>
    /// <param name="_transDate">
    /// The date to retrieve the cost for; optional. Default is the system date.
    /// </param>
    /// <param name="_newSiteId">
    /// The site to retrieve the cost for; optional. Default is blank.
    /// </param>
    /// <param name="_throwError">
    /// A Boolean value that indicates whether to throw an error if no cost is found; optional. Default is false.
    /// </param>
    /// <returns>
    /// An <c>InventPriceMap</c> buffer with the cost for the item.
    /// </returns>
    /// <remarks>
    /// The owner dimension is used when retrieving the correct item price. In case the specified item is owner enabled the owner dimension must be specified.
    /// </remarks>
    public InventPriceMap inventCostPriceMap(
        InventTable             _inventTable,
        InventDimId             _inventDimId,
        InventTableModule       _inventTableModuleInvent    = null, // set this parameter for better performance if avail
        TransDate               _transDate                  = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        InventSiteId            _newSiteId                  = '',
        boolean                 _throwError                 = false)
    {
        InventPriceMap inventPriceMap = InventItemPrice::findCurrent(_inventTable.ItemId, CostingVersionPriceType::Cost, _inventDimId, _transDate, _newSiteId);

        if (! inventPriceMap.RecId)
        {
            if (_inventTableModuleInvent.RecId)
            {
                inventPriceMap = _inventTableModuleInvent;
            }
            else
            {
                inventPriceMap = InventTableModule::find(_inventTable.ItemId, ModuleInventPurchSales::Invent);
            }
        }

        return inventPriceMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventModel</Name>
				<Source><![CDATA[
    public abstract InventModel inventModel()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventSumOpenTransact</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of a subclass of the <c>InventSumOpenTransact</c> class.
    /// </summary>
    /// <param name="_perDate">
    /// The date to calculate the open transactions.
    /// </param>
    /// <param name="_itemId">
    /// The identification of the item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// An <c>InventDim</c> record with the criteria.
    /// </param>
    /// <param name="_inventDimParm">
    /// An <c>InventDimParm</c> record with the paramters.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventSumOpenTransact</c> class.
    /// </returns>
    public InventSumOpenTransact inventSumOpenTransact(
        TransDate       _perDate,
        ItemId          _itemId,
        InventDim       _inventDimCriteria,
        InventDimParm   _inventDimParm
    )
    {
        return new InventSumOpenTransact(_perDate, _itemId, _inventDimCriteria, _inventDimParm);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventoryOwnerAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the inventory model allows inventory owner enabled items.
    /// </summary>
    /// <returns>true if the inventory model allows inventory owner enabled items; otherwise, false.</returns>
    public boolean isInventoryOwnerAllowed()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSettled</Name>
				<Source><![CDATA[
    public boolean isSettled()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>matchDateInPreCloseReturns</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the date is matched in the pre-closing of returns.
    /// </summary>
    /// <returns>
    ///    true if the date is matched in the pre-closing of returns; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    By default, the date is not considered when matching transactions.
    /// </remarks>
    public boolean matchDateInPreCloseReturns()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustAlwaysBeBookedPhysically</Name>
				<Source><![CDATA[
    public boolean mustAlwaysBeBookedPhysically()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeClosed</Name>
				<Source><![CDATA[
    public boolean mustBeClosed()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckInventOnHand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the inventory model needs to perform a on-hand validation when InventSum is updated.
    /// </summary>
    /// <param name="_inventSumDelta">
    /// The delta the inventory sum is updated with.
    /// </param>
    /// <returns>
    /// true if the inventory model needs to perform a on-hand validation when InventSum is updated; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The validation is implemented in the method checkInventOnHand
    /// </remarks>
    public boolean mustCheckInventOnHand(InventSumDelta _inventSumDelta)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSplitInventSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if <c>InventSettlement</c> must be split when <c>InventTrans</c> is split.
    /// </summary>
    /// <returns>
    /// true if <c>InventSettlement</c> must be split when <c>InventTrans</c> is split; otherwise, false.
    /// </returns>
    public boolean mustSplitInventSettlement()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateInventJournalCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the cost on the inventory journal must be updated to the current cost before the journal is posted.
    /// </summary>
    /// <param name="_inventJournalType">
    /// The inventory jounral type
    /// </param>
    /// <returns>
    /// true if the cost on the inventory journal must be updated to the current cost before the journal is posted; otherwise, false.
    /// </returns>
    public boolean mustUpdateInventJournalCost(InventJournalType _inventJournalType)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateInventTableCostPrice</Name>
				<Source><![CDATA[
    public boolean mustUpdateInventTableCostPrice()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventModelType_Orig</Name>
				<Source><![CDATA[
    protected InventModelType newInventModelType_Orig(InventModelGroupItem _inventModelGroupItem)
    {
        // <GEERU>
        boolean     countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        if (_inventModelGroupItem.RecId && _inventModelGroupItem.orig().ModelGroupId && _inventModelGroupItem.orig().ModelGroupId != _inventModelGroupItem.ModelGroupId)
        {
            // <GEERU>
            if (countryRegion_RU)
            {
                return inventTransCurrency == InventTransCurrency_RU::PrimaryCur ?
                       _inventModelGroupItem.orig().modelGroup().inventModelType()  :
                       _inventModelGroupItem.orig().modelGroup().inventModelTypeSecCur_RU();
            }
            else
            {
            // </GEERU>
                return _inventModelGroupItem.orig().modelGroup().inventModelType();
            // <GEERU>
            }
            // </GEERU>
        }

        return this;
    }

]]></Source>
			</Method>
			<Method>
				<Name>originalCostAmountPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the original physical cost amount.
    /// </summary>
    /// <param name="_inventTrans">
    ///     The <c>InventTrans</c> buffer.
    /// </param>
    /// <returns>
    ///     The original physical cost amount
    /// </returns>
    /// <remarks>
    ///     The method is used to calculate the original physical cost amount during the financial update.
    ///     The result is only correct between the call to preUpdateFinancial() and postUpdateFinancial().
    /// </remarks>
    public CostAmount originalCostAmountPhysical(InventTrans _inventTrans)
    {
        return _inventTrans.CostAmountPhysical - _inventTrans.costAmountPhysicalAdjustment();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventTransCurrency_RU</Name>
				<Source><![CDATA[
    final public InventTransCurrency_RU parmInventTransCurrency_RU(InventTransCurrency_RU _inventTransCurrency = inventTransCurrency)
    {
        inventTransCurrency = _inventTransCurrency;
        return inventTransCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUpdateFinancial</Name>
				<Source><![CDATA[
    public void postUpdateFinancial(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans,
        InventOnhand    _inventOnhand = null)
    {
        this.advancePhysicalAdjustmentToFinancialAdjustments(_inventMovement, _ledgerVoucher, _inventTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUpdateFinancialAdjustment</Name>
				<Source><![CDATA[
    public void postUpdateFinancialAdjustment(
        InventTrans     _inventTrans,
        Voucher         _voucher,
        TransDate       _postingDate,
        CostAmount      _costAmount)
    {
        // <GEERU>
        boolean     countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        // <GEERU>
        if ((countryRegion_RU
            && (inventTransCurrency == InventTransCurrency_RU::PrimaryCur))
            || ! countryRegion_RU)
        {
        // </GEERU>
            _inventTrans.inventTable().updateLastCostPrice(_inventTrans.costValue(), _inventTrans.Qty, _inventTrans.DateFinancial, _inventTrans.inventDim());
        // <GEERU>
        }
        else
        {
            _inventTrans.inventTable().updateLastCostPriceSecCur_RU(_inventTrans.costValueSecCur_RU(),
                                                                    _inventTrans.Qty,
                                                                    _inventTrans.DateFinancial,
                                                                    _inventTrans.inventDim());
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUpdatePhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the inventory transaction after it is updated physical.
    /// </summary>
    /// <param name="_inventMovement">
    /// The <c>InventMovement</c> object for the transaction.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> object for the transaction.
    /// </param>
    /// <param name="_inventTrans">
    /// The <c>InventTrans</c> buffer.
    /// </param>
    /// <param name="_financialInventOnhand">
    /// The <c>InventOnhand</c> object with the financial inventory on-hand.
    /// </param>
    /// <remarks>
    /// The method must be called after the <c>InventTrans</c> buffer is updated physical.
    /// </remarks>
    public void postUpdatePhysical(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans,
        InventOnhand    _financialInventOnhand = null)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUpdatePhysicalReturn</Name>
				<Source><![CDATA[
    public void postUpdatePhysicalReturn(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans,
        InventTrans     _returnInventTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>preUpdateFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Processes the inventory transaction before it is updated financial.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The <c>InventMovement</c> that belongs to the currently processed transaction.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The <c>LedgerVoucher</c> to which the postings should be added.
    /// </param>
    /// <param name="_inventTrans">
    ///    The inventory transaction that is currently processed.
    /// </param>
    /// <param name="_inventOnhand">
    /// The <c>InventOnhand</c> object that has the physical or financial inventory.
    /// </param>
    public void preUpdateFinancial(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans,
        InventOnhand    _inventOnhand = null)
    {
        this.reversePhysicalAdjustment(_inventMovement, _ledgerVoucher, _inventTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>preUpdateInventTable</Name>
				<Source><![CDATA[
    public void preUpdateInventTable(InventTable _inventTable)
    {
        InventItemDimCostPriceChangeHigh::newInventTable(_inventTable).createPrices();
    }

]]></Source>
			</Method>
			<Method>
				<Name>stdCostBased</Name>
				<Source><![CDATA[
    public boolean stdCostBased()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRevaluationAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update an inventory transaction with a reluation adjustment.
    /// </summary>
    /// <param name="_inventClosing">
    /// The <c>InventClosing</c> record related to the adjustment.
    /// </param>
    /// <param name="_inventTrans">
    /// The <c>inventTrans</c> record for to update with the adjustment.
    /// </param>
    /// <param name="_adjustment">
    /// The adjustment to update the
    /// </param>
    /// <exception cref="Exception::Error">
    /// A revaluation cannot be done using this method for the inventory model.
    /// </exception>
    public void updateRevaluationAdjustment(InventClosing _inventClosing, InventTrans _inventTrans, CostAmount _adjustment)
    {
        throw error(strFmt("@SYS22828",funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFieldInventModelGroupItem</Name>
				<Source><![CDATA[
    public boolean validateFieldInventModelGroupItem(InventModelGroupItem _inventModelGroupItem, FieldName _fieldName, int _arrayIndex = 1)
    {
        boolean         ret = true;

        switch (_fieldName)
        {
            case fieldStr(InventModelGroupItem, ModelGroupId):
                ret = ret && this.checkNewModelGroupId(_inventModelGroupItem);
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFieldInventTable</Name>
				<Source><![CDATA[
    public boolean validateFieldInventTable(InventTable _inventTable, FieldName _fieldName, int _arrayIndex = 1)
    {
        boolean         ret = true;
        str             warningMessage;

        switch (_fieldName)
        {
            case fieldStr(InventTable, ItemDimCostPrice):
                if (_inventTable.ItemDimCostPrice != _inventTable.orig().ItemDimCostPrice && FormDataUtil::isFormDataSource(_inventTable))
                {
                    if (_inventTable.ItemDimCostPrice)
                    {
                        warningMessage = "@SYS111319";
                    }
                    else
                    {
                        warningMessage = this.getWarningItemDimCostPriceOff();
                    }

                    ret = Box::okCancel(warningMessage, DialogButton::Cancel, "@SYS6998") == DialogButton::Ok;
                }
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInclPhysicalValueInCostDisabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that include physical value in cost is disabled.
    /// </summary>
    /// <param name="_inventModelGroup">
    /// The <c>InventModelGroup</c> buffer to validate.
    /// </param>
    /// <returns>
    /// true if include physical value in cost is disabled; otherwise, false.
    /// </returns>
    protected boolean validateInclPhysicalValueInCostDisabled(InventModelGroup  _inventModelGroup)
    {
        if (_inventModelGroup.InclPhysicalValueInCost)
        {
            return checkFailed(strFmt("@SYS104453",enum2str(_inventModelGroup.InventModel)));
        }
        else
        {
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateItemTypeIsNotService</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the item related to the inventory model group is not a service.
    /// </summary>
    /// <param name="_inventModelGroupItem">
    /// The <c>InventModelGroup</c> buffer to validate.
    /// </param>
    /// <returns>
    /// true if the item is not a service; otherwise, false.
    /// </returns>
    protected boolean validateItemTypeIsNotService(InventModelGroupItem _inventModelGroupItem)
    {
        InventTable         inventTable = InventTable::find(_inventModelGroupItem.ItemId);

        if (inventTable.ItemType == ItemType::Service)
        {
            return checkFailed(strFmt("@FPK270056", this.inventModel()));
        }
        else
        {
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateModelGroupHasNoService</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if no items of type Service are associated with the inventory model group.
    /// </summary>
    /// <param name="_inventModelGroup">
    /// The <c>InventModelGroup</c> buffer to validate.
    /// </param>
    /// <returns>
    /// true if no items of type Service are associated with the inventory model group; otherwise, false.
    /// </returns>
    protected boolean validateModelGroupHasNoService(InventModelGroup _inventModelGroup)
    {
        InventTable             inventTable;
        InventModelGroupItem    inventModelGroupItem;

        select firstonly RecId from inventTable
            where inventTable.ItemType == ItemType::Service
        exists join inventModelGroupItem
            where inventModelGroupItem.ModelGroupId         == _inventModelGroup.ModelGroupId
               && inventModelGroupItem.ModelGroupDataAreaId == _inventModelGroup.DataAreaId
               && inventModelGroupItem.ItemId               == inventTable.ItemId;

        if (inventTable.RecId)
        {
            return checkFailed(strFmt("@FPK270056", this.inventModel()));
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePostOnhandFinancialEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that post financial inventory is enabled for the inventory model group.
    /// </summary>
    /// <param name="_inventModelGroup">
    /// The <c>InventModelGroup</c> buffer to validate.
    /// </param>
    /// <returns>
    /// true if post financial inventory is enabled; otherwise, false.
    /// </returns>
    protected boolean validatePostOnhandFinancialEnabled(InventModelGroup  _inventModelGroup)
    {
        if (!_inventModelGroup.PostOnhandFinancial)
        {
            return checkFailed(strFmt("@FPK270057", this.inventModel()));
        }
        else
        {
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePostOnhandPhysicalEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that post physical inventory is enabled for the inventory model group.
    /// </summary>
    /// <param name="_inventModelGroup">
    /// The <c>InventModelGroup</c> buffer to validate.
    /// </param>
    /// <returns>
    /// true if post physical inventory is enabled; otherwise, false.
    /// </returns>
    protected boolean validatePostOnhandPhysicalEnabled(InventModelGroup  _inventModelGroup)
    {
        if (!_inventModelGroup.PostOnhandPhysical)
        {
            return checkFailed(strFmt("@FPK270058", this.inventModel()));
        }
        else
        {
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateStandardCostDisabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that standard cost parameter is disabled.
    /// </summary>
    /// <param name="_inventModelGroup">
    /// The <c>InventModelGroup</c> buffer to validate.
    /// </param>
    /// <returns>
    /// true if the standard cost parameter  is disabled; otherwise, false.
    /// </returns>
    protected boolean validateStandardCostDisabled(InventModelGroup  _inventModelGroup)
    {
        if (_inventModelGroup.StandardCost)
        {
            return checkFailed(strFmt("@SYS104454",enum2str(_inventModelGroup.InventModel)));
        }
        else
        {
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWriteInventItemPriceSim</Name>
				<Source><![CDATA[
    public boolean validateWriteInventItemPriceSim(InventItemPriceSim _inventItemPriceSim)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWriteInventModelGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the inventory model group is valid.
    /// </summary>
    /// <param name="_inventModelGroup">
    /// The <c>InventModelGroup</c> buffer.
    /// </param>
    /// <returns>
    /// true if the inventory model group is valid; otherwise, false.
    /// </returns>
    public boolean validateWriteInventModelGroup(InventModelGroup  _inventModelGroup)
    {
        InventTable             inventTable;
        InventTrans             inventTrans;

        InventModelType         inventModelTypeOrig;
        InventModelGroupItem    inventModelGroupItem;

        // <GEERU>
        InventModel         inventModel, inventModelOrig;
        boolean             countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        // <GEERU>
        if (inventTransCurrency == InventTransCurrency_RU::PrimaryCur)
        {
            inventModel     = _inventModelGroup.InventModel;
            inventModelOrig = _inventModelGroup.orig().InventModel;
        }
        else
        {
            inventModel     = _inventModelGroup.InventModelSecCur_RU;
            inventModelOrig = _inventModelGroup.orig().InventModelSecCur_RU;
        }
        // </GEERU>

        // <GEERU>
        if (_inventModelGroup.orig().RecId && inventModel != inventModelOrig) //InventModel has changed
        // </GEERU>
        {
            // <GEERU>
            if (countryRegion_RU)
            {
                inventModelTypeOrig = InventModelTypeFactory::construct().getInventModelTypeFromInventModel(inventModelOrig);
                if (inventModelTypeOrig)
                {
                    inventModelTypeOrig.parmInventTransCurrency_RU(inventTransCurrency);
                }
            }
            else
            {
            // </GEERU>
                inventModelTypeOrig = _inventModelGroup.orig().inventModelType();
            // <GEERU>
            }
            // </GEERU>

            if (inventModelTypeOrig.isSettled() != this.isSettled())
            {
                if (_inventModelGroup.hasInventTrans())
                {
                    // <GEERU>
                    return checkFailed(strFmt("@SYS128861", inventModelOrig, inventModel));
                    // </GEERU>
                }
            }
        }

        // <GCN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCN]))
        {
            //when change model to MAC or backward
            if (_inventModelGroup.orig().InventModel == InventModel::MonthlyAverageCost
                || _inventModelGroup.InventModel == InventModel::MonthlyAverageCost)
            {
                select firstonly RecId, ItemId, DataAreaId from inventTable
                    exists join RecId from inventModelGroupItem
                        where inventModelGroupItem.ItemId               == inventTable.ItemId
                           && inventModelGroupItem.ItemDataAreaId       == inventTable.DataAreaId
                           && inventModelGroupItem.ModelGroupId         == _inventModelGroup.ModelGroupId
                           && inventModelGroupItem.ModelGroupDataAreaId == _inventModelGroup.DataAreaId
                    exists join RecId from inventTrans
                        where inventTrans.ItemId        == inventTable.ItemId
                            && inventTrans.ValueOpen    == InventTransOpen::Yes;
                if (inventTable.RecId != 0)
                {
                    if (_inventModelGroup.InventModel == InventModel::MonthlyAverageCost)
                    {
                        return checkFailed(strFmt("@SYS128861", _inventModelGroup.orig().InventModel, "@GLS63357"));
                    }
                    else
                    {
                        return checkFailed(strFmt("@SYS128861", "@GLS63357", _inventModelGroup.InventModel ));
                    }
                }
            }
        }
        // </GCN>

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWriteInventModelGroupItem</Name>
				<Source><![CDATA[
    public boolean validateWriteInventModelGroupItem(InventModelGroupItem _inventModelGroupItem, boolean _inclConvCheck = true)
    {
        InventTrans     inventTrans;

        if (_inventModelGroupItem.RecId && this.isSettled() != this.newInventModelType_Orig(_inventModelGroupItem).isSettled())
        {
            select firstonly RecId from inventTrans
                where  inventTrans.ItemId       == _inventModelGroupItem.ItemId
                    && inventTrans.DatePhysical != dateNull();

            if (inventTrans.RecId)
            {
                return checkFailed(strFmt("@SYS105788",enum2str(this.newInventModelType_Orig(_inventModelGroupItem).inventModel())));
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWriteInventTable</Name>
				<Source><![CDATA[
    public boolean validateWriteInventTable(InventTable _inventTable)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryValueIsSettled</Name>
				<Source><![CDATA[
    public static str queryValueIsSettled()
    {
        Counter                 i;
        str                     queryValue;
        InventModelTypeFactory  inventModelTypeFactory = InventModelTypeFactory::construct();

        DictEnum dictEnum = new DictEnum(enumNum(InventModel));
        for (i=0;i<dictEnum.values();i++)
        {
            InventModelType inventModelType = inventModelTypeFactory.getInventModelTypeFromInventModel(i);
            if (inventModelType.isSettled())
            {
                queryValue = queryRangeConcat(queryValue,inventModelType.inventModel());
            }
        }
        return queryValue ? queryValue : SysQuery::valueEmptyString();
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryValueMustBeClosed</Name>
				<Source><![CDATA[
    public static str queryValueMustBeClosed()
    {
        Counter                 i;
        str                     queryValue;
        InventModelTypeFactory  inventModelTypeFactory = InventModelTypeFactory::construct();

        DictEnum dictEnum = new DictEnum(enumNum(InventModel));
        for (i=0;i<dictEnum.values();i++)
        {
            InventModelType inventModelType = inventModelTypeFactory.getInventModelTypeFromInventModel(i);
            if (inventModelType.mustBeClosed())
            {
                queryValue = queryRangeConcat(queryValue,inventModelType.inventModel());
            }
        }
        return queryValue ? queryValue : SysQuery::valueEmptyString();
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryValueStdCostBased</Name>
				<Source><![CDATA[
    public static str queryValueStdCostBased()
    {
        Counter                 i;
        str                     queryValue;
        InventModelTypeFactory  inventModelTypeFactory = InventModelTypeFactory::construct();

        DictEnum dictEnum = new DictEnum(enumNum(InventModel));
        for (i=0;i<dictEnum.values();i++)
        {
            InventModelType inventModelType = inventModelTypeFactory.getInventModelTypeFromInventModel(i);
            if (inventModelType.stdCostBased())
            {
                queryValue = queryRangeConcat(queryValue,inventModelType.inventModel());
            }
        }
        return queryValue ? queryValue : SysQuery::valueEmptyString();
    }

]]></Source>
			</Method>
			<Method>
				<Name>physicalSettlementList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns physical inventory settlement adjustments related to an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The inventory transaction.
    /// </param>
    /// <returns>
    ///    A record sorted list that has inventory settlement records.
    /// </returns>
    protected RecordSortedList physicalSettlementList(InventTrans _inventTrans)
    {
        if (!physicalSettlementList)
        {
            physicalSettlementList = new RecordSortedList(tableNum(InventSettlement));
            physicalSettlementList.sortOrder(fieldNum(InventSettlement, RecId));

            InventSettlement    inventSettlement;

            while select inventSettlement
            where inventSettlement.TransRecId           == _inventTrans.RecId
               && inventSettlement.Cancelled            == NoYes::No
               && inventSettlement.SettleModel          == InventSettleModel::PhysicalValue
               && inventSettlement.OperationsPosting    == LedgerPostingType::PurchStockVariation
               // <GEERU>
               && inventSettlement.InventTransCurrency_RU == inventTransCurrency
               // </GEERU>
            {
                physicalSettlementList.ins(inventSettlement);
            }
        }
        return physicalSettlementList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reversePhysicalSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reverses a physical value adjustment.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The <c>InventMovement</c> that belongs to the currently processed transaction.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The <c>LedgerVoucher</c> to which the postings should be added.
    /// </param>
    /// <param name="_inventTrans">
    ///    The inventory transaction that is currently processed.
    /// </param>
    /// <param name="_inventSettlement">
    ///    The <c>InventSettlement</c> that should be reversed.
    /// </param>
    protected void reversePhysicalSettlement(
        InventMovement   _inventMovement,
        LedgerVoucher    _ledgerVoucher,
        InventTrans      _inventTrans,
        InventSettlement _inventSettlement
        )
    {
        InventSettlement reverseSettlement = InventSettlement::reserveAdjustment(_ledgerVoucher, _inventSettlement);
        reverseSettlement.initFromInventTrans(_inventTrans, _inventSettlement.DefaultDimension);

        if (reverseSettlement.InventTransCurrency_RU == InventTransCurrency_RU::PrimaryCur)
        {
            _inventTrans.CostAmountPhysical += reverseSettlement.CostAmountAdjustment;
        }
        else
        {
            _inventTrans.CostAmountSecCurPhysical_RU += reverseSettlement.CostAmountAdjustment;
        }

        if (_inventSettlement.Posted == NoYes::Yes)
        {
            reverseSettlement.post(_ledgerVoucher);
        }

        reverseSettlement.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>advancePhysicalAdjustmentToFinancialAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Advances a physical adjustment to a financial adjustment.
    /// </summary>
    /// <param name="_inventMovement">The <c>InventMovement</c> that belongs to the currently processed transaction.</param>
    /// <param name="_ledgerVoucher">The <c>LedgerVoucher</c> to which the postings should be added.</param>
    /// <param name="_inventTrans">The inventory transaction that is currently processed.</param>
    /// <param name="_physicalSettlement">The physical adjustment.</param>
    protected internal void advancePhysicalAdjustmentToFinancialAdjustment(
        InventMovement      _inventMovement,
        LedgerVoucher       _ledgerVoucher,
        InventTrans         _inventTrans,
        InventSettlement    _physicalSettlement)
    {
        InventSettlement financialSettlement = InventSettlement::advancePhysicalAdjustmentToFinancialAdjustment(_inventMovement, _ledgerVoucher, _physicalSettlement);

        if (financialSettlement.InventTransCurrency_RU == InventTransCurrency_RU::PrimaryCur)
        {
            _inventTrans.CostAmountAdjustment += financialSettlement.CostAmountAdjustment;
        }
        else
        {
            _inventTrans.CostAmountSecCurAdjustment_RU += financialSettlement.CostAmountAdjustment;
        }

        if (_inventMovement.mustBeBookedFinancially())
        {
            financialSettlement.post(_ledgerVoucher);
        }
        financialSettlement.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reversePhysicalAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reverses physical adjustments with offset purchase stock variation.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The <c>InventMovement</c> that belongs to the currently processed transaction.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The <c>LedgerVoucher</c> to which the postings should be added.
    /// </param>
    /// <param name="_inventTrans">
    ///    The inventory transaction that is currently processed.
    /// </param>
    protected internal void reversePhysicalAdjustment(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans)
    {
        if (_inventMovement is InventMov_Purch)
        {
            InventSettlement    settlement;

            ttsbegin;
            boolean more = this.physicalSettlementList(_inventTrans).first(settlement);
            while (more)
            {
                if (settlement.OperationsPosting == LedgerPostingType::PurchStockVariation)
                {
                    this.reversePhysicalSettlement(_inventMovement,_ledgerVoucher,_inventTrans, settlement);
                }
                more = this.physicalSettlementList(_inventTrans).next(settlement);
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>advancePhysicalAdjustmentToFinancialAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Advances physical adjustments with offset purchase stock variation to financial adjustments.
    /// </summary>
    /// <param name="_inventMovement">
    ///    The <c>InventMovement</c> that belongs to the currently processed transaction.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The <c>LedgerVoucher</c> to which the postings should be added.
    /// </param>
    /// <param name="_inventTrans">
    ///    The inventory transaction that is currently processed.
    /// </param>
    protected internal void advancePhysicalAdjustmentToFinancialAdjustments(
        InventMovement  _inventMovement,
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans)
    {
        if (_inventMovement is InventMov_Purch)
        {
            InventSettlement    physicalSettlement;

            ttsbegin;
            boolean more = this.physicalSettlementList(_inventTrans).first(physicalSettlement);
            while (more)
            {
                if (physicalSettlement.OperationsPosting == LedgerPostingType::PurchStockVariation)
                {
                    this.advancePhysicalAdjustmentToFinancialAdjustment(_inventMovement, _ledgerVoucher, _inventTrans, physicalSettlement);
                }

                more = this.physicalSettlementList(_inventTrans).next(physicalSettlement);
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>