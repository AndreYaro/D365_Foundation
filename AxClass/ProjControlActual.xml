<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjControlActual</Name>
	<SourceCode>
		<Declaration><![CDATA[
class ProjControlActual
{
    TmpProjControlActual        tmpProjControlActual;
    TmpProjControlActualCost    tmpProjControlActualCost;
    boolean                     updateWIPPeriod;

    boolean                     reversal;
    boolean                     useFromDate;
    boolean                     includeActual;
    boolean                     includeCommitted;
    boolean                     includeCurrentPeriod;
    boolean                     includeAfterPeriodEnd;
    boolean                     isContractLineUsed;

    ProjWipId                   projWipId;
    ProjPeriodFrom              projPeriodFrom;
    ProjPeriodTo                projPeriodTo;
    ProjControlId               projControlId;
    ProjControlVersion          projControlVersion;

    boolean                     getEliminated;
    ProjParameters              projParameters;

    ProjBeginningBalance        beginningBalance;

    [SysObsolete("This variable is obsolete. Use projContractCurrencyForRevRecParmEnabled instead.", false, 10\6\2024)]
    boolean contractCurrencyRevRecCalculationFeature = ProjContractCurrencyForRevRecCalculationFeature::isEnabled();

    private boolean projContractCurrencyForRevRecParmEnabled = ProjParameters::find().EnableContractCurrencyForRevRec;
    boolean contractLineBasedRevRecFeature = ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled();

    private ProjRevRecInstrumentationLogger logger;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>factor</Name>
				<Source><![CDATA[
    private Factor factor()
    {
        return this.reversal() ? -1 : 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCostTmp</Name>
				<Source><![CDATA[
    private void insertCostTmp()
    {
        ProjTable           projTable;
        ProjCostTrans       projCostTrans;
        ProjCostTransCost   projCostTransCost;
        ProjWIPTable        projWIPTable;
        ProjControlCategory projControlCategory;
        ProjRevRecContractLine projRevRecContractLine;

        ProjCostType                transactionType = ProjCostType::Cost;
        ProjControlActualCostType   estimateType    = ProjControlActualCostType::Actual;
        ProjControlActualRange      periodRange     = ProjControlActualRange::CurrentPeriod;
        ProjId wipProjid = this.parmWIPProjId();

        // Insert bulk into tmpProjControlActual
        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            insert_recordset tmpProjControlActual
            (ProjId, ActivityNumber, ContractLineNum, CategoryId, Qty, TransId, Txt, LinePropertyId,
             Voucher, Resource, ResourceCategory, TransDate, CostType, DefaultDimension,
             Type, Range, Origin)
        select wipProjid, ActivityNumber, PSAContractLineNum, CategoryId, Qty, TransId, Txt, LinePropertyId,
            VoucherJournal, Resource, ResourceCategory, TransDate, transactionType,
            DefaultDimension, estimateType, periodRange, TransactionOrigin
        from projCostTrans
            where projCostTrans.TransactionOrigin != ProjOrigin::EstimateAccruedLoss
            exists join projCostTransCost
                where projCostTransCost.TransId == projCostTrans.TransId
                &&   (projCostTransCost.TransStatus   == ProjTransStatus::Estimated ||
                     (getEliminated
                &&   (projCostTransCost.TransStatus   == ProjTransStatus::Eliminated)))
                &&   ((!this.parmUseFromDate() && projCostTransCost.wipPeriod != dateNull() && projCostTransCost.wipPeriod <= this.parmProjPeriodTo())
                ||   (this.parmUseFromDate() && projCostTransCost.wipPeriod != dateNull() && projCostTransCost.wipPeriod == this.parmProjPeriodTo()))
            exists join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == wipProjid
            && projRevRecContractLine.ContractLineNum == projCostTrans.PSAContractLineNum
             exists join projWIPTable
                where projWIPTable.ProjId == wipProjid
             exists join projControlCategory
                where projControlCategory.ControlId == projWIPTable.ControlId
                &&    projControlCategory.CategoryId == projCostTrans.CategoryId;        
        }
        else
        {
            insert_recordset tmpProjControlActual
            (ProjId, ActivityNumber, CategoryId, Qty, TransId, Txt, LinePropertyId,
             Voucher, Resource, ResourceCategory, TransDate, CostType, DefaultDimension,
             Type, Range, Origin)
        select ProjId, ActivityNumber, CategoryId, Qty, TransId, Txt, LinePropertyId,
            VoucherJournal, Resource, ResourceCategory, TransDate, transactionType,
            DefaultDimension, estimateType, periodRange, TransactionOrigin
        from projCostTrans
            where projCostTrans.TransactionOrigin != ProjOrigin::EstimateAccruedLoss
            exists join projCostTransCost
                where projCostTransCost.TransId == projCostTrans.TransId
                &&   (projCostTransCost.TransStatus   == ProjTransStatus::Estimated ||
                     (getEliminated
                &&   (projCostTransCost.TransStatus   == ProjTransStatus::Eliminated)))
                &&   ((!this.parmUseFromDate() && projCostTransCost.wipPeriod != dateNull() && projCostTransCost.wipPeriod <= this.parmProjPeriodTo())
                ||   (this.parmUseFromDate() && projCostTransCost.wipPeriod != dateNull() && projCostTransCost.wipPeriod == this.parmProjPeriodTo()))
             exists join projTable
                where projTable.ProjId     == projCostTrans.ProjId
                &&    projTable.wipProject == this.parmWIPProjId()
             exists join projWIPTable
                where projWIPTable.ProjId == projTable.WIPProject
             exists join projControlCategory
                where projControlCategory.ControlId == projWIPTable.ControlId
                &&    projControlCategory.CategoryId == projCostTrans.CategoryId;        
        }
 
        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select CostAmountLedger, CostPriceCurrency, LedgerStatusCost, wipPeriod, LedgerTransdate
            from projCostTransCost
            where    (projCostTransCost.TransStatus == ProjTransStatus::Estimated ||
                        (getEliminated
                &&   (projCostTransCost.TransStatus == ProjTransStatus::Eliminated)))
                &&   ((!this.parmUseFromDate() && projCostTransCost.wipPeriod != dateNull() && projCostTransCost.wipPeriod <= this.parmProjPeriodTo())
                ||   (this.parmUseFromDate() && projCostTransCost.wipPeriod != dateNull() && projCostTransCost.wipPeriod == this.parmProjPeriodTo()))
            join RecId, ProjId from tmpProjControlActual
                where tmpProjControlActual.TransId == projCostTransCost.TransId
                    && tmpProjControlActual.CostType == transactionType
                    && tmpProjControlActual.Origin != ProjOrigin::BeginningBalance
            join projCostTrans
                    where projCostTrans.TransId == projCostTransCost.TransId
            exists join projRevRecContractLine
                    where projRevRecContractLine.RevenueRecognitionId == wipProjid
                && projRevRecContractLine.ContractLineNum == tmpProjControlActual.ContractLineNum
            exists join projWIPTable
                where projWIPTable.ProjId == wipProjid
            {
                tmpProjControlActualCost.clear();
                tmpProjControlActualCost.CostPrice = projCostTransCost.CostPriceCurrency;
                tmpProjControlActualCost.LedgerStatusCost = projCostTransCost.LedgerStatusCost;
                tmpProjControlActualCost.WIPPeriod = projCostTransCost.WIPPeriod;
                tmpProjControlActualCost.RefRecID = tmpProjControlActual.RecID;

                if (projContractCurrencyForRevRecParmEnabled && PSAContractLineItems::find(tmpProjControlActual.ContractLineNum).BillingMethod == ProjContractBillingMethod::FixedPrice)
                {
                    CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                        Ledger::primaryLedger(CompanyInfo::findDataArea(projCostTransCost.company()).RecId),
                        projCostTransCost.LedgerTransdate);
                    tmpProjControlActualCost.costAmount = currencyExchangeHelper.calculateAccountingToTransaction(projTable.contractCurrCode(), projCostTransCost.CostAmountLedger, true);
                }
                else
                {
                    tmpProjControlActualCost.costAmount = projCostTransCost.CostAmountLedger;
                }

                tmpProjControlActualCost.insert();
            }
        }
        else if (projContractCurrencyForRevRecParmEnabled)
        {
            while select CostAmountLedger, CostPriceCurrency, LedgerStatusCost, wipPeriod, LedgerTransdate
            from projCostTransCost
            where    (projCostTransCost.TransStatus == ProjTransStatus::Estimated ||
                        (getEliminated
                &&   (projCostTransCost.TransStatus == ProjTransStatus::Eliminated)))
                &&   ((!this.parmUseFromDate() && projCostTransCost.wipPeriod != dateNull() && projCostTransCost.wipPeriod <= this.parmProjPeriodTo())
                ||   (this.parmUseFromDate() && projCostTransCost.wipPeriod != dateNull() && projCostTransCost.wipPeriod == this.parmProjPeriodTo()))
            join RecId, ProjId from tmpProjControlActual
                where tmpProjControlActual.TransId == projCostTransCost.TransId
                    && tmpProjControlActual.CostType == transactionType
                    && tmpProjControlActual.Origin != ProjOrigin::BeginningBalance
            join projTable
                where projTable.ProjId == tmpProjControlActual.ProjId
                    && projTable.wipProject == this.parmWIPProjId()
            exists join projWIPTable
                where projWIPTable.ProjId == projTable.WIPProject
            {
                tmpProjControlActualCost.clear();
                tmpProjControlActualCost.CostPrice = projCostTransCost.CostPriceCurrency;
                tmpProjControlActualCost.LedgerStatusCost = projCostTransCost.LedgerStatusCost;
                tmpProjControlActualCost.WIPPeriod = projCostTransCost.WIPPeriod;
                tmpProjControlActualCost.RefRecID = tmpProjControlActual.RecID;

                if (ProjMultipleContractLinesForProjectFeatureHelper::isFixedPriceBillingMethod(projTable, ProjTransType::Cost))
                {
                    CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                        Ledger::primaryLedger(CompanyInfo::findDataArea(projCostTransCost.company()).RecId),
                        projCostTransCost.LedgerTransdate);
                    tmpProjControlActualCost.costAmount = currencyExchangeHelper.calculateAccountingToTransaction(projTable.contractCurrCode(), projCostTransCost.CostAmountLedger, true);
                }
                else
                {
                    tmpProjControlActualCost.costAmount = projCostTransCost.CostAmountLedger;
                }

                tmpProjControlActualCost.insert();
            }
        }
        else
        {
            // Insert bulk into tmpProjControlActualCost where tmpProjControlActual has its origin other than Beginning Balance Journal.
            insert_recordset tmpProjControlActualCost
            (CostAmount, CostPrice, LedgerStatusCost, wipperiod, RefRecId)
            select CostAmountLedger, CostPriceCurrency, LedgerStatusCost, wipPeriod
            from projCostTransCost
            where    (projCostTransCost.TransStatus   == ProjTransStatus::Estimated ||
                     (getEliminated
                &&   (projCostTransCost.TransStatus   == ProjTransStatus::Eliminated)))
                &&   ((!this.parmUseFromDate() && projCostTransCost.wipPeriod != dateNull() && projCostTransCost.wipPeriod <= this.parmProjPeriodTo())
                ||   (this.parmUseFromDate() && projCostTransCost.wipPeriod != dateNull() && projCostTransCost.wipPeriod == this.parmProjPeriodTo()))
            join firstonly RecId from tmpProjControlActual
                where tmpProjControlActual.TransId  == projCostTransCost.TransId
                   && tmpProjControlActual.CostType == transactionType
                   && tmpProjControlActual.Origin != ProjOrigin::BeginningBalance;
        }


        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select TotalCostAmountCur from projCostTrans
                where projCostTrans.TransactionOrigin == ProjOrigin::BeginningBalance
            join CostPriceCurrency, LedgerStatusCost, WIPPeriod, LedgerTransdate from projCostTransCost
                where   projCostTransCost.TransId ==  projCostTrans.TransId
                    &&  (projCostTransCost.TransStatus == ProjTransStatus::Estimated
                    ||   (getEliminated
                    &&   (projCostTransCost.TransStatus == ProjTransStatus::Eliminated)))
                    &&   ((!this.parmUseFromDate() && projCostTransCost.wipPeriod != dateNull() && projCostTransCost.wipPeriod <= this.parmProjPeriodTo())
                    ||   (this.parmUseFromDate() && projCostTransCost.wipPeriod != dateNull() && projCostTransCost.wipPeriod == this.parmProjPeriodTo()))
            join firstOnly RecId, ProjId from tmpProjControlActual
                where  tmpProjControlActual.TransId == projCostTransCost.TransId
                    && tmpProjControlActual.CostType == transactionType
                    && tmpProjControlActual.Origin == ProjOrigin::BeginningBalance
            join projCostTrans
                    where projCostTrans.TransId == projCostTransCost.TransId
            exists join projRevRecContractLine
                where projRevRecContractLine.ContractLineNum == tmpProjControlActual.ContractLineNum
                && projRevRecContractLine.RevenueRecognitionId == projWipId
            exists join projWIPTable
                where projWIPTable.ProjId == projWipId
            {
                tmpProjControlActualCost.clear();
                tmpProjControlActualCost.CostPrice = projCostTransCost.CostPriceCurrency;
                tmpProjControlActualCost.LedgerStatusCost = projCostTransCost.LedgerStatusCost;
                tmpProjControlActualCost.WIPPeriod = projCostTransCost.WIPPeriod;
                tmpProjControlActualCost.RefRecID = tmpProjControlActual.RecID;

                if (projContractCurrencyForRevRecParmEnabled && PSAContractLineItems::find(tmpProjControlActual.ContractLineNum).BillingMethod == ProjContractBillingMethod::FixedPrice)
                {
                    CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                        Ledger::primaryLedger(CompanyInfo::findDataArea(projCostTransCost.company()).RecId),
                        projCostTransCost.LedgerTransdate);
                    tmpProjControlActualCost.costAmount = currencyExchangeHelper.calculateAccountingToTransaction(projTable.contractCurrCode(), projCostTrans.TotalCostAmountCur, true);
                }
                else
                {
                    tmpProjControlActualCost.costAmount = projCostTrans.TotalCostAmountCur;
                }

                tmpProjControlActualCost.insert();
            }
        
        }
        else if (projContractCurrencyForRevRecParmEnabled)
        {
            while select TotalCostAmountCur from projCostTrans
                where projCostTrans.TransactionOrigin == ProjOrigin::BeginningBalance
            join CostPriceCurrency, LedgerStatusCost, WIPPeriod, LedgerTransdate from projCostTransCost
                where   projCostTransCost.TransId ==  projCostTrans.TransId
                    &&  (projCostTransCost.TransStatus == ProjTransStatus::Estimated
                    ||   (getEliminated
                    &&   (projCostTransCost.TransStatus == ProjTransStatus::Eliminated)))
                    &&   ((!this.parmUseFromDate() && projCostTransCost.wipPeriod != dateNull() && projCostTransCost.wipPeriod <= this.parmProjPeriodTo())
                    ||   (this.parmUseFromDate() && projCostTransCost.wipPeriod != dateNull() && projCostTransCost.wipPeriod == this.parmProjPeriodTo()))
            join firstOnly RecId, ProjId from tmpProjControlActual
                where  tmpProjControlActual.TransId == projCostTransCost.TransId
                    && tmpProjControlActual.CostType == transactionType
                    && tmpProjControlActual.Origin == ProjOrigin::BeginningBalance
            join projTable
                where projTable.ProjId == tmpProjControlActual.ProjId
                &&    projTable.wipProject == projWipId
            exists join projWIPTable
                where projWIPTable.ProjId == projTable.WIPProject
            {
                tmpProjControlActualCost.clear();
                tmpProjControlActualCost.CostPrice = projCostTransCost.CostPriceCurrency;
                tmpProjControlActualCost.LedgerStatusCost = projCostTransCost.LedgerStatusCost;
                tmpProjControlActualCost.WIPPeriod = projCostTransCost.WIPPeriod;
                tmpProjControlActualCost.RefRecID = tmpProjControlActual.RecID;

                if (ProjMultipleContractLinesForProjectFeatureHelper::isFixedPriceBillingMethod(projTable, ProjTransType::Cost))
                {
                    CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                        Ledger::primaryLedger(CompanyInfo::findDataArea(projCostTransCost.company()).RecId),
                        projCostTransCost.LedgerTransdate);
                        tmpProjControlActualCost.costAmount = currencyExchangeHelper.calculateAccountingToTransaction(projTable.contractCurrCode(), projCostTrans.TotalCostAmountCur, true);
                }
                else
                {
                    tmpProjControlActualCost.costAmount = projCostTrans.TotalCostAmountCur;
                }

                tmpProjControlActualCost.insert();
            }
        }
        else
        {
            // Insert bulk into tmpProjControlActualCost where tmpProjControlActual has its origin from a Beginning Balance Journal
            // Begining balance journal is not posted to Ledger, so we have to take the amount from TotalCostAmount column of ProjCostTrans instead of individual cost lines.
            insert_recordset tmpProjControlActualCost(CostAmount, CostPrice, LedgerStatusCost,
                                              wipperiod, RefRecId)
        select TotalCostAmountCur from projCostTrans
                where projCostTrans.TransactionOrigin == ProjOrigin::BeginningBalance
            join CostPriceCurrency, LedgerStatusCost, WIPPeriod from projCostTransCost
                where   projCostTransCost.TransId ==  projCostTrans.TransId
                    &&  (projCostTransCost.TransStatus   == ProjTransStatus::Estimated
                    ||   (getEliminated
                    &&   (projCostTransCost.TransStatus   == ProjTransStatus::Eliminated)))
                    &&   ((!this.parmUseFromDate() && projCostTransCost.wipPeriod != dateNull() && projCostTransCost.wipPeriod <= this.parmProjPeriodTo())
                    ||   (this.parmUseFromDate() && projCostTransCost.wipPeriod != dateNull() && projCostTransCost.wipPeriod == this.parmProjPeriodTo()))
            join firstOnly RecId from tmpProjControlActual
                where  tmpProjControlActual.TransId  == projCostTransCost.TransId
                    && tmpProjControlActual.CostType == transactionType
                    && tmpProjControlActual.Origin == ProjOrigin::BeginningBalance;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertHourTmp</Name>
				<Source><![CDATA[
    private void insertHourTmp()
    {
        ProjTable                   projTable;
        ProjEmplTrans               projEmplTrans;
        ProjEmplTransCost           projEmplTransCost;
        PSAIndirectComponentTrans   psaIndirectComponentTrans;
        ProjWIPTable                projWIPTable;
        ProjControlCategory         projControlCategory;
        ProjRevRecContractLine projRevRecContractLine;

        ProjCostType                transactionType = ProjCostType::Hour;
        ProjControlActualCostType   estimateType    = ProjControlActualCostType::Actual;
        ProjControlActualRange      periodRange     = ProjControlActualRange::CurrentPeriod;
        ProjId wipProjid = this.parmWIPProjId();

        // Insert bulk into tmpProjControlActual
        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            insert_recordset tmpProjControlActual
            (ProjId, ActivityNumber, ContractLineNum, CategoryId,
             Qty, TransId, Txt, LinePropertyId, Voucher, Resource, ResourceCategory,
             TransDate, CostType, DefaultDimension, Type, Range, Origin)
        select wipProjid, ActivityNumber, PSAContractLineNum, CategoryId,
            Qty, TransId, Txt, LinePropertyId, VoucherJournal, Resource, ResourceCategory, TransDate, transactionType,
            DefaultDimension, estimateType, periodRange, TransactionOrigin
        from projEmplTrans
              exists join firstonly projEmplTransCost
                where projEmplTransCost.TransId == projEmplTrans.TransId
                &&   (projEmplTransCost.TransStatus   == ProjTransStatus::Estimated ||
                     (getEliminated
                &&   (projEmplTransCost.TransStatus   == ProjTransStatus::Eliminated)))
                &&   ((!this.parmUseFromDate() && projEmplTransCost.wipPeriod != dateNull() && projEmplTransCost.wipPeriod <= this.parmProjPeriodTo())
                ||   (this.parmUseFromDate() && projEmplTransCost.wipPeriod != dateNull() && projEmplTransCost.wipPeriod == this.parmProjPeriodTo()))
             exists join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == this.parmWIPProjId()
            && projRevRecContractLine.ContractLineNum == projEmplTrans.PSAContractLineNum
             exists join projWIPTable
                where projWIPTable.ProjId == this.parmWIPProjId()
             exists join projControlCategory
                where projControlCategory.ControlId == projWIPTable.ControlId
                &&    projControlCategory.CategoryId == projEmplTrans.CategoryId;        
        } else 
        {
            insert_recordset tmpProjControlActual
            (ProjId, ActivityNumber, CategoryId,
             Qty, TransId, Txt, LinePropertyId, Voucher, Resource, ResourceCategory,
             TransDate, CostType, DefaultDimension, Type, Range, Origin)
        select wipProjid, ActivityNumber, CategoryId,
            Qty, TransId, Txt, LinePropertyId, VoucherJournal, Resource, ResourceCategory, TransDate, transactionType,
            DefaultDimension, estimateType, periodRange, TransactionOrigin
        from projEmplTrans
            exists join firstonly projEmplTransCost
                where projEmplTransCost.TransId == projEmplTrans.TransId
                &&   (projEmplTransCost.TransStatus   == ProjTransStatus::Estimated ||
                     (getEliminated
                &&   (projEmplTransCost.TransStatus   == ProjTransStatus::Eliminated)))
                &&   ((!this.parmUseFromDate() && projEmplTransCost.wipPeriod != dateNull() && projEmplTransCost.wipPeriod <= this.parmProjPeriodTo())
                ||   (this.parmUseFromDate() && projEmplTransCost.wipPeriod != dateNull() && projEmplTransCost.wipPeriod == this.parmProjPeriodTo()))
             exists join firstonly projTable
                where projTable.ProjId     == projEmplTrans.ProjId
                &&    projTable.wipProject == wipProjid
             exists join projWIPTable
                where projWIPTable.ProjId == projTable.WIPProject
             exists join projControlCategory
                where projControlCategory.ControlId == projWIPTable.ControlId
                &&    projControlCategory.CategoryId == projEmplTrans.CategoryId;        
        }
 
        if (isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select LineAmount, CostPrice, LedgerStatusCost, wipPeriod, LedgerTransdate from projEmplTransCost
                where    (projEmplTransCost.TransStatus == ProjTransStatus::Estimated ||
                         (getEliminated
                    &&   (projEmplTransCost.TransStatus == ProjTransStatus::Eliminated)))
                    &&   ((!this.parmUseFromDate() && projEmplTransCost.wipPeriod != dateNull() && projEmplTransCost.wipPeriod <= this.parmProjPeriodTo())
                    ||   (this.parmUseFromDate() && projEmplTransCost.wipPeriod != dateNull() && projEmplTransCost.wipPeriod == this.parmProjPeriodTo()))
                join RecId, ProjId from tmpProjControlActual
                    where tmpProjControlActual.TransId == projEmplTransCost.TransId
                       && tmpProjControlActual.CostType == transactionType
                join projEmplTrans
                    where projEmplTrans.TransId == projEmplTransCost.TransId
                exists join projRevRecContractLine
                    where projRevRecContractLine.RevenueRecognitionId == wipProjid
                && projRevRecContractLine.ContractLineNum == tmpProjControlActual.ContractLineNum
                exists join projWIPTable
                    where projWIPTable.ProjId == wipProjid
            {
                tmpProjControlActualCost.clear();
                tmpProjControlActualCost.LedgerStatusCost = projEmplTransCost.LedgerStatusCost;
                tmpProjControlActualCost.WIPPeriod = projEmplTransCost.WIPPeriod;
                tmpProjControlActualCost.RefRecID = tmpProjControlActual.RecId;
                tmpProjControlActualCost.CostPrice = projEmplTransCost.CostPrice;

                if (projContractCurrencyForRevRecParmEnabled && PSAContractLineItems::find(tmpProjControlActual.ContractLineNum).BillingMethod == ProjContractBillingMethod::FixedPrice)
                {
                    CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                        Ledger::primaryLedger(CompanyInfo::findDataArea(projEmplTransCost.company()).RecId),
                        projEmplTransCost.LedgerTransdate);
                    tmpProjControlActualCost.costAmount = currencyExchangeHelper.calculateAccountingToTransaction(projTable.contractCurrCode(), projEmplTransCost.LineAmount, true);
                }
                else
                {
                    tmpProjControlActualCost.costAmount = projEmplTransCost.LineAmount;
                }

                tmpProjControlActualCost.insert();
            }
        
        }
        else if (projContractCurrencyForRevRecParmEnabled)
        {
            while select LineAmount, CostPrice, LedgerStatusCost, wipPeriod, LedgerTransdate from projEmplTransCost
                where    (projEmplTransCost.TransStatus == ProjTransStatus::Estimated ||
                         (getEliminated
                    &&   (projEmplTransCost.TransStatus == ProjTransStatus::Eliminated)))
                    &&   ((!this.parmUseFromDate() && projEmplTransCost.wipPeriod != dateNull() && projEmplTransCost.wipPeriod <= this.parmProjPeriodTo())
                    ||   (this.parmUseFromDate() && projEmplTransCost.wipPeriod != dateNull() && projEmplTransCost.wipPeriod == this.parmProjPeriodTo()))
                join RecId, ProjId from tmpProjControlActual
                    where tmpProjControlActual.TransId == projEmplTransCost.TransId
                       && tmpProjControlActual.CostType == transactionType
                join projTable
                    where projTable.ProjId == tmpProjControlActual.ProjId
                        && projTable.wipProject == wipProjid
                exists join projWIPTable
                    where projWIPTable.ProjId == projTable.WIPProject
            {
                tmpProjControlActualCost.clear();
                tmpProjControlActualCost.LedgerStatusCost = projEmplTransCost.LedgerStatusCost;
                tmpProjControlActualCost.WIPPeriod = projEmplTransCost.WIPPeriod;
                tmpProjControlActualCost.RefRecID = tmpProjControlActual.RecId;
                tmpProjControlActualCost.CostPrice = projEmplTransCost.CostPrice;

                if (ProjMultipleContractLinesForProjectFeatureHelper::isFixedPriceBillingMethod(projTable, ProjTransType::Hour))
                {
                    CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                        Ledger::primaryLedger(CompanyInfo::findDataArea(projEmplTransCost.company()).RecId),
                        projEmplTransCost.LedgerTransdate);
                    tmpProjControlActualCost.costAmount = currencyExchangeHelper.calculateAccountingToTransaction(projTable.contractCurrCode(), projEmplTransCost.LineAmount, true);
                }
                else
                {
                    tmpProjControlActualCost.costAmount = projEmplTransCost.LineAmount;
                }

                tmpProjControlActualCost.insert();
            }
        }
        else
        {
            // Insert bulk into tmpProjControlActualCost
            insert_recordset tmpProjControlActualCost
                (CostAmount, CostPrice, LedgerStatusCost, wipperiod, RefRecId)
            select LineAmount, CostPrice, LedgerStatusCost, wipPeriod from projEmplTransCost
                where    (projEmplTransCost.TransStatus   == ProjTransStatus::Estimated ||
                         (getEliminated
                    &&   (projEmplTransCost.TransStatus   == ProjTransStatus::Eliminated)))
                    &&   ((!this.parmUseFromDate() && projEmplTransCost.wipPeriod != dateNull() && projEmplTransCost.wipPeriod <= this.parmProjPeriodTo())
                    ||   (this.parmUseFromDate() && projEmplTransCost.wipPeriod != dateNull() && projEmplTransCost.wipPeriod == this.parmProjPeriodTo()))
                join firstonly RecId from tmpProjControlActual
                    where tmpProjControlActual.TransId  == projEmplTransCost.TransId
                       && tmpProjControlActual.CostType == transactionType;
        }

        if (projContractCurrencyForRevRecParmEnabled)
        {
            // Convert Indirect cost to contract currency amount before inserting into tmpProjControlActualCost
            while select Amount, CurrencyId from psaIndirectComponentTrans
                where psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                join LedgerStatusCost, LedgerTransDate from projEmplTransCost
                    where projEmplTransCost.TransId == psaIndirectComponentTrans.TransId
                        && projEmplTransCost.FundingSource == psaIndirectComponentTrans.ProjFundingSource
                        && (projEmplTransCost.TransStatus == ProjTransStatus::Estimated
                             || (getEliminated && projEmplTransCost.TransStatus == ProjTransStatus::Eliminated))
                        && ((!this.parmUseFromDate() && projEmplTransCost.wipPeriod != dateNull() && projEmplTransCost.wipPeriod <= this.parmProjPeriodTo())
                             || (this.parmUseFromDate() && projEmplTransCost.wipPeriod != dateNull() && projEmplTransCost.wipPeriod == this.parmProjPeriodTo()))
                join RecId from tmpProjControlActual
                    where tmpProjControlActual.TransId == projEmplTransCost.TransId
                        && tmpProjControlActual.CostType == transactionType
            {
                // psaIndirectComponentTrans.Amount is in accounting currency and psaIndirectComponentTrans.CurrencyId is the transaction currency
                // CurrencyExchangeHelper::curAmount() converts the indirect cost from accounting currency to transaction currency
                tmpProjControlActualCost.costAmount = CurrencyExchangeHelper::curAmount(psaIndirectComponentTrans.Amount, psaIndirectComponentTrans.CurrencyId, projEmplTransCost.LedgerTransDate);
                tmpProjControlActualCost.CostPrice = psaIndirectComponentTrans.Amount;
                tmpProjControlActualCost.Range = periodRange;
                tmpProjControlActualCost.LedgerStatusCost = projEmplTransCost.LedgerStatusCost;
                tmpProjControlActualCost.RefRecId = tmpProjControlActual.RecId;
                tmpProjControlActualCost.insert();
            }
        }
        else
        {
            // Insert Records for indirect cost
            insert_recordset tmpProjControlActualCost
			    (CostAmount, CostPrice, Range, WipPeriod, LedgerStatusCost, RefRecId)
		    select Amount, Amount, periodRange from psaIndirectComponentTrans
                where psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
			    join firstonly wipPeriod, LedgerStatusCost from projEmplTransCost
				    where    projEmplTransCost.TransId        == psaIndirectComponentTrans.TransId
					    &&   projEmplTransCost.FundingSource  == psaIndirectComponentTrans.ProjFundingSource
					    &&   (projEmplTransCost.TransStatus   == ProjTransStatus::Estimated ||
						     (getEliminated
					    &&   (projEmplTransCost.TransStatus   == ProjTransStatus::Eliminated)))
                        &&   ((!this.parmUseFromDate() && projEmplTransCost.wipPeriod != dateNull() && projEmplTransCost.wipPeriod <= this.parmProjPeriodTo())
                        ||   (this.parmUseFromDate() && projEmplTransCost.wipPeriod != dateNull() && projEmplTransCost.wipPeriod == this.parmProjPeriodTo()))
			    join firstonly RecId from tmpProjControlActual
				    where tmpProjControlActual.TransId  == projEmplTransCost.TransId
					    && tmpProjControlActual.CostType == transactionType;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertItemTmp</Name>
				<Source><![CDATA[
    private void insertItemTmp()
    {
        ProjTable           projTable;
        ProjItemTrans       projItemTrans;
        ProjItemTransCost   projItemTransCost;
        ProjWIPTable        projWIPTable;
        ProjControlCategory projControlCategory;
        ProjRevRecContractLine projRevRecContractLine;

        ProjCostType                transactionType = ProjCostType::Item;
        ProjControlActualCostType   estimateType    = ProjControlActualCostType::Actual;
        ProjControlActualRange      periodRange     = ProjControlActualRange::CurrentPeriod;
        ProjId wipProjid = this.parmWIPProjId();

        // Insert bulk into tmpProjControlActual
        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            insert_recordset tmpProjControlActual
            (ProjId, ActivityNumber, ContractLineNum, CategoryId,
             Qty, TransId, Txt, LinePropertyId, Voucher, TransDate, CostType,
             EmplItemId, InventTransId, PackingSlipId, ProjAdjustRefId,
             DefaultDimension, Type, Range, Origin)
        select wipProjid, ActivityNumber, PSAContractLineNum, CategoryId,
             Qty, ProjTransId, Txt, LinePropertyId, VoucherPackingSlip, TransDate, transactionType,
             ItemId, InventTransId, PackingSlipId, ProjAdjustRefId,
             DefaultDimension, estimateType, periodRange, TransactionOrigin
        from projItemTrans
            exists join projItemTransCost
                where projItemTransCost.InventTransId == projItemTrans.InventTransId
                &&    projItemTransCost.ProjAdjustRefId == projItemTransCost.ProjAdjustRefId
                &&   (projItemTransCost.TransStatus   == ProjTransStatus::Estimated ||
                     (getEliminated
                &&   (projItemTransCost.TransStatus   == ProjTransStatus::Eliminated)))
                &&   ((!this.parmUseFromDate() && projItemTransCost.wipPeriod != dateNull() && projItemTransCost.wipPeriod <= this.parmProjPeriodTo())
                ||   (this.parmUseFromDate() && projItemTransCost.wipPeriod != dateNull() && projItemTransCost.wipPeriod == this.parmProjPeriodTo()))
            exists join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == projWipId
            && projRevRecContractLine.ContractLineNum == projItemTrans.PSAContractLineNum
             exists join projWIPTable
                where projWIPTable.ProjId == projWipId
             exists join projControlCategory
                where projControlCategory.ControlId == projWIPTable.ControlId
                &&    projControlCategory.CategoryId == projItemTrans.CategoryId;
        }
        else
        {
        insert_recordset tmpProjControlActual
			(ProjId, ActivityNumber, CategoryId,
			 Qty, TransId, Txt, LinePropertyId, Voucher, TransDate, CostType,
			 EmplItemId, InventTransId, PackingSlipId, ProjAdjustRefId,
			 DefaultDimension, Type, Range, Origin)
		select ProjId, ActivityNumber, CategoryId,
			 Qty, ProjTransId, Txt, LinePropertyId, VoucherPackingSlip, TransDate, transactionType,
			 ItemId, InventTransId, PackingSlipId, ProjAdjustRefId,
			 DefaultDimension, estimateType, periodRange, TransactionOrigin
        from projItemTrans
            exists join projItemTransCost
                where projItemTransCost.InventTransId == projItemTrans.InventTransId
                &&    projItemTransCost.ProjAdjustRefId == projItemTransCost.ProjAdjustRefId
                &&   (projItemTransCost.TransStatus   == ProjTransStatus::Estimated ||
                     (getEliminated
                &&   (projItemTransCost.TransStatus   == ProjTransStatus::Eliminated)))
                &&   ((!this.parmUseFromDate() && projItemTransCost.wipPeriod != dateNull() && projItemTransCost.wipPeriod <= this.parmProjPeriodTo())
                ||   (this.parmUseFromDate() && projItemTransCost.wipPeriod != dateNull() && projItemTransCost.wipPeriod == this.parmProjPeriodTo()))
             exists join projTable
                where projTable.ProjId     == projItemTrans.ProjId
                &&    projTable.wipProject == this.parmWIPProjId()
             exists join projWIPTable
                where projWIPTable.ProjId == projTable.WIPProject
             exists join projControlCategory
                where projControlCategory.ControlId == projWIPTable.ControlId
                &&    projControlCategory.CategoryId == projItemTrans.CategoryId;
        }

        if (isContractLineUsed && contractLineBasedRevRecFeature)
        {
            ttsbegin;
            while select AmountMST, LedgerStatusCost, wipPeriod, ProjId, LedgerTransdate from projItemTransCost
            where (projItemTransCost.TransStatus == ProjTransStatus::Estimated ||
                     (getEliminated
                &&   (projItemTransCost.TransStatus == ProjTransStatus::Eliminated)))
                &&   ((!this.parmUseFromDate() && projItemTransCost.wipPeriod != dateNull() && projItemTransCost.wipPeriod <= this.parmProjPeriodTo())
                ||   (this.parmUseFromDate() && projItemTransCost.wipPeriod != dateNull() && projItemTransCost.wipPeriod == this.parmProjPeriodTo()))
            join RecId from tmpProjControlActual
                where tmpProjControlActual.InventTransId == projItemTransCost.InventTransId
                   && tmpProjControlActual.ProjAdjustRefId == projItemTransCost.ProjAdjustRefId
                   && tmpProjControlActual.CostType == transactionType
            join projItemTrans
                    where projItemTrans.InventTransId == projItemTransCost.InventTransId
                    &&  projItemTrans.ProjAdjustRefId == projItemTransCost.ProjAdjustRefId
            exists join projRevRecContractLine
                    where projRevRecContractLine.RevenueRecognitionId == wipProjid
                    && projRevRecContractLine.ContractLineNum == projItemTrans.PSAContractLineNum
             exists join projWIPTable
                where projWIPTable.ProjId == projWipId
            {
                tmpProjControlActualCost.clear();
                tmpProjControlActualCost.LedgerStatusCost = projItemTransCost.LedgerStatusCost;
                tmpProjControlActualCost.WIPPeriod = projItemTransCost.WIPPeriod;
                tmpProjControlActualCost.RefRecID = tmpProjControlActual.RecID;

                if (projContractCurrencyForRevRecParmEnabled && PSAContractLineItems::find(tmpProjControlActual.ContractLineNum).BillingMethod == ProjContractBillingMethod::FixedPrice)
                {
                    CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                        Ledger::primaryLedger(CompanyInfo::findDataArea(projItemTransCost.company()).RecId),
                        projItemTransCost.LedgerTransdate);
                    tmpProjControlActualCost.costAmount = currencyExchangeHelper.calculateAccountingToTransaction(projTable.contractCurrCode(), projItemTransCost.AmountMST, true);
                }
                else
                {
                    tmpProjControlActualCost.costAmount = projItemTransCost.AmountMST;
                }

                tmpProjControlActualCost.insert();
            }
            ttscommit;

        }
        else if (projContractCurrencyForRevRecParmEnabled)
        {
            ttsbegin;
            while select AmountMST, LedgerStatusCost, wipPeriod, ProjId, LedgerTransdate from projItemTransCost
            where (projItemTransCost.TransStatus == ProjTransStatus::Estimated ||
                     (getEliminated
                &&   (projItemTransCost.TransStatus == ProjTransStatus::Eliminated)))
                &&   ((!this.parmUseFromDate() && projItemTransCost.wipPeriod != dateNull() && projItemTransCost.wipPeriod <= this.parmProjPeriodTo())
                ||   (this.parmUseFromDate() && projItemTransCost.wipPeriod != dateNull() && projItemTransCost.wipPeriod == this.parmProjPeriodTo()))
            join RecId from tmpProjControlActual
                where tmpProjControlActual.InventTransId == projItemTransCost.InventTransId
                   && tmpProjControlActual.ProjAdjustRefId == projItemTransCost.ProjAdjustRefId
                   && tmpProjControlActual.CostType == transactionType
            join projTable
                where projTable.ProjId == projItemTransCost.ProjId
                   && projTable.wipProject == this.parmWIPProjId()
             exists join projWIPTable
                where projWIPTable.ProjId == projTable.WIPProject
            {
                tmpProjControlActualCost.clear();
                tmpProjControlActualCost.LedgerStatusCost = projItemTransCost.LedgerStatusCost;
                tmpProjControlActualCost.WIPPeriod = projItemTransCost.WIPPeriod;
                tmpProjControlActualCost.RefRecID = tmpProjControlActual.RecID;

                if (ProjMultipleContractLinesForProjectFeatureHelper::isFixedPriceBillingMethod(projTable, ProjTransType::Item))
                {
                    CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                        Ledger::primaryLedger(CompanyInfo::findDataArea(projItemTransCost.company()).RecId),
                        projItemTransCost.LedgerTransdate);
                    tmpProjControlActualCost.costAmount = currencyExchangeHelper.calculateAccountingToTransaction(projTable.contractCurrCode(), projItemTransCost.AmountMST, true);
                }
                else
                {
                    tmpProjControlActualCost.costAmount = projItemTransCost.AmountMST;
                }

                tmpProjControlActualCost.insert();
            }
            ttscommit;
        }
        else
        {
            // Insert bulk into tmpProjControlActualCost
            insert_recordset tmpProjControlActualCost
            (CostAmount, LedgerStatusCost, wipperiod, RefRecId)
        select AmountMST, LedgerStatusCost, wipPeriod from projItemTransCost
            where    (projItemTransCost.TransStatus   == ProjTransStatus::Estimated ||
                     (getEliminated
                &&   (projItemTransCost.TransStatus   == ProjTransStatus::Eliminated)))
                &&   ((!this.parmUseFromDate() && projItemTransCost.wipPeriod != dateNull() && projItemTransCost.wipPeriod <= this.parmProjPeriodTo())
                ||   (this.parmUseFromDate() && projItemTransCost.wipPeriod != dateNull() && projItemTransCost.wipPeriod == this.parmProjPeriodTo()))
            join firstonly RecId from tmpProjControlActual
                where tmpProjControlActual.InventTransId   == projItemTransCost.InventTransId
                   && tmpProjControlActual.ProjAdjustRefId == projItemTransCost.ProjAdjustRefId
                   && tmpProjControlActual.CostType        == transactionType;
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>initTransactionOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes transaction origin of <c>TmpProjControlActual</c> buffer.
    /// </summary>
    /// <param name = "_projTrans">
    ///     The <c>ProjTrans</c> enumeration value.
    /// </param>
    /// <param name = "_costType">
    ///     The <c>ProjCostType</c> enumeration value.
    /// </param>
    protected void initTransactionOrigin(ProjTrans _projTrans, ProjCostType _costType)
    {
        switch (_costType)
        {
            case ProjCostType::Hour:
                tmpProjControlActual.Origin = _projTrans.originEmpl();
                break;

            case ProjCostType::Cost:
                tmpProjControlActual.Origin = _projTrans.originCost();
                break;

            case ProjCostType::Item:
                tmpProjControlActual.Origin = _projTrans.itemType();
                break;
           
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTmp</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Inserts records in the temporary table.
    /// </summary>
    /// <param name = "_projTrans">
    ///     The <c>ProjTrans</c> enumeration value.
    /// </param>
    /// <param name = "_recId">
    ///     The record ID of the record.
    /// </param>
    /// <param name = "_type">
    ///     The <c>ProjControlActualCostType</c> enumeration value.
    /// </param>
    /// <param name = "_range">
    ///     The <c>ProjControlActualRange</c> enumeration value.
    /// </param>
    /// <param name = "_controlId">
    ///     The cost template.
    /// </param>
    /// <param name = "_id">
    ///     The identification string.
    /// </param>
    /// <param name = "_costType">
    ///     The <c>ProjCostType</c> enumeration value.
    /// </param>
    /// <param name = "_resourceRecId">
    ///     The record ID of the resource.
    /// </param>
    /// <param name = "_costAmount">
    ///     The cost amount.
    /// </param>
    /// <param name = "_transCostAmount">
    ///     The transaction cost amount.
    /// </param>
    /// <param name = "_qty">
    ///     The quantity.
    /// </param>
    private void insertTmp(ProjTrans _projTrans, RecId _recId, ProjControlActualCostType _type, ProjControlActualRange _range, ProjControlId _controlId, str _id, ProjCostType _costType, ResourceRecId _resourceRecId, AmountMST _costAmount = 0, AmountMST _transCostAmount = 0, Qty _qty = 0)
    {
        TransactionId   transId;
        AmountMST       transCostAmountMST;

        transId = _projTrans.transId();

        if (_recId)
        {
            select tmpProjControlActual
            where tmpProjControlActual.RefRecID == _recId;
        }
        else
        {
            select tmpProjControlActual
            where tmpProjControlActual.TransId == transid;
        }

        if (! tmpProjControlActual)
        {
            tmpProjControlActual.clear();

            tmpProjControlActual.ProjId             = _projTrans.projId();
            tmpProjControlActual.ActivityNumber     = _projTrans.activityNumber();
            tmpProjControlActual.CategoryId         = _projTrans.categoryId();
            tmpProjControlActual.costGroupId        = ProjControlCategory::findCategoryGroup(_controlId, tmpProjControlActual.CategoryId);
            tmpProjControlActual.ContractLineNum = _projTrans.psaContractLineNum();
            tmpProjControlActual.Qty                = (_qty? _qty : _projTrans.qty());
            if (reversal)
            {
                tmpProjControlActual.qty            = -tmpProjControlActual.qty;
            }

            tmpProjControlActual.TransId            = transId;
            tmpProjControlActual.RefRecID           = _recId;
            tmpProjControlActual.Txt                = _projTrans.txt();
            tmpProjControlActual.LinePropertyId     = _projTrans.linePropertyId();
            tmpProjControlActual.Voucher            = _projTrans.voucherOriginal();
            tmpProjControlActual.EmplItemId         = _id;
            tmpProjControlActual.Resource           = _resourceRecId;
            tmpProjControlActual.ResourceCategory   = _projTrans.resourceCategory();
            tmpProjControlActual.TransDate          = _projTrans.transDate();
            tmpProjControlActual.CostType           = _costType;

            this.initTransactionOrigin(_projTrans, _costType);

            tmpProjControlActual.InventTransId      = _projTrans.inventTransId();
            tmpProjControlActual.PackingSlipId      = _projTrans.packingSlipId();
            tmpProjControlActual.ProjAdjustRefId    = _projTrans.projAdjustRefId();
            tmpProjControlActual.DefaultDimension   = _projTrans.defaultDimension();
            tmpProjControlActual.Type               = _type;
            tmpProjControlActual.Range              = _range;
            tmpProjControlActual.insert();
        }

        tmpProjControlActualCost.clear();
        if (!_costAmount && !_transCostAmount)
        {
            transCostAmountMST = _projTrans.transCostMST();
        }

        tmpProjControlActualCost.RefRecID = tmpProjControlActual.RecId;
        tmpProjControlActualCost.CostAmount = (_costAmount ? _costAmount : transCostAmountMST)  * this.factor();

        if (_type == ProjControlActualCostType::Actual &&
        _range == ProjControlActualRange::CurrentPeriod &&
        _projTrans.canBeCapitalize())
        {
            tmpProjControlActualCost.Capitalize = (_transCostAmount ? _transCostAmount : transCostAmountMST);
        }

        if (_costType   == ProjCostType::Item)
        {
            if (tmpProjControlActual.Qty)
            {
                tmpProjControlActualCost.CostPrice = tmpProjControlActualCost.CostAmount / tmpProjControlActual.Qty;
            }
        }
        else
        {
            tmpProjControlActualCost.CostPrice = _projTrans.costPrice();
        }
        tmpProjControlActualCost.LedgerStatusCost = _projTrans.ledgerStatusCost();
        tmpProjControlActualCost.wipPeriod = _projTrans.wipPeriod();
        tmpProjControlActualCost.Range = _range;
        tmpProjControlActualCost.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new(boolean _updateWIPPeriod = false)
    {
        updateWIPPeriod = _updateWIPPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBeginningBalance</Name>
				<Source><![CDATA[
    public ProjBeginningBalance parmBeginningBalance(ProjBeginningBalance _beginningBalance = beginningBalance)
    {
        beginningBalance = _beginningBalance;

        return beginningBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGetEliminated</Name>
				<Source><![CDATA[
    public boolean parmGetEliminated(boolean  _getEliminated  = getEliminated)
    {
        getEliminated = _getEliminated;

        return getEliminated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeActual</Name>
				<Source><![CDATA[
    public boolean parmIncludeActual(boolean _includeActual = includeActual)
    {
        includeActual = _includeActual;

        return includeActual;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeAfterPeriodEnd</Name>
				<Source><![CDATA[
    public boolean parmIncludeAfterPeriodEnd(boolean _includeAfterPeriodEnd = includeAfterPeriodEnd)
    {
        includeAfterPeriodEnd = _includeAfterPeriodEnd;

        return includeAfterPeriodEnd;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeCommitted</Name>
				<Source><![CDATA[
    public boolean parmIncludeCommitted(boolean _includeCommitted = includeCommitted)
    {
        includeCommitted = _includeCommitted;

        return includeCommitted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeCurrentPeriod</Name>
				<Source><![CDATA[
    public boolean parmIncludeCurrentPeriod(boolean _includeCurrentPeriod = includeCurrentPeriod)
    {
        includeCurrentPeriod = _includeCurrentPeriod;

        return includeCurrentPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjControlId</Name>
				<Source><![CDATA[
    public ProjControlId parmProjControlId(ProjControlId  _projControlId  = projControlId)
    {
        projControlId = _projControlId;

        return projControlId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjControlVersion</Name>
				<Source><![CDATA[
    public ProjControlVersion parmProjControlVersion(ProjControlVersion _version = projControlVersion)
    {
        projControlVersion = _version ? _version : 1;

        return projControlVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjPeriodFrom</Name>
				<Source><![CDATA[
    public ProjPeriodFrom parmProjPeriodFrom(ProjPeriodFrom _projPeriodFrom  = projPeriodFrom)
    {
        projPeriodFrom = _projPeriodFrom;

        return projPeriodFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjPeriodTo</Name>
				<Source><![CDATA[
    public ProjPeriodTo parmProjPeriodTo(ProjPeriodTo _projPeriodTo  = projPeriodTo)
    {
        projPeriodTo = _projPeriodTo;

        return projPeriodTo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseFromDate</Name>
				<Source><![CDATA[
    public boolean parmUseFromDate(boolean  _useFromDate  = useFromDate)
    {
        useFromDate = _useFromDate;

        return useFromDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWIPProjId</Name>
				<Source><![CDATA[
    public ProjWipId parmWIPProjId(ProjWipId _projWipId = projWipId)
    {
        projWipId = _projWipId;

        return projWipId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsContractLineUsed</Name>
				<Source><![CDATA[
    public boolean parmIsContractLineUsed(boolean _isContractLineUsed = isContractLineUsed )
    {
        isContractLineUsed = _isContractLineUsed;

        return isContractLineUsed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjCostType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the value of <c>ProjCostType</c> enumeration.
    /// </summary>
    /// <param name = "_projTrans">
    ///     The instance of <c>ProjTrans</c> class.
    /// </param>
    /// <returns>
    ///     The value of <c>ProjCostType</c> enumeration.
    /// </returns>
    protected ProjCostType getProjCostType(ProjTrans _projTrans)
    {
        ProjCostType    projCostType;
        switch (_projTrans.transType())
        {
            case ProjTransType::Cost:
                projCostType = ProjCostType::Cost;
                break;
            case ProjTransType::Hour:
                projCostType = ProjCostType::Hour;
                break;
            case ProjTransType::Item:
                projCostType = ProjCostType::Item;
                break;
        }

        return projCostType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAfterPeriodEnd</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Process project control after period end.
    /// </summary>
    private void processAfterPeriodEnd()
    {
        ProjTable                               projTable;
        ProjEmplTrans                           projEmplTrans;
        ProjEmplTransCost                       projEmplTransCost;
        ProjCostTrans                           projCostTrans;
        ProjCostTransCost                       projCostTransCost;
        ProjItemTrans                           projItemTrans;
        ProjItemTransCost                       projItemTransCost;
        CostControlTransCommittedCost           costControlTransCommittedCost;
        ProjTrans                               projTrans;
        ProjCostType                            projCostType;
        ProjControlCategory                     projControlCategory;
        ProjControlPeriodCostGroup              projControlPeriodCostGroup;
        PSAIndirectComponentTrans               psaIndirectComponentTrans;
        ProjRevRecContractLine                  projRevRecContractLine;

        void processCommitted(ProjControlPeriodCostGroupCTCMethod _ctcMethod)
        {
            // CostControlTransCommittedCost
            // Update temporary table
            if(!isContractLineUsed || !contractLineBasedRevRecFeature)
            {
                while select RecId from projTable
            where projTable.wipProject == this.parmWIPProjId()
                join costControlTransCommittedCost
                where costControlTransCommittedCost.ProjId == projTable.ProjId
                    && costControlTransCommittedCost.CommittedDate > this.parmProjPeriodTo()
                join RecId from projControlCategory
                    where projControlCategory.ControlId == this.parmProjControlId() &&
                        projControlCategory.CategoryId == costControlTransCommittedCost.CategoryId
                join RecId from projControlPeriodCostGroup
                    where projControlPeriodCostGroup.ProjId == projTable.wipProject &&
                        projControlPeriodCostGroup.ControlId == projControlCategory.ControlId &&
                        projControlPeriodCostGroup.PeriodFrom == this.parmProjPeriodFrom() &&
                        projControlPeriodCostGroup.Version == this.parmProjControlVersion() &&
                        projControlPeriodCostGroup.CostGroupId == projControlCategory.CostGroupId &&
                        projControlPeriodCostGroup.ctcMethod == _ctcMethod
                {
                    projTrans = ProjTrans::newCostControlTransCommittedCost(costControlTransCommittedCost);
                    projCostType = this.getProjCostType(projTrans);
                    this.insertTmp(projTrans,
                costControlTransCommittedCost.RecId,
                ProjControlActualCostType::Committed,
                ProjControlActualRange::AfterPeriodEnd,
                this.parmProjControlId(),
                projTrans.itemId(),
                projCostType,
                projTrans.resource());
                }
            }
        }

        void processActual(ProjControlPeriodCostGroupCTCMethod _ctcMethod)
        {
            // ProjEmplTrans
            // Update temporary table (All Trx after period)
            if(isContractLineUsed && contractLineBasedRevRecFeature)
            {
                while select RecId from projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == this.parmWIPProjId()
                    join projEmplTrans
                      where projEmplTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum
                    join RecId from projControlCategory
                        where projControlCategory.ControlId == this.parmProjControlId() &&
                            projControlCategory.CategoryId == projEmplTrans.CategoryId
                    join  RecId from projControlPeriodCostGroup
                        where projControlPeriodCostGroup.ProjId == this.parmWIPProjId() &&
                            projControlPeriodCostGroup.ControlId == projControlCategory.ControlId &&
                            projControlPeriodCostGroup.PeriodFrom == this.parmProjPeriodFrom() &&
                            projControlPeriodCostGroup.Version == this.parmProjControlVersion() &&
                            projControlPeriodCostGroup.CostGroupId == projControlCategory.CostGroupId &&
                            projControlPeriodCostGroup.ctcMethod == _ctcMethod
                    join projEmplTransCost
                        where projEmplTransCost.TransId == projEmplTrans.TransId
                            && projEmplTransCost.LedgerTransdate > this.parmProjPeriodTo()
                {
                    while select psaIndirectComponentTrans
                where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                    psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                    psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                    {
                        projTrans           = ProjTrans::newProjEmplTransIndirectCost(projEmplTrans, projEmplTransCost, psaIndirectComponentTrans);
                        this.insertTmp(projTrans,
                    0,
                    ProjControlActualCostType::Actual,
                    ProjControlActualRange::AfterPeriodEnd,
                    this.parmProjControlId(),
                    '',
                    ProjCostType::Hour,
                    projTrans.resource());
                    }

                    projTrans           = ProjTrans::newProjEmplTransCost(projEmplTrans, projEmplTransCost);
                    this.insertTmp(projTrans,
                0,
                ProjControlActualCostType::Actual,
                ProjControlActualRange::AfterPeriodEnd,
                this.parmProjControlId(),
                '',
                ProjCostType::Hour,
                projTrans.resource());
                }        
            }
            else
            {
                while select RecId from projTable
                where projTable.wipProject == this.parmWIPProjId()
                    join projEmplTrans
                      where projEmplTrans.ProjId == projTable.ProjId
                    join RecId from projControlCategory
                        where projControlCategory.ControlId == this.parmProjControlId() &&
                            projControlCategory.CategoryId == projEmplTrans.CategoryId
                    join  RecId from projControlPeriodCostGroup
                        where projControlPeriodCostGroup.ProjId == projTable.wipProject &&
                            projControlPeriodCostGroup.ControlId == projControlCategory.ControlId &&
                            projControlPeriodCostGroup.PeriodFrom == this.parmProjPeriodFrom() &&
                            projControlPeriodCostGroup.Version == this.parmProjControlVersion() &&
                            projControlPeriodCostGroup.CostGroupId == projControlCategory.CostGroupId &&
                            projControlPeriodCostGroup.ctcMethod == _ctcMethod
                    join projEmplTransCost
                        where projEmplTransCost.TransId == projEmplTrans.TransId
                            && projEmplTransCost.LedgerTransdate > this.parmProjPeriodTo()
                {
                    while select psaIndirectComponentTrans
                where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                    psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                    psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                    {
                        projTrans           = ProjTrans::newProjEmplTransIndirectCost(projEmplTrans, projEmplTransCost, psaIndirectComponentTrans);
                        this.insertTmp(projTrans,
                    0,
                    ProjControlActualCostType::Actual,
                    ProjControlActualRange::AfterPeriodEnd,
                    this.parmProjControlId(),
                    '',
                    ProjCostType::Hour,
                    projTrans.resource());
                    }

                    projTrans           = ProjTrans::newProjEmplTransCost(projEmplTrans, projEmplTransCost);
                    this.insertTmp(projTrans,
                0,
                ProjControlActualCostType::Actual,
                ProjControlActualRange::AfterPeriodEnd,
                this.parmProjControlId(),
                '',
                ProjCostType::Hour,
                projTrans.resource());
                }
            }

            // Update temporary table (All Trx before period end but not included in estimate - Handle BegBal, Reg)
            if(isContractLineUsed && contractLineBasedRevRecFeature)
            {
                while select RecId from projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == this.parmWIPProjId()
                    join projEmplTrans
                      where projEmplTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum
                    join RecId from projControlCategory
                        where projControlCategory.ControlId == this.parmProjControlId() &&
                            projControlCategory.CategoryId == projEmplTrans.CategoryId
                    join  RecId from projControlPeriodCostGroup
                        where projControlPeriodCostGroup.ProjId == this.parmWIPProjId() &&
                            projControlPeriodCostGroup.ControlId == projControlCategory.ControlId &&
                            projControlPeriodCostGroup.PeriodFrom == this.parmProjPeriodFrom() &&
                            projControlPeriodCostGroup.Version == this.parmProjControlVersion() &&
                            projControlPeriodCostGroup.CostGroupId == projControlCategory.CostGroupId &&
                            projControlPeriodCostGroup.ctcMethod == _ctcMethod
                    join projEmplTransCost
                        where projEmplTransCost.TransId == projEmplTrans.TransId
                            && projEmplTransCost.LedgerTransdate <= this.parmProjPeriodTo()
                            && projEmplTransCost.wipPeriod == dateNull()
                {
                    while select psaIndirectComponentTrans
                    where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                        psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                        psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                    {
                        projTrans           = ProjTrans::newProjEmplTransIndirectCost(projEmplTrans, projEmplTransCost, psaIndirectComponentTrans);
                        this.insertTmp(projTrans,
                        0,
                        ProjControlActualCostType::Actual,
                        ProjControlActualRange::AfterPeriodEnd,
                        this.parmProjControlId(),
                        '',
                        ProjCostType::Hour,
                        projTrans.resource());
                    }

                    projTrans           = ProjTrans::newProjEmplTransCost(projEmplTrans, projEmplTransCost);
                    this.insertTmp(projTrans,
                    0,
                    ProjControlActualCostType::Actual,
                    ProjControlActualRange::AfterPeriodEnd,
                    this.parmProjControlId(),
                    '',
                    ProjCostType::Hour,
                    projTrans.resource());
                }
            }
              else 
              {
                while select RecId from projTable
                where projTable.wipProject == this.parmWIPProjId()
                    join projEmplTrans
                      where projEmplTrans.ProjId == projTable.ProjId
                    join RecId from projControlCategory
                        where projControlCategory.ControlId == this.parmProjControlId() &&
                            projControlCategory.CategoryId == projEmplTrans.CategoryId
                    join  RecId from projControlPeriodCostGroup
                        where projControlPeriodCostGroup.ProjId == projTable.wipProject &&
                            projControlPeriodCostGroup.ControlId == projControlCategory.ControlId &&
                            projControlPeriodCostGroup.PeriodFrom == this.parmProjPeriodFrom() &&
                            projControlPeriodCostGroup.Version == this.parmProjControlVersion() &&
                            projControlPeriodCostGroup.CostGroupId == projControlCategory.CostGroupId &&
                            projControlPeriodCostGroup.ctcMethod == _ctcMethod
                    join projEmplTransCost
                        where projEmplTransCost.TransId == projEmplTrans.TransId
                            && projEmplTransCost.LedgerTransdate <= this.parmProjPeriodTo()
                            && projEmplTransCost.wipPeriod == dateNull()
                {
                    while select psaIndirectComponentTrans
                    where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                        psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                        psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                    {
                        projTrans           = ProjTrans::newProjEmplTransIndirectCost(projEmplTrans, projEmplTransCost, psaIndirectComponentTrans);
                        this.insertTmp(projTrans,
                        0,
                        ProjControlActualCostType::Actual,
                        ProjControlActualRange::AfterPeriodEnd,
                        this.parmProjControlId(),
                        '',
                        ProjCostType::Hour,
                        projTrans.resource());
                    }

                    projTrans           = ProjTrans::newProjEmplTransCost(projEmplTrans, projEmplTransCost);
                    this.insertTmp(projTrans,
                    0,
                    ProjControlActualCostType::Actual,
                    ProjControlActualRange::AfterPeriodEnd,
                    this.parmProjControlId(),
                    '',
                    ProjCostType::Hour,
                    projTrans.resource());
                }
              }

            // ProjCostTrans
            // Update temporary table  (All Trx after period)
            if(isContractLineUsed && contractLineBasedRevRecFeature)
            {
                while select RecId from projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == this.parmWIPProjId()
                join projCostTrans
                    where projCostTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum &&
                    projCostTrans.TransactionOrigin != ProjOrigin::EstimateAccruedLoss
                join RecId from projControlCategory
                    where projControlCategory.ControlId == this.parmProjControlId() &&
                        projControlCategory.CategoryId == projCostTrans.CategoryId
                join  RecId from projControlPeriodCostGroup
                    where projControlPeriodCostGroup.ProjId == this.parmWIPProjId() &&
                        projControlPeriodCostGroup.ControlId == projControlCategory.ControlId &&
                        projControlPeriodCostGroup.PeriodFrom == this.parmProjPeriodFrom() &&
                        projControlPeriodCostGroup.Version == this.parmProjControlVersion() &&
                        projControlPeriodCostGroup.CostGroupId == projControlCategory.CostGroupId &&
                        projControlPeriodCostGroup.ctcMethod == _ctcMethod
                join projCostTransCost
                    where projCostTransCost.TransId == projCostTrans.TransId
                    && projCostTransCost.LedgerTransdate > this.parmProjPeriodTo()
                {
                    projTrans = ProjTrans::newProjCostTransCost(projCostTrans, projCostTransCost);
                    this.insertTmp(projTrans,
                    0,
                    ProjControlActualCostType::Actual,
                    ProjControlActualRange::AfterPeriodEnd,
                    this.parmProjControlId(),
                    '',
                    ProjCostType::Cost,
                    projTrans.resource(),
                    projTrans.ledgerCostAmountMST());
                }
            }
            else
            {
                while select RecId from projTable
            where projTable.wipProject == this.parmWIPProjId()
                join projCostTrans
                where projCostTrans.ProjId == projTable.ProjId
                && projCostTrans.TransactionOrigin != ProjOrigin::EstimateAccruedLoss
                join RecId from projControlCategory
                    where projControlCategory.ControlId == this.parmProjControlId() &&
                        projControlCategory.CategoryId == projCostTrans.CategoryId
                join  RecId from projControlPeriodCostGroup
                    where projControlPeriodCostGroup.ProjId == projTable.wipProject &&
                        projControlPeriodCostGroup.ControlId == projControlCategory.ControlId &&
                        projControlPeriodCostGroup.PeriodFrom == this.parmProjPeriodFrom() &&
                        projControlPeriodCostGroup.Version == this.parmProjControlVersion() &&
                        projControlPeriodCostGroup.CostGroupId == projControlCategory.CostGroupId &&
                        projControlPeriodCostGroup.ctcMethod == _ctcMethod
                join projCostTransCost
                    where projCostTransCost.TransId == projCostTrans.TransId
                    && projCostTransCost.LedgerTransdate > this.parmProjPeriodTo()
                {
                    projTrans = ProjTrans::newProjCostTransCost(projCostTrans, projCostTransCost);
                    this.insertTmp(projTrans,
                    0,
                    ProjControlActualCostType::Actual,
                    ProjControlActualRange::AfterPeriodEnd,
                    this.parmProjControlId(),
                    '',
                    ProjCostType::Cost,
                    projTrans.resource(),
                    projTrans.ledgerCostAmountMST());
                }
            }

            // Update temporary table  (All Trx before period end but not included in estimate - Handle BegBal, Reg)
            if(isContractLineUsed && contractLineBasedRevRecFeature)
            {
                while select RecId from projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == this.parmWIPProjId()
                join projCostTrans
                where projCostTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum &&
                    projCostTrans.TransactionOrigin != ProjOrigin::EstimateAccruedLoss
                join RecId from projControlCategory
                    where projControlCategory.ControlId == this.parmProjControlId() &&
                        projControlCategory.CategoryId == projCostTrans.CategoryId
                join  RecId from projControlPeriodCostGroup
                    where projControlPeriodCostGroup.ProjId ==  this.parmWIPProjId() &&
                        projControlPeriodCostGroup.ControlId == projControlCategory.ControlId &&
                        projControlPeriodCostGroup.PeriodFrom == this.parmProjPeriodFrom() &&
                        projControlPeriodCostGroup.Version == this.parmProjControlVersion() &&
                        projControlPeriodCostGroup.CostGroupId == projControlCategory.CostGroupId &&
                        projControlPeriodCostGroup.ctcMethod == _ctcMethod
                join projCostTransCost
                    where projCostTransCost.TransId == projCostTrans.TransId
                    && projCostTransCost.LedgerTransdate <= this.parmProjPeriodTo()
                    && projCostTransCost.wipPeriod == dateNull()
                {
                    projTrans = ProjTrans::newProjCostTransCost(projCostTrans, projCostTransCost);
                    this.insertTmp(projTrans,
                    0,
                    ProjControlActualCostType::Actual,
                    ProjControlActualRange::AfterPeriodEnd,
                    this.parmProjControlId(),
                    '',
                    ProjCostType::Cost,
                    projTrans.resource(),
                    projTrans.ledgerCostAmountMST());
                }
            }
            else
            {
                while select RecId from projTable
            where projTable.wipProject == this.parmWIPProjId()
                join projCostTrans
                where projCostTrans.ProjId == projTable.ProjId
                && projCostTrans.TransactionOrigin != ProjOrigin::EstimateAccruedLoss
                join RecId from projControlCategory
                    where projControlCategory.ControlId == this.parmProjControlId() &&
                        projControlCategory.CategoryId == projCostTrans.CategoryId
                join  RecId from projControlPeriodCostGroup
                    where projControlPeriodCostGroup.ProjId == projTable.wipProject &&
                        projControlPeriodCostGroup.ControlId == projControlCategory.ControlId &&
                        projControlPeriodCostGroup.PeriodFrom == this.parmProjPeriodFrom() &&
                        projControlPeriodCostGroup.Version == this.parmProjControlVersion() &&
                        projControlPeriodCostGroup.CostGroupId == projControlCategory.CostGroupId &&
                        projControlPeriodCostGroup.ctcMethod == _ctcMethod
                join projCostTransCost
                    where projCostTransCost.TransId == projCostTrans.TransId
                    && projCostTransCost.LedgerTransdate <= this.parmProjPeriodTo()
                    && projCostTransCost.wipPeriod == dateNull()
                {
                    projTrans = ProjTrans::newProjCostTransCost(projCostTrans, projCostTransCost);
                    this.insertTmp(projTrans,
                    0,
                    ProjControlActualCostType::Actual,
                    ProjControlActualRange::AfterPeriodEnd,
                    this.parmProjControlId(),
                    '',
                    ProjCostType::Cost,
                    projTrans.resource(),
                    projTrans.ledgerCostAmountMST());
                }
            }

            // ProjItemTrans
            // Update temporary table (All Trx after period)
            if(isContractLineUsed && contractLineBasedRevRecFeature)
            {
                while select RecId from projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == this.parmWIPProjId()
            join RecId from projItemTrans
                where projItemTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum
            join RecId from projControlCategory
                where projControlCategory.ControlId == this.parmProjControlId() &&
                    projControlCategory.CategoryId == projItemTrans.CategoryId
            join  RecId from projControlPeriodCostGroup
                where projControlPeriodCostGroup.ProjId == this.parmWIPProjId() &&
                    projControlPeriodCostGroup.ControlId == projControlCategory.ControlId &&
                    projControlPeriodCostGroup.PeriodFrom == this.parmProjPeriodFrom() &&
                    projControlPeriodCostGroup.Version == this.parmProjControlVersion() &&
                    projControlPeriodCostGroup.CostGroupId == projControlCategory.CostGroupId &&
                    projControlPeriodCostGroup.ctcMethod == _ctcMethod
            join projItemTransCost
                where projItemTransCost.InventTransId == projItemTrans.InventTransId
                    && projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId
                    && projItemTransCost.LedgerTransdate > this.parmProjPeriodTo()
                {
                    projTrans = ProjTrans::newProjItemTransCost(projItemTransCost);
                    this.insertTmp(projTrans,
                    0,
                    ProjControlActualCostType::Actual,
                    ProjControlActualRange::AfterPeriodEnd,
                    this.parmProjControlId(),
                    projTrans.itemId(),
                    ProjCostType::Item,
                    0);
                }
            }
            else
            {
                while select RecId from projTable
            where projTable.wipProject == this.parmWIPProjId()
            join RecId from projItemTrans
                where projItemTrans.ProjId == projTable.ProjId
            join RecId from projControlCategory
                where projControlCategory.ControlId == this.parmProjControlId() &&
                    projControlCategory.CategoryId == projItemTrans.CategoryId
            join  RecId from projControlPeriodCostGroup
                where projControlPeriodCostGroup.ProjId == projTable.wipProject &&
                    projControlPeriodCostGroup.ControlId == projControlCategory.ControlId &&
                    projControlPeriodCostGroup.PeriodFrom == this.parmProjPeriodFrom() &&
                    projControlPeriodCostGroup.Version == this.parmProjControlVersion() &&
                    projControlPeriodCostGroup.CostGroupId == projControlCategory.CostGroupId &&
                    projControlPeriodCostGroup.ctcMethod == _ctcMethod
            join projItemTransCost
                where projItemTransCost.InventTransId == projItemTrans.InventTransId
                    && projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId
                    && projItemTransCost.LedgerTransdate > this.parmProjPeriodTo()
                {
                    projTrans = ProjTrans::newProjItemTransCost(projItemTransCost);
                    this.insertTmp(projTrans,
                    0,
                    ProjControlActualCostType::Actual,
                    ProjControlActualRange::AfterPeriodEnd,
                    this.parmProjControlId(),
                    projTrans.itemId(),
                    ProjCostType::Item,
                    0);
                }
            }

            // Update temporary table  (All Trx before period end but not included in estimate - Handle BegBal, Reg)
            if(isContractLineUsed && contractLineBasedRevRecFeature)
            {
                while select RecId from projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == this.parmWIPProjId()
            join RecId from projItemTrans
                 where projItemTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum
            join RecId from projControlCategory
                where projControlCategory.ControlId == this.parmProjControlId() &&
                    projControlCategory.CategoryId == projItemTrans.CategoryId
            join  RecId from projControlPeriodCostGroup
                where projControlPeriodCostGroup.ProjId == this.parmWIPProjId() &&
                    projControlPeriodCostGroup.ControlId == projControlCategory.ControlId &&
                    projControlPeriodCostGroup.PeriodFrom == this.parmProjPeriodFrom() &&
                    projControlPeriodCostGroup.Version == this.parmProjControlVersion() &&
                    projControlPeriodCostGroup.CostGroupId == projControlCategory.CostGroupId &&
                    projControlPeriodCostGroup.ctcMethod == _ctcMethod
            join projItemTransCost
                where projItemTransCost.InventTransId == projItemTrans.InventTransId
                    && projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId
                    && projItemTransCost.LedgerTransdate <= this.parmProjPeriodTo()
                    && projItemTransCost.wipPeriod == dateNull()
                {
                    projTrans = ProjTrans::newProjItemTransCost(projItemTransCost);
                    this.insertTmp(projTrans,
                    0,
                    ProjControlActualCostType::Actual,
                    ProjControlActualRange::AfterPeriodEnd,
                    this.parmProjControlId(),
                    projTrans.itemId(),
                    ProjCostType::Item,
                    0);
                }
            }
            else
            {
                while select RecId from projTable
            where projTable.wipProject == this.parmWIPProjId()
            join RecId from projItemTrans
                where projItemTrans.ProjId == projTable.ProjId
            join RecId from projControlCategory
                where projControlCategory.ControlId == this.parmProjControlId() &&
                    projControlCategory.CategoryId == projItemTrans.CategoryId
            join  RecId from projControlPeriodCostGroup
                where projControlPeriodCostGroup.ProjId == projTable.wipProject &&
                    projControlPeriodCostGroup.ControlId == projControlCategory.ControlId &&
                    projControlPeriodCostGroup.PeriodFrom == this.parmProjPeriodFrom() &&
                    projControlPeriodCostGroup.Version == this.parmProjControlVersion() &&
                    projControlPeriodCostGroup.CostGroupId == projControlCategory.CostGroupId &&
                    projControlPeriodCostGroup.ctcMethod == _ctcMethod
            join projItemTransCost
                where projItemTransCost.InventTransId == projItemTrans.InventTransId
                    && projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId
                    && projItemTransCost.LedgerTransdate <= this.parmProjPeriodTo()
                    && projItemTransCost.wipPeriod == dateNull()
                {
                    projTrans = ProjTrans::newProjItemTransCost(projItemTransCost);
                    this.insertTmp(projTrans,
                    0,
                    ProjControlActualCostType::Actual,
                    ProjControlActualRange::AfterPeriodEnd,
                    this.parmProjControlId(),
                    projTrans.itemId(),
                    ProjCostType::Item,
                    0);
                }
            }
        }

        if (includeAfterPeriodEnd)
        {
            if (includeActual)
            {
                if (this.projParameters().AddActualPeriodEndToCTC)
                {
                    processActual(ProjControlPeriodCostGroupCTCMethod::RemainingEstimate);//Remaining budget
                }

                processActual(ProjControlPeriodCostGroupCTCMethod::TotalEstimate);//Total cost - Actual
            }

            if (includeCommitted)
            {
                if (this.projParameters().AddCommittedPeriodEndToCTC)
                {
                    processCommitted(ProjControlPeriodCostGroupCTCMethod::RemainingEstimate);//Remaining budget
                }

                processCommitted(ProjControlPeriodCostGroupCTCMethod::TotalEstimate);//Total cost - Actual
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCurrentPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Process project control for current period.
    /// </summary>
    private void processCurrentPeriod()
    {
        ProjTable                               projTable;
        CostControlTransCommittedCost           costControlTransCommittedCost;
        ProjControlCategory                     projControlCategory;
        ProjControlPeriodCostGroup              projControlPeriodCostGroup;
        ProjTrans                               projTrans;
        ProjCostType                            projCostType;
        
        void processCommitted(ProjControlPeriodCostGroupCTCMethod _ctcMethod)
        {
            if(!isContractLineUsed || !contractLineBasedRevRecFeature)
            {
                update_recordset costControlTransCommittedCost
                setting
                    wipPeriod = this.parmProjPeriodTo()
                where (! this.parmUseFromDate()
                   || (this.parmUseFromDate()
                   &&  costControlTransCommittedCost.CommittedDate    >= this.parmProjPeriodFrom()))
                   &&  costControlTransCommittedCost.CommittedDate    <= this.parmProjPeriodTo()
                   &&  !costControlTransCommittedCost.wipPeriod
                join RecId from projControlCategory
                    where projControlCategory.ControlId == this.parmProjControlId()
                      &&  projControlCategory.CategoryId == costControlTransCommittedCost.CategoryId
                join RecId from projControlPeriodCostGroup
                    where projControlPeriodCostGroup.ControlId == projControlCategory.ControlId &&
                          projControlPeriodCostGroup.PeriodFrom == this.parmProjPeriodFrom() &&
                          projControlPeriodCostGroup.Version == this.parmProjControlVersion() &&
                          projControlPeriodCostGroup.CostGroupId == projControlCategory.CostGroupId &&
                          projControlPeriodCostGroup.ctcMethod == _ctcMethod
                join RecId from projTable
                    where projTable.wipProject == this.parmWIPProjId()
                       && projTable.ProjId     == costControlTransCommittedCost.ProjId
                       && projTable.wipProject == projControlPeriodCostGroup.ProjId;
            }
        }

        if (includeCurrentPeriod)
        {
            if (includeActual)
            {
                this.updateWIPPeriodForTrans();
            }

            if (includeCommitted)
            {
                if (isContractLineUsed && contractLineBasedRevRecFeature)
                {
                    return;
                }
                // Update costControlTransCommittedCost
                if (updateWIPPeriod)
                {
                    CostControlTransCommittedCost::clearWIPPeriod(this.parmWIPProjId(), this.parmProjPeriodTo());

                    if (this.projParameters().AddCommittedToCTC)
                    {
                        processCommitted(ProjControlPeriodCostGroupCTCMethod::RemainingEstimate);//Remaining budget
                    }
                    processCommitted(ProjControlPeriodCostGroupCTCMethod::TotalEstimate);//Total cost - Actual
                }

                // Update temporary table
                while select RecId from projTable
                where projTable.wipProject == this.parmWIPProjId()
                    join costControlTransCommittedCost
                      where costControlTransCommittedCost.ProjId        == projTable.ProjId
                      &&   (! this.parmUseFromDate() ||
                             (this.parmUseFromDate() &&
                              costControlTransCommittedCost.CommittedDate    >= this.parmProjPeriodFrom()))
                      &&   costControlTransCommittedCost.wipPeriod
                      &&   costControlTransCommittedCost.wipPeriod     <= this.parmProjPeriodTo()
                {
                    projTrans = ProjTrans::newCostControlTransCommittedCost(costControlTransCommittedCost);
                    projCostType = this.getProjCostType(projTrans);
                    this.insertTmp(projTrans,
						costControlTransCommittedCost.RecId,
						ProjControlActualCostType::Committed,
						ProjControlActualRange::CurrentPeriod,
						this.parmProjControlId(),
						projTrans.itemId(),
						projCostType,
						projTrans.resource());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>projParameters</Name>
				<Source><![CDATA[
    private ProjParameters projParameters()
    {
        if (!projParameters)
        {
            projParameters = ProjParameters::find();
        }

        return projParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reversal</Name>
				<Source><![CDATA[
    private boolean reversal(boolean _reversal = reversal)
    {
        reversal = _reversal;

        return reversal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        ttsbegin;

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            logger = ProjRevRecInstrumentationLogger::createLogger(classStr(ProjControlActual));
        }
        else
        {
            logger = ProjRevRecInstrumentationLogger::createLogger(classStr(ProjControlActual));
        }

        this.processCurrentPeriod();

        this.processAfterPeriodEnd();
        
        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            using (var activityContext = logger.revRecActivity().postContractLineBasedRevRec())
            {
                logger.logInformation(strFmt(@"ProjControlActual::%7 done for
                ProjectId: %1,
                ContractLineNum: %2,
                TransId: %3
                Voucher: %4
                costamount: %5
                costprice: %6",
                projWipId,
                tmpProjControlActual.ContractLineNum,
                tmpProjControlActual.TransId,
                tmpProjControlActual.Voucher,
                tmpProjControlActualCost.costAmount,
                tmpProjControlActualCost.CostPrice,
                ProjRevRecInstrumentationActivities::ContractLineBasedRevRec));
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpProjControlActual</Name>
				<Source><![CDATA[
    public TmpProjControlActual    tmpProjControlActual()
    {
        return tmpProjControlActual;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpProjControlActualCost</Name>
				<Source><![CDATA[
    public TmpProjControlActualCost    tmpProjControlActualCost()
    {
        return tmpProjControlActualCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTmpTable</Name>
				<Source><![CDATA[
    private void updateTmpTable()
    {
        ProjLineProperty        lineProperty;
        ProjControlCategory     controlCategory;
        ProjControl             controlType;

        // Update Capitalize Amount
        update_recordset tmpProjControlActualCost
    setting Capitalize = tmpProjControlActualCost.CostAmount
        where tmpProjControlActualCost.LedgerStatusCost != ProjLedgerStatus::Never
    exists join firstonly tmpProjControlActual
        where tmpProjControlActual.RecId    == tmpProjControlActualCost.RefRecID
    exists join firstonly lineProperty
        where lineProperty.LinePropertyId == tmpProjControlActual.LinePropertyId
           && lineProperty.ToBeCapitalize;

        // Update costgroupid
        update_recordset tmpProjControlActual
    setting CostGroupId      = controlCategory.CostGroupId
    join firstonly CostGroupId from controlCategory
        where controlCategory.ControlId  == this.parmProjControlId()
           && controlCategory.CategoryId == tmpProjControlActual.CategoryId;

        // Handling remaining cases where ProjControl.costGroupId is used

        controlType = ProjControl::find(this.parmProjControlId());

        update_recordset tmpProjControlActual
    setting CostGroupId      = controlType.CostGroupHourId
        where tmpProjControlActual.CostType    == ProjCostType::Hour
           && !tmpProjControlActual.CostGroupId;

        update_recordset tmpProjControlActual
    setting CostGroupId      = controlType.CostGroupCostId
        where tmpProjControlActual.CostType    == ProjCostType::Cost
           && !tmpProjControlActual.CostGroupId;

        update_recordset tmpProjControlActual
    setting CostGroupId      = controlType.CostGroupItemId
        where tmpProjControlActual.CostType    == ProjCostType::Item
           && !tmpProjControlActual.CostGroupId;

        // Update the cost price for item transactions
        update_recordset tmpProjControlActualCost
    setting CostPrice = tmpProjControlActualCost.CostAmount/tmpProjControlActual.Qty
    join firstonly Qty from tmpProjControlActual
        where tmpProjControlActual.RecId    == tmpProjControlActualCost.RefRecID
           && tmpProjControlActual.CostType == ProjCostType::Item
           && tmpProjControlActual.Qty != 0;

        // Handling reversal scenario for updating quantity and cost amount
        if (reversal)
        {
            update_recordset tmpProjControlActual
            setting Qty = tmpProjControlActual.Qty * this.factor();

            update_recordset tmpProjControlActualCost
            setting CostAmount = tmpProjControlActualCost.CostAmount * this.factor();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWIPPeriodForTrans</Name>
				<Source><![CDATA[
    private void updateWIPPeriodForTrans()
    {
        ProjTable  projTable;
        ProjEmplTrans projEmplTrans;
        ProjEmplTransCost projEmplTransCost;
        ProjCostTrans projCostTrans;
        ProjCostTransCost projCostTransCost;
        ProjItemTrans  projItemTrans;
        ProjItemTransCost projItemTransCost;
        PSAContractLineItems contractLine;
        ProjRevRecContractLine projRevRecContractLine;

        boolean useBegBal = this.parmBeginningBalance() == NoYes::Yes;
        boolean multipleContractLinesFeatureEnabled = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();

        // Update projEmplTrans
        if (updateWIPPeriod)
        {
            if (multipleContractLinesFeatureEnabled)
            {
                if(isContractLineUsed && contractLineBasedRevRecFeature)
                {
                    update_recordset projEmplTransCost
                setting
                    wipPeriod   = this.parmProjPeriodTo(),
                    TransStatus = ProjTransStatus::Estimated
                where projEmplTransCost.TransStatus  == ProjTransStatus::Posted
                   && (! this.parmUseFromDate()
                   || (this.parmUseFromDate()
                   && projEmplTransCost.LedgerTransdate    >= this.parmProjPeriodFrom()))
                   && projEmplTransCost.LedgerTransdate    <= this.parmProjPeriodTo()
                   && !projEmplTransCost.wipPeriod
                exists join projEmplTrans
                    where projEmplTrans.TransId == projEmplTransCost.TransId
                        && ((useBegBal && projEmplTrans.TransactionOrigin == ProjOrigin::BeginningBalance)
                        || (!useBegBal && ProjEmplTrans.TransactionOrigin != ProjOrigin::BeginningBalance))
                exists join contractLine
                    where contractLine.ContractLineNum == projEmplTrans.PSAContractLineNum
                        && contractLine.IncludeHourTrans == NoYes::Yes
                        && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice
                exists join projRevRecContractLine
                    where projRevRecContractLine.RevenueRecognitionId == this.parmWIPProjId()
                    && projRevRecContractLine.ContractLineNum == contractLine.ContractLineNum;
                }
                else
                {
                    update_recordset projEmplTransCost
                setting
                    wipPeriod   = this.parmProjPeriodTo(),
                    TransStatus = ProjTransStatus::Estimated
                where projEmplTransCost.TransStatus  == ProjTransStatus::Posted
                   && (! this.parmUseFromDate()
                   || (this.parmUseFromDate()
                   && projEmplTransCost.LedgerTransdate    >= this.parmProjPeriodFrom()))
                   && projEmplTransCost.LedgerTransdate    <= this.parmProjPeriodTo()
                   && !projEmplTransCost.wipPeriod
                exists join projEmplTrans
                    where projEmplTrans.TransId == projEmplTransCost.TransId
                        && ((useBegBal && projEmplTrans.TransactionOrigin == ProjOrigin::BeginningBalance)
                        || (!useBegBal && ProjEmplTrans.TransactionOrigin != ProjOrigin::BeginningBalance))
                exists join projTable
                    where projTable.ProjId    == projEmplTrans.ProjId
                       && projTable.wipProject == this.parmWIPProjId()
                exists join contractLine
                    where contractLine.ContractLineNum == projEmplTrans.PSAContractLineNum
                        && contractLine.IncludeHourTrans == NoYes::Yes
                        && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice;
                }
            }
            else
            {
                if(isContractLineUsed && contractLineBasedRevRecFeature)
                {
                    update_recordset projEmplTransCost
                setting
                    wipPeriod   = this.parmProjPeriodTo(),
                    TransStatus = ProjTransStatus::Estimated
                where projEmplTransCost.TransStatus  == ProjTransStatus::Posted
                   && (! this.parmUseFromDate()
                   || (this.parmUseFromDate()
                   && projEmplTransCost.LedgerTransdate    >= this.parmProjPeriodFrom()))
                   && projEmplTransCost.LedgerTransdate    <= this.parmProjPeriodTo()
                   && !projEmplTransCost.wipPeriod
                exists join projEmplTrans
                    where projEmplTrans.TransId == projEmplTransCost.TransId
                        && ((useBegBal && projEmplTrans.TransactionOrigin == ProjOrigin::BeginningBalance)
                        || (!useBegBal && ProjEmplTrans.TransactionOrigin != ProjOrigin::BeginningBalance))
                exists join projRevRecContractLine
                    where projRevRecContractLine.RevenueRecognitionId == this.parmWIPProjId()
                    && projRevRecContractLine.ContractLineNum == projEmplTrans.PSAContractLineNum;
                }
                else
                {
                    update_recordset projEmplTransCost
                setting
                    wipPeriod   = this.parmProjPeriodTo(),
                    TransStatus = ProjTransStatus::Estimated
                where projEmplTransCost.TransStatus  == ProjTransStatus::Posted
                   && (! this.parmUseFromDate()
                   || (this.parmUseFromDate()
                   && projEmplTransCost.LedgerTransdate    >= this.parmProjPeriodFrom()))
                   && projEmplTransCost.LedgerTransdate    <= this.parmProjPeriodTo()
                   && !projEmplTransCost.wipPeriod
                exists join projEmplTrans
                    where projEmplTrans.TransId == projEmplTransCost.TransId
                        && ((useBegBal && projEmplTrans.TransactionOrigin == ProjOrigin::BeginningBalance)
                        || (!useBegBal && ProjEmplTrans.TransactionOrigin != ProjOrigin::BeginningBalance))
                exists join projTable
                    where projTable.ProjId    == projEmplTrans.ProjId
                       && projTable.wipProject == this.parmWIPProjId();
                }
            }
        }

        this.insertHourTmp();

        // Update ProjCostTrans
        if (updateWIPPeriod)
        {
            if (multipleContractLinesFeatureEnabled)
            {
                if(isContractLineUsed && contractLineBasedRevRecFeature)
                {
                    update_recordset projCostTransCost
                setting
                    wipPeriod   = this.parmProjPeriodTo(),
                    TransStatus = ProjTransStatus::Estimated
                where projCostTransCost.TransStatus  == ProjTransStatus::Posted
                   && (! this.parmUseFromDate()
                   || (this.parmUseFromDate()
                   && projCostTransCost.LedgerTransdate    >= this.parmProjPeriodFrom()))
                   && projCostTransCost.LedgerTransdate    <= this.parmProjPeriodTo()
                   && !projCostTransCost.wipPeriod
                exists join projCostTrans
                    where projCostTrans.TransId == projCostTransCost.TransId
                       && projCostTrans.TransactionOrigin != ProjOrigin::EstimateAccruedLoss
                        && ((useBegBal && projCostTrans.TransactionOrigin == ProjOrigin::BeginningBalance)
                        || (!useBegBal && ProjCostTrans.TransactionOrigin != ProjOrigin::BeginningBalance))
                exists join contractLine
                    where contractLine.ContractLineNum == projCostTrans.PSAContractLineNum
                        && contractLine.IncludeExpenseTrans == NoYes::Yes
                        && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice
                exists join projRevRecContractLine
                    where projRevRecContractLine.RevenueRecognitionId == this.parmWIPProjId()
                    && projRevRecContractLine.ContractLineNum == contractLine.ContractLineNum;
                }
                else
                {
                    update_recordset projCostTransCost
                setting
                    wipPeriod   = this.parmProjPeriodTo(),
                    TransStatus = ProjTransStatus::Estimated
                where projCostTransCost.TransStatus  == ProjTransStatus::Posted
                   && (! this.parmUseFromDate()
                   || (this.parmUseFromDate()
                   && projCostTransCost.LedgerTransdate    >= this.parmProjPeriodFrom()))
                   && projCostTransCost.LedgerTransdate    <= this.parmProjPeriodTo()
                   && !projCostTransCost.wipPeriod
                exists join projCostTrans
                    where projCostTrans.TransId == projCostTransCost.TransId
                       && projCostTrans.TransactionOrigin != ProjOrigin::EstimateAccruedLoss
                        && ((useBegBal && projCostTrans.TransactionOrigin == ProjOrigin::BeginningBalance)
                        || (!useBegBal && ProjCostTrans.TransactionOrigin != ProjOrigin::BeginningBalance))
                exists join projTable
                    where projTable.ProjId    == projCostTrans.ProjId
                       && projTable.wipProject == this.parmWIPProjId()
                exists join contractLine
                    where contractLine.ContractLineNum == projCostTrans.PSAContractLineNum
                        && contractLine.IncludeExpenseTrans == NoYes::Yes
                        && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice;
                }
            }
            else
            {
                if(isContractLineUsed && contractLineBasedRevRecFeature)
                {
                    update_recordset projCostTransCost
                setting
                    wipPeriod   = this.parmProjPeriodTo(),
                    TransStatus = ProjTransStatus::Estimated
                where projCostTransCost.TransStatus  == ProjTransStatus::Posted
                   && (! this.parmUseFromDate()
                   || (this.parmUseFromDate()
                   && projCostTransCost.LedgerTransdate    >= this.parmProjPeriodFrom()))
                   && projCostTransCost.LedgerTransdate    <= this.parmProjPeriodTo()
                   && !projCostTransCost.wipPeriod
                exists join projCostTrans
                    where projCostTrans.TransId == projCostTransCost.TransId
                       && projCostTrans.TransactionOrigin != ProjOrigin::EstimateAccruedLoss
                        && ((useBegBal && projCostTrans.TransactionOrigin == ProjOrigin::BeginningBalance)
                        || (!useBegBal && ProjCostTrans.TransactionOrigin != ProjOrigin::BeginningBalance))
                exists join projRevRecContractLine
                    where projRevRecContractLine.RevenueRecognitionId == this.parmWIPProjId()
                    && projRevRecContractLine.ContractLineNum == projCostTrans.PSAContractLineNum;
                }
                else
                {
                    update_recordset projCostTransCost
                setting
                    wipPeriod   = this.parmProjPeriodTo(),
                    TransStatus = ProjTransStatus::Estimated
                where projCostTransCost.TransStatus  == ProjTransStatus::Posted
                   && (! this.parmUseFromDate()
                   || (this.parmUseFromDate()
                   && projCostTransCost.LedgerTransdate    >= this.parmProjPeriodFrom()))
                   && projCostTransCost.LedgerTransdate    <= this.parmProjPeriodTo()
                   && !projCostTransCost.wipPeriod
                exists join projCostTrans
                    where projCostTrans.TransId == projCostTransCost.TransId
                       && projCostTrans.TransactionOrigin != ProjOrigin::EstimateAccruedLoss
                        && ((useBegBal && projCostTrans.TransactionOrigin == ProjOrigin::BeginningBalance)
                        || (!useBegBal && ProjCostTrans.TransactionOrigin != ProjOrigin::BeginningBalance))
                exists join projTable
                    where projTable.ProjId    == projCostTrans.ProjId
                       && projTable.wipProject == this.parmWIPProjId();
                }
            }
        }

        this.insertCostTmp();

        // Update ProjItemTrans
        if (updateWIPPeriod)
        {
            if (multipleContractLinesFeatureEnabled)
            {
                if(isContractLineUsed && contractLineBasedRevRecFeature)
                {
                    update_recordset projItemTransCost
                setting
                    wipPeriod   = this.parmProjPeriodTo(),
                    TransStatus = ProjTransStatus::Estimated
                where projItemTransCost.TransStatus  == ProjTransStatus::Posted
                   && (! this.parmUseFromDate()
                   || (this.parmUseFromDate()
                   && projItemTransCost.LedgerTransdate    >= this.parmProjPeriodFrom()))
                   && projItemTransCost.LedgerTransdate    <= this.parmProjPeriodTo()
                   && !projItemTransCost.wipPeriod
                exists join projItemTrans
                    where projItemTrans.InventTransId == projItemTransCost.InventTransId
                       && projItemTrans.ProjAdjustRefId == projItemTransCost.ProjAdjustRefId
                        && ((useBegBal && projItemTrans.TransactionOrigin == ProjOrigin::BeginningBalance)
                        || (!useBegBal && ProjItemTrans.TransactionOrigin != ProjOrigin::BeginningBalance))
                exists join contractLine
                    where contractLine.ContractLineNum == projItemTrans.PSAContractLineNum
                        && contractLine.IncludeItemTrans == NoYes::Yes
                        && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice
                exists join projRevRecContractLine
                    where projRevRecContractLine.RevenueRecognitionId == this.parmWIPProjId()
                    && projRevRecContractLine.ContractLineNum == contractLine.ContractLineNum;
                }
                else
                {
                    update_recordset projItemTransCost
                setting
                    wipPeriod   = this.parmProjPeriodTo(),
                    TransStatus = ProjTransStatus::Estimated
                where projItemTransCost.TransStatus  == ProjTransStatus::Posted
                   && (! this.parmUseFromDate()
                   || (this.parmUseFromDate()
                   && projItemTransCost.LedgerTransdate    >= this.parmProjPeriodFrom()))
                   && projItemTransCost.LedgerTransdate    <= this.parmProjPeriodTo()
                   && !projItemTransCost.wipPeriod
                exists join projItemTrans
                    where projItemTrans.InventTransId == projItemTransCost.InventTransId
                       && projItemTrans.ProjAdjustRefId == projItemTransCost.ProjAdjustRefId
                        && ((useBegBal && projItemTrans.TransactionOrigin == ProjOrigin::BeginningBalance)
                        || (!useBegBal && ProjItemTrans.TransactionOrigin != ProjOrigin::BeginningBalance))
                exists join projTable
                    where projTable.wipProject == this.parmWIPProjId()
                       && projTable.ProjId     == projItemTrans.ProjId
                exists join contractLine
                    where contractLine.ContractLineNum == projItemTrans.PSAContractLineNum
                        && contractLine.IncludeItemTrans == NoYes::Yes
                        && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice;
                }
            }
            else
            {
                if(isContractLineUsed && contractLineBasedRevRecFeature)
                {
                    update_recordset projItemTransCost
                setting
                    wipPeriod   = this.parmProjPeriodTo(),
                    TransStatus = ProjTransStatus::Estimated
                where projItemTransCost.TransStatus  == ProjTransStatus::Posted
                   && (! this.parmUseFromDate()
                   || (this.parmUseFromDate()
                   && projItemTransCost.LedgerTransdate    >= this.parmProjPeriodFrom()))
                   && projItemTransCost.LedgerTransdate    <= this.parmProjPeriodTo()
                   && !projItemTransCost.wipPeriod
                exists join projItemTrans
                    where projItemTrans.InventTransId == projItemTransCost.InventTransId
                       && projItemTrans.ProjAdjustRefId == projItemTransCost.ProjAdjustRefId
                        && ((useBegBal && projItemTrans.TransactionOrigin == ProjOrigin::BeginningBalance)
                        || (!useBegBal && ProjItemTrans.TransactionOrigin != ProjOrigin::BeginningBalance))
                exists join projRevRecContractLine
                    where projRevRecContractLine.RevenueRecognitionId == this.parmWIPProjId()
                    && projRevRecContractLine.ContractLineNum == projItemTrans.PSAContractLineNum;
                }
                else
                {
                    update_recordset projItemTransCost
                setting
                    wipPeriod   = this.parmProjPeriodTo(),
                    TransStatus = ProjTransStatus::Estimated
                where projItemTransCost.TransStatus  == ProjTransStatus::Posted
                   && (! this.parmUseFromDate()
                   || (this.parmUseFromDate()
                   && projItemTransCost.LedgerTransdate    >= this.parmProjPeriodFrom()))
                   && projItemTransCost.LedgerTransdate    <= this.parmProjPeriodTo()
                   && !projItemTransCost.wipPeriod
                exists join projItemTrans
                    where projItemTrans.InventTransId == projItemTransCost.InventTransId
                       && projItemTrans.ProjAdjustRefId == projItemTransCost.ProjAdjustRefId
                        && ((useBegBal && projItemTrans.TransactionOrigin == ProjOrigin::BeginningBalance)
                        || (!useBegBal && ProjItemTrans.TransactionOrigin != ProjOrigin::BeginningBalance))
                exists join projTable
                    where projTable.wipProject == this.parmWIPProjId()
                       && projTable.ProjId     == projItemTrans.ProjId;
                }
            }
        }

        this.insertItemTmp();
        this.updateTmpTable();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>