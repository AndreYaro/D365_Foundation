<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjYearEndProcess</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>ProjYearEndProcess</c> class implements all the required year-end processing methods that
/// carry forward the remaining project budget.
/// </summary>
public class ProjYearEndProcess extends RunBaseBatch implements BatchRetryable
{
    boolean                 carryForward;
    boolean                 adjustGL;
    FiscalCalendarID        fiscalCalendarID;
    FiscalYearName          fiscalYearName;
    PeriodName              fiscalCalendarPeriodName;
    FiscalYearName          projfiscalYearName;
    boolean                 salesCurrency;
    NoYesId                 showZeroRemaining;
    ForecastModelId         fromForecastModel;
    BudgetModelHeadId       toForecastModel;
    NoYesId                 includeProfitAndloss;
    NoYesId                 includeWIP;
    NoYesId                 includePayrollAllocation;

    List                    selectedProjBudgetLine;

    private ProjOpsFinancialsLogger logger;
    private const str LoggerErrorMessage = 'Error found during Project budget carry-forward process: %1';

    #define.CurrentVersion(1)
    #localmacro.CurrentList
        carryForward,
        adjustGL,
        fiscalCalendarID,
        fiscalYearName,
        fiscalCalendarPeriodName,
        projfiscalYearName,
        salesCurrency,
        showZeroRemaining,
        fromForecastModel,
        toForecastModel,
        includeProfitAndloss,
        includeWIP,
        includePayrollAllocation
    #endmacro
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canGoBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the class can be executed in batch.
    /// </summary>
    /// <returns>
    /// Always returns false.
    /// </returns>
    /// <remarks>
    /// This method is an overridden method of the <c>RunBaseBatch</c> class.
    /// </remarks>
    public boolean canGoBatch()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an instance of custom parameters form for the batch process.
    /// </summary>
    /// <returns>
    /// Returns an instance of the <c>ProjYearEndProcess</c> form.
    /// </returns>
    public Object dialog()
    {
        Args    args;
        FormRun formRun;

        args = new Args();
        args.name(formStr(ProjYearEndProcess));
        args.caller(this);

        formRun = ClassFactory::formRunClassOnClient(args);
        formRun.init();

        return formRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new instance of the class.
    /// </summary>
    protected void new()
    {
        super();
        logger = ProjOpsFinancialsLogger::createLogger(classStr(ProjBudgetTransactionLine));
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container packedContainer = [#CurrentVersion, #CurrentList];

        return packedContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdjustGL</Name>
				<Source><![CDATA[
    public boolean parmAdjustGL(boolean _adjustGL = adjustGL)
    {
        adjustGL = _adjustGL;

        return adjustGL;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCarryForward</Name>
				<Source><![CDATA[
    public boolean parmCarryForward(boolean _carryForward = carryForward)
    {
        carryForward = _carryForward;

        return carryForward;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFiscalCalendarID</Name>
				<Source><![CDATA[
    public FiscalCalendarID parmFiscalCalendarID(FiscalCalendarID _fiscalCalendarID = fiscalCalendarID)
    {
        fiscalCalendarID = _fiscalCalendarID;

        return fiscalCalendarID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFiscalCalendarPeriod</Name>
				<Source><![CDATA[
    public PeriodName parmFiscalCalendarPeriod(PeriodName   _fiscalCalendarPeriod = fiscalCalendarPeriodName)
    {
        fiscalCalendarPeriodName = _fiscalCalendarPeriod;

        return fiscalCalendarPeriodName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFiscalYearName</Name>
				<Source><![CDATA[
    public FiscalYearName parmFiscalYearName(FiscalYearName _fiscalYearName = fiscalYearName)
    {
        fiscalYearName = _fiscalYearName;

        return fiscalYearName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFromForecastModel</Name>
				<Source><![CDATA[
    public ForecastModelId parmFromForecastModel(ForecastModelId _fromForecastModel = fromForecastModel)
    {
        fromForecastModel  = _fromForecastModel;

        return fromForecastModel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludePayrollAllocation</Name>
				<Source><![CDATA[
    public boolean parmIncludePayrollAllocation(boolean _includePayrollAllocation = includePayrollAllocation)
    {
        includePayrollAllocation  = _includePayrollAllocation;

        return includePayrollAllocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeProfitAndloss</Name>
				<Source><![CDATA[
    public boolean parmIncludeProfitAndloss(boolean _includeProfitAndloss = includeProfitAndloss)
    {
        includeProfitAndloss  = _includeProfitAndloss;

        return includeProfitAndloss;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeWIP</Name>
				<Source><![CDATA[
    public boolean parmIncludeWIP(boolean _includeWIP = includeWIP)
    {
        includeWIP  = _includeWIP;

        return includeWIP;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjFiscalYearName</Name>
				<Source><![CDATA[
    public FiscalYearName parmProjFiscalYearName(FiscalYearName _projfiscalYearName = projfiscalYearName)
    {
        projfiscalYearName = _projfiscalYearName;

        return projfiscalYearName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesCurrency</Name>
				<Source><![CDATA[
    public boolean parmSalesCurrency(boolean _salesCurrency = salesCurrency)
    {
        salesCurrency = _salesCurrency;

        return salesCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSelectedProjBudgetLine</Name>
				<Source><![CDATA[
    public List parmSelectedProjBudgetLine(List _selectedProjBudgetLine = selectedProjBudgetLine)
    {
        selectedProjBudgetLine = _selectedProjBudgetLine;
        return selectedProjBudgetLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowZeroRemaining</Name>
				<Source><![CDATA[
    public NoYesId parmShowZeroRemaining(NoYesId    _showZeroRemaining = showZeroRemaining)
    {
        showZeroRemaining = _showZeroRemaining;

        return showZeroRemaining;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmToForecastModel</Name>
				<Source><![CDATA[
    public BudgetModelHeadId parmToForecastModel(BudgetModelHeadId _toForecastModel = toForecastModel)
    {
        toForecastModel  = _toForecastModel;

        return toForecastModel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        ProjBudgetLine                      projBudgetLine;
        ProjBudgetAllocationLine            projBudgetAllocationLine;
        boolean                             isAllocationRecordUpdated;
        boolean                             isNegativeBudgetAmount;
        Enumerator                          listEnumerator;
        ProjId                              projId;
        ProjBudgetLine                      projBudgetLineLocal;
        FiscalCalendarPeriod                fiscalCalendarPeriod;
        FiscalCalendarYearRecId             projfiscalYearRecId = FiscalCalendarYear::findByCalendarYearName(Ledger::fiscalCalendar(CompanyInfo::current()), projfiscalYearName).RecId;

        ProjForecastBudgetTransferToLedger  projForeBudTransToLed;
        PeriodDate                          periodStartDate;
        TransactionID                       transId;
        ProjCostSales                       projCostSales;
        ProjTransBudget                     projTransBudgetLocal;
        List                                listTransId;
        ForecastModel                       forecastModel;

        listEnumerator = selectedProjBudgetLine.getEnumerator();

        super();

        periodStartDate = FiscalCalendarPeriod::findByCalendarYearPeriod(FiscalCalendarYear::findByCalendarYearName(
                                                                                    Ledger::fiscalCalendar(CompanyInfo::current()),
                                                                                    fiscalYearName).RecId,
                                                                                    fiscalCalendarPeriodName).StartDate;
        ttsbegin;
        while (listEnumerator.moveNext())
        {
            projBudgetLine              = listEnumerator.current();
            projBudgetLineLocal         = ProjBudgetLine::find(projBudgetLine.RecId);
            projId = ProjBudget::find(projBudgetLineLocal.ProjBudget).RootProjId;

            select sum(TotalAllocationAmount), sum(ReductionAmount) from projBudgetAllocationLine
                where projBudgetAllocationLine.ProjBudgetLine == projBudgetLine.RecId  &&
                    (projBudgetAllocationLine.FiscalCalendarYear == projfiscalYearRecId || projBudgetAllocationLine.FiscalCalendarPeriod != 0)
            notexists join RecId, FiscalCalendarYear from  fiscalCalendarPeriod
                where projBudgetAllocationLine.FiscalCalendarPeriod == fiscalCalendarPeriod.RecId &&
                    fiscalCalendarPeriod.FiscalCalendarYear != projfiscalYearRecId;

            isAllocationRecordUpdated = this.updateProjBudgetAllocationLine(projId, projBudgetLineLocal,
                                                                            projBudgetAllocationLine.TotalAllocationAmount,
                                                                            projBudgetAllocationLine.ReductionAmount);

            if (isAllocationRecordUpdated)
            {
                transId = ProjYearEndProcess::createForecastRecord(
                                                    projBudgetLineLocal,
                                                    periodStartDate,
                                                    (projBudgetAllocationLine.TotalAllocationAmount - projBudgetAllocationLine.ReductionAmount));

                if (adjustGL)
                {
                    if (!listTransId)
                    {
                        listTransId = new List(Types::Container);
                    }

                    projCostSales = projBudgetLineLocal.ProjBudgetLineType == ProjBudgetLineType::Cost ? ProjCostSales::Cost : ProjCostSales::Sales;
                    listTransId.addEnd([transId, projCostSales]);
                }
            }
            else
            {
                isNegativeBudgetAmount = true;
            }
        }

        if (isNegativeBudgetAmount)
        {
            warning("@SYS333760");
        }

        if (adjustGL && listTransId && listTransId.elements())
        {
            select firstonly ModelId from forecastModel
                where forecastModel.ProjBudgetType == ProjBudgetType::CarryForward;

            projForeBudTransToLed = new ProjForecastBudgetTransferToLedger();
            projForeBudTransToLed.parmBudgetTransactionHeaderDate(periodStartDate);
            projForeBudTransToLed.parmSalesCurrency(salesCurrency);
            projForeBudTransToLed.parmFromForecastModel(forecastModel.ModelId);
            projForeBudTransToLed.parmToForecastModel(toForecastModel);
            projForeBudTransToLed.parmIncludeProfitAndloss(includeProfitAndloss);
            projForeBudTransToLed.parmIncludeWIP(includeWIP);
            projForeBudTransToLed.parmPayrollAllocation(includePayrollAllocation);
            projForeBudTransToLed.queryRanges();

            listEnumerator = listTransId.getEnumerator();
            while (listEnumerator.moveNext())
            {
                [transId, projCostSales] = listEnumerator.current();
                while select RecId from projTransBudgetLocal
                    where projTransBudgetLocal.TransId == transId &&
                        projTransBudgetLocal.CostSales == projCostSales
                {
                    projForeBudTransToLed.setRange(tableNum(ProjTransBudget), fieldNum(ProjTransBudget, RecId), SysQuery::value(projTransBudgetLocal.RecId), RangeStatus::Locked, false);
                }
            }

            if (projForeBudTransToLed.validate())
            {
                projForeBudTransToLed.runOperation();
            }
            else
            {
                throw error("@SYS329830");
            }
        }

        ttscommit;
        info("@SYS328437");
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Integer         version         = RunBase::getVersion(packedClass);
        boolean         ret = true;

        switch (version)
        {
            case #CurrentVersion:
                [version,#CurrentList] = packedClass;

                break;
            default:
                ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjBudgetAllocationLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>ProjBudgetAllocationLine</c> records.
    /// </summary>
    /// <param name="_projId">
    /// The project ID of the project to use to determine whether the project is valid for the process.
    /// </param>
    /// <param name="_projBudgetLine">
    /// The project budget line record for which the <c>ProjBudgetAllocationLine</c> records are updated.
    /// </param>
    /// <param name="_totalAmount">
    /// A <c>AmountCur</c> value that determines the total amount of the <c>ProjBudgetAllocationLine</c>
    /// records.
    /// </param>
    /// <param name="_reductionAmount">
    /// A <c>AmountCur</c> value that determines the reduction amount of the
    /// <c>ProjBudgetAllocationLine</c> records.
    /// </param>
    /// <returns>
    /// true if a record is updated; otherwise, false.
    /// </returns>
    public boolean updateProjBudgetAllocationLine(
        ProjId          _projId,
        ProjBudgetLine  _projBudgetLine,
        AmountCur       _totalAmount,
        AmountCur       _reductionAmount
    )
    {
        ProjBudgetAllocationLine    projBudgetAllocationLine;
        FiscalCalendarPeriod        fiscalCalendarPeriod;
        FiscalCalendarYearRecId     fiscalYearRecId;
        FiscalCalendarPeriodRecId   fiscalPeriodRecId;
        RefRecId                    projBudgetAllocationLineRecId;
        boolean                     ret;

        FiscalCalendarRecId         fiscalCalendarRecId = Ledger::fiscalCalendar(CompanyInfo::current());
        AmountCur                   remainingAmount = _totalAmount - _reductionAmount;
        boolean                     isForwardNegativeBudgetAllowed = ProjTable::find(_projId).ProjCarryForwardNegativeBudget;

        ///gets the Fiscal Calendar Year Record ID based on fiscal year name.
        RefRecId getFiscalYearRecId(FiscalYearName _fiscalYearName)
        {
            fiscalYearRecId = FiscalCalendarYear::findByCalendarYearName(fiscalCalendarRecId, _fiscalYearName).RecId;

            return fiscalYearRecId;
        }

        ///inserts or update the Project budget allocation line record.
        void updateBudgetAllocationLineRecord()
        {
            projBudgetAllocationLine.ProjBudgetLine = _projBudgetLine.RecId;
            projBudgetAllocationLine.TotalAllocationAmount += remainingAmount;
            if (!projBudgetAllocationLine)
            {
                projBudgetAllocationLine.insert();
            }
            else
            {
                projBudgetAllocationLine.update();
            }

            ret = true;
        }

        if ((remainingAmount == 0) || (remainingAmount < 0 && !isForwardNegativeBudgetAllowed))
        {
            return false;
        }

        ttsbegin;

        ///checking the case of allocation method of the project budget line.
        ///record in project budget allocation method is updated with the current allocation method type.
        switch (_projBudgetLine.ProjAllocationMethod)
        {
            case ProjAllocationMethod::Periods :
                    fiscalPeriodRecId = LedgerFiscalCalendar::findFirstOpenPeriodInYear(fiscalCalendarRecId,
                                                        FiscalCalendarYear::findByCalendarYearName(fiscalCalendarRecId,
                                                        fiscalYearName).StartDate).RecId;

                    if (fiscalPeriodRecId)
                    {
                        select forupdate firstonly projBudgetAllocationLine
                                where projBudgetAllocationLine.ProjBudgetLine == _projBudgetLine.RecId &&
                                        projBudgetAllocationLine.FiscalCalendarPeriod == fiscalPeriodRecId;

                        projBudgetAllocationLine.FiscalCalendarPeriod = fiscalPeriodRecId;
                        updateBudgetAllocationLineRecord();
                    }
                    break;

            case ProjAllocationMethod::Quarter :
                if (getFiscalYearRecId(fiscalYearName))
                {
                    select forupdate firstonly projBudgetAllocationLine
                            where projBudgetAllocationLine.ProjBudgetLine == _projBudgetLine.RecId &&
                                    projBudgetAllocationLine.Quarter == FiscalQuarter::Q1 &&
                                    projBudgetAllocationLine.FiscalCalendarYear == getFiscalYearRecId(fiscalYearName);

                    projBudgetAllocationLine.Quarter = FiscalQuarter::Q1;
                    projBudgetAllocationLine.FiscalCalendarYear = getFiscalYearRecId(fiscalYearName);
                    updateBudgetAllocationLineRecord();
                }
                break;

            case ProjAllocationMethod::Yearly :
                if (getFiscalYearRecId(fiscalYearName))
                {
                        select forupdate firstonly projBudgetAllocationLine
                                where projBudgetAllocationLine.ProjBudgetLine == _projBudgetLine.RecId &&
                                        projBudgetAllocationLine.FiscalCalendarYear == getFiscalYearRecId(fiscalYearName);

                        projBudgetAllocationLine.FiscalCalendarYear = getFiscalYearRecId(fiscalYearName);
                    updateBudgetAllocationLineRecord();
                }
                break;
        }

        if (ret)
        {
            projBudgetAllocationLineRecId = projBudgetAllocationLine.RecId;

            ///updates the total allocation amount field value to make the remaining amount zero for the project year selected.
            projBudgetAllocationLine.clear();

            while select forupdate projBudgetAllocationLine
                where projBudgetAllocationLine.ProjBudgetLine == _projBudgetLine.RecId &&
                    ((projBudgetAllocationLine.TotalAllocationAmount - projBudgetAllocationLine.ReductionAmount) != 0) &&
                    (projBudgetAllocationLine.FiscalCalendarYear == getFiscalYearRecId(projfiscalYearName) || projBudgetAllocationLine.FiscalCalendarPeriod != 0)
            notexists join fiscalCalendarPeriod
                where projBudgetAllocationLine.FiscalCalendarPeriod == fiscalCalendarPeriod.RecId &&
                    fiscalCalendarPeriod.FiscalCalendarYear != getFiscalYearRecId(projfiscalYearName)
            {
                remainingAmount = projBudgetAllocationLine.TotalAllocationAmount - projBudgetAllocationLine.ReductionAmount;

                projBudgetAllocationLine.TotalAllocationAmount -= remainingAmount;
                projBudgetAllocationLine.CarryForwardAmount += remainingAmount;
                if (projBudgetAllocationLine.CarryForwardTo && projBudgetAllocationLine.CarryForwardTo != projBudgetAllocationLineRecId)
                {
                    throw error("@SYS6144");
                }
                projBudgetAllocationLine.CarryForwardTo = projBudgetAllocationLineRecId;
                projBudgetAllocationLine.update();
            }

            // Carry forward existing transactions from new fiscal year
            if (projBudgetAllocationLineRecId)
            {
                using (SysInstrumentationActivityContext activityContext = logger.projOpsFinActivity()
                    .activityContext(ProjOpsFinancialsInstrumentationActivites::BudgetCarryForwardProcessing))
                {
                    this.carryForwardNewFiscalYearTransactions(_projBudgetLine, projBudgetAllocationLineRecId);
                }
            }
            else
            {
                logger.logError(strFmt(LoggerErrorMessage, 'new budget allocation line should not be 0.'));
            }
        }

        ttscommit;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>carryForwardNewFiscalYearTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Carry forward transactions from new fiscal year that were allocated to previous allocation lines.
    /// Update existing new fiscal year <c>ProjBudgetReductionHistory</c> records with the new budget allocation line.
    /// </summary>
    /// <param name="_projBudgetLine">
    /// The <c>ProjBudgetLine</c> record for which the carry-forward process of existing new fiscal year transactions is done.
    /// </param>
    /// <param name="_projBudgetAllocationLineRecId">
    /// The RecId of the <c>ProjBudgetAllocationLine</c> for the new fiscal year.
    /// </param>
    private void carryForwardNewFiscalYearTransactions(ProjBudgetLine _projBudgetLine, RefRecId _projBudgetAllocationLineRecId)
    {
        ProjBudgetReductionHistory projBudgetReductionHistory;
        ProjBudgetAllocationLine projBudgetAllocationLine, prevAllocationLine, newAllocationLine;
        ProjPostTransView projPostTransView;
        FiscalCalendarPeriod fiscalCalendarPeriod;

        FiscalCalendarRecId fiscalCalendarRecId = Ledger::fiscalCalendar(CompanyInfo::current());
        FiscalCalendarYear projFiscalYear = FiscalCalendarYear::findByCalendarYearName(fiscalCalendarRecId, projfiscalYearName);
        FiscalCalendarYear fiscalYear = FiscalCalendarYear::findByCalendarYearName(fiscalCalendarRecId, fiscalYearName);

        switch (_projBudgetLine.ProjBudgetLineType)
        {
            case ProjBudgetLineType::Cost :

                while select forupdate projBudgetReductionHistory
                    where projBudgetReductionHistory.ProjBudgetAllocationLineIdCost != 0
                        && projBudgetReductionHistory.ProjBudgetAllocationLineIdCost != _projBudgetAllocationLineRecId
                    exists join projPostTransView
                        where projPostTransView.TransId == projBudgetReductionHistory.ProjTransId
                            && projPostTransView.TransDate >= fiscalYear.StartDate
                    exists join projBudgetAllocationLine
                        where projBudgetAllocationLine.RecId == projBudgetReductionHistory.ProjBudgetAllocationLineIdCost
                            && projBudgetAllocationLine.ProjBudgetLine == _projBudgetLine.RecId
                            && (projBudgetAllocationLine.FiscalCalendarYear == projFiscalYear.RecId
                            || projBudgetAllocationLine.FiscalCalendarPeriod != 0)
                    notexists join fiscalCalendarPeriod
                        where projBudgetAllocationLine.FiscalCalendarPeriod == fiscalCalendarPeriod.RecId
                            && fiscalCalendarPeriod.FiscalCalendarYear != projFiscalYear.RecId
                {
                    prevAllocationLine = ProjBudgetAllocationLine::find(projBudgetReductionHistory.ProjBudgetAllocationLineIdCost, true);
                    newAllocationLine = ProjBudgetAllocationLine::find(_projBudgetAllocationLineRecId, true);

                    if (prevAllocationLine && newAllocationLine)
                    {
                        prevAllocationLine.TotalAllocationAmount -= projBudgetReductionHistory.CostAmountReduced;
                        prevAllocationLine.ReductionAmount -= projBudgetReductionHistory.CostAmountReduced;
                        prevAllocationLine.CarryForwardAmount += projBudgetReductionHistory.CostAmountReduced;
                        prevAllocationLine.update();

                        newAllocationLine.TotalAllocationAmount += projBudgetReductionHistory.CostAmountReduced;
                        newAllocationLine.ReductionAmount += projBudgetReductionHistory.CostAmountReduced;
                        newAllocationLine.update();

                        RefRecId prevAllocationLineRecId = projBudgetReductionHistory.ProjBudgetAllocationLineIdCost;
                        projBudgetReductionHistory.ProjBudgetAllocationLineIdCost = _projBudgetAllocationLineRecId;
                        projBudgetReductionHistory.update();

                        this.logCarryForwardTelemetryInfo(projBudgetReductionHistory.ProjTransId, prevAllocationLineRecId,
                            _projBudgetAllocationLineRecId);
                    }
                    else
                    {
                        this.logCarryForwardTelemetryError(projBudgetReductionHistory.ProjBudgetAllocationLineIdCost,
                            _projBudgetAllocationLineRecId);
                    }
                }

                break;

            case ProjBudgetLineType::Revenue :
                while select forupdate projBudgetReductionHistory
                    where projBudgetReductionHistory.ProjBudgetAllocationLineIdSales != 0
                        && projBudgetReductionHistory.ProjBudgetAllocationLineIdSales != _projBudgetAllocationLineRecId
                    exists join projPostTransView
                        where projPostTransView.TransId == projBudgetReductionHistory.ProjTransId
                            && projPostTransView.TransDate >= fiscalYear.StartDate
                    exists join projBudgetAllocationLine
                        where projBudgetAllocationLine.RecId == projBudgetReductionHistory.ProjBudgetAllocationLineIdSales
                            && projBudgetAllocationLine.ProjBudgetLine == _projBudgetLine.RecId
                            && (projBudgetAllocationLine.FiscalCalendarYear == projFiscalYear.RecId
                            || projBudgetAllocationLine.FiscalCalendarPeriod != 0)
                    notexists join fiscalCalendarPeriod
                        where projBudgetAllocationLine.FiscalCalendarPeriod == fiscalCalendarPeriod.RecId
                            && fiscalCalendarPeriod.FiscalCalendarYear != projFiscalYear.RecId
                {
                    prevAllocationLine = ProjBudgetAllocationLine::find(projBudgetReductionHistory.ProjBudgetAllocationLineIdSales, true);
                    newAllocationLine = ProjBudgetAllocationLine::find(_projBudgetAllocationLineRecId, true);

                    if (prevAllocationLine && newAllocationLine)
                    {
                        prevAllocationLine.TotalAllocationAmount -= projBudgetReductionHistory.SalesAmountReduced;
                        prevAllocationLine.ReductionAmount -= projBudgetReductionHistory.SalesAmountReduced;
                        prevAllocationLine.CarryForwardAmount += projBudgetReductionHistory.SalesAmountReduced;
                        prevAllocationLine.update();

                        newAllocationLine.TotalAllocationAmount += projBudgetReductionHistory.SalesAmountReduced;
                        newAllocationLine.ReductionAmount += projBudgetReductionHistory.SalesAmountReduced;
                        newAllocationLine.update();

                        RefRecId prevAllocationLineRecId = projBudgetReductionHistory.ProjBudgetAllocationLineIdSales;
                        projBudgetReductionHistory.ProjBudgetAllocationLineIdSales = _projBudgetAllocationLineRecId;
                        projBudgetReductionHistory.update();

                        this.logCarryForwardTelemetryInfo(projBudgetReductionHistory.ProjTransId, prevAllocationLineRecId,
                            _projBudgetAllocationLineRecId);
                    }
                    else
                    {
                        this.logCarryForwardTelemetryError(projBudgetReductionHistory.ProjBudgetAllocationLineIdSales,
                            _projBudgetAllocationLineRecId);
                    }
                }

                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>logCarryForwardTelemetryInfo</Name>
				<Source><![CDATA[
    private void logCarryForwardTelemetryInfo(ProjTransIdBase _projTransId, RefRecId _prevAllocationLineRecId, RefRecId _newAllocationLineRecId)
    {
        str telemetryMessage = 'Transaction %1 was carried forward from allocation line %2 to allocation line %3.';
        logger.logInformation(strFmt(telemetryMessage, _projTransId, _prevAllocationLineRecId, _newAllocationLineRecId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>logCarryForwardTelemetryError</Name>
				<Source><![CDATA[
    private void logCarryForwardTelemetryError(RefRecId _prevAllocationLineRecId, RefRecId _newAllocationLineRecId)
    {
        str telemetryMessage = '%1 budget allocation line with RecId %2 not found in ProjBudgetAllocationLine table.';
        if (!_prevAllocationLineRecId)
        {
            logger.logError(strFmt(LoggerErrorMessage, strFmt(telemetryMessage, 'previous', _prevAllocationLineRecId)));
        }

        if (!_newAllocationLineRecId)
        {
            logger.logError(strFmt(LoggerErrorMessage, strFmt(telemetryMessage, 'new', _newAllocationLineRecId)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBudgetReductionHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates existing new fiscal year <c>ProjBudgetReductionHistory</c> records
    /// with the new budget allocation line reference.
    /// </summary>
    /// <param name="_projBudgetLine">
    /// The <c>ProjBudgetLine</c> record for which the <c>ProjBudgetReductionHistory</c> records are updated.
    /// </param>
    /// <param name="_projBudgetAllocationLineRecId">
    /// The RecId of the <c>ProjBudgetAllocationLine</c> for the new fiscal year.
    /// </param>
    private void updateBudgetReductionHistory(ProjBudgetLine _projBudgetLine, RefRecId _projBudgetAllocationLineRecId)
    {
        ProjBudgetReductionHistory projBudgetReductionHistory;
        ProjBudgetAllocationLine projBudgetAllocationLine;
        ProjPostTransView projPostTransView;
        FiscalCalendarPeriod fiscalCalendarPeriod;

        FiscalCalendarRecId fiscalCalendarRecId = Ledger::fiscalCalendar(CompanyInfo::current());
        FiscalCalendarYear projFiscalYear = FiscalCalendarYear::findByCalendarYearName(fiscalCalendarRecId, projfiscalYearName);
        FiscalCalendarYear fiscalYear = FiscalCalendarYear::findByCalendarYearName(fiscalCalendarRecId, fiscalYearName);

        switch (_projBudgetLine.ProjBudgetLineType)
        {
            case ProjBudgetLineType::Cost :
                update_recordset projBudgetReductionHistory
                setting ProjBudgetAllocationLineIdCost = _projBudgetAllocationLineRecId
                where projBudgetReductionHistory.ProjBudgetAllocationLineIdCost != 0
                && projBudgetReductionHistory.ProjBudgetAllocationLineIdCost != _projBudgetAllocationLineRecId
                    join projPostTransView
                    where projPostTransView.TransId == projBudgetReductionHistory.ProjTransId
                    && projPostTransView.TransDate >= fiscalYear.StartDate
                        join projBudgetAllocationLine
                        where projBudgetAllocationLine.RecId == projBudgetReductionHistory.ProjBudgetAllocationLineIdCost
                        && projBudgetAllocationLine.ProjBudgetLine == _projBudgetLine.RecId
                        && (projBudgetAllocationLine.FiscalCalendarYear == projFiscalYear.RecId
                        || projBudgetAllocationLine.FiscalCalendarPeriod != 0)
                            notexists join fiscalCalendarPeriod
                            where projBudgetAllocationLine.FiscalCalendarPeriod == fiscalCalendarPeriod.RecId
                            && fiscalCalendarPeriod.FiscalCalendarYear != projFiscalYear.RecId;
                break;

            case ProjBudgetLineType::Revenue :
                update_recordset projBudgetReductionHistory
                setting ProjBudgetAllocationLineIdSales = _projBudgetAllocationLineRecId
                where projBudgetReductionHistory.ProjBudgetAllocationLineIdSales != 0
                && projBudgetReductionHistory.ProjBudgetAllocationLineIdSales != _projBudgetAllocationLineRecId
                    join projPostTransView
                    where projPostTransView.TransId == projBudgetReductionHistory.ProjTransId
                    && projPostTransView.TransDate >= fiscalYear.StartDate
                        join projBudgetAllocationLine
                        where projBudgetAllocationLine.RecId == projBudgetReductionHistory.ProjBudgetAllocationLineIdSales
                        && projBudgetAllocationLine.ProjBudgetLine == _projBudgetLine.RecId
                        && (projBudgetAllocationLine.FiscalCalendarYear == projFiscalYear.RecId
                        || projBudgetAllocationLine.FiscalCalendarPeriod != 0)
                            notexists join fiscalCalendarPeriod
                            where projBudgetAllocationLine.FiscalCalendarPeriod == fiscalCalendarPeriod.RecId
                            && fiscalCalendarPeriod.FiscalCalendarYear != projFiscalYear.RecId;
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate(Object calledFrom = null)
    {
        boolean ret;
        FiscalYearStart     fiscalYearStartDate, projFiscalYearStartDate;
        FiscalCalendarRecId fiscalCalendarRecId = Ledger::fiscalCalendar(CompanyInfo::current());

        ret = super(calledFrom);

        fiscalYearStartDate = FiscalCalendarYear::findByCalendarYearName(fiscalCalendarRecId, fiscalYearName).StartDate;
        projFiscalYearStartDate = FiscalCalendarYear::findByCalendarYearName(fiscalCalendarRecId, projfiscalYearName).StartDate;

        if (fiscalYearStartDate <= projFiscalYearStartDate)
        {
            ret = checkFailed("@SYS318942");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs an instance of the <c>ProjYearEndProcess</c> class.
    /// </summary>
    /// <returns>
    /// A new instance of the <c>ProjYearEndProcess</c> class.
    /// </returns>
    public static ProjYearEndProcess construct()
    {
        return new ProjYearEndProcess();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createForecastRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates forecast table record of forecast budget type carry forward.
    /// </summary>
    /// <param name="_projBudgetLine">
    /// The <c>ProjBudgetLine</c> table buffer that is used to create the forecast record.
    /// </param>
    /// <param name="_periodStartDate">
    /// The date the new forecast record will be created in the forecast table.
    /// </param>
    /// <param name="_remainingAmount">
    /// The amount that is used in the new forecast table record.
    /// </param>
    /// <returns>
    /// The transaction ID that is generated for the new forecast record.
    /// </returns>
    public static ProjTransIdBase createForecastRecord(
        ProjBudgetLine  _projBudgetLine,
        PeriodDate      _periodStartDate,
        AmountCur       _remainingAmount
    )
    {
        ForecastModel       forecastModel;
        ProjForecastEmpl    projForecastEmpl;
        ProjForecastCost    projForecastCost;
        ForecastSales       forecastSales;
        ProjForecastRevenue projForecastRevenue;
        ProjForecastOnAcc   projForecastOnAcc;
        ProjTransIdBase     transId;

        ///creating or getting a carry forward forcast model record.
        select firstonly * from forecastModel
            where forecastModel.ProjBudgetType == ProjBudgetType::CarryForward;

        ///inserting default record if carry forward forecast model does not exist
        if (!forecastModel)
        {
            forecastModel.ModelId           = "@SYS319749";
            forecastModel.Txt               = "@SYS319749";
            forecastModel.Blocked           = NoYes::Yes;
            forecastModel.ProjBudgetType    = ProjBudgetType::CarryForward;
            forecastModel.insert();
        }

        ///creating forecast record with the forecast model of carry forward
        switch (_projBudgetLine.ProjTransType)
        {
            case ProjTransType::Hour :
                select firstonly forupdate projForecastEmpl
                    where projForecastEmpl.ProjId == _projBudgetLine.ProjId
                    &&  projForecastEmpl.CategoryId == _projBudgetLine.CategoryId
                    &&  projForecastEmpl.ActivityNumber == _projBudgetLine.ActivityNumber
                    &&  projForecastEmpl.ProjForecastBudgetType == ProjForecastBudgetType::CarryForward
                    &&  projForecastEmpl.SchedFromDate == _periodStartDate;

                if (!projForecastEmpl)
                {
                    projForecastEmpl.clear();
                    projForecastEmpl.CurrencyId             = Ledger::accountingCurrency(CompanyInfo::current());
                    projForecastEmpl.initValue();
                    projForecastEmpl.ProjId                 = _projBudgetLine.ProjId;
                    projForecastEmpl.CategoryId             = _projBudgetLine.CategoryId;
                    projForecastEmpl.Qty                    = 1;
                    projForecastEmpl.ModelId                = forecastModel.ModelId;
                    projForecastEmpl.ProjForecastBudgetType = ProjForecastBudgetType::CarryForward;
                    projForecastEmpl.ActivityNumber         = _projBudgetLine.ActivityNumber;
                    projForecastEmpl.DefaultDimension       = ProjTable::find(_projBudgetLine.ProjId).DefaultDimension;
                    projForecastEmpl.LinePropertyId         = ProjLinePropertySetup::findLinePropertyId(_projBudgetLine.ProjId, _projBudgetLine.CategoryId);

                    projForecastEmpl.SchedFromDate          = _periodStartDate;
                    projForecastEmpl.initFromTransDate();

                    if (_projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Cost)
                    {
                        projForecastEmpl.CostPrice = _remainingAmount;
                    }
                    else
                    {
                        projForecastEmpl.SalesPrice = _remainingAmount;
                    }
                    projForecastEmpl.insert();
                }
                else
                {
                    if (_projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Cost)
                    {
                        projForecastEmpl.CostPrice += _remainingAmount;
                    }
                    else
                    {
                        projForecastEmpl.SalesPrice += _remainingAmount;
                    }
                    projForecastEmpl.update();
                }
                transId = projForecastEmpl.TransId;
                break;

            case ProjTransType::Cost :
                select firstonly forupdate projForecastCost
                    where projForecastCost.ProjId == _projBudgetLine.ProjId
                    &&  projForecastCost.CategoryId == _projBudgetLine.CategoryId
                    &&  projForecastCost.ActivityNumber == _projBudgetLine.ActivityNumber
                    &&  projForecastCost.ProjForecastBudgetType == ProjForecastBudgetType::CarryForward
                    &&  projForecastCost.StartDate == _periodStartDate;

                if (!projForecastCost)
                {
                    projForecastCost.clear();
                    projForecastCost.CurrencyId             = Ledger::accountingCurrency(CompanyInfo::current());
                    projForecastCost.initValue();
                    projForecastCost.ProjId                 = _projBudgetLine.ProjId;
                    projForecastCost.CategoryId             = _projBudgetLine.CategoryId;
                    projForecastCost.Qty                    = 1;
                    projForecastCost.ModelId                = forecastModel.ModelId;
                    projForecastCost.ProjForecastBudgetType = ProjForecastBudgetType::CarryForward;
                    projForecastCost.ActivityNumber         = _projBudgetLine.ActivityNumber;
                    projForecastCost.DefaultDimension       = ProjTable::find(_projBudgetLine.ProjId).DefaultDimension;
                    projForecastCost.LinePropertyId         = ProjLinePropertySetup::findLinePropertyId(_projBudgetLine.ProjId, _projBudgetLine.CategoryId);

                    projForecastCost.StartDate              = _periodStartDate;
                    projForecastCost.initFromTransDate();

                    if (_projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Cost)
                    {
                        projForecastCost.CostPrice = _remainingAmount;
                    }
                    else
                    {
                        projForecastCost.SalesPrice = _remainingAmount;
                    }
                    projForecastCost.insert();
                }
                else
                {
                    if (_projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Cost)
                    {
                        projForecastCost.CostPrice += _remainingAmount;
                    }
                    else
                    {
                        projForecastCost.SalesPrice += _remainingAmount;
                    }
                    projForecastCost.update();
                }
                transId = projForecastCost.TransId;
                break;

            case ProjTransType::Item :
                select firstonly forupdate forecastSales
                    where forecastSales.ProjId == _projBudgetLine.ProjId
                    &&  forecastSales.ProjCategoryId == _projBudgetLine.CategoryId
                    &&  forecastSales.ActivityNumber == _projBudgetLine.ActivityNumber
                    &&  forecastSales.ProjForecastBudgetType == ProjForecastBudgetType::CarryForward
                    &&  forecastSales.StartDate == _periodStartDate;

                if (!forecastSales)
                {
                    forecastSales.clear();
                    forecastSales.initValue();
                    forecastSales.ProjId                    = _projBudgetLine.ProjId;
                    forecastSales.Active                    = NoYes::Yes;
                    forecastSales.ModelId                   = forecastModel.ModelId;
                    forecastSales.ProjCategoryId            = _projBudgetLine.CategoryId;
                    forecastSales.ActivityNumber            = _projBudgetLine.ActivityNumber;
                    forecastSales.InventQty                 = 1;
                    forecastSales.SalesQty                  = 1;
                    forecastSales.InventDimId               = InventDim::findOrCreateBlank().InventDimId;
                    forecastSales.DefaultDimension          = ProjTable::find(_projBudgetLine.ProjId).DefaultDimension;
                    forecastSales.ProjLinePropertyId        = ProjLinePropertySetup::findLinePropertyId(_projBudgetLine.ProjId, _projBudgetLine.CategoryId);
                    forecastSales.Currency                  = Ledger::accountingCurrency(CompanyInfo::current());
                    forecastSales.StartDate                 = _periodStartDate;
                    forecastSales.initFromTransDate();
                    forecastSales.ProjForecastBudgetType    = ProjForecastBudgetType::CarryForward;

                    if (_projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Cost)
                    {
                        forecastSales.CostPrice = _remainingAmount;
                    }
                    else
                    {
                        forecastSales.SalesPrice = _remainingAmount;
                        forecastSales.Amount = forecastSales.calcLineAmount();
                    }
                    forecastSales.insert();
                }
                else
                {
                    if (_projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Cost)
                    {
                        forecastSales.CostPrice += _remainingAmount;
                    }
                    else
                    {
                        forecastSales.SalesPrice += _remainingAmount;
                        forecastSales.Amount = forecastSales.calcLineAmount();
                    }
                    forecastSales.update();
                }
                transId = forecastSales.ProjTransId;
                break;

            case ProjTransType::Revenue :
                select firstonly forupdate projForecastRevenue
                    where projForecastRevenue.ProjId == _projBudgetLine.ProjId
                    &&  projForecastRevenue.CategoryId == _projBudgetLine.CategoryId
                    &&  projForecastRevenue.ProjForecastBudgetType == ProjForecastBudgetType::CarryForward
                    &&  projForecastRevenue.StartDate == _periodStartDate;

                if (!projForecastRevenue)
                {
                    projForecastRevenue.clear();
                    projForecastRevenue.CurrencyId              = Ledger::accountingCurrency(CompanyInfo::current());
                    projForecastRevenue.initValue();
                    projForecastRevenue.ProjId                  = _projBudgetLine.ProjId;
                    projForecastRevenue.CategoryId              = _projBudgetLine.CategoryId;
                    projForecastRevenue.Qty                     = 1;
                    projForecastRevenue.ModelId                 = forecastModel.ModelId;
                    projForecastRevenue.ProjForecastBudgetType  = ProjForecastBudgetType::CarryForward;
                    projForecastRevenue.DefaultDimension = ProjTable::find(_projBudgetLine.ProjId).DefaultDimension;
                    projForecastRevenue.LinePropertyId          = ProjLinePropertySetup::findLinePropertyId(_projBudgetLine.ProjId, _projBudgetLine.CategoryId);

                    projForecastRevenue.StartDate               = _periodStartDate;
                    projForecastRevenue.initFromTransDate();

                    projForecastRevenue.SalesPrice              = _remainingAmount;
                    projForecastRevenue.insert();
                }
                else
                {
                    projForecastRevenue.SalesPrice              += _remainingAmount;
                    projForecastRevenue.update();
                }

                transId = projForecastRevenue.TransId;
                break;

            case ProjTransType::OnAccount :
                select firstonly forupdate projForecastOnAcc
                    where projForecastOnAcc.ProjId == _projBudgetLine.ProjId
                    &&  projForecastOnAcc.ProjForecastBudgetType == ProjForecastBudgetType::CarryForward
                    &&  projForecastOnAcc.TransDate == _periodStartDate;

                if (!projForecastOnAcc)
                {
                    projForecastOnAcc.clear();
                    projForecastOnAcc.CurrencyId                = Ledger::accountingCurrency(CompanyInfo::current());
                    projForecastOnAcc.initValue();
                    projForecastOnAcc.ProjId                    = _projBudgetLine.ProjId;
                    projForecastOnAcc.ModelId                   = forecastModel.ModelId;
                    projForecastOnAcc.ProjForecastBudgetType    = ProjForecastBudgetType::CarryForward;
                    projForecastOnAcc.DefaultDimension = ProjTable::find(_projBudgetLine.ProjId).DefaultDimension;

                    projForecastOnAcc.TransDate                 = _periodStartDate;
                    projForecastOnAcc.initFromTransDate();

                    projForecastOnAcc.SalesPrice                = _remainingAmount;
                    projForecastOnAcc.insert();
                }
                else
                {
                    projForecastOnAcc.SalesPrice                += _remainingAmount;
                }

                transId = projForecastOnAcc.TransId;
                break;
        }
        return transId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS315169";
    }

]]></Source>
			</Method>
			<Method>
				<Name>existUncommittedRevisions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the record of the uncommitted revision budget exists for the specified fiscal
    /// year.
    /// </summary>
    /// <param name="_projBudgetLineRecId">
    /// The record ID of the <c>ProjBudgetLine</c> table to check for see comment.
    /// </param>
    /// <param name="_fiscalYearRecId">
    /// The record ID of the <c>FiscalCalendarYear</c> table for the revision budget in the specified year.
    /// </param>
    /// <returns>
    /// true if the specified record exists; otherwise, false.
    /// </returns>
    public static boolean existUncommittedRevisions(RefRecId _projBudgetLineRecId,
                                                    FiscalCalendarYearRecId _fiscalYearRecId)
    {
        ProjBudget                  projBudget;
        ProjBudgetRevision          projBudgetRevision;
        ProjBudgetAllocationLine    projBudgetAllocationLine;
        FiscalCalendarPeriod        fiscalCalendarPeriod;
        ProjBudgetLine              projBudgetLine = ProjBudgetLine::find(_projBudgetLineRecId);
        boolean                     exist;

        select firstonly RecId from projBudgetRevision
            where projBudgetRevision.RevisionWorkflowStatus == ProjBudgetRevisionWFStatus::Submitted
                join RecId from projBudget
                    where projBudget.RecId == projBudgetRevision.ProjBudget
                        join RecId from projBudgetLine
                            where projBudgetLine.ProjBudget == projBudget.RecId
                                join RecId from  projBudgetAllocationLine
                                    where projBudgetAllocationLine.ProjBudgetLine == projBudgetLine.RecId
                                        && (projBudgetAllocationLine.UncommittedRevisions != 0)
                                        && (projBudgetAllocationLine.FiscalCalendarYear == _fiscalYearRecId || projBudgetAllocationLine.FiscalCalendarPeriod != 0)
                                            notexists join fiscalCalendarPeriod
                                                where projBudgetAllocationLine.FiscalCalendarPeriod == fiscalCalendarPeriod.RecId
                                                    && fiscalCalendarPeriod.FiscalCalendarYear != _fiscalYearRecId;

        exist = (projBudgetRevision.RecId != 0);

        return exist;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupFiscalYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the lookup for the fiscal year field.
    /// </summary>
    /// <param name="_formControl">
    /// The form control on which the lookup will be performed.
    /// </param>
    /// <param name="_excludePreviousFiscalYears">
    /// A Boolean value that indicates whether to use the current year filter; optional.
    /// </param>
    public static void lookupFiscalYear(FormControl _formControl, boolean _excludePreviousFiscalYears = false)
    {
        Query                query          = new Query();
        QueryBuildDataSource queryBuildDataSource;
        QueryBuildRange      queryBuildRange;
        SysTableLookup       sysTableLookup = SysTableLookup::newParameters(tableNum(FiscalCalendarYear), _formControl);
        FiscalCalendarRecId  fiscalCalendarRecId = Ledger::fiscalCalendar(CompanyInfo::current());
        StartDate            currentYearStartDate;

        sysTableLookup.addLookupfield(fieldNum(FiscalCalendarYear, Name));

        queryBuildDataSource = query.addDataSource(tableNum(FiscalCalendarYear));

        queryBuildRange = queryBuildDataSource.addRange(fieldNum(FiscalCalendarYear, FiscalCalendar));
        queryBuildRange.value(SysQuery::value(fiscalCalendarRecId));
        if (_excludePreviousFiscalYears)
        {
            currentYearStartDate = FiscalCalendarYear::findYearByCalendarDate(fiscalCalendarRecId, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())).StartDate;
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(FiscalCalendarYear, StartDate));
            queryBuildRange.value(strFmt("((%1.%2 >= %3))",
                        queryBuildDataSource.name(),
                        fieldStr(FiscalCalendarYear,StartDate),
                        date2StrXpp(currentYearStartDate)));
        }

        queryBuildDataSource.addOrderByField(fieldNum(FiscalCalendarYear, StartDate));

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupOpeningFiscalPeriods</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the lookup for the fiscal period field.
    /// </summary>
    /// <param name="_formControl">
    /// The form control for which to perform the lookup.
    /// </param>
    /// <param name="_fiscalYearName">
    /// The fiscal year name to use to filter fiscal periods.
    /// </param>
    public static void lookupOpeningFiscalPeriods(FormControl _formControl, FiscalYearName _fiscalYearName)
    {
        Query                query          = new Query();
        QueryBuildDataSource queryBuildDataSource;
        QueryBuildRange      queryBuildRange;
        SysTableLookup       sysTableLookup = SysTableLookup::newParameters(tableNum(FiscalCalendarPeriod), _formControl);

        sysTableLookup.addLookupfield(fieldNum(FiscalCalendarPeriod, Name));
        sysTableLookup.addLookupfield(fieldNum(FiscalCalendarPeriod, StartDate));

        queryBuildDataSource = query.addDataSource(tableNum(FiscalCalendarPeriod));

        queryBuildDataSource.addSelectionField(fieldNum(FiscalCalendarPeriod, Name));

        queryBuildRange = queryBuildDataSource.addRange(fieldNum(FiscalCalendarPeriod, FiscalCalendarYear));
        queryBuildRange.value(SysQuery::value(FiscalCalendarYear::findByCalendarYearName(Ledger::fiscalCalendar(CompanyInfo::current()), _fiscalYearName).RecId));

        queryBuildRange = queryBuildDataSource.addRange(fieldNum(FiscalCalendarPeriod, Type));
        queryBuildRange.value(SysQuery::value(FiscalPeriodType::Operating));

        queryBuildDataSource.addOrderByField(fieldNum(FiscalCalendarPeriod, StartDate));

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        ProjYearEndProcess projYearEndProcessBatch = ProjYearEndProcess::construct();

        if (projYearEndProcessBatch.prompt())
        {
            projYearEndProcessBatch.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedFiscalCalendarYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the fiscal year name and project budget year difference.
    /// </summary>
    /// <param name="_fiscalYearName">
    /// The fiscal year name to check.
    /// </param>
    /// <param name="_projBudgetYear">
    /// The project fiscal year name to check.
    /// </param>
    /// <returns>
    /// A Boolean value that is based on the <c>YesNo</c> dialog result that was selected.
    /// </returns>
    public static boolean modifiedFiscalCalendarYear(FiscalYearName _fiscalYearName, FiscalYearName _projBudgetYear)
    {
        boolean             ret = true;
        boolean             isFiscalYearBeyondTwoYears;
        FiscalCalendarRecId fiscalCalendarRecId = Ledger::fiscalCalendar(CompanyInfo::current());

        if (_fiscalYearName && _projBudgetYear)
        {
            isFiscalYearBeyondTwoYears = (year(FiscalCalendarYear::findByCalendarYearName(fiscalCalendarRecId, _fiscalYearName).StartDate)
                                            - year(FiscalCalendarYear::findByCalendarYearName(fiscalCalendarRecId, _projBudgetYear).StartDate)) >= 2;
            if (isFiscalYearBeyondTwoYears)
            {
                ret = Box::yesNo(strFmt("@SYS315398",_fiscalYearName), DialogButton::Yes) == DialogButton::Yes;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>opensProjTransBudgetForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the <c>ProjTransBudget</c> form by using the specified parameters.
    /// </summary>
    /// <param name="_forecastModel">
    /// The project forecast model ID to use to filter the forecast table record.
    /// </param>
    /// <param name="_projId">
    /// The project ID to use to filter the forecast table record.
    /// </param>
    /// <param name="_projTransType">
    /// The transaction type that indicates the type of budget transaction to pass the forecast table in
    /// the arguments.
    /// </param>
    /// <param name="_categoryId">
    /// The category ID to filter the forecast table record.
    /// </param>
    public static void opensProjTransBudgetForm(ProjForecastModelId _forecastModel, ProjId _projId,
                                            ProjTransType _projTransType, CategoryId _categoryId)
    {
        MenuFunction        menuFunction;
        Args                args;
        ProjForecastEmpl    projForecastEmpl;
        ProjForecastCost    projForecastCost;
        ForecastSales       forecastSales;
        ProjForecastRevenue projForecastRevenue;
        ProjForecastOnAcc   projForecastOnAcc;

        args = new Args();
        menuFunction = new MenuFunction(menuitemDisplayStr(ProjTransBudget), MenuItemType::Display);

        switch (_projTransType)
        {
            case ProjTransType::Hour :
                select projForecastEmpl where projForecastEmpl.ProjId == _projId &&
                                                projForecastEmpl.CategoryId == _categoryId &&
                                                projForecastEmpl.ModelId == _forecastModel;
                args.record(projForecastEmpl);
                break;

            case ProjTransType::Cost :
                select projForecastCost where projForecastCost.ProjId == _projId &&
                                                projForecastCost.CategoryId == _categoryId &&
                                                projForecastCost.ModelId == _forecastModel;
                args.record(projForecastCost);
                break;

            case ProjTransType::Item :
                select forecastSales where forecastSales.ProjId == _projId &&
                                            forecastSales.ProjCategoryId == _categoryId &&
                                            forecastSales.ProjForecastBudgetType == ProjForecastBudgetType::RemainingBudget;
                args.record(forecastSales);
                break;

            case ProjTransType::Revenue :
                select projForecastRevenue where projForecastRevenue.ProjId == _projId &&
                                                    projForecastRevenue.CategoryId == _categoryId &&
                                                    projForecastRevenue.ModelId == _forecastModel;
                args.record(projForecastRevenue);
                break;

            case ProjTransType::OnAccount :
                select projForecastOnAcc where projForecastOnAcc.ProjId == _projId &&
                                                projForecastOnAcc.ModelId == _forecastModel;
                args.record(projForecastOnAcc);
                break;
        }

        menuFunction.run(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFiscalCalendarYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the fiscal year name that is used in the project budget carry forward process.
    /// </summary>
    /// <param name="_fiscalYearName">
    /// The fiscal year name to validate.
    /// </param>
    /// <param name="_showErrorMessage">
    /// true if error message needs to be displayed; Optional.
    /// </param>
    /// <returns>
    /// true if the specified fiscal year name is valid; otherwise, false.
    /// </returns>
    public static boolean validateFiscalCalendarYear(FiscalYearName _fiscalYearName, boolean _showErrorMessage = true)
    {
        boolean ret = true;
        FiscalCalendarRecId fiscalCalendarRecId = Ledger::fiscalCalendar(CompanyInfo::current());
        StartDate           currentYearStartDate = FiscalCalendarYear::findYearByCalendarDate(fiscalCalendarRecId, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())).StartDate;

        boolean isFiscalCalendarYearInvalid;

        if (_fiscalYearName && !FiscalCalendarYear::existByCalendarYearName(fiscalCalendarRecId, _fiscalYearName))
        {
            if (_showErrorMessage)
            {
                checkFailed(strFmt("@SYS315394", _fiscalYearName));
            }
            ret = false;
        }

        if (ret && _fiscalYearName)
        {
            isFiscalCalendarYearInvalid = (select firstonly RecId from fiscalCalendarYear
                                            where fiscalCalendarYear.FiscalCalendar == fiscalCalendarRecId &&
                                            fiscalCalendarYear.Name == _fiscalYearName &&
                                            fiscalCalendarYear.StartDate >= currentYearStartDate).RecId == 0;

            if (isFiscalCalendarYearInvalid)
            {
                if (_showErrorMessage)
                {
                    checkFailed(strFmt("@SYS315397", _fiscalYearName));
                }
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFiscalPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the fiscal period name that is used in the project budget carry forward process.
    /// </summary>
    /// <param name="_periodName">
    /// The fiscal period name to validate.
    /// </param>
    /// <param name="_fiscalYearName">
    /// The fiscal year name to which the period belongs.
    /// </param>
    /// <returns>
    /// true if the specified fiscal period name is valid; otherwise, false.
    /// </returns>
    public static boolean validateFiscalPeriod(PeriodName _periodName, FiscalYearName _fiscalYearName)
    {
        boolean isFiscalPeriodValid;
        RecId calendarRecId = Ledger::fiscalCalendar(CompanyInfo::current());
        FiscalCalendarPeriod fiscalCalendarPeriod;
        FiscalCalendarYear   fiscalCalendarYear;

        fiscalCalendarYear = FiscalCalendarYear::findByCalendarYearName(calendarRecId, _fiscalYearName);
        fiscalCalendarPeriod = FiscalCalendarPeriod::findByCalendarYearPeriod(fiscalCalendarYear.RecId,_periodName);

        isFiscalPeriodValid = fiscalCalendarPeriod.RecId && fiscalCalendarPeriod.currentLedgerPeriodStatus() == FiscalPeriodStatus::Open;

        if (_periodName && !isFiscalPeriodValid)
        {
            checkFailed(strFmt("@SYS315396", _periodName));
        }

        return isFiscalPeriodValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFromForecastModelId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the project budget forecast model that is used in the project budget carry forward process.
    /// </summary>
    /// <param name="_forecastModelId">
    /// The forecast model ID to validate.
    /// </param>
    /// <returns>
    /// true if the specified forecast model ID is valid; otherwise, false.
    /// </returns>
    public static boolean validateFromForecastModelId(ForecastModelId  _forecastModelId)
    {
        boolean ret = true;
        boolean isFromForecastModelValid = (select firstonly RecId from forecastModel
                                            where forecastModel.ModelId == _forecastModelId &&
                                                    forecastModel.ProjBudgetType == ProjBudgetType::RemainingBudget).RecId != 0;

        if (_forecastModelId && !isFromForecastModelValid)
        {
            ret = checkFailed(strFmt("@SYS315395", _forecastModelId));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLedgerBudgetModel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the budget model that is used in the project budget carry forward process.
    /// </summary>
    /// <param name="_budgetModelId">
    /// The budget model ID to validate.
    /// </param>
    /// <returns>
    /// true if the specified budget model ID is valid; otherwise, false.
    /// </returns>
    public static boolean validateLedgerBudgetModel(BudgetModelId  _budgetModelId)
    {
        boolean ret = true;
        boolean isBudgetModelExists = (select firstonly RecId from budgetModel
                                                where budgetModel.Type == HeadingSub::Heading &&
                                                budgetModel.ModelId == _budgetModelId).RecId != 0;

        if (_budgetModelId && !isBudgetModelExists)
        {
            ret = checkFailed(strFmt("@SYS55265", _budgetModelId,
                                     fieldStr(BudgetModel, ModelId),
                                     tableId2pname(tableNum(BudgetModel))));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProjBudgetYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the project fiscal year name that is used in the project budget carry forward process.
    /// </summary>
    /// <param name="_fiscalYearName">
    /// The fiscal year name to validate.
    /// </param>
    /// <returns>
    /// true if the specified fiscal year name is valid; otherwise, false.
    /// </returns>
    public static boolean validateProjBudgetYear(FiscalYearName _fiscalYearName)
    {
        boolean ret = true;

        if (_fiscalYearName && !FiscalCalendarYear::existByCalendarYearName(Ledger::fiscalCalendar(CompanyInfo::current()), _fiscalYearName))
        {
            ret = checkFailed(strFmt("@SYS315394", _fiscalYearName));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable() 
    {
        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>