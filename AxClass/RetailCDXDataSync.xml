<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailCDXDataSync</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Application.Instrumentation;

/// <summary>
/// Retail CDX data sync.
/// </summary>
public class RetailCDXDataSync
{
    RetailCDXDataSyncContext ctContext;

    RetailCdxCsvDataOutput writer;
    RetailCDXDataTranslator translator;

    container leContainer;
    DataAreaId singleTargetLE;

    // work around x++ limitation. lack of "rethrow"
    boolean errorFound;

    private RetailCDXDownloadJobSourceLogger logger;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>cleanUp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleans up the context and writer.
    /// </summary>
    public void cleanUp()
    {
        Microsoft.Dynamics.Ax.Xpp.ErrorException xppEx;
        System.Exception ex;

        try
        {
            if (writer)
            {
                writer.cleanUp();
            }

            if (this.parmDataSyncContext())
            {
                this.parmDataSyncContext().cleanUp();
            }
        }
        catch (xppEx)
        {
            logger.logCDXResourceCleanUpFailureWarning(xppEx);
        }
        catch (ex)
        {
            logger.logCDXResourceCleanUpFailureWarning(ex);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDataSyncContext</Name>
				<Source><![CDATA[
    internal RetailCDXDataSyncContext parmDataSyncContext(RetailCDXDataSyncContext _ctContext = ctContext)
    {
        if (!prmIsDefault(_ctContext))
        {
            // only need to set this if we are also setting the ctContext
            logger.parmDataSyncContext(_ctContext);
        }

        ctContext = _ctContext;

        return ctContext;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initialize</Name>
				<Source><![CDATA[
    private boolean initialize()
    {
        Microsoft.Dynamics.Ax.Xpp.ErrorException xppEx;
        System.Exception ex;
        boolean initializationResult = false;

        try
        {
            logger.logCDXJobDownloadSourceCtxInitializationStart();

            boolean shouldRunInitializeCommerceScheduler = RetailPostSetupActions::hasAnyActionQueued(classStr(RetailSetup), methodStr(RetailSetup, initializeCommerceScheduler));
            boolean shouldRunPopulateExtensibleEnumMetadata = RetailPostSetupActions::hasAnyActionQueued(classStr(RetailSetup), methodStr(RetailSetup, populateExtensibleEnumMetadata));
            boolean isDataSyncQueryOutOfSyncWithFlightKey = RetailCDXCodeGen::isDataSyncQueryOutOfSyncWithFlightKey(this.parmDataSyncContext().getChannelSchema());
            if (shouldRunInitializeCommerceScheduler || shouldRunPopulateExtensibleEnumMetadata || isDataSyncQueryOutOfSyncWithFlightKey)
            {
                int sleepTimeMs = 1 * 60 * 1000; // 1 minute
                int remainingTimeMs = 10 * 60 * 1000; // 10 minutes

                using (var lock = ReqReaderWriterLock::construct())
                {
                    // try to get lock to execute setup actions
                    if (lock.tryEnterWriterLock(classStr(RetailCDXDataSync)))
                    {
                        if (shouldRunInitializeCommerceScheduler)
                        {
                            RetailPostSetupActions::initializeCommerceScheduler();
                        }
                        else if (isDataSyncQueryOutOfSyncWithFlightKey)
                        {
                            // regenerate data sync queries.
                            RetailCDXCodeGen::generate(this.parmDataSyncContext().getChannelSchema());
                        }

                        if (shouldRunPopulateExtensibleEnumMetadata)
                        {
                            RetailPostSetupActions::populateExtensibleEnumMetadata();
                        }
                    }
                    else
                    {
                        // if another scheduler job is already executing setup actions, just wait for it to finish
                        do
                        {
                            sleep(sleepTimeMs);
                            remainingTimeMs -= sleepTimeMs;
                        }
                        while (!ReqReaderWriterLock::testWriter(classStr(RetailCDXDataSync)) || remainingTimeMs > 0);
                    }
                }
            }

            RetailCDXRowVersion currentSyncVer = RetailCDXChangeTrackingAux::getChangeTrackingCurrentVersion();
            this.parmDataSyncContext().ParamCurrentSyncVer(currentSyncVer);

            this.parmDataSyncContext().initializeSessionNumbers();

            this.parmDataSyncContext().initializeDownloadSessions();

            if (this.shouldSkipPackageGeneration())
            {
                logger.logCDXJobDownloadSourcePackageGenerationSkipped();

                initializationResult = false;
            }
            else if (this.prepareTargetChannel())
            {
                this.prepareLEContainer();

                this.prepareTargetLegalEntityTempTable();

                // only track new channel mapping if the data sync is incremental sync.
                if (!this.parmDataSyncContext().paramIsInitSync())
                {
                    this.trackChannelDBAssignment();
                    this.prepareTargetLegalEntityNewLEsTempTable();
                }

                this.initializeClasses();

                this.parmDataSyncContext().initializeRefTable();

                writer.beginSession();

                initializationResult = true;
            }
            else
            {
                initializationResult = false;
            }

            this.initialized();

            return initializationResult;
        }
        catch (xppEx)
        {
            ex = xppEx;

            logger.logCDXJobDownloadSourceCtxInitializationFailure(ex);
            throw error(strFmt("@Retail:CDXJobDownloadSourceCtxInitErrorMsg", this.parmDataSyncContext().paramJobID()));
        }
        catch (ex)
        {
            logger.logCDXJobDownloadSourceCtxInitializationFailure(ex);
            throw error(strFmt("@Retail:CDXJobDownloadSourceCtxInitErrorMsg", this.parmDataSyncContext().paramJobID()));
        }
        finally
        {
            this.parmDataSyncContext().addException(ex);
            this.parmDataSyncContext().paramInitializationResult(initializationResult);
            logger.logCDXJobDownloadSourceCtxInitializationStop(ex);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initialized</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal void initialized()
    {
        // This method is empty on purpose in order to enable extensibility.
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWriter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the writer.
    /// </summary>
    /// <param name = "_channelSchema">The channel schema that is being used.</param>
    /// <returns>A <c>RetailCdxCsvDataOutput</c> writer.</returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute,
     Wrappable(true)]
    internal static RetailCdxCsvDataOutput createWriter(RetailConnChannelSchema _channelSchema)
    {
        return new RetailCdxCsvDataOutput();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeClasses</Name>
				<Source><![CDATA[
    private void initializeClasses()
    {
        RetailConnChannelSchema channelSchema;
        RetailConnSchedulerJobTable jobTable;
        DictClass translatorClass;

        select channelSchema
            exists join jobTable
            where channelSchema.RecId == jobTable.RetailConnChannelSchema
               && jobTable.JobId == this.parmDataSyncContext().paramJobID();

        if (!channelSchema)
        {
            // Cannot find channel schema for job: %1
            throw Global::error(strFmt("@REX1576", this.parmDataSyncContext().paramJobID()));
        }

        writer = RetailCDXDataSync::createWriter(channelSchema);
        writer.paramDataSyncContext(this.parmDataSyncContext());
        writer.paramSingleTargetLE(singleTargetLE);

        //Get translation class for this schema
        select firstonly DataTranslationClass from channelSchema where channelSchema.RecId == this.parmDataSyncContext().getChannelSchema();

        if (channelSchema.DataTranslationClass)
        {
            translatorClass = new DictClass(className2Id(channelSchema.DataTranslationClass));
            RetailCDXDataSync::validateDictClass(translatorClass, channelSchema.DataTranslationClass);
            translator = translatorClass.makeObject();
            translator.paramCtContext(this.parmDataSyncContext());
            translator.paramLE(singleTargetLE);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteDataFile</Name>
				<Source><![CDATA[
    private void deleteDataFile()
    {
        // delete the data file droppped to blob storage, if this download session fails to complete

        Microsoft.Dynamics.Ax.Xpp.ErrorException xppEx;
        System.Exception ex;

        try
        {
            this.parmDataSyncContext().deleteSessionsDataFiles();
        }
        catch (xppEx)
        {
            logger.logCDXResourceCleanUpFailureWarning(xppEx);
        }
        catch (ex)
        {
            logger.logCDXResourceCleanUpFailureWarning(ex);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramErrorFound</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns if error was found in data sync.
    /// </summary>
    /// <param name="_errorFound">
    /// If error found true or false.
    /// </param>
    /// <returns>
    /// If error found true or false.
    /// </returns>
    public boolean paramErrorFound(boolean _errorFound = errorFound)
    {
        errorFound = _errorFound;
        return errorFound;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDownloadSession</Name>
				<Source><![CDATA[
    private void updateDownloadSession()
    {
        System.Exception ex;

        try
        {
            logger.logCDXJobDownloadSourceUpdateSessionStart();

            const int retryNum = 10;
            const int retryWaitMs = 500;

            try
            {
                ttsBegin;
                
                this.parmDataSyncContext().updateDownloadSessions();
                
                ttscommit;
            }
            catch (Exception::UpdateConflict)
            {
                if (xSession::currentRetryCount() < retryNum)
                {
                    sleep(retryWaitMs);
                    ApplicationEventSource::EventWriteCDXJobDownloadSourceUpdateSessionRetry(this.parmDataSyncContext().paramJobID(), xSession::currentRetryCount(), this.parmDataSyncContext().paramCorrelationId());
                    retry; // retry if there is an update conflic while updating the downloadSessionDataStore status.
                }
                else
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
            }
            catch (Exception::Deadlock)
            {
                if (xSession::currentRetryCount() < retryNum)
                {
                    sleep(retryWaitMs);
                    ApplicationEventSource::EventWriteCDXJobDownloadSourceUpdateSessionRetry(this.parmDataSyncContext().paramJobID(), xSession::currentRetryCount(), this.parmDataSyncContext().paramCorrelationId());
                    retry;  // retry if there is a deadlock while updating the downloadSessionDataStore status.
                }
                else
                {
                    throw Exception::Deadlock;
                }
            }
        }
        catch (ex)
        {
            logger.logCDXJobDownloadSourceUpdateSessionFailure(ex);
            throw error(strFmt("@Retail:UpdateDownloadSessionErrMsg", this.parmDataSyncContext().getSessionNumbers().ToString()));
        }
        finally
        {
            this.parmDataSyncContext().addException(ex);
            logger.logCDXJobDownloadSourceUpdateSessionStop(ex);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelReplacedDownloadSessionDataStores</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels all pre-existing sessions for the current job (except already Applied sessions) whose packaged data contains a subset of the data contained in the newly created session.
    /// </summary>
    /// <param name = "_newSession">The newly created RetailCDXDownloadSession record.</param>
    /// <param name = "_targetDataStoreForNewSession)">The data store record Id for which the new session is created.</param>
    /// <return>The number of sessions replaced by the new download session.</return>
    /// <remarks>
    /// The _targetDataStoreForNewSession argument is optional.
    /// If _targetDataStoreForNewSession is 0 or is not provided then it means sessionDataStore records from all datastores in the datagroup corresponding to the new session will be considered for replacement by the new session and cancelation.
    /// If _targetDataStoreForNewSession is provided then it means only sessionDataStore records for the specified datastore will be considered for replacement by the new session and cancelation.
    /// </remarks>
    internal static int64 cancelReplacedDownloadSessionDataStores(RetailCDXDownloadSession _newSession, RecId _targetDataStoreForNewSession)
    {
        RetailCDXDownloadSessionDataStore retailCDXDownloadSessionDataStore;
        RetailCDXDownloadSession retailCDXDownloadSession;
        int64 replacedSessionsCount;

        str updateMessage = strFmt("@Retail:SessionDataStoreCanceledByNewerSession", _newSession.Session);

        ttsbegin;

        // The two update statements below differ only on retailCDXDownloadSessionDataStore.DataStore filter (split for performance)
        // if _targetDataStoreForNewSession is 0 then it means pre-existing sessiondatastore records from all datastores of the current datagroup, containing a subset of the data contained in the newly created session will be replaced and canceled.
        if (_targetDataStoreForNewSession == 0)
        {
            // For performance, we update even the current session
            update_recordset retailCDXDownloadSessionDataStore
                setting Status     = RetailCDXDownloadSessionStatus::Canceled,      // cancel pre-existing sessions that contain just a subset of the dataset included in the newly created download session.
                    ReplacedBy = _newSession.RecId,                           // save the session Id that caused the cancelation (ie. the newly created session Id that contains a superset of the data in the pre-existing sessions.
                    Message    = updateMessage
                where retailCDXDownloadSessionDataStore.Status != RetailCDXDownloadSessionStatus::Applied &&
                    retailCDXDownloadSessionDataStore.Status != RetailCDXDownloadSessionStatus::Canceled // no need to replace already canceled sessions.
                join retailCDXDownloadSession
                where retailCDXDownloadSession.RecId == retailCDXDownloadSessionDataStore.Session &&
                    retailCDXDownloadSession.JobID == _newSession.JobID &&
                    retailCDXDownloadSession.DataGroup == _newSession.DataGroup &&
                    retailCDXDownloadSession.SyncRowVersion >= _newSession.syncRowVersion &&      // select all sessions with the same jobId as the new one and their syncRowVersion range falls between the new sessions syncrowversion range
                    retailCDXDownloadSession.CurrentRowVersion <= _newSession.CurrentRowVersion;

            replacedSessionsCount = retailCDXDownloadSessionDataStore.RowCount();

            // enable the newSession again
            update_recordset retailCDXDownloadSessionDataStore
                setting Status     = RetailCDXDownloadSessionStatus::Available,
                        ReplacedBy = 0,
                        Message    = ''
                where retailCDXDownloadSessionDataStore.Session == _newSession.RecId;

            // Enabling a new session again with the above update_recordset, shouldn't count new session(current session) as replaced session.
            replacedSessionsCount = replacedSessionsCount - retailCDXDownloadSessionDataStore.RowCount();
        }
        // if _targetDataStoreForNewSession is passed then only pre-existing sessiondatastore records from the specified datastore, containing a subset of the data contained in the newly created session will be replaced and canceled.
        else
        {
            update_recordset retailCDXDownloadSessionDataStore
                setting Status = RetailCDXDownloadSessionStatus::Canceled,      // cancel pre-existing sessions that contain just a subset of the dataset included in the newly created download session.
                    ReplacedBy = _newSession.RecId,                           // save the session Id that caused the cancelation (ie. the newly created session Id that contains a superset of the data in the pre-existing sessions.
                    Message    = updateMessage
                where retailCDXDownloadSessionDataStore.Status    != RetailCDXDownloadSessionStatus::Applied &&
                    retailCDXDownloadSessionDataStore.Status    != RetailCDXDownloadSessionStatus::Canceled &&// no need to replace already canceled sessions.
                    retailCDXDownloadSessionDataStore.DataStore == _targetDataStoreForNewSession
                join retailCDXDownloadSession
                where retailCDXDownloadSession.RecId == retailCDXDownloadSessionDataStore.Session &&
                    retailCDXDownloadSession.JobID == _newSession.JobID &&
                    retailCDXDownloadSession.DataGroup == _newSession.DataGroup &&
                    retailCDXDownloadSession.SyncRowVersion >= _newSession.syncRowVersion &&      // select all sessions with the same jobId as the new one and their syncRowVersion range falls between the new sessions syncrowversion range
                    retailCDXDownloadSession.CurrentRowVersion <= _newSession.CurrentRowVersion;

            replacedSessionsCount = retailCDXDownloadSessionDataStore.RowCount();

            // enable the newSession again
            update_recordset retailCDXDownloadSessionDataStore
                setting Status     = RetailCDXDownloadSessionStatus::Available,
                        ReplacedBy = 0,
                        Message    = ''
                where retailCDXDownloadSessionDataStore.Session == _newSession.RecId &&
                      retailCDXDownloadSessionDataStore.DataStore == _targetDataStoreForNewSession;

            // Enabling a new session again with the above update_recordset, shouldn't count new session(current session) as replaced session.
            replacedSessionsCount = replacedSessionsCount - retailCDXDownloadSessionDataStore.RowCount();

        }
        ttscommit;

        return replacedSessionsCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareLEContainer</Name>
				<Source><![CDATA[
    private void prepareLEContainer()
    {
        RetailChannelTable channel;
        RetailCDXTargetChannel targetChannel;
        RetailConnSchedulerJobTable job;
        RetailConnSchedulerJobLine jobLine;
        RetailConnSchedulerSubjobTable subjob;

        targetChannel = this.parmDataSyncContext().openTargetChannelTable();

        while select InventLocationDataAreaId
        from channel
            group by channel.InventLocationDataAreaId
            exists join targetChannel
            where channel.RecId == targetChannel.Channel
        {
            leContainer += channel.InventLocationDataAreaId;
        }

        this.parmDataSyncContext().paramLEContainer(leContainer);
        this.parmDataSyncContext().paramLEContainerBaseline(leContainer);

        if (conLen(leContainer) == 1)
        {
            singleTargetLE = conPeek(leContainer, 1);
        }

        if (conLen(leContainer) > 1)
        {
            while select SubJobId, axTableName, ChannelTableName, ReplicateDataAreaId from subjob
                exists join jobLine where subjob.SubJobId == jobLine.SubJobId
                exists join job where jobLine.JobId == job.JobId && job.JobId == this.parmDataSyncContext().paramJobID()
            {
                // If the subjob table doesn't exist, just skip it without throwing exception so we keep backward compatibility
                if (tableName2Id(subjob.axTableName) != 0)
                {
                    if (!RetailConnReplicationUtilities::isGlobalTable(subjob.axTableName)
                     && RetailConnReplicationUtilities::isTableTempDB(subjob.axTableName))
                    {
                        // For subjob: %1, channel table: %2 is non-Global. Data package is not allowed to be sent to channels of different legal entities.
                        throw Global::error(strFmt("@REX1577", subjob.SubJobId, subjob.ChannelTableName));
                    }

                    if (RetailConnReplicationUtilities::isGlobalTable(subjob.axTableName)
                     && subjob.ReplicateDataAreaId)
                    {
                        // ReplicateAreaID is enabled on subjob: %1. Data package is not allowed to be sent to channels of different legal entities.
                        throw Global::error(strFmt("@REX1577", subjob.SubJobId));
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareTargetChannel</Name>
				<Source><![CDATA[
    private boolean prepareTargetChannel()
    {
        RetailCDXTargetChannel targetChannelTable;
        RetailCDXDataStoreChannel dataStoreChannel;
        RetailConnDatabaseProfile dataStore;
        RetailCDXDataGroup dataGroup;
        int i;
        RefRecId dataStoreRecID;
        boolean targetChannelAdded = false;

        targetChannelTable = this.parmDataSyncContext().openTargetChannelTable();
        RetailCDXTargetChannel targetChannelTable_baseline = this.parmDataSyncContext().openTargetChannelTableBaseline();

        delete_from targetChannelTable;

        while select Channel from dataStoreChannel
            exists join dataStore
                where dataStoreChannel.DatabaseProfile == dataStore.RecId
                   && dataStore.DataGroup == this.parmDataSyncContext().paramDataGroupRecID()
        {
            targetChannelTable.initValue();
            targetChannelTable.Channel = dataStoreChannel.Channel;
            targetChannelTable.insert();

            targetChannelTable_baseline.initValue();
            targetChannelTable_baseline.Channel = dataStoreChannel.Channel;
            targetChannelTable_baseline.insert();

            targetChannelAdded = true;
        }

        if (!targetChannelAdded)
        {
            // No target channel is configured on data group %1.
            select firstonly Name from dataGroup where dataGroup.RecId == this.parmDataSyncContext().paramDataGroupRecID();
            Global::warning(strFmt("@Retail:CdxWarningNoTargetChannel", dataGroup.Name));
            logger.logCdxWarningNoTargetChannel(dataGroup.Name);
        }

        return targetChannelAdded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareTargetLegalEntityTempTable</Name>
				<Source><![CDATA[
    private void prepareTargetLegalEntityTempTable()
    {
        RetailTmpCDXTargetLegalEntity targetLegalEntityTempTable = this.parmDataSyncContext().openTargetLegalEntityTempTable();

        for (int i = 1; i <= conLen(leContainer); i++)
        {
            targetLegalEntityTempTable.TargetDataAreaId = conPeek(leContainer, i);
            targetLegalEntityTempTable.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareTargetLegalEntityNewLEsTempTable</Name>
				<Source><![CDATA[
    private void prepareTargetLegalEntityNewLEsTempTable()
    {
        RetailTmpCDXTargetLegalEntity targetLegalEntityNewLEsTempTable = this.parmDataSyncContext().openTargetLegalEntityTempTableNewLEs();
        Set newLEs = this.parmDataSyncContext().paramNewLESet();
        SetEnumerator newLEsEnumerator = newLEs.getEnumerator();

        while(newLEsEnumerator.moveNext())
        {
            str leStr = newLEsEnumerator.current();
            targetLegalEntityNewLEsTempTable.TargetDataAreaId = leStr;
            targetLegalEntityNewLEsTempTable.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>trackChannelDBAssignment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Tracks channel database assignment.
    /// </summary>
    /// <returns>True if new channel is detected in this data group; false otherwise.</returns>
    internal boolean trackChannelDBAssignment()
    {
        RetailCDXChangeTracking ct = RetailCDXChangeTracking::createInstanceFromJobSourceCtx(this.parmDataSyncContext());
        ct.runChangeTracking_table(tableNum(RetailCDXDataStoreChannel));

        RetailCDXTargetChannel newTargetChannels;
        Set newChannelSet = new Set(Types::Int64);
        RetailCDXDataStoreChannel dataStoreChannel;
        RetailConnDatabaseProfile dataStore;

        RetailCDXChangeRefTable1 changeTrackingTempTable = this.parmDataSyncContext().openChangeRefTable1();

        // newly added records in RetailChannelTable
        while select RefRecId from changeTrackingTempTable
            where changeTrackingTempTable.NodeID <= 0 // from changeTrackingTempTable pick all:
                                                      //  1. non-link column value updates (these types of changes have NodeID zero i.e. they change doesnt affect other table nodes.
                                                      // &2. all inserts made in the current table; (these types of changes have NodeID of -1 to indicate that such changes affect
                                                      //     every  other table nodes linked/referenced by the nodes of the table specified in RefTableId.
                                                      && changeTrackingTempTable.RefTableID == tableNum(RetailChannelTable)
               && changeTrackingTempTable.SYS_CHANGE_OPERATION == 'I'  // for insert changes, affected NodeID will always be -1 (i.e indicating the change affects all referenced nodes)
                                                                       // the only reason NodeID<= 0 is used as opposed to NodeId==-1 is to be backward compatible with the previous version which sets the affected nodeId for 'insert' changes to 0.
                                                                       exists join dataStoreChannel
              where changeTrackingTempTable.RefRecID == dataStoreChannel.Channel
            exists join dataStore
              where dataStoreChannel.DatabaseProfile == dataStore.RecId
                 && dataStore.DataGroup == this.parmDataSyncContext().paramDataGroupRecID()
        {
            RefRecId channelRecId = changeTrackingTempTable.RefRecID;
            this.addToNewChannelsCollection(channelRecId);
        }

        Set newDataStoreChannels = new Set(Types::Int64);

        while select RefRecId, RefTableId
            from changeTrackingTempTable
            where changeTrackingTempTable.NodeID <= 0
               && changeTrackingTempTable.RefTableID == tableNum(RetailCDXDataStoreChannel)
            exists join dataStoreChannel // use change tracking of datastorechannel only for datastores part of the datagroup
              where changeTrackingTempTable.RefRecID == dataStoreChannel.RecId
            exists join dataStore
              where dataStoreChannel.DatabaseProfile == dataStore.RecId
                 && dataStore.DataGroup == this.parmDataSyncContext().paramDataGroupRecID()
        {
            newDataStoreChannels.add(changeTrackingTempTable.RefRecID);
        }

        SetEnumerator newDataStoreChannelIterator = newDataStoreChannels.getEnumerator();
        // not new channel but the channel is newly assigned to a database/assigned to different database
        while (newDataStoreChannelIterator.moveNext())
        {
            RefRecId newRetailCDXDataStoreChannelRecId = newDataStoreChannelIterator.current();
            RetailCDXDataStoreChannel newlyAddedRetailCDXDataStoreChannel = RetailCDXDataStoreChannel::find(newRetailCDXDataStoreChannelRecId);

            RetailCDXDataStoreChannel preExistingRetailCDXDataStoreChannel;

            select firstonly RecId
                from preExistingRetailCDXDataStoreChannel
                    where preExistingRetailCDXDataStoreChannel.Channel == newlyAddedRetailCDXDataStoreChannel.Channel  // find all the dataStoreChannel records corresponding to the CHANNEL of the newly added dataStoreChannel
                exists join dataStore                                                                                  // and filter out the records that belong to the current datagroup
                    where dataStore.RecId == preExistingRetailCDXDataStoreChannel.DatabaseProfile &&                   // specified by this.parmDataSyncContext().paramDataGroupRecID()
                          dataStore.DataGroup == this.parmDataSyncContext().paramDataGroupRecID()
                notexists join changeTrackingTempTable                                                                                    // then find which of these dataStoreChannel records are not new
                    where changeTrackingTempTable.NodeID <= 0 &&                                                                          // by filtering out the ones that are not present in the
                          changeTrackingTempTable.RefTableID == tableNum(RetailCDXDataStoreChannel) &&                                    // ref1 temp table (ie.e in the changed records temp table
                          changeTrackingTempTable.RefRecID == preExistingRetailCDXDataStoreChannel.RecId;

            // if the above query returns any records then it means the CHANNEL in newlyAddedRetailCDXDataStoreChannel has already been mapped by
            // another dataStoreChannel record which is not new. Hence in such cases the CHANNEL should not be added to the newChannelSet collection
            // ex: Assume:
            //      1- channel A is *already* mapped to datastore DS-A which is assigned to datagroup DG-A
            //      2- now assume Channel A is *newly* mapped to datastore DS-A-Offline which is assigned to datagroup DG-A
            //    In the above scenario channel A already exists in DG-A even before the second mapping between channel A and DS-A-Offline is added. Hence
            //    such channel-datastore mapping should not be considered as addition of a new channel since the channel was already in DG-A even before the new mapping.
            if (preExistingRetailCDXDataStoreChannel.RecId == 0)
            {
                this.addToNewChannelsCollection(newlyAddedRetailCDXDataStoreChannel.Channel);
            }
        }

        boolean isNewChannelIncluded = !this.parmDataSyncContext().paramNewChannelSet().empty();

        if (isNewChannelIncluded)
        {
            this.trackNewCompanyAssignment();
        }

        return isNewChannelIncluded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToNewChannelsCollection</Name>
				<Source><![CDATA[
    private void addToNewChannelsCollection(RefRecId _channelRecId)
    {
        if (!this.parmDataSyncContext().paramNewChannelSet().in(_channelRecId))
        {
            RetailCDXTargetChannel targetChannelTable_baseline = this.parmDataSyncContext().openTargetChannelTableBaseline();
            delete_from targetChannelTable_baseline where targetChannelTable_baseline.Channel == _channelRecId;

            this.parmDataSyncContext().paramNewChannelSet().add(_channelRecId);

            logger.logChannelDataFilteringChannelAssignDetected(_channelRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>trackNewCompanyAssignment</Name>
				<Source><![CDATA[
    private void trackNewCompanyAssignment()
    {
        RetailCDXDataStoreChannel dataStoreChannel;
        RetailConnDatabaseProfile dataStore;
        RetailChannelTable channelTable;
        Set existingCompanies = new Set(Types::String);
        Set newLESet = new Set(Types::String);

        // add all existing LEs to a Set.
        while select Channel from dataStoreChannel
            exists join dataStore
                where dataStoreChannel.DatabaseProfile == dataStore.RecId
                   && dataStore.DataGroup == this.parmDataSyncContext().paramDataGroupRecID()
        {
            if (!this.parmDataSyncContext().paramNewChannelSet().in(dataStoreChannel.Channel))
            {
                // not a new channel, add its LE to set
                select firstonly InventLocationDataAreaId
                    from channelTable
                    where channelTable.RecId == dataStoreChannel.Channel;

                if (!existingCompanies.in(channelTable.inventLocationDataAreaId))
                {
                    existingCompanies.add(channelTable.inventLocationDataAreaId);
                }
            }
        }

        SetEnumerator se = this.parmDataSyncContext().paramNewChannelSet().getEnumerator();

        container leContainerBaseline = this.parmDataSyncContext().paramLEContainerBaseline();

        // for new channels, if it is in a new LE, mark the LE as full sync for non-global tables
        while (se.moveNext())
        {
            RefRecId channelRecId = se.current();

            select firstonly InventLocationDataAreaId
                from channelTable
                where channelTable.RecId == channelRecId;

            if (!existingCompanies.in(channelTable.inventLocationDataAreaId) && !newLESet.in(channelTable.inventLocationDataAreaId))
            {
                newLESet.add(channelTable.inventLocationDataAreaId);
                
                int le_Index = conFind(leContainerBaseline, channelTable.inventLocationDataAreaId);
                
                if (le_Index)
                {
                    leContainerBaseline = conDel(leContainerBaseline, le_Index, 1);
                }

                logger.logChannelDataFilteringNewCompanyDetected(channelTable.inventLocationDataAreaId);
            }
        }

        this.parmDataSyncContext().paramNewLESet(newLESet);
        this.parmDataSyncContext().paramLEContainerBaseline(leContainerBaseline);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processParams</Name>
				<Source><![CDATA[
    private void processParams(container _params)
    {
        Microsoft.Dynamics.Ax.Xpp.ErrorException xppEx;
        try
        {
            RetailCDXDataSyncContext ctx = RetailCDXDataSync::con2DataSyncContext(_params);
            this.parmDataSyncContext(ctx);
        }
        catch (xppEx)
        {
            logger.logCDXCannotStartDownloadSourceProcessing(xppEx);
            throw error(strFmt("@Retail:DataSyncInvalidInputErrMsg", con2Str(_params)));
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    private void run()
    {
        Microsoft.Dynamics.Ax.Xpp.ErrorException xppEx;
        System.Exception ex;

        try
        {
            logger.logCDXJobDownloadSourceProcessingStart();

            //Create a new download session record. Prepare channel list, LE list.
            //Initialize classes etc.
            if (this.initialize())
            {
                // preprocess before change tracking
                if (translator)
                {
                    translator.preChangeTracking(leContainer);
                }

                this.createPackage();

                this.savePackageToBlob();

                //Update download session information
                this.updateDownloadSession();
            }
        }
        catch (xppEx)
        {
            ex = xppEx;
            logger.logCDXJobDownloadSourceProcessingFailure(ex);

            // Error happened during scheduler job execution. Check infolog for details.
            throw error("@REX1582");
        }
        catch (ex)
        {
            logger.logCDXJobDownloadSourceProcessingFailure(ex);
            error(RetailCDXDataSync::getFriendlyErrorMessage(ex));

            // Error happened during scheduler job execution. Check infolog for details.
            throw error("@REX1582");
        }
        finally
        {
            container exceptions = conNull();
            if (ex != null)
            {
                this.paramErrorFound(true);
                this.parmDataSyncContext().addException(ex);

                Microsoft.Dynamics.Ax.Xpp.ErrorException xppExp2;
                try
                {
                    this.deleteDataFile();
                    this.parmDataSyncContext().setDownloadSessionsAsCreateFailed();
                }
                catch (xppExp2)
                {
                    logger.logCDXJobDownloadSourceProcessingFailure(xppExp2);
                }
                finally
                {
                    if (xppExp2)
                    {
                        this.parmDataSyncContext().addException(xppExp2);
                        exceptions = [ex, xppExp2];
                    }
                    else
                    {
                        exceptions = [ex];
                    }
                }
            }

            //Clean up SyncContext - clean up all temp tables
            this.cleanUp();

            logger.logCDXJobDownloadSourceProcessingStop(exceptions);
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>transformForChannelSchema</Name>
				<Source><![CDATA[
    //Populate temp DB tables specific to the channel schema
    //Used for N-1 data translation.
    private void transformForChannelSchema()
    {
        if (translator)
        {
            // In N-1 multiple legal entities pointing to same channel database is not supported.
            if (conLen(leContainer) > 1)
            {
                throw Global::error("@Retail:LegacyMultipleLegalEntitiesMapToSameChannelDB");
            }

            translator.preDataOutput(leContainer);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPackage</Name>
				<Source><![CDATA[
    private void createPackage()
    {
        Microsoft.Dynamics.Ax.Xpp.ErrorException xppEx;
        System.Exception ex;

        try
        {
            logger.logCDXJobDownloadSourceCreatePackageStart();

            RetailConnSchedulerJobTable job;
            RetailConnSchedulerJobLine jobLine;
            RetailConnSchedulerSubjobTable subJob;

            while select subJob
                exists join jobLine
                    where subJob.subJobId == jobLine.subJobId && subJob.enabled
                exists join job
                    where jobLine.jobId == job.jobId && job.jobId == this.parmDataSyncContext().paramJobID() && jobLine.enabled
            {
                SysDictTable dictTable = new SysDictTable(tableName2Id(subJob.AXTableName));

                if (dictTable != null)
                {
                    if (!dictTable.enabled())
                    {
                        str errorMsg = strFmt("@Retail:CdxTableIsNotReadyForUseWarningMessage", subJob.AXTableName);
                        ApplicationEventSource::EventWriteCDXUserAccessToTableCheckWarning(errorMsg, subJob.AXTableName);
                        warning(errorMsg);
                    }
                    else if (!hasTableAccess(tableName2Id(subJob.AxTableName), AccessType::View))
                    {
                        UserInfo userInfo;
                        select firstonly ObjectId from userInfo where userInfo.id == curUserId();

                        str errorMsg = strFmt("@Retail:CdxUserPermissionOnTableCheckErrorMsg", userInfo.ObjectId, subJob.AXTableName);
                        ApplicationEventSource::EventWriteCDXUserAccessToTableCheckWarning(errorMsg, subJob.AXTableName);
                        warning(errorMsg);
                    }
                    else
                    {
                        RetailCDXDownloadSubjobSourceContext subjobSourceContext = new RetailCDXDownloadSubjobSourceContext(subJob.subJobId, this.parmDataSyncContext(), translator, writer);
                        subjobSourceContext.execute();
                    }
                }
                else
                {
                    str errorMsg = strFmt("@Retail:CdxTableIsNotReadyForUseWarningMessage", subJob.AXTableName);
                    ApplicationEventSource::EventWriteCDXUserAccessToTableCheckWarning(errorMsg, subJob.AXTableName);
                    warning(errorMsg);
                }
            }
        }
        catch (xppEx)
        {
            ex = xppEx;
            logger.logCDXJobDownloadSourceCreatePackageFailure(ex);
            throw error(strFmt("@Retail:CDXPackageGenerationErrMsg", this.parmDataSyncContext().paramJobID()));
        }
        catch (ex)
        {
            logger.logCDXJobDownloadSourceCreatePackageFailure(ex);
            throw error(strFmt("@Retail:CDXPackageGenerationErrMsg", this.parmDataSyncContext().paramJobID()));
        }
        finally
        {
            this.parmDataSyncContext().addException(ex);
            logger.logCDXJobDownloadSourceCreatePackageStop(ex);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>savePackageToBlob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Compresses and uploads the package to blob storage.
    /// </summary>
    private void savePackageToBlob()
    {
        Microsoft.Dynamics.Ax.Xpp.ErrorException xppEx;
        System.Exception ex;

        try
        {
            logger.logCDXJobDownloadSourceSavePackageToBlobStart();

            // endSession will compress and save the package to BLOB
            writer.endSession();
        }
        catch (xppEx)
        {
            ex = xppEx;
            logger.logCDXJobDownloadSourceSavePackageToBlobFailure(ex);
            throw error(strFmt("@Retail:CDXSavePackageToBlobErrMsg", this.parmDataSyncContext().paramJobID(), this.parmDataSyncContext().getSessionNumbers().ToString()));
        }
        catch (ex)
        {
            logger.logCDXJobDownloadSourceSavePackageToBlobFailure(ex);
            throw error(strFmt("@Retail:CDXSavePackageToBlobErrMsg", this.parmDataSyncContext().paramJobID(), this.parmDataSyncContext().getSessionNumbers().ToString()));
        }
        finally
        {
            this.parmDataSyncContext().addException(ex);
            logger.logCDXJobDownloadSourceSavePackageToBlobStop(ex);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipPackageGeneration</Name>
				<Source><![CDATA[
    private boolean shouldSkipPackageGeneration()
    {
        // check if the package generation step should be skipped or not.
        // If the job is marked to be skipped for datasync and the incremental sync is only done against offline datastores then the pkg generation step can be skipped.

        boolean shouldSkipPackageGeneration = true;

        Map sessions = this.parmDataSyncContext().getSessions();
        MapEnumerator sessionsEnumerator = sessions.getEnumerator();

        while (sessionsEnumerator.moveNext())
        {
            RetailCDXDataSyncContextSession sessionCtx = sessionsEnumerator.currentValue();

            if (!(sessionCtx.parmSessionType() == RetailCDXDownloadSessionType::DataFiltered && sessionCtx.parmSkipJobSync() && !this.parmDataSyncContext().paramIsInitSync()))
            {
                shouldSkipPackageGeneration = false;
                break;
            }
        }

        if (shouldSkipPackageGeneration)
        {
            sessionsEnumerator.reset();

            while (sessionsEnumerator.moveNext())
            {
                RetailCDXDataSyncContextSession sessionCtx = sessionsEnumerator.currentValue();
                RetailCDXDownloadSession session;

                ttsbegin;
                select forupdate session where session.Session == sessionCtx.parmSessionNumber();
                session.Status = RetailCDXDownloadSessionStatus::NoData;
                session.update();
                ttscommit;
            }
        }

        return shouldSkipPackageGeneration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLockScope</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the lock scope given the topology of datagroup and datastores.
    /// </summary>
    /// <param name = "_dataGroupRecId">The datagroup RecId value.</param>
    /// <param name = "_dataStoreRecIds">The container with datastore RecIds value.</param>
    /// <returns>If data sync is running for a single datastore (or datagroup with only one datastore), then returns lock name at the database scope; otherwise lock at the datagroup scope.</returns>
    internal static str getLockScope(RefRecId _dataGroupRecId, Set _dataStoreRecIds)
    {
        str hashKey = '';

        if (_dataStoreRecIds.elements() > 0)
        {
            hashKey = 'DS';
            SetEnumerator dataStoreEnumerator = _dataStoreRecIds.getEnumerator();
            while (dataStoreEnumerator.moveNext())
            {
                hashKey += ' ' + int642Str(dataStoreEnumerator.current());
            }
        }
        else
        {
            hashKey = 'DG ' + int642Str(_dataGroupRecId);
        }
        
        return hashKey;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Syncs the data for the session.
    /// </summary>
    /// <param name="params">Parameters required for sync.</param>
    /// <returns>Data sync output.</returns>
    /// <remarks>The statup params should be listed as secified below
    /// [scheduleRecId: int64, dataGroupRecId: int64, jobId: str, lastsyncVer: int64, targetDatastore: container, deleteExistingData: bool, readingOnly: bool, correlationId: guid]
    /// </remarks>
    public static container sync(container params)
    {
        RetailCDXDataSync::syncInternal(params);

        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncInternal</Name>
				<Source><![CDATA[
    internal static RetailCDXDataSyncContext syncInternal(container params)
    {
        RetailCDXDataSync dataSync = RetailCDXDataSync::createInstance();

        dataSync.processParams(params);

        if (dataSync.shouldSwitchToFullSync())
        {
            dataSync.switchToFullSync();
        }

        if (!RetailCdxFeatureControl::IsSkipExecutionWhenSameJobAlreadyInProgressDisabled())
        {
            boolean dataSyncRunSucceeded = false;
            Microsoft.Dynamics.Ax.Xpp.ErrorException errorException;
            RetailCDXDownloadJobSourceLogger logger = dataSync.logger;

            try
			{
				// use fullsync and delta sync locks to prevent the current download job from generating package for the current datagroup if there is already another instance of the same job generating package for the datagroup.
				using (var lock = ReqReaderWriterLock::construct())
				{
					str lockScope = RetailCDXDataSync::getLockScope(dataSync.parmDataSyncContext().paramDataGroupRecID(), dataSync.parmDataSyncContext().getAllDataStores());

                    str fullSyncLockName = InventDim::computeSHA3Hash(strFmt(RetailCDXConstants::DataGroupDownloadJobProcessingLockName, lockScope, dataSync.parmDataSyncContext().paramJobID(), 'fullSync'));
                    str deltaSyncLockName = InventDim::computeSHA3Hash(strFmt(RetailCDXConstants::DataGroupDownloadJobProcessingLockName, lockScope, dataSync.parmDataSyncContext().paramJobID(), 'deltaSync'));

					RetailCDXDataGroup datagroup = RetailCDXDataGroup::find(dataSync.parmDataSyncContext().paramDataGroupRecID());

					if (dataSync.parmDataSyncContext().paramIsInitSync())
					{
						// Try to acquire a fullsync lock on the datagroup for the current job. If it fails to acquire a lock, then it means there is already a full sync in progress hence skip the package generation.
						// No need to check if there is delta sync lock on the datagroup as full sync download package generation is allowed to proceed even if there is a delta sync in progress for the datagroup.
						if (!lock.tryEnterWriterLock(fullSyncLockName))
						{
							logger.logCDXJobDownloadSourceProcessingSkipped();
							warning (strFmt("@Retail:SkipConcurrentDownloadJobPkgGenerationWarning", dataSync.parmDataSyncContext().paramJobID(),  datagroup.Name));
							return dataSync.parmDataSyncContext();
						}
					}
					else
					{
						// Test if there is already a fullsync lock on the datagroup. If the test lock fails (i.e. !ReqReaderWriterLock::testWriter(fullSyncLockName)),
						// then it means there is already another fullsync in progress for this job on this datagroup hence skip delta sync package generation.
						//      Note: Here an actual fullsync lock is not made as a delta sync which is in progress is not supposed to block a full sync.
						// OR
						// Try to acquire delta sync lock on the datagroup for the current job. If it fails to acquire a delta sync lock (i.e. !lock.tryEnterWriterLock(deltaSyncLockName)),
						// then it means there is already a delta sync in progress for this job on this datagroup hence skip the delta sync package generation.
						if (!ReqReaderWriterLock::testWriter(fullSyncLockName) || !lock.tryEnterWriterLock(deltaSyncLockName))
						{
							logger.logCDXJobDownloadSourceProcessingSkipped();
							warning (strFmt("@Retail:SkipConcurrentDownloadJobPkgGenerationWarning", dataSync.parmDataSyncContext().paramJobID(),  datagroup.Name));
							return dataSync.parmDataSyncContext();
						}
					}

					dataSync.run();
					dataSyncRunSucceeded = true;
				}
			}
			catch (errorException)
			{
                // If the exception was thrown after 'dataSync.run()', it was probably at the lock disposal, which we can ignore.
                if (dataSyncRunSucceeded)
                {
                    logger.logCDXJobDownloadSourceProcessingLockFailureAtDisposal(errorException);
                }
                else
                {
                    throw;
                }
            }
        }
        else
        {
            dataSync.run();
        }

        return dataSync.parmDataSyncContext();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSwitchToFullSync</Name>
				<Source><![CDATA[
    private boolean shouldSwitchToFullSync()
    {
        boolean     shouldSwitchToFullSync;

        // check min change tracking row version.
        // if the table marker out of the retention period range, run InitSync
        if (!this.parmDataSyncContext().paramIsInitSync() && this.parmDataSyncContext().paramLastSyncVer() != -1)
        {
            shouldSwitchToFullSync = RetailConnSchedulerJobTable::shouldSwitchToFullSync(this.parmDataSyncContext().paramJobID(), this.parmDataSyncContext().paramDataGroupRecID(), this.parmDataSyncContext().paramLastSyncVer());
        }

        return shouldSwitchToFullSync;
    }

]]></Source>
			</Method>
			<Method>
				<Name>switchToFullSync</Name>
				<Source><![CDATA[
    private void switchToFullSync()
    {
        RetailCDXDataGroup dataGroup;

        // The data changes related to scheduler job xxxx and data group xxxx are no longer available. All data will be sent instead.
        // Contact your SQL administrator to adjust the change tracking retention period.
        select firstonly Name from dataGroup where dataGroup.RecId == this.parmDataSyncContext().paramDataGroupRecID();

        warning(strFmt("@REX4161229",
                    this.parmDataSyncContext().paramJobID(),
                    dataGroup.Name));

        this.parmDataSyncContext().paramDeleteExistingData(true);
        this.parmDataSyncContext().paramLastSyncVer(-1);
        this.parmDataSyncContext().paramIsInitSync(true);
        this.parmDataSyncContext().paramSwitchedToFullSync(NoYes::Yes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWriter</Name>
				<Source><![CDATA[
    private RetailCdxCsvDataOutput getWriter()
    {
        return writer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDictClass</Name>
				<Source><![CDATA[
    private static void validateDictClass(DictClass dc, ClassName className)
    {
        if (!dc)
        {
            throw Global::error(strFmt("@SYS4973", className));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>con2DataSyncContext</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates a data sync context from the specified parameters
    /// </summary>
    /// <param name = "_params">The data sync start up parameters.</param>
    /// <returns>The <c>RetailCDXDataSyncContext</c> object</returns>
    /// <remarks>The statup params should be listd in the as secified below
    /// [scheduleRecId: int64, dataGroupRecId: int64, jobId: str, lastsyncVer: int64, targetDatastore: container, deleteExistingData: bool, readingOnly: bool, correlationId: guid,  ]
    /// </remarks>
    internal static RetailCDXDataSyncContext con2DataSyncContext(container _params)
    {
        if (conLen(_params) < 4)
        {
            // CDX Data sync error: Invalid number of parameters
            throw error("@REX1578");
        }

        RefRecId scheduleRecID          = RetailCDXDataSync::getConValue(Types::Int64, _params, 1);
        RefRecId dataGroupRecID         = RetailCDXDataSync::getConValue(Types::Int64, _params, 2);
        RetailConnJobId jobId           = RetailCDXDataSync::getConValue(Types::String, _params, 3);
        RetailCDXRowVersion lastSyncVer = RetailCDXDataSync::getConValue(Types::Int64, _params, 4);

        RetailCDXDataSyncContext dataSyncContext = new RetailCDXDataSyncContext(scheduleRecID, dataGroupRecID, jobId, lastSyncVer);

        // parses the container of target data stores
        dataSyncContext.initializeSessions(RetailCDXDataSync::getConValueOrDefault(Types::Container, _params, 5));

        dataSyncContext.paramDeleteExistingData(RetailCDXDataSync::getConValueOrDefault(Types::Enum, _params, 6));
        dataSyncContext.paramReadingOnly(RetailCDXDataSync::getConValueOrDefault(Types::Enum, _params, 7));
        dataSyncContext.paramCorrelationId(RetailCDXDataSync::getConValueOrDefault(Types::Guid, _params, 8));
        dataSyncContext.paramBatchJobId(RetailCDXDataSync::getConValueOrDefault(Types::Int64, _params, 9));

        if (dataSyncContext.paramCorrelationId() == nullValueFromType(Types::Guid))
        {
            dataSyncContext.paramCorrelationId(newGuid());
        }

        return dataSyncContext;

    }

]]></Source>
			</Method>
			<Method>
				<Name>getTableIDFromRelation</Name>
				<Source><![CDATA[
    private static TableId getTableIDFromRelation(TableName tableName, str relationName)
    {
        DictRelation dr = new DictRelation(tableName2id(tableName));
        TableId tid = dr.loadNameRelation(relationName);

        return tid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFriendlyErrorMessage</Name>
				<Source><![CDATA[
    private static str getFriendlyErrorMessage(System.Exception ex)
    {
        System.Exception exInner = ex;

        while (exInner)
        {
            if (exInner is Microsoft.WindowsAzure.Storage.StorageException)
            {
                // Windows Azure blob storage service is not available.
                return "@Retail:CdxErrorNoBlobStorageService" + ' ' + ex.ToString();

            }

            exInner = exInner.InnerException;
        }

        return ex ? ex.ToString() : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>getConValue</Name>
				<Source><![CDATA[
    private static anytype getConValue(Types _type, container _params, int _index)
    {
        if (_index <= 0 || conLen(_params) < _index)
        {
            throw error("@Retail:DataSyncParamsIndexOutOfRangeErrMsg");
        }

        anytype result = conPeek(_params, _index);

        if (_type == Types::Int64 && typeOf(result) == Types::Integer)
        {
            return result;
        }

        if (typeOf(result) != _type)
        {
            throw error("@Retail:InvalidArgumentType");
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getConValueOrDefault</Name>
				<Source><![CDATA[
    private static anytype getConValueOrDefault(Types _type, container _params, int _index)
    {
        if (conLen(_params) < _index)
        {
            return nullValueFromType(_type);
        }
        else
        {
            return RetailCDXDataSync::getConValue(_type, _params, _index);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInstance</Name>
				<Source><![CDATA[
    internal static RetailCDXDataSync createInstance()
    {
        RetailCDXDataSync dataSync = new RetailCDXDataSync();

        dataSync.logger = new RetailCDXDownloadJobSourceLogger();

        return dataSync;
    }

]]></Source>
			</Method>
			<Method>
				<Name>AssertUserHasFullReadAccessPermission</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the user has full read access permission
    /// </summary>
    /// <param name = "_userID">This carries the current user</param>
    internal static void AssertUserHasFullReadAccessPermission(UserId _userID)
    {
        System.Exception ex;
        boolean warningOnly;
        str errorMsg;

        warningOnly = RetailCdxFeatureControl::IsCheckUserPermissionDuringCdxExecutionDisabled();
        if (warningOnly)
        {
            try
            {
                errorMsg = RetailCDXDataSync::GetFullReadAccessPermissionError(_userID);
                if (errorMsg)
                {
                    warning(errorMsg);
                }
            }   
            catch (ex)
            {
                // when feature is disabled, still check permission and log error, but don't throw exception
            }
        }
        else
		{
            errorMsg = RetailCDXDataSync::GetFullReadAccessPermissionError(_userID);
            if (errorMsg)
            {
                throw error(errorMsg);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetFullReadAccessPermissionError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the given user has full permissions to all organizations which is a requirement for CDX.
    /// </summary>
    /// <param name = "_userID">The user running CDX data sync job.</param>
    /// <returns>The respective error message, or empty string if the user has all the required permissions.</returns>
    internal static str GetFullReadAccessPermissionError(UserId _userID)
    {
        SecurityUserRole        securityUserRole;
        SecurityRole            securityRole;
        str errorMsg;
        #define.AdminRole('-SYSADMIN-')

        // check if user exists.
        UserInfo userInfo;
        select firstOnly ObjectId, RecId from userInfo where userInfo.id == _userID;

        if (!userInfo.RecId)
        {
            errorMsg = strFmt("@Retail:CdxUserPermissionUserNotFound", _userId);
            ApplicationEventSource::EventWriteCDXUserFullAccessCheckWarning(errorMsg);

            return errorMsg;
        }

        // check security roles.
        select firstOnly RecId from securityUserRole where securityUserRole.User == _userID;

        if (!securityUserRole.RecId)
        {
            errorMsg = strFmt("@Retail:CdxUserPermissionNoSecurityRoleCheckErrorMsg", userInfo.ObjectId);
            ApplicationEventSource::EventWriteCDXUserFullAccessCheckWarning(errorMsg);
            
            return errorMsg;
        }

        //check if user is mapped to 'System administrator' role then no need to check permissions for other roles
        select RecId from securityUserRole
            join securityRole
                where securityUserRole.SecurityRole == securityRole.recid
                    && securityUserRole.User == _userID
                    && securityRole.AotName == #AdminRole;

        if (securityUserRole.RecId)
        {
            return errorMsg;
        }
        
        //check if user is mapped to any security role that has organization limitations
        OMUserRoleOrganization  omUserRoleOrganization;

        select firstonly RecId from securityUserRole
            join securityRole
                where securityUserRole.SecurityRole == securityRole.recid
                    &&  securityUserRole.User == _userID
            exists join omUserRoleOrganization
                where  securityRole.recid == omUserRoleOrganization.SecurityRole
                    && securityUserRole.user == omUserRoleOrganization.User;

        //If any LE related role is found, then throw an exception
        if (securityUserRole.RecId > 0)
        {
            errorMsg = strFmt("@Retail:CdxUserPermissionCheckErrorMsg", userInfo.ObjectId);
            ApplicationEventSource::EventWriteCDXUserFullAccessCheckWarning(errorMsg);

            return errorMsg;
        }

        //check if user is mapped to atleast one security role with XDS
        ModelSecPolRuntimeEx modelSecPolRuntimeEx;

        select firstonly RecId from securityUserRole
            join securityRole
                where securityUserRole.SecurityRole == securityRole.recid
                    && securityUserRole.User == _userID
            exists join modelSecPolRuntimeEx
                where  securityRole.AotName == modelSecPolRuntimeEx.ContextString;
            
        //If any XDS role is found, then throw an exception
        if (securityUserRole.RecId)
        {
            errorMsg = strFmt("@Retail:CdxUserXdsRoleCheckErrorMsg", userInfo.ObjectId);
            ApplicationEventSource::EventWriteCDXUserFullAccessCheckWarning(errorMsg);
            
            return errorMsg;
        }

        return errorMsg;

    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>