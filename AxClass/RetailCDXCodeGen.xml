<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailCDXCodeGen</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Retail.SynchLibrary.CodeGen;

/// <summary>
/// Retail CDX code generation.
/// </summary>
class RetailCDXCodeGen
{
    DistributionCodeGen codeGenContext;
    RetailConnChannelSchema channelSchema;

    Set immutableFieldNames;

    date lowerDate, upperDate;
    utcDateTime lowerDateTime, upperDateTime;

    #RetailCDXCodeGen
    private const str SourceTableDataSourceLabel = 'SourceTableDS';

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addFieldInfo_subjob</Name>
				<Source><![CDATA[
    private void addFieldInfo_subjob()
    {
        #RetailCDX
        RetailConnSchedulerSubjobTable schedulerSubJob;

        while select subJobId, AXTableName
            from schedulerSubJob
                where schedulerSubJob.dataReplicationByPull == NoYes::No
                && schedulerSubJob.RetailConnChannelSchema == channelSchema.RecId
        {
            // if this is a temp table - select the fields of its related tables and assume all fields need to be tracked, this is done since
            // we currently have no good way of knowing which fields from related tables participate in populating the temp table.
            // Selecting the "participating("interested") fields here is needed by the DistributionCodeGenAux.cs class' GetUpdateCTQuery(..) method
            // which decides how granular the change tracking on the table should be. (i.e. table level vs column level).
            if (RetailConnReplicationUtilities::isTableTempDB(schedulerSubJob.AXTableName))
            {
                // process related tables if the source table is a temporary table.
                int relatedTableCounter = 0;
                TableId relatedTableId = RetailConnReplicationUtilities::getTableIDFromRelation(schedulerSubJob.AXTableName, #RelTableRelationName);

                if (relatedTableId <= 0)
                {
                    // Main counterpart table is missing for AX source TempDB table: %1
                    throw Global::error(strFmt("@REX1571", schedulerSubJob.AXTableName));
                }

                while (relatedTableId)
                {
                    DistributionTableField tableField = new DistributionTableField(relatedTableId, 0);
                    // since this table may not have been used in any subjob we should assume all fields are required.
                    container interestedFields = this.getInterestedFieldsFromTable(relatedTableId);

                    if (conLen(interestedFields) > 0)
                    {
                        for (int i = 1; i <= conLen(interestedFields); ++i)
                        {
                            DictField df = new DictField(relatedTableId, fieldName2id(relatedTableId, conPeek(interestedFields, i)));
                            tableField.AddFieldInfo(df.name(), df.name(DbBackend::Sql), enum2int(df.baseType()));
                        }

                        codeGenContext.AddTableField(tableField);
                    }

                    relatedTableCounter++;
                    relatedTableId = RetailConnReplicationUtilities::getTableIDFromRelation(schedulerSubJob.AXTableName, #RelTableRelationName + int2str(relatedTableCounter));
                }
            }
            else
            {
                TableId axTableId = tableName2id(schedulerSubJob.AXTableName);
                DistributionTableField tableField = new DistributionTableField(axTableId, 0);

                container interestedFields = this.getInterestedFields(schedulerSubJob);

                if (conLen(interestedFields) > 0)
                {
                    for (int i = 1; i <= conLen(interestedFields); ++i)
                    {
                        DictField df = new DictField(axTableId, fieldName2id(axTableId, conPeek(interestedFields, i)));

                        // Check if the field is available in Table.
                        if (!df)
                        {
                            throw error(strFmt("@Retail:RetailFieldNotFoundInTable",
                                                conPeek(interestedFields, i), schedulerSubJob.AXTableName, schedulerSubJob.subJobId));
                        }
                        
                        tableField.AddFieldInfo(df.name(), df.name(DbBackend::Sql), enum2int(df.baseType()));
                    }

                    codeGenContext.AddTableField(tableField);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFieldInfo_treeNode</Name>
				<Source><![CDATA[
    private void addFieldInfo_treeNode()
    {
        DataDistributionNode treeRootNode = codeGenContext.GetTreeRoot();
        DataDistributionNodeCollection rootChildNodes = treeRootNode.Children;

        for (int i = 0; i < rootChildNodes.Count; ++i)
        {
            DataDistributionNode childNode = rootChildNodes.get_Item(i);
            this.fillNode(childNode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addNonChannelSpecificTables</Name>
				<Source><![CDATA[
    private void addNonChannelSpecificTables()
    {
        #RetailCDX

        RetailConnSchedulerJobTable job;
        RetailConnSchedulerSubjobTable subJob;
        RetailConnSchedulerJobLine jobLine;

        while select AXTableName
            from subJob
                where subJob.dataReplicationByPull == NoYes::No
            exists join jobLine
                where jobLine.subJobId == subJob.subJobId
            exists join job
                where job.jobId == jobLine.jobId
                   && job.RetailConnChannelSchema == channelSchema.RecId
        {
            if (RetailConnReplicationUtilities::isTableTempDB(subJob.AXTableName))
            {
                // process related tables if the source table is a temporary table.
                int relatedTableCounter = 0;
                TableId relatedTableId = RetailConnReplicationUtilities::getTableIDFromRelation(subJob.AXTableName, #RelTableRelationName);

                if (relatedTableId <= 0)
                {
                    // Main counterpart table is missing for AX source TempDB table: %1
                    throw Global::error(strFmt("@REX1571", subJob.AXTableName));
                }

                while (relatedTableId)
                {
                    str axTableName = tableId2name(relatedTableId);
                    codeGenContext.AddNonChannelSpecificTable(axTableName);

                    relatedTableCounter++;
                    relatedTableId = RetailConnReplicationUtilities::getTableIDFromRelation(subJob.AXTableName, #RelTableRelationName + int2str(relatedTableCounter));
                }
            }
            else
            {
                str axTableName = subJob.AXTableName;
                codeGenContext.AddNonChannelSpecificTable(axTableName);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildBaseQuery</Name>
				<Source><![CDATA[
    private void buildBaseQuery(DataDistributionNode node)
    {
        Query q = new Query();

        DataDistributionNodeCollection baseQueryNodeCollection = node.GetBaseQueryNodeCollection();
        System.Collections.Specialized.StringCollection tableLinks = node.GetQueryTableLinks();

        Map fromToDataSources = new Map(Types::String, Types::String);

        // There is no method to get the GroupBy Fields from the QueryBuildDataSource object so we have to use this map to work around that limitation.
        Map groupByFieldMap = new Map(Types::String, Types::Container); //dsname, group by field Id list

        QueryBuildDataSource dsMain, ds;
        TableId tid, lastTableId;
        str previousDsName;
        boolean lastNodeSkipped;

        for (int i = 0; i < baseQueryNodeCollection.Count; ++i)
        {
            DataDistributionNode currentNode = baseQueryNodeCollection.get_Item(i);

            int depth = currentNode.get_Depth();
            str dsName = strFmt('t%1', depth);
            tid = currentNode.TableID;

            if (i == 0)
            {
                dsMain = q.addDataSource(tid, dsName);
                dsMain.addGroupByField(fieldName2id(tid, 'RecId'));
                groupByFieldMap.insert(dsName, [fieldName2id(tid, 'RecId')]);
                dsMain.fields().dynamic(NoYes::No);
                dsMain.label(RetailCDXCodeGen::SourceTableDataSourceLabel);

                // if the table node is not joined/linked with any other table in the table-distribution xml (i.e.. if the table node doesn't have other nested table nodes)
                // then add the condition directly on the datasource that is created for the table.
                if (baseQueryNodeCollection.Count == 1)
                {
                    str filterValue = tableLinks.get_Item(baseQueryNodeCollection.Count - 1);

                    // if there is table filter on the root table (root table will not have any joined condition),
                    // add the filter to the datasource
                    if (filterValue)
                    {
                        QueryBuildRange range = dsMain.addRange(fieldName2id(tid, 'RecId'));
                        range.value(filterValue);
                    }
                }

                ds = dsMain;
            }
            else
            {
                // current filter (the link between current node and its child node + other current node filters)
                str filterValue = tableLinks.get_Item(i - 1);

                // If we skipped last node, it means that it was a parent data source joined with its child only by recId
                // As this is redundant and compromises query performance, we skipped it.
                // As a consequence, here, we need to remap the target datasource from the previous one to its child.
                // Thus from depth + 1 (previous) to depth + 2 (previous' child)
                if (lastNodeSkipped)
                {
                    filterValue     = strReplace(filterValue, strFmt('t%1', depth + 1), strFmt('t%1', depth + 2));
                    lastNodeSkipped = false;
                    fromToDataSources.insert(previousDsName, dsName);
                }
                else if (tid != tableNum(RetailChannelTable))
                {
                    SysDictTable dictTable = new SysDictTable(lastTableId);
                    
                    if (dictTable.isDerivedFrom(tableId2Name(tid)))
                    {
                        // If the previous node is derived from current node and the relation between both are
                        // only through RecId, we should skip the current node.
                        if (filterValue == strFmt('((t%1.RecId==t%2.RecId))', depth + 1, depth))
                        {
                            lastNodeSkipped = true;
                            previousDsName = dsName;

                            continue;
                        }
                    }
                }

                ds = ds.addDataSource(tid, dsName);
                ds.fields().dynamic(NoYes::No);
                ds.joinMode(JoinMode::InnerJoin);
                ds.relations(false);

                if (filterValue)
                {
                    QueryBuildRange range = ds.addRange(fieldName2id(tid, 'RecId'));
                    range.value(filterValue);
                }
            }

            lastTableId = tid;
        }

        // RetailCDXTargetChannel
        if (tid == tableNum(RetailChannelTable))
        {
            ds = ds.addDataSource(tableNum(RetailCDXTargetChannel), #TargetChannelDSName);
            ds.fields().dynamic(NoYes::No);
            ds.joinMode(JoinMode::InnerJoin);
            ds.relations(false);
            ds.addLink(fieldNum(RetailChannelTable, RecId), fieldNum(RetailCDXTargetChannel, Channel));
        }

        ValidTimeStateType validTimeStateType = node.GetQueryValidTimeState();

        if (validTimeStateType == ValidTimeStateType::Date)
        {
            q.validTimeStateDateRange(lowerDate, upperDate);
        }
        else if (validTimeStateType == ValidTimeStateType::DateTime)
        {
            q.validTimeStateDateTimeRange(lowerDateTime, upperDateTime);
        }

        q.clearAllFields();

        RetailCDXSqlQueryID queryID = node.NodeID;
        RetailCDXEntityType entityType = node.get_EntityType();
        boolean shouldLoopThroughCompanies = node.ShouldLoopThroughCompanies();

        RetailCDXDataDistributionQuery ddQuery;
        ddQuery.initValue();
        ddQuery.RetailConnChannelSchema = channelSchema.RecId;
        ddQuery.RefTableID = dsMain.table();
        ddQuery.QueryID = queryID;
        ddQuery.IsGlobal = shouldLoopThroughCompanies ? NoYes::No : NoYes::Yes;
        ddQuery.PackedQuery = q.pack();
        ddQuery.EntityType = entityType;
        ddQuery.insert();

        System.Collections.Specialized.StringCollection queryFilters = codeGenContext.GetQueryFilters(node);

        int depth = node.get_Depth();

        for (int i = 0; i < queryFilters.Count; ++i)
        {
            str filterValue = queryFilters.get_Item(i);
            str dsName = strFmt('t%1', depth - i);

            // if the node was skipped, instead of linking with the parent, we should link with its grandparent.
            if (fromToDataSources.exists(dsName))
            {
                dsName = fromToDataSources.lookup(dsName);
            }

            RetailCDXDataDistributionQueryFilter ddQueryFilter;
            ddQueryFilter.initValue();
            ddQueryFilter.RetailConnChannelSchema = channelSchema.RecId;
            ddQueryFilter.QueryID = queryID;
            ddQueryFilter.FilterID = i + 1;
            ddQueryFilter.LinkSourceName = dsName;
            ddQueryFilter.Filter = filterValue;
            ddQueryFilter.insert();
        }

        // for cache based delta sync approach create the node level change detection query relying on the base query.
        QueryBuildDataSource changeTrackingTempTableDS = q.dataSourceNo(q.dataSourceCount()).addDataSource(tableNum(RetailCDXChangeRefTable1), #Ref1DSName);
        changeTrackingTempTableDS.addGroupByField(fieldNum(RetailCDXChangeRefTable1, NodeID));
        groupByFieldMap.insert(#Ref1DSName, [fieldNum(RetailCDXChangeRefTable1, NodeID)]);

        changeTrackingTempTableDS.fields().dynamic(NoYes::No);
        changeTrackingTempTableDS.joinMode(JoinMode::InnerJoin);
        changeTrackingTempTableDS.relations(false);
        QueryBuildRange refTableIdrange = changeTrackingTempTableDS.addRange(fieldNum(RetailCDXChangeRefTable1, RefTableId));
        refTableIdrange.value(int2Str(dsMain.table()));

        changeTrackingTempTableDS.clearLinks();
        changeTrackingTempTableDS.addLink(fieldName2id(dsMain.table(), 'RecId'), fieldNum(RetailCDXChangeRefTable1, RefRecId), dsMain.name());

        if (!RetailCDXCodeGen::isRemoveCdxNodeConstTableFromQueryFlightEnabled())
        {
            QueryBuildDataSource nodeConstantsTempTableDS = q.dataSourceNo(q.dataSourceCount()).addDataSource(tableNum(RetailTmpCDXNodeConstTable), tableStr(RetailTmpCDXNodeConstTable));
            nodeConstantsTempTableDS.addGroupByField(fieldNum(RetailTmpCDXNodeConstTable, NodeID));
            nodeConstantsTempTableDS.addGroupByField(fieldNum(RetailTmpCDXNodeConstTable, SkipRecord));
            groupByFieldMap.insert(tableStr(RetailTmpCDXNodeConstTable), [fieldNum(RetailTmpCDXNodeConstTable, NodeID), fieldNum(RetailTmpCDXNodeConstTable, SkipRecord)]);

            nodeConstantsTempTableDS.fields().dynamic(NoYes::No);
            nodeConstantsTempTableDS.joinMode(JoinMode::InnerJoin);
            nodeConstantsTempTableDS.relations(false);
        }

        container packedQuery = this.optimizeJoinOrderAndPack(q, groupByFieldMap, validTimeStateType);

        ddQuery.clear();
        ddQuery.initValue();
        ddQuery.RetailConnChannelSchema = channelSchema.RecId;
        ddQuery.RefTableID = dsMain.table();
        ddQuery.QueryID = queryID;
        ddQuery.IsGlobal = shouldLoopThroughCompanies ? NoYes::No : NoYes::Yes;
        ddQuery.IsCacheBasedQuery = NoYes::Yes;
        ddQuery.NodeLevelValueChangeSelectorQuery = packedQuery;
        ddQuery.EntityType = entityType;
        ddQuery.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCacheBasedQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new cache based query.
    /// </summary>
    /// <param name = "node">Current node from data distribution xml file.</param>
    private void buildCacheBasedQuery(DataDistributionNode node)
    {
        TableId tid;
        TableId mainTableId;
        QueryBuildDataSource ds;
        Query q = new Query();
     
        // get main node and all parent nodes
        DataDistributionNodeCollection baseQueryNodeCollection = node.GetBaseQueryNodeCollection();

        // get link values for main node and all parent node
        // all link values for one node will be in one string
        System.Collections.Specialized.StringCollection tableLinks = node.GetQueryTableLinks();
        int baseQueryNodeCount = baseQueryNodeCollection.Count;

        for (int i = 0; i < baseQueryNodeCount; ++i)
        {
            DataDistributionNode currentNode = baseQueryNodeCollection.get_Item(i);

            int depth = currentNode.get_Depth();
            str dsName = strFmt('t%1', depth);
            tid = currentNode.TableID;

            if (i == 0)
            {
                QueryBuildDataSource dsMain = q.addDataSource(tid, dsName);
                dsMain.addGroupByField(fieldName2id(tid, 'RecId'));
                dsMain.fields().dynamic(NoYes::No);
                dsMain.label(RetailCDXCodeGen::SourceTableDataSourceLabel);

                // if the table node is not joined/linked with any other table in the table-distribution xml (i.e.. if the table node doesn't have other nested table nodes)
                // then add the condition directly on the datasource that is created for the table.
                if (baseQueryNodeCount == 1)
                {
                    str mainNodefilterValue = tableLinks.get_Item(baseQueryNodeCount - 1);

                    // if there is table filter on the root table (root table will not have any joined condition),
                    // add the filter to the datasource
                    if (mainNodefilterValue)
                    {
                        QueryBuildRange mainNodeRange = dsMain.addRange(fieldName2id(tid, 'RecId'));
                        mainNodeRange.value(mainNodefilterValue);
                    }
                }

                ds = dsMain;
                mainTableId = tid;
            }
            else
            {
                // generate new query for cache based data filter
                if (i == 1)
                {
                    QueryBuildDataSource parentNodeDS, originalParentTableDS;

                    // current filter (the link between current node and its child node + other current node filters)
                    str parentNodeFilterValue = tableLinks.get_Item(i - 1);

                    // if the table is linked with its parent on the parent's RecId only then we can directly join the table with
                    // the RetailTmpCDXDataDistributionFilteredRecords RefRecId column as that table contains the filtered record list of the parent.
                    //
                    // So the below query (where t2 is child node and t1 represent parent node) will be simplified by removing one extra join as shown in the second query
                    // t2
                    // inner join t1 on t2.Product = t1.RecId
                    // inner join RetailTmpCDXDataDistributionFilteredRecords on t1.RecId =  RetailTmpCDXDataDistributionFilteredRecords.RefRecID
                    //
                    // t2
                    // inner join RetailTmpCDXDataDistributionFilteredRecords on t2.Product =  RetailTmpCDXDataDistributionFilteredRecords.RefRecID
                    //
                    if (this.isLinkedWithParentOnParentRecIdOnly(node))
                    {
                        parentNodeDS = ds.addDataSource(tableNum(RetailTmpCDXDataDistributionFilteredRecords), currentNode.Get_TableName());
                        parentNodeFilterValue = strReplace(parentNodeFilterValue, strFmt('==t%1.RecId', depth), strFmt('==%1.RefRecId', currentNode.Get_TableName()));
                        parentNodeDS.addRange(fieldNum(RetailTmpCDXDataDistributionFilteredRecords, RecId)).value(parentNodeFilterValue);
                    }
                    else
                    {
                        originalParentTableDS = ds.addDataSource(tid, dsName);
                        originalParentTableDS.fields().dynamic(NoYes::No);
                        originalParentTableDS.joinMode(JoinMode::InnerJoin);
                        originalParentTableDS.relations(false);

                        if (parentNodeFilterValue)
                        {
                            QueryBuildRange parentNodeRange = originalParentTableDS.addRange(fieldName2id(tid, 'RecId'));
                            parentNodeRange.value(parentNodeFilterValue);
                        }

                        parentNodeDS = originalParentTableDS.addDataSource(tableNum(RetailTmpCDXDataDistributionFilteredRecords), currentNode.Get_TableName());
                        parentNodeDS.addLink(fieldName2Id(mainTableId, 'RecId'), fieldNum(RetailTmpCDXDataDistributionFilteredRecords, RefRecID));
                    }

                    parentNodeDS.fields().dynamic(NoYes::No);
                    parentNodeDS.joinMode(JoinMode::InnerJoin);
                    parentNodeDS.relations(false);
                    parentNodeDS.addRange(fieldNum(RetailTmpCDXDataDistributionFilteredRecords, NodeId)).value(int2Str(currentNode.get_NodeId()));

                    // since we only need main node and its parent node to generate cache based query, no need to loop all the parent node, so stop at parent node
                    break;
                }
            }
        }

        // only add target channel temp table for the root RetailChannelTable node
        if (tid == tableNum(RetailChannelTable) && baseQueryNodeCount == 1)
        {
            ds = ds.addDataSource(tableNum(RetailCDXTargetChannel), #TargetChannelDSName);
            ds.fields().dynamic(NoYes::No);
            ds.joinMode(JoinMode::InnerJoin);
            ds.relations(false);
            ds.addLink(fieldNum(RetailChannelTable, RecId), fieldNum(RetailCDXTargetChannel, Channel));
        }

        ValidTimeStateType validTimeStateType = node.GetQueryValidTimeState();

        if (validTimeStateType == ValidTimeStateType::Date)
        {
            q.validTimeStateDateRange(lowerDate, upperDate);
        }
        else if (validTimeStateType == ValidTimeStateType::DateTime)
        {
            q.validTimeStateDateTimeRange(lowerDateTime, upperDateTime);
        }

        if (!RetailCDXCodeGen::isRemoveCdxNodeConstTableFromQueryFlightEnabled())
        {
            // add nodeId temp table because x++ does not allow to use constant value in insert statement
            QueryBuildDataSource nodeConstDS = q.dataSourceNo(q.dataSourceCount()).addDataSource(tableNum(RetailTmpCDXNodeConstTable), tableStr(RetailTmpCDXNodeConstTable));
            nodeConstDS.addGroupByField(fieldNum(RetailTmpCDXNodeConstTable, NodeID));
            nodeConstDS.addGroupByField(fieldNum(RetailTmpCDXNodeConstTable, SkipRecord));

            nodeConstDS.fields().dynamic(NoYes::No);
            nodeConstDS.joinMode(JoinMode::InnerJoin);
            nodeConstDS.relations(false);
        }

        q.clearAllFields();
        container packedQuery= q.pack();

        RetailCDXSqlQueryID queryID = node.NodeID;
        RetailCDXEntityType entityType = node.get_EntityType();

        RetailCDXDataDistributionQuery dataDistributionQuery;

        select forupdate dataDistributionQuery
            where dataDistributionQuery.QueryId == queryID &&
                dataDistributionQuery.RetailConnChannelSchema == channelSchema.RecId &&
                dataDistributionQuery.IsCacheBasedQuery == NoYes::Yes;

        // the above query should always return a single row as the RetailCDXDataDistributionQuery.NodeLevelValueChangeSelectorQuery query is already constructed (in the buildBaseQuery method)
        // and is inserted to the RetailCDXDataDistributionQuery table the time we reach this point.
        // so this if clause is added just for safety.
        if (!dataDistributionQuery)
        {
            boolean shouldLoopThroughCompanies = node.ShouldLoopThroughCompanies();
            dataDistributionQuery.initValue();
            dataDistributionQuery.RetailConnChannelSchema = channelSchema.RecId;
            dataDistributionQuery.RefTableID = mainTableId;
            dataDistributionQuery.QueryID = queryID;
            dataDistributionQuery.IsGlobal = shouldLoopThroughCompanies ? NoYes::No : NoYes::Yes;
            dataDistributionQuery.PackedQuery = packedQuery;
            dataDistributionQuery.EntityType = entityType;
            dataDistributionQuery.IsCacheBasedQuery = NoYes::Yes;
        }
        else
        {
            dataDistributionQuery.PackedQuery = packedQuery;
        }

        // set the propagated optimization property of distribution query node. 
        dataDistributionQuery.IsOptimizedPropagation = node.IsPropagatedOptimizationEnabled ? NoYes::Yes : NoYes::No;
        
        // builds the cache based delta queries and sets fields cacheBasedNodeLevelValueChangeSelectorQuery and PropagatedChangeSelectorQuery on dataDistributionQuery
        this.buildCacheBasedDeltaQuery(node, dataDistributionQuery);

        // save the generated packed queries used for the cache based delta sync approach.
        dataDistributionQuery.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCacheBasedQuery_Optimized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new cache based query.
    /// </summary>
    /// <param name = "node">Current node from data distribution xml file.</param>
    private void buildCacheBasedQuery_Optimized(DataDistributionNode node)
    {
        // get main node and all parent nodes
        DataDistributionNodeCollection baseQueryNodeCollection = node.GetBaseQueryNodeCollection();

        // get link values for main node and all parent node
        // all link values for one node will be in one string
        System.Collections.Specialized.StringCollection tableLinks = node.GetQueryTableLinks();
        int baseQueryNodeCount = baseQueryNodeCollection.Count;

        DataDistributionNode mainTableNode = node;
        DataDistributionNode parentTableNode = node.Parent && node.Parent.TableID != 0 ? node.Parent : null;

        Query query = new Query();

        if (parentTableNode) //if there is a parent node
        {
            QueryBuildDataSource filteredRecordsNodeDS, parentTableDS;

            // current filter (the link between current node and its child node + other current node filters)
            filteredRecordsNodeDS = query.addDataSource(tableNum(RetailTmpCDXDataDistributionFilteredRecords), parentTableNode.Get_TableName());
            filteredRecordsNodeDS.fields().dynamic(NoYes::No);
            filteredRecordsNodeDS.joinMode(JoinMode::InnerJoin);
            filteredRecordsNodeDS.relations(false);
            filteredRecordsNodeDS.addRange(fieldNum(RetailTmpCDXDataDistributionFilteredRecords, NodeId)).value(int2Str(parentTableNode.get_NodeId()));

            // if the table is linked with its parent on the parent's RecId only then we can directly join the table with
            // the RetailTmpCDXDataDistributionFilteredRecords RefRecId column as that table contains the filtered record list of the parent.
            //
            // So the below query (where t2 is child node and t1 represent parent node) will be simplified by removing one extra join as shown in the second query
            // t2
            // inner join t1 on t2.Product = t1.RecId
            // inner join RetailTmpCDXDataDistributionFilteredRecords on t1.RecId =  RetailTmpCDXDataDistributionFilteredRecords.RefRecID
            //
            // t2
            // inner join RetailTmpCDXDataDistributionFilteredRecords on t2.Product =  RetailTmpCDXDataDistributionFilteredRecords.RefRecID
            //
            if (!this.isLinkedWithParentOnParentRecIdOnly(node))
            {
                str parentTableDsName = strFmt('t%1', parentTableNode.Depth);
                parentTableDS = filteredRecordsNodeDS.addDataSource(parentTableNode.TableID, parentTableDsName);
                parentTableDS.fields().dynamic(NoYes::No);
                parentTableDS.joinMode(JoinMode::InnerJoin);
                parentTableDS.relations(false);

                parentTableDS.addLink(fieldNum(RetailTmpCDXDataDistributionFilteredRecords, RefRecID), fieldName2Id(parentTableNode.TableID, 'RecId'));
            }
        }

        QueryBuildDataSource dsMain;
        str mainTableDsName = strFmt('t%1', mainTableNode.Depth);
        if (parentTableNode == null) // if there is no parent node
        {
            dsMain = query.addDataSource(mainTableNode.TableID, mainTableDsName);
        }
        else
        {
            dsMain = query.dataSourceNo(query.dataSourceCount()).addDataSource(mainTableNode.TableID, mainTableDsName);
        }
        
        dsMain.addGroupByField(fieldName2id(mainTableNode.TableID, 'RecId'));

        dsMain.fields().dynamic(NoYes::No);
        dsMain.label(RetailCDXCodeGen::SourceTableDataSourceLabel);

        str mainNodefilterValue = tableLinks.get_Item(0);

        // if there is table filter on the root table (root table will not have any joined condition),
        // add the filter to the datasource
        if (mainNodefilterValue)
        {
            if (this.isLinkedWithParentOnParentRecIdOnly(node))
            {
                mainNodefilterValue = strReplace(mainNodefilterValue, strFmt('==t%1.RecId', parentTableNode.Depth), strFmt('==%1.RefRecId', parentTableNode.Get_TableName()));
            }
            QueryBuildRange mainNodeRange = dsMain.addRange(fieldName2id(mainTableNode.TableID, 'RecId'));
            mainNodeRange.value(mainNodefilterValue);
        }

        // only add target channel temp table for the root RetailChannelTable node
        if (mainTableNode.TableID == tableNum(RetailChannelTable) && baseQueryNodeCount == 1)
        {
            QueryBuildDataSource targetChannelDS = dsMain.addDataSource(tableNum(RetailCDXTargetChannel), #TargetChannelDSName);
            targetChannelDS.fields().dynamic(NoYes::No);
            targetChannelDS.joinMode(JoinMode::InnerJoin);
            targetChannelDS.relations(false);
            targetChannelDS.addLink(fieldNum(RetailChannelTable, RecId), fieldNum(RetailCDXTargetChannel, Channel));
        }

        ValidTimeStateType validTimeStateType = node.GetQueryValidTimeState();
        if (validTimeStateType == ValidTimeStateType::Date)
        {
            query.validTimeStateDateRange(lowerDate, upperDate);
        }
        else if (validTimeStateType == ValidTimeStateType::DateTime)
        {
            query.validTimeStateDateTimeRange(lowerDateTime, upperDateTime);
        }

        if (!RetailCDXCodeGen::isRemoveCdxNodeConstTableFromQueryFlightEnabled())
        {
            // add nodeId temp table because x++ does not allow to use constant value in insert statement
            QueryBuildDataSource nodeConstDS = query.dataSourceNo(query.dataSourceCount()).addDataSource(tableNum(RetailTmpCDXNodeConstTable), tableStr(RetailTmpCDXNodeConstTable));
            nodeConstDS.addGroupByField(fieldNum(RetailTmpCDXNodeConstTable, NodeID));
            nodeConstDS.addGroupByField(fieldNum(RetailTmpCDXNodeConstTable, SkipRecord));

            nodeConstDS.fields().dynamic(NoYes::No);
            nodeConstDS.joinMode(JoinMode::InnerJoin);
            nodeConstDS.relations(false);
        }

        query.clearAllFields();

        container packedQuery= query.pack();

        RetailCDXSqlQueryID queryID = node.NodeID;
        RetailCDXEntityType entityType = node.get_EntityType();
        
        RetailCDXDataDistributionQuery dataDistributionQuery;
        
        select forupdate dataDistributionQuery
            where dataDistributionQuery.QueryId == queryID &&
                dataDistributionQuery.RetailConnChannelSchema == channelSchema.RecId &&
                dataDistributionQuery.IsCacheBasedQuery == NoYes::Yes;

        // the above query should always return a single row as the RetailCDXDataDistributionQuery.NodeLevelValueChangeSelectorQuery query is already constructed (in the buildBaseQuery method)
        // and is inserted to the RetailCDXDataDistributionQuery table the time we reach this point.
        // so this if clause is added just for safety.
        if (!dataDistributionQuery)
        {
            boolean shouldLoopThroughCompanies = node.ShouldLoopThroughCompanies();
            dataDistributionQuery.initValue();
            dataDistributionQuery.RetailConnChannelSchema = channelSchema.RecId;
            dataDistributionQuery.RefTableID = mainTableNode.TableID;
            dataDistributionQuery.QueryID = queryID;
            dataDistributionQuery.IsGlobal = shouldLoopThroughCompanies ? NoYes::No : NoYes::Yes;
            dataDistributionQuery.PackedQuery = packedQuery;
            dataDistributionQuery.EntityType = entityType;
            dataDistributionQuery.IsCacheBasedQuery = NoYes::Yes;
        }
        else
        {
            dataDistributionQuery.PackedQuery = packedQuery;
        }

        // set the propagated optimization property of distribution query node.
        dataDistributionQuery.IsOptimizedPropagation = node.IsPropagatedOptimizationEnabled ? NoYes::Yes : NoYes::No;
        
        // builds the cache based delta queries and sets fields cacheBasedNodeLevelValueChangeSelectorQuery and PropagatedChangeSelectorQuery on dataDistributionQuery
        this.buildCacheBasedDeltaQuery(node, dataDistributionQuery);

        // save the generated packed queries used for the cache based delta sync approach.
        dataDistributionQuery.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCacheBasedDeltaQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new cache based query.
    /// </summary>
    /// <param name = "node">Current node from data distribution xml file.</param>
    /// <param name = "dataDistributionQuery">Data distribution query.</param>
    private void buildCacheBasedDeltaQuery(DataDistributionNode node, RetailCdxDataDistributionQuery dataDistributionQuery)
    {
        Query cacheBasedNodeLevelValueChangeSelectorQuery = this.buildCacheBasedNodeLevelValueChangeSelectorQuery(node);
        dataDistributionQuery.cacheBasedNodeLevelValueChangeSelectorQuery = cacheBasedNodeLevelValueChangeSelectorQuery.pack();

        Query propagatedChangeSelectorQuery;
        if (this.isDataFilterQueryJoinOrderOptimizationFlightEnabled())
        {
            propagatedChangeSelectorQuery = this.buildCacheBasedPropagatedChangeSelectorQuery_Optimized(node);
        }
        else
        {
            propagatedChangeSelectorQuery = this.buildCacheBasedPropagatedChangeSelectorQuery(node);
        }

        if (propagatedChangeSelectorQuery)
        {
            dataDistributionQuery.PropagatedChangeSelectorQuery = propagatedChangeSelectorQuery.pack();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCacheBasedPropagatedChangeSelectorQuery_Optimized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the propagation change selector query.
    /// </summary>
    /// <param name = "node">Current node from data distribution xml file.</param>
    /// <returns>The propagation change selector query.</returns>
    private Query buildCacheBasedPropagatedChangeSelectorQuery_Optimized(DataDistributionNode node)
    {
        Query propagatedChangeSelectorQuery;
        DataDistributionNode mainTableNode = node;
        DataDistributionNode parentTableNode = mainTableNode.Parent != null && mainTableNode.Parent.TableID != 0 ? mainTableNode.Parent : null;
        if (parentTableNode)
        {
            propagatedChangeSelectorQuery = new Query();
            
            QueryBuildDataSource parentNodeDeltaResultDS = propagatedChangeSelectorQuery.addDataSource(tableNum(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords), parentTableNode.TableName);
            parentNodeDeltaResultDS.fields().dynamic(NoYes::No);
            parentNodeDeltaResultDS.joinMode(JoinMode::InnerJoin);
            parentNodeDeltaResultDS.relations(false);

            parentNodeDeltaResultDS.addRange(fieldNum(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, NodeID)).value(int2Str(parentTableNode.NodeId)); // pick all records selected by the query of the current node.
  
            // ChildNodeId indicate whether the selected record affects referenced child table node in the data distribution.
            // A childNodeId value of -1 indicates the specified record from the current table node affects all referenced child nodes. i.e. The record is newly inserted row hence we should check if this results in selection of additional rows from the
            // related tables (referenced/linked tables nodes)
            // If the row is selected because change tracking detecting an update on the column used to reference other tables then the childnode
            // is marked with the node which uses the updated column; This value is used to check if the updated value results in selection of additional rows from the referenced table.
            // A ChildNodeId of zero indicates the row is picked up by our change tracking query just because it included in the CDX seed data definition to be sent to the channel table. Such changes do not affect any referenced table as they are not links.
            parentNodeDeltaResultDS.addRange(fieldNum(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, ChildNodeID)).value(strFmt('((ChildNodeID = %1) || (ChildNodeId = %2))', mainTableNode.NodeId, -1)); // pick all row changes detected by the change tracking query because they are used as a link between other tables.

            if (!this.isLinkedWithParentOnParentRecIdOnly(mainTableNode))
            {
                str parentTableDSName = strFmt('t%1', parentTableNode.Depth);
                QueryBuildDataSource parentTableDS = parentNodeDeltaResultDS.addDataSource(parentTableNode.TableID, parentTableDSName);
                parentTableDS.fields().dynamic(NoYes::No);
                parentTableDS.joinMode(JoinMode::InnerJoin);
                parentTableDS.relations(false);
                parentTableDS.addLink(fieldNum(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, RefRecID), fieldName2Id(parentTableNode.TableID, 'RecId'));
            }
            
            str mainTableDSName = strFmt('t%1', mainTableNode.Depth);

            // second query, main table join with parent node delta sync result
            QueryBuildDataSource mainTableDS = propagatedChangeSelectorQuery.dataSourceNo(propagatedChangeSelectorQuery.dataSourceCount()).addDataSource(mainTableNode.TableID, mainTableDSName);
            mainTableDS.addGroupByField(fieldName2id(mainTableNode.TableID, 'RecId'));
            mainTableDS.label(RetailCDXCodeGen::SourceTableDataSourceLabel);

            System.Collections.Specialized.StringCollection tableLinks = mainTableNode.GetQueryTableLinks();
            str parentNodeFilterValue = tableLinks.get_Item(0);
            if (this.isLinkedWithParentOnParentRecIdOnly(mainTableNode))
            {
                parentNodeFilterValue = strReplace(parentNodeFilterValue, strFmt('==t%1.RecId', parentTableNode.Depth), strFmt('==%1.RefRecId', parentTableNode.TableName));
            }
            
            QueryBuildRange mainTableDSRange = mainTableDS.addRange(fieldName2id(mainTableNode.TableID, 'RecId'));
            mainTableDSRange.value(parentNodeFilterValue);

            ValidTimeStateType validTimeStateType = mainTableNode.GetQueryValidTimeState();

            if (validTimeStateType == ValidTimeStateType::Date)
            {
                propagatedChangeSelectorQuery.validTimeStateDateRange(lowerDate, upperDate);
            }
            else if (validTimeStateType == ValidTimeStateType::DateTime)
            {
                propagatedChangeSelectorQuery.validTimeStateDateTimeRange(lowerDateTime, upperDateTime);
            }

            if (!RetailCDXCodeGen::isRemoveCdxNodeConstTableFromQueryFlightEnabled())
            {
                QueryBuildDataSource nodeConstDS;
                // add nodeId temp table because x++ does not allow to use constant value in insert statement
                nodeConstDS = propagatedChangeSelectorQuery.dataSourceNo(propagatedChangeSelectorQuery.dataSourceCount()).addDataSource(tableNum(RetailTmpCDXNodeConstTable), tableStr(RetailTmpCDXNodeConstTable));
                nodeConstDS.addGroupByField(fieldNum(RetailTmpCDXNodeConstTable, NodeID));
                nodeConstDS.addGroupByField(fieldNum(RetailTmpCDXNodeConstTable, ChildNodeID));
                nodeConstDS.addGroupByField(fieldNum(RetailTmpCDXNodeConstTable, SkipRecord));
            
                nodeConstDS.fields().dynamic(NoYes::No);
                nodeConstDS.joinMode(JoinMode::InnerJoin);
                nodeConstDS.relations(false);
            }

            propagatedChangeSelectorQuery.clearAllFields();
        }
        
        return propagatedChangeSelectorQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCacheBasedPropagatedChangeSelectorQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new cache based query.
    /// </summary>
    /// <param name = "node">Current node from data distribution xml file.</param>
    /// <returns>Cache based propagated change selector query.</returns>
    private Query buildCacheBasedPropagatedChangeSelectorQuery(DataDistributionNode node)
    {
        Query propagatedChangeSelectorQuery;

        TableId changeTrackingTableId = tableNum(RetailCDXChangeRefTable1);
        TableId mainTableId           = node.TableID;

        // get main node and all parent nodes
        DataDistributionNodeCollection baseQueryNodeCollection = node.GetBaseQueryNodeCollection();

        int baseQueryNodeCount = baseQueryNodeCollection.Count;

        if (baseQueryNodeCount > 1)
        {
            propagatedChangeSelectorQuery = new Query();

            CLRObject node_temp = baseQueryNodeCollection.get_Item(1);
            DataDistributionNode parentNode = node_temp as DataDistributionNode;

            CLRObject tableLinks_temp = node.GetQueryTableLinks();
            System.Collections.Specialized.StringCollection tableLinks = tableLinks_temp as System.Collections.Specialized.StringCollection;
            str parentNodeFilterValue = tableLinks.get_Item(0);

            int depth = node.get_Depth();
            str tableName = node.Get_TableName();

            str mainTableDSName = strFmt('t%1', depth);
            str parentTableDSName = strFmt('t%1', depth-1);

            // second query, main table join with parent node delta sync result
            QueryBuildDataSource mainTableDS = propagatedChangeSelectorQuery.addDataSource(mainTableId, mainTableDSName);
            mainTableDS.addGroupByField(fieldName2id(mainTableId, 'RecId'));
            mainTableDS.label(RetailCDXCodeGen::SourceTableDataSourceLabel);

            str parentNodeFilterValue2 = tableLinks.get_Item(0);

            // if the right side is RecId then no need to join with the parent table
            if (strScan(parentNodeFilterValue2, strFmt('==t%1.RecId', depth-1), 1, strLen(parentNodeFilterValue2)))
            {
                parentNodeFilterValue2 = strReplace(parentNodeFilterValue2, strFmt('==t%1.RecId', depth-1), strFmt('==%1.RefRecId', parentNode.Get_TableName()));

                QueryBuildDataSource parentNodeDeltaResultDS = mainTableDS.addDataSource(tableNum(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords), parentNode.Get_TableName());
                parentNodeDeltaResultDS.fields().dynamic(NoYes::No);
                parentNodeDeltaResultDS.joinMode(JoinMode::InnerJoin);
                parentNodeDeltaResultDS.relations(false);
                parentNodeDeltaResultDS.addRange(fieldNum(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, NodeID)).value(int2Str(parentNode.get_NodeId())); // pick all records selected by the query of the current node.

                // ChildNodeId indicate whether the selected record affects referenced child table node in the data distribution.
                // A childNodeId value of -1 indicates the specified record from the current table node affects all referenced child nodes. i.e. The record is newly inserted row hence we should check if this results in selection of additional rows from the
                // related tables (referenced/linked tables nodes)
                // If the row is selected because change tracking detecting an update on the column used to reference other tables then the childnode
                // is marked with the node which uses the updated column; This value is used to check if the updated value results in selection of additional rows from the referenced table.
                // A ChildNodeId of zero indicates the row is picked up by our change tracking query just because it included in the CDX seed data definition to be sent to the channel table. Such changes do not affect any referenced table as they are not links.
                parentNodeDeltaResultDS.addRange(fieldNum(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, ChildNodeID)).value(strFmt('((ChildNodeID = %1) || (ChildNodeId = %2))', node.NodeId, -1)); // pick all row changes detected by the change tracking query because they are used as a link between other tables.
                QueryBuildRange parentNodeDeltaResultDSRange = parentNodeDeltaResultDS.addRange(fieldNum(RetailTmpCDXDataDistributionFilteredRecords, RecId));
                parentNodeDeltaResultDSRange.value(parentNodeFilterValue2);
            }
            else
            {
                QueryBuildDataSource parentTableDS = mainTableDS.addDataSource(parentNode.TableID, parentTableDSName);
                parentTableDS.fields().dynamic(NoYes::No);
                parentTableDS.joinMode(JoinMode::InnerJoin);
                parentTableDS.relations(false);

                if (parentNodeFilterValue2)
                {
                    QueryBuildRange parentTableDSRange = parentTableDS.addRange(fieldName2id(parentNode.TableID, 'RecId'));
                    parentTableDSRange.value(parentNodeFilterValue2);
                }

                QueryBuildDataSource parentNodeDeltaResultDS = parentTableDS.addDataSource(tableNum(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords), parentNode.Get_TableName());
                parentNodeDeltaResultDS.fields().dynamic(NoYes::No);
                parentNodeDeltaResultDS.joinMode(JoinMode::InnerJoin);
                parentNodeDeltaResultDS.relations(false);
                parentNodeDeltaResultDS.addRange(fieldNum(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, NodeID)).value(int2Str(parentNode.get_NodeId()));
                // pick all row changes detected by the change tracking query because they are used as a link between other tables.
                // note: although in most cases a range on RecID is used to attach custom conditions like '((ChildNodeID = %1) || (ChildNodeId = %2))'  in this case we add the range in ChildNodeId because
                // we already have a range on RecId and adding multiple ranges on the same field will result in the two conditions being joined as OR instead of what we want here which is AND of the two ranges.
                // this is the end result of the two ranges below.   (RecId == RefRecId && (ChildNodeId == %1 || ChildNodeId == -1)
                parentNodeDeltaResultDS.addRange(fieldNum(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, ChildNodeID)).value(strFmt('((ChildNodeID = %1) || (ChildNodeId = %2))', node.get_NodeId(), -1));
                parentNodeDeltaResultDS.addLink(fieldName2Id(parentNode.TableID, 'RecId'), fieldNum(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, RefRecID));
            }

            ValidTimeStateType validTimeStateType = node.GetQueryValidTimeState();
            if (validTimeStateType == ValidTimeStateType::Date)
            {
                propagatedChangeSelectorQuery.validTimeStateDateRange(lowerDate, upperDate);
            }
            else if (validTimeStateType == ValidTimeStateType::DateTime)
            {
                propagatedChangeSelectorQuery.validTimeStateDateTimeRange(lowerDateTime, upperDateTime);
            }

            if (!RetailCDXCodeGen::isRemoveCdxNodeConstTableFromQueryFlightEnabled())
            {
                QueryBuildDataSource nodeConstDS;
                // add nodeId temp table because x++ does not allow to use constant value in insert statement
                nodeConstDS = propagatedChangeSelectorQuery.dataSourceNo(propagatedChangeSelectorQuery.dataSourceCount()).addDataSource(tableNum(RetailTmpCDXNodeConstTable), tableStr(RetailTmpCDXNodeConstTable));
                nodeConstDS.addGroupByField(fieldNum(RetailTmpCDXNodeConstTable, NodeID));
                nodeConstDS.addGroupByField(fieldNum(RetailTmpCDXNodeConstTable, ChildNodeID));
                nodeConstDS.addGroupByField(fieldNum(RetailTmpCDXNodeConstTable, SkipRecord));

                nodeConstDS.fields().dynamic(NoYes::No);
                nodeConstDS.joinMode(JoinMode::InnerJoin);
                nodeConstDS.relations(false);
            }

            propagatedChangeSelectorQuery.clearAllFields();
        }

        return propagatedChangeSelectorQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCacheBasedNodeLevelValueChangeSelectorQuery</Name>
				<Source><![CDATA[
    private Query buildCacheBasedNodeLevelValueChangeSelectorQuery(DataDistributionNode node)
    {
        Query cacheBasedNodeLevelValueChangeSelectorQuery = new Query();
        
        // change tracking temp table
        TableId changeTrackingTableId = tableNum(RetailCDXChangeRefTable1);
        TableId mainTableId = node.TableID;

        QueryBuildDataSource validNodeLevelChangeSelectorDS = cacheBasedNodeLevelValueChangeSelectorQuery.addDataSource(changeTrackingTableId);
        validNodeLevelChangeSelectorDS.label(RetailCDXCodeGen::SourceTableDataSourceLabel); // mark it as a SourceTableDataSource as the changed/delta records are read from the RetailCDXChangeRefTable1

        validNodeLevelChangeSelectorDS.addGroupByField(fieldNum(RetailCDXChangeRefTable1, RefRecId));
        validNodeLevelChangeSelectorDS.addGroupByField(fieldNum(RetailCDXChangeRefTable1, NodeID));
        validNodeLevelChangeSelectorDS.addRange(fieldNum(RetailCDXChangeRefTable1, RefTableID)).value(int2Str(mainTableId));

        // get main node and all parent nodes
        DataDistributionNodeCollection baseQueryNodeCollection = node.GetBaseQueryNodeCollection();

        int baseQueryNodeCount = baseQueryNodeCollection.Count;

        if (baseQueryNodeCount == 1)
        {
            // for root node only need one delta sync query
            if (mainTableId == tableNum(RetailChannelTable))
            {
                // only add target channel temp table for the root RetailChannelTable node
                QueryBuildDataSource targetChannelDS = validNodeLevelChangeSelectorDS.addDataSource(tableNum(RetailCDXTargetChannel), #TargetChannelDSName);
                targetChannelDS.fields().dynamic(NoYes::No);
                targetChannelDS.joinMode(JoinMode::InnerJoin);
                targetChannelDS.relations(false);
                targetChannelDS.addLink(fieldNum(RetailCDXChangeRefTable1, RefRecId), fieldNum(RetailCDXTargetChannel, Channel));
            }
        }
        else
        {
            CLRObject node_temp = baseQueryNodeCollection.get_Item(1);
            DataDistributionNode parentNode = node_temp as DataDistributionNode;

            CLRObject tableLinks_temp = node.GetQueryTableLinks();
            System.Collections.Specialized.StringCollection tableLinks = tableLinks_temp as System.Collections.Specialized.StringCollection;
            str parentNodeFilterValue = tableLinks.get_Item(0);

            int depth = node.get_Depth();
            str tableName = node.Get_TableName();

            str mainTableDSName = strFmt('t%1', depth);
            str parentTableDSName = strFmt('t%1', depth-1);

            boolean hasDateFilterField = false;

            RetailCDXDateFilterField dateFilterField = RetailCDXDateFilterField::find(channelSchema.RecId, tableId2Name(mainTableId));

            if (dateFilterField.DateFilterField != '' && fieldName2Id(mainTableId, dateFilterField.DateFilterField) != 0)
            {
                hasDateFilterField = true;
            }
            // if there is only one link and the left side is RecId then no need to join with the source table
            if (!hasDateFilterField && strScan(parentNodeFilterValue, strFmt('t%1.RecId==', depth), 1, strLen(parentNodeFilterValue)) && !strScan(parentNodeFilterValue, strFmt('&&'), 1, strLen(parentNodeFilterValue)))
            {
                validNodeLevelChangeSelectorDS.name(mainTableDSName);

                // after setting validNodeLevelChangeSelectorDS name group by field will be removed
                validNodeLevelChangeSelectorDS.addGroupByField(fieldNum(RetailCDXChangeRefTable1, RefRecId));
                validNodeLevelChangeSelectorDS.addGroupByField(fieldNum(RetailCDXChangeRefTable1, NodeID));
                parentNodeFilterValue = strReplace(parentNodeFilterValue, 'RecId==', 'RefRecId==');
            }
            else
            {
                // source table
                validNodeLevelChangeSelectorDS = validNodeLevelChangeSelectorDS.addDataSource(mainTableId, mainTableDSName);
                validNodeLevelChangeSelectorDS.fields().dynamic(NoYes::No);
                validNodeLevelChangeSelectorDS.joinMode(JoinMode::InnerJoin);
                validNodeLevelChangeSelectorDS.relations(false);
                validNodeLevelChangeSelectorDS.addLink(fieldNum(RetailCDXChangeRefTable1, RefRecId), fieldName2Id(mainTableId, 'RecId'));
            }
            
            // if the right side is RecId then no need to join with the parent table
            if (strScan(parentNodeFilterValue, strFmt('==t%1.RecId', depth-1), 1, strLen(parentNodeFilterValue)))
            {
                parentNodeFilterValue = strReplace(parentNodeFilterValue, strFmt('==t%1.RecId', depth-1), strFmt('==%1.RefRecId', parentNode.Get_TableName()));

                QueryBuildDataSource parentNodeFullSyncResultDS = validNodeLevelChangeSelectorDS.addDataSource(tableNum(RetailTmpCDXDataDistributionFilteredRecords), parentNode.Get_TableName());
                parentNodeFullSyncResultDS.fields().dynamic(NoYes::No);
                parentNodeFullSyncResultDS.joinMode(JoinMode::InnerJoin);
                parentNodeFullSyncResultDS.relations(false);

                parentNodeFullSyncResultDS.addRange(fieldNum(RetailTmpCDXDataDistributionFilteredRecords, NodeID)).value(int2Str(parentNode.NodeId));
                QueryBuildRange parentNodeFullSyncResultDSRange = parentNodeFullSyncResultDS.addRange(fieldNum(RetailTmpCDXDataDistributionFilteredRecords, RecId));
                parentNodeFullSyncResultDSRange.value(parentNodeFilterValue);
            }
            else
            {
                // parent table
                validNodeLevelChangeSelectorDS = validNodeLevelChangeSelectorDS.addDataSource(parentNode.TableID, parentTableDSName);
                validNodeLevelChangeSelectorDS.fields().dynamic(NoYes::No);
                validNodeLevelChangeSelectorDS.relations(false);
                validNodeLevelChangeSelectorDS.joinMode(JoinMode::InnerJoin);

                QueryBuildRange validNodeLevelChangeSelectorDSRange = validNodeLevelChangeSelectorDS.addRange(fieldName2id(parentNode.TableID, 'RecId'));
                validNodeLevelChangeSelectorDSRange.value(parentNodeFilterValue);

                QueryBuildDataSource parentNodeFullSyncResultDS = validNodeLevelChangeSelectorDS.addDataSource(tableNum(RetailTmpCDXDataDistributionFilteredRecords), parentNode.Get_TableName());
                parentNodeFullSyncResultDS.fields().dynamic(NoYes::No);
                parentNodeFullSyncResultDS.relations(false);
                parentNodeFullSyncResultDS.addLink(fieldName2id(parentNode.TableID, 'RecId'), fieldNum(RetailTmpCDXDataDistributionFilteredRecords, RefRecID));
                parentNodeFullSyncResultDS.joinMode(JoinMode::InnerJoin);
                parentNodeFullSyncResultDS.addRange(fieldNum(RetailTmpCDXDataDistributionFilteredRecords, NodeID)).value(int2Str(parentNode.get_NodeId()));
            }
        }
        
        ValidTimeStateType validTimeStateType = node.GetQueryValidTimeState();

        if (validTimeStateType == ValidTimeStateType::Date)
        {
            cacheBasedNodeLevelValueChangeSelectorQuery.validTimeStateDateRange(lowerDate, upperDate);
        }
        else if (validTimeStateType == ValidTimeStateType::DateTime)
        {
            cacheBasedNodeLevelValueChangeSelectorQuery.validTimeStateDateTimeRange(lowerDateTime, upperDateTime);
        }

        if (!RetailCDXCodeGen::isRemoveCdxNodeConstTableFromQueryFlightEnabled())
        {
            QueryBuildDataSource nodeConstDS;

            // add nodeId temp table because x++ does not allow to use constant value in insert statement
            nodeConstDS = cacheBasedNodeLevelValueChangeSelectorQuery.dataSourceNo(cacheBasedNodeLevelValueChangeSelectorQuery.dataSourceCount()).addDataSource(tableNum(RetailTmpCDXNodeConstTable), tableStr(RetailTmpCDXNodeConstTable));
            nodeConstDS.addGroupByField(fieldNum(RetailTmpCDXNodeConstTable, NodeID));
            nodeConstDS.addGroupByField(fieldNum(RetailTmpCDXNodeConstTable, SkipRecord));

            nodeConstDS.fields().dynamic(NoYes::No);
            nodeConstDS.relations(false);
            nodeConstDS.joinMode(JoinMode::InnerJoin);
        }

        cacheBasedNodeLevelValueChangeSelectorQuery.clearAllFields();

        return cacheBasedNodeLevelValueChangeSelectorQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLinkedWithParentOnParentRecIdOnly</Name>
				<Source><![CDATA[
    private boolean isLinkedWithParentOnParentRecIdOnly(DataDistributionNode node)
    {
        // In all cases the node passed to this method will have links
        // but for completness default 'isLinkedWithParentOnRecIdOnly' to false so as to return false if the node is root node and has no tbl links.
        boolean isLinkedWithParentOnRecIdOnly = false;

        var linkGroups = node.LinkCondition;
        for (int i=0; i< linkGroups.Count; i++)
        {
            DistributionLinkCollection linkGroup = linkGroups.get_Item(i);

            for (int j=0; j< linkGroup.Count; j++)
            {
                DataDistributionLink link = linkGroup.get_Item(j);

                if (link.LinkType == DistributionLinkType::FieldMatch && link.ParentFieldName != 'RecId')
                {
                    isLinkedWithParentOnRecIdOnly = false;
                    break;
                }
                else if (link.LinkType == DistributionLinkType::FieldMatch && link.ParentFieldName == 'RecId')
                {
                    isLinkedWithParentOnRecIdOnly = true;
                }
            }
        }

        return isLinkedWithParentOnRecIdOnly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillNode</Name>
				<Source><![CDATA[
    private void fillNode(DataDistributionNode node)
    {
        #RetailCDXCodeGen

        // complete tree node info
        TableName tableName = node.TableName;
        TableId tid = tableName2id(tableName);

        if (!tid)
        {
            throw Global::error(strFmt("@SYS75683", tableName));
        }

        DictTable dt = new DictTable(tid);

        node.TableID = tid;
        node.PhysicalTableName = dt.name(DbBackend::Sql);
        node.IsGlobal = RetailConnReplicationUtilities::isGlobalTable(tableName);
        node.HasPartitionColumn = RetailConnReplicationUtilities::hasParitionColumn(tableName);

        int validTimeStateType = RetailConnReplicationUtilities::getValidTimeStateFieldType(tableName);

        if (validTimeStateType == 1)
        {
            node.ValidTimeState = ValidTimeStateType::Date;
        }
        else if (validTimeStateType == 2)
        {
            node.ValidTimeState = ValidTimeStateType::DateTime;
        }

        container pk = RetailCDXChangeTrackingAux::getPrimaryKey(tid);

        // enable change tracking
        RetailCDXChangeTrackingAux::enableChangeTracking(node.PhysicalTableName);

        for (int i = 1; i <= conLen(pk); ++i)
        {
            str pkCol = conPeek(pk, i);
            node.AddPrimaryKeyColumnName(pkCol);
        }

        container pkAX = RetailConnReplicationUtilities::getAXPrimaryIndexColumnNames(tableName);

        if (conLen(pkAX) > #MAX_AX_PK_COLNUM_NUM)
        {
            // Table: %1: primary index contains too many fields.
            throw Global::error(strFmt("@REX1570", tableName));
        }

        for (int i = 1; i <= conLen(pkAX); ++i)
        {
            str pkCol = conPeek(pkAX, i);
            FieldId fid = fieldName2id(tid, pkCol);
            DictField df = new DictField(tid, fid);
            pkCol = df.name(DbBackend::Sql);
            node.AddAXPrimaryKeyColumnName(pkCol);
        }

        // add field info for all tree nodes
        TableId parentTid = node.Parent.TableID;

        if (parentTid > 0)
        {
            System.Collections.Specialized.StringCollection parentFields = node.GetInterestedParentFields();

            DistributionTableField tableField = new DistributionTableField(parentTid, node.NodeID);
            boolean fieldAdded = false;

            for (int i = 0; i < parentFields.Count; ++i)
            {
                FieldName fieldName = parentFields.get_Item(i);

                if (immutableFieldNames.in(fieldName))
                {
                    continue;
                }

                DictField df = new DictField(parentTid, fieldName2id(parentTid, fieldName));

                if (!df)
                {
                    throw Global::error(strFmt("@SYS75684", fieldName, tableName));
                }

                tableField.AddFieldInfo(df.name(), df.name(DbBackend::Sql), enum2int(df.baseType()));
                fieldAdded = true;
            }

            if (fieldAdded)
            {
                codeGenContext.AddTableField(tableField);
            }
        }

        // fill sub-nodes
        DataDistributionNodeCollection childNodes = node.Children;

        for (int i = 0; i < childNodes.Count; ++i)
        {
            DataDistributionNode childNode = childNodes.get_Item(i);
            this.fillNode(childNode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateCT</Name>
				<Source><![CDATA[
    private void generateCT()
    {
        DataDistributionNode rootNode = codeGenContext.GetTreeRoot();
        DataDistributionNodeCollection rootChildNodes = rootNode.Children;

        for (int i = 0; i < rootChildNodes.Count; ++i)
        {
            DataDistributionNode childNode = rootChildNodes.get_Item(i);
            this.generateCT_node(childNode);
        }

        // Queues the change tracking queries in such a way that we read more changes from referenced
        // tables as well so that we avoid multiple channel specific filtering calculation.
        this.generateCTQueryQueue(/*OptimizedForCacheBasedApproach*/ false);
        this.generateCTQueryQueue(/*OptimizedForCacheBasedApproach*/ true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateCT_node</Name>
				<Source><![CDATA[
    private void generateCT_node(DataDistributionNode node)
    {
        RetailCDXChangeTrackingSQL ctQueries;

        boolean cardinalityEstimationFlightEnabled = RetailCdxEnableForceDefaultCardinalityEstimationFlight::instance().isEnabled();

        // step 1: Delete CT query
        str deleteCTSqlQuery = codeGenContext.GenerateDeleteCTQuery(node);

        if (deleteCTSqlQuery)
        {
            if (!cardinalityEstimationFlightEnabled)
            {
                deleteCTSqlQuery = this.removeCardinalityEstimation(deleteCTSqlQuery);
            }

            int queryID = node.get_DeleteCTQueryID();
            ctQueries.initValue();
            ctQueries.QueryID = queryID;
            ctQueries.SqlCTQuery = deleteCTSqlQuery;
            ctQueries.RetailConnChannelSchema = channelSchema.RecId;
            ctQueries.insert();
        }

        // step 2: Insert CT query
        str insertCTSqlQuery = codeGenContext.GenerateInsertCTQuery(node);

        if (insertCTSqlQuery)
        {
            if (!cardinalityEstimationFlightEnabled)
            {
                insertCTSqlQuery = this.removeCardinalityEstimation(insertCTSqlQuery);
            }

            int queryID = node.get_InsertCTQueryID();
            ctQueries.initValue();
            ctQueries.QueryID = queryID;
            ctQueries.SqlCTQuery = insertCTSqlQuery;
            ctQueries.RetailConnChannelSchema = channelSchema.RecId;
            ctQueries.insert();
        }

        // step 3: Update CT query
        str updateCTSqlQuery = codeGenContext.GenerateUpdateCTQuery(node);

        if (updateCTSqlQuery)
        {
            if (!cardinalityEstimationFlightEnabled)
            {
                updateCTSqlQuery = this.removeCardinalityEstimation(updateCTSqlQuery);
            }

            int queryID = node.get_UpdateCTQueryID();
            ctQueries.initValue();
            ctQueries.QueryID = queryID;
            ctQueries.SqlCTQuery = updateCTSqlQuery;
            ctQueries.RetailConnChannelSchema = channelSchema.RecId;
            ctQueries.insert();
        }

        // step 4: Parent update CT query
        str parentUpdateCTSqlQuery = codeGenContext.GenerateParentUpdateCTQuery(node);

        if (parentUpdateCTSqlQuery)
        {
            if (!cardinalityEstimationFlightEnabled)
            {
                parentUpdateCTSqlQuery = this.removeCardinalityEstimation(parentUpdateCTSqlQuery);
            }
            
            int queryID = node.get_ParentUpdateCTQueryID();
            ctQueries.initValue();
            ctQueries.QueryID = queryID;
            ctQueries.SqlCTQuery = parentUpdateCTSqlQuery;
            ctQueries.RetailConnChannelSchema = channelSchema.RecId;
            ctQueries.insert();
        }

        // process sub-nodes
        DataDistributionNodeCollection childNodes = node.Children;

        for (int i = 0; i < childNodes.Count; ++i)
        {
            DataDistributionNode childNode = childNodes.get_Item(i);
            this.generateCT_node(childNode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateCTQueryQueue</Name>
				<Source><![CDATA[
    private void generateCTQueryQueue(boolean optimizeForCacheBasedApproach = false)
    {
        TableCTQueryCollection tableCollection = codeGenContext.GenerateTableQueryQueue(optimizeForCacheBasedApproach);

        for (int i = 0; i < tableCollection.Count; ++i)
        {
            TableCTQuery ctQuery = tableCollection.get_Item(i);
            TableId tableID = ctQuery.TableID;

            QueryIDCollection queryCollection = ctQuery.get_QueryIDs();

            for (int j = 0; j < queryCollection.Count; ++j)
            {
                int queryID = queryCollection.get_Item(j);

                RetailCDXChangeTrackingQueue ctQueryQueue;
                ctQueryQueue.initValue();
                ctQueryQueue.RetailConnChannelSchema = channelSchema.RecId;
                ctQueryQueue.RefTableID = tableID;
                ctQueryQueue.QueryID = queryID;
                ctQueryQueue.QueryType = RetailCDXSqlQueryTypeEnum::InsertUpdate;
                ctQueryQueue.IsForCacheBasedQuery = optimizeForCacheBasedApproach;
                ctQueryQueue.insert();
            }

            int deleteQueryID = ctQuery.DeleteQueryID;

            RetailCDXChangeTrackingQueue ctQueryQueue;
            ctQueryQueue.initValue();
            ctQueryQueue.RetailConnChannelSchema = channelSchema.RecId;
            ctQueryQueue.RefTableID = tableID;
            ctQueryQueue.QueryID = deleteQueryID;
            ctQueryQueue.QueryType = RetailCDXSqlQueryTypeEnum::Delete;
            ctQueryQueue.IsForCacheBasedQuery = optimizeForCacheBasedApproach;
            ctQueryQueue.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInterestedFields</Name>
				<Source><![CDATA[
    private container getInterestedFields(RetailConnSchedulerSubjobTable subjob)
    {
        RetailConnSchedulerSubjobFieldList fieldList;
        container interestedFields;

        while select fromFieldName from fieldList
            where fieldList.subjobId == subjob.subJobId
        {
            if (immutableFieldNames.in(fieldList.fromFieldName))
            {
                continue;
            }

            if (conFind(interestedFields, fieldList.fromFieldName) == 0)
            {
                interestedFields += fieldList.fromFieldName;
            }
        }

        return interestedFields;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInterestedFieldsFromTable</Name>
				<Source><![CDATA[
    private container getInterestedFieldsFromTable(TableId tid)
    {
        RetailConnSchedulerSubjobFieldList fieldList;
        container interestedFields;

        DictTable tbl = new DictTable(tid);
        for (int i = 0; i < tbl.fieldCnt(); i++)
        {
            str fieldName = fieldId2Name(tid, tbl.fieldCnt2Id(i));
            if (immutableFieldNames.in(fieldName))
            {
                continue;
            }

            if (conFind(interestedFields, fieldName) == 0)
            {
                interestedFields += fieldName;
            }
        }

        return interestedFields;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCTQueryTable</Name>
				<Source><![CDATA[
    private void initCTQueryTable()
    {
        RetailCDXChangeTrackingSQL ctQueries;
        RetailCDXChangeTrackingQueue ctQueryQueue;
        RetailCDXDataDistributionQuery ddQuery;
        RetailCDXDataDistributionQueryFilter ddQueryFilter;
        RetailCdxChannelSpecificTable channelSpecificTables;
        RetailCDXDataDistributionTable retailCDXDataDistributionTable;

        delete_from ctQueries where ctQueries.RetailConnChannelSchema == channelSchema.RecId;
        delete_from ctQueryQueue where ctQueryQueue.RetailConnChannelSchema == channelSchema.RecId;
        delete_from ddQuery where ddQuery.RetailConnChannelSchema == channelSchema.RecId;
        delete_from ddQueryFilter where ddQueryFilter.RetailConnChannelSchema == channelSchema.RecId;
        delete_from channelSpecificTables where channelSpecificTables.RetailConnChannelSchema == channelSchema.RecId;
        delete_from retailCDXDataDistributionTable where retailCDXDataDistributionTable.RetailConnChannelSchema == channelSchema.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadXmlSource</Name>
				<Source><![CDATA[
    private void loadXmlSource()
    {
        str xmlSource;

        xmlSource = channelSchema.TableDistributionXML;

        if (!xmlSource)
        {
            // Table distribution XML is not available for channel schema: %1
            throw Global::error(strFmt("@REX1568", channelSchema.SchemaName));
        }

        codeGenContext.LoadXmlSource(xmlSource);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        codeGenContext = new DistributionCodeGen();

        immutableFieldNames = new Set(Types::String);

        immutableFieldNames.add('DataAreaId');
        immutableFieldNames.add('ModifiedDateTime');
        immutableFieldNames.add('ModifiedBy');
        immutableFieldNames.add('ModifiedTransactionId');
        immutableFieldNames.add('CreatedDateTime');
        immutableFieldNames.add('CreatedBy');
        immutableFieldNames.add('CreatedTransactionId');
        immutableFieldNames.add('RecId');
        immutableFieldNames.add('TableId');

        lowerDate = dateNull();
        upperDate = maxDate();
        lowerDateTime = DateTimeUtil::minValue();
        upperDateTime = DateTimeUtil::maxValue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramChannelSchema</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the value of recId of channel schema.
    /// </summary>
    /// <param name="_channelSchema">
    /// The value of <c>channelschema</c> optional.
    /// </param>
    /// <returns>
    /// RecId of channel schema.
    /// </returns>
    public RefRecId paramChannelSchema(RefRecId _channelSchema)
    {
        select channelSchema where channelSchema.RecId == _channelSchema;

        return channelSchema.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateQuery</Name>
				<Source><![CDATA[
    private void populateQuery()
    {
        DataDistributionNode rootNode = codeGenContext.GetTreeRoot();
        DataDistributionNodeCollection rootChildNodes = rootNode.Children;

        // recursively generate queries for all nodes of the codeGenContext tree
        for (int i = 0; i < rootChildNodes.Count; ++i)
        {
            DataDistributionNode childNode = rootChildNodes.get_Item(i);
            this.populateQuery_node(childNode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateQuery_node</Name>
				<Source><![CDATA[
    private void populateQuery_node(DataDistributionNode node)
    {
        this.buildBaseQuery(node);

        // add to RetailCDXDataDistributionTable and create cache based query
        this.addToDataDistributionTable(node);

        if (this.isDataFilterQueryJoinOrderOptimizationFlightEnabled())
        {
            this.buildCacheBasedQuery_Optimized(node);
        }
        else
        {
            this.buildCacheBasedQuery(node);
        }

        DataDistributionNodeCollection childNodes = node.Children;

        for (int i = 0; i < childNodes.Count; ++i)
        {
            DataDistributionNode subNode = childNodes.get_Item(i);
            this.populateQuery_node(subNode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTableIDCache</Name>
				<Source><![CDATA[
    private void populateTableIDCache()
    {
        System.Collections.Specialized.StringCollection allTables = codeGenContext.GetAllTables();

        for (int i = 0; i < allTables.Count; ++i)
        {
            TableName tableName = allTables.get_Item(i);
            TableId tid = tableName2id(tableName);

            if (!tid)
            {
                throw Global::error(strFmt("@SYS75683", tableName));
            }

            RetailCDXAXTableID tidCache;

            select forUpdate tidCache
            where tidCache.RefTableID == tid;

            if (!tidCache)
            {
                tidCache.initValue();
                tidCache.RefTableID = tid;
                tidCache.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareCodeGenContext</Name>
				<Source><![CDATA[
    private void prepareCodeGenContext()
    {
        // step 1: init tree from xml
        codeGenContext.InitTreeFromSource();

        // step 2: clean up
        this.initCTQueryTable();

        // step 3: load non-channel specific tables to tree
        this.addNonChannelSpecificTables();

        // step 4: Add field info for all subjobs
        // all AX field defined in field mapping will be added as interested columns
        this.addFieldInfo_subjob();

        // step 5: Walkthrough tree nodes
        //   5.1 complete tree node info
        //   5.2 add field info for all tree nodes
        this.addFieldInfo_treeNode();

        // step 6: bookkeep tables under RetailChannelTable node
        this.addChannelSpecificTables();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addChannelSpecificTables</Name>
				<Source><![CDATA[
    private void addChannelSpecificTables()
    {
        System.Collections.Specialized.StringCollection allChannelTables = codeGenContext.GetAllTablesUnderChannel();

        for (int i = 0; i < allChannelTables.Count; ++i)
        {
            TableName tableName = allChannelTables.get_Item(i);

            // add to table: RetailCdxChannelSpecificTables
            RetailCdxChannelSpecificTable channelSpecificTables;

            channelSpecificTables.initValue();
            channelSpecificTables.RetailConnChannelSchema = channelSchema.RecId;
            channelSpecificTables.AXTableName = tableName;
            channelSpecificTables.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToDataDistributionTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds/Updates current node filter type.
    /// </summary>
    /// <param name = "node">Current node from data distribution xml file.</param>
    private void addToDataDistributionTable(DataDistributionNode node)
    {
        RetailCDXDataDistributionTable retailCDXDataDistributionTable;

        RetailCDXDataDistributionTableFilterType currentTableFilterType = this.getDataDistributionNodeFilterType(node);

        select firstonly RecId, Type from retailCDXDataDistributionTable
            where retailCDXDataDistributionTable.RetailConnChannelSchema == channelSchema.RecId
                && retailCDXDataDistributionTable.RefTableID == node.TableID;

        if (retailCDXDataDistributionTable)
        {
            // if the current table type (by the current node) has higher data filter priority than the existing type then update the type to the new one.
            // data filter priority: ChannelSpecificFilter > JoinBasedFilter > RangeBasedFilter > NoFilter
            // i.e if one table has two nodes and one node has ChannelSpecificFilter type while the other has RangeBasedFilter type, both the nodes need to be filtered
            if (enum2int(currentTableFilterType) < enum2int(retailCDXDataDistributionTable.Type))
            {
                ttsbegin;

                select forupdate retailCDXDataDistributionTable
                    where retailCDXDataDistributionTable.RetailConnChannelSchema == channelSchema.RecId
                        && retailCDXDataDistributionTable.RefTableID == node.TableID;

                retailCDXDataDistributionTable.Type = currentTableFilterType;
                retailCDXDataDistributionTable.update();

                ttscommit;
            }
        }
        else
        {
            retailCDXDataDistributionTable.RetailConnChannelSchema = channelSchema.RecId;
            retailCDXDataDistributionTable.RefTableId = node.TableID;
            retailCDXDataDistributionTable.Type = currentTableFilterType;
            retailCDXDataDistributionTable.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDataDistributionNodeFilterType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets current node data distribution filter type.
    /// </summary>
    /// <param name = "node">Current node from data distribution xml file.</param>
    /// <returns>Current node filter type.</returns>
    private RetailCDXDataDistributionTableFilterType getDataDistributionNodeFilterType(DataDistributionNode node)
    {
        DataDistributionNodeCollection childrenNodeCollection = node.Children;
        int childrenNodeCounts = childrenNodeCollection.Count;

        DataDistributionNode parentNode = node.get_Parent();
        int parentTableId = parentNode.TableID;

        RetailCDXDataDistributionTableFilterType currentNodeFilterType;

        if (childrenNodeCounts > 0 || parentTableId > 0)
        {
            // if a node has child/parent node, need to filter data for the node
            RetailCdxChannelSpecificTable channelSpecificTable;

            select firstonly RecId from channelSpecificTable
                where channelSpecificTable.RetailConnChannelSchema == channelSchema.RecId
                   && channelSpecificTable.AXTableName == node.TableName;

            if (channelSpecificTable)
            {
                currentNodeFilterType = RetailCDXDataDistributionTableFilterType::ChannelSpecificFilter;
            }
            else
            {
                currentNodeFilterType = RetailCDXDataDistributionTableFilterType::JoinBasedFilter;
            }
        }
        else
        {
            // if a node does not have child/parent node, then no need to filter the data for the node
            System.Collections.Specialized.StringCollection tableLinks = node.GetQueryTableLinks();

            // for no filter type table, it still has one empty table link
            if (tableLinks.Count == 1 && tableLinks.get_Item(0) == '')
            {
                currentNodeFilterType = RetailCDXDataDistributionTableFilterType::NoFilter;
            }
            else
            {
                currentNodeFilterType = RetailCDXDataDistributionTableFilterType::RangeBasedFilter;
            }
        }

        return currentNodeFilterType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the code generation.
    /// </summary>
    public void run()
    {
        ttsbegin;

        this.loadXmlSource();

        // Fill full information about tables and fields
        //   table name, id, physical sql name
        //   field name, physical sql name
        //   table primary key field physical sql name
        //   distribution tree, tree link, link fields
        this.prepareCodeGenContext();

        // Table ID cache
        //   A Workaround for dynamic query not supporting constant number
        this.populateTableIDCache();

        // Generate change-tracking sql query
        this.generateCT();

        // Generate channel specific data queries
        this.populateQuery();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates the CIL code for this channel schema.
    /// </summary>
    /// <param name="_channelSchemaRecID">
    /// Channel schema rec ID.
    /// </param>
    public static void generate(RefRecId _channelSchemaRecID)
    {
        try
        {
            RetailCDXCodeGen codeGen = new RetailCDXCodeGen();
            codeGen.paramChannelSchema(_channelSchemaRecID);
            codeGen.run();
        }
        catch(Exception::CLRError)
        {
            CLRObject ex = CLRInterop::getLastException();
            error(ex.ToString());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSourceTableDS</Name>
				<Source><![CDATA[
    internal static QueryBuildDataSource getSourceTableDS(Query _query)
    {
        QueryBuildDataSource sourceTableDS;

        for(int i = 1; i <= _query.dataSourceCount(); i++)
        {
            QueryBuildDataSource ds = _query.dataSourceNo(i);

            if (ds.label() == RetailCDXCodeGen::SourceTableDataSourceLabel)
            {
                sourceTableDS = ds;
                break;
            }
        }

        if (sourceTableDS == null)
        {
            sourceTableDS = _query.dataSourceNo(1);
        }

        return sourceTableDS;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDataFilterQueryGlobal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if all the datasource tables used by the query are global or not.
    /// </summary>
    /// <param name = "_query">The query object.</param>
    /// <returns>True if the datasource tables used by the query are all global; false otherwise.</returns>
    internal static boolean isDataFilterQueryGlobal(Query _query)
    {
        boolean isDataFilterQueryGlobal = true;
        for(int i = 1; i <= _query.dataSourceCount(); i++)
        {
            QueryBuildDataSource ds = _query.dataSourceNo(i);
            if (!RetailConnReplicationUtilities::isGlobalTable(tableId2Name(ds.table())))
            {
                isDataFilterQueryGlobal = false;
                break;
            }
        }

        return isDataFilterQueryGlobal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDataSyncQueryOutOfSyncWithFlightKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the current data filter queries are in sync/compatible with the cdx feature/flight values.
    /// </summary>
    /// <param name = "channelSchemaRecId">The channel schema record Id.</param>
    /// <returns>True if the data filter queries are incompatible with the cdx feature flight values.</returns>
    internal static boolean isDataSyncQueryOutOfSyncWithFlightKey(RefRecId channelSchemaRecId)
    {
        RetailCdxDataDistributionQuery dataDistributionQuery;

        select firstonly dataDistributionQuery
            where dataDistributionQuery.RetailConnChannelSchema == channelSchemaRecId &&
            dataDistributionQuery.IsCacheBasedQuery == NoYes::Yes;

        if (dataDistributionQuery)
        {
            Query q = new Query(dataDistributionQuery.PackedQuery);
            QueryBuildDataSource nodeConstTableDS = q.dataSourceTable(tableNum(RetailTmpCDXNodeConstTable));

            if ((RetailCDXCodeGen::isRemoveCdxNodeConstTableFromQueryFlightEnabled() && nodeConstTableDS != null) ||
                (!RetailCDXCodeGen::isRemoveCdxNodeConstTableFromQueryFlightEnabled() && nodeConstTableDS == null))
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeCardinalityEstimation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes FORCE_DEFAULT_CARDINALITY_ESTIMATION from SQL string.
    /// </summary>
    /// <param name = "_sql">The original SQL statement with or without FORCE_DEFAULT_CARDINALITY_ESTIMATION.</param>
    /// <returns>The transformed SQL statement without FORCE_DEFAULT_CARDINALITY_ESTIMATION.</returns>
    internal str removeCardinalityEstimation(str _sql)
    {
        _sql = strReplace(_sql, codeGenContext.CardinalityEstimationOption, "");
 
        return _sql;
    }

]]></Source>
			</Method>
			<Method>
				<Name>optimizeJoinOrderAndPack</Name>
				<Source><![CDATA[
    private container optimizeJoinOrderAndPack(Query query, Map groupByFieldMap, ValidTimeStateType _validTimeStateType)
    {
        Query optimizedQuery;

        query.clearAllFields();

        // Rearrange the joins, in order of tables with small row count being joined first, to make sure Sql doesnt select bad query plan.
        // In the data distribution xml mostly the tables at the root node, like RetailChannelTable, have smaller row count and the nested child nodes have higher row count.
        // The goal here is to reverse the join order in the query object so that it starts with the tables at the root node and goes all the way to the leaf node in that order.
        // The reversal is necessary because the buildBaseQuery method joins the tables by starting from the leaf node tables to the root node table.
        if (this.isDataFilterQueryJoinOrderOptimizationFlightEnabled())
        {
            // reorder cross joins for making sure sql doesn't pick unoptimal query plan.
            int dsCount = query.dataSourceCount();
            optimizedQuery = new Query();

            QueryBuildDataSource optimizedQueryDataSource;
            QueryBuildDataSource nodeConstDS;

            for (int i = 0; i <= dsCount - 1; i++)
            {
                QueryBuildDataSource currentDS = query.dataSourceNo(dsCount - i);

                if (currentDS.name() == tableStr(RetailTmpCDXNodeConstTable))
                {
                    // skip RetailTmpCDXNodeConstTable datasource so that it is added at the end of the cross join order.
                    nodeConstDS = currentDS;
                    continue;
                }

                if (optimizedQueryDataSource == null)
                {
                    optimizedQueryDataSource = optimizedQuery.addDataSource(currentDS.table(), currentDS.name());
                }
                else
                {
                    optimizedQueryDataSource = optimizedQueryDataSource.addDataSource(currentDS.table(), currentDS.name());
                }

                optimizedQueryDataSource.label(currentDS.label());
                optimizedQueryDataSource.relations(false);
                optimizedQueryDataSource.joinMode(JoinMode::InnerJoin);
                optimizedQueryDataSource.fields().dynamic(NoYes::No);
            }

            // if there is a RetailTmpCDXNodeConstTable datasource add it at the end of the query's datasource.
            if (nodeConstDS != null)
            {
                optimizedQueryDataSource = optimizedQueryDataSource.addDataSource(nodeConstDS.table(), nodeConstDS.name());
                optimizedQueryDataSource.label(nodeConstDS.label());
                optimizedQueryDataSource.relations(false);
                optimizedQueryDataSource.joinMode(JoinMode::InnerJoin);
                optimizedQueryDataSource.fields().dynamic(NoYes::No);
            }

            // add ranges and links after all datasources are added to the optimizedQuery object.
            for (int i = 1; i <= dsCount; i++)
            {
                QueryBuildDataSource currentDS = query.dataSourceNo(i);
                optimizedQueryDataSource = optimizedQuery.dataSourceName(currentDS.name());

                for (int j = 1; j <= currentDS.rangeCount(); j++)
                {
                    QueryBuildRange currentDSRange = currentDS.range(j);
                    QueryBuildRange range = optimizedQueryDataSource.addRange(currentDSRange.field());
                    range.value(currentDSRange.value());
                }

                // add links
                for (int j = 1; j <= currentDS.linkCount(); j++)
                {
                    QueryBuildLink currentDSLink = currentDS.link(j);
                    QueryBuildDataSource joinDataSource = optimizedQuery.dataSourceName(currentDSLink.joinDataSourceName());
                    joinDataSource.addLink(currentDSLink.relatedField(), currentDSLink.field(), currentDS.name());
                }

                if (groupByFieldMap.exists(currentDS.name()))
                {
                    container fields = groupByFieldMap.lookup(currentDS.name());

                    for (int j = 1; j <= conLen(fields); j++)
                    {
                        optimizedQueryDataSource.addGroupByField(conPeek(fields, j));
                    }
                }
            }
        }
        else
        {
            optimizedQuery = query;
        }
        
        if (_validTimeStateType == ValidTimeStateType::Date)
        {
            optimizedQuery.validTimeStateDateRange(lowerDate, upperDate);
        }
        else if (_validTimeStateType == ValidTimeStateType::DateTime)
        {
            optimizedQuery.validTimeStateDateTimeRange(lowerDateTime, upperDateTime);
        }

        optimizedQuery.clearAllFields();

        return optimizedQuery.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDataFilterQueryJoinOrderOptimizationFlightEnabled</Name>
				<Source><![CDATA[
    private boolean isDataFilterQueryJoinOrderOptimizationFlightEnabled()
    {
        return RetailCDXDataFilterQueryJoinOrderOptimizationFlight::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRemoveCdxNodeConstTableFromQueryFlightEnabled</Name>
				<Source><![CDATA[
    private static boolean isRemoveCdxNodeConstTableFromQueryFlightEnabled()
    {
        return RetailCDXRemoveCdxNodeConstTableFromQueryFlight::instance().isEnabled();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>