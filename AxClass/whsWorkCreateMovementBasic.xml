<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSWorkCreateMovementBasic</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WhsWorkCreateMovementBasic</c> class creates warehouse work for basic movement.
/// </summary>
public class WhsWorkCreateMovementBasic
{
    WHSUserId               userId;
    ItemId                  itemId;
    Qty                     qty;
    WHSUOM                  unitId;
    InventDim               inventDim;
    WHSLicensePlateId       fromLicensePlateId;
    WMSLocationId           fromLocationId;
    WMSLocationId           toLocationId;
    WHSLicensePlateId       toLicensePlateId;
    WHSInventStatusId       fromInventStatusId;
    WHSInventStatusId       toInventStatusId;
    boolean                 reverseWork;
    boolean                 executeWork;
    WHSWorkClassId          workClassId;
    InventCostOnhandCache   inventCostOnhandCache;
    real                    lastWorkLineNum;
    boolean                 isMovingWholeLP;
    boolean                 skipAnchoringValidation;
    WHSWorkInventTransReservationCollectionBuilder workInventTransReservationCollectionBuilder;
    private WHSContainerId  containerId;

    private WHSCapturedWeight   capturedWeight;
    private container           scannedTags;

    private WHSStageWorkMovement stageWorkMovement;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>fromLocation</Name>
				<Source><![CDATA[
    private WMSLocation fromLocation()
    {
        return WMSLocation::find(fromLocationId, inventDim.InventLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>toLocation</Name>
				<Source><![CDATA[
    private WMSLocation toLocation()
    {
        return WMSLocation::find(toLocationId, inventDim.InventLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWorkLinesWithLocatedLP</Name>
				<Source><![CDATA[
    private void checkWorkLinesWithLocatedLP()
    {
        WHSWorkLine workLineWithLocatedLP;

        if (fromLicensePlateId)
        {
            select firstonly workLineWithLocatedLP
                where workLineWithLocatedLP.LocatedLPId == fromLicensePlateId
                    && (workLineWithLocatedLP.WorkStatus != WHSWorkStatus::Closed
                    && workLineWithLocatedLP.WorkStatus != WHSWorkStatus::Cancelled);

            // If somebody has located against this LP we should not move items out of it or change the lp since we do not know if the LP itself was important
            // An example could be cross docking of packages, pre-packed on LPs
            if (workLineWithLocatedLP)
            {
                throw error(strFmt("@WAX:CannotMoveLPBeingUsedAsLocatedLPError", fromLicensePlateId, fieldPName(WHSWorkLine, LocatedLPId), workLineWithLocatedLP.WorkId));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipAnchoringValidation</Name>
				<Source><![CDATA[
    public boolean parmSkipAnchoringValidation(boolean _skipAnchoringValidation = skipAnchoringValidation)
    {
        skipAnchoringValidation = _skipAnchoringValidation;
        return skipAnchoringValidation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCapturedWeight</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public WHSCapturedWeight parmCapturedWeight(WHSCapturedWeight _capturedWeight = capturedWeight)
    {
        capturedWeight = _capturedWeight;

        return capturedWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmContainerId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    final public WHSContainerId parmContainerId(WHSContainerId _containerId = containerId)
    {
        containerId = _containerId;

        return containerId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmScannedTags</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public container parmScannedTags(container _scannedTags = scannedTags)
    {
        scannedTags = _scannedTags;
        return scannedTags;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLocationBeingChanged</Name>
				<Source><![CDATA[
    private boolean isLocationBeingChanged()
    {
        return (fromLocationId != toLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSkipMixedInventStatusCheck</Name>
				<Source><![CDATA[
    private boolean canSkipMixedInventStatusCheck()
    {
        return (itemId || !fromLicensePlateId)
            && executeWork
            && fromInventStatusId != toInventStatusId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndExecuteSingleSKUQuarantine</Name>
				<Source><![CDATA[
    private void createAndExecuteSingleSKUQuarantine(
        InventDim       _workLineInventDim,
        InventDim       _toInventDim,
        WHSWorkLine     _workLine,
        WHSTransWeight  _movedWeight)
    {
        InventDim           workLineInventDim = InventDim::find(_workLineInventDim.InventDimId);
        WHSWorkQuarantine   workQuarantine;

        ttsbegin;

        workLineInventDim.wmsLocationId = _workLine.wmsLocationId;
        workLineInventDim = InventDim::findOrCreate(workLineInventDim);

        if (fromInventStatusId != toInventStatusId)
        {
            workQuarantine.initFromWorkLine(_workLine);
            if (WMSLocation::find(_toInventDim.wmsLocationId, _toInventDim.InventLocationId).whsLocationIsLPControlled())
            {
                workQuarantine.setDimIds(workLineInventDim, fromInventStatusId, toInventStatusId, toLicensePlateId);
            }
            else
            {
                workQuarantine.setDimIds(workLineInventDim, fromInventStatusId, toInventStatusId, '');
            }

            if (PdsGlobal::pdsIsCWItem(_workLine.ItemId))
            {
                workQuarantine.CapturedWeight = _movedWeight;
                workQuarantine.RemainingCapturedWeight = workQuarantine.CapturedWeight;
            }

            workQuarantine.insert();
            WHSWorkQuarantineExecutor quarantineExecutor = WHSWorkQuarantineExecutor::newWorkQuarantine(workQuarantine, _workLine.InventQtyWork, false);
            if (scannedTags)
            {
                quarantineExecutor.parmCatchWeightTagDimensionUpdater(WHSCatchWeightTagDimensionUpdater::newScannedTags(scannedTags, InventDim::find(workQuarantine.InventDimIdTo)));
            }
            quarantineExecutor.execute();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndProcessMultiSKUPickWIT</Name>
				<Source><![CDATA[
    private InventHandlingQty createAndProcessMultiSKUPickWIT(
        InventDim			_toInventDimWIT,
        WHSWorkLine			_workLine,
        LedgerVoucher		_ledgerVoucher,
        WHSLicensePlateId	_licensePlateId = fromLicensePlateId)
    {
        NumberSeq           inventTransNumberSeq;
        InventSum           loopInventSum;
        InventDim           loopInventDim;
        InventDim           loopToInventDim;
        WHSWorkInventTrans  workInventTrans;
        InventHandlingQty   tmpQty;

        ttsbegin;

        inventTransNumberSeq = NumberSeq::newGetNum(InventParameters::numRefInventTransId());

        if (InventUseDimOfInventSumToggle::instance().isEnabled())
        {
            while select ItemId, PhysicalInvent, PdsCWPhysicalInvent, InventDimId, #InventDimGroupAllFields from loopInventSum
                where loopInventSum.ClosedQty           == NoYes::No
                   && loopInventSum.PhysicalInvent      > 0
                   && loopInventSum.InventSiteId        == inventDim.InventSiteId
                   && loopInventSum.InventLocationId    == inventDim.InventLocationId
                   && loopInventSum.wmsLocationId       == fromLocationId
                   && loopInventSum.LicensePlateId      == _licensePlateId
            {
                // Create the Work Invent Trans records for the Pick Work Line.
                loopInventDim.clear();
                loopInventDim.initFromInventSum(loopInventSum);
                loopInventDim.wmsLocationId = _toInventDimWIT.wmsLocationId;
                loopToInventDim = InventDim::findOrCreate(loopInventDim);

                boolean isCWItem = PdsGlobal::pdsIsCWItem(loopInventSum.ItemId);

                workInventTrans.clear();
                workInventTrans.WorkId                  = _workLine.WorkId;
                workInventTrans.LineNum                 = _workLine.LineNum;
                workInventTrans.InventDimIdTo           = loopToInventDim.InventDimId;
                workInventTrans.InventTransIdParent     = inventTransNumberSeq.num();
                workInventTrans.TransDateTime           = DateTimeUtil::utcNow();
                workInventTrans.ItemId                  = loopInventSum.ItemId;
            
                if (isCWItem)
                {
                    workInventTrans.setInitialQuantityAndWeightValues(loopInventSum.PdsCWPhysicalInvent, loopInventSum.PhysicalInvent);
                }
                else
                {
                    workInventTrans.Qty                     = loopInventSum.PhysicalInvent;
                    workInventTrans.InventQtyRemain         = workInventTrans.Qty;
                }
                workInventTrans.InventDimIdFrom         = loopInventSum.InventDimId;
                workInventTrans.insert();

                if (executeWork)
                {
                    this.moveQuantities(workInventTrans, loopToInventDim, _ledgerVoucher, null);
                }

                tmpQty += workInventTrans.Qty;
            }
        }
        else
        {
            while select ItemId, PhysicalInvent, PdsCWPhysicalInvent, InventDimId from loopInventSum
                where loopInventSum.ClosedQty == NoYes::No
                   && loopInventSum.PhysicalInvent  > 0
                join loopInventDim
                    where loopInventSum.InventDimId         == loopInventDim.InventDimId
                    &&    loopInventDim.InventSiteId        == inventDim.InventSiteId
                    &&    loopInventDim.InventLocationId    == inventDim.InventLocationId
                    &&    loopInventDim.wmsLocationId       == fromLocationId
                    &&    loopInventDim.LicensePlateId      == _licensePlateId
            {
                // Create the Work Invent Trans records for the Pick Work Line.
                loopInventDim.wmsLocationId = _toInventDimWIT.wmsLocationId;
                loopToInventDim = InventDim::findOrCreate(loopInventDim);

                boolean isCWItem = PdsGlobal::pdsIsCWItem(loopInventSum.ItemId);

                workInventTrans.clear();
                workInventTrans.WorkId                  = _workLine.WorkId;
                workInventTrans.LineNum                 = _workLine.LineNum;
                workInventTrans.InventDimIdTo           = loopToInventDim.InventDimId;
                workInventTrans.InventTransIdParent     = inventTransNumberSeq.num();
                workInventTrans.TransDateTime           = DateTimeUtil::utcNow();
                workInventTrans.ItemId                  = loopInventSum.ItemId;
            
                if (isCWItem)
                {
                    workInventTrans.setInitialQuantityAndWeightValues(loopInventSum.PdsCWPhysicalInvent, loopInventSum.PhysicalInvent);
                }
                else
                {
                    workInventTrans.Qty                     = loopInventSum.PhysicalInvent;
                    workInventTrans.InventQtyRemain         = workInventTrans.Qty;
                }
                workInventTrans.InventDimIdFrom         = loopInventSum.InventDimId;
                workInventTrans.insert();

                if (executeWork)
                {
                    this.moveQuantities(workInventTrans, loopToInventDim, _ledgerVoucher, null);
                }

                tmpQty += workInventTrans.Qty;
            }
        }

        ttscommit;

        return tmpQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndProcessMultiSKUPickWITForGroupedContainers</Name>
				<Source><![CDATA[
    private InventHandlingQty createAndProcessMultiSKUPickWITForGroupedContainers(
        InventDim			_toInventDimWIT,
        WHSWorkLine			_workLine,
        LedgerVoucher		_ledgerVoucher,
        WHSLicensePlateId	_licensePlateId)
    {
        InventHandlingQty tmpQty;
        WHSLicensePlate childLicensePlate;

        while select LicensePlateId from childLicensePlate
            where childLicensePlate.LicensePlateParent == _licensePlateId
        {
            tmpQty += this.createAndProcessMultiSKUPickWIT(_toInventDimWIT, _workLine, _ledgerVoucher, childLicensePlate.LicensePlateId);
        }

        return tmpQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndProcessMultiSKUPickWITDelta</Name>
				<Source><![CDATA[
    private InventHandlingQty createAndProcessMultiSKUPickWITDelta(
        InventDim       _toInventDimWIT,
        WHSWorkLine     _workLine,
        LedgerVoucher   _ledgerVoucher)
    {
        NumberSeq           inventTransNumberSeq;
        InventSumDelta      inventSumDelta;
        InventDim           loopInventDim;
        WHSWorkInventTrans  workInventTrans;
        InventDim           loopToInventDim;
        InventHandlingQty   tmpQty;

        ttsbegin;

        inventTransNumberSeq = NumberSeq::newGetNum(InventParameters::numRefInventTransId());

        if (InventUseDimOfInventSumDeltaToggle::instance().isEnabled())
        {
            // For reverse work we must use the inventSumDelta Table
            while select ItemId, PhysicalInvent, PdsCWPhysicalInvent, InventDimId, #InventDimGroupAllFields from inventSumDelta
            where inventSumDelta.PhysicalInvent     > 0
                && inventSumDelta.SQLTransactionID  == InventUpdateOnhandGlobal::instance().inventUpdateOnhand().sqlTransactionId()
                && inventSumDelta.InventSiteId      == inventDim.InventSiteId
                && inventSumDelta.InventLocationId  == inventDim.InventLocationId
                && inventSumDelta.wmsLocationId     == fromLocationId
                && inventSumDelta.LicensePlateId    == fromLicensePlateId
            {
                // Create the Work Invent Trans records for the Pick Work Line.
                loopInventDim.clear();
                loopInventDim.initFromInventSumDelta(inventSumDelta);
                loopInventDim.wmsLocationId = _toInventDimWIT.wmsLocationId;
                loopToInventDim = InventDim::findOrCreate(loopInventDim);
            
                boolean isCWItem = PdsGlobal::pdsIsCWItem(inventSumDelta.ItemId);

                workInventTrans.clear();
                workInventTrans.WorkId                  = _workLine.WorkId;
                workInventTrans.LineNum                 = _workLine.LineNum;
                workInventTrans.InventDimIdTo           = loopToInventDim.InventDimId;
                workInventTrans.InventTransIdParent     = inventTransNumberSeq.num();
                workInventTrans.TransDateTime           = DateTimeUtil::utcNow();
                workInventTrans.ItemId                  = inventSumDelta.ItemId;
                if (isCWItem)
                {
                    workInventTrans.setInitialQuantityAndWeightValues(inventSumDelta.PdsCWPhysicalInvent, inventSumDelta.PhysicalInvent);
                }
                else
                {
                    workInventTrans.Qty                     = inventSumDelta.PhysicalInvent;
                    workInventTrans.InventQtyRemain         = workInventTrans.Qty;
                }
                workInventTrans.InventDimIdFrom         = inventSumDelta.InventDimId;
                workInventTrans.insert();

                if (executeWork)
                {
                    this.moveQuantities(workInventTrans, loopToInventDim, _ledgerVoucher, null);
                }

                tmpQty += workInventTrans.Qty;
            }
        }
        else
        {
            // For reverse work we must use the inventSumDelta Table
            while select ItemId, PhysicalInvent, PdsCWPhysicalInvent, InventDimId from inventSumDelta
            where inventSumDelta.PhysicalInvent > 0
                && inventSumDelta.SQLTransactionID      == InventUpdateOnhandGlobal::instance().inventUpdateOnhand().sqlTransactionId()
            join loopInventDim
                where inventSumDelta.InventDimId        == loopInventDim.InventDimId
                &&    loopInventDim.InventSiteId        == inventDim.InventSiteId
                &&    loopInventDim.InventLocationId    == inventDim.InventLocationId
                &&    loopInventDim.wmsLocationId       == fromLocationId
                &&    loopInventDim.LicensePlateId      == fromLicensePlateId
            {
                // Create the Work Invent Trans records for the Pick Work Line.
                loopInventDim.wmsLocationId = _toInventDimWIT.wmsLocationId;
                loopToInventDim = InventDim::findOrCreate(loopInventDim);
            
                boolean isCWItem = PdsGlobal::pdsIsCWItem(inventSumDelta.ItemId);

                workInventTrans.clear();
                workInventTrans.WorkId                  = _workLine.WorkId;
                workInventTrans.LineNum                 = _workLine.LineNum;
                workInventTrans.InventDimIdTo           = loopToInventDim.InventDimId;
                workInventTrans.InventTransIdParent     = inventTransNumberSeq.num();
                workInventTrans.TransDateTime           = DateTimeUtil::utcNow();
                workInventTrans.ItemId                  = inventSumDelta.ItemId;
                if (isCWItem)
                {
                    workInventTrans.setInitialQuantityAndWeightValues(inventSumDelta.PdsCWPhysicalInvent, inventSumDelta.PhysicalInvent);
                }
                else
                {
                    workInventTrans.Qty                     = inventSumDelta.PhysicalInvent;
                    workInventTrans.InventQtyRemain         = workInventTrans.Qty;
                }
                workInventTrans.InventDimIdFrom         = inventSumDelta.InventDimId;
                workInventTrans.insert();

                if (executeWork)
                {
                    this.moveQuantities(workInventTrans, loopToInventDim, _ledgerVoucher, null);
                }

                tmpQty += workInventTrans.Qty;
            }
        }

        ttscommit;

        return tmpQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeToInventDimForProcessMultiSKUPutWIT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the inventory dimension for the work inventory transaction InventDimIdTo field.
    /// </summary>
    /// <param name = "_loopWorkInventTrans">The work inventory transaction record.</param>
    /// <param name = "_inventDim">The inventory dimension record.</param>
    /// <param name = "_inventDimWIT">The WIT inventory dimension record.</param>
    /// <returns>The initialized inventory dimension.</returns>
    protected InventDim initializeToInventDimForProcessMultiSKUPutWIT(
        WHSWorkInventTrans  _loopWorkInventTrans,
        InventDim           _inventDim,
        InventDim           _inventDimWIT)
    {
        InventDim loopToInventDim = InventDim::find(_loopWorkInventTrans.InventDimIdFrom);
        loopToInventDim.wmsLocationId = _inventDimWIT.wmsLocationId;
        if (!WMSLocation::find(_inventDim.wmsLocationId, _inventDim.InventLocationId).whsLocationIsLPControlled())
        {
            loopToInventDim.LicensePlateId = '';
        }
        else if (!WHSContainerTable::isLicensePlateIdUsedForContainerGrouping(fromLicensePlateId)
            || WHSDockInventoryManagementFeature::instance().isEnabled())
        {
            loopToInventDim.LicensePlateId = _inventDim.LicensePlateId;
        }

        return InventDim::findOrCreate(loopToInventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndProcessMultiSKUPutWIT</Name>
				<Source><![CDATA[
    private InventHandlingQty createAndProcessMultiSKUPutWIT(
        InventDimId         _loopInventDimId,
        WHSWorkInventTrans  _loopWorkInventTrans,
        WHSWorkLine         _workLine,
        InventDim           _toInventDim,
        InventDim           _toInventDimWIT,
        LedgerVoucher       _ledgerVoucher)
    {
        NumberSeq           inventTransNumberSeq;
        InventDim           loopToInventDim;
        WHSWorkInventTrans  workInventTrans;
        WHSWorkQuarantine   workQuarantine;
        InventHandlingQty   tmpQty;

        ttsbegin;

        inventTransNumberSeq = NumberSeq::newGetNum(InventParameters::numRefInventTransId());

        if (executeWork)
        {
            // Create the Work Invent Trans records for the Put Work Line.
            loopToInventDim = this.initializeToInventDimForProcessMultiSKUPutWIT(
                _loopWorkInventTrans,
                _toInventDim,
                _toInventDimWIT);

            workInventTrans.WorkId                  = _workLine.WorkId;
            workInventTrans.LineNum                 = _workLine.LineNum;
            workInventTrans.InventDimIdTo           = loopToInventDim.InventDimId;
            workInventTrans.InventTransIdParent     = inventTransNumberSeq.num();
            workInventTrans.TransDateTime           = DateTimeUtil::utcNow();
            workInventTrans.ItemId                  = _loopWorkInventTrans.ItemId;
            workInventTrans.Qty                     = _loopWorkInventTrans.Qty;
            workInventTrans.InventQtyRemain         = _loopWorkInventTrans.Qty;
            workInventTrans.TransactionWeight       = _loopWorkInventTrans.TransactionWeight;
            workInventTrans.RemainingTransactionWeight = _loopWorkInventTrans.TransactionWeight;
            workInventTrans.InventDimIdFrom         = _loopWorkInventTrans.InventDimIdTo;
            workInventTrans.insert();

            // Process the Work Invent Trans record.
            this.moveQuantities(workInventTrans, loopToInventDim, _ledgerVoucher, null);
            
            WHSCatchWeightTagDimensionUpdater tagDimensionUpdater;

            if (WHSInventTable::isCatchWeightTagTracked(_loopWorkInventTrans.ItemId)
                && WHSInventTable::catchWeightTagDimensionTrackingMethod(_loopWorkInventTrans.ItemId) == WHSCatchWeightTagDimensionTrackingMethod::ProductTrackingAndAllStorageDimensions)
            {
                // Tags are not updated to user locations so use the original inventory dimension passed in.
                InventDim tagFromInventDim = InventDim::find(_loopInventDimId);

                tagDimensionUpdater = WHSCatchWeightTagDimensionUpdater::newPutWorkInventTrans(workInventTrans, tagFromInventDim, loopToInventDim);
            }
            
            if (fromInventStatusId != toInventStatusId)
            {
                workQuarantine.initFromWorkLine(_workLine);
                workQuarantine.Qty = _loopWorkInventTrans.Qty;
                workQuarantine.InventQtyRemain = _loopWorkInventTrans.Qty;
                workQuarantine.ItemId = _loopWorkInventTrans.ItemId;

                if (WMSLocation::find(_toInventDim.wmsLocationId, _toInventDim.InventLocationId).whsLocationIsLPControlled())
                {
                    workQuarantine.setDimIds(loopToInventDim, fromInventStatusId, toInventStatusId, toLicensePlateId);
                }
                else
                {
                    workQuarantine.setDimIds(loopToInventDim, fromInventStatusId, toInventStatusId, '');
                }

                if (PdsGlobal::pdsIsCWItem(_loopWorkInventTrans.ItemId))
                {
                    workQuarantine.CapturedWeight = _loopWorkInventTrans.TransactionWeight;
                    workQuarantine.RemainingCapturedWeight = _loopWorkInventTrans.TransactionWeight;
                }

                workQuarantine.insert();
                WHSWorkQuarantineExecutor quarantineExecutor = WHSWorkQuarantineExecutor::newWorkQuarantine(workQuarantine, _loopWorkInventTrans.Qty, true);

                if (tagDimensionUpdater)
                {
                    // Since to inventory status changed, then use the quarantine to InventDim as the destination dimension for the tags
                    tagDimensionUpdater.parmToInventDim(InventDim::find(workQuarantine.InventDimIdTo));
                    quarantineExecutor.parmCatchWeightTagDimensionUpdater(tagDimensionUpdater);
                }

                quarantineExecutor.execute();
            }
            else if (tagDimensionUpdater)
            {
                tagDimensionUpdater.updateCatchWeightTags();
            }
        }

        tmpQty += _loopWorkInventTrans.Qty;

        ttscommit;

        return tmpQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndProcessSingleSKUPickWIT</Name>
				<Source><![CDATA[
    private WHSTransWeight createAndProcessSingleSKUPickWIT(
        WHSWorkLine     _workLine,
        InventDim       _fromInventDim,
        InventDim       _toInventDim,
        InventDim       _toInventDimWIT,
        LedgerVoucher   _ledgerVoucher)
    {
        WHSTransWeight transWeightToMove = this.calculateTransWeightToMove(_workLine, _fromInventDim);

        WHSWorkInventTrans workInventTrans = this.createWorkInventTrans(_workLine, _fromInventDim, _toInventDimWIT, transWeightToMove);
        
        if (executeWork)
        {
            this.moveQuantities(workInventTrans, _toInventDim, _ledgerVoucher, null);

        }

        return transWeightToMove;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndProcessSingleSKUPutWIT</Name>
				<Source><![CDATA[
    private void createAndProcessSingleSKUPutWIT(
        WHSWorkLine     _workLine,
        InventDim       _fromInventDim,
        InventDim       _toInventDim,
        InventDim       _toInventDimWIT,
        LedgerVoucher   _ledgerVoucher,
        WHSTransWeight  _movedWeight)
    {
        if (executeWork)
        {
            WHSLocationMixingConstraintCheckSkip locationMixingConstraintCheckSkip;

            WHSWorkInventTrans workInventTrans = this.createWorkInventTrans(_workLine, _fromInventDim, _toInventDimWIT, _movedWeight);

            //For scenarios where the status is changed as part of the move we need to temporarily skip the mixed status change since the item is first moved to the to-location and then have the status changed afterwards.
            if (this.canSkipMixedInventStatusCheck())
            {
                locationMixingConstraintCheckSkip = WHSLocationMixingConstraintCheckSkip::construct();
                locationMixingConstraintCheckSkip.parmSkipAllowMixedStatusCheck(true);
            }

            this.moveQuantities(workInventTrans, _toInventDim, _ledgerVoucher, locationMixingConstraintCheckSkip);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveQuantities</Name>
				<Source><![CDATA[
    private void moveQuantities(
        WHSWorkInventTrans                      _workInventTrans,
        InventDim                               _toInventDim,
        LedgerVoucher                           _ledgerVoucher,
        WHSLocationMixingConstraintCheckSkip    _locationMixingConstraintCheckSkip)
    {
        
        PdsCWInventQty inventoryCWQty;
        InventQty inventQtyToMove;

        if (PdsGlobal::pdsIsCWItem(_workInventTrans.ItemId))
        {
            inventQtyToMove = _workInventTrans.RemainingTransactionWeight;
            inventoryCWQty = _workInventTrans.InventQtyRemain;
        }
        else
        {
            inventQtyToMove = _workInventTrans.InventQtyRemain;
            inventoryCWQty = 0;
        }
        
        WHSInvent::moveWorkQuantities(_workInventTrans, _workInventTrans.InventDimIdFrom, _toInventDim.InventDimId, inventQtyToMove, inventoryCWQty, inventCostOnhandCache, _ledgerVoucher, null, true, false, _locationMixingConstraintCheckSkip);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkInventTransReservationCollectionBuilder</Name>
				<Source><![CDATA[
    public WHSWorkInventTransReservationCollectionBuilder getWorkInventTransReservationCollectionBuilder()
    {
        if (!workInventTransReservationCollectionBuilder)
        {
            workInventTransReservationCollectionBuilder = WHSWorkInventTransReservationCollectionBuilder::construct();

            // If we are moving the entire LP (also including the case where there is only 1 item on the LP, when isMovingWholeLP = false)
            if (isMovingWholeLP || this.isMovingEntireSingleItemLP(fromLicensePlateId))
            {
                workInventTransReservationCollectionBuilder.addFromLicensePlate(this.fromLocation(), fromLicensePlateId);
            }
            else
            {
                workInventTransReservationCollectionBuilder.addFromItemHandlingQty(itemId, this.buildFromInventDim(), this.singleItemInventQuantityBeingMoved(), null);
            }
        }

        return workInventTransReservationCollectionBuilder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteReservedWorkInventTrans</Name>
				<Source><![CDATA[
    private void deleteReservedWorkInventTrans(Enumerator _workInventTransReservationEnumerator)
    {
        while (_workInventTransReservationEnumerator.moveNext())
        {
            WHSWorkInventTrans workInventTransDelete;
            WHSWorkInventTrans workInventTransCurrent = _workInventTransReservationEnumerator.current() as WHSWorkInventTrans;

            delete_from workInventTransDelete
                where workInventTransDelete.RecId == workInventTransCurrent.recId
                   && workInventTransDelete.RecVersion == workInventTransCurrent.RecVersion;

            if (workInventTransDelete.RowCount() == 0)
            {
                throw infolog.add(Exception::UpdateConflict, strFmt("@WAX:DeleteConflictExceptionMessage", tableStr(WHSWorkInventTrans)));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteOrderCommittedReservations</Name>
				<Source><![CDATA[
    private void deleteOrderCommittedReservations(Enumerator _orderCommittedReservationEnumerator)
    {
        while (_orderCommittedReservationEnumerator.moveNext())
        {
            WHSOrderCommittedTransReservation orderCommittedTransReservation = _orderCommittedReservationEnumerator.current() as WHSOrderCommittedTransReservation;

            WHSOrderCommittedReservationFacade::updateInventoryReservation(orderCommittedTransReservation.parmOrderCommittedReservationRecId(), -orderCommittedTransReservation.parmReservedQuantity(), InventDim::find(orderCommittedTransReservation.parmReservedInventDimId()));            
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReservationRemovalAllowed</Name>
				<Source><![CDATA[
    private boolean isReservationRemovalAllowed()
    {
        return executeWork
            && WHSWorkUser::find(userId).AllowInventoryMovementWithAssociatedWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildFromInventDim</Name>
				<Source><![CDATA[
    private InventDim buildFromInventDim()
    {
        InventDim fromInventDim;
        buf2Buf(inventDim, fromInventDim);

        // Create the InventDim record(s) for the Movement Pick Work Line.
        fromInventDim.wmsLocationId     = fromLocationId;
        fromInventDim.LicensePlateId    = fromLicensePlateId;
        fromInventDim.InventStatusId    = fromInventStatusId;
        fromInventDim = InventDim::findOrCreate(fromInventDim);

        return fromInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustHandleReservationRemoval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true, if we expect that we'll need to handle work reservations on associated work; Otherwise, false.
    /// </summary>
    /// <returns>True, if removal of reservations might need to be performed; Otherwise, false.</returns>
    public boolean mustHandleReservationRemoval()
    {
        return (!reverseWork
                && this.isReservationRemovalAllowed() 
                && (this.isInventoryStatusBeingChanged() 
                    || this.isLocationBeingChanged()
                    || (WHSReservationHierarchyElementPolicyProvider::singleton().isFlexibleReservationEnabledForItem(ItemId)
                        && this.getWorkInventTransReservationCollectionBuilder().hasFlexibleReservations())));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventoryStatusBeingChanged</Name>
				<Source><![CDATA[
    private boolean isInventoryStatusBeingChanged()
    {
        return (fromInventStatusId != toInventStatusId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a new movement work order using the specified parameters.
    /// </summary>
    /// <returns>Id of the work order created.</returns>
    public WHSWorkId createWork()
    {
        this.validate();

        ttsbegin;

        this.findAndDecreaseStageWorkMovement();
  
        // Create the Work header record.
        WHSWorkTable workTable = this.createWorkHeader();

        if (   workTable.InventoryTransactionMechanism == WHSInventoryTransactionMechanismEnum::InventTrans
            || !executeWork)
        {
            this.createWorkLines(workTable);
        }
        else
        {
            // We are reaching this branch if we are executing movement work right away in the new stack.
            this.createAndExecuteWorkLinesBasedOnWarehouseInventoryTransaction(workTable);
        }

        ttscommit;

        return workTable.WorkId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndExecuteWorkLinesBasedOnWarehouseInventoryTransaction</Name>
				<Source><![CDATA[
    private void createAndExecuteWorkLinesBasedOnWarehouseInventoryTransaction(WHSWorkTable _workTable)
    {
        if (!executeWork)
        {
            // We should not reach this place because of the previous checks. This check to be explicit.
            WHSInventoryTransactionErrorProvider::throwNotSupportedWarehouseTransactionScenario();
        }

        _workTable.ExecutedWithoutUserLocation = NoYes::Yes;
        _workTable.update();

        // Create the From InventDimId.
        InventDim fromInventDim = this.buildFromInventDim();
        if (this.isMovingWholeLP)
        {
            fromInventDim.clearNotSelectedDim(InventDimParm::allStorageDim());
            fromInventDim = InventDim::findOrCreate(fromInventDim);
        }

        // Create the From (Pick) Work Line.
        WHSWorkLine pickWorkLine = this.createWorkLine(_workTable.WorkId, WHSWorkType::Pick, fromLocationId, fromInventDim);

        // Create the Pick Work Trans record.
        this.createWorkTrans(pickWorkLine, fromInventDim.InventDimId, fromLicensePlateId);

        // Create the To InventDimId.
        InventDim toInventDim;
        buf2Buf(inventDim, toInventDim);

        // Create the To License Plate
        if (toLicensePlateId)
        {
            WHSAgingDate agingDate = WHSLicensePlate::calculateAgingDateForMovement(fromLicensePlateId, fromLocationId, inventDim.InventLocationId, toLicensePlateId);
            WHSLicensePlate::createLicensePlateWithAgingDate(toLicensePlateId, agingDate);
        }

        toInventDim.wmsLocationId       = toLocationId;     // this is valid only if execute right away and skip the user location
        toInventDim.LicensePlateId      = WMSLocation::find(toLocationId, toInventDim.InventLocationId).whsLocationIsLPControlled() ? toLicensePlateId : '';
        toInventDim.InventStatusId      = toInventStatusId;
        if (this.isMovingWholeLP)
        {
            toInventDim.clearNotSelectedDim(InventDimParm::allStorageDim());
        }
        toInventDim = InventDim::findOrCreate(toInventDim);

        // If we move across locations and allow removal of reservations we need to handle that we potentially move reserved quantity
        boolean mustHandleReservationRemoval;
        if (stageWorkMovement == null)
        {
            mustHandleReservationRemoval = this.mustHandleReservationRemoval();
        }

        if (mustHandleReservationRemoval)
        {
            workInventTransReservationCollectionBuilder = this.getWorkInventTransReservationCollectionBuilder();

            this.validateMovementWithWorkReservations(workInventTransReservationCollectionBuilder, pickWorkLine);

            // This will remove the reservations allowing us to move the entire quantity
            this.deleteReservedWorkInventTrans(workInventTransReservationCollectionBuilder.getWorkInventTransEnumerator());

            if (WHSReservationHierarchyElementPolicyProvider::singleton().isFlexibleReservationEnabledForItem(ItemId)
                || isMovingWholeLP)
            {
                this.deleteOrderCommittedReservations(workInventTransReservationCollectionBuilder.getOrderCommittedReservationEnumerator());
            }
        }

        // Create the To (Put) Work Line.
        WHSWorkLine putWorkLine = this.createWorkLine(_workTable.WorkId, WHSWorkType::Put, toLocationId, toInventDim);

        // Create the Put Work Trans record.
        this.createWorkTrans(putWorkLine, toInventDim.InventDimId, toLicensePlateId);

        // Create the WITs and move inventory.
        WHSInventoryTransactionHandlingQty    totalHandlingQty;
        WHSInventoryTransactionHandlingWeight totalHandlingWeight;

        [totalHandlingQty, totalHandlingWeight] = this.createAndExecuteWITBasedOnWarehouseInventoryTransaction(
            pickWorkLine,
            putWorkLine,
            fromInventDim,
            toInventDim);

        // Update the Qty on the Work Line
        pickWorkLine.QtyWork = totalHandlingQty;
        pickWorkLine.InventQtyWork = totalHandlingQty;
        if (pickWorkLine.WorkStatus == WHSWorkStatus::Closed)
        {
            pickWorkLine.QtyRemain = 0;
            pickWorkLine.InventQtyRemain = 0;
        }
        pickWorkLine.doUpdate();

        putWorkLine.QtyWork = totalHandlingQty;
        putWorkLine.InventQtyWork = totalHandlingQty;
        if (putWorkLine.WorkStatus == WHSWorkStatus::Closed)
        {
            putWorkLine.QtyRemain = 0;
            putWorkLine.InventQtyRemain = 0;
        }
        putWorkLine.doUpdate();

        if (mustHandleReservationRemoval)
        {
            // Quarantine journal reverses/recreates order-committed reservations ignoring balance (see below), so restore order-committed reservations immediately
            if (WHSReservationHierarchyElementPolicyProvider::singleton().isFlexibleReservationEnabledForItem(ItemId)
                || isMovingWholeLP)
            {
                this.reCreateOrderCommittedReservations(workInventTransReservationCollectionBuilder.getOrderCommittedReservationEnumerator());
            }
        }

        // Create and execute the Quarantine records.
        if (executeWork && itemId)
        {
            this.createAndExecuteSingleSKUQuarantine(toInventDim, toInventDim, putWorkLine, totalHandlingWeight);
        }

        if (mustHandleReservationRemoval)
        {
            if (!workInventTransReservationCollectionBuilder)
            {
                throw error(Error::wrongUseOfFunction(funcName()));
            }

            this.updateReservedWorkLinesLocation(workInventTransReservationCollectionBuilder.getWorkLineEnumerator());

            this.reCreateReservedWorkInventTrans(workInventTransReservationCollectionBuilder.getEnumerator());
        }

        this.updatePackedContainerLocation(putWorkLine);
  
        // Increment staged work
        if (stageWorkMovement != null)
        {
            stageWorkMovement.increaseStagedWork(toLocationId);
        }

        // Update location status fields for both the to and from locations.
        WHSLocationWorkUpdater::updateLocationInfoFromMovement(
            inventDim.InventLocationId,
            fromLocationId,
            inventDim.InventLocationId,
            toLocationId,
            fromLicensePlateId);

        this.handleLocationLicensePlatePositioning(fromLicensePlateId, this.fromLocation(), toLicensePlateId, this.toLocation());

        // If not changing the status for a catch tag tracked item then update catch weight tags now (with status change, the tags are updated along with the status update)
        if (executeWork
            && !isMovingWholeLP
            && fromInventStatusId == toInventStatusId
            && PdsGlobal::pdsIsCWItem(putWorkLine.ItemId)
            && WHSInventTable::catchWeightTagDimensionTrackingMethod(putWorkLine.ItemId) == WHSCatchWeightTagDimensionTrackingMethod::ProductTrackingAndAllStorageDimensions)
        {
            WHSCatchWeightTagDimensionUpdater::newScannedTags(scannedTags, toInventDim).updateCatchWeightTags();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndExecuteWITBasedOnWarehouseInventoryTransaction</Name>
				<Source><![CDATA[
    private container createAndExecuteWITBasedOnWarehouseInventoryTransaction(
        WHSWorkLine _pickWorkLine,
        WHSWorkLine _putWorkLine,
        InventDim   _fromInventDim,
        InventDim   _toInventDim)
    {
        InventDim copyButReplaceLP(InventDim _sourceInventDim, WHSLicensePlateId _newLicensePlateId)
        {
            InventDim newInventDim = _sourceInventDim.data();
            newInventDim.LicensePlateId = _newLicensePlateId;
            newInventDim = InventDim::findOrCreate(newInventDim);   // we rely on correct InventDimId downstream.

            return newInventDim;
        }

        InventDim fromInventDim = _fromInventDim;

        // toInventDim contains potentially a new inventory status (if inventory status being changed as part of inventory movement).
        // But the warehouse movement work does not change status by itself and should still keep the original inventory status.
        InventDim toInventDim = this.copyButReplaceInventoryStatus(_toInventDim, fromInventDim.InventStatusId);

        container totalHandlingQuantityAndWeight;

        if (isMovingWholeLP)
        {
            if (WHSContainerTable::isLicensePlateIdUsedForContainerGrouping(fromLicensePlateId))
            {
                WHSInventoryTransactionHandlingQty    totalHandlingQty;
                WHSInventoryTransactionHandlingWeight totalHandlingWeight;

                WHSLicensePlate childLicensePlate;

                while select LicensePlateId from childLicensePlate
                    where childLicensePlate.LicensePlateParent == fromLicensePlateId
                {
                    InventDim fromInventDimWithChildLP = copyButReplaceLP(fromInventDim, childLicensePlate.LicensePlateId);
                    InventDim toInventDimWithChildLP = copyButReplaceLP(toInventDim, childLicensePlate.LicensePlateId);

                    WHSInventoryTransactionHandlingQty    totalHandlingQtyOfChildLP;
                    WHSInventoryTransactionHandlingWeight totalHandlingWeightOfChildLP;

                    [totalHandlingQtyOfChildLP, totalHandlingWeightOfChildLP] = this.createAndExecuteWITBasedOnWarehouseInventoryTransactionWholeLP(
                        _pickWorkLine,
                        _putWorkLine,
                        fromInventDimWithChildLP,
                        toInventDimWithChildLP);

                    totalHandlingQty += totalHandlingQtyOfChildLP;
                    totalHandlingWeight += totalHandlingWeightOfChildLP;
                }

                totalHandlingQuantityAndWeight = [totalHandlingQty, totalHandlingWeight];
            }
            else
            {
                totalHandlingQuantityAndWeight = this.createAndExecuteWITBasedOnWarehouseInventoryTransactionWholeLP(
                    _pickWorkLine,
                    _putWorkLine,
                    fromInventDim,
                    toInventDim);
            }
        }
        else
        {
            totalHandlingQuantityAndWeight = this.createAndExecuteWITBasedOnWarehouseInventoryTransactionSingleItem(
                _pickWorkLine,
                _putWorkLine,
                fromInventDim,
                toInventDim);
        }

        return totalHandlingQuantityAndWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyButReplaceInventoryStatus</Name>
				<Source><![CDATA[
    private InventDim copyButReplaceInventoryStatus(InventDim _inventDim, WHSInventStatusId _newInventStatusId)
    {
        InventDim newInventDim = _inventDim.data();
        newInventDim.InventStatusId = _newInventStatusId;

        return InventDim::findOrCreate(newInventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTransWeightToMove</Name>
				<Source><![CDATA[
    private WHSTransWeight calculateTransWeightToMove(WHSWorkLine _workLine, InventDim _fromInventDim)
    {
        WHSTransWeight transWeightToMove;
        
        if (PdsGlobal::pdsIsCWItem(_workLine.ItemId))
        {
            if (capturedWeight)
            {
                transWeightToMove = capturedWeight;
            }
            else
            {
                //use specific from dimensions to get most accurate average calculation,e.g. if a batch or license plate is moved
                transWeightToMove = WHSCatchWeightHelper::calculateMovingWeight(_workLine.ItemId, _fromInventDim.inventDimId, _workLine.InventQtyRemain);
            }
        }

        return transWeightToMove;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndExecuteWITBasedOnWarehouseInventoryTransactionSingleItem</Name>
				<Source><![CDATA[
    private container createAndExecuteWITBasedOnWarehouseInventoryTransactionSingleItem(
        WHSWorkLine _pickWorkLine,
        WHSWorkLine _putWorkLine,
        InventDim   _fromInventDim,
        InventDim   _toInventDim)
    {
        WHSTransWeight transWeightToMove = this.calculateTransWeightToMove(_pickWorkLine, _fromInventDim);
        WHSInventoryItemSetId itemSetId = WHSSequentialGuidGenerator::generateSequentialGuid();

        WHSInventoryItemSetElement::insertItemSetElement(
            itemSetId,
            itemId,
            _fromInventDim,
            _pickWorkLine.InventQtyWork,
            transWeightToMove);

        this.createAndExecutePickPutWITBasedOnWarehouseInventoryTransactions(
            _pickWorkLine,
            _putWorkLine,
            _fromInventDim,
            _toInventDim,
            itemId,
            _pickWorkLine.InventQtyWork,
            transWeightToMove,
            itemSetId);

        return [_pickWorkLine.InventQtyWork, transWeightToMove];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndExecuteWITBasedOnWarehouseInventoryTransactionWholeLP</Name>
				<Source><![CDATA[
    private container createAndExecuteWITBasedOnWarehouseInventoryTransactionWholeLP(
        WHSWorkLine _pickWorkLine,
        WHSWorkLine _putWorkLine,
        InventDim   _fromInventDim,
        InventDim   _toInventDim)
    {
        ItemId prevItemId;
        WHSInventoryItemSetId prevItemSetId = emptyGuid();

        WHSInventoryTransactionHandlingQty itemSetHandlingQty;
        WHSInventoryTransactionHandlingQty totalHandlingQty;
        WHSInventoryTransactionHandlingWeight itemSetHandlingWeight;
        WHSInventoryTransactionHandlingWeight totalHandlingWeight;

        boolean shouldExcludeInventStatusIdFromWIT = false;

        InventDim copyButReplaceInventoryStatusIfNeeded(InventDim _inventDim)
        {
            return shouldExcludeInventStatusIdFromWIT ? this.copyButReplaceInventoryStatus(_inventDim, '') : _inventDim;
        }

        void handleInventSumLoop(ItemId _itemId, InventDim _loopInventDim, InventQty _physicalInventQty, PdsCWInventQty _cwInventQty)
        {
            // if item changed, than need to create the WITs for the already collected stuff.
            if (_itemId != prevItemId)
            {
                if (prevItemSetId != emptyGuid())
                {
                    this.createAndExecutePickPutWITBasedOnWarehouseInventoryTransactions(
                        _pickWorkLine,
                        _putWorkLine,
                        copyButReplaceInventoryStatusIfNeeded(_fromInventDim),
                        copyButReplaceInventoryStatusIfNeeded(_toInventDim),
                        prevItemId,
                        itemSetHandlingQty,
                        itemSetHandlingWeight,
                        prevItemSetId);
                }

                // construct the item set
                prevItemId = _itemId;
                prevItemSetId = WHSSequentialGuidGenerator::generateSequentialGuid();

                itemSetHandlingQty = 0;
                itemSetHandlingWeight = 0;

                shouldExcludeInventStatusIdFromWIT = false;
            }

            WHSInventoryTransactionHandlingQty    handlingQty;
            WHSInventoryTransactionHandlingWeight handlingWeight;

            [handlingQty, handlingWeight] = WHSInventoryTransactionQuantityFormatConverter::convertFromCwFormatToWarehouseHandlingFormat(
                prevItemId,
                _physicalInventQty,
                _cwInventQty);

            itemSetHandlingQty += handlingQty;
            itemSetHandlingWeight += handlingWeight;

            totalHandlingQty += handlingQty;
            totalHandlingWeight += handlingWeight;

            WHSInventoryItemSetElement::insertItemSetElement(
                prevItemSetId,
                prevItemId,
                _loopInventDim,
                handlingQty,
                handlingWeight);

            // When moving the whole LP, the _fromInventDim will still contain the inventory status.
            // Since in the new stack we produce less WIT records, we need to clean up this manually when several statuses are detected.
            // This is to make sure that InventStatusId on WIT's InventDimIdFrom and InventDimIdTo match the actual transactions.
            if (_loopInventDim.InventStatusId != _fromInventDim.InventStatusId)
            {
                shouldExcludeInventStatusIdFromWIT = true;
            }
        }

        if (reverseWork)
        {
            InventSumUnionAllDeltaPhysicalQty   inventSumDelta;
            InventDim                           loopInventDim;

            // For reverse work we must use the inventSumDelta Table
            while select ItemId, PhysicalInvent, PdsCWPhysicalInvent, InventDimId from inventSumDelta
            where inventSumDelta.PhysicalInvent > 0
            join loopInventDim
                where inventSumDelta.InventDimId        == loopInventDim.InventDimId
                &&    loopInventDim.InventSiteId        == _fromInventDim.InventSiteId
                &&    loopInventDim.InventLocationId    == _fromInventDim.InventLocationId
                &&    loopInventDim.wmsLocationId       == _fromInventDim.wmsLocationId
                &&    loopInventDim.LicensePlateId      == _fromInventDim.LicensePlateId
            {
                handleInventSumLoop(
                    inventSumDelta.ItemId,
                    loopInventDim,
                    inventSumDelta.PhysicalInvent,
                    inventSumDelta.PdsCWPhysicalInvent);
            }
        }
        else
        {
            InventSum loopInventSum;

            if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                while select ItemId, PhysicalInvent, PdsCWPhysicalInvent, InventDimId, #InventDimGroupAllFields from loopInventSum
                    order by ItemId
                    where loopInventSum.ClosedQty           == NoYes::No
                       && loopInventSum.PhysicalInvent      > 0
                       && loopInventSum.InventSiteId        == _fromInventDim.InventSiteId
                       && loopInventSum.InventLocationId    == _fromInventDim.InventLocationId
                       && loopInventSum.wmsLocationId       == _fromInventDim.wmsLocationId
                       && loopInventSum.LicensePlateId      == _fromInventDim.LicensePlateId
                {
                    handleInventSumLoop(
                        loopInventSum.ItemId,
                        loopInventSum.inventDim(),
                        loopInventSum.PhysicalInvent,
                        loopInventSum.PdsCWPhysicalInvent);
                }
            }
            else
            {
                InventDim loopInventDim;

                while select ItemId, PhysicalInvent, PdsCWPhysicalInvent, InventDimId from loopInventSum
                    where loopInventSum.ClosedQty == NoYes::No
                       && loopInventSum.PhysicalInvent  > 0
                    join loopInventDim
                        where loopInventSum.InventDimId         == loopInventDim.InventDimId
                        &&    loopInventDim.InventSiteId        == _fromInventDim.InventSiteId
                        &&    loopInventDim.InventLocationId    == _fromInventDim.InventLocationId
                        &&    loopInventDim.wmsLocationId       == _fromInventDim.wmsLocationId
                        &&    loopInventDim.LicensePlateId      == _fromInventDim.LicensePlateId
                {
                    handleInventSumLoop(
                        loopInventSum.ItemId,
                        loopInventDim,
                        loopInventSum.PhysicalInvent,
                        loopInventSum.PdsCWPhysicalInvent);
                }
            }
        }

        if (prevItemSetId != emptyGuid())
        {
            this.createAndExecutePickPutWITBasedOnWarehouseInventoryTransactions(
                _pickWorkLine,
                _putWorkLine,
                copyButReplaceInventoryStatusIfNeeded(_fromInventDim),
                copyButReplaceInventoryStatusIfNeeded(_toInventDim),
                prevItemId,
                itemSetHandlingQty,
                itemSetHandlingWeight,
                prevItemSetId);
        }

        return [totalHandlingQty, totalHandlingWeight];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndExecutePickPutWITBasedOnWarehouseInventoryTransactions</Name>
				<Source><![CDATA[
    private void createAndExecutePickPutWITBasedOnWarehouseInventoryTransactions(
        WHSWorkLine _pickWorkLine,
        WHSWorkLine _putWorkLine,
        InventDim _fromInventDim,
        InventDim _toInventDim,
        ItemId _itemId,
        WHSInventoryTransactionHandlingQty _itemSetHandlingQty,
        WHSInventoryTransactionHandlingWeight _itemSetHandlingWeight,
        WHSInventoryItemSetId _itemSetId)
    {
        NumberSeq inventTransNumberSeq = NumberSeq::newGetNum(InventParameters::numRefInventTransId());

        // need to create WIT for the constructed item set
        WHSWorkInventTrans pickWorkInventTrans, putWorkInventTrans;

        pickWorkInventTrans.clear();
        pickWorkInventTrans.WorkId                  = _pickWorkLine.WorkId;
        pickWorkInventTrans.LineNum                 = _pickWorkLine.LineNum;
        pickWorkInventTrans.InventDimIdFrom         = _fromInventDim.InventDimId;
        pickWorkInventTrans.InventDimIdTo           = _toInventDim.InventDimId;
        pickWorkInventTrans.InventTransIdParent     = inventTransNumberSeq.num();
        pickWorkInventTrans.TransDateTime           = DateTimeUtil::utcNow();
        pickWorkInventTrans.ItemId                  = _itemId;
        pickWorkInventTrans.ItemSetId               = _itemSetId;
        pickWorkInventTrans.InventoryTransactionOriginId = WHSSequentialGuidGenerator::generateSequentialGuid();

        pickWorkInventTrans.setInitialQuantityAndWeightValues(_itemSetHandlingQty, _itemSetHandlingWeight);
        if (executeWork)
        {
            pickWorkInventTrans.InventQtyRemain = 0;
            pickWorkInventTrans.RemainingTransactionWeight = 0;
        }

        // skip the insert() logic.
        pickWorkInventTrans.doInsert();

        // Put WIT.
        buf2Buf(pickWorkInventTrans, putWorkInventTrans);
        putWorkInventTrans.LineNum = _putWorkLine.LineNum;
        putWorkInventTrans.RecId = 0;
        putWorkInventTrans.InventoryTransactionOriginId = WHSSequentialGuidGenerator::generateSequentialGuid();
        putWorkInventTrans.doInsert();

        // here we do the fast movement using the constructed set and bypassing the user location.
        WHSInventoryTransactionSource pickSource = WHSInventoryTransactionSource::newFromValues(
            WHSInventoryTransactionReferenceCategoryEnum::Work,
            pickWorkInventTrans.WorkId,
            pickWorkInventTrans.InventoryTransactionOriginId);

        WHSInventoryTransactionSource putSource = WHSInventoryTransactionSource::newFromValues(
            WHSInventoryTransactionReferenceCategoryEnum::Work,
            putWorkInventTrans.WorkId,
            putWorkInventTrans.InventoryTransactionOriginId);

        WHSInventoryTransactionActionIssueRegistrationParameters issueActionParams = WHSInventoryTransactionActionIssueRegistrationParameters::newFromValues(
            pickSource,
            _itemSetId,
            WHSInventoryStorageDimensions::newFromInventDim(_fromInventDim),
            WHSInventoryTransactionActionValidationParameters::noChecks()
                .activateAllCreateReservationChecks()
                .activateAllIssueRegistrationChecks());

        WHSInventoryTransactionIssueRegistrationAction::construct().execute(issueActionParams);

        WHSInventoryTransactionActionReceiptRegistrationParameters receiptActionParams = WHSInventoryTransactionActionReceiptRegistrationParameters::newFromValues(
            putSource,
            _itemSetId,
            WHSInventoryStorageDimensions::newFromInventDim(_toInventDim),
            WHSInventoryTransactionActionValidationParameters::noChecks()
                .activateAllRemoveReservationChecks()
                .activateAllReceiptRegistrationChecks()
                .setCheckMultiStatusLP(!isMovingWholeLP));

        if (this.canSkipMixedInventStatusCheck())
        {
            receiptActionParams.parmValidationParameters().setLocationMixingConstraintCheckSkip(WHSLocationMixingConstraintCheckSkip::newSkipAllowMixedStatusCheck());
        }

        WHSInventoryTransactionReceiptRegistrationAction::construct().execute(receiptActionParams);

        // After whole LP is moved may need to perform quarantine and update catch weight tags.
        if (isMovingWholeLP)
        {
            boolean shouldUpdateCatchWeightTags = WHSInventTable::isCatchWeightTagTracked(_itemId) &&
                WHSInventTable::catchWeightTagDimensionTrackingMethod(_itemId) == WHSCatchWeightTagDimensionTrackingMethod::ProductTrackingAndAllStorageDimensions;

            if (shouldUpdateCatchWeightTags || this.isInventoryStatusBeingChanged())
            {
                WHSInventoryItemSetElement itemSetElement;

                while select itemSetElement
                    where itemSetElement.ItemSetId == _itemSetId
                {
                    InventDim fromInventDimItemSetElement;
                    InventDim toInventDimItemSetElement;

                    [fromInventDimItemSetElement, toInventDimItemSetElement] = this.constructDetailedFromAndToInventDimBasedOnItemSetElement(
                        _fromInventDim,
                        _toInventDim,
                        itemSetElement);

                    WHSCatchWeightTagDimensionUpdater tagDimensionUpdater;

                    if (shouldUpdateCatchWeightTags)
                    {
                        // Tags are not updated to user locations so use the original inventory dimension passed in.
                        tagDimensionUpdater = WHSCatchWeightTagDimensionUpdater::newPutWorkInventTrans(putWorkInventTrans, fromInventDimItemSetElement, toInventDimItemSetElement);
                    }
                    
                    if (this.isInventoryStatusBeingChanged())
                    {
                        WHSWorkQuarantine workQuarantine;

                        workQuarantine.initFromWorkLine(_putWorkLine);
                        workQuarantine.Qty = itemSetElement.HandlingQty;
                        workQuarantine.InventQtyRemain = itemSetElement.HandlingQty;
                        workQuarantine.ItemId = _itemId;

                        if (WMSLocation::find(toInventDimItemSetElement.wmsLocationId, toInventDimItemSetElement.InventLocationId).whsLocationIsLPControlled())
                        {
                            workQuarantine.setDimIds(toInventDimItemSetElement, fromInventStatusId, toInventStatusId, toLicensePlateId);
                        }
                        else
                        {
                            workQuarantine.setDimIds(toInventDimItemSetElement, fromInventStatusId, toInventStatusId, '');
                        }

                        if (PdsGlobal::pdsIsCWItem(_itemId))
                        {
                            workQuarantine.CapturedWeight = itemSetElement.HandlingWeight;
                            workQuarantine.RemainingCapturedWeight = itemSetElement.HandlingWeight;
                        }

                        workQuarantine.insert();
                        WHSWorkQuarantineExecutor quarantineExecutor = WHSWorkQuarantineExecutor::newWorkQuarantine(workQuarantine, itemSetElement.HandlingQty, true);

                        if (tagDimensionUpdater)
                        {
                            // Since to inventory status changed, then use the quarantine to InventDim as the destination dimension for the tags
                            tagDimensionUpdater.parmToInventDim(InventDim::find(workQuarantine.InventDimIdTo));
                            quarantineExecutor.parmCatchWeightTagDimensionUpdater(tagDimensionUpdater);
                        }

                        quarantineExecutor.execute();
                    }
                    else if (tagDimensionUpdater)
                    {
                        tagDimensionUpdater.updateCatchWeightTags();
                    }
                }
            }
        }

        // After work transactions have been executed we should check the issue dimension set and make sure weight is within minimum threshold.
        PDSCatchWeightOnHandAdjustment::adjustOnhandWeightWithinThresholds(_itemId, _fromInventDim.inventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructDetailedFromAndToInventDimBasedOnItemSetElement</Name>
				<Source><![CDATA[
    private container constructDetailedFromAndToInventDimBasedOnItemSetElement(
        InventDim _fromInventDim,
        InventDim _toInventDim,
        WHSInventoryItemSetElement _itemSetElement)
    {
        InventDim fromInventDimItemSetElement;
        InventDim toInventDimItemSetElement;

        buf2Buf(_fromInventDim, fromInventDimItemSetElement);
        buf2Buf(_toInventDim, toInventDimItemSetElement);

        _itemSetElement.copyInventoryDimensionsTo(fromInventDimItemSetElement);
        _itemSetElement.copyInventoryDimensionsTo(toInventDimItemSetElement);

        fromInventDimItemSetElement = InventDim::findOrCreate(fromInventDimItemSetElement);
        toInventDimItemSetElement = InventDim::findOrCreate(toInventDimItemSetElement);

        return [fromInventDimItemSetElement, toInventDimItemSetElement];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkLines</Name>
				<Source><![CDATA[
    private void createWorkLines(WHSWorkTable _workTable)
    {
        // Create the Work Line InventDimId.
        InventDim workLineInventDim;
        buf2Buf(inventDim, workLineInventDim);
        workLineInventDim.InventStatusId = fromInventStatusId;
        workLineInventDim = InventDim::findOrCreate(workLineInventDim);

        // Create the From (Pick) Work Line.
        WHSWorkLine workLine = this.createWorkLine(_workTable.WorkId, WHSWorkType::Pick, fromLocationId, workLineInventDim);

        // Create the From InventDimId.
        InventDim fromInventDim = this.buildFromInventDim();

        // Create the Pick Work Trans record.
        this.createWorkTrans(workLine, fromInventDim.InventDimId, fromLicensePlateId);

        // Create the To InventDimId.
        InventDim toInventDim;
        buf2Buf(inventDim, toInventDim);

        // Create the To License Plate
        if (toLicensePlateId)
        {
            WHSAgingDate agingDate = WHSLicensePlate::calculateAgingDateForMovement(fromLicensePlateId, fromLocationId, inventDim.InventLocationId, toLicensePlateId);
            WHSLicensePlate::createLicensePlateWithAgingDate(toLicensePlateId, agingDate);
        }

        toInventDim.wmsLocationId       = userId;
        toInventDim.LicensePlateId      = toLicensePlateId;
        toInventDim.InventStatusId      = fromInventDim.InventStatusId;
        toInventDim = InventDim::findOrCreate(toInventDim);

        // Remove below location dims from the WIT InventDim records.
        InventDim toInventDimWIT      = InventDim::find(toInventDim.InventDimId);
        if (itemId && !executeWork)
        {
            toInventDimWIT.clearBelowLocationDim(itemId);
            toInventDimWIT      = InventDim::findOrCreate(toInventDimWIT);
        }

        // Create common ledger voucher for the updates
        LedgerVoucher ledgerVoucher = this.initLedgerVoucher(_workTable.WorkId);

        // If we move across locations and allow removal of reservations we need to handle that we potentially move reserved quantity
        boolean mustHandleReservationRemoval;
        if (stageWorkMovement == null)
        {
            mustHandleReservationRemoval = this.mustHandleReservationRemoval();
        }

        if (mustHandleReservationRemoval)
        {
            workInventTransReservationCollectionBuilder = this.getWorkInventTransReservationCollectionBuilder();

            this.validateMovementWithWorkReservations(workInventTransReservationCollectionBuilder, workLine);

            // This will remove the reservations allowing us to move the entire quantity
            this.deleteReservedWorkInventTrans(workInventTransReservationCollectionBuilder.getWorkInventTransEnumerator());

            if (WHSReservationHierarchyElementPolicyProvider::singleton().isFlexibleReservationEnabledForItem(ItemId)
                || isMovingWholeLP)
            {
                this.deleteOrderCommittedReservations(workInventTransReservationCollectionBuilder.getOrderCommittedReservationEnumerator());
            }
        }

        WHSTransWeight movedWeight;
        InventHandlingQty tmpQty = 0;
        if (!isMovingWholeLP)
        {
            movedWeight = this.createAndProcessSingleSKUPickWIT(workLine, fromInventDim, toInventDim, toInventDimWIT, ledgerVoucher);
        }
        else if (containerId)
        {
            // If container specified only move inventory tied to container.
            this.createContainerMovement(toInventDimWIT, workLine, containerId);
        }
        else
        {
            if (!reverseWork)
            {
                if (WHSContainerTable::isLicensePlateIdUsedForContainerGrouping(fromLicensePlateId))
                {
                    tmpQty = this.createAndProcessMultiSKUPickWITForGroupedContainers(toInventDimWIT, workLine, ledgerVoucher, fromLicensePlateId);
                }
                else
                {
                    tmpQty = this.createAndProcessMultiSKUPickWIT(toInventDimWIT, workLine, ledgerVoucher);
                }
            }
            else
            {
                tmpQty = this.createAndProcessMultiSKUPickWITDelta(toInventDimWIT, workLine, ledgerVoucher);

                if (!tmpQty)
                {
                    tmpQty = this.createAndProcessMultiSKUPickWIT(toInventDimWIT, workLine, ledgerVoucher);
                }
            }

            // Update the Qty on the Work Line
            workLine.QtyWork = tmpQty;
            workLine.InventQtyWork = tmpQty;
            if (workLine.WorkStatus == WHSWorkStatus::Closed)
            {
                workLine.QtyRemain = 0;
                workLine.InventQtyRemain = 0;
            }
            workLine.update();
        }

        workLineInventDim.InventStatusId = toInventStatusId;
        workLineInventDim = InventDim::findOrCreate(workLineInventDim);

        // Create the To (Put) Work Line.
        workLine = this.createWorkLine(_workTable.WorkId, WHSWorkType::Put, toLocationId, workLineInventDim);

        this.initializeInventDimsForPutWorkLine(toInventDim, fromInventDim);
        toInventDim     = InventDim::findOrCreate(toInventDim);
        fromInventDim   = InventDim::findOrCreate(fromInventDim);

        // Create the Put Work Trans record.
        this.createWorkTrans(workLine, toInventDim.InventDimId, toLicensePlateId);

        // Remove the LP from the WIT InventDim records.
        toInventDimWIT      = InventDim::find(toInventDim.InventDimId);
        if (itemId && !executeWork)
        {
            toInventDimWIT.clearBelowLocationDim(itemId);
        }
        toInventDimWIT      = InventDim::findOrCreate(toInventDimWIT);

        if (!isMovingWholeLP)
        {
            this.createAndProcessSingleSKUPutWIT(workLine, fromInventDim, toInventDim, toInventDimWIT, ledgerVoucher, movedWeight);
        }
        else
        {
            tmpQty = 0;
            WHSWorkInventTrans loopWorkInventTrans;
            InventDim          loopInventDim;

            while select loopWorkInventTrans
                where loopWorkInventTrans.WorkId    == _workTable.WorkId
                &&    loopWorkInventTrans.LineNum   == 1
                join InventDimId from loopInventDim
                where loopInventDim.InventDimId == loopWorkInventTrans.InventDimIdFrom
            {
                tmpQty += this.createAndProcessMultiSKUPutWIT(loopInventDim.InventDimId, loopWorkInventTrans, workLine, toInventDim, toInventDimWIT, ledgerVoucher);
            }

            // Update the Qty on the Work Line
            workLine.QtyWork = tmpQty;
            workLine.InventQtyWork = tmpQty;
            if (workLine.WorkStatus == WHSWorkStatus::Closed)
            {
                workLine.QtyRemain = 0;
                workLine.InventQtyRemain = 0;
            }
            workLine.update();
        }

        if (mustHandleReservationRemoval)
        {
            // Quarantine journal reverses/recreates order-committed reservations ignoring balance (see below), so restore order-committed reservations immediately
            if (WHSReservationHierarchyElementPolicyProvider::singleton().isFlexibleReservationEnabledForItem(ItemId)
                || isMovingWholeLP)
            {
                this.reCreateOrderCommittedReservations(workInventTransReservationCollectionBuilder.getOrderCommittedReservationEnumerator());
            }
        }

        // Create and execute the Quarantine records.
        if (executeWork && itemId)
        {
            this.createAndExecuteSingleSKUQuarantine(workLineInventDim, toInventDim, workLine, movedWeight);
        }

        if (mustHandleReservationRemoval)
        {
            if (!workInventTransReservationCollectionBuilder)
            {
                throw error(Error::wrongUseOfFunction(funcName()));
            }

            this.updateReservedWorkLinesLocation(workInventTransReservationCollectionBuilder.getWorkLineEnumerator());

            this.reCreateReservedWorkInventTrans(workInventTransReservationCollectionBuilder.getEnumerator());
        }

        this.updatePackedContainerLocation(workLine);
  
        // Increment staged work
        if (stageWorkMovement != null)
        {
            stageWorkMovement.increaseStagedWork(toLocationId);
        }

        // Close the ledger voucher as the work lines have been created
        this.closeLedgerVoucher(ledgerVoucher);

        // Update location status fields for both the to and from locations.
        WHSLocationWorkUpdater::updateLocationInfoFromMovement(
            inventDim.InventLocationId,
            fromLocationId,
            inventDim.InventLocationId,
            toLocationId,
            fromLicensePlateId);

        this.handleLocationLicensePlatePositioning(fromLicensePlateId, this.fromLocation(), toLicensePlateId, this.toLocation());

        // If not changing the status for a catch tag tracked item then update catch weight tags now (with status change, the tags are updated along with the status update)
        if (executeWork
            && !isMovingWholeLP
            && fromInventStatusId == toInventStatusId
            && PdsGlobal::pdsIsCWItem(workLine.ItemId)
            && WHSInventTable::catchWeightTagDimensionTrackingMethod(workLine.ItemId) == WHSCatchWeightTagDimensionTrackingMethod::ProductTrackingAndAllStorageDimensions)
        {
            WHSCatchWeightTagDimensionUpdater::newScannedTags(scannedTags, toInventDim).updateCatchWeightTags();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventDimsForPutWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the inventory dimensions for the put work line.
    /// </summary>
    /// <param name = "_toInventDim">The to inventory dimensions.</param>
    /// <param name = "_fromInventDim">The from inventory dimensions.</param>
    protected void initializeInventDimsForPutWorkLine(InventDim _toInventDim, InventDim _fromInventDim)
    {
        _fromInventDim.wmsLocationId     = _toInventDim.wmsLocationId;
        _fromInventDim.LicensePlateId    = _toInventDim.LicensePlateId;
        _toInventDim.wmsLocationId       = toLocationId;

        if (WMSLocation::find(_toInventDim.wmsLocationId, _toInventDim.InventLocationId).whsLocationIsLPControlled())
        {
            _toInventDim.LicensePlateId = toLicensePlateId;
        }
        else
        {
            _toInventDim.LicensePlateId = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleLocationLicensePlatePositioning</Name>
				<Source><![CDATA[
    private void handleLocationLicensePlatePositioning(
        WHSLicensePlateId   _fromLicensePlateId, 
        WMSLocation         _fromWMSLocation,
        WHSLicensePlateId   _toLicensePlateId,
        WMSLocation         _toWMSLocation)
    {
        WHSLocationLicensePlatePositioningSequencer::newFromLicensePlateAtLocation(_fromLicensePlateId, _fromWMSLocation).pickLicensePlateFromCurrentPosition();

        WHSLocationLicensePlatePositioningSequencer::newFromLicensePlateAtLocation(_toLicensePlateId, _toWMSLocation).putLicensePlateAtFirstPosition();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePackedContainerLocation</Name>
				<Source><![CDATA[
    private void updatePackedContainerLocation(WHSWorkLine _workLine)
    {
        WHSWorkTable workTable = _workLine.whsWorkTable();

        if (WHSContainerTable::isLicensePlateIdAssociatedToContainer(workTable.TargetLicensePlateId))
        {
            this.updateSingleContainerLocation(workTable.TargetLicensePlateId, _workLine);
        }
        else if (WHSContainerTable::isLicensePlateIdUsedForContainerGrouping(workTable.TargetLicensePlateId))
        {
            this.updateGroupedContainerLocation(workTable.TargetLicensePlateId, _workLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSingleContainerLocation</Name>
				<Source><![CDATA[
    private void updateSingleContainerLocation(WHSLicensePlateId _containerLicensePlateId, WHSWorkLine _workLine)
    {
        InventHandlingQty totalContainerQuantity = WHSLicensePlate::getTotalHandlingQtyOnLicensePlate(_containerLicensePlateId);

        /*
            If only a part of the container is moved, the container location should not be updated.
            This can happen with reduce picked quantity on the load line.
        */
        if (_workLine.QtyWork == totalContainerQuantity)
        {
            WHSContainerTable::updateContainerLocation(_containerLicensePlateId, _workLine.WMSLocationId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateGroupedContainerLocation</Name>
				<Source><![CDATA[
    private void updateGroupedContainerLocation(WHSLicensePlateId _containerGroupingLicensePlateId, WHSWorkLine _workLine)
    {
        InventHandlingQty totalGroupedContainerQuantity = WHSLicensePlate::getTotalHandlingQtyOnParentLicensePlate(_containerGroupingLicensePlateId);

        /*
            If only a part of the container is moved, the container location should not be updated.
            This can happen with reduce picked quantity on the load line.
        */
        if (_workLine.QtyWork == totalGroupedContainerQuantity)
        {
            WHSLicensePlate childLicensePlate;

            while select LicensePlateId from childLicensePlate
                where childLicensePlate.LicensePlateParent == _containerGroupingLicensePlateId
            {
                WHSContainerTable::updateContainerLocation(childLicensePlate.LicensePlateId, _workLine.WMSLocationId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReservedWorkLinesLocation</Name>
				<Source><![CDATA[
    private void updateReservedWorkLinesLocation(Enumerator _workLineEnumerator)
    {
        while (_workLineEnumerator.moveNext())
        {
            WHSWorkLine workLineCurrent = _workLineEnumerator.current() as WHSWorkLine;

            WHSWorkLine workLineUpdate;

            workLineUpdate.skipDataMethods(true);
            update_recordset workLineUpdate
                setting WMSLocationId = toLocationId
            where workLineUpdate.LineNum == workLineCurrent.LineNum
                && workLineUpdate.WorkId == workLineCurrent.WorkId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reCreateReservedWorkInventTrans</Name>
				<Source><![CDATA[
    private void reCreateReservedWorkInventTrans(Enumerator _workInventTransReservationEnumerator)
    {
        while (_workInventTransReservationEnumerator.moveNext())
        {
            WHSWorkInventTransReservation workInventTransReservation = _workInventTransReservationEnumerator.current() as WHSWorkInventTransReservation;

            InventDim inventDimTo = InventDim::find(workInventTransReservation.parmToInventDimId());
            InventDim inventDimFromSpecific = this.newInventDimWithToLocationAndToStatus(InventDim::find(workInventTransReservation.parmReservedInventDimId()), inventDimTo);
            
            WHSWorkLine workLine = WHSWorkLine::find(workInventTransReservation.parmWorkId(), workInventTransReservation.parmWorkLineNumber());

            InventDim inventDimFrom;
            
            if (workInventTransReservation.parmReservationFlexibleLevel())
            {
                inventDimFrom = this.initFlexInventDimFrom(inventDimFromSpecific, workInventTransReservation.parmItemId(), workInventTransReservation.parmReservationFlexibleLevel());
                inventDimFromSpecific = InventDim::findOrCreate(inventDimFrom);
            }
            else
            {
                inventDimFrom = inventDimFromSpecific.data();
                inventDimFrom.clearBelowLocationDim(workInventTransReservation.parmItemId());
            }

            if (workLine.whsWorkTable().isLicensePlateSpecificReservationRequired())
            {
                inventDimFrom.LicensePlateId = inventDimFromSpecific.LicensePlateId;
            }
            inventDimFrom = InventDim::findOrCreate(inventDimFrom);

            WHSWorkInventTrans workInventTrans = WHSWorkInventTrans::find(workInventTransReservation.parmWorkId(), workInventTransReservation.parmWorkLineNumber(), workInventTransReservation.parmItemId(), workInventTransReservation.parmInventTransIdParent(), inventDimFrom.inventDimId, true);

            if (workInventTrans.RecId)
            {
                workInventTrans.changeQuantitiesForSpecificDimensions(workInventTransReservation.parmReservedQuantity(), 0, inventDimFromSpecific, inventDimTo, true);

                WHSInventoryItemSetElement::addItemsFromSet(workInventTransReservation.parmItemSetId(), workInventTrans.ItemSetId);
            }
            else
            {
                workInventTrans.initFromWorkLine(workLine);
                workInventTrans.ItemId = workInventTransReservation.parmItemId();
                workInventTrans.InventTransIdParent = workInventTransReservation.parmInventTransIdParent();
                workInventTrans.WorkHasReservation = workInventTransReservation.parmWorkHasReservation();
                workInventTrans.ItemSetId = WHSInventoryItemSetElement::duplicateItemSet(workInventTransReservation.parmItemSetId());
                workInventTrans.createQuantitiesWithSpecificDimensions(workInventTransReservation.parmReservedQuantity(), 0, inventDimFrom, inventDimTo, inventDimFromSpecific, inventDimTo, true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reCreateOrderCommittedReservations</Name>
				<Source><![CDATA[
    private void reCreateOrderCommittedReservations(Enumerator _orderCommittedReservationEnumerator)
    {
        // Invent status for reserved quantities will be changed in the createAndExecuteSingleSKUQuarantine method, so the toInventStatusId is ignored here.
        while (_orderCommittedReservationEnumerator.moveNext())
        {
            WHSOrderCommittedTransReservation orderCommittedTransReservation = _orderCommittedReservationEnumerator.current() as WHSOrderCommittedTransReservation;
            InventDim                         inventDimFromSpecific = InventDim::find(orderCommittedTransReservation.parmReservedInventDimId()).data();

            inventDimFromSpecific.wmsLocationId = toLocationId;

            InventDim                         inventDimFrom = InventDim::findOrCreate(this.initFlexInventDimFrom(inventDimFromSpecific, orderCommittedTransReservation.parmItemId(), orderCommittedTransReservation.parmReservationFlexibleLevel()));

            WHSOrderCommittedReservationFacade::updateInventoryReservation(orderCommittedTransReservation.parmOrderCommittedReservationRecId(),  orderCommittedTransReservation.parmReservedQuantity(), inventDimFrom);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFlexInventDimFrom</Name>
				<Source><![CDATA[
    private InventDim initFlexInventDimFrom(
        InventDim                    _inventDim,
        ItemId                       _itemId,
        WHSReservationHierarchyLevel _level)
    {
        InventTable   inventTable = InventTable::find(_itemId);
        InventDimParm inventDimParmReservationFlexible = WHSReservationHierarchyInventDimUtil::initInventDimParmAboveAndIncludingLevel(inventTable, _level);
        InventDimParm inventDimParmForCopy = InventDimParm::andParms(inventDimParmReservationFlexible, WHSReservationHierarchyInventDimUtil::initInventDimParmBelowLocation(inventTable));
        InventDim     inventDimFrom = _inventDim.data();

        //Dimensions below the lowest flexible dimension are cleared
        inventDimFrom.clearNotSelectedDim(inventDimParmReservationFlexible);

        //Dimensions below location and above-or-equal the lowest flexible dimension are copied from the inventDim parameter (where existing reservations are stored)
        // do not override with empty values as in case of full LP movement, the inventDim may not have all the dimensions.
        inventDimFrom.initFromInventDimParmNonBlank(inventDim, inventDimParmForCopy);

        //If a location is not LP controlled, the LP dimension should be cleared; otherwise it should be filled from the toLicensePlateId parameter
        if (!WMSLocation::find(inventDimFrom.wMSLocationId, inventDimFrom.InventLocationId).whsLocationIsLPControlled())
        {
            inventDimFrom.LicensePlateId = '';
        }
        else if (toLicensePlateId && inventDimParmForCopy.LicensePlateFlag)
        {
            inventDimFrom.LicensePlateId = toLicensePlateId;
        }

        return inventDimFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventDimWithToLocationAndToStatus</Name>
				<Source><![CDATA[
    private InventDim newInventDimWithToLocationAndToStatus(InventDim _inventDimFrom, InventDim _inventDimTo)
    {
        InventDim inventDimTo = _inventDimFrom.data();

        inventDimTo.wmsLocationId = toLocationId;

        if (_inventDimTo.InventStatusId)
        {
            inventDimTo.inventStatusId = _inventDimTo.InventStatusId;
        }
        else if (toInventStatusId)
        {
            inventDimTo.inventStatusId = toInventStatusId;
        }

        inventDimTo = InventDim::findOrCreate(inventDimTo);

        return inventDimTo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkHeader</Name>
				<Source><![CDATA[
    protected WHSWorkTable createWorkHeader()
    {
        WHSWorkTable    workTable;

        workTable.setWorkId();
        workTable.WorkTransType             = WHSWorkTransType::Invent;
        workTable.InventSiteId              = inventDim.InventSiteId;
        workTable.InventLocationId          = inventDim.InventLocationId;
        workTable.TargetLicensePlateId      = fromLicensePlateId;

        if (executeWork)
        {
            workTable.WorkStatus                = WHSWorkStatus::Closed;
            workTable.WorkInProcessUTCDateTime  = DateTimeUtil::utcNow();
            workTable.WorkClosedUTCDateTime     = workTable.WorkInProcessUTCDateTime;
        }

        workTable.insert();

        return workTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkInventTrans</Name>
				<Source><![CDATA[
    private WHSWorkInventTrans createWorkInventTrans(
        WHSWorkLine     _workLine,
        InventDim       _fromInventDim,
        InventDim       _toInventDim,
        WHSTransWeight  _weightToMove)
    {
        WHSWorkInventTrans  workInventTrans;

        workInventTrans.initFromWorkLine(_workLine);
        workInventTrans.setInitialQuantityAndWeightValues(_workLine.InventQtyWork, _weightToMove);

        workInventTrans.InventDimIdFrom = _fromInventDim.InventDimId;
        workInventTrans.InventDimIdTo   = _toInventDim.InventDimId;
        workInventTrans.insert();

        return workInventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>singleItemInventQuantityBeingMoved</Name>
				<Source><![CDATA[
    private InventHandlingQty singleItemInventQuantityBeingMoved()
    {
        return WHSCatchWeightHelper::convertInventQuantity(itemId, unitId, qty, inventDim.inventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkLine</Name>
				<Source><![CDATA[
    private WHSWorkLine createWorkLine(
        WHSWorkId        _workId,
        WHSWorkType      _workType,
        WMSLocationId    _locationId,
        InventDim        _workLineInventDim)
    {
        WHSWorkLine     workLine;
        InventDim       workLineInventDim = _workLineInventDim.data();
        if (itemId)
        {
            workLineInventDim.clearLocationAndBelowDim(itemId);
            workLineInventDim = inventDim::findOrCreate(workLineInventDim);
        }

        workLine.WorkId                 = _workId;
        workLine.LineNum                = lastWorkLineNum;
        lastWorkLineNum++;
        workLine.WorkType               = _workType;
        workLine.wmsLocationId          = _locationId;
        workLine.ItemId                 = itemId;
        workLine.InventDimId            = workLineInventDim.inventDimId;
        workLine.QtyRemain              = qty;
        workLine.QtyWork                = qty;
        workLine.UnitId                 = unitId;
        workLine.InventQtyRemain        = WHSCatchWeightHelper::convertInventQuantity(itemId, unitId, qty, workLineInventDim.inventDimId);
        workLine.InventQtyWork          = workLine.InventQtyRemain;
        workLine.WorkClassId            = workClassId;
        if (executeWork)
        {
            workLine.WorkStatus                 = WHSWorkStatus::Closed;
            workLine.UserId                     = userId;
            workLine.WorkInProcessUTCDateTime   = DateTimeUtil::utcNow();
            workLine.WorkClosedUTCDateTime      = workLine.WorkInProcessUTCDateTime;
        }
        workLine.insert();

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkTrans</Name>
				<Source><![CDATA[
    private void createWorkTrans(
        WHSWorkLine        _workLine,
        InventDimId        _inventDimId,
        WHSLicensePlateId  _licensePlateId)
    {
        WHSWorkTrans    workTrans;

        if (executeWork)
        {
            workTrans.setWorkTransId();
            workTrans.InventDimId               = _inventDimId;
            workTrans.ItemId                    = itemId;
            workTrans.Qty                       = qty;
            workTrans.uom                       = unitId;
            workTrans.TransDateTime             = DateTimeUtil::utcNow();
            workTrans.WorkId                    = _workLine.WorkId;
            workTrans.LineNum                   = _workLine.LineNum;
            workTrans.UserId                    = userId;
            workTrans.TargetLicensePlateId      = _licensePlateId;
            workTrans.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        inventCostOnhandCache = InventCostOnhandCache::construct();
        lastWorkLineNum = 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to set global parameters for creating basic movement work.
    /// </summary>
    /// <param name="_userId">
    /// The warehouse RF user.
    /// </param>
    /// <param name="_itemId">
    /// The item being moved.
    /// </param>
    /// <param name="_qty">
    /// The qty being moved.
    /// </param>
    /// <param name="_unitId">
    /// The unit of measure of qty being moved.
    /// </param>
    /// <param name="_inventDim">
    /// Dimensions of inventory being moved.
    /// </param>
    /// <param name="_fromLicensePlateId">
    /// The license plate we are moving from.
    /// </param>
    /// <param name="_fromLocationId">
    /// The location we are moving from.
    /// </param>
    /// <param name="_toLocationId">
    /// The location we are moving to.
    /// </param>
    /// <param name="_toLicensePlateId">
    /// The license plate we are moving to. May match the from license plate.
    /// </param>
    /// <param name="_fromInventStatusId">
    /// The inventory status we are moving from.
    /// </param>
    /// <param name="_toInventStatusId">
    /// The inventory status we are moving to. May match the from status.
    /// </param>
    /// <param name="_reverseWork">
    /// Boolean determining if the movement is occuring because of reverse sales work.
    /// </param>
    /// <param name="_executeWork">
    /// Boolean determining if the work should be automatically executed.
    /// </param>
    /// <param name="_workClassId">
    /// The work class Id to be assigned to the movement work.
    /// </param>
    public void setParameters(
        WHSUserId           _userId,
        ItemId              _itemId,
        Qty                 _qty,
        WHSUOM              _unitId,
        InventDim           _inventDim,
        WHSLicensePlateId   _fromLicensePlateId,
        WMSLocationId       _fromLocationId,
        WMSLocationId       _toLocationId = '',
        WHSLicensePlateId   _toLicensePlateId = '',
        WHSInventStatusId   _fromInventStatusId = '',
        WHSInventStatusId   _toInventStatusId = '',
        boolean             _reverseWork = false,
        boolean             _executeWork = true,
        WHSWorkClassId      _workClassId = '')
    {
        userId              = _userId;
        itemId              = _itemId;
        qty                 = _qty;
        unitId              = _unitId;
        inventDim           = _inventDim;
        fromLicensePlateId  = _fromLicensePlateId;
        fromLocationId      = _fromLocationId;
        toLicensePlateId    = _toLicensePlateId;
        toLocationId        = _toLocationId;
        fromInventStatusId  = _fromInventStatusId;
        toInventStatusId    = _toInventStatusId;
        reverseWork         = _reverseWork;
        executeWork         = _executeWork;
        workClassId         = _workClassId;

        isMovingWholeLP     = !itemId && fromLicensePlateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLPisTargetLP</Name>
				<Source><![CDATA[
    private void checkLPisTargetLP(WHSLicensePlateId _licensePlateId)
    {
        if (_licensePlateId)
        {
            WHSWorkTable workTable = WHSWorkTable::findByLicensePlate(_licensePlateId);

            if (workTable)
            {
                // Removing inventory from tote LP with open packing work is allowed
                if (workTable.WorkTransType == WHSWorkTransType::Packing)
                {
                    return;
                }

                if (!this.isReservationRemovalAllowed())
                {
                    throw error("@WAX:CannotMoveTargetLPForWork");
                }

                // Fail if we are not moving the entirety of the single item LP
                if (!WHSDockInventoryManagementFeature::instance().isEnabled()
                    && !this.isMovingEntireSingleItemLP(_licensePlateId))
                {
                    throw error(strFmt("@WAX:CannotMoveSingleSKUWhenLPisTargetLP", _licensePlateId, workTable));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateGroupedContainerWithActiveWork</Name>
				<Source><![CDATA[
    private void validateGroupedContainerWithActiveWork(WHSLicensePlateId _licensePlateId)
    {
        WHSContainerTable containerTable;

        select firstonly ContainerGroupingLicensePlateId from containerTable
            where containerTable.ContainerId == _licensePlateId;

        if (containerTable.ContainerGroupingLicensePlateId)
        {
            WHSWorkTable workTable = WHSWorkTable::findByLicensePlate(containerTable.ContainerGroupingLicensePlateId);

            if (workTable)
            {
                throw error(strFmt("@WAX:CantMoveContainerThatIsPartOfContainerGroupWithIncompleteWork", _licensePlateId));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMovingEntireSingleItemLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return true if
    ///     - the license plate only contains one item (taking into consideration that variants would be treated as different items)
    ///     - the quantity being moved equals the total quantity on the License plate.
    /// </summary>
    /// <param name = "_licensePlateId">Id of the license plate being moved.</param>
    /// <returns>true, if moving the entire license plate; otherwise, false.</returns>
    private boolean isMovingEntireSingleItemLP(WHSLicensePlateId _licensePlateId)
    {
        InventHandlingQty getInventQtyToMove()
        {
            return this.singleItemInventQuantityBeingMoved();
        }

        if (_licensePlateId
            && !WHSLicensePlate::isLPMultiDimension(_licensePlateId)
            && getInventQtyToMove() == WHSLicensePlate::getTotalHandlingQtyOnLicensePlate(_licensePlateId))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    private void validate()
    {
        boolean isLPChanging = (fromLicensePlateId != toLicensePlateId);

        if (isLPChanging)
        {
            this.checkWorkLinesWithLocatedLP();
        }

        if (isMovingWholeLP)
        {
            if ((fromLicensePlateId && WHSWorkTable::findByTargetLicensePlate(fromLicensePlateId))
                || (toLicensePlateId && WHSWorkTable::findByTargetLicensePlate(toLicensePlateId)))
            {
                WHSStageWorkMovement::validateLicensePlatesAndAssociatedWork(fromLicensePlateId,
                                                                             toLicensePlateId,
                                                                             fromLocationId,
                                                                             toLocationId,
                                                                             inventDim.InventLocationId,
                                                                             containerId,
                                                                             userId,
                                                                             executeWork);
            }

            if (!WHSLicensePlate::allowMixedItemLP(fromLicensePlateId, toLocationId, inventDim.InventLocationId))
            {
                throw error(strFmt("@WAX2239", toLocationId));
            }

            if (!WHSLicensePlate::allowMixedBatchLP(fromLicensePlateId, toLocationId, inventDim.InventLocationId))
            {
                throw error(strFmt("@WAX1678", toLocationId));
            }

            if (!WHSLicensePlate::allowMixedStatusLP(fromLicensePlateId, toLocationId, inventDim.InventLocationId))
            {
                throw error(strFmt("@WAX3389", toLocationId));
            }

            if (WHSContainerTable::isLicensePlateIdAssociatedToContainer(toLicensePlateId)
                && !this.toLocation().whsLocationIsLPControlled())
            {
                if (InventDim::find(WHSContainerTable::findByContainerId(toLicensePlateId).InventDimId).InventLocationId == inventDim.InventLocationId)
                {
                    throw error("@WAX:CannotMoveContainerToNonLPControlledLocationSameWarehouse");
                }
            }
        }
        else
        {
            this.checkLPisTargetLP(fromLicensePlateId);
            if (isLPChanging) // perf optimization: no need to do it again for the same LP
            {
                if (fromLicensePlateId
                    && WHSWorkTable::findByLicensePlate(fromLicensePlateId)
                    && PdsGlobal::pdsIsCWItem(itemId))
                {
                    throw error("@WAX:Error_WHSConsolidateWorkFeatureDoesNotSupportCW");
                }

                this.checkLPisTargetLP(toLicensePlateId);
            }

            this.validateGroupedContainerWithActiveWork(fromLicensePlateId);

            if (!WHSInvent::allowMixedItem(itemId, toLocationId, inventDim.InventLocationId))
            {
                throw error(strFmt("@WAX2239", toLocationId));
            }

            if (itemId && !WHSInvent::allowMixedBatch(itemId, inventDim.InventBatchId, inventDim.InventLocationId, toLocationId))
            {
                throw error(strFmt("@WAX1678", toLocationId));
            }

            if (!WHSInvent::allowMixedStatus(toInventStatusId, inventDim.InventLocationId, toLocationId))
            {
                throw error("@WAX3389");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateMovementWithWorkReservations</Name>
				<Source><![CDATA[
    private void validateMovementWithWorkReservations(
        WHSWorkInventTransReservationCollectionBuilder _workInventTransReservationCollectionBuilder,
        WHSWorkLine _workLineFrom)
    {
        if (_workInventTransReservationCollectionBuilder.getWorkInventTransEnumerator().moveNext())
        {
            if (this.isInventoryStatusBeingChanged())
            {
                throw error("@WAX:CannotMoveInventoryStatusChangeReservationImpact");
            }

            if (this.fromLocation().whsLocationIsUserLocation())
            {
                throw error(strFmt("@WAX:CannotMoveInventoryReservedFromToUserLocation", fromLocationId));
            }

            if (this.toLocation().whsLocationIsUserLocation())
            {
                throw error(strFmt("@WAX:CannotMoveInventoryReservedFromToUserLocation", toLocationId));
            }
        }

        Enumerator workLineEnumerator = _workInventTransReservationCollectionBuilder.getWorkLineEnumerator();

        while (workLineEnumerator.moveNext())
        {
            WHSWorkLine _workLineWithReservation = workLineEnumerator.current() as WHSWorkLine;
            if (_workLineWithReservation.WorkStatus != WHSWorkStatus::Open)
            {
                throw error("@WAX:CannotMoveGoodsWithInProgressWorkLine");
            }
            if (_workLineWithReservation.ReplenDemand == NoYes::Yes)
            {
                throw error("@WAX:CannotMoveGoodsWithWorkLineThatNeedsReplen");
            }

        }

        // Extra validation specific to the associated work being present.
        if (!WHSDockManagement::validateDockMgmtMixing(this.toLocation(), _workLineFrom))
        {
            throw error("@WAX:CannotMoveItemDockMgmtRuleFailure");
        }

        if (!skipAnchoringValidation)
        {
            this.validateAnchoring(_workInventTransReservationCollectionBuilder.getWorkLineEnumerator());
        }

        if (   WHSMoveFlexReservBlockChangeStatusV2Flight::instance().isEnabled()
            && _workInventTransReservationCollectionBuilder.getOrderCommittedReservationEnumerator().moveNext())
        {
            if (this.isInventoryStatusBeingChanged())
            {
                throw error("@WAX:CannotMoveInventoryStatusChangeReservationImpact");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAnchoring</Name>
				<Source><![CDATA[
    /// <summary>
    /// Warn the work user using this API that he's broken the anchoring for one or more of the associated work lines.
    /// </summary>
    /// <param name = "_workLineEnumerator">Enumerator over work lines with reservation behind.</param>
    /// <returns>True, if the validation succeeded; otherwise, false.</returns>
    public boolean validateAnchoring(Enumerator _workLineEnumerator)
    {
        boolean ret = true;

        while (_workLineEnumerator.moveNext())
        {
            WHSWorkLine workLineCurrent = _workLineEnumerator.current() as WHSWorkLine;

            if (workLineCurrent.IsAnchored)
            {
                WHSWorkLine workLineAnchored;

                // If the current work line is anchored, find another anchored work line on same Load/Shipment
                // that is at the same location and still waits to be processed.
                // The query is split in 2, to give SQL an opportunity of selecting a good index (LoadId and ShipmentId based, accordingly)
                select firstonly RecId from workLineAnchored
                        where workLineAnchored.LoadId == workLineCurrent.LoadId
                            && workLineAnchored.RecId != workLineCurrent.RecId
                            && workLineAnchored.IsAnchored == NoYes::Yes
                            && workLineAnchored.WMSLocationId == workLineCurrent.WMSLocationId
                            && workLineAnchored.WorkStatus != WHSWorkStatus::Closed
                            && workLineAnchored.WorkStatus != WHSWorkStatus::Cancelled;

                if (workLineAnchored)
                {
                    // Keep looping, so we show the warnings with all the WorkIds impacted
                    ret = checkFailed(strFmt("@WAX:MoveInventoryWithWork_AnchoredWorkExists", workLineCurrent.WorkId));
                }
                else
                {
                    select firstonly WorkId from workLineAnchored
                    where workLineAnchored.ShipmentId == workLineCurrent.ShipmentId
                        && workLineAnchored.RecId != workLineCurrent.RecId
                        && workLineAnchored.IsAnchored == NoYes::Yes
                        && workLineAnchored.WMSLocationId == workLineCurrent.WMSLocationId
                        && workLineAnchored.WorkStatus != WHSWorkStatus::Closed
                        && workLineAnchored.WorkStatus != WHSWorkStatus::Cancelled;

                    if (workLineAnchored)
                    {
                        // Keep looping, so we show the warnings with all the WorkIds impacted
                        ret = checkFailed(strFmt("@WAX:MoveInventoryWithWork_AnchoredWorkExists", workLineCurrent.WorkId));
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBasicMovementWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates basic movement work between two locations.
    /// </summary>
    /// <param name="_userId">
    /// Work user id.
    /// </param>
    /// <param name="_itemId">
    /// Item id to be moved between locations.
    /// </param>
    /// <param name="_qty">
    /// Quantity of the item.
    /// </param>
    /// <param name="_unitId">
    /// UOM of the item.
    /// </param>
    /// <param name="_inventDim">
    /// Dimensions of the item.
    /// </param>
    /// <param name="_fromLicensePlateId">
    /// License plate id of the item that is subject to be moved.
    /// </param>
    /// <param name="_fromLocationId">
    /// Initial location of the item that is subject to be moved.
    /// </param>
    /// <param name="_toLocationId">
    /// Final location of the item that is subject to be moved.
    /// </param>
    /// <param name="_toLicensePlateId">
    /// Final license plate of the item that is subject to be moved.
    /// </param>
    /// <param name="_fromInventStatusId">
    /// Initial status of the item that is subject to be moved.
    /// </param>
    /// <param name="_toInventStatusId">
    /// Final status of the item that is subject to be moved.
    /// </param>
    /// <param name="_reverseWork">
    /// Determines whether work should be reversed or not.
    /// </param>
    /// <param name="_executeWork">
    /// Determines whether work should be executed or not.
    /// </param>
    /// <param name="_workClassId">
    /// Work class id.
    /// </param>
    /// <returns>
    /// Work id of the work created.
    /// </returns>
    public static WHSWorkId createBasicMovementWork(
        WHSUserId           _userId,
        ItemId              _itemId,
        Qty                 _qty,
        WHSUOM              _unitId,
        InventDim           _inventDim,
        WHSLicensePlateId   _fromLicensePlateId,
        WMSLocationId       _fromLocationId,
        WMSLocationId       _toLocationId = '',
        WHSLicensePlateId   _toLicensePlateId = '',
        WHSInventStatusId   _fromInventStatusId = '',
        WHSInventStatusId   _toInventStatusId = '',
        boolean             _reverseWork = false,
        boolean             _executeWork = true,
        WHSWorkClassId      _workClassId = '')
    {
        WHSWorkCreateMovementBasic  workCreateMovementBasic;
        WHSWorkId                   workId;

        ttsbegin;

        workCreateMovementBasic = WHSWorkCreateMovementBasic::newFromParms(_userId,
                                                                           _itemId,
                                                                           _qty,
                                                                           _unitId,
                                                                           _inventDim,
                                                                           _fromLicensePlateId,
                                                                           _fromLocationId,
                                                                           _toLocationId,
                                                                           _toLicensePlateId,
                                                                           _fromInventStatusId,
                                                                           _toInventStatusId,
                                                                           _reverseWork,
                                                                           _executeWork,
                                                                           _workClassId);

        workId = workCreateMovementBasic.createWork();

        ttscommit;

        return workId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromParms</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method which creates new instance of basic movement creation class using parameters.
    /// </summary>
    /// <param name="_userId">
    /// The warehouse RF user.
    /// </param>
    /// <param name="_itemId">
    /// The item being moved.
    /// </param>
    /// <param name="_qty">
    /// The qty being moved.
    /// </param>
    /// <param name="_unitId">
    /// The unit of measure of qty being moved.
    /// </param>
    /// <param name="_inventDim">
    /// Dimensions of inventory being moved.
    /// </param>
    /// <param name="_fromLicensePlateId">
    /// The license plate we are moving from.
    /// </param>
    /// <param name="_fromLocationId">
    /// The location we are moving from.
    /// </param>
    /// <param name="_toLocationId">
    /// The location we are moving to.
    /// </param>
    /// <param name="_toLicensePlateId">
    /// The license plate we are moving to. May match the from license plate.
    /// </param>
    /// <param name="_fromInventStatusId">
    /// The inventory status we are moving from.
    /// </param>
    /// <param name="_toInventStatusId">
    /// The inventory status we are moving to. May match the from status.
    /// </param>
    /// <param name="_reverseWork">
    /// Boolean determining if the movement is occuring because of reverse sales work.
    /// </param>
    /// <param name="_executeWork">
    /// Boolean determining if the work should be automatically executed.
    /// </param>
    /// <param name="_workClassId">
    /// The work class Id to be assigned to the movement work.
    /// </param>
    /// <returns>
    /// An instance of the basic movement creation class.
    /// </returns>
    public static WHSWorkCreateMovementBasic newFromParms(
        WHSUserId           _userId,
        ItemId              _itemId,
        Qty                 _qty,
        WHSUOM              _unitId,
        InventDim           _inventDim,
        WHSLicensePlateId   _fromLicensePlateId,
        WMSLocationId       _fromLocationId,
        WMSLocationId       _toLocationId = '',
        WHSLicensePlateId   _toLicensePlateId = '',
        WHSInventStatusId   _fromInventStatusId = '',
        WHSInventStatusId   _toInventStatusId = '',
        boolean             _reverseWork = false,
        boolean             _executeWork = true,
        WHSWorkClassId      _workClassId = '')
    {
        WHSWorkCreateMovementBasic  workCreateMovementBasic;

        workCreateMovementBasic = new WHSWorkCreateMovementBasic();

        workCreateMovementBasic.setParameters(_userId,
                                              _itemId,
                                              _qty,
                                              _unitId,
                                              _inventDim,
                                              _fromLicensePlateId,
                                              _fromLocationId,
                                              _toLocationId,
                                              _toLicensePlateId,
                                              _fromInventStatusId,
                                              _toInventStatusId,
                                              _reverseWork,
                                              _executeWork,
                                              _workClassId);

        return workCreateMovementBasic;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of basic movement creation class based on container.
    /// </summary>
    /// <param name="_userId">
    /// The warehouse RF user.
    /// </param>
    /// <param name="_inventDim">
    /// Dimensions of inventory being moved.
    /// </param>
    /// <param name="_fromLocationId">
    /// A location where inventory is moved from.
    /// </param>
    /// <param name="_fromLicensePlateId">
    /// A license plate where inventory is moved from.
    /// </param>
    /// <param name="_toLocationId">
    /// A location where inventory is moved to.
    /// </param>
    /// <param name="_toLicensePlateId">
    /// A license plate where inventory is moved to. The license plate can be the same as the from license plate.
    /// </param>
    /// <param name="_containerId">
    /// A container ID specifying the inventory to move.
    /// </param>
    /// <returns>
    /// An instance of the basic movement creation class.
    /// </returns>
    public static WHSWorkCreateMovementBasic newFromContainer(
        WHSUserId           _userId,
        InventDim           _inventDim,
        WMSLocationId       _fromLocationId,
        WHSLicensePlateId   _fromLicensePlateId,
        WMSLocationId       _toLocationId,
        WHSLicensePlateId   _toLicensePlateId,
        WHSContainerId      _containerId)
    {
        WHSWorkCreateMovementBasic workCreateMovementBasic = new WHSWorkCreateMovementBasic();

        workCreateMovementBasic.setParameters(_userId,
                                              '',
                                              0,
                                              '',
                                              _inventDim,
                                              _fromLicensePlateId,
                                              _fromLocationId,
                                              _toLocationId,
                                              _toLicensePlateId);

        workCreateMovementBasic.parmContainerId(_containerId);

        return workCreateMovementBasic;
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Closes the ledger after the work lines have been created.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> record to close
    /// </param>
    /// <remarks>
    /// This call should be made once all the work transactions have been made.
    /// </remarks>
    protected void closeLedgerVoucher(LedgerVoucher _ledgerVoucher)
    {
        if (_ledgerVoucher)
        {
            _ledgerVoucher.end();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>executePutWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the put work line.
    /// </summary>
    /// <param name = "_ledgerVoucher"> The ledger voucher against which the transactions should be posted</param>
    /// <param name = "_workLine">The work line against which the transactions should be posted</param>
    /// <param name = "_fromInventDim">Initial inventory dimensions</param>
    /// <param name = "_toInventDim">Target inventory dimensions</param>
    /// <param name = "_toInventDimWIT">Inventory dimensions of the work inventory transactions</param>
    protected void executePutWorkLine(
        LedgerVoucher       _ledgerVoucher,
        WHSWorkLine         _workLine,
        InventDim           _fromInventDim,
        InventDim           _toInventDim,
        InventDim           _toInventDimWIT)
    {
        InventHandlingQty       tmpQty;
        WHSWorkInventTrans      loopWorkInventTrans;

        if (!isMovingWholeLP)
        {
            this.createAndProcessSingleSKUPutWIT(_workLine, _fromInventDim, _toInventDim, _toInventDimWIT, _ledgerVoucher, 0);
        }
        else
        {
            tmpQty = 0;

            while select loopWorkInventTrans
                where loopWorkInventTrans.WorkId    == _workLine.WorkId
                      && loopWorkInventTrans.LineNum   == 1
            {
                tmpQty += this.createAndProcessMultiSKUPutWIT(loopWorkInventTrans.InventDimIdFrom, loopWorkInventTrans, _workLine, _toInventDim, _toInventDimWIT, _ledgerVoucher);
            }

            // Update the Qty on the Work Line
            _workLine.QtyWork = tmpQty;
            _workLine.InventQtyWork = tmpQty;
            _workLine.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize a ledger voucher against which the work transactions shall be posted
    /// </summary>
    /// <param name="_workId">
    /// The id of the <c>WHSWorkTable</c> for which transactions are going to be made
    /// </param>
    /// <returns>
    /// The <c>LedgerVoucher</c> record initialized
    /// </returns>
    /// <remarks>
    /// This call should be made once before starting any transactions.
    /// </remarks>
    protected LedgerVoucher initLedgerVoucher(WHSWorkId _workId)
    {
        LedgerVoucher       ret;

        if (executeWork)
        {
            ret = WHSInvent::beginLedger(_workId);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeDimsBelowLocation</Name>
				<Source><![CDATA[
    private InventDim removeDimsBelowLocation(InventDimId _toInventDimId)
    {
        InventDim   ret      = InventDim::find(_toInventDimId);
        if (itemId)
        {
            ret.clearBelowLocationDim(itemId);
            ret = InventDim::findOrCreate(ret);
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildContainerLineInventoryOnHandQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for container line with related inventory on-hand and dimensions,
    /// to be used for work inventory transactions.
    /// </summary>
    /// <param name = "_containerId">The container Id.</param>
    /// <param name = "_containerLine">The container line record.</param>
    /// <param name = "_loopInventSum">The on-hand inventory record.</param>
    /// <param name = "_loopInventDim">The inventory dimension record.</param>
    /// <returns>The query object to be executed.</returns>
    protected SysDaQueryObject buildContainerLineInventoryOnHandQuery(
        WHSContainerId      _containerId,
        WHSContainerLine    _containerLine,
        InventSum           _loopInventSum,
        InventDim           _loopInventDim)
    {
        InventDim           containerDim;
        InventDimParm       inventDimParm;

        SysDaQueryObject containerLineQueryObject = new SysDaQueryObject(_containerLine);
        containerLineQueryObject.projection().add(fieldStr(WHSContainerLine, ItemId));
        containerLineQueryObject.projection().add(fieldStr(WHSContainerLine, InventDimId));
        containerLineQueryObject.projection().add(fieldStr(WHSContainerLine, Qty));
        containerLineQueryObject.projection().add(fieldStr(WHSContainerLine, UnitId));
        containerLineQueryObject.projection().add(fieldStr(WHSContainerLine, CapturedWeight));
        containerLineQueryObject.whereClause(
            new SysDaEqualsExpression(
                new SysDaFieldExpression(_containerLine, fieldStr(WHSContainerLine, ContainerId)),
                new SysDaValueExpression(_containerId)));

        SysDaQueryObject containerDimQueryObject = new SysDaQueryObject(containerDim);
        containerDimQueryObject.whereClause(
            new SysDaEqualsExpression(
                new SysDaFieldExpression(containerDim, fieldStr(InventDim, InventDimId)),
                new SysDaFieldExpression(_containerLine, fieldStr(WHSContainerLine, InventDimId))));
        containerLineQueryObject.joinClause(SysDaJoinKind::InnerJoin, containerDimQueryObject);

        SysDaQueryObject loopInventSumQueryObject = new SysDaQueryObject(_loopInventSum);
        loopInventSumQueryObject.projection().add(fieldStr(InventSum, ItemId));
        loopInventSumQueryObject.projection().add(fieldStr(InventSum, InventDimId));
        loopInventSumQueryObject.whereClause(
                 new SysDaEqualsExpression(
                    new SysDaFieldExpression(_loopInventSum, fieldStr(InventSum, ItemId)),
                    new SysDaFieldExpression(_containerLine, fieldStr(WHSContainerLine, ItemId)))
            .and(new SysDaEqualsExpression(
                    new SysDaFieldExpression(_loopInventSum, fieldStr(InventSum, ClosedQty)),
                    new SysDaValueExpression(NoYes::No)))
            .and(new SysDaGreaterThanExpression(
                    new SysDaFieldExpression(_loopInventSum, fieldStr(InventSum, PhysicalInvent)),
                    new SysDaValueExpression(0))));
        containerDimQueryObject.joinClause(SysDaJoinKind::InnerJoin, loopInventSumQueryObject);

        SysDaQueryObject loopInventDimQueryObject = new SysDaQueryObject(_loopInventDim);
        loopInventDimQueryObject.whereClause(
            new SysDaEqualsExpression(
                    new SysDaFieldExpression(_loopInventDim, fieldStr(InventDim, InventDimId)),
                    new SysDaFieldExpression(_loopInventSum, fieldStr(InventSum, InventDimId)))
            .and(new SysDaEqualsExpression(
                    new SysDaFieldExpression(_loopInventDim, fieldStr(InventDim, InventSiteId)),
                    new SysDaValueExpression(inventDim.InventSiteId)))
            .and(new SysDaEqualsExpression(
                    new SysDaFieldExpression(_loopInventDim, fieldStr(InventDim, InventLocationId)),
                    new SysDaValueExpression(inventDim.InventLocationId)))
            .and(new SysDaEqualsExpression(
                    new SysDaFieldExpression(_loopInventDim, fieldStr(InventDim, wMSLocationId)),
                    new SysDaValueExpression(fromLocationId)))
            .and(new SysDaEqualsExpression(
                    new SysDaFieldExpression(_loopInventDim, fieldStr(InventDim, LicensePlateId)),
                    new SysDaValueExpression(fromLicensePlateId))));
        
        loopInventSumQueryObject.joinClause(SysDaJoinKind::InnerJoin, loopInventDimQueryObject);

        return containerLineQueryObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createContainerMovement</Name>
				<Source><![CDATA[
    private void createContainerMovement(
        InventDim       _toInventDimWIT,
        WHSWorkLine     _workLine,
        WHSContainerId  _containerId)
    {
        WHSContainerLine    containerLine;
        InventSum           loopInventSum;
        InventDim           loopInventDim;

        ttsbegin;
        
        SysDaSearchObject searchObject = new SysDaSearchObject(
            this.buildContainerLineInventoryOnHandQuery(
                _containerId,
                containerLine,
                loopInventSum,
                loopInventDim));
        
        SysDaSearchStatement statement = new SysDaSearchStatement();
        
        // Move inventory tied to container.
        while (statement.next(searchObject))
        {
            InventHandlingQty inventHandlingQty = WHSCatchWeighthelper::convertInventQuantity(containerLine.ItemId, containerLine.UnitId, containerLine.Qty, containerLine.InventDimId);

            // Create the work transaction records for the pick work line.
            loopInventDim.wmsLocationId = _toInventDimWIT.wmsLocationId;
            InventDim loopToInventDim = InventDim::findOrCreate(loopInventDim);

            WHSWorkInventTrans  workInventTrans;

            workInventTrans.WorkId                  = _workLine.WorkId;
            workInventTrans.LineNum                 = _workLine.LineNum;
            workInventTrans.InventDimIdTo           = loopToInventDim.inventDimId;
            workInventTrans.InventTransIdParent     = NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num();
            workInventTrans.TransDateTime           = DateTimeUtil::utcNow();
            workInventTrans.ItemId                  = loopInventSum.ItemId;
            workInventTrans.Qty                     = inventHandlingQty;
            workInventTrans.TransactionWeight       = containerLine.CapturedWeight;
            workInventTrans.InventQtyRemain         = workInventTrans.Qty;
            workInventTrans.InventDimIdFrom         = loopInventSum.InventDimId;
            workInventTrans.insert();
    
            if (executeWork)
            {
                InventQty   inventQty;
                PdsCWQty    cwQty;
                if (!PdsGlobal::pdsIsCWItem(workInventTrans.ItemId))
                {
                    inventQty   = inventHandlingQty;
                    cwQty       = 0;
                }
                else
                {
                    inventQty   = containerLine.CapturedWeight;
                    cwQty       = inventHandlingQty;
                }

                WHSInvent::moveWorkQuantities(workInventTrans, workInventTrans.InventDimIdFrom, loopToInventDim.inventDimId, inventQty, cwQty);
            }
    
            qty += workInventTrans.Qty;
        }
    
        // Update the quantity on the work line.
        if (qty)
        {
            WHSWorkLine workLine = WHSWorkLine::findByRecId(_workLine.RecId, true);
            workLine.QtyWork = qty;
            workLine.InventQtyWork = qty;
            workLine.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBasicLicensePlateMovementWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a basic movement work between two locations for the specified license plate.
    /// The entire quantity on the license plate will be moved
    /// </summary>
    /// <param name="_userId">Work user id.</param>
    /// <param name="_licensePlateId">Id of the license plate subject to be moved.</param>
    /// <param name="_inventDim">Inventory dimensions, where items are being moved from.</param>
    /// <param name="_toLocationId">Final location of the item that is subject to be moved.</param>
    /// <param name="_reverseWork">Determines whether work should be reversed or not.</param>
    /// <param name="_executeWork">Determines whether work should be executed or not.</param>
    /// <param name="_workClassId">Work class id.</param>
    /// <returns>Work id of the inventory movement work created.</returns>
    /// <remarks>
    /// The <c>_inventDim</c> is expected to have the location and warehouse the goods are moved from, as well as any additional dimensions related to the work line
    /// </remarks>
    public static WHSWorkId createBasicLicensePlateMovementWork(
        WHSUserId           _userId,
        WHSLicensePlateId   _licensePlateId,
        InventDim           _inventDim,
        WMSLocationId       _toLocationId,
        boolean             _reverseWork = false,
        boolean             _executeWork = true,
        WHSWorkClassId      _workClassId = '')
    {
        return WHSWorkCreateMovementBasic::createBasicMovementWork(_userId, '', 0, '', _inventDim, _licensePlateId, _inventDim.wMSLocationId,
                                                                    _toLocationId, _licensePlateId, _inventDim.InventStatusId, _inventDim.InventStatusId,
                                                                    _reverseWork, _executeWork, _workClassId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBasicContainerMovementWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a basic movement work based on container inventory.
    /// </summary>
    /// <param name="_containerId">The container being moved</param>
    /// <param name="_userId">Work user id.</param>
    /// <param name="_inventDim">Inventory dimensions, where items are being moved from.</param>
    /// <param name="_fromLocationId">Location inventory is being moved from.</param>
    /// <param name="_fromLicensePlateId">The license plate inventory is being moved from.</param>
    /// <param name="_toLocationId">Location inventory is being moved to.</param>
    /// <param name="_toLicensePlateId">The license plate inventory is being moved to.</param>
    /// <returns>Work id of the inventory movement work created.</returns>
    [Hookable(false)]
    internal static WHSWorkId createBasicContainerMovementWork(
        WHSContainerId      _containerId,
        WHSUserId           _userId,
        InventDim           _inventDim,
        WMSLocationId       _fromLocationId,
        WHSLicensePlateId   _fromLicensePlateId,
        WMSLocationId       _toLocationId,
        WHSLicensePlateId   _toLicensePlateId)
    {
        WHSWorkCreateMovementBasic  workCreateMovementBasic;
        WHSWorkId                   workId;

        ttsbegin;

        workCreateMovementBasic = WHSWorkCreateMovementBasic::newFromContainer(_userId,
                                                                            _inventDim,
                                                                            _fromLocationId,
                                                                            _fromLicensePlateId,
                                                                            _toLocationId,
                                                                            _toLicensePlateId,
                                                                            _containerId);

        workId = workCreateMovementBasic.createWork();

        ttscommit;

        return workId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAndDecreaseStageWorkMovement</Name>
				<Source><![CDATA[
    private void findAndDecreaseStageWorkMovement()
    {
        if (this.mustExecuteWorkForStageWorkMovement() && WHSDockInventoryManagementFeature::instance().isEnabled())
        {
            InventDim tmpInventDim;
            buf2Buf(inventDim, tmpInventDim);

            tmpInventDim.InventStatusId = fromInventStatusId;
            tmpInventDim.wMSLocationId  = fromLocationId;
            tmpInventDim.LicensePlateId = fromLicensePlateId;
    
            // Decrement staged work
            WHSWorkTable stagedWorkTable = WHSWorkTable::findByLicensePlate(fromLicensePlateId);
            // If the work we are moving inventory from is staged work then we should use Advanced Warehousing logic.
            if (WHSWorkTable::isFirstPutCompleted(stagedWorkTable.WorkId))
            {
                if (containerId)
                {
                    stageWorkMovement = WHSStageWorkMovement::newFromContainerMovement(containerId, toLicensePlateId, tmpInventDim);
                }
                else
                {
                    InventHandlingQty inventQty = WHSCatchWeightHelper::convertInventQuantity(itemId, unitId, qty, InventDim::findOrCreate(inventDim).inventDimId);
                    stageWorkMovement = WHSStageWorkMovement::newFromInventoryMovement(itemId, inventQty, tmpInventDim, toLicensePlateId);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustExecuteWorkForStageWorkMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if find stage work movement should be executed.
    /// </summary>
    /// <returns>true if execute work is true; otherwise, false.</returns>
    protected boolean mustExecuteWorkForStageWorkMovement()
    {
        return executeWork;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>