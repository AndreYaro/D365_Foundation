<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxSalesTaxPaymentFacade_IN</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// This class helps generating tax sales and tax payment reports.
/// </summary>
class TaxSalesTaxPaymentFacade_IN
{
    TaxSalesTaxPaymentProfile_IN     profile;
    TaxReporthrchyStructureDesign_IN structureDesign;
    TaxSalesTaxPaymentHistory_IN     paymentHistory;
    TaxSalesTaxPaymentDoc_IN         taxPaymentDoc;
    boolean                          hasLedgerVoucherTrans;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calculateNodeBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate all nodes' balance
    /// </summary>
    public void calculateNodeBalance()
    {
        TaxReportHrchyNode_IN           rootNode;
        TaxReportHierarchyNode_IN       tableNode;
        int                             currentLevel;

        //Calculate history node balance
        this.calculateNodeSelfBalance();

        rootNode = TaxReportHierarchyHelper_IN::findRootNode(profile.parmSetOffHierarchyVersion().RecId);
        select maxOf(Level) from tableNode
            where tableNode.TaxReportHierarchyVersion_IN == rootNode.parmTaxReportHierarchyVersion()
            &&    tableNode.LeftId > rootNode.parmLeftId()
            &&    tableNode.RightId < rootNode.parmRightId()
            &&    tableNode.RightId - tableNode.LeftId == 1;

        //summarize the node balance for none leaf nodes
        for (currentLevel = tableNode.Level - 1; currentLevel >= 1; currentLevel --)
        {
            this.calculateNodeBalanceByLevel(currentLevel);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateNodeBalanceByLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the node's accumulcated balance on the specified level
    /// </summary>
    /// <param name="_level">
    /// The level
    /// </param>
    /// <exception cref="Exception::Error">
    /// Throw error if the node cannot be found
    /// </exception>
    private void calculateNodeBalanceByLevel(Level _level)
    {
        TaxReportHierarchyNode_IN               tableNode, childTableNode, childTableNodeTaxReg;
        TaxSalesTaxPaymentHistoryDetails_IN     historyDetail, childHistoryDetail, childHistoryDetailTaxReg;

        if (paymentHistory)
        {
            while select NodeId, TaxReportHierarchyVersion_IN, NodeType, RecId
                from tableNode
                where tableNode.TaxReportHierarchyVersion_IN == paymentHistory.TaxReportHierarchyVersion_IN
                &&  tableNode.Level == _level
                &&  tableNode.RightId - tableNode.LeftId > 1
            {
                select sum(AccumulatedPayAmountMST), sum(AccumulatedRecAmountMST) from childHistoryDetail
                        where childHistoryDetail.TaxSalesTaxPaymentHistory_IN == paymentHistory.RecId
                    join childTableNode
                        where childTableNode.RecId == childHistoryDetail.TaxReportHierarchyNode_IN
                        &&    childTableNode.ParentId == tableNode.NodeId
                        &&    childTableNode.TaxReportHierarchyVersion_IN == tableNode.TaxReportHierarchyVersion_IN;

                if (tableNode.NodeType != TaxReportHierarchyNodeType_IN::Root)
                {
                    select firstOnly TaxRegistrationNumbers_IN from childHistoryDetailTaxReg
                            where childHistoryDetailTaxReg.TaxSalesTaxPaymentHistory_IN == paymentHistory.RecId
                            &&    childHistoryDetailTaxReg.TaxRegistrationNumbers_IN == profile.parmTaxRegistrationNumber().RecId
                        join childTableNodeTaxReg
                            where childHistoryDetailTaxReg.TaxReportHierarchyNode_IN == childTableNodeTaxReg.RecId
                            &&    childTableNodeTaxReg.ParentId == tableNode.NodeId
                            &&    childTableNodeTaxReg.TaxReportHierarchyVersion_IN == tableNode.TaxReportHierarchyVersion_IN;

                    if (childHistoryDetailTaxReg.TaxRegistrationNumbers_IN == 0)
                    {
                        select firstOnly TaxRegistrationNumbers_IN from childHistoryDetailTaxReg
                                where childHistoryDetailTaxReg.TaxSalesTaxPaymentHistory_IN == paymentHistory.RecId
                                &&    childHistoryDetailTaxReg.TaxRegistrationNumbers_IN != 0
                                &&    childHistoryDetailTaxReg.TaxRegistrationNumbers_IN != profile.parmTaxRegistrationNumber().RecId
                            join childTableNodeTaxReg
                                where childHistoryDetailTaxReg.TaxReportHierarchyNode_IN == childTableNodeTaxReg.RecId
                                &&    childTableNodeTaxReg.ParentId == tableNode.NodeId
                                &&    childTableNodeTaxReg.TaxReportHierarchyVersion_IN == tableNode.TaxReportHierarchyVersion_IN;
                    }
                }

                historyDetail = TaxSalesTaxPaymentHistoryDetails_IN::findByHistoryAndNode(paymentHistory.RecId, tableNode.RecId, true);
                if (historyDetail.RecId)
                {
                    ttsBegin;

                    if (childHistoryDetailTaxReg.TaxRegistrationNumbers_IN != 0)
                    {
                        historyDetail.TaxRegistrationNumbers_IN = childHistoryDetailTaxReg.TaxRegistrationNumbers_IN;
                    }
                    historyDetail.AccumulatedRecAmountMST = historyDetail.RecoverableAmountToSettle + childHistoryDetail.AccumulatedRecAmountMST;
                    historyDetail.AccumulatedPayAmountMST = historyDetail.PayableAmountToSettle + childHistoryDetail.AccumulatedPayAmountMST;
                    historyDetail.update();

                    ttsCommit;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateNodeSelfBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate node self balance
    /// </summary>
    private void calculateNodeSelfBalance()
    {
        TaxSalesTaxPaymentHistoryDetails_IN         historyDetail, historyDetailTmp, historyDetailSumTmp;
        TaxSalesTaxPymHistoryDetailsTransView_IN    detailTransView;
        TaxSalesTaxPaymentTaxAdjSumView_IN          taxAdjustSumView;
        TaxTrans_IN                                 taxTransIN;
        RecId                                       paymentHistoryRecId = paymentHistory.RecId;

        //Update HistoryDetail balance
        update_recordSet historyDetail
                setting  SettledRecoverableAmountMST = 0,
                         SettledPayableAmountMST = 0,
                         RecoverableAmountMST = 0,
                         RecoverableAmountToSettle = 0,
                         AccumulatedRecAmountMST = 0,
                         PayableAmountMST = 0,
                         PayableAmountToSettle = 0,
                         AccumulatedPayAmountMST = 0,
                         RemainingRecAmtToSettle = 0,
                         RemainingPayAmtToSettle = 0,
                         Balance = 0
                   where historyDetail.TaxSalesTaxPaymentHistory_IN == paymentHistoryRecId;

        historyDetailTmp.setTmp();
        insert_recordset historyDetailTmp
            (RecoverableAmountMST, PayableAmountMST, RecoverableAmountToSettle, PayableAmountToSettle, TaxReportHierarchyNode_IN, TaxRegistrationNumbers_IN, TaxSalesTaxPaymentHistory_IN)
             select TotalRecoverableAmountMST, TotalPayableAmountMST, TotalRecoverableAmountToSettle, TotalPayableAmountToSettle from detailTransView
                where detailTransView.Mark == NoYes::Yes
             join TaxReportHierarchyNode_IN, TaxRegistrationNumbers_IN, TaxSalesTaxPaymentHistory_IN from historyDetail
             where historyDetail.RecId == detailTransView.TaxSalesTaxPaymentHistoryDetails_IN
                && historyDetail.TaxSalesTaxPaymentHistory_IN == paymentHistoryRecId;

        update_recordSet historyDetail
                setting  RecoverableAmountMST = historyDetailTmp.RecoverableAmountMST,
                         RecoverableAmountToSettle = historyDetailTmp.RecoverableAmountToSettle,
                         AccumulatedRecAmountMST = historyDetailTmp.RecoverableAmountToSettle,
                         PayableAmountMST = historyDetailTmp.PayableAmountMST,
                         PayableAmountToSettle = historyDetailTmp.PayableAmountToSettle,
                         AccumulatedPayAmountMST = historyDetailTmp.PayableAmountToSettle,
                         RemainingRecAmtToSettle = historyDetailTmp.RecoverableAmountToSettle,
                         RemainingPayAmtToSettle = historyDetailTmp.PayableAmountToSettle,
                         Balance = historyDetailTmp.RemainingRecAmtToSettle + historyDetailTmp.RemainingPayAmtToSettle
            join historyDetailTmp
                where historyDetailTmp.TaxReportHierarchyNode_IN == historyDetail.TaxReportHierarchyNode_IN
                   && historyDetailtmp.TaxRegistrationNumbers_IN == historyDetail.TaxRegistrationNumbers_IN
                   && historyDetailtmp.TaxSalesTaxPaymentHistory_IN == historyDetail.TaxSalesTaxPaymentHistory_IN;

        historyDetailSumTmp.setTmp();
        insert_recordset historyDetailSumTmp
            (TaxSalesTaxPaymentHistory_IN, PreSettledRecAmountMST, PreSettledPayAmountMST, TaxReportHierarchyNode_IN, TaxRegistrationNumbers_IN)
            select paymentHistoryRecId, sum(SumOfSettledRecoverableAmountMST), sum(SumOfSettledPayableAmountMST)
                from taxAdjustSumView
                join TaxReportHierarchyNode_IN, CompanyRegistrationNumber from taxTransIN
                    group by taxTransIN.TaxReportHierarchyNode_IN, taxTransIN.CompanyRegistrationNumber
                    where taxTransIN.RecId == taxAdjustSumView.TaxTrans_IN
                       && taxTransIN.TaxReportPeriod_IN == 0
                join historyDetail
                    where historyDetail.TaxReportHierarchyNode_IN == taxTransIN.TaxReportHierarchyNode_IN
                       && historyDetail.TaxRegistrationNumbers_IN == taxTransIN.CompanyRegistrationNumber
                       && historyDetail.TaxSalesTaxPaymentHistory_IN == paymentHistoryRecId;

        update_recordSet historyDetail
            setting  PreSettledRecAmountMST = historyDetailSumTmp.PreSettledRecAmountMST,
                     PreSettledPayAmountMST = historyDetailSumTmp.PreSettledPayAmountMST
            join historyDetailSumTmp
                where historyDetailSumTmp.TaxReportHierarchyNode_IN == historyDetail.TaxReportHierarchyNode_IN
                    && historyDetailSumTmp.TaxRegistrationNumbers_IN == historyDetail.TaxRegistrationNumbers_IN
                    && historyDetailSumTmp.TaxSalesTaxPaymentHistory_IN == paymentHistoryRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSetOffHistory</Name>
				<Source><![CDATA[
    private void createSetOffHistory(TaxSalesTaxPaymentHistoryDetails_IN _recHistoryDetail,
                                     TaxSalesTaxPaymentHistoryDetails_IN _payHistoryDetail,
                                     TaxAmount _setOffAmount)
    {
        TaxSalesTaxPaymentSetOffHistory_IN          setOffHistory, setOffHistoryInserted;
        TaxSalesTaxPaymentHistoryDetailsTrans_IN    recDetailTrans, payDetailTrans;
        TaxAmount                                   remainingAmount = _setOffAmount, settledAmount, transRemainingRecAmount;

        while select RecoverableAmountToSettle, TransDate, RecId from recDetailTrans
                order by recDetailTrans.TransDate asc
                where recDetailTrans.TaxSalesTaxPaymentHistoryDetails_IN == _recHistoryDetail.RecId &&
                      recDetailTrans.RecoverableAmountToSettle > 0 &&
                      recDetailTrans.Mark == NoYes::Yes
        {
            if (recDetailTrans.RecoverableAmountToSettle >= remainingAmount)
            {
                transRemainingRecAmount = remainingAmount;
            }
            else
            {
                transRemainingRecAmount = recDetailTrans.RecoverableAmountToSettle;
            }

            while select payDetailTrans
                order by payDetailTrans.TransDate asc
                where payDetailTrans.TaxSalesTaxPaymentHistoryDetails_IN == _payHistoryDetail.RecId &&
                      payDetailTrans.PayableAmountToSettle < 0 &&
                      payDetailTrans.Mark == NoYes::Yes
                notexists join setOffHistoryInserted
                    where setOffHistoryInserted.DetailTransToBeSettled == payDetailTrans.RecId &&
                          setOffHistoryInserted.RecoverableAmountMST == payDetailTrans.PayableAmountToSettle * -1
            {
                settledAmount = 0;

                //Recoverable amount > payable amount
                if (transRemainingRecAmount >= abs(payDetailTrans.PayableAmountToSettle))
                {
                    settledAmount = abs(payDetailTrans.PayableAmountToSettle);
                }
                else
                {
                    //Recoverable amount < payable amount
                    settledAmount = transRemainingRecAmount;
                }

                ttsbegin;

                setOffHistory.initValue();
                setOffHistory.DetailTransToSettle = recDetailTrans.RecId;
                setOffHistory.DetailTransToBeSettled = payDetailTrans.RecId;
                setOffHistory.RecoverableAmountMST = settledAmount;
                setOffHistory.insert();

                ttsCommit;

                transRemainingRecAmount -= settledAmount;
                if (transRemainingRecAmount == 0)
                {
                    break;
                }
            }

            remainingAmount -= recDetailTrans.RecoverableAmountToSettle;

            if (remainingAmount <= 0)
            {
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxSalesTaxPaymentHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create TaxSalesTaxPaymentHistory_IN record
    /// </summary>
    /// <returns>
    /// The newly created TaxSalesTaxPaymentHistory_IN
    /// </returns>
    private TaxSalesTaxPaymentHistory_IN createTaxSalesTaxPaymentHistory()
    {
        if (profile)
        {
            ttsBegin;

            paymentHistory.initValue();
            paymentHistory.TaxReportHierarchyVersion_IN = profile.parmSetOffHierarchyVersion().RecId;
            paymentHistory.TaxPeriod = profile.parmTaxPeriod();
            paymentHistory.FromDate = profile.taxPeriodFromDate();
            paymentHistory.ToDate = profile.taxPeriodToDate();
            paymentHistory.TaxRegistrationNumbers_IN = profile.parmTaxRegistrationNumber().RecId;
            paymentHistory.insert();

            ttsCommit;
        }
        return paymentHistory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxSalesTaxPaymentHistoryDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Init all payment history details that is associated with nodes
    /// </summary>
    public void initTaxSalesTaxPaymentHistoryDetails()
    {
        select firstOnly paymentHistory
            where paymentHistory.TaxReportHierarchyVersion_IN == profile.parmSetOffHierarchyVersion().RecId
            &&    paymentHistory.TaxPeriod == profile.parmTaxPeriod()
            &&    paymentHistory.FromDate == profile.taxPeriodFromDate()
            &&    paymentHistory.ToDate == profile.taxPeriodToDate()
            &&    paymentHistory.TaxRegistrationNumbers_IN == profile.parmTaxRegistrationNumber().RecId
            &&    paymentHistory.TaxReportVoucher == 0;

        if (!paymentHistory)
        {
            TaxSalesTaxPaymentFacade_IN::clearSalesTaxPaymentHistory();

            this.createTaxSalesTaxPaymentHistory();

            //Calculate all detail trans for its own balance
            structureDesign.calculateAllNodesSelfBalance(paymentHistory, profile);

            //Calculate balance for each history node
            this.calculateNodeBalance();

            this.processSalesTaxSetOffRules();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of <c>TaxSalesTaxPaymentFacade_IN</c>.
    /// </summary>
    /// <param name="_profile">
    /// The instance of <c>TaxSalesTaxPaymentProfile_IN</c>.
    /// </param>
    /// <param name="_structureDesign">
    /// The instance of <c>TaxReportHrchyStructureDesign_IN</c>.
    /// </param>
    protected void new(TaxSalesTaxPaymentProfile_IN     _profile,
                       TaxReportHrchyStructureDesign_IN _structureDesign)
    {
        profile = _profile;
        structureDesign = _structureDesign;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHasLedgerVoucherTrans</Name>
				<Source><![CDATA[
    public boolean parmHasLedgerVoucherTrans(boolean _hasLedgerVoucherTrans = hasLedgerVoucherTrans)
    {
        hasLedgerVoucherTrans = _hasLedgerVoucherTrans;
        return hasLedgerVoucherTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxReportHrchyStructureDesign</Name>
				<Source><![CDATA[
    public TaxReportHrchyStructureDesign_IN parmTaxReportHrchyStructureDesign()
    {
        return structureDesign;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxSalesTaxPaymentDoc</Name>
				<Source><![CDATA[
    public TaxSalesTaxPaymentDoc_IN parmTaxSalesTaxPaymentDoc(TaxSalesTaxPaymentDoc_IN _taxPaymentDoc = taxPaymentDoc)
    {
        taxPaymentDoc = _taxPaymentDoc;
        return taxPaymentDoc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxSalesTaxPaymentHistory</Name>
				<Source><![CDATA[
    public TaxSalesTaxPaymentHistory_IN parmTaxSalesTaxPaymentHistory(TaxSalesTaxPaymentHistory_IN _paymentHistory = paymentHistory)
    {
        paymentHistory = _paymentHistory;
        return paymentHistory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxSalesTaxPaymentProfile</Name>
				<Source><![CDATA[
    public TaxSalesTaxPaymentProfile_IN parmTaxSalesTaxPaymentProfile()
    {
        return profile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingExcisePLARegister</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert data objects of ExcisePLARegisterObject_IN into the table
    /// </summary>
    public void postingExcisePLARegister()
    {
        ExcisePLARegisterObject_IN    excisePLARegisterObject;
        ExcisePLARegister_IN          excisePLARegister;
        ListEnumerator                listEnum;
        Voucher                       voucher;

        if (taxPaymentDoc.parmExcisePLARegisterObjectList())
        {
            voucher = taxPaymentDoc.parmLedgerVoucher().lastVoucher();
            listEnum = taxPaymentDoc.parmExcisePLARegisterObjectList().getEnumerator();
            while (listEnum.moveNext())
            {
                excisePLARegisterObject = listEnum.current();
                excisePLARegister = excisePLARegisterObject.parmExcisePLARegister();

                if (!excisePLARegisterObject.parmIsInterimPLA())
                {
                    excisePLARegister.insert();
                    TaxTrans_IN::insertIntoTaxTransPLA(excisePLARegister,
                                                       null,
                                                       profile.parmTaxPeriod(),
                                                       excisePLARegister.PLALedgerDimension,
                                                       0,
                                                       profile.parmTransactionDate(),
                                                       profile.parmTaxRegistrationNumber().RecId,
                                                       voucher,
                                                       excisePLARegister.TaxComponentTable,
                                                       '');
                }
                else
                {
                    TaxTrans_IN::insertIntoTaxTransPLA(excisePLARegister,
                                                       null,
                                                       profile.parmTaxPeriod(),
                                                       0,
                                                       excisePLARegister.PLALedgerDimension,
                                                       profile.parmTransactionDate(),
                                                       profile.parmTaxRegistrationNumber().RecId,
                                                       voucher,
                                                       excisePLARegister.TaxComponentTable,
                                                       '');
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingExciseRG23ARegister</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert data object ExciseRG23ARegister_IN into the table
    /// </summary>
    private void postingExciseRG23ARegister()
    {
        ExciseRG23ARegister_IN  exciseRG23ARegister;
        ListEnumerator          listEnum;

        if (taxPaymentDoc.parmExciseRG23ARegisterList())
        {
            listEnum = taxPaymentDoc.parmExciseRG23ARegisterList().getEnumerator();
            while (listEnum.moveNext())
            {
                exciseRG23ARegister = listEnum.current();
                exciseRG23ARegister.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingExciseRG23CRegister</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert data objects ExciseRG23CRegister_IN into the table
    /// </summary>
    private void postingExciseRG23CRegister()
    {
        ExciseRG23CRegister_IN  exciseRG23CRegister;
        ListEnumerator          listEnum;

        if (taxPaymentDoc.parmExciseRG23CRegisterList())
        {
            listEnum = taxPaymentDoc.parmExciseRG23CRegisterList().getEnumerator();
            while (listEnum.moveNext())
            {
                exciseRG23CRegister = listEnum.current();
                exciseRG23CRegister.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTaxAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert data objects TaxSalesTaxPaymentTaxAdjustments_IN into the table
    /// </summary>
    private void postingTaxAdjustments()
    {
        TaxSalesTaxPaymentTaxAdjustments_IN         taxAdjustment, taxAdjustmentLoc;
        TaxSalesTaxPaymentHistoryDetailsTrans_IN    detailTrans;
        TaxSalesTaxPaymentHistoryDetails_IN         historyDetail;
        TaxSalesTaxPaymentSetOffHistory_IN          setoffHistory;
        ListEnumerator                              listEnum;

        if (taxPaymentDoc.parmTaxAdjustmentsList())
        {
            listEnum = taxPaymentDoc.parmTaxAdjustmentsList().getEnumerator();
            while (listEnum.moveNext())
            {
                taxAdjustment = listEnum.current();

                select forUpdate taxAdjustmentLoc
                    where taxAdjustmentLoc.TaxSalesTaxPaymentHistoryDetailsTrans_IN == taxAdjustment.TaxSalesTaxPaymentHistoryDetailsTrans_IN
                       && taxAdjustmentLoc.TaxTrans_IN == taxAdjustment.TaxTrans_IN;

                if (taxAdjustmentLoc.RecId)
                {
                    if (taxAdjustmentLoc.UtilizedRecoverableAmountMST != 0 && taxAdjustment.SettledRecoverableAmountMST != 0)
                    {
                        taxAdjustmentLoc.UtilizedRecoverableAmountMST = 0;
                    }
                    if (taxAdjustmentLoc.UtilizedPayableAmountMST != 0 && taxAdjustment.SettledPayableAmountMST != 0)
                    {
                        taxAdjustmentLoc.UtilizedPayableAmountMST = 0;
                    }
                    taxAdjustmentLoc.SettledRecoverableAmountMST += taxAdjustment.SettledRecoverableAmountMST;
                    taxAdjustmentLoc.SettledPayableAmountMST += taxAdjustment.SettledPayableAmountMST;
                    taxAdjustmentLoc.update();
                }
                else
                {
                    taxAdjustment.insert();
                }
            }
        }

        //Delete all adjustment records if the node is not for current tax registration number and the utilized amount is not used for settlement
        delete_from taxAdjustment
            exists join detailTrans
                where detailTrans.RecID == taxAdjustment.TaxSalesTaxPaymentHistoryDetailsTrans_IN
            exists join historyDetail
                where historyDetail.RecId == detailTrans.TaxSalesTaxPaymentHistoryDetails_IN &&
                      historyDetail.TaxRegistrationNumbers_IN != profile.parmTaxRegistrationNumber().RecId &&
                      historyDetail.TaxSalesTaxPaymentHistory_IN == paymentHistory.RecId
            notExists join setoffHistory
                where setoffHistory.DetailTransToBeSettled == taxAdjustment.TaxSalesTaxPaymentHistoryDetailsTrans_IN ||
                      setoffHistory.DetailTransToSettle == taxAdjustment.TaxSalesTaxPaymentHistoryDetailsTrans_IN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTaxSalesTaxPaymentDoc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert all data objects in the TaxSalesTaxPaymentHistory_IN into the tables accordingly
    /// </summary>
    public void postingTaxSalesTaxPaymentDoc()
    {
        TaxSalesTaxPaymentHistory_IN    history;

        if (taxPaymentDoc)
        {
            ttsBegin;

            //Posting taxAdjustment trans
            this.postingTaxAdjustments();

            //Posting ledger voucher
            this.postTaxTransAndTaxLedgerTrans();
            this.postVendVoucher();
            taxPaymentDoc.parmLedgerVoucher().end();

            //Posting TaxReportVoucher
            taxPaymentDoc.parmTaxReportVoucher().insert();
            if (taxPaymentDoc.parmTaxSalesTaxPaymentHistory().RecId)
            {
                select forUpdate history
                    where history.RecId == taxPaymentDoc.parmTaxSalesTaxPaymentHistory().RecId;

                history.TaxReportVoucher = taxPaymentDoc.parmTaxReportVoucher().RecId;
                history.update();
            }

            ttsCommit;

            ttsBegin;

            //If contains ExcisesRegister, then updateExciseRegister
            this.postingExciseRG23ARegister();
            this.postingExciseRG23CRegister();
            this.postingExcisePLARegister();

            ttsCommit;

            //Update TaxReportPeriod_IN field for TaxTrans_IN and TaxSalesTaxPaymentTaxAdjustment_IN
            this.updateTransWithTaxReportPeriod();

            //Sumup taxReportPeriod
            this.updateTaxReportPeriod();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxTransAndTaxLedgerTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert data objects TaxTrans_IN into the table
    /// </summary>
    private void postTaxTransAndTaxLedgerTrans()
    {
        ListEnumerator              taxTransListEnum;
        TaxTransObject_IN           taxTransObject;
        TaxTrans_IN                 taxTrans_IN;
        LedgerPostingController     ledgerPostingController;

        if (taxPaymentDoc.parmTaxTransList())
        {
            taxTransListEnum = taxPaymentDoc.parmTaxTransList().getEnumerator();

            while (taxTransListEnum.moveNext())
            {
                taxTransObject = taxTransListEnum.current();

                taxTransObject.parmTaxTrans().insertTaxReporting_IN(
                    taxPaymentDoc.parmTaxSalesTaxPaymentProfile().taxPeriodFromDate(),
                    taxTransObject.parmTaxTrans_IN().CompanyRegistrationNumber);

                if (taxTransObject.parmTaxTrans_IN().RefRecId == 0)
                {
                    taxTrans_IN = taxTransObject.parmTaxTrans_IN();
                    TaxTrans_IN.RefRecId = taxTransObject.parmTaxTrans().RecId;
                }
                taxTransObject.parmTaxTrans_IN(taxTrans_IN).insert();

                ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(taxPaymentDoc.parmLedgerVoucher());
                taxTransObject.parmledgerVoucherTransObject().addTaxTransRelationship(taxTransObject.parmTaxTrans().RecId, TaxTransRelationshipType::Tax);
                ledgerPostingController.addTrans(taxTransObject.parmledgerVoucherTransObject());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postVendVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert data objects VendVoucher into the table
    /// </summary>
    private void postVendVoucher()
    {
        ListEnumerator              vendVoucherListEnum;
        VendVoucher                 vendVoucher;
        vendTrans                   vendTrans;

        if (taxPaymentDoc.parmVendVoucherList())
        {
            vendVoucherListEnum = taxPaymentDoc.parmVendVoucherList().getEnumerator();

            while (vendVoucherListEnum.moveNext())
            {
                 vendVoucher = vendVoucherListEnum.current();
                 vendVoucher.post(taxPaymentDoc.parmLedgerVoucher(), vendTrans, NoYes::No, UnknownNoYes::Unknown);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSalesTaxSetOffRules</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process Set off rules for each hierarchy node
    /// </summary>
    public void processSalesTaxSetOffRules()
    {
        TaxReportHierarchyNode_IN                    tableNode;
        TaxReportHierarchySetOffRule_IN              setOffRule;
        TaxReportHierarchySetOffRuleDirection_IN     direction;
        TaxReportHierarchySetOffRuleDetails_IN       ruleDetails;
        TaxReportHrchyNodeCollectionDetails_IN       collectionDetails;
        TaxSalesTaxPaymentHistoryDetails_IN          paymentDetail;

        if (paymentHistory && profile.parmTaxRegistrationNumber())
        {
            while select setOffRule
                order by setOffRule.Priority asc, ruleDetails.Priority asc, paymentDetail.TaxRegistrationNumbers_IN asc
                    where setOffRule.TaxReportHierarchyVersion_IN == paymentHistory.TaxReportHierarchyVersion_IN
                join TaxReportHierarchySetOffRule_IN, TaxDirection, RecId from direction
                    where direction.TaxReportHierarchySetOffRule_IN == setOffRule.RecId
                        && direction.TaxDirection == TaxDirection::IncomingTax
                join TaxReportHierarchySetOffRuleDirection_IN, TaxReportHrchyNodeCollectionDetails_IN from ruleDetails
                    where ruleDetails.TaxReportHierarchySetOffRuleDirection_IN == direction.RecId
                join RecId, TaxReportHierarchyNode_IN from collectionDetails
                    where collectionDetails.RecId == ruleDetails.TaxReportHrchyNodeCollectionDetails_IN
                join RecId, CanSettle from tableNode
                    where tableNode.RecId == collectionDetails.TaxReportHierarchyNode_IN
                        && tableNode.CanSettle == NoYes::Yes
                join paymentDetail
                    where paymentDetail.TaxReportHierarchyNode_IN == tableNode.RecId
                        && paymentDetail.RemainingRecAmtToSettle != 0
                        && paymentDetail.TaxSalesTaxPaymentHistory_IN == paymentHistory.RecId
            {
                paymentDetail.selectForUpdate(true);
                this.processSetOffRuleDetailsBasedOnNewSetOffRule(paymentDetail, setOffRule);
            }

            //Process self-settlement for the unsettled entries
            this.processSelfSettlement();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSetOffRuleDetailsBasedOnNewSetOffRule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the node amounts/balance based on new set off rules.
    /// </summary>
    /// <param name="_recoverableHistoryDetail">
    /// The recoverable TaxSalesTaxPaymentHistoryDetails_IN that is used to set off payable amount
    /// </param>
    /// <param name="_setOffRule">
    /// The set off rule
    /// </param>
    private void processSetOffRuleDetailsBasedOnNewSetOffRule(TaxSalesTaxPaymentHistoryDetails_IN _recoverableHistoryDetail,
                                          TaxReportHierarchySetOffRule_IN     _setOffRule)
    {
        TaxReportHierarchySetOffRuleDetails_IN       payableRuleDetail;
        TaxReportHierarchySetOffRuleDirection_IN     ruleDirection;
        TaxReportHrchyNodeCollectionDetails_IN       collectionDetails;
        TaxSalesTaxPaymentHistoryDetails_IN          payableHistoryDetail;

        // Reread the buffer to avoid update conflict.
        _recoverableHistoryDetail.reread();

        while select forUpdate payableHistoryDetail
            order by payableRuleDetail.Priority asc
                where payableHistoryDetail.RemainingPayAmtToSettle != 0
                   && payableHistoryDetail.TaxSalesTaxPaymentHistory_IN == _recoverableHistoryDetail.TaxSalesTaxPaymentHistory_IN
            join collectionDetails
                where payableHistoryDetail.TaxReportHierarchyNode_IN == collectionDetails.TaxReportHierarchyNode_IN
            join payableRuleDetail
                where payableRuleDetail.TaxReportHrchyNodeCollectionDetails_IN == collectionDetails.RecId
            exists join ruleDirection
                where payableRuleDetail.TaxReportHierarchySetOffRuleDirection_IN == ruleDirection.RecId
                    &&    ruleDirection.TaxDirection == TaxDirection::OutgoingTax
                    &&    ruleDirection.TaxReportHierarchySetOffRule_IN == _setOffRule.RecId
        {
            // Reread the buffer to avoid update conflict.
            payableHistoryDetail.reread();
            this.updateAmounts(_recoverableHistoryDetail, payableHistoryDetail, _recoverableHistoryDetail.RemainingRecAmtToSettle, payableHistoryDetail.RemainingPayAmtToSettle);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSelfSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process self-settment even though the set off rule is not create for the hierarchy node
    /// </summary>
    private void processSelfSettlement()
    {
        TaxReportHierarchyNode_IN                   tableNode;
        TaxSalesTaxPaymentHistoryDetails_IN         paymentDetail;

        while select forUpdate paymentDetail
                where (paymentDetail.RemainingRecAmtToSettle != 0 || paymentDetail.RemainingPayAmtToSettle != 0)
                &&    paymentDetail.TaxSalesTaxPaymentHistory_IN == paymentHistory.RecId
                &&    paymentDetail.TaxRegistrationNumbers_IN != 0
            join tableNode
                where tableNode.RecId == paymentDetail.TaxReportHierarchyNode_IN
                && tableNode.CanSettle == NoYes::Yes
        {
           this.updateAmounts(paymentDetail, paymentDetail, paymentDetail.RemainingRecAmtToSettle, paymentDetail.RemainingPayAmtToSettle);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSetOffRuleDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the node amounts/balance after running the set off rules
    /// </summary>
    /// <param name="_recoverableHistoryDetail">
    /// The recoverable TaxSalesTaxPaymentHistoryDetails_IN that is used to set off payable amount
    /// </param>
    /// <param name="_setOffRule">
    /// The set off rule
    /// </param>
    private void processSetOffRuleDetails(TaxSalesTaxPaymentHistoryDetails_IN _recoverableHistoryDetail,
                                          TaxReportHierarchySetOffRule_IN     _setOffRule)
    {
        TaxReportHierarchySetOffRuleDetails_IN       payableRuleDetail;
        TaxReportHierarchySetOffRuleDirection_IN     ruleDirection;
        TaxReportHrchyNodeCollectionDetails_IN       collectionDetails;
        TaxSalesTaxPaymentHistoryDetails_IN         payableHistoryDetail;

        // Reread the buffer to avoid update conflict.
        _recoverableHistoryDetail.reread();

        while select forUpdate payableHistoryDetail
            order by payableRuleDetail.Priority asc
                where payableHistoryDetail.Balance <= 0
                   && payableHistoryDetail.TaxSalesTaxPaymentHistory_IN == _recoverableHistoryDetail.TaxSalesTaxPaymentHistory_IN
            join collectionDetails
                where payableHistoryDetail.TaxReportHierarchyNode_IN == collectionDetails.TaxReportHierarchyNode_IN
            join payableRuleDetail
                where payableRuleDetail.TaxReportHrchyNodeCollectionDetails_IN == collectionDetails.RecId
            exists join ruleDirection
                where payableRuleDetail.TaxReportHierarchySetOffRuleDirection_IN == ruleDirection.RecId
                    &&    ruleDirection.TaxDirection == TaxDirection::OutgoingTax
                    &&    ruleDirection.TaxReportHierarchySetOffRule_IN == _setOffRule.RecId
        {
            // Reread the buffer to avoid update conflict.
            payableHistoryDetail.reread();

            //Skip the self node if the rule is selfSettlementFirst
            if (_setOffRule.SelfSettlementFirst
               && payableHistoryDetail.RecId == _recoverableHistoryDetail.RecId)
            {
                break;
            }

            if (payableHistoryDetail.Balance < 0)
            {
                this.updateAmounts(_recoverableHistoryDetail, payableHistoryDetail, _recoverableHistoryDetail.Balance, payableHistoryDetail.Balance);
            }
            else if (payableHistoryDetail.Balance == 0 && payableHistoryDetail.RemainingPayAmtToSettle != 0)
            {
                //Self settlement = False
                this.updateAmounts(_recoverableHistoryDetail, payableHistoryDetail, _recoverableHistoryDetail.Balance, payableHistoryDetail.RemainingPayAmtToSettle);
            }

            if (_recoverableHistoryDetail.Balance == 0)
            {
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runSalesTaxPaymentProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Start run the sales tax payment process
    /// </summary>
    public void runSalesTaxPaymentProcess()
    {
        TaxSalesTaxPaymentPosting_IN    posting;

        this.initTaxSalesTaxPaymentHistoryDetails();

        switch (TaxRegistrationNumbers_IN::find(profile.parmTaxRegistrationNumber().RecId).TaxType)
        {
            case TaxType_IN::Excise:
                posting = TaxSalesTaxPaymentExcisePosting_IN::construct(paymentHistory, profile);
                break;
            case TaxType_IN::ServiceTax:
                posting = TaxSalesTaxPaymentServTaxPosting_IN::construct(paymentHistory, profile);
                break;
            default:
                posting = TaxSalesTaxPaymentPosting_IN::construct(paymentHistory, profile);
                break;
        }

        if (posting)
        {
            posting.generateTaxSalesTaxPaymentDoc();

            this.parmHasLedgerVoucherTrans(posting.parmHasLedgerVoucherTrans());
            this.parmTaxSalesTaxPaymentDoc(posting.parmTaxSalesTaxPaymentDoc());
            this.postingTaxSalesTaxPaymentDoc();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update history node details with amounts and balances
    /// </summary>
    /// <param name="_recHistoryDetail">
    /// The recoverable TaxSalesTaxPaymentHistoryDetails_IN
    /// </param>
    /// <param name="_payHistoryDetail">
    /// The payable TaxSalesTaxPaymentHistoryDetails_IN
    /// </param>
    /// <param name="_recoverableAmtToSettle">
    /// The recoverable amount that is utilized
    /// </param>
    /// <param name="_payableAmtToSettle">
    /// The payable amount that is paid
    /// </param>
    private void updateAmounts(
                    TaxSalesTaxPaymentHistoryDetails_IN _recHistoryDetail,
                    TaxSalesTaxPaymentHistoryDetails_IN _payHistoryDetail,
                    TaxAmount                           _recoverableAmtToSettle,
                    TaxAmount                           _payableAmtToSettle)
    {
        TaxAmount                           absoluateSettledAmount;

        if (_recoverableAmtToSettle > 0 && _payableAmtToSettle < 0)
        {
            //Recoverable balance > payable balance
            if (abs(_recoverableAmtToSettle) > abs(_payableAmtToSettle))
            {
                absoluateSettledAmount = abs(_payableAmtToSettle);
            }
            else
            {
                //Recoverable balance <= payable balance
                absoluateSettledAmount = _recoverableAmtToSettle;
            }
        }

        ttsBegin;

        if (_recHistoryDetail.RecId == _payHistoryDetail.RecId)
        {
            _recHistoryDetail.SettledRecoverableAmountMST += absoluateSettledAmount;
            _recHistoryDetail.RemainingRecAmtToSettle -= absoluateSettledAmount;
            _recHistoryDetail.SettledPayableAmountMST -= absoluateSettledAmount;
            _recHistoryDetail.RemainingPayAmtToSettle += absoluateSettledAmount;
            _recHistoryDetail.Balance = _recHistoryDetail.RemainingRecAmtToSettle + _recHistoryDetail.RemainingPayAmtToSettle;
            _recHistoryDetail.update();
        }
        else
        {
            _recHistoryDetail.SettledRecoverableAmountMST += absoluateSettledAmount;
            _recHistoryDetail.RemainingRecAmtToSettle -= absoluateSettledAmount;
            _recHistoryDetail.Balance = _recHistoryDetail.RemainingRecAmtToSettle + _recHistoryDetail.RemainingPayAmtToSettle;
            _recHistoryDetail.update();

            _payHistoryDetail.SettledPayableAmountMST -= absoluateSettledAmount;
            _payHistoryDetail.RemainingPayAmtToSettle += absoluateSettledAmount;
            _payHistoryDetail.Balance = _payHistoryDetail.RemainingRecAmtToSettle + _payHistoryDetail.RemainingPayAmtToSettle;
            _payHistoryDetail.update();
        }

        ttsCommit;

        if (_recHistoryDetail.TaxRegistrationNumbers_IN == profile.parmTaxRegistrationNumber().RecId ||
           _payHistoryDetail.TaxRegistrationNumbers_IN == profile.parmTaxRegistrationNumber().RecId)
        {
            //Create setoff history
            this.createSetOffHistory(_recHistoryDetail, _payHistoryDetail, absoluateSettledAmount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxReportPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update or create TaxReportPeriod after successfully running the sales tax payment process
    /// </summary>
    /// <remarks>
    /// The TaxRepCounter will be increased so that the new tax transactions will be posted with the new TaxRepCounter value
    /// </remarks>
    private void updateTaxReportPeriod()
    {
        TaxReportPeriod_IN  taxReportPeriod;

        if (!TaxReportPeriod_IN::findByTaxPeriod(profile.parmTaxPeriod(),
            profile.parmTaxRegistrationNumber().RecId,
            profile.taxPeriodFromDate()))
        {
            taxReportPeriod.TaxPeriod                   = profile.parmTaxPeriod();
            taxReportPeriod.TaxRegistrationNumberTable  = profile.parmTaxRegistrationNumber().RecId;
            taxReportPeriod.FromDate                    = profile.taxPeriodFromDate();
            taxReportPeriod.ToDate                      = profile.taxPeriodToDate();
            taxReportPeriod.Availed                     = NoYes::Yes;
            taxReportPeriod.insert();
        }

        TaxReportPeriod_IN::versionSumUp(profile.parmTaxPeriod(), profile.parmTaxRegistrationNumber().RecId, profile.taxPeriodFromDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransWithTaxReportPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update taxTrans with settled tax report period
    /// </summary>
    /// <remarks>
    /// This indicates that the tax trans is fully settled in the current tax report period
    /// </remarks>
    private void updateTransWithTaxReportPeriod()
    {
        TaxSalesTaxPaymentHistoryDetails_IN         historyDetails;
        TaxSalesTaxPaymentHistoryDetailsTrans_IN    detailTrans;
        TaxReportPeriod_IN                          taxReportPeriod;
        TaxSalesTaxPaymentTaxAdjustments_IN         taxAdjustment;
        TaxTrans_IN                                 taxTransIN;
        TaxTrans                                    taxTrans;

        if (profile)
        {
            taxReportPeriod = TaxReportPeriod_IN::findByTaxPeriod(profile.parmTaxPeriod(), profile.parmTaxRegistrationNumber().RecId, profile.taxPeriodFromDate());

            if (taxReportPeriod)
            {
                update_recordSet taxAdjustment
                    setting TaxReportPeriod_IN = taxReportPeriod.RecId
                    where taxAdjustment.TaxReportPeriod_IN == 0
                    join taxTransIN
                        where taxTransIN.RecId == taxAdjustment.TaxTrans_IN
                        &&    taxTransIN.CompanyRegistrationNumber == profile.parmTaxRegistrationNumber().RecId;

                update_recordSet taxTransIN
                    setting taxReportPeriod_IN = taxReportPeriod.RecId
                        where taxTransIN.taxReportPeriod_IN == 0
                           && taxTransIN.TransDate <= profile.taxPeriodToDate()
                           && taxTransIN.CompanyRegistrationNumber == profile.parmTaxRegistrationNumber().RecId
                    join detailTrans
                        where detailTrans.TaxTrans_IN == taxTransIN.RecId
                           && detailTrans.Mark == NoYes::Yes
                    join historyDetails
                        where historyDetails.RecId == detailTrans.TaxSalesTaxPaymentHistoryDetails_IN
                        &&    historyDetails.TaxSalesTaxPaymentHistory_IN == paymentHistory.RecId
                    notexists join taxAdjustment
                        where taxAdjustment.TaxTrans_IN == taxTransIN.RecId
                           && taxAdjustment.TaxSalesTaxPaymentHistoryDetailsTrans_IN == detailTrans.RecId;

                update_recordSet taxTrans
                    setting TaxRepCounter = taxReportPeriod.VersionNum + 1
                        where taxTrans.TaxRepCounter < (taxReportPeriod.VersionNum + 1)
                        &&    taxTrans.Source != TaxModuleType::Tax
                    join taxTransIN
                        where taxTransIN.RefRecId == taxTrans.RecId
                        &&    taxTransIN.TaxReportPeriod_IN == 0
                        &&    taxTransIN.TaxPeriod == profile.parmTaxPeriod()
                        &&    taxTransIN.CompanyRegistrationNumber == profile.parmTaxRegistrationNumber().RecId
                        &&    taxTransIN.TaxReportHierarchyNode_IN != 0
                        &&    taxTransIN.TransDate <= profile.taxPeriodToDate()
                        &&    taxTransIN.TransDate >= profile.taxPeriodFromDate();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearSalesTaxPaymentHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clean up sales tax payment history and it's related tables if the sales tax payment has not been run yet
    /// Or the sales tax payment process was failed by some reasons
    /// </summary>
    public static void clearSalesTaxPaymentHistory()
    {
        TaxSalesTaxPaymentHistory_IN                history;
        TaxSalesTaxPaymentHistoryDetails_IN         historyDetails;
        TaxSalesTaxPaymentHistoryDetailsTrans_IN    historyDetailTrans;
        TaxSalesTaxPaymentSetOffHistory_IN          setOffHistory;
        taxSalesTaxPaymentTaxAdjustments_IN         taxAdjust;

        ttsBegin;

        delete_from taxAdjust
            exists join historyDetailTrans
                where historyDetailTrans.RecId == taxAdjust.TaxSalesTaxPaymentHistoryDetailsTrans_IN
            exists join historyDetails
                where historyDetails.RecId == historyDetailTrans.TaxSalesTaxPaymentHistoryDetails_IN
            exists join history
                where history.RecId == historydetails.TaxSalesTaxPaymentHistory_IN
                   && history.TaxReportVoucher == 0;

        delete_from setOffHistory
            exists join historyDetailTrans
                where historyDetailTrans.RecId == setOffHistory.DetailTransToBeSettled ||
                      historyDetailTrans.RecId == setOffHistory.DetailTransToSettle
            exists join historyDetails
                where historyDetails.RecId == historyDetailTrans.TaxSalesTaxPaymentHistoryDetails_IN
            exists join history
                where history.RecId == historydetails.TaxSalesTaxPaymentHistory_IN
                   && history.TaxReportVoucher == 0;

        delete_from historyDetailTrans
            exists join historyDetails
                where historyDetails.RecId == historyDetailTrans.TaxSalesTaxPaymentHistoryDetails_IN
            exists join history
                where history.RecId == historydetails.TaxSalesTaxPaymentHistory_IN
                   && history.TaxReportVoucher == 0;

        delete_from historyDetails
            exists join history
                where historydetails.TaxSalesTaxPaymentHistory_IN == history.RecId
                   && history.TaxReportVoucher == 0;

        delete_from history
            where history.TaxReportVoucher == 0;

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new instance of <c> TaxSalesTaxPaymentFacade_IN </c>.
    /// </summary>
    /// <param name="_profile">
    /// The instance of <c> TaxSalesTaxPaymentProfile_IN </c>.
    /// </param>
    /// <param name="_structureDesign">
    /// The instance of <c> TaxReportHrchyStructureDesign_IN </c>.
    /// </param>
    /// <returns>
    /// A new instance of <c> TaxSalesTaxPaymentFacade_IN </c>.
    /// </returns>
    public static TaxSalesTaxPaymentFacade_IN construct(
        TaxSalesTaxPaymentProfile_IN    _profile,
        TaxReportHrchyStructureDesign_IN _structureDesign)
    {
        TaxSalesTaxPaymentFacade_IN facade = new TaxSalesTaxPaymentFacade_IN(_profile, _structureDesign);

        return facade;
    }

]]></Source>
			</Method>
			<Method>
				<Name>counterMax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the maximum value of tax report counter
    /// </summary>
    /// <param name="_taxRepVersion">
    /// The TaxRepVersion
    /// </param>
    /// <param name="_taxPeriod">
    /// The TaxPeriod
    /// </param>
    /// <param name="_taxRegistrationNumberRecId">
    /// The recId of TaxRegistrationNumber
    /// </param>
    /// <param name="_fromDate">
    /// The from date
    /// </param>
    /// <returns>
    /// The maximum value of tax report counter
    /// </returns>
    server static Counter counterMax(TaxRepVersion  _taxRepVersion,
                                     TaxPeriod      _taxPeriod,
                                     RefRecId       _taxRegistrationNumberRecId,
                                     TransDate      _fromDate)
    {
        if  (_taxRepVersion == TaxRepVersion::Original)
            return 0;
        else
            return TaxReportPeriod_IN::version(_taxPeriod, _taxRegistrationNumberRecId, _fromDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>counterMin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the minimum value of tax report counter
    /// </summary>
    /// <param name="_taxRepVersion">
    /// The TaxRepVersion
    /// </param>
    /// <param name="_taxPeriod">
    /// The TaxPeriod
    /// </param>
    /// <param name="_taxRegistrationNumberRecId">
    /// The recId of TaxRegistrationNumber
    /// </param>
    /// <param name="_fromDate">
    /// The from date
    /// </param>
    /// <returns>
    /// The minimum value of tax report counter
    /// </returns>
    server static Counter counterMin(TaxRepVersion  _taxRepVersion,
                                     TaxPeriod      _taxPeriod,
                                     RefRecId       _taxRegistrationNumberRecId,
                                     TransDate      _fromDate)
    {
        Integer counter;
        switch (_taxRepVersion)
        {
            case TaxRepVersion::Original :
                counter= 0;
                break;

            case TaxRepVersion::Correct :
                counter= 1;
                break;

            case TaxRepVersion::Latest :
                counter= TaxReportPeriod_IN::version(_taxPeriod, _taxRegistrationNumberRecId, _fromDate);
                break;

            case TaxRepVersion::Total :
                counter= 0;
                break;
        }
        return counter;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>