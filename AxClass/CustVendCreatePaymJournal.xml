<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendCreatePaymJournal</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>CustVendCreatePaymJournal</c> class collects open transactions for treatment in a payment
///    proposal.
/// </summary>
/// <remarks>
///    A <see cref="T:CustVendPaymProposal" /> object matches transactions to specific payments.
/// </remarks>
abstract class CustVendCreatePaymJournal extends RunBaseBatch
{
    DialogRunbase dialog;

    QueryRun queryCreatePayment;
    Map mstBalances;
    boolean areMstBalancesCached;
    Map transOpenPaymModeMap;

    CustVendCreatePaymProposalType paymProposalType;
    CustVendPaymProposal paymProposal;

    LedgerJournalId ledgerJournalId;

    TransDate fromDate;
    TransDate toDate;
    NoYes balanceCheck;
    NoYes deleteCredit;
    NoYes printProposal;
    NoYes generateProposal;
    NoYes skipProposalEditForm;

    TransDate earlyPaymDate;
    TransDate paymDateFixed;
    WeekDays paymWeekDayFixed;
    CurrencyCode paymCurrency;
    Counter progressCounter;
    AmountMST amountMax;
    AmountMST proposalTotalMST;

    private const int BundleSize = 2500;
    private boolean hasBatchBeenSplit;
    private CustVendAC fromCustVendAccountNum;
    private CustVendAC toCustVendAccountNum;
    private boolean isAutomation;
    private boolean isFirstBatch;
    private boolean isFinalBatch;
    private RefRecId processExecutionSourceLinkRecId;
    private str curUserId;
    private int64 custVendPaymProposalLineTmpRecId;

    // <GCN>
    LedgerVoucherTypeId_CN voucherType_CN;
    boolean isChineseVoucher;
    // </GCN>

    // Italian feature
    TransDate postingDate;
    NoYes useFutureDueDate;
    NoYes postingDateOption_IT;

    // <GJP>
    TransDate consFromDate;
    TransDate consToDate;
    VendConsId_JP consId;
    VendConsDay_JP consDay;
    // </GJP>

    DialogGroup dialogGroupDateOfPayment;

    // <GJP>
    DialogGroup dialogGroupConsDate;
    DialogGroup dialogGroupConsId;
    DialogGroup dialogGroupConsDay;
    // </GJP>

    DialogField dialogPaymProposalType;
    DialogField dialogBalanceCheck;
    DialogField dialogFromDate;
    DialogField dialogToDate;
    DialogField dialogFromAccount;
    DialogField dialogToAccount;
    DialogField dialogPaymDateFixed;
    DialogField dialogPaymWeekDayFixed;
    DialogField dialogEarlyPaymDate;
    DialogField dialogPaymCurrency;
    DialogField dialogDeleteCredit;
    DialogField dialogAmountMax;
    DialogField dialogPrintProposal;
    DialogField dialogSkipEditForm;
    // <GCN>
    DialogField dialogVoucherType_CN;
    // </GCN>

    DialogField dialogPostingDate;
    DialogField dialogUseFutureDueDate;
    
    // <GJP>
    DialogField dialogConsFrom;
    DialogField dialogConsTo;
    DialogField dialogConsId;
    DialogField dialogConsDay;
    // </GJP>

    DialogField dialogIncludeInvoicesFromOtherCompanies;
    #DEFINE.dialogIncludeInvoicesFromOtherCompaniesFieldNo(990)
    #DEFINE.dialogIncludeInvoicesFromOtherCompaniesCtrlName('Fld990_1')
    NoYes includeInvoicesFromOtherCompanies;
    DialogField dialogProposeSeparatePaymentPerCompany;
    NoYes proposeSeparatePaymentPerCompany;
    boolean limitPaymCreationToLedgerCompanyOnly;

    DialogField dialogDynamicAccountType;
    LedgerJournalACTypeForPaymProposal defaultOffsetAccountType;

    DialogField dialogDynamicAccount;
    LedgerDimensionDefaultAccount defaultOffsetLedgerDimension;

    CompanyId journalHeaderCompany;
    DimensionDefault journalHeaderDefaultDimension;
    DimensionDefault mainAccountDefaultDimension;

    // <GTH>
    TaxBranchEnabled isTaxBranchEnabled;
    TaxBranchCode taxBranchCode;
    TaxBranchRefRecId taxBranchRecId;
    DialogField dialogTaxBranch;
    // </GTH>

    CustVendPaymProposalUserInteraction userInteraction;
    boolean isPaymentRequestsEnabled;
    boolean isGeneratedFromPaymentSchedule;
    CFMPaymentRequestTable paymentRequestTable;

    VendRoutingSlipId_PSN PSNVendRoutingSlipId;

    #DEFINE.CrossCompanyCacheKeyValue('SUMMARY')

    // <GCN>
    #DEFINE.CurrentVersion(29)
    // </GCN>
    #LOCALMACRO.CurrentList
        ledgerJournalId,
        paymProposalType,
        // <GTH>
        taxBranchCode,
        // </GTH>
        balanceCheck,
        fromDate,
        todate,
        paymDateFixed,
        paymWeekDayFixed,
        earlyPaymDate,
        paymCurrency,
        deleteCredit,
        amountMax,
        printProposal,
        skipProposalEditForm,
        postingDate,
        useFutureDueDate,
        postingDateOption_IT,
        includeInvoicesFromOtherCompanies,
        proposeSeparatePaymentPerCompany,
        defaultOffsetAccountType,
        // <GCN>
        voucherType_CN,
        // </GCN>
        // <GJP>
        defaultOffsetLedgerDimension,
        consFromDate,
        consToDate,
        consId,
        consDay,
        // </GJP>
        limitPaymCreationToLedgerCompanyOnly,
        hasBatchBeenSplit,
        fromCustVendAccountNum,
        toCustVendAccountNum,
        isFinalBatch,
        curUserId,
        custVendPaymProposalLineTmpRecId,
        PSNVendRoutingSlipId,
        isAutomation,
        isFirstBatch,
        processExecutionSourceLinkRecId
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accountType_Modified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the modified event for the "AccountType" dialog field
    /// </summary>
    /// <param name="_formComboBoxControl">
    /// The control for the AccountType field.
    /// </param>
    private boolean accountType_Modified(FormComboBoxControl _formComboBoxControl)
    {
        boolean valueWasModified = _formComboBoxControl.modified();
        if (valueWasModified)
        {
            SegmentedEntryControl dialogDynamicAccountControl = dialogDynamicAccount.control();
            dialogDynamicAccountControl.parmAccountTypeEnumValue(dialogDynamicAccountType.value());
            dialogDynamicAccount.value(0);
            this.enableDisableFields();
        }
        return valueWasModified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSpecTransToQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a <c>SpecTrans</c> data source to the query.
    /// </summary>
    /// <param name="_custVendTransOpenTableId">
    ///    The table ID of the customer or vendor open transaction table.
    /// </param>
    [SysObsolete('This method is obsolete.', false, 30\6\2020)]
    protected void addSpecTransToQuery(tableId _custVendTransOpenTableId)
    {
        QueryBuildDataSource qbdsSpecTrans = queryCreatePayment.query().dataSourceTable(_custVendTransOpenTableId).addDataSource(tableNum(SpecTrans));

        DictRelation dictRelation = new DictRelation(tableNum(SpecTrans));
        dictRelation.loadTableRelation(_custVendTransOpenTableId);

        qbdsSpecTrans.addRelation(dictRelation);
        qbdsSpecTrans.joinMode(JoinMode::NoExistsJoin);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheCustVendBalancesAcrossCompanies</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines how customer and vendor balances are to be cached.
    /// </summary>
    /// <returns>
    ///    true if the customer and vendor balances are to be cached across companies; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Balances are cached cross company only if you include invoices from other companies and do not
    ///    propose separate payments per company.
    /// </remarks>
    private boolean cacheCustVendBalancesAcrossCompanies()
    {
        return includeInvoicesFromOtherCompanies == NoYes::Yes
            && proposeSeparatePaymentPerCompany == NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs final calculation on the transaction to determine whether it should be added to the
    ///    payment proposal.
    /// </summary>
    /// <param name="_custVendTransOpen">
    ///    The <c>CustVendTransOpen</c> record buffer on which to perform the final calculation.
    /// </param>
    /// <returns>
    ///    true if the transaction should be added to the payment proposal; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The query does the major filtering. On a transaction level you must conclude whether the
    ///    transaction would release a cash discount if paid at a certain date.
    /// </remarks>
    protected boolean calc(CustVendTransOpen _custVendTransOpen)
    {
        if (isPaymentRequestsEnabled)
        {
            this.paymProposal().parmPaymProposalCalcPaym().parmPaymentRequest(paymentRequestTable);
            this.paymProposal().parmPaymProposalCalcPaym().parmPaymCurrency(paymentRequestTable.PaymentCurrency);
            return paymentRequestTable.amountToPayInCurrency() != 0;
        }

        return _custVendTransOpen.AmountCur != 0.0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBlocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the selection query to be suited for finding the covered customers and vendors who are also
    /// blocked.
    /// </summary>
    /// <remarks>
    /// The customers or vendor account numbers in question are displayed in the info log.For the real
    /// selection of transactions, blocked customers or vendors are not considered at all.If the user
    /// selects to run a payment proposal per Due date &amp; cash discount, the collection job is run two
    /// times; this makes sure that blocked customers or vendors are only selected one time.
    /// </remarks>
    public void checkBlocked()
    {
        if (this.shouldExecCheckBlockedQuery())
        {
            Query queryCheckBlocked = this.checkBlockedInitQuery();
            this.checkBlockedExecuteQuery(queryCheckBlocked);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldExecCheckBlockedQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defines whether the query for finding blocked vendors should be executed.
    /// </summary>
    /// <returns>True if blocked query should execute; Otherwise, false.</returns>
    protected boolean shouldExecCheckBlockedQuery()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBlockedExecuteQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes query to get blocked elements in the payment scope.
    /// </summary>
    /// <param name = "_query">Query to be executed.</param>
    protected void checkBlockedExecuteQuery(Query _query)
    {
        QueryRun queryRunCheckBlocked = new QueryRun(_query);
        QueryBuildDataSource qbdsInitCustVendTable = queryRunCheckBlocked.query().dataSourceNo(1);
        TableId tableIdCustVendTable = qbdsInitCustVendTable.table();
        LabelString labelStr;

        switch (tableIdCustVendTable)
        {
            case tableNum(CustTable):
                labelStr = "@SYS88530";
                break;

            case tableNum(VendTable):
                labelStr = "@SYS67305";
                break;
        }

        while (queryRunCheckBlocked.next())
        {
            if (queryRunCheckBlocked.changed(tableIdCustVendTable))
            {
                CustVendTable custVendTable = queryRunCheckBlocked.get(tableIdCustVendTable);
                this.logMessage(Exception::Info, strFmt(labelStr, custVendTable.AccountNum, this.getCustVendorBlockedInfoStates()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendorBlockedInfoStates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns label content of Vendor Blocked enum state for block elements.
    /// </summary>
    /// <returns>Formatted LabelString with values for <c>CustVendorBlocked::All</c> and <c>CustVendorBlocked::Payment</c></returns>
    protected LabelString getCustVendorBlockedInfoStates()
    {
        return enum2Value(CustVendorBlocked::All) + ', ' + enum2Value(CustVendorBlocked::Payment);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBlockedInitQuery</Name>
				<Source><![CDATA[
    protected Query checkBlockedInitQuery()
    {
        Query queryCheckBlocked = new Query(queryCreatePayment.query());
        QueryBuildDataSource qbdsCustVendTable = queryCheckBlocked.dataSourceNo(1);

        FieldId fieldIdBlocked;

        switch (qbdsCustVendTable.table())
        {
            case tableNum(CustTable):
                fieldIdBlocked = fieldNum(CustTable, Blocked);
                break;

            case tableNum(VendTable):
                fieldIdBlocked = fieldNum(VendTable, Blocked);
                break;
        }

        QueryBuildRange blockedIdRange = SysQuery::findOrCreateRange(qbdsCustVendTable, fieldIdBlocked);
        blockedIdRange.value(
            strFmt('((%1 == %2) || (%1 == %3))',
            BlockedIdRange.fieldName(),
            enum2int(CustVendorBlocked::All),
            enum2int(CustVendorBlocked::Payment)));

        return queryCheckBlocked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertToLedgerJournalACType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts a <c>LedgerJournalACTypeForPaymProposal</c> value to a <c>LedgerJournalACType</c> value.
    /// </summary>
    /// <param name="_ledgerJournalACTypeForPaymProposal">
    ///    The <c>LedgerJournalACTypeForPaymProposal</c> value to be converted.
    /// </param>
    /// <returns>
    ///    The <c>LedgerJournalACType</c> value associated with the <c>LedgerJournalACTypeForPaymProposal</c>
    ///    value provided.
    /// </returns>
    /// <remarks>
    ///    Only Bank and Ledger values are associated between the <c>LedgerJournalACType</c> and
    ///    <c>LedgerJournalACTypeForPaymProposal</c> enumerations. Any unmapped
    ///    <c>LedgerJournalACTypeForPaymProposal</c> value will result in the default
    ///    <c>LedgerJournalACType</c> value, which is Ledger.
    /// </remarks>
    public LedgerJournalACType convertToLedgerJournalACType(LedgerJournalACTypeForPaymProposal _ledgerJournalACTypeForPaymProposal)
    {
        LedgerJournalACType ledgerJournalACType;

        switch (_ledgerJournalACTypeForPaymProposal)
        {
            case LedgerJournalACTypeForPaymProposal::Bank:
                ledgerJournalACType = LedgerJournalACType::Bank;
                break;

            case LedgerJournalACTypeForPaymProposal::Ledger:
                ledgerJournalACType = LedgerJournalACType::Ledger;
                break;

            default:
                ledgerJournalACType = LedgerJournalACType::Ledger;
                break;
        }

        return ledgerJournalACType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    /// interface.
    /// </summary>
    /// <returns>
    /// A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    /// A dialog box can be either built by using the <c>Dialog</c> class or by using a class that is
    /// created in the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        dialog = this.dialogInternal(dialog);

        // When a dialog has showQueryValues set to true, the mainFormGroup needs to be restored after
        // adding controls like Tab Page because the dialog framework can't handle it automatically.
        FormBuildGroupControl parametersGroup = dialog.mainFormGroup();

        this.dialogAddInvoiceSelectionCriteriaFields();

        dialog.addTabPage("@CashManagement:AdvancedParameters").columns(2);

        this.dialogAddPaymentDefaultFields();

        this.dialogAddCountrySpecificFields();

        this.dialogAddBillingClassificationFields_Cust();

        this.dialogAddCentralizedPaymentsFields();

        this.updateCustVendSpecificLabels();

        dialog.mainFormGroup(parametersGroup);
        dialog.curFormGroup(parametersGroup);

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddInvoiceSelectionCriteriaFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the fields that will be the criteria for filtering invoices
    /// </summary>
    protected void dialogAddInvoiceSelectionCriteriaFields()
    {
        dialog.addGroup("@CashManagement:InvoiceSelectionCriteria").widthMode(FormWidth::SizeToAvailable);

        this.dialogAddPaymProposalType();

        this.dialogAddDateSelectionFields();

        this.dialogAddMinimumPaymentDateField();

        this.dialogAddLimitFields();

        dialogSkipEditForm = dialog.addFieldValue(extendedTypeStr(NoYesId), skipProposalEditForm, "@CashManagement:SkipEditDialog");
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddPaymProposalType</Name>
				<Source><![CDATA[
    protected void dialogAddPaymProposalType()
    {
        dialogPaymProposalType = dialog.addFieldValue(enumStr(CustVendCreatePaymProposalType), paymProposalType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddDateSelectionFields</Name>
				<Source><![CDATA[
    protected void dialogAddDateSelectionFields()
    {
        dialogFromDate = dialog.addFieldValue(extendedTypeStr(TransDate), fromDate, "@SYS5209");
        dialogToDate = dialog.addField(extendedTypeStr(TransDate), "@SYS14656");

        if (toDate != maxDate())
        {
            dialogToDate.value(toDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddLimitFields</Name>
				<Source><![CDATA[
    private void dialogAddLimitFields()
    {
        dialogAmountMax = dialog.addFieldValue(extendedTypeStr(Amount), amountMax, "@SYS27719");

        FormBuildRealControl dialogAmountMaxControl = dialogAmountMax.control() as FormBuildRealControl;
        dialogAmountMaxControl.allowNegative(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddBalanceCheckField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the balance check field to the dialog.
    /// </summary>
    protected abstract void dialogAddBalanceCheckField()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddCountrySpecificFields</Name>
				<Source><![CDATA[
    private void dialogAddCountrySpecificFields()
    {
        this.dialogAddTaxBranchFields_TH();

        this.dialogAddChineseVoucherFields_CN();

        this.dialogAddPostingDateOptionFields_IT();

        this.dialogAddConsolidationInvoiceFields_JP();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddTaxBranchFields_TH</Name>
				<Source><![CDATA[
    private void dialogAddTaxBranchFields_TH()
    {
        if (isTaxBranchEnabled)
        {
            dialogTaxBranch = dialog.addFieldValue(extendedTypeStr(TaxBranchCode), taxBranchCode, "@SYS4082514");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddCentralizedPaymentsFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the fields associated with centralized payments processing to the dialog.
    /// </summary>
    /// <param name="_dialog">
    ///    The <c>Dialog</c> window to which fields will be added.
    /// </param>
    private void dialogAddCentralizedPaymentsFields()
    {
        DialogGroup centralizedPaymentsGroup = dialog.addGroup("@SYS115163");
        centralizedPaymentsGroup.configurationKey(configurationKeyNum(LedgerAdvIntercompanyAccounting));

        dialogIncludeInvoicesFromOtherCompanies = new DialogField(dialog, extendedTypeStr(NoYesId), #dialogIncludeInvoicesFromOtherCompaniesFieldNo);
        dialog.addCtrlDialogField(dialogIncludeInvoicesFromOtherCompanies.name());
        dialogIncludeInvoicesFromOtherCompanies.init(dialog);
        // note: label & helpText values for this field are added by derived classes
        dialogIncludeInvoicesFromOtherCompanies.value(includeInvoicesFromOtherCompanies);
        // assert if resulting field name was not set as expected as this must match the method which processes the event, e.g. fld990_1_validate
        Debug::assert(dialogIncludeInvoicesFromOtherCompanies.fieldname() == #dialogIncludeInvoicesFromOtherCompaniesCtrlName);

        dialogProposeSeparatePaymentPerCompany = dialog.addFieldValue(extendedTypeStr(NoYesId), proposeSeparatePaymentPerCompany);
        // note: label & helpText values for this field are added by derived classes
        dialogProposeSeparatePaymentPerCompany.enabled(includeInvoicesFromOtherCompanies != NoYes::No);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddBillingClassificationFields_Cust</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the fields associated with customer billing classification to the dialog.
    /// </summary>
    protected void dialogAddBillingClassificationFields_Cust()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddChineseVoucherFields_CN</Name>
				<Source><![CDATA[
    private void dialogAddChineseVoucherFields_CN()
    {
        isChineseVoucher = LedgerParameters::isChineseVoucher_CN();
        if (isChineseVoucher)
        {
            dialog.addGroup("@GLS54929");
            dialogVoucherType_CN = dialog.addFieldValue(extendedTypeStr(LedgerVoucherTypeId_CN), voucherType_CN, "@GLS54929", "@GLS54489");

            if (LedgerJournalId
                && (LedgerJournalTable::find(LedgerJournalId).ledgerJournalName().NewVoucher == NewVoucher::OneVoucher))
            {
                LedgerJournalTrans ledgerJournalTransForOneVoucher;

                select firstOnly ledgerJournalTransForOneVoucher
                    where ledgerJournalTransForOneVoucher.JournalNum == LedgerJournalId;
                if (ledgerJournalTransForOneVoucher)
                {
                    dialogVoucherType_CN.value(LedgerVoucherType_CN::find(ledgerJournalTransForOneVoucher.LedgerVoucherType_CN).Id);
                    dialogVoucherType_CN.enabled(false);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddPostingDateOptionFields_IT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the fields associated with posting date options to the dialog.
    /// </summary>
    protected abstract void dialogAddPostingDateOptionFields_IT()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddConsolidationInvoiceFields_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the fields associated with invoice consolidation to the dialog.
    /// </summary>
    protected abstract void dialogAddConsolidationInvoiceFields_JP()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddPaymentDefaultFields</Name>
				<Source><![CDATA[
    private void dialogAddPaymentDefaultFields()
    {
        DialogGroup paymentDefaultsGroup = dialog.addGroup("@CashManagement:PaymentDefaults");
        paymentDefaultsGroup.widthMode(FormWidth::SizeToAvailable);

        dialogPaymCurrency = dialog.addFieldValue(extendedTypeStr(CurrencyCode), paymCurrency, "@SYS66023");

        this.dialogAddPaymWeekDayFixedField_Vend();

        this.dialogAddOffsetAccountAndTypeFields();

        this.dialogAddSummarizedPaymentDate();

        this.dialogAddBalanceCheckField();

        dialogDeleteCredit = dialog.addFieldValue(extendedTypeStr(NoYesId), deleteCredit, "@SYS77425");
        dialogPrintProposal = dialog.addFieldValue(extendedTypeStr(NoYesId), printProposal, "@CashManagement:PrintReportOnly");
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddMinimumPaymentDateField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the minimum payment date field to the dialog.
    /// </summary>
    protected abstract void dialogAddMinimumPaymentDateField()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddPaymWeekDayFixedField_Vend</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the fixed day of week field to the dialog.
    /// </summary>
    protected void dialogAddPaymWeekDayFixedField_Vend()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddOffsetAccountAndTypeFields</Name>
				<Source><![CDATA[
    protected void dialogAddOffsetAccountAndTypeFields()
    {
        dialogDynamicAccountType = dialog.addFieldValue(enumStr(LedgerJournalACTypeForPaymProposal), defaultOffsetAccountType, "@SYS23950");

        dialogDynamicAccount = SegmentedEntryControlBuild::addToDialog(dialog, classstr(DimensionDynamicAccountController), extendedTypeStr(LedgerDimensionBase), "@SYS11162", defaultOffsetLedgerDimension);

        if (defaultOffsetAccountType == LedgerJournalACTypeForPaymProposal::None)
        {
            defaultOffsetAccountType = LedgerJournalACTypeForPaymProposal::Ledger;
        }

        SegmentedEntryControlBuild::initDialogFieldAccountType(dialogDynamicAccount, enumStr(LedgerJournalACTypeForPaymProposal), defaultOffsetAccountType);

        dialogDynamicAccount.control().parmIsDefaultAccount(true);

        this.enableDisableFields();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddSummarizedPaymentDate</Name>
				<Source><![CDATA[
    protected void dialogAddSummarizedPaymentDate()
    {
        dialogPaymDateFixed = dialog.addField(extendedTypeStr(TransDate), "@CashManagement:CreatePaymentProposalSummarizedPaymentDate", "@CashManagement:CreatePaymentProposalSummarizedPaymentDateHelp");
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustVendSpecificLabels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates customer/vendor specific labels on the dialog.
    /// </summary>
    protected abstract void updateCustVendSpecificLabels()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPostRun</Name>
				<Source><![CDATA[
    public void dialogPostRun(DialogRunbase _dialog)
    {
        super(_dialog);

        // allow the dialog infrastructure to raise dialog field events
        dialogIncludeInvoicesFromOtherCompanies.registerOverrideMethod(
            methodStr(FormStringControl, modified),
            methodStr(CustVendCreatePaymJournal, includeInvFromOtherCompanies_Modified),
            this);

        if (isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)))
        {
            dialogDynamicAccount.registerOverrideMethod(
                methodStr(FormStringControl, lookup),
                methodStr(CustVendCreatePaymJournal, lookupDynamicAccount),
                this);

            dialogDynamicAccountType.registerOverrideMethod(
                methodStr(FormStringControl, modified),
                methodStr(CustVendCreatePaymJournal, accountType_Modified),
                this);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableDisableFields</Name>
				<Source><![CDATA[
    public void enableDisableFields()
    {
        if (dialogDynamicAccountType.value() == LedgerJournalACTypeForPaymProposal::None)
        {
            dialogDynamicAccount.allowEdit(false);
        }
        else
        {
            dialogDynamicAccount.allowEdit(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCachedMstBalance</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the cached balance value that is associated with the supplied <c>CustVendTable</c> record.
    /// </summary>
    /// <param name="_custVendTable">
    ///    The <c>CustVendTable</c> record that represents the customer or vendor for which to retrieve the
    ///    associated balance.
    /// </param>
    /// <returns>
    ///    The balance value that is associated with the supplied customer or vendor if it is in the cache;
    ///    otherwise, 0.
    /// </returns>
    /// <remarks>
    ///    The balance values are cached by using the <c>initBalances</c> method.
    /// </remarks>
    protected AmountMST getCachedMstBalance(CustVendTable _custVendTable)
    {
        Debug::assert(areMstBalancesCached); // This call should not be made if the balance value caches have not been populated

        CompanyId companyKey;
        str custVendKey;
        if (this.cacheCustVendBalancesAcrossCompanies())
        {
            companyKey = #CrossCompanyCacheKeyValue; // Cache contains balances for all companies
            custVendKey = int642str(_custVendTable.Party);
        }
        else
        {
            // Cache is keyed by company & cust/vend account number
            companyKey = _custVendTable.company(); // Use company() as it is always a concrete company
            custVendKey = _custVendTable.AccountNum;
        }

        AmountMST mstBalance;
        if (companyKey != '' && custVendKey != '')
        {
            if (mstBalances.exists(companyKey))
            {
                Map mstBalancesByCustVend = mstBalances.lookup(companyKey);
                if (mstBalancesByCustVend.exists(custVendKey))
                {
                    mstBalance = mstBalancesByCustVend.lookup(custVendKey);
                }
            }
        }

        return mstBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Transfers values from dialog box fields to the class member values that represent the user input.
    /// </summary>
    /// <returns>
    ///    true.
    /// </returns>
    /// <remarks>
    ///    This method is invoked by the <c>RunBase</c> framework when the OK button of the dialog box is
    ///    pressed.
    /// </remarks>
    public boolean getFromDialog()
    {
        paymProposalType = dialogPaymProposalType.value();

        // <GTH>
        if (isTaxBranchEnabled)
        {
            taxBranchCode = dialogTaxBranch.value();
            taxBranchRecId = TaxBranch::findByCode(taxBranchCode).RecId;
        }
        // /<GTH>

        balanceCheck = dialogBalanceCheck.value();
        fromDate = dialogFromDate.value();
        if (dialogToDate.value())
        {
            toDate = dialogToDate.value();
        }
        else
        {
            toDate = maxDate();
        }

        if (dialogPaymDateFixed.value())
        {
            paymDateFixed = dialogPaymDateFixed.value();
        }
        else
        {
            paymDateFixed = dateNull();
        }

        if (dialogPaymWeekDayFixed)
        {
            paymWeekDayFixed = dialogPaymWeekDayFixed.value();
        }

        amountMax = dialogAmountMax.value();
        deleteCredit = dialogDeleteCredit.value();
        printProposal = dialogPrintProposal.value();
        skipProposalEditForm = dialogSkipEditForm.value();
        paymCurrency = dialogPaymCurrency.value();

        // <GCN>
        if (isChineseVoucher)
        {
            voucherType_CN = dialogVoucherType_CN.value();
        }
        // </GCN>

        includeInvoicesFromOtherCompanies = dialogIncludeInvoicesFromOtherCompanies.value();
        proposeSeparatePaymentPerCompany = dialogProposeSeparatePaymentPerCompany.value();

        curUserId = curUserId();

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalHeaderDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the default dimension for the journal header.
    /// </summary>
    /// <param name="_companyId">
    /// The company ID wherein the default dimension will be applied.
    /// </param>
    /// <returns>
    /// The ID of the <c>DimensionAttributeValueSet</c> record that represents the default dimension.
    /// </returns>
    protected DimensionDefault getJournalHeaderDefaultDimension(CompanyId _companyId)
    {
        return _companyId == journalHeaderCompany ? journalHeaderDefaultDimension : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>includeInvFromOtherCompanies_Modified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the modified event for the "IncludeInvoicesFromOtherCompanies" dialog field
    /// </summary>
    /// <param name="_formCheckBoxControl">
    /// The control for the IncludeInvoicesFromOtherCompanies field.
    /// </param>
    private boolean includeInvFromOtherCompanies_Modified(FormCheckBoxControl _formCheckBoxControl)
    {
        boolean valueWasModified = _formCheckBoxControl.modified();

        if (valueWasModified)
        {
            NoYes includeCrossCompanyInvoices = dialogIncludeInvoicesFromOtherCompanies.value();

            this.updateDialogToIncludeCrossCompanyInvoices(includeCrossCompanyInvoices);
        }

        return valueWasModified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDialogToIncludeCrossCompanyInvoices</Name>
				<Source><![CDATA[
    private void updateDialogToIncludeCrossCompanyInvoices(NoYes _includeCrossCompanyInvoices)
    {
        if (_includeCrossCompanyInvoices == NoYes::Yes)
        {
            dialogProposeSeparatePaymentPerCompany.enabled(true);
        }
        else
        {
            dialogProposeSeparatePaymentPerCompany.enabled(false);
            dialogProposeSeparatePaymentPerCompany.value(NoYes::No);
        }

        this.updateQueryToIncludeCrossCompanyInvoices(_includeCrossCompanyInvoices);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryToIncludeCrossCompanyInvoices</Name>
				<Source><![CDATA[
    private void updateQueryToIncludeCrossCompanyInvoices(NoYes _includeCrossCompanyInvoices)
    {
        Query query = queryCreatePayment.query();

        if (_includeCrossCompanyInvoices == NoYes::Yes)
        {
            // Enable query for cross company and default company range with only companies that are part
            // of the shared service boundary
            queryCreatePayment.allowCrossCompany(true);
            query.clearCompanyRange();

            container sharedServiceBoundaryCompanies = CustVendOpenTransManager::findSharedServiceCompanies(curext());

            for (int i = 1; i <= conLen(sharedServiceBoundaryCompanies); i++)
            {
                query.addCompanyRange(conPeek(sharedServiceBoundaryCompanies, i));
            }
        }
        else
        {
            queryCreatePayment.allowCrossCompany(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBalances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the balances of all the customers or vendors who are covered by the query collecting
    /// transactions for payment.
    /// </summary>
    /// <remarks>
    /// If the user selects to run a payment proposal per Due date &amp; cash discount, the collection job
    /// is run two times; this makes sure that balances are only calculated one time.
    /// </remarks>
    protected void initBalances()
    {
        if (this.skipInitBalances())
        {
            return;
        }

        TableId tableIdCustVendTable = queryCreatePayment.query().dataSourceNo(1).table();
        QueryRun queryRunBalances = new QueryRun(queryCreatePayment.query());

        CompanyId lastCustVendTableCompany;

        while (queryRunBalances.next())
        {
            // Determine if the CustVendTable record from the query is referencing a different logical customer/vendor
            // than the previous transaction. This is needed because Query.changed(CustTable/VendTable) will not
            // return true if the customer/vendor differs only by company in the shared table scenario. See also kernel bug 47368.
            CustVendTable custVendTable = queryRunBalances.get(tableIdCustVendTable);
            if (queryRunBalances.changed(tableIdCustVendTable)
                || custVendTable.company() != lastCustVendTableCompany)
            {
                lastCustVendTableCompany = custVendTable.company();
                AmountMST mstBalance;
                CurrencyCode sourceCompanyMstCurrencyId;

                changecompany(custVendTable.company())
                {
                    mstBalance = this.calcOpenBalanceMST(custVendTable);
                    sourceCompanyMstCurrencyId = CompanyInfoHelper::standardCurrency();
                }

                CompanyId companyKey;
                str custVendKey;
                if (this.cacheCustVendBalancesAcrossCompanies())
                {
                    // Balance value cache keyed by Directory company & partyId
                    try
                    {
                        // Must convert open balance values from each company to a common currency, i.e. Mst of current company
                        // convert to Mst of current company using source company exchange rate & current system date
                        CurrencyExchangeHelper currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(
                            Ledger::primaryLedger(CompanyInfo::findDataArea(custVendTable.company()).RecId),
                            DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

                        mstBalance = currencyExchHelper.calculateAccountingToTransaction(sourceCompanyMstCurrencyId, mstBalance, true);
                        DirPartyTable dirPartyTable = DirPartyTable::findRec(custVendTable.Party);

                        if (dirPartyTable)
                        {
                            companyKey = #CrossCompanyCacheKeyValue; // Summarize across companies
                            custVendKey = int642str(custVendTable.Party);
                        }
                    }
                    catch (Exception::Error)
                    {
                        // Currency exchange failed, ignore the balance amount and continue
                        mstBalance = 0;
                    }
                }
                else
                {
                    // Sstore balance by Company & Cust/Vend account number

                    // Use company() property as key in collection so cust/vend balance is total per concrete company
                    // dataAreaId field may contain a virtual company Id while company() method always returns a concrete company
                    companyKey = custVendTable.company();
                    custVendKey = custVendTable.AccountNum;
                }

                // add the calculated balance to the balances collection
                if (companyKey != '' && custVendKey != '')
                {
                    Map mstBalancesByCustVend;
                    if (mstBalances.exists(companyKey))
                    {
                        mstBalancesByCustVend = mstBalances.lookup(companyKey);
                    }
                    else
                    {
                        mstBalancesByCustVend = new Map(Types::String, Types::Real);
                        mstBalances.insert(companyKey, mstBalancesByCustVend);
                    }

                    if (mstBalancesByCustVend.exists(custVendKey))
                    {
                        mstBalance += mstBalancesByCustVend.lookup(custVendKey);
                    }
                    mstBalancesByCustVend.insert(custVendKey, mstBalance);
                }
            }
        }

        areMstBalancesCached = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipInitBalances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Skip initializing balances.
    /// </summary>
    /// <returns>
    /// True if the initializing balances should be skipped; otherwise false.
    /// </returns>
    protected boolean skipInitBalances()
    {
        return !balanceCheck;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcOpenBalanceMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the open balance in accounting currency.
    /// </summary>
    /// <param name = "_custVendTable">The customer or vendor.</param>
    /// <returns>
    /// The open balance in accounting currency.
    /// </returns>
    protected AmountMST calcOpenBalanceMST(CustVendTable _custVendTable)
    {
        return _custVendTable.openBalanceMST();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the internal variables.
    /// </summary>
    /// <remarks>
    ///    This method is called when no <c>SysLastValue</c> record can be found when calling the
    ///    <c>SysLastValue.GetLast</c> method. Remember to call the <c>super</c> method.
    /// </remarks>
    public void initParmDefault()
    {
        super();

        limitPaymCreationToLedgerCompanyOnly = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalId</Name>
				<Source><![CDATA[
    public LedgerJournalId ledgerJournalId()
    {
        return ledgerJournalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupDynamicAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Explicitly implemented dialog field lookup method as the dialog fields are dynamically added at
    ///    runtime, so no method can be specified at design time.
    /// </summary>
    /// <param name="_segmentedEntryControl">
    ///    The <c>SegmentedEntryControl</c> that triggered this event.
    /// </param>
    public void lookupDynamicAccount(SegmentedEntryControl _segmentedEntryControl)
    {
        if (dialogDynamicAccountType.value() == LedgerJournalACTypeForPaymProposal::Bank)
        {
            BankAccountTable::lookupBankAccount(_segmentedEntryControl);
        }
        else
        {
            _segmentedEntryControl.lookup();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        mstBalances = new Map(Types::String, Types::Class);
        transOpenPaymModeMap = new Map(typeName2Type(extendedTypeStr(recId)), Types::Record);

        // If no last value exists then it defaults to 0 which does not correlate to the proper default value of None.
        defaultOffsetAccountType = LedgerJournalACTypeForPaymProposal::None;

        // <GTH>
        isTaxBranchEnabled = TaxThaiGovCertificationFeatureChecker::isTaxBranchEnabled();
        // </GTH>
        isPaymentRequestsEnabled = CFMParameters::isPaymentRequestsEnabled();
        super();

        this.showBatchTab(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHasBatchBeenSplit</Name>
				<Source><![CDATA[
    protected boolean parmHasBatchBeenSplit(boolean _hasBatchBeenSplit = hasBatchBeenSplit)
    {
        hasBatchBeenSplit = _hasBatchBeenSplit;
        return hasBatchBeenSplit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsAutomation</Name>
				<Source><![CDATA[
    protected internal boolean parmIsAutomation(boolean _isAutomation = isAutomation)
    {
        isAutomation = _isAutomation;
        return isAutomation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsFirstBatch</Name>
				<Source><![CDATA[
    private boolean parmIsFirstBatch(boolean _isFirstBatch = isFirstBatch)
    {
        isFirstBatch = _isFirstBatch;
        return isFirstBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsFinalBatch</Name>
				<Source><![CDATA[
    private boolean parmIsFinalBatch(boolean _isFinalBatch = isFinalBatch)
    {
        isFinalBatch = _isFinalBatch;
        return isFinalBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProcessExecutionSourceLinkRecId</Name>
				<Source><![CDATA[
    private RefRecId parmProcessExecutionSourceLinkRecId(RefRecId _processExecutionSourceLinkRecId = processExecutionSourceLinkRecId)
    {
        processExecutionSourceLinkRecId = _processExecutionSourceLinkRecId;
        return processExecutionSourceLinkRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendPaymProposalLineTmpRecId</Name>
				<Source><![CDATA[
    private boolean parmCustVendPaymProposalLineTmpRecId(int64 _custVendPaymProposalLineTmpRecId = custVendPaymProposalLineTmpRecId)
    {
        custVendPaymProposalLineTmpRecId = _custVendPaymProposalLineTmpRecId;
        return custVendPaymProposalLineTmpRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container packedPaymProposal = paymProposal != null ? paymProposal.pack() : conNull();
        container userInteractionArgs = userInteraction != null && userInteraction.parmArgs() != null ? userInteraction.parmArgs().pack() : conNull();

        return [#CurrentVersion, #CurrentList, queryCreatePayment.pack(), userInteractionArgs, packedPaymProposal];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipProposalEditForm</Name>
				<Source><![CDATA[
    public NoYes parmSkipProposalEditForm(NoYes _skipProposalEditForm = skipProposalEditForm)
    {
        skipProposalEditForm = _skipProposalEditForm;
        return skipProposalEditForm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDefaultOffsetAccount</Name>
				<Source><![CDATA[
    public LedgerJournalAC parmDefaultOffsetAccount(LedgerJournalAC _account = '', LedgerJournalACTypeForPaymProposal _accountType = defaultOffsetAccountType)
    {
        if (!prmisDefault(_accountType))
        {
            defaultOffsetAccountType = _accountType;
        }

        // If account has been changed, update the backing ledger dimension value
        LedgerJournalAC account;
        if (!prmisDefault(_account))
        {
            if (_account)
            {
                LedgerJournalACType ledgerJournalAccountType = this.convertToLedgerJournalACType(_accountType);
                defaultOffsetLedgerDimension = LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(_account, ledgerJournalAccountType);
                account = _account;
            }
            else
            {
                account = '';
                defaultOffsetLedgerDimension = 0;
            }
        }
        else if (defaultOffsetLedgerDimension)
        {
            // If the account has not been changed, then pull the value from ledger dimension as the master
            DimensionAttributeValueCombination ledgerDimension;
            select firstonly DisplayValue from ledgerDimension where ledgerDimension.RecId == defaultOffsetLedgerDimension;
            account = ledgerDimension.DisplayValue;
        }

        return account;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDefaultOffsetAccountType</Name>
				<Source><![CDATA[
    public LedgerJournalACTypeForPaymProposal parmDefaultOffsetAccountType(LedgerJournalACTypeForPaymProposal _defaultOffsetAccountType = defaultOffsetAccountType)
    {
        defaultOffsetAccountType = _defaultOffsetAccountType;

        return defaultOffsetAccountType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDefaultOffsetLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount parmDefaultOffsetLedgerDimension(LedgerDimensionDefaultAccount _defaultOffsetLedgerDimension = defaultOffsetLedgerDimension)
    {
        defaultOffsetLedgerDimension = _defaultOffsetLedgerDimension;

        return defaultOffsetLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalId</Name>
				<Source><![CDATA[
    protected LedgerJournalId parmLedgerJournalId(LedgerJournalId _ledgerJournalId = ledgerJournalId)
    {
        ledgerJournalId = _ledgerJournalId;

        return ledgerJournalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMainAccountDefaultDimension</Name>
				<Source><![CDATA[
    protected DimensionDefault parmMainAccountDefaultDimension(DimensionDefault _mainAccountDefaultDimension = mainAccountDefaultDimension)
    {
        mainAccountDefaultDimension = _mainAccountDefaultDimension;

        return mainAccountDefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymCurrency</Name>
				<Source><![CDATA[
    protected CurrencyCode paymCurrency(CurrencyCode _transCurrencyCode)
    {
        return paymCurrency ? paymCurrency : _transCurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymModeTable</Name>
				<Source><![CDATA[
    protected CustVendPaymModeTable paymModeTable(CustVendTransOpen _custVendTransOpen)
    {
        CustVendPaymModeTable paymModeTable;

        if (transOpenPaymModeMap.exists(_custVendTransOpen.RecId))
        {
            paymModeTable = transOpenPaymModeMap.lookup(_custVendTransOpen.RecId);
        }
        else
        {
            paymModeTable = CustVendTransOpenData::construct(_custVendTransOpen).findPaymModeTable(false);

            if (paymModeTable)
            {
                transOpenPaymModeMap.insert(_custVendTransOpen.RecId, paymModeTable);
            }
        }

        return paymModeTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printProposal</Name>
				<Source><![CDATA[
    protected void printProposal()
    {
        Args args = new Args(ssrsReportStr(CustVendPaymProposal, Report));

        args.caller(this);
        new MenuFunction(menuitemOutputStr(CustVendPaymProposal), MenuItemType::Output).run(args);

        CustVendPaymProposalLine::deleteByJournalId(ledgerJournalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </summary>
    /// <returns>
    /// The instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </returns>
    /// <remarks>
    /// This method is used if a query prompt is the dialog, and if a Select menu item is added to a dialog
    /// box. Do not create the instance of the <c>QueryRun</c> class when this method is called. Do it in
    /// the <c>unpack</c> method and the <c>initParmDefault</c> method, or in the <c>init</c> method.
    /// </remarks>
    public QueryRun queryRun()
    {
        return queryCreatePayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Provides the entry point of the payment proposal processing logic.
    /// </summary>
    /// <remarks>
    ///    This method is invoked by the <c>RunBase</c> framework when the OK button is pressed.
    /// </remarks>
    public void run()
    {
        if (this.isInBatch())
        {
            if (FeatureStateProvider::isFeatureEnabled(CustVendPaymProposalTopPickingFeature::instance()))
            {
                this.runTopPicking();
            }
            else if (this.parmIsAutomation())
            {
                this.runAutomation();
            }
            else
            {
                this.runInBatch();
            }
        }
        else
        {
            this.runIteractive();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runIteractive</Name>
				<Source><![CDATA[
    private void runIteractive()
    {
        container inputParameters = [classIdGet(this), this.pack()];
        this.runWithParameters(inputParameters);

        if (printProposal)
        {
            this.printProposal();
        }
        else
        {
            this.userInteraction().runProposalEditForm();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runInBatch</Name>
				<Source><![CDATA[
    private void runInBatch()
    {
        if (!hasBatchBeenSplit)
        {
            ttsbegin;

            BatchHeader batchHeader = BatchHeader::construct(this.parmCurrentBatch().BatchJobId);
            if (batchHeader == null)
            {
                batchHeader = batchHeader::construct();
            }

            this.updateCustVendPaymProposalBatchProcessWithPaymProposal();

            // Add final batch task to copy payment proposal lines back to the payment journal
            ClassId classId = classIdGet(this);
            DictClass dictClass = new DictClass(classId);
            CustVendCreatePaymJournal custVendCreatePaymJournalFinal = dictClass.makeObject();
            custVendCreatePaymJournalFinal.unpack(this.pack());
            custVendCreatePaymJournalFinal.parmHasBatchBeenSplit(true);
            custVendCreatePaymJournalFinal.parmIsFinalBatch(true);
            custVendCreatePaymJournalFinal.batchInfo().parmCaption(strFmt("@SYS4080918", this.parmCurrentBatch().Caption));
            custVendCreatePaymJournalFinal.batchInfo().parmGroupId(this.parmCurrentBatch().GroupId);
            
            batchHeader.addTask(custVendCreatePaymJournalFinal);

            this.splitBatch(batchHeader, custVendCreatePaymJournalFinal);

            batchHeader.save();

            CustVendPaymProposalLine::deleteByJournalId(ledgerJournalId);

            ttscommit;

            return;
        }

        if (this.isFinalBatch)
        {
            // Adjust to max totals for the complete journal,since not done for every splitted thread
            if (this.shouldAdjustToMaxTotals())
            {
                paymProposal.adjustToMaxTotals(amountMax);
            }

            CustVendPaymProposalBatchProcess::changeState(ledgerJournalId , CustVendPaymProposalBatchProcessState::CreatedProposalLines);

            if (skipProposalEditForm)
            {
                CustVendPaymProposalCalcPaym paymProposalCalcPaym = this.initCustVendPaymProposalCalcPaym();
                this.initCustVendPaymProposal(paymProposalCalcPaym);

                ttsbegin;
                CustVendPaymProposalTransferToJournal transfer = CustVendPaymProposalTransferToJournal::constructForPaymProposal(paymProposal);
                BatchInfo transferBatchInfo = transfer.batchInfo();
                transferBatchInfo.parmBatchExecute(NoYes::Yes);
                transferBatchInfo.parmGroupId(this.parmCurrentBatch().GroupId);
                transferBatchInfo.doBatch();
                ttscommit;
            }

            return;
        }

        ttsbegin;
        this.runPaymentProposalGenerationProcess();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runTopPicking</Name>
				<Source><![CDATA[
    private void runTopPicking()
    {
        if (this.parmIsAutomation() && isFinalBatch)
        {
            return;
        }

        ttsbegin;

        this.updateCustVendPaymProposalBatchProcessWithPaymProposal();

        if (this.parmIsAutomation() && isFirstBatch)
        {
            CustVendPaymProposalLine::deleteByJournalId(ledgerJournalId);
        }

        container inputParameters = [classIdGet(this), this.pack()];
        CustVendPaymentProposalCreationTopPickingRun runner = new CustVendPaymentProposalCreationTopPickingRun(inputParameters, classIdGet(this), this.pack());
        CustVendGeneralTopPickingSubmitFacade::submitToTPPool(classIdGet(runner), inputParameters, runner.pack(), this.constructParentJobInfo());

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructParentJobInfo</Name>
				<Source><![CDATA[
    private CustVendGeneralTopPickingBatchInfo constructParentJobInfo()
    {
        BatchHeader header = BatchHeader::getCurrentBatchHeader();
        return CustVendGeneralTopPickingBatchInfo::construct(header, this.parmCurrentBatch().BatchJobId, this.parmIsAutomation());
    }

]]></Source>
			</Method>
			<Method>
				<Name>runAutomation</Name>
				<Source><![CDATA[
    private void runAutomation()
    {
        ttsbegin;

        if (isFirstBatch)
        {
            this.updateCustVendPaymProposalBatchProcessWithPaymProposal();

            CustVendPaymProposalLine::deleteByJournalId(ledgerJournalId);

            this.splitBatchAutomation();
        }
        else if (isFinalBatch)
        {
            CustVendPaymProposalBatchProcess::changeState(ledgerJournalId , CustVendPaymProposalBatchProcessState::CreatedProposalLines);
        }
        else
        {
            this.runPaymentProposalGenerationProcess();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSplitBatch</Name>
				<Source><![CDATA[
    private boolean shouldSplitBatch()
    {
        boolean shouldSplitBatch = false;

        Query query = queryCreatePayment.query();
        QueryBuildDataSource qbds = query.dataSourceTable(this.getCustVendTableId());
        QueryBuildRange qbr = SysQuery::findOrCreateRange(qbds, this.getCustVendTableAccountNumFieldId());

        str rangeValue = qbr.value();
        int rangeLocationForBetweenTwoCustomers = strScan(qbr.value(), '..', 0, strLen(qbr.value()));

        if (rangeValue == SysQueryRangeUtil::valueUnlimited()
            || rangeLocationForBetweenTwoCustomers > 0)
        {
            shouldSplitBatch = true;
        }

        return shouldSplitBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustVendPaymProposalBatchProcessWithPaymProposal</Name>
				<Source><![CDATA[
    private void updateCustVendPaymProposalBatchProcessWithPaymProposal()
    {
        CustVendPaymProposalCalcPaym paymProposalCalcPaym = this.initCustVendPaymProposalCalcPaym();
        this.initCustVendPaymProposal(paymProposalCalcPaym);

        CustVendPaymProposalBatchProcess paymentProposalBatchProcess = CustVendPaymProposal::initializeBatchProcessTable(paymProposal);

        paymentProposalBatchProcess.State = CustVendPaymProposalBatchProcessState::CreatingProposalLines;
        paymentProposalBatchProcess.UserId = curUserId;

        paymentProposalBatchProcess.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitBatch</Name>
				<Source><![CDATA[
    private void splitBatch(BatchHeader _batchHeader, CustVendCreatePaymJournal _custVendCreatePaymJournalFinal)
    {
        List batchTasks = this.getSplitBatchList();

        ListEnumerator listEnumerator = batchTasks.getEnumerator();

        while (listEnumerator.moveNext())
        {
            CustVendCreatePaymJournal currentTask = listEnumerator.current() as CustVendCreatePaymJournal;

            _batchHeader.addTask(currentTask);
            _batchHeader.addDependency(_custVendCreatePaymJournalFinal, currentTask);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitBatchAutomation</Name>
				<Source><![CDATA[
    private void splitBatchAutomation()
    {
        BatchHeader batchHeader = BatchHeader::construct(this.parmCurrentBatch().BatchJobId);

        if (batchHeader == null)
        {
            batchHeader = batchHeader::construct();
        }

        List batchTasks = this.getSplitBatchList();

        ListEnumerator listEnumerator = batchTasks.getEnumerator();

        while (listEnumerator.moveNext())
        {
            Batchable currentTask = listEnumerator.current();

            batchHeader.addRuntimeTask(currentTask, this.parmCurrentBatch().RecId);
        }

        batchHeader.save();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSplitBatchQuery</Name>
				<Source><![CDATA[
    private Query initSplitBatchQuery()
    {
        QueryRun queryRun = new QueryRun(queryCreatePayment.query());
        this.updateQueryWithQueryRun(queryRun);
        Query query = queryRun.query();
        QueryBuildDataSource qbds = query.dataSourceTable(this.getCustVendTransOpenTableId());

        if (qbds)
        {
            qbds.addSelectionField(this.getCustVendTransOpenAccountNumFieldId());
            qbds.addSelectionField(this.getCustVendTransOpenRecIdFieldId(), SelectionField::Count);
            qbds.addGroupByField(this.getCustVendTransOpenAccountNumFieldId());
            qbds.addOrderByField(this.getCustVendTransOpenAccountNumFieldId(), SortOrder::Ascending);
        }
        else
        {
            query = null;
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitBatchToList</Name>
				<Source><![CDATA[
    private List splitBatchToList()
    {
        List batchTasks = new List(Types::Class);

        int lastPaymentLineNum = real2int(LedgerJournalTrans::lastLineNum(ledgerJournalId));
        custVendPaymProposalLineTmpRecId = lastPaymentLineNum + 1;

        int i;
        int64 totalInvoices;
        int64 nextBundleSize;
        AccountNum lastAccountNum;

        Query query = this.initSplitBatchQuery();
        QueryRun queryRun = new QueryRun(query);
        while (queryRun.next())
        {
            i++;

            CustVendTransOpen custVendTransOpen = queryRun.get(this.getCustVendTransOpenTableId());

            AccountNum accountNum = custVendTransOpen.AccountNum;
            int64 accountNumCount = custVendTransOpen.RecId;
            totalInvoices += accountNumCount;

            if (i == 1)
            {
                this.fromCustVendAccountNum = accountNum;
            }

            nextBundleSize += accountNumCount;
            if (nextBundleSize >= BundleSize)
            {
                this.toCustVendAccountNum = accountNum;

                batchTasks.addEnd(this.getSplitBatchTask());

                custVendPaymProposalLineTmpRecId = lastPaymentLineNum + 1 + totalInvoices;

                i = 0;
                nextBundleSize = 0;
                this.fromCustVendAccountNum = '';
                this.toCustVendAccountNum = '';
            }

            lastAccountNum = accountNum;
        }

        // The last bundle is smaller than BundleSize
        if (i > 0)
        {
            this.toCustVendAccountNum = lastAccountNum;

            batchTasks.addEnd(this.getSplitBatchTask());
        }

        return batchTasks;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplitBatchList</Name>
				<Source><![CDATA[
    private List getSplitBatchList()
    {
        List batchTasks = new List(Types::Class);
        
        if (this.shouldSplitBatch())
        {
            batchTasks = this.splitBatchToList();
        }
        else
        {
            batchTasks.addEnd(this.getSplitBatchTask());
        }

        return batchTasks;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplitBatchTask</Name>
				<Source><![CDATA[
    private CustVendCreatePaymJournal getSplitBatchTask()
    {
        ClassId classId = classIdGet(this);
        DictClass dictClass = new DictClass(classId);
        CustVendCreatePaymJournal custVendCreatePaymJournal = dictClass.makeObject();
    
        custVendCreatePaymJournal.unpack(this.pack());
        custVendCreatePaymJournal.parmIsFirstBatch(false);
        custVendCreatePaymJournal.parmIsFinalBatch(false);
        custVendCreatePaymJournal.parmHasBatchBeenSplit(true);

        batchInfo = custVendCreatePaymJournal.batchInfo();
        batchInfo.parmCaption(strFmt('%1 : %2 : %3', ledgerJournalId, this.fromCustVendAccountNum, this.toCustVendAccountNum));
        batchInfo.parmGroupId(this.parmCurrentBatch().GroupId);

        return custVendCreatePaymJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstAutomationBatchTask</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public CustVendCreatePaymJournal getFirstAutomationBatchTask()
    {
        ClassId classId = classIdGet(this);
        DictClass dictClass = new DictClass(classId);
        CustVendCreatePaymJournal custVendCreatePaymJournalFirst = dictClass.makeObject();
        custVendCreatePaymJournalFirst.unpack(this.pack());
        custVendCreatePaymJournalFirst.parmIsAutomation(true);
        custVendCreatePaymJournalFirst.parmHasBatchBeenSplit(true);
        custVendCreatePaymJournalFirst.parmIsFirstBatch(true);
        custVendCreatePaymJournalFirst.parmIsFinalBatch(false);

        return custVendCreatePaymJournalFirst;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFinalAutomationBatchTask</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public CustVendCreatePaymJournal getFinalAutomationBatchTask()
    {
        ClassId classId = classIdGet(this);
        DictClass dictClass = new DictClass(classId);
        CustVendCreatePaymJournal custVendCreatePaymJournalFinal = dictClass.makeObject();
        custVendCreatePaymJournalFinal.unpack(this.pack());
        custVendCreatePaymJournalFinal.parmIsAutomation(true);
        custVendCreatePaymJournalFinal.parmHasBatchBeenSplit(true);
        custVendCreatePaymJournalFinal.parmIsFirstBatch(false);
        custVendCreatePaymJournalFinal.parmIsFinalBatch(true);

        return custVendCreatePaymJournalFinal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendPaymProposalForAutomation</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public CustVendPaymProposal getCustVendPaymProposalForAutomation()
    {
        this.initCustVendPaymProposal(this.initCustVendPaymProposalCalcPaym());

        return paymProposal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>logMessage</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected void logMessage(Exception _exceptionType, SysInfoLogStr _message, URL _helpUrl = '', SysInfoAction _sysInfoAction = null)
    {
        if (this.parmIsAutomation() && this.parmProcessExecutionSourceLinkRecId() != 0)
        {
            ProcessExecutionMessageLogItem messageLogItem = ProcessExecutionMessageLogItem::construct();
            messageLogItem.parmProcessExecutionSourceLink(this.parmProcessExecutionSourceLinkRecId());
            messageLogItem.parmException(_exceptionType);
            messageLogItem.parmMessage(_message);

            ProcessExecutionMessageLog::insertMessage(messageLogItem);
        }
        else
        {
            if (_exceptionType != Exception::Error)
            {
                infolog.add(_exceptionType, getPrefix() + _message, _helpUrl, _sysInfoAction, false);
            }
        }

        if (_exceptionType == Exception::Error)
        {
            throw error(_message, _helpUrl, _sysInfoAction);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendTransOpenAccountNumFieldId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get CustTransOpen.AccountNum or VendTransOpen.AccountNum FieldId.
    /// </summary>
    /// <returns>
    /// The CustTransOpen.AccountNum or VendTransOpen.AccountNum FieldId.
    /// </returns>
    protected abstract FieldId getCustVendTransOpenAccountNumFieldId()
    {
    
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendTransOpenRecIdFieldId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get CustTransOpen.RecId or VendTransOpen.RecId FieldId.
    /// </summary>
    /// <returns>
    /// The CustTransOpen.RecId or VendTransOpen.RecId FieldId.
    /// </returns>
    protected abstract FieldId getCustVendTransOpenRecIdFieldId()
    {
    
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendTransOpenTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get CustTransOpen or VendTransOpen TableId.
    /// </summary>
    /// <returns>
    /// The CustTransOpen or VendTransOpen TableId.
    /// </returns>
    protected abstract TableId getCustVendTransOpenTableId()
    {
    
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get CustTable or VendTable TableId.
    /// </summary>
    /// <returns>
    /// The CustTable or VendTable TableId.
    /// </returns>
    protected abstract TableId getCustVendTableId()
    {
    
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendTableRecIdFieldId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get CustTable.RecId or VendTable.RecId FieldId.
    /// </summary>
    /// <returns>
    /// The CustTable.RecId or VendTable.RecId FieldId.
    /// </returns>
    protected abstract FieldId getCustVendTableRecIdFieldId()
    {
    
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendTableAccountNumFieldId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get CustTable.AccountNum or VendTable.AccountNum FieldId.
    /// </summary>
    /// <returns>
    /// The CustTable.AccountNum or VendTable.AccountNum FieldId.
    /// </returns>
    protected abstract FieldId getCustVendTableAccountNumFieldId()
    {
    
    }

]]></Source>
			</Method>
			<Method>
				<Name>runWithParameters</Name>
				<Source><![CDATA[
    private void runWithParameters(container _inputParameters)
    {
        try
        {
            container result = SysOperationSandbox::callStaticMethod(
                classNum(CustVendCreatePaymJournal),
                staticMethodStr(CustVendCreatePaymJournal, runPaymentProposalGenerationProcessStatic),
                _inputParameters,
                this.caption());

            container createPaymJournalPack;
            [createPaymJournalPack] = result;
            this.unpack(createPaymJournalPack);

            if (!CustVendPaymProposal::doesJournalContainAnyPaymentProposalLines(ledgerJournalId))
            {
                this.logMessage(Exception::Info, "@SYS93093");
            }
        }
        catch
        {
            CustVendPaymProposalLine::deleteByJournalId(ledgerJournalId);
            throw;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructFromAutomationExecutionContract</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public static CustVendCreatePaymJournal constructFromAutomationExecutionContract(CustVendPaymProposalAutomationExecutionContract _automationExecutionContract)
    {
        CustVendCreatePaymJournal createPaymJournal;

        if (_automationExecutionContract.validate())
        {
            createPaymJournal =
                CustVendPaymProposalAutomationTypeProviderFactory::constructPaymProposalFromProcessScheduleType(_automationExecutionContract.processScheduleTypeName);
            createPaymJournal.parmIsAutomation(true);

            createPaymJournal.initNonUserInteractive(_automationExecutionContract.dialogValues);
            createPaymJournal.parmLedgerJournalId(_automationExecutionContract.journalNum);

            ProcessScheduleQueryCriteriaApplicator::applyCriteriaForOccurrenceExecution(
                createPaymJournal.queryRun().query(),
                _automationExecutionContract.processScheduleOccurrenceRecId);

            createPaymJournal.parmProcessExecutionSourceLinkRecId(_automationExecutionContract.processExecutionSourceLinkRecId);
            createPaymJournal.parmInBatch(true);
        }

        return createPaymJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSearchTransactions</Name>
				<Source><![CDATA[
    protected void postSearchTransactions()
    {
        tableId tableIdCustVendTable = queryCreatePayment.query().dataSourceNo(1).table();

        if (this.canUseCustVendPaymProposalLineSetBasedInsert())
        {
            paymProposal.invokeCustVendPaymProposalLineSetBasedInsert();
            paymProposal.parmCanUseCustVendPaymProposalLineSetBasedInsert(false);
        }

        if (this.canUseSpecTransSetBasedInsert())
        {
            if (this.canUseCustVendPaymProposalLineSetBasedInsert())
            {
                paymProposal.invokeSpecTransSetBasedInsert(ledgerJournalId);
            }
            else
            {
                paymProposal.invokeSpecTransSetBasedInsert();
            }
            paymProposal.parmCanUseSpecTransSetBasedInsert(false);
        }

        if (tableIdCustVendTable == tableNum(VendTable))
        {
            CustVendPaymProposalLine::vendSearchForOmittedPaymentGroupInvoice(tableIdCustVendTable);
        }

        if (this.shouldRemoveNegativePayments())
        {
            paymProposal.removeNegativePayments();
        }

        if (this.shouldRemoveAlreadySettledTransactions())
        {
            paymProposal.removeAlreadySettledTransactions();
        }

        //do not adjust to max totals in batch since this should not be done for every splitted thread
        if ((!this.isInBatch() || this.parmIsAutomation()) && this.shouldAdjustToMaxTotals())
        {
            paymProposal.adjustToMaxTotals(amountMax);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPaymentProposalGenerationProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the payment proposal processing logic.
    /// </summary>
    /// <exception cref="M:Exception::UpdateConflict">
    /// There is an unresolved conflict in the database.
    /// </exception>
    /// <exception cref="M:Exception::UpdateConflictNotRecovered">
    /// There is an unresolved conflict in the database.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// Validation of user input failed or there is a general failure in the creation process.
    /// </exception>
    protected void runPaymentProposalGenerationProcess()
    {
        #OCCRetryCount
        const int WaitTimeAfterDeadlockInMiliseconds = 500;
        int line;

        CustVendPaymProposalCalcPaym paymProposalCalcPaym = this.initCustVendPaymProposalCalcPaym();
        this.initCustVendPaymProposal(paymProposalCalcPaym);

        // Update the company range and continue only if the company range is valid for the process
        if (this.updateQueryCompanyRange())
        {
            this.updateQuerySplitBatch();
            this.checkBlocked();
            this.initBalances();

            SysInstrumentationProgressLogger progressLogger = this.createProgressLogger();

            using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextForStage(CustVendInstrumentationConstants::PaymentProposalGeneratePaymentProposal))
            {
                activityContext.addCustomProperty(CustVendInstrumentationConstants::PaymentProposalJournalRecId, int642Str(LedgerJournalTable::find(ledgerJournalId).RecId));
                activityContext.addCustomProperty(CustVendInstrumentationConstants::BatchJobId, int642Str(this.parmCurrentBatch().BatchJobId));

                try
                {
                    line = Global::infologLine();
                    ttsbegin;

                    if (this.canUseCustVendPaymProposalLineSetBasedInsert())
                    {
                        Debug::assert(this.canUseSpecTransSetBasedInsert());

                        paymProposal.parmCanUseCustVendPaymProposalLineSetBasedInsert(true);
                    }

                    if (this.canUseSpecTransSetBasedInsert())
                    {
                        paymProposal.parmCanUseSpecTransSetBasedInsert(true);
                    }

                    if (!this.isInBatch())
                    {
                        paymProposal.deleteLines();
                    }

                    this.updateQuery();

                    this.searchTransactions();

                    this.postSearchTransactions();

                    // Need to clear payment proposal line cache of temporary RecIds.
                    if (this.canUseCustVendPaymProposalLineSetBasedInsert())
                    {
                        paymProposal.clearPaymentProposalLineCache();
                    }

                    ttscommit;
                }
                catch (Exception::Deadlock)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        throw Exception::Deadlock;
                    }
                    else
                    {
                        progressLogger.logRetryOnDeadlock();

                        sleep(WaitTimeAfterDeadlockInMiliseconds);
                        infolog.clear(line);
                        retry;
                    }
                }
                catch (Exception::UpdateConflict)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        throw Exception::UpdateConflictNotRecovered;
                    }
                    else
                    {
                        progressLogger.logRetryOnUpdateConflict();

                        infolog.clear(line);
                        retry;
                    }
                }
                catch (Exception::Error)
                {
                    this.logMessage(Exception::Error, "@SYS21628");
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProgressLogger</Name>
				<Source><![CDATA[
    internal SysInstrumentationProgressLogger createProgressLogger()
    {
        str SourceName = CustVendInstrumentationFormatter::sourceNameWithModule(CustVendInstrumentationConstants::SourceNamePaymentProposalGenerate, paymProposal.moduleCustVend());

        return SysInstrumentationProgressLogger::createLogger(SourceName, CustVendInstrumentationConstants::InstrumentationNamespace);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldRemoveNegativePayments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether negative payments should be removed.
    /// </summary>
    /// <returns>
    /// true if negative payments should be removed; otherwise, false.
    /// </returns>
    protected boolean shouldRemoveNegativePayments()
    {
        return deleteCredit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldRemoveAlreadySettledTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether already settled transactions should be removed.
    /// </summary>
    /// <returns>
    /// true if settled transactions should be removed; otherwise, false.
    /// </returns>
    protected boolean shouldRemoveAlreadySettledTransactions()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldAdjustToMaxTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether maximum totals should be adjusted.
    /// </summary>
    /// <returns>
    /// true if totals should be adjusted; otherwise, false.
    /// </returns>
    protected boolean shouldAdjustToMaxTotals()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendPaymProposalCalcPaym</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>CustVendPaymProposalCalcPaym</c> from the dialog parameters.
    /// </summary>
    /// <returns>
    /// An instance of <c>CustVendPaymProposalCalcPaym</c>.
    /// </returns>
    protected CustVendPaymProposalCalcPaym initCustVendPaymProposalCalcPaym()
    {
        CustVendPaymProposalCalcPaym paymProposalCalcPaym = CustVendPaymProposalCalcPaym::construct(LedgerJournalTable::find(ledgerJournalId).JournalType);

        paymProposalCalcPaym.parmPaymDatePrinciple(paymProposalType);
        paymProposalCalcPaym.parmPaymWeekDayFixed(paymWeekDayFixed);
        paymProposalCalcPaym.parmPaymDateFixed(paymDateFixed);
        paymProposalCalcPaym.parmMinimumPaymDate(earlyPaymDate);
        paymProposalCalcPaym.parmFromDate(fromDate);
        paymProposalCalcPaym.parmToDate(toDate);
        paymProposalCalcPaym.parmPaymCurrency(paymCurrency);
        paymProposalCalcPaym.parmPaymDate_IT(postingDate);
        paymProposalCalcPaym.parmPaymOnDateFixed_IT(useFutureDueDate);
        paymProposalCalcPaym.parmPostingDateOption_IT(postingDateOption_IT);
        
        return paymProposalCalcPaym;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendPaymProposal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>CustVendPaymProposal</c>.
    /// </summary>
    /// <param name = "_paymProposalCalcPaym">
    /// The payment proposal parameters are used to initalize the payment proposal.
    /// </param>
    protected void initCustVendPaymProposal(CustVendPaymProposalCalcPaym _paymProposalCalcPaym)
    {
        LedgerDimensionDefaultAccount offsetDefaultLedgerDimension;
        MainAccount mainAccount;
        MainAccountLegalEntity mainAccountLegalEntity;

        paymProposal = CustVendPaymProposal::newLedgerJournal(ledgerJournalId);
        paymProposal.parmPaymProposalCalcPaym(_paymProposalCalcPaym);
        paymProposal.parmIncludeInvoicesFromOtherCompanies(includeInvoicesFromOtherCompanies == NoYes::Yes);
        paymProposal.parmCreatePaymPerInvoiceCompany(proposeSeparatePaymentPerCompany == NoYes::Yes);
        paymProposal.parmLimitPaymCreationToLedgerCompanyOnly(limitPaymCreationToLedgerCompanyOnly);

        paymProposal.parmDefaultOffsetAccountType(this.convertToLedgerJournalACType(defaultOffsetAccountType));
        paymProposal.parmUserInteraction(this.userInteraction());

        paymProposal.parmCustVendPaymProposalLineTmpRecId(custVendPaymProposalLineTmpRecId);

        if (paymProposal.parmDefaultOffsetAccountType() == LedgerJournalACType::Ledger)
        {
            // Cache default dimensions
            journalHeaderCompany = paymProposal.getLedgerJournalTable().company();
            journalHeaderDefaultDimension = paymProposal.getLedgerJournalTable().DefaultDimension;

            offsetDefaultLedgerDimension = this.parmDefaultOffsetLedgerDimension();
            if (offsetDefaultLedgerDimension)
            {
                mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(offsetDefaultLedgerDimension);
                mainAccountLegalEntity = MainAccountLegalEntity::findByMainAccountLegalEntity(mainAccount.RecId, CompanyInfo::current());
                this.parmMainAccountDefaultDimension(mainAccountLegalEntity.DefaultDimension);
            }
        }
        else
        {
            // NOTE: For non-ledger, the default dimension is not defaulted for either the primary or offset.
            // These default dimensions are calcuated during the transfer.
            paymProposal.parmDefaultOffsetAccount(this.parmDefaultOffsetAccount());
        }

        if (LedgerParameters::isChineseVoucher_CN())
        {
            paymProposal.parmVoucherType_CN(voucherType_CN);
        }

        if (PublicSectorUtils::isFrenchRegulatoryEnabled())
        {
            paymProposal.PSNParmVendRoutingSlip(PSNVendRoutingSlipId);
        }

        paymProposal.parmFromCustVendAccountNum(this.fromCustVendAccountNum);
        paymProposal.parmToCustVendAccountNum(this.toCustVendAccountNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUseSpecTransSetBasedInsert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether <c>SpecTrans</c> table records can be delayed.
    /// </summary>
    /// <returns>
    /// true if the <c>SpecTrans</c> inserts should be delayed; otherwise, false.
    /// </returns>
    protected abstract boolean canUseSpecTransSetBasedInsert()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUseCustVendPaymProposalLineSetBasedInsert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether <c>CustVendPaymProposalLine</c> table records can be delayed.
    /// </summary>
    /// <returns>
    /// true if the <c>CustVendPaymProposalLine</c> inserts should be delayed; otherwise, false.
    /// </returns>
    protected abstract boolean canUseCustVendPaymProposalLineSetBasedInsert()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchTransactions</Name>
				<Source><![CDATA[
    protected void searchTransactions()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to add a Select button to the dialog box.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    /// <remarks>
    /// If you click this button, it will show the query form. Therefore, the <c>queryRun</c> method has to
    /// return a valid <c>queryRun</c> object.If you change the return value to false the button will no
    /// longer be added.
    /// </remarks>
    public boolean showQueryValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);
        container packedQuery;
        container packedUserInteractionArgs;
        container packedPaymProposal;
        Counter qtyMax;

        // <GJP>
        #DEFINE.Version22(22)
        #LOCALMACRO.CurrentListV22
            ledgerJournalId,
            paymProposalType,
            balanceCheck,
            fromDate,
            todate,
            paymDateFixed,
            paymWeekDayFixed,
            earlyPaymDate,
            paymCurrency,
            deleteCredit,
            qtyMax,
            amountMax,
            printProposal,
            generateProposal,
            postingDate,
            useFutureDueDate,
            postingDateOption_IT,
            includeInvoicesFromOtherCompanies,
            proposeSeparatePaymentPerCompany,
            defaultOffsetAccountType,
            defaultOffsetLedgerDimension
        #ENDMACRO
        // </GJP>

        // <GCN>
        #DEFINE.Version23(23)
        #LOCALMACRO.CurrentListV23
            ledgerJournalId,
            paymProposalType,
            balanceCheck,
            fromDate,
            todate,
            paymDateFixed,
            paymWeekDayFixed,
            earlyPaymDate,
            paymCurrency,
            deleteCredit,
            qtyMax,
            amountMax,
            printProposal,
            generateProposal,
            postingDate,
            useFutureDueDate,
            postingDateOption_IT,
            includeInvoicesFromOtherCompanies,
            proposeSeparatePaymentPerCompany,
            defaultOffsetAccountType,
            // <GJP>
            defaultOffsetLedgerDimension,
            consFromDate,
            consToDate,
            consId,
            consDay
            // </GJP>
        #ENDMACRO
        // </GCN>

        #DEFINE.Version24(24)
        #LOCALMACRO.CurrentListV24
            ledgerJournalId,
            paymProposalType,
            // <GTH>
            taxBranchCode,
            // </GTH>
            balanceCheck,
            fromDate,
            todate,
            paymDateFixed,
            paymWeekDayFixed,
            earlyPaymDate,
            paymCurrency,
            deleteCredit,
            qtyMax,
            amountMax,
            printProposal,
            generateProposal,
            postingDate,
            useFutureDueDate,
            postingDateOption_IT,
            includeInvoicesFromOtherCompanies,
            proposeSeparatePaymentPerCompany,
            defaultOffsetAccountType,
            // <GCN>
            voucherType_CN,
            // </GCN>
            // <GJP>
            defaultOffsetLedgerDimension,
            consFromDate,
            consToDate,
            consId,
            consDay
            // </GJP>
        #ENDMACRO

        #DEFINE.Version27(27)
        // </GCN>
        #LOCALMACRO.CurrentListV27
        ledgerJournalId,
        paymProposalType,
        // <GTH>
        taxBranchCode,
        // </GTH>
        balanceCheck,
        fromDate,
        todate,
        paymDateFixed,
        paymWeekDayFixed,
        earlyPaymDate,
        paymCurrency,
        deleteCredit,
        amountMax,
        printProposal,
        skipProposalEditForm,
        postingDate,
        useFutureDueDate,
        postingDateOption_IT,
        includeInvoicesFromOtherCompanies,
        proposeSeparatePaymentPerCompany,
        defaultOffsetAccountType,
        // <GCN>
        voucherType_CN,
        // </GCN>
        // <GJP>
        defaultOffsetLedgerDimension,
        consFromDate,
        consToDate,
        consId,
        consDay,
        // </GJP>
        limitPaymCreationToLedgerCompanyOnly,
        hasBatchBeenSplit,
        fromCustVendAccountNum,
        toCustVendAccountNum,
        isFinalBatch,
        curUserId,
        custVendPaymProposalLineTmpRecId
        #ENDMACRO

        #DEFINE.Version28(28)
        // </GCN>
        #LOCALMACRO.CurrentListV28
        ledgerJournalId,
        paymProposalType,
        // <GTH>
        taxBranchCode,
        // </GTH>
        balanceCheck,
        fromDate,
        todate,
        paymDateFixed,
        paymWeekDayFixed,
        earlyPaymDate,
        paymCurrency,
        deleteCredit,
        amountMax,
        printProposal,
        skipProposalEditForm,
        postingDate,
        useFutureDueDate,
        postingDateOption_IT,
        includeInvoicesFromOtherCompanies,
        proposeSeparatePaymentPerCompany,
        defaultOffsetAccountType,
        // <GCN>
        voucherType_CN,
        // </GCN>
        // <GJP>
        defaultOffsetLedgerDimension,
        consFromDate,
        consToDate,
        consId,
        consDay,
        // </GJP>
        limitPaymCreationToLedgerCompanyOnly,
        hasBatchBeenSplit,
        fromCustVendAccountNum,
        toCustVendAccountNum,
        isFinalBatch,
        curUserId,
        custVendPaymProposalLineTmpRecId,
        PSNVendRoutingSlipId
        #ENDMACRO

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList, packedQuery, packedUserInteractionArgs, packedPaymProposal] = _packedClass;

                if (packedQuery)
                {
                    queryCreatePayment = new QueryRun(packedQuery);
                }

                if (packedUserInteractionArgs)
                {
                    Args userInteractionArgs = new Args();
                    userInteractionArgs.unpack(packedUserInteractionArgs);
                    this.userInteraction(userInteractionArgs);
                }

                if (packedPaymProposal)
                {
                    if (paymProposal == null)
                    {
                        paymProposal = CustVendPaymProposal::newLedgerJournal(ledgerJournalId);
                    }

                    paymProposal.unpack(packedPaymProposal);
                }

                break;

            case #Version28:
                [version, #CurrentListV28, packedQuery, packedUserInteractionArgs, packedPaymProposal] = _packedClass;

                if (packedQuery)
                {
                    queryCreatePayment = new QueryRun(packedQuery);
                }

                if (packedUserInteractionArgs)
                {
                    Args userInteractionArgs = new Args();
                    userInteractionArgs.unpack(packedUserInteractionArgs);
                    this.userInteraction(userInteractionArgs);
                }

                if (packedPaymProposal)
                {
                    if (paymProposal == null)
                    {
                        paymProposal = CustVendPaymProposal::newLedgerJournal(ledgerJournalId);
                    }

                    paymProposal.unpack(packedPaymProposal);
                }

                break;

            case #Version27:
                [version, #CurrentListV27, packedQuery] = _packedClass;

                if (packedQuery)
                {
                    queryCreatePayment = new QueryRun(packedQuery);
                }
                break;

            // <GCN>
            case #Version24:
                [version, #CurrentListV24, packedQuery] = _packedClass;

                if (packedQuery)
                {
                    queryCreatePayment = new QueryRun(packedQuery);
                }
                break;

            case #Version23:
                [version, #CurrentListV23, packedQuery] = _packedClass;

                if (packedQuery)
                {
                    queryCreatePayment = new QueryRun(packedQuery);
                }
                break;
            // </GCN>
            // <GJP>
            case #Version22:
                [version, #CurrentListV22, packedQuery] = _packedClass;

                if (packedQuery)
                {
                    queryCreatePayment = new QueryRun(packedQuery);
                }
                break;
            // </GJP>
            default :
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuery</Name>
				<Source><![CDATA[
    protected void updateQuery()
    {
        this.updateQueryWithQueryRun(queryCreatePayment);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryWithQueryRun</Name>
				<Source><![CDATA[
    protected void updateQueryWithQueryRun(QueryRun _queryRun)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuery_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the process query so that records will be grouped by Tax branch when feature is opened.
    /// </summary>
    /// <param name="_transTableId">
    /// The table Id to specify the datasource and field Id.
    /// </param>
    /// <remarks>
    /// When feature Tax branch is opened, the query process should group records by tax branch.
    /// </remarks>
    public void updateQuery_TH(TableId _transTableId)
    {
        this.updateQueryWithQueryRun_TH(_transTableId, queryCreatePayment);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryWithQueryRun_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the process query so that records will be grouped by Tax branch when feature is opened.
    /// </summary>
    /// <param name="_transTableId">
    /// The table Id to specify the datasource and field Id.
    /// </param>
    /// <param name="_queryRun">
    /// QueryRun to get the query from.
    /// </param>
    /// <remarks>
    /// When feature Tax branch is opened, the query process should group records by tax branch.
    /// </remarks>
    public void updateQueryWithQueryRun_TH(TableId _transTableId, QueryRun _queryRun)
    {
        QueryBuildDataSource qbdsCustVendTrans;
        FieldId defaultDimension;

        if (_transTableId == tableNum(VendTrans))
        {
            qbdsCustVendTrans = SysQuery::findOrCreateDataSource(_queryRun.query(), tableNum(VendTrans));
            defaultDimension = fieldNum(VendTrans, DefaultDimension);
        }
        else if (_transTableId == tableNum(CustTrans))
        {
            qbdsCustVendTrans = SysQuery::findOrCreateDataSource(_queryRun.query(), tableNum(CustTrans));
            defaultDimension = fieldNum(CustTrans, DefaultDimension);
        }

        QueryBuildDataSource qbdsDimAttributeValueSetItemView = qbdsCustVendTrans.addDataSource(tableNum(DimensionAttributeValueSetItemView));
        qbdsDimAttributeValueSetItemView.relations(false);
        qbdsDimAttributeValueSetItemView.addLink(defaultDimension, fieldNum(DimensionAttributeValueSetItemView, DimensionAttributeValueSet));
        qbdsDimAttributeValueSetItemView.joinMode(JoinMode::ExistsJoin);

        SysQuery::findOrCreateRange(qbdsDimAttributeValueSetItemView, fieldNum(DimensionAttributeValueSetItemView, EntityInstance)).value(queryValue(taxBranchRecId));

        QueryBuildDataSource qbdsDimAttribute = qbdsDimAttributeValueSetItemView.addDataSource(tableNum(DimensionAttribute));
        qbdsDimAttribute.relations(false);
        qbdsDimAttribute.addLink(fieldNum(DimensionAttributeValueSetItemView, DimensionAttribute), fieldNum(DimensionAttribute, RecId));
        qbdsDimAttribute.joinMode(JoinMode::ExistsJoin);

        SysQuery::findOrCreateRange(qbdsDimAttribute, fieldNum(DimensionAttribute, BackingEntityType)).value(queryValue(tableNum(DimAttributeTaxBranch)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryCompanyRange</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the company range of the process query so that only companies that were selected and are
    ///    part of the shared service boundary are enabled.
    /// </summary>
    /// <returns>
    ///    true if the company range of the process query includes enabled companies that are part of the
    ///    shared service boundary; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The enabled companies in the company range of the process query may include companies that are not
    ///    part of the shared service boundary. The payment proposal process should only include companies
    ///    that are part of the shared service boundary.
    /// </remarks>
    private boolean updateQueryCompanyRange()
    {
        boolean isQueryValidForProcess = false;

        if (queryCreatePayment.allowCrossCompany() && !isPaymentRequestsEnabled)
        {
            Query query = queryCreatePayment.query();

            container sharedServiceBoundaryCompanies = CustVendOpenTransManager::findSharedServiceCompanies(curext());
            container queryRangeCompanies = query.getCompanyRange();

            // Disable companies that are not part of the shared service boundary
            // The company range is a collection of containers. The container structure is (CompanyId,boolean)
            // where the boolean is a flag specifying whether data for the associated CompanyId is included in
            // the query processing.

            query.clearCompanyRange();
            for (int i = 1; i <= conLen(queryRangeCompanies); i++)
            {
                container queryRangeCompany = conPeek(queryRangeCompanies, i);

                // If the company was enabled and is part of the shared service boundary then add it back to the company range
                if (conPeek(queryRangeCompany, 2) && conFind(sharedServiceBoundaryCompanies, conPeek(queryRangeCompany, 1)) != 0)
                {
                    query.addCompanyRange(conPeek(queryRangeCompany, 1));

                    // If we enable at least one company that is part of the shared service boundary
                    // the query is useful to the process.
                    isQueryValidForProcess = true;
                }
            }
        }
        else
        {
            // Query is not cross company so company range is ignored and thus valid
            isQueryValidForProcess = true;
        }

        return isQueryValidForProcess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuerySplitBatch</Name>
				<Source><![CDATA[
    private void updateQuerySplitBatch()
    {
        if (this.fromCustVendAccountNum && this.toCustVendAccountNum)
        {
            Query query = queryCreatePayment.query();
            QueryBuildDataSource qbds = query.dataSourceTable(this.getCustVendTableId());
            QueryBuildRange qbr = SysQuery::findOrCreateRange(qbds, this.getCustVendTableAccountNumFieldId());

            qbr.value(this.fromCustVendAccountNum + '..' + this.toCustVendAccountNum);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate(Object calledFrom = null)
    {
        boolean ret = true;

        if (defaultOffsetAccountType == LedgerJournalACTypeForPaymProposal::Bank && defaultOffsetLedgerDimension != 0)
        {
            ret = BankAccountTable::checkIsActive(this.parmDefaultOffsetAccount());
        }

        if (!LedgerJournalTable::find(ledgerJournalId).checkJournalOpen())
        {
            ret = false;
        }

        if (paymCurrency && !Currency::exist(paymCurrency))
        {
            ret = checkFailed(strFmt("@SYS91941", paymCurrency));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS66014";
    }

]]></Source>
			</Method>
			<Method>
				<Name>userInteraction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates a version of the <c>CustVendPaymProposalUserInteraction</c> class. This class dictates the interactive or non-interactive payment proposal activities.
    /// </summary>
    /// <param name = "_args">Args has data that provides the input to the plugin factory.</param>
    /// <returns>The default object which is interactive or non-default non-interactive object.</returns>
    protected CustVendPaymProposalUserInteraction userInteraction(Args _args = null)
    {
        if (userInteraction == null)
        {
            Debug::assert(_args != null);

            userInteraction = CustVendPaymProposalUserInteraction::constructForProposal(_args);
        }

        userInteraction.parmCustVendCreatePaymJournal(this);
        return userInteraction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymProposal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the CustVendPaymProposal object.
    /// </summary>
    public CustVendPaymProposal getPaymProposal()
    {
        Debug::assert(paymProposal != null);
        return paymProposal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDialogValuesNonUserInteractive</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the dialog values for non-UI interaction.
    /// </summary>
    /// <param name="_dialogValues">
    /// The class that contains values to be set for the specified dialog values.
    /// </param>
    protected void initDialogValuesNonUserInteractive(CustVendCreatePaymJournalDialogValues _dialogValues)
    {
        paymProposalType = _dialogValues.parmPaymProposalType();
        balanceCheck = _dialogValues.parmBalanceCheck();
        fromDate = _dialogValues.parmFromDate();
        toDate = _dialogValues.parmToDate();
        earlyPaymDate = _dialogValues.parmEarlyPaymDate();
        paymDateFixed = _dialogValues.parmPaymDateFixed();
        paymWeekDayFixed = _dialogValues.parmPaymWeekDayFixed();
        amountMax = _dialogValues.parmAmountMax();
        deleteCredit = _dialogValues.parmDeleteCredit();
        printProposal = _dialogValues.parmPrintProposal();
        skipProposalEditForm = _dialogValues.parmSkipEditForm();
        paymCurrency = _dialogValues.parmPaymCurrency();
        includeInvoicesFromOtherCompanies = _dialogValues.parmIncludeInvoicesFromOtherCompanies();
        proposeSeparatePaymentPerCompany = _dialogValues.parmProposeSeparatePaymentPerCompany();
        defaultOffsetAccountType = _dialogValues.parmDefaultOffsetAccountType();
        defaultOffsetLedgerDimension = _dialogValues.parmDefaultOffsetLedgerDimension();

        // <GCN>
        if (LedgerParameters::isChineseVoucher_CN())
        {
            voucherType_CN = _dialogValues.parmVoucherType_CN();
        }
        // </GCN>

        if (PublicSectorUtils::isFrenchRegulatoryEnabled())
        {
            PSNVendRoutingSlipId = _dialogValues.PSNParmVendRoutingSlip();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQueryNonUserInteractive</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the query for non-UI interaction.
    /// </summary>
    /// <param name="_dialogValues">
    /// The class that contains values to be set for the specified query ranges.
    /// </param>
    protected void initQueryNonUserInteractive(CustVendCreatePaymJournalDialogValues _dialogValues)
    {
        this.initParmDefault();

        this.updateQueryToIncludeCrossCompanyInvoices(_dialogValues.parmIncludeInvoicesFromOtherCompanies());
    }

]]></Source>
			</Method>
			<Method>
				<Name>initNonUserInteractive</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set variable values that are used as criteria to generate payment proposal lines.
    /// </summary>
    /// <param name = "_dialogValues">The parameter contains values to be used for selecting invoices for payment proposal.</param>
    /// <remarks>This method is used for setting the values when payment proposal line is to be created using non-UI interaction.</remarks>
    public void initNonUserInteractive(CustVendCreatePaymJournalDialogValues _dialogValues)
    {
        this.initQueryNonUserInteractive(_dialogValues);
        this.initDialogValuesNonUserInteractive(_dialogValues);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPaymentProposalGenerationProcessStatic</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the payment proposal processing logic.
    /// </summary>
    /// <param name = "_parameters">A packed list of parameters for running payment proposal.</param>
    /// <returns>The packed results of the payment proposal process.</returns>
    public static container runPaymentProposalGenerationProcessStatic(container _parameters)
    {
        ClassId custVendCreatePaymJournalClassId;
        container custVendCreatePaymJournalPack;
        [custVendCreatePaymJournalClassId, custVendCreatePaymJournalPack] = _parameters;

        CustVendCreatePaymJournal custCreatePaymJournal = new SysDictClass(custVendCreatePaymJournalClassId).makeObject();
        custCreatePaymJournal.unpack(custVendCreatePaymJournalPack);
        custCreatePaymJournal.runPaymentProposalGenerationProcess();

        return [custCreatePaymJournal.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIncludeInvoicesFromOtherCompanies</Name>
				<Source><![CDATA[
    public NoYes getIncludeInvoicesFromOtherCompanies()
    {
        return includeInvoicesFromOtherCompanies;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProposeSeparatePaymentPerCompany</Name>
				<Source><![CDATA[
    public NoYes getProposeSeparatePaymentPerCompany()
    {
        return proposeSeparatePaymentPerCompany;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLimitPaymCreationToLedgerCompanyOnly</Name>
				<Source><![CDATA[
    public boolean getLimitPaymCreationToLedgerCompanyOnly()
    {
        return limitPaymCreationToLedgerCompanyOnly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPostingDate</Name>
				<Source><![CDATA[
    public TransDate getPostingDate()
    {
        return postingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUseFutureDueDate</Name>
				<Source><![CDATA[
    public NoYes getUseFutureDueDate()
    {
        return useFutureDueDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGenerateProposal</Name>
				<Source><![CDATA[
    public NoYes parmGenerateProposal(NoYes _generateProposal = generateProposal)
    {
        generateProposal = _generateProposal;
        return generateProposal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeInvoicesFromOtherCompanies</Name>
				<Source><![CDATA[
    protected  NoYes parmIncludeInvoicesFromOtherCompanies(NoYes _includeInvoicesFromOtherCompanies = includeInvoicesFromOtherCompanies)
    {
        includeInvoicesFromOtherCompanies = _includeInvoicesFromOtherCompanies;

        return includeInvoicesFromOtherCompanies;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsGeneratedFromPaymentSchedule</Name>
				<Source><![CDATA[
    public boolean parmIsGeneratedFromPaymentSchedule(boolean _isGeneratedFromPaymentSchedule = isGeneratedFromPaymentSchedule)
    {
        isGeneratedFromPaymentSchedule = _isGeneratedFromPaymentSchedule;
        return isGeneratedFromPaymentSchedule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmToDate</Name>
				<Source><![CDATA[
    public TransDate parmToDate(TransDate _toDate = toDate)
    {
        toDate = _toDate;
        return toDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymProposal</Name>
				<Source><![CDATA[
    public CustVendPaymProposal paymProposal()
    {
        return paymProposal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryCashFlowWithQueryRun</Name>
				<Source><![CDATA[
    protected void updateQueryCashFlowWithQueryRun(TableId _transOpenTableId, QueryRun _queryRun)
    {
        Query query = _queryRun.query();

        if (query.dataSourceTable(tableNum(CFMPaymentRequestTable)))
        {
            return;
        }

        CFMAccountType accountType;
        switch (_transOpenTableId)
        {
            case tableNum(VendTransOpen):
                accountType = CFMAccountType::Vend;
                break;

            case tableNum(CustTransOpen):
                accountType = CFMAccountType::Cust;
                break;

            default:
                this.logMessage(Exception::Error, error::wrongUseOfFunction(funcName()));
        }

        CFMCustVendPaymProposalQueryHelper queryHelper = CFMCustVendPaymProposalQueryHelper::construct(accountType, query, query.allowCrossCompany(), conNull());
        queryHelper.buildQuery();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryCashFlow</Name>
				<Source><![CDATA[
    protected void updateQueryCashFlow(TableId _transOpenTableId)
    {
        this.updateQueryCashFlowWithQueryRun(_transOpenTableId, queryCreatePayment);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromCashFlowJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates instance of <c>CustVendCreatePaymJournal</c> class.
    /// </summary>
    /// <param name="_accountType">
    /// Defines account type to define what type of journal will be used.
    /// </param>
    /// <param name="_cashFlowJournalRecId">
    /// Rec Id of <c>CFMCashflowJournalTable</c> record.
    /// </param>
    /// <param name="_ledgerJournalId">
    /// Journal identifier of ledger journal.
    /// </param>
    /// <param name="_casFlowCompanies">
    /// List of companies that will be used to select transactions.
    /// </param>
    /// <param name="_cashFlowJournalQuery">
    /// Query object to cash flow journals
    /// </param>
    /// <param name="_splitPaymentPerCompany">
    /// Define whether or not splitt lines in journal per company.
    /// </param>
    /// <returns>
    /// Instance of <c>CustVendCreatePaymJournal</c> class.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error exception if account type not Customer or Vendor or validation of parameters failed.
    /// </exception>
    public static CustVendCreatePaymJournal createFromCashFlowJournal(
        CFMAccountType _accountType,
        RefRecId _cashFlowJournalRecId,
        LedgerJournalId _ledgerJournalId,
        container _casFlowCompanies,
        Query _cashFlowJournalQuery,
        NoYes _splitPaymentPerCompany)
    {
        CustVendCreatePaymJournal createPaymJournal;

        switch (_accountType)
        {
            case CFMAccountType::Cust:
                createPaymJournal = new CustVendCreatePaymJournal_Cust();
                break;

            case CFMAccountType::Vend:
                createPaymJournal = new CustVendCreatePaymJournal_Vend();
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        createPaymJournal.initParmDefault();

        Query paymentProposalQuery = createPaymJournal.queryRun().query();
        CFMCustVendPaymProposalQueryHelper queryHelper = CFMCustVendPaymProposalQueryHelper::construct(_accountType, paymentProposalQuery, true, _casFlowCompanies, _cashFlowJournalRecId);
        queryHelper.buildQuery();
        queryHelper.copyPaymentRequestQueryRange(_cashFlowJournalQuery);

        createPaymJournal.parmLedgerJournalId(_ledgerJournalId);
        createPaymJournal.parmToDate(maxDate());
        createPaymJournal.parmGenerateProposal(NoYes::No);
        createPaymJournal.parmIncludeInvoicesFromOtherCompanies(NoYes::Yes);
        createPaymJournal.parmIsGeneratedFromPaymentSchedule(_cashFlowJournalRecId);
        createPaymJournal.parmProposeSeparatePaymentPerCompany(_splitPaymentPerCompany);

        if (createPaymJournal.validate())
        {
            createPaymJournal.runPaymentProposalGenerationProcess();
        }
        else
        {
            throw error("@SYS70403");
        }

        return createPaymJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProposeSeparatePaymentPerCompany</Name>
				<Source><![CDATA[
    public NoYes parmProposeSeparatePaymentPerCompany(NoYes _proposeSeparatePaymentPerCompany = proposeSeparatePaymentPerCompany)
    {
        proposeSeparatePaymentPerCompany = _proposeSeparatePaymentPerCompany;
        return proposeSeparatePaymentPerCompany;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateTopPickingList</Name>
				<Source><![CDATA[
    internal static List generateTopPickingList(container _packedInformation, int _bundleSize = 0)
    {
        ClassId classId;
        container packedInformation;
        [classId, packedInformation] = _packedInformation;
        DictClass dictClass = new DictClass(classId);
        CustVendCreatePaymJournal custVendCreatePaymJournalCalculate = dictClass.makeObject();
        custVendCreatePaymJournalCalculate.unpack(packedInformation);
        return custVendCreatePaymJournalCalculate.generateTopPickingTaskList(_bundleSize);
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateTopPickingTaskList</Name>
				<Source><![CDATA[
    internal List generateTopPickingTaskList(int _bundleSize = 0)
    {
        List subTaskList = this.generateTopPickingListInternal(_bundleSize);
        ListEnumerator rangeListEnumerator = subTaskList.getEnumerator();
        ClassId classId = classIdGet(this);
        DictClass dictClass = new DictClass(classId);
        List res = new List(Types::Container);
        while (rangeListEnumerator.moveNext())
        {
            CustVendCreatePaymJournal custVendCreatePaymJournal = dictClass.makeObject();
            custVendCreatePaymJournal.unpack(this.pack());

            RecId start = conPeek(rangeListEnumerator.current(), 1);
            RecId end = conPeek(rangeListEnumerator.current(), 2);
            DataAreaId currentDataAreaId = conPeek(rangeListEnumerator.current(), 3);
            RecId paymProposalTmpRecId = conPeek(rangeListEnumerator.current(), 4);
            custVendCreatePaymJournal.updateQueryWithTransRecId(start, end);
            custVendCreatePaymJournal.updateQueryToSpecificCompany(currentDataAreaId);
            custVendCreatePaymJournal.custVendPaymProposalLineTmpRecId = paymProposalTmpRecId;
            res.addEnd([classIdGet(custVendCreatePaymJournal), custVendCreatePaymJournal.pack()]);
        }
        return res;
    }

]]></Source>
			</Method>
			<Method>
				<Name>triggerTopPickingRun</Name>
				<Source><![CDATA[
    internal static boolean triggerTopPickingRun(container _payload)
    {
        ClassId classId;
        container payload;
        [classId, payload] = _payload;
        DictClass dictClass = new DictClass(classId);
        CustVendCreatePaymJournal custVendCreatePaymJournal = dictClass.makeObject();
        custVendCreatePaymJournal.parmInBatch(true);
        custVendCreatePaymJournal.unpack(payload);
        custVendCreatePaymJournal.runPaymentProposalGenerationProcess();
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateTopPickingListInternal</Name>
				<Source><![CDATA[
    private List generateTopPickingListInternal(int _bundleSize = 0)
    {
        List subTaskList = new List(Types::container);
        RecId fromRecId;
        Map dataAreaMap = new Map(Types::String, Types::Container);
        Map dataAreaLastRecIdMap = new Map(Types::String, Types::Int64);
        int mapCount;
        RecId paymProposalLineTmpRecId;
        this.updateQueryToIncludeCrossCompanyInvoices(includeInvoicesFromOtherCompanies);
        this.sortTransOpenRecId();

        int runningBundleSize = _bundleSize ? _bundleSize : BundleSize;

        while (queryCreatePayment.next())
        {
            CustVendTransOpen custVendTransOpen = queryCreatePayment.get(this.getCustVendTransOpenTableId());
            DataAreaId currentDataAreaId = custVendTransOpen.DataArea;
            paymProposalLineTmpRecId ++;

            if (dataAreaMap.exists(currentDataAreaId))
            {
                int currentPaymProposalLineTmpRecId;
                [mapCount, fromRecId, currentPaymProposalLineTmpRecId] = dataAreaMap.lookup(currentDataAreaId);

                if (mapCount == runningBundleSize)
                {
                    subTaskList.addEnd([fromRecId, dataAreaLastRecIdMap.lookup(currentDataAreaId), currentDataAreaId, currentPaymProposalLineTmpRecId]);
                    dataAreaMap.insert(currentDataAreaId, [1, custVendTransOpen.RecId, paymProposalLineTmpRecId]);
                }
                else
                {
                    dataAreaMap.insert(currentDataAreaId, [mapCount + 1, fromRecId, currentPaymProposalLineTmpRecId]);
                }
            }
            else
            {
                dataAreaMap.insert(currentDataAreaId, [1, custVendTransOpen.RecId, paymProposalLineTmpRecId]);
            }

            dataAreaLastRecIdMap.insert(currentDataAreaId, custVendTransOpen.RecId);
        }

        MapEnumerator mapEnumerator = dataAreaMap.getEnumerator();
        while (mapEnumerator.moveNext())
        {
            DataAreaId currentMapDataAreaId = mapEnumerator.currentKey();
            [mapCount, fromRecId, paymProposalLineTmpRecId] = mapEnumerator.currentValue();
            subTaskList.addEnd([fromRecId, dataAreaLastRecIdMap.lookup(currentMapDataAreaId), currentMapDataAreaId, paymProposalLineTmpRecId]);
        }
        return subTaskList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sortTransOpenRecId</Name>
				<Source><![CDATA[
    private void sortTransOpenRecId()
    {
        Query query = queryCreatePayment.query();
        QueryBuildDataSource qbds = query.dataSourceTable(this.getCustVendTransOpenTableId());
        qbds.addSortField(this.getCustVendTransOpenRecIdFieldId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryWithTransRecId</Name>
				<Source><![CDATA[
    private void updateQueryWithTransRecId(RecId _start, RecId _end)
    {
        Query query = queryCreatePayment.query();
        QueryBuildDataSource qbds = query.dataSourceTable(this.getCustVendTransOpenTableId());
        qbds.addRange(this.getCustVendTransOpenRecIdFieldId()).value(SysQuery::range(_start, _end));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryToSpecificCompany</Name>
				<Source><![CDATA[
    private void updateQueryToSpecificCompany(DataAreaId _dataAreaId)
    {
        Query query = queryCreatePayment.query();
        queryCreatePayment.allowCrossCompany(true);
        query.clearCompanyRange();
        query.addCompanyRange(_dataAreaId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>triggerTransfer</Name>
				<Source><![CDATA[
    internal void triggerTransfer()
    {
        if (skipProposalEditForm && !this.parmIsAutomation())
        {
            CustVendPaymProposalCalcPaym paymProposalCalcPaym = this.initCustVendPaymProposalCalcPaym();
            this.initCustVendPaymProposal(paymProposalCalcPaym);

            CustVendPaymProposalTransferToJournal transfer = CustVendPaymProposalTransferToJournal::constructForPaymProposal(paymProposal);
            transfer.parmIsAutomation(this.parmIsAutomation());
            transfer.parmProcessExecutionSourceLinkRecId(this.parmProcessExecutionSourceLinkRecId());
            transfer.removeUnwantedJournalLines();
            BatchInfo transferBatchInfo = transfer.batchInfo();

            ttsbegin;
            transferBatchInfo.parmBatchExecute(NoYes::Yes);
            transferBatchInfo.parmGroupId(this.parmCurrentBatch().GroupId);
            transferBatchInfo.doBatch();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postOperationsInTopPicking</Name>
				<Source><![CDATA[
    internal void postOperationsInTopPicking()
    {
        ttsbegin;

        this.mergeTopPickingResult();

        if (this.shouldAdjustToMaxTotals())
        {
            paymProposal.adjustToMaxTotals(amountMax);
        }

        CustVendPaymProposalBatchProcess::changeState(this.ledgerJournalId() , CustVendPaymProposalBatchProcessState::CreatedProposalLines);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeTopPickingResult</Name>
				<Source><![CDATA[
    private void mergeTopPickingResult()
    {
        Query query = new Query();
        QueryBuildDataSource qbds = query.addDataSource(tableNum(CustVendPaymProposalLine));
        qbds.addRange(fieldNum(CustVendPaymProposalLine, JournalId)).value(queryValue(this.ledgerJournalId()));
        qbds = qbds.addDataSource(tableNum(SpecTrans));
        qbds.relations(true);
        qbds.joinMode(JoinMode::ExistsJoin);
        QueryRun queryRun = new QueryRun(query);

        Map paymentProposalLineMap = new Map(Types::Integer, Types::Int64);

        while (queryRun.next())
        {
            CustVendPaymProposalLine paymProposalLine = queryRun.get(tableNum(CustVendPaymProposalLine));

            int hashKey = paymProposalLine.generateHashKey();
            if (paymentProposalLineMap.exists(hashKey))
            {
                RecId summaryRecId = paymentProposalLineMap.lookup(hashKey);
                SpecTrans::updateSpecRecId(paymProposalLine.DataAreaId, paymProposalLine.TableId, paymProposalLine.RecId, summaryRecId);

                paymProposalLine.selectForUpdate(true);
                paymProposalLine.delete();
            }
            else
            {
                paymentProposalLineMap.insert(hashKey, paymProposalLine.RecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runProposalAutomationRuntimeMonitor</Name>
				<Source><![CDATA[
    internal static void runProposalAutomationRuntimeMonitor(
        RefRecId _processExecutionSourceLinkRecId,
        RefRecId _batchJobId,
        LedgerJournalId _ledgerJournalId,
        boolean _isFinalRuntimeMonitor)
    {
        if (_batchJobId)
        {
            CustVendPaymProposalAutomationRuntimeMonitor runtimeMonitor = new CustVendPaymProposalAutomationRuntimeMonitor(
                classStr(CustVendPaymProposalAutomationRuntimeMonitor),
                methodStr(CustVendPaymProposalAutomationRuntimeMonitor, runMonitor),
                SysOperationExecutionMode::Synchronous);

            CustVendPaymProposalAutomationRuntimeMonitorContract contract = runtimeMonitor.getDataContractInfoObject().dataContractObject() as CustVendPaymProposalAutomationRuntimeMonitorContract;
            contract.parmIsFinalRuntimeMonitor(_isFinalRuntimeMonitor);
            contract.parmJournalNum(_ledgerJournalId);
            contract.parmProcessExecutionSourceLinkRecId(_processExecutionSourceLinkRecId);
            contract.parmBatchJobId(_batchJobId);
            contract.parmSuccessMessage("@CashManagement:CustVendPaymProposalAutomationSucceeded");
            contract.parmFailureMessage("@CashManagement:CustVendPaymProposalAutomationFailed");

            runtimeMonitor.runMonitor(contract);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>