<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailPricingCacheManager</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;

/// <summary>
/// Manages cached data access for <c>RetailPricingDataManager</c>.
/// </summary>
internal class RetailPricingCacheManager
{
    private static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;

    private const str CacheHitKeyword = 'CacheHit';
    private const str CacheMissKeyword = 'CacheMiss';

    // Key: [[DataAreaId]-[OfferId]-[CategoryRecId]].
    // Value: RetailPeriodicDiscountCategoryCache object.
    private const str discountCacheScope = "RetailPricingCacheManager_ReadRetailDiscountsByCategory";
    // Key: [[DataAreaId]-[OfferId]-[CategoryRecId]].
    // Value: false (that nothing can be found with this key).
    private const str retailPeriodicDiscountNoExistsCacheScope = "RetailPricingCacheManager_OfferNotFound";

    // Key: [ProductRecId].
    // Value: Collection of Category RecIds.
    private const str productCategoriesCacheScope = "RetailPricingCacheManager_ProductCategories";
    // Key: [EcoResDistinctProductVariant].
    // Value: Collection of Category RecIds.
    private const str variantCategoriesCacheScope = "RetailPricingCacheManager_VariantCategories";
    // Key: [DataAreaId, OfferId].
    // Value: [hasDiscountForProducts, hasDiscountForVariants, hasDiscountsForInventDim, hasDiscountsForCategories].
    private const str offerDiscountConfigCacheScope = "RetailPricingCacheManager_OfferDiscountConfiguration";

    // Key: [SalesTaxGroupId, ItemTaxGroupId].
    // Value: Collection of RetailTaxIntervalCacheObject.
    private const str exemptTaxIntervalsCacheScope = "RetailPricingCacheManager_ExemptTaxIntervals";

    // Key: [PriceGroupRecId, DlvModeId]
    // Value: Collection of RetailShippingThresholdDiscounts RecIds.
    private const str shippingDiscountCacheScope = "RetailPricingCacheManager_ReadRetailDiscounts";

    // Key:Container [SalesId, LineNum].
    // Value: FieldId of the field whose value has been modified.
    private const str salesLineModifySalesQtyFieldIdCacheSope = 'SalesLineModifySalesQtyFieldId';

    // Key: RetailPeriodicDiscount RecId which has category based discount lines;
    // Value: Collection of category RecId in discount lines of the discount.
    private const str categoryDiscountCategoryIdCacheSope = 'RetailPricingCacheManager_CategoryRecId';

    // Key: Container [RetailPeriodicDiscount RecId which has category based discount lines, category RecId in discount lines of the discount].
    // Value: Collection of RetailPeriodicDiscountLine RecIds which are category based and use the given category.
    private const str categoryDiscountLineIdCacheSope = 'RetailPricingCacheManager_CategoryDiscountLineRecId';

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getExemptTaxIntervalsCacheScope</Name>
				<Source><![CDATA[
    internal static str getExemptTaxIntervalsCacheScope()
    {
        return exemptTaxIntervalsCacheScope;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAvailableItemDiscountsForOffer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the given OfferId has discounts configured for Products, Variants, Invent dimensions and categories.
    /// </summary>
    /// <param name = "_offerId">The offerId to check discount types.</param>
    /// <param name = "_dataAreaId">The dataAreaId to check discount types.</param>
    /// <returns>Container indicating if the offerId contains discounts for products, variants, inventDimId and categories</returns>
    public static container checkAvailableItemDiscountsForOffer(DataAreaId _dataAreaId, str _offerId)
    {
        if (RetailPricingCacheManager::shouldDisableCache())
        {
            // Throw an error for read access to cache as we no longer keep those cache. So we can get alerted as early as possible.
            throw error(Error::wrongUseOfFunction(funcName()));
        }
        
        boolean hasDiscountForProducts, hasDiscountForVariants, hasDiscountsForInventDim, hasDiscountsForCategories;

        RetailGroupMemberLine retailGroupMemberLine;
        RetailPeriodicDiscountLine periodicDiscountLine;

        using(var telemetry = RetailPricingInstrumentationSegment::construct(classStr(RetailPricingCacheManager), funcName()))
        {
            SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();

            container cache = objectCache.find(offerDiscountConfigCacheScope, [_dataAreaId, _offerId]);
            if (cache == conNull())
            {
                telemetry.addExtendedData(CacheMissKeyword, '1');

                select firstonly RecId from retailGroupMemberLine
                                where retailGroupMemberLine.Product > 0 && retailGroupMemberLine.Variant == 0
                                exists join periodicDiscountLine
                                where periodicDiscountLine.RetailGroupMemberLine == retailGroupMemberLine.RecId
                                    && periodicDiscountLine.OfferId == _offerId;

                if (retailGroupMemberLine)
                {
                    hasDiscountForProducts = true;
                }

                select firstonly RecId from retailGroupMemberLine
                                where retailGroupMemberLine.Variant > 0
                                exists join periodicDiscountLine
                                where periodicDiscountLine.RetailGroupMemberLine == retailGroupMemberLine.RecId
                                    && periodicDiscountLine.OfferId == _offerId;
                if (retailGroupMemberLine)
                {
                    hasDiscountForVariants = true;
                }

                select firstonly RecId from retailGroupMemberLine
                                where retailGroupMemberLine.InventDimId != ''
                                exists join periodicDiscountLine
                                where periodicDiscountLine.RetailGroupMemberLine == retailGroupMemberLine.RecId
                                    && periodicDiscountLine.OfferId == _offerId;
                if (retailGroupMemberLine)
                {
                    hasDiscountsForInventDim = true;
                }

                select firstonly RecId from retailGroupMemberLine
                                where retailGroupMemberLine.Category > 0 && retailGroupMemberLine.Product == 0 && retailGroupMemberLine.Variant == 0
                                exists join periodicDiscountLine
                                where periodicDiscountLine.RetailGroupMemberLine == retailGroupMemberLine.RecId
                                    && periodicDiscountLine.OfferId == _offerId;
                if (retailGroupMemberLine)
                {
                    hasDiscountsForCategories = true;
                }

                objectCache.insert(offerDiscountConfigCacheScope, [_dataAreaId, _offerId], [hasDiscountForProducts, hasDiscountForVariants, hasDiscountsForInventDim, hasDiscountsForCategories]);
            }
            else
            {
                telemetry.addExtendedData(CacheHitKeyword, '1');

                hasDiscountForProducts = conPeek(cache, 1);
                hasDiscountForVariants = conPeek(cache, 2);
                hasDiscountsForInventDim = conPeek(cache, 3);
                hasDiscountsForCategories = conPeek(cache, 4);
            }
        }

        return [hasDiscountForProducts, hasDiscountForVariants, hasDiscountsForInventDim, hasDiscountsForCategories];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getValidShippingDiscounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return enabled shipping discounts.
    /// </summary>
    /// <param name = "_fromDate">From date to query discounts.</param>
    /// <param name = "_toDate">To date to query discounts.</param>
    /// <param name = "_priceDiscGroupTmp">Price groups record ids.</param>
    /// <param name = "_dlvMode">The delivery mode to query discount.</param>
    /// <returns>Set of shipping discounts RecId.</returns>
    public static Set getValidShippingDiscounts(FromDate _fromDate, ToDate _toDate, TmpRecIdFilter _priceDiscGroupTmp, DlvModeId _dlvMode)
    {
        Set cachedOffers = new Set(Types::Int64);

        RetailDiscountPriceGroup discountPriceGroup;
        RetailShippingThresholdDiscounts shippingDiscount;

        ValidFromDate noDate = DateTimeUtil::date(DateTimeUtil::minValue());
        ValidFromDate neverDate = DateTimeUtil::date(DateTimeUtil::maxValue());

        using(var telemetry = RetailPricingInstrumentationSegment::construct(classStr(RetailPricingCacheManager), funcName()))
        {
            int cacheHitCount = 0;
            int cacheMissCount = 0;

            while select _priceDiscGroupTmp
            {
                RecId priceGroupRecId = _priceDiscGroupTmp.RefRecId;

                Set offers = RetailPricingCacheManager::getCachedShippingDiscountsDiscount(priceGroupRecId, _dlvMode);

                if (offers.elements() == 0)
                {
                    cacheMissCount++;

                    while select RecId from shippingDiscount
                    where shippingDiscount.PeriodicDiscountType == RetailDiscountOfferTypeBase::Shipping
                       && shippingDiscount.Status == RetailDisabledEnabled::Enabled
                       && shippingDiscount.DlvModeId == _dlvMode
                    exists join discountPriceGroup
                        where discountPriceGroup.OfferId == shippingDiscount.OfferId
                            && discountPriceGroup.PriceDiscGroup == priceGroupRecId
                    {
                        offers.add(shippingDiscount.RecId);
                    }

                    RetailPricingCacheManager::cacheShippingDiscountsDiscount(priceGroupRecId, _dlvMode, offers);
                }
                else
                {
                    cacheHitCount++;
                }

                cachedOffers = Set::union(cachedOffers, offers);
            }

            if (cacheMissCount)
            {
                telemetry.addExtendedData(CacheMissKeyword, int2Str(cacheMissCount));
            }

            if (cacheHitCount)
            {
                telemetry.addExtendedData(CacheHitKeyword, int2Str(cacheHitCount));
            }
        }

        return cachedOffers;
    }

]]></Source>
			</Method>
			<Method>
				<Name>readRetailDiscountForCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return retail discounts and the first applicable line for given <c>RetailPeriodicDiscount</c> and Category record id.
    /// </summary>
    /// <param name = "_periodicDiscount">The <c>RetailPeriodicDiscount</c> record.</param>
    /// <param name = "_categoryRecId">The category record id.</param>
    /// <returns>The <c>RetailPeriodicDiscountCategoryCache</c> class.</returns>
    public static RetailPeriodicDiscountCategoryCache readRetailDiscountForCategory(RetailPeriodicDiscount _periodicDiscount, RecId _categoryRecId)
    {
        if (RetailPricingCacheManager::shouldDisableCache())
        {
            // Throw an error for read access to cache as we no longer keep those cache. So we can get alerted as early as possible.
            throw error(Error::wrongUseOfFunction(funcName()));
        }
        
        RetailPeriodicDiscountLine periodicDiscountLine;
        RetailGroupMemberLine retailGroupMemberLine;
        UnitOfMeasure unitOfMeasure;

        RetailPeriodicDiscountCategoryCache cachedDiscount = null;

        using(var telemetry = RetailPricingInstrumentationSegment::construct(classStr(RetailPricingCacheManager), funcName()))
        {
            telemetry.addExtendedData('_periodicDiscount', int642Str(_periodicDiscount.RecId));
            telemetry.addExtendedData('_categoryRecId', int642Str(_categoryRecId));

            // Category already processed and no discount found
            if (!RetailPricingCacheManager::existCategoryDiscount(_periodicDiscount.DataAreaId, _periodicDiscount.OfferId, _categoryRecId))
            {
                telemetry.addExtendedData(CacheHitKeyword, '1');
                return null;
            }

            cachedDiscount = RetailPricingCacheManager::getCategoryDiscount(_periodicDiscount.DataAreaId, _periodicDiscount.OfferId, _categoryRecId);

            str offerId = '';
            if (cachedDiscount != null)
            {
                periodicDiscountLine = cachedDiscount.retailPeriodicDiscountLine;
                offerId = periodicDiscountLine.OfferId;

                telemetry.addExtendedData(CacheHitKeyword, '1');
            }

            if (cachedDiscount != null && offerId != '')
            {
                return cachedDiscount;
            }
            else if (cachedDiscount == null)
            {
                eventSource.EventWritePricingCacheManagerReadDiscountForCategoryCacheMiss();
                telemetry.addExtendedData(CacheMissKeyword, '1');

                select periodicDiscountLine
                where periodicDiscountLine.OfferId == _periodicDiscount.OfferId
                outer join RecId, Symbol from unitOfMeasure
                    where unitOfMeasure.RecId == periodicDiscountLine.UnitOfMeasure
                    exists join retailGroupMemberLine
                        where retailGroupMemberLine.RecId == periodicDiscountLine.RetailGroupMemberLine
                            && retailGroupMemberLine.Variant == 0
                            && retailGroupMemberLine.Product == 0
                            && retailGroupMemberLine.Category != 0
                            && retailGroupMemberLine.Category == _categoryRecId;

                if (periodicDiscountLine)
                {
                    // Add offerId to found cache
                    cachedDiscount = RetailPeriodicDiscountCategoryCache::init(_periodicDiscount, periodicDiscountLine, unitOfMeasure);
                    RetailPricingCacheManager::cacheCategoryDiscount(_periodicDiscount.DataAreaId, _periodicDiscount.OfferId, _categoryRecId, cachedDiscount);
                }
                else
                {
                    // Add offerId to not found cache
                    RetailPricingCacheManager::cacheCategoryDiscount(_periodicDiscount.DataAreaId, _periodicDiscount.OfferId, _categoryRecId, null);
                }
            }
        }

        return cachedDiscount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existCategoryDiscount</Name>
				<Source><![CDATA[
    private static boolean existCategoryDiscount(DataAreaId _dataAreaId, RetailDiscountOfferId _offerId, int64 _category)
    {
        str strKey = strfmt('%1-%2-%3', _dataAreaId, _offerId, _category);

        SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();

        container cache = objectCache.find(retailPeriodicDiscountNoExistsCacheScope, [strKey]);

        if (cache != conNull())
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVariantCategories</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns categories for the given variant record id.
    /// </summary>
    /// <param name = "_variant">The variant record id.</param>
    /// <returns>A container with category tree related to the variant</returns>
    public static container getVariantCategories(RecId _variant)
    {
        RetailCategoryContainmentLookup categoryLookup;
        RetailSpecialCategoryMember variantCategory;
        RetailGroupMemberLine retailGroupMemberLine;
        container cache = conNull();

        str strKey = strfmt("%1", _variant);

        using(var telemetry = RetailPricingInstrumentationSegment::construct(classStr(RetailPricingCacheManager), funcName()))
        {
            telemetry.addExtendedData('_variant', int642Str(_variant));

            SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();

            cache = objectCache.find(variantCategoriesCacheScope, [strKey]);

            if (cache == conNull())
            {
                telemetry.addExtendedData(CacheMissKeyword, '1');

                while select Category from categoryLookup
                group by Category
                join variantCategory
                    where variantCategory.Category == categoryLookup.ContainedCategory
                    exists join retailGroupMemberLine
                        where retailGroupMemberLine.RecId == variantCategory.RetailGroupMember
                            && retailGroupMemberLine.Variant == _variant
                {
                    cache += categoryLookup.Category;
                }

                if (RetailPricingCacheManager::shouldDisableCache())
                {
                    // Do not cache it so it will not be hit.
                    // This piece of code is only called by shipping discount lookup which we don't have flatten discount on.
                    // Given the number of usage for shipping discount in fin ops, it's relatively safe to not have cache on it.
                }
                else
                {
                    RetailPricingCacheManager::cacheVariantCategories(_variant, cache);
                }
        
            }
            else
            {
                telemetry.addExtendedData(CacheHitKeyword, '1');
            }
        }

        return cache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductCategories</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns categories for the given product record id.
    /// </summary>
    /// <param name = "_product">The product record id.</param>
    /// <returns>A container with category tree related to the product</returns>
    public static container getProductCategories(RecId _product)
    {
        RetailCategoryContainmentLookup categoryLookup;
        EcoResProductCategory productCategory;
        container cache = conNull();

        str strKey = strfmt("%1", _product);

        using(var telemetry = RetailPricingInstrumentationSegment::construct(classStr(RetailPricingCacheManager), funcName()))
        {
            telemetry.addExtendedData('_product', int642Str(_product));

            SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();

            cache = objectCache.find(productCategoriesCacheScope, [strKey]);

            if (cache == conNull())
            {
                telemetry.addExtendedData(CacheMissKeyword, '1');

                while select Category from categoryLookup
                    group by Category
                        exists join productCategory
                            where productCategory.Category == categoryLookup.ContainedCategory
                                && productCategory.Product == _product
                {
                    cache += categoryLookup.Category;
                }
                
                if (RetailPricingCacheManager::shouldDisableCache())
                {
                    // Do not cache it so it will not be hit.
                    // This piece of code is only called by shipping discount lookup which we don't have flatten discount on.
                    // Given the number of usage for shipping discount in fin ops, it's relatively save to not have cache on it.
                }
                else
                {
                    RetailPricingCacheManager::cacheProductCategories(_product, cache);
                }
            }
            else
            {
                telemetry.addExtendedData(CacheHitKeyword, '1');
            }
        }

        return cache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheVariantCategories</Name>
				<Source><![CDATA[
    private static void cacheVariantCategories(RecId _variant, container _categoriesRecId)
    {
        str strKey = strfmt("%1", _variant);

        SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();

        objectCache.insert(productCategoriesCacheScope, [strKey], _categoriesRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheProductCategories</Name>
				<Source><![CDATA[
    private static void cacheProductCategories(RecId _product, container _categoriesRecId)
    {
        str strKey = strfmt("%1", _product);

        SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();

        objectCache.insert(productCategoriesCacheScope, [strKey], _categoriesRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheCategoryDiscount</Name>
				<Source><![CDATA[
    private static void cacheCategoryDiscount(DataAreaId _dataAreaId, RetailDiscountOfferId _offerId, int64 _category, RetailPeriodicDiscountCategoryCache _periodicDiscountCache)
    {
        str strKey = strfmt("%1-%2-%3", _dataAreaId, _offerId, _category);

        SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();

        if (_periodicDiscountCache)
        {
            objectCache.insert(discountCacheScope, [strKey], _periodicDiscountCache.pack());
        }
        else
        {
            objectCache.insert(retailPeriodicDiscountNoExistsCacheScope, [strKey], [false]);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCachedShippingDiscountsDiscount</Name>
				<Source><![CDATA[
    private static Set getCachedShippingDiscountsDiscount(RecId _priceGroupRecId, DlvModeId _dlvModeId)
    {
        str strKey = strFmt("%1-%2", _priceGroupRecId, _dlvModeId);
        container cache = conNull();

        using(var telemetry = RetailPricingInstrumentationSegment::construct(classStr(RetailPricingCacheManager), funcName()))
        {
            telemetry.addExtendedData('_priceGroupRecId', int642Str(_priceGroupRecId));
            telemetry.addExtendedData('_dlvModeId', _dlvModeId);

            SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();

            cache = objectCache.find(shippingDiscountCacheScope, [strKey]);

            if (cache == conNull())
            {
                telemetry.addExtendedData(CacheMissKeyword, '1');
                return new Set(Types::Int64);
            }
            else
            {
                telemetry.addExtendedData(CacheHitKeyword, '1');
            }
        }

        return Set::create(cache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheShippingDiscountsDiscount</Name>
				<Source><![CDATA[
    private static void cacheShippingDiscountsDiscount(RecId _priceGroupRecId, DlvModeId _dlvModeId, Set _offers)
    {
        str strKey = strFmt("%1-%2", _priceGroupRecId, _dlvModeId);

        SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();

        objectCache.insert(shippingDiscountCacheScope, [strKey], _offers.pack());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCategoryDiscount</Name>
				<Source><![CDATA[
    private static RetailPeriodicDiscountCategoryCache getCategoryDiscount(DataAreaId _dataAreaId, RetailDiscountOfferId _offerId, int64 _category)
    {
        str strKey = strfmt("%1-%2-%3", _dataAreaId, _offerId, _category);
        container cache = conNull();

        using(var telemetry = RetailPricingInstrumentationSegment::construct(classStr(RetailPricingCacheManager), funcName()))
        {
            telemetry.addExtendedData('_category', int642Str(_category));

            SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();

            cache = objectCache.find(discountCacheScope, [strKey]);

            if (cache != conNull())
            {
                telemetry.addExtendedData(CacheHitKeyword, '1');
                return RetailPeriodicDiscountCategoryCache::create(cache);
            }
            else
            {
                telemetry.addExtendedData(CacheMissKeyword, '1');
            }
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheSalesLineModifySalesQtyFieldId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Caches the field Id which triggers SalesLine::modifySalesQty.
    /// </summary>
    /// <param name = "_salesId">Sales ID of SalesLine buffer.</param>
    /// <param name = "_lineNum">Line number of SalesLine buffer.</param>
    /// <param name = "_modifiedFieldId">Field Id which triggers SalesLine::modifySalesQty.</param>
    internal static void cacheSalesLineModifySalesQtyFieldId(
        SalesId _salesId, LineNum _lineNum, FieldId _modifiedFieldId)
    {
        SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();
        objectCache.insert(salesLineModifySalesQtyFieldIdCacheSope, [_salesId, _lineNum], [_modifiedFieldId]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeCachedSalesLineModifySalesQtyFieldId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get and remove the cached field Id which triggers SalesLine::modifySalesQty. This also clears the cached value.
    /// </summary>
    /// <param name = "_salesId">Sales ID of SalesLine buffer.</param>
    /// <param name = "_lineNum">Line number of SalesLine buffer.</param>
    /// <returns>Field Id which triggers SalesLine::modifySalesQty.</returns>
    internal static FieldId removeCachedSalesLineModifySalesQtyFieldId(
        SalesId _salesId, LineNum _lineNum)
    {
        SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();
        container cache = objectCache.find(salesLineModifySalesQtyFieldIdCacheSope, [_salesId, _lineNum]);
        FieldId modifiedFieldId = 0;

        if (cache != conNull())
        {
            [modifiedFieldId] = cache;
            objectCache.remove(salesLineModifySalesQtyFieldIdCacheSope, [_salesId, _lineNum]);
        }

        return modifiedFieldId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxIntervalsForTaxGroups</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds and caches, or finds the cached, intersecting tax intervals that have configurations supported by the 'tax exempt for price inclusive' feature.
    /// </summary>
    /// <param name="salesTaxGroupId">
    /// The sales tax group.
    /// </param>
    /// <param name="itemTaxGroupId">
    /// The item tax group.
    /// </param>
    /// <returns>
    /// For the given item and sales tax groups, returns the intersecting tax intervals that have a supported configuration.
    /// </returns>
    public static List getTaxIntervalsForTaxGroups(TaxGroup salesTaxGroupId, TaxItemGroup itemTaxGroupId)
    {
        List taxIntervalsToReturn = new List(Types::Class);

        using(var telemetry = RetailPricingInstrumentationSegment::construct(classStr(RetailPricingCacheManager), funcName()))
        {
            SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();

            container taxIntervalsCached = objectCache.find(exemptTaxIntervalsCacheScope, [salesTaxGroupId, itemTaxGroupId]);

            if (taxIntervalsCached == conNull())
            {
                telemetry.addExtendedData(CacheMissKeyword, '1');

                List taxIntervalsToCache = new List(Types::Container);

                TaxGroupData    taxGroupData;
                TaxOnItem       taxOnItem;
                TaxData         taxData;
                TaxTable        taxTable;

                while select taxGroupData
                where taxGroupData.TaxGroup == salesTaxGroupId
                   && taxGroupData.ExemptTax == true
            join taxOnItem
                where taxOnItem.TaxItemGroup == itemTaxGroupId
                   && taxOnItem.TaxCode == taxGroupData.TaxCode
            join taxTable
                where taxTable.TaxCode == taxGroupData.TaxCode
                   && taxTable.TaxBase == TaxBaseType::PctPerNet
                   && taxTable.TaxLimitBase == TaxLimitBase::InvoiceWithoutVAT
                   && taxTable.TaxCalcMethod == TaxCalcMode::FullAmounts
            join taxData
                where taxData.TaxCode == taxGroupData.TaxCode
                {
                    RetailTaxIntervalCacheObject cacheObject = RetailTaxIntervalCacheObject::construct(taxData.TaxCode, taxData.TaxFromDate, taxData.TaxToDate, taxData.TaxLimitMin, taxData.TaxLimitMax, taxData.TaxValue);
                    taxIntervalsToReturn.addEnd(cacheObject);
                    taxIntervalsToCache.addEnd(cacheObject.pack());
                }

                // If the intersection is null, cache an empty object to ensure the selection isn't done again
                if (taxIntervalsToCache.elements() == 0)
                {
                    RetailTaxIntervalCacheObject cacheObject = RetailTaxIntervalCacheObject::constructEmpty();
                    taxIntervalsToReturn.addEnd(cacheObject);
                    taxIntervalsToCache.addEnd(cacheObject.pack());
                }

                objectCache.insert(exemptTaxIntervalsCacheScope, [salesTaxGroupId, itemTaxGroupId], list2Con(taxIntervalsToCache));
            }
            else
            {
                telemetry.addExtendedData(CacheHitKeyword, '1');

                List taxIntervalsFromCache = new List(Types::Container);

                taxIntervalsFromCache = con2List(taxIntervalsCached);

                ListIterator iterator = new ListIterator(taxIntervalsFromCache);

                while (iterator.more())
                {
                    RetailTaxIntervalCacheObject taxIntervalObject = RetailTaxIntervalCacheObject::constructEmpty();
                    taxIntervalObject.unpack(iterator.value());

                    taxIntervalsToReturn.addEnd(taxIntervalObject);

                    iterator.next();
                }
            }
        }

        return taxIntervalsToReturn;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCategoryIdListForPeriodicDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets list of category RecIds which are referenced by category-based discount lines of the given discount.
    /// </summary>
    /// <param name = "_periodicDiscountId">RecId of <c>RetailPeriodicDiscount</c>.</param>
    /// <returns>List of category RecIds which are referenced by category-based discount lines of the given discount.</returns>
    internal static Set getCategoryIdListForPeriodicDiscount(RefRecId _periodicDiscountId)
    {
        if (RetailPricingCacheManager::shouldDisableCache())
        {
            // This should not be called for flatten discount users. Given we no longer write to the cache, everything read from this will be wrong.
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        Set categoryIdSet = null;
        container cachedCategoryIds = conNull();

        using(var telemetry = RetailPricingInstrumentationSegment::construct(classStr(RetailPricingCacheManager), funcName()))
        {
            telemetry.addExtendedData('_periodicDiscountId', int642Str(_periodicDiscountId));

            SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();
            cachedCategoryIds = objectCache.find(categoryDiscountCategoryIdCacheSope, [_periodicDiscountId]);

            // No cached value.
            if (!cachedCategoryIds)
            {
                telemetry.addExtendedData(CacheMissKeyword, '1');

                categoryIdSet = new Set(Types::Int64);
                RetailOfferIdEx3 discountOfferId = RetailPeriodicDiscount::find(_periodicDiscountId).OfferId;
                RetailPeriodicDiscountLine periodicDiscountLine;
                RetailGroupMemberLine retailGroupMemberLine;

                RefRecId currentCategoryId;
                container periodicDiscountLineIds;

                while select Category from retailGroupMemberLine
                order by retailGroupMemberLine.Category asc
                where retailGroupMemberLine.Variant == 0
                    && retailGroupMemberLine.Product == 0
                    && retailGroupMemberLine.Category != 0
                join RecId from periodicDiscountLine
                    where periodicDiscountLine.OfferId == discountOfferId
                    && retailGroupMemberLine.RecId == periodicDiscountLine.RetailGroupMemberLine
                {
                    categoryIdSet.add(retailGroupMemberLine.Category);
                    cachedCategoryIds += retailGroupMemberLine.Category;

                    // Now it is a different category, need to the cache the value of periodicDiscountLineIds so far;
                    if (currentCategoryId != 0 && currentCategoryId != retailGroupMemberLine.Category)
                    {
                        objectCache.insert(categoryDiscountLineIdCacheSope, [_periodicDiscountId, currentCategoryId], periodicDiscountLineIds);
                        periodicDiscountLineIds = conNull();
                    }

                    currentCategoryId = retailGroupMemberLine.Category;
                    // There could be multiple discount lines for the same category, with different unit of measure.
                    periodicDiscountLineIds += periodicDiscountLine.RecId;
                }

                // Cache the value in the last round of while select.
                if (currentCategoryId > 0)
                {
                    objectCache.insert(categoryDiscountLineIdCacheSope, [_periodicDiscountId, retailGroupMemberLine.Category], periodicDiscountLineIds);
                }

                if (conLen(cachedCategoryIds) > 0)
                {
                    objectCache.insert(categoryDiscountCategoryIdCacheSope, [_periodicDiscountId], cachedCategoryIds);
                }
                else
                {
                    // Put 0 as RecId to indicate that the value has been searched but no result found.
                    objectCache.insert(categoryDiscountCategoryIdCacheSope, [_periodicDiscountId], [0]);
                }
            }
            else
            {
                telemetry.addExtendedData(CacheHitKeyword, '1');
            }

            // Value cahced, need to generate the set from cache.
            if (!categoryIdSet && cachedCategoryIds)
            {
                int firstRecId = conPeek(cachedCategoryIds, 1);

                // firstRecId = 0 means it has been searched before, but the discount does not have any category based lines.
                if (firstRecId > 0)
                {
                    categoryIdSet = new Set(Types::Int64);
                    int conLength = conLen(cachedCategoryIds);
                    RefRecId categoryId;
                    for (int i = 1; i <= conLength; i++)
                    {
                        categoryId = conPeek(cachedCategoryIds, i);
                        categoryIdSet.add(categoryId);
                    }
                }
            }
        }

        // We shall not return null as caller may not properly handle it - leading to NullReferenceException.
        if (!categoryIdSet)
        {
            categoryIdSet = new Set(Types::Int64);
        }

        return categoryIdSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCategoryLineIdForDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets RecID of category based discount line for given discount RecId and given category RecId.
    /// </summary>
    /// <param name = "_periodicDiscountId">RecId of <c>RetailPeriodicDiscount</c>.</param>
    /// <param name = "_categoryId">Category RecId of the discount line to be found.</param>
    /// <returns>Collection of discount line RecIds which are for the discount and based on the given category.</returns>
    internal static container getCategoryLineIdForDiscount(RefRecId _periodicDiscountId, RefRecId _categoryId)
    {
        if (RetailPricingCacheManager::shouldDisableCache())
        {
            // This should not be called for flatten discount users. Given we no longer write to the cache, everything read from this will be wrong.
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        container discountLineIds = conNull();

        using(var telemetry = RetailPricingInstrumentationSegment::construct(classStr(RetailPricingCacheManager), funcName()))
        {
            telemetry.addExtendedData('_periodicDiscountId', int642Str(_periodicDiscountId));
            telemetry.addExtendedData('_categoryId', int642Str(_categoryId));

            SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();
            discountLineIds = objectCache.find(categoryDiscountLineIdCacheSope, [_periodicDiscountId, _categoryId]);
            if (!discountLineIds)
            {
                telemetry.addExtendedData(CacheMissKeyword, '1');

                RetailPeriodicDiscount discount = RetailPeriodicDiscount::find(_periodicDiscountId);
                RetailPeriodicDiscountLine discountLine;
                RetailGroupMemberLine retailGroupMemberLine;
                while select RecId from discountLine
                where discountLine.OfferId == discount.OfferId
                exists join retailGroupMemberLine
                where retailGroupMemberLine.RecId == discountLine.RetailGroupMemberLine
                    && retailGroupMemberLine.Variant == 0
                    && retailGroupMemberLine.Product == 0
                    && retailGroupMemberLine.Category == _categoryId
                {
                    discountLineIds += discountLine.RecId;
                }

                objectCache.insert(categoryDiscountLineIdCacheSope, [_periodicDiscountId, _categoryId], discountLineIds);
            }
            else
            {
                telemetry.addExtendedData(CacheHitKeyword, '1');
            }
        }

        return discountLineIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCategoryLineCacheForPeriodicDiscount</Name>
				<Source><![CDATA[
    internal static void clearCategoryLineCacheForPeriodicDiscount(RefRecId _retailPeriodicDiscountId)
    {
        if (RetailPricingCacheManager::shouldDisableCache())
        {
            // When flatten discount feature is enabled and kill switch is not there, swallow this call.
            return ;
        }

         // Removes all category based line RecId cache for the discount.
        SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();
        // For perf reason, initiate clear call instead of looping through the cache and remove entries one by one.
        objectCache.clear(categoryDiscountLineIdCacheSope);

        // Remove entry of category Ids for the given discount.
        objectCache.remove(categoryDiscountCategoryIdCacheSope, [_retailPeriodicDiscountId]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearTaxIntervalCache</Name>
				<Source><![CDATA[
    internal static void clearTaxIntervalCache()
    {
        // It's a tax cache and hook's on Tax* tables - which are less frequently to be changed than category.
        SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();
        objectCache.clear(exemptTaxIntervalsCacheScope);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearDiscountCache</Name>
				<Source><![CDATA[
    internal static void clearDiscountCache()
    {
        if (RetailPricingCacheManager::shouldDisableCache())
        {
            // When flatten discount feature is enabled and kill switch is not there, swallow this call.
            return ;
        }

        SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();
        objectCache.clear(discountCacheScope);
        objectCache.clear(retailPeriodicDiscountNoExistsCacheScope);
        objectCache.clear(offerDiscountConfigCacheScope);
        objectCache.clear(shippingDiscountCacheScope);
        objectCache.clear(categoryDiscountCategoryIdCacheSope);
        objectCache.clear(categoryDiscountLineIdCacheSope);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCategoriesCache</Name>
				<Source><![CDATA[
    internal static void clearCategoriesCache()
    {
        if (RetailPricingCacheManager::shouldDisableCache())
        {
            // When flatten discount feature is enabled and kill switch is not there, swallow this call.
            return ;
        }

        SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();
        objectCache.clear(productCategoriesCacheScope);
        objectCache.clear(variantCategoriesCacheScope);
        objectCache.clear(categoryDiscountCategoryIdCacheSope);
        objectCache.clear(categoryDiscountLineIdCacheSope);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldDisableCache</Name>
				<Source><![CDATA[
    internal static boolean shouldDisableCache()
    {
        boolean featureEnabled = RetailPricingFeatureToggle::shouldUseRetailPricingDataManagerV3();
        boolean flightEnabled = RetailPricingDisableCacheForFlattenDiscountV2Flight::instance().isEnabled();

        boolean shippingDiscount = RetailShippingDiscountFeature::existsConfiguration();

        return featureEnabled && flightEnabled && !shippingDiscount;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>