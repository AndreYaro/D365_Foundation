<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BudgetControlTrackingUpdate</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>BudgetControlTrackingUpdate</c> class and its sub-classes manage budget control tracking
/// information, depending on whether relieving management is required.
/// </summary>
public class BudgetControlTrackingUpdate
{
    BudgetSourceRecId budgetSourceRecId;
    BudgetSourceTrackingStatus trackingStatus;
    BudgetControlCategory budgetControlCategory;

    TransDate trackingDate;
    userId trackingUserId;
    Num trackingNumber;

    BudgetModel budgetModel;

    boolean requiresRelieving;
    boolean isCarryforward;
    boolean isClosing;
    boolean isSimulation;
    BudgetSourceRecId simulatedBudgetSourceRecId;

    boolean isBudgetSourceTracked;
    boolean isCleanUpTracking;
    boolean isBudgetSourceValid;
    boolean arePendingDeletionsPrepared;
    boolean areRelievingDetailsPrepared;
    boolean areTrackingDetailsPrepared;
    boolean areReturnDetailsPrepared;
    boolean areRelievingPendingDeletionsPrepared;
    boolean areCarryforwardDetailsPrepared;

    sequenceNum currentTrackingSequenceNumber;

    BudgetSourceTracking currentBudgetSourceTracking;
    BudgetSourceTracking removalBudgetSourceTracking;
    BudgetSourceTracking lastBudgetSourceTracking;
    BudgetSourceTracking budgetSourceTrackingToSimulate;
    BudgetSourceTracking budgetSourceTrackingToReturnAmounts;

    Map reversedSourceLedgerDimensionDetails;

    Set budgetSourceTrackingRecIdsToRemove;

    #define.InverseSign(-1)
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>activateTracking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Activates the tracking process.
    /// </summary>
    /// <param name="_isBudgetSourceValid">
    /// A Boolean value that indicates whether the <c>BudgetSource</c> record is valid.
    /// </param>
    /// <remarks>
    /// This method can only be called one time per <c>BudgetControlTrackingUpdate</c> object and must be
    /// called before the <c>trackLedgerDimension</c>, <c>relieveSourceLedgerDimension</c>, and
    /// <c>finalizeTracking</c> methods.
    /// </remarks>
    public final void activateTracking(boolean _isBudgetSourceValid)
    {
        isBudgetSourceValid = _isBudgetSourceValid;

        // Remove existing budget source references from budget source tracking and budget source tracking details.
        this.cleanUpTracking();
    }

]]></Source>
			</Method>
			<Method>
				<Name>arePendingDeletionsPrepared</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether any pending deletions were prepared by this instance.
    /// </summary>
    /// <returns>
    /// true if pending deletions were prepared; otherwise, false.
    /// </returns>
    public boolean arePendingDeletionsPrepared()
    {
        return arePendingDeletionsPrepared;
    }

]]></Source>
			</Method>
			<Method>
				<Name>areRelievingDetailsPrepared</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether any relieving details were prepared by this instance.
    /// </summary>
    /// <returns>
    /// true if relieving details were prepared; otherwise, false.
    /// </returns>
    public boolean areRelievingDetailsPrepared()
    {
        return areRelievingDetailsPrepared;
    }

]]></Source>
			</Method>
			<Method>
				<Name>areRelievingPendingDeletionsPrepared</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether any relieving detail pending deletions were prepared by this instance.
    /// </summary>
    /// <returns>
    /// true if relieving detail pending deletions were prepared; otherwise, false.
    /// </returns>
    public boolean areRelievingPendingDeletionsPrepared()
    {
        return areRelievingPendingDeletionsPrepared;
    }

]]></Source>
			</Method>
			<Method>
				<Name>areReturnDetailsPrepared</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a flag that indicates whether any return details were prepared by this instance.
    /// </summary>
    /// <returns>
    /// true if return details were prepared; otherwise, false.
    /// </returns>
    public boolean areReturnDetailsPrepared()
    {
        return areReturnDetailsPrepared;
    }

]]></Source>
			</Method>
			<Method>
				<Name>areTrackingDetailsPrepared</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether any tracking details were prepared by this instance.
    /// </summary>
    /// <returns>
    /// true if tracking details were prepared; otherwise, false.
    /// </returns>
    public boolean areTrackingDetailsPrepared()
    {
        return areTrackingDetailsPrepared;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpTracking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks any prior budget tracking information that is not in a Confirmed status for the
    /// <c>BudgetSource</c> record as delete pending.
    /// </summary>
    protected void cleanUpTracking()
    {
        isCleanUpTracking = true;
        this.removeTracking();
    }

]]></Source>
			</Method>
			<Method>
				<Name>collapseRelievingDetailRecords</Name>
				<Source><![CDATA[
    private void collapseRelievingDetailRecords(RecId _trackingDetailRecIdToCollapse1, RecId _trackingDetailRecIdToCollapse2)
    {
        BudgetSourceTrackingRelievingDetail relievingDetailToCollapse, relievingDetailToRemove, pairedRelievingDetail;

        ttsBegin;

        while select forUpdate AccountingCurrencyAmount from relievingDetailToCollapse
            where relievingDetailToCollapse.RelievedBudgetSourceTrackingDetail == _trackingDetailRecIdToCollapse1
            join pairedRelievingDetail
                where pairedRelievingDetail.RelievedBudgetSourceTrackingDetail == _trackingDetailRecIdToCollapse2
                    && pairedRelievingDetail.RelievingBudgetSourceTracking == relievingDetailToCollapse.RelievingBudgetSourceTracking
                    && pairedRelievingDetail.RelievingBudgetSourceLedgerDimension == relievingDetailToCollapse.RelievingBudgetSourceLedgerDimension
                    && pairedRelievingDetail.IsReturnOfBudgetFunds == relievingDetailToCollapse.IsReturnOfBudgetFunds
        {
            // Combine the amounts into the first relieving detail record.
            relievingDetailToCollapse.AccountingCurrencyAmount += pairedRelievingDetail.AccountingCurrencyAmount;
            relievingDetailToCollapse.update();

            // Delete the other relieving detail record.
            select forUpdate firstOnly RecId from relievingDetailToRemove
                where relievingDetailToRemove.RecId == pairedRelievingDetail.RecId;

            relievingDetailToRemove.delete();
        }

        update_recordSet relievingDetailToCollapse
            setting RelievedBudgetSourceTrackingDetail = _trackingDetailRecIdToCollapse1
                where relievingDetailToCollapse.RelievedBudgetSourceTrackingDetail == _trackingDetailRecIdToCollapse2;

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetSource</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a <c>BudgetSourceTracking</c> record for the <c>BudgetSource</c> record.
    /// </summary>
    protected void createBudgetSource()
    {
        if (isSimulation)
        {
            this.createSourceTrackingAsSimulation();
        }
        else
        {
            this.createSourceTrackingAsNonSimulation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReturnDetailsForSimulation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates return tracking details for simulation.
    /// </summary>
    protected void createReturnDetailsForSimulation()
    {
        BudgetSourceTrackingDetail budgetSourceTrackingDetail;

        this.determineSourceTrackingToSimulate();

        if (budgetSourceTrackingToSimulate)
        {
            while select * from budgetSourceTrackingDetail
                where budgetSourceTrackingDetail.BudgetSourceTracking == budgetSourceTrackingToSimulate.RecId &&
                    budgetSourceTrackingDetail.IsReturnOfBudgetFunds == NoYes::No
            {
                if (!isBudgetSourceTracked)
                {
                    this.createBudgetSource();

                    isBudgetSourceTracked = true;
                }

                this.createTrackingDetail(
                    currentBudgetSourceTracking.RecId,
                    budgetSourceTrackingDetail.PrimaryLedger,
                    budgetSourceTrackingDetail.BudgetSourceLedgerDimension,
                    budgetSourceTrackingDetail.BudgetControlRule,
                    budgetSourceTrackingDetail.BudgetGroupMember,
                    budgetSourceTrackingDetail.BudgetControlLedgerDimension,
                    budgetSourceTrackingDetail.AccountingCurrencyAmount * #InverseSign,
                    budgetSourceTrackingDetail.IsCarryForward,
                    NoYes::Yes);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReturnRemainingDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates budget source tracking return details for all remaining confirmed funds for the budget source.
    /// </summary>
    protected void createReturnRemainingDetails()
    {
        BudgetSourceTrackingDetail budgetSourceTrackingDetail;
        BudgetSourceTracking budgetSourceTracking;

        while select sum(AccountingCurrencyAmount)
            from budgetSourceTrackingDetail
                where budgetSourceTrackingDetail.IsDeletePending == NoYes::No &&
                    budgetSourceTrackingDetail.IsSummarized == NoYes::Yes
            join RecId from budgetSourceTracking
                group by budgetSourceTrackingDetail.PrimaryLedger,
                    budgetSourceTrackingDetail.BudgetSourceLedgerDimension,
                    budgetSourceTrackingDetail.BudgetControlLedgerDimension,
                    budgetSourceTrackingDetail.IsCarryForward
                where budgetSourceTracking.RecId == budgetSourceTrackingDetail.BudgetSourceTracking &&
                    budgetSourceTracking.BudgetSource == budgetSourceRecId &&
                    budgetSourceTracking.IsDeletePending == NoYes::No
        {
            if (budgetSourceTrackingDetail.AccountingCurrencyAmount)
            {
                this.trackBudgetSourceForReturnRemaining();

                this.createTrackingDetail(
                        currentBudgetSourceTracking.RecId,
                        budgetSourceTrackingDetail.PrimaryLedger,
                        budgetSourceTrackingDetail.BudgetSourceLedgerDimension,
                        0,
                        0,
                        budgetSourceTrackingDetail.BudgetControlLedgerDimension,
                        budgetSourceTrackingDetail.AccountingCurrencyAmount * #InverseSign,
                        budgetSourceTrackingDetail.IsCarryForward,
                        NoYes::Yes);
            }

            // Otherwise do nothing because the budget source has not been tracked with funds before.
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSourceTracking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a tracking record for the budget source.
    /// </summary>
    /// <param name="_budgetSourceId">
    /// The identity for the budget source.
    /// </param>
    /// <param name="_budgetControlCategory">
    /// The budget control category for the budget funds.
    /// </param>
    /// <param name="_status">
    /// The status for the budget funds.
    /// </param>
    /// <param name="_budgetDate">
    /// The transaction date for which the budget funds are created.
    /// </param>
    /// <param name="_budgetUser">
    /// The user ID of the user who creates the budget funds.
    /// </param>
    /// <param name="_sequenceNumber">
    /// The sequence number for the <c>BudgetSourceTracking</c> record.
    /// </param>
    /// <param name="_trackingNumber">
    /// A user-friendly unique number that is used by the user to identify the budget funds; optional.
    /// </param>
    /// <param name="_isSimulation">
    /// A Boolean value that indicates whether the budget funds is a simulation; optional.
    /// </param>
    /// <param name="_budgetModelId">
    /// The budget model identity that is associated to the budget funds; optional.
    /// </param>
    /// <param name="_budgetModelSubModelId">
    /// The budget model sub model identity that is associated to the budget funds; optional.
    /// </param>
    /// <param name="_budgetModelType">
    /// The budget model type that is associated to the budget funds; optional.
    /// </param>
    /// <param name="_budgetModelDataAreaId">
    /// The budget model data area that is associated to the budget funds; optional.
    /// </param>
    protected void createSourceTracking(
        BudgetSourceRecId _budgetSourceId,
        BudgetControlCategory _budgetControlCategory,
        BudgetSourceTrackingStatus _status,
        TransDate _budgetDate,
        userId  _budgetUser,
        sequenceNum _sequenceNumber,
        Num _trackingNumber = '',
        boolean _isSimulation = false,
        BudgetModelId _budgetModelId = '',
        BudgetModelSubId _budgetModelSubModelId = '',
        HeadingSub _budgetModelType = HeadingSub::Heading,
        DataAreaId _budgetModelDataAreaId = '')
    {
        currentBudgetSourceTracking.clear();
        currentBudgetSourceTracking.BudgetSource = _budgetSourceId;
        currentBudgetSourceTracking.Category = _budgetControlCategory;
        currentBudgetSourceTracking.Status = _status;
        currentBudgetSourceTracking.TrackingDate = _budgetDate;
        currentBudgetSourceTracking.TrackingUser = _budgetUser;
        currentBudgetSourceTracking.SequenceNumber = _sequenceNumber;
        currentBudgetSourceTracking.TrackingNumber = _trackingNumber;
        currentBudgetSourceTracking.IsSimulation = _isSimulation;

        if (_budgetModelId)
        {
            currentBudgetSourceTracking.BudgetModelId = _budgetModelId;
            currentBudgetSourceTracking.BudgetModelType = _budgetModelType;
            currentBudgetSourceTracking.BudgetModelSubModelId = _budgetModelSubModelId;
            currentBudgetSourceTracking.BudgetModelDataAreaId = _budgetModelDataAreaId;
            currentBudgetSourceTracking.IsDefaultBudgetModel = NoYes::No;
        }
        else
        {
            currentBudgetSourceTracking.IsDefaultBudgetModel = NoYes::Yes;
        }

        currentBudgetSourceTracking.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSourceTrackingAsNonSimulation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a tracking record for non-simulation budget source.
    /// </summary>
    protected void createSourceTrackingAsNonSimulation()
    {
        this.determineTrackingSequenceNumber();
        this.determineSourceTrackingToReturn();

        this.logConfirmedStatusMovingToDraft();

        this.createSourceTracking(
            budgetSourceRecId,
            budgetControlCategory,
            trackingStatus,
            trackingDate,
            trackingUserId,
            currentTrackingSequenceNumber,
            trackingNumber,
            isSimulation,
            budgetModel.ModelId,
            budgetModel.SubModelId,
            budgetModel.Type,
            budgetModel.dataAreaId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>logConfirmedStatusMovingToDraft</Name>
				<Source><![CDATA[
    private void logConfirmedStatusMovingToDraft()
    {
        if (lastBudgetSourceTracking
            && lastBudgetSourceTracking.Status == BudgetSourceTrackingStatus::Confirmed
            && trackingStatus == BudgetSourceTrackingStatus::Draft)
        {
            BudgetControlInstrumentationLogger::createLogger(classStr(BudgetControlTrackingUpdate))
                .processing()
                .logConfirmedStatusMovingToDraft(
                    lastBudgetSourceTracking.RecId,
                    budgetSourceRecId,
                    budgetControlCategory);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSourceTrackingAsSimulation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a tracking record for simulation budget source.
    /// </summary>
    protected void createSourceTrackingAsSimulation()
    {
        this.determineTrackingSequenceNumber();
        this.determineSourceTrackingToSimulate();

        this.createSourceTracking(
            budgetSourceRecId,
            budgetControlCategory,
            trackingStatus,
            trackingDate,
            trackingUserId,
            currentTrackingSequenceNumber,
            trackingNumber,
            isSimulation,
            budgetModel.ModelId,
            budgetModel.SubModelId,
            budgetModel.Type,
            budgetModel.dataAreaId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTrackingDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a budget source tracking detail record.
    /// </summary>
    /// <param name="_budgetSourceTrackingId">
    /// The budget source tracking to which the detail record belongs.
    /// </param>
    /// <param name="_primaryLedgerId">
    /// The primary ledger record identity for the detail.
    /// </param>
    /// <param name="_sourceLedgerDimension">
    /// The source ledger dimension for the detail.
    /// </param>
    /// <param name="_controlRuleId">
    /// The control rule record identity for the detail.
    /// </param>
    /// <param name="_groupMemberId">
    /// The control group member record identity for the detail.
    /// </param>
    /// <param name="_controlLedgerDimension">
    /// The control ledger dimension for the detail.
    /// </param>
    /// <param name="_accountingCurrencyAmount">
    /// The accounting currency amount for the detail.
    /// </param>
    /// <param name="_isCarryforward">
    /// Indicates whether the amounts for the detail are carry-forward amounts.
    /// </param>
    /// <param name="_isReturnOfBudgetFunds">
    /// Indicates whether the amount for the detail is a return of budget funds.
    /// </param>
    /// <returns>
    /// A <c>BudgetSourceTrackingDetail</c> record.
    /// </returns>
    protected budgetSourceTrackingDetail createTrackingDetail(
        recId _budgetSourceTrackingId,
        LedgerRecId _primaryLedgerId,
        LedgerDimensionBase _sourceLedgerDimension,
        recId _controlRuleId,
        recId _groupMemberId,
        LedgerDimensionBudgetControl _controlLedgerDimension,
        AmountMST _accountingCurrencyAmount,
        boolean _isCarryforward,
        boolean _isReturnOfBudgetFunds)
    {
        BudgetSourceTrackingDetail budgetSourceTrackingDetail;
        BudgetSourceTrackingDetailClosing budgetSourceTrackingDetailClosing;

        select firstOnly forUpdate budgetSourceTrackingDetail
            where budgetSourceTrackingDetail.BudgetSourceTracking == _budgetSourceTrackingId
                && budgetSourceTrackingDetail.IsReturnOfBudgetFunds == _isReturnOfBudgetFunds
                && budgetSourceTrackingDetail.BudgetSourceLedgerDimension == _sourceLedgerDimension
                && budgetSourceTrackingDetail.PrimaryLedger == _primaryLedgerId
                && budgetSourceTrackingDetail.IsCarryForward == _isCarryforward;

        budgetSourceTrackingDetail.BudgetSourceTracking = _budgetSourceTrackingId;
        budgetSourceTrackingDetail.PrimaryLedger = _primaryLedgerId;
        budgetSourceTrackingDetail.BudgetSourceLedgerDimension = _sourceLedgerDimension;
        budgetSourceTrackingDetail.BudgetControlRule = _controlRuleId;
        budgetSourceTrackingDetail.BudgetGroupMember = _groupMemberId;
        budgetSourceTrackingDetail.BudgetControlLedgerDimension = _controlLedgerDimension;
        budgetSourceTrackingDetail.AccountingCurrencyAmount += _accountingCurrencyAmount;
        budgetSourceTrackingDetail.IsCarryForward = _isCarryforward;
        budgetSourceTrackingDetail.IsReturnOfBudgetFunds = _isReturnOfBudgetFunds;
        budgetSourceTrackingDetail.IsDeletePending = NoYes::No;
        budgetSourceTrackingDetail.IsSummarized = NoYes::No;
        budgetSourceTrackingDetail.write();

        if (isClosing && isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            budgetSourceTrackingDetailClosing.BudgetSourceTrackingDetail = budgetSourceTrackingDetail.RecId;
            budgetSourceTrackingDetailClosing.insert();
        }

        if (_isReturnOfBudgetFunds)
        {
            areReturnDetailsPrepared = true;
        }
        else
        {
            areTrackingDetailsPrepared = true;
        }

        return budgetSourceTrackingDetail;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineLastSourceTracking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the last <c>BudgetSourceTracking</c> record that is associated with the
    /// <c>BudgetSource</c> record.
    /// </summary>
    protected void determineLastSourceTracking()
    {
        lastBudgetSourceTracking = BudgetSourceTracking::findByBudgetSource(budgetSourceRecId);

        // Cache the tracking sequence number for subsequent processing
        currentTrackingSequenceNumber = lastBudgetSourceTracking.SequenceNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineRemovalSource</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the <c>BudgetSource</c> record can be removed and marks it for removal.
    /// </summary>
    protected void determineRemovalSource()
    {
        BudgetSource sourceToRemove;
        BudgetSourceTracking localSourceTracking;

        sourceToRemove.concurrencyModel(ConcurrencyModel::Pessimistic);

        select firstOnly localSourceTracking
            where localSourceTracking.IsDeletePending != NoYes::Yes &&
                  localSourceTracking.BudgetSource == budgetSourceRecId;

        if (!localSourceTracking)
        {
            update_recordSet sourceToRemove
                setting IsDeletePending = NoYes::Yes
                where sourceToRemove.RecId == budgetSourceRecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineRemovalSourceTracking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the <c>BudgetSourceTracking</c> records that are associated with the
    /// <c>BudgetSource</c> record are to be removed.
    /// </summary>
    protected void determineRemovalSourceTracking()
    {
        removalBudgetSourceTracking.clear();
        removalBudgetSourceTracking.concurrencyModel(ConcurrencyModel::Auto);

        if (isCleanUpTracking)
        {
            this.determineLastSourceTracking();

            if (lastBudgetSourceTracking.Status == BudgetSourceTrackingStatus::Draft)
            {
                // Find the budget source tracking that needs to be removed.
                removalBudgetSourceTracking = BudgetSourceTracking::findByBudgetSource(budgetSourceRecId, true);

                budgetSourceTrackingRecIdsToRemove.add(removalBudgetSourceTracking.RecId);
                arePendingDeletionsPrepared = true;

                // The last budget source tracking has been removed - re-find the lastBudgetSourceTracking
                // so subsequent processing can reference correctly

                select firstOnly * from lastBudgetSourceTracking
                    order by SequenceNumber desc
                    where lastBudgetSourceTracking.RecId != removalBudgetSourceTracking.RecId &&
                        lastBudgetSourceTracking.BudgetSource == budgetSourceRecId;
            }
        }
        else
        {
            // Explicit budget source removal request
            while select RecId from removalBudgetSourceTracking
                where removalBudgetSourceTracking.Status != BudgetSourceTrackingStatus::Confirmed ||
                      (removalBudgetSourceTracking.Status == BudgetSourceTrackingStatus::Confirmed &&
                       removalBudgetSourceTracking.IsSimulation == true) &&
                      removalBudgetSourceTracking.BudgetSource == budgetSourceRecId
            {
                budgetSourceTrackingRecIdsToRemove.add(removalBudgetSourceTracking.RecId);
                arePendingDeletionsPrepared = true;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineSourceTrackingToReturn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the tracking record to return funds.
    /// </summary>
    protected void determineSourceTrackingToReturn()
    {
        if (lastBudgetSourceTracking && lastBudgetSourceTracking.Status == BudgetSourceTrackingStatus::Confirmed)
        {
            budgetSourceTrackingToReturnAmounts = BudgetSourceTracking::findByBudgetSource(lastBudgetSourceTracking.BudgetSource);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineSourceTrackingToSimulate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the tracking record for the budget source to simulate.
    /// </summary>
    protected void determineSourceTrackingToSimulate()
    {
        if (simulatedBudgetSourceRecId)
        {
            budgetSourceTrackingToSimulate = BudgetSourceTracking::findByBudgetSource(simulatedBudgetSourceRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineTrackingSequenceNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the sequence number for the tracking record.
    /// </summary>
    protected void determineTrackingSequenceNumber()
    {
        if (currentTrackingSequenceNumber)
        {
            // There is already a budget source tracking sequence for the budget source, increment the sequence.
            currentTrackingSequenceNumber++;
        }
        else
        {
            // There is not yet a budget source tracking for the budget source, start the sequence.
            currentTrackingSequenceNumber = 1;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAmountInTracking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the carry-forward and non-carry-forward amounts for the specified
    /// <c>BudgetSourceDetail</c> object.
    /// </summary>
    /// <param name="_primaryLedgerId">
    /// The ID for the primary <c>Ledger</c> record.
    /// </param>
    /// <param name="_budgetSourceDetail">
    /// A <c>BudgetSourceDetail</c> object.
    /// </param>
    /// <returns>
    /// A container that contains both the carry-forward and non-carry-forward amounts in tracking.
    /// </returns>
    protected container getAmountInTracking(LedgerRecId _primaryLedgerId, BudgetSourceDetail _budgetSourceDetail)
    {
        AmountMST carryforwardAmount;
        AmountMST nonCarryforwardAmount;

        container amounts;

        BudgetSourceTracking budgetSourceTracking;
        BudgetSourceTrackingDetail budgetSourceTrackingDetail;

        if (budgetSourceTrackingToReturnAmounts)
        {
            while select sum(AccountingCurrencyAmount) from budgetSourceTrackingDetail
                group by budgetSourceTrackingDetail.IsCarryForward
                join RecId from budgetSourceTracking
                    where budgetSourceTracking.RecId == budgetSourceTrackingDetail.BudgetSourceTracking &&
                        budgetSourceTracking.IsDeletePending == NoYes::No &&
                        budgetSourceTracking.BudgetSource == budgetSourceTrackingToReturnAmounts.BudgetSource &&
                        budgetSourceTrackingDetail.BudgetSourceLedgerDimension == _budgetSourceDetail.parmLedgerDimension() &&
                        budgetSourceTrackingDetail.PrimaryLedger == _primaryLedgerId &&
                        budgetSourceTrackingDetail.IsSummarized == NoYes::Yes &&
                        budgetSourceTrackingDetail.IsDeletePending == NoYes::No
            {
                if (budgetSourceTrackingDetail.IsCarryForward == NoYes::Yes)
                {
                    carryforwardAmount = budgetSourceTrackingDetail.AccountingCurrencyAmount;
                }
                else
                {
                    nonCarryforwardAmount = budgetSourceTrackingDetail.AccountingCurrencyAmount;
                }
            }
        }

        amounts = [carryforwardAmount, nonCarryforwardAmount];

        return amounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPendingCarryforwardAmountReturned</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the pending carry-forward amounts returned for the specified budget source ledger dimension
    /// and current budget source tracking in the specified primary ledger.
    /// </summary>
    /// <param name="_primaryLedgerId">
    /// The ID for the primary ledger record.
    /// </param>
    /// <param name="_sourceLedgerDimension">
    /// The ledger dimension from the integration source.
    /// </param>
    /// <returns>
    /// The pending carry-forward amount returned in accounting currency.
    /// </returns>
    protected AmountMST getPendingCarryforwardAmountReturned(
        LedgerRecId _primaryLedgerId,
        LedgerDimensionBase _sourceLedgerDimension)
    {
        BudgetSourceTrackingDetail budgetSourceTrackingDetail;

        select sum(AccountingCurrencyAmount)
            from budgetSourceTrackingDetail
                where budgetSourceTrackingDetail.BudgetSourceLedgerDimension == _sourceLedgerDimension
                    && budgetSourceTrackingDetail.PrimaryLedger == _primaryLedgerId
                    && budgetSourceTrackingDetail.IsCarryForward == NoYes::Yes
                    && BudgetSourceTrackingDetail.IsReturnOfBudgetFunds == NoYes::Yes
                    && budgetSourceTrackingDetail.BudgetSourceTracking == currentBudgetSourceTracking.RecId;

        return budgetSourceTrackingDetail.AccountingCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTrackedCarryforwardAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tracked carry-forward amounts for the specified budget source ledger dimension in the
    /// specified primary ledger.
    /// </summary>
    /// <param name="_primaryLedgerId">
    /// The ID for the primary <c>Ledger</c> record.
    /// </param>
    /// <param name="_budgetSourceId">
    /// The ID for the <c>BudgetSource</c> record.
    /// </param>
    /// <param name="_sourceLedgerDimension">
    /// The ledger dimension from the integration source.
    /// </param>
    /// <returns>
    /// The carry-forward accounting currency amount.
    /// </returns>
    protected AmountMST getTrackedCarryforwardAmount(
        LedgerRecId _primaryLedgerId,
        BudgetSourceRecId _budgetSourceId,
        LedgerDimensionBase _sourceLedgerDimension)
    {
        BudgetSourceTrackingDetail budgetSourceTrackingDetail;
        BudgetSourceTracking budgetSourceTracking;

        select sum(AccountingCurrencyAmount)
            from budgetSourceTrackingDetail
                where budgetSourceTrackingDetail.BudgetSourceLedgerDimension == _sourceLedgerDimension &&
                    budgetSourceTrackingDetail.PrimaryLedger == _primaryLedgerId &&
                    budgetSourceTrackingDetail.IsCarryForward == NoYes::Yes
            exists join budgetSourceTracking
                where budgetSourceTrackingDetail.BudgetSourceTracking == budgetSourceTracking.RecId &&
                    budgetSourceTracking.RecId != currentBudgetSourceTracking.RecId &&
                    budgetSourceTracking.RecId != removalBudgetSourceTracking.RecId &&
                    budgetSourceTracking.BudgetSource == _budgetSourceId;

        return budgetSourceTrackingDetail.AccountingCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeForProcessing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>BudgetControlTrackingUpdate</c> class.
    /// </summary>
    /// <param name="_budgetSourceRecId">
    /// The record ID of the <c>BudgetSource</c> record for which to track.
    /// </param>
    /// <param name="_isDraft">
    /// A Boolean value that indicates whether the budget source tracking status is draft.
    /// </param>
    /// <param name="_budgetControlCategory">
    /// The <c>BudgetControlCategory</c> enumeration value for which to categorize the budget source
    /// tracking.
    /// </param>
    /// <param name="_trackingDate">
    /// The tracking date for the budget source tracking.
    /// </param>
    /// <param name="_trackingUserId">
    /// The tracking user ID for the budget source tracking.
    /// </param>
    /// <param name="_trackingNumber">
    /// The tracking number for the budget source tracking.
    /// </param>
    /// <param name="_requiresRelieving">
    /// A Boolean value that indicates whether the budget source tracking requires relieving; optional.
    /// </param>
    /// <param name="_budgetModel">
    /// The <c>BudgetModel</c> record for the budget source tracking; optional.
    /// </param>
    /// <param name="_isCarryforward">
    /// A Boolean value that indicates whether the budget source tracking amounts are carry-forward
    /// amounts; optional.
    /// </param>
    /// <param name="_isSimulation">
    /// A Boolean value that indicates whether the budget source tracking is a simulation; optional.
    /// </param>
    /// <param name="_simulatedBudgetSourceRecId">
    /// The record ID of the simulated <c>BudgetSource</c> record; optional.
    /// </param>
    protected void initializeForProcessing(
        BudgetSourceRecId _budgetSourceRecId,
        boolean _isDraft,
        BudgetControlCategory _budgetControlCategory,
        TransDate _trackingDate,
        userId _trackingUserId,
        Num _trackingNumber,
        boolean _requiresRelieving = false,
        BudgetModel _budgetModel = null,
        boolean _isCarryforward = false,
        boolean _isSimulation = false,
        BudgetSourceRecId _simulatedBudgetSourceRecId = 0)
    {
        budgetSourceRecId = _budgetSourceRecId;
        budgetControlCategory = _budgetControlCategory;

        if (_isDraft)
        {
            trackingStatus = BudgetSourceTrackingStatus::Draft;
        }
        else
        {
            trackingStatus = BudgetSourceTrackingStatus::Confirmed;
        }

        trackingDate = _trackingDate;
        trackingUserId = _trackingUserId;
        trackingNumber = _trackingNumber;

        budgetModel = _budgetModel;

        requiresRelieving = _requiresRelieving;
        isCarryforward = _isCarryforward;
        isSimulation = _isSimulation;
        simulatedBudgetSourceRecId = _simulatedBudgetSourceRecId;

        reversedSourceLedgerDimensionDetails = new Map(typeName2Type(extendedtypestr(recId)), Types::Class);
        budgetSourceTrackingRecIdsToRemove = new Set(typename2type(extendedTypeStr(recId)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeForRemoval</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the <c>BudgetControlTrackingUpdate</c> class.
    /// </summary>
    /// <param name="_budgetSourceRecId">
    ///    The record ID of the <c>BudgetSource</c> record for which to track.
    /// </param>
    protected void initializeForRemoval(BudgetSourceRecId _budgetSourceRecId)
    {
        budgetSourceRecId = _budgetSourceRecId;
        budgetSourceTrackingRecIdsToRemove = new Set(typename2type(extendedTypeStr(BudgetSourceRecId)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeForReturnRemaining</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the <c>BudgetControlTrackingUpdate</c> class.
    /// </summary>
    /// <param name="_budgetSourceRecId">
    ///    The record ID of the <c>BudgetSource</c> record for which to track.
    /// </param>
    /// <param name="_returnRemainingDate">
    /// The date to account for the returning remaining funds.
    /// </param>
    /// <param name="_returnRemainingUser">
    /// The user who is returning remaining funds.
    /// </param>
    /// <param name="_doReturnAsClosing">
    /// A boolean indicating whether to return the funds as a closing entry; optional.
    /// </param>
    protected void initializeForReturnRemaining(
        BudgetSourceRecId _budgetSourceRecId,
        TransDate _returnRemainingDate,
        userId _returnRemainingUser,
        boolean _doReturnAsClosing = false)
    {
        budgetSourceRecId = _budgetSourceRecId;
        trackingDate = _returnRemainingDate;
        trackingUserId = _returnRemainingUser;
        isClosing = _doReturnAsClosing;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>relieveSourceLedgerDimensionAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Relieves the specified amount from the specified relieving ledger dimension detail.
    /// </summary>
    /// <param name="_primaryLedgerIdToRelieve">
    /// The ID of the primary <c>Ledger</c> record to relieve budget funds.
    /// </param>
    /// <param name="_controlLedgerDimension">
    /// The budget control ledger dimension that is relieving the budget funds.
    /// </param>
    /// <param name="_relievingDetail">
    /// The <c>BudgetRelievingDetail</c> object that contains the ledger dimension detail for budget funds
    /// relieving.
    /// </param>
    /// <exception cref="M:Exception::Error">
    /// This method was not overridden.
    /// </exception>
    public void relieveSourceLedgerDimensionAmount(
        LedgerRecId _primaryLedgerIdToRelieve,
        LedgerDimensionBudgetControl _controlLedgerDimension,
        BudgetRelievingDetail _relievingDetail)
    {
        throw error(Error::missingOverride(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeLastSourceTracking</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Marks the <c>BudgetSourceTracking</c> records for the <c>BudgetSource</c> record as pending deletion.
    /// </summary>
    protected void removeLastSourceTracking()
    {
        SetEnumerator removeElements;

        if (budgetSourceTrackingRecIdsToRemove.elements() > 0)
        {
            removeElements = budgetSourceTrackingRecIdsToRemove.getEnumerator();

            while (removeElements.moveNext())
            {
                removalBudgetSourceTracking = BudgetSourceTracking::find(removeElements.current(), true, ConcurrencyModel::Pessimistic);
                removalBudgetSourceTracking.IsDeletePending = NoYes::Yes;
                removalBudgetSourceTracking.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeLastSourceTrackingDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks the <c>BudgetSourceTrackingDetail</c> records that are associated with
    /// <c>BudgetSourceTracking</c> records and are marked for deletion as pending deletion.
    /// </summary>
    protected void removeLastSourceTrackingDetail()
    {
        BudgetSourceTrackingDetail budgetSourceTrackingDetail;
        SetEnumerator removeElements;

        if (budgetSourceTrackingRecIdsToRemove.elements() > 0)
        {
            budgetSourceTrackingDetail.concurrencyModel(ConcurrencyModel::Pessimistic);

            removeElements = budgetSourceTrackingRecIdsToRemove.getEnumerator();

            while (removeElements.moveNext())
            {
                removalBudgetSourceTracking = BudgetSourceTracking::find(removeElements.current());

                update_recordSet budgetSourceTrackingDetail
                    setting IsDeletePending = NoYes::Yes
                    where budgetSourceTrackingDetail.BudgetSourceTracking == removalBudgetSourceTracking.RecId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeTracking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks the last budget tracking information for the <c>BudgetSource</c> record as delete pending.
    /// </summary>
    /// <param name="_includeBudgetSource">
    /// A Boolean value that indicates whether to remove the budget source; optional.
    /// </param>
    public void removeTracking(boolean _includeBudgetSource = false)
    {
        this.determineRemovalSourceTracking();
        this.removeLastSourceTrackingDetail();
        this.removeLastSourceTracking();

        if (_includeBudgetSource)
        {
            this.determineRemovalSource();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnRemainingFunds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets all remaining confirmed funds for the budget source.
    /// </summary>
    public void returnRemainingFunds()
    {
        if (isSimulation)
        {
            // This API does not support returning remaining funds as simulation.
            throw error("@Budget:BudgetReturnRemainingFundsNotSupportSimulationError");
        }
        else
        {
            this.determineLastSourceTracking();

            if (lastBudgetSourceTracking && lastBudgetSourceTracking.Status != BudgetSourceTrackingStatus::Confirmed)
            {
                // This API does not support returning remaining funds for draft budget sources.
                // Use removeTracking API to remove funds for draft budget sources.
                throw error("@Budget:BudgetSourceTrackingNotConfirmedError");
            }

            this.determineTrackingSequenceNumber();
            this.determineSourceTrackingToReturn();

            if (budgetSourceTrackingToReturnAmounts)
            {
                this.createReturnRemainingDetails();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>trackBudgetSource</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a <c>BudgetSourceTracking</c> record and its ledger dimension return funds details for the
    ///    <c>BudgetSource</c> record.
    /// </summary>
    protected void trackBudgetSource()
    {
        if (!isBudgetSourceTracked)
        {
            // Creates or updates budget source tracking record for the current budget source.
            this.createBudgetSource();

            isBudgetSourceTracked = true;

            if (isSimulation)
            {
                // Return funds for simulated budget source.
                this.createReturnDetailsForSimulation();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>trackBudgetSourceForReturnRemaining</Name>
				<Source><![CDATA[
    /// <summary>
    /// Tracks the budget source for the returned budget.
    /// </summary>
    protected void trackBudgetSourceForReturnRemaining()
    {
        if (!isBudgetSourceTracked)
        {
            this.createSourceTracking(
                budgetSourceRecId,
                budgetSourceTrackingToReturnAmounts.Category,
                BudgetSourceTrackingStatus::Confirmed,
                trackingDate,
                trackingUserId,
                currentTrackingSequenceNumber,
                budgetSourceTrackingToReturnAmounts.TrackingNumber,
                false,
                budgetSourceTrackingToReturnAmounts.BudgetModelId,
                budgetSourceTrackingToReturnAmounts.BudgetModelSubModelId,
                budgetSourceTrackingToReturnAmounts.BudgetModelType,
                budgetSourceTrackingToReturnAmounts.BudgetModelDataAreaId);

            isBudgetSourceTracked = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>trackLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Tracks the ledger dimension detail.
    /// </summary>
    /// <param name="_primaryLedgerId">
    /// The ID for the primary <c>Ledger</c> record for which the ledger dimension details are tracked.
    /// </param>
    /// <param name="_controlRuleId">
    /// The ID for the <c>BudgetControlRule</c> record for the budget control ledger dimension to track
    /// budget funds.
    /// </param>
    /// <param name="_groupMemberId">
    /// The ID for the <c>BudgetGroupMember</c> record for the budget control ledger dimension to track
    /// budget funds.
    /// </param>
    /// <param name="_controlLedgerDimension">
    /// The budget control ledger dimension to track budget funds.
    /// </param>
    /// <param name="_sourceDetails">
    /// The collection of budget source ledger dimension details that are associated with the budget
    /// control ledger dimension to track budget funds.
    /// </param>
    public void trackLedgerDimension(
        LedgerRecId _primaryLedgerId,
        recId _controlRuleId,
        recId _groupMemberId,
        LedgerDimensionBudgetControl _controlLedgerDimension,
        Set _sourceDetails)
    {
        SetEnumerator budgetSourceDetailsEnumerator;
        BudgetSourceDetail budgetSourceDetail;
        AmountMST lastCarryforwardAmount;
        AmountMST pendingCarryforwardAmountReturned;
        AmountMST carryforwardAmount;
        AmountMST nonCarryforwardAmount;

        if (_primaryLedgerId &&
            _controlLedgerDimension &&
            _sourceDetails.elements() > 0)
        {
            budgetSourceDetailsEnumerator = _sourceDetails.getEnumerator();

            while (budgetSourceDetailsEnumerator.moveNext())
            {
                budgetSourceDetail = budgetSourceDetailsEnumerator.current();

                lastCarryforwardAmount = this.getTrackedCarryforwardAmount(
                                            _primaryLedgerId,
                                            budgetSourceRecId,
                                            budgetSourceDetail.parmLedgerDimension());

                if (lastCarryforwardAmount)
                {
                    // Remember the carry-forward status in order to potentially maintain it for the entire budget source.
                    // This status will only be maintained if the tracked carry-forward amount for the budget source is not zero.
                    // If the amounts balance to zero the carry-forward status will not be maintained even if there are carry-forward amounts for the budget source.
                    areCarryforwardDetailsPrepared = NoYes::Yes;
                }

                if (areReturnDetailsPrepared)
                {
                    pendingCarryforwardAmountReturned = this.getPendingCarryforwardAmountReturned(
                                                            _primaryLedgerId,
                                                            budgetSourceDetail.parmLedgerDimension());

                    // Adjust last carry forward amount for returned carry forward amount.
                    lastCarryforwardAmount = lastCarryforwardAmount + pendingCarryforwardAmountReturned;
                }

                // Calculate current carryforward amount.
                if (abs(lastCarryforwardAmount) > abs(budgetSourceDetail.parmCurrencyAmount()))
                {
                    carryforwardAmount = lastCarryforwardAmount - budgetSourceDetail.parmCurrencyAmount();
                }
                else
                {
                    carryforwardAmount = lastCarryforwardAmount;
                    nonCarryforwardAmount = budgetSourceDetail.parmCurrencyAmount() - carryforwardAmount;
                }

                if (carryforwardAmount)
                {
                    // Create budget source tracking to track budget control ledger dimension detail if not already created.
                    this.trackBudgetSource();

                    // Create carryforward budget source tracking detail.
                    this.createTrackingDetail(
                            currentBudgetSourceTracking.RecId,
                            _primaryLedgerId,
                            budgetSourceDetail.parmLedgerDimension(),
                            _controlRuleId,
                            _groupMemberId,
                            _controlLedgerDimension,
                            carryforwardAmount,
                            NoYes::Yes,
                            NoYes::No);
                }

                if (nonCarryforwardAmount)
                {
                    // Create budget source tracking to track budget control ledger dimension detail if not already created.
                    this.trackBudgetSource();

                    // Create non-carryforward budget source tracking detail.
                    this.createTrackingDetail(
                            currentBudgetSourceTracking.RecId,
                            _primaryLedgerId,
                            budgetSourceDetail.parmLedgerDimension(),
                            _controlRuleId,
                            _groupMemberId,
                            _controlLedgerDimension,
                            nonCarryforwardAmount,
                            NoYes::No,
                            NoYes::No);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>trackMaintainedCarryforwardDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the carry-forward status needs to be maintained for this budget source.  If so,
    /// updates the carry-forward flag on budget source tracking detail records that did not maintain the flag.
    /// In addition to that, carry forward flag of an invoice created from carry forwarded purchase order gets updated
    /// only if maintain carryforward amount parameter is selected in the budget control configuration and
    /// <c>BudgetControlMaintainCarryForwardQueryFlight</c> is enabled,
    /// </summary>
    /// <param name="_primaryLedgerId">
    /// The primary ledger record Id.
    /// </param>
    public void trackMaintainedCarryforwardDetails(LedgerRecId _primaryLedgerId)
    {
        BudgetSource relievingBudgetSource, budgetSource;
        BudgetSourceTracking budgetSourceTracking, relievingBudgetSourceTracking, relievedBudgetSourceTracking, previousBudgetSourceTracking;
        BudgetSourceTrackingDetail budgetSourceTrackingDetail, relievingBudgetSourceTrackingDetail, relievedBudgetSourceTrackingDetail, previousBudgetSourceTrackingDetail;
        BudgetSourceTrackingRelievingDetail budgetSourceTrackingRelievingDetail;
        BudgetSourceTrackingDetail pairedBudgetSourceTrackingDetail, removedBudgetSourceTrackingDetail;
        NoYes maintainCarryforwardAmounts;

        boolean budgetControlUpdatePurchInvoiceCarryForwardFlightEnabled = BudgetControlUpdatePurchInvoiceCarryForwardFlight::instance().isEnabled();
        maintainCarryforwardAmounts = BudgetControlConfiguration::findActiveByPrimaryLedger(_primaryLedgerId).MaintainCarryforwardAmounts;

        if (maintainCarryforwardAmounts)
        {
            //Note-Below query behind flight is based on reference : Class/BudgetControlMaintainCarryForwardProvider::processRelievingDocumentsMissingCF.
            if (budgetControlUpdatePurchInvoiceCarryForwardFlightEnabled && areRelievingDetailsPrepared)
            {
                while select forUpdate AccountingCurrencyAmount from relievingBudgetSourceTrackingDetail
                    where relievingBudgetSourceTrackingDetail.IsCarryForward == NoYes::Yes
                        && relievingBudgetSourceTrackingDetail.PrimaryLedger == _primaryLedgerId
                join AccountingCurrencyAmount from pairedBudgetSourceTrackingDetail
                    where pairedBudgetSourceTrackingDetail.BudgetSourceTracking == relievingBudgetSourceTrackingDetail.BudgetSourceTracking
                        && pairedBudgetSourceTrackingDetail.BudgetSourceLedgerDimension == relievingBudgetSourceTrackingDetail.BudgetSourceLedgerDimension
                        && pairedBudgetSourceTrackingDetail.IsReturnOfBudgetFunds == relievingBudgetSourceTrackingDetail.IsReturnOfBudgetFunds
                        && pairedBudgetSourceTrackingDetail.PrimaryLedger == relievingBudgetSourceTrackingDetail.PrimaryLedger
                        && pairedBudgetSourceTrackingDetail.IsCarryForward == NoYes::No
                exists join relievingBudgetSourceTracking
                    where relievingBudgetSourceTracking.RecId == relievingBudgetSourceTrackingDetail.BudgetSourceTracking
                        && relievingBudgetSourceTracking.BudgetSource == budgetSourceRecId
                exists join budgetSourceTrackingRelievingDetail
                    where budgetSourceTrackingRelievingDetail.RelievingBudgetSourceTracking == relievingBudgetSourceTracking.RecId
                exists join relievedBudgetSourceTrackingDetail
                    where relievedBudgetSourceTrackingDetail.RecId == budgetSourceTrackingRelievingDetail.RelievedBudgetSourceTrackingDetail
                exists join relievedBudgetSourceTracking
                    where relievedBudgetSourceTracking.RecId == relievedBudgetSourceTrackingDetail.BudgetSourceTracking
                exists join previousBudgetSourceTracking
                    where previousBudgetSourceTracking.BudgetSource == relievedBudgetSourceTracking.BudgetSource
                        && previousBudgetSourceTracking.SequenceNumber <= relievedBudgetSourceTracking.SequenceNumber
                        && previousBudgetSourceTracking.TrackingDate <= relievedBudgetSourceTracking.TrackingDate
                exists join previousBudgetSourceTrackingDetail
                    where previousBudgetSourceTrackingDetail.BudgetSourceTracking == previousBudgetSourceTracking.RecId
                        && previousBudgetSourceTrackingDetail.IsCarryForward == NoYes::Yes
                {
                    // Combine the amounts into the first detail record.
                    relievingBudgetSourceTrackingDetail.AccountingCurrencyAmount += pairedBudgetSourceTrackingDetail.AccountingCurrencyAmount;
                    relievingBudgetSourceTrackingDetail.update();

                    this.collapseRelievingDetailRecords(relievingBudgetSourceTrackingDetail.RecId, pairedBudgetSourceTrackingDetail.RecId);

                    // Delete the deprecated detail record.
                    select forUpdate firstOnly RecId from removedBudgetSourceTrackingDetail
                    where removedBudgetSourceTrackingDetail.RecId == pairedBudgetSourceTrackingDetail.RecId;

                    removedBudgetSourceTrackingDetail.delete();
                }

                update_recordSet relievingBudgetSourceTrackingDetail
                setting IsCarryForward = NoYes::Yes
                    where relievingBudgetSourceTrackingDetail.IsCarryForward == NoYes::No
                        && relievingBudgetSourceTrackingDetail.PrimaryLedger == _primaryLedgerId
                join relievingBudgetSourceTracking
                    where relievingBudgetSourceTracking.RecId == relievingBudgetSourceTrackingDetail.BudgetSourceTracking
                join RecId from relievingBudgetSource
                    where relievingBudgetSource.RecId == relievingBudgetSourceTracking.BudgetSource
                        && relievingBudgetSource.RecId == budgetSourceRecId
                join RecId from budgetSourceTrackingRelievingDetail
                    where budgetSourceTrackingRelievingDetail.RelievingBudgetSourceTracking == relievingBudgetSourceTracking.RecId
                join RecId from relievedBudgetSourceTrackingDetail
                    where relievedBudgetSourceTrackingDetail.RecId == budgetSourceTrackingRelievingDetail.RelievedBudgetSourceTrackingDetail
                join RecId from relievedBudgetSourceTracking
                    where relievedBudgetSourceTracking.RecId == relievedBudgetSourceTrackingDetail.BudgetSourceTracking
                join RecId from previousBudgetSourceTracking
                    where previousBudgetSourceTracking.BudgetSource == relievedBudgetSourceTracking.BudgetSource
                        && previousBudgetSourceTracking.SequenceNumber <= relievedBudgetSourceTracking.SequenceNumber
                        && previousBudgetSourceTracking.TrackingDate <= relievedBudgetSourceTracking.TrackingDate
                join RecId from previousBudgetSourceTrackingDetail
                    where previousBudgetSourceTrackingDetail.BudgetSourceTracking == previousBudgetSourceTracking.RecId
                        && previousBudgetSourceTrackingDetail.IsCarryForward == NoYes::Yes;
            }
            else
            {
                if (areCarryforwardDetailsPrepared)
                {
                    // Combine BudgetSourceTrackingDetail pairs with mismatched IsCarryForward flags.
                    while select forUpdate AccountingCurrencyAmount from budgetSourceTrackingDetail
                        where budgetSourceTrackingDetail.IsCarryForward == NoYes::Yes
                            && budgetSourceTrackingDetail.PrimaryLedger == _primaryLedgerId
                    join AccountingCurrencyAmount from pairedBudgetSourceTrackingDetail
                        where pairedBudgetSourceTrackingDetail.BudgetSourceTracking == budgetSourceTrackingDetail.BudgetSourceTracking
                            && pairedBudgetSourceTrackingDetail.BudgetSourceLedgerDimension == budgetSourceTrackingDetail.BudgetSourceLedgerDimension
                            && pairedBudgetSourceTrackingDetail.IsReturnOfBudgetFunds == budgetSourceTrackingDetail.IsReturnOfBudgetFunds
                            && pairedBudgetSourceTrackingDetail.PrimaryLedger == budgetSourceTrackingDetail.PrimaryLedger
                            && pairedBudgetSourceTrackingDetail.IsCarryForward == NoYes::No
                    exists join budgetSourceTracking
                        where budgetSourceTracking.RecId == budgetSourceTrackingDetail.BudgetSourceTracking
                            && budgetSourceTracking.SequenceNumber == currentTrackingSequenceNumber
                            && budgetSourceTracking.BudgetSource == budgetSourceRecId
                    {
                        // Combine the amounts into the first detail record.
                        budgetSourceTrackingDetail.AccountingCurrencyAmount += pairedBudgetSourceTrackingDetail.AccountingCurrencyAmount;
                        budgetSourceTrackingDetail.update();

                        this.collapseRelievingDetailRecords(budgetSourceTrackingDetail.RecId, pairedBudgetSourceTrackingDetail.RecId);

                        // Delete the second detail record.
                        select forUpdate firstOnly RecId from removedBudgetSourceTrackingDetail
                        where removedBudgetSourceTrackingDetail.RecId == pairedBudgetSourceTrackingDetail.RecId;

                        removedBudgetSourceTrackingDetail.delete();
                    }

                    // Update the carry-forward flag on budget source tracking detail records that did not maintain the flag.
                    update_recordSet budgetSourceTrackingDetail
                    setting IsCarryForward = NoYes::Yes
                        where budgetSourceTrackingDetail.PrimaryLedger == _primaryLedgerId
                            && budgetSourceTrackingDetail.IsCarryForward == NoYes::No
                    join RecId from budgetSourceTracking
                        where budgetSourceTracking.RecId == budgetSourceTrackingDetail.BudgetSourceTracking
                            && budgetSourceTracking.SequenceNumber == currentTrackingSequenceNumber
                    join RecId from budgetSource
                        where budgetSource.RecId == budgetSourceTracking.BudgetSource
                            && budgetSource.RecId == budgetSourceRecId;
                            
                }
            }
        }       
    }

]]></Source>
			</Method>
			<Method>
				<Name>trackReturnLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Tracks the ledger dimension return detail.
    /// </summary>
    /// <param name="_primaryLedgerId">
    /// The ID for the primary <c>Ledger</c> record for which the ledger dimension details are tracked.
    /// </param>
    /// <param name="_controlLedgerDimension">
    /// The budget control ledger dimension for which to return budget funds.
    /// </param>
    /// <param name="_sourceDetails">
    /// The collection of budget source ledger dimension details that are associated with the budget
    /// control ledger dimension to return budget funds.
    /// </param>
    public void trackReturnLedgerDimension(
        LedgerRecId _primaryLedgerId,
        LedgerDimensionBudgetControl _controlLedgerDimension,
        Set _sourceDetails)
    {
        AmountMST returnAmount;
        AmountMST returnAmountRemaining;
        AmountMST carryforwardAmount;
        AmountMST nonCarryforwardAmount;

        container amounts;

        SetEnumerator budgetSourceDetailsEnumerator;
        BudgetSourceDetail budgetSourceDetail;

        if (_primaryLedgerId && (_sourceDetails.elements() > 0))
        {
            budgetSourceDetailsEnumerator = _sourceDetails.getEnumerator();

            this.determineSourceTrackingToReturn();

            if (budgetSourceTrackingToReturnAmounts)
            {
                while (budgetSourceDetailsEnumerator.moveNext())
                {
                    budgetSourceDetail = budgetSourceDetailsEnumerator.current();

                    // Get the total amount to return. The sign of the amount will be opposite of the amounts in tracking.
                    // Flip the sign of the amount so that the funds remaining can be compared to the amounts on the BudgetSourceTrackingDetail records.
                    returnAmountRemaining = budgetSourceDetail.parmCurrencyAmount() * #InverseSign;

                    amounts = this.getAmountInTracking(_primaryLedgerId, budgetSourceDetail);
                    carryforwardAmount = conpeek(amounts, 1);
                    nonCarryforwardAmount = conpeek(amounts, 2);

                    // Process non-carryforward amounts first.

                    if (nonCarryforwardAmount <= returnAmountRemaining)
                    {
                        // There are sufficient funds to return the entire non-carryforward amount.
                        returnAmount = nonCarryforwardAmount;
                        returnAmountRemaining -= returnAmount;
                    }
                    else
                    {
                        // There are insufficient funds to return the entire non-carryforward amount.
                        // Return whatever budget return funds are remaining.
                        returnAmount = returnAmountRemaining;
                        returnAmountRemaining = 0;
                    }

                    if (returnAmount)
                    {
                        // There is a non-carryforward amount to return.
                        // Create budget source tracking to track budget control ledger dimension detail if not already created.
                        this.trackBudgetSource();

                        this.createTrackingDetail(
                            currentBudgetSourceTracking.RecId,
                            _primaryLedgerId,
                            budgetSourceDetail.parmLedgerDimension(),
                            0,
                            0,
                            _controlLedgerDimension,
                            returnAmount * #InverseSign,
                            NoYes::No,
                            NoYes::Yes);
                    }

                    if (returnAmountRemaining && carryforwardAmount)
                    {
                        // There is a carryforward amount to return and funds available to return.

                        if (carryforwardAmount <= returnAmountRemaining)
                        {
                            // There are sufficient funds to return the entire carryforward amount.
                            returnAmount = carryforwardAmount;
                        }
                        else
                        {
                            // There are insufficient funds to return the entire carryforward amount.
                            // Return whatever budget return funds are remaining.
                            returnAmount = returnAmountRemaining;
                        }

                        // Create budget source tracking to track budget control ledger dimension detail if not already created.
                        this.trackBudgetSource();

                        this.createTrackingDetail(
                            currentBudgetSourceTracking.RecId,
                            _primaryLedgerId,
                            budgetSourceDetail.parmLedgerDimension(),
                            0,
                            0,
                            _controlLedgerDimension,
                            returnAmount * #InverseSign,
                            NoYes::Yes,
                            NoYes::Yes);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>trackSimulatingBudgetSource</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a <c>BudgetSourceTracking</c> record and its ledger dimension return funds details for the
    ///    <c>BudgetSource</c> record that simulates another <c>BudgetSource</c> record.
    /// </summary>
    public void trackSimulatingBudgetSource()
    {
        if (isSimulation &&
            simulatedBudgetSourceRecId &&
            !isBudgetSourceTracked)
        {
            // Create the return funds for simulated budget source.
            this.createReturnDetailsForSimulation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>BudgetControlTrackingUpdate</c> class.
    /// </summary>
    /// <returns>
    ///    A <c>BudgetControlTrackingUpdate</c> class instance.
    /// </returns>
    protected static BudgetControlTrackingUpdate construct()
    {
        return new BudgetControlTrackingUpdate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForBudgetControlProcessing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>BudgetControlTrackingUpdate</c>,
    /// <c>BudgetControlTrackingUpdateRelieving</c>, or <c>BudgetControlTrackingUpdateCarryforward</c>
    /// class.
    /// </summary>
    /// <param name="_budgetSourceRecId">
    /// The record ID of the <c>BudgetSource</c> record for which to track.
    /// </param>
    /// <param name="_isDraft">
    /// A Boolean value that indicates whether the budget source tracking status is draft.
    /// </param>
    /// <param name="_budgetControlCategory">
    /// The <c>BudgetControlCategory</c> enumeration value for which to categorize the budget source
    /// tracking.
    /// </param>
    /// <param name="_trackingDate">
    /// The tracking date for the budget source tracking.
    /// </param>
    /// <param name="_trackingUserId">
    /// The tracking user ID for the budget source tracking.
    /// </param>
    /// <param name="_trackingNumber">
    /// The tracking number for the budget source tracking.
    /// </param>
    /// <param name="_requiresRelieving">
    /// A Boolean value that indicates whether the budget source tracking requires relieving; optional.
    /// </param>
    /// <param name="_budgetModel">
    /// The <c>BudgetModel</c> record for the budget source tracking; optional.
    /// </param>
    /// <param name="_isCarryforward">
    /// A Boolean value that indicates whether the budget source tracking amounts are carry-forward
    /// amounts; optional.
    /// </param>
    /// <param name="_isSimulation">
    /// A Boolean value that indicates whether the budget source tracking is a simulation; optional.
    /// </param>
    /// <param name="_simulatedBudgetSourceRecId">
    /// The record ID of the simulated <c>BudgetSource</c> record; optional.
    /// </param>
    /// <returns>
    /// An instance of the <c>BudgetControlTrackingUpdate</c>, <c>BudgetControlTrackingUpdateRelieving</c>,
    /// or <c>BudgetControlTrackingUpdateCarryforward</c> class.
    /// </returns>
    /// <remarks>
    /// The designated usage pattern for this class is to first start the tracking update process.Then,
    /// request tracking individual budget source details for every unique ledger account, and finally,
    /// complete the tracking update process. Not following the usage pattern will cause errors.
    /// </remarks>
    public static BudgetControlTrackingUpdate newForBudgetControlProcessing(
        BudgetSourceRecId _budgetSourceRecId,
        boolean _isDraft,
        BudgetControlCategory _budgetControlCategory,
        TransDate _trackingDate,
        userId _trackingUserId,
        Num _trackingNumber,
        boolean _requiresRelieving = false,
        BudgetModel _budgetModel = null,
        boolean _isCarryforward = false,
        boolean _isSimulation = false,
        BudgetSourceRecId _simulatedBudgetSourceRecId = 0)
    {
        BudgetControlTrackingUpdate trackingUpdate;
        BudgetSourceRecId budgetSourceId;

        if (_simulatedBudgetSourceRecId)
        {
            budgetSourceId = _simulatedBudgetSourceRecId;
        }
        else
        {
            budgetSourceId = _budgetSourceRecId;
        }

        if (_isCarryforward)
        {
            trackingUpdate = BudgetControlTrackingUpdateCarryforward::construct();
        }
        else if (_requiresRelieving ||
            BudgetSourceTrackingRelievingDetail::existRelievedBudgetSource(budgetSourceId) ||
            BudgetSourceTrackingRelievingDetail::existRelievingBudgetSource(budgetSourceId))
        {
            trackingUpdate = BudgetControlTrackingUpdateRelieving::construct();
        }
        else
        {
            trackingUpdate = BudgetControlTrackingUpdate::construct();
        }

        trackingUpdate.initializeForProcessing(
            _budgetSourceRecId,
            _isDraft,
            _budgetControlCategory,
            _trackingDate,
            _trackingUserId,
            _trackingNumber,
            _requiresRelieving,
            _budgetModel,
            _isCarryforward,
            _isSimulation,
            _simulatedBudgetSourceRecId);

        return trackingUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForBudgetControlRemoval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>BudgetControlTrackingUpdate</c>,
    /// <c>BudgetControlTrackingUpdateRelieving</c>, or <c>BudgetControlTrackingUpdateCarryforward</c>
    /// class.
    /// </summary>
    /// <param name="_budgetSourceRecId">
    /// The record ID of the <c>BudgetSource</c> record for which to track.
    /// </param>
    /// <returns>
    /// An instance of the <c>BudgetControlTrackingUpdate</c>, <c>BudgetControlTrackingUpdateRelieving</c>,
    /// or <c>BudgetControlTrackingUpdateCarryforward</c> class.
    /// </returns>
    public static BudgetControlTrackingUpdate newForBudgetControlRemoval(BudgetSourceRecId _budgetSourceRecId)
    {
        BudgetControlTrackingUpdate trackingUpdate;

        if (BudgetSourceTrackingRelievingDetail::existRelievedBudgetSource(_budgetSourceRecId) ||
            BudgetSourceTrackingRelievingDetail::existRelievingBudgetSource(_budgetSourceRecId))
        {
            trackingUpdate = BudgetControlTrackingUpdateRelieving::construct();
        }
        else
        {
            trackingUpdate = BudgetControlTrackingUpdate::construct();
        }

        trackingUpdate.initializeForRemoval(_budgetSourceRecId);

        return trackingUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForBudgetControlReturnRemaining</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>BudgetControlTrackingUpdate</c>,
    /// <c>BudgetControlTrackingUpdateRelieving</c>, or <c>BudgetControlTrackingUpdateCarryforward</c>
    /// class.
    /// </summary>
    /// <param name="_budgetSourceRecId">
    /// The budget source identity to return all confirmed funds.
    /// </param>
    /// <param name="_returnRemainingDate">
    /// The date to account for the return of remaining funds.
    /// </param>
    /// <param name="_returnRemainingUser">
    /// The user who is returning remaining funds.
    /// </param>
    /// <param name="_doReturnAsClosing">
    /// A boolean indicating whether to return the funds as a closing entry; optional.
    /// </param>
    /// <returns>
    /// An instance of the <c>BudgetControlTrackingUpdate</c>, <c>BudgetControlTrackingUpdateRelieving</c>,
    /// or <c>BudgetControlTrackingUpdateCarryforward</c> class.
    /// </returns>
    public static BudgetControlTrackingUpdate newForBudgetControlReturnRemaining(
        BudgetSourceRecId _budgetSourceRecId,
        TransDate _returnRemainingDate,
        userId _returnRemainingUser,
        boolean _doReturnAsClosing = false)
    {
        BudgetControlTrackingUpdate trackingUpdate;

        if (BudgetSourceTrackingRelievingDetail::existRelievedBudgetSource(_budgetSourceRecId) ||
            BudgetSourceTrackingRelievingDetail::existRelievingBudgetSource(_budgetSourceRecId))
        {
            trackingUpdate = BudgetControlTrackingUpdateRelieving::construct();
        }
        else
        {
            trackingUpdate = BudgetControlTrackingUpdate::construct();
        }

        trackingUpdate.initializeForReturnRemaining(_budgetSourceRecId, _returnRemainingDate, _returnRemainingUser, _doReturnAsClosing);

        return trackingUpdate;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>