<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSWorkManualComplete</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WhsWorkManualComplete</c> class is used to complete works manually.
/// </summary>
public class WhsWorkManualComplete
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>executeWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Manually completes the specified work transactions.
    /// </summary>
    /// <param name="_userId">
    /// Warehouse user to complete the work as.
    /// </param>
    /// <param name="_tmpCompleteWorkTable">
    /// Buffer with work headers to be completed.
    /// </param>
    /// <param name="_tmpCompleteWorkLine">
    /// Buffer with work lines to be completed.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Thrown if no warehouse user is specified.
    /// </exception>
    public void executeWork(
        WHSUserId               _userId,
        WHSTmpCompleteWorkTable _tmpCompleteWorkTable,
        WHSTmpCompleteWorkLine  _tmpCompleteWorkLine)
    {
        container inputParameters = [_userId, SysTableInMemorySerializer::packTable(_tmpCompleteWorkTable), SysTableInMemorySerializer::packTable(_tmpCompleteWorkLine)];
       
        // Since this is a potential long running operation we need to sandbox it to avoid timeouts
       SysOperationSandbox::callStaticMethod(
            classIdGet(this),
            staticMethodStr(WhsWorkManualComplete, processWork),
            inputParameters,
            "@WAX411");
    }

]]></Source>
			</Method>
			<Method>
				<Name>processWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Manually completes the specified work transactions.
    /// </summary>
    /// <param name="_inputParameters">
    /// A container with the warehouse user to complete the work, buffer with packed work header and work lines.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Thrown if no warehouse user is specified.
    /// </exception>
    public static void processWork(container _inputParameters)
    {
        WHSUserId   userId;
        container   packedCompleteWorkTable;
        container   packedCompleteWorkLine;
     
        [userId, packedCompleteWorkTable, packedCompleteWorkLine] = _inputParameters;
      
        if (!userId)
        {
            throw error("@WAX2648");
        }
        using (var workExecuteManuallyContext = WHSWorkExecuteManuallyContext::newManualWorkExecutionContext())
        {
            using (var processWorkHeadersPerf = WHSInstrumentationManualWorkCompletionPerformanceTask::newProcessWorkHeaders())
            {
                WHSTmpCompleteWorkTable tmpCompleteWorkTable;
                WHSTmpCompleteWorkLine  tmpCompleteWorkLine;

                SysTableInMemorySerializer::unpackTable(packedCompleteWorkTable, tmpCompleteWorkTable);
                SysTableInMemorySerializer::unpackTable(packedCompleteWorkLine, tmpCompleteWorkLine);

                while select tmpCompleteWorkTable
                {
                    WHSWorkTable workHeader = WHSWorkTable::find(tmpCompleteWorkTable.WorkId);

                    using (var processWorkHeaderPerf = WHSInstrumentationManualWorkCompletionPerformanceTask::newProcessWorkHeader(workHeader.RecId, workHeader.numberOfOpenWorkLines()))
                    {
                        WhsWorkManualComplete::executeWorkLines(userId, tmpCompleteWorkTable, tmpCompleteWorkLine);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWorkHeaderForManualCompletionStart</Name>
				<Source><![CDATA[
    private static void validateWorkHeaderForManualCompletionStart(WHSWorkTable _workTable, WHSUserId _userId)
    {
        if (WhsWorkManualComplete::isWorkHeaderLockedByDifferentUser(_workTable, _userId)
            || !_workTable.canBeCompleted())
        {
            throw error(strFmt("@WAX:ManualWorkCompleteWorkHeaderValidationError", _workTable.workId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkHeaderLockedByDifferentUser</Name>
				<Source><![CDATA[
    private static boolean isWorkHeaderLockedByDifferentUser(WHSWorkTable _workTable, WHSUserId _userId)
    {
        return _workTable.LockedUser
            && _workTable.LockedUser != _userId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWorkLineForManualCompletion</Name>
				<Source><![CDATA[
    private static void validateWorkLineForManualCompletion(WHSWorkLine _workLine, WHSUserId _userId)
    {
        if (!WhsWorkManualComplete::isWorkLineValidForManualCompletion(_workLine, _userId))
        {
            throw error(strFmt("@WAX:ManualWorkCompleteWorkLineValidationError", _workLine.LineNum, _workLine.workId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkLineValidForManualCompletion</Name>
				<Source><![CDATA[
    private static boolean isWorkLineValidForManualCompletion(WHSWorkLine _workLine, WHSUserId _userId)
    {
        return _workLine.WorkStatus  == WHSWorkStatus::Open ||
               (_workLine.WorkStatus == WHSWorkStatus::InProcess &&
                _workLine.UserId     == _userId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWorkLineIfItemNotAllowsNegativeInventory</Name>
				<Source><![CDATA[
    private static void validateWorkLineIfItemNotAllowsNegativeInventory(
        InventTable             _item,
        WHSWorkLine             _workLine,
        WHSTmpCompleteWorkLine  _whsTmpCompleteWorkLine,
        InventSiteId            _pickSiteId,
        InventLocationId        _pickWarehouse)
    {
        if (_item.ItemId
            && _item.isItemGTDActivated()
            && _workLine.WMSLocationId
            && _workLine.WorkType == WHSWorkType::Pick)
        {
            WHSLocationProfile locationProfile = WMSLocation::find(_workLine.WMSLocationId, _pickWarehouse).whsLocationProfile();

            if (locationProfile
                && !locationProfile.LPControlled
                && !locationProfile.AllowNegative
                && !_item.whsAllowPhysNeg())
            {
                InventDim inventDimPick = _workLine.inventDim();
                inventDimPick.wMSLocationId = _workLine.wmsLocationId;
                inventDimPick.InventLocationId = _pickWarehouse;
                inventDimPick.InventSiteId = _pickSiteId;
                inventDimPick.inventBatchId = _whsTmpCompleteWorkLine.InventBatchId;
                inventDimPick.InventGtdId_RU = _whsTmpCompleteWorkLine.InventGtdId_RU;

                inventDimPick = InventDim::findOrCreate(inventDimPick);

                InventQty onHandQty = WHSInventOnHand::getWorkPhysicalInventHandlingQty(_workLine.ItemId, inventDimPick.InventDimId);

                if (onHandQty && onHandQty < _workLine.InventQtyRemain)
                {
                    throw error("@Inventory_Localization:MobileAppNoQtyForSpecifiedDimError");
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWorkLineBatchSpecifedIfItemAllowsNegativeInventory</Name>
				<Source><![CDATA[
    private static void validateWorkLineBatchSpecifedIfItemAllowsNegativeInventory(
        InventTable             _item,
        WHSWorkLine             _workLine,
        WHSTmpCompleteWorkLine  _whsTmpCompleteWorkLine,
        InventLocationId        _pickWarehouse)
    {
        if (_item.ItemId
            && _workLine.WMSLocationId
            && !_whsTmpCompleteWorkLine.inventBatchId
            && _workLine.WorkType == WHSWorkType::Pick)
        {
            WHSLocationProfile locationProfile = WMSLocation::find(_workLine.WMSLocationId, _pickWarehouse).whsLocationProfile();

            if (!locationProfile.LPControlled
                && locationProfile.AllowNegative
                && _item.whsAllowPhysNeg())
            {
                throw error(strFmt("@WAX:ManualWorkCompleteWorkLineBatchIdError", _workLine.WorkId, _workLine.LineNum));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWorkLineItemIsSerialActivatedAndAllowsNegativeInventory</Name>
				<Source><![CDATA[
    private static void validateWorkLineItemIsSerialActivatedAndAllowsNegativeInventory(
        InventTable             _item,
        WHSWorkLine             _workLine,
        WHSTmpCompleteWorkLine  _whsTmpCompleteWorkLine,
        InventSiteId            _pickSiteId,
        InventLocationId        _pickWarehouse)
    {
        if (_item.ItemId
            && _workLine.WMSLocationId
            && _workLine.WorkType == WHSWorkType::Pick)
        {
            WHSLocationProfile locationProfile = WMSLocation::find(_workLine.WMSLocationId, _pickWarehouse).whsLocationProfile();

            if (!locationProfile.LPControlled
                && locationProfile.AllowNegative
                && _item.whsAllowPhysNeg())
            {
                InventDim inventDimPick = _workLine.inventDim();
                inventDimPick.wMSLocationId = _workLine.wmsLocationId;
                inventDimPick.InventLocationId = _pickWarehouse;
                inventDimPick.InventSiteId = _pickSiteId;

                inventDimPick = InventDim::findOrCreate(inventDimPick);

                if (WHSInventOnHand::getWorkPhysicalInventHandlingQty(_workLine.ItemId, inventDimPick.InventDimId) < _workLine.InventQtyRemain)
                {
                    throw error(strFmt("@WAX:ManualWorkCompleteWorkLineSerialNumberQtyError", _workLine.WorkId, _workLine.LineNum));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unlockManuallyCompletedWorkHeader</Name>
				<Source><![CDATA[
    private static void unlockManuallyCompletedWorkHeader(WHSWorkId _workId, WHSUserId _userId)
    {
        ttsbegin;

        WHSWorkTable workTable = WHSWorkTable::find(_workId, true);
        workTable.LockedUser                = '';
        workTable.WorkManuallyCompletedBy   = _userId;
        workTable.update();

        if (workTable.WorkStatus == WHSWorkStatus::Closed)
        {
            info(strFmt("@WAX2663", workTable.WorkId));
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether the specified work transactions can be manually completed.
    /// </summary>
    /// <param name="_userId">
    /// Warehouse user to complete the work as.
    /// </param>
    /// <param name="_tmpCompleteWorkTable">
    /// Buffer with work headers to be completed.
    /// </param>
    /// <param name="_tmpCompleteWorkLine">
    /// Buffer with work lines to be completed.
    /// </param>
    /// <returns>
    /// True if validation succeeds; otherwise, false.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Thrown if no warehouse user is specified.
    /// </exception>
    public boolean validateWork(
        WHSUserId               _userId,
        WHSTmpCompleteWorkTable _tmpCompleteWorkTable,
        WHSTmpCompleteWorkLine  _tmpCompleteWorkLine)
    {
        if (!_userId)
        {
            throw error("@WAX2648");
        }

        List errors = WHSWorkManualComplete::performValidation(_userId, _tmpCompleteWorkTable, _tmpCompleteWorkLine);
        boolean valid = !errors.elements();

        if (valid)
        {
            info("@WAX2650");
        }
        else
        {
            ListEnumerator le = errors.getEnumerator();
            while (le.moveNext())
            {
                error(le.current());
            }
        }

        return valid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the work completion for all work lines.
    /// </summary>
    /// <param name="_userId">
    /// Warehouse user to complete the work as.
    /// </param>
    /// <param name="_whsTmpCompleteWorkTable">
    /// Buffer with work headers to be completed.
    /// </param>
    /// <param name="_whsTmpCompleteWorkLine">
    /// Buffer with work lines to be completed.
    /// </param>
	protected static void executeWorkLines(
        WHSUserId               _userId,
        WHSTmpCompleteWorkTable _whsTmpCompleteWorkTable,
        WHSTmpCompleteWorkLine  _whsTmpCompleteWorkLine)
    {
        const int CommitSize = 100;
        
        int64               numberOfProcessedWorkLines;
        int64               numberOfProcessedCWWorkLines;
        WHSLicensePlateId   licensePlateId;
        WhsWorkExecute      workExecute = WhsWorkExecute::construct();
        WHSWorkTable        workTable;
        InventDim           inventDim;
        WHSLicensePlateId   licensePlateIdToPickFrom;
        boolean             handleByLP;
        counter             numOfPickWorkLinesProcessedInSeq;
        
        WHSWorkLineManualCompletionIterationTracker iterationTracker = WHSWorkLineManualCompletionIterationTracker::construct();

        boolean transactionOpened;
        boolean explicitTransactionHandling = appl.ttsLevel() == 0;

        if (!explicitTransactionHandling)
        {
            workTable = WHSWorkTable::find(_whsTmpCompleteWorkTable.WorkId, true);

            if (workTable
                && workTable.WorkTransType == WHSWorkTransType::Packing)
            {
                error(strFmt("@WAX:WorkCannotBeExecuted", workTable.WorkId, WHSWorkTransType::Packing));

                return;
            }
        }

        WHSWorkLine workLine = workExecute.getFirstOpenLine(_whsTmpCompleteWorkTable.WorkId, _userId);

        // Loop through all of the Work Lines and auto-execute them.
        while (workLine.RecId != 0)
        {
            numberOfProcessedWorkLines++;
            boolean cwItem = PdsGlobal::pdsIsCWItem(workLine.ItemId);
            if (cwItem)
            {
                numberOfProcessedCWWorkLines++;
            }

            // Start a new transaction if we entered the executeWorkLines method without a transaction and we have committed the previously processed lines.
            if (explicitTransactionHandling
                && appl.ttsLevel() == 0)
            {
                ttsbegin;

                transactionOpened = true;

                workTable = WHSWorkTable::find(_whsTmpCompleteWorkTable.WorkId, true);

                WhsWorkManualComplete::validateWorkHeaderForManualCompletionStart(workTable, _userId);
            }

            using (var processWorkLinePerf = WHSInstrumentationManualWorkCompletionPerformanceTask::newProcessWorkLine(workTable.RecId, workLine.RecId, cwItem))
            {
                if (explicitTransactionHandling)
                {
                    // Reread the work line inside the transaction to get the latest version in case it was changed before starting the transaction.
                    workLine.reread();
                    WhsWorkManualComplete::validateWorkLineForManualCompletion(workLine, _userId);
                }

                iterationTracker.trackIteration(workLine);
                if (iterationTracker.isMaximumNumberOfIterationsReached(workLine))
                {
                    throw error(strFmt("@WAX:ManualWorkCompletion_MaximumWorkLineCompletionAttemptsReached_ErrorMessage", workLine.WorkId, workLine.LineNum));
                }

                inventDim.clear();

                select firstonly _whsTmpCompleteWorkLine
                    where _whsTmpCompleteWorkLine.WorkId   == workLine.WorkId    &&
                          _whsTmpCompleteWorkLine.LineNum  == workLine.LineNum;

                //reset performance related settings when the work type changes or we will do a break due to stop
                if (workLine.WorkType != WHSWorkType::Pick
                || workLine.WorkStop)
                {
                    numOfPickWorkLinesProcessedInSeq = 0;
                    workExecute.parmSkipWorkTableStatusUpdate(false);
                    workExecute.insertWorkTransFromList();
                    workExecute.parmUseInsertListForWorkTrans(false);
                }

                switch (workLine.WorkType)
                {
                    case WHSWorkType::Pick:
                        numOfPickWorkLinesProcessedInSeq++;

                        boolean isPutBefore = _whsTmpCompleteWorkLine.isPutBefore();
                        InventTable item = InventTable::find(workLine.ItemId);

                        if (item.whsBatchActive()
                            && !_whsTmpCompleteWorkLine.InventBatchId 
                            && !isPutBefore)
                        {
                            InventDim inventDimCriteria = workLine.inventDim();
                            inventDimCriteria.wMSLocationId = workLine.wmsLocationId;
                            inventDimCriteria.InventLocationId = workTable.InventLocationId;
                            inventDimCriteria.InventSiteId = workTable.InventSiteId;

                            WHSWorkTemplateTable workTemplate = WHSWorkTemplateTable::find(
                                                                    WHSWorkTemplateLine::findByRecId(workLine.WorkTemplateLineRecId).WorkTemplateCode,
                                                                    workTable.WorkTransType);

                            InventIBatchComparer batchComparer = InventBatchComparerFactory::createFromAllocationStrategy(workTemplate.BatchAllocationStrategy);
                            _whsTmpCompleteWorkLine.InventBatchId = WhsInvent::findBatchWithAvailablePhysicalQuantity(workLine.itemId, inventDimCriteria, batchComparer);

                            WhsWorkManualComplete::validateWorkLineBatchSpecifedIfItemAllowsNegativeInventory(
                                item,
                                workLine, 
                                _whsTmpCompleteWorkLine, 
                                workTable.InventLocationId);
                        }
                        else if (_whsTmpCompleteWorkLine.InventBatchId && isPutBefore)
                        {
                            _whsTmpCompleteWorkLine.InventBatchId = '';
                        }

                        if (item.isItemSerialNumberActivated()
                            && !isPutBefore)
                        {
                            WhsWorkManualComplete::validateWorkLineItemIsSerialActivatedAndAllowsNegativeInventory(
                                item,
                                workLine, 
                                _whsTmpCompleteWorkLine, 
                                workTable.InventSiteId,
                                workTable.InventLocationId);
                        }

                        if (WMSLocation::find(workLine.wmsLocationId, workTable.InventLocationId).whsLocationIsLPControlled())
                        {
                            if (_whsTmpCompleteWorkLine.LocatedLPId)
                            {
                                licensePlateIdToPickFrom = _whsTmpCompleteWorkLine.LocatedLPId;
                                licensePlateId = '';
                                handleByLP = true;
                                //if possible use a recordInsertList for the workTrans since we often have multiple pick lines for the same LP when we are using locatedLP
                                workExecute.parmUseInsertListForWorkTrans(!workLine.WorkStop);
                            }
                            else
                            {
                                // Set the license plate we are picking from on the dim criteria.
                                inventDim.LicensePlateId = _whsTmpCompleteWorkLine.TargetLicensePlateId;

                                // Typically the target LP of the should be what is set on the work header or the one we are initially picking from if the work header has not been set.
                                licensePlateId = workTable.TargetLicensePlateId ? workTable.TargetLicensePlateId : _whsTmpCompleteWorkLine.TargetLicensePlateId;

                                // If we are splitting off qty from the lp we are picking from we need to generate a new target LP.
                                if (workLine.AskForNewLicensePlate)
                                {
                                    licensePlateId = WHSLicensePlate::generateLicensePlateId(workLine.ItemId, workLine.UnitId);
                                }

                                licensePlateIdToPickFrom = (_whsTmpCompleteWorkLine.TargetLicensePlateId) ? _whsTmpCompleteWorkLine.TargetLicensePlateId : workTable.TargetLicensePlateId;
                            }

                            //for performance reasons we only try to update the worktable for the first pick line when we are dealing with full license plate picks
                            if (numOfPickWorkLinesProcessedInSeq > 1 && handleByLP && !workLine.WorkStop)
                            {
                                workExecute.parmSkipWorkTableStatusUpdate(true);
                            }

                            workLine = workExecute.pickWorkFromLicensePlate(licensePlateIdToPickFrom,
                                                                            workLine,
                                                                            _userId,
                                                                            inventDim,
                                                                            licensePlateId,
                                                                            0,
                                                                            false,
                                                                            NoYes::No,
                                                                            false,
                                                                            handleByLP);
                        }
                        else // Non License plate controlled Locations
                        {
                            // If work already has a target LP use that.
                            if (workTable.TargetLicensePlateId)
                            {
                                licensePlateId = workTable.TargetLicensePlateId;
                            }
                            else if (_whsTmpCompleteWorkLine.TargetLicensePlateId)
                            {
                                // If user chose a target LP use that
                                licensePlateId = _whsTmpCompleteWorkLine.TargetLicensePlateId;
                            }
                            else
                            {
                                // If no LP has been provided then generate the target license plate.
                                licensePlateId = WHSLicensePlate::generateLicensePlateId(workLine.ItemId, workLine.UnitId);
                            }

                            // Build an inventDim for dimensions below license plate.
                            // Currently manual execute only supports batch dimensions below license plate.
                            inventDim.InventBatchId = _whsTmpCompleteWorkLine.InventBatchId;
                            WhsWorkManualComplete::initializeGTDId(inventDim, _whsTmpCompleteWorkLine.InventGtdId_RU);

                            workLine = workExecute.pickNonLicensePlateCheckDigitQuantities(workLine.WorkId,
                                                                                 workLine.LineNum,
                                                                                 workLine.ItemId,
                                                                                 workLine.QtyRemain,
                                                                                 0,
                                                                                 workLine.UnitId,
                                                                                 _userId,
                                                                                 inventDim,
                                                                                 licensePlateId,
                                                                                 false);
                        }

                        if (workLine.WorkStatus != WHSWorkStatus::Closed)
                        {
                            WhsWorkManualComplete::validateWorkLineIfItemNotAllowsNegativeInventory(
                                item,
                                workLine,
                                _whsTmpCompleteWorkLine,
                                workTable.InventSiteId,
                                workTable.InventLocationId);
                        }

                        if (workTable.TargetLicensePlateId != licensePlateId)
                        {
                            workTable = WHSWorkTable::find(workTable.WorkId, true);
                            workTable.TargetLicensePlateId = licensePlateId;
                            workTable.update();
                        }

                        if (!WarehouseInventoryTransactionStackToteReuseCapabilityFlight::instance().isEnabled()
                            && WHSUseTmpToteIdForTargetLpForManualWorkProcessingV2Flight::instance().isEnabled()
                            && WHSToteReuseTable::isToteReuseEnabled(workLine))
                        {
                            WHSToteReuseTable toteReuseTable = WHSToteReuseTable::addNewRecord(workLine.WorkId, workTable.TargetLicensePlateId);
                            WHSLicensePlateId temporaryLicensePlateId = toteReuseTable.TmpToteId;
                            if (temporaryLicensePlateId)
                            {
                                workTable = WHSWorkTable::find(workTable.WorkId, true);
                                workTable.TargetLicensePlateId = temporaryLicensePlateId;
                                workTable.update();
                            }
                        }

                        break;

                    case WHSWorkType::Put:
                        
                        // Close work's container
                        if (!WHSWorkLine::isPutBefore(workLine.WorkId, workLine.LineNum))
                        {
                            WHSContainerTable::determineContainerClose(workLine.WorkId);
                        }

                        WHSLicensePlateId sourceLicensePlateId = WhsWorkManualComplete::processEarlyToteReuse(workTable, workLine);
                        WHSLicensePlateId targetLicensePlateId = workTable.TargetLicensePlateId;
                        
                        workLine = workExecute.putAwayToLocation(workLine.WorkId,
                            workLine.LineNum,
                            workLine.wmsLocationId,
                            WhsWorkManualComplete::retrieveWorkPutFlow(workTable, workLine),
                            _userId,
                            sourceLicensePlateId,
                            targetLicensePlateId,
                            handleByLP);
                        break;
                       
                    default:
                        WhsWorkTypeHandler handler = WhsWorkTypeHandler::singletonFromType(workLine.WorkType);
                        
                        if (handler)
                        {
                            workLine = handler.executeWorkLine(workExecute, workLine, _userId);
                        }
                        break;
                }

                if (workLine.WorkId && WHSWorkTemplateLine::findByRecId(workLine.WorkTemplateLineRecId).Freeze)
                {
                    WHSWorkBlocking::newFromWorkIdSkipInProgressWorkLineWithNoPreviousPutCheck(workLine.WorkId)
                        .tryBlockWorkWithReasonType(WHSWorkBlockingReasonType::Undefined);
                    break;
                }

                if (workLine.WorkStop)
                {
                    break;
                }

                // Reread the work header in case it has been changed by work line processing.
                workTable.reread();

                if (explicitTransactionHandling
                    && numberOfProcessedWorkLines mod CommitSize == 0)
                {
                    WhsWorkManualComplete::unlockManuallyCompletedWorkHeader(workTable.WorkId, _userId);

                    ttscommit;

                    transactionOpened = false;

                    WHSInstrumentationManualWorkCompletionPerformanceTask::logWorkLineSplitCommit(workTable.RecId, numberOfProcessedWorkLines, numberOfProcessedCWWorkLines);
                }
            }
        }

        if (transactionOpened)
        {
            WhsWorkManualComplete::unlockManuallyCompletedWorkHeader(workTable.WorkId, _userId);
            
            ttscommit;

            WHSInstrumentationManualWorkCompletionPerformanceTask::logWorkLineFinalCommit(workTable.RecId, numberOfProcessedWorkLines, numberOfProcessedCWWorkLines);
        }

        if (!explicitTransactionHandling)
        {
            WhsWorkManualComplete::unlockManuallyCompletedWorkHeader(workTable.WorkId, _userId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processEarlyToteReuse</Name>
				<Source><![CDATA[
    private static WHSLicensePlateId processEarlyToteReuse(WHSWorkTable _workTable, WHSWorkLine _workLine)
    {
        WHSLicensePlateId sourceLicensePlateId = _workTable.TargetLicensePlateId;

        if (WarehouseInventoryTransactionStackToteReuseCapabilityFlight::instance().isEnabled()
            && WHSToteReuseTable::isToteReuseEnabled(_workLine))
        {
            WHSToteReuseTable toteReuseTable = WHSToteReuseTable::addNewRecord(_workLine.WorkId, _workTable.TargetLicensePlateId);
            WHSLicensePlateId temporaryLicensePlateId = toteReuseTable.TmpToteId;
            if (temporaryLicensePlateId)
            {
                _workTable.TargetLicensePlateId = temporaryLicensePlateId;
                _workTable.update();
                                
                if (!WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(_workLine.WorkId))
                {
                    sourceLicensePlateId = temporaryLicensePlateId;
                }
            }
        }

        return sourceLicensePlateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeGTDId</Name>
				<Source><![CDATA[
    private static void initializeGTDId(InventDim _inventDim, InventGTDId_RU _gtdId)
    {
        _inventDim.InventGtdId_RU = _gtdId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>performValidation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the validation on work.
    /// </summary>
    /// <param name="_userId">
    /// Warehouse user to complete the work as.
    /// </param>
    /// <param name="_whsTmpCompleteWorkTable">
    /// Buffer with work headers to be completed.
    /// </param>
    /// <param name="_whsTmpCompleteWorkLine">
    /// Buffer with work lines to be completed.
    /// </param>
    /// <returns>
    /// A list of errors from the validation.
    /// </returns>
    protected static List performValidation(
        WHSUserId               _userId,
        WHSTmpCompleteWorkTable _whsTmpCompleteWorkTable,
        WHSTmpCompleteWorkLine  _whsTmpCompleteWorkLine)
    {
        List errors = new List(Types::String);
        WHSLicensePlateQuantityValidator    licensePlateQuantityValidator;

        while select _whsTmpCompleteWorkTable
        {
            if (!_whsTmpCompleteWorkTable.TargetLicensePlateId
                && WHSWorkTable::hasPickLinesWithoutLocatedLP(_whsTmpCompleteWorkTable.WorkId)
                && WHSWorkTable::hasPickLinesWithLocatedLP(_whsTmpCompleteWorkTable.WorkId))
            {
                errors.addEnd(strFmt("@SYP5070018", _whsTmpCompleteWorkTable.WorkId));
                continue;
            }

            if (!WhsWorkManualComplete::canCompleteWorkWithMultipleLocatedLPs(_whsTmpCompleteWorkTable))
            {
                errors.addEnd(strFmt("@WAX:WorkWithoutDifferentLocatedLPError", _whsTmpCompleteWorkTable.WorkId));
                continue;
            }

            WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromType(_whsTmpCompleteWorkTable.WorkTransType);
            
            licensePlateQuantityValidator = WHSLicensePlateQuantityValidator::construct();

            if (workTransactionType &&
                 (workTransactionType.isOutbound() ||
                  _whsTmpCompleteWorkTable.WorkTransType == WHSWorkTransType::Replenishment))
            {

                while select _whsTmpCompleteWorkLine
                    where _whsTmpCompleteWorkLine.WorkId       == _whsTmpCompleteWorkTable.WorkId
                        && (_whsTmpCompleteWorkLine.WorkStatus == WHSWorkStatus::Open
                        ||  _whsTmpCompleteWorkLine.WorkStatus == WHSWorkStatus::InProcess)
                {
                    if (WhsWorkManualComplete::validateWorkTypeForTmpCompleteWorkLine(_whsTmpCompleteWorkLine)
                        && !_whsTmpCompleteWorkLine.isPutBefore())
                    {
                        if (WMSLocation::find(_whsTmpCompleteWorkLine.wmsLocationId, _whsTmpCompleteWorkTable.InventLocationId).whsLocationIsLPControlled())
                        {
                            if (!_whsTmpCompleteWorkLine.TargetLicensePlateId)
                            {
                                if (_whsTmpCompleteWorkLine.LocatedLPId)
                                {
                                    licensePlateQuantityValidator.addQuantityOnLP(_whsTmpCompleteWorkLine.InventQtyRemain, _whsTmpCompleteWorkLine.LocatedLPId);
                                }
                                else
                                {
                                    errors.addEnd(strFmt("@WAX2651", _whsTmpCompleteWorkTable.WorkId));
                                }
                            }
                            else if (_whsTmpCompleteWorkTable.WorkTransType == WHSWorkTransType::PackedContainerPicking
                                && WHSLicensePlate::isParentLicensePlate(_whsTmpCompleteWorkLine.TargetLicensePlateId))
                            {
                                if (!licensePlateQuantityValidator.quantityEqualsTotalParentLPQuantity(_whsTmpCompleteWorkLine.InventQtyRemain, _whsTmpCompleteWorkLine.TargetLicensePlateId))
                                {
                                    errors.addEnd(strFmt("@WAX4149", _whsTmpCompleteWorkTable.WorkId));
                                }
                            }
                            else if (!licensePlateQuantityValidator.quantityEqualsTotalLPQuantity(_whsTmpCompleteWorkLine.InventQtyRemain, _whsTmpCompleteWorkLine.TargetLicensePlateId))
                            {
                                errors.addEnd(strFmt("@WAX4149", _whsTmpCompleteWorkTable.WorkId));
                            }
                        }
                        else if (!WhsWorkManualComplete::isPickWorkLineLicensePlateValid(_whsTmpCompleteWorkTable, _whsTmpCompleteWorkLine))
                        {
                            errors.addEnd("@WAX2194");
                        }
                    }
                }
            }

            if (!licensePlateQuantityValidator.allAddedQuantitiesEqualTotalLPQuantities())
            {
                errors.addEnd(strFmt("@SYP5070017", _whsTmpCompleteWorkTable.WorkId));
            }

            container workTypesWithNotMandatoryLocation = WhsWorkManualComplete::workTypesWithNotMandatoryLocation();
            select count(RecId) from _whsTmpCompleteWorkLine
                where _whsTmpCompleteWorkLine.WorkId         == _whsTmpCompleteWorkTable.WorkId
                    && _whsTmpCompleteWorkLine.wmsLocationId == ''
                    && _whsTmpCompleteWorkLine.WorkStatus    != WHSWorkStatus::Cancelled
                    && !(_whsTmpCompleteWorkLine.WorkType    in workTypesWithNotMandatoryLocation);

            if (_whsTmpCompleteWorkLine.RecId > 0)
            {
                errors.addEnd(strFmt("@WAX2649", _whsTmpCompleteWorkTable.WorkId));
            }

            if (!WhsWorkManualComplete::validateQualityCheckLines(_whsTmpCompleteWorkTable, _whsTmpCompleteWorkLine))
            {
                errors.addEnd(strFmt("@WAX:CannotProcessWorkWithQualityCheckLines", _whsTmpCompleteWorkLine.WorkId));
            }

            WHSWorkTable workTable = WHSWorkTable::find(_whsTmpCompleteWorkTable.WorkId);

            if (!workTable.Frozen
                && workTable.ReplenishmentDependentWorkBlockingPolicy == WHSReplenishmentDependentWorkBlockingPolicy::IndividualWorkLine
                && workTable.hasUnFinishedReplenWork())
            {
                errors.addEnd(strFmt("@WAX:CannotProcessWorkWithLinesBlockedByReplenishment", workTable.workId));
            }
        }

        return errors;
    }

]]></Source>
			</Method>
			<Method>
				<Name>workTypesWithNotMandatoryLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns container with the work types that do not require location specified. 
    /// </summary>
    /// <returns>Container with the work types that do not require location specified.</returns>
    protected static container workTypesWithNotMandatoryLocation()
    {
        return [WHSWorkType::Print, WHSWorkType::Custom, WHSWorkType::QualityCheck];
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWorkTypeForTmpCompleteWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the work type for temporary complete work line.
    /// </summary>
    /// <param name = "_tmpCompleteWorkLine">The temporary complete work line record.</param>
    /// <returns>true if work type is pick; otherwise, false.</returns>
    protected static boolean validateWorkTypeForTmpCompleteWorkLine(WHSTmpCompleteWorkLine _tmpCompleteWorkLine)
    {
        return _tmpCompleteWorkLine.WorkType == WHSWorkType::Pick;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPickWorkLineLicensePlateValid</Name>
				<Source><![CDATA[
    private static boolean isPickWorkLineLicensePlateValid(WHSTmpCompleteWorkTable _whsTmpCompleteWorkTable, 
															WHSTmpCompleteWorkLine  _whsTmpCompleteWorkLine)
    {
        // If the target license plate is set on the work header, then the picked license plate will not be used as the target, so no validation is needed.
        // If the work line has generate license plate set, the target license plate will be auto-generated and in almost all cases it will be unique, so no validation is needed.
        return _whsTmpCompleteWorkTable.TargetLicensePlateId
            || _whsTmpCompleteWorkLine.GenerateLP
            || WHSLicensePlate::validateLicensePlateQty(_whsTmpCompleteWorkLine.TargetLicensePlateId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCompleteWorkWithMultipleLocatedLPs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check that the work can be completed in case if exists multiple located LPs.
    /// </summary>
    /// <param name="_whsTmpCompleteWorkTable">
    /// <c>WHSTmpCompleteWorkTable</c> table record.
    /// </param>
    /// <returns>True if the work can be completed; otherwise, false.</returns>
    private static boolean canCompleteWorkWithMultipleLocatedLPs(WHSTmpCompleteWorkTable _whsTmpCompleteWorkTable)
    {
        return _whsTmpCompleteWorkTable.TargetLicensePlateId ||
            _whsTmpCompleteWorkTable.WorkTransType != WHSWorkTransType::TransferIssue ||
            !WHSWorkTable::hasPickLinesWithDifferentLocatedLP(_whsTmpCompleteWorkTable.WorkId) ||
            !WHSWorkTable::hasTransferOrderInventLocationToWHSEnabled(_whsTmpCompleteWorkTable.WorkId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveWorkPutFlow</Name>
				<Source><![CDATA[
    private static WHSWorkPutFlow retrieveWorkPutFlow(WHSWorkTable _workTable, WHSWorkLine _workLine)
    {
        if (!WMSLocation::find(_workLine.wmsLocationId, _workTable.InventLocationId).whsLocationIsLPControlled())
        {
            return WHSWorkPutFlow::SplitQuantity; 
        }
        
        return WHSWorkTable::retrieveWorkPutFlow(_workLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateQualityCheckLines</Name>
				<Source><![CDATA[
    private static boolean validateQualityCheckLines(
        WHSTmpCompleteWorkTable _whsTmpCompleteWorkTable,
        WHSTmpCompleteWorkLine  _whsTmpCompleteWorkLine)
    {
        select firstonly RecId from _whsTmpCompleteWorkLine
            where _whsTmpCompleteWorkLine.WorkId         == _whsTmpCompleteWorkTable.WorkId
                && _whsTmpCompleteWorkLine.WorkStatus    != WHSWorkStatus::Cancelled
                && _whsTmpCompleteWorkLine.WorkType      == WHSWorkType::QualityCheck;

        return _whsTmpCompleteWorkLine.RecId == 0;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>