<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSWorkExecuteDisplayClusterPicking</Name>
	<SourceCode>
		<Declaration><![CDATA[
[WHSWorkExecuteMode(WHSWorkExecuteMode::ClusterPicking)]
[WHSWorkExecuteMode(WHSWorkExecuteMode::SystemDirectedClusterPicking)]
public class WhsWorkExecuteDisplayClusterPicking extends WHSWorkExecuteDisplayCluster
{
    private const int PositionFullStep = -1;
    private const int QuantityFullStep = -2;
    private const int AutoGenerateClusterStep = 9;
    
    private boolean putReadyForOverrideLoc;
    private boolean addButtons;

    #define.SortVerification(4)

    private InventDim batchPickInventDim;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>mustGoToMenuWhenCancelling</Name>
				<Source><![CDATA[
    protected boolean mustGoToMenuWhenCancelling()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processControl</Name>
				<Source><![CDATA[
    public boolean processControl(WhsControl _control, str _value)
    {
        switch (true)
        {
            case _control is WhsControlQtyToPick:
                WhsControlQtyToPick controlQtyToPick = _control as WhsControlQtyToPick;
                InventQty qtyToPickInvent = controlQtyToPick.parmQtyToPickInvent();

                if (qtyToPickInvent < 0 || 
                    pass.parmQty() < qtyToPickInvent)
                {
                    return _control.fail("@WAX1172");
                }
                var fieldValues = _control.parmContext().fieldValues;
                fieldValues.insert(#QtyShort, pass.parmQty() - qtyToPickInvent);
                break;

            case _control is WhsControlPositionFullQty:
                WhsControlPositionFullQty controlFullQty = _control as WhsControlPositionFullQty;
                WMSLocationId pickLocation;
                ItemId localItem;

                [pickLocation, localItem] = this.getNextBatchPick(pass.lookup(#ClusterId));
                InventQty inventQty = this.getBatchPickWorkQuantityWithPosition(pass.lookup(#ClusterId), pass.lookup(WhsWorkExecuteDisplayClusterControls::PositionFull), pickLocation, localItem);
                
                if (controlFullQty.parmPositionFullQty() > inventQty
                    || controlFullQty.parmPositionFullQty() < 0)
                {
                    return _control.fail("@WAX1172");
                }
        }
        
        return super(_control, _value);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPositionAndQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state to show cluster position and work quantity of a work transaction.
    /// </summary>
    /// <param name="localtransId">
    /// The work transaction id.
    /// </param>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    public container addPositionAndQty(WHSWorkTransId localtransId, container _con)
    {
        WHSWorkCLusterLine workClusterLine;
        WHSWorkTrans       workTrans;
        container          ret = _con;

        select firstonly ClusterPosition from workClusterLine
            where workClusterLine.ClusterId      == pass.lookup(#ClusterId)
                join Qty, UOM from workTrans
                    where workTrans.WorkId       == workClusterLine.WorkId &&
                          workTrans.worktransid  == localtransId;

        ret += [this.buildControl(#RFLabel, #PositionName, strFmt("@WAX3619", workClusterLine.ClusterPosition), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSClusterPosition))];
        ret += [this.buildControl(#RFLabel, #RFQtyLabel, strFmt("@WAX1685", WHSWorkExecuteDisplay::num2StrDisplay(workTrans.Qty), workTrans.UOM), 0, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFQuantityAndUOM))];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildBatchPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds clustered pick screen.
    /// </summary>
    /// <param name="_con">
    /// Current container that represents the currently build RF screen.
    /// </param>
    /// <param name="_locationId">
    /// The warehouse location ID.
    /// </param>
    /// <param name="_itemId">
    /// The Item ID.
    /// </param>
    /// <param name="_updatePass">
    /// A boolean which determines how we are updating the global pass. If building a new dim control we must prompt the user again.
    /// </param>
    /// <returns>
    /// A container that represents the currently build RF screen including any controls built in this method.
    /// </returns>
    public container buildBatchPick(
        container      _con,
        WMSLocationId  _locationId,
        ItemId         _itemId,
        boolean        _updatePass = true)
    {
        container           ret = _con;
        WMSLocation         location = WMSLocation::find(_locationId, pass.lookup(#InventLocationId));
        WHSRFDescription1   description1;
        WHSRFDescription2   description2;
        InventQty           inventQty;
        WHSWorkClusterLine  tmpClusterLine;
        Qty                 highQty;
        UnitOfMeasureSymbol highUOM;
        InventTable         inventTable;

        description1    = WHSInventTable::find(_itemId).rfDescription1;
        description2    = WHSInventTable::find(_itemId).rfDescription2;

        ret += [this.buildControl(#RFLabel, 'Pick', strFmt("@WAX1275", WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).rfTitle), 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFLabel, #ClusterId, strFmt("@WAX3618", pass.lookup(#ClusterId)), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSClusterId))];

        ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, _locationId, extendedTypeNum(WMSLocationId), '', 0, false)];

        if (pass.exists(#MenuItem))
        {
            if (WHSRFAutoConfirm::isLocationConfirmationEnabled(pass.lookup(#MenuItem), WHSWorkType::Pick))
            {
                if (location.CheckText)
                {
                    ret += [this.buildControl(#RFText, #CheckDigit, "@WAX1197", 1, pass.lookupStr(#CheckDigit), extendedTypeNum(WMSCheckText), '', 0)];
                }
                else
                {
                    ret += [this.buildControl(#RFText, #LocVerification, "@WAX1196", 1, pass.lookupStr(#LocVerification), extendedTypeNum(WMSLocationId), '', 0)];
                }
            }
        }

        boolean locationIsLPControlled = location.whsLocationIsLPControlled();

        if (locationIsLPControlled)
        {
            boolean enabled = pass.exists(WHSWorkExecuteDisplayPieceByPieceControls::PieceByPieceConfirmation) && pass.hasValue(#LicensePlateId);

            ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1,
            pass.exists(WHSWorkExecuteDisplayPieceByPieceControls::PieceByPieceConfirmation) || (pass.hasValue(#LicensePlateId)) ? pass.lookupStr(#LicensePlateId) : '',
                extendedTypeNum(WHSLicensePlateId), '', 0, !enabled)];
        }

        inventQty = this.getBatchPickInventQty(pass.lookup(#ClusterId), _locationId, _itemId);

        ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, _itemId, extendedTypeNum(InventInventItemSearchItem), '', 0, false)];
        ret += this.addProductConfirmationControl(WHSWorkType::Pick, inventQty, _itemId);

        if (_itemId)
        {
            if (description1)
            {
                ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt('\t        %1', description1), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription1))];
            }
            else
            {
                ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt('\t        %1', InventTable::find(_itemId).productNameWhsWorkExecute()), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(EcoResProductName))];
            }

            if (description2)
            {
                ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt('\t        %1', description2), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription2))];
            }
        }

        batchPickInventDim = pass.createInventDimFromPass();

        ret = this.buildAboveLocationDimensions(ret, batchPickInventDim, _itemId);

        pass.insert(#Qty, inventQty);

        [highQty, highUOM] = this.getBatchPickQty(inventQty, _itemId);

        ret += [this.buildControl(#RFLabel, #RFQtyLabel, strFmt("@WAX1685", WHSWorkExecuteDisplay::num2StrDisplay(highQty), highUOM), 1, '', #WHSRFUndefinedDataType, '', 0, true, "", WHSRFColorText::Default, extendedTypeNum(WHSRFQuantityAndUOM))];

        if (pass.exists(#MenuItem))
        {
            if (WHSRFAutoConfirm::isVerifyQtyConfirmationEnabled(pass.lookup(#MenuItem), WHSWorkType::Pick))
            {
                ret += [this.buildControl(#RFText, #ClusterPickQtyVerification, "@SYS105177", 1, '', extendedTypeNum(Qty), '', 0)];
                ret += [this.buildControl(#RFLabel, #QtyVerifyUOM, highUOM, 0, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(UnitOfMeasureSymbol))];
            }
        }

        inventTable = InventTable::find(_itemId);

        if (!workLine)
        {
            workLine = WHSWorkLine::find(pass.parmWorkId(), pass.parmLineNum());
            ret = this.buildNextDimensionCaptureControl(ret, batchPickInventDim, _itemId, inventQty, _updatePass);
            workLine.clear();
        }
        else
        {
            ret = this.buildNextDimensionCaptureControl(ret, batchPickInventDim, _itemId, inventQty, _updatePass);
        }

        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];

        //Hide pass button if cluster has partially picked line by the user
        if (this.canPassCluster(pass))
        {
            ret += [this.buildControl(#RFButton, #RFPass, "@SYS113811", 1, '', #WHSRFUndefinedDataType, '', 0)];
        }

        ret += [this.buildControl(#RFButton, #RFSkip, "@WAX3534", 1, '', #WHSRFUndefinedDataType, '', 0)];

        if (this.canAddShortPickButtonForClusterPicking())
        {
            ret += [this.buildControl(#RFButton, #RFShortPick, "@WAX1322", 1, '', #WHSRFUndefinedDataType, '', 0)];
        }
        
        if (mode == WHSWorkExecuteMode::SystemDirectedClusterPicking)
        {
            ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAddShortPickButtonForClusterPicking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the short pick button can be added to the warehouse mobile device page for cluster picking.
    /// </summary>
    /// <returns>true if the short pick button can be added; otherwise, false.</returns>
    [Wrappable(true)]
    internal boolean canAddShortPickButtonForClusterPicking()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildClusterShortPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for Short Pick screen.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before the controls are added.
    /// </param>
    /// <param name="_locationId">
    /// Location id for short picking.
    /// </param>
    /// <param name="_itemId">
    /// The short picked item id.
    /// </param>
    /// <returns>
    /// Container containing the form state after the controls are added.
    /// </returns>
    public container buildClusterShortPick(
        container       _con,
        WMSLocationId   _locationId,
        ItemId          _itemId)
    {
        WHSRFDescription1 description1    = WHSInventTable::find(_itemId).rfDescription1;
        WHSRFDescription2 description2    = WHSInventTable::find(_itemId).rfDescription2;
     
        WMSLocation location = WMSLocation::find(_locationId, pass.lookup(#InventLocationId));

        container  ret = _con;

        ret += [this.buildControl(#RFLabel, #RFShortPick, "@WAX1322", 1, '', #WHSRFUndefinedDataType, '', 0)];

        ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, _locationId, extendedTypeNum(WMSLocationId), '', 0, false)];

        if (location.whsLocationIsLPControlled())
        {
            ret += [this.buildControl(#RFText, #LicensePlateId, "@WAX1198", 1, pass.lookupStr(#LicensePlateId), extendedTypeNum(WHSLicensePlateId), '', 0)];
        }

        if (!workLine)
        {
            workLine = WHSWorkLine::find(pass.lookupStr(#WorkId), pass.parmLineNum());
        }

        InventQty inventQty = this.getBatchPickInventQty(pass.lookup(#ClusterId), _locationId, _itemId);

        ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, _itemId, extendedTypeNum(InventInventItemSearchItem), '', 0, false)];
        ret += this.addProductConfirmationControl(workLine.WorkType, inventQty, _itemId);

        if (description1)
        {
            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", description1), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription1))];
        }
        else
        {
            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", InventTable::find(_itemId).productNameWhsWorkExecute()), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(EcoResProductName))];
        }

        if (description2)
        {
            ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", description2), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription2))];
        }

        ret += [this.buildControl(#RFText, #QtyToPick, "@WAX1327", 1, pass.lookupStr(#QtyToPick), extendedTypeNum(Qty), '', 0, !pass.exists(WHSWorkExecuteDisplayPieceByPieceControls::TotalPiecesToConfirm))];

        boolean pieceByPieceEnabled = WHSRFAutoConfirm::isPieceByPieceConfirmationEnabled(pass.lookup(#MenuItem), workLine.WorkType);

        ret = this.buildUOM(ret, '', false, false, false, pieceByPieceEnabled ? pass.lookupStr(WHSWorkExecuteDisplayPieceByPieceControls::PieceByPieceConfirmUOM) : pass.lookupStr(#SelectedValueUOM), !pieceByPieceEnabled);

        WHSWorkException    shortPickReason;
        boolean             first = true;
        str                 elements;

        while select shortPickReason
            where shortPickReason.ExceptionType == WHSExceptionType::ShortPick
        {
            if (first)
            {
                elements += shortPickReason.WorkExceptionDesc;
                first = false;
            }
            else
            {
                elements = elements + '||' + shortPickReason.WorkExceptionDesc;
            }
        }

        ret += [this.buildControl(#RFCombobox, #ShortPickReason, "@SYS86426", 1, elements, #WHSRFUndefinedDataType, '', 0, true, pass.lookupStr(#SelectedValue), WHSRFColorText::Default, extendedTypeNum(WHSWorkExceptionDesc))];
        
        ret = this.addOkButton(ret);

        if (pieceByPieceEnabled)
        {
            ret = this.addDoneButton(ret);
        }
        
        ret += [this.buildControl(#RFButton, #RFBack, "@SYS56453", 1, '', #WHSRFUndefinedDataType, '', 0)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>backClicked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles back button click.
    /// </summary>
    protected void backClicked()
    {
        step = 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildClusterShortPickConf</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds controls to form state for Short Pick Confirmation screen.
    /// </summary>
    /// <param name="_con">
    /// Container containing the form state before controls are added.
    /// </param>
    /// <param name="_locationId">
    /// Location id of the short picking.
    /// </param>
    /// <param name="_itemId">
    /// The short picked item id.
    /// </param>
    /// <returns>
    /// Container containing the form state after controls are added.
    /// </returns>
    public container buildClusterShortPickConf(container       _con,
                                        WMSLocationId   _locationId,
                                        ItemId          _itemId)
    {
        container           ret = _con;
        WMSLocation         location;
        WHSLicensePlateId   licensePlateId;
        WHSRFDescription1   description1;
        WHSRFDescription2   description2;
        UnitOfMeasureSymbol uom;
        UnitOfMeasureSymbol inventUOM;

        description1    = WHSInventTable::find(_itemId).rfDescription1;
        description2    = WHSInventTable::find(_itemId).rfDescription2;
        uom             = workLine.UnitId;
        inventUOM       = InventTableModule::find(workLine.ItemId, ModuleInventPurchSales::Invent).UnitId;

        location = WMSLocation::find(_locationId, pass.lookup(#InventLocationId));

        ret += [this.buildControl(#RFLabel, #RFShortPick, "@WAX1322", 1, '', #WHSRFUndefinedDataType, '', 0)];

        ret += [this.buildControl(#RFText, #WMSLocationId, "@WAX1196", 1, _locationId, extendedTypeNum(WMSLocationId), '', 0, false)];

        if (licensePlateId)
        {
            ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1214", 1, licensePlateId, extendedTypeNum(WHSLicensePlateId), '', 0, false)];
        }

        ret += [this.buildControl(#RFText, #ItemId, "@SYS14428", 1, _itemId, extendedTypeNum(InventInventItemSearchItem), '', 0, false)];

        if (description1)
        {
            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", description1), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription1))];
        }
        else
        {
            ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt("\t        %1", InventTable::find(_itemId).productNameWhsWorkExecute()), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(EcoResProductName))];
        }

        if (description2)
        {
            ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt("\t        %1", description2), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription2))];
        }

        ret += [this.buildControl(#RFText, #QtyToPick, "@WAX1327", 1, pass.lookup(#QtyToPick), extendedTypeNum(Qty), '', 0, false)];
        ret += [this.buildControl(#RFText, #QtyShort, "@WAX1333", 1, pass.lookup(#QtyShort), extendedTypeNum(Qty), '', 0, false)];
        ret = this.buildUOM(ret, '', false, false, false, pass.lookupStr(#SelectedValueUOM), false);

        ret += [this.buildControl(#RFText, 'ReasonString', "@SYS86426", 1, pass.exists(#ShortPickReason) ? WHSWorkException::find(pass.lookup(#ShortPickReason), WHSExceptionType::ShortPick).WorkExceptionDesc : '', #WHSRFUndefinedDataType, '', 0, false)];

        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        ret += [this.buildControl(#RFButton, #RFBack, "@SYS56453", 1, '', #WHSRFUndefinedDataType, '', 0)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSortVerification</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the sort verification screen after a batched pick
    /// </summary>
    /// <param name="_con">
    /// Current container that represents the currently build RF screen.
    /// </param>
    /// <param name="_transCon">
    /// Container of WHSWorkTransId
    /// </param>
    /// <returns>
    /// A container that represents the currently build RF screen including any controls built in this method.
    /// </returns>
    public container buildSortVerification(
        container _con,
        container _transCon)
    {
        container           ret = _con;
        WHSWorkTransId      tmpTransId;
        WHSRFDescription1   description1;
        WHSRFDescription2   description2;
        ItemId              itemId;
        WHSWorkClusterTable workClusterTable;
        int                 i;

        itemId = pass.lookup(#ItemId);
        description1    = WHSInventTable::find(itemId).rfDescription1;
        description2    = WHSInventTable::find(itemId).rfDescription2;

        ret += [this.buildControl(#RFLabel, #ClusterSort, strFmt("@WAX3730", WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).rfTitle), 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFLabel, #ClusterId, strFmt("@WAX3618", pass.lookup(#ClusterId)), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSClusterId))];
        ret += [this.buildControl(#RFLabel, #ItemId, strFmt("@WAX2328", itemId), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(InventInventItemSearchItem))];

        if (itemId)
        {
            if (description1)
            {
                ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt('\t        %1', description1), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription1))];
            }
            else
            {
                ret += [this.buildControl(#RFLabel, #RFDescription1, strFmt('\t        %1', InventTable::find(itemId).productNameWhsWorkExecute()), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(EcoResProductName))];
            }

            if (description2)
            {
                ret += [this.buildControl(#RFLabel, #RFDescription2, strFmt('\t        %1', description2), 1, '', #WHSRFUndefinedDataType, '', 0, false, "", WHSRFColorText::Default, extendedTypeNum(WHSRFDescription2))];
            }
        }

        switch (WHSClusterProfile::find(pass.lookup(#ClusterProfile)).ClusterSortVerification)
        {
            case WHSClusterSortVerification::None:

                for (i = 1; i <= conLen(_transcon); i++)
                {
                    tmpTransId = conPeek(_transCon, i);
                    ret = this.addPositionAndQty(tmpTransId, ret);
                }
                break;

            case WHSClusterSortVerification::LPScan:
                tmpTransId = conPeek(_transCon, 1);

                ret = this.addPositionAndQty(tmpTransId, ret);
                ret += [this.buildControl(#RFText, #TargetLicensePlateId, "@WAX1198", 1, '', extendedTypeNum(WHSTargetLicensePlateId), '', 0)];

                ttsbegin;
                workClusterTable = WHSWorkClusterTable::find(pass.lookup(#ClusterId), true);
                workClusterTable.WorkClusterTransContainer = _transCon;
                workClusterTable.update();
                ttscommit;
                break;

            case WHSClusterSortVerification::PositionScan:
                tmpTransId = conPeek(_transCon, 1);
                ret = this.addPositionAndQty(tmpTransId, ret);
                ret += [this.buildControl(#RFText, #ClusterPosition, "@WAX3553", 1, '', extendedTypeNum(WHSClusterPosition), '', 0)];

                ttsbegin;
                workClusterTable = WHSWorkClusterTable::find(pass.lookup(#ClusterId), true);
                workClusterTable.WorkClusterTransContainer = _transCon;
                workClusterTable.update();
                ttscommit;
                break;
        }

        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clusterCompleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Closes the cluster and prepares the next screen to be shown in the RF
    /// </summary>
    /// <param name="_con">
    /// The previous RF screen container.
    /// </param>
    /// <param name="_clusterProfile">
    /// The cluster profile being used by the current active menu item.
    /// </param>
    /// <param name="_keepClusterOpen">
    /// Boolean determining if cluster is to remain open (staged work for example)
    /// </param>
    /// <returns>
    /// A container of the new RF screen to be displayed.
    /// </returns>
    private container clusterCompleted(
        container           _con,
        WHSClusterProfile   _clusterProfile,
        boolean             _keepClusterOpen = false)
    {
        
        WHSClusterId clusterId = pass.lookup(#ClusterId);
        WHSWorkClusterTable::lockUnlockWorkCluster(clusterId, '');
        WHSWorkClusterTable::lockUnlockClusteredWork(clusterId, '');

        WHSWorkClusterStatus clusterStatus;

        if (_keepClusterOpen)            
        {
            clusterStatus = WHSWorkClusterStatus::InProcess;
        }
        else 
        {
            clusterStatus = WHSWorkClusterTable::find(clusterId).calculateWorkClusterStatusOnCompletion();
        }
        
        WHSWorkClusterTable::updateClusterStatus(clusterId, clusterStatus);
        pass = this.resetPassthrough(_con, false);

        return this.buildClusterCompleted(_clusterProfile);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVariablesForOverrideLoc</Name>
				<Source><![CDATA[
    private void setVariablesForOverrideLoc()
    {
        putReadyForOverrideLoc = true;
        addButtons = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildClusterCompleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the next screen to be shown in the RF.
    /// </summary>
    /// <param name="_clusterProfile">
    /// The cluster profile being used by the current active menu item.
    /// </param>
    /// <returns>
    /// A container of the new RF screen to be displayed.
    /// </returns>
    protected container buildClusterCompleted(WHSClusterProfile _clusterProfile)
    {
        container ret = this.addErrorLabel(conNull(), "@WAX3749", WHSRFColorText::Success);

        if (mode == WHSWorkExecuteMode::SystemDirectedClusterPicking)
        {
            step = 0;
            ret += conDel(this.displayForm(this.updateModeStepPass(conNull(), mode, step, pass)), 1, 2);
        } 
        else 
        {
            if (_clusterProfile.GenerateClusterId)
            {
                pass.insert(#ClusterId, NumberSeq::newGetNum(WHSParameters::numRefWHSClusterId()).num());
                pass.insert(#ClusterProfile, _clusterProfile.ClusterProfileId);
                ret = this.buildAssignPositions(ret);
                step = 2;
            }
            else
            {
                ret = this.buildGetClusterId(ret);
                step = 1;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowClusterFullOption</Name>
				<Source><![CDATA[
    private boolean allowClusterFullOption(WHSAllowFullSplit _menuItemFullSplit)
    {
        return _menuItemFullSplit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleRFOverride</Name>
				<Source><![CDATA[
    private void handleRFOverride()
    {
        step = #OverrideStep1;
    
        // Clustered override
        if (workLine.RecId == 0)
        {
            workLine = this.findClusterWorkLineForOverride(pass.lookup(#ClusterId), pass.lookup(#WMSLocationId));
            pass.insert(WHSWorkExecuteDisplayClusterPickingControls::ClusterPickOverridePutLocation, 1);
            pass.insert(#WorkId, workLine.WorkId);
            pass.insert(#ItemID, workLine.ItemId);
            pass.parmLineNum(workLine.LineNum);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayForm</Name>
				<Source><![CDATA[
    container displayForm(container _con, str _buttonClicked = '')
    {
        container                       ret = conNull();
        container                       con = _con;
        container                       transCon;
        WhsWorkExecute                  workExecute = WhsWorkExecute::construct();
        int                             hasError = 0;
        boolean                         complete;
        Map                             fieldValues;
        container                       tmpFieldValues;
        WHSClusterProfile               clusterProfile;
        WMSLocationId                   location;
        ItemId                          pickItem;
        InventTable                     inventTable;
        boolean                         cycleCountDisplayUpdated;
        WHSRFMenuItemTable              menuItemTable;
        WHSWorkAuditTemplateTable       workAuditTemplateTable;
        WHSWorkAuditTemplateLine        workAuditTemplateLine;
        WHSWorkAuditCaptureData         workAuditCaptureData;
        WHSAuditSeqNum                  auditSeqNum;
        boolean                         auditComplete;
        boolean                         workStop;
        WHSWorkLine                     shortPickWorkLine;
        WHSWorkClusterLine              workClusterLine;

        WHSClusterId                    clusterId;
        WHSWorkExecuteMode              workExecuteMode;
        boolean                         recall;
        container                       tmpPass;
        WHSClusterId                    localClusterId;
        WHSWorkClusterTable             workClusterTable;
        
        pass = WHSRFPassthrough::create(conPeek(_con, 2));

        menuItemTable = WHSRFMenuItemTable::find(pass.lookup(#MenuItem));

        if (menuItemTable.WorkAuditTemplateId)
        {
            workAuditTemplateTable = WHSWorkAuditTemplateTable::find(menuItemTable.WorkAuditTemplateId);
        }

        pass.insert(#ClusterProfile, menuItemTable.ClusterProfileId);
        pass.insert(#ClusterSort, enum2Value(WHSClusterProfile::find(menuItemTable.ClusterProfileId).ClusterSortVerification));

        if (!pass.exists(#InventSiteId))
        {
            pass.insert(#InventLocationId, WHSWorkUserSession::find(userId).InventLocationId);
            pass.insert(#InventSiteId, InventLocation::find(WHSWorkUserSession::find(userId).InventLocationId).InventSiteId);
        }

        clusterProfile = WHSClusterProfile::find(pass.lookup(#ClusterProfile));

        if (_buttonClicked == #RFPass)      // Pass
        {
            WHSPassCluster::passCluster(pass.lookup(#ClusterId));

            pass.remove(#ClusterId);
            pass.remove(#ClusterPosition);
            pass.remove(#PositionCounter);
            pass.remove(#WorkId);
            pass.remove(#LineNum);

            step = 0;
        }
        else if (_buttonClicked == #RFSkip) // Skip
        {
            step = 7;
        }
        else if (_buttonClicked == #RFShortPick) // Short Pick
        {
            step = #ShortPick;

            pass.insert(#Initiation, 1);
        }
        else if (_buttonClicked == WhsWorkExecuteDisplayClusterControls::PositionFullButton) // Position full clicked while on pick screen.
        {
            step = PositionFullStep;
        } 
        else if (_buttonClicked == #RFOverride)
        {
            this.handleRFOverride();
        }

        // Generate cluster Id if automatically assigned
        boolean  autoGenerateCluster = false;
        if (step == 0 && clusterProfile.GenerateClusterId && !pass.exists(#ClusterId))
        {
            pass.insert(#ClusterId, NumberSeq::newGetNum(WHSParameters::numRefWHSClusterId()).num());
            
            if (mode == WHSWorkExecuteMode::SystemDirectedClusterPicking)
            {
                try
                {
                    // Attempt to find an in process cluster locked by current user first
                    autoGenerateCluster = this.getOpenOrInProcessCluster();

                    if (!autoGenerateCluster)
                    {
                        // Try to automatically create cluster based on system directed query
                        autoGenerateCluster = this.createSystemDirectedCluster();
                    }
                }
                catch
                {
                    ret = conNull();
                }
            }

            if (autoGenerateCluster && !this.checkAnyClusterPositionMissingTargetLP())
            {
                step = AutoGenerateClusterStep;
            }
            else
            {
                step = 1;
            }
        }

        hasError = this.hasError(_con);

        switch (step)
        {
            // Ask for cluster Id if not automatically assigned
            case 0:
                if (_buttonClicked == #RFPass)
                {
                    ret = this.addErrorLabel(ret, "@WAX3750", WHSRFColorText::Success);
                }
                ret = this.buildGetClusterId(ret);
                step = 1; 
                break;

            // Cluster Validation
            case 1:
                if (hasError)
                {
                    con = conDel(con, 3, 1);
                }

                [con, tmpFieldValues] = WHSRFControlData::processData(con, pass);
                fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                pass = this.combineMaps(pass, fieldValues);
                hasError = this.hasError(con);

                if (hasError)
                {
                    ret = con;
                    break;
                }

                [ret, complete] = this.processFieldValues(con, fieldValues);

                if (complete || _buttonClicked == #RFPass || _buttonClicked == #RFBack)
                {
                    ret = conNull();
                    
                    // Check to see if existing cluster was scanned
                    if (!autoGenerateCluster && WHSWorkClusterTable::exist(pass.lookup(#ClusterId)))
                    {
                        WHSWorkClusterTable::lockUnlockWorkCluster(pass.lookup(#ClusterId), pass.lookup(#UserId));

                        // Execute audit template if break event of Prior
                        if (workAuditTemplateTable.RecId != 0 && workAuditTemplateTable.AuditBreakEvent == WHSAuditBreakEvent::Prior)
                        {
                            [auditSeqNum, auditComplete] = WHSWorkAuditTemplateExecute::execute(workAuditTemplateTable.WorkAuditTemplateId,
                                                                                            WHSWorkAuditTemplateTable::getNextTemplateLine(workAuditTemplateTable.WorkAuditTemplateId).AuditSeqNum,
                                                                                            null);

                            if (!auditComplete)
                            {
                                pass.insert(#AuditTemplateId, workAuditTemplateTable.WorkAuditTemplateId);
                                pass.insert(#AuditSeqNum, auditSeqNum);
                                ret = this.buildWorkAuditTemplate(ret);
                                step = #WorkAuditTemplate;
                                break;
                            }
                        }

                        // Look for remaining initial batch picks
                        [location, pickItem] = this.getNextBatchPick(pass.lookup(#ClusterId));

                        if (!location)
                        {
                            // With initial picks completed, look for Putaways to complete
                            location = this.getNextGroupPutLocation(pass.lookup(#ClusterId));

                            if (location)
                            {
                                pass.insert(#WMSLocationId, location);
                                ret = conNull();
                                ret = this.buildGroupPut(ret, location);
                                step = 5;

                                this.setVariablesForOverrideLoc();
                                break;
                            }
                            else
                            {
                                // Finally look for any picks off of staging to complete
                                [location, workStop] = this.getNextGroupPickLocation(pass.lookup(#ClusterId));

                                pass.insert(#WMSLocationId, location);
                                ret = conNull();
                                ret = this.buildGroupPick(ret, location);
                                step = 6;
                                break;
                            }
                        }

                        pass.insert(#WMSLocationId, location);
                        pass.insert(#ItemId, pickItem);                        

                        ret = this.buildBatchPick(conNull(), location, pickItem);
                        
                        if (this.allowClusterFullOption(menuItemTable.AllowFullSplit))
                        {
                            ret += [this.buildControl(#RFButton, WhsWorkExecuteDisplayClusterControls::PositionFullButton, "@WAX:PositionFullButton", 1, '', #WHSRFUndefinedDataType, '', 0)];
                        }

                        step = 3;
                    }
                    else
                    {
                        if (_buttonClicked == #RFPass)
                        {
                            ret = this.addErrorLabel(ret, "@WAX3750", WHSRFColorText::Success);
                        }

                        if (mode == WHSWorkExecuteMode::SystemDirectedClusterPicking)
                        {
                            // Try to automatically create cluster based on system directed query
                            // If auto generating the cluster Id we already attempted to create cluster
                            if (!clusterProfile.GenerateClusterId)
                            {
                                autoGenerateCluster = this.createSystemDirectedCluster();
                            }
    
                            if (autoGenerateCluster && !this.checkAnyClusterPositionMissingTargetLP())
                            {
                                // Look for remaining initial batch picks
                                [location, pickItem] = this.getNextBatchPick(pass.lookup(#ClusterId));
    
                                if (!location)
                                {
                                    // With initial picks completed, look for Putaways to complete
                                    location = this.getNextGroupPutLocation(pass.lookup(#ClusterId));
    
                                    if (location)
                                    {
                                        this.lockWorkForUser(pass.lookup(#ClusterId), userId);
                                        pass.insert(#WMSLocationId, location);
                                        ret = conNull();
                                        ret = this.buildGroupPut(ret, location);
                                        step = 5;

                                        this.setVariablesForOverrideLoc();
                                        break;
                                    }
                                    else
                                    {
                                        // Finally look for any picks off of staging to complete
                                        [location, workStop] = this.getNextGroupPickLocation(pass.lookup(#ClusterId));
    
                                        this.lockWorkForUser(pass.lookup(#ClusterId), userId);
                                        pass.insert(#WMSLocationId, location);
                                        ret = conNull();
                                        ret = this.buildGroupPick(ret, location);
                                        step = 6;
                                        break;
                                    }
                                }
    
                                this.lockWorkForUser(pass.lookup(#ClusterId), userId);
                                pass.insert(#WMSLocationId, location);
                                pass.insert(#ItemId, pickItem);                                
    
                                ret = conNull();
                                ret = this.buildBatchPick(ret, location, pickItem);
    
                                step = 3;
                                break;
                            }
                            else if (!autoGenerateCluster)
                            {
                                ret = this.addErrorLabel(ret, "@WAX:NotEnoughWorkForClusterMessage", WHSRFColorText::Success);
                                ret += [this.buildControl(#RFButton, #RFCancel, "@SYS50163", 1, '', #WHSRFUndefinedDataType, '', 0)];
                            }

                            workClusterLine = this.getNextClusterLineMissingTargetLP();
                            if (workClusterLine)
                            {
                                pass.insert(#WorkId, workClusterLine.WorkId);
                            }
                            else
                            {
                                break;
                            }
                        }
                        ret = this.buildAssignPositionsForCluster(ret, workClusterLine);
                        step = 2;
                    }
                }
                break;

            // Assign Work Units To Cluster
            case 2:

                if (hasError)
                {
                    con = conDel(con, 3, 1);
                }

                [con, tmpFieldValues] = WHSRFControlData::processData(con, pass);
                fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                pass = this.combineMaps(pass, fieldValues);
                hasError = this.hasError(con);

                if (hasError)
                {
                    ret = con;
                    break;
                }

                [ret, complete] = this.processFieldValues(con, fieldValues);

                if (pass.exists(#WorkId) && !WHSWorkTable::find(pass.lookup(#WorkId)).canAddToPickingWorkCluster())
                {
                    WHSWorkId currentWorkId = pass.lookupStr(#WorkId);  
                    pass.remove(#WorkId);
                    throw error(strFmt("@WAX:CannotAddWorkToPickingCluster", currentWorkId));
                }

                if (complete || _buttonClicked == #RFDone)
                {
                    if (_buttonClicked != #RFDone)
                    {
                        WHSWorkId workId = pass.lookup(#WorkId);
                        pass.remove(#WorkId);

                        // if an exception occurs we must clear the work id
                        // to avoid the work being impacted when the user cancels out.
                        this.removeFromPassOnException(#WorkId);

                        if (!WHSWorkClusterTable::exist(pass.lookup(#ClusterId)))
                        {
                            WHSWorkClusterTable::createWorkClusterTable(pass.lookup(#ClusterId), pass.lookup(#ClusterProfile), pass.lookup(#UserId));
                        }

                        if (!WHSWorkTable::find(workId).TargetLicensePlateId)
                        {
                            if (WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GenerateLP)
                            {
                                WHSWorkTable::addTargetLicensePlate(workId, WHSLicensePlate::generateLicensePlateIdNoItem());
                            }
                            else
                            {
                                WHSWorkTable::addTargetLicensePlate(workId, pass.lookup(#TargetLicensePlateId));
                                
                                // In case of System Directed Cluster Picking the Work cluster line is created before target license plate
                                // is assigned to Work. So in case positions are not active we need to update Work cluster line position.
                                if (mode == WHSWorkExecuteMode::SystemDirectedClusterPicking && !clusterProfile.ClusterPositionsActive)
                                {
                                    WHSWorkClusterLine::updateClusterLinePosition(pass.lookup(#ClusterId),
                                                                                  workId,
                                                                                  pass.lookup(#TargetLicensePlateId));
                                }
                            }
                        }
                        if (mode != WHSWorkExecuteMode::SystemDirectedClusterPicking) 
                        {
                            if (clusterProfile.ClusterPositionsActive)
                            {
                                WHSWorkClusterLine::createWorkClusterLine(pass.lookup(#ClusterId),
                                                                    workId,
                                                                    pass.lookup(#ClusterPosition));
                            }
                            else
                            {
                                WHSWorkClusterLine::createWorkClusterLine(pass.lookup(#ClusterId),
                                                                    workId,
                                                                    WHSWorkTable::find(workId).TargetLicensePlateId);
                            }
                        }

                        pass.insert(#PositionCounter, str2int(pass.lookup(#PositionCounter)) + 1);
                    }

                    if (mode == WHSWorkExecuteMode::SystemDirectedClusterPicking)
                    {
                        workClusterLine = this.getNextClusterLineMissingTargetLP();
                        pass.insert(#WorkId, workClusterLine.WorkId);
                    }

                    if (workClusterLine.RecId != 0
                        || (mode != WHSWorkExecuteMode::SystemDirectedClusterPicking 
                            && _buttonClicked != #RFDone
                            && clusterProfile.ClusterNumPositions
                            && pass.exists(#PositionCounter)
                            && str2int(pass.lookup(#PositionCounter)) < clusterProfile.ClusterNumPositions))
                    {
                        ret = conNull();
                        ret = this.buildAssignPositionsForCluster(ret, workClusterLine);
                    }
                    else
                    {
                        // Execute audit template if break event of Prior
                        if (workAuditTemplateTable.RecId != 0 && workAuditTemplateTable.AuditBreakEvent == WHSAuditBreakEvent::Prior)
                        {
                            [auditSeqNum, auditComplete] = WHSWorkAuditTemplateExecute::execute(workAuditTemplateTable.WorkAuditTemplateId,
                                                                                            WHSWorkAuditTemplateTable::getNextTemplateLine(workAuditTemplateTable.WorkAuditTemplateId).AuditSeqNum,
                                                                                            null);

                            if (!auditComplete)
                            {
                                pass.insert(#AuditTemplateId, workAuditTemplateTable.WorkAuditTemplateId);
                                pass.insert(#AuditSeqNum, auditSeqNum);
                                ret = conNull();
                                ret = this.buildWorkAuditTemplate(ret);
                                step = #WorkAuditTemplate;
                                break;
                            }
                        }

                        // Look for remaining initial batch picks
                        [location, pickItem] = this.getNextBatchPick(pass.lookup(#ClusterId));

                        if (location)
                        {
                            pass.insert(#WMSLocationId, location);
                            pass.insert(#ItemId, pickItem);                            

                            ret = this.buildBatchPick(conNull(), location, pickItem);
                            
                            if (this.allowClusterFullOption(menuItemTable.AllowFullSplit))
                            {
                                ret += [this.buildControl(#RFButton, WhsWorkExecuteDisplayClusterControls::PositionFullButton, "@WAX:PositionFullButton", 1, '', #WHSRFUndefinedDataType, '', 0)];
                            }

                            step = 3;
                        }
                        else
                        {
                            this.executeAdditionalSteps(con);

                            // With initial picks completed, look for Putaways to complete
                            location = this.getNextGroupPutLocation(pass.lookup(#ClusterId));

                            if (location)
                            {
                                pass.insert(#WMSLocationId, location);
                                ret = conNull();
                                ret = this.buildGroupPut(ret, location);
                                step = 5;
                                
                                this.setVariablesForOverrideLoc();
                            }
                            else
                            {
                                // Finally look for any picks off of staging to complete
                                [location, workStop] = this.getNextGroupPickLocation(pass.lookup(#ClusterId));

                                pass.insert(#WMSLocationId, location);
                                ret = this.buildGroupPick(conNull(), location);
                                step = 6;
                            }
                        }
                    }
                }
                else
                {
                    ret = conNull();
                    ret = this.buildAssignPositionsForCluster(ret, this.getNextClusterLineMissingTargetLP());
                }
                break;

            // Batched Initial Pick Work
            case 3:
                WHSWorkClusterTable::lockUnlockWorkCluster(pass.lookup(#ClusterId), pass.lookup(#UserId));
                WHSWorkClusterTable::updateClusterStatus(pass.lookup(#ClusterId), WHSWorkClusterStatus::InProcess);

                if (hasError)
                {
                    con = conDel(con, 3, 1);
                }
                
                str piecesConfirmed;

                piecesConfirmed = pass.lookupStr(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed);

                [con, tmpFieldValues] = WHSRFControlData::processData(con, pass);
                fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                pass = this.combineMaps(pass, fieldValues);
                hasError = this.hasError(con);

                if (hasError)
                {
                    ret = con;
                    break;
                }

                [ret, complete] = this.processFieldValues(con, fieldValues);
                
                if (complete)
                {
                    workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
                    
                    if (this.isPieceByPieceConfirmationUsed(workLine.WorkType)
                        && ((pass.lookupNum(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed) < pass.lookupNum(WHSWorkExecuteDisplayPieceByPieceControls::TotalPiecesToConfirm))
                        || (!pass.lookupNum(WHSWorkExecuteDisplayPieceByPieceControls::TotalPiecesToConfirm))))
                    {
                        pass.remove(#ProductConfirmation);
                        ret = this.buildBatchPick(conNull(), pass.lookup(#WMSLocationId), pass.lookup(#ItemId), true);
                        break;
                    }

                    inventTable = InventTable::find(pass.lookup(#ItemId));

                    if (!pass.exists(#AssignSerial)
                        &&  this.canWorkTransTypeAllowSerialAssignment(workLine.WorkId)
                        &&  WHSInventTable::captureSerial(pass.lookup(#ItemId)) == WHSRFWhenToCapture::Picking
                        &&  ((inventTable.isItemSerialNumberActivated()
                            && WhsReservationHierarchyInventDimUtil::isSerialBelowLocation(inventTable))
                            || inventTable.isSalesProcessSerialActive()))
                    {
                        pass.insert(#AssignSerial, 1);
                        pass.insert(#SerialCounter, 1);
                        pass.insert(#SerialQty, this.getClusterItemLocationQty(pass.lookup(#ClusterId),
                                                                                pass.lookup(#WMSLocationId),
                                                                                pass.lookup(#ItemId)));

                        ret = conNull();
                        ret = this.buildAssignSerial(ret, strFmt("@WAX3619", pass.lookup(#ClusterPosition)));

                        step = #AssignSerialStep;
                    }
                    else
                    {
                        if (!pass.exists(#AssignSerial) && pass.exists(#SerialCounter)) // assign last serial number in sequence
                        {
                            this.createAssignSerialDimTracking(_buttonClicked);
                        }
                        if (pass.exists(#DimPrompt))
                        {
                            ret = conNull();
                            ret = this.buildBatchPick(ret, pass.lookup(#WMSLocationId), pass.lookup(#ItemId), false);
                            pass.remove(#DimPrompt);
                            break;
                        }

                        transCon = workExecute.executeBatchPick(pass.lookup(#ClusterId),
                                                            pass.lookup(#WMSLocationId),
                                                            pass.lookup(#ItemId),
                                                            pass.lookup(#UserId),
                                                            pass.createInventDimFromPass(),
                                                            pass.exists(#AssignSerial));

                        ret = this.completePickStep(transCon, workExecute);                        

                        this.unblockReplenishmentOverflowWorkWithinCapacity(workLine.WMSLocationId);
                    }
                }
                else
                {
                    if (piecesConfirmed && pass.exists(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed)) 
                    {
                        pass.insert(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed, piecesConfirmed);
                    }
                }

                break;

            // Sort Verification
            case 4:
                if (hasError)
                {
                    con = conDel(con, 3, 1);
                }

                [con, tmpFieldValues] = WHSRFControlData::processData(con, pass);
                fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                pass = this.combineMaps(pass, fieldValues);
                hasError = this.hasError(con);

                if (hasError)
                {
                    ret = con;
                    break;
                }

                [ret, complete] = this.processFieldValues(con, fieldValues);

                if (complete)
                {
                    transCon = WHSWorkClusterTable::find(pass.lookup(#ClusterId)).WorkClusterTransContainer;

                    if (!transCon)
                    {
                        // Look for remaining initial batch picks
                        // If we have full position quantity, we should use the same location/item as the full was for.
                        if (pass.hasValue(WhsWorkExecuteDisplayClusterControls::PositionFullQty)
                            && pass.lookupReal(WhsWorkExecuteDisplayClusterControls::PositionFullQty) != 0)
                        {
                            location = pass.lookup(#WMSLocationId);
                            pickItem = pass.lookup(#ItemId);
                        }
                        else
                        {
                            [location, pickItem] = this.getNextBatchPick(pass.lookup(#ClusterId));
                        }

                        [cycleCountDisplayUpdated, ret] = this.checkCycleCountThresholdAndUpdateDisplay(
                                                                                                    ret,
                                                                                                    _buttonClicked,
                                                                                                    null,
                                                                                                    2,
                                                                                                    location,
                                                                                                    pickItem);

                        if (cycleCountDisplayUpdated)
                        {
                            break;
                        }

                        if (location)
                        {
                            pass.insert(#WMSLocationId, location);
                            pass.insert(#ItemId, pickItem);

                            // Clear passthrough dimension values for new pick
                            this.clearPassBelowLocation(pass.lookup(#ItemId));

                            ret = conNull();
                            ret = this.buildBatchPick(ret, location, pickItem);

                            if (this.allowClusterFullOption(menuItemTable.AllowFullSplit))
                            {
                                ret += [this.buildControl(#RFButton, WhsWorkExecuteDisplayClusterControls::PositionFullButton, "@WAX:PositionFullButton", 1, '', #WHSRFUndefinedDataType, '', 0)];
                            }
                            step = 3;
                        }
                        else
                        {
                            this.executeAdditionalSteps(con);

                            pass.remove(#CheckDigit);
                            pass.remove(#LocVerification);

                            // With initial picks completed, look for Putaways to complete
                            location = this.getNextGroupPutLocation(pass.lookup(#ClusterId));

                            if (location)
                            {
                                pass.insert(#WMSLocationId, location);
                                ret = conNull();
                                ret = this.buildGroupPut(ret, location);
                                step = 5;

                                this.setVariablesForOverrideLoc();
                            }
                            else
                            {
                                // Finally look for any picks off of staging to complete
                                [location, workStop] = this.getNextGroupPickLocation(pass.lookup(#ClusterId));

                                if (location)
                                {
                                    pass.insert(#WMSLocationId, location);
                                    ret = conNull();
                                    ret = this.buildGroupPick(ret, location);
                                    step = 6;
                                }
                                else // Cluster is complete
                                {
                                    // Execute audit template if break event of Completion
                                    if (workAuditTemplateTable.RecId != 0 && workAuditTemplateTable.AuditBreakEvent == WHSAuditBreakEvent::Completion)
                                    {
                                        [auditSeqNum, auditComplete] = WHSWorkAuditTemplateExecute::execute(workAuditTemplateTable.WorkAuditTemplateId,
                                                                                                        WHSWorkAuditTemplateTable::getNextTemplateLine(workAuditTemplateTable.WorkAuditTemplateId).AuditSeqNum,
                                                                                                        null);

                                        if (!auditComplete)
                                        {
                                            pass.insert(#AuditTemplateId, workAuditTemplateTable.WorkAuditTemplateId);
                                            pass.insert(#AuditSeqNum, auditSeqNum);
                                            ret = conNull();
                                            ret = this.buildWorkAuditTemplate(ret);
                                            step = #WorkAuditTemplate;
                                            break;
                                        }
                                    }

                                    ret = this.clusterCompleted(ret, clusterProfile);
                                }
                            }
                        }
                    }
                    else
                    {
                        ret = conNull();
                        ret = this.buildSortVerification(ret, transCon);
                        step = #SortVerification;
                    }

                    if (pass.exists(#LicensePlateId))
                    {
                        pass.remove(#LicensePlateId);
                    }
                }
                break;

            // Summed Putaway (Grouped by location)
            case 5:  
                WHSWorkClusterTable::lockUnlockWorkCluster(pass.lookup(#ClusterId), pass.lookup(#UserId));
                WHSWorkClusterTable::updateClusterStatus(pass.lookup(#ClusterId), WHSWorkClusterStatus::InProcess);

                if (hasError)
                {
                    con = conDel(con, 3, 1);
                }
                
                [con, tmpFieldValues] = WHSRFControlData::processData(con, pass);
                fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                pass = this.combineMaps(pass, fieldValues);
                hasError = this.hasError(con);

                if (hasError)
                {
                    ret = con;
                    break;
                }

                [ret, complete] = this.processFieldValues(con, fieldValues);

                if (complete)
                {
                    using (var activityContext = this.instrumentationLogger().workExecuteClusterPicking().executePut())
                    {
                        workExecute.executeClusterPutConsiderDeferredPut(pass.lookup(#ClusterId), pass.lookup(#WMSLocationId), pass.lookup(#UserId), this.allowUseOfDeferredPut());
                    }

                    location = this.getNextGroupPutLocation(pass.lookup(#ClusterId));

                    if (location)
                    {
                        pass.insert(#WMSLocationId, location);

                        if (pass.exists(#LocVerification)
                            && pass.lookupStr(#LocVerification) != location)
                        {
                            this.clearVerificationFields();
                        }

                        ret = conNull();
                        ret = this.buildGroupPut(ret, location);
                        break;
                    }

                    if (clusterProfile.BreakCluster == WHSBreakCluster::PickPutClose)
                    {
                        // Execute audit template if break event of Completion
                        if (workAuditTemplateTable.RecId != 0 && workAuditTemplateTable.AuditBreakEvent == WHSAuditBreakEvent::Completion)
                        {
                            [auditSeqNum, auditComplete] = WHSWorkAuditTemplateExecute::execute(workAuditTemplateTable.WorkAuditTemplateId,
                                                                                            WHSWorkAuditTemplateTable::getNextTemplateLine(workAuditTemplateTable.WorkAuditTemplateId).AuditSeqNum,
                                                                                            null);

                            if (!auditComplete)
                            {
                                pass.insert(#AuditTemplateId, workAuditTemplateTable.WorkAuditTemplateId);
                                pass.insert(#AuditSeqNum, auditSeqNum);
                                ret = conNull();
                                ret = this.buildWorkAuditTemplate(ret);
                                step = #WorkAuditTemplate;
                                break;
                            }
                        }

                        ret = this.clusterCompleted(ret, clusterProfile);
                        break;
                    }
                     
                    
                    [location, workStop] = this.getNextGroupPickLocation(pass.lookup(#ClusterId));

                    if (location)
                    {
                        // Respect stop flag on staged work units
                        if (workStop)
                        {
                                                           
                            this.blockWorkForWorkLineWithFreezeFlag(nextWorkLine);

                            ret = this.clusterCompleted(ret, clusterProfile, true);
                            break;
                        }
                        else
                        {
                            pass.insert(#WMSLocationId, location);
                            ret = conNull();
                            ret = this.buildGroupPick(ret, location);
                            step = 6;
                        }
                    }
                    else
                    {
                        // Execute audit template if break event of Completion
                        if (workAuditTemplateTable.RecId != 0 && workAuditTemplateTable.AuditBreakEvent == WHSAuditBreakEvent::Completion)
                        {
                            [auditSeqNum, auditComplete] = WHSWorkAuditTemplateExecute::execute(workAuditTemplateTable.WorkAuditTemplateId,
                                                                                            WHSWorkAuditTemplateTable::getNextTemplateLine(workAuditTemplateTable.WorkAuditTemplateId).AuditSeqNum,
                                                                                            null);

                            if (!auditComplete)
                            {
                                pass.insert(#AuditTemplateId, workAuditTemplateTable.WorkAuditTemplateId);
                                pass.insert(#AuditSeqNum, auditSeqNum);
                                ret = conNull();
                                ret = this.buildWorkAuditTemplate(ret);
                                step = #WorkAuditTemplate;
                                break;
                            }
                        }

                        ret = this.clusterCompleted(ret, clusterProfile);
                    }
                }
                break;

            // Summed Picks (Off of Staging, grouped by location)
            case 6:
                WHSWorkClusterTable::lockUnlockWorkCluster(pass.lookup(#ClusterId), pass.lookup(#UserId));
                WHSWorkClusterTable::updateClusterStatus(pass.lookup(#ClusterId), WHSWorkClusterStatus::InProcess);

                if (hasError)
                {
                    con = conDel(con, 3, 1);
                }

                [con, tmpFieldValues] = WHSRFControlData::processData(con, pass);
                fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                pass = this.combineMaps(pass, fieldValues);
                hasError = this.hasError(con);

                if (hasError)
                {
                    ret = con;
                    break;
                }

                [ret, complete] = this.processFieldValues(con, fieldValues);

                if (complete)
                {
                    workExecute.executeClusterPick(pass.lookup(#ClusterId), pass.lookup(#WMSLocationId), pass.lookup(#UserId));

                    [location, workStop] = this.getNextGroupPickLocation(pass.lookup(#ClusterId));

                    if (location)
                    {
                        pass.insert(#WMSLocationId, location);
                        ret = conNull();
                        ret = this.buildGroupPick(ret, location);
                    }
                    else
                    {
                        this.executeAdditionalSteps(con);

                        location = this.getNextGroupPutLocation(pass.lookup(#ClusterId));

                        if (location)
                        {
                            pass.insert(#WMSLocationId, location);
                            ret = conNull();
                            ret = this.buildGroupPut(ret, location);
                            step = 5;

                            this.setVariablesForOverrideLoc();
                        }
                        else
                        {
                            // Execute audit template if break event of Completion
                            if (workAuditTemplateTable.RecId != 0 && workAuditTemplateTable.AuditBreakEvent == WHSAuditBreakEvent::Completion)
                            {
                                [auditSeqNum, auditComplete] = WHSWorkAuditTemplateExecute::execute(workAuditTemplateTable.WorkAuditTemplateId,
                                                                                                WHSWorkAuditTemplateTable::getNextTemplateLine(workAuditTemplateTable.WorkAuditTemplateId).AuditSeqNum,
                                                                                                null);

                                if (!auditComplete)
                                {
                                    pass.insert(#AuditTemplateId, workAuditTemplateTable.WorkAuditTemplateId);
                                    pass.insert(#AuditSeqNum, auditSeqNum);
                                    ret = conNull();
                                    ret = this.buildWorkAuditTemplate(ret);
                                    step = #WorkAuditTemplate;
                                    break;
                                }
                            }

                            ret = this.clusterCompleted(ret, clusterProfile);
                        }
                    }
                }
                break;

            // Skip Initial Batch Pick
            case 7:
                [location, pickItem] = this.skipBatchPick(pass.lookup(#ClusterId),
                                                        pass.lookup(#WMSLocationId),
                                                        pass.lookup(#ItemId),
                                                        pass.createInventDimFromPass());

                pass.insert(#WMSLocationId, location);
                pass.insert(#ItemId, pickItem);                

                ret = conNull();
                ret = this.buildBatchPick(ret, location, pickItem);

                if (this.allowClusterFullOption(menuItemTable.AllowFullSplit))
                {
                    ret += [this.buildControl(#RFButton, WhsWorkExecuteDisplayClusterControls::PositionFullButton, "@WAX:PositionFullButton", 1, '', #WHSRFUndefinedDataType, '', 0)];
                }

                step = 3;
                break;

            // Short Pick Initial Batch Pick
            case #ShortPick:
                if (this.isClusterRelatedToOrderCommittedWork(pass.lookupStr(#ClusterId)))
                {
                    throw error("@WAX:Error_FunctionalityNotSupportedForFlexReservation");
                }

                if (pass.exists(#Initiation))
                {
                    ret = conNull();
                    pass.insert(#SelectedValue, '');
                    pass.insert(#selectedValueUOM, '');
                    ret = this.buildClusterShortPick(ret, pass.lookup(#WMSLocationId), pass.lookup(#ItemId));
                    pass.remove(#Initiation);
                }
                else
                {
                    if (hasError)
                    {
                        con = conDel(con, 3, 1);
                    }

                    [con, tmpFieldValues] = WHSRFControlData::processData(con, pass);
                    fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                    pass = this.combineMaps(pass, fieldValues);
                    hasError = this.hasError(con);

                    if (hasError)
                    {
                        ret = con;
                        break;
                    }

                    [ret, complete] = this.processFieldValues(con, fieldValues);

                    shortPickWorkLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
                    
                    if (complete
                        && _buttonClicked == #RFOK
                        && !pass.exists(#RFShortPick)
                        && WHSRFAutoConfirm::isPieceByPieceConfirmationEnabled(pass.lookup(#MenuItem), shortPickWorkLine.WorkType))
                    {
                        complete = false;
                        
                        if (pass.exists(#ProductConfirmation))
                        {
                            pass.remove(#ProductConfirmation);
                        }

                        ret = this.buildClusterShortPick(conNull(), pass.lookup(#WMSLocationId), pass.lookup(#ItemId));
                        break;
                    }

                    if (complete)
                    {
                        if (!pass.exists(#RFShortPick))
                        {
                            ret = this.completeShortPickStep(con, shortPickWorkLine);
                        }
                        else
                        {
                            boolean mustCaptureAdditionalTrackingDims;
                            [transCon, mustCaptureAdditionalTrackingDims] = this.runExecuteClusterShortPick(shortPickWorkLine, workExecute);
                            
                            /*
                            transCon is empty if we need to capture additional tracking dimensions for the current pick or if we have short picked 0 and
                            there is not any other initial pick line left to process.
                            */
                            if (!transCon)
                            {
                                [location, pickItem] = this.getNextBatchPick(pass.lookup(#ClusterId));

                                if (mustCaptureAdditionalTrackingDims)
                                {
                                    ret = this.updateDisplayToCaptureAdditionalTrackingDims(location, pickItem);
                                }
                            }

                            ret = this.completeShortPickConfirmationStep(transCon);
                        }
                    }
                    else if (WHSWorkExecuteDisplayClusterPickingRebuildShortPickToShowFullReasonListFlight::instance().isEnabled())
                    {
                        ret = this.buildClusterShortPick(conNull(), pass.lookup(#WMSLocationId), pass.lookup(#ItemId));
                    }
                }
                break;

            case #ManualReallocationListShortPickConf:
                shortPickWorkLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
                boolean mustCaptureAdditionalTrackingDims;
                ret = conNull();

                if (WHSWorkExecuteDisplayItemReallocationControls::isItemReallocationControl(_buttonClicked) ||
                    WHSWorkExecuteDisplayItemReallocationControls::isProceedControl(_buttonClicked))
                {
                    WMSLocationId selectedLocationId = WHSWorkExecuteDisplayItemReallocationControls::getLocationIdFromControl(_buttonClicked);
                    boolean isItemReallocationControl = WHSWorkExecuteDisplayItemReallocationControls::isItemReallocationControl(_buttonClicked);
                    workExecute.parmSelectedLocationId(selectedLocationId);
                    workExecute.parmManualReallocationSelected(isItemReallocationControl);
                    
                    [transCon, mustCaptureAdditionalTrackingDims] = this.runExecuteClusterShortPick(shortPickWorkLine, workExecute);

                    WHSWorkLineReallocationParams workLineReallocationParams = WHSWorkLineReallocationParams::newFromPass(pass);
                    WHSWorkLineManualReallocatorBase reallocator = WHSWorkLineManualReallocatorBase::newFromParams(workLineReallocationParams);
                    InventHandlingQty inventQtyToReallocate = workLineReallocationParams.getInventHandlingQtyToReallocate();

                    if (isItemReallocationControl)
                    {
                        InventHandlingQty reallocatedQty = reallocator.reallocateWorkLineHandlingQty(selectedLocationId, inventQtyToReallocate);

                        inventQtyToReallocate -= reallocatedQty;

                        reallocator.runShortPickConfirmationPostUpdatesHandlingQty(inventQtyToReallocate);

                        if (inventQtyToReallocate > 0)
                        {
                            pass.insert(WHSWorkExecuteDisplayItemReallocationControls::TotalReallocatedQty, reallocatedQty);
                            ret = this.buildManualReallocationList(workLineReallocationParams, inventQtyToReallocate, reallocator, true);
                            step = #ManualReallocationList;

                            if (transCon)
                            {
                                str seperator = subStr(guid2Str(newGuid()), 1, 5);

                                pass.insert(WHSWorkExecuteDisplayItemReallocationControls::WorkTransSeperator, seperator);
                                pass.insert(WHSWorkExecuteDisplayItemReallocationControls::WorkTransStr, con2Str(transCon, seperator));
                            }
                        }
                    }
                    else if (WHSWorkExecuteDisplayItemReallocationControls::isProceedControl(_buttonClicked))
                    {
                        reallocator.runShortPickConfirmationPostUpdatesHandlingQty(inventQtyToReallocate);
                    }
                }

                if (ret == conNull())
                {
                    ret = this.completeWorkLinePick(transCon);
                }

                break;

            case #ManualReallocationList:
                WHSWorkLineReallocationParams workLineReallocationParams = WHSWorkLineReallocationParams::newFromPass(pass);
                WHSWorkLineManualReallocatorBase reallocator = WHSWorkLineManualReallocatorBase::newFromParams(workLineReallocationParams);
                InventHandlingQty inventQtyToReallocate = workLineReallocationParams.getInventHandlingQtyToReallocate();
                ret = conNull();

                if (WHSWorkExecuteDisplayItemReallocationControls::isItemReallocationControl(_buttonClicked))
                {
                    WMSLocationId selectedLocationId = WHSWorkExecuteDisplayItemReallocationControls::getLocationIdFromControl(_buttonClicked);

                    InventHandlingQty reallocatedQty = reallocator.reallocateWorkLineHandlingQty(selectedLocationId, workLineReallocationParams.getInventHandlingQtyToReallocate());
                    inventQtyToReallocate -= reallocatedQty;

                    InventHandlingQty totalReallocatedInventQty = workLineReallocationParams.getTotalReallocatedInventHandlingQty() + reallocatedQty;

                    reallocator.runManualWorkLineReallocationPostUpdatesHandlingQty(reallocatedQty);

                    if (inventQtyToReallocate > 0)
                    {
                        pass.insert(WHSWorkExecuteDisplayItemReallocationControls::TotalReallocatedQty, totalReallocatedInventQty);
                        ret = this.buildManualReallocationList(workLineReallocationParams, inventQtyToReallocate);
                        ret = this.addCancelButton(ret);
                    }
                }
                if (ret == conNull())
                {
                    ret = this.cleanupManualReallocationListDisplay();
                }
                break;

            case #WorkAuditTemplate:
                workAuditTemplateLine = WHSWorkAuditTemplateLine::find(workAuditTemplateTable.WorkAuditTemplateId, pass.lookup(#AuditSeqNum));

                pass.insert(#AuditTemplateId, workAuditTemplateTable.WorkAuditTemplateId);

                if (workAuditTemplateLine.AuditBreakFunction == WHSAuditBreakFunction::CaptureData)
                {
                    pass.insert(#CustomData, conPeek(conPeek(con, 4), #data));

                    if (pass.lookup(#CustomData) != '')
                    {
                        // Insert data into our audit custom data table
                        workAuditCaptureData = WHSWorkAuditCaptureData::create('',
                                                                            pass.lookup(#AuditTemplateId),
                                                                            pass.lookup(#AuditSeqNum),
                                                                            pass.lookup(#CustomData));
                    }
                    else
                    {
                        // User did not scan anything
                        ret = _con;
                        break;
                    }
                }

                if (!workAuditTemplateLine.hasCustomMethod())
                {
                    // If not using a custom method on captured data, move on to remaining audit functions
                    workAuditTemplateLine = WHSWorkAuditTemplateTable::getNextTemplateLine(pass.lookup(#AuditTemplateId), pass.lookup(#AuditSeqNum));

                    if (workAuditTemplateLine.RecId != 0)
                    {
                        pass.insert(#AuditSeqNum, workAuditTemplateLine.AuditSeqNum);
                    }
                    else
                    {
                        pass.insert(#AuditSeqNum, str2int(pass.lookup(#AuditSeqNum)) + 1);
                    }
                }

                // Execute Audit Template functions
                [auditSeqNum, auditComplete] = WHSWorkAuditTemplateExecute::execute(pass.lookup(#AuditTemplateId),
                                                                                pass.lookup(#AuditSeqNum),
                                                                                workTable,
                                                                                workAuditCaptureData.RecId);

                // If Capture Data or Display Function, screen must be presented to user
                if (!auditComplete)
                {
                    pass.insert(#AuditSeqNum, auditSeqNum);

                    ret = conNull();
                    ret = this.buildWorkAuditTemplate(ret);
                }
                else
                {
                    pass.remove(#AuditSeqNum);

                    // Look for remaining initial batch picks
                    [location, pickItem] = this.getNextBatchPick(pass.lookup(#ClusterId));

                    if (location)
                    {
                        pass.insert(#WMSLocationId, location);
                        pass.insert(#ItemId, pickItem);

                        ret = conNull();
                        ret = this.buildBatchPick(ret, location, pickItem);

                        step = 3;
                    }
                    else
                    {
                        // With initial picks completed, look for Putaways to complete
                        location = this.getNextGroupPutLocation(pass.lookup(#ClusterId));

                        if (location)
                        {
                            pass.insert(#WMSLocationId, location);
                            ret = conNull();
                            ret = this.buildGroupPut(ret, location);
                            step = 5;

                            this.setVariablesForOverrideLoc();
                        }
                        else
                        {
                            // Finally look for any picks off of staging to complete
                            [location, workStop] = this.getNextGroupPickLocation(pass.lookup(#ClusterId));

                            if (location)
                            {
                                pass.insert(#WMSLocationId, location);
                                ret = conNull();
                                ret = this.buildGroupPick(ret, location);
                                step = 6;
                            }
                            else // Cluster is complete
                            {
                                ret = this.clusterCompleted(ret, clusterProfile);
                            }
                        }
                    }
                }
                break;

            case #AssignSerialStep:
                if (hasError)
                {
                    con = conDel(con, 3, 1);
                }

                [con, tmpFieldValues] = WHSRFControlData::processData(con, pass);
                fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                pass = this.combineMaps(pass, fieldValues);
                [ret, complete] = this.processFieldValues(con, fieldValues);

                if (this.hasError(con))
                {
                    ret = con;
                    break;
                }

                if (complete || _buttonClicked == #RFSerialUnreadable)
                {
                    if (!workLine)
                    {
                        if (pass.exists(#WorkLineRecId))
                        {
                            workline = WHSWorkLine::findByRecId(pass.lookupInt64(#WorkLineRecId));
                        }
                        else
                        {
                            if (pass.exists(#WorkId) && pass.exists(#LineNum))
                            {
                                workLine = WHSWorkLine::find(pass.lookup(#WorkId),pass.parmLineNum());
                            }
                            else
                            {
                                workLine = this.getWorkLinePendingDimTracking(pass.lookup(#ClusterId), pass.lookup(#WMSLocationId), pass.lookup(#ItemId));
                            }
                        }
                    }

                    this.createAssignSerialDimTracking(_buttonClicked);

                    if (pass.lookupNum(#SerialCounter) < pass.lookupNum(#SerialQty))
                    {
                        pass.insert(#SerialCounter, pass.lookupNum(#SerialCounter) + 1);
                        workLine = this.getWorkLinePendingDimTracking(pass.lookup(#ClusterId), pass.lookup(#WMSLocationId), pass.lookup(#ItemId));
                        pass.insert(#WorkLineRecId, workline.RecId);
                        ret = conNull();
                        ret = this.buildAssignSerial(ret, strFmt("@WAX3619", WHSWorkClusterLine::find(pass.lookup(#ClusterId), workLine.workid).ClusterPosition));
                    }
                    else
                    {
                        pass.remove(#SerialCounter);
                        pass.remove(#SerialQty);
                        pass.insert(#SkipSerialValidate, 1);
                        pass.remove(#WorkLineRecId);
                        step = 3;

                        ret = [[mode,step], pass.pack()];
                        ret = this.updateModeStepPass(ret, mode, step, pass);
                        return this.displayForm(ret);
                    }
                }
                break;

            case PositionFullStep:
                if (_buttonClicked == WhsWorkExecuteDisplayClusterControls::PositionFullButton)
                {
                    ret = this.buildFullClusterPosition(conNull());
                    break;
                }

                hasError = this.hasError(_con);
    
                if (hasError)
                {
                    con = conDel(con, 3, 1);
                }

                [con, tmpFieldValues] = WHSRFControlData::processData(con, pass);
                fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                pass = this.combineMaps(pass, fieldValues);

                hasError = this.hasError(con);

                if (hasError)
                {
                    ret = con;
                    break;
                }

                [ret, complete] = this.processFieldValues(con, fieldValues);
    
                if (complete)
                {
                    step = QuantityFullStep;
                    ret = this.buildFullPositionQuantity(conNull());
                }
                else
                {
                    ret = this.addErrorLabel(conNull(), "@WAX:ClusterFullPositionSelectError", WHSRFColorText::Error);
                    ret = this.buildFullClusterPosition(ret);
                }
                
                break;

            case QuantityFullStep:
                hasError = this.hasError(_con);
    
                if (hasError)
                {
                    con = conDel(con, 3, 1);
                }

                [con, tmpFieldValues] = WHSRFControlData::processDataWithCallback(this, con, pass);
                fieldValues = WHSRFPassthrough::create(tmpFieldValues);
                pass = this.combineMaps(pass, fieldValues);

                hasError = this.hasError(con);

                if (hasError)
                {
                    ret = con;
                    break;
                }

                [ret, complete] = this.processFieldValues(con, fieldValues);
                
                if (complete)
                {
                    if (pass.lookup(WhsWorkExecuteDisplayClusterControls::PositionFullQty) != 0)
                    {
                        this.splitWorkOnCluster();
                    }

                    step = 4;
                    ret = this.updateModeStepPass(ret, mode, step, pass);
                    ret = this.displayForm(ret);

                    pass.remove(WhsWorkExecuteDisplayClusterControls::PositionFull);
                    pass.remove(WhsWorkExecuteDisplayClusterControls::PositionFullQty);
                }
                else
                {
                    ret = this.addErrorLabel(conNull(), "@WAX:ClusterFullQuantityError", WHSRFColorText::Error);
                    ret = this.buildFullPositionQuantity(ret);
                }
                
                break;

            // Auto-generate a cluster
            case AutoGenerateClusterStep:
    
                // Look for remaining initial batch picks
                [location, pickItem] = this.getNextBatchPick(pass.lookup(#ClusterId));
    
                if (!location)
                {
                    // With initial picks completed, look for Putaways to complete
                    location = this.getNextGroupPutLocation(pass.lookup(#ClusterId));
    
                    if (location)
                    {
                        this.lockWorkForUser(pass.lookup(#ClusterId), userId);
                        pass.insert(#WMSLocationId, location);
                        ret = conNull();
                        ret = this.buildGroupPut(ret, location);
                        step = 5;

                        this.setVariablesForOverrideLoc();
                        break;
                    }
                    else
                    {
                        // Finally look for any picks off of staging to complete
                        [location, workStop] = this.getNextGroupPickLocation(pass.lookup(#ClusterId));
    
                        this.lockWorkForUser(pass.lookup(#ClusterId), userId);
                        pass.insert(#WMSLocationId, location);
                        ret = conNull();
                        ret = this.buildGroupPick(ret, location);
                        step = 6;
                        break;
                    }
                }
    
                this.lockWorkForUser(pass.lookup(#ClusterId), userId);
                pass.insert(#WMSLocationId, location);
                pass.insert(#ItemId, pickItem);                
    
                ret = conNull();
                ret = this.buildBatchPick(ret, location, pickItem);
    
                step = 3;
                break;
            default:
                if (pass.exists(WHSWorkExecuteDisplayClusterPickingControls::ClusterPickOverridePutLocation))
                {
                    if (pass.exists(#WorkId))
                    {
                        if (pass.exists(#LineNum))
                        {
                            workLine = WHSWorkLine::find(pass.lookup(#WorkId), pass.parmLineNum());
                        }
                        else
                        {
                            workLine = workExecute.getFirstOpenLine(pass.lookup(#WorkId), userId);
                        }
                    }

                    if (workLine && !WHSRFMenuItemLine::validateMenuItemWorkClass(pass.lookupStr(#MenuItem), workLine.WorkClassId))
                    {
                        throw error("@WAX1459");
                    }

                    if (workLine)
                    {
                        if (pass.lookup(#InventLocationId) != workLine.whsWorkTable().InventLocationId)
                        {
                            throw(error("@WAX1207"));
                        }

                        localClusterId = pass.lookup(#ClusterId);
                        con = conpoke(con, 2, pass.pack());
                        workTable = workLine.whsWorkTable();
                        workExecuteMode = this.getWorkExecuteModeFromWorkTransType(workTable.WorkTransType, workTable.TargetLicensePlateId);
                        [ret, step, recall, tmpPass] = this.processWorkLine(workLine, con, workExecuteMode, step, userId, '', _buttonClicked, false);
                        pass = WHSRFPassthrough::create(tmpPass);
                        pass.insert(#ClusterId, localClusterId);
                        
                        addButtons = true;
                        
                        if (step == #StepOne)
                        {
                             //If we just overrode cluster put location. Display new put screen.
                            if (pass.exists(WHSWorkExecuteDisplayClusterPickingControls::ClusterPickOverridePutLocation))
                            {
                                ret = conNull();
                                ret = this.buildGroupPut(ret, pass.lookup(#WMSLocationId));

                                pass.remove(WHSWorkExecuteDisplayClusterPickingControls::ClusterPickOverridePutLocation);
                                pass.remove(#WorkId);
                                pass.remove(#LineNum);
                                step = 5;
                                break;
                            }

                            step = 1;
                            pass.insert(#DetermineStep, 1);
                        }
                        else if (step == #NoLocation)
                        {
                            ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
                            ret += [this.buildControl(#RFButton, #RFPass, "@SYS113811", 1, '', #WHSRFUndefinedDataType, '', 0)];
                            addButtons = false;
                        }
                    }
                    else
                    {
                        throw error("@WAX859");
                    }
                }
                else
                {
                    throw error("@WAX859");
                }
                break;
        }
   
        ret = this.updateModeStepPass(ret, mode, step, pass);

        if (addButtons)
        {
            ret = this.addButtons(ret);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPieceByPieceConfirmationUsed</Name>
				<Source><![CDATA[
    private boolean isPieceByPieceConfirmationUsed(WHSWorkType _workType)
    {
        boolean ret = WHSRFAutoConfirm::isPieceByPieceConfirmationEnabled(pass.lookupStr(#MenuItem), _workType);

        if (ret)
        {
            ret = !InventDimGroupFieldSetup::isAnySerialTrackingActivated(pass.lookup(#ItemId));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeAdditionalSteps</Name>
				<Source><![CDATA[
    private void executeAdditionalSteps(container _con)
    {
        boolean customWorkProcessed = false;
        do 
        {
            this.executeBatchPrintForCluster(pass.lookup(#ClusterId), _con);

            if (WHSClusterProcessingCustomWorkStepFlight::instance().isEnabled())
            {
                customWorkProcessed = this.executeBatchCustomWorkForCluster(pass.lookup(#ClusterId));
            }
        } 
        while (customWorkProcessed);
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeBatchPrintForItem</Name>
				<Source><![CDATA[
    private void executeBatchPrintForItem(
        WHSClusterId                 _clusterId,
        ItemId                       _itemId,
        WHSUserId                    _userId,
        InventDim                    _inventDimCriteria,
        container                    _con)
    {
        WHSWorkClusterLine  workClusterLine;
        WHSWorkLine         printWorkLine;
        InventDim           inventDim;

        WhsWorkProcessWorkLineState state = WhsWorkProcessWorkLineState::construct();
        state.previousForm = _con;

        InventDimParm inventDimParmResHieachy = WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(InventTable::find(_itemId));

        while select WorkId, ClusterId from workClusterLine
                where workClusterLine.ClusterId   == _clusterId
                join printWorkLine
                    where  printWorkLine.WorkId           == workClusterLine.WorkId
                        && printWorkLine.WorkType         == WHSWorkType::Print
                        && printWorkLine.InventQtyRemain  != 0
                        && printWorkLine.ItemId           == _itemId
                          #InventDimExistsJoin(printWorkLine.InventDimId, inventDim, _inventDimCriteria, inventDimParmResHieachy)
        {
            WHSWorkTable workTableLocal = WHSWorkTable::find(printWorkLine.WorkId);
            workLine = printWorkLine;
            WHSWorkExecuteMode workExecuteMode = this.getWorkExecuteModeFromWorkTransType(workTableLocal.WorkTransType, workTableLocal.TargetLicensePlateId);
            state.mode = workExecuteMode;
            this.getStep(state.previousForm, workExecuteMode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canWorkTransTypeAllowSerialAssignment</Name>
				<Source><![CDATA[
    private boolean canWorkTransTypeAllowSerialAssignment(WHSWorkId _workId)
    {
        WHSWorkTransType workTransType = WHSWorkTable::find(_workId).WorkTransType;
        
        return WhsWorkTransactionType::singletonFromTypeOrDefault(workTransType).isSerialNumberAssignmentEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitWorkOnCluster</Name>
				<Source><![CDATA[
    private void splitWorkOnCluster()
    {
        WHSWorkClusterLine  workClusterLine;
        WHSWorkClusterTable workCluster;
        WHSWorkTable        localWorkTable;

        select firstonly forupdate workClusterLine
            where workClusterLine.ClusterId         == pass.lookup(#ClusterId)
            &&    workClusterLine.ClusterPosition   == pass.lookup(WhsWorkExecuteDisplayClusterControls::PositionFull)
            exists join workCluster 
                where workCluster.ClusterId == workClusterLine.ClusterId
                &&    workCluster.WorkClusterStatus != WHSWorkClusterStatus::Closed
                &&    workCluster.LockedUser == pass.lookup(#UserId)
            exists join localWorkTable
                where localWorkTable.WorkId == workClusterLine.WorkId
                &&    localWorkTable.WorkStatus <= WHSWorkStatus::InProcess; // InProcess or Open

        if (workClusterLine)
        {
            WMSLocationId pickLocation;
            ItemId        localItem;

            [pickLocation, localItem] = this.getNextBatchPick(pass.lookup(#ClusterId));

            InventQty runningQty = pass.lookup(WhsWorkExecuteDisplayClusterControls::PositionFullQty);

            WHSWorkId           newWorkId;
            WHSWorkId           origWorkId = workClusterLine.WorkId;
            WHSWorkLine         pickWorkLine;
            InventDim           inventDim;
            InventDimParm       inventDimParm = WhsReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(InventTable::find(localItem));
            WHSRFMenuItemTable  menuItem = WHSRFMenuItemTable::find(pass.lookup(#MenuItem));
            Map                 workLineWithQuantity = new Map(Types::Real, Types::Real);

            while select pickWorkLine
                order by LineNum
                where pickWorkLine.WorkId        == workClusterLine.WorkId
                &&    pickWorkLine.WorkType      == WHSWorkType::Pick
                &&    pickWorkLine.WMSLocationId == pickLocation
                &&    pickWorkLine.ItemId        == localItem
            #InventDimExistsJoin(pickWorkLine.InventDimId, inventDim, pass.createInventDimFromPass(), inventDimParm)
            {
                workLineWithQuantity.insert(pickWorkLine.LineNum, min(runningQty, pickWorkLine.InventQtyRemain));

                runningQty -= pickWorkLine.InventQtyRemain;
                
                if (runningQty <= 0)
                {
                    break;
                }
            }

            MapEnumerator me;

            if (workLineWithQuantity.elements() == 1)
            {
                me = workLineWithQuantity.getEnumerator();
                me.moveNext();

                newWorkId = WHSWorkTable::splitWork(origWorkId, me.currentKey(), me.currentValue(), menuItem.WorkerKeepsOrigWork, pass.lookup(#UserId));
            }
            else if (workLineWithQuantity.elements() > 1)
            {
                WhsSplitWork splitWork = WhsSplitWork::newFromMultipleWorkLines(origWorkId, workLineWithQuantity, menuItem.WorkerKeepsOrigWork, pass.lookup(#UserId));
                newWorkId = splitWork.splitMultipleWorkLines();
            }


            if (newWorkId)
            {
                workClusterLine.WorkId = newWorkId;
                workClusterLine.update();
            }
        }
        else
        {
            throw error("@WAX:FullClusterErrorDuringSplit");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBatchPickInventQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the remaining qty for a batched pick.
    /// </summary>
    /// <param name="_clusterId">
    /// The cluster ID.
    /// </param>
    /// <param name="_locationId">
    /// The warehouse locationID.
    /// </param>
    /// <param name="_itemId">
    /// The item ID.
    /// </param>
    /// <returns>
    /// The remaining qty for a batched pick.
    /// </returns>
    InventQty getBatchPickInventQty(WHSClusterId    _clusterId,
                                    WMSLocationId   _locationId,
                                    ItemId          _itemId)
    {
        WHSWorkClusterLine  workClusterLine;
        WHSWorkLine         pickWorkLine;
        InventDim           inventDim;
        InventDimParm       inventDimParm;

        inventDimParm = WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(InventTable::find(_itemId));

        select sum(InventQtyRemain) from pickWorkLine
            exists join workClusterLine
            where pickWorkLine.WorkId           == workClusterLine.WorkId
            &&    pickWorkLine.WorkType         == WHSWorkType::Pick
            &&    pickWorkLine.wmsLocationId    == _locationId
            &&    pickWorkLine.ItemId           == _itemId
            &&    workClusterLine.ClusterId     == _clusterId
            #InventDimExistsJoin(pickWorkLine.InventDimId, inventDim, pass.createInventDimFromPass(), inventDimParm);

        return pickWorkLine.InventQtyRemain;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBatchPickQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get highest UOM/Qty for an initial batched pick.
    /// </summary>
    /// <param name="_inventQty">
    /// Inventory quantity
    /// </param>
    /// <param name="_itemId">
    /// The Item ID.
    /// </param>
    /// <returns>
    /// Highest UOM/Qty for an initial batched pick.
    /// </returns>
    container getBatchPickQty(InventQty _inventQty,
                              ItemId    _itemId)
    {
        return WHSUOMSeqGroupQtyUnitCalculator::newFromItemQtyAndDimensionForInventHandlingUnit(_itemId, _inventQty, batchPickInventDim.inventDimId)
            .determineHighestUOMWithNoDecimal();

    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextBatchPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the warehouse location ID and item ID for the next batched Pick.
    /// </summary>
    /// <param name="_clusterId">
    /// The cluster ID.
    /// </param>
    /// <returns>
    /// The warehouse location ID and item ID for the next batched Pick.
    /// </returns>
    container getNextBatchPick(WHSClusterId _clusterId)
    {
        Query                   query;
        QueryRun                queryRun;
        QueryBuildDataSource    qbdsPickWorkLine;
        QueryBuildDataSource    qbdsCluster;
        QueryBuildRange         qbrPickWorkStatus;
        QueryBuildRange         qbrPickWorkType;
        QueryBuildRange         qbrCluster;
        QueryBuildRange         qbrPickWorkSkip;
        WHSWorkLine             batchWorkLine;
        WHSWorkLine             putWorkLine;
        WHSClusterSort          clusterSort;
        SortOrder               sortOrder;
        WHSWorkClusterLine      clusterLine;
        boolean                 skipFound;

        query = new Query();

        qbdsCluster         = query.addDataSource(tableNum(WHSWorkClusterLine));
        qbdsPickWorkLine    = qbdsCluster.addDataSource(tableNum(WHSWorkLine));

        qbdsPickWorkLine.relations(true);
        qbdsPickWorkLine.addLink(fieldNum(WHSWorkClusterLine, WorkId), fieldNum(WHSWorkLine, WorkId), qbdsCluster.name());

        qbrCluster = qbdsCluster.addRange(fieldNum(WHSWorkClusterLine, ClusterId));
        qbrCluster.value(_clusterId);

        qbrPickWorkStatus = qbdsPickWorkLine.addRange(fieldNum(WHSWorkLine, WorkStatus));
        qbrPickWorkStatus.value(strFmt("@SYS26868", enum2str(WHSWorkStatus::Open), enum2str(WHSWorkStatus::InProcess)));

        qbrPickWorkType = qbdsPickWorkLine.addRange(fieldNum(WHSWorkLine, WorkType));
        qbrPickWorkType.value(enum2str(WHSWorkType::Pick));

        qbrPickWorkSkip = qbdsPickWorkLine.addRange(fieldNum(WHSWorkLine, Skipped));
        qbrPickWorkSkip.value(enum2str(NoYes::No));

        // Add Order by fields
        while select clusterSort
            order by SeqNum asc
            where clusterSort.ClusterProfileId == pass.lookup(#ClusterProfile)
        {
            if (clusterSort.AscendingDescending == AscendingDescending::Ascending)
            {
                sortOrder = SortOrder::Ascending;
            }
            else
            {
                sortOrder = SortOrder::Descending;
            }

            qbdsPickWorkLine.addOrderByField(fieldName2id(tableNum(WHSWorkLine), clusterSort.FieldName), sortOrder);
        }

        queryRun = new QueryRun(query);

        while (queryRun.next())
        {
            batchWorkLine = queryRun.get(tableNum(WHSWorkLine));

            select firstonly RecId from putWorkLine
                where putWorkLine.WorkId     == batchWorkLine.WorkId
                    && putWorkLine.WorkType   == WHSWorkType::Put
                    && putWorkLine.LineNum    <  batchWorkLine.LineNum
                    && putWorkLine.WorkStatus != WHSWorkStatus::Cancelled;

            if (putWorkLine.RecId == 0)
            {
                break;
            }
            else
            {
                batchWorkLine.clear();
            }
        }

        // If nothing found, check for previously skipped picks
        if (batchWorkLine.RecId == 0)
        {
            while select forupdate batchWorkLine
                join clusterLine
                where batchWorkLine.WorkId   == clusterLine.WorkId    &&
                      batchWorkLine.Skipped  == NoYes::Yes               &&
                      clusterLine.ClusterId  == _clusterId
            {
                // If skipped picks are found, open them back up to be looped through again

                ttsbegin;

                batchWorkLine.Skipped = NoYes::No;
                batchWorkLine.update();

                ttscommit;

                skipFound = true;
            }

            // With skipped work opened up, run query again for initial batched picks
            if (skipFound)
            {
                return this.getNextBatchPick(_clusterId);
            }
        }

        this.updatePassWithWorkLineDimensions(batchWorkLine);

        if (!batchWorkLine
            || batchWorkLine.WorkId != pass.lookupStr(#WorkId)
            || batchWorkLine.LineNum != pass.parmLineNum())
        {
            this.clearVerificationFields();
        }

        pass.insert(#WorkID, batchWorkLine.WorkId);
        pass.parmLineNum(batchWorkLine.LineNum);
        pass.insert(#ClusterPosition, WHSWorkClusterLine::find(_clusterId, batchWorkLine.WorkId).ClusterPosition);
        this.clearPassShortPicking();

        return [batchWorkLine.wmsLocationId, batchWorkLine.ItemId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePassWithWorkLineDimensions</Name>
				<Source><![CDATA[
    private void updatePassWithWorkLineDimensions(WHSWorkLine _batchWorkLine)
    {
        // If Item has dimensions, store off in passthrough
        InventDim inventDim = _batchWorkLine.inventDim();

        this.clearDimensionsForCurrentItemInPass();
        
        this.fillPassFromInventDim(inventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearDimensionsForCurrentItemInPass</Name>
				<Source><![CDATA[
    private void clearDimensionsForCurrentItemInPass()
    {
        if (pass.exists(#ItemId))
        {
            ItemId itemId = pass.lookup(#ItemId);

            if (itemId)
            {
                this.clearPassProductDimensions(itemId);
            }

            if (itemId)
            {
                this.clearPassTrackingDimensionAboveLocation(itemId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkLinePendingDimTracking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a work line associated with a cluster pick position where DimTracking is not complete
    /// </summary>
    /// <param name="clusterId">
    /// The Work Cluster ID
    /// </param>
    /// <param name="locationId">
    /// The Location to which work is associated
    /// </param>
    /// <param name="itemId">
    /// The item for work lines
    /// </param>
    /// <returns>
    /// A workline were DimTracking is not complete
    /// </returns>
    public WHSWorkLine getWorkLinePendingDimTracking(WHSClusterId clusterId, WMSLocationID locationId, ItemId itemId)
    {
        WHSDimTrackingSumQty whsDimTrackingSumQty;
        WHSWorkLine          localWorkLine;
        WHSWorkClusterLine   clusterLine;

        
        select WorkId from clusterline
            where clusterline.ClusterId == clusterId
            join firstOnly localWorkLine
                where   localWorkLine.WorkId        == clusterLine.WorkId
                    &&   localWorkLine.WMSLocationId == locationId
                    &&   localWorkLine.ItemId        == itemId
                        exists join whsDimTrackingSumQty
                        where   whsDimTrackingSumQty.workId  == localWorkLine.WorkId
                            &&   whsDimTrackingSumQty.LineNum == localWorkLine.LineNum
                            &&   whsDimTrackingSumQty.SumOfQty < localWorkLine.InventQtyRemain;

        if (!localWorkLine)
        {
            select WorkId from clusterline 
            where clusterline.ClusterId == clusterId
                join firstOnly localWorkLine
                    where   localWorkLine.WorkId        == clusterLine.WorkId
                        &&   localWorkLine.WMSLocationId == locationId
                        &&   localWorkLine.ItemId        == itemId
                            notExists join whsDimTrackingSumQty
                                where   whsDimTrackingSumQty.WorkId  == localWorkLine.workId
                                    &&   whsDimTrackingSumQty.LineNum == localWorkLine.linenum;
        }


        return localWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipBatchPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Skips current batched pick and returns location/item for next one.
    /// </summary>
    /// <param name="_clusterId">
    /// The cluster ID.
    /// </param>
    /// <param name="_locationId">
    /// The warehouse location ID.
    /// </param>
    /// <param name="_itemId">
    /// The item ID.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The below location dimension criteria for this work execution; optional.
    /// </param>
    /// <returns>
    /// The warehouse location ID and item ID for the next batched Pick.
    /// </returns>
    public container skipBatchPick(WHSClusterId     _clusterId,
                            WMSLocationId    _locationId,
                            ItemId           _itemId,
                            InventDim        _inventDimCriteria = null)
    {
        WHSWorkLine         clusterWorkLine;
        WHSWorkClusterLine  workClusterLine;
        InventDim           inventDim;

        InventDimParm inventDimParm = WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(InventTable::find(_itemId));

        while select WorkId, LineNum from clusterWorkLine
            where clusterWorkLine.wmsLocationId  == _locationId
                && clusterWorkLine.ItemId         == _itemId
                && clusterWorkLine.WorkType       == WHSWorkType::Pick
                && (clusterWorkLine.WorkStatus == WHSWorkStatus::Open
                    || clusterWorkLine.WorkStatus == WHSWorkStatus::InProcess)
            join TableId from workClusterLine
                where workClusterLine.WorkId         == clusterWorkLine.WorkId
                    && workClusterLine.ClusterId      == _clusterId
                    #InventDimExistsJoin(clusterWorkLine.InventDimId, inventDim, _inventDimCriteria, inventDimParm)
        {
            WHSWorkLine::skipWorkLine(clusterWorkLine.WorkId, clusterWorkLine.LineNum);
        }
        return this.getNextBatchPick(_clusterId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCycleCountThresholdAndUpdateDisplay</Name>
				<Source><![CDATA[
    protected container checkCycleCountThresholdAndUpdateDisplay(
                                                            container       _con,
                                                            str             _buttonClicked,
                                                            WHSWorkLine     _workLine,
                                                            int             _prevCountStep = step,
                                                            WMSLocationId   _locationId = '',
                                                            ItemId          _itemId = '')
    {
        boolean cycleCountDisplayUpdated = false;

        var passLocationId = pass.lookup(#WMSLocationId);
        var passItemId = pass.lookup(#ItemId);

        // If done picking location/item combination, evaluate cycle count thresholds if allowed
        if (!WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).DisableCycleCountThreshold &&
                                (_locationId != passLocationId || _itemId != passItemId))
        {
            var cycleCountThresholdId = WHSCycleCountCreateThreshold::processCycleCountThresholdCluster(passItemId,
                                                                                                    pass.lookup(#InventLocationId),
                                                                                                    passLocationId);

            // Check to see if an immediate count needs to be executed
            if (WHSCycleCountThreshold::find(cycleCountThresholdId).ImmediateCycleCount)
            {
                // Find open cycle count work for the location
                var cycleCountWorkId = WHSWorkTable::findCycleCountByLocation(WHSWorkUserSession::find(userId).InventLocationId, passLocationId);

                if (cycleCountWorkId)
                {
                    _con = this.updateDisplayForImmediateCycleCounting(
                                                                cycleCountWorkId,
                                                                _con,
                                                                _prevCountStep,
                                                                _buttonClicked,
                                                                true);
                    cycleCountDisplayUpdated = true;
                }
            }
        }

        return [cycleCountDisplayUpdated, _con];
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeItemReallocationKeysFromPass</Name>
				<Source><![CDATA[
    protected void removeItemReallocationKeysFromPass()
    {
        super();
        pass.remove(WHSWorkExecuteDisplayItemReallocationControls::WorkTransSeperator);
        pass.remove(WHSWorkExecuteDisplayItemReallocationControls::WorkTransStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>completeShortPickConfirmationStep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Completes the short picking confirmation step based on the selected work exception.
    /// </summary>
    /// <param name = "_transCon">Container containing the work invent trans</param>
    /// <param name = "_workExecute">The instance of the <c>WHSWorkExecute</c> class</param>
    /// <returns>Container with a container with the form state after the controls of the next step are added and a boolean
    /// variable indicating if it is necessary to recall or not</returns>
    protected container completeShortPickConfirmationStep(container _transCon, WhsWorkExecute _workExecute = null)
    {
        WHSItemReallocation reallocationProcess = real2int(pass.lookupNum(WHSWorkExecuteDisplayItemReallocationControls::SelectedReallocationProcess));

        if (pass.lookupNum(WHSWorkExecuteDisplayItemReallocationControls::AutoReallocationRequired)
            && (reallocationProcess == WHSItemReallocation::Automatic || reallocationProcess == WHSItemReallocation::AutomaticAndManual))
        {
            WHSWorkLineAutoReallocatorBase  autoReallocator;
            WHSWorkLineReallocationParams   workLineReallocationParams;

            workLineReallocationParams = WHSWorkLineReallocationParams::newFromPass(pass);
            autoReallocator = WHSWorkLineAutoReallocatorBase::newFromParams(workLineReallocationParams);
            autoReallocator.reallocateWorkLineHandlingQty();
        }
        else if (reallocationProcess == WHSItemReallocation::Manual || reallocationProcess == WHSItemReallocation::AutomaticAndManual)
        {
            /*
            The manual reallocation list has separate steps to run the reallocation and the needed updates. If it was not possible
            to display the list at all, we continued in the #ShortPickConf step and need to do the updates now.
            */
            WHSWorkLineReallocationParams   workLineReallocationParams;

            workLineReallocationParams = WHSWorkLineReallocationParams::newFromPass(pass);
            WHSWorkLineManualReallocatorBase reallocator = WHSWorkLineManualReallocatorBase::newFromParams(workLineReallocationParams);
            reallocator.runShortPickConfirmationPostUpdatesHandlingQty(workLineReallocationParams.getInventHandlingQtyToReallocate());
        }

        container ret = this.completeWorkLinePick(_transCon);
        this.removeItemReallocationKeysFromPass();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeManualWorkLineReallocationList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the manual work line reallocation process. If the manual reallocation list is empty proceeds with the next step of the process.
    /// </summary>
    /// <param name = "_reallocationParams">The work line reallocation parameters</param>
    /// <returns>Container with the form state after the controls of the next step are added</returns>
    protected container initializeManualWorkLineReallocationList(WHSWorkLineReallocationParams _reallocationParams)
    {
        container ret = this.buildManualReallocationList(_reallocationParams, _reallocationParams.getInventHandlingQtyToReallocate());

        if (ret == conNull())
        {
            ret = this.buildClusterShortPickConf(conNull(), pass.lookup(#WMSLocationId), pass.lookup(#ItemId));
            pass.insert(#RFShortPick, 1);
        }
        else
        {
            step = #ManualReallocationListShortPickConf;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>completeWorkLinePick</Name>
				<Source><![CDATA[
    private container completeWorkLinePick(container _transCon)
    {
        container ret;

        if (_transCon)
        {
            ret = this.buildSortVerification(conNull(), _transCon);
            step = 4;
        }
        else
        {
            WMSLocationId   locationId;
            ItemId          nextPickItemId;

            [locationId, nextPickItemId] = this.getNextBatchPick(pass.lookup(#ClusterId));

            if (locationId)
            {
                pass.insert(#WMSLocationId, locationId);
                pass.insert(#ItemId, nextPickItemId);

                this.clearPassBelowLocation(pass.lookup(#ItemId));

                ret = this.buildBatchPick(conNull(), locationId, nextPickItemId);

                step = 3;
            }
            else
            {
                ret = this.completeClusterPickingAfterInitialPicksAreCompleted();
            }
        }

        this.removeItemReallocationKeysFromPass();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>completeShortPickStep</Name>
				<Source><![CDATA[
    protected container completeShortPickStep(container _con, WHSWorkLine _workLineToShortPick)
    {
        WHSWorkException    workException = WHSWorkException::find(pass.lookup(#ShortPickReason), WHSExceptionType::ShortPick);
        WHSItemReallocation reallocationProcess = WHSWorkLineReallocatorBase::determineItemReallocation(workException, WHSWorkUser::find(pass.lookupStr(#UserId)), WHSWorkTable::find(_workLineToShortPick.WorkId));

        container                       ret;
        WHSWorkLineReallocationParams   workLineReallocationParams;

        pass.insert(WHSWorkExecuteDisplayItemReallocationControls::AutoReallocationRequired, 0);
        pass.insert(WHSWorkExecuteDisplayItemReallocationControls::SelectedReallocationProcess, reallocationProcess);

        pass.remove(WHSWorkExecuteDisplayPieceByPieceControls::TotalPiecesToConfirm);
        pass.remove(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed);

        switch (reallocationProcess)
        {
            case WHSItemReallocation::None:
                ret = this.buildClusterShortPickConf(conNull(), pass.lookup(#WMSLocationId), pass.lookup(#ItemId));
                pass.insert(#RFShortPick, 1);
                break;
            case WHSItemReallocation::AutomaticAndManual:
                this.initializePassItemReallocationValues(_workLineToShortPick.InventQtyWork, _workLineToShortPick);
                workLineReallocationParams = WHSWorkLineReallocationParams::newFromPass(pass);
                WHSWorkLineAutoReallocatorBase autoReallocator = WHSWorkLineAutoReallocatorBase::newFromParams(workLineReallocationParams);
                InventHandlingQty qtyThatCanBeAutoReallocated = autoReallocator.calculateHandlingQtyThatCanBeAutoReallocated();
                if (qtyThatCanBeAutoReallocated == workLineReallocationParams.getInventHandlingQtyToReallocate())
                {
                    pass.insert(WHSWorkExecuteDisplayItemReallocationControls::AutoReallocationRequired, 1);
                    ret = this.buildClusterShortPickConf(conNull(), pass.lookup(#WMSLocationId), pass.lookup(#ItemId));
                    pass.insert(#RFShortPick, 1);
                }
                else
                {
                    ret = this.initializeManualWorkLineReallocationList(workLineReallocationParams);
                }
                break;
            case WHSItemReallocation::Manual:
                // Reallocate should look at full quantity amount not just for the first work line.
                this.initializePassItemReallocationValues(pass.parmQty(), _workLineToShortPick);
                workLineReallocationParams = WHSWorkLineReallocationParams::newFromPass(pass);
                ret = this.initializeManualWorkLineReallocationList(workLineReallocationParams);
                break;
            case WHSItemReallocation::Automatic:
                this.initializePassItemReallocationValues(_workLineToShortPick.InventQtyWork, _workLineToShortPick);
                pass.insert(WHSWorkExecuteDisplayItemReallocationControls::AutoReallocationRequired, 1);
                ret = this.buildClusterShortPickConf(conNull(), pass.lookup(#WMSLocationId), pass.lookup(#ItemId));
                pass.insert(#RFShortPick, 1);
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePassItemReallocationValues</Name>
				<Source><![CDATA[
    protected void initializePassItemReallocationValues(InventQty _initialWorkLineInventQty, WHSWorkLine _workLineToShortPick)
    {
        super(_initialWorkLineInventQty, _workLineToShortPick);
        EcoResReleasedProductUnitConverter releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();
        InventQty shortPickInventQty = releasedProductUnitConverter.convert(pass.lookupNum(#QtyToPick),
                                                        UnitOfMeasure::unitOfMeasureIdBySymbol(pass.lookup(#SelectedValueUOM)),
                                                        UnitOfMeasure::unitOfMeasureIdBySymbol(InventTableModule::find(_workLineToShortPick.ItemId, ModuleInventPurchSales::Invent).UnitId),
                                                        NoYes::No,
                                                        _workLineToShortPick.ItemId,
                                                        _workLineToShortPick.InventDimId,
                                                        NoYes::No);

        pass.insert(WHSWorkExecuteDisplayItemReallocationControls::InventPickQtyFromInitialLocation, shortPickInventQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>completeClusterPickingAfterInitialPicksAreCompleted</Name>
				<Source><![CDATA[
    private container completeClusterPickingAfterInitialPicksAreCompleted()
    {
        // With initial picks completed, look for Putaways to complete
        WMSLocationId location = this.getNextGroupPutLocation(pass.lookup(#ClusterId));

        container ret;

        if (location)
        {
            pass.insert(#WMSLocationId, location);
            ret = conNull();
            ret = this.buildGroupPut(ret, location);
            step = 5;
        }
        else
        {
            // Finally look for any picks off of staging to complete
            WHSWorkStop workStop;
            [location, workStop] = this.getNextGroupPickLocation(pass.lookup(#ClusterId));

            if (location)
            {
                pass.insert(#WMSLocationId, location);
                ret = conNull();
                ret = this.buildGroupPick(ret, location);
                step = 6;
            }
            else // Cluster is complete
            {
                WHSRFMenuItemTable menuItemTable = WHSRFMenuItemTable::find(pass.lookup(#MenuItem));
                WHSWorkAuditTemplateTable workAuditTemplateTable;
                if (menuItemTable.WorkAuditTemplateId)
                {
                    workAuditTemplateTable = WHSWorkAuditTemplateTable::find(menuItemTable.WorkAuditTemplateId);
                }
                // Execute audit template if break event of Completion
                if (workAuditTemplateTable.RecId != 0 && workAuditTemplateTable.AuditBreakEvent == WHSAuditBreakEvent::Completion)
                {
                    WHSAuditSeqNum auditSeqNum;
                    boolean        auditComplete;
                    [auditSeqNum, auditComplete] = WHSWorkAuditTemplateExecute::execute(workAuditTemplateTable.WorkAuditTemplateId,
                                                                                        WHSWorkAuditTemplateTable::getNextTemplateLine(workAuditTemplateTable.WorkAuditTemplateId).AuditSeqNum,
                                                                                        null);

                    if (!auditComplete)
                    {
                        pass.insert(#AuditTemplateId, workAuditTemplateTable.WorkAuditTemplateId);
                        pass.insert(#AuditSeqNum, auditSeqNum);
                        ret = conNull();
                        ret = this.buildWorkAuditTemplate(ret);
                        step = #WorkAuditTemplate;
                        return ret;
                    }
                }

                ret = this.clusterCompleted(ret, WHSClusterProfile::find(pass.lookup(#ClusterProfile)));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>completePickStep</Name>
				<Source><![CDATA[
    protected container completePickStep(container _transCon, WhsWorkExecute _workExecute)
    {
        container ret;

        if (pass.lookupNum(WHSWorkExecuteDisplayItemReallocationControls::AutoReallocationRequired))
        {
            ret = this.completeShortPickConfirmationStep(_transCon, _workExecute);
        }

        this.clearPassBelowLocation(pass.lookup(#ItemId));
        pass.remove(#AssignSerial);
        pass.remove(WHSWorkExecuteDisplayPieceByPieceControls::PiecesConfirmed);

        if (ret == conNull())
        {
            ret = this.buildSortVerification(conNull(), _transCon);
            step = 4;
            this.removeItemReallocationKeysFromPass();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runExecuteClusterShortPick</Name>
				<Source><![CDATA[
    private container runExecuteClusterShortPick(WHSWorkLine _shortPickWorkLine, WhsWorkExecute _workExecute)
    {
        if (PdsGlobal::pdsIsCWItem(pass.lookupStr(#ItemId)))
        {
            throw error("@WAX:Error_ClusterPickingDoesNotSupportCW");
        }

        boolean mustCaptureMoreDims = this.buildNextDimensionCaptureControl(conNull(), this.createInventDimFromPass(), pass.lookupStr(#ItemId), pass.lookupNum(#QtyToPick)) != conNull();

        WHSLicensePlateId licensePlateId = (WMSLocation::find(pass.lookup(#WMSLocationId), pass.lookup(#InventLocationId)).whsLocationIsLPControlled()) ? pass.lookupStr(#LicensePlateId) : '';
        boolean reallocationTriggered = pass.lookupNum(WHSWorkExecuteDisplayItemReallocationControls::SelectedReallocationProcess) != 0;
        
        WHSItemReallocation reallocationProcess;

        if (pass.exists(WHSWorkExecuteDisplayItemReallocationControls::SelectedReallocationProcess))
        {
            reallocationProcess = real2int(pass.lookupNum(WHSWorkExecuteDisplayItemReallocationControls::SelectedReallocationProcess));
        }

        _workExecute.parmAutoReallocationRequired(pass.lookupNum(WHSWorkExecuteDisplayItemReallocationControls::AutoReallocationRequired));
        _workExecute.parmReallocationProcess(reallocationProcess);

        container   transCon;
        WHSWorkLine newWorkLine;
        InventQty   newInitialInventQty;

        [transCon, newWorkLine, newInitialInventQty] = _workExecute.executeClusterShortPick(pass.lookup(#ClusterId),
																							pass.lookup(#WMSLocationId),
																							pass.lookup(#ItemId),
																							pass.lookupStr(#UserId),
																							pass.lookup(#ShortPickReason),
																							InventTableModule::unitConvert(pass.lookup(#ItemId),
																														   ModuleInventPurchSales::Invent,
																														   pass.lookup(#SelectedValueUOM),
																											  			   pass.lookupNum(#QtyToPick),
                                                                                                                           _shortPickWorkLine.InventDimId),
																							licensePlateId,
																							mustCaptureMoreDims,
																							pass.createInventDimFromPass(),
																							reallocationTriggered);

        Qty initialWorkLineInventQty;

        // Work line could have changed during batch shot pick, need to have correct line in pass.
        if (reallocationTriggered
            && newWorkLine.RecId 
            && newWorkLine.RecId != _shortPickWorkLine.RecId)
        {
            pass.insert(#WorkId, newWorkLine.WorkId);
            pass.parmLineNum(newWorkLine.LineNum);
            initialWorkLineInventQty = newInitialInventQty;

            // Qty to pick should only be the partial pick qty on the current work line
            // the work qty and unit on the new work line was updated during execute short pick
            pass.insert(#QtyToPick, newWorkLine.QtyWork);
            pass.insert(#SelectedValueUOM, newWorkLine.UnitId);
        }
        else
        {
            newWorkLine = _shortPickWorkLine;

            if (reallocationProcess != WHSItemReallocation::None)
            {
                initialWorkLineInventQty = this.initialShortPickConfirmationWorkLineInventQuantity(_shortPickWorkLine, reallocationProcess);
            }
            else
            {
                initialWorkLineInventQty = _shortPickWorkLine.InventQtyRemain;
            }
        }

        pass.remove(#RFShortPick);
        this.initializePassItemReallocationValues(initialWorkLineInventQty, newWorkLine);

        return [transCon, mustCaptureMoreDims];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDisplayToCaptureAdditionalTrackingDims</Name>
				<Source><![CDATA[
    private container updateDisplayToCaptureAdditionalTrackingDims(WMSLocationId _locationId, ItemId _pickItemId)
    {
        pass.insert(#WMSLocationId, _locationId);
        pass.insert(#ItemId, _pickItemId);

        this.clearPassBelowLocation(pass.lookup(#ItemId));

        container ret = this.buildBatchPick(conNull(), _locationId, _pickItemId);

        step = 3;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupManualReallocationListDisplay</Name>
				<Source><![CDATA[
    protected container cleanupManualReallocationListDisplay(container _con = conNull())
    {
        container workTransCon;
        workTransCon = pass.exists(WHSWorkExecuteDisplayItemReallocationControls::WorkTransStr)
                    ? str2con(pass.lookupStr(WHSWorkExecuteDisplayItemReallocationControls::WorkTransStr), (pass.lookupStr(WHSWorkExecuteDisplayItemReallocationControls::WorkTransSeperator)))
                    : workTransCon;

        return this.completeWorkLinePick(workTransCon);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildManualReallocationList</Name>
				<Source><![CDATA[
    protected container buildManualReallocationList(
                            WHSWorkLineReallocationParams   _reallocationParams,
                            InventQty                       _remainingQtyToReallocate,
                            WHSWorkLineManualReallocatorBase _reallocator = null,
                            boolean                          _checkReservedQtyAvailForReallocation = false)
    {
        container ret = super(_reallocationParams, _remainingQtyToReallocate, _reallocator, _checkReservedQtyAvailForReallocation);

        if (ret)
        {
            ret = this.addCancelButton(ret, 1, true);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCleanupWorkCluster</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work cluster must be cleaned.
    /// </summary>
    /// <param name="_pass">
    /// The <c>WHSRFPassthrough</c> instance.
    /// </param>
    /// <returns>
    /// true if the work cluster must be cleaned; otherwise, false.
    /// </returns>
    protected boolean mustCleanupWorkCluster(WHSRFPassthrough _pass)
    {
        return _pass.exists(#ClusterId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildFullClusterPosition</Name>
				<Source><![CDATA[
    private container buildFullClusterPosition(container _con)
    {
        str elements;      
        elements = this.buildSelectablePositionFullElements();      
    
        container ret = _con;
        ret += [this.buildControl(#RFCombobox, WhsWorkExecuteDisplayClusterControls::PositionFull, "@WAX:SelectFullClusterPosition", 1, elements, extendedTypeNum(WHSClusterPositionFull), '', 0, true)];
        
        WHSWorkLine localWorkLine;
        WHSWorkClusterLine workClusterLine;
        WHSWorkClusterTable workCluster;

        while select sum(QtyWork) from localWorkLine
            group by workClusterLine.ClusterPosition asc
            where localWorkLine.WorkStatus    == WHSWorkStatus::Closed
            &&    localWorkLine.WorkType      == WHSWorkType::Pick
                join ClusterPosition from workClusterLine
                    where workClusterLine.WorkId    == localWorkLine.WorkId
                    &&    workClusterLine.ClusterId == pass.lookup(#ClusterId)
                exists join workCluster
                    where workCluster.ClusterId == workClusterLine.ClusterId
                    &&    workCluster.WorkClusterStatus != WHSWorkClusterStatus::Closed
        {
            ret += [this.buildControl(#RFLabel, #PositionName, strFmt("@WAX:QuantityOnClusterPosition", workClusterLine.ClusterPosition, localWorkLine.QtyWork), 1, '', #WHSRFUndefinedDataType, '', 0)];
        }
    
        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        ret += [this.buildControl(#RFButton, #RFBack, "@SYS56453", 1, '', #WHSRFUndefinedDataType, '', 0)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSelectablePositionFullElements</Name>
				<Source><![CDATA[
    private str buildSelectablePositionFullElements()
    {
        str elements = '';

        WHSClusterProfile clusterProfile = WHSClusterProfile::find(pass.lookup(#ClusterProfile));
        
        WMSLocationId pickLocation;
        ItemId localItem;

        [pickLocation, localItem] = this.getNextBatchPick(pass.lookup(#ClusterId));

        WHSWorkClusterLine workClusterLine;
        WHSWorkLine localWorkLine;
        WHSWorkClusterTable workCluster;
        WHSClusterNumPositions currentClusterNumPosition;

        while select ClusterPosition from workClusterLine
            order by workClusterLine.ClusterPosition asc
            where workClusterLine.ClusterId == pass.lookup(#ClusterId)
            exists join localWorkLine
                where localWorkLine.WMSLocationId == pickLocation
                    && localWorkLine.ItemId == localItem
                    && localWorkLine.WorkType == WHSWorkType::Pick
                    && localWorkLine.WorkStatus <= WHSWorkStatus::InProcess // InProcess or Open.
                    && localWorkLine.WorkId == workClusterLine.WorkId
            exists join workCluster
                where workCluster.ClusterId == workClusterLine.ClusterId
                    &&  workCluster.WorkClusterStatus != WHSWorkClusterStatus::Closed
        {
            elements += '||' + workClusterLine.ClusterPosition;
            currentClusterNumPosition++;

            // This needs to be >= in order to support cluster profile with 0 positions, which is allowed and it behaves as if it has 1 position.
            if (currentClusterNumPosition >= clusterProfile.ClusterNumPositions)
            {
                break;
            }
        }

        return elements;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildFullPositionQuantity</Name>
				<Source><![CDATA[
    private container buildFullPositionQuantity(container _con)
    {
        WMSLocationId   pickLocation;
        ItemId          localItem;
        container       ret = _con;

        [pickLocation, localItem] = this.getNextBatchPick(pass.lookup(#ClusterId));
        InventHandlingUnitId inventHandlingUnit = WHSCatchWeightHelper::inventHandlingUnitId(localItem);
        
        ret += [this.buildControl(#RFLabel, #Enter, "@WAX727", 1, '', #WHSRFUndefinedDataType, '', 0)];
        ret += [this.buildControl(#RFText, WhsWorkExecuteDisplayClusterControls::PositionFullQty, strFmt("@WAX:ClusterFullQuanityWithUnit", inventHandlingUnit), 1, pass.lookupStr(WhsWorkExecuteDisplayClusterControls::PositionFullQty), extendedTypeNum(Qty), '', 0)];
        
        InventQty inventQty = this.getBatchPickWorkQuantityWithPosition(pass.lookup(#ClusterId), pass.lookup(WhsWorkExecuteDisplayClusterControls::PositionFull), pickLocation, localItem);

        ret += [this.buildControl(#RFLabel,
                                  #RFQtyLabel,
                                  strFmt("@WAX2611", inventQty, inventHandlingUnit),
                                  1, 
                                  '', 
                                  #WHSRFUndefinedDataType, 
                                  '', 
                                  0, 
                                  false)];
        
        ret += [this.buildControl(#RFButton, #RFOK, "@SYS5473", 1, '', #WHSRFUndefinedDataType, '', 1)];
        ret += [this.buildControl(#RFButton, #RFBack, "@SYS56453", 1, '', #WHSRFUndefinedDataType, '', 0)];

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBatchPickWorkQuantityWithPosition</Name>
				<Source><![CDATA[
    private InventQty getBatchPickWorkQuantityWithPosition(
        WHSClusterId        _clusterId,
        WHSClusterPosition  _clusterPosition,
        WMSLocationId       _locationId,
        ItemId              _itemId)
    {
        WHSWorkClusterTable workCluster;
        WHSWorkClusterLine  workClusterLine;
        WHSWorkLine         pickWorkLine;
        InventDim           inventDim;

        InventDimParm inventDimParm = WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(InventTable::find(_itemId));

        select sum(InventQtyRemain) from pickWorkLine
            where pickWorkLine.WorkType      == WHSWorkType::Pick
            &&    pickWorkLine.wmsLocationId == _locationId
            &&    pickWorkLine.ItemId        == _itemId
            exists join workClusterLine
                where workClusterLine.WorkId            == pickWorkLine.WorkId
                &&    workClusterLine.ClusterId         == _clusterId
                &&    workClusterLine.ClusterPosition   == _clusterPosition
            exists join workCluster
                where workCluster.ClusterId == workClusterLine.ClusterId
                &&    workCluster.WorkClusterStatus != WHSWorkClusterStatus::Closed
            #InventDimExistsJoin(pickWorkLine.InventDimId, inventDim, pass.createInventDimFromPass(), inventDimParm);

        return pickWorkLine.InventQtyRemain;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOpenOrInProcessCluster</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an open or in process cluster Id locked by the current RF user.
    /// </summary>
    /// <returns>
    /// True if cluster Id found; otherwise false.
    /// </returns>
    private  boolean getOpenOrInProcessCluster()
    {
        WHSWorkClusterTable workClusterTable;
    
        select firstOnly ClusterId from workClusterTable
            where workClusterTable.LockedUser           == userId
            &&    (workClusterTable.WorkClusterStatus   == WHSWorkClusterStatus::Open
            ||    workClusterTable.WorkClusterStatus    == WHSWorkClusterStatus::InProcess);
    
        if (workClusterTable.ClusterId)
        {
            pass.insert(#ClusterId, workClusterTable.ClusterId);
        }
    
        return workClusterTable.ClusterId != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAnyClusterPositionMissingTargetLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if any positions within a cluster need to have a LP specified.
    /// </summary>
    /// <returns>
    /// true if an LP needs to be specified for a cluster position; otherwise false.
    /// </returns>
    private boolean checkAnyClusterPositionMissingTargetLP()
    {
        WHSWorkClusterLine  clusterLine = this.getNextClusterLineMissingTargetLP();
            
        return clusterLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextClusterLineMissingTargetLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the next cluster line that an LP needs to be specified for.
    /// </summary>
    /// <returns>
    /// The next cluster line in the current cluster that needs a target LP assigned.
    /// </returns>
    private WHSWorkClusterLine getNextClusterLineMissingTargetLP()
    {        
        WHSWorkClusterLine  clusterLine;
        WHSWorkTable        workTableNoLP;
    
        select firstOnly clusterLine
            order by ClusterPosition
            where clusterLine.ClusterId == pass.lookup(#ClusterId)
            exists join workTableNoLP
                where workTableNoLP.WorkId               == clusterLine.WorkId
                &&    workTableNoLP.TargetLicensePlateId == '';
    
        return clusterLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lockWorkForUser</Name>
				<Source><![CDATA[
    private void lockWorkForUser(WHSClusterId _clusterId, UserId _userId)
    {
        WHSWorkClusterLine      workClusterLine;
    
        while select WorkId from workClusterLine
            order by workClusterLine.ClusterId desc
                where workClusterLine.ClusterId == _clusterId
        {
            if (!pass.exists(#WorkId))
            {
                pass.insert(#WorkId, workClusterLine.WorkId);
            }
    
            if (!WHSWorkTable::find(workClusterLine.WorkId).LockedUser)
            {
                WHSWorkTable::lockUnlockWork(workClusterLine.WorkId, _userId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePassForCreatingSystemDirectedCluster</Name>
				<Source><![CDATA[
    protected void initializePassForCreatingSystemDirectedCluster(WHSClusterProfile _clusterProfile)
    {
        if (this.useClusterPositions(_clusterProfile))
        {
            pass.insert(#ClusterPosition, this.clusterPosition(_clusterProfile, 0));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>useClusterPositions</Name>
				<Source><![CDATA[
    private boolean useClusterPositions(WHSClusterProfile _clusterProfile)
    {
        if (_clusterProfile.ClusterPositionsActive)
        {
            return true;
        }
        
        return _clusterProfile.ClusterType == WHSClusterType::Picking;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSystemDirectedCluster</Name>
				<Source><![CDATA[
    /// <summary>
    /// Automatically create cluster based on system directed query.
    /// </summary>
    /// <returns>true if a cluster is created; otherwise, false.</returns>
    protected boolean createSystemDirectedCluster()
    {
        boolean ret = false;
        
        ttsbegin;
    
        WHSClusterProfile clusterProfile = WHSClusterProfile::find(pass.lookup(#ClusterProfile));

        boolean useClusterPositions = this.useClusterPositions(clusterProfile);

        this.initializePassForCreatingSystemDirectedCluster(clusterProfile);

        if (clusterProfile.ClusterNumPositions > 0)
        {
            WHSSystemDirectedWorkLineDetailsRetriever systemDirectedWorkLineDetailsRetriever = WHSSystemDirectedClusterPickingWorkLineDetailsRetriever::construct();
            systemDirectedWorkLineDetailsRetriever.parmRequestedWorkHeaders(clusterProfile.ClusterNumPositions);
            systemDirectedWorkLineDetailsRetriever.parmMenuItemName(pass.lookup(#MenuItem));
            systemDirectedWorkLineDetailsRetriever.parmInventSiteId(pass.lookup(#InventSiteId));
            systemDirectedWorkLineDetailsRetriever.parmInventLocationId(pass.lookup(#InventLocationId));
            systemDirectedWorkLineDetailsRetriever.parmUserId(userId);
            systemDirectedWorkLineDetailsRetriever.parmSkipWorkId(conNull());
            systemDirectedWorkLineDetailsRetriever.parmSequenceNumber(0);

            List systemDirectedWorkLineDetails = systemDirectedWorkLineDetailsRetriever.retrieveSystemDirectedWorkLineDetails();

            if (systemDirectedWorkLineDetails.empty())
            {
                pass.remove(#WorkId);
            }
            else
            {
                boolean clusterLocked = false;
                int workNum;

                ListEnumerator workLineDetailsEnumerator = systemDirectedWorkLineDetails.getEnumerator();

                while (workLineDetailsEnumerator.moveNext())
                {
                    WHSSystemDirectedWorkLineDetails workLineDetails = workLineDetailsEnumerator.current();
                    WHSWorkLine tmpNewWorkLine = workLineDetails.WorkLine;

                    // If no workLine was returned from getFirstOpenLineSystemDirected then we should exit this loop.
                    if (tmpNewWorkLine.RecId == 0)
                    {
                        pass.remove(#WorkId);
                        break;
                    }

                    if (WHSWorkTable::hasOrderCommittedReservations(tmpNewWorkLine.WorkId))

                    {
                        continue;
                    }
    
                    if (!clusterLocked)
                    {
                        if (!WHSWorkClusterTable::exist(pass.lookup(#ClusterId)))
                        {
                            WHSWorkClusterTable::createWorkClusterTable(pass.lookup(#ClusterId), pass.lookup(#ClusterProfile));
                        }
                        WHSWorkClusterTable::lockUnlockWorkCluster(pass.lookup(#ClusterId), pass.lookup(#UserId));
                        clusterLocked = true;
                    }
            
                    WHSWorkTable::lockUnlockWork(tmpNewWorkLine.WorkId, '');

                    pass.insert(#WorkId, tmpNewWorkLine.WorkId);
                    ++workNum;
    
                    ret = true;
    
                    if (!WHSWorkTable::find(tmpNewWorkLine.WorkId).TargetLicensePlateId
                    && WHSRFMenuItemTable::find(pass.lookup(#MenuItem)).GenerateLP)
                    {
                        WHSWorkTable::addTargetLicensePlate(tmpNewWorkLine.WorkId, WHSLicensePlate::generateLicensePlateIdNoItem());
                    }
    
                    if (useClusterPositions)
                        {
                            WHSClusterPosition clusterPositionUsingLP = WHSWorkTable::find(tmpNewWorkLine.WorkId).TargetLicensePlateId;
                            if (clusterProfile.ClusterPositionsActive || !clusterPositionUsingLP)
                            {
                                WHSWorkClusterLine::createWorkClusterLine(pass.lookup(#ClusterId), tmpNewWorkLine.WorkId, pass.lookup(#ClusterPosition));
                                pass.insert(#ClusterPosition, this.clusterPosition(clusterProfile, workNum));
                            }
                            else
                            {
                                WHSWorkClusterLine::createWorkClusterLine(pass.lookup(#ClusterId), tmpNewWorkLine.WorkId, clusterPositionUsingLP);
                        }
                    }
                    else
                    {
                        WHSWorkClusterLine::createWorkClusterLine(pass.lookup(#ClusterId), tmpNewWorkLine.WorkId, WHSWorkTable::find(tmpNewWorkLine.WorkId).TargetLicensePlateId);
                    }
                }
            }
        }

        ttscommit;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isClusterRelatedToOrderCommittedWork</Name>
				<Source><![CDATA[
    private boolean isClusterRelatedToOrderCommittedWork(str _clusterId)
    {
        WHSWorkClusterLine workClusterLine;
        WHSWorkLine workLineInCluster;

        select firstOnly RecId from workClusterLine
            where workClusterLine.ClusterId == _clusterId
            exists join workLineInCluster
                where  workLineInCluster.WorkId == workClusterLine.WorkId
                    && workLineInCluster.OrderCommittedInventDimId != '';

        return workClusterLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addOverrideButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds Override button to the form state.
    /// </summary>
    /// <param name="_con">
    /// Container containing the state of the form before button is added.
    /// </param>
    /// <param name="_newLine">
    /// 1 if the button is placed in a new line in the form, 0 otherwise.
    /// </param>
    /// <returns>
    /// Container containing the state of the form after button is added.
    /// </returns>
    container addOverrideButton(
            container _con,
            int       _newLine = 1)
    {
        container retCon = _con;
        if (putReadyForOverrideLoc)
        {
            if (this.hasOverrideBtnAccess(WHSWorkType::Put))
            {
                retCon += [this.buildControl(#RFButton, #RFOverride, "@WAX:OverrideLoc", _newLine, '', #WHSRFUndefinedDataType, '', 0)];
            }
        }
        else
        {
            retCon = super(_con, _newLine);
        }
        return retCon;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>