<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ResRollUpWriter</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Roll-up table writer which <c>ResRollUp</c> table is used as availability view resources chart item data cache table.
/// There are three different <c>ResRollUpCoverage</c> enum coverage level:
///
/// Availability - Used by company resource and named resource.
///                It shows the resource with the sum of all engagement locked capacity.
/// Assignement  - Used by planned resource and named resource.
///                For planned resource, it shows the assigned capacity for this particular engagement.
///                For named reosurce, it shows the sum of all engagment locked capaicty minus
///                this engagment capaicty plus this engagement assignment capacity.
/// Activity     - Used by planned resource and named resource.
///                It shows the resource with this paritcular engagement locked capacity.
///
/// ActivityResourceId format - In <c>ResRollup</c>, it is being referred to as CollectionKey field.
///                             This is used in <c>ResRollUp</c> table as the resource unique identifier.
///                             The format is always ActivityRecId-ResourceRecId-ActivityResourceRecId.
///                             For company resource, it will be like 0-ResourceRecId-0.
///                             For planned resource, it will be like ActivityRecId-0-ActivityResourceRecId.
///                             For named resource, it will be like ActivityRecId-ResourceRecId-ActivityResourceRecId.
///
/// Note:
/// Locked capaciity means the higher reserved capacity by compare booked capacity and assignment capacity
/// ActivityRecId is the <c>smmActivities</c> table rec Id.
/// ResourceRecId is the <c>ResResourceIdentifier</c> table rec Id.
/// ActivityResourceRecId is the <c>PSAProjSchedRole</c>
/// </summary>
public class ResRollupWriter
{
    #TimeConstants
    #OCCRetryCount
    private List rollUpResourcesList;
    private Set calendarSet;
    private boolean enableHourScheduling;
    const real reservationStatusToleranceInHours = 0.09;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getCompanyResources</Name>
				<Source><![CDATA[
    private void getCompanyResources(utcdatetime _rangeStartDateTime, utcdatetime _rangeEndDateTime)
    {
        // add this company resource to availability coverage level list
        ResCompanyResourceSchedulableView companyResourceView;
        while select Resource, SourceLegalEntity, EffectiveDate, ExpirationDate, Calendar from companyResourceView
        group by companyResourceView.Resource, companyResourceView.SourceLegalEntity,
            companyResourceView.EffectiveDate, companyResourceView.ExpirationDate,
            companyResourceView.Calendar
            where companyResourceView.EffectiveDate <= _rangeEndDateTime
                && companyResourceView.ExpirationDate >= _rangeStartDateTime
        {
            rollUpResourcesList.addEnd(this.setCompanyRollUpResource(companyResourceView, _rangeStartDateTime, _rangeEndDateTime));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSpecificCompanyResource</Name>
				<Source><![CDATA[
    private void getSpecificCompanyResource(DataAreaId _company, utcdatetime _rangeStartDateTime, 
        utcdatetime _rangeEndDateTime, ResourceRecId _resource)
    {
        // Add this company resource to availability coverage level list.
        // This is a while loop for the cases of the specified resource which has multiple effective dates period.
        ResCompanyResourceSchedulableView companyResourceView;
        while select Resource, SourceLegalEntity, EffectiveDate, ExpirationDate, Calendar from companyResourceView
        group by companyResourceView.Resource, companyResourceView.SourceLegalEntity,
            companyResourceView.EffectiveDate, companyResourceView.ExpirationDate,
            companyResourceView.Calendar
            where companyResourceView.Resource == _resource
                && companyResourceView.RecipientCompany == _company
        {
            rollUpResourcesList.addEnd(this.setCompanyRollUpResource(companyResourceView, _rangeStartDateTime, _rangeEndDateTime));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCompanyRollUpResource</Name>
				<Source><![CDATA[
    private ResRollupResource setCompanyRollUpResource(ResCompanyResourceSchedulableView _companyResourceView,
        utcdatetime _rangeStartDateTime, utcdatetime _rangeEndDateTime)
    {
        ResRollupResource rollUpResource = ResRollupResource::construct();
        rollUpResource.parmActivity(0);
        rollUpResource.parmResource(_companyResourceView.Resource);
        rollUpResource.parmActivityResource(0);
        rollUpResource.parmCalendar(_companyResourceView.Calendar);
        rollUpResource.parmStart(_rangeStartDateTime);
        rollUpResource.parmEnd(_rangeEndDateTime);
        rollUpResource.parmEffectiveDateTime(_companyResourceView.EffectiveDate);
        rollUpResource.parmExpirationDateTime(_companyResourceView.ExpirationDate);
        if (_rangeStartDateTime <= _companyResourceView.EffectiveDate || _rangeEndDateTime >= _companyResourceView.ExpirationDate)
        {
            rollUpResource.parmInculsiveEffectiveDateRange(false);
        }
        else
        {
            rollUpResource.parmInculsiveEffectiveDateRange(true);
        }

        rollUpResource.parmCoverage(ResRollupCoverage::Availability);

        if (_companyResourceView.Calendar)
        {
            calendarSet.add(_companyResourceView.Calendar);
        }

        return rollUpResource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBaseCalendar</Name>
				<Source><![CDATA[
    private CalendarRecId getBaseCalendar(CalendarRecId _calendar)
    {
        CalendarRecId baseCalendar;

        WorkCalendarTable calendarTable = WorkCalendarTable::findByRecId(_calendar);

        if (calendarTable.RecId && calendarTable.BasicCalendarId)
        {
            WorkCalendarTable baseCalendarTable;

            select firstonly crosscompany RecId from baseCalendarTable
                where baseCalendarTable.CalendarId == calendarTable.BasicCalendarId
                    && baseCalendarTable.DataAreaId == calendarTable.DataAreaId;

            baseCalendar = baseCalendarTable.RecId;
        }

        return baseCalendar;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateRollupCalendarRecordsRequiresUpdate</Name>
				<Source><![CDATA[
    private boolean validateRollupCalendarRecordsRequiresUpdate(CalendarRecId _calendar,
        utcdatetime _startDateTime, utcdatetime _endDateTime)
    {
        WorkCalendarDateLine    calendarDateLine;
        WorkCalendarTable       calendarTable;
        
        CalendarRecId baseCalendar = this.getBaseCalendar(_calendar);

        CalendarRecId calendar = baseCalendar ? baseCalendar : _calendar;

        date requestedStartDate = DateTimeUtil::date(_startDateTime);
        date requestedEndDate = DateTimeUtil::date(_endDateTime);

        date actualStartDate = requestedStartDate;
        date actualEndDate = requestedEndDate;

        // ResCalendarCapacity date records can only be as small as what has been defined in WorkCalendarDateLine.
        select crosscompany minof(TransDate) from calendarDateLine
            exists join calendarTable
                where calendarTable.CalendarId == calendarDateLine.CalendarId
                    &&  calendarTable.DataAreaId == calendarDateLine.DataAreaId
                    &&  calendarTable.RecId == calendar;

        // Verify if calendar has been setup.
        if (calendarDateLine.TransDate == dateNull())
        {
            calendarTable = WorkCalendarTable::findByRecId(calendar);
            error (strFmt("@Res:CalendarDatesIsMissing",
                calendarTable.CalendarId,
                strUpr(calendarTable.DataAreaId)));
            return false;
        }

        // Update start date time to begin in 0 second of the day to make the expected records is correct.
        utcdatetime startDateTime;
        if (calendarDateLine.TransDate > requestedEndDate)
        {
            calendarTable = WorkCalendarTable::findByRecId(calendar);
            error (strFmt("@Res:EarliestCalendarDateIsTooLarge",
                calendarTable.CalendarId,
                strUpr(calendarTable.DataAreaId),
                date2StrUsr(calendarDateLine.TransDate, DateFlags::FormatAll),
                date2StrUsr(requestedEndDate, DateFlags::FormatAll)));
            return false;
        }
        else if (calendarDateLine.TransDate > actualStartDate)
        {
            startDateTime = DateTimeUtil::newDateTime(calendarDateLine.TransDate, 0);
            actualStartDate = DateTimeUtil::date(startDateTime);
        }
        else
        {
            startDateTime = DateTimeUtil::newDateTime(actualStartDate, 0);
        }

        // ResCalendarCapacity date records can only be as large as what has been defined in WorkCalendarDateLine.
        select crosscompany maxof(TransDate) from calendarDateLine
            exists join calendarTable
                where calendarTable.CalendarId == calendarDateLine.CalendarId
                    &&  calendarTable.DataAreaId == calendarDateLine.DataAreaId
                    &&  calendarTable.RecId == calendar;

        // Update end date time to end in the last second of the day to make the expected records is correct.
        
        utcdatetime endDateTime;
        if (calendarDateLine.TransDate < requestedStartDate)
        {
            calendarTable = WorkCalendarTable::findByRecId(calendar);
            error (strFmt("@Res:LatestCalendarDateIsTooSmall",
                calendarTable.CalendarId,
                strUpr(calendarTable.DataAreaId),
                date2StrUsr(calendarDateLine.TransDate, DateFlags::FormatAll),
                date2StrUsr(requestedStartDate, DateFlags::FormatAll)));
            return false;
        }
        else if (calendarDateLine.TransDate < actualEndDate)
        {
            endDateTime = DateTimeUtil::newDateTime(calendarDateLine.TransDate, #LastSecondOfTheDay);
            actualEndDate = DateTimeUtil::date(endDateTime);
        }
        else
        {
            endDateTime = DateTimeUtil::newDateTime(actualEndDate, #LastSecondOfTheDay);
        }

        int expectedHourCount = (actualEndDate - actualStartDate + 1) * #hoursPerDay;

        ResCalendarCapacity calendarCapacity;

        select count(RecId) from calendarCapacity
            where calendarCapacity.Calendar == _calendar &&
                calendarCapacity.Hour >= startDateTime &&
                calendarCapacity.Hour <= endDateTime;

        if (calendarCapacity.RecId != expectedHourCount)
        {
            this.updateCalendarCapacity(_calendar, actualStartDate, actualEndDate);
        }

        ResRollupCalendarShared rollUpCalendarTable;

        select count(RecId) from rollUpCalendarTable
            where rollUpCalendarTable.Calendar == _calendar &&
                rollUpCalendarTable.Timescale == AVTimeframeType::Hour &&
                rollUpCalendarTable.Timeframe >= startDateTime &&
                rollUpCalendarTable.Timeframe <= endDateTime;

        return (rollUpCalendarTable.RecId == expectedHourCount) ? false : true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCalendarCapacity</Name>
				<Source><![CDATA[
    private void updateCalendarCapacity(CalendarRecId _calendar, date _startDate, date _endDate)
    {
        WorkCalendarTable   calendarTable;

        select firstonly crosscompany CalendarId, DataAreaId from calendarTable
                where calendarTable.RecId == _calendar;

        changecompany(calendarTable.DataAreaId)
        {
            // if ResCalendarCapacity table doesn't have the dates, then add the dates to this table
            ResCalendarCapacitySynchronizationTask calendarCapacitySynchronization;
            calendarCapacitySynchronization = ResCalendarCapacitySynchronizationTask::construct();
            calendarCapacitySynchronization.parmCalendarId(calendarTable.CalendarId);
            calendarCapacitySynchronization.parmCalendarDataAreaId(calendarTable.DataAreaId);
            calendarCapacitySynchronization.parmFromDate(_startDate - 1);
            calendarCapacitySynchronization.parmToDate(_endDate + 1);
            calendarCapacitySynchronization.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityResources</Name>
				<Source><![CDATA[
    private void getActivityResources(utcdatetime _rangeStartDateTime, utcdatetime _rangeEndDateTime)
    {
        date rangeStartDate = DateTimeUtil::date(_rangeStartDateTime);
        date rangeEndDate = DateTimeUtil::date(_rangeEndDateTime);

        // add engagement team members to all coverage level list
        ResActivityResourceView resActivityResourceView;
        ResourceLegalEntityView resourceLegalEntityView;

        DataAreaId currentCompany = curExt();

        while select Activity, Resource, ActivityResource,
            Calendar, EngagementStartDate, EngagementEndDate from resActivityResourceView
            where !(resActivityResourceView.EngagementStartDate > rangeEndDate)
                && !(resActivityResourceView.EngagementEndDate < rangeStartDate)
            outer join ValidFrom, ValidTo from resourceLegalEntityView
                where resourceLegalEntityView.Resource == resActivityResourceView.Resource
        {
            boolean     inclusiveEffectiveDateRange = true;
            utcdatetime startDateTime = dateTimeUtil::newDateTime(resActivityResourceView.EngagementStartDate, 0);
            utcdatetime endDateTime = datetimeUtil::newDateTime(resActivityResourceView.EngagementEndDate, #LastSecondOfTheDay);
            utcdatetime effectiveDateTime = utcDateTimeNull();
            utcdatetime expirationDateTime = utcDateTimeNull();

            // For staffed resource which resource effective date is smaller than requested range date, set dateRangeNotMathes to true.
            if (resActivityResourceView.Resource != 0 && resourceLegalEntityView)
            {
                effectiveDateTime = resourceLegalEntityView.ValidFrom;
                expirationDateTime = resourceLegalEntityView.ValidTo;

                if (_rangeStartDateTime <= effectiveDateTime || _rangeEndDateTime >= expirationDateTime)
                {
                    inclusiveEffectiveDateRange = false;
                }
            }

            rollUpResourcesList.addEnd(this.setActivityRollUpResource(resActivityResourceView.Resource,
                resActivityResourceView.Calendar, resActivityResourceView.Activity,
                resActivityResourceView.ActivityResource, startDateTime, endDateTime, ResRollupCoverage::Activity,
                inclusiveEffectiveDateRange, effectiveDateTime, expirationDateTime));
            rollUpResourcesList.addEnd(this.setActivityRollUpResource(resActivityResourceView.Resource,
                resActivityResourceView.Calendar, resActivityResourceView.Activity,
                resActivityResourceView.ActivityResource, startDateTime, endDateTime, ResRollupCoverage::Assignment,
                inclusiveEffectiveDateRange, effectiveDateTime, expirationDateTime));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSpecificPlannedResource</Name>
				<Source><![CDATA[
    private void getSpecificPlannedResource(utcdatetime _rangeStartDateTime, utcdatetime _rangeEndDateTime,
        ActivityResourceRecId _activityResource, boolean _assignmentOnly = false)
    {
        // add the specify activity resoruce to all coverage level
        ResActivityResourceView resActivityResourceView;
        select firstonly Activity, Resource, ActivityResource, Calendar from resActivityResourceView
            where resActivityResourceView.ActivityResource == _activityResource;
        if (resActivityResourceView)
        {
            if (!_assignmentOnly)
            {
                rollUpResourcesList.addEnd(this.setActivityRollUpResource(resActivityResourceView.Resource,
                    resActivityResourceView.Calendar, resActivityResourceView.Activity,
                    resActivityResourceView.ActivityResource, _rangeStartDateTime, _rangeEndDateTime, ResRollupCoverage::Activity, true));
            }

            rollUpResourcesList.addEnd(this.setActivityRollUpResource(resActivityResourceView.Resource,
                resActivityResourceView.Calendar, resActivityResourceView.Activity,
                resActivityResourceView.ActivityResource, _rangeStartDateTime, _rangeEndDateTime, ResRollupCoverage::Assignment, true));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSpecificNamedResource</Name>
				<Source><![CDATA[
    private void getSpecificNamedResource(utcdatetime _rangeStartDateTime, utcdatetime _rangeEndDateTime,
        ResourceRecId _resource)
    {
        DataAreaId currentCompany = curExt();
        Set resourceCalendarSet = new Set(Types::Int64);

        // add the specify resource to all coverage level
        // only one company resource in availability coverage will be added to the list
        ResActivityResourceEngagementView resActivityResourceView;
        ResCompanyResourceSchedulableView companyResourceView;

        while select Activity, Resource, ActivityResource from resActivityResourceView
            where resActivityResourceView.Resource == _resource
            join Calendar, EffectiveDate, ExpirationDate from companyResourceView
                where companyResourceView.Resource == _resource
                    && companyResourceView.RecipientCompany == currentCompany
        {
            utcdatetime startDateTime = _rangeStartDateTime;
            utcdatetime endDateTime = _rangeEndDateTime;
            boolean     inclusiveEffectiveDateRange = true;

            if (_rangeStartDateTime <= companyResourceView.EffectiveDate || _rangeEndDateTime >= companyResourceView.ExpirationDate)
            {
                inclusiveEffectiveDateRange = false;
            }

            if (companyResourceView.Calendar)
            {
                resourceCalendarSet.add(companyResourceView.Calendar);
            }
            
            rollUpResourcesList.addEnd(this.setActivityRollUpResource(resActivityResourceView.Resource,
                companyResourceView.Calendar, 0,
                0, startDateTime, endDateTime, ResRollupCoverage::Availability,
                inclusiveEffectiveDateRange, companyResourceView.EffectiveDate, companyResourceView.ExpirationDate));
            rollUpResourcesList.addEnd(this.setActivityRollUpResource(resActivityResourceView.Resource,
                companyResourceView.Calendar, resActivityResourceView.Activity,
                resActivityResourceView.ActivityResource, startDateTime, endDateTime, ResRollupCoverage::Activity,
                inclusiveEffectiveDateRange, companyResourceView.EffectiveDate, companyResourceView.ExpirationDate));
            rollUpResourcesList.addEnd(this.setActivityRollUpResource(resActivityResourceView.Resource,
                companyResourceView.Calendar, resActivityResourceView.Activity,
                resActivityResourceView.ActivityResource, startDateTime, endDateTime, ResRollupCoverage::Assignment,
                inclusiveEffectiveDateRange, companyResourceView.EffectiveDate, companyResourceView.ExpirationDate));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCancelSpecificPlannedResource</Name>
				<Source><![CDATA[
    private void getCancelSpecificPlannedResource(utcdatetime _rangeStartDateTime,
        utcdatetime _rangeEndDateTime, activityresourcerecid _activityResource)
    {
        ResRollUp rollUp;
        ResRollUpWriter::skipDatabaseLogAndEvent(rollUp);

        // add the specify activity resoruce to activity coverage level list and availability coverage level if it is a  resoruce
        select RootActivity, Resource, ActivityResource, Calendar from rollUp
            where rollUp.ActivityResource == _activityResource
                && rollUp.Coverage != ResRollupCoverage::Assignment;
        if (rollUp)
        {
            rollUpResourcesList.addEnd(this.setActivityRollUpResource(rollUp.Resource,
                rollUp.Calendar, rollUp.RootActivity,
                rollUp.ActivityResource, _rangeStartDateTime, _rangeEndDateTime, ResRollupCoverage::Activity, true));
            rollUpResourcesList.addEnd(this.setActivityRollUpResource(rollUp.Resource,
                rollUp.Calendar, rollUp.RootActivity,
                rollUp.ActivityResource, _rangeStartDateTime, _rangeEndDateTime, ResRollupCoverage::Assignment, true));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setActivityRollUpResource</Name>
				<Source><![CDATA[
    private ResRollupResource setActivityRollUpResource(ResourceRecId _resource,
        CalendarRecId _calendar, ActivityRecId _activity, activityResourceRecId _activityResource,
        utcdatetime _rangeStartDateTime, utcdatetime _rangeEndDateTime, ResRollupCoverage _coverageType,
        boolean _inclusiveEffectiveDateRange, utcdatetime _effectiveDateTime = utcDateTimeNull(), utcdatetime _expirationDateTime = utcDateTimeNull())
    {
        ResRollupResource rollUpResource = ResRollupResource::construct();

        rollUpResource.parmActivity(_activity);
        rollUpResource.parmActivityResource(_activityResource);
        rollUpResource.parmResource(_resource);
        rollUpResource.parmCalendar(_calendar);
        rollUpResource.parmStart(_rangeStartDateTime);
        rollUpResource.parmEnd(_rangeEndDateTime);
        rollUpResource.parmCoverage(_coverageType);
        rollUpResource.parmInculsiveEffectiveDateRange(_inclusiveEffectiveDateRange);
        rollUpResource.parmEffectiveDateTime(_effectiveDateTime);
        rollUpResource.parmExpirationDateTime(_expirationDateTime);

        if (_calendar && _coverageType != ResRollupCoverage::Assignment)
        {
            calendarSet.add(_calendar);
        }

        return rollUpResource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupCalendarTable</Name>
				<Source><![CDATA[
    private void setupCalendarTable(utcdatetime _rangeStartDateTime, utcdatetime _rangeEndDateTime, boolean _refreshCalendarRollup = false)
    {
        if (!calendarSet.empty())
        {
            ResCalendarCapacityView calendarView;

            SetIterator calendarIterator = new SetIterator(calendarSet);
            Set         calendarToBeRemoved = new Set(Types::Int64);

            // If rollup calendar table contains the calendar in the target date range, add this calendar to the 'ToBeRemoved' set.
            calendarIterator.begin();
            while (calendarIterator.more())
            {
                if (_refreshCalendarRollup)
                {
                    this.updateCalendarCapacity(calendarIterator.value(),
                        DateTimeUtil::date(_rangeStartDateTime), DateTimeUtil::date(_rangeEndDateTime));
                }
                else if (!this.validateRollupCalendarRecordsRequiresUpdate(calendarIterator.value(), _rangeStartDateTime, _rangeEndDateTime))
                {
                    calendarToBeRemoved.add(calendarIterator.value());
                }
                calendarIterator.next();
            }

            // remove the calendars from calendar set which has sufficient data in rollup calendar table
            SetIterator calendarToBeRemovedIterator = new SetIterator(calendarToBeRemoved);
            while  (calendarToBeRemovedIterator.more())
            {
                calendarSet.remove(calendarToBeRemovedIterator.value());
                calendarToBeRemovedIterator.next();
            }

            // add records to the the rollup calendar table for  each calendar hat left in the calendar set by each time scale
            DictEnum        timescales = new DictEnum(enumNum(AVTimeframeType));
            SetEnumerator   calendarEnum = calendarSet.getEnumerator();

            while (calendarEnum.moveNext())
            {
                CalendarRecId setCalendar = calendarEnum.current();
                container arguments = [_rangeStartDateTime, _rangeEndDateTime, setCalendar];
                ResRollupCalendarWriter::updateCalendarRollUp(arguments, System.Threading.CancellationToken::None);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteResourceRollupTableByActivityResourceIdWithNoDateLimit</Name>
				<Source><![CDATA[
    private void deleteResourceRollupTableByActivityResourceIdWithNoDateLimit(ActivityResourceId _activityResourceId)
    {
        ResRollup   rollUpTable;
        ResRollUpWriter::skipDatabaseLogAndEvent(rollUpTable);

        // remove records from the ResRollup table by activity resource Id
        delete_from rollUpTable
            where rollupTable.CollectionKey == _activityResourceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupResourceRollUpTable</Name>
				<Source><![CDATA[
    private void setupResourceRollUpTable(ResTmpRollUp _resRollUp, AVTimeframeType _timescale,
        utcdatetime _rangeStartDateTime, utcdatetime _rangeEndDateTime, boolean _updateForAllResources = false, boolean _removeAllExistingRecords = false)
    {
        Set staffedResourceAvailabilitySet = new Set(Types::Container);
        Set staffedResourceInsertedSet = new Set(Types::Container);

        // insert records to ResRollUp table from the calendar table by matching the resource calendar
        ResRollupCalendarShared rollUpCalendarTable;

        ListEnumerator rollUpResourceEnum = rollUpResourcesList.getEnumerator();
        while (rollUpResourceEnum.moveNext())
        {
            ResRollupResource       rollUpResource =  rollUpResourceEnum.current();
            ResRollUpCoverage       coverageType = rollUpResource.parmCoverage();
            ActivityRecId           rootActivityRecId = rollUpResource.parmRootActivity();
            ResourceRecId           resourceRecId = rollUpResource.parmResource();
            activityresourcerecid   activityResourceRecId = rollUpResource.parmActivityResource();
            ActivityResourceId      activityResourceId = rollUpResource.parmActivityResourceId();
            CalendarRecId           resourceCalendar = rollUpResource.parmCalendar();
            real                    initializeValue = 0;

            Container staffedResourceAvailabilityCon = [resourceRecId, rollUpResource.parmEffectiveDateTime(), rollUpResource.parmExpirationDateTime()];
            
            //Only update rollup once if this is a staffed resource and the coverage type is availability
            if (!resourceRecId || coverageType != ResRollUpCoverage::Availability || !staffedResourceAvailabilitySet.in(staffedResourceAvailabilityCon))
            {
                if (resourceRecId && coverageType == ResRollUpCoverage::Availability)
                {
                    staffedResourceAvailabilitySet.add(staffedResourceAvailabilityCon);
                }

                // In the case of update for all resources, then it should first remove all existing records.
                if (!_removeAllExistingRecords && _updateForAllResources)
                {
                    ResRollUp resRollup;
                    ResRollUpWriter::skipDatabaseLogAndEvent(resRollup);

                    delete_from resRollup
                        where resRollup.Coverage == coverageType
                            && resRollup.RootActivity == rootActivityRecId
                            && resRollup.Resource == resourceRecId
                            && resRollup.ActivityResource == activityResourceRecId
                            && resRollup.Timescale == _timescale
                            && resRollup.Timeframe >= _rangeStartDateTime
                            && resRollup.Timeframe <= _rangeEndDateTime;
                }

                // Detect if a staffed resource has multiple effective periods within this time range.
                // If the staffed resource has been added to the insertion set, then it should not be inserted again.
                Container staffedResourceCon = [resourceRecId, coverageType, rootActivityRecId, activityResourceRecId];
                boolean insertRecord = !resourceRecId || !staffedResourceInsertedSet.in(staffedResourceCon);

                if (insertRecord)
                {
                    if (resourceRecId)
                    {
                        staffedResourceInsertedSet.add(staffedResourceCon);
                    }
                    
                    insert_recordset _resRollUp (
                        Coverage, RootActivity, Resource, ActivityResource,
                        CollectionKey, Timescale, Timeframe, Capacity, HardLocked, SoftLocked, Remaining,
                        Status, Calendar)
                        select
                        coverageType, rootActivityRecId, resourceRecId, activityResourceRecId,
                        activityResourceId, Timescale, Timeframe, Capacity, initializeValue, initializeValue, Capacity,
                        Status, resourceCalendar
                        from rollUpCalendarTable
                            where rollUpCalendarTable.Calendar == resourceCalendar
                                && rollUpCalendarTable.Timescale == _timescale
                                && rollUpCalendarTable.Timeframe >= _rangeStartDateTime
                                && rollUpCalendarTable.Timeframe <= _rangeEndDateTime;

                    // If resource effective date range is smaller than the requested date range,
                    // update resource non-effective dates as unavailable with 0 capacity and remaining hours.
                    if (!rollUpResource.parmInculsiveEffectiveDateRange())
                    {
                        utcdatetime effectiveDateTime = rollUpResource.parmEffectiveDateTime();
                        utcdatetime exiprationDateTime = rollUpResource.parmExpirationDateTime();

                        utcdatetime effectiveDay = DateTimeUtil::newDateTime(DateTimeUtil::date(effectiveDateTime), 0);
                        utcdatetime expirationDay = DateTimeUtil::newDateTime(DateTimeUtil::date(exiprationDateTime), 0);

                        switch (_timescale)
                        {
                            case AVTimeframeType::Hour:
                                update_recordset _resRollUp
                                    setting Capacity = 0,
                                        Remaining = 0,
                                        Calendar = 0,
                                        Status = ProjScheduleStatus::Unavailable
                                    where _resRollUp.Coverage == coverageType
                                        && _resRollUp.RootActivity == rootActivityRecId
                                        && _resRollUp.Resource == resourceRecId
                                        && _resRollUp.ActivityResource == activityResourceRecId
                                        && _resRollUp.Timescale == AVTimeframeType::Hour
                                        && (_resRollUp.Timeframe < effectiveDateTime
                                            || _resRollUp.Timeframe > exiprationDateTime);
                                break;
                            case AVTimeframeType::Day:
                                update_recordset _resRollUp
                                    setting Capacity = 0,
                                        Remaining = 0,
                                        Calendar = 0,
                                        Status = ProjScheduleStatus::Unavailable
                                    where _resRollUp.Coverage == coverageType
                                        && _resRollUp.RootActivity == rootActivityRecId
                                        && _resRollUp.Resource == resourceRecId
                                        && _resRollUp.ActivityResource == activityResourceRecId
                                        && _resRollUp.Timescale == AVTimeframeType::Day
                                        && (_resRollUp.Timeframe < effectiveDay
                                            || _resRollUp.Timeframe > expirationDay);
                                break;
                            default:
                                utcdatetime effectiveStartTimeByTimeScale = AVTimeframe::getTimeframe(effectiveDay, _timescale).start();
                                utcdatetime expirationStartTimeByTimeScale = AVTimeframe::getTimeframe(expirationDay, _timescale).start();

                                update_recordset _resRollUp
                                    setting Capacity = 0,
                                        Remaining = 0,
                                        Calendar = 0,
                                        Status = ProjScheduleStatus::Unavailable
                                    where _resRollUp.Coverage == coverageType
                                        && _resRollUp.RootActivity == rootActivityRecId
                                        && _resRollUp.Resource == resourceRecId
                                        && _resRollUp.ActivityResource == activityResourceRecId
                                        && _resRollUp.Timescale == _timescale
                                        && (_resRollUp.Timeframe <= effectiveStartTimeByTimeScale
                                            || _resRollUp.Timeframe >= expirationStartTimeByTimeScale);

                                utcdatetime startRangeStartTimeByTimeScale = AVTimeframe::getTimeframe(_rangeStartDateTime, _timescale).start();
                                utcdatetime endRangeStartTimeByTimeScale = AVTimeframe::getTimeframe(_rangeEndDateTime, _timescale).start();
                                utcdatetime endRangeEndTimeByTimeScale = AVTimeframe::getTimeframe(_rangeEndDateTime, _timescale).end();

                                this.updateBorderRecordCapacity(
                                    _resRollUp, _timescale, rollUpResource,
                                    effectiveDay, expirationDay,
                                    effectiveStartTimeByTimeScale, expirationStartTimeByTimeScale,
                                    startRangeStartTimeByTimeScale, endRangeStartTimeByTimeScale,
                                    endRangeEndTimeByTimeScale);
                                break;
                        }
                    }
                }
                else
                {
                    ResourceCalendarView resourceCalendarView;
                    ResourceLegalEntityView resourceLegalEntityView;

                    while select ValidFrom, ValidTo from resourceLegalEntityView
                        where resourceLegalEntityView.Resource == resourceRecId
                            && resourceLegalEntityView.ValidFrom == rollUpResource.parmEffectiveDateTime()
                            && resourceLegalEntityView.ValidTo == rollUpResource.parmExpirationDateTime()
                        join resourceCalendarView
                            where resourceCalendarView.ResourceLegalEntityRefRecId == resourceLegalEntityView.RefRecId
                                && resourceCalendarView.ResourceLegalEntityRefTableId == resourceLegalEntityView.RefTableId
                                && resourceCalendarView.Calendar == resourceCalendar
                    {
                        utcdatetime effectiveDateTime = resourceLegalEntityView.ValidFrom;
                        utcdatetime expirationDateTime = resourceLegalEntityView.ValidTo;

                        utcdatetime effectiveDay = DateTimeUtil::newDateTime(DateTimeUtil::date(effectiveDateTime), 0);
                        utcdatetime expirationDay = DateTimeUtil::newDateTime(DateTimeUtil::date(expirationDateTime), 0);

                        utcdatetime effectiveStartTimeByTimeScale = AVTimeframe::getTimeframe(effectiveDay, _timescale).start();
                        utcdatetime expirationStartTimeByTimeScale = AVTimeframe::getTimeframe(expirationDay, _timescale).start();

                        switch (_timescale)
                        {
                            case AVTimeframeType::Hour:
                            case AVTimeframeType::Day:
                                update_recordset _resRollUp
                                    setting Capacity = rollUpCalendarTable.Capacity,
                                        Remaining = rollUpCalendarTable.Capacity,
                                        Status = rollUpCalendarTable.Status,
                                        Calendar = resourceCalendar
                                    where _resRollUp.Coverage == coverageType
                                        && _resRollUp.RootActivity == rootActivityRecId
                                        && _resRollUp.Resource == resourceRecId
                                        && _resRollUp.ActivityResource == activityResourceRecId
                                        && _resRollUp.Timescale == _timescale
                                        && _resRollUp.Timeframe >= effectiveStartTimeByTimeScale
                                        && _resRollUp.Timeframe <= expirationStartTimeByTimeScale
                                    join rollUpCalendarTable
                                        where rollUpCalendarTable.Calendar == resourceCalendar
                                            && rollUpCalendarTable.Timescale == _resRollUp.Timescale
                                            && rollUpCalendarTable.Timeframe == _resRollUp.Timeframe;
                                break;
                            default:
                                update_recordset _resRollUp
                                    setting Capacity = rollUpCalendarTable.Capacity,
                                        Remaining = rollUpCalendarTable.Capacity,
                                        Status = rollUpCalendarTable.Status,
                                        Calendar = resourceCalendar
                                    where _resRollUp.Coverage == coverageType
                                        && _resRollUp.RootActivity == rootActivityRecId
                                        && _resRollUp.Resource == resourceRecId
                                        && _resRollUp.ActivityResource == activityResourceRecId
                                        && _resRollUp.Timescale == _timescale
                                        && _resRollUp.Timeframe > effectiveStartTimeByTimeScale
                                        && _resRollUp.Timeframe < expirationStartTimeByTimeScale
                                    join rollUpCalendarTable
                                        where rollUpCalendarTable.Calendar == resourceCalendar
                                            && rollUpCalendarTable.Timescale == _resRollUp.Timescale
                                            && rollUpCalendarTable.Timeframe == _resRollUp.Timeframe;

                                utcdatetime startRangeStartTimeByTimeScale = AVTimeframe::getTimeframe(_rangeStartDateTime, _timescale).start();
                                utcdatetime endRangeStartTimeByTimeScale = AVTimeframe::getTimeframe(_rangeEndDateTime, _timescale).start();
                                utcdatetime endRangeEndTimeByTimeScale = AVTimeframe::getTimeframe(_rangeEndDateTime, _timescale).end();

                                this.updateBorderRecordCapacity(
                                    _resRollUp, _timescale, rollUpResource,
                                    effectiveDay, expirationDay,
                                    effectiveStartTimeByTimeScale, expirationStartTimeByTimeScale,
                                    startRangeStartTimeByTimeScale, endRangeStartTimeByTimeScale,
                                    endRangeEndTimeByTimeScale);
                                break;
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBorderRecordCapacity</Name>
				<Source><![CDATA[
    private void updateBorderRecordCapacity(
        ResTmpRollUp _resRollUp, 
        AVTimeframeType _timescale,
        ResRollupResource _rollUpResource,
        utcdatetime _effectiveDay,
        utcdatetime _expirationDay,
        utcdatetime _effectiveStartTimeByTimeScale, 
        utcdatetime _expirationStartTimeByTimeScale,
        utcdatetime _startRangeStartTimeByTimeScale,
        utcdatetime _endRangeStartTimeByTimeScale,
        utcdatetime _endRangeEndTimeByTimeScale)
    {
        // Calculate the resource capacity for a specific record which overlap with the effectiveDay.
        if ((_effectiveStartTimeByTimeScale >= _startRangeStartTimeByTimeScale
            && _effectiveStartTimeByTimeScale <= _endRangeStartTimeByTimeScale)
            && (_effectiveDay >= _effectiveStartTimeByTimeScale))
        {
            utcdatetime effectiveEndTimeByTimeScale = AVTimeframe::getTimeframe(_effectiveDay, _timescale).end();
            utcdatetime endTime = effectiveEndTimeByTimeScale > _expirationDay ? _expirationDay : effectiveEndTimeByTimeScale;
            this.updateBorderRecordCapacityExecution(_resRollUp, _timescale, _rollUpResource,
                _effectiveStartTimeByTimeScale, _effectiveDay, endTime);
        }

        // Calculate the resource capacity for the specific record which overlap with the expirationDay.
        if ((_effectiveStartTimeByTimeScale != _expirationStartTimeByTimeScale)
            && (_expirationStartTimeByTimeScale >= _startRangeStartTimeByTimeScale
                && _expirationStartTimeByTimeScale <= _endRangeStartTimeByTimeScale)
            && (_expirationDay >= _expirationStartTimeByTimeScale))
        {
            this.updateBorderRecordCapacityExecution(_resRollUp, _timescale, _rollUpResource,
                _expirationStartTimeByTimeScale, _expirationStartTimeByTimeScale, _expirationDay);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBorderRecordCapacityExecution</Name>
				<Source><![CDATA[
    private void updateBorderRecordCapacityExecution(ResTmpRollUp _resRollUp, AVTimeframeType _timescale,
        ResRollupResource _rollUpResource, utcdatetime _verificationDay,
        utcdatetime _targetStartDateTime, utcdatetime _targetEndDateTime)
    {
        ResRollUpCoverage       coverageType = _rollUpResource.parmCoverage();
        ActivityRecId           rootActivityRecId = _rollUpResource.parmRootActivity();
        ResourceRecId           resourceRecId = _rollUpResource.parmResource();
        activityresourcerecid   activityResourceRecId = _rollUpResource.parmActivityResource();
        CalendarRecId           resourceCalendar = _rollUpResource.parmCalendar();
        ResRollupCalendarShared rollUpCalendarTable;

        select sum(Capacity) from rollUpCalendarTable
            where rollUpCalendarTable.Calendar == resourceCalendar
                && rollUpCalendarTable.Timescale == AVTimeframeType::Day
                && rollUpCalendarTable.Timeframe >= _targetStartDateTime
                && rollUpCalendarTable.Timeframe <= _targetEndDateTime;

        update_recordset _resRollUp
            setting
                Remaining = rollUpCalendarTable.Capacity,
                Capacity = _resRollUp.Capacity + rollUpCalendarTable.Capacity,
                Status = ProjScheduleStatus::Available,
                Calendar = resourceCalendar
            where _resRollUp.Coverage == coverageType
                && _resRollUp.RootActivity == rootActivityRecId
                && _resRollUp.Resource == resourceRecId
                && _resRollUp.ActivityResource == activityResourceRecId
                && _resRollUp.Timescale == _timescale
                && _resRollUp.Timeframe == _verificationDay;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRemainingHoursAndStatusByResource</Name>
				<Source><![CDATA[
    private void updateRemainingHoursAndStatusByResource(ResTmpRollUp _resRollUp, 
        AVTimeframeType _timescale, utcdatetime _rangeStartDateTime, utcdatetime _rangeEndDateTime, 
        ResourceRecId _resource = 0)
    {
        update_recordset _resRollUp
            setting Remaining = _resRollUp.Capacity - _resRollUp.HardLocked
            where (!_resource || _resRollUp.Resource == _resource)
                && _resRollUp.Timescale ==_timescale
                && _resRollUp.Timeframe >= _rangeStartDateTime
                && _resRollUp.Timeframe <= _rangeEndDateTime;

        update_recordset _resRollUp
            setting Status = ProjScheduleStatus::Available
            where (!_resource || _resRollUp.Resource == _resource)
                && _resRollUp.Timescale == _timescale
                && _resRollUp.Timeframe >= _rangeStartDateTime
                && _resRollUp.Timeframe <= _rangeEndDateTime
                && _resRollUp.Capacity != 0
                && _resRollUp.HardLocked == 0;

        update_recordset _resRollUp
            setting Status = ProjScheduleStatus::Booked
            where (!_resource || _resRollUp.Resource == _resource)
                && _resRollUp.Timescale == _timescale
                && _resRollUp.Timeframe >= _rangeStartDateTime
                && _resRollUp.Timeframe <= _rangeEndDateTime
                && _resRollUp.Capacity != 0
                && _resRollUp.HardLocked >= _resRollUp.Capacity
                && (_resRollUp.HardLocked - _resRollUp.Capacity) <= reservationStatusToleranceInHours;
                    
        update_recordset _resRollUp
            setting Status = ProjScheduleStatus::Booked
            where (!_resource || _resRollUp.Resource == _resource)
                && _resRollUp.Timescale == _timescale
                && _resRollUp.Timeframe >= _rangeStartDateTime
                && _resRollUp.Timeframe <= _rangeEndDateTime
                && _resRollUp.Capacity != 0
                && _resRollUp.Capacity > _resRollUp.HardLocked
                && (_resRollUp.Capacity - _resRollUp.HardLocked) <= reservationStatusToleranceInHours;

        update_recordset _resRollUp
            setting Status = ProjScheduleStatus::Overbooked
            where (!_resource || _resRollUp.Resource == _resource)
                && _resRollUp.Timescale == _timescale
                && _resRollUp.Timeframe >= _rangeStartDateTime
                && _resRollUp.Timeframe <= _rangeEndDateTime
                && (_resRollUp.HardLocked - _resRollUp.Capacity) > reservationStatusToleranceInHours;

        update_recordset _resRollUp
            setting Status = ProjScheduleStatus::PartiallyAvailable
            where (!_resource || _resRollUp.Resource == _resource)
                && _resRollUp.Timescale == _timescale
                && _resRollUp.Timeframe >= _rangeStartDateTime
                && _resRollUp.Timeframe <= _rangeEndDateTime
                && _resRollUp.Capacity != 0
                && _resRollUp.HardLocked != 0
                && _resRollUp.HardLocked < _resRollUp.Capacity;

        update_recordset _resRollUp
            setting Status = ProjScheduleStatus::Unavailable
            where (!_resource || _resRollUp.Resource == _resource)
                && _resRollUp.Timescale == _timescale
                && _resRollUp.Timeframe >= _rangeStartDateTime
                && _resRollUp.Timeframe <= _rangeEndDateTime
                && _resRollUp.Capacity == 0
                && _resRollUp.HardLocked == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRemainingHoursAndStatusByActivityResource</Name>
				<Source><![CDATA[
    private void updateRemainingHoursAndStatusByActivityResource(ResTmpRollUp _resRollUp,
        AVTimeframeType _timescale, utcdatetime _rangeStartDateTime,
        utcdatetime _rangeEndDateTime, ActivityResourceRecId _activityResource = 0)
    {
        update_recordset _resRollUp
            setting Remaining = _resRollUp.Capacity - _resRollUp.HardLocked
            where (!_activityResource
                    || _resRollUp.ActivityResource == _activityResource)
                && _resRollUp.Timescale ==_timescale
                && _resRollUp.Timeframe >= _rangeStartDateTime
                && _resRollUp.Timeframe <= _rangeEndDateTime;

        update_recordset _resRollUp
            setting Status = ProjScheduleStatus::Available
            where (!_activityResource
                    || _resRollUp.ActivityResource == _activityResource)
                && _resRollUp.Timescale == _timescale
                && _resRollUp.Timeframe >= _rangeStartDateTime
                && _resRollUp.Timeframe <= _rangeEndDateTime
                && _resRollUp.Capacity != 0
                && _resRollUp.HardLocked == 0;

        update_recordset _resRollUp
            setting Status = ProjScheduleStatus::Booked
            where (!_activityResource
                    || _resRollUp.ActivityResource == _activityResource)
                && _resRollUp.Timescale == _timescale
                && _resRollUp.Timeframe >= _rangeStartDateTime
                && _resRollUp.Timeframe <= _rangeEndDateTime
                && _resRollUp.Capacity != 0
                && _resRollUp.HardLocked >= _resRollUp.Capacity
                && (_resRollUp.HardLocked - _resRollUp.Capacity) <= reservationStatusToleranceInHours;
                        
        update_recordset _resRollUp
            setting Status = ProjScheduleStatus::Booked
            where (!_activityResource
                    || _resRollUp.ActivityResource == _activityResource)
                && _resRollUp.Timescale == _timescale
                && _resRollUp.Timeframe >= _rangeStartDateTime
                && _resRollUp.Timeframe <= _rangeEndDateTime
                && _resRollUp.Capacity != 0
                && _resRollUp.Capacity > _resRollUp.HardLocked                        
                && (_resRollUp.Capacity - _resRollUp.HardLocked) <= reservationStatusToleranceInHours;

        update_recordset _resRollUp
            setting Status = ProjScheduleStatus::Overbooked
            where (!_activityResource
                    || _resRollUp.ActivityResource == _activityResource)
                && _resRollUp.Timescale == _timescale
                && _resRollUp.Timeframe >= _rangeStartDateTime
                && _resRollUp.Timeframe <= _rangeEndDateTime
                && (_resRollUp.HardLocked - _resRollUp.Capacity) > reservationStatusToleranceInHours;

        update_recordset _resRollUp
            setting Status = ProjScheduleStatus::PartiallyAvailable
            where (!_activityResource
                    || _resRollUp.ActivityResource == _activityResource)
                && _resRollUp.Timescale == _timescale
                && _resRollUp.Timeframe >= _rangeStartDateTime
                && _resRollUp.Timeframe <= _rangeEndDateTime
                && _resRollUp.Capacity != 0
                && _resRollUp.HardLocked != 0
                && _resRollUp.HardLocked < _resRollUp.Capacity;

        update_recordset _resRollUp
            setting Status = ProjScheduleStatus::Unavailable
            where (!_activityResource
                    || _resRollUp.ActivityResource == _activityResource)
                && _resRollUp.Timescale == _timescale
                && _resRollUp.Timeframe >= _rangeStartDateTime
                && _resRollUp.Timeframe <= _rangeEndDateTime
                && _resRollUp.Capacity == 0
                && _resRollUp.HardLocked == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveTmpDataToRollUpTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Move processed data from temp table to the actual <c>ResRollUp</c> table.
    /// This is done to minimize the lock time in the <c>ResRollUp</c> table.
    /// </summary>
    /// <param name = "_tmpRollUp">Temp table <c>ResTmpRollUp</c> buffer.</param>
    /// <param name = "_startDateTime">Start date time.</param>
    /// <param name = "_endDateTime">End date time.</param>
    /// <param name = "_timescale">Time scale.</param>
    /// <param name = "_activityResource">Activity resource record ID should only be defined for planned resource.</param>
    /// <param name = "_resource">Resource record ID should only be defined for non-planned resource.</param>
    public void moveTmpDataToRollUpTable(ResTmpRollUp _tmpRollUp, utcdatetime _startDateTime, utcdatetime _endDateTime,
        AVTimeframeType _timescale, ActivityResourceRecId _activityResource = 0, ResourceRecId _resource = 0)
    {
        ResRollUp rollUp;
        ResRollUpWriter::skipDatabaseLogAndEvent(rollUp);
        ActivityResourceRecId activityResource = _activityResource;

        // Add try catch in case of async call and encounter multiple threads updating ResRollup table to cause update conflict exception.
        try
        {
            DictEnum rollupCoverageValue = new DictEnum(enumNum(ResRollupCoverage));
            for (int counter = 0; counter < rollupCoverageValue.values(); counter++)
            {
                ResRollupCoverage rollupCoverage = rollupCoverageValue.index2Value(counter);

                //If this is a staffed resource and coverage type is availability, then activity resource should set to 0.
                if (_resource && rollupCoverage == ResRollupCoverage::Availability)
                {
                    activityResource = 0;
                }

                ttsbegin;
                this.updateTmpDataToRollUpTable(rollUp, rollupCoverage, _tmpRollUp, _startDateTime, _endDateTime, _timescale, activityResource, _resource);
                this.insertTmpDataToRollUpTable(rollUp, rollupCoverage, _tmpRollUp, _startDateTime, _endDateTime, _timescale, activityResource, _resource);
                ttscommit;

            }

            this.postedResRollup(rollUp, _startDateTime, _endDateTime, _timescale, activityResource, _resource);

        }
        catch (Exception::UpdateConflict)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                ttsabort;
                throw Exception::UpdateConflictNotRecovered;
            }
            else
            {
                retry;
            }
        }
        catch(Exception::Error)
        {
            ttsabort;
            throw Exception::Error;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTmpDataToRollUpTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update processed data from temp table to the actual <c>ResRollUp</c> table.
    /// This is done to minimize the lock time in the <c>ResRollUp</c> table.
    /// </summary>
    /// <param name = "_rollup"><c>ResRollUp</c> table buffer.</param>
    /// <param name = "_coverage">Rollup coverage type.</param>
    /// <param name = "_tmpRollUp">Temp table <c>ResTmpRollUp</c> buffer.</param>
    /// <param name = "_startDateTime">Start date time.</param>
    /// <param name = "_endDateTime">End date time.</param>
    /// <param name = "_timescale">Time scale.</param>
    /// <param name = "_activityResource">Activity resource record ID should only be defined for planned resource.</param>
    /// <param name = "_resource">Resource record ID should only be defined for non-planned resource.</param>
    private void updateTmpDataToRollUpTable(ResRollUp _rollup, ResRollupCoverage _coverage,
        ResTmpRollUp _tmpRollUp, utcdatetime _startDateTime, utcdatetime _endDateTime,
        AVTimeframeType _timescale, ActivityResourceRecId _activityResource = 0, ResourceRecId _resource = 0)
    {
        update_recordset _rollup
            setting
                Capacity = _tmpRollUp.Capacity,
                HardLocked = _tmpRollUp.HardLocked,
                SoftLocked = _tmpRollUp.SoftLocked,
                Remaining = _tmpRollUp.Remaining,
                Status = _tmpRollUp.Status,
                Calendar = _tmpRollUp.Calendar
            join _tmpRollUp
                where _tmpRollUp.Timescale == _timescale
                    && _tmpRollUp.Timeframe >= _startDateTime
                    && _tmpRollUp.Timeframe <= _endDateTime
                    && _tmpRollUp.Coverage == _coverage
                    && (!_resource || _tmpRollUp.Resource == _resource)
                    && (!_activityResource || _tmpRollUp.ActivityResource == _activityResource)
                    && _tmpRollUp.Coverage == _rollup.Coverage
                    && _tmpRollUp.RootActivity == _rollup.RootActivity
                    && _tmpRollUp.Resource == _rollup.Resource
                    && _tmpRollUp.ActivityResource == _rollup.ActivityResource
                    && _tmpRollUp.Timescale == _rollup.Timescale
                    && _tmpRollUp.Timeframe == _rollup.Timeframe;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTmpDataToRollUpTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert processed data from temp table to the actual <c>ResRollUp</c> table.
    /// This is done to minimize the lock time in the <c>ResRollUp</c> table.
    /// </summary>
    /// <param name = "_rollup"><c>ResRollUp</c> table buffer.</param>
    /// <param name = "_coverage">Rollup coverage type.</param>    
    /// <param name = "_tmpRollUp">Temp table <c>ResTmpRollUp</c> buffer.</param>
    /// <param name = "_startDateTime">Start date time.</param>
    /// <param name = "_endDateTime">End date time.</param>
    /// <param name = "_timescale">Time scale.</param>
    /// <param name = "_activityResource">Activity resource record ID should only be defined for planned resource.</param>
    /// <param name = "_resource">Resource record ID should only be defined for non-planned resource.</param>
    private void insertTmpDataToRollUpTable(ResRollUp _rollup, ResRollupCoverage _coverage,
        ResTmpRollUp _tmpRollUp, utcdatetime _startDateTime, utcdatetime _endDateTime,
        AVTimeframeType _timescale, ActivityResourceRecId _activityResource = 0, ResourceRecId _resource = 0)
    {
        insert_recordset _rollup (
            Coverage, RootActivity, Resource, ActivityResource,
            CollectionKey, Timescale, Timeframe, Capacity, HardLocked, SoftLocked, Remaining,
            Status, Calendar)
            select
                Coverage, RootActivity, Resource, ActivityResource,
                CollectionKey, Timescale, Timeframe, Capacity, HardLocked, SoftLocked, Remaining,
                Status, Calendar
            from _tmpRollUp
            where _tmpRollUp.Timescale == _timescale
                && _tmpRollUp.Timeframe >= _startDateTime
                && _tmpRollUp.Timeframe <= _endDateTime
                && _tmpRollUp.Coverage == _coverage
                && (!_resource || _tmpRollUp.Resource == _resource)
                && (!_activityResource || _tmpRollUp.ActivityResource == _activityResource)
            notexists join _rollup
                where _rollup.Coverage == _tmpRollUp.Coverage
                    && _rollup.RootActivity == _tmpRollUp.RootActivity
                    && _rollup.Resource == _tmpRollUp.Resource
                    && _rollup.ActivityResource == _tmpRollUp.ActivityResource
                    && _rollup.Timescale == _tmpRollUp.Timescale
                    && _rollup.Timeframe == _tmpRollUp.Timeframe;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postedResRollup</Name>
				<Source><![CDATA[
    delegate void postedResRollup(ResRollUp _rollUp, utcdatetime _startDateTime, utcdatetime _endDateTime,
        AVTimeframeType _timescale, ActivityResourceRecId _activityResource = 0, ResourceRecId _resource = 0)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeExistingRollupRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove all existing records in the <c>ResRollUp</c> and <c>ResRollUpCalendarShared</c> tables
    /// </summary>
    private void removeExistingRollupRecords()
    {
        // Truncate ResRollup table data if ResRollup table contains data in only one partition.
        str truncateResRollUpStatement = ResRollUpWriter::getTruncateSQLStatement(tableStr(ResRollup));
        ResRollUpWriter::executeSQLStatement(truncateResRollUpStatement);
            
        // If ResRollup records are not removed, then remove the records by delete method.
        if (ResRollUp::hasRecords())
        {
            ResRollUp resRollup;
            ResRollUpWriter::skipDatabaseLogAndEvent(resRollup);

            // First, remove all records which are not hour time scale.
            DictEnum timescales = new DictEnum(enumNum(AVTimeframeType));
            for (int counter = timescales.values() - 1; counter >= 0; counter--)
            {
                AVTimeframeType timescale = timescales.index2Value(counter);
                if (timescale != AVTimeframeType::Hour)
                {
                    if (timescale == AVTimeframeType::Day)
                    {
                        // If ResRollUp table contains hour time scale records, then don't remove day time scale just yet
                        // as SQL table may not have enough space to store all the day transaction records.
                        if (ResRollUp::hasRecordsByTimescale(AVTimeframeType::Hour))
                        {
                            continue;
                        }
                    }

                    ttsbegin;

                    delete_from resRollup
                        where resRollup.Timescale == timescale;

                    ttscommit;
                }
            }

            // If there is any record left, these will be the day and hour time scale records which needs to be removed.
            if (ResRollUp::hasRecordsByTimescale(AVTimeframeType::Hour) || ResRollUp::hasRecordsByTimescale(AVTimeframeType::Day))
            {
                utcdatetime earliestTimeFrameByMonth =
                    AVTimeframe::getTimeframe(
                        ResRollUp::getEarliestTimeframeByTimeScale(AVTimeframeType::Hour),
                        AVTimeframeType::Month).start();
                    
                utcdatetime latestTimeFrameByMonth =
                    AVTimeframe::getTimeframe(
                        ResRollUp::getLatestTimeframeByTimeScale(AVTimeframeType::Hour),
                        AVTimeframeType::Month).end();

                if (latestTimeFrameByMonth >= earliestTimeFrameByMonth)
                {
                    // Delete ResRollUp table day and hour timescale records by month until there are no records left
                    // This is done to workaround a SQL issue which when deleting all the records
                    // by a single delete command, SQL may run out of space to store all the transaction which
                    // causes time out error.
                    utcdatetime startDateTime = earliestTimeFrameByMonth;

                    while (latestTimeFrameByMonth >= startDateTime)
                    {
                        utcdatetime currentMonthEndDateTime = AVTimeframe::getTimeframe(startDateTime, AVTimeframeType::Month).end();

                        ttsbegin;

                        delete_from resRollup
                            where resRollup.Timescale == AVTimeframeType::Day
                                && resRollup.Timeframe <= currentMonthEndDateTime;

                        delete_from resRollup
                            where resRollup.Timescale == AVTimeframeType::Hour
                                && resRollup.Timeframe <= currentMonthEndDateTime;

                        ttscommit;
                        
                        startDateTime = ResUtil::getNextDateTimeByTimeScale(startDateTime, AVTimeframeType::Month);
                    }
                }
            }
        }

        // Truncate ResRollUpCalendarShared table data if ResRollUpCalendarShared table contains data in only one partition.
        str truncateResRollUpCalendarSharedStatement = ResRollUpWriter::getTruncateSQLStatement(tableStr(ResRollUpCalendarShared));
        ResRollUpWriter::executeSQLStatement(truncateResRollUpCalendarSharedStatement);

        if (ResRollUpCalendarShared::hasRecords())
        {
            ResRollUpCalendarShared resRollupCalendar;
            ResRollUpWriter::skipDatabaseLogAndEvent(resRollupCalendar);

            // First, remove all records which are not hour time scale.
            DictEnum timescales = new DictEnum(enumNum(AVTimeframeType));
            for (int counter = timescales.values() - 1; counter >= 0; counter--)
            {
                AVTimeframeType timescale = timescales.index2Value(counter);
                if (timescale != AVTimeframeType::Hour)
                {
                    ttsbegin;

                    delete_from resRollupCalendar
                        where resRollupCalendar.Timescale == timescale;

                    ttscommit;
                }
            }

            // If there is any record left, those must be hour type records.
            if (ResRollUpCalendarShared::hasRecords())
            {
                utcdatetime earliestTimeFrameByMonth =
                    AVTimeframe::getTimeframe(
                        ResRollUpCalendarShared::getEarliestTimeframeByTimeScale(AVTimeframeType::Hour),
                        AVTimeframeType::Month).start();
                    
                utcdatetime latestTimeFrameByMonth =
                    AVTimeframe::getTimeframe(
                        ResRollUpCalendarShared::getLatestTimeframeByTimeScale(AVTimeframeType::Hour),
                        AVTimeframeType::Month).end();

                if (latestTimeFrameByMonth >= earliestTimeFrameByMonth)
                {
                    // Delete ResRollUpCalendarShared table hour timescale records by month until there are no records left
                    // This is done to workaround a SQL issue which when deleting all the records
                    // by a single delete command, SQL may run out of space to store all the transaction which
                    // causes time out error.
                    utcdatetime startDateTime = earliestTimeFrameByMonth;

                    while (latestTimeFrameByMonth >= startDateTime)
                    {
                        utcdatetime currentMonthEndDateTime = AVTimeframe::getTimeframe(startDateTime, AVTimeframeType::Month).end();

                        ttsbegin;

                        delete_from resRollupCalendar
                            where resRollupCalendar.Timescale == AVTimeframeType::Hour
                                && resRollupCalendar.Timeframe <= currentMonthEndDateTime;
                        
                        ttscommit;

                        startDateTime = ResUtil::getNextDateTimeByTimeScale(startDateTime, AVTimeframeType::Month);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRollupForAllReosurcesOperationDetails</Name>
				<Source><![CDATA[
    private void updateRollupForAllReosurcesOperationDetails(AVTimeframeType _timeScale, boolean _removeAllExistingRecords, utcdatetime _startDateTime, utcdatetime _endDateTime)
    {
        ResRollupActivityWriter activityWriter = ResRollupActivityWriter::construct();
        ResRollupAvailabilityWriter availabilityWriter = ResRollupAvailabilityWriter::construct();
        ResRollupAssignmentWriter assignmentWriter = ResRollupAssignmentWriter::construct();

        // First insert record to temp table.  Then copy data to ResRollup table after data processing is done.
        ResTmpRollUp tmpRollup;
        ResRollUpWriter::skipDatabaseLogAndEvent(tmpRollup);

        this.setupResourceRollUpTable(tmpRollup, _timeScale, _startDateTime, _endDateTime, true, _removeAllExistingRecords);
        activityWriter.updateRollupTableWithLockedCapacityForActivityResource(tmpRollup, _timeScale, _startDateTime, _endDateTime);
        availabilityWriter.updateRollupTableWithLockedCapacityForNamedResource(tmpRollup, _timeScale, _startDateTime, _endDateTime);
        assignmentWriter.updateRollupTableWithAssignmentCapacityForPlannedResource(tmpRollup, _timeScale, _startDateTime, _endDateTime);
        assignmentWriter.updateRollupTableWithLockedCapacityForNamedResource(tmpRollup, _timeScale, _startDateTime, _endDateTime);
        assignmentWriter.updateRollupTableWithSubtractingEngagementLockedCapacityForNamedResource(tmpRollup, _timeScale, _startDateTime, _endDateTime);
        assignmentWriter.updateRollUpTableWithEnagementAssignmentCapacityForNamedResource(tmpRollup, _timeScale, _startDateTime, _endDateTime);
        this.updateRemainingHoursAndStatusByResource(tmpRollup, _timeScale, _startDateTime, _endDateTime);
        this.moveTmpDataToRollUpTable(tmpRollup, _startDateTime, _endDateTime, _timeScale);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRollUpForAllResourcesOperation</Name>
				<Source><![CDATA[
    private void updateRollUpForAllResourcesOperation(utcdatetime _rangeStartDateTime, utcdatetime _rangeEndDateTime, boolean _removeAllExistingRecords)
    {
        if (_removeAllExistingRecords)
        {
            this.removeExistingRollupRecords();
        }

        // add all resources to rollup resources list
        this.getCompanyResources(_rangeStartDateTime, _rangeEndDateTime);
        this.getActivityResources(_rangeStartDateTime, _rangeEndDateTime);
        this.setupCalendarTable(_rangeStartDateTime, _rangeEndDateTime, true);
        
        // update the all resources scheduling data to the resource roll-up table
        DictEnum    timescales = new DictEnum(enumNum(AVTimeframeType));
        int         values = timescales.values();
        for (int counter = 0; counter < values; counter++)
        {
            AVTimeframeType timescale = timescales.index2Value(counter);
            
            utcdatetime userDefineStartDateTime = AVTimeframe::getTimeframe(_rangeStartDateTime, timescale).start();
            utcdatetime userDefineEndDateTime = AVTimeframe::getTimeframe(_rangeEndDateTime, timescale).end();

            if (this.enableHourScheduling && timescale == AVTimeframeType::Hour)
            {
                // For hour time scale, generate and commit records per month.
                utcdatetime startDateTime = userDefineStartDateTime;

                while (userDefineEndDateTime >= startDateTime)
                {
                    // For hour time scale, generate and commit records per month.
                    utcdatetime currentMonthEndDateTime = AVTimeframe::getTimeframe(startDateTime, AVTimeframeType::Month).end();
                    utcdatetime endDateTime = min(currentMonthEndDateTime, userDefineEndDateTime);
                    this.updateRollupForAllReosurcesOperationDetails(timescale, _removeAllExistingRecords, startDateTime, endDateTime);
                    startDateTime = ResUtil::getNextDateTimeByTimeScale(startDateTime, AVTimeframeType::Month);
                }
            }
            else if (timescale != AVTimeframeType::Hour)
            {
                this.updateRollupForAllReosurcesOperationDetails(timescale, _removeAllExistingRecords, userDefineStartDateTime, userDefineEndDateTime);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRollUpForSpecificActivityResourceIdOperation</Name>
				<Source><![CDATA[
    private void updateRollUpForSpecificActivityResourceIdOperation(utcdatetime _rangeStartDateTime, utcdatetime _rangeEndDateTime,
        activityResourceId _activityResourceId, boolean _cancelOperation, boolean _syncSpecificTimeScale = false, AVTimeframeType _syncTimeScaleType = AVTimeframeType::Day)
    {
        boolean isPlannedResource = ResUtil::isPlannedResourceFromActivityResourceId(_activityResourceId);
        activityresourcerecid activityResource = ResUtil::getActivityResourceRecId(_activityResourceId);
        ResourceRecId resource =  isPlannedResource ? 0 : ResUtil::getResourceRecId(_activityResourceId);

        // add the specify resource to rollup resources list
        this.getRollupResourceListForSpecificActivityResourceIdOperation(_rangeStartDateTime, _rangeEndDateTime, 
            activityResource, resource, isPlannedResource, _cancelOperation);

        ttsbegin;
        this.setupCalendarTable(_rangeStartDateTime, _rangeEndDateTime);
        ttscommit;

        if (_syncSpecificTimeScale)
        {
            // Generate roll-ups data for the specific time scale in synchronization process
            this.updateRollUpForSpecificActivityResourceIdByTimescale(_rangeStartDateTime, _rangeEndDateTime,
                _syncTimeScaleType, activityResource, isPlannedResource, resource);
            // Generate roll-ups data for the other time scale in asynchronization process
            container arguments = [activityResource, resource, isPlannedResource, _rangeStartDateTime,
                _rangeEndDateTime, _syncTimeScaleType, _cancelOperation, this.enableHourScheduling];
            Global::runAsync(classNum(ResRollUpWriter),
                staticMethodStr(ResRollUpWriter, updateRollUpForSpecificActivityResourceIdByExcludeSpecificTimeScaleAsync), arguments);
        }
        else
        {
			// update the specify activity resource scheduling data to the roll-up table        
			DictEnum        timescales = new DictEnum(enumNum(AVTimeframeType));
			int             values = timescales.values();
			for (int counter = 0; counter < values; counter++)
			{
			    AVTimeframeType timescale = timescales.index2Value(counter);
			    if (this.enableHourScheduling || timescale != AVTimeframeType::Hour )
			    {
                    this.updateRollUpForSpecificActivityResourceIdByTimescale(_rangeStartDateTime,
                        _rangeEndDateTime, timescale, activityResource, isPlannedResource, resource);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRollUpForSpecificActivityResourceIdByExcludeSpecificTimeScaleAsync</Name>
				<Source><![CDATA[
    private static void updateRollUpForSpecificActivityResourceIdByExcludeSpecificTimeScaleAsync(container _arguments, System.Threading.CancellationToken _cancellationToken)
    {
        if (_cancellationToken.Equals(System.Threading.CancellationToken::None))
        {
            ActivityResourceRecId activityResource = conPeek(_arguments, 1);
            ResourceRecId resource = conPeek(_arguments, 2);
            boolean isPlannedResource = conPeek(_arguments, 3);
            utcdatetime rangeStartDateTime = conPeek(_arguments, 4);
            utcdatetime rangeEndDateTime = conPeek(_arguments, 5);
            AVTimeframeType excludedTimescale = conPeek(_arguments, 6);
            boolean cancelOperation = conPeek(_arguments, 7);
            boolean enableHourSchedulingLocal = conPeek(_arguments, 8);

            // update the specify activity resource scheduling data to the roll-up table
            DictEnum timescales = new DictEnum(enumNum(AVTimeframeType));
            int values = timescales.values();
            for (int counter = 0; counter < values; counter++)
            {
                AVTimeframeType timescale = timescales.index2Value(counter);
                if (timescale != excludedTimescale && (enableHourSchedulingLocal || timescale != AVTimeframeType::Hour))
                {
                    rangeStartDateTime = AVTimeframe::getTimeframe(rangeStartDateTime, timescale).start();
                    rangeEndDateTime = AVTimeframe::getTimeframe(rangeEndDateTime, timescale).end();

                    ResRollupWriter rollupWriter = new resRollupWriter();
                    // add the specify planned resource to rollup resources list
                    rollupWriter.getRollupResourceListForSpecificActivityResourceIdOperation(rangeStartDateTime, rangeEndDateTime,
                            activityResource, resource, isPlannedResource, cancelOperation);

                    rollupWriter.updateRollUpForSpecificActivityResourceIdByTimescale(rangeStartDateTime, rangeEndDateTime,
                            timescale, activityResource, isPlannedResource, resource);
				}

			}
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRollupResourceListForSpecificActivityResourceIdOperation</Name>
				<Source><![CDATA[
    private void getRollupResourceListForSpecificActivityResourceIdOperation(utcdatetime _rangeStartDateTime, utcdatetime _rangeEndDateTime, 
        ActivityResourceRecId _activityResource, ResourceRecId _resource, boolean _isPlannedResource, boolean _cancelOperation)
    {
        if (_isPlannedResource)
        {
            if (_cancelOperation)
            {
                this.getCancelSpecificPlannedResource(_rangeStartDateTime, _rangeEndDateTime, _activityResource);
            }
            else
            {
                this.getSpecificPlannedResource(_rangeStartDateTime, _rangeEndDateTime, _activityResource);
            }
        }
        // add the specify resource to rollup resources list
        else
        {
            if (_cancelOperation)
            {
                this.getSpecificNamedResource(_rangeStartDateTime, _rangeEndDateTime, _resource);
            }
            else
            {
                this.getSpecificNamedResource(_rangeStartDateTime, _rangeEndDateTime, _resource);
                if (rollUpResourcesList.empty())
                {
                    this.getSpecificCompanyResource(curExt(), _rangeStartDateTime, _rangeEndDateTime, _resource);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRollUpForSpecificActivityResourceIdByTimescale</Name>
				<Source><![CDATA[
    private void updateRollUpForSpecificActivityResourceIdByTimescale(utcdatetime _rangeStartDateTime, utcdatetime _rangeEndDateTime, 
        AVTimeframeType _timescale, ActivityResourceRecId _activityResource, boolean _isPlannedResource, ResourceRecId _resource)
    {
        // First insert record to temp table.  Then copy data to ResRollup table after data processing is done.
        ResTmpRollUp tmpRollUp;
        ResRollUpWriter::skipDatabaseLogAndEvent(tmpRollUp);

        ResRollupActivityWriter activityWriter = ResRollupActivityWriter::construct();
        ResRollupAvailabilityWriter availabilityWriter = ResRollupAvailabilityWriter::construct();
        ResRollupAssignmentWriter assignmentWriter = ResRollupAssignmentWriter::construct();

        utcdatetime startDateTime = AVTimeframe::getTimeframe(_rangeStartDateTime, _timescale).start();
        utcdatetime endDateTime = AVTimeframe::getTimeframe(_rangeEndDateTime, _timescale).end();

        try
        {
            // insert all necessary roll-up records for all coverage level
            this.setupResourceRollUpTable(tmpRollUp, _timescale, startDateTime, endDateTime);

            // update roll-up records for all coverage level
            activityWriter.updateRollupTableWithLockedCapacityForActivityResource(tmpRollUp,
                _timescale, startDateTime, endDateTime, _activityResource);

            if (_isPlannedResource)
            {
                assignmentWriter.updateRollupTableWithAssignmentCapacityForPlannedResource(tmpRollUp,
                    _timescale, startDateTime, endDateTime, _activityResource);
            }
            else
            {
                availabilityWriter.updateRollupTableWithLockedCapacityForNamedResource(tmpRollUp,
                    _timescale, startDateTime, endDateTime, _resource);
                assignmentWriter.updateRollupTableWithLockedCapacityForNamedResource(tmpRollUp,
                    _timescale, startDateTime, endDateTime, _resource);
                assignmentWriter.updateRollupTableWithSubtractingEngagementLockedCapacityForNamedResource(tmpRollUp,
                    _timescale, startDateTime, endDateTime, _resource);
                assignmentWriter.updateRollUpTableWithEnagementAssignmentCapacityForNamedResource(tmpRollUp,
                    _timescale, startDateTime, endDateTime, _resource);
            }

            // update roll-up records remaining hours and status
            if (_isPlannedResource)
            {
                this.updateRemainingHoursAndStatusByActivityResource(tmpRollUp, _timescale, startDateTime, endDateTime, _activityResource);
                this.moveTmpDataToRollUpTable(tmpRollup, startDateTime, endDateTime, _timescale, _activityResource);
            }
            else
            {
                this.updateRemainingHoursAndStatusByResource(tmpRollUp, _timescale, startDateTime, endDateTime, _resource);
                this.moveTmpDataToRollUpTable(tmpRollup, startDateTime, endDateTime, _timescale, _activityResource, _resource);
            }
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
        catch(Exception::Error)
        {
            throw Exception::Error;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupRollUpForNewPlannedResourceOperation</Name>
				<Source><![CDATA[
    private void setupRollUpForNewPlannedResourceOperation(utcdatetime _rangeStartDateTime, utcdatetime _rangeEndDateTime,
        ActivityResourceId _activityResourceId)
    {
        // First insert record to temp table.  Then copy data to ResRollup table after data processing is done.
        ResTmpRollUp tmpRollUp;
        ResRollUpWriter::skipDatabaseLogAndEvent(tmpRollUp);

        ActivityResourceRecId activityResource = ResUtil::getActivityResourceRecId(_activityResourceId);

        // add the specify new planned resource to rollup resources list
        this.getSpecificPlannedResource(_rangeStartDateTime, _rangeEndDateTime, activityResource);
        this.setupCalendarTable(_rangeStartDateTime, _rangeEndDateTime);
        
        // setup the specify new planned resource to the roll-up table
        DictEnum    timescales = new DictEnum(enumNum(AVTimeframeType));
        int         values = timescales.values();
        for (int counter = 0; counter < values; counter++)
        {
            AVTimeframeType timescale = timescales.index2Value(counter);
            if (this.enableHourScheduling || timescale != AVTimeframeType::Hour)
            {
                utcdatetime startDateTime = AVTimeframe::getTimeframe(_rangeStartDateTime, timescale).start();
                utcdatetime endDateTime = AVTimeframe::getTimeframe(_rangeEndDateTime, timescale).end();
                this.setupResourceRollUpTable(tmpRollUp, timescale, startDateTime, endDateTime);
                this.moveTmpDataToRollUpTable(tmpRollup, startDateTime, endDateTime, timescale, activityResource);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupRollUpForNewResourceOperation</Name>
				<Source><![CDATA[
    private void setupRollUpForNewResourceOperation(DataAreaId _company, utcdatetime _rangeStartDateTime, 
        utcdatetime _rangeEndDateTime, ResourceRecId _resource)
    {
        // First insert record to temp table. Then copy data to ResRollup table after data processing is done.
        ResTmpRollUp tmpRollUp;
        ResRollUpWriter::skipDatabaseLogAndEvent(tmpRollUp);

        // add the specify new resource to rollup resources list
        this.getSpecificCompanyResource(_company, _rangeStartDateTime, _rangeEndDateTime, _resource);
        this.setupCalendarTable(_rangeStartDateTime, _rangeEndDateTime);
        
        // setup the specify new resource to the roll-up table
        DictEnum timescales = new DictEnum(enumNum(AVTimeframeType));
        int      values = timescales.values();
        for (int counter = 0; counter < values; counter++)
        {
            AVTimeframeType timescale = timescales.index2Value(counter);
            if (this.enableHourScheduling || timescale != AVTimeframeType::Hour)
            {
                utcdatetime startDateTime = AVTimeframe::getTimeframe(_rangeStartDateTime, timescale).start();
                utcdatetime endDateTime = AVTimeframe::getTimeframe(_rangeEndDateTime, timescale).end();
                this.setupResourceRollUpTable(tmpRollUp, timescale, startDateTime, endDateTime);
                this.moveTmpDataToRollUpTable(tmpRollup, startDateTime, endDateTime, timescale, 0, _resource);
            }
        }        
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeRollUpForSpecificActivityResourceIdOperation</Name>
				<Source><![CDATA[
    private void removeRollUpForSpecificActivityResourceIdOperation(ActivityResourceId _activityResourceId)
    {
        this.deleteResourceRollupTableByActivityResourceIdWithNoDateLimit(_activityResourceId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRollUpForAllResources</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update roll-up records for all resources, for all timescales.
    /// </summary>
    /// <param name = "_startDateTime">Start date time.</param>
    /// <param name = "_endDateTime">End date time.</param>
    /// <param name = "_removeAllExistingRecords">Whether all existing <c>ResRollup</c> table records should be removed.</param>
    public static void updateRollUpForAllResources(utcdatetime _startDateTime, utcdatetime _endDateTime, boolean _removeAllExistingRecords = false)
    {
        ResRollupWriter rollUpWriter = ResRollupWriter::construct();

        if (rollUpWriter.validateDateTimeInput(_startDateTime, _endDateTime))
        {
            rollUpWriter.updateRollUpForAllResourcesOperation(_startDateTime, _endDateTime, _removeAllExistingRecords);   
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRollUpForSpecificActivityResourceId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update roll-up records for the specified resource, for all timescales.
    /// </summary>
    /// <param name = "_activityResourceId">Activity resource ID for which this methods should update roll-up records.</param>
    /// <param name = "_startDateTime">Start date time.</param>
    /// <param name = "_endDateTime">End date time.</param>
    /// <param name = "_syncSpecificTimeScale">true to update a specific time scale in synchronous and the rest to run asynchronous; otherwise all time scale will run synchronously.</param>
    /// <param name = "_syncTimeScaleType">The specific time scale which will be run synchronously and the rest will be run in asynchronous.</param>
    public static void updateRollUpForSpecificActivityResourceId(activityResourceId _activityResourceId,
        utcdatetime _startDateTime, utcdatetime _endDateTime, boolean _syncSpecificTimeScale = false, AVTimeframeType _syncTimeScaleType = AVTimeframeType::Day)
    {
        ResRollupWriter rollUpWriter = ResRollupWriter::construct();

        rollUpWriter.updateRollUpForSpecificActivityResourceIdOperation(_startDateTime, _endDateTime, _activityResourceId, false, _syncSpecificTimeScale, _syncTimeScaleType);
               
        ListIterator li = new ListIterator(rollUpWriter.rollUpResourcesList);
        if (li.more())
        {
            li.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRollUpForSpecificActivityResourceIdAsync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update roll-up records for the specified resource, for all timescales.
    /// Method designed to be called asynchronously using Global::runAsync().
    /// </summary>
    /// <param name = "_arguments">Activity resource ID for which this methods should update roll-up records; start date time; end date time.</param>
    /// <param name = "_cancellationToken">Cancellation token.</param>
    public static void updateRollUpForSpecificActivityResourceIdAsync(
        container _arguments, System.Threading.CancellationToken _cancellationToken)
    {
        if (_cancellationToken.Equals(System.Threading.CancellationToken::None))
        {
            ActivityResourceId activityResourceId = conPeek(_arguments, 1);
            utcdatetime startDateTime = conPeek(_arguments, 2);
            utcdatetime endDateTime = conPeek(_arguments, 3);

            try
            {
                ResRollUpWriter::updateRollUpForSpecificActivityResourceId(activityResourceId, startDateTime, endDateTime, false);
            }
            catch (Exception::Deadlock)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::Deadlock;
                }
                else
                {
                    retry;
                }
            }
            catch (Exception::Error)
            {
                throw Exception::Error;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelRollUpForSpecificActivityResourceId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update roll-up records to cancel reservation for the specified resource, for all timescales.
    /// </summary>
    /// <param name = "_activityResourceId">Activity resource ID for which this methods should update existing roll-up records for reservation cancelation.</param>
    /// <param name = "_startDateTime">Start date time.</param>
    /// <param name = "_endDateTime">End date time.</param>
    /// <param name = "_syncSpecificTimeScale">true to update a specific time scale in synchronous and the rest to run asynchronous; otherwise all time scale will run synchronously.</param>
    /// <param name = "_syncTimeScaleType">The specific time scale which will be run synchronously and the rest will be run in asynchronous.</param>
    public static void cancelRollUpForSpecificActivityResourceId(activityResourceId _activityResourceId,
        utcdatetime _startDateTime, utcdatetime _endDateTime, boolean _syncSpecificTimeScale = false, AVTimeframeType _syncTimeScaleType = AVTimeframeType::Day)
    {
        ResRollupWriter rollUpWriter = ResRollupWriter::construct();

        rollUpWriter.updateRollUpForSpecificActivityResourceIdOperation(_startDateTime, _endDateTime, _activityResourceId, true, _syncSpecificTimeScale, _syncTimeScaleType);
        
        // remove the resources list elements
        ListIterator li = new ListIterator(rollUpWriter.rollUpResourcesList);
        if (li.more())
        {
            li.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelRollUpForSpecificActivityResourceIdAsync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update roll-up records to cancel reservation for the specified resource, for all timescales.
    /// Method designed to be called asynchronously using Global::runAsync().
    /// </summary>
    /// <param name = "_arguments">Activity resource ID for which this methods should update existing roll-up records for reservation cancelation; start date time; end date time.</param>
    /// <param name = "_cancellationToken">Cancellation token.</param>
    public static void cancelRollUpForSpecificActivityResourceIdAsync(
        container _arguments, System.Threading.CancellationToken _cancellationToken)
    {
        if (_cancellationToken.Equals(System.Threading.CancellationToken::None))
        {
            ActivityResourceId activityResourceId = conPeek(_arguments, 1);
            utcdatetime startDateTime = conPeek(_arguments, 2);
            utcdatetime endDateTime = conPeek(_arguments, 3);

            try
            {
                ResRollUpWriter::cancelRollUpForSpecificActivityResourceId(activityResourceId, startDateTime, endDateTime, false);
            }
            catch (Exception::Deadlock)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::Deadlock;
                }
                else
                {
                    retry;
                }
            }
            catch (Exception::Error)
            {
                throw Exception::Error;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupRollUpForNewResource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create new roll-up records for the specified staffed resource, for all timescales.
    /// </summary>
    /// <param name = "_resource">Staffed resource activity resource Id for which this methods should create new roll-up records.</param>
    /// <param name = "_startDateTime">Start date time.</param>
    /// <param name = "_endDateTime">End date time.</param>
    public static void setupRollUpForNewResource(ResourceRecId _resource, 
        utcdatetime _startDateTime, utcdatetime _endDateTime)
    {
        ResRollupWriter rollUpWriter = ResRollupWriter::construct();

        ttsbegin;
        rollUpWriter.setupRollUpForNewResourceOperation(curExt(), _startDateTime, _endDateTime, _resource);
        ttscommit;

        // remove the resources list elements
        ListIterator li = new ListIterator(rollUpWriter.rollUpResourcesList);
        if (li.more())
        {
            li.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupRollUpForNewResourceAsync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create new roll-up records for the specified staffed resource, for all timescales.
    /// Method designed to be called asynchronously using Global::runAsync().
    /// </summary>
    /// <param name = "_arguments">Staffed resource activity resource ID for which this methods should create new roll-up records; start date time; end date time.</param>
    /// <param name = "_cancellationToken">Cancellation token.</param>
    public static void setupRollUpForNewResourceAsync(
        container _arguments, System.Threading.CancellationToken _cancellationToken)
    {
        if (_cancellationToken.Equals(System.Threading.CancellationToken::None))
        {
            ResourceRecId resource = conPeek(_arguments, 1);
            utcdatetime startDateTime = conPeek(_arguments, 2);
            utcdatetime endDateTime = conPeek(_arguments, 3);

            try
            {
                ResRollUpWriter::setupRollUpForNewResource(resource, startDateTime, endDateTime);
            }
            catch (Exception::Deadlock)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::Deadlock;
                }
                else
                {
                    retry;
                }
            }
            catch (Exception::Error)
            {
                throw Exception::Error;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupRollUpForNewPlannedResource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create new roll-up records for the specified planned resource, for all timescales.
    /// </summary>
    /// <param name = "_activityResourceId">Planned resource activity resource ID for which this methods should create new roll-up records.</param>
    /// <param name = "_startDateTime">Start date time.</param>
    /// <param name = "_endDateTime">End date time.</param>
    public static void setupRollUpForNewPlannedResource(activityresourceid  _activityResourceId,
        utcdatetime _startDateTime, utcdatetime _endDateTime)
    {
        ResRollupWriter rollUpWriter = ResRollupWriter::construct();

        rollUpWriter.setupRollUpForNewPlannedResourceOperation(_startDateTime, _endDateTime, _activityResourceId);

        // remove the resources list elements
        ListIterator li = new ListIterator(rollUpWriter.rollUpResourcesList);
        if (li.more())
        {
            li.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupRollUpForNewPlannedResourceAsync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create new roll-up records for the specified planned resource, for all timescales.
    /// Method designed to be called asynchronously using Global::runAsync().
    /// </summary>
    /// <param name = "_arguments">Planned resource activity resource ID for which this methods should create new roll-up records; start date time; end date time.</param>
    /// <param name = "_cancellationToken">Cancellation token.</param>
    public static void setupRollUpForNewPlannedResourceAsync(container _arguments, System.Threading.CancellationToken _cancellationToken)
    {
        if (_cancellationToken.Equals(System.Threading.CancellationToken::None))
        {
            activityResourceId activityResourceId = conPeek(_arguments, 1);
            utcdatetime startDateTime = conPeek(_arguments, 2);
            utcdatetime endDateTime = conPeek(_arguments, 3);

            try
            {
                ResRollUpWriter::setupRollUpForNewPlannedResource(activityResourceId, startDateTime, endDateTime);
            }
            catch (Exception::Deadlock)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::Deadlock;
                }
                else
                {
                    retry;
                }
            }
            catch (Exception::Error)
            {
                throw Exception::Error;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeRollUpForSpecificActivityResourceId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove roll-up records for the specified resource, for all timescales.
    /// </summary>
    /// <param name = "_activityResourceId">Activity resource ID for which this methods should remove all roll-up records.</param>
    public static void removeRollUpForSpecificActivityResourceId(activityResourceId _activityResourceId)
    {
        ResRollupWriter rollUpWriter = ResRollupWriter::construct();

        rollUpWriter.removeRollUpForSpecificActivityResourceIdOperation(_activityResourceId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeRollUpForSpecificActivityResourceIdAsync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove roll-up records for the specified resource, for all timescales.
    /// Method designed to be called asynchronously using Global::runAsync().
    /// </summary>
    /// <param name = "_arguments">Activity resource ID for which this methods should remove all roll-up records.</param>
    /// <param name = "_cancellationToken">Cancellation token.</param>
    public static void removeRollUpForSpecificActivityResourceIdAsync(
        container _arguments, System.Threading.CancellationToken _cancellationToken)
    {
        if (_cancellationToken.Equals(System.Threading.CancellationToken::None))
        {
            activityResourceId activityResourceId = conPeek(_arguments, 1);
        
            try
            {
                ResRollUpWriter::removeRollUpForSpecificActivityResourceId(activityResourceId);
            }
            catch (Exception::Deadlock)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::Deadlock;
                }
                else
                {
                    retry;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeAndUpdateRollUpForSpecificActivityResourceIdAsync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove existing records and add roll-up records for the specified resource, for all timescales.
    /// Method designed to be called asynchronously using Global::runAsync().
    /// This method is used when a resource has change to a different calendar.
    /// </summary>
    /// <param name = "_arguments">Activity resource ID for which this methods should update roll-up records; start date time; end date time.</param>
    /// <param name = "_cancellationToken">Cancellation token.</param>
    public static void removeAndUpdateRollUpForSpecificActivityResourceIdAsync(
        container _arguments, System.Threading.CancellationToken _cancellationToken)
    {
        if (_cancellationToken.Equals(System.Threading.CancellationToken::None))
        {
            ActivityResourceId activityResourceId = conPeek(_arguments, 1);
            utcdatetime startDateTime = conPeek(_arguments, 2);
            utcdatetime endDateTime = conPeek(_arguments, 3);

            try
            {
                ResRollUpWriter::removeRollUpForSpecificActivityResourceId(activityResourceId);
                ResRollUpWriter::updateRollUpForSpecificActivityResourceId(activityResourceId, startDateTime, endDateTime, false);
            }
            catch (Exception::Deadlock)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::Deadlock;
                }
                else
                {
                    retry;
                }
            }
            catch (Exception::Error)
            {
                throw Exception::Error;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDateTimeInput</Name>
				<Source><![CDATA[
    private boolean validateDateTimeInput(utcdatetime _startDateTime, utcdatetime _endDateTime)
    {
        boolean result = true;

        if (_startDateTime > _endDateTime)
        {
            date startDate = datetimeUtil::date(_startDateTime);
            str startDateTimeStr = strFmt("@Res:FullDateFormatWithTime",
                dayName(dayOfWk(startDate)),
                date2StrUsr(startDate, DateFlags::FormatAll),
                time2Str(DateTimeUtil::time(_startDateTime), TimeSeparator::Auto, TimeFormat::Auto));

            date endDate = datetimeUtil::date(_endDateTime);
            str endDateTimeStr = strFmt("@Res:FullDateFormatWithTime",
                dayName(dayOfWk(endDate)),
                date2StrUsr(endDate, DateFlags::FormatAll),
                time2Str(DateTimeUtil::time(_endDateTime), TimeSeparator::Auto, TimeFormat::Auto));

            result = checkFailed(strFmt("@Res:StartDateTimeComparisonError", startDateTimeStr, endDateTimeStr));
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipDatabaseLogAndEvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Skip data base log and event to improve performance.
    /// </summary>
    /// <param name = "_table">The specify table buffer.</param>
    public static void skipDatabaseLogAndEvent(Common _table)
    {
        // Skip database log is set to true in code. These are performance cache data which 
        // are neither master or transaction data. There is no value for our user to log it.
        _table.skipDatabaseLog(true);
        _table.skipEvents(true);
        _table.skipDataMethods(true);
        _table.skipDeleteMethod(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of roll-up writer.
    /// </summary>
    protected void new ()
    {
        super();
        rollUpResourcesList = new List(Types::Class);
        calendarSet = new Set(Types::Int64);
        enableHourScheduling = ResUtil::getEnableHourSchedulingSetting();
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new instance of roll-up writer.
    /// </summary>
    /// <returns>Roll-up writer object.</returns>
    public static ResRollupWriter construct()
    {
        ResRollupWriter writer = new ResRollupWriter();
        return writer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTruncateSQLStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get truncate table SQL statement for the specific table. This truncate statement will only execute if the table has data in only one partition.
    /// </summary>
    /// <param name = "_truncateTableName">Specific table name to be truncate.</param>
    /// <returns>Truncate table SQL statement string.</returns>
    private static str getTruncateSQLStatement(str _truncateTableName)
    {
        return 'DECLARE @TotalPartition integer; ' +
            'SET @TotalPartition = (select COUNT(*) OVER () AS TotalRecords ' +
            'FROM '  + _truncateTableName + ' T1 GROUP BY T1.Partition); ' +
            'IF @totalPartition = 1 ' +
            'TRUNCATE TABLE ' + _truncateTableName + ';';
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeSQLStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Execute SQL statement.
    /// </summary>
    /// <param name = "_statement">SQL statement string.</param>
    private static void executeSQLStatement(str _statement)
    {
        ttsbegin;
        Connection userConnection = new Connection();
        Statement stmt = userConnection.createStatement();
        new SqlStatementExecutePermission(_statement).assert();
        stmt.executeUpdate(_statement);
        CodeAccessPermission::revertAssert();
        ttscommit;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>