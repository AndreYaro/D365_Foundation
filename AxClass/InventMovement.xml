<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventMovement</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>InventMovement</c> class is the data carrier to use when updating inventory transactions.
/// </summary>
/// <remarks>
///  Typically this class holds a buffer which could be a sales or a purchase order line or a line from
///  an inventory journal. The
///  <c>
///  InventMovement
///  </c>
///   class hierarchy is closely connected to the
///  <c>
///  InventUpdate
///  </c>
///   class. The
///  <c>
///  InventUpdate
///  </c>
///   class is the engine that brings inventory transactions from one status to another and the
///  <c>
///  InventMovement
///  </c>
///   class is the data carrier to use when updating inventory transactions. It is important to remember
///  the behavior of transactions and that special handling must be implemented on the
///  <c>
///  InventMovement
///  </c>
///   class and not be included in the
///  <c>
///  InventUpdate
///  </c>
///   engine, which should stay generic. The
///  <c>
///  InventMovement
///  </c>
///   classes are as follows:
///  <list type="table">
///   <item>
///    <description>
///    <c>InventMov_Jour_BOM</c>
///    </description>
///    <description>
///    An inventory BOM journal.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_Jour_BOMLine</c>
///    </description>
///    <description>
///    An inventory BOM journal.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_Jour_Loss_Project</c>
///    </description>
///    <description>
///    A project item journal.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_Jour_Loss_SumUp</c>
///    </description>
///    <description>
///    An inventory counting journal.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_Jour_LossProfit</c>
///    </description> <description />
///   </item>
///   <item>
///    <description>
///    <c>InventMov_Jour_Movement</c>
///    </description>
///    <description>
///    An inventory movement journal.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_Jour_Transfer</c>
///    </description>
///    <description>
///    An inventory transfer journal.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_Jour_TransferIssue</c>
///    </description>
///    <description>
///    An inventory transfer journal.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_Jour_TransferReceipt</c>
///    </description>
///    <description>
///    An inventory transfer journal.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_Journal</c>
///    </description>
///    <description>
///    An inventory journal.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_KanbanEmpty</c>
///    </description>
///    <description>
///    A kanban.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_KanbanJob</c>
///    </description>
///    <description>
///    A kanban job.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_KanbanJob_Process</c>
///    </description>
///    <description>
///    A process kanban job.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_KanbanJob_Tranfer</c>
///    </description>
///    <description>
///    A transfer kanban job.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_KanbanJob_TransReceipt</c>
///    </description>
///    <description>
///    A transfer kanban job receipt.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_KanbanJob_TransIssue</c>
///    </description>
///    <description>
///    A transfer kanban job issue.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_KanbanJob_ProfitLoss</c>
///    </description>
///    <description>
///    A profit or loss kanban job.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_KanbanJobPickingList</c>
///    </description>
///    <description>
///    A kanban job picking list.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_Prod</c>
///    </description>
///    <description>
///    A production table.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_Prod_JournalProd</c>
///    </description>
///    <description>
///    A production report finished journal.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_ProdLine</c>
///    </description>
///    <description>
///    A production BOM line.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_ProdLine_JournalBOM</c>
///    </description>
///    <description>
///    A production picking list journal.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_ProjItemTrans</c>
///    </description> <description />
///   </item>
///   <item>
///    <description>
///    <c>InventMov_Purch</c>
///    </description>
///    <description>
///    A purchase order.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_Quarantine</c>
///    </description>
///    <description>
///    A quarantine order issue.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_QuarantineInvent</c>
///    </description>
///    <description>
///    A quarantine order receipt.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_Sales</c>
///    </description>
///    <description>
///    A sales order.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_Sales_JournalPickingList</c>
///    </description>
///    <description>
///    A sales order picking list.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_SalesQuotation</c>
///    </description>
///    <description>
///    A sales quotation.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_TransferFrom</c>
///    </description>
///    <description>
///    An inventory transfer order.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_TransferTo</c>
///    </description>
///    <description>
///    An inventory transfer order.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_TransferTransitFrom</c>
///    </description>
///    <description>
///    An inventory transfer order.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_TransferTransitTo</c>
///    </description>
///    <description>
///    An inventory transfer order.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_Vir_Counting</c>
///    </description> <description />
///   </item>
///   <item>
///    <description>
///    <c>InventMov_Vir_QuarantineLoss</c>
///    </description> <description />
///   </item>
///   <item>
///    <description>
///    <c>InventMov_Vir_Transfer</c>
///    </description> <description />
///   </item>
///   <item>
///    <description>
///    <c>InventMov_Virtuel</c>
///    </description>
///    <description>
///    An update without a buffer.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_WMSOrder</c>
///    </description>
///    <description>
///    A warehouse output order.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_WMSTransport</c>
///    </description>
///    <description>
///    A warehouse transport.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_WMSTransportIssue</c>
///    </description>
///    <description>
///    A warehouse transport issue.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_WMSTransportReceipt</c>
///    </description>
///    <description>
///    A warehouse transport receipt.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_WHSOrderCommittedReservation</c>
///    </description>
///    <description>
///    An order committed reservation.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>WHSInventMov_InventoryAdjustmentJournalLine</c>
///    </description>
///    <description>
///    A warehouse inventory adjustment journal line.
///    </description>
///   </item>
///  </list>
/// </remarks>
abstract public class InventMovement
{
    Common                      buffer;
    InventType                  inventType;

    InventTransIdSum            transIdSum;
    InventTransIdSum            transIdSumTransId;
    InventDimGroupSetup         inventDimGroupSetup;

    LedgerDimensionDefaultAccount   cacheAccountBalanceSheet;
    LedgerDimensionDefaultAccount   cacheAccountOperations;

    LedgerDimensionDefaultAccount    cacheAccountPhysical;
    LedgerDimensionDefaultAccount    cacheOffsetAccountPhysical;
    InventITransConsistencyValidator consistencyValidator;

    InventMovSubType            subType;

    InventTable                 inventTable;
    InventModelGroup            inventModelGroup;
    InventModelType             inventModelType;

    // <GEERU>
    InventModelType             inventModelTypeSecCur;
    // </GEERU>

    InventDim                   inventDim;

    // cache of inventory dimension flags that are fixed for marking
    InventDimParm               markingInventDimParmFixed;
    boolean                     markingInventDimParmFixedCached;

    Map                         inventDimCostPrice;

    // <GEERU>
    Map                         inventDimCostPriceSecCur;
    // </GEERU>

    ProjAdjustRefId             projAdjustRefId;

    NoYes                       mustBeQuarantineControled;
    NoYes                       mustBeQuarantineControledInitialized;
    NoYes                       mustDoAutoLossProfitForbid;
    //if mustNotReduceForecast is true, forecast should not be reduced again in projPost
    NoYes                       mustNotReduceForecast;

    UnknownNoYes                bookedPhysically;
    UnknownNoYes                bookedPhysicalRevenue;

    QuotationType               quotationCallerType;

    InventTransOriginId         inventTransOriginIdRef_virtuel;

    InventTransOriginId         inventTransOriginId;

    InventTransOriginId         inventTransOriginIdOriginalProject;

    boolean                     projectReturnIssue;
    boolean                     projectReturnReceipt;

    InventSiteDimensionCheck    inventSiteDimensionCheck;

    Set inventTransVirtualSet = new Set(Types::Int64);

    // Variance list for inventory cost breakdown
    InventCostTransVarianceList inventCostTransVarianceList;

    //cache of item group ID
    ItemGroupId                 itemGroupId;

    InventCostIndirectPhysical  inventCostIndirectPhysical;
    InventCostIndirectFinancial inventCostIndirectFinancial;

    //indicates whether ledger posting is to be done using distributions and subledgerjournal lines
    boolean                     distributionLedgerPosting;

    // The dimension change on the movement may result in dimension update action on the related reservation
    // transactions. Some reservations may be removed due to insufficient on-hand for the new dimensions
    // Such reservation transactions updates the Issue status from Reserved Physical or Reserved Ordered to On-Order status.
    // This variable holds the total quantity which cannot be reserved due to dimension change on the movement.
    InventQty                   releasedReservationQty;

    boolean                 burdenItem;
    boolean                 pdsUseBAForRes;

    PDSBaseValue            pdsBaseValue;

    boolean                 pdsCWItem;
    boolean                 pdsCWItemInitialized;

    UnknownNoYes            isItemWHSEnabled;
    UnknownNoYes            mustConsiderBatchProcessing;

    InventDimId                 lastDimIdForinventItemOrderSetupMapSearch; //used for caching of inventItemOrderSetupMap
    InventItemOrderSetupMap     inventItemOrderSetupMap;

    // <GEERU>
    Storno_RU                   storno;
    InventTransOriginId         markingRefInventTransOrigin_RU;
    UnknownNoYes                returnedSpecialCheckUpdate;
    NoYes                       forceReturnLotInInventTrans_RU;

    boolean                     goodsInRoute;
    InventTransId               inventTransIdTransit;
    InventTransId               inventTransIdDelivery;
    Storno_RU                   stornoPhysical;
    boolean                     stornoPhysicalForced;
    InventRefTransId            inventRefTransId_RU;
    InventDim                   physicalInventDimCriteria;
    InventDimParm               physicalInventDimParmCriteria;

    CostAmount                  indirectCostAmount, indirectCostAmountSecCur;
    // </GEERU>
    // <GEERU><GIN>
    #ISOCountryRegionCodes
    // </GIN></GEERU>

    // <GIN>
    TaxAmountCur                customsLoadOnInventoryMST;
    TaxAmountCur                customsLoadOnInventory;
    ParmId                      parmId;
    // </GIN>
    // <GEEU>
    LedgerCorrection            adjustCorrection;
    // </GEEU>

    boolean                     salesPackingSlipJournalPostProj;
    TransDate                   exchangeRateDate;
    Voucher                     voucher;
    RecId                       inventTransRecId;
    container                   deliveryLeadTime;
    boolean                     returnMode;

    // These should not be used directly but by corresponding methods.
    private CompanyCountryRegion    companyCountryRegion;
    private RecordSortedList        physicalLedgerAmountList;
    private UnknownNoYes            whsIsReservationOnDemandOrderEnabledOnAnyDimension;
    private InventDim               inventBlockingStatusSyncInventDim;

    boolean                     autoReserveInventQty;
    private boolean             skipAutoReservationWhenAdjustingCatchWeight; // Prevent autoreservation for catch weight items when weight is being adjusted.
    
    DateInvent                  dateRegistration;
    boolean                     skipCheckPickComplete;
    protected boolean isTelemetryForStornoSent;
    protected boolean isTelemetryForSecCurSent;
    protected PackingSlipId packingSlipId;

    //<GTE>
    TaxEngineInventMovement     taxEngineInventMovement;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canLinkToRegisteredReturns</Name>
				<Source><![CDATA[
    //</GTE>

    /// <summary>
    /// Determines if the movement allows returns to be linked to registered transactions.
    /// </summary>
    /// <returns>true if the movement allow returns to be linked to registered transactions; otherwise, false.</returns>
    public boolean canLinkToRegisteredReturns()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAutoReserveOnOrderChangeInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the <c>InventMovement</c> instance, such as a <c>salesLine</c>, can be reserved again
    ///    for On-Order transaction when changing dimension.
    /// </summary>
    /// <returns>
    ///    true if the <c>InventMovement</c> instance can be reserved again for On-Order transaction when changing dimension; otherwise, false.
    /// </returns>
    public boolean canAutoReserveOnOrderChangeInventDim()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowInventoryUpdateWhenInventTransIdIsEmpty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the movement check whether InventTransId is empty.
    /// </summary>
    /// <returns>true if the movement doesn't check whether InventTransId is empty; otherwise, false.</returns>
    public boolean allowInventoryUpdateWhenInventTransIdIsEmpty()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountBalanceAutoLossProfit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Changes an account based on the <c>InventIssue</c> enumeration value to the <c>InventIssueFA</c>
    ///    enumeration value when a fixed asset is set.
    /// </summary>
    /// <param name="_qty">
    ///    An <c>InventQty</c> type variable that specifies the quantity.
    /// </param>
    /// <returns>
    ///    A ledger account for a particular account type.
    /// </returns>
    /// <remarks>
    ///    If the <c>InventIssueFA</c> does not have an account specified the account will revert to being
    ///    based on the <c>InventIssue</c>.
    /// </remarks>
    public LedgerDimensionDefaultAccount accountBalanceAutoLossProfit(InventQty _qty)
    {
        LedgerDimensionDefaultAccount ledgerAccount;

        if (this.parmCompanyCountryRegion().isCountryRegionRU())
        {
            if (_qty >= 0)
            {
                ledgerAccount = InventPosting::itemLedgerDimensionFromParameter(this.createInventPostingItemLedgerDimensionParameters(InventAccountType::InventReceipt));
            }
            else
            {
                if (this.assetId())
                {
                    ledgerAccount = InventPosting::itemLedgerDimensionFromParameter(this.createInventPostingItemLedgerDimensionParameters(InventAccountType::InventIssueFixedAsset));
                }

                if (!ledgerAccount)
                {
                    ledgerAccount = InventPosting::itemLedgerDimensionFromParameter(this.createInventPostingItemLedgerDimensionParameters(InventAccountType::InventIssue));
                }
            }
        }
        else
        {
            if (_qty >= 0)
            {
                if (InventPostingExtendParm_CN::checkExtendParmEnabled())
                {
                    ledgerAccount = InventPosting::itemExtendParm_CN(
                        InventAccountType::InventReceipt,
                        InventPostingExtendParm_CN::constructInventDim(this.inventdim()),
                        this.itemId(),
                        this.inventTable().itemGroupId());
                }
                else
                {
                    ledgerAccount = InventPosting::itemLedgerDimensionFromParameter(this.createInventPostingItemLedgerDimensionParameters(InventAccountType::InventReceipt));
                }
            }
            else
            {
                if (this.assetId())
                {
                    ledgerAccount = InventPosting::itemLedgerDimensionFromParameter(this.createInventPostingItemLedgerDimensionParameters(InventAccountType::InventIssueFixedAsset));
                }

                if (!ledgerAccount)
                {
                    if (InventPostingExtendParm_CN::checkExtendParmEnabled())
                    {
                        ledgerAccount = InventPosting::itemExtendParm_CN(
                            InventAccountType::InventIssue,
                            InventPostingExtendParm_CN::constructInventDim(this.inventdim()),
                            this.itemId(),
                            this.inventTable().itemGroupId());
                    }
                    else
                    {
                        ledgerAccount = InventPosting::itemLedgerDimensionFromParameter(this.createInventPostingItemLedgerDimensionParameters(InventAccountType::InventIssue));
                    }
                }
            }
        }

        return ledgerAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountBalanceSheet</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountBalanceSheet()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountCharge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the charge ledger account.
    /// </summary>
    /// <returns>
    /// The charge ledger account.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Method must be overridden.
    /// </exception>
    public LedgerDimensionDefaultAccount accountCharge()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountOperations</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountOperations()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountOperationsAutoLossProfit</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountOperationsAutoLossProfit(InventQty _qty)
    {
        if (_qty >= 0)
        {
            return InventPosting::itemLedgerDimensionFromParameter(this.createInventPostingItemLedgerDimensionParameters(InventAccountType::InventProfit));
        }

        return InventPosting::itemLedgerDimensionFromParameter(this.createInventPostingItemLedgerDimensionParameters(InventAccountType::InventLoss));
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountPhysical</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountPhysical()
    {
        if (this.mustBeBookedPhysically())
        {
            throw error(Error::missingOverload(funcName()));
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountPhysicalRevenue</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountPhysicalRevenue()
    {
        if (this.mustBeBookedPhysicalRevenue())
        {
            throw error(Error::missingOverload(funcName()));
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountPhysicalRevenueOffset</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountPhysicalRevenueOffset()
    {
        if (this.mustBeBookedPhysicalRevenue())
        {
            throw error(Error::missingOverload(funcName()));
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountPhysicalTax</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountPhysicalTax()
    {
        if (this.mustBeBookedPhysicalTax())
        {
            throw error(Error::missingOverload(funcName()));
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountStdLoss</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountStdLoss()
    {
        if (InventPostingExtendParm_CN::checkExtendParmEnabled())
        {
            return InventPosting::itemExtendParm_CN(
                InventAccountType::InventStdLoss,
                InventPostingExtendParm_CN::constructInventDim(this.inventdim()),
                this.itemId(),
                this.inventTable().itemGroupId());
        }
        
        return InventPosting::itemLedgerDimensionFromParameter(this.createInventPostingItemLedgerDimensionParameters(InventAccountType::InventStdLoss));
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountStdOffset</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountStdOffset()
    {
        return this.accountBalanceSheet();
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountStdProfit</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountStdProfit()
    {
        if (InventPostingExtendParm_CN::checkExtendParmEnabled())
        {
            return InventPosting::itemExtendParm_CN(
                InventAccountType::InventStdProfit,
                InventPostingExtendParm_CN::constructInventDim(this.inventdim()),
                this.itemId(),
                this.inventTable().itemGroupId());
        }
            
        return InventPosting::itemLedgerDimensionFromParameter(this.createInventPostingItemLedgerDimensionParameters(InventAccountType::InventStdProfit));
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountStockVariation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the stock variation ledger account.
    /// </summary>
    /// <returns>
    /// The stock variation ledger account.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Method must be overridden.
    /// </exception>
    public LedgerDimensionDefaultAccount accountStockVariation()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>physicalLedgerAmountList</Name>
				<Source><![CDATA[
    private RecordSortedList physicalLedgerAmountList()
    {
        if (!physicalLedgerAmountList)
        {
            physicalLedgerAmountList = new RecordSortedList(tableNum(LedgerPostingTransactionTmp));
            physicalLedgerAmountList.sortOrder(
                            fieldNum(LedgerPostingTransactionTmp, PostingType),
                            fieldNum(LedgerPostingTransactionTmp, LedgerDimension)
                            );
        }
         
        return physicalLedgerAmountList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerPhysicalAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a ledger posting transaction record for physical amount.
    /// </summary>
    /// <param name = "_ledgerPostingType">The ledger posting type.</param>
    /// <param name = "_ledgerDimensionAccount">The ledger dimension account.</param>
    /// <param name = "_accountingCurrencyAmount">The amount in accounting currency for posting.</param>
    protected void addLedgerPhysicalAmounts(
                LedgerPostingType      _ledgerPostingType,
                LedgerDimensionAccount  _ledgerDimensionAccount,
                AmountMSTDebCred        _accountingCurrencyAmount
                )
    {
        RecordSortedList            list = this.physicalLedgerAmountList();
        LedgerPostingTransactionTmp transaction;

        transaction.PostingType                 = _ledgerPostingType;
        transaction.LedgerDimension             = _ledgerDimensionAccount;

        if (!list.find(transaction))
        {
            transaction.clear();
            transaction.PostingType        = _ledgerPostingType;
            transaction.LedgerDimension    = _ledgerDimensionAccount;
        }

        this.updateLedgerPostingTransactionTmpFields(transaction, _accountingCurrencyAmount);
        
        list.ins(transaction, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerPostingTransactionTmpFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates fields on the ledger posting transaction temp record.
    /// </summary>
    /// <param name="_transaction">
    /// The ledger posting transaction temp record which is to be updated.
    /// </param>
    /// <param name="_accountingCurrencyAmount">
    /// The account currency amount for the ledger posting transaction temp record.
    /// </param>
    protected void updateLedgerPostingTransactionTmpFields(LedgerPostingTransactionTmp _transaction, AmountMSTDebCred _accountingCurrencyAmount)
    {
        _transaction.AccountingCurrencyAmount += _accountingCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processLedgerPhysicalAmountList</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Processes the <c>LedgerPostingTransactionTmp</c> table records, stored in the <c>RecordSortedList</c> object.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///     The <c>LedgerVoucher</c> class object where the ledger transactions are added.
    /// </param>
    public void processLedgerPhysicalAmountList(LedgerVoucher _ledgerVoucher)
    {
        LedgerPostingTransactionTmp transaction;
        RecordSortedList            list = this.physicalLedgerAmountList();
        
        CurrencyCode                standardCurrencyCode;
        LedgerVoucherObject         ledgerVoucherObject;
        CurrencyExchangeHelper      currencyExchHelper;
        boolean                     recordExists;
        
        for (recordExists = list.first(transaction); recordExists; recordExists = list.next(transaction))
        {
            if (!ledgerVoucherObject)
            {
                ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
                standardCurrencyCode = CompanyInfoHelper::standardCurrency();
                currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
            }

            LedgerVoucherTransObject ledgerVoucherTransObject = 
                this.initializeLedgerVoucherTransPostingTransactionTmp(
                    ledgerVoucherObject,
                    transaction.PostingType,
                    transaction.LedgerDimension,
                    standardCurrencyCode,
                    transaction.AccountingCurrencyAmount,
                    currencyExchHelper,
                    transaction);

            _ledgerVoucher.addTrans(ledgerVoucherTransObject);

            // Clear the record which has been posted to ledger voucher
            list.del(transaction);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerVoucherTransObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>LedgerVoucherTransObject</c> class.
    /// </summary>
    /// <param name="_ledgerVoucherObject">
    /// The ledger posting reference to use for defaulting.
    /// </param>
    /// <param name="_postingType">
    /// The posting type of the general journal entry.
    /// </param>
    /// <param name="_ledgerDimensionId">
    /// The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name="_standardCurrencyCode">
    /// The currency code of the general journal entry.
    /// </param>
    /// <param name="_transactionCurrencyAmount">
    /// The amount in the transaction currency.
    /// </param>
    /// <param name="_currencyExchHelper">
    /// The accounting currency amount and secondary currency amount exchange rates.
    /// </param>
    /// <returns>
    /// A new instance of the <c>LedgerVoucherTransObject</c> class.
    /// </returns>
    protected LedgerVoucherTransObject createLedgerVoucherTransObject(
        LedgerVoucherObject _ledgerVoucherObject,
        LedgerPostingType _postingType,
        LedgerDimensionAccount _ledgerDimensionId,
        CurrencyCode _standardCurrencyCode,
        Money _transactionCurrencyAmount,
        CurrencyExchangeHelper _currencyExchHelper)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = InventoryReportingCurrencyTriangulationHelper::createLedgerVoucherTransObject(
                    _ledgerVoucherObject,
                    _postingType,
                    _ledgerDimensionId,
                    _standardCurrencyCode,
                    _transactionCurrencyAmount,
                    _currencyExchHelper);

        this.updateFinTag(ledgerVoucherTransObject);

        return ledgerVoucherTransObject;

    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLedgerVoucherTransPostingTransactionTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>LedgerVoucherTransObject</c> class.
    /// </summary>
    /// <param name="_ledgerVoucherObject">
    /// The ledger posting reference to use for defaulting.
    /// </param>
    /// <param name="_postingType">
    /// The posting type of the general journal entry.
    /// </param>
    /// <param name="_ledgerDimensionId">
    /// The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name="_standardCurrencyCode">
    /// The currency code of the general journal entry.
    /// </param>
    /// <param name="_transactionCurrencyAmount">
    /// The amount in the transaction currency.
    /// </param>
    /// <param name="_currencyExchHelper">
    /// The accounting currency amount and secondary currency amount exchange rates.
    /// </param>
    /// <param name="_transaction">
    /// The <c>LedgerPostingTransactionTmp</c> that carries general journal entry information.
    /// </param>
    /// <returns>
    /// A new instance of the <c>LedgerVoucherTransObject</c> class.
    /// </returns>
    protected LedgerVoucherTransObject initializeLedgerVoucherTransPostingTransactionTmp(
        LedgerVoucherObject _ledgerVoucherObject,
        LedgerPostingType _postingType,
        LedgerDimensionAccount _ledgerDimensionId,
        CurrencyCode _standardCurrencyCode,
        Money _transactionCurrencyAmount,
        CurrencyExchangeHelper _currencyExchHelper,
        LedgerPostingTransactionTmp _transaction)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = InventoryReportingCurrencyTriangulationHelper::createLedgerVoucherTransObject(
                    _ledgerVoucherObject,
                    _postingType,
                    _ledgerDimensionId,
                    _standardCurrencyCode,
                    _transactionCurrencyAmount,
                    _currencyExchHelper);

        this.updateFinTag(ledgerVoucherTransObject);
        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerVoucherTransObjectForFinancialUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>LedgerVoucherTransObject</c> class.
    /// </summary>
    /// <param name="_ledgerVoucherObject">
    /// The ledger posting reference to use for defaulting.
    /// </param>
    /// <param name="_postingType">
    /// The posting type of the general journal entry.
    /// </param>
    /// <param name="_ledgerDimensionId">
    /// The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name="_standardCurrencyCode">
    /// The currency code of the general journal entry.
    /// </param>
    /// <param name="_transactionCurrencyAmount">
    /// The amount in the transaction currency.
    /// </param>
    /// <param name="_currencyExchHelper">
    /// The accounting currency amount and secondary currency amount exchange rates.
    /// </param>
    /// <param name="_inventTrans">
    /// An inventory transaction.
    /// </param>
    /// <returns>
    /// A new instance of the <c>LedgerVoucherTransObject</c> class.
    /// </returns>
    [SuppressBpWarning("BPParameterNotUsed", "Parameter _inventTrans is used by extensions that wrap this method.")]
    protected LedgerVoucherTransObject createLedgerVoucherTransObjectForFinancialUpdate(
        LedgerVoucherObject    _ledgerVoucherObject,
        LedgerPostingType      _postingType,
        LedgerDimensionAccount _ledgerDimensionId,
        CurrencyCode           _standardCurrencyCode,
        Money                  _transactionCurrencyAmount,
        CurrencyExchangeHelper _currencyExchHelper,
        InventTrans            _inventTrans)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject;

        InventTransPosting inventTransPosting = _inventTrans.inventTransPostingPhysical();

         // For reverse
        if (InventoryReportingCurrencyTriangulationFeature::instance().isEnabled() && inventTransPosting.IsPosted)
        {
            _currencyExchHelper = InventoryReportingCurrencyTriangulationHelper::getReversalCurrencyExchangeHelperFromGL(
                        _currencyExchHelper,
                        this.postingPhysical(),
                        inventTransPosting.Voucher,
                        inventTransPosting.DataAreaId,
                        inventTransPosting.TransDate,
                        _standardCurrencyCode);

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                    _ledgerVoucherObject,
                    _postingType,
                    _ledgerDimensionId,
                    _standardCurrencyCode,
                    _transactionCurrencyAmount,
                    _currencyExchHelper);

            this.updateFinTag(ledgerVoucherTransObject);

            return ledgerVoucherTransObject;
        }

        ledgerVoucherTransObject = this.createLedgerVoucherTransObject(
                    _ledgerVoucherObject,
                    _postingType,
                    _ledgerDimensionId,
                    _standardCurrencyCode,
                    _transactionCurrencyAmount,
                    _currencyExchHelper);

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>activityNumber</Name>
				<Source><![CDATA[
    public ProjActivityNumber activityNumber()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRemainFinancialUnit</Name>
				<Source><![CDATA[
    public void addRemainFinancialUnit(
        UnitQty     _qtyUnit,
        InventQty   _qty)
    {
        if (this.mustBeUnitControlled() && this.mustBeRemainControlled())
        {
            throw error(Error::missingOverload(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRemainPhysical</Name>
				<Source><![CDATA[
    public void addRemainPhysical(InventQty  _inventQty)
    {
        if (this.mustBeRemainControlled())
        {
            throw error(Error::missingOverload(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRemainPhysicalUnit</Name>
				<Source><![CDATA[
    public void addRemainPhysicalUnit(UnitQty _qtyUnit)
    {
        if (this.mustBeRemainControlled() && this.mustBeUnitControlled())
        {
            throw error(Error::missingOverload(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustInventDimReservationCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjust the inventDimCriteria for reservation.
    /// </summary>
    /// <param name="_inventDimCriteria">
    /// The original inventDimCriteria.
    /// </param>
    /// <param name="_inventDimParm">
    /// The inventDimParm of the movement. This can be modified by reference.
    /// </param>
    /// <returns>
    /// The new inventDimCriteria
    /// </returns>
    public InventDim adjustInventDimReservationCriteria(
        InventDim       _inventDimCriteria,
        InventDimParm   _inventDimParm)
    {
        return _inventDimCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustmentMovement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether movements are created as adjustments to previous transactions.
    /// </summary>
    /// <returns>
    ///    true if the movement is an adjustment to a previous transaction; otherwise, false.
    /// </returns>
    protected boolean adjustmentMovement()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustToFixedReceiptPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns whether a receipt should be adjusted to fixed receipt price.
    /// </summary>
    /// <returns>
    ///    true if a receipt should be adjusted to fixed receipt price; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method is overridden by the <c>InventMov_Vir_Transfer_Closing</c> method.
    /// </remarks>
    public boolean adjustToFixedReceiptPrice()
    {
        return this.inventModelGroup().StandardCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustTransactionInventDimEstimated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an inventDim based on the movement inventDim and adjusts it as needed to be used on the estimated inventTrans.
    /// </summary>
    /// <returns>
    /// An inventDim after being adjusted as needed.
    /// </returns>
    public InventDim adjustTransactionInventDimEstimated()
    {
        return this.inventdim();
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowAutoLossProfit</Name>
				<Source><![CDATA[
    public boolean allowAutoLossProfit()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowNegativePhysicalForBlockingStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if validation should allow a negative physical available quantity for inventory status blocking.
    /// </summary>
    /// <returns>
    ///     Always returns false.
    /// </returns>
    /// <remarks>
    ///     Availability validation must be skipped for issue transactions on certain inventory journal transactions with blocking status.
    /// </remarks>
    public boolean allowNegativePhysicalForBlockingStatus()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assemblyInventTransOriginId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID of the assembly inventory transaction originator that corresponds to the movement.
    /// </summary>
    /// <returns>
    ///    The ID of the assembly inventory transaction originator that corresponds to the movement.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden in relevant inherited classes.
    /// </remarks>
    public InventTransOriginId assemblyInventTransOriginId()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetBookId</Name>
				<Source><![CDATA[
    public AssetBookId assetBookId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetId</Name>
				<Source><![CDATA[
    public AssetId assetId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoLossProfitInventMovVirtuel</Name>
				<Source><![CDATA[
    protected InventMov_Virtuel autoLossProfitInventMovVirtuel(
        InventUpd_Financial     _financial,
        InventTrans             _inventTrans,
        InventTransId           _inventTransId)
    {
        InventMov_Virtuel movement = InventMov_Virtuel::newAutoLossProfit(_financial, _inventTrans, _inventTransId);
        return movement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoReserveQty</Name>
				<Source><![CDATA[
    public InventQty autoReserveQty(InventMovement _movement_ORIG)
    {
        return -this.transQty() + _movement_ORIG.transQty() - this.transIdSum().onOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>batchDispReservationBlockedFieldId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the field ID of the <c>PdsDispositionMaster</c> table for reservation blocking control field for the type of movement.
    /// </summary>
    /// <returns>
    /// The field ID of the <c>PdsDispositionMaster</c> table that controls batch block for reservations for the movement; otherwise, zero if there is no blocking control field.
    /// </returns>
    public FieldId batchDispReservationBlockedFieldId()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>batchProdDate</Name>
				<Source><![CDATA[
    public InventBatchProdDate batchProdDate(InventTrans _inventTrans = null)
    {
        if (_inventTrans)
        {
            return ( _inventTrans.DatePhysical ? _inventTrans.DatePhysical : _inventTrans.DateStatus);
        }

        return this.transDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>buffer</Name>
				<Source><![CDATA[
    public Common buffer()
    {
        return buffer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcEstimatedUnit</Name>
				<Source><![CDATA[
    public UnitQty calcEstimatedUnit(InventQty _estimated)
    {
        UnitQty estimatedUnit;

        if (this.mustBeUnitControlled())
        {
            estimatedUnit  = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(this.itemId(),
                                                                                                   this.inventDimId(),
                                                                                                   _estimated,
                                                                                                   this.inventTable().inventUnitId(),
                                                                                                   this.transUnitId(),
                                                                                                   NoYes::Yes);

            estimatedUnit  = decRound(estimatedUnit, UnitOfMeasure::unitOfMeasureDecimalPrecision(
                UnitOfMeasure::unitOfMeasureIdBySymbol(this.transUnitId())));
        }
        else
        {
            estimatedUnit  = _estimated;
        }

        return estimatedUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateIndirectCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the indirect cost that is related to the movement.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher object where the ledger transactions are added.
    /// </param>
    /// <param name="_physical">
    ///    The quantity that is physically updated.
    /// </param>
    /// <param name="_inputAmount">
    ///    The input amount.
    /// </param>
    /// <remarks>
    ///    The indirect cost must be calculated when the movement is physically updated.
    /// </remarks>
    public void calculateIndirectCost(LedgerVoucher _ledgerVoucher, Qty _physical, InventCostInputAmount _inputAmount)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeAutoRepAsFinished</Name>
				<Source><![CDATA[
    public boolean canBeAutoRepAsFinished()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeOnAllInventLocations</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the movement can be on all warehouses.
    /// </summary>
    /// <returns>
    ///     True if the movement can be on all warehouses; false otherwise.
    /// </returns>
    public boolean canBeOnAllInventLocations()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeOnAllInventSites</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the movement can be on all sites.
    /// </summary>
    /// <returns>
    ///     True if the movement can be on all sites; false otherwise.
    /// </returns>
    public boolean canBeOnAllInventSites()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeOnSupermarket</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a movement can have an <c>InventDimId</c> value that represents a kanban
    ///    supermarket.
    /// </summary>
    /// <returns>
    ///    Always returns false.
    /// </returns>
    public boolean canBeOnSupermarket()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeReserved</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the <c>InventMovement</c> instance, such as a <c>salesLine</c>, can be reserved.
    /// </summary>
    /// <returns>
    ///    true if the <c>InventMovement</c> instance can be reserved; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Returns a Boolean value from the <c>inventType</c> class. For example, if a <c>salesLine</c> is
    ///    entered, a <c>SalesLineType</c> class is initialized. On this class, the method can be set to
    ///    return if the type, for example, <c>salesLine</c>, can be reserved. This method is often used
    ///    together with the <c>mustBeAutoReserved</c> method.
    /// </remarks>
    public boolean  canBeReserved()
    {
        return inventType.canInventBeReserved();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeUpdatedEstimated</Name>
				<Source><![CDATA[
    protected boolean canBeUpdatedEstimated()
    {
        return inventType.canInventUpdExpected();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeUpdatedFinancial</Name>
				<Source><![CDATA[
    protected boolean canBeUpdatedFinancial()
    {
        return inventType.canInventUpdFinancial();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeUpdatedPhysical</Name>
				<Source><![CDATA[
    protected boolean canBeUpdatedPhysical()
    {
        return inventType.canInventUpdPhysical();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeUpdatedPicked</Name>
				<Source><![CDATA[
    protected boolean canBeUpdatedPicked()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeUpdatedRegistered</Name>
				<Source><![CDATA[
    protected boolean canBeUpdatedRegistered()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canChangeConsistentDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether consistent dimensions can be modified.
    /// </summary>
    /// <param name="_onlyCheckStorageDimensions">
    ///    A Boolean value that specifies whether the check should only consider consistent storage dimensions.
    /// </param>
    /// <returns>
    ///    true if consistent inventory dimensions can be changed; otherwise, false.
    /// </returns>
    public boolean canChangeConsistentDim(boolean _onlyCheckStorageDimensions)
    {
        boolean includeFinancialTrans = _onlyCheckStorageDimensions && this.canChangeStorageConsistentDimWhenFinUpd();

        return (select firstonly inventTrans
                where inventTrans.InventTransOrigin         == this.inventTransOriginId()
                 &&   inventTrans.PackingSlipReturned       == NoYes::No
                 &&  (!includeFinancialTrans
                 ||  (inventTrans.StatusIssue               != StatusIssue::Sold
                 &&   inventTrans.StatusReceipt             != StatusReceipt::Purchased))
                 &&(!(inventTrans.StatusReceipt             == StatusReceipt::Ordered
                 ||   inventTrans.StatusReceipt             == StatusReceipt::QuotationReceipt
                 ||   inventTrans.StatusIssue               == StatusIssue::OnOrder
                 ||   inventTrans.StatusIssue               == StatusIssue::ReservPhysical
                 ||   inventTrans.StatusIssue               == StatusIssue::ReservOrdered
                 ||   inventTrans.StatusIssue               == StatusIssue::QuotationIssue)
                 || !(inventTrans.TransChildType            == this.transChildType()
                 &&   inventTrans.TransChildRefId           == this.transChildRefId()))).RecId == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canChangeStorageConsistentDimWhenFinUpd</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether consistent storage dimensions may be changed when inventory transactions are
    ///    financially updated.
    /// </summary>
    /// <returns>
    ///    true if consistent storage dimensions may be changed; otherwise, false.
    /// </returns>
    protected boolean canChangeStorageConsistentDimWhenFinUpd()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCommittedCostBeReversed</Name>
				<Source><![CDATA[
    public boolean canCommittedCostBeReversed()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCostValuebeChanged</Name>
				<Source><![CDATA[
    protected boolean canCostValuebeChanged()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canHaveReservedWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the movement type can have WHS work created that takes over reserving the lower levels of the hierarchy.
    /// </summary>
    /// <returns>
    /// Always returns false.
    /// </returns>
    public boolean canHaveReservedWork()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInventTransBeUpdatedRegistered</Name>
				<Source><![CDATA[
    internal boolean canInventTransBeUpdatedRegistered(InventTrans _inventTrans)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInventTransBeFinancialUpdated</Name>
				<Source><![CDATA[
    public boolean canInventTransBeFinancialUpdated(InventTrans _inventTrans)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInventTransBePhysicalUpdated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verifies whether an inventory transaction can be physically updated.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The inventory transaction that is to be verified.
    /// </param>
    /// <returns>
    ///    true if the inventory transaction can be physically updated; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method will be used to determine whether an inventory transaction can be physically updated.
    /// </remarks>
    public boolean canInventTransBePhysicalUpdated(InventTrans _inventTrans)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReservationFormBeEdited</Name>
				<Source><![CDATA[
    public boolean canReservationFormBeEdited()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReservationFormBeShown</Name>
				<Source><![CDATA[
    public boolean canReservationFormBeShown()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUpdateInventStatusBlocking</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the movement can update inventory status blocking transactions
    /// </summary>
    /// <returns>
    ///     Returns true if the transaction sign is positive (receipt).
    /// </returns>
    public boolean canUpdateInventStatusBlocking()
    {
        return this.transSign() > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUpdateOnHandDatePhysicalOnReturn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the physical date of on-hand inventory can be updated when items are returned.
    /// </summary>
    /// <returns>
    /// Always return true.
    /// </returns>
    public boolean canUpdateOnHandDatePhysicalOnReturn()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllowManualMarking</Name>
				<Source><![CDATA[
    public boolean checkAllowManualMarking()
    {
        if (this.projId() && this.hasVirtualTransactions())
        {
            return checkFailed("@SYS105254");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCountingLocks</Name>
				<Source><![CDATA[
    public boolean checkCountingLocks(InventDim _inventDim)
    {
        if (!InventParameters::find().LockCounting)
        {
            return true;
        }

        if (InventItemLocation::isCountingStarted(this.itemId(),_inventDim))
        {
            return checkFailed(strFmt("@SYS59534", this.itemId(), _inventDim.InventLocationId));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDimFieldsValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate that the specified inventory dimensions are valid.
    /// </summary>
    /// <param name="_inventDim">
    /// Inventory dimensions to validate.
    /// </param>
    /// <param name="_inventDim_orig">
    /// Original values of the dimensions.
    /// </param>
    /// <param name="_skipProductDimensions">
    /// Controls whether product dimensions were already validated and can be skipped.
    /// </param>
    /// <returns>
    /// True if all the dimensions are valid. False otherwise.
    /// </returns>
    public boolean checkDimFieldsValid(
        InventDim   _inventDim,
        InventDim   _inventDim_orig,
        boolean     _skipProductDimensions = false)
    {
        return _inventDim.checkDimFieldsValid(this.itemId(), _inventDim_orig, true, new Set(Types::Integer), _skipProductDimensions);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateInventOwnerId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies whether an inventory transaction can be inserted or updated with the specified inventory owner.
    /// </summary>
    /// <param name = "_inventDim">The inventory dimension values which will be set on the inventory transaction after the inventory update.</param>
    /// <param name = "_inventDimOrig">The inventory dimension values which were set on the inventory transaction before the inventory update; optional.</param>
    /// <returns>true, if the transaction can be inserted or updated; otherwise, false.</returns>
    public boolean checkUpdateInventOwnerId(InventDim _inventDim, InventDim _inventDimOrig = null)
    {
        if (this.parmCompanyCountryRegion().isCountryRegionRU())
        {
            return this.checkDimInventOwnerId_RU(_inventDim);
        }

        boolean ret = true;

        boolean ownerChanged = _inventDim.InventOwnerId_RU != _inventDimOrig.InventOwnerId_RU;

        if (ownerChanged)
        {
            ret = this.checkIfInventoryOwnerIsMandatory(_inventDim);
        }

        if (ret
            && this.mustCheckAdvancedWarehousingInventoryOwner()
            && (ownerChanged || _inventDim.InventLocationId != _inventDimOrig.InventLocationId))
        {
            ret = this.checkAdvancedWarehousingInventoryOwner(_inventDim);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasMandatoryInventoryOwner</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the movement has a mandatory inventory owner.
    /// </summary>
    /// <returns>true if there is a mandatory inventory owner; otherwise, false.</returns>
    public boolean hasMandatoryInventoryOwner()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfInventoryOwnerIsMandatory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies whether the inventory owner from the passed inventory dimensions is the mandatory inventory owner for the movement.
    /// </summary>
    /// <param name = "_inventDim">The inventory dimension values to check.</param>
    /// <returns>true if the inventory owner is the mandatory one, or if the check is irrelevant; otherwise, false.</returns>
    protected boolean checkIfInventoryOwnerIsMandatory(InventDim _inventDim)
    {
        if (this.hasMandatoryInventoryOwner()
            && !this.skipMandatoryInventoryOwnerCheck(_inventDim))
        {
            InventOwnerId mandatoryOwnerId = this.getInventoryOwnerId();
            if (_inventDim.InventOwnerId_RU != mandatoryOwnerId)
            {
                return checkFailed(strFmt("@SCM:SpecifiedInventoryOwnerIsNotAllowedInThisProcess", _inventDim.InventOwnerId_RU, mandatoryOwnerId));
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipMandatoryInventoryOwnerCheck</Name>
				<Source><![CDATA[
    internal boolean skipMandatoryInventoryOwnerCheck(InventDim _inventDim)
    {
        if (this.inventTable().whsItemInventoryOwnershipEnabled()
            && _inventDim.inventLocation().WHSEnabled)
        {
            return true;
        }
        
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckAdvancedWarehousingInventoryOwner</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current movement should be checked for the required inventory owner in advanced warehousing scenarios.
    /// </summary>
    /// <returns>true if the inventory owner should be checked; otherwise, false.</returns>
    protected boolean mustCheckAdvancedWarehousingInventoryOwner()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAdvancedWarehousingInventoryOwner</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the inventory owner is the correct one during an update in an advanced warehousing scenario.
    /// </summary>
    /// <param name = "_updateInventDim">Inventory dimensions to validate.</param>
    /// <returns>true if the inventory owner is correct; otherwise, false.</returns>
    protected boolean checkAdvancedWarehousingInventoryOwner(InventDim _updateInventDim)
    {
        if (WHSWarehouseInventoryOwnerFlight::instance().isEnabled())
        {
            if (_updateInventDim.InventOwnerId_RU
                && this.isItemWHSEnabled()
                && _updateInventDim.inventLocation().WHSEnabled)
            {
                if (this.inventTable().whsItemInventoryOwnershipEnabled())
                {
                    return true;
                }
                else if (_updateInventDim.InventOwnerId_RU != InventOwner_RU::findOrCreateCurrentLegalEntity().InventOwnerId)
                {
                    return checkFailed("@Consignment:MessageValidation_VendorOwnedWhs");
                }
            }
        }
        else
        {
            if (this.isItemWHSEnabled()
                && _updateInventDim.inventLocation().WHSEnabled
                && !_updateInventDim.isOwnerCurrentLegalEntity())
            {
                return checkFailed("@Consignment:MessageValidation_VendorOwnedWhs");
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDimInventOwnerId_RU</Name>
				<Source><![CDATA[
    public boolean checkDimInventOwnerId_RU(InventDim _inventDim, boolean _showError = true)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDimPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the physical dimensions of a given <c>InventDim</c> table buffer for the current movement.
    /// </summary>
    /// <param name="_qty">
    ///    A quantity used to validate the physical dimensions.
    /// </param>
    /// <param name="_inventDim">
    ///    The <c>InventDim</c> table buffer to validate.
    /// </param>
    /// <param name="_finalCheck">
    ///    A Boolean flag that indicates if all inventory dimension must have been assigned; optional.
    /// </param>
    /// <param name="_showError">
    ///    A Boolean value that indicates if errors must be shown in the infolog; optional.
    /// </param>
    /// <returns>
    ///    true if the validation passes; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    if argument finalCheck is set to true, it's expected that all dimensions are assigned to the inventory transaction as they should be before posting.
    ///    Please be aware of usage of method InventUpd.writeInventTransAutoDim() after call of this method with finalCheck=True.
    /// </remarks>
    public boolean checkDimPhysical(
        InventQty   _qty,
        InventDim   _inventDim,
        boolean     _finalCheck,
        boolean     _showError = true
        )
    {
        boolean                                 ok         = true;
        InventDimGroupFieldSetupEnumerator      enumerator = this.inventDimGroupSetup().getFieldSetupEnumerator();

        while (enumerator.moveNext())
        {
            InventDimGroupFieldSetup inventDimGroupFieldSetup = enumerator.current();

            boolean okTmp = this.checkInventDimForInventDimField(_qty, _inventDim, inventDimGroupFieldSetup, _finalCheck, _showError);

            if (!okTmp)
            {
                ok = okTmp;
            }
        }

        return ok && _inventDim.checkInventDimCombination(this.itemId(),this.ecoResProductDimGroupSetup(),_showError);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventSiteDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the used inventory dimensions against the used financial dimensions.
    /// </summary>
    /// <param name="_inventDim">
    ///    An <c>InventDim</c> record buffer that contains the used inventory dimensions.
    /// </param>
    /// <returns>
    ///    true if validation is correct; otherwise, false.
    /// </returns>
    public boolean checkInventSiteDimension(InventDim _inventDim)
    {
        if (this.adjustmentMovement())
        {
            return true;
        }

        if (!inventSiteDimensionCheck)
        {
            inventSiteDimensionCheck = InventSiteDimensionCheck::newStandard();
        }

        return inventSiteDimensionCheck.checkDimensions(_inventDim, this.defaultDimension());
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLocationBlocking</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean validateLocationBlocking(InventDim _inventDimLocation)
    {
        return this.checkLocationBlocking(_inventDimLocation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLocationBlocking</Name>
				<Source><![CDATA[
    protected boolean checkLocationBlocking(InventDim _inventDimLocation = null)
    {
        boolean     ret             = true;

        if (!this.mustCheckLocationBlocking())
        {
            return true;
        }

        InventDim inventDimThis = _inventDimLocation;
        if (!_inventDimLocation.wmsLocationId)
        {
            inventDimThis = this.inventdim();
            if (!inventDimThis.wmsLocationId)
            {
                return true;
            }
        }

        return this.checkSingleWMSLocationBlocking(inventDimThis.wmsLocation(), this.transQty());
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSingleWMSLocationBlocking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the location is blocked for input or output.
    /// </summary>
    /// <param name = "_wmsLocation">
    ///  A <c>WMSLocation</c> record buffer which will checked.
    /// </param>
    /// <param name = "_qty">
    /// The quantity that is being added or removed to the location. If the quantity is positive the location is checked for input blocking and if it is negative it is checked for output blocking.
    /// </param>
    /// <returns>
    /// true if the location is not blocked; else false.
    /// </returns>
    protected boolean checkSingleWMSLocationBlocking(WMSLocation _wmsLocation, InventQty _qty)
    {
        boolean ret = true;

        if (!_wmsLocation)
        {
            return ret;
        }

        if (_wmsLocation.InputBlockingCauseId && _qty > 0)
        {
            if (this.isBlockingCausePolicyActive(_wmsLocation.InputBlockingCauseId))
            {
                ret = checkFailed(strFmt("@SYS72264", _wmsLocation.wmsLocationId));
            }
        }

        if (_wmsLocation.OutputBlockingCauseId && _qty < 0)
        {
            if (this.isBlockingCausePolicyActive(_wmsLocation.OutputBlockingCauseId))
            {
                ret = checkFailed(strFmt("@SYS72265", _wmsLocation.wmsLocationId));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBlockingCausePolicyActive</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the blocking cause policy is active.
    /// </summary>
    /// <param name = "_blockingCauseId">
    /// A blocking cause id which will be validated.
    /// </param>
    /// <returns>
    /// true if the blocking cause policy is active; else false.
    /// </returns>
    [Hookable(false)]
    protected boolean isBlockingCausePolicyActive(WMSBlockingCauseId _blockingCauseId)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNotOverDelivery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verify whether the movement quantities cause over-delivery.
    /// </summary>
    /// <param name="_physicalNow">
    ///    An inventory quantity being updated.
    /// </param>
    /// <param name="_isPhysicalUpdate">
    ///    A Boolean value that indicates whether the update is a physical update.
    /// </param>
    /// <param name="_pdsCWPhysicalNow">
    ///    A catch weight inventory quantity being updated.
    /// </param>
    /// <returns>
    ///    true if the movement quantities are not causing over-delivery; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    In many cases the over-delivery context occurs at the parent movement.
    /// </remarks>
    public boolean checkNotOverDelivery(
        InventQty       _physicalNow,
        boolean         _isPhysicalUpdate,
        PdsCWInventQty  _pdsCWPhysicalNow
        )
    {
        UnitQty         qtyPre;
        UnitQty         qtyPost;
        Percent         subOverPct;
        InventMovement  parentMovement = this.parentMovement();
        PdsCWInventQty  pdsCWQtyPre;
        PdsCWInventQty  pdsCWQtyPost;
        InventTransIdSum    inventTransIdSum;
        UnitQty             qtyOverDelivery;

        if (this.pdsCWItem())
        {
            //<GEERU>
            if (_isPhysicalUpdate && this.parmCompanyCountryRegion().isCountryRegionRU())
            {
                inventTransIdSum = this.transIdSumTransId(true);
                inventTransIdSum.parmInventDimCriteria    (physicalInventDimCriteria);
                inventTransIdSum.parmInventDimParmCriteria(physicalInventDimParmCriteria);

                pdsCWQtyPre = abs(inventTransIdSum.pdsCWReceipt() + inventTransIdSum.pdsCWRegistered() +
                             inventTransIdSum.pdsCWIssue()   + inventTransIdSum.pdsCWPicked());

                if (this.mustBeExpectedAgain())
                {
                    pdsCWQtyPost     = abs(inventTransIdSum.pdsCWPhysical() + _pdsCWPhysicalNow);
                }
                else
                {
                    pdsCWQtyPost     = abs(inventTransIdSum.pdsCWPhysical() + inventTransIdSum.pdsCWFinancial() + _pdsCWPhysicalNow);
                }
            }
            else
            {
                //</GEERU>
                pdsCWQtyPre     = abs(parentMovement.pdsCWTransQty());
                pdsCWQtyPost    = parentMovement.pdsCWQtyPost(_pdsCWPhysicalNow, _isPhysicalUpdate);
                // <GEERU>
            }
            // </GEERU>

            subOverPct      = (pdsCWQtyPost - pdsCWQtyPre) / (pdsCWQtyPre ? pdsCWQtyPre : 1) * 100;
        }
        else
        {
            if (_isPhysicalUpdate && this.parmCompanyCountryRegion().isCountryRegionRU())
            {
                inventTransIdSum = this.transIdSumTransId(true);
                inventTransIdSum.parmInventDimCriteria    (physicalInventDimCriteria);
                inventTransIdSum.parmInventDimParmCriteria(physicalInventDimParmCriteria);

                qtyPre = abs(inventTransIdSum.receipt() + inventTransIdSum.registered() +
                             inventTransIdSum.issue()   + inventTransIdSum.picked());

                if (this.mustBeExpectedAgain())
                {
                    qtyPost     = abs(inventTransIdSum.physical() + _physicalNow);
                }
                else
                {
                    qtyPost     = abs(inventTransIdSum.physical() + inventTransIdSum.financial() + _physicalNow);
                }

                qtyOverDelivery = qtyPost - qtyPre;
            }
            else
            {
                if (this.parmCompanyCountryRegion().isCountryRegionIN())
                {
                    qtyPre      = this.getQtyPreForNotOverDeliveryCheck_IN();
                }
                else
                {
                    qtyPre      = abs(parentMovement.transQty());
                }

                // In case mustBeExpectedAgain() is true, the transaction in question originates from a subscription order.
                // That type of order is expected to be fully delivered over and over hence,
                // the posting history can't be used to determine deviations from the ordered quantity.
                if (this.mustBeExpectedAgain())
                {
                    if (this.remainPhysical() - _physicalNow > 0)
                    {
                        qtyOverDelivery = this.remainPhysical() - _physicalNow;
                    }
                    else
                    {
                        qtyOverDelivery = 0;
                    }
                }
                else
                {
                    qtyPost         = parentMovement.qtyPost(_physicalNow, _isPhysicalUpdate);
                    qtyOverDelivery = qtyPost - qtyPre;
                }
            }

            subOverPct  = qtyOverDelivery / (qtyPre ? qtyPre : 1) * 100;
        }

        if (!this.isOverDeliveryAllowed(subOverPct, parentMovement))
        {
            if (this.isTransfer())
            {
                return checkFailed("@SCM:Error_TransferOverDelivery");
            }
            else
            {
                return checkFailed(strFmt("@SYS24920", subOverPct, parentMovement.overDeliveryPct()));
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOverDeliveryAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if an overdelivery percentage is allowed for a parent movement.
    /// </summary>
    /// <param name = "_overDelivery">An overdelivery percentage.</param>
    /// <param name = "_parentMovement">A parent movement.</param>
    /// <returns>true if overdelivery is allowed; otherwise, false.</returns>
    protected boolean isOverDeliveryAllowed(Percent _overDelivery, InventMovement _parentMovement)
    {
        return _overDelivery <= _parentMovement.overDeliveryPct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNotSubDelivery</Name>
				<Source><![CDATA[
    protected boolean checkNotSubDelivery(
        InventQty       _physicalNow,
        InventQty       _remainPhysicalNow,
        boolean         _isPhysicalUpdate
        , PdsCWInventQty  _pdsCWPhysicalNow
        , PdsCWInventQty  _pdsCWRemainPhysicalNow
        )
    {
        UnitQty     qtyPre;
        UnitQty     qtyPost;
        Percent     subOverPct;
        PdsCWInventQty  pdsCWQtyPre;
        PdsCWInventQty  pdsCWQtyPost;
        // <GEERU>
        InventTransIdSum    inventTransIdSum;
        // </GEERU>
        UnitQty             qtySubDelivery;

        if (_remainPhysicalNow != 0)
        {
            return true;
        }

        if (this.transQty() * _physicalNow < 0)
        {
            return true;
        }

        if (this.pdsCWItem())
        {
            // <GEERU>
            if (this.parmCompanyCountryRegion().isCountryRegionRU())
            {
                inventTransIdSum = this.transIdSumTransId(true);
                inventTransIdSum.parmInventDimCriteria    (physicalInventDimCriteria);
                inventTransIdSum.parmInventDimParmCriteria(physicalInventDimParmCriteria);

                if (this.mustBeExpectedAgain())
                {
                    pdsCWQtyPost     = abs(inventTransIdSum.pdsCWPhysical() + _pdsCWPhysicalNow);
                }
                else
                {
                    pdsCWQtyPost     = abs(inventTransIdSum.pdsCWPhysical() + inventTransIdSum.pdsCWFinancial() + _pdsCWPhysicalNow);
                }

                pdsCWQtyPre = abs(inventTransIdSum.pdsCWReceipt() + inventTransIdSum.pdsCWIssue());
            }
            else
            {
                // </GEERU>
                pdsCWQtyPre      = abs(this.pdsCWTransQty());
                pdsCWQtyPost     = this.pdsCWQtyPost(_pdsCWPhysicalNow, _isPhysicalUpdate);
                // <GEERU>
            }
            // </GEERU>

            subOverPct  = (pdsCWQtyPre - pdsCWQtyPost) / (pdsCWQtyPre ? pdsCWQtyPre : 1) * 100;
        }
        else
        {
            // <GEERU>
            if (_isPhysicalUpdate && this.parmCompanyCountryRegion().isCountryRegionRU())
            {
                inventTransIdSum = this.transIdSumTransId(true);
                inventTransIdSum.parmInventDimCriteria    (physicalInventDimCriteria);
                inventTransIdSum.parmInventDimParmCriteria(physicalInventDimParmCriteria);

                if (this.mustBeExpectedAgain())
                {
                    qtyPost     = abs(inventTransIdSum.physical() + _physicalNow);
                }
                else
                {
                    qtyPost     = abs(inventTransIdSum.physical() + inventTransIdSum.financial() + _physicalNow);
                }

                qtyPre          = abs(inventTransIdSum.receipt() + inventTransIdSum.issue());
                qtySubDelivery  = qtyPre - qtyPost;
            }
            else
            {
                // </GEERU>
                qtyPre      = abs(this.transQty());

                // In case mustBeExpectedAgain() is true, the transaction in question originates from a subscription order.
                // That type of order is expected to be fully delivered over and over hence,
                // the posting history can't be used to determine deviations from the ordered quantity.
                if (this.mustBeExpectedAgain())
                {
                    if (this.remainPhysical() - _physicalNow < 0)
                    {
                        qtySubDelivery = (abs(this.remainPhysical() - _physicalNow));
                    }
                    else
                    {
                        qtySubDelivery = 0;
                    }
                }
                else
                {
                    qtyPost         = this.qtyPost(_physicalNow, _isPhysicalUpdate);
                    qtySubDelivery  = qtyPre - qtyPost;
                }
                // <GEERU>
            }
            // </GEERU>

            subOverPct  = qtySubDelivery / (qtyPre ? qtyPre : 1) * 100;
        }

        if (!this.isUnderDeliveryAllowed(subOverPct))
        {
            return checkFailed(strFmt("@SYS24921", subOverPct, this.subDeliveryPct()));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUnderDeliveryAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if an underdelivery percentage is allowed for a movement.
    /// </summary>
    /// <param name = "_underDelivery">An underdelivery percentage.</param>
    /// <returns>true if underdelivery is allowed; otherwise, false.</returns>
    protected boolean isUnderDeliveryAllowed(Percent _underDelivery)
    {
        return _underDelivery <= this.subDeliveryPct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCWWeightAdjustment</Name>
				<Source><![CDATA[
    private boolean isCWWeightAdjustment(InventTrans _inventTrans, boolean _isCWItem)
    {
        return _isCWItem && !_inventTrans.PdsCWQty && _inventTrans.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSerialNum</Name>
				<Source><![CDATA[
    protected boolean checkSerialNum(InventTrans _inventTrans, InventSerialId _inventSerialId)
    {
        InventDimParm   inventDimParm;
        InventDim       inventDimCriteria;

        ItemId          itemId = this.itemId();
        boolean         isFailed;

        boolean isFullVisibilityItem = PdsGlobal::pdsIsCWFullVisItem(itemId);

        inventDimCriteria.InventSerialId = _inventSerialId;
        inventDimParm.InventSerialIdFlag = NoYes::Yes;
        InventOnhand inventOnhand        = InventOnhand::newItemDim(itemId, inventDimCriteria, inventDimParm);

        //since we are looking for physical invent only we do not need to go to the WHSInventReserve tables so for performance reasons we set the delay flag
        inventOnhand.parmDelayAvailabilityCalculation(true);

        InventQty physicalQty;
        InventQty arrivedQty;

        if (isFullVisibilityItem)
        {
            physicalQty = inventOnhand.pdsCWPhysicalInvent();
            arrivedQty  = inventOnhand.pdsCWArrived();
        }
        else
        {
            physicalQty = inventOnhand.physicalInvent();
            arrivedQty  = inventOnhand.arrived();
        }
        if (physicalQty + arrivedQty >= 1)
        {
            if (physicalQty == 1)
            {
                // only check if this is not CW weight adjustment on full visibility item
                if (!this.isCWWeightAdjustment(_inventTrans, isFullVisibilityItem) && !this.pdsIgnoreSerNumCtrlValidation())
                {
                    // don't fail if we are updating the same record, which has previously been marked as physical on hand for the same serial number
                    InventTrans inventTransCurrent = InventTrans::findRecId(_inventTrans.RecId);
                    InventDim inventDimCurrent = inventTransCurrent.inventDim();
                    boolean isUnpicking = inventTransCurrent.StatusIssue == StatusIssue::Picked && _inventTrans.StatusIssue > StatusIssue::Picked;

                    if (inventDimCurrent.InventSerialId     != _inventSerialId
                            || inventTransCurrent.StatusReceipt >= StatusReceipt::Arrived
                            ||(this.pdsCWItem()  && (inventTransCurrent.PdsCWQty != _inventTrans.PdsCWQty))
                            ||(!this.pdsCWItem() && (inventTransCurrent.Qty != _inventTrans.Qty))
                            || isUnpicking)
                    {
                        checkFailed(strFmt("@SYS68713", _inventSerialId));
                        isFailed = true;
                    }
                }
            }
            else
            {
                checkFailed(strFmt("@SYS68713", _inventSerialId));
                isFailed = true;
            }
        }

        if (isFailed)
        {
            isFailed = this.onCheckSerialNumFailed(_inventTrans.inventDim());
        }

        return !isFailed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSerialNumWithMultiLines</Name>
				<Source><![CDATA[
    protected boolean checkSerialNumWithMultiLines(InventTrans _inventTrans, InventSerialId _inventSerialId, InventQty _journalAccumulated)
    {
        InventDimParm   inventDimParm;
        InventDim       inventDimCriteria;

        ItemId          itemId = this.itemId();
        boolean         isFailed;

        boolean isFullVisibilityItem = PdsGlobal::pdsIsCWFullVisItem(itemId);

        inventDimCriteria.InventSerialId = _inventSerialId;
        inventDimParm.InventSerialIdFlag = NoYes::Yes;
        InventOnhand inventOnhand        = InventOnhand::newItemDim(itemId, inventDimCriteria, inventDimParm);

        //since we are looking for physical invent only we do not need to go to the WHSInventReserve tables so for performance reasons we set the delay flag
        inventOnhand.parmDelayAvailabilityCalculation(true);

        InventQty physicalQty;
        InventQty arrivedQty;

        if (isFullVisibilityItem)
        {
            physicalQty = inventOnhand.pdsCWPhysicalInvent();
            arrivedQty  = inventOnhand.pdsCWArrived();
        }
        else
        {
            physicalQty = inventOnhand.physicalInvent();
            arrivedQty  = inventOnhand.arrived();
        }
        if (physicalQty + arrivedQty + _journalAccumulated >= 1)
        {
            if (physicalQty + _journalAccumulated == 1)
            {
                // only check if this is not CW weight adjustment on full visibility item
                if (!this.isCWWeightAdjustment(_inventTrans, isFullVisibilityItem) && !this.pdsIgnoreSerNumCtrlValidation())
                {
                    if (_inventTrans.StatusReceipt >= StatusReceipt::Arrived)
                    {
                        checkFailed(strFmt("@SYS68713", _inventSerialId));
                        isFailed = true;
                    }
                }
            }
            else
            {
                checkFailed(strFmt("@SYS68713", _inventSerialId));
                isFailed = true;
            }
        }

        if (isFailed)
        {
            // Give chance to child classes on how to handle the failure.
            isFailed = this.onCheckSerialNumFailed(inventDimCriteria);
        }

        return !isFailed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSerialNumReceiptQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if quantity is valid for serialized product receipt.
    /// </summary>
    /// <param name = "_inventTrans">The inventory transaction.</param>
    /// <param name = "_inventDim">The inventory dimension.</param>
    /// <returns>true if the quantity is valid; otherwise, false.</returns>
    protected boolean checkSerialNumReceiptQuantity(InventTrans _inventTrans, InventDim _inventDim)
    {
        boolean cwItem                  = PdsGlobal::pdsIsCWItem(_inventTrans.ItemId);
        boolean isFullVisibilityItem    = PdsGlobal::pdsIsCWFullVisItem(_inventTrans.ItemId);

        // for CW item 0 PdsCWQty means quantity adjustment
        boolean isFailed =
            (!cwItem && abs(_inventTrans.Qty) != 1)
                || (cwItem && (!isFullVisibilityItem || !this.pdsIgnoreSerNumCtrlValidation()) 
                    && abs(_inventTrans.PdsCWQty) != 1 && !this.isCWWeightAdjustment(_inventTrans, cwItem))
                || (cwItem && this.pdsIgnoreSerNumCtrlValidation() && isFullVisibilityItem && abs(_inventTrans.PdsCWQty) > 1);

        if (isFailed)
        {
            // Give chance to child classes on how to handle the failure.
            isFailed = this.onCheckSerialNumQuantityFailed(_inventDim);
        }

        return !isFailed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onCheckSerialNumFailed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handle any custom logic when serial number check fails.
    /// </summary>
    /// <param name = "_inventDim">The inventory dimension.</param>
    /// <returns>true if final check result should be failed; otherwise false.</returns>
    protected boolean onCheckSerialNumFailed(InventDim _inventDim)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onCheckSerialNumQuantityFailed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handle any custom logic when serial number quantity check fails.
    /// </summary>
    /// <param name = "_inventDim">The inventory dimension.</param>
    /// <returns>true if final check result should be failed; otherwise false.</returns>
    protected boolean onCheckSerialNumQuantityFailed(InventDim _inventDim)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProfileOwner_RU</Name>
				<Source><![CDATA[
    boolean checkProfileOwner_RU(InventDim _inventDim)
    {
        boolean                     ret = true;

        if (_inventDim.inventProfile_RU().StockInTransit == StockInTransit_RU::BoughtInTransit)
        {
            RecId trackingDimensionGroupRecId = this.inventDimGroupSetup().getTrackingDimensionGroup();

            if (trackingDimensionGroupRecId)
            {
                if (! this.inventDimGroupSetup().isDimensionActive(fieldNum(InventDim, InventOwnerId_RU)))
                {
                    ret = checkFailed(strFmt("@GLS115703",
                                             fieldId2pname(tableNum(InventDim),
                                                           fieldNum(InventDim, InventOwnerId_RU)),
                                             EcoResTrackingDimensionGroup::find(trackingDimensionGroupRecId).Name));
                }
                else
                {
                    if (! this.updateAutoDimOwnerId_RU() && ! _inventDim.InventOwnerId_RU)
                    {
                        ret = checkFailed(strFmt("@GLS115704", fieldId2pname(tableNum(InventDim), fieldNum(InventDim, InventOwnerId_RU))));
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateArrived</Name>
				<Source><![CDATA[
    public boolean checkUpdateArrived(InventUpd_Arrived _updateNow)
    {
        boolean             ok = true;

        if (this.mustCheckOverDeliveryForQty(_updateNow.parmArrived()) && ! this.checkNotOverDelivery(_updateNow.parmArrived(),false
            , _updateNow.parmPdsCWArrived()
        ))
        {
            ok = false;
        }

        if (! this.checkDimFieldsValid(_updateNow.parmInventDimCriteria(),null))
        {
            return false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateChildReference</Name>
				<Source><![CDATA[
    public boolean checkUpdateChildReference(InventUpd_ChildReference _updateNow)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateEstimated</Name>
				<Source><![CDATA[
    public boolean checkUpdateEstimated(
        InventUpd_Estimated     _updateNow,
        InventMovement          _this_Orig)
    {
        boolean         ok = true;
        InventQty transQty = this.transQty();

        if (_this_Orig)
        {
            InventQty origTransQty = _this_Orig.transQty();
            // Check whether this.transQty() and _this_Orig.transQty() have different signs.
            boolean qtySignChanged = transQty != 0.0 && origTransQty != 0.0 && sign(transQty) * sign(OrigTransQty) < 0;

            if (qtySignChanged)
            {
                if (this.remainPhysicalUnit()  !=  this.transQtyUnit() ||
                    this.remainFinancialUnit() != 0)
                {
                    ok = checkFailed("@SYS25506");
                }
            }
            
            if (abs(transQty)  <  abs(origTransQty))
            {
                // Check whether this.transQty() and _this_Orig.transQty() have the same sign.
                boolean qtySignNotChanged = transQty == 0.0 || origTransQty == 0.0 || sign(transQty) * sign(OrigTransQty) > 0;

                if (qtySignNotChanged)
                {
                    // Check whether this.remainPhysicalUnit() and _this_Orig.remainPhysicalUnit() have different signs, 
                    // or this.remainPhysicalUnit() and _this_Orig.remainFinancialUnit() have differnt signs.
                    boolean remainUpdateQtySignChanged;
                
                    UnitQty remainPhysicalUnit = this.remainPhysicalUnit();
                    UnitQty origRemainPhysicalUnit = _this_Orig.remainPhysicalUnit();
                    UnitQty origRemainFinancialUnit = _this_Orig.remainFinancialUnit();

                    remainUpdateQtySignChanged = (remainPhysicalUnit != 0.0 && origRemainPhysicalUnit != 0.0
                                                &&  sign(remainPhysicalUnit) * sign(origRemainPhysicalUnit) < 0)
                                                || (remainPhysicalUnit != 0.0 && origRemainFinancialUnit != 0.0
                                                && sign(remainPhysicalUnit) * sign(origRemainFinancialUnit) < 0);

                    if (remainUpdateQtySignChanged)
                    {
                        ok = checkFailed("@SYS25508");
                    }
                }
            }
        }

        if (this.mustBeUnitControlled())
        {
            InventQty transQtyUnit = this.transQtyUnit();

            if (transQty != 0 && transQtyUnit == 0 ||
                transQty == 0 && transQtyUnit != 0)
            {
                ok = checkFailed("@SYS18730");
            }

            // Check whether this.transQty() and this.transQtyUnit() have different signs.
            boolean qtyUnitSignChanged = transQty != 0.0 && transQtyUnit != 0.0 && sign(transQty) * sign(transQtyUnit) < 0;

            if (qtyUnitSignChanged)
            {
                ok = checkFailed("@SYS10214");
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateEstimatedMovement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the estimated transactions value must be updated.
    /// </summary>
    /// <param name="_movement_Orig">
    ///    The inventory movement class that contains the original values.
    /// </param>
    /// <returns>
    ///    true if the values must be updated; otherwise, false
    /// </returns>
    /// <remarks>
    ///    This method calls the <c>checkUpdateEstimatedMovement</c> method of the <c>InventDim</c> class to
    ///    determine whether the values should be updated.
    /// </remarks>

    public boolean checkUpdateEstimatedMovement(InventMovement _movement_Orig)
    {
        return InventDim::checkUpdateEstimatedMovement(this,_movement_Orig);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateFinancial</Name>
				<Source><![CDATA[
    public boolean checkUpdateFinancial(InventUpd_Financial _updateNow)
    {
        boolean         ok = true;

        if (!  this.canBeUpdatedFinancial())
        {
            ok = checkFailed("@SYS24414");
        }

        if (this.mustBeUnitControlled() && _updateNow.parmPhysicalReduction() == InventPhysicalReduction::None)
        {
            if (_updateNow.parmFinancialUnit() == 0)
            {
                ok =  checkFailed("@SYS4670");
            }

            if (_updateNow.parmFinancial() * _updateNow.parmFinancialUnit() <= 0)
            {
                ok = checkFailed("@SYS5382");
            }
        }

        if (_updateNow.parmFinancial() == 0 && _updateNow.parmPhysicalReduction() == InventPhysicalReduction::None)
        {
            ok = checkFailed("@SYS3595");
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateFinancialLite</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean checkUpdateFinancialLite(InventUpd_FinancialLite _updateNow)
    {
        boolean ok = true;

        if (this.mustCheckLocationBlocking() && WHSBlockingCauseWorkPolicyFlight::instance().isEnabled())
        {
            ok = this.checkLocationBlockingForDims(_updateNow.parmInventDim(), _updateNow.parmInventDimParm()) && ok;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdatePhysical</Name>
				<Source><![CDATA[
    public boolean checkUpdatePhysical(InventUpd_Physical _updateNow)
    {
        boolean             ok = true;

        if (! this.canBeUpdatedPhysical())
        {
            ok = checkFailed("@SYS24007");
        }

        if (ok && #PmfEnabled)
        {
            ok = this.pmfCheckUpdateInvent();
        }

        if (ok && #PdsCatchWeightEnabled)
        {
            ok = inventTable.pdsCheckCWItemSetup();
        }

        if (this.mustCheckTransSign(_updatenow))
        {
            if (_updateNow.parmPhysical() > 0)
            {
                if (this.transIdSum().estimatedIssue() && ! this.transIdSum().deducted())
                {
                    ok = checkFailed("@SYS2298");
                }
            }
            else
            if (_updateNow.parmPhysical() < 0)
            {
                if (this.transIdSum().ordered() &&  ! this.transIdSum().received())
                {
                    ok = checkFailed("@SYS2298");
                }
            }
        }

        if (this.transQty() * _updateNow.parmRemainPhysical() < 0)
        {
            ok = checkFailed("@SYS7676");
        }

        if (! this.checkUpdatePhysicalQty(_updateNow))
        {
            ok = false;
        }

        if (! InventUpd_Physical::checkUpdRemainQty(_updateNow.parmRemainPhysical(),
                                                    this.inventTableInvent().UnitId,
                                                    _updateNow.parmRemainPhysicalUnit(),
                                                    this.transUnitId()))
        {
            ok = false;
        }

        // <GEERU>
        if (this.parmCompanyCountryRegion().isCountryRegionRU())
        {
            physicalInventDimCriteria       = _updateNow.parmInventDim();
            physicalInventDimParmCriteria   = _updateNow.parmInventDimParm();
        }
        // </GEERU>

        if (this.mustCheckOverDeliveryForQty(_updateNow.parmPhysical())
        && !this.checkNotOverDelivery(_updateNow.parmPhysical(), true, _updateNow.parmPdsCWPhysical()))
        {
            ok = false;
        }

        if (! this.checkNotSubDelivery(_updateNow.parmPhysical(), _updateNow.parmRemainPhysical(),true
            , _updateNow.parmPdsCWPhysical()
            , _updateNow.parmPdsCWRemainPhysical()
        ))
        {
            ok = false;
        }

        if (_updateNow.parmReturnMode() == InventUpdate::financialReturn())
        {
            if (abs(this.transIdSum().physical() + this.transIdSum().financial()) < abs(_updateNow.parmPhysical()))
            {
                ok = checkFailed("@SYS4903");
            }
        }
        else
        if (_updateNow.parmReturnMode() == InventUpdate::physicalReturn())
        {
            if (abs(this.remainFinancialUnit()) < abs(_updateNow.parmPhysicalUnit()))
            {
                if (this.remainFinancialUnit() > 0)
                {
                    ok = checkFailed(strFmt("@SYS70374",abs(this.remainFinancialUnit())));
                }
                else
                {
                    ok = checkFailed("@SYS10627");
                }
            }
        }
        else
        {
            if (_updateNow.parmPhysical() > 0)
            {
                if (_updateNow.parmPhysical() + _updateNow.parmRemainPhysical() < this.transIdSum().registered())
                {
                    ok = checkFailed(strFmt("@SYS54072", this.transIdSum().registered(), _updateNow.parmPhysical(), _updateNow.parmRemainPhysical()));
                }
            }
            else
            if (_updateNow.parmPhysical() < 0)
            {
                if (_updateNow.parmPhysical() + _updateNow.parmRemainPhysical() > this.transIdSum().picked())
                {
                    ok = checkFailed(strFmt("@SYS54073", -this.transIdSum().picked(), -_updateNow.parmPhysical(), -_updateNow.parmRemainPhysical()));
                }
            }
        }

        if (!(_updateNow.parmPhysical() < 0
                && this.remainPhysical() < 0
                && _updateNow.parmPhysical() > this.remainPhysical()
                && this.haveAllIssueTransactionsBeenPhysicallyUpdated()))
        {
            ok = this.checkLocationBlockingForDims(_updateNow.parmInventDim(), _updateNow.parmInventDimParm()) && ok;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLocationBlockingForDims</Name>
				<Source><![CDATA[
    private boolean checkLocationBlockingForDims(InventDim inventDimUpdateCriteria, InventDimParm inventDimUpdateParm)
    {
        boolean ok = true;

        if (inventDimUpdateCriteria.InventLocationId
            && inventDimUpdateCriteria.wMSLocationId
            && inventDimUpdateParm.InventLocationIdFlag
            && inventDimUpdateParm.WMSLocationIdFlag)
        {
            ok = this.checkLocationBlocking(inventDimUpdateCriteria) && ok;
        }
        else
        {
            ok = this.checkLocationBlocking() && ok;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>haveAllIssueTransactionsBeenPhysicallyUpdated</Name>
				<Source><![CDATA[
    private boolean haveAllIssueTransactionsBeenPhysicallyUpdated()
    {
        return this.transIdSum().onOrder() == 0
            && this.transIdSum().pdsCWOnOrder() == 0
            && this.transIdSum().reservPhysical() == 0
            && this.transIdSum().pdsCWReservPhysical() == 0
            && this.transIdSum().reserveOrdered() == 0
            && this.transIdSum().pdsCWReserveOrdered() == 0
            && this.transIdSum().quotationIssue() == 0
            && this.transIdSum().pdsCWQuotationIssue() == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdatePhysicalQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the inventory unit and quantity.
    /// </summary>
    /// <param name="_updateNow">
    /// The <c>InventUpd_Physical</c> that carries the fields to be validated.
    /// </param>
    /// <returns>
    /// true if the inventory unit and quantity are valid; otherwise, false.
    /// </returns>
    [Replaceable]
    protected boolean checkUpdatePhysicalQty(InventUpd_Physical _updateNow)
    {
        return InventUpd_Physical::checkUpdQty(
            _updateNow.parmPhysical(),
            this.inventTableInvent().UnitId,
            _updateNow.parmPhysicalUnit(),
            this.transType() != InventTransType::Project ? this.transUnitId() : this.inventTableInvent().UnitId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckTransSign</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the sign of the inventory quantity should be checked.
    /// </summary>
    /// <param name = "_updateNow">
    ///     An instance of the <c>InventUpd_Reservation</c> class that contains the current inventory update reservation.
    /// </param>
    /// <returns>
    ///     true if the sign of the inventory quantity should be checked; otherwise, false.
    /// </returns>
    protected boolean mustCheckTransSign(InventUpd_Physical _updateNow)
    {
        return (!this.mustBeSameTransSign() && !_updateNow.parmReturnMode()); 
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdatePicked</Name>
				<Source><![CDATA[
    public boolean checkUpdatePicked(InventUpd_Picked _updateNow)
    {
        boolean ok = true;

        if (! this.canBeUpdatedPicked())
        {
            ok = checkFailed("@SYS54065");
        }

        if (this.mustCheckOverDeliveryForQty(_updateNow.parmPicked()))
        {
            ok = this.checkNotOverDelivery(_updateNow.parmPicked(),false
                , _updateNow.parmPdsCWPicked()
            ) && ok;
        }
        ok = this.checkDimFieldsValid(_updateNow.parmPickInventDimCriteria(),null, _updateNow.canSkipProductDimensionCheck()) && ok;
        ok = this.checkLocationBlocking(_updateNow.parmPickInventDimCriteria()) && ok;

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateRegistered</Name>
				<Source><![CDATA[
    public boolean checkUpdateRegistered(InventUpd_Registered _updateNow)
    {
        boolean             ok = true;

        if (! this.canBeUpdatedRegistered())
        {
            ok = checkFailed("@SYS54064");
        }

        if (this.mustCheckOverDeliveryForQty(_updateNow.parmRegistered()))
        {
            ok = this.checkNotOverDelivery(_updateNow.parmRegistered(), false
                , _updateNow.parmPdsCWRegistered()
            ) && ok;
        }
        ok = this.checkDimFieldsValid(_updateNow.parmRegInventDimCriteria(), null, _updateNow.canSkipProductDimensionCheck()) && ok;
        ok = this.checkLocationBlocking(_updateNow.parmArrInventDimCriteria()) && ok;

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateReservation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the used inventory movement against an inventory update reservation.
    /// </summary>
    /// <param name="_updateNow">
    ///    An instance of the <c>InventUpd_Reservation</c> class that contains the current inventory update
    ///    reservation.
    /// </param>
    /// <returns>
    ///    true if the inventory movement is valid; otherwise, false.
    /// </returns>
    public boolean checkUpdateReservation(InventUpd_Reservation _updateNow)
    {
        boolean     result = true;

        if (   _updateNow
            && _updateNow.parmReservation() < 0)
        {
            InventDim inventDimCriteria = _updateNow.parmInventDimCriteria();

            if (   !this.canBeOnSupermarket()
                && inventDimCriteria.isSupermarket())
            {
                result = checkFailed(strFmt("@SYS4006536",inventDimCriteria.wmsLocationId));
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateStandard</Name>
				<Source><![CDATA[
    public boolean checkUpdateStandard(
        TransDate       _transDate,
        NoYes           _checkItemPostingDate = NoYes::Yes)
    {
        boolean ok = true;

        ok = this.inventTable().checkValid(this.itemId())                    && ok;

        if (this.shouldCheckStoppedItem())
        {
            ok = this.inventItemOrderCheckNotStopped()                       && ok;
            ok = this.checkForStoppedProducts()                              && ok;
        }

        ok = (!_checkItemPostingDate ||
              InventUpdate::checkItemPostingDate(this.itemId(), _transDate)) && ok;
        ok = this.checkWMSLocation()                                         && ok;

        // <GEERU>
        if (this.parmCompanyCountryRegion().isCountryRegionRU()
            && ! InventClosing::checkOpen(_transDate, false, InventTransCurrency_RU::SecondaryCur))
        {
            ok = false;
        }
        // </GEERU>
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWHSLoadLineInventTransConsistency</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the <c>WHSLoadLine</c> table related to the source line is in sync with the inventory transactions.
    /// </summary>
    /// <param name="_onlyCheckWork">
    /// Determines if we only need to check for conflict with work created quantity instead of doing full check.
    /// </param>
    public void checkWHSLoadLineInventTransConsistency(boolean _onlyCheckWork = false)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>canHaveOutboundLoadLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the source can have an outbound load line.
    /// </summary>
    /// <returns>
    /// true if it can be on an outbound load line; otherwise, false
    /// </returns>
    public boolean canHaveOutboundLoadLine()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWMSLocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks the <c>InventDim.WMSLocationId</c> field of the inventory dimensions of the movement.
    /// </summary>
    /// <returns>
    ///    true if the warehouse location is valid; otherwise, false.
    /// </returns>
    public boolean checkWMSLocation()
    {
        boolean ok = true;

        if (!this.canBeOnSupermarket()     &&
            this.inventdim().wmsLocationId &&
            this.inventdim().wmsLocation().LocationType == WMSLocationType::KanbanSupermarket)
        {
            ok = ok && checkFailed(strFmt("@SYS135900",this.transId(),this.inventdim().wmsLocationId));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>childBuffer</Name>
				<Source><![CDATA[
    public Common childBuffer(Common _common = null)
    {
        return _common;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearInventRefFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets reference fields based on owner so that they do not reference anything.
    /// </summary>
    public void clearInventRefFields()
    {
        if (this.markingRefInventTransOrigin())
        {
            this.setInventRefFields(InventRefType::None,'',0);
            this.updateDoBuffer();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>componentInventTransOriginIds</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the IDs of the component inventory transaction originator that corresponds to the movement.
    /// </summary>
    /// <returns>
    ///    The IDs of the component inventory transaction originator that corresponds to the movement.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden in relevant inherited classes.
    /// </remarks>
    public Set componentInventTransOriginIds()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>correctionSwapOnItem_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the correction flag should be swapped or not
    /// </summary>
    /// <param name="_amount">
    ///     The adjustment amount
    /// </param>
    /// <returns>
    ///     true if correction flag should be swapped; otherwise, false
    /// </returns>
    protected boolean correctionSwapOnItem_RU(Amount _amount)
    {
        return _amount > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costValueChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the cost amount that gets updated on the inventory transaction.
    /// </summary>
    /// <param name = "_inventTrans">The inventory transaction containing the cost amount.</param>
    /// <returns>The cost amount that gets updated on the inventory transaction.</returns>
    protected CostAmount costValueChanged(InventTrans _inventTrans)
    {
        if(!this.canCostValuebeChanged())
        {
            throw error(Error::missingOverload(funcName()));
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventTransPosting</Name>
				<Source><![CDATA[
    public boolean createInventTransPosting()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOriginOwnerRelationship</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the relationship between the inventory transactions originator and the owner.
    /// </summary>
    /// <remarks>
    ///    This method should be overridden in inherited classes if the relationship is maintained in a
    ///    separate table.
    /// </remarks>
    public void createOriginOwnerRelationship()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createQuarantineOrder</Name>
				<Source><![CDATA[
    public InventQuarantineId createQuarantineOrder(
        InventUpdate    _inventUpd,
        InventTrans     _inventTrans,
        TransDate       _quarantineDate)
    {
        if (! this.mustBeQuarantineControlled())
        {
            return '';
        }

        if (this.mustDoAutoLossProfitPhysical())
        {
            this.parmInventTransOriginIdRef_virtuel(_inventTrans.MarkingRefInventTransOrigin);
        }
        return InventQuarantineOrder::createFromInventUpd(_inventUpd,_inventTrans,_quarantineDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendAc</Name>
				<Source><![CDATA[
    public CustVendAC custVendAc()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultDimension</Name>
				<Source><![CDATA[
    public DimensionDefault defaultDimension()
    {
        return buffer.(fieldName2id(buffer.TableId,fieldStr(InventTransPosting,DefaultDimension)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMainAccountDefaultDimension</Name>
				<Source><![CDATA[
    protected DimensionDefault getMainAccountDefaultDimension(LedgerDimensionDefaultAccount _defaultAccount)
    {
        return MainAccountLegalEntity::findByMainAccountLegalEntity(
                LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(_defaultAccount),
                CompanyInfo::current()).DefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteOriginOwnerRelationship</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the relationship between the inventory transactions originator and the owner.
    /// </summary>
    /// <remarks>
    ///    This method should be overridden in inherited classes if the relationship is maintained in a
    ///    separate table.
    /// </remarks>
    public void deleteOriginOwnerRelationship()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>deliveryPostalAddress</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Identifies the postal delivery address of the inventory movement.
    /// </summary>
    /// <returns>
    ///    An ID of a <c>LogisticsPostalAddress</c> record; otherwise 0.
    /// </returns>
    /// <remarks>
    ///    Only used for shipping deliveries such as sales orders and transfer orders.
    /// </remarks>
    protected LogisticsPostalAddressRecId deliveryPostalAddress()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dimAllowBlankIssue</Name>
				<Source><![CDATA[
    protected boolean dimAllowBlankIssue(InventDimGroupFieldSetup _inventDimGroupFieldSetup)
    {
        return _inventDimGroupFieldSetup.isAllowBlankIssueEnabled() == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dimAllowBlankReceipt</Name>
				<Source><![CDATA[
    protected boolean dimAllowBlankReceipt(InventDimGroupFieldSetup _inventDimGroupFieldSetup)
    {
        return _inventDimGroupFieldSetup.isAllowBlankReceiptEnabled() == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dimParmRelatedUpdate</Name>
				<Source><![CDATA[
    /**
    Used as criteria when finding and updating related inventTrans
    */
    public InventDimParm dimParmRelatedUpdate(InventDim _inventDim = this.inventdim())
    {
        InventDimParm inventDimParm;
        return inventDimParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dirParty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the party ID of the customer or vendor that is related to the movement.
    /// </summary>
    /// <returns>
    ///    The party ID of the customer or vendor that is related to the movement.
    /// </returns>
    /// <remarks>
    ///    This method returns zero when there is no customer or vendor that is related to the movement.
    /// </remarks>
    public DirPartyRecId dirParty()
    {
        CustVendAC     account = this.custVendAc();

        if (!account)
        {
            return 0;
        }

        return CustTable::find(account).Party;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsAdjustIntercompanyRemainInventoryQty</Name>
				<Source><![CDATA[
    public void pdsAdjustIntercompanyRemainInventoryQty()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>dlvMode</Name>
				<Source><![CDATA[
    protected DlvModeId dlvMode()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>dlvTerm</Name>
				<Source><![CDATA[
    protected DlvTermId dlvTerm()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>doScrap</Name>
				<Source><![CDATA[
    protected boolean doScrap()
    {
        return inventType.doScrap();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReturnScrap</Name>
				<Source><![CDATA[
    public boolean isReturnScrap()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doSumUp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sums inventory transactions related to current inventory movement.
    /// </summary>
    public void doSumUp()
    {
        InventTrans         inventTrans;
        InventTransOriginId inventTransOrigId = this.inventTransOriginId();

        if (inventTransOrigId)
        {
            ttsbegin;
            while select forupdate inventTrans where inventTrans.InventTransOrigin == inventTransOrigId
            {
                // Check if inventTrans still exist...
                if (InventTrans::existRecId(inventTrans.RecId))
                {
                    // ... and sum up.
                    inventTrans.updateSumUp();
                }
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ecoResProductDimGroupSetup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves an instance of the <c>EcoResProductDimGroupSetup</c> class that controls how product
    ///    dimensions are configured for this movement.
    /// </summary>
    /// <returns>
    ///    An instance of the <c>EcoResProductDimGroupSetup</c> class.
    /// </returns>
    public EcoResProductDimGroupSetup ecoResProductDimGroupSetup()
    {
        return this.inventDimGroupSetup().ecoResProductDimGroupSetup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>enforceSerialDimensionQuantityControl</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the movement type enforces a quantity of 1.0 for serial control.
    /// </summary>
    /// <returns>
    ///    true if the movement enforces inventory tracking dimension uniqueness;
    ///    otherwise, false.
    /// </returns>
    public boolean enforceSerialDimensionQuantityControl()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>enteredPcsPrice</Name>
				<Source><![CDATA[
    protected PriceCur enteredPcsPrice()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedFinancialValue</Name>
				<Source><![CDATA[
    public CostAmount  estimatedFinancialValue(
        InventTrans     _inventTrans,
        InventOnhand    _inventOnhand)
    {
        InventDimParm   inventDimParmFinancial;
        str             dimFinancial = '';
        CostAmount      value;
        InventQty       qty;
        InventOnhand    financialInventOnHand;

        CostAmount calcCostAmount(Price _pcsPrice)
        {
            InventTableModule   inventTableModule  = this.inventTableInvent();
            InventPriceMarkup   inventPriceMarkup  = inventTableModule.AllocateMarkup ? 0 : inventTableModule.Markup * sign(_inventTrans.Qty);
            InventQty           transQty           = this.transQty();

            if (!transQty)
            {
                transQty = _inventTrans.Qty;
            }
            return CurrencyExchangeHelper::amount((_pcsPrice + inventPriceMarkup / transQty) * _inventTrans.Qty);
        }

        if (_inventTrans.Qty >= 0)
        {
            if (this.canCostValuebeChanged())
            {
                return CurrencyExchangeHelper::amount(this.costValueChanged(_inventTrans));
            }

            if (this.inventModelGroup().inventModelType().stdCostBased())
            {
                return InventModelType_StdCost::estimatedPhysicalValueStdCost(this, _inventTrans);
            }

            return calcCostAmount(this.inventTable().costPcsPrice(_inventTrans.InventDimId));
        }

        if (this.inventModelGroup().inventModelType().stdCostBased())
        {
            return InventModelType_StdCost::estimatedPhysicalValueStdCost(this, _inventTrans);
        }

        if (_inventTrans.MarkingRefInventTransOrigin)
        {
            this.recordFinancialInventDimContext(_inventTrans);
            [qty,value] = this.calcMarkedCostValue(_inventTrans.MarkingRefInventTransOrigin, _inventTrans.InventTransOrigin);

            if (qty > 0 && value > 0)
            {
                return CurrencyExchangeHelper::amount(value / qty * _inventTrans.Qty);
            }
        }

        if (this.canCostValuebeChanged())
        {
            return CurrencyExchangeHelper::amount(this.costValueChanged(_inventTrans));
        }

        this.inventDimGroupSetup().inventDimParmActiveFinancialInventory(inventDimParmFinancial);
        InventDim inventDimFinancial = InventDim::find(_inventTrans.InventDimId);
        inventDimFinancial.clearNotSelectedDim(inventDimParmFinancial);

        dimFinancial = inventDimFinancial.mapKey();

        if (! inventDimCostPrice.exists(dimFinancial))
        {
            if (_inventOnhand && InventDimParm::isInventDimParmEqual(_inventOnhand.parmInventDimParm(),inventDimParmFinancial))
            {
                financialInventOnHand = _inventOnhand;
            }
            else
            {
                inventDimFinancial    = InventDim::findOrCreate(inventDimFinancial);
                financialInventOnHand = InventOnhand::newItemDim(this.itemId(), inventDimFinancial, inventDimParmFinancial);
            }

            inventDimCostPrice.insert(dimFinancial, financialInventOnHand.costPricePcs());
        }
        return calcCostAmount(inventDimCostPrice.lookup(dimFinancial));
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedFinancialValueSecCur_RU</Name>
				<Source><![CDATA[
    public CostAmount estimatedFinancialValueSecCur_RU(
        InventTrans     _inventTrans,
        InventOnhand    _inventOnhand)
    {
        InventDimParm   inventDimParmFinancial;
        str             dimFinancial = '';
        CostAmount      value;
        InventQty       qty;
        InventOnhand    financialInventOnHand;

        CostAmount calcCostAmount(Price _pcsPrice)
        {
            InventTableModule   inventTableModule  = this.inventTableInvent();
            InventPriceMarkup   inventPriceMarkup  = inventTableModule.AllocateMarkup ? 0 : inventTableModule.Markup * sign(_inventTrans.Qty);
            InventQty           transQty           = this.transQty();

            if (!transQty)
            {
                transQty = _inventTrans.Qty;
            }
            return CurrencyExchangeHelper::amount((_pcsPrice + inventPriceMarkup / transQty) * _inventTrans.Qty, CompanyInfoHelper::secondaryCurrency_RU());
        }

        if (_inventTrans.Qty >= 0)
        {
            if (this.canCostValuebeChanged())
            {
                value = CurrencyExchangeHelper::amountMST2MSTSecond_RU(this.costValueChanged(_inventTrans));
            }
            else if (this.inventModelGroup().inventModelTypeSecCur_RU().stdCostBased())
            {
                value = InventModelType_StdCost::estimatedPhysicalValueStdCostSecCur_RU(this, _inventTrans);
            }
            else
            {
                value = calcCostAmount(this.inventTable().costPcsPriceSecCur_RU(_inventTrans.InventDimId));
            }

            if (!value)
            {
                value = CurrencyExchangeHelper::amountMST2MSTSecond_RU(this.inventTable().costPcsPrice(_inventTrans.InventDimId) * _inventTrans.Qty);
            }

            return value;
        }

        if (this.inventModelGroup().inventModelTypeSecCur_RU().stdCostBased())
        {
            return InventModelType_StdCost::estimatedPhysicalValueStdCostSecCur_RU(this, _inventTrans);
        }

        if (_inventTrans.MarkingRefInventTransOrigin)
        {
            [qty, value] = InventTransOrigin::calcMarkedCostValueSecCur_RU(_inventTrans.MarkingRefInventTransOrigin,
                                                                           this.itemId(),
                                                                           this.inventModelGroup().InclPhysicalValueInCost,
                                                                           _inventTrans.InventTransOrigin);

            if (qty > 0 && value > 0)
            {
                return CurrencyExchangeHelper::amount(value / qty * _inventTrans.Qty, CompanyInfoHelper::secondaryCurrency_RU());
            }
        }

        if (this.canCostValuebeChanged())
        {
            return CurrencyExchangeHelper::amountMST2MSTSecond_RU(this.costValueChanged(_inventTrans));
        }

        this.inventDimGroupSetup().inventDimParmActiveFinancialInventory(inventDimParmFinancial);

        InventDim inventDimFinancial = InventDim::find(_inventTrans.InventDimId);
        inventDimFinancial.clearNotSelectedDim(inventDimParmFinancial);

        dimFinancial = inventDimFinancial.mapKey();

        if (!inventDimCostPriceSecCur.exists(dimFinancial))
        {
            if (_inventOnhand && InventDimParm::isInventDimParmEqual(_inventOnhand.parmInventDimParm(), inventDimParmFinancial))
            {
                financialInventOnHand = _inventOnhand;
            }
            else
            {
                inventDimFinancial    = InventDim::findOrCreate(inventDimFinancial);
                financialInventOnHand = InventOnhand::newItemDim(this.itemId(), inventDimFinancial, inventDimParmFinancial);
            }

            inventDimCostPriceSecCur.insert(dimFinancial, financialInventOnHand.costPriceSecPcs_RU());
        }
        return calcCostAmount(inventDimCostPriceSecCur.lookup(dimFinancial));
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedPhysicalRevenue</Name>
				<Source><![CDATA[
    protected AmountMSTPhysicalRevenue estimatedPhysicalRevenue(InventTrans _inventTrans)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedPhysicalTax</Name>
				<Source><![CDATA[
    protected AmountMST estimatedPhysicalTax(InventTrans _inventTrans)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcReceiptPhysicalCostAmount</Name>
				<Source><![CDATA[
    [Wrappable(false), Hookable(false)]   
    protected CostAmount calcReceiptPhysicalCostAmount(
        InventTrans     _inventTrans,
        InventUpd_Physical  _update)
    {
        if (_update
            && _update.parmCostInputAmount())
        {
            return _update.parmCostInputAmount().getAmount(_inventTrans.Qty);
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedPhysicalValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Get the estimated physical value for an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The <c>inventTrans</c> record for which to get the estimated physical value.
    /// </param>
    /// <param name="_inventOnhand">
    ///    The <c>InventOnHand</c> object.
    /// </param>
    /// <param name="_updateNow">
    ///    The <c>InventUpdate</c> object.
    /// </param>
    /// <returns>
    ///    The estimated physical value for the inventory transaction.
    /// </returns>
    protected CostAmount estimatedPhysicalValue(
        InventTrans     _inventTrans,
        InventOnhand    _inventOnhand,
        InventUpdate    _updateNow)
    {
        CostAmount          costAmount;
        InventUpd_Physical  update = _updateNow as InventUpd_Physical;

        if (update
            && update.parmCostInputAmount()
            && _inventTrans.Qty >= 0
            && !this.inventModelGroup().StandardCost
            )
        {
            costAmount = this.calcReceiptPhysicalCostAmount(_inventTrans, update);
        }
        else
        {
            costAmount = this.estimatedFinancialValue(_inventTrans, _inventOnhand);
        }

        return costAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedPhysicalValuePublic</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the estimated physical value of an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    /// The <c>inventTrans</c> record for which to get the estimated physical value.
    /// </param>
    /// <param name="_inventOnhand">
    /// An <c>InventOnHand</c> object.
    /// </param>
    /// <param name="_updateNow">
    /// An <c>InventUpdate</c> object.
    /// </param>
    /// <returns>
    /// The estimated physical value for the inventory transaction.
    /// </returns>
    public CostAmount estimatedPhysicalValuePublic(
        InventTrans     _inventTrans,
        InventOnhand    _inventOnhand,
        InventUpdate    _updateNow)
    {
        return this.estimatedPhysicalValue(_inventTrans, _inventOnhand, _updateNow);
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedPhysicalValueSecCur_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Get the estimated physical value in reporting currency for an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The <c>inventTrans</c> record for which to get the estimated physical value in reporting currency.
    /// </param>
    /// <param name="_inventOnhand">
    ///    The <c>InventOnHand</c> object.
    /// </param>
    /// <param name="_updateNow">
    ///    The <c>InventUpdate</c> object.
    /// </param>
    /// <returns>
    ///    The estimated physical value in reporting currency for the inventory transaction.
    /// </returns>
    protected CostAmount estimatedPhysicalValueSecCur_RU(
        InventTrans     _inventTrans,
        InventOnhand    _inventOnhand,
        InventUpdate    _updateNow)
    {
        CostAmount          costAmount;
        InventUpd_Physical  update = _updateNow as InventUpd_Physical;

        if (update
            && update.parmCostInputAmountSecCur_RU()
            && _inventTrans.Qty >= 0
            && !this.inventModelGroup().StandardCost
            )
        {
            costAmount = update.parmCostInputAmountSecCur_RU().getAmount(_inventTrans.Qty);
        }
        else
        {
            costAmount = this.estimatedFinancialValueSecCur_RU(_inventTrans, _inventOnhand);
        }

        return costAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedPhysicalValueSecCurPublic_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Get the estimated physical value in reporting currency for an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The <c>inventTrans</c> record for which to get the estimated physical value in reporting currency.
    /// </param>
    /// <param name="_inventOnhand">
    ///    The <c>InventOnHand</c> object.
    /// </param>
    /// <param name="_updateNow">
    ///    The <c>InventUpdate</c> object.
    /// </param>
    /// <returns>
    ///    The estimated physical value in reporting currency for the inventory transaction.
    /// </returns>
    public CostAmount estimatedPhysicalValueSecCurPublic_RU(
        InventTrans     _inventTrans,
        InventOnhand    _inventOnhand,
        InventUpdate    _updateNow)
    {
        return this.estimatedPhysicalValueSecCur_RU(_inventTrans, _inventOnhand, _updateNow);
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialIssueCostValue</Name>
				<Source><![CDATA[
    public CostAmount financialIssueCostValue(
        InventTrans      _inventTrans,
        InventOnhand     _inventOnhand)
    {
        CostAmount  value;
        InventQty   qty;
        InventTrans receiptInventTrans;

        if (_inventTrans.Qty >= 0 || ! _inventOnhand)
        {
            throw error(strFmt("@SYS22828",funcName()));
        }

        if (this.inventModelGroup().StandardCost)
        {
            return CurrencyExchangeHelper::amount(this.inventTable().costPcsPrice(_inventTrans.InventDimId) * _inventTrans.Qty);
        }

        if (this.useEnteredPriceAsCost())
        {
            return CurrencyExchangeHelper::amount(this.enteredPcsPrice() * _inventTrans.Qty);
        }

        InventTransOriginId markingReferenceId = _inventTrans.MarkingRefInventTransOrigin;
        if (markingReferenceId)
        {
            // In case of quarantine existence getting the <c> InventTransOrigin </c> value of the original transaction.
            if (_inventTrans.ProjId)
            {
                markingReferenceId = this.getVirtualTransMarkingRefBasedOnQuarantineExistence(markingReferenceId);
            }

            this.recordFinancialInventDimContext(_inventTrans);
            [qty,value] = this.calcMarkedCostValue(markingReferenceId, _inventTrans.InventTransOrigin);

            if (qty > 0 && value >= 0)
            {
                return CurrencyExchangeHelper::amount(value / qty * _inventTrans.Qty);
            }
        }

        // Inventjournal service item
        if (this.canCostValuebeChanged())
        {
            return CurrencyExchangeHelper::amount(this.costValueChanged(_inventTrans));
        }

        //Find the cost price from receipts that are hard marked against the issue
        if (_inventTrans.InvoiceReturned)
        {
            select firstonly InventTransOrigin from receiptInventTrans
                where receiptInventTrans.ReturnInventTransOrigin == _inventTrans.InventTransOrigin;

            if (receiptInventTrans.InventTransOrigin)
            {
                [qty,value] = InventTransOrigin::calcInvoicedCostValue(receiptInventTrans.InventTransOrigin);

                if (qty > 0 && value >= 0)
                {
                    return CurrencyExchangeHelper::amount(value / qty * _inventTrans.Qty);
                }
            }
        }

        // Find the cost price from the current on-hand inventory
        InventSum inventSum = _inventOnhand.inventSumWithoutAvailability(false);

        CostPrice price = inventSum.costPricePcs(true);

        // Fall back to the values on the transaction if necessary
        if (price == 0)
        {
            value = _inventTrans.CostAmountPhysical;
            qty   = _inventTrans.Qty;

            if ((value < 0 && qty < 0) || (value > 0 && qty > 0))
            {
                price = value / qty;
            }
        }

        // If nothing else worked, fall back to the item master
        if (price == 0)
        {
            return CurrencyExchangeHelper::amount(this.inventTable().costPcsPrice(_inventTrans.InventDimId) * _inventTrans.Qty);
        }
        return CurrencyExchangeHelper::amount(price * _inventTrans.Qty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialIssueCostValueSecCur_RU</Name>
				<Source><![CDATA[
    public CostAmount financialIssueCostValueSecCur_RU(
        InventTrans      _inventTrans,
        InventOnhand     _inventOnhand)
    {
        CostAmount  value;
        InventQty   qty;
        InventTrans receiptInventTrans;

        if (_inventTrans.Qty >= 0 || !_inventOnhand)
        {
            throw error(strFmt("@SYS22828", funcName()));
        }

        if (this.inventModelGroup().StandardCost)
        {
            return CurrencyExchangeHelper::amount(this.inventTable().costPcsPriceSecCur_RU(_inventTrans.InventDimId) * _inventTrans.Qty, CompanyInfoHelper::secondaryCurrency_RU());
        }

        if (this.useEnteredPriceAsCost())
        {
            return CurrencyExchangeHelper::amountMST2MSTSecond_RU(this.enteredPcsPrice() * _inventTrans.Qty);
        }

        if (_inventTrans.MarkingRefInventTransOrigin)
        {
            [qty, value] = InventTransOrigin::calcMarkedCostValueSecCur_RU(_inventTrans.MarkingRefInventTransOrigin,
                                                                           this.itemId(),
                                                                           this.inventModelGroup().InclPhysicalValueInCost,
                                                                           _inventTrans.InventTransOrigin);

            if (qty > 0 && value >= 0)
            {
                return CurrencyExchangeHelper::amount(value / qty * _inventTrans.Qty, CompanyInfoHelper::secondaryCurrency_RU());
            }
        }

        // Inventjournal service item
        if (this.canCostValuebeChanged())
        {
            return CurrencyExchangeHelper::amountMST2MSTSecond_RU(this.costValueChanged(_inventTrans));
        }

        //Find the cost price from receipts that are hard marked against the issue
        if (_inventTrans.InvoiceReturned)
        {
            select firstonly InventTransOrigin from receiptInventTrans
                where receiptInventTrans.ReturnInventTransOrigin == _inventTrans.InventTransOrigin;

            if (receiptInventTrans.InventTransOrigin)
            {
                [qty, value] = InventTransOrigin::calcInvoicedCostValueSecCur_RU(receiptInventTrans.InventTransOrigin);

                if (qty > 0 && value >= 0)
                {
                    return CurrencyExchangeHelper::amount(value / qty * _inventTrans.Qty, CompanyInfoHelper::secondaryCurrency_RU());
                }
            }
        }

        // Find the cost price from the current on-hand inventory
        InventSum inventSum = _inventOnhand.inventSumWithoutAvailability(false);

        CostPrice price = inventSum.costPriceSecCurPcs_RU(true);

        // Fall back to the values on the transaction if necessary
        if (price == 0)
        {
            value = _inventTrans.CostAmountSecCurPhysical_RU;
            qty   = _inventTrans.Qty;

            if (value > 0 && qty > 0)
            {
                price = value / qty;
            }
        }

        // If nothing else worked, fall back to the item master
        if (price == 0)
        {
            return CurrencyExchangeHelper::amount(this.inventTable().costPcsPriceSecCur_RU(_inventTrans.InventDimId) * _inventTrans.Qty, CompanyInfoHelper::secondaryCurrency_RU());
        }

        return CurrencyExchangeHelper::amount(price * _inventTrans.Qty, CompanyInfoHelper::secondaryCurrency_RU());
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialUpdateReceiptQty_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets financial update receipt quantity and CW financial update receipt quantity
    /// </summary>
    /// <param name="_inventTrans">
    /// InventTrans table buffer
    /// </param>
    /// <returns>
    /// return as [qty, cwQty]
    /// </returns>
    /// <remarks>
    /// This method shall be called in Indian country context, it provides same implementation as Sys, this is
    /// a window to be overridden provided to sub movement classes, and allow India specific implementations
    /// to return correct quantity and CW quantity
    /// </remarks>
    public container financialUpdateReceiptQty_IN(InventTrans _inventTrans)
    {
        return [_inventTrans.Qty, _inventTrans.PdsCWQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>forceReturnLotInInventTrans_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Specifies whether a Return lot will be write down to the inventory transaction against a common rules.
    /// </summary>
    /// <returns>
    ///     True  if a Return lot will be write down to the inventory transaction; otherwise, false.
    /// </returns>
    public NoYes forceReturnLotInInventTrans_RU()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>freightSlipType</Name>
				<Source><![CDATA[
    protected FreightSlipType freightSlipType()
    {
        return FreightSlipType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>freightZone</Name>
				<Source><![CDATA[
    protected FreightZoneId freightZone()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExpiryCheckDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the date against which to check the expiry date of an inventory batch.
    /// </summary>
    /// <returns>
    /// The date against which to check the expiry date.
    /// </returns>
    /// <remarks>
    /// By default the method returns the result of the transDate method of the movement.Derived classes
    /// should override this method to return dates different from the <c>transDate</c> method.
    /// </remarks>
    public TransDate getExpiryCheckDate()
    {
        return this.transDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventDimForIssueTransFromReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the <c>InventDim</c> that should be put on the issue transaction during a receipt which updates the issue transaction for WHS items.
    /// </summary>
    /// <param name="_inventDimIssue">
    /// The original issue transaction <c>InventDim</c>
    /// </param>
    /// <param name="_inventDimReceipt">
    /// The receipt transaction <c>InventDim</c>
    /// </param>
    /// <returns>
    /// The new issue transaction <c>InventDim</c>
    /// </returns>
    /// <remarks>
    /// By default the issue transaction will keep it's original dimensions.
    /// </remarks>
    public InventDim getInventDimForIssueTransFromReceipt(
        InventDim _inventDimIssue,
        InventDim _inventDimReceipt)
    {
        InventDim retInventDim;

        if (this.canHaveReservedWork()
           && _InventDimReceipt.inventLocationId
           && _inventDimReceipt.inventLocation().WHSEnabled)
        {
            retInventDim = InventDim::find(_inventDimReceipt.inventDimId);
            retInventDim.clearLocationAndBelowDim(this.itemId());
            retInventDim = InventDim::findOrCreate(retInventDim);
        }
        else
        {
            retInventDim = _inventDimIssue;
        }

        return retInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getModuleType_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the value of module type.
    /// </summary>
    /// <returns>
    /// Module Type.
    /// </returns>
    /// <remarks>
    /// Because the method moduleType is changed from public to protected,
    /// this method is added to be used by other classes.
    /// </remarks>
    public ModuleInventPurchSales getModuleType_CN()
    {
        return this.moduleType();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQtyPreForNotOverDeliveryCheck_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the pre-post trans quantity of current inventory transaction
    /// </summary>
    /// <returns>
    /// The pre-post trans quantity of current inventory transaction
    /// </returns>
    /// <remarks>
    /// This method shall be called in Indian country context, it provides same implementation as Sys, this is
    /// a window to be overridden provided to sub movement classes, and allow India specific implementations
    /// to return pre-post trans quantity of current inventory transaction
    /// </remarks>
    protected UnitQty getQtyPreForNotOverDeliveryCheck_IN()
    {
        InventMovement  parentMovement = this.parentMovement();

        return abs(parentMovement.transQty());
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasBestBeforeDateLimit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value indicating whether the movement imposes a limitation on the best before date of the product that needs to be moved.
    /// </summary>
    /// <returns>
    /// true if there is a limitation on the best before date of the product that needs to be moved; otherwise false.
    /// </returns>
    protected boolean hasBestBeforeDateLimit()
    {
        return this.needsShelfLifeCheck() && this.inventModelGroup().PdsPickCriteria == PdsPickCriteria::BestBeforeDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasExpiryDateLimit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value indicating whether the movement imposes a limitation on the expiry date of the product that needs to be moved.
    /// </summary>
    /// <returns>
    /// true if there is a limitation on the expiry date of the product that needs to be moved; otherwise false.
    /// </returns>
    protected boolean hasExpiryDateLimit()
    {
        return this.needsShelfLifeCheck() && this.inventModelGroup().PdsPickCriteria == PdsPickCriteria::ExpiryDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasVirtualTransactions</Name>
				<Source><![CDATA[
    public boolean hasVirtualTransactions()
    {
        return InventTransOrigin::findMarkingRefInventTransOrigin(this.inventTransOriginId(),this.itemId(),true)? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDimParmAutoReserv</Name>
				<Source><![CDATA[
    public InventDimParm initDimParmAutoReserv(
        InventDim           _inventDimCriteria,
        InventDimParm       _inventDimParm = null)
    {
        _inventDimParm.initPhysicalDimensionsFromInventDim(this.inventDimGroupSetup(),_inventDimCriteria);
        return _inventDimParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initForAutoReservation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the movement for auto reservation.
    /// </summary>
    public void initForAutoReservation()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeFromTmpInventTransWMS</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the movement from <c>TmpInventTransWMS</c>.
    /// </summary>
    /// <param name = "_tmpInventTransWMS">A <c>TmpInventTransWMS</c> record.</param>
    public void initializeFromTmpInventTransWMS(TmpInventTransWMS _tmpInventTransWMS)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransFinancial</Name>
				<Source><![CDATA[
    public void initInventTransFinancial(
        InventTrans          _inventTrans,
        TransDate            _dateFinancial,
        InvoiceId            _invoiceId,
        CurrencyCode         _currencyCode)
    {
        _inventTrans.InvoiceId          = _invoiceId;
        _inventTrans.DateFinancial      = _dateFinancial;
        _inventTrans.CurrencyCode       = _currencyCode;
        _inventTrans.ProjCategoryId     = this.projCategoryId();
        _inventTrans.ActivityNumber     = this.activityNumber();
        // <GEERU>
        _inventTrans.Storno_RU          = this.parmStorno_RU();
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransFromBuffer</Name>
				<Source><![CDATA[
    public void initInventTransFromBuffer(
        InventTrans     _inventTrans,
        InventMovement  _movement_orig)
    {
        _inventTrans.ItemId                = this.itemId();
        _inventTrans.InventTransOrigin     = this.inventTransOriginId();
        _inventTrans.ProjId                = this.projId();
        _inventTrans.ProjCategoryId        = this.projCategoryId();
        _inventTrans.ActivityNumber        = this.activityNumber();
        _inventTrans.DateExpected          = this.transDate() ? this.transDate() : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        _inventTrans.TimeExpected          = this.transSchedTime();
        _inventTrans.ShippingDateRequested = this.shippingDateRequested();
        _inventTrans.ShippingDateConfirmed = this.shippingDateConfirmed();
        // <GEERU>
        _inventTrans.Storno_RU             = this.parmStorno_RU();
        // </GEERU>

        InventTransOriginId markingRefInventTransOrigin = _movement_orig == null || _movement_orig.markingRefInventTransOrigin() == _inventTrans.MarkingRefInventTransOrigin ? this.markingRefInventTransOrigin() : _inventTrans.MarkingRefInventTransOrigin;
        _inventTrans.setMarking(markingRefInventTransOrigin);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransPhysical</Name>
				<Source><![CDATA[
    public void initInventTransPhysical(
        InventTrans         _inventTrans,
        TransDate           _datePhysical,
        PackingSlipId       _packingSlipId)
    {
        _inventTrans.PackingSlipId      = _packingSlipId;
        _inventTrans.DatePhysical       = _datePhysical;
        _inventTrans.ProjCategoryId     = this.projCategoryId();
        _inventTrans.ActivityNumber     = this.activityNumber();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransPicked</Name>
				<Source><![CDATA[
    public void initInventTransPicked(
        InventTrans         _inventTrans,
        WMSPickingRouteID   _pickingRouteId)
    {
        _inventTrans.PickingRouteID = _pickingRouteId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransReceiptId</Name>
				<Source><![CDATA[
    internal void initInventTransReceiptId(
        InventTrans                     _inventTrans,
        WhsLoadLineInventoryReceiptId   _receiptId)
    {
        _inventTrans.ReceiptId = _receiptId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransRegisteredLoad</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the fields on inventTrans when moving to Registered state with Load data.
    /// </summary>
    /// <param name = "_inventTrans">Inventory transaction transitioning to Registered.</param>
    /// <param name = "_loadID">Load associated with inventory registration.</param>
    [Hookable(false)]
    internal void initInventTransRegisteredLoad(
        InventTrans _inventTrans,
        WHSLoadId _loadID)
    {
        _inventTrans.LoadId = _loadId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initWMSOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initialize a <c>WMSOrder</c> record.
    /// </summary>
    /// <param name="_wmsOrder">
    ///    The record buffer to initialize.
    /// </param>
    public void initWMSOrder(WMSOrder _wmsOrder)
    {
        _wmsOrder.InventTransId             = this.transId();
        _wmsOrder.ItemId                    = this.itemId();
        _wmsOrder.InventTransType           = this.transType();
        _wmsOrder.InventTransRefId          = this.transRefId();
        _wmsOrder.InventDimId               = this.inventDimId();
        _wmsOrder.DlvDate                   = this.transDate();
        _wmsOrder.FreightSlipType           = this.freightSlipType();
        _wmsOrder.FreightZone               = this.freightZone();
        _wmsOrder.DlvMode                   = this.dlvMode();
        _wmsOrder.DlvTerm                   = this.dlvTerm();
        _wmsOrder.DeliveryPostalAddress     = this.deliveryPostalAddress();
        _wmsOrder.Customer                  = this.custVendAc();
        _wmsOrder.ShipmentGroupingTransType = this.wmsShipmentGroupingTransType();
        _wmsOrder.ShipmentGroupingRefId     = this.wmsShipmentGroupingRefId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>informAboutIncompleteMarking</Name>
				<Source><![CDATA[
    /// <summary>
    /// A method to notify users about incomplete marking of quantities.
    /// </summary>
    /// <param name="_totalQty">
    /// Quantity to be marked.
    /// </param>
    /// <param name="_markedQty">
    /// Quantity marked for a transaction.
    /// </param>
    /// <param name="_voucherId">
    /// Voucher used to be marked for a transaction; Optional.
    /// </param>
    /// <remarks>
    /// The method should be overridden by subclasses if needed. It is overridden by the <c>InventMov_PurchCreditNote</c> class.
    /// </remarks>
    public void informAboutIncompleteMarking(InventQty _totalQty, InventQty _markedQty, Voucher _voucherId = '')
    {
        // No implementation in the base class.
    }

]]></Source>
			</Method>
			<Method>
				<Name>relatedVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates a reference voucher related to the movement.
    /// </summary>
    /// <returns>
    /// Empty string by default.
    /// </returns>
    /// <remarks>
    /// The method should be overridden by subclasses if needed. It is overridden by the <c>InventMov_PurchCreditNote</c> class.
    /// </remarks>
    public Voucher relatedVoucher()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertChildBuffer</Name>
				<Source><![CDATA[
    public InventTransChildRefId insertChildBuffer(
        InventDimId     _inventDimId,
        InventQty       _qtyNow,
        UnitQty         _qtyNowUnit,
        boolean         _splitMovement,
        Object          _updateClass = null
        , PdsCWInventQty  _cwQty = 0
        )
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyMarkingAllowed</Name>
				<Source><![CDATA[
    public boolean interCompanyMarkingAllowed()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyMovement</Name>
				<Source><![CDATA[
    public boolean interCompanyMovement()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyTransaction</Name>
				<Source><![CDATA[
    public boolean interCompanyTransaction()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostIndirectFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves an <c>InventCostIndirectFinancial</c> object.
    /// </summary>
    /// <returns>
    ///    An <c>InventCostIndirectFinancial</c> object.
    /// </returns>
    /// <remarks>
    ///    The <c>InventCostIndirectFinancial</c> object is used to update the indirect cost that is related
    ///    to an inventory transaction.
    /// </remarks>
    public InventCostIndirectFinancial inventCostIndirectFinancial()
    {
        if (!inventCostIndirectFinancial)
        {
            inventCostIndirectFinancial = InventCostIndirectFinancial::construct(false);
        }
        return inventCostIndirectFinancial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostIndirectPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a <c>InventCostIndirectPhysical</c> object.
    /// </summary>
    /// <returns>
    ///    An <c>InventCostIndirectPhysical</c> object.
    /// </returns>
    /// <remarks>
    ///    The <c>InventCostIndirectPhysical</c> is used to update the indirect cost that is related to an
    ///    inventory transaction.
    /// </remarks>
    public InventCostIndirectPhysical inventCostIndirectPhysical()
    {
        if (!inventCostIndirectPhysical)
        {
            inventCostIndirectPhysical = InventCostIndirectPhysical::newNoIndirectCost();
        }
        return inventCostIndirectPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventdim</Name>
				<Source><![CDATA[
    public InventDim inventdim(InventDim _inventDim = inventDim)
    {
        inventDim = _inventDim;

        if (!inventDim)
        {
            inventDim = InventDim::find(this.inventDimId());
        }
        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimGroupSetup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves an instance of the <c>InventDimGroupSetup</c> class that controls how inventory
    ///    dimensions are configured for this movement.
    /// </summary>
    /// <param name="_inventDimGroupSetup">
    ///    The new value to use; optional.
    /// </param>
    /// <returns>
    ///    The current instance of the <c>InventDimGroupSetup</c> class.
    /// </returns>
    public InventDimGroupSetup inventDimGroupSetup(InventDimGroupSetup _inventDimGroupSetup = inventDimGroupSetup)
    {
        inventDimGroupSetup = _inventDimGroupSetup;

        if (!inventDimGroupSetup)
        {
            inventDimGroupSetup = InventDimGroupSetup::newItemId(this.itemId());
        }
        return inventDimGroupSetup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimId</Name>
				<Source><![CDATA[
    public InventDimId inventDimId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimMerged</Name>
				<Source><![CDATA[
    public InventDim inventDimMerged(InventDim _inventDim)
    {
        if (!this.isTransfer())
        {
            return _inventDim;
        }

        InventDim inventDimMerged = _inventDim.data();
        inventDimMerged.mergeUsedDim(this.inventDimGroupSetup(), this.inventdim());

        return InventDim::findOrCreate(inventDimMerged);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmMatchTransferTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves an <c>InventDimParm</c> buffer which should be used when finding related
    ///    <c>InventTrans</c> records.
    /// </summary>
    /// <returns>
    ///    An <c>InventDimParm</c> buffer.
    /// </returns>
    /// <remarks>
    ///    This method is used for movements that represent transfers.
    /// </remarks>
    public InventDimParm inventDimParmMatchTransferTrans()
    {
        InventDimParm inventDimParm;
        return inventDimParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventItemInventSetup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an <c>InventItemInventSetup</c> buffer.
    /// </summary>
    /// <param name="_inventDimId">
    /// An <c>InventDimId</c> value that is used as search criteria.
    /// </param>
    /// <returns>
    /// An <c>InventItemInventSetup</c> buffer.
    /// </returns>
    public InventItemInventSetup inventItemInventSetup(InventDimId _inventDimId = this.inventDimId())
    {
        if (inventItemOrderSetupMap         != null
        &&  inventItemOrderSetupMap.TableId == tableNum(InventItemInventSetup)
        &&  _inventDimId                    == lastDimIdForinventItemOrderSetupMapSearch)
        {
            return inventItemOrderSetupMap;
        }

        //if the module type is invent we can cache this as the InventItemOrderSetupMap
        if (InventItemOrderSetupMap::module2SetupType(this.moduleType()) == InventItemOrderSetupType::Invent)
        {
            inventItemOrderSetupMap                     = InventItemInventSetup::find(this.itemId(), _inventDimId);
            lastDimIdForinventItemOrderSetupMapSearch   = _inventDimId;

            return inventItemOrderSetupMap;
        }

        return InventItemInventSetup::find(this.itemId(), _inventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventItemOrderCheckNotStopped</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if the item in question is stopped in the inventory.
    /// </summary>
    /// <returns>
    ///    true if the item is not stopped; otherwise, false.
    /// </returns>
    public boolean inventItemOrderCheckNotStopped()
    {
        return this.inventItemOrderSetupMap().checkNotStopped();
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventItemOrderSetupMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an <c>InventItemOrderSetupMap</c> table map.
    /// </summary>
    /// <param name="_inventDimId">
    /// An <c>InventDimId</c> ID that is used as search criteria.
    /// </param>
    /// <returns>
    /// An <c>InventItemOrderSetupMap</c> table map.
    /// </returns>
    public InventItemOrderSetupMap inventItemOrderSetupMap(InventDimId _inventDimId = this.inventDimId())
    {
        if (inventItemOrderSetupMap                     != null
        &&  lastDimIdForinventItemOrderSetupMapSearch   == _inventDimId)
        {
            return inventItemOrderSetupMap;
        }

        InventItemOrderSetupType setupType = InventItemOrderSetupMap::module2SetupType(this.moduleType());
        if (setupType == InventItemOrderSetupType::Invent)
        {
            inventItemOrderSetupMap = this.inventItemInventSetup(_inventDimId);
        }
        else
        {
            inventItemOrderSetupMap =  InventItemOrderSetupMap::find(this.itemId(), setupType, _inventDimId, false, this.inventTable());
        }

        lastDimIdForinventItemOrderSetupMapSearch = _inventDimId;

        return inventItemOrderSetupMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventLocationId</Name>
				<Source><![CDATA[
    public InventLocationId inventLocationId()
    {
        return this.inventdim().InventLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventModelGroup</Name>
				<Source><![CDATA[
    public InventModelGroup inventModelGroup()
    {
        if (!inventModelGroup)
        {
            inventModelGroup = InventTable::find(this.itemId()).modelGroup();
        }

        return inventModelGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventModelType</Name>
				<Source><![CDATA[
    public InventModelType inventModelType()
    {
        if (!inventModelType)
        {
            inventModelType = this.inventModelGroup().inventModelType();
        }
        return inventModelType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventModelTypeSecCur_RU</Name>
				<Source><![CDATA[
    public InventModelType inventModelTypeSecCur_RU()
    {
        if (!inventModelTypeSecCur)
        {
            inventModelTypeSecCur = this.inventModelGroup().inventModelTypeSecCur_RU();
        }
        return inventModelTypeSecCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventMovSubType</Name>
				<Source><![CDATA[
    public InventMovSubType inventMovSubType(InventMovSubType _subType = subType)
    {
        subType = _subType;
        return subType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventSiteId</Name>
				<Source><![CDATA[
    public InventSiteId inventSiteId()
    {
        return this.inventdim().InventSiteId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTable</Name>
				<Source><![CDATA[
    public InventTable inventTable()
    {
        if (!inventTable)
        {
            inventTable = InventTable::find(this.itemId());
        }
        return inventTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTableInvent</Name>
				<Source><![CDATA[
    public InventTableModule inventTableInvent(boolean _forUpdate = false)
    {
        return InventTableModule::find(this.itemId(),ModuleInventPurchSales::Invent,_forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransOriginId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or retrieves the ID of the inventory transaction originator that corresponds to the movement.
    /// </summary>
    /// <param name="_inventTransOriginId">
    ///    The new value of the ID of the inventory transaction originator.
    /// </param>
    /// <returns>
    ///    The ID of the inventory transaction originator that corresponds to the movement.
    /// </returns>
    public InventTransOriginId inventTransOriginId(InventTransOriginId _inventTransOriginId = inventTransOriginId)
    {
        if (_inventTransOriginId != inventTransOriginId)
        {
            inventTransOriginId = _inventTransOriginId;
        }
        else
        {
            if (!inventTransOriginId)
            {
                inventTransOriginId = InventTransOrigin::findByInventTransId(this.transId()).RecId;
            }
        }

        return inventTransOriginId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCompanyCountryRegion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the <c>CompanyCountryRegion</c> instance associated with the movement.
    /// </summary>
    /// <returns>The <c>CompanyCountryRegion</c> instance associated with the movement.</returns>
    public CompanyCountryRegion parmCompanyCountryRegion()
    {
        if (!companyCountryRegion)
        {
            companyCountryRegion = CompanyCountryRegion::construct(curExt());
        }

        return companyCountryRegion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmConsistencyValidator</Name>
				<Source><![CDATA[
    public InventITransConsistencyValidator parmConsistencyValidator(InventITransConsistencyValidator _consistencyValidator = consistencyValidator)
    {
        consistencyValidator = _consistencyValidator;
        return consistencyValidator;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemWHSEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the item for this movement is enabled for using the WHS system.
    /// </summary>
    /// <returns>
    /// true if the item is enabled for use of the WHS system; Otherwise, false.
    /// </returns>
    public boolean isItemWHSEnabled()
    {
        if (isItemWHSEnabled == UnknownNoYes::Unknown)
        {
            if (WHSInventEnabled::exist(this.itemId()))
            {
                isItemWHSEnabled = UnknownNoYes::Yes;
            }
            else
            {
                isItemWHSEnabled = UnknownNoYes::No;
            }
        }

        return isItemWHSEnabled == UnknownNoYes::Yes ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPrimaryMovement</Name>
				<Source><![CDATA[
    public boolean isPrimaryMovement()
    {
        return this.inventMovSubType() == InventMovSubType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProjTransCorrection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the project transaction should be marked as correction or not.
    /// </summary>
    /// <returns>
    /// true if the transaction should be a correction; otherwise, false.
    /// </returns>
    /// <remarks>
    /// A project transaction will be a correction if: Transaction is of type adjustment and method
    /// <c>parmProjAdjustCorrection</c> returns true, or Transaction is of type item journal and quantity
    /// is receipt and Project parameter to post negative amounts as correction is enabled.
    /// </remarks>
    public LedgerCorrection isProjTransCorrection()
    {
        return ((this.projLedgerOrigin() == ProjOrigin::Adjustment && this.parmProjAdjustCorrection())
                    || (this.projLedgerOrigin() == ProjOrigin::ItemJournal && ProjParameters::find().NegativeTransCorrection && this.transQty() > 0));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetailSalesOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether the current <c>SalesTable</c> record is a Retail sales record.
    /// </summary>
    /// <returns>
    ///     false.
    /// </returns>
    /// <remarks>
    ///     Always return false in instances of the base class.
    /// </remarks>
    public boolean isRetailSalesOrder()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRetailSalesOrderType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the RetailSalesOrderType for the movement.
    /// </summary>
    /// <returns>
    ///     None.
    /// </returns>
    /// <remarks>
    ///     Always return None in instances of the base class.
    /// </remarks>
    public RetailSalesOrderType getRetailSalesOrderType()
    {
        return RetailSalesOrderType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReturned</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the movement represents a return.
    /// </summary>
    /// <param name="_qty">
    ///    The movement quantity.
    /// </param>
    /// <returns>
    ///    true if the movement represents a return; otherwise, false.
    /// </returns>
    public boolean isReturned(InventQty _qty)
    {
        return this.transSign() * _qty < 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStorageDimensionOnlyTransfer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the movement operates only with the storage dimensions during transfers.
    /// </summary>
    /// <returns>
    ///    true if the movement operates only with the storage dimensions during transfers; otherwise, false.
    /// </returns>
    public boolean isStorageDimensionOnlyTransfer()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransfer</Name>
				<Source><![CDATA[
    // returns true if the movement is a transfer of items. This includes transfer orders and quarantine orders
    public NoYes isTransfer()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVirtuel</Name>
				<Source><![CDATA[
    public boolean isVirtuel()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemDescription</Name>
				<Source><![CDATA[
    public ItemFreeTxt itemDescription()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDoPhysicalOnHandCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if physical on-hand check should be done for this movement.
    /// </summary>
    /// <returns>true if physical on-hand availability should be checked; otherwise, false.</returns>
    public boolean mustDoPhysicalOnHandCheck()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemGroupId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves an item group ID of the item related to this movement.
    /// </summary>
    /// <returns>
    ///    An item group ID.
    /// </returns>
    /// <remarks>
    ///    This method caches the item group ID and retrieves it from the cache, if available.
    /// </remarks>
    public ItemGroupId itemGroupId()
    {
        if (!itemGroupId)
        {
            itemGroupId = this.inventTable().itemGroupId();
        }

        return itemGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemId</Name>
				<Source><![CDATA[
    public ItemId itemId()
    {
        return buffer.(fieldName2id(buffer.TableId,fieldStr(InventTable,ItemId)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>markingInventDimParmFixed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills an <c>InventDimParm</c> buffer with values that specify which dimensions are fixed when
    /// marking is applied.
    /// </summary>
    /// <returns>
    /// The <c>InventDimParm</c> buffer.
    /// </returns>
    public InventDimParm markingInventDimParmFixed()
    {
        InventDimParm   inventDimParmPrimary;
        InventDimParm   inventDimParmMovement;

        if (!markingInventDimParmFixedCached)
        {
            // get InventDimParm with primary stocking dimensions flags set to Yes
            this.inventDimGroupSetup().inventDimParmActivePrimaryDimension(inventDimParmPrimary);
            // get InventDimParm with flags set to Yes for every specified dimension for this movement
            inventDimParmMovement.initFromInventDim(this.inventdim());
            // clear primary dimensions which are not specified for this movement
            markingInventDimParmFixed = InventDimParm::andParms(inventDimParmPrimary, inventDimParmMovement);

            markingInventDimParmFixedCached = true;
        }

        return markingInventDimParmFixed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markingPreferPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the physically updated transactions are preferred over expected when finding
    /// transactions for marking.
    /// </summary>
    /// <returns>
    /// Always returns false.
    /// </returns>
    public boolean markingPreferPhysical()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markingRefInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the ID of the marked transaction origin.
    /// </summary>
    /// <returns>
    ///    0 if the whole movement is not marked; otherwise, the ID of the transaction origin marked with.
    /// </returns>
    public InventTransOriginId markingRefInventTransOrigin()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayScrapBeExpected</Name>
				<Source><![CDATA[
    protected boolean mayScrapBeExpected()
    {
        return inventType.mayScrapBeExpected();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrReserveQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the quantity to reserve.
    /// </summary>
    /// <returns>
    /// The quantity reserved.
    /// </returns>
    public InventQty mcrReserveQty()
    {
        // The inventqty amount to be reserved.
        InventQty inventQty = -this.transQty();

        // Can't reserve a negative value entered
        if (inventQty < 0)
        {
            inventQty = 0;
        }
        return inventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrSetInventDeliverNow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the deliver now quantity.
    /// </summary>
    /// <param name="_prevReserve">
    /// The quantity previously reserved.
    /// </param>
    /// <param name="_CurrReserve">
    /// The quantity currently reserved; optional.
    /// </param>
    /// <param name="_availToReserve">
    /// The quantity available to be reserved; optional.
    /// </param>
    public void mcrSetInventDeliverNow(InventQtyAvailReservation  _prevReserve,
                                InventQtyAvailReservation  _CurrReserve = 0,
                                InventQtyAvailReservation  _availToReserve = 0)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrSetReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the quantity to be reserved.
    /// </summary>
    /// <returns>
    /// The quantity to be reserved.
    /// </returns>
    public qty mcrSetReservation()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrSetSalesDeliverNow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the deliver now quantity.
    /// </summary>
    /// <param name="_prevReserve">
    /// The quantity previously reserved.
    /// </param>
    /// <param name="_currReserve">
    /// The quantity currently reserved; optional.
    /// </param>
    /// <param name="_availToReserve">
    /// The quantity available to be reserved; optional.
    /// </param>
    public void mcrSetSalesDeliverNow(InventQtyAvailReservation  _prevReserve,
                                InventQtyAvailReservation  _currReserve = 0,
                                InventQtyAvailReservation  _availToReserve = 0)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrUpdateDetailedStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the sales or purchase order detailed status.
    /// </summary>
    public void mcrUpdateDetailedStatus()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeTransDimTransferReceipt</Name>
				<Source><![CDATA[
    /*
        Returns an InventDim which is merged with this movements inventDim
        Override this method if dimensions should be merged differently
    */
    public InventDim mergeTransDimTransferReceipt(
        InventDim           _toInventDim,
        InventDim           _fromInventDim          = this.inventdim(),
        InventDim           _origFromDim            = _fromInventDim)
    {
        _toInventDim.mergeUsedDim(this.inventDimGroupSetup(), _fromInventDim);

        return _toInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>minAllowedBestBeforeDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the minimum allowed best before date for the movement.
    /// </summary>
    /// <returns>
    /// Minimum allowed best before date for the movement.
    /// </returns>
    /// <remarks>
    /// If the expiry check is not needed for the movement then an empty date will be returned.
    /// </remarks>
    public PdsBestBeforeDate minAllowedBestBeforeDate()
    {
        return this.hasBestBeforeDateLimit() ? this.getExpiryCheckDate() + 1 : dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>minAllowedExpiryDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the minimum allowed batch expiry date for the movement.
    /// </summary>
    /// <returns>
    /// Minimum allowed batch expiry date for the movement.
    /// </returns>
    /// <remarks>
    /// If the expiry check is not needed for the movement then an empty date will be returned.
    /// </remarks>
    public InventBatchExpDate minAllowedExpiryDate()
    {
        return this.hasExpiryDateLimit() ? this.getExpiryCheckDate() : dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>moduleType</Name>
				<Source><![CDATA[
    protected ModuleInventPurchSales moduleType()
    {
        return ModuleInventPurchSales::Invent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustAggregateExpectedTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines whether the expected transactions related to this movement must be aggregated.
    /// </summary>
    /// <returns>
    ///   true if, transactions must be aggregated; otherwise false.
    /// </returns>
    public boolean mustAggregateExpectedTransactions()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeAutoReserved</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the <c>inventMovement</c> object must be auto-reserved.
    /// </summary>
    /// <returns>
    ///    true if the <c>inventMovement</c> object must be auto-reserved; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method is often called together with the <c>canBeReserved</c> method, which returns a default
    ///    <c>Boolean</c> value from the <c>inventType</c> class hierarchy.
    /// </remarks>
    public boolean mustBeAutoReserved()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedBalanceSheet</Name>
				<Source><![CDATA[
    public boolean mustBeBookedBalanceSheet()
    {
        return this.mustBeBookedOnhand();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedCharge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if charges must be booked.
    /// </summary>
    /// <returns>
    /// true if charges must be booked; otherwise, false.
    /// </returns>
    public boolean mustBeBookedCharge()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedFinancially</Name>
				<Source><![CDATA[
    public boolean  mustBeBookedFinancially()
    {
        return this.mustBeBookedBalanceSheet() || this.mustBeBookedOperations();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedOnhand</Name>
				<Source><![CDATA[
    public boolean mustBeBookedOnhand()
    {
        return this.inventModelGroup().PostOnhandFinancial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedOnhandSecCur_RU</Name>
				<Source><![CDATA[
    public boolean mustBeBookedOnhandSecCur_RU()
    {
        return this.inventModelGroup().PostOnhandFinancialSecCur_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedOperations</Name>
				<Source><![CDATA[
    public boolean mustBeBookedOperations()
    {
        return this.mustBeBookedOnhand();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedPhysically</Name>
				<Source><![CDATA[
    public boolean mustBeBookedPhysically()
    {
        return this.inventModelGroup().PostOnhandPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedPhysicalRevenue</Name>
				<Source><![CDATA[
    protected boolean mustBeBookedPhysicalRevenue()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedPhysicalTax</Name>
				<Source><![CDATA[
    protected boolean mustBeBookedPhysicalTax()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeCostControlled</Name>
				<Source><![CDATA[
    public boolean mustBeCostControlled()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canItemReqBeCancelled</Name>
				<Source><![CDATA[
    public boolean canItemReqBeCancelled()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeDeducted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether model group associated with current <c>InventMovement</c> object requires
    ///    mandatory deduct.
    /// </summary>
    /// <returns>
    ///    A Boolean value, which indicates whether model group associated with current <c>InventMovement</c>
    ///    object requires mandatory deduct.
    /// </returns>
    public boolean mustBeDeducted()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeExpectedAgain</Name>
				<Source><![CDATA[
    public boolean mustBeExpectedAgain()
    {
        return inventType.mustInventBeExpectedAgain();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBePicked</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the transactions related to this movement must be picked.
    /// </summary>
    /// <returns>
    ///    true if the transactions must be picked; otherwise, false.
    /// </returns>
    public boolean mustBePicked()
    {
        return this.inventModelGroup().MandatoryPick;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeQuarantineControlled</Name>
				<Source><![CDATA[
    public boolean mustBeQuarantineControlled()
    {
        if (!mustBeQuarantineControledInitialized)
        {
            if (WHSInventEnabled::exist(this.itemId()) && this.inventdim().inventLocation().WHSEnabled)
            {
                mustBeQuarantineControled = false;
            }
            else
            {
                mustBeQuarantineControled =  this.inventModelGroup().QuarantineControl;
            }
            mustBeQuarantineControledInitialized = NoYes::Yes;
        }

        return mustBeQuarantineControled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeQuotationControlled</Name>
				<Source><![CDATA[
    public boolean mustBeQuotationControlled()
    {
        return inventType.mustInventBeQuotationControlled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeReceived</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the model group associated with the current <c>InventMovement</c> object must be
    ///    received.
    /// </summary>
    /// <returns>
    ///    true if the model group associated with current <c>InventMovement</c> object must be received;
    ///    otherwise, false.
    /// </returns>
    public boolean mustBeReceived()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeRegistered</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the transactions that are related to this movement must be registered.
    /// </summary>
    /// <returns>
    ///    true if transactions must be registered; otherwise, false.
    /// </returns>
    public boolean mustBeRegistered()
    {
        if (this.mayScrapBeExpected() && this.doScrap())
        {
            return false;
        }

        return this.inventModelGroup().MandatoryRegister;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeRemainControlled</Name>
				<Source><![CDATA[
    public boolean  mustBeRemainControlled()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeSameTransSign</Name>
				<Source><![CDATA[
    public boolean mustBeSameTransSign()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeUnitControlled</Name>
				<Source><![CDATA[
    public boolean  mustBeUnitControlled()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeUpdatedExpected</Name>
				<Source><![CDATA[
    public boolean  mustBeUpdatedExpected()
    {
        return inventType.mustInventUpdEstimated() && this.canBeUpdatedEstimated();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeWMSOrderControlled</Name>
				<Source><![CDATA[
    [SysObsolete('Functionality related to Warehouse Management II is not supported', false, 7\11\2016)]
    public boolean mustBeWMSOrderControlled()
    {
        InventItemLocation inventItemLocation = InventItemLocation::find(this.itemId(), this.inventDimId());

        if (inventItemLocation.RecId)
        {
            return inventItemLocation.useWMSOrder(this.inventdim());
        }

        return this.inventModelGroup().MandatoryWMSOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckLocationBlocking</Name>
				<Source><![CDATA[
    protected NoYes mustCheckLocationBlocking()
    {
        return NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckOverDelivery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the current <c>InventMovement</c> object requires checking for over delivery.
    /// </summary>
    /// <param name="_direction">
    /// The <c>InventDirection</c> of the update that is being made.
    /// </param>
    /// <returns>
    /// true if over delivery must be checked; otherwise, false.
    /// </returns>
    public NoYes mustCheckOverDelivery(InventDirection _direction)
    {
        if (this.overDeliveryPct() == realMax())
        {
            // No need to check over delivery if there is no real max value
            return NoYes::No;
        }
        return NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckOverDeliveryForQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the current <c>InventMovement</c> object requires checking for over delivery for
    /// the specified quantity.
    /// </summary>
    /// <param name="_qty">
    /// The quantity of the update that is being made.
    /// </param>
    /// <returns>
    /// true if over delivery must be checked; otherwise, false.
    /// </returns>
    public NoYes mustCheckOverDeliveryForQty(InventQty _qty)
    {
        InventDirection direction = this.quantityToDirection(_qty);

        return this.mustCheckOverDelivery(direction);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustClearChildRef</Name>
				<Source><![CDATA[
    // Must child reference be cleared when updating items picked or registered
    public boolean mustClearChildRef()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateQuarantineOrder</Name>
				<Source><![CDATA[
    public boolean mustCreateQuarantineOrder()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateCostTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if cost transactions must be created for this movement.
    /// </summary>
    /// <returns>true if cost transactions must be created for this movement; otherwise, false.</returns>
    public boolean mustCreateCostTransactions()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDoAutoLossProfitEstimate</Name>
				<Source><![CDATA[
    public boolean mustDoAutoLossProfitEstimate()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDoAutoLossProfitFinancial</Name>
				<Source><![CDATA[
    public boolean mustDoAutoLossProfitFinancial()
    {
        return this.mustDoAutoLossProfitEstimate()||this.mustDoAutoLossProfitPhysical();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDoAutoLossProfitPhysical</Name>
				<Source><![CDATA[
    public boolean mustDoAutoLossProfitPhysical()
    {
        return this.mustDoAutoLossProfitEstimate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDoProjPhysicalAdjust</Name>
				<Source><![CDATA[
    public boolean mustDoProjPhysicalAdjust()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDoProjPhysicalPosting</Name>
				<Source><![CDATA[
    public boolean mustDoProjPhysicalPosting()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDoProjPosting</Name>
				<Source><![CDATA[
    protected boolean mustDoProjPosting()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustExcludeFromInventoryValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the transactions must be excluded from the inventory value.
    /// </summary>
    /// <returns>true if the transactions must be excluded from the inventory value; otherwise, false.</returns>
    public boolean mustExcludeFromInventoryValue()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the inventory transaction originator must be updated.
    /// </summary>
    /// <returns>true if the inventory transaction originator must be updated; otherwise, false.</returns>
    public boolean mustUpdateInventTransOrigin()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustPhysicallyUnreserveBlocking</Name>
				<Source><![CDATA[
    /// <summary>
    ///     For inventory blocking unreservation, determines whether physical inventory reservation must be removed.
    /// </summary>
    /// <returns>
    ///     Always returns false.
    /// </returns>
    public boolean mustPhysicallyUnreserveBlocking()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustRegisterTrackingDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the movement type supports inventory tracking
    /// </summary>
    /// <returns>
    ///    true if the movement supports inventory tracking;
    ///    otherwise, false.
    /// </returns>
    public boolean mustRegisterTrackingDimension()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustReserveBasedOnMarkingOnCreation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if issue transactions need to be reserved because of marking during creation.
    /// </summary>
    /// <returns>
    /// Always returns true
    /// </returns>
    public boolean mustReserveBasedOnMarkingOnCreation()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustReserveBasedOnMarkingOnUpdate</Name>
				<Source><![CDATA[
    public boolean mustReserveBasedOnMarkingOnUpdate()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSetProjAdjRefInventTrans</Name>
				<Source><![CDATA[
    public boolean mustSetProjAdjRefInventTrans()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSetProjAdjustRefInventTrans</Name>
				<Source><![CDATA[
    public boolean mustSetProjAdjustRefInventTrans()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustShowMarkingWarningOnUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines if a warning message is shown if marking cannot be updated according to dimensions.
    /// </summary>
    /// <returns>
    ///   true if, a warning must be shown; otherwise false.
    /// </returns>
    public boolean mustShowMarkingWarningOnUpdate()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateBatchAttribValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the movement should update the batch attributes on the related quality orders.
    /// </summary>
    /// <returns>
    ///    true if attributes should be updated; otherwise, false.
    /// </returns>
    public boolean mustUpdateBatchAttribValues()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateGeneralJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets a value that indicates whether to post the inventory movement to the general journal.
    /// </summary>
    /// <returns>
    ///    true if the inventory movement should post to the general journal; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method retrieves false if the general journal updates are handled elsewhere, such as by
    ///    subledger journal lines.
    /// </remarks>
    public boolean mustUpdateGeneralJournal()
    {
        return !this.parmDistributionLedgerPosting();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateInventTableCostPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the movement can update the cost price on the related <c>InventTable</c>.
    /// </summary>
    /// <returns>
    ///    true.
    /// </returns>
    /// <remarks>
    ///    By default, this method returns true, to signal that the movement can update the cost price on the
    ///    related <c>InventTable</c>. If the movement is not able to update the <c>costprice</c> on the
    ///    <c>InventTable</c>, the method should be overridden to return false.
    /// </remarks>
    public boolean mustUpdateInventTableCostPrice()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateInventTransFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the movement can update the fields of the related <c>InventTrans</c>.
    /// </summary>
    /// <param name="_movement_orig">
    /// The inventory movement that contains the original values.
    /// </param>
    /// <returns>
    /// true if the movement can update the fields; otherwise, false.
    /// </returns>
    public boolean mustUpdateInventTransFields(InventMovement _movement_orig)
    {
        // <GEERU>
        if (this.parmCompanyCountryRegion().isCountryRegionRU())
        {
            return (this.transDate()                    != _movement_orig.transDate()                   ||
                    this.shippingDateRequested()        != _movement_orig.shippingDateRequested()       ||
                    this.transSchedTime()               != _movement_orig.transSchedTime()              ||
                    this.returnInventTransOrigin()      != _movement_orig.returnInventTransOrigin()     ||
                    this.projCategoryId()               != _movement_orig.projCategoryId()              ||
                    this.activityNumber()               != _movement_orig.activityNumber()              ||
                    this.custVendAc()                   != _movement_orig.custVendAc()                  ||
                    this.assetId()                      != _movement_orig.assetId()                     ||
                    (!this.parmMarkingRefInventTransOrigin_RU() &&
                    this.markingRefInventTransOrigin()  != _movement_orig.markingRefInventTransOrigin())||
                    this.projId()                       != _movement_orig.projId()                      ||
                    this.parmStorno_RU()                != _movement_orig.parmStorno_RU());
        }
        else
        {
            // </GEERU>
            return (this.transDate()                    != _movement_orig.transDate()                   ||
                    this.shippingDateRequested()        != _movement_orig.shippingDateRequested()       ||
                    this.transSchedTime()               != _movement_orig.transSchedTime()              ||
                    this.returnInventTransOrigin()      != _movement_orig.returnInventTransOrigin()     ||
                    this.projCategoryId()               != _movement_orig.projCategoryId()              ||
                    this.activityNumber()               != _movement_orig.activityNumber()              ||
                    this.custVendAc()                   != _movement_orig.custVendAc()                  ||
                    this.assetId()                      != _movement_orig.assetId()                     ||
                    this.markingRefInventTransOrigin()  != _movement_orig.markingRefInventTransOrigin() ||
                    this.projId()                       != _movement_orig.projId());
            // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateInventTransOriginFields</Name>
				<Source><![CDATA[
    public boolean mustUpdateInventTransOriginFields(InventMovement _movement_orig)
    {
        InventDimGroupSetup             inventDimGroupSetupOrig = _movement_orig.inventDimGroupSetup();

        InventDim itemInventDim = this.inventdim().data();
        itemInventDim.clearNotProductDim(inventDimGroupSetupOrig);

        InventDim itemInventDimOrigin = _movement_orig.inventdim().data();
        itemInventDimOrigin.clearNotProductDim(inventDimGroupSetupOrig);

        // <GEERU>
        if (this.parmCompanyCountryRegion().isCountryRegionRU())
        {
            return (    this.custVendAc()   !=  _movement_orig.custVendAc()  ||
                        this.parmStorno_RU() != _movement_orig.parmStorno_RU() ||
                        InventDim::findOrCreate(itemInventDim).InventDimId != InventDim::findOrCreate(itemInventDimOrigin).InventDimId);
        }
        else
        {
            // </GEERU>
            return (    this.custVendAc()   !=  _movement_orig.custVendAc()  ||
                        InventDim::findOrCreate(itemInventDim).InventDimId != InventDim::findOrCreate(itemInventDimOrigin).InventDimId);
            // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateRelatedTrans</Name>
				<Source><![CDATA[
    public boolean mustUpdateRelatedTrans()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateVoucherMatched</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether we can update the voucher matched parameter.
    /// </summary>
    /// <returns>
    /// False as the decision will be taken in the child classes.
    /// </returns>
    public boolean mustUpdateVoucherMatched()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUseParentMovToDimTransferReceipt</Name>
				<Source><![CDATA[
    /*
        Should return true if the movements parentMovement should be used to handle merges
        of dimensions in relation to transfer receipts
    */
    public boolean mustUseParentMovToDimTransferReceipt()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needsShelfLifeCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a value indicating whether shelf life check is needed for the inventory movement.
    /// </summary>
    /// <returns>
    /// true if the shelf life check is needed; otherwise false.
    /// </returns>
    public boolean needsShelfLifeCheck()
    {
        return this.inventTable().isShelfLifeItem() && !this.pdsOverrideFEFO() && this.inventModelGroup().PdsCheck;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void  new(
        Common      _buffer,
        InventType  _inventType = new InventType(_buffer))
    {
        buffer     = _buffer;
        inventType = _inventType;

        if (! buffer.TableId)
        {
            throw error(Error::missingRecord(funcName()));
        }

        inventDimCostPrice = new Map(Types::String, Types::Real);

        if (this.parmCompanyCountryRegion().isCountryRegionRU())
        {
            inventDimCostPriceSecCur = new Map(Types::String, Types::Real);
            stornoPhysical = InventParameters::find().StornoPhysicalPosting_RU;
        }

        if (#PmfEnabled)
        {
            burdenItem = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newMovement_Orig</Name>
				<Source><![CDATA[
    public InventMovement newMovement_Orig()
    {
        if (!this.buffer().RecId)
        {
            return null;
        }

        if (this.childBuffer().RecId)
        {
            return InventMovement::construct(this.buffer().orig(),this.inventMovSubType(),this.childBuffer().orig());
        }

        return InventMovement::construct(this.buffer().orig(),this.inventMovSubType());
    }

]]></Source>
			</Method>
			<Method>
				<Name>newMovement_TransferIssue</Name>
				<Source><![CDATA[
    public InventMovement  newMovement_TransferIssue()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newMovement_TransferIssueReceive</Name>
				<Source><![CDATA[
    public InventMovement  newMovement_TransferIssueReceive()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newMovement_TransferReceipt</Name>
				<Source><![CDATA[
    public InventMovement  newMovement_TransferReceipt()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newMovement_TransferReceiptShip</Name>
				<Source><![CDATA[
    public InventMovement  newMovement_TransferReceiptShip()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetAccountPhysical</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount offsetAccountPhysical()
    {
        if (this.mustBeBookedPhysically())
        {
            throw error(Error::missingOverload(funcName()));
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onlyCheckStorageDimInConsistentCheck</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether to check only storage dimensions when you verify whether consistent dimensions
    ///    can be changed.
    /// </summary>
    /// <param name="_origInventDim">
    ///    An <c>InventDim</c> record that contains the original inventory dimension values.
    /// </param>
    /// <returns>
    ///    true if only storage dimensions should be checked; otherwise, false.
    /// </returns>
    public boolean onlyCheckStorageDimInConsistentCheck(InventDim _origInventDim)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>overDeliveryPct</Name>
				<Source><![CDATA[
    public Percent overDeliveryPct()
    {
        return realMax();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parentDepreciateMovement</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Get the parent movement which will be depreciated.
    /// </summary>
    /// <returns>
    ///   the movement object.
    /// </returns>
    public InventMovement parentDepreciateMovement()
    {
        return this;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAutoReserveWhenAdjustingCatchWeight</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean parmAutoReserveWhenAdjustingCatchWeight(boolean _autoReserveWhenAdjustingCatchWeight = !skipAutoReservationWhenAdjustingCatchWeight)
    {
        skipAutoReservationWhenAdjustingCatchWeight = !_autoReserveWhenAdjustingCatchWeight;

        return !skipAutoReservationWhenAdjustingCatchWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsInsufficientReservationQty</Name>
				<Source><![CDATA[
    public boolean parmIsInsufficientReservationQty(boolean     _autoReserveInventQty = autoReserveInventQty)
    {
        autoReserveInventQty = _autoReserveInventQty;
        return  _autoReserveInventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parentMovement</Name>
				<Source><![CDATA[
    public InventMovement parentMovement(boolean _noThrow = false)
    {
        return this;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventTransOriginIdOriginalProject</Name>
				<Source><![CDATA[
    public InventTransOriginId parmInventTransOriginIdOriginalProject(
        InventTransOriginId _inventTransOriginIdOriginalProject = inventTransOriginIdOriginalProject)
    {
        inventTransOriginIdOriginalProject = _inventTransOriginIdOriginalProject;
        return inventTransOriginIdOriginalProject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectReturnIssue</Name>
				<Source><![CDATA[
    public boolean parmProjectReturnIssue(boolean _projectReturnIssue = projectReturnIssue)
    {
        projectReturnIssue = _projectReturnIssue;
        return projectReturnIssue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBurdenItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method gets/sets if the movement is a burden item
    /// </summary>
    /// <param name="_burdenItem">burden item flag</param>
    /// <returns>returns flag</returns>
    public boolean parmBurdenItem(boolean _burdenItem = burdenItem)
    {
        burdenItem = _burdenItem;
        return burdenItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustomsLoadOnInventory_IN</Name>
				<Source><![CDATA[
    public TaxAmountCur parmCustomsLoadOnInventory_IN(TaxAmountCur _customsLoadOnInventory = customsLoadOnInventory)
    {
        customsLoadOnInventory = _customsLoadOnInventory;
        return customsLoadOnInventory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustomsLoadOnInventoryMST_IN</Name>
				<Source><![CDATA[
    public TaxAmountCur parmCustomsLoadOnInventoryMST_IN(TaxAmountCur _customsLoadOnInventoryMST = customsLoadOnInventoryMST)
    {
        customsLoadOnInventoryMST = _customsLoadOnInventoryMST;
        return customsLoadOnInventoryMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDistributionLedgerPosting</Name>
				<Source><![CDATA[
    public boolean parmDistributionLedgerPosting(boolean _distributionLedgerPosting = distributionLedgerPosting)
    {
        distributionLedgerPosting = _distributionLedgerPosting;
        return distributionLedgerPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchangeRateDate</Name>
				<Source><![CDATA[
    public TransDate parmExchangeRateDate(TransDate _exchangeRateDate = exchangeRateDate)
    {
        exchangeRateDate = _exchangeRateDate;
        return exchangeRateDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGoodsInRoute_RU</Name>
				<Source><![CDATA[
    boolean parmGoodsInRoute_RU(boolean _goodsInRoute = goodsInRoute)
    {
        goodsInRoute = _goodsInRoute;
        return goodsInRoute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIndirectCostAmount_RU</Name>
				<Source><![CDATA[
    public CostAmount parmIndirectCostAmount_RU(CostAmount _indirectCostAmount = indirectCostAmount)
    {
        indirectCostAmount = _indirectCostAmount;
        return indirectCostAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIndirectCostAmountSecCur_RU</Name>
				<Source><![CDATA[
    public CostAmount parmIndirectCostAmountSecCur_RU(CostAmount _indirectCostAmountSecCur = indirectCostAmountSecCur)
    {
        indirectCostAmountSecCur = _indirectCostAmountSecCur;
        return indirectCostAmountSecCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventCostTransVarianceList</Name>
				<Source><![CDATA[
    public InventCostTransVarianceList parmInventCostTransVarianceList(InventCostTransVarianceList _inventCostTransVarianceList = inventCostTransVarianceList)
    {
        inventCostTransVarianceList = _inventCostTransVarianceList;
        return inventCostTransVarianceList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventParmID_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets and sets the Parm ID of the InventTransferParmLine Table
    /// </summary>
    /// <param name="_parmId">
    ///  _parmId that to be assigned.
    /// </param>
    /// <returns>
    /// returns parmID
    /// </returns>
    public ParmId parmInventParmID_IN(ParmId  _parmId = parmId)
    {
        parmId = _parmId;

        return parmId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventParmID</Name>
				<Source><![CDATA[
    public ParmId parmInventParmID(ParmId  _parmId = parmId)
    {
        parmId = _parmId;

        return parmId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventRefTransId_RU</Name>
				<Source><![CDATA[
    InventRefTransId parmInventRefTransId_RU(InventRefTransId _inventRefTransId = inventRefTransId_RU)
    {
        inventRefTransId_RU = _inventRefTransId;
        return inventRefTransId_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventTransIdDelivery_RU</Name>
				<Source><![CDATA[
    InventTransId parmInventTransIdDelivery_RU(InventTransId _inventTransId = inventTransIdDelivery)
    {
        inventTransIdDelivery = _inventTransId;
        return inventTransIdDelivery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventTransIdTransit_RU</Name>
				<Source><![CDATA[
    InventTransId parmInventTransIdTransit_RU(InventTransId _inventTransId = inventTransIdTransit)
    {
        inventTransIdTransit = _inventTransId;
        return inventTransIdTransit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventTransOriginIdRef_virtuel</Name>
				<Source><![CDATA[
    public InventTransOriginId parmInventTransOriginIdRef_virtuel(InventTransOriginId _inventTransOriginIdRef_virtuel = inventTransOriginIdRef_virtuel)
    {
        inventTransOriginIdRef_virtuel =  _inventTransOriginIdRef_virtuel;
        return inventTransOriginIdRef_virtuel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkingRefInventTransOrigin_RU</Name>
				<Source><![CDATA[
    public InventTransOriginId parmMarkingRefInventTransOrigin_RU(InventTransOriginId _markingRefInventTransOrigin = markingRefInventTransOrigin_RU)
    {
        markingRefInventTransOrigin_RU = _markingRefInventTransOrigin;
        return markingRefInventTransOrigin_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRInventTransRecid</Name>
				<Source><![CDATA[
    Recid parmMCRInventTransRecid(Recid _inventTransRecId = inventTransRecId)
    {
        inventTransRecId = _inventTransRecId;
        return inventTransRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventBlockingStatusSyncInventDim</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal InventDim parmInventBlockingStatusSyncInventDim(InventDim _inventBlockingStatusSyncInventDim = inventBlockingStatusSyncInventDim)
    {
        inventBlockingStatusSyncInventDim = _inventBlockingStatusSyncInventDim;

        return inventBlockingStatusSyncInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMustBeQuarantineControled</Name>
				<Source><![CDATA[
    public NoYes parmMustBeQuarantineControled(NoYes _mustBeQuarantineControled = this.mustBeQuarantineControlled())
    {
        if (!prmisDefault(_mustBeQuarantineControled))
        {
            mustBeQuarantineControledInitialized = true;
        }

        mustBeQuarantineControled =  _mustBeQuarantineControled;
        return _mustBeQuarantineControled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMustDoAutoLossProfitForbid</Name>
				<Source><![CDATA[
    public NoYes parmMustDoAutoLossProfitForbid(NoYes _mustDoAutoLossProfitForbid=mustDoAutoLossProfitForbid)
    {
        mustDoAutoLossProfitForbid =  _mustDoAutoLossProfitForbid;
        return mustDoAutoLossProfitForbid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMustNotReduceForecast</Name>
				<Source><![CDATA[
    public NoYes parmMustNotReduceForecast(NoYes _mustNotReduceForecast = mustNotReduceForecast)
    {
        mustNotReduceForecast =  _mustNotReduceForecast;
        return mustNotReduceForecast;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPDSBaseValue</Name>
				<Source><![CDATA[
    public PDSBaseValue parmPDSBaseValue(PDSBaseValue _pdsBaseValue = pdsBaseValue)
    {
        pdsBaseValue = _pdsBaseValue;
        return pdsBaseValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPdsBatchAttribAutoRes</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method gets/sets whether to use batch attributes for reservations
    /// </summary>
    /// <param name="_pdsBatchAttribAutoRes">flag to use batch attribute reservation.</param>
    /// <returns>returns flag</returns>
    public PdsBatchAttribAutoRes parmPdsBatchAttribAutoRes(
        PdsBatchAttribAutoRes _pdsBatchAttribAutoRes = false)
    {
        if (!prmisDefault(_pdsBatchAttribAutoRes))
        {
            pdsUseBAForRes = _pdsBatchAttribAutoRes;
        }

        return pdsUseBAForRes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjAdjustCorrection</Name>
				<Source><![CDATA[
    public LedgerCorrection parmProjAdjustCorrection(LedgerCorrection _adjustCorrection = adjustCorrection)
    {
        adjustCorrection = _adjustCorrection;
        return adjustCorrection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReleasedReservationQty</Name>
				<Source><![CDATA[
    public InventQty parmReleasedReservationQty(InventQty _releasedReservationQty = releasedReservationQty)
    {
        releasedReservationQty = _releasedReservationQty;

        return releasedReservationQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReturnMode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Decides whether the current movement is a return mode or not.
    /// </summary>
    /// <param name="_returnMode">
    /// A Boolean value that stores the current mode of transaction.
    /// </param>
    /// <returns>
    /// True if the current movement is in return mode else false.
    /// </returns>
    public boolean parmReturnMode(boolean _returnMode = returnMode)
    {
        if (!prmisDefault(_returnMode))
        {
            returnMode = _returnMode;
        }

        return    returnMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesPackingSlipJournalPostProj</Name>
				<Source><![CDATA[
    public boolean parmSalesPackingSlipJournalPostProj(boolean _salesPackingSlipJournalPostProj = salesPackingSlipJournalPostProj)
    {
        salesPackingSlipJournalPostProj = _salesPackingSlipJournalPostProj;
        return salesPackingSlipJournalPostProj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStorno_RU</Name>
				<Source><![CDATA[
    public Storno_RU parmStorno_RU(Storno_RU _storno = storno)
    {
        FieldId fieldId = fieldName2id(buffer.TableId, fieldStr(InventJournalTrans, Storno_RU));

        storno = _storno;

        if (fieldId)
        {
            return buffer.(fieldId);
        }
        else
        {
            return storno;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStornoPhysical_RU</Name>
				<Source><![CDATA[
    final NoYes parmStornoPhysical_RU(Storno_RU _stornoPhysical = stornoPhysical)
    {
        stornoPhysical = _stornoPhysical;
        return stornoPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStornoPhysicalForced_RU</Name>
				<Source><![CDATA[
    final boolean parmStornoPhysicalForced_RU(boolean _stornoPhysicalForced = stornoPhysicalForced)
    {
        stornoPhysicalForced = _stornoPhysicalForced;
        return stornoPhysicalForced;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDateRegistration</Name>
				<Source><![CDATA[
    public DateInvent parmDateRegistration(DateInvent _dateRegistration = dateRegistration)
    {
        dateRegistration = _dateRegistration;
        return dateRegistration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipCheckPickComplete</Name>
				<Source><![CDATA[
    public boolean parmSkipCheckPickComplete(boolean _skipCheckPickComplete = skipCheckPickComplete)
    {
        skipCheckPickComplete = _skipCheckPickComplete;
        return skipCheckPickComplete;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsAdjustInventoryQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the inventory quantity for the movement.
    /// </summary>
    /// <param name="_inventQty">
    /// The inventory quantity to adjust.
    /// </param>
    public void pdsAdjustInventoryQuantity(InventQty _inventQty)
    {
        if (this.pdsCWItem())
        {
            this.addRemainPhysical(_inventQty);

            UnitOfMeasure unitOfMeasureInvent = UnitOfMeasure::findBySymbol(this.inventTable().inventUnitId());
            UnitOfMeasure unitOfMeasureMovement = UnitOfMeasure::findBySymbol(this.transUnitId());

            if (unitOfMeasureInvent.UnitOfMeasureClass == unitOfMeasureMovement.UnitOfMeasureClass)
            {
                if (unitOfMeasureInvent.Symbol == unitOfMeasureMovement.Symbol)
                {
                    // Same unit class so update movement quantity related field too, but convert to proper unit
                    this.addRemainPhysicalUnit(UnitOfMeasureConverter::convert(
                        _inventQty,
                        unitOfMeasureInvent.RecId,
                        unitOfMeasureMovement.RecId,
                        NoYes::No,
                        this.inventTable().Product));
                }
                else
                {
                    // When units are different set qty to prevent unmatched ramain physical and remain physical unit quantities during conversion
                    this.setRemainPhysicalUnit(UnitOfMeasureConverter::convert(
                        this.remainPhysical(),
                        unitOfMeasureInvent.RecId,
                        unitOfMeasureMovement.RecId,
                        NoYes::No,
                        this.inventTable().Product));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsAskSameLotResolution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Requests that the user determine how to resolve a same lot reservation issue.
    /// </summary>
    /// <param name="_error">
    /// The error that must be resolved.
    /// </param>
    /// <param name="_inventDimReq">
    /// The inventory dimension from which the reservation was requested.
    /// </param>
    /// <param name="_reserveNow">
    /// The quantity that tried to be reserved.
    /// </param>
    /// <param name="_cwReserveNow">
    /// The catch weight quantity that tried to be reserved.
    /// </param>
    /// <returns>
    /// The <c>PdsSameLotBatchResolution</c> object to resolve the issue.
    /// </returns>
    /// <remarks>
    /// The method of the base class runs a form to let the user decide on a resolution of the issue.
    /// </remarks>
    public PdsSameLotBatchResolution pdsAskSameLotResolution(
        PdsSameLotError _error,
        InventDim       _inventDimReq,
        InventQty       _reserveNow,
        PdsCWInventQty  _cwReserveNow = 0)
    {
        Args    args = new Args(formStr(PdsAskSameLotForm));

        FormRun formRun = classfactory.formRunClass(args);
        formRun.init();

        Object  formRunObj = formRun;
        formRunObj.parmMovement(this);
        formRunObj.parmInventDimReq(_inventDimReq);
        formRunObj.parmError(_error);
        formRunObj.parmPdsCWReserveNow(_cwReserveNow);
        formRunObj.parmReserveNow(_reserveNow);

        formRun.run();
        formRun.wait();

        return formRun.sameLotResolution();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsBaseAttributeValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the base attribute value for the current movement.
    /// </summary>
    /// <returns>
    ///     The base value for the current movement, if the movement has one, blank otherwise.
    /// </returns>
    /// <remarks>
    ///     The base method always returns a blank value.
    /// </remarks>
    public PDSBaseValue pdsBaseAttributeValue()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCanHaveBatchInheritance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value indicating if the movement can trigger batch inheritance.
    /// </summary>
    /// <returns>
    /// true if this movement can trigger batch inheritance; otherwise, false.
    /// </returns>
    /// <remarks>
    /// To be overridden by applicable movement instances. All sub-classes that
    /// override this to return true, must also ensure that the lot inheritance
    /// configuration key is enabled.
    /// </remarks>
    public boolean pdsCanHaveBatchInheritance()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCheckCopyBatchAttrib</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a batch attribute record exists.
    /// </summary>
    /// <param name="_toInventDim">
    /// An <c>InventDim</c> record for which to search records
    /// </param>
    /// <returns>
    /// true if a record exists; otherwise false .
    /// </returns>
    public boolean pdsCheckCopyBatchAttrib(
        InventDim   _toInventDim)
    {
        PdsBatchAttributes  batchAttributes;

        select firstonly RecId from batchAttributes
            where batchAttributes.ItemId == this.itemId()
                && batchAttributes.InventBatchId == _toInventDim.InventBatchId;

        return batchAttributes.RecId == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsConsiderRestrictReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates if the batch disposition functionality should be considered reservation.
    /// </summary>
    /// <returns>
    /// Always returns false;
    /// </returns>
    public boolean pdsConsiderRestrictReservation()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCountryOfOrigin1</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the first country of origin.
    /// </summary>
    /// <returns>
    /// An empty string.
    /// </returns>
    /// <remarks>
    /// This method returns an empty string as child classes will define the field for the specific
    /// movement type.
    /// </remarks>
    public PdsCountryOfOrigin pdsCountryOfOrigin1()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCountryOfOrigin2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the second country of origin
    /// </summary>
    /// <returns>
    /// An empty string.
    /// </returns>
    /// <remarks>
    /// This method returns empty string as child classes will define the field for the specific movement
    /// type.
    /// </remarks>
    public PdsCountryOfOrigin pdsCountryOfOrigin2()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWAddRemainFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a catch weight to the remaining financial quantity.
    /// </summary>
    /// <param name="_qty">
    /// The quantity to add.
    /// </param>
    public void pdsCWAddRemainFinancial(PdsCWInventQty _qty)
    {
        if (this.mustBeUnitControlled()
            && this.mustBeRemainControlled()
            && this.pdsCWItem())
        {
            throw error(Error::missingOverload(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWAddRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a catch weight quantity to the remaining physical quantity.
    /// </summary>
    /// <param name="_qty">
    /// The quantity to add.
    /// </param>
    public void pdsCWAddRemainPhysical(PdsCWInventQty _qty)
    {
        if (this.mustBeRemainControlled() && this.pdsCWItem())
        {
            throw error(Error::missingOverload(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWAutoReserveQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight auto reserve quantity.
    /// </summary>
    /// <param name="_movement_orig">
    /// The <c>InventMovement</c> object for the original buffer.
    /// </param>
    /// <returns>
    /// The catch weight quantity.
    /// </returns>
    public PdsCWInventQty pdsCWAutoReserveQty(InventMovement _movement_orig)
    {
        return -this.pdsCWTransQty() + _movement_orig.pdsCWTransQty() - this.transIdSum().pdsCWOnOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method returns true if the movement is for a catch weight item
    /// </summary>
    /// <returns>returns flag</returns>
    public boolean pdsCWItem()
    {
        if (!pdsCWItemInitialized && this.itemId())
        {
            pdsCWItem = PdsGlobal::pdsIsCWItem(this.itemId());
            pdsCWItemInitialized = true;
        }
        return pdsCWItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQtyPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total received catch weight quantity after an inventory update.
    /// </summary>
    /// <param name="_pdsCWPhysicalNow">
    /// The catch weight quantity being received now.
    /// </param>
    /// <param name="_isPhysicalUpdate">
    /// A Boolean parameter that indicates whether the inventory update is a physical update.
    /// </param>
    /// <returns>
    /// The total received catch weight quantity after the inventory update.
    /// </returns>
    protected PdsCWInventQty pdsCWQtyPost(
        PdsCWInventQty  _pdsCWPhysicalNow,
        boolean         _isPhysicalUpdate)
    {
        PdsCWInventQty  pdsCWQtyPost;

        if (_isPhysicalUpdate)
        {
            pdsCWQtyPost = this.transIdSumTransId().pdsCWPhysical();
        }
        else
        {
            pdsCWQtyPost = this.transIdSumTransId().pdsCWPhysicalInventNotFinancial();
        }

        if (!this.mustBeExpectedAgain())
        {
            pdsCWQtyPost += this.transIdSumTransId().pdsCWFinancial();
        }

        pdsCWQtyPost = abs(pdsCWQtyPost + _pdsCWPhysicalNow);

        return pdsCWQtyPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight remaining physical quantity.
    /// </summary>
    /// <returns>
    /// The catch weight quantity.
    /// </returns>
    [Replaceable]
    public PdsCWInventQty pdsCWRemainPhysical()
    {
        if (this.pdsCWItem())
        {
            throw error(Error::missingOverload(funcName()));
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWReserveMarkMin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the catch weight should reserve a minimum.
    /// </summary>
    /// <returns>
    /// Always returns true .
    /// </returns>
    public boolean pdsCWReserveMarkMin()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWReserveQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight reserve quantity.
    /// </summary>
    /// <returns>
    /// The catch weight reserve quantity.
    /// </returns>
    [Replaceable]    
    public PdsCWInventQty pdsCWReserveQty()
    {
        if (this.pdsCWItem())
        {
            throw error(Error::missingOverload(funcName()));
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWSetRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the catch weight remain physical quantity.
    /// </summary>
    /// <param name="_qty">
    /// The quantity to set.
    /// </param>
    public void pdsCWSetRemainPhysical(PdsCWInventQty _qty)
    {
        if (this.mustBeRemainControlled() && this.pdsCWItem())
        {
            throw error(Error::missingOverload(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWSetTransQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the catch weight transaction quantity.
    /// </summary>
    /// <param name="_pdsCWQtyInvent">
    /// The quantity to set.
    /// </param>
    public void pdsCWSetTransQty(PdsCWInventQty _pdsCWQtyInvent)
    {
        if (this.pdsCWItem())
        {
            throw error(Error::missingOverload(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWTransQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight transaction quantity.
    /// </summary>
    /// <returns>
    /// The catch weight quantity.
    /// </returns>
    [Replaceable]
    public PdsCWInventQty pdsCWTransQty()
    {
        if (this.pdsCWItem())
        {
            throw error(Error::missingOverload(funcName()));
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWUnitId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight unit ID.
    /// </summary>
    /// <returns>
    /// The catch weight unit ID.
    /// </returns>
    [Replaceable]
    public PdsCWUnitId pdsCWUnitId()
    {
        if (this.pdsCWItem())
        {
            throw error(Error::missingOverload(funcName()));
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsGetBaseValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the potency base value associated with the current inventory movement.
    /// </summary>
    /// <returns>
    ///     The defined potency base value.
    /// </returns>
    public PDSBaseValue pdsGetBaseValue()
    {
        if (!pdsBaseValue)
        {
            pdsBaseValue = this.pdsBaseAttributeValue();
        }
        return pdsBaseValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsIgnoreSerNumCtrlValidation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the movement should ignore the serial number control.
    /// </summary>
    /// <returns>
    /// Always returns false.
    /// </returns>
    protected boolean pdsIgnoreSerNumCtrlValidation()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsInheritBatchData</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Inherits information to the given <c>InventBatch</c> based on rules for the current type of movement and the transaction data.
    /// </summary>
    /// <param name="_inventBatch">
    ///     The <c>InventBatch</c> record to update.
    /// </param>
    /// <param name="_inventTrans">
    ///     A record of the <c>InventTrans</c> table for additional calculations during inheritance; optional.
    /// </param>
    public void pdsInheritBatchData(InventBatch _inventBatch, InventTrans _inventTrans = null)
    {
        // empty
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsInitDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>InventDim</c> and <c>InventDimParm</c> records with the dimension of the
    /// movement.
    /// </summary>
    /// <param name="_inventDim">
    /// A <c>InventDim</c> record to initialize.
    /// </param>
    /// <param name="_inventDimParm">
    /// A <c>InventDimParm</c> record to initialize.
    /// </param>
    public void pdsInitDim(InventDim _inventDim, InventDimParm _inventDimParm)
    {
        if (!_inventDim.RecId)
        {
            _inventDim.data(this.inventdim());
            _inventDimParm.initFromInventDim(_inventDim);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsMustConsiderBatchAttrib</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the batch attributes should be considered for reservation.
    /// </summary>
    /// <returns>
    /// Always returns true .
    /// </returns>
    public PdsBatchAttribAutoRes pdsMustConsiderBatchAttrib()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsOverrideFEFO</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the movement should use FEFO logic.
    /// </summary>
    /// <returns>
    /// Always returns the <c>NoYes::No</c> enumeration value.
    /// </returns>
    public PdsOverrideFEFO pdsOverrideFEFO()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsResolveSameLotReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Shows a dialog for fixing same lot reservation conflict or warns the user about existing reservation conflict.
    /// </summary>
    /// <param name="_origMovement">
    /// The inventory movement class that contains the original values.
    /// </param>
    /// <param name="_showDialog">
    /// The Boolean which indicates whether dialog or warning should be shown if auto reservation is not possible.
    /// </param>
    /// <returns>
    /// true if reservation was successful; otherwise, false.
    /// </returns>
    protected boolean pdsResolveSameLotReservation(InventMovement _origMovement, boolean _showDialog)
    {
        PdsSameLotError sameLotError = InventSameBatchReserveCheck::newFromMovement(this, false).run();

        if (sameLotError == PdsSameLotError::None)
        {
            return true;
        }

        InventBatch inventBatch = this.pdsSameLotReservationBatch();

        if (sameLotError == PdsSameLotError::NoInventory
            && inventBatch.RecId)
        {
            InventUpd_Reservation reservation = InventUpd_Reservation::newMovement(
                                                      this,
                                                      -this.transIdSum().reserved(),
                                                      true,
                                                      false,
                                                      true,
                                                      -this.transIdSum().pdsCWReserved());

            reservation.updateNow();

            info(strFmt("@PDS1011",inventBatch.InventBatchId));
            sameLotError = InventSameBatchReserveCheck::newFromMovement(this, false).run();
        }

        InventQty reserveNow = this.autoReserveQty(_origMovement);
        PdsCWInventQty cwReserveNow = this.pdsCWAutoReserveQty(_origMovement);

        if (_showDialog)
        {
            PdsSameLotBatchResolution resolution = InventMovement::pdsAskSameLotResolutionClient(this, sameLotError, this.inventdim(), reserveNow, cwReserveNow);
            if (!resolution)
            {
                return false;
            }
            resolution.resolve();
            return resolution.continueReservation();
        }
        else
        {
            return checkFailed("@SYS4009981");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsRestrictReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether to block reservation.
    /// </summary>
    /// <param name="_dispMaster">
    /// A <c>PdsDispositionMaster</c> record.
    /// </param>
    /// <returns>
    /// true if the reservation is blocked; otherwise, false.
    /// </returns>
    public boolean pdsRestrictReservation(PdsDispositionMaster _dispMaster)
    {
        FieldId dispFieldId = this.batchDispReservationBlockedFieldId();

        return dispFieldId ? _dispMaster.(dispFieldId) == NoYes::Yes : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsSameLotOverride</Name>
				<Source><![CDATA[
    /// <summary>
    /// Overrides the same lot feature and sets it not to use this feature for this movement.
    /// </summary>
    /// <remarks>
    /// This method must be overridden by movements that implement the same lot reservation feature. The
    /// base class does not implement any functionality for this method.
    /// </remarks>
    public void pdsSameLotOverride()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsSameLotReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether an inventory movement should be reserved against the same inventory batch.
    /// </summary>
    /// <returns>
    /// Always returns false .
    /// </returns>
    /// <remarks>
    /// This method has to be overridden by movements that implement the same lot batch reservation feature.
    /// </remarks>
    public boolean pdsSameLotReservation()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsSameLotReservationBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the batch the movement must be reserved against
    /// </summary>
    /// <returns>
    /// The <c>InventBatch</c> record that the movement must be reserved against.
    /// </returns>
    /// <remarks>
    /// The method returns the batch for the first transaction that is past the <c>OnOrder</c> status.It
    /// does not check whether the same lot reservation feature is actually turned on.
    /// </remarks>
    public InventBatch pdsSameLotReservationBatch()
    {
        InventTrans inventTrans;
        InventDim   lclInventDim;

        select firstonly RecId
            from inventTrans
            where  inventTrans.InventTransOrigin    == this.inventTransOriginId()
                && inventTrans.StatusIssue      != StatusIssue::None
                && inventTrans.StatusIssue      != StatusIssue::OnOrder
            join InventBatchId
            from lclInventDim
            where  lclInventDim.InventDimId     == inventTrans.InventDimId;

        return InventBatch::find(lclInventDim.InventBatchId, this.itemId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsUpdateBufferWithAdjQtyUncommited</Name>
				<Source><![CDATA[
    protected void pdsUpdateBufferWithAdjQtyUncommited(WMSOrder _wmsOrder)
    {
        InventUpd_Estimated         estimatedIssue;
        InventUpd_Estimated         estimatedReceipt;
        InventDimParm               inventDimParm;

        if (_wmsOrder.PostTransfer)
        {
            InventMovement inventMovementIssue = InventMovement::construct(_wmsOrder);
            estimatedIssue = InventUpd_Estimated::newInventMovement(inventMovementIssue);

            InventDim inventDimFrom = inventMovementIssue.inventdim();
            inventDimParm.initFromInventDim(inventDimFrom);

            InventUpd_Reservation reserved = InventUpd_Reservation::newParameters(
                inventMovementIssue,
                inventDimFrom,
                inventDimParm,
                0,
                _wmsOrder.Qty,
                true,
                false,
                _wmsOrder.PdsCWQty);
            reserved.updateNow();

            InventMovement inventMovementReceipt = InventMovement::construct(_wmsOrder, InventMovSubType::TransferReceipt);
            inventMovementReceipt.inventTransOriginId(inventMovementIssue.inventTransOriginId());
            estimatedReceipt = InventUpd_Estimated::newInventMovement(inventMovementReceipt);
        }

        if (estimatedIssue)
        {
            estimatedIssue.updateOwnerRelationship();
        }

        if (estimatedReceipt)
        {
            estimatedReceipt.updateOwnerRelationship();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsUpdateBufferWithAdjustedQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the document buffer after the inventory quantity adjustment.
    /// </summary>
    /// <param name="_inventDimId">
    ///    The preferred inventory dimension to adjust quantities for; optional.
    /// </param>
    public void pdsUpdateBufferWithAdjustedQuantity(InventDimId _inventDimId = this.inventDimId())
    {
        Common locBuffer = this.buffer();

        // for uncommitted scenarios of WMS
        if (!locBuffer.RecId && (locBuffer is WMSOrder))
        {
            this.pdsUpdateBufferWithAdjQtyUncommited(locBuffer as WMSOrder);
        }
        else
        {
            this.updateBuffer(this.parmAutoReserveWhenAdjustingCatchWeight());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsUseVendBatchDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether to use the vendor batch date.
    /// </summary>
    /// <returns>
    /// Always returns false .
    /// </returns>
    public PdsUseVendBatchDate pdsUseVendBatchDate()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsUseVendBatchExp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether to use the vendor expiration date.
    /// </summary>
    /// <returns>
    /// Always returns false .
    /// </returns>
    public PdsUseVendBatchExp pdsUseVendBatchExp()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsVendBatchDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the vendor batch date.
    /// </summary>
    /// <returns>
    /// A null date.
    /// </returns>
    public PdsVendBatchDate pdsVendBatchDate()
    {
        return dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsVendBatchId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the vendor batch ID.
    /// </summary>
    /// <returns>
    /// An empty string.
    /// </returns>
    public PdsVendBatchId pdsVendBatchId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsVendBatchInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the vendor batch details associated with this transaction.
    /// </summary>
    /// <returns>
    /// A <c>PdsVendBatchInfo</c> table buffer.
    /// </returns>
    public PdsVendBatchInfo pdsVendBatchInfo()
    {
        PdsVendBatchInfo pdsVendBatchInfo;
        return pdsVendBatchInfo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsVendExpiryDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the vendor batch expiration date.
    /// </summary>
    /// <returns>
    /// A null date.
    /// </returns>
    public PdsVendExpiryDate pdsVendExpiryDate()
    {
        return dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>physicalUpdateIssueRemainQty_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets physical update remain quantity and CW physical update remain quantity
    /// </summary>
    /// <param name="_inventTrans">
    /// InventTrans table buffer
    /// </param>
    /// <returns>
    /// return as [qty, cwQty]
    /// </returns>
    /// <remarks>
    /// This method shall be called in Indian country context, it provides same implementation as Sys, this is
    /// a window to be overridden provided to sub movement classes, and allow India specific implementations
    /// to return proper remaining quantity and CW quantity
    /// </remarks>
    public container physicalUpdateIssueRemainQty_IN(InventTrans _inventTrans)
    {
        return [0, 0];
    }

]]></Source>
			</Method>
			<Method>
				<Name>physicalUpdateReceiptRemainQty_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets physical update remain quantity and CW physical update remain quantity
    /// </summary>
    /// <param name="_inventTrans">
    /// InventTrans table buffer
    /// </param>
    /// <returns>
    /// return as [qty, cwQty]
    /// </returns>
    /// <remarks>
    /// This method shall be called in Indian country context, it provides same implementation as Sys, this is
    /// a window to be overridden provided to sub movement classes, and allow India specific implementations
    /// to return proper remaining quantity and CW quantity
    /// </remarks>
    public container physicalUpdateReceiptRemainQty_IN(InventTrans _inventTrans)
    {
        return [0, 0];
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfCheckUpdateInvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the current inventory movement can be inventory updated or not.
    /// </summary>
    /// <returns>
    /// true if the current inventory movement can be inventory updated; otherwise, false .
    /// </returns>
    public boolean pmfCheckUpdateInvent()
    {
        boolean ok = true;

        if (ok)
        {
            ok = this.inventTable()
                    .pmfInventProductType().validateInventUpd();
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfSetMinMaxQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a quantity based on minimum and maximum quantities from the item setup.
    /// </summary>
    /// <param name="_showUsrDialog">
    /// A Boolean value that indicates whether to show the user dialog; optional.
    /// </param>
    /// <param name="_useDefaultOrderSetup">
    /// A Boolean value that indicates whether to use the default order setup; optional.
    /// </param>
    /// <param name="_doMinQtyCheck">
    /// A Boolean value that indicates whether to perform the minimum value check; optional.
    /// </param>
    /// <param name="_doMaxQtyCheck">
    /// A Boolean value that indicates whether to perform the maximum value check; optional.
    /// </param>
    /// <returns>
    /// A quantity that is in the minimum and maximum quantity range, unless the parameters have been
    ///     passed to override this behavior.
    /// </returns>
    public Qty pmfSetMinMaxQty(
        boolean _showUsrDialog        = true,
        boolean _useDefaultOrderSetup = false,
        boolean _doMinQtyCheck        = true,
        boolean _doMaxQtyCheck        = true)
    {
        var errorCorrectionMethods = InventMovementQuantityErrorCorrectionMethods::newParameters(_showUsrDialog, _doMinQtyCheck, _doMaxQtyCheck);
        return this.acceptableTransQty(errorCorrectionMethods, _useDefaultOrderSetup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingBalanceSheet</Name>
				<Source><![CDATA[
    public LedgerPostingType postingBalanceSheet()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingCharge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the charge ledger posting type.
    /// </summary>
    /// <returns>
    /// The charge ledger posting type.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Method must be overridden.
    /// </exception>
    public LedgerPostingType postingCharge()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingOffsetPhysical</Name>
				<Source><![CDATA[
    public LedgerPostingType postingOffsetPhysical()
    {
        if (this.mustBeBookedPhysically())
        {
            throw error(Error::missingOverload(funcName()));
        }
        return LedgerPostingType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingOperations</Name>
				<Source><![CDATA[
    public LedgerPostingType postingOperations()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingPhysical</Name>
				<Source><![CDATA[
    public LedgerPostingType postingPhysical()
    {
        if (this.mustBeBookedPhysically())
        {
            throw error(Error::missingOverload(funcName()));
        }
        return LedgerPostingType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingPhysicalRevenue</Name>
				<Source><![CDATA[
    public LedgerPostingType postingPhysicalRevenue()
    {
        if (this.mustBeBookedPhysicalRevenue())
        {
            throw error(Error::missingOverload(funcName()));
        }
        return LedgerPostingType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingPhysicalRevenueOffset</Name>
				<Source><![CDATA[
    public LedgerPostingType postingPhysicalRevenueOffset()
    {
        if (this.mustBeBookedPhysicalRevenue())
        {
            throw error(Error::missingOverload(funcName()));
        }
        return LedgerPostingType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingPhysicalTax</Name>
				<Source><![CDATA[
    public LedgerPostingType postingPhysicalTax()
    {
        if (this.mustBeBookedPhysicalTax())
        {
            throw error(Error::missingOverload(funcName()));
        }
        return LedgerPostingType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingStdLoss</Name>
				<Source><![CDATA[
    public LedgerPostingType postingStdLoss()
    {
        return LedgerPostingType::InventStdLoss;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingStdOffset</Name>
				<Source><![CDATA[
    public LedgerPostingType postingStdOffset()
    {
        return this.postingBalanceSheet();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingStdProfit</Name>
				<Source><![CDATA[
    public LedgerPostingType postingStdProfit()
    {
        return LedgerPostingType::InventStdProfit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingStockVariation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the stock variation ledger posting type.
    /// </summary>
    /// <returns>
    /// The stock variation ledger posting type.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Method must be overridden.
    /// </exception>
    public LedgerPostingType postingStockVariation()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>projAdjustRefId</Name>
				<Source><![CDATA[
    public ProjAdjustRefId projAdjustRefId()
    {
        return  projAdjustRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projCategoryId</Name>
				<Source><![CDATA[
    public ProjCategoryId projCategoryId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>projId</Name>
				<Source><![CDATA[
    public ProjId projId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>projLedgerOrigin</Name>
				<Source><![CDATA[
    public ProjLedgerOrigin projLedgerOrigin()
    {
        return ProjOrigin::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projLinePropertyId</Name>
				<Source><![CDATA[
    public ProjLinePropertyId projLinePropertyId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>projSalesCurrencyId</Name>
				<Source><![CDATA[
    public ProjSalesCurrencyCode projSalesCurrencyId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>projSalesQty</Name>
				<Source><![CDATA[
    internal Qty projSalesQty(Qty _qty)
    {
        return _qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projSalesPrice</Name>
				<Source><![CDATA[
    public ProjSalesPriceCost projSalesPrice()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTaxGroupId</Name>
				<Source><![CDATA[
    public ProjTaxGroup projTaxGroupId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTaxItemGroupId</Name>
				<Source><![CDATA[
    public ProjTaxItemGroup projTaxItemGroupId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTransactionOrigin</Name>
				<Source><![CDATA[
    public ProjTransactionOrigin projTransactionOrigin()
    {
        return ProjOrigin::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTransId</Name>
				<Source><![CDATA[
    public ProjTransIdBase projTransId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTransIdRef</Name>
				<Source><![CDATA[
    public ProjTransIdBase projTransIdRef()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyPost</Name>
				<Source><![CDATA[
    protected UnitQty qtyPost(
        InventQty       _physicalNow,
        boolean         _isPhysicalUpdate)
    {
        UnitQty     qtyPost;

        if (_isPhysicalUpdate)
        {
            qtyPost = this.transIdSumTransId().physical();
        }
        else
        {
            qtyPost = this.transIdSumTransId().physicalInventNotFinancial();
        }

        if (!this.mustBeExpectedAgain())
        {
            qtyPost += this.transIdSumTransId().financial();
        }

        qtyPost     = abs(qtyPost + _physicalNow);
        return qtyPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>quantityToDirection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a quantity to an <c>InventDirection</c> object that matches the quantity.
    /// </summary>
    /// <param name="_qty">
    /// The quantity to convert.
    /// </param>
    /// <returns>
    /// An <c>InventDirection</c> value.
    /// </returns>
    private InventDirection quantityToDirection(InventQty _qty)
    {
        if (_qty < 0)
        {
            return InventDirection::Issue;
        }

        if (_qty > 0)
        {
            return InventDirection::Receipt;
        }

        return InventDirection::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>quotationType</Name>
				<Source><![CDATA[
    public QuotationType quotationType(QuotationType _quotationType = quotationCallerType)
    {
        return quotationCallerType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerBlankTrackingValueAsNotReadable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the movement type considers the registration of a blank tracking dimension value as a not readable value.
    /// </summary>
    /// <returns>
    ///    true if the movement considers the registration of a blank tracking dimension value as a not readable value;
    ///    otherwise, false.
    /// </returns>
    public boolean registerBlankTrackingValueAsNotReadable()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>relatedMovement</Name>
				<Source><![CDATA[
    public InventMovement relatedMovement()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainFinancial</Name>
				<Source><![CDATA[
    public InventQty   remainFinancial()
    {
        return this.transIdSum().physical();
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainFinancialUnit</Name>
				<Source><![CDATA[
    public UnitQty     remainFinancialUnit()
    {
        return this.remainFinancial();
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainPhysical</Name>
				<Source><![CDATA[
    abstract public InventQty remainPhysical()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainPhysicalUnit</Name>
				<Source><![CDATA[
    public UnitQty      remainPhysicalUnit()
    {
        return this.remainPhysical();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reservationHierarchyLevelStrategyList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a list containing <c>WHSReservationHierarchyLevelStrategy</c> instances for this movement.
    /// </summary>
    /// <param name="_inventDimReservationCriteria">
    /// An <c>InventDim</c> buffer with the values that are required to be reserved.
    /// </param>
    /// <returns>
    /// A list containing <c>WHSReservationHierarchyLevelStrategy</c> instances for this movement.
    /// </returns>
    /// <remarks>
    /// If the item is not WHS enabled the empty list is returned.
    /// </remarks>
    public List reservationHierarchyLevelStrategyList(InventDim _inventDimReservationCriteria)
    {
        if (this.isItemWHSEnabled())
        {
            return WHSReservationHierarchyLevelStrategyTypesProvider::newFromParameters(this, _inventDimReservationCriteria).allStrategiesList();
        }

        return new List(Types::Class);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveQty</Name>
				<Source><![CDATA[
    public InventQty reserveQty()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnedSpecialCheckUpdate_RU</Name>
				<Source><![CDATA[
    UnknownNoYes returnedSpecialCheckUpdate_RU(UnknownNoYes _returnedSpecialCheckUpdate = returnedSpecialCheckUpdate)
    {
        return UnknownNoYes::Unknown;
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Identifies the original transactions.
    /// </summary>
    /// <returns>
    ///    The ID of the original transaction originator if any; otherwise, 0.
    /// </returns>
    public InventTransOriginId returnInventTransOrigin()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>serialProdDate</Name>
				<Source><![CDATA[
    public InventSerialProdDate serialProdDate(InventTrans _inventTrans = null)
    {
        if (_inventTrans)
        {
            return _inventTrans.DatePhysical
                ? _inventTrans.DatePhysical
                : (_inventTrans.DateInvent ? _inventTrans.DateInvent : _inventTrans.DateStatus);
        }

        return this.transDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventDimId</Name>
				<Source><![CDATA[
    public void setInventDimId(InventDimId _dimId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventRefFields</Name>
				<Source><![CDATA[
    public boolean setInventRefFields(
        InventRefType           _inventRefType,
        InventRefId             _inventRefId,
        InventTransOriginId     _markingRefInventTransOrigin)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPreTransEstimated</Name>
				<Source><![CDATA[
    public void setPreTransEstimated(
        InventMovement        _this_Orig,
        InventUpd_Estimated   _updateNow)
    {
        InventQty  preEstimated = 0;
        InventQty  transEstimated = 0;

        PdsCWInventQty cwPreEstimated   = 0;
        PdsCWInventQty cwTransEstimated = 0;

        if (_this_Orig && _this_Orig.mustBeUpdatedExpected() && (!_this_Orig.mayScrapBeExpected() || !_this_Orig.doScrap()))
        {
            preEstimated = _this_Orig.remainPhysical();
            cwPreEstimated = _this_Orig.pdsCWRemainPhysical();
        }

        if (this.mustBeUpdatedExpected() && (!this.mayScrapBeExpected() || !this.doScrap()))
        {
            transEstimated = this.remainPhysical();
            cwTransEstimated = this.pdsCWRemainPhysical();
        }

        _updateNow.parmPreEstimated(preEstimated);
        _updateNow.parmTransEstimated(transEstimated);

        _updateNow.parmCWPreEstimated(cwPreEstimated);
        _updateNow.parmCWTransEstimated(cwTransEstimated);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProjAdjustRefId</Name>
				<Source><![CDATA[
    public void setProjAdjustRefId(InventTrans _inventTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRemainPhysical</Name>
				<Source><![CDATA[
    public void setRemainPhysical(InventQty  _inventQty)
    {
        if (this.mustBeRemainControlled())
        {
            throw error(Error::missingOverload(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRemainPhysicalUnit</Name>
				<Source><![CDATA[
    public void setRemainPhysicalUnit(UnitQty   _qtyUnit)
    {
        if (this.mustBeRemainControlled())
        {
            if (this.mustBeUnitControlled())
            {
                throw error(Error::missingOverload(funcName()));
            }
            this.setRemainPhysical(_qtyUnit);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransQty</Name>
				<Source><![CDATA[
    public void setTransQty(InventQty  _qtyInvent)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransQtyUnit</Name>
				<Source><![CDATA[
    public void  setTransQtyUnit(UnitQty  _qtyUnit)
    {
        if (this.mustBeUnitControlled())
        {
            throw error(Error::missingOverload(funcName()));
        }
        this.setTransQty(_qtyUnit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shippingDateConfirmed</Name>
				<Source><![CDATA[
    protected SalesShippingDateConfirmed shippingDateConfirmed()
    {
        return dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shippingDateRequested</Name>
				<Source><![CDATA[
    public SalesShippingDateRequested shippingDateRequested()
    {
        return dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>storno_RU</Name>
				<Source><![CDATA[
    public Storno_RU storno_RU()
    {
        int       fieldId = fieldName2id(buffer.TableId, fieldStr(InventJournalTrans, Storno_RU));
        Storno_RU ret;

        if (fieldId)
        {
            ret = buffer.(fieldId);
        }
        else
        {
            ret = storno;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>subDeliveryPct</Name>
				<Source><![CDATA[
    protected Percent subDeliveryPct()
    {
        return realMax();
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumUpTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sums up identical inventory transactions.
    /// </summary>
    public void sumUpTransactions()
    {
        InventTrans     inventTrans;
        InventTrans     inventTransDuplicate;

        if (!InventParameters::find().AddTransact)
        {
            return;
        }

        InventDirection direction = this.transSign() > 0         ?
                                        InventDirection::Receipt :
                                        InventDirection::Issue;
        Set deletedTransactions = new Set(typeName2Type(extendedTypeStr(RecId)));

        ttsBegin;

        // Summing up is only possible if there exists at least one duplicate transaction
        while select forupdate inventTrans
            where inventTrans.InventTransOrigin == this.inventTransOriginId()
                  && inventTrans.TransChildType == this.transChildType()
                  && inventTrans.TransChildRefId == this.transChildRefId()
                  && (direction == InventDirection::Receipt || inventTrans.StatusReceipt == StatusReceipt::None)
                  && (direction == InventDirection::Issue || inventTrans.StatusIssue   == StatusIssue::None)
            exists join inventTransDuplicate
                where inventTransDuplicate.InventTransOrigin == inventTrans.InventTransOrigin
                      && inventTransDuplicate.StatusIssue == inventTrans.StatusIssue
                      && inventTransDuplicate.StatusReceipt == inventTrans.StatusReceipt
                      && inventTransDuplicate.InventDimId == inventTrans.InventDimId
                      && inventTransDuplicate.MarkingRefInventTransOrigin == inventTrans.MarkingRefInventTransOrigin
                      && inventTransDuplicate.RecId != inventTrans.RecId
        {
            if (!deletedTransactions.in(inventTrans.RecId))
            {
                inventTrans.updateSumUp(NoYes::No, false, deletedTransactions);
            }
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transChildRefId</Name>
				<Source><![CDATA[
    public InventTransChildRefId transChildRefId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>transChildType</Name>
				<Source><![CDATA[
    public InventTransChildType transChildType()
    {
        return InventTransChildType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDate</Name>
				<Source><![CDATA[
    abstract public TransDate transDate()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferDirection</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the direction of the transfer movements.
    /// </summary>
    /// <returns>
    ///    The direction of the transfer movements.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden in all transfer-related inherited classes.
    /// </remarks>
    public InventDirection transferDirection()
    {
        return InventDirection::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferInventTransOriginId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves an ID of transfer counterpart inventory transaction originator that corresponds to the
    ///    movement.
    /// </summary>
    /// <returns>
    ///    An ID of transfer counterpart inventory transaction originator that corresponds to the movement.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden in all transfer-related inherited classes.
    /// </remarks>
    public InventTransOriginId transferInventTransOriginId()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferIssueCostPriceInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    For a transfer issue the inventory dimension are returned.
    /// </summary>
    /// <returns>
    ///    The inventory dimension where the transfer was issued.
    /// </returns>
    /// <remarks>
    ///    Only the inventory dimension of the originating buffer are returned.
    /// </remarks>
    public InventDim transferIssueCostPriceInventDim()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transId</Name>
				<Source><![CDATA[
    public InventTransId transId()
    {
        if (! fieldName2id(buffer.TableId,fieldStr(InventTransOrigin,InventTransId)))
        {
            return '';
        }

        return buffer.(fieldName2id(buffer.TableId,fieldStr(InventTransOrigin,InventTransId)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>transIdSum</Name>
				<Source><![CDATA[
    public InventTransIdSum transIdSum(boolean _reRead = false)
    {
        if (! transIdSum || _reRead)
        {
            transIdSum = InventTransIdSum::newParameters(this.inventTransOriginId(), this.transChildType() != InventTransChildType::None, this.transChildType(), this.transChildRefId());
        }
        return transIdSum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transIdSumTransId</Name>
				<Source><![CDATA[
    protected InventTransIdSum transIdSumTransId(boolean _reRead = false)
    {
        if (this.transChildType() != InventTransChildType::None)
        {
            if (! transIdSumTransId || _reRead)
            {
                transIdSumTransId = InventTransIdSum::newTransOriginId(this.inventTransOriginId());
            }
        }
        else
        {
            transIdSumTransId = this.transIdSum(_reRead);
        }

        return transIdSumTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transInventRefType</Name>
				<Source><![CDATA[
    public InventRefType transInventRefType()
    {
        return InventRefType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transQty</Name>
				<Source><![CDATA[
    abstract public InventQty transQty()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>transQtyUnit</Name>
				<Source><![CDATA[
    public UnitQty  transQtyUnit()
    {
        return this.transQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transRefId</Name>
				<Source><![CDATA[
    public InventTransRefId transRefId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>transSchedTime</Name>
				<Source><![CDATA[
    public SchedTime transSchedTime()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transSign</Name>
				<Source><![CDATA[
    public Integer transSign()
    {
        return -1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transType</Name>
				<Source><![CDATA[
    abstract public InventTransType transType()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>transUnitId</Name>
				<Source><![CDATA[
    public UnitOfMeasureSymbol transUnitId()
    {
        if (this.mustBeUnitControlled())
        {
            throw error(Error::missingOverload(funcName()));
        }

        return this.inventTable().inventUnitId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventoryOwnerId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ID of the owner that must be assigned to all inventory transactions in the global country context.
    /// </summary>
    /// <returns>The ID of the inventory owner.</returns>
    protected InventOwnerId getInventoryOwnerId()
    {
        return InventOwner_RU::findOrCreateCurrentLegalEntity().InventOwnerId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAutoDimOwnerId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the movement's inventory owner dimension.
    /// </summary>
    /// <returns>true if the inventory owner dimension was updated; otherwise, false.</returns>
    public boolean updateAutoDimOwnerId()
    {
        InventDim inventDimLocal = this.inventdim();
        InventOwnerId originalOwnerId = inventDimLocal.InventOwnerId_RU;

        if (!(originalOwnerId && this.skipMandatoryInventoryOwnerCheck(inventDimLocal)))
        {
            inventDimLocal.setInventoryOwner(this.inventTable(), this.getInventoryOwnerId());
        }

        if (originalOwnerId != inventDimLocal.InventOwnerId_RU)
        {
            this.inventdim(inventDimLocal);
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAutoDimLocationId</Name>
				<Source><![CDATA[
    public boolean updateAutoDimLocationId()
    {
        InventDirection     inventDirection;
        InventDim           inventDimItemLoc;

        //No need to update default location for counting journal
        if (this.transType()  == InventTransType::InventCounting)
        {
            return false;
        }

        InventDim inventDimLocal = this.inventdim();
        if (inventDimLocal.wmsLocationId)
        {
            if (this.inventDimGroupSetup().isDimensionActive(fieldNum(InventDim,wmsLocationId)))
            {
                // validate that the already specified location actually exists
                if (WMSLocation::exist(inventDimLocal.wmsLocationId, inventDimLocal.InventLocationId))
                {
                    return false;
                }
            }
            inventDimLocal.wmsLocationId = ''; // clear the illegal location
            this.inventdim(inventDimLocal);
            return true;
        }

        // If an WHS controlled item and WHS controlled warehouse then skip this routine
        if (this.isItemWHSEnabled() &&
            InventLocation::find(inventDimLocal.InventLocationId).whsEnabled)
        {
            return false;
        }
        // No location specified going forward
        if (!this.inventDimGroupSetup().isDimensionActive(fieldNum(InventDim,wmsLocationId)))
        {
            return false;
        }

        InventQty qty = this.transQty();
        if (qty > 0)
        {
            inventDirection = InventDirection::Receipt;
        }
        else
        if (qty < 0)
        {
            inventDirection = InventDirection::Issue;
        }
        else
        {
            if (this.transSign() < 0)
            {
                if (this.isReturned(0))
                {
                    inventDirection = InventDirection::Receipt;
                }
                else
                {
                    inventDirection = InventDirection::Issue;
                }
            }
            else
            {
                if (this.isReturned(0))
                {
                    inventDirection = InventDirection::Issue;
                }
                else
                {
                    inventDirection = InventDirection::Receipt;
                }
            }
        }

        // Location should not be defaulted if we are marking, as it may end up in
        // conflicts against the matched inventory transaction
        if (   inventDirection == InventDirection::Issue
            && this.markingRefInventTransOrigin())
        {
            return false;
        }

        inventDimItemLoc.data(inventDimLocal.data());
        inventDimItemLoc.InventLocationId = this.inventLocationId();
        inventDimItemLoc = InventDim::findOrCreate(inventDimItemLoc);

        WMSLocation wmsLocation = WMSLocation::defaultItemLocation(this.itemId(), inventDirection, inventDimItemLoc);
        if (!wmsLocation)
        {
            return false; // no need to update
        }
        inventDimLocal.InventLocationId = wmsLocation.InventLocationId;
        inventDimLocal.initFromInventLocation(inventDimLocal.inventLocation());

        inventDimLocal.wmsLocationId    = wmsLocation.wmsLocationId;
        this.inventdim(inventDimLocal);
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAutoDimOwnerId_RU</Name>
				<Source><![CDATA[
    public boolean updateAutoDimOwnerId_RU()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAutoEstimate</Name>
				<Source><![CDATA[
    public void updateAutoEstimate(InventUpd_Estimated _estimated)
    {
        InventMov_Virtuel       movement_VirtuelOrig;
        InventTransId           inventTransId_Virtuel;
        InventTransOriginId     existingVirtuel_OriginId;

        UnitQty calcEstimatedUnit(InventQty _estimatedInventQty, InventMovement _movement)//duplicate of \Classes\InventUpdate\calcEstimatedUnit()
        {
            UnitQty estimatedUnitQty;

            if (_movement.mustBeUnitControlled())
            {
                estimatedUnitQty  = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_movement.itemId(),
                                                                                                          _movement.inventDimId(),
                                                                                                          _estimatedInventQty,
                                                                                                          _movement.inventTable().inventUnitId(),
                                                                                                          _movement.transUnitId(),
                                                                                                          NoYes::Yes);

                estimatedUnitQty  = decRound(estimatedUnitQty, UnitOfMeasure::unitOfMeasureDecimalPrecision(
                    UnitOfMeasure::unitOfMeasureIdBySymbol(_movement.transUnitId())));
            }
            else
            {
                estimatedUnitQty  = _estimatedInventQty;
            }
            return estimatedUnitQty;
        }

        if (this.parmInventTransOriginIdRef_virtuel())
        {
            existingVirtuel_OriginId = this.parmInventTransOriginIdRef_virtuel();
        }
        else
        {
            existingVirtuel_OriginId = InventTransOrigin::findMarkingRefInventTransOrigin(this.inventTransOriginId(), this.itemId(), true);
        }

        if (!existingVirtuel_OriginId && this.parmInventTransOriginIdOriginalProject())
        {
            existingVirtuel_OriginId = this.parmInventTransOriginIdOriginalProject();
        }

        if (!existingVirtuel_OriginId)
        {
            inventTransId_Virtuel = NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num();
        }
        else
        {
            inventTransId_Virtuel = InventTransOrigin::find(existingVirtuel_OriginId).InventTransId;
        }

        InventMov_Virtuel movement_Virtuel = InventMov_Virtuel::newAutoLossProfit_Estimate(_estimated, this, inventTransId_Virtuel);
        movement_Virtuel.addRemainPhysical(-_estimated.updEstimated());
        movement_Virtuel.addRemainPhysicalUnit(calcEstimatedUnit(-_estimated.updEstimated(), movement_Virtuel));

        InventMovement movement_Orig = this.newMovement_Orig();
        if (movement_Orig)
        {
            movement_VirtuelOrig=InventMov_Virtuel::newAutoLossProfit_Estimate(_estimated,this,inventTransId_Virtuel);
            movement_VirtuelOrig.parmInventMovReference(movement_Orig);
        }

        if (movement_Orig)
        {
            movement_VirtuelOrig.initAutoEstimateFromOrig(movement_Orig);
        }
        movement_Virtuel.parmInventMovVirtuelOrig(movement_VirtuelOrig);
        boolean changefromQuotationToPurch = (movement_Virtuel.parmInventMovVirtuelOrig()
                                     &&  movement_Virtuel.parmInventMovVirtuelOrig().mustBeQuotationControlled()
                                     &&  !movement_Virtuel.mustBeQuotationControlled());
        if (changefromQuotationToPurch)
        {
            movement_Virtuel.parmInventMovVirtuelOrig(null);
        }

        InventUpd_Estimated estimated_Virtuel = InventUpd_Estimated::newInventMovement(movement_Virtuel);
        estimated_Virtuel.parmPreEstimated(-_estimated.parmPreEstimated());
        estimated_Virtuel.parmTransEstimated(-_estimated.parmTransEstimated());

        // if the header changes from quotation to others
        if (changefromQuotationToPurch)
        {
            estimated_Virtuel.parmEstimated(-movement_Orig.transQty());
        }
        else
        {
            estimated_Virtuel.parmEstimated(estimated_Virtuel.parmTransEstimated()-estimated_Virtuel.parmPreEstimated());
        }

        estimated_Virtuel.updateNow();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAutoLossProfit</Name>
				<Source><![CDATA[
    public void updateAutoLossProfit(InventUpd_Financial _financial)
    {
        InventMov_Virtuel       movement_Virtuel;
        InventTrans             inventTrans;
        InventTransId           inventTransId_Virtuel;
        InventTransId           existingInventTransId_Virtuel   = '';
        ProjAdjustRefId         projAdjustRefId_Virtuel;

        if (_financial.parmAutoLossProfit() ||(_financial.movement().mustDoAutoLossProfitEstimate()))
        {
            InventTransOriginId existingVirtuel_OriginId = InventTransOrigin::findMarkingRefInventTransOrigin(this.inventTransOriginId(), this.itemId(), true);
            if (existingVirtuel_OriginId)
            {
                existingInventTransId_Virtuel = InventTransOrigin::find(existingVirtuel_OriginId).InventTransId;
            }

            while select forupdate inventTrans
                order by InventTransOrigin  // Force RecordViewCache to only return records existing at selection time
                where inventTrans.InventTransOrigin == this.inventTransOriginId()
                 &&   (!inventTrans.ProjId || !inventTrans.MarkingRefInventTransOrigin || existingInventTransId_Virtuel)
                 &&   inventTrans.DateFinancial     == _financial.parmLedgerVoucher().lastTransDate()
                 &&   inventTrans.Voucher           == _financial.parmLedgerVoucher().lastVoucher()
                 &&   inventTrans.InvoiceId         == _financial.parmInvoiceId()
                 &&   inventTrans.Qty               != 0
                 &&   (!_financial.parmPackingSlipId()   || inventTrans.PackingSlipId   == _financial.parmPackingSlipId())
                 &&   (!_financial.parmVoucherPhysical() || inventTrans.VoucherPhysical == _financial.parmVoucherPhysical())
            {
                if (inventTrans.ProjId && inventTransVirtualSet.in(inventTrans.RecId))
                {
                    continue;
                }
                if (!existingInventTransId_Virtuel)
                {
                    inventTransId_Virtuel = NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num();
                    existingInventTransId_Virtuel=inventTransId_Virtuel;
                }
                else
                {
                    inventTransId_Virtuel = existingInventTransId_Virtuel;
                }
                movement_Virtuel = _financial.movement().autoLossProfitInventMovVirtuel(_financial, inventTrans, inventTransId_Virtuel);
                movement_Virtuel.parmInventMovReference(_financial.movement());

                if (inventTrans.ProjId)
                {
                    ProjAdjustRefId   projAdjustRefIdTmp = projAdjustRefId_Virtuel;
                    ProjId            projIdTmp          = movement_Virtuel.projId();
                    ProjCategoryId    projCategoryIdTmp  = movement_Virtuel.projCategoryId();
                    InventTransOrigin inventTransOrigin  = InventTransOrigin::find(inventTransOriginId);
                    if (inventTransOrigin.ReferenceCategory == InventTransType::Sales &&
                    InventTransOriginSalesLine::salesLine(inventTransOrigin.RecId).Scrap)  // Posting should not affect the project, but inventory
                    {
                        projAdjustRefIdTmp  = '';
                        projIdTmp           = '';
                        projCategoryIdTmp   = '';
                    }
                    movement_Virtuel.setAutoLossProfitProjectInformation(projAdjustRefIdTmp, projIdTmp, projCategoryIdTmp);
                    inventTransVirtualSet.add(inventTrans.RecId);
                }

                InventUpd_Financial financial_Virtuel = this.constructInventUpdForUpdateAutoLossProfit(movement_Virtuel, _financial);
                financial_Virtuel.updateNow();

                if (!projAdjustRefId_Virtuel)
                {
                    projAdjustRefId_Virtuel = movement_Virtuel.projAdjustRefId();
                }
            }
            if (isConfigurationkeyEnabled(configurationKeyNum(Project))
                && !projAdjustRefId_Virtuel)
            {
                return;
            }
            else
            if (this.mustDoProjPosting())
            {
                ProjPost::newInventUpd_Financial(_financial,
                                                 _financial.parmLedgerVoucher(),
                                                 projAdjustRefId_Virtuel,
                                                 false,
                                                 inventTransId_Virtuel,
                                                 movement_Virtuel.parmMustNotReduceForecast()).postTrans();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructInventUpdForUpdateAutoLossProfit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs an <c>InventUpd_Financial</c> instance.
    /// </summary>
    /// <param name = "_movement_Virtuel">An <c>InventMov_Virtuel</c> instance.</param>
    /// <param name = "_financial">An <c>InventUpd_Financial</c> instance.</param>
    /// <returns>An <c>InventUpd_Financial</c> instance.</returns>
    protected InventUpd_Financial constructInventUpdForUpdateAutoLossProfit(InventMov_Virtuel _movement_Virtuel, InventUpd_Financial _financial)
    {
        return InventUpd_Financial::newAutoLossProfit(_movement_Virtuel, _financial);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAutoPhysical</Name>
				<Source><![CDATA[
    public void updateAutoPhysical(
        InventUpd_Physical  _physical,
        LedgerVoucher       _ledgerVoucher)
    {
        InventTransOriginId     existingVirtuel_OriginId;

        if (this.parmInventTransOriginIdRef_virtuel())
        {
            existingVirtuel_OriginId = this.parmInventTransOriginIdRef_virtuel();
        }
        else
        {
            existingVirtuel_OriginId = InventTransOrigin::findMarkingRefInventTransOrigin(this.inventTransOriginId(), this.itemId(), true);
        }

        if (!existingVirtuel_OriginId)
        {
            throw error(strFmt("@SYS105789", this.transId()));
        }
        InventMov_Virtuel movement_Virtuel = InventMov_Virtuel::newAutoLossProfit_Physical(_physical, this, InventTransOrigin::find(existingVirtuel_OriginId).InventTransId);

        if (movement_Virtuel.projId())
        {
            if (movement_Virtuel.parmUseEnteredPriceAsCost() && movement_Virtuel.inventModelType().stdCostBased())
            {
                movement_Virtuel.parmUseEnteredPriceAsCost(false);
            }

            if (this.parmProjectReturnIssue())
            {
                movement_Virtuel.parmProjectReturnReceipt(true);
            }
        }

        InventUpd_Physical physical_Virtuel = InventUpd_Physical::newAutoLossProfit(movement_Virtuel,
                                                                                    _physical,
                                                                                    -_physical.parmPhysical(),
                                                                                    -_physical.parmPhysicalUnit(),
                                                                                    -_physical.parmProjCostAmountMST());

        physical_Virtuel.updateNow(_ledgerVoucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the movement buffer and optionally the reservation.
    /// </summary>
    /// <param name="_updateReservation">
    ///    A Boolean value that specifies whether the reservation must be updated.
    /// </param>
    public void updateBuffer(boolean _updateReservation = true)
    {
        buffer.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDoBuffer</Name>
				<Source><![CDATA[
    public void updateDoBuffer()
    {
        buffer.doUpdate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateGoodsInRoute_RU</Name>
				<Source><![CDATA[
    void updateGoodsInRoute_RU(InventUpd_Financial _financial)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInheritedBatchesPostRegistration</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the batches created for co-products and finished goods from the ingredients, based on the rules defined for lot inheritance.
    /// </summary>
    /// <param name="_inventTrans">
    ///     The record of the <c>InventTrans</c> record associated with the inventory update.
    /// </param>
    /// <remarks>
    ///     The method call should be within a transaction scope.
    /// </remarks>
    public void updateInheritedBatchesPostRegistration(InventTrans _inventTrans)
    {
        //empty
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedFinanciallyForUpdateLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether financially booking is a must.
    /// </summary>
    /// <returns>
    /// true if financially booking is a must; otherwise, false.
    /// </returns>
    [Replaceable]
    protected boolean mustBeBookedFinanciallyForUpdateLedger()
    {
        return this.mustBeBookedFinancially();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedBalanceSheetForUpdateLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether balance sheet booking is a must.
    /// </summary>
    /// <returns>
    /// true if balance sheet booking is a must; otherwise, false.
    /// </returns>
    [Replaceable]
    protected boolean mustBeBookedBalanceSheetForUpdateLedger()
    {
        return this.mustBeBookedBalanceSheet();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedOperationsForUpdateLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether operation booking is a must.
    /// </summary>
    /// <returns>
    /// true if operation booking is a must; otherwise, false.
    /// </returns>
    [Replaceable]
    protected boolean mustBeBookedOperationsForUpdateLedger()
    {
        return this.mustBeBookedOperations();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerAdjust</Name>
				<Source><![CDATA[
    public void updateLedgerAdjust(
        LedgerVoucher           _ledgerVoucher,
        InventUpd_Financial     _updateNow,
        CostAmount              _costAmount,
        ProjAdjustRefId         _projAdjustRefId = '',
        ProjTransDate           _projTransDate  = dateNull())
    {
        // <GEERU>
        LedgerBondClient_RU         ledgerBondClient;
        boolean                     correct;
        LedgerVoucherTransObject    transObject;
        boolean                     countryRegion_RU = this.parmCompanyCountryRegion().isCountryRegionRU();
        // </GEERU>
        // <GEEU>
        boolean                     isStornoEnabled = LedgerParameters::isStornoEnabledEE();
        // </GEEU>
        if (!this.mustBeBookedFinanciallyForUpdateLedger())
        {
            return;
        }

        if (!this.checkInventSiteDimension(this.inventdim()))
        {
            throw error("@SYS18447");
        }

        if (!_costAmount)
        {
            return;
        }

        // <GEERU>
        if (countryRegion_RU)
        {
            ledgerBondClient = _ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
            correct          = _ledgerVoucher.findLedgerVoucherObject().parmCorrection();

            if (InventParameters::find().StornoAdjPosting && this.correctionSwapOnItem_RU(_costAmount))
            {
                correct = !correct;

                if (!isTelemetryForStornoSent)
                {
                    isTelemetryForStornoSent = true;
                    GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceRU00114, funcName());
                }
            }

            if (ledgerBondClient)
            {
                ledgerBondClient.addNewLogObject();
            }
        }
        // </GEERU>
        LedgerVoucherObject ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
        CurrencyExchangeHelper currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());

        if (this.mustBeBookedBalanceSheetForUpdateLedger())
        {
            // <GEERU>
            if (countryRegion_RU
                // <GEEU>
                || isStornoEnabled
                // </GEEU>
                )
            {
                transObject =
                    LedgerVoucherTransObject::newTransactionAmountDefault(
                        ledgerVoucherObject,
                        this.postingBalanceSheet(),
                        LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountBalanceSheet(), this.retrieveDimensionDefault1ForBalanceSheetUpdateLedger()),
                        CompanyInfoHelper::standardCurrency(),
                        _costAmount,
                        currencyExchHelper);
                // <GEEU>
                if (isStornoEnabled 
                    && this.isProjTransCorrectionApplicable_EE() && 
                    !StornoInvoiceToPreventInventoryVoucherLinesOnCreditNoteInvoice_EEFlight::instance().isEnabled())
                {
                    transObject.parmCorrect(this.isProjTransCorrection());
                }
                else if (isStornoEnabled && StornoInvoiceToPreventInventoryVoucherLinesOnCreditNoteInvoice_EEFlight::instance().isEnabled())
                {
                    if (this.isProjTransCorrectionApplicable_EE())
                    {
                        transObject.parmCorrect(this.isProjTransCorrection());
                    }
                }
                else
                {
                    // </GEEU>
                    transObject.parmCorrect(correct);
                    // <GEEU>
                }
                // </GEEU>
                
                this.updateFinTag(transObject);
                _ledgerVoucher.addTrans(transObject);
            }
            else
            {
                // </GEERU>
                transObject = InventoryReportingCurrencyTriangulationHelper::createLedgerVoucherTransObject(
                    ledgerVoucherObject,
                    this.postingBalanceSheet(),
                    LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountBalanceSheet(), this.retrieveDimensionDefault1ForBalanceSheetUpdateLedger(), this.retrieveDimensionDefault2ForBalanceSheetUpdateLedger()),
                    CompanyInfoHelper::standardCurrency(),
                    _costAmount,
                    currencyExchHelper);

                this.updateFinTag(transObject);
                _ledgerVoucher.addTrans(transObject);
                // <GEERU>
            }
            // </GEERU>

            _updateNow.updCostAmountLedger(_updateNow.updCostAmountLedger() + _costAmount);
        }

        if (this.mustBeBookedOperationsForUpdateLedger())
        {
            LedgerDimensionAccount mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(
                this.accountOperations(), this.retrieveDimensionDefault1ForOperationsUpdateLedger(), this.retrieveDimensionDefault2ForOperationsUpdateLedger());

            if (this.projId())
            {
                mergedLedgerDimension = this.getMergedProjectFundingSourceDimension(mergedLedgerDimension, this.projId());
            }

            LedgerVoucherTransObject ledgerVoucherTransObject = InventoryReportingCurrencyTriangulationHelper::createLedgerVoucherTransObject(
                    ledgerVoucherObject,
                    this.postingOperations(),
                    mergedLedgerDimension,
                    CompanyInfoHelper::standardCurrency(),
                    -_costAmount,
                    currencyExchHelper);

            this.updateFinTag(ledgerVoucherTransObject);

            // <GEERU>
            if (countryRegion_RU)
            {
                ledgerVoucherTransObject.parmCorrect(correct);
            }
            // </GEERU>

            ledgerVoucherTransObject.parmProjLedger(this.createProjLedgerForUpdateLedgerAdjust(_ledgerVoucher, _updateNow, _costAmount, _projAdjustRefId, _projTransDate));

            // <GEEU>
            if (isStornoEnabled && this.isProjTransCorrectionApplicable_EE())
            {
                ledgerVoucherTransObject.parmIsCorrection(this.isProjTransCorrection());
            }
            // </GEEU>
            ledgerVoucherTransObject.parmHistoricalExchangeRateDate(this.parmExchangeRateDate());
            _ledgerVoucher.addTrans(ledgerVoucherTransObject);

            this.setOperationsAmountLedger(_updateNow, _costAmount);
        }

        // <GEERU>
        if (countryRegion_RU
            && ledgerBondClient)
        {
            if (ledgerBondClient.currentLogLength() == 2)
            {
                ledgerBondClient.bondLastVRef2CurrentLog();
            }
            ledgerBondClient.removeCurrentLogObject();
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMergedProjectFundingSourceDimension</Name>
				<Source><![CDATA[
    private LedgerDimensionAccount getMergedProjectFundingSourceDimension(LedgerDimensionAccount _baseDefaultDimension, ProjId _projectId)
    {
        LedgerDimensionAccount mergedLedgerDimension = _baseDefaultDimension;

        ProjInvoiceTable projInvoiceTable = ProjInvoiceTable::find(ProjTable::find(_projectId).ProjInvoiceProjId);
        if (projInvoiceTable)
        {
            // Only merge project funding source dimension if the project contract has only one funding source.
            // This is done for performance reason so that it won't need to call into split LedgerVoucherTransObject
            // in ProjPost.postItemReverseTransaction().
            ProjFundingSource projFundingSource;
            if (ProjFundingSource::numberOfFundingSources(projInvoiceTable.ProjInvoiceProjId) == 1)
            {
                select firstonly DefaultDimension from projFundingSource
                    where projFundingSource.ContractId == projInvoiceTable.ProjInvoiceProjId;
            }

            if (projFundingSource.DefaultDimension)
            {
                mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(_baseDefaultDimension, projFundingSource.DefaultDimension);
            }
        }

        return mergedLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveDimensionDefault1ForBalanceSheetUpdateLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the first dimension default value for balance sheet update ledger.
    /// </summary>
    /// <returns>
    /// First dimension default value.
    /// </returns>
    protected DimensionDefault retrieveDimensionDefault1ForBalanceSheetUpdateLedger()
    {
        return this.defaultDimension();
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveDimensionDefault2ForBalanceSheetUpdateLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the second dimension default value for balance sheet update ledger.
    /// </summary>
    /// <returns>
    /// Second dimension default value.
    /// </returns>
    protected DimensionDefault retrieveDimensionDefault2ForBalanceSheetUpdateLedger()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveDimensionDefault1ForOperationsUpdateLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the first dimension default value for operations update ledger.
    /// </summary>
    /// <returns>
    /// First dimension default value.
    /// </returns>
    protected DimensionDefault retrieveDimensionDefault1ForOperationsUpdateLedger()
    {
        return this.defaultDimension();
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveDimensionDefault2ForOperationsUpdateLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the second dimension default value for operations update ledger.
    /// </summary>
    /// <returns>
    /// Second dimension default value.
    /// </returns>
    protected DimensionDefault retrieveDimensionDefault2ForOperationsUpdateLedger()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setOperationsAmountLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the operations amount on the instance of <c>InventUpd_Financial</c>.
    /// </summary>
    /// <param name="_updateNow">
    /// An instance of the <c>InventUpd_Financial</c> class.
    /// </param>
    /// <param name="_costAmount">
    /// The operations amount.
    /// </param>
    protected void setOperationsAmountLedger(
        InventUpd_Financial _updateNow,
        CostAmount _costAmount)
    {
        _updateNow.updOperationsAmountLedger(_updateNow.updOperationsAmountLedger() - _costAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjLedgerForUpdateLedgerAdjust</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>ProjLedger</c> instance for the updateLedgerAdjust method.
    /// </summary>
    /// <param name = "_ledgerVoucher">A ledger voucher.</param>
    /// <param name = "_updateNow">An instance of the <c>InventUpd_Financial</c> class.</param>
    /// <param name = "_costAmount">The cost amount.</param>
    /// <param name = "_projAdjustRefId">The adjustment number.</param>
    /// <param name = "_projTransDate">The project date.</param>
    /// <returns>
    /// A new <c>ProjLedger</c> instance.
    /// </returns>
    protected ProjLedger createProjLedgerForUpdateLedgerAdjust(
        LedgerVoucher           _ledgerVoucher,
        InventUpd_Financial     _updateNow,
        CostAmount              _costAmount,
        ProjAdjustRefId         _projAdjustRefId,
        ProjTransDate           _projTransDate)
    {
        ProjLedger projLedger = ProjLedger::newInventCost(
            this.projId(),
            this.activityNumber(),
            this.projCategoryId(),
            this.transId(),
            _projAdjustRefId,
            this.projTransactionOrigin(),
            this.projLedgerOrigin(),
            this.itemId(),
            false,
            _projTransDate,
            ProjItemTransCostType::Cost);

        return projLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerAdjustSecCur_RU</Name>
				<Source><![CDATA[
    public void updateLedgerAdjustSecCur_RU(
        LedgerVoucher           _ledgerVoucher,
        InventUpd_Financial     _updateNow,
        CostAmountSecCur_RU     _costAmount,
        ProjAdjustRefId         _projAdjustRefId = '',
        ProjTransDate           _projTransDate   = dateNull())
    {
        LedgerVoucherTransObject    trans;

        if (!this.mustBeBookedFinancially() || !this.mustBeBookedOnhandSecCur_RU())
        {
            return;
        }

        if (!_costAmount)
        {
            return;
        }

        if (!isTelemetryForSecCurSent)
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceRU00111, funcName());
            isTelemetryForSecCurSent = true;
        }

        LedgerVoucherObject ledgerVoucherObject = _ledgerVoucher.findOrCreateReferenceSecCur_RU();
        LedgerBondClient_RU ledgerBondClient    = ledgerVoucherObject.ledgerBondClient_RU();
        boolean             correct             = ledgerVoucherObject.parmCorrection();

        if (InventParameters::find().StornoAdjPosting && this.correctionSwapOnItem_RU(_costAmount))
        {
            correct = !correct;
        }

        if (ledgerBondClient)
        {
            ledgerBondClient.addNewLogObject();
        }

        if (this.mustBeBookedBalanceSheetForUpdateLedger())
        {
            trans = LedgerVoucherTransObject::newBasicSecondary_RU(
                    ledgerVoucherObject,
                    this.postingBalanceSheet(),
                    LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountBalanceSheet(), this.defaultDimension()),
                    CompanyInfoHelper::standardCurrency(),
                    _costAmount);

            trans.parmCorrect(correct);
            ledgerVoucherObject.addTrans(trans);
        }

        if (this.mustBeBookedOperations())
        {
            trans = LedgerVoucherTransObject::newBasicSecondary_RU(
                        ledgerVoucherObject,
                        this.postingOperations(),
                        LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountOperations(), this.defaultDimension()),
                        CompanyInfoHelper::standardCurrency(),
                        -_costAmount);

            trans.parmCorrect(correct);
            trans.parmProjLedger(ProjLedger::newInventCost(this.projId(),
                                              this.activityNumber(),
                                              this.projCategoryId(),
                                              this.transId(),
                                              _projAdjustRefId,
                                              this.projTransactionOrigin(),
                                              this.projLedgerOrigin(),
                                              this.itemId(),
                                              false,
                                              _projTransDate,
                                              ProjItemTransCostType::Cost));

            ledgerVoucherObject.addTrans(trans);
        }

        if (ledgerBondClient)
        {
            if (ledgerBondClient.currentLogLength() == 2)
            {
                ledgerBondClient.bondLastVRef2CurrentLog();
            }

            ledgerBondClient.removeCurrentLogObject();
        }

        _ledgerVoucher.restoreReferenceSecCur_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerFinancial</Name>
				<Source><![CDATA[
    public CostAmount updateLedgerFinancial(
        LedgerVoucher       _ledgerVoucher,
        InventUpd_Financial _updateNow,
        boolean             _allowNegative = false)
    {
        CostAmount                  costAmountMST;
        AmountMST                   transactionAmountMst;
        // <GEERU>
        LedgerBondClient_RU ledgerBondClient = _ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
        boolean             countryRegion_RU = this.parmCompanyCountryRegion().isCountryRegionRU();
        // </GEERU>
        LedgerVoucherTransObject    ledgerVoucherTransObject;

        if (_updateNow.parmFinancial() <= 0 && !_allowNegative)
        {
            return 0;
        }

        if (this.mustBeBookedFinanciallyForUpdateLedger())
        {
            if (!this.checkInventSiteDimension(this.inventdim()))
            {
                throw error("@SYS18447");
            }

            // <GEERU>
            if (countryRegion_RU
                && ledgerBondClient)
            {
                ledgerBondClient.addNewLogObject();
            }
            // </GEERU>
            CurrencyExchangeHelper exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(
                Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
               _ledgerVoucher.findLedgerVoucherObject().parmAccountingDate());

            exchangeRateHelper.parmExchangeRate1(_updateNow.parmExchRate());
            exchangeRateHelper.parmExchangeRate2(_updateNow.parmExchRateSecondary());

            if (this.mustBeBookedBalanceSheetForUpdateLedger())
            {
                // <GEEU>
                ledgerVoucherTransObject =
                // </GEEU>
                LedgerVoucherTransObject::newTransactionAmountDefault(
                            _ledgerVoucher.findLedgerVoucherObject(),
                            this.postingBalanceSheet(),
                            LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountBalanceSheet(), this.retrieveDimensionDefault1ForBalanceSheetUpdateLedger(), this.retrieveDimensionDefault2ForBalanceSheetUpdateLedger()),
                            _updateNow.parmCurrencyCode(),
                            _updateNow.parmCostAmountCur()
                            // <GTE>
                            - this.taxEngineInventMovement().taxInCostPriceCur() - this.taxEngineInventMovement().postedTaxInCostPriceCur(),
                            // </GTE>
                // <GEEU>
                            exchangeRateHelper);

                if (LedgerParameters::isStornoEnabledEE() && this.isProjTransCorrectionApplicable_EE())
                {
                    ledgerVoucherTransObject.parmIsCorrection(this.isProjTransCorrection());
                }
                this.updateFinTag(ledgerVoucherTransObject);

                _ledgerVoucher.addTrans(ledgerVoucherTransObject);
                // </GEEU>
                costAmountMST = exchangeRateHelper.calculateTransactionToAccounting(_updateNow.parmCurrencyCode(), _updateNow.parmCostAmountCur(), true);

                // <GTE>
                if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
                {
                    this.taxEngineInventMovement().updateTaxFinancial(
                        _ledgerVoucher, _updateNow, 
                        this.postingBalanceSheet(), this.accountBalanceSheet(), 
                        this.defaultDimension());
                    costAmountMST += (this.taxEngineInventMovement().taxInCostPriceMST() + this.taxEngineInventMovement().postedTaxInCostPriceMST());
                }
                // </GTE>

                this.initializeCostAmountLedger(_updateNow, costAmountMST);
            }

            if (! this.mustBeBookedBalanceSheet() && ! this.mustBeBookedOperations())
            {
                if (_updateNow.parmCurrencyCode() != CompanyInfoHelper::standardCurrency())
                {
                    throw error("@SYS2009");
                }
                costAmountMST = _updateNow.parmCostAmountCur();
            }

            if (this.mustBeBookedOperationsForUpdateLedger())
            {
                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                        _ledgerVoucher.findLedgerVoucherObject(),
                        this.postingOperations(),
                        LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountOperations(), this.retrieveDimensionDefault1ForOperationsUpdateLedger(),
                                                                            this.retrieveDimensionDefault2ForOperationsUpdateLedger()),
                        _updateNow.parmCurrencyCode(),
                       -_updateNow.parmCostAmountCur()
                        // <GTE>
                        + this.taxEngineInventMovement().taxInCostPriceCur() + this.taxEngineInventMovement().postedTaxInCostPriceCur(),
                        // </GTE>
                        exchangeRateHelper);

                ledgerVoucherTransObject.parmProjLedger(this.createProjLedgerForUpdateLedgerFinancial(_ledgerVoucher, _updateNow, _allowNegative));

                // <GEEU>
                if (LedgerParameters::isStornoEnabledEE() && this.isProjTransCorrectionApplicable_EE())
                {
                    ledgerVoucherTransObject.parmIsCorrection(this.isProjTransCorrection());
                }
                // </GEEU>

                this.updateFinTag(ledgerVoucherTransObject);

                _ledgerVoucher.addTrans(ledgerVoucherTransObject);

                if (_updateNow.parmCostAmountCur())
                {
                    transactionAmountMst = exchangeRateHelper.calculateTransactionToAccounting(_updateNow.parmCurrencyCode(), -_updateNow.parmCostAmountCur(), true);
                    _updateNow.updOperationsAmountLedger(transactionAmountMst);
                    if (! this.mustBeBookedBalanceSheet())
                    {
                        costAmountMST = -transactionAmountMst;
                    }
                }
                else
                {
                    // No ledger transactions created so lastAmountMST isn't updated from last posting
                    _updateNow.updOperationsAmountLedger(0);
                    if (! this.mustBeBookedBalanceSheet())
                    {
                        costAmountMST = 0;
                    }
                }

                // <GTE>
                if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
                {
                    this.taxEngineInventMovement().updateTaxFinancial(_ledgerVoucher, _updateNow, this.postingOperations(), this.accountOperations(), this.defaultDimension());
                    if (_updateNow.parmCostAmountCur())
                    {
                        transactionAmountMst = exchangeRateHelper.calculateTransactionToAccounting(_updateNow.parmCurrencyCode(), -_updateNow.parmCostAmountCur(), true);
                        _updateNow.updOperationsAmountLedger(transactionAmountMst);
                        if (!this.mustBeBookedBalanceSheet())
                        {
                            costAmountMST = -(transactionAmountMst + this.taxEngineInventMovement().taxInCostPriceMST() + this.taxEngineInventMovement().postedTaxInCostPriceMST());
                        }
                    }
                }
                // </GTE>
            }

            // <GEERU>
            if (countryRegion_RU
                && ledgerBondClient)
            {
                if (ledgerBondClient.currentLogLength() == 2)
                {
                    ledgerBondClient.bondLastVRef2CurrentLog();
                }

                ledgerBondClient.removeCurrentLogObject();
            }
            // </GEERU>
        }
        else
        {
            if (_updateNow.parmCurrencyCode() != CompanyInfoHelper::standardCurrency())
            {
                throw error("@SYS2009");
            }

            // If inventory is not financial updated project create a never ledger transaction in the project module
            if (this.projId() && ProjPost::checkCreateProjCost(this.itemId(),this.projId()))
            {
                ProjPost::newInventNeverLedger2(this.transId(),
                                                this.projAdjustRefId(),
                                                this.projId(),
                                                _ledgerVoucher.lastTransDate(),
                                                _ledgerVoucher.lastVoucher(),
                                                _updateNow.parmCostAmountCur(),
                                                false,
                                                ProjItemTransCostType::Cost).postTrans();
            }
        }

        costAmountMST = _updateNow.parmCostAmountCur()
                        // <GTE>
                        + this.taxEngineInventMovement().taxInCostPriceMST() + this.taxEngineInventMovement().postedTaxInCostPriceMST();
                        // </GTE>
        return costAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCostAmountLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the cost amount on the instance of <c>InventUpd_Financial</c>.
    /// </summary>
    /// <param name="_updateNow">
    /// An instance of the <c>InventUpd_Financial</c> class.
    /// </param>
    /// <param name="_costAmount">
    /// The cost amount.
    /// </param>
    protected void initializeCostAmountLedger(
        InventUpd_Financial _updateNow,
        CostAmount _costAmount)
    {
        _updateNow.updCostAmountLedger(_costAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjLedgerForUpdateLedgerFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>ProjLedger</c> instance for the updateLedgerFinancial method.
    /// </summary>
    /// <param name = "_ledgerVoucher">
    /// An instance of the <c>LedgerVoucher</c> class.
    /// </param>
    /// <param name = "_updateNow">
    /// An instance of the <c>InventUpd_Financial</c> class.
    /// </param>
    /// <param name = "_allowNegative">
    /// A boolean indicating if negative is allowed.
    /// </param>
    /// <returns>
    /// A new <c>ProjLedger</c> instance.
    /// </returns>
    protected ProjLedger createProjLedgerForUpdateLedgerFinancial(
        LedgerVoucher       _ledgerVoucher,
        InventUpd_Financial _updateNow,
        boolean             _allowNegative)
    {
        ProjLedger projLedger = ProjLedger::newInventCost(
            this.projId(),
            this.activityNumber(),
            this.projCategoryId(),
            this.transId(),
            this.projAdjustRefId(),
            this.projTransactionOrigin(),
            this.projLedgerOrigin(),
            this.itemId(),
            false,
            _updateNow.parmProjTransDate(),
            ProjItemTransCostType::Cost,
            this.transType(),
            this.transRefId());

        return projLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerFinancialSecCur_RU</Name>
				<Source><![CDATA[
    public CostAmountSecCur_RU updateLedgerFinancialSecCur_RU(
        LedgerVoucher         _ledgerVoucher,
        InventUpd_Financial   _updateNow,
        boolean               _allowNegative = false)
    {
        CostAmountSecCur_RU         costAmountSecCur;

        if (this.mustBeBookedOnhandSecCur_RU() && (_updateNow.parmFinancial() > 0 || _allowNegative))
        {
            costAmountSecCur = CurrencyExchangeHelper::amount(_updateNow.parmCostAmountCurSecCur_RU(), CompanyInfoHelper::secondaryCurrency_RU());

            if (this.mustBeBookedFinancially())
            {
                if (!isTelemetryForSecCurSent)
                {
                    GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceRU00111, funcName());
                    isTelemetryForSecCurSent = true;
                }

                LedgerVoucherObject ledgerVoucherObject = _ledgerVoucher.findOrCreateReferenceSecCur_RU();

                LedgerBondClient_RU ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();
                if (ledgerBondClient)
                {
                    ledgerBondClient.addNewLogObject();
                }

                if (this.mustBeBookedBalanceSheet())
                {
                    ledgerVoucherObject.addTrans(
                        LedgerVoucherTransObject::newBasicSecondary_RU(
                            ledgerVoucherObject,
                            this.postingBalanceSheet(),
                            LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountBalanceSheet(), this.defaultDimension()),
                            _updateNow.parmCurrencyCode(),
                            costAmountSecCur,
                            ledgerVoucherObject.parmCorrection()));

                    _updateNow.updCostAmountSecCurLedger_RU(costAmountSecCur);
                }

                if (this.mustBeBookedOperations())
                {
                    LedgerVoucherTransObject transObject = LedgerVoucherTransObject::newBasicSecondary_RU(
                        ledgerVoucherObject,
                        this.postingOperations(),
                        LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountOperations(), this.defaultDimension()),
                        _updateNow.parmCurrencyCode(),
                        -costAmountSecCur,
                        ledgerVoucherObject.parmCorrection());

                    transObject.parmProjLedger(
                        ProjLedger::newInventCost(
                            this.projId(),
                            this.activityNumber(),
                            this.projCategoryId(),
                            this.transId(),
                            this.projAdjustRefId(),
                            this.projTransactionOrigin(),
                            this.projLedgerOrigin(),
                            this.itemId(),
                            false,
                            _updateNow.parmProjTransDate(),
                            ProjItemTransCostType::Cost,
                            this.transType(),
                            this.transRefId()));

                    ledgerVoucherObject.addTrans(transObject);

                    _updateNow.updOperationsAmountSecCurLedger_RU(-costAmountSecCur);
                }

                if (ledgerBondClient)
                {
                    if (ledgerBondClient.currentLogLength() == 2)
                    {
                        ledgerBondClient.bondLastVRef2CurrentLog();
                    }

                    ledgerBondClient.removeCurrentLogObject();
                }

                _ledgerVoucher.restoreReferenceSecCur_RU();
            }
        }

        return costAmountSecCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs physical update of a ledger.
    /// </summary>
    /// <param name = "_ledgerVoucher">A ledger voucher.</param>
    /// <param name = "_inventTrans">An inventory transaction.</param>
    /// <param name = "_updateNow">An inventory transaction status update.</param>
    /// <param name = "_inventOnhand">An inventory on hand quantity.</param>
    /// <param name = "_inventTransUpd_RU">An inventory transaction update RU region instance.</param>
    public void updateLedgerPhysical(
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans,
        InventUpdate    _updateNow,
        InventOnhand    _inventOnhand,
        InventTrans     _inventTransUpd_RU = _inventTrans
        )
    {
        boolean ledgerVoucherCorrectionChanged;

        if (_inventTrans.isUpdatedPhysical())
        {
            ledgerVoucherCorrectionChanged = this.performPhysicalLedgerUpdate(
                _ledgerVoucher, 
                _inventTrans,
                _updateNow, 
                _inventOnhand,
                _inventTransUpd_RU);
        }
        else if (_inventTrans.isUpdatedFinancial())
        {
            ledgerVoucherCorrectionChanged = this.performFinancialLedgerUpdate(
                _ledgerVoucher,
                _inventTrans,
                _updateNow,
                _inventOnhand,
                _inventTransUpd_RU);
        }

        if (ledgerVoucherCorrectionChanged)
        {
            _ledgerVoucher.findLedgerVoucherObject().parmCorrection(!_ledgerVoucher.findLedgerVoucherObject().parmCorrection());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>invertVoucherCorrectionChanged_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inverts parameter that indicates if correction is default for RU region.
    /// </summary>
    /// <param name = "_ledgerVoucher">A ledger voucher.</param>
    /// <returns>true if parameter has been changed; otherwise, false.</returns>
    protected boolean invertVoucherCorrectionChanged_RU(LedgerVoucher _ledgerVoucher)
    {
        boolean ledgerVoucherCorrectionChanged;

        if (this.parmCompanyCountryRegion().isCountryRegionRU()
            && _ledgerVoucher.findLedgerVoucherObject().parmIsCorrectionDefault())
        {
            _ledgerVoucher.findLedgerVoucherObject().parmIsCorrectionDefault(false);
            ledgerVoucherCorrectionChanged = true;
        }

        return ledgerVoucherCorrectionChanged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>performPhysicalLedgerUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs physical ledger update.
    /// </summary>
    /// <param name = "_ledgerVoucher">A ledger voucher instance.</param>
    /// <param name = "_inventTrans">An inventory transaction.</param>
    /// <param name = "_updateNow">An inventory transaction update instance.</param>
    /// <param name = "_inventOnhand">An inventory on hand quantity.</param>
    /// <param name = "_inventTransUpd_RU">An inventory transaction update RU region instance.</param>
    /// <returns>true if the ledger voucher correction has been changed; otherwise, false.</returns>
    protected boolean performPhysicalLedgerUpdate(
        LedgerVoucher _ledgerVoucher, 
        InventTrans _inventTrans, 
        InventUpdate _updateNow,
        InventOnhand _inventOnhand,
        InventTrans _inventTransUpd_RU)
    {
        boolean             isCountryRegion_RU             = this.parmCompanyCountryRegion().isCountryRegionRU();
        InventUpd_Physical  inventUpd_Physical             = isCountryRegion_RU && classIdGet(_updateNow) == classNum(InventUpd_Physical)  ? _updateNow : null;
        boolean             ledgerVoucherCorrectionChanged = this.updateLedgerVoucherCorrectionChangedForPhysicalUpdate(_ledgerVoucher, inventUpd_Physical);

        _updateNow.postingPhysical(true);

        if (_inventTrans.VoucherPhysical)
        {
            throw error("@SYS14236");
        }

        this.updateInventTransUpdStornoPhysicalForPhysicalUpdate_RU(_inventTransUpd_RU, inventUpd_Physical);

        _inventTrans.VoucherPhysical = _ledgerVoucher.lastVoucher();

        this.setCostAmountPhysical(_inventTrans, _updateNow, _inventOnhand);

        LedgerVoucherObject      ledgerVoucherObject    = _ledgerVoucher.findLedgerVoucherObject();
        CurrencyExchangeHelper   currencyExchHelper     = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
        LedgerBondClient_RU      ledgerBondClient       = ledgerVoucherObject.ledgerBondClient_RU();

        if (this.mustBeBookedPhysically())
        {
            if (!this.checkInventSiteDimension(this.inventdim()))
            {
                throw error("@SYS18447");
            }
            _updateNow.updPhysicalAmountLedger(_inventTrans.CostAmountPhysical + _updateNow.updPhysicalAmountLedger());

            this.addLedgerVoucherTransactionAmountsForPhysicalUpdate(
                _ledgerVoucher, 
                _inventTrans, 
                ledgerVoucherObject, 
                currencyExchHelper);

            if (isCountryRegion_RU
                && ledgerBondClient
                && _inventTrans.CostAmountPhysical)
            {
                ledgerBondClient.bondLast2();
            }
        }
        else
        {
            bookedPhysically = UnknownNoYes::No;
        }

        if (this.mustBeBookedPhysicalRevenue())
        {
            if (!this.checkInventSiteDimension(this.inventdim()))
            {
                throw error("@SYS18447");
            }

            if (isCountryRegion_RU && ledgerBondClient)
            {
                ledgerBondClient.addNewLogObject();
            }

            _updateNow.postingPhysicalRevenue(true);

            _inventTrans.RevenueAmountPhysical = this.estimatedPhysicalRevenue(_inventTrans);
            _inventTrans.TaxAmountPhysical     = this.estimatedPhysicalTax(_inventTrans);

            _updateNow.updPhysicalRevenueAmountLedger(_inventTrans.RevenueAmountPhysical + _updateNow.updPhysicalRevenueAmountLedger());
                
            LedgerBondId_RU vRefId = this.addLedgerVoucherRevenueTransactionAmountsForPhysicalUpdate(
                _ledgerVoucher, 
                _inventTrans, 
                ledgerVoucherObject, 
                currencyExchHelper);

            if (isCountryRegion_RU && ledgerBondClient)
            {
                if (_inventTrans.RevenueAmountPhysical && vRefId)
                {
                    ledgerBondClient.bondVRef2Log(vRefId);
                }
                ledgerBondClient.removeCurrentLogObject();
            }
        }
        else
        {
            bookedPhysicalRevenue = UnknownNoYes::No;
        }

        return ledgerVoucherCorrectionChanged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventTransUpdStornoPhysicalForPhysicalUpdate_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates storno flag on an inventory transaction update instance for the RU country region.
    /// </summary>
    /// <param name = "_inventTransUpd_RU">An inventory transaction update instance for the RU country region.</param>
    /// <param name = "_inventUpd_Physical">An instance used to update an inventory physically.</param>
    protected void updateInventTransUpdStornoPhysicalForPhysicalUpdate_RU(InventTrans _inventTransUpd_RU, InventUpd_Physical _inventUpd_Physical)
    {
        if (_inventUpd_Physical
            && (((_inventUpd_Physical.parmCalledFromFinancial() || this.parmStornoPhysicalForced_RU()) && this.parmStornoPhysical_RU())
                || ((_inventUpd_Physical.parmPhysical() * this.transSign() > 0
                       && _inventUpd_Physical.parmCalledFromFinancial()
                       && this.parmStornoPhysical_RU() 
                       && _inventUpd_Physical.parmReturnMode() == InventUpdate::financialReturn())
                    || (_inventUpd_Physical.parmPhysical() * this.transSign() < 0 && this.parmStornoPhysical_RU()))))
        {
            _inventTransUpd_RU.StornoPhysical_RU = NoYes::Yes;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerVoucherCorrectionChangedForPhysicalUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates whether correction is default for a ledger voucher for a physical ledger update.
    /// </summary>
    /// <param name = "_ledgerVoucher">A ledger voucher.</param>
    /// <param name = "_inventUpd_Physical">An instance used to update an inventory physically.</param>
    /// <returns>true if the parameter has been changed; otherwise, false.</returns>
    protected boolean updateLedgerVoucherCorrectionChangedForPhysicalUpdate(LedgerVoucher _ledgerVoucher, InventUpd_Physical _inventUpd_Physical)
    {
        boolean ledgerVoucherCorrectionChanged = this.invertVoucherCorrectionChanged_RU(_ledgerVoucher);

        if (_inventUpd_Physical
            && (((_inventUpd_Physical.parmPhysical() * this.transSign() < 0) || this.parmStornoPhysicalForced_RU()) && this.parmStornoPhysical_RU()))
        {
            _ledgerVoucher.findLedgerVoucherObject().parmIsCorrectionDefault(! _ledgerVoucher.findLedgerVoucherObject().parmIsCorrectionDefault());
            ledgerVoucherCorrectionChanged = !ledgerVoucherCorrectionChanged;
        }

        return ledgerVoucherCorrectionChanged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCostAmountPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets a cost amount for a physical update.
    /// </summary>
    /// <param name = "_inventTrans">An inventory transaction.</param>
    /// <param name = "_updateNow">An inventory transaction update instance.</param>
    /// <param name = "_inventOnhand">An inventory on hand quantity.</param>
    protected void setCostAmountPhysical(
        InventTrans _inventTrans,
        InventUpdate _updateNow,
        InventOnhand _inventOnhand)
    {
        boolean isCountryRegion_RU = this.parmCompanyCountryRegion().isCountryRegionRU();

        if (this.useEnteredPriceAsCost())
        {
            _inventTrans.CostAmountPhysical = _updateNow.parmProjCostAmountMST();

            if (isCountryRegion_RU && this.mustBeBookedOnhandSecCur_RU())
            {
                _inventTrans.CostAmountSecCurPhysical_RU = _updateNow.parmProjCostAmountMSTSecCur_RU();
            }
        }
        else
        {
            _inventTrans.CostAmountPhysical = this.retrieveEstimatedCostAmountPhysicalValue(_inventTrans, _inventOnhand, _updateNow);

            if (isCountryRegion_RU && this.mustBeBookedOnhandSecCur_RU())
            {
                _inventTrans.CostAmountSecCurPhysical_RU = this.estimatedPhysicalValueSecCur_RU(_inventTrans, _inventOnhand, _updateNow);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveEstimatedCostAmountPhysicalValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the estimated cost amount for a physical update.
    /// </summary>
    /// <param name = "_inventTrans">
    /// An inventory transaction.
    /// </param>
    /// <param name = "_inventOnhand">
    /// An inventory on hand quantity.
    /// </param>
    /// <param name = "_updateNow">
    /// An inventory transaction update instance.
    /// </param>
    /// <returns>
    /// Estimated cost amount.
    /// </returns>
    [Replaceable]
    protected CostAmount retrieveEstimatedCostAmountPhysicalValue(
        InventTrans _inventTrans, 
        InventOnhand _inventOnhand,
        InventUpdate _updateNow)
    {
        return _updateNow.movement().inventModelType().estimatedPhysicalValue(_inventTrans, _inventOnhand, _updateNow);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerVoucherTransactionAmountsForPhysicalUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds transaction amounts to be posted for a physical update.
    /// </summary>
    /// <param name = "_ledgerVoucher">A ledger voucher.</param>
    /// <param name = "_inventTrans">An inventory transaction.</param>
    /// <param name = "_ledgerVoucherObject">A ledger voucher object.</param>
    /// <param name = "_currencyExchHelper">A currency exchange helper.</param>
    protected void addLedgerVoucherTransactionAmountsForPhysicalUpdate(
        LedgerVoucher _ledgerVoucher,
        InventTrans _inventTrans, 
        LedgerVoucherObject _ledgerVoucherObject, 
        CurrencyExchangeHelper _currencyExchHelper)
    {
        CurrencyCode             standardCurrencyCode       = CompanyInfoHelper::standardCurrency();
        boolean                  isCountryRegion_RU         = this.parmCompanyCountryRegion().isCountryRegionRU();

        ProjLedger projLedger = this.createProjLedgerForAddLedgerVoucherTransaction(_ledgerVoucher, _inventTrans, _ledgerVoucherObject, _currencyExchHelper);
                
        if (isCountryRegion_RU || projLedger || _ledgerVoucher.parmDetailSummary() != DetailSummary::Summary)
        {
            LedgerVoucherTransObject ledgerVoucherTransObject = 
                this.createLedgerVoucherTransObject(
                    _ledgerVoucherObject,
                    this.postingPhysical(),
                    LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountPhysical(), this.defaultDimension()),
                    standardCurrencyCode,
                    _inventTrans.CostAmountPhysical,
                    _currencyExchHelper);

            ledgerVoucherTransObject.parmProjLedger(projLedger);
                
            _ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }
        else
        {
            this.addLedgerPhysicalAmounts(this.postingPhysical(),
                LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountPhysical(), this.defaultDimension()),
                _inventTrans.CostAmountPhysical);
        }

        projLedger = this.createProjLedgerForAddLedgerVoucherTransaction(_ledgerVoucher, _inventTrans, _ledgerVoucherObject, _currencyExchHelper, ProjItemTransCostType::Accrued);

        if (isCountryRegion_RU || projLedger || _ledgerVoucher.parmDetailSummary() != DetailSummary::Summary)
        {
            LedgerVoucherTransObject ledgerVoucherTransObject = 
                this.createLedgerVoucherTransObject(
                    _ledgerVoucherObject,
                    this.postingOffsetPhysical(),
                    LedgerDimensionFacade::serviceCreateLedgerDimension(this.offsetAccountPhysical(), this.defaultDimension()),
                    standardCurrencyCode,
                    -_inventTrans.CostAmountPhysical,
                    _currencyExchHelper);

            ledgerVoucherTransObject.parmProjLedger(projLedger);

            _ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }
        else
        {
            this.addLedgerPhysicalAmounts(this.postingOffsetPhysical(),
                LedgerDimensionFacade::serviceCreateLedgerDimension(this.offsetAccountPhysical(), this.defaultDimension()),
                -_inventTrans.CostAmountPhysical);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerVoucherRevenueTransactionAmountsForPhysicalUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds revenue transaction amounts to be posted for a physical update.
    /// </summary>
    /// <param name = "_ledgerVoucher">A ledger voucher.</param>
    /// <param name = "_inventTrans">An inventory transaction.</param>
    /// <param name = "_ledgerVoucherObject">A ledger voucher object.</param>
    /// <param name = "_currencyExchHelper">A currency exchange helper.</param>
    /// <returns>A ledger bond ID for the country region RU.</returns>
    protected LedgerBondId_RU addLedgerVoucherRevenueTransactionAmountsForPhysicalUpdate(
        LedgerVoucher _ledgerVoucher,
        InventTrans _inventTrans,
        LedgerVoucherObject _ledgerVoucherObject,
        CurrencyExchangeHelper _currencyExchHelper)
    {
        CurrencyCode             standardCurrencyCode       = CompanyInfoHelper::standardCurrency();
        boolean                  isCountryRegion_RU         = this.parmCompanyCountryRegion().isCountryRegionRU();
        
        if (isCountryRegion_RU || _ledgerVoucher.parmDetailSummary() != DetailSummary::Summary)
        {
            LedgerVoucherTransObject ledgerVoucherTransObject = 
                this.createLedgerVoucherTransObject(
                    _ledgerVoucherObject,
                    this.postingPhysicalRevenue(),
                    LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountPhysicalRevenue(), this.defaultDimension()),
                    standardCurrencyCode,
                    _inventTrans.RevenueAmountPhysical,
                    _currencyExchHelper);
                
            _ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }
        else
        {
            this.addLedgerPhysicalAmounts(this.postingPhysicalRevenue(),
                LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountPhysicalRevenue(), this.defaultDimension()),
                _inventTrans.RevenueAmountPhysical);
        }

        LedgerBondClient_RU ledgerBondClient = _ledgerVoucherObject.ledgerBondClient_RU();
        LedgerBondId_RU vRefId;

        if (isCountryRegion_RU)
        {
            vRefId = (ledgerBondClient != null) ? ledgerBondClient.lastVrefId(): 0;
        }

        if (isCountryRegion_RU || _ledgerVoucher.parmDetailSummary() != DetailSummary::Summary)
        {
            LedgerVoucherTransObject ledgerVoucherTransObject = 
                this.createLedgerVoucherTransObject(
                    _ledgerVoucherObject,
                    this.postingPhysicalRevenueOffset(),
                    LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountPhysicalRevenueOffset(), this.defaultDimension()),
                    standardCurrencyCode,
                    -_inventTrans.RevenueAmountPhysical - _inventTrans.TaxAmountPhysical,
                    _currencyExchHelper);

            _ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }
        else
        {
            this.addLedgerPhysicalAmounts(this.postingPhysicalRevenueOffset(),
                LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountPhysicalRevenueOffset(), this.defaultDimension()),
                -_inventTrans.RevenueAmountPhysical - _inventTrans.TaxAmountPhysical);
        }
                
        if (_inventTrans.TaxAmountPhysical)
        {
            if (isCountryRegion_RU || _ledgerVoucher.parmDetailSummary() != DetailSummary::Summary)
            {
                LedgerVoucherTransObject ledgerVoucherTransObject = 
                    this.createLedgerVoucherTransObject(
                        _ledgerVoucherObject,
                        this.postingPhysicalTax(),
                        LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountPhysicalTax(), this.defaultDimension()),
                        standardCurrencyCode,
                        _inventTrans.TaxAmountPhysical,
                        _currencyExchHelper);

                _ledgerVoucher.addTrans(ledgerVoucherTransObject);
            }
            else
            {
                this.addLedgerPhysicalAmounts(this.postingPhysicalTax(),
                    LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountPhysicalTax(), this.defaultDimension()),
                    _inventTrans.TaxAmountPhysical);
            }
        }

        return vRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>performPhysicalAmountLedgerUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs physical amount ledger update.
    /// </summary>
    /// <param name = "_ledgerVoucher">A ledger voucher instance.</param>
    /// <param name = "_inventTrans">An inventory transaction.</param>
    /// <param name = "_updateNow">An inventory transaction update instance.</param>
    protected void performPhysicalAmountLedgerUpdate(
        LedgerVoucher _ledgerVoucher,
        InventTrans _inventTrans,
        InventUpdate _updateNow)
    {
        InventTransPosting inventTransPosting = _inventTrans.inventTransPostingPhysical();

        if (inventTransPosting.IsPosted)
        {
            _updateNow.updPhysicalAmountLedger(-_inventTrans.CostAmountPhysical + _updateNow.updPhysicalAmountLedger());

            LedgerVoucherObject ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
            CurrencyExchangeHelper currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());

            this.addLedgerVoucherTransactionAmountsForFinancialUpdate(
                    _ledgerVoucher,
                    _inventTrans,
                    ledgerVoucherObject,
                    currencyExchHelper,
                    inventTransPosting);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>performPhysicalRevenueAmountLedgerUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs physical revenue amount ledger update.
    /// </summary>
    /// <param name = "_ledgerVoucher">A ledger voucher instance.</param>
    /// <param name = "_inventTrans">An inventory transaction.</param>
    /// <param name = "_updateNow">An inventory transaction update instance.</param>
    private void performPhysicalRevenueAmountLedgerUpdate(
        LedgerVoucher _ledgerVoucher,
        InventTrans _inventTrans,
        InventUpdate _updateNow)
    {
        InventTransPosting inventTransPosting = _inventTrans.inventTransPostingPhysicalRevenue();
        if (inventTransPosting.IsPosted)
        {
            LedgerVoucherObject ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
            CurrencyExchangeHelper currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
            boolean isCountryRegion_RU = this.parmCompanyCountryRegion().isCountryRegionRU();

            if (!isCountryRegion_RU)
            {
                _updateNow.updPhysicalRevenueAmountLedger(-_inventTrans.RevenueAmountPhysical + _updateNow.updPhysicalRevenueAmountLedger());
            }


            currencyExchHelper.parmExchangeDate(inventTransPosting.TransDate);

            this.addLedgerVoucherRevenueTransactionAmountsForFinancialUpdate(
                _ledgerVoucher,
                _inventTrans,
                ledgerVoucherObject,
                currencyExchHelper,
                inventTransPosting);

            currencyExchHelper.parmExchangeDate(ledgerVoucherObject.parmAccountingDate());

        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>performFinancialPhysicalLedgerUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs financial ledger update.
    /// </summary>
    /// <param name = "_ledgerVoucher">A ledger voucher instance.</param>
    /// <param name = "_inventTrans">An inventory transaction.</param>
    /// <param name = "_updateNow">An inventory transaction update instance.</param>
    /// <param name = "_inventOnhand">An inventory on hand quantity.</param>
    /// <param name = "_inventTransUpd_RU">An inventory transaction update RU instance.</param>
    /// <returns>true if the ledger voucher correction has been changed; otherwise, false.</returns>
    protected boolean performFinancialPhysicalLedgerUpdate(
        LedgerVoucher _ledgerVoucher,
        InventTrans _inventTrans,
        InventUpdate _updateNow,
        InventOnhand _inventOnhand,
        InventTrans _inventTransUpd_RU)
    {
        if (_inventTrans.CostAmountPhysical && bookedPhysically != UnknownNoYes::No)
        {
            this.performPhysicalAmountLedgerUpdate(_ledgerVoucher, _inventTrans, _updateNow);
        }

        if (_inventTrans.RevenueAmountPhysical && bookedPhysicalRevenue != UnknownNoYes::No)
        {
            this.performPhysicalRevenueAmountLedgerUpdate(_ledgerVoucher, _inventTrans, _updateNow);
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>performFinancialLedgerUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs financial ledger update.
    /// </summary>
    /// <param name = "_ledgerVoucher">A ledger voucher instance.</param>
    /// <param name = "_inventTrans">An inventory transaction.</param>
    /// <param name = "_updateNow">An inventory transaction update instance.</param>
    /// <param name = "_inventOnhand">An inventory on hand quantity.</param>
    /// <param name = "_inventTransUpd_RU">An inventory transaction update RU instance.</param>
    /// <returns>true if the ledger voucher correction has been changed; otherwise, false.</returns>
    protected boolean performFinancialLedgerUpdate(
        LedgerVoucher _ledgerVoucher,
        InventTrans _inventTrans,
        InventUpdate _updateNow,
        InventOnhand _inventOnhand,
        InventTrans   _inventTransUpd_RU)
    {
        _updateNow.postingFinancial(true);
        return this.performFinancialPhysicalLedgerUpdate(_ledgerVoucher, _inventTrans, _updateNow, _inventOnhand, _inventTransUpd_RU);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventTransUpdStornoPhysicalForFinancialUpdate_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates storno flag on an inventory transaction update instance for the RU country region.
    /// </summary>
    /// <param name = "_inventTransUpd_RU">An inventory transaction update instance for the RU country region.</param>
    /// <param name = "_inventUpd_Physical">An instance used to update an inventory physically.</param>
    /// <param name = "_inventUpd_Financial">An instance used to update an inventory financially.</param>
    protected void updateInventTransUpdStornoPhysicalForFinancialUpdate_RU(InventTrans _inventTransUpd_RU, InventUpd_Physical _inventUpd_Physical, InventUpd_Financial _inventUpd_Financial)
    {
        if (_inventUpd_Physical && this.parmStornoPhysical_RU())
        {
            _inventTransUpd_RU.StornoPhysical_RU = NoYes::Yes;
        }
        else if (_inventUpd_Financial && this.parmStornoPhysical_RU()
                && (this.parmStornoPhysicalForced_RU() 
                    || (!(_inventTransUpd_RU.orig() 
                            && _inventTransUpd_RU.orig().isUpdatedPhysical() 
                            && _inventUpd_Financial.parmFinancial() * this.transSign() < 0
                            && _inventTransUpd_RU.PackingSlipId))))
        {
            _inventTransUpd_RU.StornoPhysical_RU = NoYes::Yes;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerVoucherCorrectionChangedForFinancialUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates whether correction is default for a ledger voucher for a financial ledger update.
    /// </summary>
    /// <param name = "_ledgerVoucher">A ledger voucher.</param>
    /// <param name = "_inventUpd_Physical">An instance used to do a physical inventory update.</param>
    /// <param name = "_inventUpd_Financial">An instance used to do a financial inventory update.</param>
    /// <returns>true if the parameter has been changed; otherwise, false.</returns>
    protected boolean updateLedgerVoucherCorrectionChangedForFinancialUpdate(LedgerVoucher _ledgerVoucher, InventUpd_Physical _inventUpd_Physical, InventUpd_Financial _inventUpd_Financial)
    {
        boolean ledgerVoucherCorrectionChanged = this.invertVoucherCorrectionChanged_RU(_ledgerVoucher);

        if (_inventUpd_Physical
            && ((_inventUpd_Physical.parmPhysical() * this.transSign() < 0) || this.parmStornoPhysicalForced_RU())
            && this.parmStornoPhysical_RU())
        {
            _ledgerVoucher.findLedgerVoucherObject().parmIsCorrectionDefault(! _ledgerVoucher.findLedgerVoucherObject().parmIsCorrectionDefault());
            ledgerVoucherCorrectionChanged = !ledgerVoucherCorrectionChanged;
        }
        else if (_inventUpd_Financial
            && ((_inventUpd_Financial.parmFinancial() * this.transSign() > 0) || this.parmStornoPhysicalForced_RU())
            && this.parmStornoPhysical_RU())
        {
            _ledgerVoucher.findLedgerVoucherObject().parmIsCorrectionDefault(! _ledgerVoucher.findLedgerVoucherObject().parmIsCorrectionDefault());
            ledgerVoucherCorrectionChanged = ! ledgerVoucherCorrectionChanged;
        }

        return ledgerVoucherCorrectionChanged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMainAccountValid</Name>
				<Source><![CDATA[
    private void checkMainAccountValid(InventTransPosting _inventTransPosting, LedgerVoucher _ledgerVoucher)
    {
        LedgerDimensionAccount offsetLedgerDimensionAccount = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(_inventTransPosting.OffsetLedgerDimension);
        DimensionAttributeValueCombination dimensionAttributeValueCombination = DimensionAttributeValueCombination::find(offsetLedgerDimensionAccount);
        if (!DimensionHierarchy::getAccountStructure(dimensionAttributeValueCombination.MainAccount))
        {
            DimensionHierarchy dimensionHierarchy = DimensionHierarchy::find(dimensionAttributeValueCombination.AccountStructure);
            MainAccount mainAccount = MainAccount::find(dimensionAttributeValueCombination.MainAccount);
                
            warning(strFmt("@SCM:CheckMainAccountErrorMessage", dimensionHierarchy.Name, mainAccount.MainAccountId, "", _ledgerVoucher.lastTransDate()) + ' ' + "@SCM:HardeningPeriodEndProcessTempWarningMessage");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerVoucherTransactionAmountsForFinancialUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds transaction amounts to be posted for a financial update.
    /// </summary>
    /// <param name = "_ledgerVoucher">A ledger voucher.</param>
    /// <param name = "_inventTrans">An inventory transaction.</param>
    /// <param name = "_ledgerVoucherObject">A ledger voucher object.</param>
    /// <param name = "_currencyExchHelper">A currency exchange helper.</param>
    /// <param name = "_inventTransPosting">An inventory transaction posting.</param>
    protected void addLedgerVoucherTransactionAmountsForFinancialUpdate(
        LedgerVoucher _ledgerVoucher,
        InventTrans _inventTrans,
        LedgerVoucherObject _ledgerVoucherObject,
        CurrencyExchangeHelper _currencyExchHelper,
        InventTransPosting _inventTransPosting)
    {
        CurrencyCode standardCurrencyCode = CompanyInfoHelper::standardCurrency();
        LedgerDimensionAccount ledgerDimension = this.getSyncdLedgerDimension(_inventTransPosting.LedgerDimension);

        if (!ledgerDimension && _ledgerVoucher.parmCheckTransOnInsert())
        {
            this.checkMainAccountValid(_inventTransPosting, _ledgerVoucher);
        }

        LedgerVoucherTransObject ledgerVoucherTransObject =
            this.createLedgerVoucherTransObjectForFinancialUpdate(
                _ledgerVoucherObject,
                _inventTransPosting.PostingType,
                ledgerDimension,
                standardCurrencyCode,
                -_inventTrans.CostAmountPhysical,
                _currencyExchHelper,
                _inventTrans);

        // When relieving physical inventory the accounts are not validated because
        // the amounts need to be relieved from the original accounts
        ledgerVoucherTransObject.parmSkipDimensionValidation(true);

        ledgerVoucherTransObject.parmProjLedger(this.createProjLedgerForAddLedgerVoucherTransaction(_ledgerVoucher, _inventTrans, _ledgerVoucherObject, _currencyExchHelper));

        if (LedgerParameters::isStornoEnabledEE() && _inventTrans.PackingSlipId)
        {
            ledgerVoucherTransObject.parmIsCorrection(true);
        }

        _ledgerVoucher.addTrans(ledgerVoucherTransObject);

        LedgerDimensionAccount offsetLedgerDimension = this.getSyncdLedgerDimension(_inventTransPosting.OffsetLedgerDimension);

        if (!offsetLedgerDimension && _ledgerVoucher.parmCheckTransOnInsert())
        {
            this.checkMainAccountValid(_inventTransPosting, _ledgerVoucher);
        }

        ledgerVoucherTransObject =
            this.createLedgerVoucherTransObjectForFinancialUpdate(
                _ledgerVoucherObject,
                _inventTransPosting.PostingTypeOffset,
                offsetLedgerDimension,
                standardCurrencyCode,
                _inventTrans.CostAmountPhysical,
                _currencyExchHelper,
                _inventTrans);

        // When relieving physical inventory the accounts are not validated because
        // the amounts need to be relieved from the original accounts
        ledgerVoucherTransObject.parmSkipDimensionValidation(true);

        ledgerVoucherTransObject.parmProjLedger(this.createProjLedgerForAddLedgerVoucherTransaction(_ledgerVoucher, _inventTrans, _ledgerVoucherObject, _currencyExchHelper, ProjItemTransCostType::Accrued));

        if (LedgerParameters::isStornoEnabledEE() && _inventTrans.PackingSlipId)
        {
            ledgerVoucherTransObject.parmIsCorrection(true);
        }

        _ledgerVoucher.addTrans(ledgerVoucherTransObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSyncdLedgerDimension</Name>
				<Source><![CDATA[
    private LedgerDimensionAccount getSyncdLedgerDimension(LedgerDimensionAccount  _ledgerDimension = 0)
    {
        // When the hierarchy is not associated with the ledger anymore, then create a new ledger dimension.
        LedgerDimensionAccount ledgerDimensionAccount = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(_ledgerDimension);
        DimensionDefault dimensionDefault = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_ledgerDimension);
        LedgerDimensionBase newLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionAccount, dimensionDefault);

        return newLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerVoucherRevenueTransactionAmountsForFinancialUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds transaction revenue amounts to be posted for a financial update.
    /// </summary>
    /// <param name = "_ledgerVoucher">A ledger voucher.</param>
    /// <param name = "_inventTrans">An inventory transaction.</param>
    /// <param name = "_ledgerVoucherObject">A ledger voucher object.</param>
    /// <param name = "_currencyExchangeHelper">A currency exchange helper.</param>
    /// <param name = "_inventTransPosting">An inventory transaction posting.</param>
    /// <returns>A ledger bond ID for the country region RU.</returns>
    protected LedgerBondId_RU addLedgerVoucherRevenueTransactionAmountsForFinancialUpdate(
        LedgerVoucher _ledgerVoucher,
        InventTrans _inventTrans,
        LedgerVoucherObject _ledgerVoucherObject,
        CurrencyExchangeHelper _currencyExchangeHelper,
        InventTransPosting _inventTransPosting)
    {
        CurrencyCode             standardCurrencyCode       = CompanyInfoHelper::standardCurrency();
        boolean                  isCountryRegion_RU         = this.parmCompanyCountryRegion().isCountryRegionRU();
        
        LedgerCorrection         defaultVoucherCorrection;

        if (LedgerParameters::isStornoEnabledEE() && _inventTrans.PackingSlipId)
        {
            defaultVoucherCorrection = _ledgerVoucherObject.parmIsCorrectionDefault();
            _ledgerVoucherObject.parmIsCorrectionDefault(true);
        }

        LedgerVoucherTransObject ledgerVoucherTransObject = 
            this.createLedgerVoucherTransObjectForFinancialUpdate(
                _ledgerVoucherObject,
                _inventTransPosting.PostingType,
                _inventTransPosting.LedgerDimension,
                standardCurrencyCode,
                -_inventTrans.RevenueAmountPhysical,
                _currencyExchangeHelper,
                _inventTrans);

        ledgerVoucherTransObject.parmSkipDimensionValidation(true);
        _ledgerVoucher.addTrans(ledgerVoucherTransObject);

        LedgerBondId_RU vRefId;
        if (isCountryRegion_RU)
        {
            LedgerBondClient_RU ledgerBondClient = _ledgerVoucherObject.ledgerBondClient_RU();
            vRefId = ledgerBondClient ? ledgerBondClient.lastVrefId(): 0;
        }

        ledgerVoucherTransObject = 
            this.createLedgerVoucherTransObjectForFinancialUpdate(
                _ledgerVoucherObject,
                _inventTransPosting.PostingTypeOffset,
                _inventTransPosting.OffsetLedgerDimension,
                standardCurrencyCode,
                _inventTrans.RevenueAmountPhysical + _inventTrans.TaxAmountPhysical,
                _currencyExchangeHelper,
                _inventTrans);

        ledgerVoucherTransObject.parmSkipDimensionValidation(true);
        _ledgerVoucher.addTrans(ledgerVoucherTransObject);

        if (// <GTE>
            ( !this.taxEngineInventMovement().taxDocument() || !TaxSolutionScopeIntegrationUtil::isCompanyEnabled()) &&
            // </GTE>
            _inventTrans.TaxAmountPhysical)
        {
            ledgerVoucherTransObject = 
                this.createLedgerVoucherTransObjectForFinancialUpdate(
                    _ledgerVoucherObject,
                    this.postingPhysicalTax(),
                    LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountPhysicalTax(), _inventTransPosting.DefaultDimension),
                    standardCurrencyCode,
                    -_inventTrans.TaxAmountPhysical,
                    _currencyExchangeHelper,
                    _inventTrans);
            _ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }

        if (LedgerParameters::isStornoEnabledEE() && _inventTrans.PackingSlipId)
        {
            _ledgerVoucherObject.parmIsCorrectionDefault(defaultVoucherCorrection);
        }

        return vRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjLedgerForAddLedgerVoucherTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>ProjLedger</c> instance for the addLedgerVoucherTransactionAmountsFor methods.
    /// </summary>
    /// <param name = "_ledgerVoucher">A ledger voucher.</param>
    /// <param name = "_inventTrans">An inventory transaction.</param>
    /// <param name = "_ledgerVoucherObject">A ledger voucher object.</param>
    /// <param name = "_currencyExchHelper">A currency exchange helper.</param>
    /// <param name = "_projItemTransCostType">A <c>ProjItemTransCostType</c> enumeration value.</param>
    /// <returns>
    /// A new <c>ProjLedger</c> instance.
    /// </returns>
    protected ProjLedger createProjLedgerForAddLedgerVoucherTransaction(
        LedgerVoucher _ledgerVoucher,
        InventTrans _inventTrans,
        LedgerVoucherObject _ledgerVoucherObject,
        CurrencyExchangeHelper _currencyExchHelper,
        ProjItemTransCostType _projItemTransCostType = ProjItemTransCostType::Cost)
    {
        InventTransOrigin inventTransOrigin = _inventTrans.inventTransOrigin();

        ProjLedger projLedger = ProjLedger::newInventCost(
            _inventTrans.ProjId,
            _inventTrans.ActivityNumber,
            _inventTrans.ProjCategoryId,
            inventTransOrigin.InventTransId,
            _inventTrans.ProjAdjustRefId,
            this.projTransactionOrigin(),
            this.projLedgerOrigin(),
            inventTransOrigin.ItemId,
            true,
            dateNull(),
            _projItemTransCostType);

        return projLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePeggingRequirements</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the pegging requirements of the inventory movement.
    /// </summary>
    /// <remarks>
    ///    This method is intended to be inherited. It supports implementing the setting "Register as empty"
    ///    of a kanban rule set to "When the source of demand is registered".
    /// </remarks>
    public void updatePeggingRequirements()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReqExplodeReservation</Name>
				<Source><![CDATA[
    public boolean updateReqExplodeReservation()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReservation</Name>
				<Source><![CDATA[
    public void updateReservation()
    {
        ttsbegin;

        using (var cache = this.constructRecordViewCache())
        {
            if (this.mustUpdateReservation())
            {
                InventUpd_Reservation::newMovement(this, this.transIdSum().onOrder(), true, false, false, this.transIdSum().pdsCWOnOrder()).updateNow();
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies if the reservation update is necessary. 
    /// </summary>
    /// <returns>true, if the reservation update is necessary; otherwise, false.</returns>
    protected boolean mustUpdateReservation()
    {
        return this.transIdSum().onOrder() != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSerialNumIssue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Verifies if a particular issue inventory transaction update can be done for a particular serial number, and creates a serial number if necessary.
    /// </summary>
    /// <param name="_inventTrans">
    ///     Current <c>InventTrans</c> record.
    /// </param>
    /// <param name="_inventTrans_orig">
    ///     Original DB <c>InventTrans</c> record.
    /// </param>
    /// <param name="_inventDim">
    ///     Current <c>InventDim</c> record linked to the _inventTrans record.
    /// </param>
    /// <remarks>
    ///     FS Pds CW: if item is a catch weight item and the <c>InventDim</c> record has a serial number, added CW quantity check if greater then negative one(-1).
    /// </remarks>
    /// <exception cref="Exception::Error">
    ///     Throw error if different than -1 in either quantity or CW quantity fields.
    /// </exception>
    /// <exception cref="Exception::Error">
    ///     Throw error if dimAllowBlankReceipt not enabled.
    /// </exception>
    /// <exception cref="Exception::Error">
    ///     Throw error if dimAllowBlankReceipt not enabled.
    /// </exception>
    public void updateSerialNumIssue(
        InventTrans     _inventTrans,
        InventTrans     _inventTrans_orig,
        InventDim       _inventDim = InventDim::find(_inventTrans.InventDimId))
    {
        if (this.needUpdateSerialNumIssue(_inventTrans, _inventTrans_orig, _inventDim))
        {
            this.doUpdateSerialNumIssue(_inventTrans, _inventTrans_orig, _inventDim);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>needUpdateSerialNumIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if verification of a particular issue inventory transaction update should be done for a particular serial number.
    /// </summary>
    /// <param name="_inventTrans">
    ///     Current <c>InventTrans</c> record.
    /// </param>
    /// <param name="_inventTrans_orig">
    ///     Original DB <c>InventTrans</c> record.
    /// </param>
    /// <param name="_inventDim">
    ///     Current <c>InventDim</c> record linked to the _inventTrans record.
    /// </param>
    /// <returns>true if verification should be done; false, otherwise.</returns>
    protected boolean needUpdateSerialNumIssue(
        InventTrans     _inventTrans,
        InventTrans     _inventTrans_orig,
        InventDim       _inventDim)
    {
        boolean doUpdate = (_inventTrans.StatusIssue    == StatusIssue::Sold     && ! _inventTrans_orig) ||
                           (_inventTrans.StatusIssue    == StatusIssue::Deducted && (! _inventTrans_orig || _inventTrans_orig.StatusIssue != StatusIssue::Picked)) ||
                           (_inventTrans.StatusIssue    == StatusIssue::Picked);

        doUpdate = doUpdate && this.persistSerialNumber();

        return doUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>persistSerialNumber</Name>
				<Source><![CDATA[
    private boolean persistSerialNumber()
    {
        InventDimGroupFieldSetup inventDimGroupFieldSetup = this.inventDimGroupSetup().getFieldSetup(fieldNum(InventDim, InventSerialId));
        return inventDimGroupFieldSetup.isActive() && (inventDimGroupFieldSetup.isSerialNumberControlEnabled() || this.forcePersistSerialNumber());
    }

]]></Source>
			</Method>
			<Method>
				<Name>forcePersistSerialNumber</Name>
				<Source><![CDATA[
    protected boolean forcePersistSerialNumber()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doUpdateSerialNumIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a verification that a particular issue inventory transaction update can be done for a particular serial number, and creates a serial number if necessary.
    /// </summary>
    /// <param name="_inventTrans">
    ///     Current <c>InventTrans</c> record.
    /// </param>
    /// <param name="_inventTrans_orig">
    ///     Original DB <c>InventTrans</c> record.
    /// </param>
    /// <param name="_inventDim">
    ///     Current <c>InventDim</c> record linked to the _inventTrans record.
    /// </param>
    protected void doUpdateSerialNumIssue(
        InventTrans     _inventTrans,
        InventTrans     _inventTrans_orig,
        InventDim       _inventDim)
    {
        InventDimGroupFieldSetup inventDimGroupFieldSetup = this.inventDimGroupSetup().getFieldSetup(fieldNum(InventDim, InventSerialId));

        if (_inventDim.InventSerialId)
        {
            boolean cwItem = PdsGlobal::pdsIsCWItem(_inventTrans.ItemId);

            if (!this.isRetailSalesOrder() && ((!cwItem && (_inventTrans.Qty != -1))
                ||  ( cwItem
                        && (_inventTrans.PdsCWQty != -1) 
                        && (!this.isCWWeightAdjustment(_inventTrans, cwItem))
                        && (!this.pdsIgnoreSerNumCtrlValidation()))))
            {
                throw error(strFmt("@SYS68712",_inventDim.InventSerialId));
            }

            if (! InventSerial::exist(_inventDim.InventSerialId, this.itemId()))
            {
                if (inventDimGroupFieldSetup.isAllowBlankReceiptEnabled())
                {
                    InventSerial inventSerial;
                    inventSerial.initFromInventMovement(this,_inventTrans);
                    inventSerial.InventSerialId = _inventDim.InventSerialId;
                    inventSerial.insert();
                }
                else
                {
                    throw error(strFmt("@SYS68707",_inventDim.InventSerialId,this.itemId()));
                }
            }
        }
        else if (!inventDimGroupFieldSetup.isAllowBlankIssueEnabled())
        {
            throw error(strFmt("@SYS53724",fieldId2pname(_inventDim.TableId, inventDimGroupFieldSetup.dimFieldId())));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSerialNumReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Verifies if a particular receipt inventory transaction update can be done for a particular serial number, and creates a serial number if necessary.
    /// </summary>
    /// <param name="_inventTrans">
    ///     Current <c>InventTrans</c> record.
    /// </param>
    /// <param name="_inventTrans_orig">
    ///     Original DB <c>InventTrans</c> record.
    /// </param>
    /// <param name="_inventDim">
    ///     Current <c>InventDim</c> record linked to the <c>_inventTrans</c> record.
    /// </param>
    /// <remarks>
    ///     If item is a catch weight item and the <c>InventDim</c> record has a serial number, added CW quantity check if greater than one(1).
    /// </remarks>
    /// <exception cref="Exception::Error">
    ///     Throw error if different than 1 in either quantity or CW quantity fields. 0 is allowed if this is CW a weight adjustment movement.
    /// </exception>
    /// <exception cref="Exception::Error">
    ///     Throw error if dimAllowBlankReceipt not enabled.
    /// </exception>
    /// <exception cref="Exception::Error">
    ///     Throw error if dimAllowBlankReceipt not enabled.
    /// </exception>
    public void updateSerialNumReceipt(
        InventTrans     _inventTrans,
        InventTrans     _inventTrans_orig,
        InventDim       _inventDim = InventDim::find(_inventTrans.InventDimId))
    {
        if (this.needUpdateSerialNumReceipt(_inventTrans, _inventTrans_orig, _inventDim))
        {
            this.doUpdateSerialNumReceipt(_inventTrans, _inventTrans_orig, _inventDim);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>needUpdateSerialNumReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if verification of a particular receipt inventory transaction update should be done for a particular serial number.
    /// </summary>
    /// <param name="_inventTrans">
    ///     Current <c>InventTrans</c> record.
    /// </param>
    /// <param name="_inventTrans_orig">
    ///     Original DB <c>InventTrans</c> record.
    /// </param>
    /// <param name="_inventDim">
    ///     Current <c>InventDim</c> record linked to the <c>_inventTrans</c> record.
    /// </param>
    /// <returns>true if verification of a particular receipt inventory transaction update should be done; false, otherwise.</returns>
    protected boolean needUpdateSerialNumReceipt(
        InventTrans     _inventTrans,
        InventTrans     _inventTrans_orig,
        InventDim       _inventDim)
    {
        boolean doUpdate = false;

        if (_inventTrans.StatusIssue      >  StatusIssue::Picked    &&
            _inventTrans_orig                                       &&
            _inventTrans_orig.StatusIssue == StatusIssue::Picked)
        {
            doUpdate    = true;
            _inventDim  = InventDim::find(_inventTrans_orig.InventDimId);
        }
        else 
        if ((  _inventTrans.StatusReceipt        == StatusReceipt::Purchased         ||
               _inventTrans.StatusReceipt        == StatusReceipt::Received          ||
               _inventTrans.StatusReceipt        == StatusReceipt::Registered        ||
             ( _inventTrans.StatusReceipt        == StatusReceipt::Arrived           &&  _inventDim.InventSerialId)) &&
             (!_inventTrans_orig                                                     ||
               _inventTrans_orig.StatusReceipt   == StatusReceipt::Ordered           ||
               _inventTrans_orig.StatusReceipt   == StatusReceipt::QuotationReceipt  ||
             ( _inventTrans_orig.StatusReceipt   == StatusReceipt::Arrived           && ! InventDim::find(_inventTrans_orig.InventDimId).InventSerialId)))
        {
            doUpdate = true;
        }

        doUpdate = doUpdate && this.persistSerialNumber();

        return doUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doUpdateSerialNumReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a verification that a particular receipt inventory transaction update can be done for a particular serial number, and creates a serial number if necessary.
    /// </summary>
    /// <param name="_inventTrans">
    ///     Current <c>InventTrans</c> record.
    /// </param>
    /// <param name="_inventTrans_orig">
    ///     Original DB <c>InventTrans</c> record.
    /// </param>
    /// <param name="_inventDim">
    ///     Current <c>InventDim</c> record linked to the <c>_inventTrans</c> record.
    /// </param>
    protected void doUpdateSerialNumReceipt(
        InventTrans     _inventTrans,
        InventTrans     _inventTrans_orig,
        InventDim       _inventDim)
    {
        InventDimGroupFieldSetup inventDimGroupFieldSetup = this.inventDimGroupSetup().getFieldSetup(fieldNum(InventDim,InventSerialId));

        if (_inventDim.InventSerialId)
        {
            if (!this.checkSerialNumReceiptQuantity(_inventTrans, _inventDim))
            {
                throw error(strFmt("@SYS68712",_inventDim.InventSerialId));
            }

            if (! InventSerial::exist(_inventDim.InventSerialId, this.itemId()))
            {
                InventSerial inventSerial;
                inventSerial.initFromInventMovement(this,_inventTrans);
                inventSerial.InventSerialId = _inventDim.InventSerialId;
                inventSerial.insert();
            }
            else if (!this.checkSerialNum(_inventTrans,_inventDim.InventSerialId))
            {
                throw error("@SYS319214");
            }
        }
        else if (!inventDimGroupFieldSetup.isAllowBlankReceiptEnabled() && _inventTrans.Qty > 0)
        {
            throw error(strFmt("@SYS53724",fieldId2pname(_inventDim.TableId, inventDimGroupFieldSetup.dimFieldId())));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>useEnteredPriceAsCost</Name>
				<Source><![CDATA[
    public boolean useEnteredPriceAsCost()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructRecordViewCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new instance of <c>RecordViewCache</c> class for the <c>InventTrans</c> table.
    /// </summary>
    /// <returns>A new instance of <c>RecordViewCache</c> class.</returns>
    /// <remarks>Instance of the <c>RecordViewCache</c> must be disposed, e.g. by wrapping it in the "using" statement.</remarks>
    public RecordViewCache constructRecordViewCache()
    {
        return new RecordViewCache(InventTrans::viewCacheBufferFromInventTransOriginId(this.inventTransOriginId(), true));
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsMustConsiderBatchProcessing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if special batch processing must be used during reservation.
    /// </summary>
    /// <returns>
    /// true, if the item utilizes special batch processing during reservation; otherwise, false.
    /// </returns>
    public boolean whsMustConsiderBatchProcessing()
    {
        if (mustConsiderBatchProcessing == UnknownNoYes::Unknown)
        {
            // Must be batch active item.
            boolean tmpRet = this.inventDimGroupSetup().isDimensionActive(fieldNum(InventDim, InventBatchId));

            // Must be batch above location in the hierarchy.
            tmpRet = tmpRet && WHSReservationHierarchyInventDimUtil::isBatchAboveLocation(this.inventTable());

            // If item uses PI batch processing such as FEFO, batch disposition, or batch attributes then we must use special batch processing.
            tmpRet = tmpRet
            && (this.inventTable().pdsCheck()
            || this.pdsConsiderRestrictReservation()
            || (#PDSBatchAttribEnabled && this.pdsMustConsiderBatchAttrib()));

            mustConsiderBatchProcessing = tmpRet ? UnknownNoYes::Yes : UnknownNoYes::No;
        }

        return  mustConsiderBatchProcessing == UnknownNoYes::Yes ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsUpdateAutoDimStatusId</Name>
				<Source><![CDATA[
    /// <summary>
    /// For WHS controlled items with inventory status not set
    /// updates it with default value and returns true, otherwise returns false.
    /// </summary>
    /// <returns>
    /// true, if inventory status of the WHS controlled item has been updated with default value;
    /// otherwise, false.
    /// </returns>
    public boolean whsUpdateAutoDimStatusId()
    {
        boolean             ret;

        InventDim inventDimStatus = this.inventdim();

        // Only for WHS controlled items
        if (this.isItemWHSEnabled()
        &&  inventDimStatus.InventLocationId
        &&  !this.isVirtuel())
        {
            if (!inventDimStatus.InventStatusId)
            {
                inventDimStatus.InventStatusId = WHSInvent::getDefaultStatus(inventDimStatus, this);
                this.inventdim(inventDimStatus);
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsShouldRemoveReservationOnReservePhysicalTransIssue</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean whsShouldRemoveReservationOnReservePhysicalTransIssue()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsShouldRemoveReservationOnReservePhysicalTransReceipt</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean whsShouldRemoveReservationOnReservePhysicalTransReceipt()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wmsShipmentGroupingRefId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the grouping reference ID to be used with output orders.
    /// </summary>
    /// <returns>
    ///    The grouping reference ID.
    /// </returns>
    public WMSShipmentGroupingRefId wmsShipmentGroupingRefId()
    {
        return this.transRefId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>wmsShipmentGroupingTransType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the grouping transaction type to be used with output orders.
    /// </summary>
    /// <returns>
    ///    The grouping transaction type.
    /// </returns>
    public WMSShipmentGroupingTransType wmsShipmentGroupingTransType()
    {
        return this.transType();
    }

]]></Source>
			</Method>
			<Method>
				<Name>bufferSetRemainQty</Name>
				<Source><![CDATA[
    public static void bufferSetRemainQty(
        Common              _buffer,
        InventMovSubType    _subType = InventMovSubType::None)
    {
        InventMovement  movement        = InventMovement::construct(_buffer,_subType);
        InventMovement  movement_Orig   = InventMovement::construct(_buffer.orig(),_subType);
        // <GIN>
        InventTransferLine  inventTransferLine;
        // </GIN>

        if (movement.mustBeRemainControlled())
        {
            // <GIN>
            if (_buffer.TableId ==  tableNum(InventTransferLine))
            {
                inventTransferLine = _buffer;
            }
            if (inventTransferLine.RecId
                && inventTransferLine.checkForUnitID_IN()
                && (movement_Orig is InventMov_TransferFrom
                    || movement_Orig is InventMov_TransferTo
                    || movement_Orig is InventMov_TransferTransitTo
                    || movement_Orig is InventMov_TransferTransitFrom))
            {
                InventMov_Transfer inventMov_TransferSTO = movement_Orig;
                if (movement_Orig is InventMov_TransferFrom)
                {
                    movement.setRemainPhysical(inventMov_TransferSTO.getQtyRemainShip());
                }
                else
                {
                    movement.setRemainPhysical(inventMov_TransferSTO.getQtyRemainReceive());
                }
                movement.addRemainPhysical(movement.transQty() - movement_Orig.transQty());
            }
            else
            {
                // </GIN>
                movement.updateRemainPhysicalFromBuffer(movement_Orig);
                // <GIN>
            }
            // </GIN>
            movement.pdsCWSetRemainPhysical(movement_Orig.pdsCWRemainPhysical());
            movement.pdsCWAddRemainPhysical(movement.pdsCWTransQty() - movement_Orig.pdsCWTransQty());

            if (movement.mustBeUnitControlled())
            {
                movement.updateRemainPhysicalUnitFromBuffer(movement_Orig);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRemainPhysicalFromBuffer</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void updateRemainPhysicalFromBuffer(InventMovement _movement_Orig)
    {
        this.setRemainPhysical(_movement_Orig.remainPhysical());
        this.addRemainPhysical(this.transQty() - _movement_Orig.transQty());
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRemainPhysicalUnitFromBuffer</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void updateRemainPhysicalUnitFromBuffer(InventMovement _movement_Orig)
    {
        this.setRemainPhysicalUnit(_movement_Orig.remainPhysicalUnit());
        this.addRemainPhysicalUnit(this.transQtyUnit() - _movement_Orig.transQtyUnit());
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteInventTransOriginAndReferences</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the inventory transaction originator and related relationship references.
    /// </summary>
    [Hookable(false)]
    internal void deleteInventTransOriginAndReferences()
    {        
        InventTransOriginId inventTransOriginIdToDelete = this.inventTransOriginId();

        if (inventTransOriginIdToDelete)
        {
            this.deleteOriginOwnerRelationship();
            InventTransOrigin::find(inventTransOriginIdToDelete, true).delete(NoYes::No); // transactions are already deleted at this point, so no need to try to delete them
            this.inventTransOriginId(nullValue(inventTransOriginIdToDelete));             // reset the InventTransOriginId since the origin has been deleted
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>bufferSetTransQty</Name>
				<Source><![CDATA[
    public static void bufferSetTransQty(Common _buffer)
    {
        InventMovement  movement        = InventMovement::construct(_buffer);

        movement.setTransQty(decRound(movement.transQty(), InventTable::inventDecimals(movement.itemId())));
    }

]]></Source>
			</Method>
			<Method>
				<Name>bufferSetTransQtyUnit</Name>
				<Source><![CDATA[
    public static void bufferSetTransQtyUnit(Common  _buffer)
    {
        InventMovement          movement            = InventMovement::construct(_buffer);
        InventTable             inventTable         = movement.inventTable();
        UnitOfMeasureSymbol     fromUnitSymbol      = movement.transUnitId();
        UnitOfMeasureSymbol     toUnitSymbol        = inventTable.inventUnitId();
        UnitQty                 qty                 = movement.transQtyUnit();

        if (fromUnitSymbol && toUnitSymbol && fromUnitSymbol != toUnitSymbol)
        {
            InventDim inventDim = movement.inventdim();
            if (EcoResProductUnitConverter::hasRequiredProductDimensionsForUnitConversion(inventTable.ItemId, inventDim))
            {
                qty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(
                            inventTable.ItemId,
                            inventDim.InventDimId,
                            qty,
                            fromUnitSymbol,
                            toUnitSymbol,
                            NoYes::Yes);
            }
        }

        qty   = decRound(qty,InventTable::inventDecimals(movement.itemId()));
        movement.setTransQty(qty);

        if (fromUnitSymbol)
        {
            UnitOfMeasureRecId fromUnitOfMeasure = UnitOfMeasure::unitOfMeasureIdBySymbol(fromUnitSymbol);

            if (!fromUnitOfMeasure)
            {
                fromUnitOfMeasure = UnitOfMeasure::unitOfMeasureIdBySymbol(fromUnitSymbol);
            }
            qty   = decRound(movement.transQtyUnit(),UnitOfMeasure::unitOfMeasureDecimalPrecision(fromUnitOfMeasure));
        }
        movement.setTransQtyUnit(qty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAutoReserveQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicate whether it is possible to auto-reserve an inventory movement.
    /// </summary>
    /// <param name="_buffer">
    ///    A record buffer from which an inventory movement can be extracted.
    /// </param>
    /// <param name="_showWarning">
    /// The Boolean which indicates should the warning message be shown if the reservation is not possible.
    /// </param>
    /// <returns>
    ///    true if the auto-reservation can proceed for the specified movement; otherwise, false.
    /// </returns>
    public static boolean canAutoReserveQuantity(Common _buffer, boolean _showWarning = false)
    {
        PdsCWInventQty                  cwAvailReservation;
        InventQty                       availReservation;

        InventMovement movement = InventMovement::construct(_buffer);
        movement.initForAutoReservation();
        InventMovement movement_Orig = InventMovement::construct(_buffer.orig());

        InventQty reserveNow = movement.autoReserveQty(movement_Orig);
        PdsCWInventQty cwReserveNow = movement.pdsCWAutoReserveQty(movement_Orig);
        if (reserveNow <= 0 && cwReserveNow <= 0)
        {
            return true;
        }

        [availReservation, cwAvailReservation] = InventMovement::qtyAvailbleForReservation(movement);

        // For CW items check only cwAvailReservation and ignore check on availReservation, for non-CW items do the opposite.
        if ((cwReserveNow && cwReserveNow <= cwAvailReservation)
            || ((cwReserveNow == 0) && (reserveNow <= availReservation)))
        {
            return true;
        }

        // Items that are both WHS and CW enabled don't need to validate available weight.
        if (cwReserveNow == 0 && movement.isItemWHSEnabled() && movement.pdsCWItem())
        {
            return true;
        }

        if (_showWarning)
        {
            if (cwReserveNow)
            {
                warning(strFmt("@PDS90", cwReserveNow, cwAvailReservation));
            }
            else
            {
                warning(strFmt("@SYS54812", reserveNow, availReservation));
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyAvailbleForReservation</Name>
				<Source><![CDATA[
    /// <summary>
    ///      Gets on hand quantities available for reservation.
    /// </summary>
    /// <param name = "_movement">
    ///     The <c>InventMovement</c> instance.
    /// </param>
    /// <returns>
    ///     A container with quantities in inventory unit and catch weight unit.
    /// </returns>
    [Replaceable]
    protected static container qtyAvailbleForReservation(InventMovement _movement)
    {
        InventOnHandCompositeCriteria   inventOnHandCompositeCriteria = InventReservationCriteriaBuilder::newMovement(_movement).buildCriteria();
        InventDim                       inventDimMovement;

        inventDimMovement.data(_movement.inventdim());
        return InventOnHandQty::availReservationDimensions(
                                    _movement.itemId(),
                                    [inventDimMovement],
                                    InventParameters::find().ReserveOnOrdered,
                                    _movement.isTransfer(),
                                    null,
                                    null,
                                    inventOnHandCompositeCriteria);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static InventMovement construct(
        Common              _buffer,
        InventMovSubType    _subType        = InventMovSubType::None,
        Common              _childBuffer    = null)
    {
        InventMovement movement = InventMovement::constructNoThrow(_buffer, _subType, _childBuffer);
        if (!movement)
        {
            throw error("@SYS20765");
        }
        return movement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructFromArgs</Name>
				<Source><![CDATA[
    public static InventMovement constructFromArgs(Args _args)
    {
        return InventMovement::constructNoThrow(_args.record());
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructFromAttribute</Name>
				<Source><![CDATA[
    private static InventMovement constructFromAttribute(anytype _argument, InventMovementFactoryAttribute _attribute)
    {
        return SysExtensionAppClassFactory::getClassFromSysAttributeWithInstantiationStrategy(
            classStr(InventMovement),
            _attribute,
            InventMovementInstantiation::construct(_argument)) as InventMovement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructNoThrow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates <c>InventMovement</c> for the supplied buffer, without throwing an error.
    /// </summary>
    /// <param name="_buffer">
    /// buffer for which inventory movement should be constructed
    /// </param>
    /// <param name="_subType">
    /// Movement subtype; defaults to None
    /// </param>
    /// <param name="_childBuffer">
    /// child buffer for creating the inventory movement.
    /// </param>
    /// <returns>
    /// <c>InventMovement</c> created from the input buffer
    /// </returns>
    /// <remarks>
    /// Returns null if the Inventory movement could not be constructed.
    /// </remarks>
    public static InventMovement constructNoThrow(
        Common              _buffer,
        InventMovSubType    _subType            = InventMovSubType::None,
        Common              _childBuffer        = null)
    {
        InventMovement                  movement;
        ProdJournalBOM                  prodJournalBOM;
        ProdJournalProd                 prodJournalProd;

        Common                          buffer;
        PmfProdCoBy                     pmfProdCoBy;
        // <GEERU>
        // </GEERU>

        switch (_childBuffer.TableId)
        {
            case tableNum(ProdJournalBOM):
                prodJournalBOM  = _childBuffer as ProdJournalBOM;
                movement = prodJournalBOM.inventMovementChild(_buffer);
                if (movement)
                {
                    return movement;
                }
                break;
            case tableNum(ProdJournalProd):
                prodJournalProd  = _childBuffer as ProdJournalProd;
                movement = prodJournalProd.inventMovementChild(_buffer);

                if (movement)
                {
                    return movement;
                }
                break;            
        }

        switch (_buffer.TableId)
        {
            case tableNum(PurchLine):
                return InventMov_Purch::newFromPurchLine(_buffer as PurchLine);
            case tableNum(ProdTable):
                return InventMov_Prod::newFromProdTable(_buffer as ProdTable);
            case tableNum(ProdJournalProd):
                prodJournalProd  = _buffer as ProdJournalProd;

                if (prodJournalProd.PmfProductType == PmfProductType::Co_Product ||
                    prodJournalProd.PmfProductType == PmfProductType::By_Product)
                {
                    buffer = prodJournalProd.pmfProdCoBy(true);
                    if (!buffer.RecId)
                    {
                        pmfProdCoBy.initFromProdJournalProd(prodJournalProd);
                        buffer = pmfProdCoBy;
                    }
                }
                else
                {
                    buffer = prodJournalProd.prodTable(true);
                }
                movement = prodJournalProd.inventMovementChild(buffer);

                if (movement)
                {
                    return movement;
                }
                return InventMov_Prod::newFromProdTable(prodJournalProd.prodTable(true));
            case tableNum(ProdJournalBOM):
                prodJournalBOM  = _buffer as ProdJournalBOM;
                movement = prodJournalBOM.inventMovementChild(prodJournalBOM.prodBOM(true));
                if (movement)
                {
                    return movement;
                }
                return InventMov_ProdLine::newFromProdBOM(prodJournalBOM.prodBOM(true));
            case tableNum(ProdBOMTransProj):
                ProdBOMTransProj prodBOMTransProj = _buffer as ProdBOMTransProj;
                movement = prodBOMTransProj.inventMovement(prodBOMTransProj.prodBOM(true));
                if (movement)
                {
                    return movement;
                }
                return InventMov_ProdLine::newFromProdBOM(prodBOMTransProj.prodBOM(true));
            case tableNum(WMSOrderTrans):
                WMSOrderTrans wmsOrderTrans = _buffer as WMSOrderTrans;
                WMSOrder wmsOrder = wmsOrderTrans.wmsOrder();
                return InventMov_WMSOrder::newFromWMSOrder(wmsOrder);
            case (tableNum(InventJournalTrans)):
                return InventMov_Journal::newFromInventJournalTrans(_buffer as InventJournalTrans, _subType, _childBuffer);
            case tableNum(SalesParmLine):
                SalesParmLine salesParmLine = _buffer as SalesParmLine;
                return InventMov_Sales::newFromSalesLine(salesParmLine.salesLine(true));
            case tableNum(PurchParmLine):
                PurchParmLine purchParmLine = _buffer as PurchParmLine;
                return InventMov_Purch::newFromPurchLine(purchParmLine.purchLine(true));
            case tableNum(VendInvoiceInfoLine):
                VendInvoiceInfoLine vendInvoiceInfoLine = _buffer as VendInvoiceInfoLine;
                return InventMov_Purch::newFromPurchLine(vendInvoiceInfoLine.purchLine(true));
            case tableNum(ProdParmReportFinished):
                ProdParmReportFinished prodParmReportFinished = _buffer as ProdParmReportFinished;
                if (#PmfEnabled)
                {
                    if (   prodParmReportFinished.PmfProductType == PmfProductType::Co_Product
                        || prodParmReportFinished.PmfProductType == PmfProductType::By_Product)
                    {
                        pmfProdCoBy = prodParmReportFinished.pmfProdCoBy(true);
                        if (!pmfProdCoBy.RecId)
                        {
                            pmfProdCoBy.initFromProdParmReportFinished(prodParmReportFinished);
                        }

                        return InventMov_Prod_JournalProd_CoBy::construct(
                                pmfProdCoBy,
                                null);
                    }
                }
                return InventMov_Prod_JournalProd::newFromProdTable(prodParmReportFinished.prodTable(true));
            case tableNum(InventTrans):
                InventTrans inventTrans = _buffer as InventTrans;
                InventTransOrigin inventTransOrigin = inventTrans.inventTransOrigin();

                if (InventTrans.TransChildType != InventTransChildType::None)
                {
                    var childReference = InventTransChildReference::newFromInventTrans(inventTrans);
                    if (childReference.canInstantiateReceiptChildMovement())
                    {
                        return childReference.instantiateReceiptChildMovement();
                    }
                }

                if (inventTransOrigin.ReferenceId)
                {
                    return inventTransOrigin.inventMovement(inventTrans.direction(), true);
                }

                if (inventTransOrigin.ReferenceCategory == InventTransType::SummedUp)
                {
                    return InventMov_Vir_Transfer_Closing::newInventTrans(inventTrans);
                }

                if (inventTransOrigin.ReferenceCategory == InventTransType::InventTransArchive)
                {
                    return InventMov_InventTransArchive::newInventTrans(inventTrans);
                }

                if (inventTransOrigin.ReferenceCategory == InventTransType::WHSInventTransArchiveOnlyAffectsLocationAndBelow)
                {
                    return InventMov_WHSInventTransArchiveOnlyAffectsLocationAndBelow::newInventTrans(inventTrans);
                }

                return InventMov_Virtuel::newInventTrans(_buffer);
            case tableNum(InventTransOrigin):
                inventTransOrigin = _buffer as InventTransOrigin;
                inventTrans = InventTrans::findByInventTransOrigin(inventTransOrigin.RecId);

                if (inventTransOrigin.ReferenceId)
                {
                    return inventTransOrigin.inventMovement(inventTrans.direction(), true);
                }

                if (inventTransOrigin.ReferenceCategory == InventTransType::SummedUp)
                {
                    return InventMov_Vir_Transfer_Closing::newInventTrans(inventTrans);
                }

                if (inventTransOrigin.ReferenceCategory == InventTransType::InventTransArchive)
                {
                    return InventMov_InventTransArchive::newInventTrans(inventTrans);
                }

                if (inventTransOrigin.ReferenceCategory == InventTransType::WHSInventTransArchiveOnlyAffectsLocationAndBelow)
                {
                    return InventMov_WHSInventTransArchiveOnlyAffectsLocationAndBelow::newInventTrans(inventTrans);
                }

                return InventMov_Virtuel::newInventTrans(inventTrans);
            case (tableNum(InventTransferParmLine)):
                InventTransferParmLine inventTransferParmLine = _buffer as InventTransferParmLine;
                return InventMovement::constructNoThrow(inventTransferParmLine.inventTransferLine(true));
            case (tableNum(InventTransferJourLine)):
                InventTransferJourLine inventTransferJourLine = _buffer as InventTransferJourLine;
                return InventMovement::constructNoThrow(inventTransferJourLine.inventTransferLine(true));
            case tableNum(KanbanJob):
                KanbanJob kanbanJob = _buffer as KanbanJob;
                if (kanbanJob.type().mustBeWIPMovement())
                {
                    return InventMov_KanbanJob_WIP::newFromKanbanJob(kanbanJob);
                }

                switch (kanbanJob.Type)
                {
                    case LeanKanbanJobType::Process:
                        return InventMov_KanbanJob_Process::newFromKanbanJob(kanbanJob);
                    case LeanKanbanJobType::Transfer:
                        if (_subType != InventMovSubType::TransferReceipt)
                        {
                            return InventMov_KanbanJob_TransIssue::newFromKanbanJob(kanbanJob);
                        }
                        movement = InventMov_KanbanJob_TransReceipt::newFromKanbanJob(kanbanJob);
                        movement.inventMovSubType(InventMovSubType::TransferReceipt);
                        return movement;
                }

            // <GEERU>
            case tableNum(ProdJournalRelease_RU)        :
                ProdJournalRelease_RU prodJournalRelease_RU = _buffer;
                return prodJournalRelease_RU.inventMovement();

            case tableNum(ProdReleaseTrans_RU)        :
                ProdReleaseTrans_RU prodReleaseTrans_RU = _buffer;
                return prodReleaseTrans_RU.inventMovement();
            // </GEERU>

            case tableNum(KanbanBoardTmpProcessJob):
                KanbanBoardTmpProcessJob kanbanBoardTmpProcessJob = _buffer as KanbanBoardTmpProcessJob;
                return InventMovement::constructNoThrow(kanbanBoardTmpProcessJob.kanbanJob(true),_subType,_childBuffer);
            case tableNum(KanbanBoardTmpTransferJob):
                KanbanBoardTmpTransferJob kanbanBoardTmpTransferJob = _buffer as KanbanBoardTmpTransferJob;
                return InventMovement::constructNoThrow(kanbanBoardTmpTransferJob.kanbanJob(true),_subType,_childBuffer);

            case tableNum(RetailTransactionSalesTrans):
                if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
                {
                    return new InventMov_Statement(_buffer);
                }
                return null;

            case tableNum(PurchLineBackOrder):
                PurchLineBackOrder purchLineBackOrder = _buffer as PurchLineBackOrder;
                return InventMov_Purch::newFromPurchLine(PurchLine::findInventTransId(purchLineBackOrder.InventTransId));
            
            case tableNum(PurchLineBackOrderWorkSpace):
                PurchLineBackOrderWorkSpace purchLineBackOrderWorkSpace = _buffer as PurchLineBackOrderWorkSpace;
                return InventMov_Purch::newFromPurchLine(PurchLine::findInventTransId(purchLineBackOrderWorkSpace.InventTransId));
            
            case tableNum(ConsignmentDraftReplenishmentOrderJournalLine):
                var consignmentDraftReplenishmentOrderJournalLine = _buffer as ConsignmentDraftReplenishmentOrderJournalLine;
                return InventMov_ConsignmentReplenishmentOrder::newFromReplenishmentOrderLine(consignmentDraftReplenishmentOrderJournalLine.replenishmentOrderLine(true));

            default:
                movement = InventMovement::constructFromAttribute(_buffer,new InventMovementFactoryAttribute(tableId2Name(_buffer.TableId),_subType));
                if (!movement) // if there is no InventMovementSubType-specific attribute, search without the InventMovementSubType and that's all
                {
                    return InventMovement::constructFromAttribute(_buffer,new InventMovementFactoryAttribute(tableId2Name(_buffer.TableId)));
                }
                movement.inventMovSubType(_subType); // otherwise, set that InventMovementSubType
                return movement;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructServer</Name>
				<Source><![CDATA[
    public static InventMovement constructServer(
        Common              _buffer,
        InventMovSubType    _subType        = InventMovSubType::None,
        Common              _childBuffer    = null)
    {
        InventMovement movement = InventMovement::constructNoThrow(_buffer, _subType, _childBuffer);
        if (!movement)
        {
            throw error("@SYS20765");
        }
        return movement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newReqTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an <c>inventMovement</c> object by using a <c>ReqTrans</c> record.
    /// </summary>
    /// <param name="_reqTrans">
    ///    A <c>ReqTrans</c> record.
    /// </param>
    /// <returns>
    ///    An <c>inventMovement</c> object.
    /// </returns>
    public static InventMovement newReqTrans(ReqTrans _reqTrans)
    {
        InventTransOrigin       inventTransOrigin = _reqTrans.inventTransOrigin();

        if (!inventTransOrigin)
        {
            return null;
        }

        InventDirection direction = (_reqTrans.isReceipt()) ? InventDirection::Receipt : InventDirection::Issue;
        return inventTransOrigin.inventMovement(direction);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransferScrapMovement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the inventory transfer scrap movement class.
    /// </summary>
    /// <param name="_inventTransferLine">
    ///    The inventory transfer order line for which the movement should be created.
    /// </param>
    /// <param name="_inventTransReceipt">
    ///    The related receipt inventory transaction.
    /// </param>
    /// <param name="_inventTransferParmTable">
    ///    The update parameters of the inventory transfer order.
    /// </param>
    /// <returns>
    ///    The new instance of the inventory transfer scrap movement.
    /// </returns>
    public static InventMovement newTransferScrapMovement(
        InventTransferLine      _inventTransferLine,
        InventTrans             _inventTransReceipt,
        InventTransferParmTable _inventTransferParmTable)
    {
        return InventMov_TransferScrap::newParameters(_inventTransferLine, _inventTransReceipt, _inventTransferParmTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>openInventOnhandCheckReserveForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens <c>InventOnhandCheckReserve</c> form.
    /// </summary>
    /// <param name="_buffer">
    /// A record for the form initialization.
    /// </param>
    /// <returns>
    /// true if form was successfully closed; otherwise, false.
    /// </returns>
    protected static boolean openInventOnhandCheckReserveForm(Common _buffer)
    {
        Args args = new Args();

        args.name(formStr(InventOnhandCheckReserve));
        args.caller();
        args.record(_buffer);

        FormRun formRun = classfactory.formRunClass(args);
        formRun.init();
        formRun.run();
        formRun.wait();
        return formRun.closedOk();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsAskSameLotResolutionClient</Name>
				<Source><![CDATA[
    /// <summary>
    /// Requests that the user determine how to resolve a same lot reservation issue.
    /// </summary>
    /// <param name="_movement">
    /// The inventory movement class.
    /// </param>
    /// <param name="_error">
    /// The error that must be resolved.
    /// </param>
    /// <param name="_inventDimReq">
    /// The inventory dimension from which the reservation was requested.
    /// </param>
    /// <param name="_reserveNow">
    /// The quantity that tried to be reserved.
    /// </param>
    /// <param name="_cwReserveNow">
    /// The catch weight quantity that tried to be reserved.
    /// </param>
    /// <returns>
    /// The <c>PdsSameLotBatchResolution</c> object to resolve the issue.
    /// </returns>
    /// <remarks>
    /// A wrapper method for <c>pdsAskSameLotResolution</c> which forces code execution under client tier.
    /// </remarks>    
    protected static PdsSameLotBatchResolution pdsAskSameLotResolutionClient(
        InventMovement  _movement,
        PdsSameLotError _error,
        InventDim       _inventDimReq,
        InventQty       _reserveNow,
        PdsCWInventQty  _cwReserveNow = 0)
    {
        return _movement.pdsAskSameLotResolution(_error, _inventDimReq, _reserveNow, _cwReserveNow);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAutoReserving</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets and checks the auto-reserving property.
    /// </summary>
    /// <param name="_buffer">
    /// The <c>salesLine</c> table buffer, <c>PurchLine</c> table buffer, and so on.
    /// </param>
    /// <param name="_showDialog">
    /// The Boolean which indicates whether dialog or warning should be shown if auto reservation is not possible.
    /// </param>
    /// <returns>
    /// An <c>inventMovement</c> object.
    /// </returns>
    /// <remarks>
    /// This method is called from the <c>SalesTableForm</c> class when you enter a new sales line. If the
    /// quantity that is entered must be reserved, the method checks for the available inventory. If
    /// inventory is not found and if it's set to show dialog, the method returns the <c>InventOnHandCheckReserve</c> dialog box to the
    /// user. From here, the user can change the quantity on the order line or ignore the dialog box and
    /// continue.
    /// </remarks>
    public static boolean setAutoReserving(Common  _buffer, boolean _showDialog = true)
    {
        InventMovement movement = InventMovement::construct(_buffer);

        if (!movement.canBeReserved() || !movement.mustBeAutoReserved())
        {
            return true;
        }

        if (! movement.inventTable().checkValid(movement.itemId()))
        {
            throw error("@SYS18447");
        }

        if (!movement.inventTable().inventItemType().mustInventBeControlled())
        {
            return true;
        }

        InventMovement movement_Orig = InventMovement::construct(_buffer.orig());
        if (!InventAutoReserveCheck::newMovement(movement, movement_Orig).isReservationNeeded())
        {
            return true;
        }

        if (!_showDialog)
        {
            setPrefix(strFmt("@SYS24300", movement.itemId()));
            str inventDimCriteriaPrefix = movement.inventdim().preFix();
            if (inventDimCriteriaPrefix)
            {
                setPrefix(inventDimCriteriaPrefix);
            }
        }

        if (movement.pdsSameLotReservation())
        {
            return movement.pdsResolveSameLotReservation(movement_Orig, _showDialog);
        }
        else
        //this call is moved to the server to reduce RPC traffic
        if (InventMovement::canAutoReserveQuantity(_buffer, !_showDialog))
        {
            return true;
        }

        if (movement.mustContinueAutoReserve())
        {
            return true;
        }

        if (_showDialog)
        {
            return InventMovement::openInventOnhandCheckReserveForm(_buffer);
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustContinueAutoReserve</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to continue auto-reserving.
    /// </summary>
    /// <returns>
    /// true if must continue auto-reserving; otherwise, false.
    /// </returns>
    protected boolean mustContinueAutoReserve()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ensureTransQtyIsAcceptableForBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Changes the quantity to an acceptable value using the specified conflicts resolution strategy if the quantity constraints are violated.
    /// </summary>
    /// <param name = "_buffer">The record that serves as the inventory movement originator.</param>
    /// <param name = "_errorCorrectionMethods">The error correction methods.</param>
    /// <param name = "_useDefaultOrderSetup">
    /// A Boolean value indicating whether the constraints should be derived
    /// from the default (cross-site) order settings regardless of the inventory dimensions of the record.
    /// </param>
    public static void ensureTransQtyIsAcceptableForBuffer(
        Common                                        _buffer,
        InventMovementQuantityErrorCorrectionMethods  _errorCorrectionMethods = InventMovementQuantityErrorCorrectionMethods::newStandard(),
        boolean                                       _useDefaultOrderSetup = false)
    {
        InventMovement movement = InventMovement::construct(_buffer);

        Qty acceptableTransQty = movement.acceptableTransQty(_errorCorrectionMethods, _useDefaultOrderSetup);

        if (acceptableTransQty != (movement.transQtyUnit() * movement.transSign()))
        {
            movement.setTransQtyUnit(acceptableTransQty * movement.transSign());
            movement.pdsCWSetTransQty(PdsCatchWeight::convertQtyToCWQty(movement.itemId(), acceptableTransQty * movement.transSign(), movement.transUnitId()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createQuantityValidator</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a quantity validator that will be used to determine the acceptable movement quantity.
    /// </summary>
    /// <param name = "_orderSetup">The order settings that define the quantity constraints.</param>
    /// <param name = "_errorCorrectionMethods">The error correction methods.</param>
    /// <returns>The created quantity validator.</returns>
    protected InventMovementQuantityValidator createQuantityValidator(
        InventItemOrderSetupMap                         _orderSetup,
        InventMovementQuantityErrorCorrectionMethods    _errorCorrectionMethods)
    {
        return InventMovementQuantityValidator::newFromErrorCorrectionMethods(_orderSetup, _errorCorrectionMethods);
    }

]]></Source>
			</Method>
			<Method>
				<Name>acceptableTransQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Based on the current transaction quantity determines the acceptable movement quantity
    /// given the strategy for resolving quantity constraint conflicts.
    /// </summary>
    /// <param name = "_errorCorrectionMethods">The error correction methods.</param>
    /// <param name = "_useDefaultOrderSetup">
    /// A Boolean value indicating whether the constraints should be derived
    /// from the default (cross-site) order settings regardless of the inventory dimensions of the record.
    /// </param>
    /// <returns>The acceptable movement quantity.</returns>
    protected Qty acceptableTransQty(
        InventMovementQuantityErrorCorrectionMethods    _errorCorrectionMethods = InventMovementQuantityErrorCorrectionMethods::newStandard(),
        boolean                                         _useDefaultOrderSetup = false)
    {
        InventDimId productInventDimId = this.inventdim().InventDimId;
        InventItemOrderSetupMap orderSetup = this.inventItemOrderSetupMap(_useDefaultOrderSetup  ? InventDim::inventDimIdBlank() : productInventDimId);

        var validator = this.createQuantityValidator(orderSetup, _errorCorrectionMethods);
        validator.parmProductInventDimId(productInventDimId);

        Qty requestedQty = this.transQtyUnit() * this.transSign();

        return validator.acceptableQty(requestedQty, this.transUnitId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>setMinMaxQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether the quantity on the specified record satisfies the imposed constraints
    /// and changes the quantity to an acceptable value if the constraints are violated.
    /// </summary>
    /// <param name = "_buffer">The inventory transaction originator record.</param>
    /// <param name = "_showUsrDialog">A Boolean parameter that controls how to resolve constraint conflicts. When set to false it will force the system to automatically accept the correction quantity suggested by the system without notifying the user; optional.</param>
    /// <param name = "_useDefaultOrderSetup">A Boolean parameter that indicates whether to ignore site-specific order settings; optional.</param>
    /// <param name = "_doMinQtyCheck">A Boolean parameter that indicates whether the lower limit quantity check must be performed; optional.</param>
    /// <param name = "_doMaxQtyCheck">A Boolean parameter that indicates whether the upper limit quantity check must be performed; optional.</param>
    public static void  setMinMaxQty(
        Common      _buffer,
        boolean     _showUsrDialog          = true,
        boolean     _useDefaultOrderSetup   = false,
        boolean     _doMinQtyCheck          = true,
        boolean     _doMaxQtyCheck          = true)
    {
        var errorCorrectionMethods = InventMovementQuantityErrorCorrectionMethods::newParameters(_showUsrDialog, _doMinQtyCheck, _doMaxQtyCheck);
        InventMovement::ensureTransQtyIsAcceptableForBuffer(_buffer, errorCorrectionMethods);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setMinMaxMultipleQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether the quantity on the specified record satisfies the imposed constraints
    /// and changes the quantity to an acceptable value if the constraints are violated.
    /// </summary>
    /// <param name = "_buffer">The inventory transaction originator record.</param>
    /// <param name = "_showUsrDialog">A Boolean parameter that controls how to resolve constraint conflicts. When set to false it will force the system to automatically accept the correction quantity suggested by the system without notifying the user; optional.</param>
    /// <param name = "_useDefaultOrderSetup">A Boolean parameter that indicates whether to ignore site-specific order settings; optional.</param>
    /// <param name = "_doMinQtyCheck">A Boolean parameter that indicates whether the lower limit quantity check must be performed; optional.</param>
    /// <param name = "_doMaxQtyCheck">A Boolean parameter that indicates whether the upper limit quantity check must be performed; optional.</param>
    /// <param name = "_doMultipleQtyCheck">A Boolean parameter that indicates whether the multiple limit quantity check must be performed; optional.</param>
    /// <remarks>
    /// The missing parameter _doMultipleQtyCheck leads to auto correct user input according to default order setting.
    /// This will cause batch merge cannot be posted because the it will not pass error correction method validation.
    /// And this method should be used afterward instead of calling method 'setMinMaxQty'.
    /// </remarks>
    public static void setMinMaxMultipleQty(
        Common      _buffer,
        boolean     _showUsrDialog          = true,
        boolean     _useDefaultOrderSetup   = false,
        boolean     _doMinQtyCheck          = true,
        boolean     _doMaxQtyCheck          = true,
        boolean     _doMultipleQtyCheck     = true)
    {
        var errorCorrectionMethods = InventMovementQuantityErrorCorrectionMethods::newParametersWithMultipleQtyCheck(_showUsrDialog, _doMinQtyCheck, _doMaxQtyCheck, _doMultipleQtyCheck);
        InventMovement::ensureTransQtyIsAcceptableForBuffer(_buffer, errorCorrectionMethods);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventDimForInventDimField</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the physical dimensions of a given <c>InventDim</c> table buffer for the passed <c>InventDim</c> table field.
    /// </summary>
    /// <param name="_qty">
    ///    A quantity used to validate the physical dimensions.
    /// </param>
    /// <param name="_inventDim">
    ///    The <c>InventDim</c> table buffer to validate.
    /// </param>
    /// <param name="_inventDimGroupFieldSetup">
    ///    The inventDim field that is validated.
    /// </param>
    /// <param name="_finalCheck">
    ///    A Boolean flag that indicates if all inventory dimension must have been assigned; optional.
    /// </param>
    /// <param name="_showError">
    ///    A Boolean value that indicates if errors must be shown in the infolog; optional.
    /// </param>
    /// <returns>
    ///    true if the validation passes; otherwise, false.
    /// </returns>
    protected boolean checkInventDimForInventDimField(
        InventQty                       _qty,
        InventDim                       _inventDim,
        InventDimGroupFieldSetup        _inventDimGroupFieldSetup,
        boolean                         _finalCheck,
        boolean                         _showError
        )
    {
        boolean                                 okTmp = true;
        FieldId                                 inventDimFieldId = _inventDimGroupFieldSetup.dimFieldId();
        InventNumGroupId                        serialNumGroupId, batchNumGroupId;

        boolean failed(str _message)
        {
            if (_showError)
            {
                return checkFailed(_message);
            }
            return false;
        }

        if (_inventDimGroupFieldSetup.isActive())
        {
            if (_inventDimGroupFieldSetup.isProductDimension())
            {
                if (!_inventDim.(inventDimFieldId))
                {
                    okTmp = failed(strFmt("@SYS54774",fieldId2pname(_inventDim.TableId, inventDimFieldId)));
                }
                else
                if (_inventDim.(inventDimFieldId) != this.inventdim().(inventDimFieldId))
                {
                    okTmp = failed(strFmt("@SYS54775",fieldId2pname(_inventDim.TableId, inventDimFieldId), _inventDim.(inventDimFieldId), this.inventdim().(inventDimFieldId)));
                }
            }
            else if (!_inventDim.(inventDimFieldId) && _inventDimGroupFieldSetup.isMandatory())
            {
                okTmp = failed(strFmt("@SYS103633",fieldId2pname(_inventDim.TableId, inventDimFieldId)));
            }

            // <GEERU>
            if (inventDimFieldId == fieldNum(InventDim, InventProfileId_RU))
            {
                okTmp = this.checkProfileOwner_RU(_inventDim) && okTmp;
            }
            // </GEERU>

            if (! _inventDim.(inventDimFieldId) && okTmp)
            {
                if ( (_inventDimGroupFieldSetup.isPrimaryStockingEnabled())
                    || (_qty > 0 && !this.dimAllowBlankReceipt(_inventDimGroupFieldSetup))
                    || (_qty < 0 && !this.dimAllowBlankIssue(_inventDimGroupFieldSetup)))
                {
                    okTmp = false;
                }

                if (_qty > 0 && !okTmp && !_finalCheck)
                {
                    switch (inventDimFieldId)
                    {
                        case fieldNum(InventDim,InventBatchId):
                            batchNumGroupId =  this.inventTable().BatchNumGroupId;
                            if (batchNumGroupId)
                            {
                                okTmp = InventNumGroup::find(batchNumGroupId).ManualAllocation  ? false : true;
                            }
                            if (   !okTmp
                                && _showError)
                            {
                                info("@SYS81882",'appldoc://forms/inventnumgroup',SysInfoAction_Formrun::newFormnameDesc(formStr(InventNumGroup),"@SYS7865"));
                            }
                            break;
                        case fieldNum(InventDim,InventSerialId):
                            serialNumGroupId = this.inventTable().SerialNumGroupId;
                            if (serialNumGroupId)
                            {
                                okTmp = InventNumGroup::find(serialNumGroupId).ManualAllocation  ? false : true;
                            }
                            if (   !okTmp
                                && _showError)
                            {
                                info("@SYS81883",'appldoc://forms/inventnumgroup',SysInfoAction_Formrun::newFormnameDesc(formStr(InventNumGroup),"@SYS7865"));
                            }
                            break;
                        // <GEERU>
                        case fieldNum(InventDim, InventOwnerId_RU):
                            if (this.parmCompanyCountryRegion().isCountryRegionRU())
                            {
                                // pass true to check it when physical update occur
                                okTmp = this.updateAutoDimOwnerId_RU();
                            }
                            break;
                        // </GEERU>
                    }
                }

                if (!okTmp)
                {
                    if (_inventDimGroupFieldSetup.isPrimaryStockingEnabled())
                    {
                        if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
                        {
                            okTmp = failed(strFmt(this.itemId() + "@SYS54776",fieldId2pname(_inventDim.TableId, inventDimFieldId)));
                        }
                        else
                        {
                            okTmp = failed(strFmt("@SYS54776",fieldId2pname(_inventDim.TableId, inventDimFieldId)));
                        }
                    }
                    else
                    {
                        okTmp = failed(strFmt("@SYS53724",fieldId2pname(_inventDim.TableId, _inventDimGroupFieldSetup.dimFieldId())));
                    }
                }
            }
        }
        else
        {
            if (_inventDim.(inventDimFieldId))
            {
                if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
                {
                    okTmp = failed(strFmt(this.itemId() + "@SYS54773",fieldId2pname(_inventDim.TableId, inventDimFieldId)));
                }
                else
                {
                    okTmp = failed(strFmt("@SYS54773",fieldId2pname(_inventDim.TableId, inventDimFieldId)));
                }
            }
        }

        return okTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventDimForReservedTransPhysChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the <c>InventDim</c> that should be put on the transaction when reservation status is updated from ordered to physical.
    /// </summary>
    /// <param name="_isWarehouseWHSEnabled">
    /// Is the warehouse using warehouse processes?
    /// </param>
    /// <param name="_issueInventDim">
    /// <c>InventDim</c> record with all available dimensions populated.
    /// </param>
    /// <param name="_issueInventDimAboveLocation">
    /// <c>InventDim</c> record with only dimensions above Location.
    /// </param>
    /// <returns>
    /// The <c>InventDim</c> to set on the transaction.
    /// </returns>
    public InventDim getInventDimForReservedTransPhysChange(
        boolean   _isWarehouseWHSEnabled,
        InventDim _issueInventDim,
        InventDim _issueInventDimAboveLocation)
    {
        inventDim localInventDim;

        // If the transaction is for a WHS enabled warehouse and can have reserved work,
        // then we only synchronize dimensions above location...
        if (_isWarehouseWHSEnabled && this.canHaveReservedWork())
        {
            localInventDim.data(_issueInventDimAboveLocation);
        }
        // ... Otherwise, we synchronize all dimensions.
        else
        {
            localInventDim.data(_issueInventDim);
        }

        return localInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimIdTransferIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an <c>InventDimId</c> Id for the issue transactions that corresponds to a receipt.
    /// </summary>
    /// <returns>
    /// An <c>InventDimId</c> Id for the issue transactions that corresponds to a receipt
    /// </returns>
    public InventDimId inventDimIdTransferIssue()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransOriginTransferId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ID of the inventory transaction originator that corresponds to the movement.
    /// </summary>
    /// <returns>
    /// The ID of the inventory transaction originator that corresponds to the movement.
    /// </returns>
    public InventTransOriginId inventTransOriginTransferId()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustReturnToDimOnSourceDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the quantity will be returned to inventory dimension from source document line.
    /// </summary>
    /// <returns>
    ///     True if the quantity will be returned to dimension from source document line; otherwise, false.
    /// </returns>
    public boolean mustReturnToDimOnSourceDocumentLine()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsDistributeInventQtyOnMarkedTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Distributes inventory quantity among related marked transactions.
    /// </summary>
    /// <param name="_inventQtyForDistribution">
    ///     Inventory quantity to distribute; positive to deduct from related transactions, negative to add.
    /// </param>
    /// <returns>
    ///     true if full quantity was distributed; false, otherwise.
    /// </returns>
    public boolean pdsDistributeInventQtyOnMarkedTrans(InventQty _inventQtyForDistribution)
    {
        InventTransOriginId             inventTransOrigId = this.inventTransOriginId();
        InventTrans                     inventTransWithMarking;
        InventQty                       inventQtyAvailableForDistribution;
        UnitOfMeasureDecimalPrecision   decimalPrecision;

        if (_inventQtyForDistribution && this.pdsCWItem())
        {
            decimalPrecision = UnitOfMeasure::findBySymbol(InventTableModule::find(this.itemId(), ModuleInventPurchSales::Invent).UnitId).DecimalPrecision;
            //  N.B.
            //  With positive _inventQtyForDistribution we assume to reduce (deduct)the inventory quantity of existing marked transactions
            //  while negative quantity means inventory quantity of the marked transaction should be increased!

            // Find related transactions that are marked...
            while select sum(Qty), sum(PdsCWQty), MarkingRefInventTransOrigin from inventTransWithMarking
            group by MarkingRefInventTransOrigin
            where   inventTransWithMarking.InventTransOrigin == inventTransOrigId
                 && inventTransWithMarking.Qty      != 0
                 && inventTransWithMarking.PdsCWQty != 0
                 && inventTransWithMarking.MarkingRefInventTransOrigin != 0
            {
                // Check inventory quantity boundaries for marked transaction...
                if (_inventQtyForDistribution > 0)
                {
                    // Reducing inventory quantity is needed:
                    inventQtyAvailableForDistribution = inventTransWithMarking.Qty - PdsCatchWeight::minInventQty(this.itemId(), inventTransWithMarking.PdsCWQty);
                }
                else
                {
                    // Retain the quantity sign here,
                    // so quantity available for distribution follows the sign of _inventQtyForDistribution parameter
                    inventQtyAvailableForDistribution = inventTransWithMarking.Qty - PdsCatchWeight::maxInventQty(this.itemId(), inventTransWithMarking.PdsCWQty);
                }

                if (inventQtyAvailableForDistribution)
                {
                    // Calculate quantity capacity (considering the sign)...
                    InventQty adjustNowInventQty = (inventQtyAvailableForDistribution > 0) ?
                    min(_inventQtyForDistribution, inventQtyAvailableForDistribution) :
                    max(_inventQtyForDistribution, inventQtyAvailableForDistribution);

                    // Distribute some quantity...
                    // We need to adjust inventory quantity for the counterpart.
                    InventMovement counterpartMovement = InventMovement::construct(InventTransOrigin::find(inventTransWithMarking.MarkingRefInventTransOrigin));
                    counterpartMovement.pdsAdjustInventoryQuantity(-adjustNowInventQty);
                    counterpartMovement.pdsUpdateBufferWithAdjustedQuantity();

                    InventTransOrigin::updateMarking(inventTransOrigId, inventTransWithMarking.MarkingRefInventTransOrigin, adjustNowInventQty);

                    // Update quantity to distribute...
                    _inventQtyForDistribution -= adjustNowInventQty;

                    // If there is nothing to distribute anymore stop now
                    if (_inventQtyForDistribution <= 0)
                    {
                        break;
                    }
                }
            }
        }
        return (decRound(_inventQtyForDistribution, decimalPrecision) == 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsSumUpTransDistributeCwQtyZero</Name>
				<Source><![CDATA[
    /// <summary>
    /// Summarize and distribute inventory quantity among related marked transactions for catch weight products
    /// </summary>
    public void pdsSumUpTransDistributeCwQtyZero()
    {
        InventTrans         inventTrans;
        InventTransOriginId inventTransOrigId = this.inventTransOriginId();

        // Try to handle transactions with non-zero inventQuantity and zero CW quantity
        // that couldn't be summed up due to mismatched marking...
        if (this.pdsCWItem())
        {
            // Do sum up right now... (executes only for CW movement)
            this.doSumUp();

            // Iterate all transactions related to the movement that still have CW quantity set to 0
            // (with non-0 )
            while select Qty from inventTrans
                where inventTrans.InventTransOrigin == inventTransOrigId
                      && inventTrans.Qty            != 0
                      && inventTrans.PdsCWQty       == 0
                      && inventTrans.MarkingRefInventTransOrigin
            {
                if (!this.pdsDistributeInventQtyOnMarkedTrans(inventTrans.Qty))
                {
                    throw error("@SYS4000146");
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an inventory transaction instance.
    /// </summary>
    /// <returns>An inventory transaction.</returns>
    public InventTrans initInventTrans()
    {
        InventTrans inventTrans;

        if (this.mustAggregateExpectedTransactions())
        {
            inventTrans = InventTrans::findTransId(this.transId(), true);
            if (! inventTrans)
            {
                this.initInventTransFromBuffer(inventTrans, null);
            }
        }
        else
        {
            this.initInventTransFromBuffer(inventTrans, null);
        }

        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxEngineInventMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set <c>TaxEngineInventMovement</c> object for tax posting.
    /// </summary>
    /// <param name = "_taxEngineInventMovement">The <c>TaxEngineInventMovement</c> object.</param>
    public void setTaxEngineInventMovement(TaxEngineInventMovement _taxEngineInventMovement)
    {
        taxEngineInventMovement = _taxEngineInventMovement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxEngineInventMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>TaxEngineInventMovement</c> object.
    /// </summary>
    /// <returns>The TaxEngineInventMovement object.</returns>
    public TaxEngineInventMovement taxEngineInventMovement()
    {
        if (!taxEngineInventMovement)
        {
            taxEngineInventMovement = TaxEngineInventMovement::newTaxEngineInventMovement();
        }
        return taxEngineInventMovement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPickComplete</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Check if pick is complete for all quantities.
    /// </summary>
    /// <param name="_pickedQty">
    ///  The picked quantities.
    /// </param>
    /// <returns>
    ///  true if all quantities has been picked; else false.
    /// </returns>
    public boolean checkPickComplete(InventQty _pickedQty)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsCheckLocationAndLP</Name>
				<Source><![CDATA[
    public boolean whsCheckLocationAndLP(InventTrans _inventTrans)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventPostingItemLedgerDimensionParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new parameter for searching an inventory posting item ledger dimension for an item.
    /// </summary>
    /// <param name = "_inventAccountType">An inventory account type.</param>
    /// <param name = "_itemGroupId">An item group Id.</param>
    /// <returns>The created parameter instance.</returns>
    public InventPostingItemLedgerDimensionParameters createInventPostingItemLedgerDimensionParameters(
        InventAccountType   _inventAccountType, 
        ItemGroupId         _itemGroupId = this.inventTable().itemGroupId())
    {
        InventPostingItemLedgerDimensionParameters searchParameters = InventPostingItemLedgerDimensionParameters::newFromParameters(
            _inventAccountType,
            this.itemId(),
            _itemGroupId);

        if (this.parmCompanyCountryRegion().isCountryRegionRU())
        {
            searchParameters.InventDim_RU = this.inventdim();
        }

        return searchParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectReturnReceipt</Name>
				<Source><![CDATA[
    public boolean parmProjectReturnReceipt(boolean _projectReturnReceipt = projectReturnReceipt)
    {
        projectReturnReceipt = _projectReturnReceipt;

        return projectReturnReceipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCheckStoppedItem</Name>
				<Source><![CDATA[
    protected boolean shouldCheckStoppedItem()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSyncInventoryBlockingStatusTransType</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean shouldSyncInventoryBlockingStatusTransType()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipProductNotStoppedCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Whether or not items in this inventory movement need to skip the validation that the product is not stopped.
    /// </summary>
    /// <returns>Always returns false.</returns>
    internal boolean shouldSkipProductNotStoppedCheck()
    {
        // subclasses can override this method in order to disable this validation.
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForStoppedProducts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the product is stopped.
    /// </summary>
    /// <returns>True if the product is not stopped or the check should be skipped; otherwise, false.</returns>
    private boolean checkForStoppedProducts()
    {
        return (this.shouldSkipProductNotStoppedCheck() || this.inventItemInventSetup().checkNotStopped());
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventJournalCheckConsolidatedQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Gets or sets <c>InventJournalCheckConsolidatedQty</c>.
    /// </summary>
    /// <param name = "_inventJournalCheckConsolidatedQty">
    ///  The <c>InventJournalCheckConsolidatedQty</c> to set.
    /// </param>
    /// <returns>
    ///  null as it only works for inventory journal movement.
    /// </returns>
    public InventJournalCheckConsolidatedQty parmInventJournalCheckConsolidatedQty(InventJournalCheckConsolidatedQty _inventJournalCheckConsolidatedQty = null)
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets <c>InventType</c>.
    /// </summary>
    /// <returns>Instance of <c>InventType</c>.</returns>
    [Hookable(false)]
    internal protected  InventType parmInventType()
    {
        return inventType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventBatchReservationPolicy</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Gets <c>WHSInventBatchReservationPolicy</c>.
    /// </summary>
    /// <returns>
    ///  null as it only works for sales movement.
    /// </returns>
    internal WHSInventBatchReservationPolicy inventBatchReservationPolicy()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFlexibleWarehouseLevelDimensionReservationEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the flexible warehouse level dimension reservation is enabled for the <c>InventMovement</c> instance, such as a <c>salesLine</c>.
    /// </summary>
    /// <returns>
    /// true if the flexible warehouse level dimension reservation is enabled; otherwise, false.
    /// </returns>
    protected boolean isFlexibleWarehouseLevelDimensionReservationEnabled()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFlexibleWarehouseLevelDimensionReservationAvailable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the flexible warehouse level dimension reservation is available.
    /// </summary>
    /// <returns>
    /// true if the flexible warehouse level dimension reservation is available; otherwise, false.
    /// </returns>
    private boolean isFlexibleWarehouseLevelDimensionReservationAvailable()
    {
        return this.isItemWHSEnabled() &&
               this.canHaveReservedWork() &&
               this.inventDim().inventLocation().WHSEnabled &&
              !this.pdsCWItem() &&
               this.whsIsReservationOnDemandOrderEnabledOnAnyDimension();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUseFlexibleWarehouseLevelDimensionReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the <c>InventMovement</c> instance, such as a <c>salesLine</c>, can use the flexible warehouse level dimension reservation.
    /// </summary>
    /// <returns>
    /// true if the <c>InventMovement</c> instance can can use the flexible warehouse level dimension reservation; otherwise, false.
    /// </returns>
    [Hookable(false)]
    public boolean canUseFlexibleWarehouseLevelDimensionReservation()
    {
        return this.isFlexibleWarehouseLevelDimensionReservationEnabled() && this.isFlexibleWarehouseLevelDimensionReservationAvailable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsInitOrderCommittedReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds and updates, or creates a specified record in the <c>WHSOrderCommittedReservation</c> table.
    /// </summary>
    /// <param name="_createIfDoesntExist">
    /// A Boolean value that indicates whether to create the order committed reservation entity if it doesn't exist; optional.
    /// </param>
    /// <returns>
    /// A record in the <c>WHSOrderCommittedReservation</c> table.
    /// </returns>
    private WHSOrderCommittedReservation whsInitOrderCommittedReservation(boolean _createIfDoesntExist = false)
    {
        WHSOrderCommittedReservation orderCommittedReservation = WHSOrderCommittedReservation::findByCommittingOriginInventTransId(this.transId());

        if (!orderCommittedReservation && _createIfDoesntExist)
        {
            ttsbegin;

            orderCommittedReservation.initValue();
            orderCommittedReservation.initFromInventMovement(this);
            orderCommittedReservation.insert();

            ttscommit;
        }

        return orderCommittedReservation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsOrderCommittedReservationMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an <c>InventMovement</c> object for the corresponding Order-committed reservation record.
    /// </summary>
    /// <param name="_createIfDoesntExist">
    /// A Boolean value that indicates whether to create the order committed reservation entity if it doesn't exist; optional.
    /// </param>
    /// <returns>
    /// The <c>InventMovement</c> object.
    /// </returns>
    public InventMov_WHSOrderCommittedReservation whsOrderCommittedReservationMovement(boolean _createIfDoesntExist = false)
    {
        if (!this.canUseFlexibleWarehouseLevelDimensionReservation())
        {
            return null;
        }

        WHSOrderCommittedReservation orderCommittedReservation = this.whsInitOrderCommittedReservation(_createIfDoesntExist);

        if (!orderCommittedReservation)
        {
            return null;
        }

        InventMov_WHSOrderCommittedReservation orderCommittedReservationMovement = InventMov_WHSOrderCommittedReservation::newFromOrderCommittedReservation(orderCommittedReservation);

        return orderCommittedReservationMovement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVirtualTransMarkingRefBasedOnQuarantineExistence</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets <c>MarkingRefInventTransOrigin</c> for virtual transactions based on quarantine.
    /// </summary>
    /// <param name = "_markingRefInventTransOrigin">
    /// <c>MarkingRefInventTransOrigin</c> of virtual Transaction
    /// </param>
    /// <returns>
    /// <c>InventTransOriginId</c> value.
    /// </returns>
    internal InventTransOriginId getVirtualTransMarkingRefBasedOnQuarantineExistence(InventTransOriginId _markingRefInventTransOrigin)
    {
        InventTrans inventTransQuarantine;
        InventTransOrigin inventTransOrigin;
        InventQuarantineOrder inventQuarantineOrder;

        select firstonly MarkingRefInventTransOrigin, RecId from inventTransQuarantine 
             where inventTransQuarantine.InventTransOrigin == _markingRefInventTransOrigin
                    && (inventTransQuarantine.StatusIssue == StatusIssue::Sold || inventTransQuarantine.StatusIssue == StatusIssue::Deducted)
            exists join inventTransOrigin
                where inventTransOrigin.RecId == inventTransQuarantine.InventTransOrigin
            exists join inventQuarantineOrder
                where inventQuarantineOrder.InventTransId == inventTransOrigin.InventTransId
                    && inventQuarantineOrder.InventDimId == inventTransQuarantine.InventDimId;

        InventTransOriginId MarkinRefInventTransOriginVir = inventTransQuarantine.RecId ? inventTransQuarantine.MarkingRefInventTransOrigin : _markingRefInventTransOrigin;

        return MarkinRefInventTransOriginVir;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCanDepreciateMarkedTransactionUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs validation when inventory transaction was updated.
    /// </summary>
    /// <param name = "_inventTrans">Inventory transaction which was updated.</param>
    [Hookable(false)]
    internal void validateCanDepreciateMarkedTransactionUpdate(InventTrans _inventTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCanDeleteMarkedTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs validation when inventory transaction was deleted.
    /// </summary>
    [Hookable(false)]
    internal void validateCanDeleteMarkedTransaction()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsCheckCrossDockLoadInventTransUpdated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ckecks if the remaining invent quantity is not less than load line marking quantity.
    /// </summary>
    /// <param name = "_inventTrans">Inventory transaction which was updated.</param>
    final protected void whsCheckCrossDockLoadInventTransUpdated(InventTrans _inventTrans)
    {
        if (!(_inventTrans.Qty > 0            
            && WHSInventEnabled::exist(_inventTrans.ItemId)))
        {
            return;
        }

        InventTransOrigin inventTransOriginDemand = InventTransOrigin::find(_inventTrans.MarkingRefInventTransOrigin);

        if (!inventTransOriginDemand)
        {
            return;
        }

        WHSCrossDockLoadLine crossDockLoadLine;

        select sum(InventHandlingQty) from crossDockLoadLine
            where crossDockLoadLine.InventTransOriginIdSupply == _inventTrans.InventTransOrigin
            &&    crossDockLoadLine.InventTransIdDemand       == inventTransOriginDemand.InventTransId;

        if (!crossDockLoadLine)
        {
            return;
        }

        InventTrans       inventTransSupply;
        InventTransOrigin inventTransOriginSupply = InventTransOrigin::find(_inventTrans.InventTransOrigin);

        select sum(Qty)
            from inventTransSupply
            where inventTransSupply.InventTransOrigin           == _inventTrans.InventTransOrigin
            &&    inventTransSupply.StatusReceipt                > StatusReceipt::None
            &&    inventTransSupply.MarkingRefInventTransOrigin == _inventTrans.MarkingRefInventTransOrigin;

        if (inventTransSupply.Qty < crossDockLoadLine.InventHandlingQty)
        {
            throw error(strFmt("@WAX:UpdateMovementCrossDockLoadError",
                inventTransOriginSupply.ReferenceCategory,
                inventTransOriginSupply.ReferenceId,
                _inventTrans.ItemId,
                inventTransSupply.Qty,
                crossDockLoadLine.InventHandlingQty,
                inventTransOriginDemand.ReferenceCategory,
                inventTransOriginDemand.ReferenceId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsCheckCrossDockLoadInventTransDeleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if no cross docking links exists for deleted inventory transaction.
    /// </summary>
    final protected void whsCheckCrossDockLoadInventTransDeleted()
    {
        if (!WHSInventEnabled::exist(this.ItemId()))
        {
            return;
        }

        InventTrans          inventTransSupply;
        InventTransOrigin    inventTransOriginSupply;
        InventTransOrigin    inventTransOriginDemand;
        WHSCrossDockLoadLine crossDockLoadLine;

        select firstonly ItemId from inventTransSupply
            where inventTransSupply.InventTransOrigin == this.inventTransOriginId()
            &&    inventTransSupply.StatusReceipt      > StatusReceipt::None
        join ReferenceCategory, ReferenceId from inventTransOriginDemand
            where inventTransOriginDemand.RecId == inventTransSupply.MarkingRefInventTransOrigin
        join ReferenceCategory, ReferenceId from inventTransOriginSupply
            where inventTransOriginSupply.RecId == inventTransSupply.InventTransOrigin
        exists join crossDockLoadLine
            where crossDockLoadLine.InventTransOriginIdSupply == inventTransSupply.InventTransOrigin
            &&    crossDockLoadLine.InventTransIdDemand       == inventTransOriginDemand.InventTransId
            &&    crossDockLoadLine.InventHandlingQty;
        
        if (inventTransSupply)
        {
            throw error(strFmt("@WAX:DeleteMovementCrossDockLoadError",
                inventTransOriginSupply.ReferenceCategory,
                inventTransOriginSupply.ReferenceId,
                inventTransSupply.ItemId,
                inventTransOriginDemand.ReferenceCategory,
                inventTransOriginDemand.ReferenceId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPackingSlipId</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method gets/sets the packingslip Id
    /// </summary>
    /// <param name="_packingSlipId">Packingslip Id</param>
    /// <returns>Packingslip Id</returns>
    public PackingSlipId parmPackingSlipId(PackingSlipId _packingSlipId = packingSlipId)
    {
        packingSlipId = _packingSlipId;
        return packingSlipId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcMarkedCostValue</Name>
				<Source><![CDATA[
    public container calcMarkedCostValue(InventTransOriginId _markingInventTransOriginId, InventTransOriginId _inventTransOriginId)
    {
        return InventTransOrigin::calcMarkedCostValue(_markingInventTransOriginId, this.itemId(), this.inventModelGroup().InclPhysicalValueInCost, _inventTransOriginId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcReturnCostValue</Name>
				<Source><![CDATA[
    public container calcReturnCostValue(InventTrans _inventTrans)
    {
        return InventTransOrigin::calcReturnCostValue(_inventTrans.ReturnInventTransOrigin, _inventTrans.InventTransOrigin);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canForceActualCatchWeightQuantityReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ensures that actual catch weight quantity is requested for reservation.
    /// </summary>
    /// <returns>false.</returns>
    internal boolean canForceActualCatchWeightQuantityReservation()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPerformInventBlockingInventStatusSyncPostSyncDuringEstimation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Decides if inventory status blocking post sync can be performed during estimation in <c>InventUpd_Estimated</c> class.
    /// </summary>
    /// <returns>True if inventory status blocking post sync can be performed; otherwise, false.</returns>
    [Hookable(false)]
    internal boolean canPerformInventBlockingInventStatusSyncPostSyncDuringEstimation()
    {
        return this.transSign() > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryInventTransTransChild</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a query to fetch non-physically/financially updated receipt/issue transactions grouped by LOT, status and child reference 
    /// </summary>
    /// <returns>A query instance</returns>
    [Hookable(false)]
    internal Query buildQueryInventTransTransChild()
    {
        Query query = new Query();
        QueryBuildDataSource qbdsInventTrans = query.addDataSource(tableNum(InventTrans));
        
        qbdsInventTrans.fields().clearFieldList();
        qbdsInventTrans.addSelectionField(fieldNum(InventTrans, Qty), SelectionField::Sum);
        qbdsInventTrans.fields().addField(fieldNum(InventTrans, InventTransOrigin));
        qbdsInventTrans.fields().addField(fieldNum(InventTrans, StatusReceipt));
        qbdsInventTrans.fields().addField(fieldNum(InventTrans, StatusIssue));
        qbdsInventTrans.fields().addField(fieldNum(InventTrans, TransChildType));
        qbdsInventTrans.fields().addField(fieldNum(InventTrans, TransChildRefId));

        qbdsInventTrans.addGroupByField(fieldNum(InventTrans, InventTransOrigin));
        qbdsInventTrans.addGroupByField(fieldNum(InventTrans, StatusReceipt));
        qbdsInventTrans.addGroupByField(fieldNum(InventTrans, StatusIssue));
        qbdsInventTrans.addGroupByField(fieldNum(InventTrans, TransChildType));
        qbdsInventTrans.addGroupByField(fieldNum(InventTrans, TransChildRefId));

        qbdsInventTrans.addRange(fieldNum(InventTrans, InventTransOrigin)).value(queryValue(this.inventTransOriginId()));
        qbdsInventTrans.addRange(fieldNum(InventTrans, ValueOpen)).value(queryValue(InventTransOpen::Yes));

        if (this.transChildRefId())
        {
            qbdsInventTrans.addRange(fieldNum(InventTrans, TransChildRefId)).value(SysQuery::valueNot(this.transChildRefId())); 
        }

        InventDirection direction = this.transSign() > 0 ? InventDirection::Receipt : InventDirection::Issue;
        switch (direction)
        {
            case InventDirection::Issue:
                qbdsInventTrans.addRange(fieldNum(InventTrans, StatusReceipt)).value(queryValue(StatusReceipt::None));
                qbdsInventTrans.addRange(fieldNum(InventTrans, StatusIssue)).value(queryRange(StatusIssue::Picked, StatusIssue::OnOrder));
                break;
            case InventDirection::Receipt:
                qbdsInventTrans.addRange(fieldNum(InventTrans, StatusReceipt)).value(queryRange(StatusReceipt::Registered, StatusReceipt::Ordered));
                qbdsInventTrans.addRange(fieldNum(InventTrans, StatusIssue)).value(queryValue(StatusIssue::None));
                break;
            default:
                break;
        }        
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needInitUpdateEstimationQty</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean needInitUpdateEstimationQty()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckTransactionsOnPhysicalUpd</Name>
				<Source><![CDATA[
    public boolean mustCheckTransactionsOnPhysicalUpd()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsIsReservationOnDemandOrderEnabledOnAnyDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a reservation on demand order is enabled on any dimension.
    /// </summary>
    /// <returns>
    /// true if the reservation on demand order is enabled; otherwise, false.
    /// </returns>
    private boolean whsIsReservationOnDemandOrderEnabledOnAnyDimension()
    {
        if (whsIsReservationOnDemandOrderEnabledOnAnyDimension == UnknownNoYes::Unknown)
        {
            if (WHSReservationHierarchyElementPolicyProvider::singleton().isReservationOnDemandOrderEnabledOnAnyField(this.inventTable().whsReservationHierarchy()))
            {
                whsIsReservationOnDemandOrderEnabledOnAnyDimension = UnknownNoYes::Yes;
            }
            else
            {
                whsIsReservationOnDemandOrderEnabledOnAnyDimension = UnknownNoYes::No;
            }
        }

        return whsIsReservationOnDemandOrderEnabledOnAnyDimension == UnknownNoYes::Yes ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>logUnexpectedLotIdNotSpecified</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void logUnexpectedLotIdNotSpecified(MethodName _fromMethod)
    {
        InventMovementUnexpectedErrorLogger::logUnexpectedLotIdNotSpecified(this, _fromMethod, xSession::xppCallStack());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProjTransCorrectionApplicable_EE</Name>
				<Source><![CDATA[
    internal boolean isProjTransCorrectionApplicable_EE()
    {
        return this.projLedgerOrigin() != ProjOrigin::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFixedAssetReturn</Name>
				<Source><![CDATA[
    internal boolean isFixedAssetReturn()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordFinancialInventDimContext</Name>
				<Source><![CDATA[
    private void recordFinancialInventDimContext(InventTrans _inventTrans)
    {
        InventTransferUpdRecordInventDimForCostContext context = InventTransferUpdRecordInventDimForCostContext::current();
        if (context)
        {
            InventDimParm inventDimParm;
            this.inventDimGroupSetup().inventDimParmActiveFinancialInventory(inventDimParm);
            if (inventDimParm.InventSerialIdFlag || inventDimParm.InventBatchIdFlag)
            {
                context.inventDimParm = inventDimParm;
                context.inventDimCriteria = inventDim::find(_inventTrans.inventDimId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFinTag</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Populate the fintag for ledgervouchertransObject
    /// </summary>
    protected void updateFinTag(LedgerVoucherTransObject _ledgerVoucherTransObject)
    {
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustAdjustReceiptDimOnMarkingReserve</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines if receipt inventory dimensions should be adjusted to issue dimensions when updating reservations for marked transactions.
    /// </summary>
    /// <returns>
    ///   true when receipt inventory dimensions should be adjusted; otherwise, false
    /// </returns>
    [Hookable(false)]
    internal boolean mustAdjustReceiptDimOnMarkingReserve()
    {
        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>