<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxReport</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>TaxReport</c> class is a parent class that is used by some country/region-specific tax
///    reports, such as the <c>TaxReport_BE</c> class.
/// </summary>
/// <remarks>
///    The following country/region reports use this class directly:
///    <list type="bullet">
///       <item>
///          <description>
///             <c>TaxReport_DE </c>
///          </description>
///       </item>
///       <item>
///          <description>
///             <c>TaxReport_NL </c>
///          </description>
///       </item>
///       <item>
///          <description>
///             <c>TaxReport_NO </c>
///          </description>
///       </item>
///       <item>
///          <description>
///             <c>TaxReport_SE </c>
///          </description>
///       </item>
///       <item>
///          <description>
///             <c>TaxReport_UK </c>
///          </description>
///       </item>
///       <item>
///          <description>
///             <c>TaxReport_US</c>
///          </description>
///       </item>
///    </list>
///     The Italian report
///    <c>
///       TaxReport_IT
///    </c>
///     uses a class called
///    <c>
///       TaxReport_IT
///    </c>
///     that is derived directly from this
///    <c>
///       TaxReport
///    </c>
///     class.The Belgium and Austrian reports named
///    <c>
///       TaxReport_BE
///    </c>
///     and
///    <c>
///       TaxReport_AU
///    </c>
///     use classes named
///    <c>
///       TaxReport_BE
///    </c>
///     and
///    <c>
///       TaxReport_AU
///    </c>
///    , which both are derived from a class named
///    <c>
///       TaxReportAdjustTrans
///    </c>
///    , which again is derived from this
///    <c>
///       TaxReport
///    </c>
///     class.
/// </remarks>
class TaxReport extends RunBaseBatch implements BatchRetryable
{
    NoYes                   updateNow;
    TaxPeriod               taxPeriod;
    TaxPeriodDate           fromDate;
    TaxRegistrationRecId    taxRegistrationRecId;
    TaxRepVersion           taxRepVersion;
    TransDate               transactionDate;
    ERFileName              fileName;
    NoYes                   printReport;

    // Fields that do not need to be packed/unpacked
    DialogField         dialogUpdate;
    DialogField         dialogTaxPeriod;
    DialogField         dialogFromDate;
    DialogField         dialogVersion;
    DialogField         dialogTransDate;
    DialogField         dialogFileName;
    DialogField         dialogPrintReport;

    NoYes               isPreview;
    NoYes               batchScheduled;
    boolean             legacyLaunch;

    NoYes               printout;
    LedgerVoucher       ledgerVoucher;
    VendAccount         vendAccount;
    NumberSeq           numberSeq;
    TaxPeriodDate       toDate;
    Voucher             voucher;
    TaxReportPeriod     taxReportPeriod;

    LedgerPostingController ledgerPostingController;

    TaxPurchaseTaxPost  taxPurchaseTaxPost;

    Counter             transactions;
    Counter             taxTransactions;
    CurrencyCode        lastCurrencyCode;

    TaxAmount           taxAmountSales;
    TaxAmount           taxAmountPurchase;
    TaxAmount           taxAmountUseTax;
    TaxAmount           totalClearingAmount;
    TaxAmount           totalClearingAmountTaxAuthorityCur;
    TaxAmount           totalClearingAmountMST;
    TaxAmount           totalClearingAmountRep;
    TaxAmount           taxAmountRoundingDelta;

    Map currencyExchRateGainAmtMap = new Map(Types::String, Types::Container);
    Map currencyExchRateLossAmtMap = new Map(Types::String, Types::Container);

    FormBuildFunctionButtonControl  settlementAccountButton;
    LedgerDimensionAccount          settlementAccount;
    DialogRunbase                   dialogCopy;

    LedgerDimensionAccount          taxClearingLedgerDimension;

    NoYes                           usePublicSectorDistributedPosting; // Post UseTax payable by distributed dimensions.

    TaxReportVersionEnumComboBox    taxReportVersionEnumComboBox;

    LedgerDimensionAccount          taxInCostPriceLedgerDimension;

    int                             totalTaxTransSettled;
    boolean                         isGenOffsetTaxTransPerRecordSetEnabled;
    boolean                         isTaxCurrencyConversionFeatureEnabled;

    [SysObsolete('The Sales tax payment performance improvement has been deprecated.', true, 24\06\2024)]
    boolean                         isCombineExcRateGainLossVoucherFeatureEnabled;

    protected boolean               isPopulateDimensionForExchGainLossAccount;
    private boolean                 isApplyReportAdjustmentToSettlementPeriodEnabled;
    private boolean                 isTaxBankExchangeRateDifferenceFlightingEnabled;
    private boolean                 isTaxBankExchangeRateDifferenceV2FlightEnabled;
    boolean                         isTaxCurrencyConversionPathRep;
    TaxCurConvPath                  taxCurrencyConversionPath;
    CurrencyCode                    reportingCurrencyCode;

    RefRecId                        taxTransOffsetRecId;

    LedgerDimensionBase             gainLedgerDimension;
    LedgerDimensionBase             lossLedgerDimension;

    private LedgerDimensionDefaultAccount gainMainAccount;
    private LedgerDimensionDefaultAccount lossMainAccount;

    boolean                         isMultipleTaxIdEnabled;

    #ISOCountryRegionCodes
    // <GIN>
    DialogField                     dialogTaxRegistrationGroupName;
    DialogField                     dialogTaxRegistrationNumber;
    DialogField                     dialogPostToInterimPLA;

    TaxReportPeriod_IN              taxReportPeriodRegistrationNum;
    RefRecId                        taxRegistrationGroupName;
    RefRecId                        taxRegistrationGroupCopy;
    RefRecId                        taxRegistrationNumber;
    TaxAuthorityAddress             taxAuthorityAddress;

    NoYes                           postToInterimPLA;
    TransDate                       taxRegistrationDate;
    boolean                         isIndirectTax;
    boolean                         isCorrections;
    container                       taxAmounts;
    boolean                         inUse;
    boolean                         instanceInUse;
    boolean                         previousTransaction;
    boolean                         isPostedTransactionCurrencyTheSame = true;

    boolean                         countryRegion_IN;
    // </GIN>

    boolean                         countryRegion_IT;
    boolean                         countryRegion_MX;
    TaxParameters                   taxParametersLocal;
    CurrencyCode                    companyStandardCurrency;

    NoYes bankExchRate;
    boolean isTaxPostOffsetTransForTaxAdjDueToBankExRateEnabled; // TaxPostOffsetTransForTaxAdjDueToBankExRate flighting has been removed from 10.0.18

    // for collecting runtime info starts:
    int64 processedCount;
    int64 totalCount;
    int64 postedV2Count;
    int64 postedV2UseTaxCount;
    str processMessage;
    str sqlStatement;
    boolean isTaxSettlementStateCollectionFlightEnabled;
    private boolean isTaxSettlementNegativeFactorFlightEnabled;
    // for collecting runtime info ends.

    protected boolean isTaxReportPerfImprovByVoucherTransCombineFlightEnabled;
    protected boolean isNotGenerateOffsetTaxTrans;
    protected boolean isTaxReportCombineVoucherForGainLoss;
    protected TaxReportVoucherTransCombine taxReportVoucherTransCombine;

    #define.CurrentVersion(6)
    #localMacro.CurrentList
        updateNow,
        taxPeriod,
        fromDate,
        taxRepVersion,
        transactionDate,
        settlementAccount,
        printout,
        toDate,
        voucher,
        vendAccount,
        taxAmountSales,
        taxAmountPurchase,
        taxAmountUseTax,
        totalClearingAmount,
        taxReportPeriod
        // <GIN>
        ,taxRegistrationGroupName,
        taxRegistrationNumber,
        postToInterimPLA,
        taxRegistrationDate
        // </GIN>
        ,fileName
    #endMacro

    #LOCALMACRO.TaxTransWhereClause
        taxTrans.TaxPeriod       ==  taxPeriod
        && taxTrans.TransDate      >= _fromDate
        && taxTrans.TransDate      <= _toDate
        && taxTrans.TaxRepCounter  >= _versionMin
        && taxTrans.TaxRepCounter  <= _versionMax
        && taxTrans.Source         != TaxModuleType::Tax
        && (taxTrans.TaxAmountCur
            || (bankExchRate && taxTrans.TaxAmount)
            || taxTrans.TaxBaseQty
            || taxTrans.TaxBaseAmount
            || taxTrans.TaxBaseAmountCur
            || taxTrans.TaxInCostPrice
            || taxTrans.TaxInCostPriceMST
            || taxTrans.TaxInCostPriceCur)
    #ENDMACRO

    // This bool value is to indicate whether child class overrides updateAndPostTaxTrans method,
    // if yes, then it is possible that the logic to set taxInCostPriceLedgerDimension in updateAndPostTaxTrans could not exist.
    // Child class needs to make sure set taxInCostPriceLedgerDimension in override updateAndPostTaxTrans method and set taxInCostPriceLedgerDimension to false.
    // Or else, the consumption code of taxInCostPriceLedgerDimension will use the original code to retrive tax in cost price ledger dimension.
    boolean overridenForMethodUpdateAndPostTaxTrans = true;

    /// <summary>
    /// Date from which there is new type of report for Norwegian tax report.
    /// </summary>
    public const date NorwegianNewTaxReportCheckpoint = 1\1\2017;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canDisplayReport</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines if the report should be generated.
    /// </summary>
    /// <returns>
    ///   true if the report should be generated; otherwise, false.
    /// </returns>
    public boolean canDisplayReport()
    {
        // only try to print the report if we are not currently in batch processing and multipleTaxId feature is not enabled or mulitpleTaxId feature is enabled but user click preview tax settleement report button.
        boolean skipDisplayReportWhenSettle = !isPreview && !printReport;
        return printout
            && !skipDisplayReportWhenSettle
            && !this.isInBatch()
            && (!isMultipleTaxIdEnabled
                || (isMultipleTaxIdEnabled && !updateNow));
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatch</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if this class can be executed in batch.
    /// </summary>
    /// <returns>
    ///    True if can run this class in batch; otherwise false.
    /// </returns>
    /// <remarks>
    ///    This method must be in this class because it is called from the <c>DialogRunBase</c> class.
    /// </remarks>
    public boolean canGoBatch()
    {
        // <GIN>
        // Indian settlement does not support batch processing.
        if (countryRegion_IN)
        {
            return false;
        }
        else
        {
            // </GIN>
            return !this.parmIsPreview();
            // <GIN>
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsPreview</Name>
				<Source><![CDATA[
    /// <summary>
    /// Has the dialog been launched from the preview menu item.
    /// If true this likely means the process cannot be run in batch.
    /// </summary>
    /// <param name = "_isPreview">Is the dialog in preview mode.</param>
    /// <returns>True if the dialog has been launched from the preview menu item; otherwise, false.</returns>
    protected NoYes parmIsPreview(NoYes _isPreview = isPreview)
    {
        isPreview = _isPreview;
        return isPreview;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExciseType_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the tax type is Excise for given parameter.
    /// </summary>
    /// <param name="_taxRegistrationNumber">
    /// The tax registration number is used to find record.
    /// </param>
    /// <returns>
    /// Returns ture, if the tax type is Excise; otherwise, false.
    /// </returns>
    boolean checkExciseType_IN(RefRecId  _taxRegistrationNumber)
    {
        boolean         ret;

        TaxRegistrationGroupSetup_IN    taxRegistrationGroupSetup;

        select RecId, TaxType from taxRegistrationGroupSetup
            where taxRegistrationGroupSetup.TaxRegistrationNumberTable == _taxRegistrationNumber;

        if (taxRegistrationGroupSetup)
        {
            if (taxRegistrationGroupSetup.TaxType == TaxTypeRegistrationGroup_IN::Excise)
            {
                ret = true;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxAuthorityDefaultDimension</Name>
				<Source><![CDATA[
    private boolean checkTaxAuthorityDefaultDimension()
    {
        VendAccount authorityVend = TaxAuthorityAddress::find(TaxPeriodHead::find(taxPeriod).TaxAuthority).AccountNum;
        if (authorityVend)
        {
            VendTable vendTable = VendTable::find(authorityVend);
            if (vendTable.DefaultDimension == 0 && LedgerInterunitBalancer::isBalancingEnabled())
            {
                return checkFailed(strFmt('@Tax:DimensionMissing', vendTable.AccountNum));
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForUpdate</Name>
				<Source><![CDATA[
    boolean checkForUpdate()
    {
        if (updateNow)
        {
            if (taxRepVersion == TaxRepVersion::Total ||
                taxRepVersion == TaxRepVersion::Correct)
                return checkFailed("@SYS25890");

            if (taxRepVersion == TaxRepVersion::Original &&
                taxReportPeriod.VersionNum > 0)
                return checkFailed("@SYS25891");
            if (taxRepVersion == TaxRepVersion::Latest &&
                taxReportPeriod.VersionNum == 0)
                return checkFailed("@SYS62062");
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForUpdate_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether can be updated.
    /// </summary>
    /// <returns>
    /// Returns ture, if can be updated; otherwise, false.
    /// </returns>
    boolean checkForUpdate_IN()
    {
        if (updateNow)
        {
            if (taxRepVersion == TaxRepVersion::Total ||
                taxRepVersion == TaxRepVersion::Correct)
                return checkFailed("@SYS25890");

            if (taxRepVersion == TaxRepVersion::Original &&
                taxReportPeriodRegistrationNum.VersionNum > 0)
                return checkFailed("@GLS6235");

            if (taxRepVersion == TaxRepVersion::Latest &&
                taxReportPeriodRegistrationNum.VersionNum == 0)
                return checkFailed("@SYS62062");
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxType_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax type.
    /// </summary>
    /// <returns>
    /// Returns the tax type, if exist record; otherwise, null.
    /// </returns>
    TaxType_IN checkTaxType_IN()
    {
        TaxTable                        taxTableloc;
        TaxRegistrationNumbers_IN   taxRegistrationNumberTableloc;
        TaxRegistrationGroupSetup_IN    taxRegistrationGroupSetuploc;

        select TaxType_IN from taxTableloc
            where taxTableloc.TaxPeriod   ==  taxPeriod
        exists join taxRegistrationNumberTableloc
            where taxRegistrationNumberTableloc.TaxType == taxTableloc.TaxType_IN
               && taxRegistrationNumberTableloc.RecId   == taxRegistrationNumber
        exists join taxRegistrationGroupSetuploc
            where taxRegistrationGroupSetuploc.TaxRegistrationNumberTable == taxRegistrationNumberTableloc.RecId
               && taxRegistrationGroupSetuploc.TaxRegistrationGroupName == taxRegistrationGroupName;

        return taxTableloc.TaxType_IN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runDialogParametersAndParseArgs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Launches the dialog to take the initial parameters for <c>TaxReport</c>.
    /// </summary>
    /// <param name="_args"><c>Args</c> class instance.</param>
    /// <remarks>
    /// This method should be used instead of directly calling <c>prompt</c>.
    /// </remarks>
    /// <returns>
    /// True if ok was clicked; Otherwise, false.
    /// </returns>
    public boolean runDialogParametersAndParseArgs(Args _args)
    {
        this.evaluateArgs(_args);
        BatchInfo batchInformation = this.batchInfo();
        batchInformation.fieldBatchExecuteValue(false);
        batchInformation.parmBatchExecute(NoYes::No);

        return this.prompt();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPostRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Code to execute after the dialog is generated to modify controls.
    /// </summary>
    /// <param name="_dialog"><c>DialogRunbase</c> class instance.</param>
    public void dialogPostRun(DialogRunbase _dialog)
    {
        if (!this.parmLegacyLaunch())
        {
            if (dialogUpdate)
            {
                dialogUpdate.value(!this.parmIsPreview());
                dialogUpdate.visible(false);
                // <ITA>
                if (dialogFileName)
                {
                    dialogFileName.enabled(this.canFileNameControlBeEnabled());
                }
                // </ITA>
            }

            if (dialogTransDate && this.parmIsPreview())
            {
                dialogTransDate.visible(false);
            }
        }

        if (dialogVersion != null)
        {
            FormComboBoxControl versionComboBox = dialogVersion.control();
            // If the class was launched by a legacy system or the class was launched to print the report
            // create the TaxReportVersionEnumComboBox with all TaxRepVersion options. The dialogVersion
            // control will be updated to be in sync with the taxReportVersionEnumComboBox.
            if (this.parmLegacyLaunch() || this.parmIsPreview())
            {
                taxReportVersionEnumComboBox = TaxReportVersionEnumComboBox::createNewInstance(_dialog.formRun(), versionComboBox.id(), TaxReportVersionEnumComboBox::taxReportVersionValuesSet());
            }
            // If the class was launched by a non-legacy system and was launched to settle the tax period
            // create the TaxReportVersionEnumComboBox with only Original and Latest TaxRepVersion options.
            // The dialogVersion control will be updated to be in sync with the taxReportVersionEnumComboBox.
            else
            {
                taxReportVersionEnumComboBox = TaxReportVersionEnumComboBox::createNewInstance(_dialog.formRun(), versionComboBox.id(), TaxReportVersionEnumComboBox::taxReportVersionSettlementValuesSet());
            }
        }

        _dialog.batchDialogTabPageVisible(false);

        super (_dialog);

        if (taxPeriod && TaxReport::isDifferentCurrencyBetweenTaxCodeAndAuthority(taxPeriod))
        {
            warning("@Tax:DifferentCurrencyBetweenTaxCodeAndAuthority");
        }

        if (isApplyReportAdjustmentToSettlementPeriodEnabled)
        {
            this.setDialogFieldStateByTaxPeriodAdjustment(TaxPeriodHead::find(taxPeriod), _dialog);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the header of this dialog.
    /// </summary>
    /// <returns>
    /// Returns the header of this dialog.
    /// </returns>
    protected Caption dialogHeader()
    {
        str header = "@Tax:TaxReportSettle";

        if (this.parmIsPreview())
        {
            header = "@Tax:TaxReportPreview";
        }

        return header;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    ///    interface.
    /// </summary>
    /// <returns>
    ///    A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog can be either built by using the <c>Dialog</c> class or by using a class that is created
    ///    in the Application Object Tree (AOT).
    /// </remarks>
    Object dialog()
    {
        DialogRunbase dialog = new DialogRunbase(this.dialogHeader(), this);

        updateNow = false;

        // <GIN>
        if (countryRegion_IN)
        {
            dialogTaxRegistrationGroupName  = dialog.addField(extendedTypeStr(TaxRegistrationGroupNameRecID_IN));
            dialogTaxRegistrationNumber     = dialog.addField(extendedTypeStr(TaxRegistrationNumberRecId_IN));

            dialogTaxRegistrationNumber.control().registerOverrideMethod(
                methodStr(FormInt64Control, lookup),
                methodStr(TaxReport, dialogTaxRegistrationNumber_lookup),
                this);
        }
        // </GIN>

        dialogTaxPeriod = dialog.addFieldValue(extendedTypeStr(TaxPeriod), taxPeriod);
        dialogTaxPeriod.control().registerOverrideMethod(
            methodStr(FormStringControl, modified),
            methodStr(TaxReport, dialogTaxPeriod_modified),
            this);
        countryRegion_IT = MultipleTaxIdReportingHelper::isLegalEntityOrTaxPeriodInCountryRegion(
            taxPeriod, [#isoIT], MultipleTaxIdScope::VATDeclaration);

        // <GIN>
        if (countryRegion_IN)
        {
            dialogFromDate  = dialog.addField(extendedTypeStr(TaxPeriodDate), "@SYS7402", "@SYS12292");
        }
        else
        {
            // </GIN>
            dialogFromDate  = dialog.addField(extendedTypeStr(TaxPeriodDate), "@SYS5209", "@SYS12292");
            // <GIN>
        }
        // </GIN>

        dialogFromDate.control().registerOverrideMethod(
            methodStr(FormDateControl, modified),
            methodStr(TaxReport, dialogFromDate_modified),
            this);

        dialogFromDate.control().mandatory(true);

        dialogTransDate =  dialog.addFieldValue(extendedTypeStr(TransDate), DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), "@SYS67", "@SYS60729");
        dialogTransDate.control().registerOverrideMethod(
            methodStr(FormDateControl, modified),
            methodStr(TaxReport, dialogTransDate_modified),
            this);

        dialogVersion   = dialog.addField(enumStr(TaxRepVersion), "" ,"@SYS25691");

        // <GIN>
        if (countryRegion_IN)
        {
            if (taxParametersLocal.Excise_IN)
            {
                dialogPostToInterimPLA  = dialog.addField(enumStr(NoYes), "@GLS6226", "@GLS6260");
            }
        }
        // </GIN>

        dialogUpdate    = dialog.addField(enumStr(NoYes), "@SYS98424", "@SYS17200");

        dialogPrintReport = dialog.addFieldValue(
            enumStr(NoYes),
            printReport,
            "@Tax_ReportSalesTaxForSettlementPeriod:PrintReport",
            "@Tax_ReportSalesTaxForSettlementPeriod:PrintReportHelpText");
        this.updatePrintReportControl(taxPeriod);

        // <ITA>
        if (MultipleTaxIdReportingHelper::isLegalEntityOrAddressInCountryRegion([#isoIT], MultipleTaxIdScope::VATDeclaration))
        {
            dialog.filenameLookupFilter(['', '*.pdf']);
            dialogFileName = dialog.addFieldValue(extendedTypeStr(ERFileName), fileName);
            dialogFileName.enabled(this.canFileNameControlBeEnabled());
            dialogUpdate.control().registerOverrideMethod(
                methodStr(FormCheckBoxControl, modified),
                methodStr(TaxReport, dialogUpdate_modified),
                this);
            dialogPrintReport.control().registerOverrideMethod(
                methodStr(FormCheckBoxControl, modified),
                methodStr(TaxReport, dialogUpdate_modified),
                this);

            dialogFileName.visible(this.isDialogFileNameVisible(taxPeriod));
        }
        // </ITA>

        // <BEL>
        this.dialogSettlementAccountMenuItem(dialog);
        // </BEL>

        dialog.allowUpdateOnSelectCtrl(true);

        dialogCopy = dialog;

        this.dialogSelectCtrl();

        dialog.addText("@TaxReport:EnableBatchModeMessage", 175);

        // <GIN>
        if (countryRegion_IN)
        {
            dialog.addMenuItemButton(MenuItemType::Display, menuitemDisplayStr(TaxSalesTaxPayment_IN), DialogMenuItemGroup::RightGrp);
            dialog.addMenuItemButton(MenuItemType::Display, menuitemDisplayStr(TaxRegistrationGroup_IN), DialogMenuItemGroup::RightGrp);
        }
        // </GIN>

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogSelectCtrl</Name>
				<Source><![CDATA[
    public void dialogSelectCtrl()
    {
        FormBuildControl    curformBuildControl;
        FormControl         curformControl;

        super();

        // The control can be a build or a run type. If the control is of FormFunctionButtonControl type
        // we cast it to FormBuildFunctionButtonControl.
        curformBuildControl = dialogCopy.dialogForm().control('MnuItm_1') as FormBuildControl;
        if (!curformBuildControl)
        {
            curformControl = dialogCopy.dialogForm().control('MnuItm_1');
            curformBuildControl = dialogCopy.formRun().form().design().control(curformControl.name());
        }

        settlementAccountButton = curformBuildControl;
        settlementAccountButton.visible(false);

        // <GIN>
        if (TaxParameters::isExciseEnable_IN())
        {
            taxRegistrationGroupName  = dialogTaxRegistrationGroupName.value();

            if (this.checkExciseType_IN(dialogTaxRegistrationNumber.value()))
            {
                dialogPostToInterimPLA.enabled(true);
            }
            else
            {
                dialogPostToInterimPLA.value(0);
                dialogPostToInterimPLA.enabled(false);
            }

            if (taxRegistrationGroupName &&
                TaxRegistrationGroup_IN::find(taxRegistrationGroupName).InUse)
            {
                instanceInUse = true;
                throw error("@GLS6277");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogSettlementAccountMenuItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the menu item for a settlement account for the Belgium tax report layout to the dialog window.
    /// </summary>
    /// <param name="_dialog">
    ///    The dialog window to which fields will be added.
    /// </param>
    protected void dialogSettlementAccountMenuItem(Dialog _dialog)
    {
        _dialog.addMenuItemButton(MenuItemType::Display, menuitemDisplayStr(TaxReportSelectSettlementAccount), DialogMenuItemGroup::RightGrp);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogUpdate_modified</Name>
				<Source><![CDATA[
    private boolean dialogUpdate_modified(FormCheckBoxControl _previousDialogUpdateControl)
    {
        boolean ret;

        ret = _previousDialogUpdateControl.modified();

        if (ret)
        {
            dialogFileName.enabled(this.canFileNameControlBeEnabled());
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canFileNameControlBeEnabled</Name>
				<Source><![CDATA[
    private boolean canFileNameControlBeEnabled()
    {
        return dialogUpdate.value() && dialogPrintReport.value();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogTaxPeriod_modified</Name>
				<Source><![CDATA[
    protected boolean dialogTaxPeriod_modified(FormStringControl _formStringControl)
    {
        boolean ret;

        ret = _formStringControl.modified();

        if (ret)
        {
            TaxReportPeriod taxReportPeriodLoc = TaxReportPeriod::find(_formStringControl.valueStr(), dialogFromDate.value());
            countryRegion_IT = MultipleTaxIdReportingHelper::isLegalEntityOrTaxPeriodInCountryRegion(
                _formStringControl.valueStr(), [#isoIT], MultipleTaxIdScope::VATDeclaration);

            this.updatePrintReportControl(_formStringControl.valueStr());

            if (isApplyReportAdjustmentToSettlementPeriodEnabled)
            {
                this.setDialogFieldStateByTaxPeriodAdjustment(TaxPeriodHead::find(_formStringControl.valueStr()));
            }

            if (taxReportPeriodLoc)
            {
                dialogTransDate.value(taxReportPeriodLoc.ToDate);
            }
            else
            {
                select firstonly ToDate from taxReportPeriodLoc;
                dialogTransDate.value(taxReportPeriodLoc.ToDate);
            }

            if (TaxReport::isDifferentCurrencyBetweenTaxCodeAndAuthority(_formStringControl.valueStr()))
            {
                warning("@Tax:DifferentCurrencyBetweenTaxCodeAndAuthority");
            }

            if (dialogFileName)
            {
                dialogFileName.visible(this.isDialogFileNameVisible(_formStringControl.valueStr()));
                dialogFileName.enabled(this.canFileNameControlBeEnabled());
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDialogFieldStateByTaxPeriodAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set related dialog fields' state by the tax period's report adjustment.
    /// </summary>
    /// <param name = "_taxPeriodHead">
    /// The record of <c>TaxPeriodHead</c> holds ReportAdjustment which indicates that dialog fields' state should be changed.
    /// </param>
    /// <param name = "_dialog">
    /// The _dialog is the instance of the <c>DialogRunbase</c> which holds all dialog fields' state.
    /// </param>
    private void setDialogFieldStateByTaxPeriodAdjustment(TaxPeriodHead _taxPeriodHead, DialogRunbase _dialog = dialogCopy)
    {
        boolean isReportAdjustmentEnabled = TaxIntegrationUtils::isReportAdjustmentEnabled(_taxPeriodHead);

        str header = isReportAdjustmentEnabled ? "@SYS65243" : this.dialogHeader();
        if (_dialog)
        {
            _dialog.formRun().design().caption(header);
        }

        if (dialogVersion)
        {
            dialogVersion.visible(!isReportAdjustmentEnabled);
        }

        if (dialogFromDate)
        {
            dialogFromDate.control().mandatory(!isReportAdjustmentEnabled);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogFromDate_modified</Name>
				<Source><![CDATA[
    protected boolean dialogFromDate_modified(FormDateControl _formDateControl)
    {
        boolean ret;

        ret = _formDateControl.modified();

        if (ret)
        {
            TaxReportPeriod taxReportPeriodLoc = TaxReportPeriod::find(dialogTaxPeriod.value(), str2Date(_formDateControl.valueStr(), 321));
            if (taxReportPeriodLoc)
            {
                dialogTransDate.value(taxReportPeriodLoc.ToDate);
            }
            else
            {
                select firstonly ToDate from taxReportPeriodLoc;
                dialogTransDate.value(taxReportPeriodLoc.ToDate);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogTransDate_modified</Name>
				<Source><![CDATA[
    protected boolean dialogTransDate_modified(FormDateControl _formDateControl)
    {
        boolean ret;

        ret =_formDateControl.modified();

        if(ret)
        {
            TransDate dateTransDate = str2Date(_formDateControl.valueStr(), 321);

            TransDate dialogFromDateVal = dialogFromDate.value();

            if (dialogFromDateVal == dateNull())
            {
                warning('@TaxAdvancedSalesTaxPayment:Tax_Message_Validation_CheckFromDate');
            }
            else
            {
                TaxReportPeriod taxReportPeriodLoc = TaxReportPeriod::find(dialogTaxPeriod.value(), dialogFromDateVal);

                if (dateTransDate < taxReportPeriodLoc.FromDate || dateTransDate > taxReportPeriodLoc.ToDate)
                {
                    warning('@TaxAdvancedSalesTaxPayment:Tax_Message_Validation_CheckTransDate');
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fromDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows the fromDate variable.
    /// </summary>
    /// <returns>
    ///    The fromDate variable.
    /// </returns>
    StartDate fromDate()
    {
        return fromDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrintReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the printReport variable.
    /// </summary>
    /// <param name="_printReport">
    ///    The print report option; optional.
    /// </param>
    /// <returns>The printReport variable.</returns>
    public NoYes parmPrintReport(NoYes _printReport = printReport)
    {
        printReport = _printReport;
        return printReport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDialogValues</Name>
				<Source><![CDATA[
    void getDialogValues(NoYes           _updateNow,
                         TaxPeriod       _taxPeriod,
                         TaxPeriodDate   _fromDate,
                         TransDate       _transactionDate)
    {
        throw error(strFmt("@SYS18885", funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBatchScheduled</Name>
				<Source><![CDATA[
    protected NoYes parmBatchScheduled(NoYes _batchScheduled = batchScheduled)
    {
        batchScheduled = _batchScheduled;
        return batchScheduled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBatchScheduled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns whether or not the current instance of the <c>TaxReport</c> class has been scheduled to batch.
    /// </summary>
    /// <returns>Returns Yes if the current instance of the class has been scheduled to batch; otherwise No.</returns>
    public NoYes isBatchScheduled()
    {
        return this.parmBatchScheduled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Configures and schedules batch.
    /// </summary>
    /// <returns>
    /// true if the run method should be called, or false if the run method has been scheduled to batch.
    /// </returns>
    public boolean canRunBatch()
    {
        NoYes useBatch = NoYes::No;
        TaxPeriodHead taxPeriodHead = TaxPeriodHead::find(this.taxPeriod());
        if (taxPeriodHead)
        {
            useBatch = taxPeriodHead.UseBatch;
        }

        // skip batch when only printing the report.
        if (!this.parmIsPreview() && this.canGoBatch() && useBatch)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Schedule this instance of the <c>TaxReport</c> class to the batch framework.
    /// </summary>
    public void runBatch()
    {
        BatchHeader batch = this.initializeBatch();
        batch.save();
        this.parmBatchScheduled(NoYes::Yes);
        info(strFmt("@SYS73254", batch.parmCaption()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Configure how to retrieve data from the dialog.
    /// </summary>
    /// <returns>true if get from dialog; otherwise false.</returns>
    public boolean getFromDialog()
    {
        updateNow         = dialogUpdate.value();
        taxPeriod         = dialogTaxPeriod.value();
        fromDate          = dialogFromDate.value();
        taxRepVersion     = taxReportVersionEnumComboBox.selection();
        transactionDate   = dialogTransDate.value();
        printReport       = dialogPrintReport.value();
        this.parmIsPreview(!updateNow);

        // <GIN>
        if (countryRegion_IN)
        {
            if (TaxParameters::find().Excise_IN)
            {
                postToInterimPLA              = dialogPostToInterimPLA.value();
            }
        }
        // </GIN>
        // <BEL>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBE]))
        {
            settlementAccount = this.parmSettlementAccount();
        }
        // </BEL>
        // <ITA>
        if (dialogFileName
            && dialogFileName.fieldControl().visible()
            && dialogFileName.fieldControl().enabled())
        {
            fileName      = dialogFileName.value();
        }
        // </ITA>
        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionForTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the ledger dimension for the <c>TaxTrans</c> of the provided tax relationship type.
    /// </summary>
    /// <param name="_taxTrans">
    /// The <c>TaxTrans</c> record to find the ledger dimension for.
    /// </param>
    /// <param name="_taxTransRelationshipType">
    /// The tax relationship for the ledger dimension.
    /// </param>
    /// <param name="_accountingDistribution">
    /// The accounting distribution related to the <c>TaxTrans</c> record.
    /// </param>
    /// <returns>
    /// The ledger dimension for the <c>TaxTrans</c> record.
    /// </returns>
    private LedgerDimensionAccount getLedgerDimensionForTaxTrans(TaxTrans                   _taxTrans,
                                                                 TaxTransRelationshipType   _taxTransRelationshipType,
                                                                 AccountingDistribution     _accountingDistribution = null)
    {
        LedgerDimensionAccount  ledgerDimension;
        ledgerDimension = TaxTransGeneralJournalAccountEntry::getLedgerDimensionForTaxTrans(_taxTrans.RecId, _taxTransRelationshipType, _accountingDistribution);

        if (!ledgerDimension && _taxTransRelationshipType == TaxTransRelationshipType::Tax)
        {
            ledgerDimension = TaxTransGeneralJournalAccountEntry::getLedgerDimensionForTaxTrans(_taxTrans.RecId, TaxTransRelationshipType::TaxInCostPrice, _accountingDistribution);

            if (!ledgerDimension)
            {
                ledgerDimension = this.getLedgerDimensionForTaxTransCashDisc(_taxTrans);
            }
        }
        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionForTaxTransCashDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the cash discount ledger dimension for the <c>TaxTrans</c>.
    /// </summary>
    /// <param name="_taxTrans">
    /// The <c>TaxTrans</c> record to find the ledger dimension for.
    /// </param>
    /// <returns>
    /// The ledger dimension for the <c>TaxTrans</c> record.
    /// </returns>
    private LedgerDimensionAccount getLedgerDimensionForTaxTransCashDisc(TaxTrans _taxTrans)
    {
        LedgerDimensionAccount      ledgerDimension;
        GeneralJournalEntry         generalJournalEntry;
        GeneralJournalAccountEntry  generalJournalAccountEntry;

        if (_taxTrans.TaxOrigin == TaxOrigin::CashDisc
            && !TaxRemoveFindLedgerDimensionForTaxTransCashDiscFlight::instance().isEnabled())
        {
            select firstonly ledgerDimension from generalJournalAccountEntry
                    where generalJournalAccountEntry.AccountingCurrencyAmount == _taxTrans.TaxBaseAmount + _taxTrans.TaxAmount
                exists join RecId from generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                        && generalJournalEntry.SubledgerVoucher == _taxTrans.Voucher
                        && generalJournalEntry.AccountingDate == _taxTrans.TransDate
                        && generalJournalEntry.Ledger == Ledger::current();

            ledgerDimension = generalJournalAccountEntry.LedgerDimension;
        }

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>gtaInterimAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets gta interim amount.
    /// </summary>
    /// <param name="_taxComponent">
    /// The tax component.
    /// </param>
    /// <returns>
    /// The GTA interim recoverable amount for tax component.
    /// </returns>
    public TaxAmount gtaInterimAmount_IN(RefRecId  _taxComponent)
    {
        TaxTrans_IN                     taxTransLoc;
        TaxTrans                        taxTrans;
        real                            isPaymPartial=1;
        TaxTrans_W                      taxTrans_W;
        ComponentTransactions_IN        componentTransactions;
        PurchLine                       purchLineLoc;
        TaxTrans                        taxTransActualAC; // TaxTrans of P or R.
        TaxTrans_W                      taxTransRev_W;
        TaxItemGroupHeading             taxItemGroupHeadingRev;
        VendTrans                       vendTransloc;
        VendTrans                       vendTransRev;
        boolean                         isAccruePayableAtInvoicing = false;
        TaxAmount                       gtaInterimRecoverableAmount = 0;

        while select componentTransactions
            where componentTransactions.Mark              == NoYes::Yes
               && componentTransactions.TaxComponentTable == _taxComponent
               && componentTransactions.LedgerVoucher     == voucher
                && componentTransactions.TaxType          == TaxType_IN::ServiceTax
        {
            select InvoiceRefRecID from taxTransLoc
                where taxTransLoc.RefRecId == componentTransactions.TransRecid;

            select taxTrans
                where taxTrans.RecId                == taxTransLoc.InvoiceRefRecID
                   && taxTrans.TaxDirection         == TaxDirection::IncomingTax
                exists join taxTrans_W
                   where taxTrans_W.TaxTrans == taxTrans.RecId
                    &&  taxTrans_W.TaxComponentTable_IN == _taxComponent;

            // Dealing with Reverse Charge - BEGIN
            select firstonly taxTransActualAC
                where taxTransActualAC.RecId == componentTransactions.TransRecid;
            isAccruePayableAtInvoicing = TaxItemGroupHeading::isAccruePayableAtInvoicing_IN(taxTransActualAC.TaxItemGroup);
            if (taxTransActualAC.taxTrans_W().ServiceTaxReverseChargePercentage_IN)
            {
                // For reverse charge, the creation of related voucehr is based on IP, rather than legacy IR based on new requirement.
                // So direction shud be outgoing.
                select firstonly RecId from taxTransRev_W
                    where taxTransRev_W.TaxTransRefRecId_IN   == taxTransActualAC.RecId
                        && taxTransRev_W.TaxType_IN           == TaxType_IN::ServiceTax
                        && taxTransRev_W.TaxComponentTable_IN == _taxComponent
                    join taxTrans
                        where taxTrans.RecId                  == taxTransRev_W.TaxTrans
                           && taxTrans.TaxDirection           == TaxDirection::OutgoingTax;
            }
            // Dealing with Reverse Charge - End

            //No GTA amount for foreign vendor
            purchLineLoc = PurchLine::findInventTransId(taxTrans.InventTransId);
            if (purchLineLoc.purchTable().vendTable_InvoiceAccount().isForeign() &&
                purchLineLoc.purchTable().purchTable_W().CustomsImportOrder_IN)
            {
                continue;
            }

            if (taxTrans)
            {
                taxItemGroupHeadingRev = TaxItemGroupHeading::find(taxTrans.TaxItemGroup);
                if (taxItemGroupHeadingRev.ReverseChargePercentage_IN != 0)
                {
                    vendTransloc = VendTrans::findVoucherDate(taxTrans.voucher, taxTrans.TransDate); //Invoice time record.
                    select sum(SettleAmountMST) from vendTransRev //Payment time record, summing up of multiple payments made if any, for single invoice.
                       where vendTransRev.LastSettleVoucher == taxTrans.voucher;
                    //Check if the 'Interim Recoverable' of invoice is fully reversed.
                    //If the sum of multiple payments made to settle an invoice is less than invoice amount, the IR of invoice will not be fully reversed.
                    //The factor 'isPaymPartial' should be calculated only if the IR is not fully reversed.
                    if (abs(vendTransRev.SettleAmountMST) < abs(vendTransLoc.AmountMST))
                    {
                        isPaymPartial = this.isGTAPartialPaym_IN(taxTrans, componentTransactions);
                    }
                }
                else
                {
                    isPaymPartial = this.isGTAPartialPaym_IN(taxTrans, componentTransactions);
                }
            }

            gtaInterimRecoverableAmount += (taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST) * isPaymPartial * (isAccruePayableAtInvoicing ? -1 : 1);
        }

        return gtaInterimRecoverableAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCorrections_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the corrections.
    /// </summary>
    /// <returns>
    /// If 'True', the check is succeed.
    /// </returns>
    boolean  isCorrections_IN()
    {
        return isCorrections;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isGTAPartialPaym_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the GTA jpartial payment factor.
    /// </summary>
    /// <param name="_taxTransLoc">
    /// The tax transaction location.
    /// </param>
    /// <param name="_componentTransactions">
    /// The components of the transaction.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxAmount</c> class.
    /// </returns>
    public TaxAmount isGTAPartialPaym_IN(TaxTrans                       _taxTransLoc,
                                      ComponentTransactions_IN       _componentTransactions)
    {
        real factor = 1;

        if (_componentTransactions.PayableAmount != _taxTransLoc.TaxAmount&&
            _taxTransLoc.taxTrans_W().TaxType_IN == TaxType_IN::ServiceTax)
        {
            factor = abs(_componentTransactions.PayableAmount)/abs(_taxTransLoc.TaxAmount);
        }
        else
        {
            factor =  1;
        }

        return factor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        super();

        countryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        countryRegion_MX = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX]);

        isTaxCurrencyConversionFeatureEnabled = TaxCurrencyConversionFeatureExposure::isEnabledForTaxSettlement();
        isTaxCurrencyConversionPathRep = isTaxCurrencyConversionFeatureEnabled && taxCurrencyConversionPath == TaxCurConvPath::ReportingCurrency;
        isTaxBankExchangeRateDifferenceFlightingEnabled = FeatureStateProvider::isFeatureEnabled(TaxBankExchangeRateDifferenceFlighting::instance());
        isTaxBankExchangeRateDifferenceV2FlightEnabled = TaxBankExchangeRateDifferenceV2Flight::instance().isEnabled();

        isMultipleTaxIdEnabled = TaxIntegrationUtils::isMultipleTaxIdEnabledForTaxService();
        isApplyReportAdjustmentToSettlementPeriodEnabled = TaxIntegrationUtils::isApplyReportAdjustmentToSettlementPeriodEnabled();

        taxParametersLocal = TaxParameters::find();
        bankExchRate = taxParametersLocal.BankExchRate_W;
        isTaxPostOffsetTransForTaxAdjDueToBankExRateEnabled = true;

        if (isTaxCurrencyConversionFeatureEnabled)
        {
            taxCurrencyConversionPath = taxParametersLocal.TaxCurConvPath;
            reportingCurrencyCode = Ledger::reportingCurrency();
        }
        isTaxSettlementStateCollectionFlightEnabled = TaxSettlementStateCollectionFlight::instance().isEnabled();
        isTaxSettlementNegativeFactorFlightEnabled = TaxSettlementNegativeFactorFlight::instance().isEnabled();

        isTaxReportPerfImprovByVoucherTransCombineFlightEnabled = TaxReportPerfImprovByVoucherTransCombineFlight::instance().isEnabled();
        if (isTaxReportPerfImprovByVoucherTransCombineFlightEnabled)
        {
            taxReportVoucherTransCombine = new TaxReportVoucherTransCombine();
        }
        isNotGenerateOffsetTaxTrans = TaxPeriodHead::find(taxPeriod).NotGenerateOffsetTaxTrans;

        isTaxReportCombineVoucherForGainLoss = taxParametersLocal.TaxReportCombineVoucherForGainLoss;
        isPopulateDimensionForExchGainLossAccount = taxParametersLocal.TaxReportPopulateDimensionForGainLoss;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container packed = [#CurrentVersion, #CurrentList];
        packed = SysPackExtensions::appendVariableToPack(packed, classStr(TaxReport), varStr(printReport), printReport);

        return packed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFileName</Name>
				<Source><![CDATA[
    /// <summary>
    /// The file name to save the output data to in the Italy tax report.
    /// </summary>
    /// <param name = "_fileName">File name to save to.</param>
    /// <returns>the file name.</returns>
    public ERFileName parmFileName(ERFileName _fileName = fileName)
    {
        fileName = _fileName;

        return fileName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPreviousTransaction_IN</Name>
				<Source><![CDATA[
    public boolean parmPreviousTransaction_IN(boolean _previousTransaction = previousTransaction)
    {
        previousTransaction = _previousTransaction;

        return previousTransaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSettlementAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the <c>settlementAccount</c> field for the settlement account dimension.
    /// </summary>
    /// <param name="_settlementAccount">
    ///    The <c>settlementAccount</c> field that is set for Belgium.
    /// </param>
    /// <returns>
    ///    The <c>settlementAccount</c> field that is set.
    /// </returns>
    public LedgerDimensionDefaultAccount parmSettlementAccount(LedgerDimensionDefaultAccount _settlementAccount = settlementAccount)
    {
        settlementAccount = _settlementAccount;
        return settlementAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxAmounts_IN</Name>
				<Source><![CDATA[
    public container parmTaxAmounts_IN(container _taxAmounts = taxAmounts)
    {
        taxAmounts = _taxAmounts;

        return _taxAmounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxRepVersion</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets/Sets the <c>taxRepVersion</c> of the tax report.
    /// </summary>
    /// <param name="_taxRepVersion">
    ///    The tax report version; optional.
    /// </param>
    /// <returns>
    ///     The tax report version.
    /// </returns>
    public taxRepVersion parmTaxRepVersion(TaxRepVersion _taxRepVersion)
    {
        taxRepVersion = _taxRepVersion;
        return taxRepVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the ledger dimension with corresponding default dimension.
    ///    If vendor tax authority is available then default dimension is pulled from vendor tax authority
    ///    else the default dimension is pulled from settlement account set in 'Tax ledger posting group' form
    /// </summary>
    /// <param name="_taxCode">
    ///    The dialog window to which fields will be added.
    /// </param>
    /// <returns>
    ///    Returns the ledger dimension with default dimension.
    /// </returns>
    public LedgerDimensionAccount getDefaultLedgerDimension(TaxCode _taxCode)
    {
        LedgerDimensionAccount  ledgerDimensionAccount;
        LedgerDimensionAccount  mergedLedgerDimension;
        MainAccountLegalEntity  mainAccountLegalEntity;
        TaxAccountGroup         taxAccountGroup;
        TaxLedgerAccountGroup   taxLedgerAccountGroup;
        DimensionDefault        defaultDimension;

        if (vendAccount)
        {
            ledgerDimensionAccount = VendLedgerAccounts::summaryLedgerDimension(vendAccount);
            defaultDimension = VendTable::find(vendAccount).DefaultDimension;
        }
        else
        {
            taxAccountGroup = TaxTable::findAccountGroup(_taxCode);
            taxLedgerAccountGroup = TaxLedgerAccountGroup::find(taxAccountGroup);
            ledgerDimensionAccount = taxLedgerAccountGroup.TaxReportLedgerDimension;
            mainAccountLegalEntity = MainAccountLegalEntity::findByMainAccountLegalEntity(
                                        MainAccount::findByLedgerDimension(taxLedgerAccountGroup.TaxReportLedgerDimension).RecId, CompanyInfo::current());

            defaultDimension = mainAccountLegalEntity.DefaultDimension;
        }

        mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionAccount, defaultDimension);

        return mergedLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineLedgerDimensionDueToAccountStructureChange</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines the ledger dimension of the posting transaction if the account structure has changed.
    /// </summary>
    /// <param name="_taxLedgerDimension">
    ///    The ledger dimension of the tax transaction being settled.
    /// </param>
    /// <param name="_settleLedgerDimension">
    ///    The ledger dimension being used to settle the tax.
    /// </param>
    /// <param name="_taxOrigin">
    ///    The <c>TaxOrigin</c> of the tax transaction being settled.
    /// </param>
    /// <param name="_taxCode">
    ///    The tax code of the tax transaction being settled.
    /// </param>
    /// <param name="_ledgerVoucherTransObject">
    ///    The <c>LedgerVoucherTransObject</c> that contains the information to post the settling transaction.
    /// </param>
    /// <returns>
    ///     The ledger dimension account used to settle the tax transaction.
    /// </returns>
    private LedgerDimensionAccount determineLedgerDimensionDueToAccountStructureChange(
            LedgerDimensionAccount      _taxLedgerDimension,
            LedgerDimensionAccount      _settleLedgerDimension,
            TaxOrigin                   _taxOrigin,
            TaxCode                     _taxCode,
            LedgerVoucherTransObject    _ledgerVoucherTransObject)
    {
        LedgerDimensionAccount settleLedgerDimension;
        boolean skipDimensionsValidation;
        [skipDimensionsValidation, settleLedgerDimension] = this.getLedgerDimensionDueToAccountStructureChange(
            _taxLedgerDimension,
            _settleLedgerDimension,
            _taxOrigin,
            _taxCode);

        if (skipDimensionsValidation)
        {
            _ledgerVoucherTransObject.parmSkipDimensionValidation(true);
        }
        if (settleLedgerDimension != _settleLedgerDimension)
        {
            _ledgerVoucherTransObject.parmLedgerDimensionId(settleLedgerDimension);
        }
        return settleLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionDueToAccountStructureChange</Name>
				<Source><![CDATA[
    private container getLedgerDimensionDueToAccountStructureChange(
        LedgerDimensionAccount _taxLedgerDimension,
        LedgerDimensionAccount _settleLedgerDimension,
        TaxOrigin _taxOrigin,
        TaxCode _taxCode)
    {
        DimensionHierarchyId taxAccStructureRecId = DimensionAttributeValueCombination::find(_taxledgerDimension).AccountStructure;
        DimensionHierarchyId settleAccStructureRecId = DimensionAttributeValueCombination::find(_settleLedgerDimension).AccountStructure;
        LedgerDimensionAccount settleLedgerDimension = _settleLedgerDimension;
        boolean skipDimensionsValidation;

        if (taxAccStructureRecId != settleAccStructureRecId)
        {
            if (_taxOrigin == TaxOrigin::TaxReversed)
            {
                skipDimensionsValidation = true;
            }
            else
            {
                settleLedgerDimension = this.getDefaultLedgerDimension(_taxCode);
            }
        }
        return [skipDimensionsValidation, settleLedgerDimension];
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the tax amount.
    /// </summary>
    /// <param name = "_taxDirection">The tax direction.</param>
    /// <param name = "_taxledgerDimension">The tax ledger dimension.</param>
    /// <param name = "_useTaxPayableLedgerDimension">The tax payable ledger dimension.</param>
    /// <param name = "_clearingLedgerDimension">The clearing ledger dimension.</param>
    /// <param name = "_currencyCode">The currency code.</param>
    /// <param name = "_taxAmount">The tax amount.</param>
    /// <param name = "_taxInCostPrice">The tax amount include cost price.</param>
    /// <param name = "_taxAmountMST">The tax amount MST.</param>
    /// <param name = "_currencyHelper">The instance of <c>CurrencyExchangeHelper</c>.</param>
    /// <param name = "_taxTransRecId">The recId of <c>TaxTrans</c>.</param>
    /// <param name = "_taxCode">The tax code.</param>
    /// <param name = "_taxOrigin">The tax origin.</param>
    /// <param name = "_taxInCostPriceMST">The tax amount MST include cost price.</param>
    [SysObsolete('Method post has been deprecated, please use method postV2.', false, 23\04\2020)]
    protected void post(TaxDirection                _taxDirection,
                          LedgerDimensionAccount    _taxledgerDimension,
                          LedgerDimensionAccount    _useTaxPayableLedgerDimension,
                          LedgerDimensionAccount    _clearingLedgerDimension,
                          CurrencyCode              _currencyCode,
                          TaxAmount                 _taxAmount,
                          TaxAmount                 _taxInCostPrice,
                          TaxAmount                 _taxAmountMST,
                          CurrencyExchangeHelper    _currencyHelper,
                          RefRecId                  _taxTransRecId,
                          TaxCode                   _taxCode,
                          TaxOrigin                 _taxOrigin = TaxOrigin::Tax,
                          TaxAmount                 _taxInCostPriceMST = 0)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the tax amount.
    /// </summary>
    /// <param name = "_taxDirection">The tax direction.</param>
    /// <param name = "_taxledgerDimension">The tax ledger dimension.</param>
    /// <param name = "_useTaxPayableLedgerDimension">The tax payable ledger dimension.</param>
    /// <param name = "_clearingLedgerDimension">The clearing ledger dimension.</param>
    /// <param name = "_currencyCode">The currency code.</param>
    /// <param name = "_taxAmount">The tax amount.</param>
    /// <param name = "_taxInCostPrice">The tax amount include cost price.</param>
    /// <param name = "_taxAmountMST">The tax amount MST.</param>
    /// <param name = "_currencyHelper">The instance of <c>CurrencyExchangeHelper</c>.</param>
    /// <param name = "_taxTransRecId">The recId of <c>TaxTrans</c>.</param>
    /// <param name = "_taxCode">The tax code.</param>
    /// <param name = "_taxOrigin">The tax origin.</param>
    /// <param name = "_taxInCostPriceMST">The tax amount MST include cost price.</param>
    /// <param name = "_taxAmountRep">The tax amount in reporting currency.</param>
    /// <param name = "_taxInCostPriceRep">The tax amount in reporting currency include cost price.</param>
    protected void postV2(
        TaxDirection              _taxDirection,
        LedgerDimensionAccount    _taxledgerDimension,
        LedgerDimensionAccount    _useTaxPayableLedgerDimension,
        LedgerDimensionAccount    _clearingLedgerDimension,
        CurrencyCode              _currencyCode,
        TaxAmount                 _taxAmount,
        TaxAmount                 _taxInCostPrice,
        TaxAmount                 _taxAmountMST,
        CurrencyExchangeHelper    _currencyHelper,
        RefRecId                  _taxTransRecId,
        TaxCode                   _taxCode,
        TaxOrigin                 _taxOrigin = TaxOrigin::Tax,
        TaxAmount                 _taxInCostPriceMST = 0,
        TaxAmount                 _taxAmountRep = 0,
        TaxAmount                 _taxInCostPriceRep = 0)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject;
        LedgerDimensionAccount  vendSummaryLedgerDimension;
        ledgerDimensionAccount  clearingLedgerDimensionLocal;
        LedgerDimensionAccount  newUseTaxPayableLedgerDimension;
        AmountCur               taxAmount;
        AmountMST               taxAmountMST;
        AmountMST               taxAmountRep;
        VendTable               vendTable;

        clearingLedgerDimensionLocal = _clearingLedgerDimension;

        if (vendAccount)
        {
            vendTable = VendTable::find(VendAccount);
        }
        if (_taxAmount)
        {
            if ((!taxParametersLocal.PurchTaxOnOperations ||
                _taxDirection == TaxDirection::OutgoingTax
                || (isTaxBankExchangeRateDifferenceV2FlightEnabled && _taxDirection == TaxDirection::OutgoingTax_W)) && _taxledgerDimension)
            {
                if (countryRegion_IN)
                {
                    ledgerVoucherTransObject = this.addLedgerVoucherTransObject(
                        ledgerPostingController,
                        LedgerPostingType::None,
                        _taxledgerDimension,
                        _currencyCode,
                        _taxAmount - _taxInCostPrice,
                        _currencyHelper,
                        _taxTransRecId,
                        TaxTransRelationshipType::Tax);
                }
                else
                {
                    ledgerVoucherTransObject = this.addLedgerVoucherTransObject(
                        ledgerPostingController,
                        LedgerPostingType::Tax,
                        _taxledgerDimension,
                        _currencyCode,
                        _taxAmount - _taxInCostPrice,
                        _currencyHelper,
                        _taxTransRecId,
                        TaxTransRelationshipType::Tax);
                }

                if (ledgerVoucherTransObject)
                {
                    ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }

                // Define a global variable to record when there are different tax currencies, this variable should be set to false
                // False means transaction currency imbalance can be ignored
                if (!lastCurrencyCode)
                {
                    lastCurrencyCode = _currencyCode;
                }
                else if (lastCurrencyCode != _currencyCode)
                {
                    isPostedTransactionCurrencyTheSame = false;
                }

                taxAmountMST = ledgerVoucherTransObject ? ledgerVoucherTransObject.parmAccountingCurrencyAmount() : _currencyHelper.calculateTransactionToAccounting(_currencyCode, _taxAmount - _taxInCostPrice, true);

                if (isTaxCurrencyConversionFeatureEnabled)
                {
                    taxAmountRep = ledgerVoucherTransObject ? ledgerVoucherTransObject.parmReportingCurrencyAmount() : _currencyHelper.calculateTransactionCurrencyToReportingCurrency(_currencyCode, _taxAmount - _taxInCostPrice);
                }

                if (vendAccount)
                {
                    if (usePublicSectorDistributedPosting)
                    {
                        vendSummaryLedgerDimension = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(
                            VendLedgerAccounts::summaryLedgerDimension(vendAccount),
                            _taxledgerDimension);

                        Amount unRoundedTaxAmount = -(_taxAmount - _taxInCostPrice) - taxAmountRoundingDelta;
                        taxAmount = taxAuthorityAddress.roundOffTaxAmount(unRoundedTaxAmount);
                        taxAmountRoundingDelta = taxAmount - unRoundedTaxAmount;

                        vendSummaryLedgerDimension = this.addTrans(
                            ledgerPostingController,
                            LedgerPostingType::VendBalance,
                            vendSummaryLedgerDimension,
                            _currencyCode,
                            taxAmount,
                            _currencyHelper,
                            _taxledgerDimension,
                            _taxCode,
                            _taxOrigin);
                    }
                }
                else
                {
                    clearingLedgerDimensionLocal = this.addTrans(
                        ledgerPostingController,
                        LedgerPostingType::Tax,
                        clearingLedgerDimensionLocal,
                        _currencyCode,
                        -(_taxAmount - _taxInCostPrice),
                        _currencyHelper,
                        _taxledgerDimension,
                        _taxCode,
                        _taxOrigin);

                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) &&
                        _taxAmount - _taxInCostPrice)
                    {
                        ledgerVoucher.bondLast2_RU();
                    }
                }

                totalClearingAmount    += ((_taxAmount - _taxInCostPrice) * -1);
                totalClearingAmountMST += taxAmountMST * -1;

                if (isTaxCurrencyConversionFeatureEnabled)
                {
                    totalClearingAmountRep += taxAmountRep * -1;
                }

                if (vendAccount)
                {
                    totalClearingAmountTaxAuthorityCur += _currencyHelper.calculateCurrencyToCurrency(_currencyCode, VendTable.Currency, (_taxAmount - _taxInCostPrice) * -1, true);
                }
                transactions++;
                if (_taxDirection == TaxDirection::OutgoingTax
                    || (isTaxBankExchangeRateDifferenceV2FlightEnabled && _taxDirection == TaxDirection::OutgoingTax_W))
                {
                    taxAmountSales += (_taxAmount - _taxInCostPrice);
                }
                else
                {
                    taxAmountPurchase += (_taxAmount - _taxInCostPrice);
                }

                if (isTaxCurrencyConversionFeatureEnabled)
                {
                    // taxAmountMST > 0 or taxAmountRep > 0 means it is going to settle outgoing tax
                    // taxAmountMST < 0 or taxAmountRep < 0 means it is going to settle incoming tax
                    // taxAmountMST or taxAmountRep is the actual settled tax amount
                    // _taxAmountMST - _taxInCostPriceMST or _taxAmountRep - _taxInCostPriceRep is the target settled tax amount
                    if (taxCurrencyConversionPath == TaxCurConvPath::AccountingCurrency)
                    {
                        Amount exchangeGainLossAmountMST = taxAmountMST - (_taxAmountMST - _taxInCostPriceMST);

                        // Currency exchange rate changed before settle and post sales tax.
                        if (exchangeGainLossAmountMST)
                        {
                            this.processExchangeRateGainLoss(
                                ledgerPostingController,
                                _currencyCode,
                                exchangeGainLossAmountMST,
                                0,
                                _taxledgerDimension);
                        }

                        // For legacy data which created before release date of sales tax conversion feature, do not support to balance for reporting currency.
                        if (_taxAmountRep != 0)
                        {
                            Amount exchangeGainLossAmountRep = taxAmountRep - (_taxAmountRep - _taxInCostPriceRep);

                            if (exchangeGainLossAmountRep)
                            {
                                this.processExchangeRateGainLoss(
                                    ledgerPostingController,
                                    _currencyCode,
                                    0,
                                    exchangeGainLossAmountRep,
                                    _taxledgerDimension);
                            }
                        }
                    }
                    else
                    {
                        // For legacy data which created before release date of sales tax conversion feature, do not support to balance for reporting currency.
                        if (_taxAmountRep != 0)
                        {
                            Amount exchangeGainLossAmountRep = taxAmountRep - (_taxAmountRep - _taxInCostPriceRep);

                            // Currency exchange rate changed before settle and post sales tax.
                            if (exchangeGainLossAmountRep)
                            {
                                this.processExchangeRateGainLoss(
                                ledgerPostingController,
                                _currencyCode,
                                0,
                                exchangeGainLossAmountRep,
                                _taxledgerDimension);
                            }
                        }

                        Amount exchangeGainLossAmountMST = taxAmountMST - (_taxAmountMST - _taxInCostPriceMST);

                        if (exchangeGainLossAmountMST)
                        {
                            this.processExchangeRateGainLoss(
                                ledgerPostingController,
                                _currencyCode,
                                exchangeGainLossAmountMST,
                                0,
                                _taxledgerDimension);
                        }
                    }
                }
                else
                {
                    // taxAmountMST > 0 means it is going to settle outgoing tax
                    // taxAmountMST < 0 means it is going to settle incoming tax
                    // taxAmountMST is the actual settled tax amount
                    // _taxAmountMST - _taxInCostPriceMST is the target settled tax amount
                    Amount exchangeGainLossAmount = taxAmountMST - (_taxAmountMST - _taxInCostPriceMST);

                    if (exchangeGainLossAmount)
                    {
                        this.processExchangeRateGainLoss(
                            ledgerPostingController,
                            _currencyCode,
                            exchangeGainLossAmount,
                            _currencyHelper.calculateAccountingToReportingAdjustment(
                                _currencyCode,
                                exchangeGainLossAmount,
                                true),
                            _taxledgerDimension);
                    }
                }

                if (isTaxSettlementStateCollectionFlightEnabled)
                {
                    postedV2Count++;
                }
            }

            if (_taxDirection == TaxDirection::UseTax && _useTaxPayableLedgerDimension)
            {
                // Reversing entries for Use tax will use the dimensions from the new account structure
                // when account structure is changed before running the settlement process.
                newUseTaxPayableLedgerDimension = Tax::getNewLedgerDimensionDueToAccountStructureChange(_useTaxPayableLedgerDimension);

                ledgerVoucherTransObject = this.addLedgerVoucherTransObject(
                    ledgerPostingController,
                    LedgerPostingType::Tax,
                    newUseTaxPayableLedgerDimension,
                    _currencyCode,
                    _taxAmount * -1,
                    _currencyHelper,
                    _taxTransRecId,
                    TaxTransRelationshipType::UseTaxPayable);

                if (ledgerVoucherTransObject)
                {
                    ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }

                if (ledgerVoucherTransObject
                    && _taxOrigin == TaxOrigin::TaxReversed)
                {
                    ledgerVoucherTransObject.parmSkipDimensionValidation(true);
                }

                taxAmountMST = ledgerVoucherTransObject ? ledgerVoucherTransObject.parmAccountingCurrencyAmount() : _currencyHelper.calculateTransactionToAccounting(_currencyCode, _taxAmount * -1, true);

                if (isTaxCurrencyConversionFeatureEnabled)
                {
                    taxAmountRep = ledgerVoucherTransObject ? ledgerVoucherTransObject.parmReportingCurrencyAmount() : _currencyHelper.calculateTransactionCurrencyToReportingCurrency(_currencyCode, _taxAmount * -1);
                }

                if (usePublicSectorDistributedPosting && vendAccount)
                {
                    vendSummaryLedgerDimension = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(
                        VendLedgerAccounts::summaryLedgerDimension(vendAccount),
                        _useTaxPayableLedgerDimension);

                    vendSummaryLedgerDimension = this.addTrans(
                        ledgerPostingController,
                        LedgerPostingType::VendBalance,
                        vendSummaryLedgerDimension,
                        _currencyCode,
                        _taxAmount,
                        _currencyHelper,
                        _useTaxPayableLedgerDimension,
                        _taxCode,
                        _taxOrigin);
                }

                if (!vendAccount)
                {
                    if (usePublicSectorDistributedPosting)
                    {
                        clearingLedgerDimensionLocal = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(
                            _clearingLedgerDimension,
                            _useTaxPayableLedgerDimension);
                    }

                    clearingLedgerDimensionLocal = this.addTrans(
                        ledgerPostingController,
                        LedgerPostingType::Tax,
                        clearingLedgerDimensionLocal,
                        _currencyCode,
                        _taxAmount,
                        _currencyHelper,
                        _useTaxPayableLedgerDimension,
                        _taxCode,
                        _taxOrigin);

                    ledgerVoucher.bondLast2_RU();
                }

                if (isTaxCurrencyConversionFeatureEnabled)
                {
                    // _taxAmountMST < 0 or _taxAmountRep < 0 means it is going to settle incoming tax
                    // _taxAmountMST > 0 or _taxAmountRep > 0 means it is going to settle outgoing tax
                    // taxAmountMST or taxAmountRep is the actual settled tax amount
                    // -_taxAmountMST or -_taxAmountRep is the target settled tax amount
                    if (taxCurrencyConversionPath == TaxCurConvPath::AccountingCurrency)
                    {
                        Amount exchangeRateGainLossAmountMST = taxAmountMST + _taxAmountMST;

                        if (exchangeRateGainLossAmountMST)
                        {
                            this.processExchangeRateGainLoss(
                                ledgerPostingController,
                                _currencyCode,
                                exchangeRateGainLossAmountMST,
                                0,
                                newuseTaxPayableLedgerDimension);
                        }

                        // For legacy data which created before release date of sales tax conversion feature, do not support to balance for reporting currency.
                        if (_taxAmountRep != 0)
                        {
                            Amount exchangeGainLossAmountRep = taxAmountRep - _taxAmountRep * -1;

                            if (exchangeGainLossAmountRep)
                            {
                                this.processExchangeRateGainLoss(
                                    ledgerPostingController,
                                    _currencyCode,
                                    0,
                                    exchangeGainLossAmountRep,
                                    newuseTaxPayableLedgerDimension);
                            }
                        }
                    }
                    else
                    {
                        // For legacy data which created before release date of sales tax conversion feature, do not support to balance for reporting currency.
                        if (_taxAmountRep != 0)
                        {
                            Amount exchangeRateGainLossAmountRep = taxAmountRep + _taxAmountRep;

                            if (exchangeRateGainLossAmountRep)
                            {
                                this.processExchangeRateGainLoss(
                                    ledgerPostingController,
                                    _currencyCode,
                                    0,
                                    exchangeRateGainLossAmountRep,
                                    newUseTaxPayableLedgerDimension);
                            }
                        }

                        Amount exchangeGainLossAmountMST = taxAmountMST - _taxAmountMST * -1;

                        if (exchangeGainLossAmountMST)
                        {
                            this.processExchangeRateGainLoss(
                                ledgerPostingController,
                                _currencyCode,
                                exchangeGainLossAmountMST,
                                0,
                                newUseTaxPayableLedgerDimension);
                        }
                    }
                }
                else
                {
                    // _taxAmountMST < 0 means it is going to settle incoming tax
                    // _taxAmountMST > 0, it is goting to settle outgoing tax
                    // taxAmountMST is the actual settled tax amount
                    // -_taxAmountMST is the target settled tax amount
                    Amount exchangeRateGainLossAmount = taxAmountMST + _taxAmountMST;

                    if (exchangeRateGainLossAmount)
                    {
                        this.processExchangeRateGainLoss(
                            ledgerPostingController,
                            _currencyCode,
                            exchangeRateGainLossAmount,
                            _currencyHelper.calculateAccountingToReportingAdjustment(
                                _currencyCode,
                                exchangeRateGainLossAmount,
                                true),
                            newUseTaxPayableLedgerDimension);
                    }
                }

                totalClearingAmount    += _taxAmount;
                totalClearingAmountMST += -taxAmountMST;

                if (isTaxCurrencyConversionFeatureEnabled)
                {
                    totalClearingAmountRep += -taxAmountRep;
                }

                if (vendAccount)
                {
                    totalClearingAmountTaxAuthorityCur += _currencyHelper.calculateCurrencyToCurrency(_currencyCode, VendTable.Currency, _taxAmount, true);
                }
                transactions++;
                taxAmountUseTax += _taxAmount;

                if (isTaxSettlementStateCollectionFlightEnabled)
                {
                    postedV2UseTaxCount++;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postToInterimPLA_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if post to interim PLA.
    /// </summary>
    /// <returns>
    /// The result whether post to interim PLA.
    /// </returns>
    NoYes postToInterimPLA_IN()
    {
        return postToInterimPLA;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printout</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes the report.
    /// </summary>
    void printout()
    {
        Args args = new Args();
        args.parmObject(this);
        args.record(taxReportPeriod);

        // <GIN>
        if (isIndirectTax)
        {
            TaxReportPrintOut::printout_IN(taxPeriod, args);
        }
        else
        {
            // </GIN>
            TaxReportPrintOut::printout(taxPeriod, args);
            // <GIN>
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportingVersionUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calls the <see cref="M:TaxReportPeriod::versionSumUp" /> on the TaxReportPeriod table.
    /// </summary>
    void reportingVersionUpdate()
    {
        // <GIN>
        if (isIndirectTax)
        {
            TaxReportPeriod_IN::versionSumUp(taxPeriod, taxRegistrationNumber, fromDate);
        }
        else
        {
            // </GIN>

            TaxReportPeriod::versionSumUp(taxPeriod,fromDate);

            // <GIN>
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void  run()
    {
        #OCCRetryCount
        boolean          canUpdate;
        boolean          success = true;
        TaxReportPeriodLock taxReportPeriodLock = new TaxReportPeriodLock();
        TaxReportVoucher taxReportVoucher;
        #define.TaxReport_BE('TAXREPORT_BE')
        #define.TaxIntervatDiskBE('TAXINTERVATDISKBE')

        // This will cause all the following infolog messages to be grouped under this one in the message center
        setPrefix(strFmt("@Tax:TaxReportBatchCaption", this.taxPeriod(), this.fromDate(), this.transDate()));

        if (isMultipleTaxIdEnabled)
        {
            if (TaxReportMultipleTaxIdHelper::getTaxRegistrationNumberISOCodeByTaxPeriod(taxPeriod) == #isoBE
                && ((strUpr(this.name()) != #TaxReport_BE)
                && (strUpr(this.name()) != #TaxIntervatDiskBE)))
            {
                throw error("@SYS92337");
            }
        }
        else
        {
            if (TaxAuthorityAddress::find(TaxPeriodHead::find(taxPeriod).TaxAuthority).TaxReportLayout == TaxReportLayout::Belgium
                && ((strUpr(this.name()) != #TaxReport_BE)
                && (strUpr(this.name()) != #TaxIntervatDiskBE)))
            {
                throw error("@SYS92337");
            }
        }

        Microsoft.Dynamics.Ax.Xpp.ErrorException errorEx;
        Microsoft.Dynamics.Ax.Xpp.DeadlockException deadLockEx;
        Microsoft.Dynamics.Ax.Xpp.UpdateConflictException updateConflictEx;
        Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource taxEventSourceLog = Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource::Log;
        System.Diagnostics.Stopwatch stopWatch;
        guid identifier;

        try
        {
            stopWatch = new System.Diagnostics.Stopwatch();
            identifier = newGuid();
            taxEventSourceLog.PaymentTaxStart(identifier);
            stopWatch.Start();

            // <GIN>
            this.setIndirectTax_IN();
            // </GIN>

            taxReportPeriod  = TaxReportPeriod::find(taxPeriod, fromDate);
            if (taxReportPeriod)
            {
                taxReportPeriodLock.lockSettlementPeriod(taxReportPeriod.RecId);
                fromDate    = taxReportPeriod.FromDate;
                toDate      = taxReportPeriod.ToDate;
                printout    = NoYes::Yes;

                if (updateNow)
                {
                    // <GIN>
                    if (isIndirectTax)
                    {
                        taxReportPeriodRegistrationNum = TaxReportPeriod_IN::findByTaxPeriod(taxPeriod, taxRegistrationNumber, fromDate);
                        canUpdate = this.checkForUpdate_IN();
                        if (! canUpdate)
                        {
                            printout = NoYes::No;
                            throw error("@Tax:TaxReportSettleError");
                        }
                    }
                    else
                    {
                        // </GIN>
                        canUpdate = this.checkForUpdate() && this.checkTaxAuthorityDefaultDimension();
                        if (! canUpdate)
                        {
                            printout = NoYes::No;
                            throw error("@Tax:TaxReportSettleError");
                        }
                        // <GIN>
                    }
                    // </GIN>
                }

                // <GIN>
                if (isIndirectTax)
                {
                    if (!updateNow &&
                        taxReportPeriodRegistrationNum.VersionNum > 0 &&
                        taxRepVersion == TaxRepVersion::Original)
                        warning("@SYS62092");
                }
                else
                {
                    // </GIN>

                    if (!updateNow &&
                        taxReportPeriod.VersionNum > 0 &&
                        taxRepVersion == TaxRepVersion::Original)
                    {
                        warning("@SYS62092");
                    }

                    // <GIN>
                }
                // </GIN>
            }
            else
            {
                throw error("@SYS24993");
            }

            ttsbegin;

            if (taxReportPeriod && updateNow && canUpdate && taxReportPeriodLock.isLockAcquired(taxReportPeriod.RecId))
            {
                numberSeq   = NumberSeq::newGetVoucher(TaxParameters::numRefTaxReportingVoucher(),false);
                voucher     = numberSeq.voucher();
                this.updateNow();

                if (taxTransactions)
                {
                    TransactionLog::create(TransactionLogType::TaxReport, voucher);
                }
                else
                {
                    select firstonly forupdate taxReportVoucher
                        where taxReportVoucher.TaxPeriod == taxPeriod &&
                                taxReportVoucher.Voucher   == voucher   &&
                                taxReportVoucher.TransDate == transactionDate;

                    taxReportVoucher.Voucher = '';
                    taxReportVoucher.update();
                    numberSeq.abort();
                }
            }

            ttscommit;
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (SysTransientSqlConnectionErrorHandler::retryTransientSqlConnectionError(3)) // here we want to retry 3 times to not make the replicate issue taking long time
            {
                // Unlock tax report period.
                this.unlockTaxPeriodBeforeRetry(taxReportPeriodLock, taxReportPeriod);
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (deadLockEx)
        {
            success = false;

            taxEventSourceLog.UpdateTaxReportPeriodError(guid2Str(newGuid()),
                                                         deadLockEx.Message,
                                                         deadLockEx.StackTrace,
                                                         taxReportPeriod.SettlementPeriodInProcessBy);
            // Unlock tax report period.
            this.unlockTaxPeriodBeforeRetry(taxReportPeriodLock, taxReportPeriod);
            retry;
        }

        catch (updateConflictEx)
        {
            success = false;

            taxEventSourceLog.UpdateTaxReportPeriodError(guid2Str(newGuid()),
                                                         updateConflictEx.Message,
                                                         updateConflictEx.StackTrace,
                                                         taxReportPeriod.SettlementPeriodInProcessBy);

            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    // Unlock tax report period.
                    this.unlockTaxPeriodBeforeRetry(taxReportPeriodLock, taxReportPeriod);
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }

        // catch exception in order not to get stack trace when settlement period doesn't exist
        catch (errorEx)
        {
            success = false;

            taxEventSourceLog.TaxProcessError(guid2Str(newGuid()),
                                              errorEx.Message,
                                              errorEx.StackTrace,
                                              methodStr(TaxReport, run));

            exceptionTextFallThrough();
            // When thrown from inside a catch a stack trace is not generated. Exception is rethrown to have this correctly marked as Error when run in batch.
            throw Exception::Error;
        }
        finally
        {
            taxReportPeriodLock.unlockSettlementPeriod(taxReportPeriod.RecId);
            this.executePostRunOperations();
            stopWatch.Stop();
            taxEventSourceLog.PaymentTaxStop(identifier, SysCountryRegionCode::countryInfo(), enum2Str(taxRepVersion), isPreview, taxTransactions, stopWatch.ElapsedMilliseconds, success);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPostLegacy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves and posts tax transaction.
    /// </summary>
    /// <param name = "_taxTrans">The buffer of <c>TaxTrans</c>.</param>
    /// <param name = "_taxLedgerDimension">The tax ledger dimension.</param>
    /// <param name = "_useTaxPayableLedgerDimension">The tax payable ledger dimension.</param>
    /// <param name = "_currencyExchangeHelper">The instance of <c>CurrencyExchangeHelper</c>.</param>
    /// <param name = "_taxCodeCurrencyAmount">The tax amount for tax code currency.</param>
    /// <param name = "_accountingTaxAmount">The tax amount for accounting currency.</param>
    /// <param name = "_taxCodeTaxInCostPriceAmount">The tax amount for tax code include cost price.</param>
    /// <param name = "_accountingTaxInCostPrice">The tax amount for accounting currency include cost price.</param>
    /// <param name = "_transactionTaxAmount">The tax amount for transaction.</param>
    void saveAndPostLegacy(TaxTrans   _taxTrans,
                     LedgerDimensionAccount _taxLedgerDimension,
                     LedgerDimensionAccount _useTaxPayableLedgerDimension,
                     CurrencyExchangeHelper _currencyExchangeHelper,
                     TaxAmountCur _taxCodeCurrencyAmount,
                     TaxAmount    _accountingTaxAmount,
                     TaxAmountCur _taxCodeTaxInCostPriceAmount,
                     TaxAmount    _accountingTaxInCostPrice,
                     TaxAmountCur _transactionTaxAmount)
    {
        AmountCur               taxAmountCur;
        AmountCur               taxInCostPriceCur;
        AmountMST               taxAmountMST;
        AmountMST               taxInCostPriceMST;
        CurrencyCode            currencyCode;
        LedgerDimensionAccount  useTaxPayableLedgerDimension;
        LedgerDimensionAccount  ledgerDimensionAccount;
        DimensionDefault        dimensionDefault;
        TaxPeriodHead           taxPeriodHead = TaxPeriodHead::find(taxPeriod);

        if (_taxTrans.CurrencyCode && _taxTrans.CurrencyCode != companyStandardCurrency)
        {
            currencyCode      = _taxTrans.CurrencyCode;
            taxAmountCur      =  CurrencyExchangeHelper::amount(_taxCodeCurrencyAmount, currencyCode);
            taxInCostPriceCur = CurrencyExchangeHelper::amount(_taxCodeTaxInCostPriceAmount, currencyCode);
        }
        else
        {
            taxAmountCur      =  CurrencyExchangeHelper::amount(_accountingTaxAmount);
            taxInCostPriceCur = CurrencyExchangeHelper::amount(_accountingTaxInCostPrice);
            currencyCode      = companyStandardCurrency;
        }

        taxAmountMST          =  CurrencyExchangeHelper::amount(_accountingTaxAmount);
        taxInCostPriceMST     =  CurrencyExchangeHelper::amount(_accountingTaxInCostPrice);

        if (_taxTrans.TaxDirection == TaxDirection::UseTax && !_useTaxPayableLedgerDimension)
        {
            useTaxPayableLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(TaxLedgerAccountGroup::offsetUseTaxLedgerDimension(_taxTrans.TaxCode));
        }
        else if ((_taxTrans.TaxDirection == TaxDirection::IncomingTax || TaxDirection::OutgoingTax) && !_useTaxPayableLedgerDimension)
        {
            ledgerDimensionAccount  = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(_taxLedgerDimension);
            dimensionDefault        = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_taxLedgerDimension);
            useTaxPayableLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionAccount, dimensionDefault);
        }
        else
        {
            useTaxPayableLedgerDimension = _useTaxPayableLedgerDimension;
        }

        taxClearingLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(TaxLedgerAccountGroup::clearingLedgerDimension(_taxTrans.TaxCode), LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(useTaxPayableLedgerDimension));

        if (!taxPeriodHead.NotGenerateOffsetTaxTrans && !isGenOffsetTaxTransPerRecordSetEnabled)
        {
            taxTransOffsetRecId = this.saveOffsetTaxTrans(_taxTrans
                                                     // <GIN>
                                                     , false,
                                                     _taxLedgerDimension
                                                     // </GIN>
                                                     );
        }
        

        if (_taxTrans.TaxDirection != TaxDirection::TaxExemptPurchase &&
            _taxTrans.TaxDirection != TaxDirection::TaxExemptSales    &&
            _taxTrans.TaxDirection != TaxDirection::TaxTransaction)
        {
            // Maintaining the call for compatibility.
            this.post(
                _taxTrans.TaxDirection,
                _taxLedgerDimension,
                useTaxPayableLedgerDimension,
                taxClearingLedgerDimension,
                currencyCode,
                taxAmountCur * -1,
                taxInCostPriceCur * -1,
                taxAmountMST * -1,
                _currencyExchangeHelper,
                taxTransOffsetRecId,
                _taxTrans.TaxCode,
                _taxTrans.TaxOrigin,
                taxInCostPriceMST * -1);

            this.postV2(
                _taxTrans.TaxDirection,
                _taxLedgerDimension,
                useTaxPayableLedgerDimension,
                taxClearingLedgerDimension,
                currencyCode,
                taxAmountCur * -1,
                taxInCostPriceCur * -1,
                taxAmountMST * -1,
                _currencyExchangeHelper,
                taxTransOffsetRecId,
                _taxTrans.TaxCode,
                _taxTrans.TaxOrigin,
                taxInCostPriceMST * -1,
                isTaxCurrencyConversionFeatureEnabled ? _taxTrans.TaxAmountRep * -1 : 0,
                isTaxCurrencyConversionFeatureEnabled ? _taxTrans.TaxInCostPriceRep * -1 : 0);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPostRetrieveAccountsAndAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves and posts tax transaction for retrieve account and amount.
    /// </summary>
    /// <param name = "_taxTrans">The buffer of <c>TaxTrans</c>.</param>
    /// <param name = "_currencyExchangeHelper">The instance of <c>CurrencyExchangeHelper</c>.</param>
    /// <param name = "_taxLedgerDimension">The tax account.</param>
    /// <param name = "_useTaxPayableLedgerDimension">The use tax payable account.</param>
    protected void saveAndPostRetrieveAccountsAndAmounts(TaxTrans _taxTrans,
        CurrencyExchangeHelper _currencyExchangeHelper,
        LedgerDimensionAccount _taxLedgerDimension = 0,
        LedgerDimensionAccount _useTaxPayableLedgerDimension = 0)
    {
        LedgerDimensionAccount taxLedgerDimension = _taxLedgerDimension;
        LedgerDimensionAccount useTaxPayableLedgerDimension = _useTaxPayableLedgerDimension;
        TaxTrans               localTaxTrans;
        TaxPeriodHead taxPeriodHead = TaxPeriodHead::find(taxPeriod);

        if (countryRegion_IT && _taxTrans.SourceDocumentLine)
        {
            TaxTable localTaxTable;

            select firstOnly RecId from localTaxTrans
                 join RecId from localTaxTable
                    where localTaxTable.TaxCode == localTaxTrans.TaxCode &&
                        localTaxTable.PaymentTaxCode == _taxTrans.TaxCode &&
                        localTaxTrans.SourceDocumentLine == _taxTrans.SourceDocumentLine;
        }

        if (_taxTrans.SourceDocumentLine && !localTaxTrans.RecId)
        {
            if(!taxPeriodHead.NotGenerateOffsetTaxTrans && !isGenOffsetTaxTransPerRecordSetEnabled)
            {
                taxTransOffsetRecId = this.saveOffsetTaxTrans(_taxTrans);
            }

            if ((isTaxBankExchangeRateDifferenceFlightingEnabled && !isTaxBankExchangeRateDifferenceV2FlightEnabled)
                && _taxTrans.ExchRateDiffOrigRecId != 0)
            {
                // Only when TaxBankExchangeRateDifferenceV2Flight is disable, separately process taxTrans generated by feature Bank exchange rate;
                // otherwise, it would be handled in saveAndPostWithAccountingDistributions.
                this.saveAndPostWithBankExchangeRate(
                    _taxTrans,
                    taxTransOffsetRecId,
                    taxLedgerDimension);
            }
            else if (_taxTrans.TaxOrigin != TaxOrigin::Payment &&
                _taxTrans.TaxOrigin != TaxOrigin::TaxReversed &&
                _taxTrans.TaxOrigin != TaxOrigin::CashDisc &&
                _taxTrans.IsOverUnderPayment == NoYes::No)
            {
                this.saveAndPostWithAccountingDistributions(_taxTrans, useTaxPayableLedgerDimension, _currencyExchangeHelper, taxTransOffsetRecId, taxLedgerDimension);
            }
            else
            {
                // Legacy scenario where the original invoice was based on the source document framework.
                // we need to recalculate split the amounts from TaxTrans using the allocation factor from
                // the accounting distribution.

                this.saveAndPostLegacyWithAccountingDistributions(
                    _taxTrans,
                    useTaxPayableLedgerDimension,
                    _currencyExchangeHelper,
                    taxTransOffsetRecId,
                    taxLedgerDimension);
            }
        }
        else
        {
            if (!taxLedgerDimension)
            {
                if (overridenForMethodUpdateAndPostTaxTrans)
                {
                    taxLedgerDimension = this.getLedgerDimensionForTaxTrans(_taxTrans, TaxTransRelationshipType::Tax);
                }
                else
                {
                    taxLedgerDimension = taxInCostPriceLedgerDimension;
                    if (!taxLedgerDimension)
                    {
                        taxLedgerDimension = this.getLedgerDimensionForTaxTransCashDisc(_taxTrans);
                    }
                }
            }
            
            this.saveAndPostLegacy(
            _taxTrans,
            taxLedgerDimension,
            useTaxPayableLedgerDimension,
            _currencyExchangeHelper,
            _taxTrans.TaxAmountCur,
            _taxTrans.TaxAmount,
            _taxTrans.TaxInCostPriceCur,
            _taxTrans.TaxInCostPriceMST,
            _taxTrans.SourceRegulateAmountCur);
            
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPostLegacyWithDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves and posts tax transaction with distribution.
    /// </summary>
    /// <param name = "_taxTrans">The buffer of <c>TaxTrans</c>.</param>
    /// <param name = "_useTaxPayableLedgerDimension">The tax payable ledger dimension.</param>
    /// <param name = "_currencyExchangeHelper">The instance of <c>CurrencyExchangeHelper</c>.</param>
    /// <param name = "_taxTransOffsetRecId">The offset tax transaction recId.</param>
    protected void saveAndPostLegacyWithDistributions(
        TaxTrans                _taxTrans,
        LedgerDimensionAccount  _useTaxPayableLedgerDimension,
        CurrencyExchangeHelper  _currencyExchangeHelper,
        RefRecId                _taxTransOffsetRecId)
    {
        this.saveAndPostLegacyWithAccountingDistributions(_taxTrans, _useTaxPayableLedgerDimension, _currencyExchangeHelper, _taxTransOffsetRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPostWithAccountingDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves and posts tax transaction with distribution.
    /// </summary>
    /// <param name = "_taxTrans">The buffer of <c>TaxTrans</c>.</param>
    /// <param name = "_useTaxPayableLedgerDimension">The tax payable ledger dimension.</param>
    /// <param name = "_currencyHelper">The instance of <c>CurrencyExchangeHelper</c>.</param>
    /// <param name = "_taxTransOffsetRecId">The offset tax transaction recId.</param>
    /// <param name = "_taxLedgerDimension">The tax ledger dimension.</param>
    protected void saveAndPostWithAccountingDistributions(
        TaxTrans _taxTrans,
        LedgerDimensionAccount _useTaxPayableLedgerDimension,
        CurrencyExchangeHelper _currencyHelper,
        RefRecId _taxTransOffsetRecId,
        LedgerDimensionAccount _taxLedgerDimension = 0)
    {
        TaxAmountCur                taxCodeCurrencyAmount;
        TaxAmount                   accountingTaxAmount;
        TaxAmount                   reportingTaxAmount;
        LedgerDimensionAccount      useTaxPayableLedgerDimension;
        CurrencyCode                currencyCode;
        TaxData                     taxData;
        LedgerDimensionAccount      taxLedgerDimensionAccount_MX;

        LedgerDimensionAccount ledgerDimensionAccount;
        DimensionDefault dimensionDefault;
        AccountingDistribution accountingDistribution;
        AccountingDistribution reversingAccountingDistribution;
        int64 accountingDistributionCounts;
        int accountingDistributionCurrentCount;
        Amount totalSettledTaxAmountMST;
        Amount totalSettledTaxAmountCur;
        Amount totalSettledTaxAmountRep;

        TaxTrans taxTransActual; // The tax trans that the actual tax amount posted, which will be used to calculate allocate factor.
        TaxTrans taxTransBeingSettled = _taxTrans; // The tax trans that is being settled, it is the same to taxTransActual by default.

        boolean isForBankExchangeRateDifference;

        if (isTaxBankExchangeRateDifferenceV2FlightEnabled && _taxTrans.ExchRateDiffOrigRecId != 0)
        {
            // For tax trans on exchange rate difference, the transaction currency amount of its accounting distribution would always be ZERO,
            // it should be settled based on the actual tax trans.

            select firstonly TaxCode, TransDate, TaxBaseAmount, SourceDocumentLine, SourceRegulateAmountCur from taxTransActual
                where taxTransActual.RecId == _taxTrans.ExchRateDiffOrigRecId;

            isForBankExchangeRateDifference = true;
        }
        else
        {
            taxTransActual = _taxTrans;
        }

        taxData = taxData::find(taxTransActual.TaxCode, taxTransActual.TransDate, taxTransActual.TaxBaseAmount);

        // If US tax rules are on then the use tax expense is non-recoverable VAT.
        // Find that record anyways so that the Use Tax Payable (the offset) can be backed out.
        boolean includeTaxNonRecoverable =
            (taxParametersLocal.PurchTaxOnOperations || taxData.VATExemptPct) && taxTransBeingSettled.TaxDirection == TaxDirection::UseTax;

        select count(RecId), sum(TransactionCurrencyAmount)
            from accountingDistribution
            where accountingDistribution.SourceDocumentLine == taxTransActual.SourceDocumentLine
                && accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing
                && (accountingDistribution.MonetaryAmount == MonetaryAmount::Tax
                    || accountingDistribution.MonetaryAmount == MonetaryAmount::TaxVariance
                    || (accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable && includeTaxNonRecoverable)
                    || (accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance && includeTaxNonRecoverable))
            notexists join reversingAccountingDistribution
                where reversingAccountingDistribution.ReferenceDistribution == accountingDistribution.RecId
                    && reversingAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing;

        accountingDistributionCounts = accountingDistribution.recid;

        if (accountingDistributionCounts == 0)
        {
            return;
        }

        real totalAllocateFactor;
        if (isTaxSettlementNegativeFactorFlightEnabled)
        {
            totalAllocateFactor = taxTransActual.SourceRegulateAmountCur ? abs(accountingDistribution.TransactionCurrencyAmount / taxTransActual.SourceRegulateAmountCur) : 0;
        }
        else
        {
            totalAllocateFactor = taxTransActual.SourceRegulateAmountCur ? accountingDistribution.TransactionCurrencyAmount / taxTransActual.SourceRegulateAmountCur : 0;
        }

        if (taxTransBeingSettled.TaxDirection == TaxDirection::UseTax && !_useTaxPayableLedgerDimension)
        {
            useTaxPayableLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(TaxLedgerAccountGroup::offsetUseTaxLedgerDimension(taxTransBeingSettled.TaxCode));
        }
        else if (!_useTaxPayableLedgerDimension
            && ((taxTransBeingSettled.TaxDirection == TaxDirection::IncomingTax || taxTransBeingSettled.TaxDirection == TaxDirection::OutgoingTax)
                || (isForBankExchangeRateDifference
                    && (taxTransBeingSettled.TaxDirection == TaxDirection::IncomingTax_W || taxTransBeingSettled.TaxDirection == TaxDirection::OutgoingTax_W))))
        {
            ledgerDimensionAccount = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(_taxLedgerDimension);
            dimensionDefault = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_taxLedgerDimension);
            useTaxPayableLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionAccount, dimensionDefault);
        }
        else
        {
            useTaxPayableLedgerDimension = _useTaxPayableLedgerDimension;
        }

        if (taxTransBeingSettled.CurrencyCode && taxTransBeingSettled.CurrencyCode != CompanyInfoHelper::standardCurrency())
        {
            currencyCode = taxTransBeingSettled.CurrencyCode;
        }
        else
        {
            currencyCode = CompanyInfoHelper::standardCurrency();
        }

        while select LedgerDimension, TransactionCurrency, TransactionCurrencyAmount, SourceDocumentLine, AllocationFactor, RecId, MonetaryAmount, ParentDistribution
            from accountingDistribution
            where accountingDistribution.SourceDocumentLine == taxTransActual.SourceDocumentLine
                && accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing
                && (accountingDistribution.MonetaryAmount == MonetaryAmount::Tax
                    || accountingDistribution.MonetaryAmount == MonetaryAmount::TaxVariance
                    || (accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable && includeTaxNonRecoverable)
                    || (accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance && includeTaxNonRecoverable))
            notexists join reversingAccountingDistribution
                where reversingAccountingDistribution.ReferenceDistribution == accountingDistribution.RecId
                        && reversingAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing
        {
            accountingDistributionCurrentCount++;

            taxClearingLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(TaxLedgerAccountGroup::clearingLedgerDimension(taxTransBeingSettled.TaxCode), LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(useTaxPayableLedgerDimension));

            if ((accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable ||
                 accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance)
                 && taxTransBeingSettled.TaxDirection == TaxDirection::UseTax
                 && taxData.VATExemptPct)
            {
                taxLedgerDimensionAccount_MX = 0;
            }
            else
            {
                if (isForBankExchangeRateDifference)
                {
                    AccountingDistribution accountingDistributionForBankExchangeRateDifference;

                    select firstonly LedgerDimension from accountingDistributionForBankExchangeRateDifference
                        where accountingDistributionForBankExchangeRateDifference.ParentDistribution == accountingDistribution.ParentDistribution
                            && accountingDistributionForBankExchangeRateDifference.SourceDocumentLine == taxTransBeingSettled.SourceDocumentLine
                            && accountingDistributionForBankExchangeRateDifference.ReferenceRole != AccountingDistributionReferenceRole::Reversing
                            && (accountingDistributionForBankExchangeRateDifference.MonetaryAmount == MonetaryAmount::Tax
                                || accountingDistributionForBankExchangeRateDifference.MonetaryAmount == MonetaryAmount::TaxVariance
                                || (accountingDistributionForBankExchangeRateDifference.MonetaryAmount == MonetaryAmount::TaxNonRecoverable && includeTaxNonRecoverable)
                                || (accountingDistributionForBankExchangeRateDifference.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance && includeTaxNonRecoverable))
                        notexists join reversingAccountingDistribution
                            where reversingAccountingDistribution.ReferenceDistribution == accountingDistribution.RecId
                                && reversingAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing;

                    taxLedgerDimensionAccount_MX = accountingDistributionForBankExchangeRateDifference.LedgerDimension;
                }
                else
                {
                    taxLedgerDimensionAccount_MX = accountingDistribution.LedgerDimension;
                }
            }

            if (accountingDistributionCurrentCount == accountingDistributionCounts)
            {
                accountingTaxAmount = taxTransBeingSettled.TaxAmount * totalAllocateFactor  - totalSettledTaxAmountMST;
                accountingTaxAmount = CurrencyExchangeHelper::amount(accountingTaxAmount, companyStandardCurrency);
                taxCodeCurrencyAmount = taxTransBeingSettled.TaxAmountCur * totalAllocateFactor  - totalSettledTaxAmountCur;
                taxCodeCurrencyAmount = CurrencyExchangeHelper::amount(taxCodeCurrencyAmount, _taxTrans.CurrencyCode);

                if (isTaxCurrencyConversionFeatureEnabled)
                {
                    reportingTaxAmount = taxTransBeingSettled.TaxAmountRep * totalAllocateFactor - totalSettledTaxAmountRep;
                    reportingTaxAmount = CurrencyExchangeHelper::amount(reportingTaxAmount, reportingCurrencyCode);
                }
            }
            else if (taxTransActual.SourceRegulateAmountCur != 0)
            {
                real localFactor;
                // Calculates the allocate factor based on the actual tax transaction.
                if (isTaxSettlementNegativeFactorFlightEnabled)
                {
                    localFactor = abs(accountingDistribution.TransactionCurrencyAmount / taxTransActual.SourceRegulateAmountCur);
                }
                else
                {
                    localFactor = accountingDistribution.TransactionCurrencyAmount / taxTransActual.SourceRegulateAmountCur;
                }

                accountingTaxAmount = taxTransBeingSettled.TaxAmount * localFactor;
                accountingTaxAmount = CurrencyExchangeHelper::amount(accountingTaxAmount, companyStandardCurrency);
                // accounting currency to tax code currency
                taxCodeCurrencyAmount = taxTransBeingSettled.TaxAmountCur * localFactor;
                taxCodeCurrencyAmount = CurrencyExchangeHelper::amount(taxCodeCurrencyAmount, _taxTrans.CurrencyCode);
                totalSettledTaxAmountMST += accountingTaxAmount;
                totalSettledTaxAmountCur += taxCodeCurrencyAmount;

                if (isTaxCurrencyConversionFeatureEnabled)
                {
                    reportingTaxAmount = taxTransBeingSettled.TaxAmountRep * localFactor;
                    reportingTaxAmount = CurrencyExchangeHelper::amount(reportingTaxAmount, reportingCurrencyCode);

                    totalSettledTaxAmountRep += reportingTaxAmount;
                }
            }
            else
            {
                accountingTaxAmount = 0;
                taxCodeCurrencyAmount = 0;

                if (isTaxCurrencyConversionFeatureEnabled)
                {
                    reportingTaxAmount = 0;
                }
            }

            // Maintaining the call for compatibility.
            this.post(_taxTrans.TaxDirection,
                taxLedgerDimensionAccount_MX,
                useTaxPayableLedgerDimension,
                taxClearingLedgerDimension,
                currencyCode,
                taxCodeCurrencyAmount * -1,
                0,
                accountingTaxAmount * -1,
                _currencyHelper,
                _taxTransOffsetRecId,
                _taxTrans.TaxCode,
                _taxTrans.TaxOrigin);

            this.postV2(_taxTrans.TaxDirection,
                taxLedgerDimensionAccount_MX,
                useTaxPayableLedgerDimension,
                taxClearingLedgerDimension,
                currencyCode,
                taxCodeCurrencyAmount * -1,
                0,
                accountingTaxAmount * -1,
                _currencyHelper,
                _taxTransOffsetRecId,
                _taxTrans.TaxCode,
                _taxTrans.TaxOrigin,
                0,
                isTaxCurrencyConversionFeatureEnabled ? reportingTaxAmount * -1 : 0,
                0);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveOffsetTaxTrans</Name>
				<Source><![CDATA[
    private RecId saveOffsetTaxTrans(
        TaxTrans                _taxTrans,
        boolean                 _excessRecPosting = false,
        LedgerDimensionAccount  _taxLedgerDimension = 0
        )
    {
        TaxReportOffsetTaxTransCreator  offsetCreator;
        
        if (!companyStandardCurrency)
        {
            companyStandardCurrency = CompanyInfoHelper::standardCurrency();
        }
        
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            offsetCreator = TaxReportOffsetTaxTransCreator_IN::constructAndInit(
                voucher,
                transactionDate,
                taxPeriod,
                fromDate,
                _excessRecPosting,
                _taxLedgerDimension,
                0,
                taxRegistrationNumber,
                isIndirectTax,
                0,
                ExciseRecordType_IN::None,
                taxAuthorityAddress,
                false,
                false);
        }
        else if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL, #isoCZ, #isoHU, #isoEE, #isoLT, #isoLV])
            || TaxParameters::reportUseVATDueDateByFeature())
        {
            offsetCreator = TaxReportOffsetTaxTransCreator_W::constructAndInit(
                voucher,
                transactionDate,
                taxPeriod,
                fromDate);
        }
        else
        {
            offsetCreator = TaxReportOffsetTaxTransCreator::constructAndInit(
                voucher,
                transactionDate,
                taxPeriod,
                fromDate);
        }

        return offsetCreator.saveOffsetTaxTrans(_taxTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setIndirectTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets indirect tax.
    /// </summary>
    public void setIndirectTax_IN()
    {
        if (countryRegion_IN && taxRegistrationNumber && taxRegistrationGroupName)
        {
            isIndirectTax = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleOtherAmounts</Name>
				<Source><![CDATA[
    TaxAmount settleOtherAmounts(DimensionDefault _defaultDimension)
    {
        LedgerDimensionDefaultAccount   pennyDiffDefaultAccount;
        LedgerDimensionAccount          pennyDiffDimAccount;
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        TaxAmount                       taxAmountRoundDiff;
        TaxAuthorityAddress             taxAuthority;
        CurrencyExchangeHelper          currencyExchangeHelper;
        DimensionDefault                mainAccdefaultDimension;
        MainAccountLegalEntity          mainAccountLegalEntity;

        taxAuthority = TaxAuthorityAddress::find(TaxPeriodHead::find(taxPeriod).TaxAuthority);

        //If there is vendor account for tax authority, it rounds amount in vendor currency.
        //If the tax currency conversion feature enabled, and the tax conversion parameter is reporting currency, it rounds amount in reporting currency.
        //If there is no venfor account for tax authority, it rounds amount in accounting currency.
        if (VendAccount)
        {
            if (usePublicSectorDistributedPosting)
            {
                // For usePublicSectorDistributedPosting scenario, since it has already been rounded in postv2 method, it should not be rounded again.
                taxAmountRoundDiff = taxAmountRoundingDelta;
            }
            else
            {
                taxAmountRoundDiff = taxAuthority.roundOffTaxAmount(totalClearingAmountTaxAuthorityCur) - totalClearingAmountTaxAuthorityCur;
            }
            totalClearingAmountTaxAuthorityCur += taxAmountRoundDiff;
        }
        else if (isTaxCurrencyConversionPathRep)
        {
            taxAmountRoundDiff = taxAuthority.roundOffTaxAmount(totalClearingAmountRep) - totalClearingAmountRep;
        }
        else
        {
            taxAmountRoundDiff = taxAuthority.roundOffTaxAmount(totalClearingAmountMST) - totalClearingAmountMST;
        }

        if (taxAmountRoundDiff)
        {
            pennyDiffDefaultAccount = LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::VATRoundOff);

            if (!pennyDiffDefaultAccount)
                throw error (strFmt("@SYS66102", LedgerPostingType::VATRoundOff));

            mainAccountLegalEntity = MainAccountLegalEntity::findByMainAccountLegalEntity(MainAccount::findByLedgerDimension(pennyDiffDefaultAccount).RecId, CompanyInfo::current());

            mainAccdefaultDimension = mainAccountLegalEntity.DefaultDimension;

            pennyDiffDimAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(pennyDiffDefaultAccount, _defaultDimension, mainAccdefaultDimension);

            currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), ledgerVoucher.findLedgerVoucherObject().parmAccountingDate());

            if (VendAccount)
            {
                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                ledgerVoucher.findLedgerVoucherObject(),
                                                LedgerPostingType::VATRoundOff,
                                                pennyDiffDimAccount,
                                                VendTable::find(vendAccount).Currency,
                                                -taxAmountRoundDiff,
                                                currencyExchangeHelper);

                ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::Detail);
                ledgerVoucher.addTrans(ledgerVoucherTransObject);

                if (isTaxCurrencyConversionPathRep)
                {
                    taxAmountRoundDiff = -LedgerVoucherTransObject.parmReportingCurrencyAmount();
                }
                else
                {
                    taxAmountRoundDiff = -LedgerVoucherTransObject.parmAccountingCurrencyAmount();
                }
            }
            else
            {
                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                ledgerVoucher.findLedgerVoucherObject(),
                                                LedgerPostingType::VATRoundOff,
                                                pennyDiffDimAccount,
                                                isTaxCurrencyConversionPathRep ? reportingCurrencyCode : Ledger::accountingCurrency(),
                                               -taxAmountRoundDiff,
                                                currencyExchangeHelper);

                ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::Detail);
                ledgerVoucher.addTrans(ledgerVoucherTransObject);
            }
        }

        return taxAmountRoundDiff;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the taxPeriod variable.
    /// </summary>
    /// <returns>
    ///    The taxPeriod variable.
    /// </returns>
    public TaxPeriod   taxPeriod()
    {
        return taxPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxRegistrationGroupName_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The tax registration group name.
    /// </summary>
    /// <returns>
    /// The reference of the RecId.
    /// </returns>
    RefRecId taxRegistrationGroupName_IN()
    {
        return taxRegistrationGroupName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxRegistrationNumber_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets tax registration number.
    /// </summary>
    /// <returns>
    /// The reference of the RecId.
    /// </returns>
    RefRecId   taxRegistrationNumber_IN()
    {
        return taxRegistrationNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxReported</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the report is set for updating.
    /// </summary>
    /// <returns>
    ///    <c>NoYes::Yes</c> if the report is set for updating; otherwise, <c>NoYes::No</c>.
    /// </returns>
    public NoYes taxReported()
    {
        if (updateNow)
            return NoYes::Yes;

        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxReportVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates record for <c>TaxReportVoucher</c>.
    /// </summary>
    /// <returns>The bufer of <c>TaxReportVoucher</c>.</returns>
    TaxReportVoucher taxReportVoucher()
    {
        TaxReportVoucher    taxReportVoucher;

        taxReportVoucher.Voucher        = voucher;
        taxReportVoucher.TransDate      = transactionDate;
        taxReportVoucher.TaxPeriod      = taxPeriod;
        taxReportVoucher.FromDate       = fromDate;
        taxReportVoucher.ToDate         = toDate;
        taxReportVoucher.TaxRepVersion  = taxRepVersion;
        taxReportVoucher.TaxRepCounter  = TaxReportPeriod::version(taxPeriod, fromDate);

        // <GIN>
        if (isIndirectTax)
        {
            taxReportVoucher.TaxRepCounter  = TaxReportPeriod_IN::version(taxPeriod, taxRegistrationNumber,fromDate);
        }

        if (countryRegion_IN)
        {
            taxReportVoucher.TaxType_IN                     = this.checkTaxType_IN();
            taxReportVoucher.TaxRegistrationNumberTable_IN  = taxRegistrationNumber;
        }
        // </GIN>

        return taxReportVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxRepVersion</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the variable taxRepVersion.
    /// </summary>
    /// <returns>
    ///    The variable taxRepVersion.
    /// </returns>
    public TaxRepVersion  taxRepVersion()
    {
        return taxRepVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>toDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Displays the variable toDate
    /// </summary>
    /// <returns>
    ///    The value of the variable named toDate.
    /// </returns>
    public EndDate toDate()
    {
        return toDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Displays the variable transactionDate.
    /// </summary>
    /// <returns>
    ///    The value of the variable transactionDate.
    /// </returns>
    public TransDate transDate()
    {
        return transactionDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Version version = RunBase::getVersion(packedClass);

        switch (version)
        {
            case #CurrentVersion :
                [version, #CurrentList] = packedClass;
                if (SysPackExtensions::findExtension(packedClass, classStr(TaxReport) + '.' + varStr(printReport)))
                {
                    printReport = SysPackExtensions::extractPackedVariable(packedClass, classStr(TaxReport), varStr(printReport));
                }
                else
                {
                    printReport = NoYes::Yes;
                }

                break;

            default :
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the variable updateNow.
    /// </summary>
    /// <returns>
    ///    The value of the variable updateNow.
    /// </returns>
    public NoYes update()
    {
        return updateNow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAndPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates and posts tax transactions.
    /// </summary>
    /// <returns>The counter of posted tax transactions.</returns>
    Counter updateAndPost()
    {
        Counter     versionMax;
        Counter     versionMin;

        versionMax  = TaxReport::counterMax(taxRepVersion, taxPeriod, fromDate);
        versionMin  = TaxReport::counterMin(taxRepVersion, taxPeriod, fromDate);

        TaxPeriodHead taxPeriodHead = TaxPeriodHead::find(taxPeriod);

        if (!taxPeriodHead.NotGenerateOffsetTaxTrans)
        {
            this.insertOffsetTaxTrans(fromDate, toDate, versionMin, versionMax);
        }

        return this.updateAndPostTaxTrans(fromDate, toDate, versionMin, versionMax);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAndPostTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates and posts tax transactions.
    /// </summary>
    /// <param name = "_fromDate">The from date.</param>
    /// <param name = "_toDate">The to date.</param>
    /// <param name = "_versionMin">The min version.</param>
    /// <param name = "_versionMax">The max version.</param>
    /// <returns>The counter of posted tax transactions.</returns>
    Counter updateAndPostTaxTrans(FromDate _fromDate,
                                  ToDate   _toDate,
                                  Counter  _versionMin,
                                  Counter  _versionMax)
    {
        TaxTrans taxTrans;
        Counter transactionsInTax;
        TaxTransGeneralJournalAccountEntryView taxTransGeneralJournalAccountEntryView;
        TaxTransGeneralJournalAccountEntryView useTaxTransGeneralJournalAccountEntryView;
        TaxTransGeneralJournalAccountEntryView taxInCostPriceTaxTransGeneralJournalAccountEntryView;
        RecId lastTaxTransRecId;
        boolean useVatDueDate_W = TaxParameters::reportUseVatDueDate_W();
        boolean isHU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU]);
        TaxTrans_W taxTrans_W;
        Map continuousHUTaxItemGroupMap = new Map(Types::String, Types::AnyType);

        Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource taxEventSourceLog = Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource::Log;

        companyStandardCurrency = CompanyInfoHelper::standardCurrency();
        overridenForMethodUpdateAndPostTaxTrans = false;

        currencyExchRateGainAmtMap = new Map(Types::String, Types::Container);
        currencyExchRateLossAmtMap = new Map(Types::String, Types::Container);

        if (useVatDueDate_W)
        {
            if (isTaxSettlementStateCollectionFlightEnabled)
            {
                processedCount = 0;
                totalCount = 0;
                postedV2Count = 0;
                postedV2UseTaxCount = 0;
                processMessage = '';
                sqlStatement = '';

                // log starts
                // this is the pre-query statement, the sql querry will not be executed
                select generateOnly forceLiterals count(RecId) from taxTrans
                    where taxTrans.TaxPeriod       ==  taxPeriod
                        && taxTrans.TaxRepCounter  >= _versionMin
                        && taxTrans.TaxRepCounter  <= _versionMax
                        && !taxTrans.PostponeVAT
                        && taxTrans.Source         != TaxModuleType::Tax
                    join taxTrans_W
                        where taxTrans_W.TaxTrans       == taxTrans.RecId
                            && taxTrans_W.VatDueDate_W  >= _fromDate
                            && taxTrans_W.VatDueDate_W  <= _toDate
                            && (taxTrans.TaxAmountCur
                                || (bankExchRate && taxTrans.TaxAmount)
                                || taxTrans.TaxBaseQty
                                || taxTrans.TaxBaseAmount
                                || taxTrans.TaxBaseAmountCur
                                || taxTrans.TaxInCostPrice
                                || taxTrans.TaxInCostPriceMST
                                || taxTrans.TaxInCostPriceCur)
                    outer join LedgerDimension from taxTransGeneralJournalAccountEntryView
                        where taxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
                            && taxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::Tax
                    outer join LedgerDimension from useTaxTransGeneralJournalAccountEntryView
                        where useTaxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
                            && useTaxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::UseTaxPayable
                    outer join LedgerDimension from taxInCostPriceTaxTransGeneralJournalAccountEntryView
                        where taxInCostPriceTaxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
                            && taxInCostPriceTaxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::TaxInCostPrice;

                sqlStatement = taxTrans.getSQLStatement();

                // this will indicate how many taxTrans should be processed.
                select firstonly count(RecId),  sum(TaxAmount), sum(TaxInCostPriceMST) from taxTrans
                    where taxTrans.TaxPeriod       ==  taxPeriod
                        && taxTrans.TaxRepCounter  >= _versionMin
                        && taxTrans.TaxRepCounter  <= _versionMax
                        && !taxTrans.PostponeVAT
                        && taxTrans.Source         != TaxModuleType::Tax
                    join taxTrans_W
                        where taxTrans_W.TaxTrans       == taxTrans.RecId
                            && taxTrans_W.VatDueDate_W  >= _fromDate
                            && taxTrans_W.VatDueDate_W  <= _toDate
                            && (taxTrans.TaxAmountCur
                                || (bankExchRate && taxTrans.TaxAmount)
                                || taxTrans.TaxBaseQty
                                || taxTrans.TaxBaseAmount
                                || taxTrans.TaxBaseAmountCur
                                || taxTrans.TaxInCostPrice
                                || taxTrans.TaxInCostPriceMST
                                || taxTrans.TaxInCostPriceCur)
                    outer join LedgerDimension from taxTransGeneralJournalAccountEntryView
                        where taxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
                            && taxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::Tax
                    outer join LedgerDimension from useTaxTransGeneralJournalAccountEntryView
                        where useTaxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
                            && useTaxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::UseTaxPayable
                    outer join LedgerDimension from taxInCostPriceTaxTransGeneralJournalAccountEntryView
                        where taxInCostPriceTaxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
                            && taxInCostPriceTaxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::TaxInCostPrice;

                processMessage += '|Use VAT Due Date|';
                processMessage += '|All PreparedCount: ' + int642Str(taxTrans.RecId);
                processMessage += '|All Total Amount:  ' + num2Str(taxTrans.TaxAmount, 1, 6, 1, 0);
                processMessage += '|All Total Tax In Cost Price: ' + num2Str(taxTrans.TaxInCostPriceMST, 1, 6, 1, 0);
                totalCount = taxTrans.RecId;

                // use tax will be handled in postV2 separately
                select count(RecId),  sum(TaxAmount), sum(TaxInCostPriceMST) from taxTrans
                    where taxTrans.TaxPeriod       ==  taxPeriod
                        && taxTrans.TaxRepCounter  >= _versionMin
                        && taxTrans.TaxRepCounter  <= _versionMax
                        && !taxTrans.PostponeVAT
                        && taxTrans.Source         != TaxModuleType::Tax
                        && taxTrans.TaxDirection == TaxDirection::UseTax
                    join taxTrans_W
                        where taxTrans_W.TaxTrans       == taxTrans.RecId
                            && taxTrans_W.VatDueDate_W  >= _fromDate
                            && taxTrans_W.VatDueDate_W  <= _toDate
                            && (taxTrans.TaxAmountCur
                                || (bankExchRate && taxTrans.TaxAmount)
                                || taxTrans.TaxBaseQty
                                || taxTrans.TaxBaseAmount
                                || taxTrans.TaxBaseAmountCur
                                || taxTrans.TaxInCostPrice
                                || taxTrans.TaxInCostPriceMST
                                || taxTrans.TaxInCostPriceCur);

                processMessage += '|Use Tax PreparedCount: ' + int642Str(taxTrans.RecId);
                processMessage += '|Use Tax Total Amount: ' + num2Str(taxTrans.TaxAmount, 1, 6, 1, 0);
                processMessage += '|Use Tax Total Tax In Cost Price: ' + num2Str(taxTrans.TaxInCostPriceMST, 1, 6, 1, 0);
                // log ends.
            }

            while select * from taxTrans
                where taxTrans.TaxPeriod       ==  taxPeriod
                    && taxTrans.TaxRepCounter  >= _versionMin
                    && taxTrans.TaxRepCounter  <= _versionMax
                    && !taxTrans.PostponeVAT
                    && taxTrans.Source         != TaxModuleType::Tax
                outer join LedgerDimension from taxTransGeneralJournalAccountEntryView
                    where taxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
                        && taxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::Tax
                outer join LedgerDimension from useTaxTransGeneralJournalAccountEntryView
                    where useTaxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
                        && useTaxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::UseTaxPayable
                outer join LedgerDimension from taxInCostPriceTaxTransGeneralJournalAccountEntryView
                    where taxInCostPriceTaxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
                        && taxInCostPriceTaxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::TaxInCostPrice
                exists join taxTrans_W
                    where taxTrans_W.TaxTrans       == taxTrans.RecId
                        && taxTrans_W.VatDueDate_W  >= _fromDate
                        && taxTrans_W.VatDueDate_W  <= _toDate
                        && (taxTrans.TaxAmountCur
                            || (bankExchRate && taxTrans.TaxAmount)
                            || taxTrans.TaxBaseQty
                            || taxTrans.TaxBaseAmount
                            || taxTrans.TaxBaseAmountCur
                            || taxTrans.TaxInCostPrice
                            || taxTrans.TaxInCostPriceMST
                            || taxTrans.TaxInCostPriceCur)
            {
                taxInCostPriceLedgerDimension = taxInCostPriceTaxTransGeneralJournalAccountEntryView.LedgerDimension;

                LedgerDimensionAccount taxLedgerDimension = taxTransGeneralJournalAccountEntryView.LedgerDimension;

                if (isHU && this.isTaxItemGroupContinuousHU(continuousHUTaxItemGroupMap, taxTrans.TaxItemGroup))
                {
                    taxLedgerDimension = this.getTaxLedgerDimension(taxLedgerDimension, taxTrans);
                }

                if (this.updateAndPostTaxTransSingle(taxTrans,
                        taxLedgerDimension,
                        useTaxTransGeneralJournalAccountEntryView.LedgerDimension))
                {
                    transactionsInTax++;
                    if (isTaxSettlementStateCollectionFlightEnabled)
                    {
                        processedCount++; // we would need a class level counter in case the block exists with excepthion.
                    }
                }
            }
        }
        else
        {
            TaxTrans offsetTaxTrans;

            if (isTaxSettlementStateCollectionFlightEnabled)
            {
                processedCount = 0;
                totalCount = 0;
                postedV2Count = 0;
                postedV2UseTaxCount = 0;
                processMessage = '';
                sqlStatement = '';

                // log starts
                // this is the pre-query statement, the sql query will not be executed
                select generateOnly forceLiterals count(RecId) from taxTrans
                    where #TaxTransWhereClause
                    outer join RecId from offsetTaxTrans
                        where offsetTaxTrans.OriginTaxTransRecId == taxTrans.RecId
                    outer join LedgerDimension from taxTransGeneralJournalAccountEntryView
                        where taxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
                            && taxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::Tax
                    outer join LedgerDimension from useTaxTransGeneralJournalAccountEntryView
                        where useTaxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
                            && useTaxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::UseTaxPayable
                    outer join LedgerDimension from taxInCostPriceTaxTransGeneralJournalAccountEntryView
                        where taxInCostPriceTaxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
                            && taxInCostPriceTaxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::TaxInCostPrice;

                sqlStatement = taxTrans.getSQLStatement();

                // this will indicate how many taxTrans should be processed.
                select firstonly count(RecId), sum(TaxAmount), sum(TaxInCostPriceMST) from taxTrans
                    where #TaxTransWhereClause
                    outer join RecId from offsetTaxTrans
                        where offsetTaxTrans.OriginTaxTransRecId == taxTrans.RecId
                    outer join LedgerDimension from taxTransGeneralJournalAccountEntryView
                        where taxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
                            && taxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::Tax
                    outer join LedgerDimension from useTaxTransGeneralJournalAccountEntryView
                        where useTaxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
                            && useTaxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::UseTaxPayable
                    outer join LedgerDimension from taxInCostPriceTaxTransGeneralJournalAccountEntryView
                        where taxInCostPriceTaxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
                            && taxInCostPriceTaxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::TaxInCostPrice;

                processMessage += '|All PreparedCount: ' + int642Str(taxTrans.RecId);
                processMessage += '|All Total Amount:  ' + num2Str(taxTrans.TaxAmount, 1, 6, 1, 0);
                processMessage += '|All Total Tax In Cost Price: ' + num2Str(taxTrans.TaxInCostPriceMST, 1, 6, 1, 0);
                totalCount = taxTrans.RecId;

                // use tax will be handled in postV2 separately
                select count(RecId), sum(TaxAmount), sum(TaxInCostPriceMST) from taxTrans
                    where #TaxTransWhereClause
                        && taxTrans.TaxDirection == TaxDirection::UseTax;

                processMessage += '|Use Tax PreparedCount: ' + int642Str(taxTrans.RecId);
                processMessage += '|Use Tax Total Amount: ' + num2Str(taxTrans.TaxAmount, 1, 6, 1, 0);
                processMessage += '|Use Tax Total Tax In Cost Price: ' + num2Str(taxTrans.TaxInCostPriceMST, 1, 6, 1, 0);
                // log ends.
            }

            while select * from taxTrans
                where #TaxTransWhereClause
                outer join RecId from offsetTaxTrans
                    where offsetTaxTrans.OriginTaxTransRecId == taxTrans.RecId
                outer join LedgerDimension from taxTransGeneralJournalAccountEntryView
                    where taxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
                        && taxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::Tax
                outer join LedgerDimension from useTaxTransGeneralJournalAccountEntryView
                    where useTaxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
                        && useTaxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::UseTaxPayable
                outer join LedgerDimension from taxInCostPriceTaxTransGeneralJournalAccountEntryView
                    where taxInCostPriceTaxTransGeneralJournalAccountEntryView.TaxTrans == taxTrans.RecId
                        && taxInCostPriceTaxTransGeneralJournalAccountEntryView.TaxTransRelationship == TaxTransRelationshipType::TaxInCostPrice
            {
                // In case there are two TaxTransGeneralJournalAccountEntry for the same tax trans
                if (taxTrans.RecId == lastTaxTransRecId)
                {
                    continue;
                }

                taxInCostPriceLedgerDimension = taxInCostPriceTaxTransGeneralJournalAccountEntryView.LedgerDimension;
                taxTransOffsetRecId = offsetTaxTrans.RecId;

                LedgerDimensionAccount taxLedgerDimension = taxTransGeneralJournalAccountEntryView.LedgerDimension;

                if (isHU && this.isTaxItemGroupContinuousHU(continuousHUTaxItemGroupMap, taxTrans.TaxItemGroup))
                {
                    taxLedgerDimension = this.getTaxLedgerDimension(taxLedgerDimension, taxTrans);
                }

                if (this.updateAndPostTaxTransSingle(taxTrans,
                        taxLedgerDimension,
                        useTaxTransGeneralJournalAccountEntryView.LedgerDimension))
                {
                    transactionsInTax++;
                    if (isTaxSettlementStateCollectionFlightEnabled)
                    {
                        processedCount++; // we would need a class level counter in case the block exists with excepthion.
                    }
                }

            }
        }

        if (isTaxReportPerfImprovByVoucherTransCombineFlightEnabled)
        {
            taxReportVoucherTransCombine.addTransToVoucher(
                ledgerPostingController,
                transactionDate);
        }

        if (!isPopulateDimensionForExchGainLossAccount && isTaxReportCombineVoucherForGainLoss)
        {
            // Posts combined voucher for exchange rate loss account.
            this.postCombinedLedgerVoucherTransObjectForExchRateGainLoss(currencyExchRateLossAmtMap, LedgerPostingType::ExchRateLoss, lossLedgerDimension);

            // Posts combined voucher for exchange rate gain account.
            this.postCombinedLedgerVoucherTransObjectForExchRateGainLoss(currencyExchRateGainAmtMap, LedgerPostingType::ExchRateGain, gainLedgerDimension);
        }

        if (isTaxSettlementStateCollectionFlightEnabled)
        {
            processMessage += '|Total TaxTrans: ' + int642Str(totalCount);
            processMessage += '|Processed TaxTrans: ' + int642Str(processedCount);
            processMessage += '|Processed PostV2: ' + int642Str(postedV2Count);
            processMessage += '|Processed PostV2 for Use Tax: ' + int642Str(postedV2UseTaxCount);
            taxEventSourceLog.LogTaxSettlementState(voucher, processMessage, sqlStatement);

            if (TaxSettlementInconsistentStateBlockingFlight::instance().isEnabled() && (totalCount != processedCount))
            {
                printout = NoYes::No;
                throw error("@Tax:SettlementTaxTransCountInconsistency");
            }
        }

        return transactionsInTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get Tax LedgerDimension used for settle, exclude the Deferred VAT account.
    /// </summary>
    /// <param name = "_ledgerDimension">The ledgerDimension.</param>
    /// <param name = "_taxTrans">The buffer of <c>TaxTrans</c>.</param>
    /// <returns>The LedgerDimension used for settle.</returns>
    private LedgerDimensionAccount getTaxLedgerDimension(LedgerDimensionAccount _taxLedgerDimension, TaxTrans _taxTrans)
    {
        LedgerDimensionAccount taxLedgerDimension = _taxLedgerDimension;

        if (!_taxTrans.SourceDocumentLine)
        {
            TaxLedgerAccountGroup taxLedgerAccountGroup = TaxLedgerAccountGroup::find(TaxTable::find(_taxTrans.TaxCode).TaxAccountGroup);
            MainAccount deferredVATAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(taxLedgerAccountGroup.taxLedgerDimension_HU(_taxTrans.TaxDirection));
            DimensionAttributeValueCombination dimAttrValueCombo;
            TaxTransGeneralJournalAccountEntry taxTransGeneralJournalAccountEntry;
            select firstonly LedgerDimension from taxTransGeneralJournalAccountEntry
                where taxTransGeneralJournalAccountEntry.TaxTrans == _taxTrans.RecId
                    && taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::Tax
                exists join dimAttrValueCombo
                    where dimAttrValueCombo.RecId == taxTransGeneralJournalAccountEntry.LedgerDimension
                        && dimAttrValueCombo.MainAccount != deferredVATAccount.RecId;

            if (taxTransGeneralJournalAccountEntry.LedgerDimension)
            {
                taxLedgerDimension = taxTransGeneralJournalAccountEntry.LedgerDimension;
            }
        }

        return taxLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxItemGroupContinuousHU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check the taxItemGroup is continuousHU or not.
    /// </summary>
    /// <param name = "_continuousHUTaxItemGroupMap">A Map to cache the result.</param>
    /// <param name = "_taxItemGroup">The taxItemGroup.</param>
    /// <returns>>true if the taxItemGroup is continuousHU, otherwise, false.</returns>
    private boolean isTaxItemGroupContinuousHU(Map _continuousHUTaxItemGroupMap, TaxItemGroup _taxItemGroup)
    {
        boolean ret;

        if (_continuousHUTaxItemGroupMap.exists(_taxItemGroup))
        {
            ret = _continuousHUTaxItemGroupMap.lookup(_taxItemGroup);
        }
        else
        {
            ret = TaxItemGroupHeading::find(_taxItemGroup).Continuous_HU;
            _continuousHUTaxItemGroupMap.insert(_taxItemGroup, ret);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAndPostTaxTransSingle</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates and posts single tax transaction.
    /// </summary>
    /// <param name = "_taxTrans">The buffer of <c>TaxTrans</c>.</param>
    /// <param name = "_taxLedgerDimension">The tax account.</param>
    /// <param name = "_useTaxPayableLedgerDimension">The use tax payable account.</param>
    /// <returns>true if post successfully; otherwise false.</returns>
    protected boolean updateAndPostTaxTransSingle(TaxTrans _taxTrans,
        LedgerDimensionAccount _taxLedgerDimension = 0,
        LedgerDimensionAccount _useTaxPayableLedgerDimension = 0)
    {
        boolean isProcessed;

        CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
            Ledger::primaryLedger(_taxTrans.companyInfo().RecId),
            transactionDate);

        taxPurchaseTaxPost.sumPurchaseTax(_taxTrans);
        this.saveAndPostRetrieveAccountsAndAmounts(_taxTrans, currencyExchangeHelper, _taxLedgerDimension, _useTaxPayableLedgerDimension);
        isProcessed = true;

        return isProcessed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNow</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the ledger or the vendor transactions and inserts a record in the TaxReportVoucher table.
    /// </summary>
    void updateNow()
    {
        TaxReportVoucher                taxReportVoucher;
        DueDate                         dueDate;
        VendTrans                       vendTrans;
        VendTable                       vendTable;
        TaxAmount                       taxAmount;
        TransactionTxt                  transactionTxt;
        VendVoucher                     vendVoucher;
        ExchangeRateHelper              exchangeRateHelper;
        CurrencyExchangeHelper          currencyExchangeHelper;
        // <GEERU>
        LedgerBondClient_RU             ledgerBondClient;
        // </GEERU>

        // <GIN>
        RefRecId                        componentLoc;
        TaxAmount                       taxExcessAmount;
        MapEnumerator                   authorityTaxMapEnumerator;
        TaxReportPeriod_IN              taxReportPeriodLoc;
        // </GIN>

        transactions    = 0;
        taxTransactions = 0;

        if (!taxAuthorityAddress)
        {
            taxAuthorityAddress = TaxAuthorityAddress::find(TaxPeriodHead::find(taxPeriod).TaxAuthority);
            vendAccount = taxAuthorityAddress.AccountNum;
        }

        usePublicSectorDistributedPosting = this.usePublicSectorPostingByDimensions();

        transactionTxt = TransactionTxt::construct();
        transactionTxt.setType(LedgerTransTxt::TaxReporting);
        transactionTxt.setVoucher(voucher);
        transactionTxt.setKey1(taxPeriod);
        transactionTxt.setDate(transactionDate);

        ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Summary,
                                                         SysModule::Tax,
                                                         numberSeq.parmVoucherSequenceCode());

        ledgerVoucher.parmCheckBlockedDimensions(false);

        ledgerVoucher.addVoucher(
            LedgerVoucherObject::newVoucher(voucher,
                                            transactionDate,
                                            SysModule::Tax,
                                            LedgerTransType::Tax));

        ledgerVoucher.findLedgerVoucherObject().lastTransTxt(transactionTxt.txt());
        taxPurchaseTaxPost = new TaxPurchaseTaxPost(ledgerVoucher, toDate);
        // <GEERU>
        ledgerBondClient = ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
        if (ledgerBondClient)
        {
            ledgerBondClient.addNewLogObject();
        }
        // </GEERU>

        ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher);

        taxTransactions = this.updateAndPost();
        taxPurchaseTaxPost.postPurchaseTax();

        if (vendAccount)
            vendTable = VendTable::find(vendAccount);

        taxAmount = this.settleOtherAmounts(vendTable.DefaultDimension);

        currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), ledgerVoucher.findLedgerVoucherObject().parmAccountingDate());

        if (taxTransactions || transactions)
        {
            if (!vendAccount)
            {
                CurrencyCode currencyCodeLoc;

                if (isTaxCurrencyConversionPathRep)
                {
                    currencyCodeLoc = Ledger::reportingCurrency();
                }
                else
                {
                    currencyCodeLoc = Ledger::accountingCurrency();
                }

                ledgerVoucher.addTrans(
                    LedgerVoucherTransObject::newTransactionAmountDefault(
                        ledgerVoucher.findLedgerVoucherObject(),
                        LedgerPostingType::Tax,
                        taxClearingLedgerDimension,
                        currencyCodeLoc,
                        taxAmount,
                        currencyExchangeHelper));
            }
            else
            {
                // <GIN>
                if (countryRegion_IN
                    && isIndirectTax)
                {
                    Map authorityTaxMap = Map::create(this.parmTaxAmounts_IN());

                    authorityTaxMapEnumerator = authorityTaxMap.getEnumerator();
                    if (authorityTaxMapEnumerator != null && TaxRegistrationNumbers_IN::find(taxRegistrationNumber).TaxType != TaxType_IN::Excise)
                    {
                        // Loop thru the MAP which contains Taxes grouped & summed per Component and then post them to authority vendor.
                        while (authorityTaxMapEnumerator.moveNext())
                        {
                            taxExcessAmount = authorityTaxMapEnumerator.currentValue();
                            // Post 2 Authority only if payables are there for normal case.
                            if (taxExcessAmount < 0 )
                            {
                                vendVoucher = CustVendVoucher::construct(SysModule::Vend,
                                                      vendTable.AccountNum,
                                                      taxExcessAmount,
                                                      vendTable.Currency,
                                                      LedgerTransTxt::TaxReporting,
                                                      vendTable.DefaultDimension,
                                                      VendParameters::find().PostingProfile,
                                                      LedgerPostingType::Tax,
                                                      vendTable.PaymTermId,
                                                      SettlementType::None,
                                                      HcmWorker::userId2Worker(curUserId()),
                                                      NoYes::Yes,
                                                      '',
                                                      dateNull(),
                                                      0,
                                                      dueDate,
                                                      vendTrans);

                                vendVoucher.parmTransTxt("@SYS23178");
                                vendVoucher.parmPaymMode(vendTable.PaymMode);
                                vendVoucher.parmPaymSpec(vendTable.PaymSpec);

                                vendVoucher.parmExchRate(
                                    ExchangeRateHelper::getExchangeRate1_Static(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),vendTable.Currency, transactionDate));

                                vendVoucher.parmExchRateSecondary(
                                    ExchangeRateHelper::getExchangeRate2_Static(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), vendTable.Currency, transactionDate));

                                componentLoc = authorityTaxMapEnumerator.currentKey();

                                TaxAmount gtaInterimRecoverableAmount = this.gtaInterimAmount_IN(componentLoc);

                                vendVoucher.parmGTAAmount_IN(gtaInterimRecoverableAmount);

                                if (gtaInterimRecoverableAmount)
                                {
                                    vendVoucher.parmSettlement_IN(NoYes::Yes);
                                }

                                vendVoucher.parmTaxComponent_IN(componentLoc);

                                vendVoucher.post(ledgerVoucher,
                                     vendTrans,
                                     NoYes::No,
                                     UnknownNoYes::Unknown);
                            }
                        }
                    }
                }
                else
                {
                    // </GIN>
                    dueDate   = TaxPeriodHead::taxReportDate(taxPeriod, toDate);
                    TaxAmount taxAmountMSTLoc, taxAmountRepLoc, taxAmountCurLoc;

                    if (lastCurrencyCode != vendTable.Currency)
                    {
                        isPostedTransactionCurrencyTheSame = false;
                    }

                    if (isTaxCurrencyConversionPathRep)
                    {
                        taxAmountRepLoc = taxAmount + totalClearingAmountRep;
                        taxAmountCurLoc = currencyExchangeHelper.calculateCurrencyToCurrency(reportingCurrencyCode, vendTable.Currency, taxAmountRepLoc, true);
                    }
                    else
                    {
                        taxAmountMSTLoc = taxAmount + totalClearingAmountMST;
                        taxAmountCurLoc =  isPostedTransactionCurrencyTheSame ? totalClearingAmountTaxAuthorityCur :CurrencyExchangeHelper::curAmount(taxAmountMSTLoc, vendTable.Currency, transactionDate);
                    }

                    vendVoucher  = CustVendVoucher::construct(SysModule::Vend,
                                                  vendTable.AccountNum,
                                                  taxAmountCurLoc,
                                                  vendTable.Currency,
                                                  LedgerTransTxt::TaxReporting,
                                                  vendTable.DefaultDimension,
                                                  VendParameters::find().PostingProfile,
                                                  LedgerPostingType::Tax,
                                                  vendTable.PaymTermId,
                                                  SettlementType::None,
                                                  HcmWorker::userId2Worker(curUserId()),
                                                  NoYes::Yes,
                                                  '',
                                                  dateNull(),
                                                  0,
                                                  dueDate);

                    vendVoucher.parmTransTxt("@SYS23178");
                    vendVoucher.parmPaymMode(vendTable.PaymMode);
                    vendVoucher.parmPaymSpec(vendTable.PaymSpec);
                    vendVoucher.parmPaymId(vendTable.PaymId);

                    if (isTaxCurrencyConversionPathRep)
                    {
                        vendVoucher.parmReportingCurrencyAmount(taxAmountRepLoc);
                    }
                    else
                    {
                        vendVoucher.parmAmountMST(taxAmountMSTLoc);
                    }

                    exchangeRateHelper = ExchangeRateHelper::newExchangeDate(
                        Ledger::current(),
                        vendTable.Currency,
                        transactionDate);

                    vendVoucher.parmExchRate(exchangeRateHelper.getExchangeRate1());
                    vendVoucher.parmExchRateSecondary(exchangeRateHelper.getExchangeRate2());

                    vendVoucher.post(ledgerVoucher,
                                        vendTrans,
                                        NoYes::No,
                                        UnknownNoYes::Unknown
                                        ,false
                                        ,usePublicSectorDistributedPosting
                                        // <GIN>
                                        || countryRegion_IN
                                        // </GIN>
                                        );

                    // <GIN>
                }
                // </GIN>
            }
        }
        else
        {
            warning("@SYS62090");
            printout = NoYes::No;
        }
        taxReportVoucher = this.taxReportVoucher();
        taxReportVoucher.insert();
        this.createTaxReportExtraFields_AU();

        // <GIN>
        // VAT deferred transaction are not registered, hence in the adjustment form no records are displayed
        if (countryRegion_IN
            && taxParametersLocal.vat_in
            && ! TaxReportPeriod_IN::findByTaxPeriod(taxReportVoucher.TaxPeriod, taxReportVoucher.TaxRegistrationNumberTable_IN, taxReportVoucher.FromDate).RecId)
        {
            taxReportPeriodLoc.TaxPeriod                   = taxReportVoucher.TaxPeriod;
            taxReportPeriodLoc.TaxRegistrationNumberTable  = taxReportVoucher.TaxRegistrationNumberTable_IN;
            taxReportPeriodLoc.FromDate                    = taxReportVoucher.FromDate;
            taxReportPeriodLoc.ToDate                      = taxReportVoucher.ToDate;
            taxReportPeriodLoc.Availed                     = NoYes::Yes;
            taxReportPeriodLoc.insert();
        }
        // </GIN>

        // <GEERU>
        if (ledgerBondClient)
        {
            if (ledgerBondClient.currentLogLength() >= 2)
            {
                ledgerBondClient.bondLastVRef2CurrentLog();
            }
            ledgerBondClient.removeCurrentLogObject();
        }
        // </GEERU>
        ledgerVoucher.end();

        if (isTaxReportPerfImprovByVoucherTransCombineFlightEnabled
            && !isNotGenerateOffsetTaxTrans)
        {
            taxReportVoucherTransCombine.generateTaxLink();
        }

        this.reportingVersionUpdate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxReportExtraFields_AU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates tax report extra fields
    /// </summary>
    protected void createTaxReportExtraFields_AU()
    {
        TaxReportExtraFields            taxReportExtraFields;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoAU]))
        {
            taxReportExtraFields = TaxReportExtraFields::find(taxPeriod, fromDate, toDate, true);

            if (taxReportExtraFields)
            {
                taxReportExtraFields.Voucher = voucher;
                taxReportExtraFields.TransDate = transactionDate;
                taxReportExtraFields.update();
            }
            else
            {
                taxReportExtraFields.TaxPeriod = taxPeriod;
                taxReportExtraFields.FromDate  = fromDate;
                taxReportExtraFields.ToDate    = toDate;
                taxReportExtraFields.Voucher   = voucher;
                taxReportExtraFields.TransDate = transactionDate;
                taxReportExtraFields.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxRegistrationGroup_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates tax registration group.
    /// </summary>
    /// <param name="_taxRegistrationGroupName">
    /// The tax registration group name.
    /// </param>
    public void updateTaxRegistrationGroup_IN(RefRecId _taxRegistrationGroupName)
    {
        TaxRegistrationGroup_IN         taxRegistrationGroup;
        TaxRegistrationGroupSetup_IN    taxRegistrationGroupSetup;

        ttsbegin;

        if (!instanceInUse)
        {
            update_recordset taxRegistrationGroup
                setting InUse = NoYes::No
                   where taxRegistrationGroup.RecId == _taxRegistrationGroupName
                      join taxRegistrationGroupSetup
                         where taxRegistrationGroupSetup.TaxRegistrationGroupName == taxRegistrationGroup.RecId;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>usePublicSectorPostingByDimensions</Name>
				<Source><![CDATA[
    private boolean usePublicSectorPostingByDimensions()
    {
        return isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
            && (PublicSectorUtils::isLegalEntityInSupportedCountryRegion()
                // <GIN>
                || countryRegion_IN);
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>isERMultipleTaxSetupCompleted</Name>
				<Source><![CDATA[
    private boolean isERMultipleTaxSetupCompleted()
    {
        LogisticsAddressCountryRegionId reportCountryRegionId = MultipleTaxIdReportingHelper::getCountryRegionIDFromTaxRegistrationRecId(
            MultipleTaxIdReportingHelper::getTaxRegistrationRecIdFromTaxPeriod(this.taxPeriod()));

        return EUSalesListReportingParameter::findByCountryRegionIdAndReport(
            reportCountryRegionId, ReportingParameterReportCallerName::VATDeclaration).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the instance of the <c>TaxReport</c> class.
    /// </summary>
    /// <param name="calledFrom">
    /// The object called from.
    /// </param>
    /// <returns>
    /// Returns true if the validation succeed.
    /// </returns>
    public boolean validate(Object calledFrom = null)
    {
        boolean ret = super();
        TaxTable                        taxTableloc;
        TaxPeriodHead                   taxPeriodHeadLoc;
        TaxRegistrationNumbers_IN       taxRegistrationNumberTableloc;
        TaxRegistrationGroupSetup_IN    taxRegistrationGroupSetuploc;

        if (countryRegion_IN)
        {
            if (taxRegistrationGroupName && !taxRegistrationNumber)
            {
                throw error(strFmt("@SYS26332", "@SYS59571"));
            }

            if (taxRegistrationGroupName && taxRegistrationNumber)
            {
                if (!TaxRegistrationGroupSetup_IN::findByTaxRegistrationGroupName_IN(taxRegistrationGroupName ,taxRegistrationNumber))
                {
                    throw error("@GLS6321");
                }
            }

            select firstonly taxTableloc
                where taxTableloc.TaxPeriod   ==  taxPeriod
            exists join taxRegistrationNumberTableloc
                where taxRegistrationNumberTableloc.TaxType == taxTableloc.TaxType_IN
                   && taxRegistrationNumberTableloc.RecId == taxRegistrationNumber
            exists join taxRegistrationGroupSetuploc
                where taxRegistrationGroupSetuploc.TaxRegistrationNumberTable == taxRegistrationNumber
                   && taxRegistrationGroupSetuploc.TaxRegistrationGroupName == taxRegistrationGroupName;

            if (!taxTableloc)
            {
                throw error("@GLS6322");
            }

            taxPeriodHeadLoc = TaxPeriodHead::find(taxPeriod);
            taxAuthorityAddress = TaxAuthorityAddress::find(taxPeriodHeadLoc.TaxAuthority);

            if (taxPeriod && !taxAuthorityAddress.AccountNum)
            {
                warning("@GLS6236");
                throw error("@SYS21533");
            }

            if (!LedgerSystemAccounts::find(LedgerPostingType::TaxAdjustmentSettlement_IN).LedgerDimension)
            {
                warning("@GLS6237");
                throw error("@SYS21533");
            }
        }

        if (this.update() && countryRegion_IT)
        {
            if (!fileName
                && printReport
                && !TaxReportERHelper_IT::isERReportShouldBeUsed(TaxPeriodHead::find(taxPeriod).TaxAuthority))
            {
                ret = checkFailed(strFmt("@SYS84378", extendedTypeId2pname(extendedTypeNum(FilenameSave))));
            }

            NumberSequenceReference numberSequenceReference = TaxParameters::numRefTaxReportingVoucher();
            if (!numberSequenceReference.NumberSequenceId)
            {
                ret = checkFailed(strFmt("@SYS53911", numberSequenceReference.referenceLabel(), numberSequenceReference.referenceModuleLabel()));
            }
        }

        TaxReportPeriod taxReportPeriodloc  = TaxReportPeriod::find(taxPeriod, fromDate);
        if (taxReportPeriodloc && taxReportPeriodloc.isPeriodSettlementInProcess())
        {
            ret = checkFailed(strFmt("@Tax:TaxReportValidate",taxReportPeriodloc.SettlementPeriodInProcessBy));
        }

        if (isMultipleTaxIdEnabled)
        {
            //Check if registration number is filled
            if (!TaxPeriodHead::find(taxPeriod).TaxID && this.isERMultipleTaxSetupCompleted())
            {
                ret = checkFailed(strFmt('@Tax_SettlementForTaxId:InsertTaxTransValidationErrorMessage', taxPeriod));
            }
        }
        else
        {
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBE]))
            {
                ret = ret && this.checkTaxEnterpriseNumberForBE();
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>voucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the voucher variable.
    /// </summary>
    /// <returns>
    ///    The voucher variable.
    /// </returns>
    Voucher voucher()
    {
        return voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>counterMax</Name>
				<Source><![CDATA[
    static Counter counterMax(TaxRepVersion  _taxRepVersion,
                                     TaxPeriod      _taxPeriod,
                                     TransDate      _fromDate)
    {
        if  (_taxRepVersion == TaxRepVersion::Original)
            return 0;
        else
            return TaxReportPeriod::version(_taxPeriod, _fromDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>counterMin</Name>
				<Source><![CDATA[
    static Counter counterMin(TaxRepVersion  _taxRepVersion,
                                     TaxPeriod      _taxPeriod,
                                     TransDate      _fromDate)
    {
        Integer counter;
        switch (_taxRepVersion)
        {
            case TaxRepVersion::Original :
                counter= 0;
                break;

            case TaxRepVersion::Correct :
                counter= 1;
                break;

            case TaxRepVersion::Latest :
                counter= TaxReportPeriod::version(_taxPeriod, _fromDate);
                break;

            case TaxRepVersion::Total :
                counter= 0;
                break;
        }
        return counter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args  _args)
    {
        TaxReport taxReport;
        boolean isGTEEnabled = VATDeclarationService_W::isGTEEnabled();

        try
        {
            taxReport = TaxReport::instantiateTaxReport();

            if (taxReport.runDialogParametersAndParseArgs(_args))
            {
                taxReport = TaxReport::reinstantiateTaxReportAsExtension(taxReport);

                taxReport.executePreRunOperations();

                if (taxReport.canRunBatch())
                {
                    taxReport.runBatch();
                }
                else
                {
                    taxReport.runOperation();

                    if (!(taxReport is TaxReport_IT)
                        && (isGTEEnabled
                        || (TaxIntegrationUtils::isMultipleTaxIdEnabledForVATDeclarations()
                            && taxReport.isERMultipleTaxSetupCompleted())))
                    {
                        GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceEUR00031, funcName());

                        _args.caller(taxReport);
                        new MenuFunction(menuItemActionStr(SalesTaxReportingByTaxId), MenuItemType::Action).run(_args);
                    }
                    else if (taxReport.canDisplayReport())
                    {
                        taxReport.printout();
                    }
                    else if (taxReport.canDisplaySettlementCompleteMsg())
                    {
                        // Print information once settle finished.
                        info(strFmt("@TaxReport:SalesTaxPaymComplete", taxReport.parmVoucher(), taxReport.parmTransactionDate()));
                    }
                }
            }

            if (!taxReport.isBatchScheduled())
            {
                taxReport.executePostRunOperations();
            }
        }
        catch (Exception::Error)
        {
            exceptionTextFallThrough();
            Box::stop("@Tax:ExceptionRaisedCheckInfolog");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>evaluateArgs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Parse the <c>Args</c> to retrive data for the class execution.
    /// </summary>
    /// <param name="_args"><c>Args</c> class instance.</param>
    protected void evaluateArgs(Args _args)
    {
        if (_args.parmEnumType() == enumNum(NoYes) && _args.parmEnum() != null)
        {
            this.parmIsPreview(_args.parmEnum());
        }
        else
        {
            this.parmLegacyLaunch(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLegacyLaunch</Name>
				<Source><![CDATA[
    /// <summary>
    /// The class was launched from a legacy format and was not provided the expected args.
    /// </summary>
    /// <param name = "_legacyLaunch">True if this class was launched from legacy code that did not provide the expected args; otherwise false.</param>
    /// <returns>True for legacy launch; otherwise false.</returns>
    /// <remarks>This method and related code should be removed once all country extensions have uptaken the new launch behavoir.</remarks>
    protected boolean parmLegacyLaunch(boolean _legacyLaunch = legacyLaunch)
    {
        legacyLaunch = _legacyLaunch;
        return legacyLaunch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateTaxReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create an instance of the <c>TaxReport</c> object based on setup parameters.
    /// </summary>
    /// <returns>An instance of the <c>TaxReport</c> object.</returns>
    protected static TaxReport instantiateTaxReport()
    {
        TaxReport localTaxReport;

        //<GIN>
        if (TaxParameters::checkTaxParameters_IN())
        {
            if (TaxParameters::find().ReportAdjustment)
            {
                localTaxReport = new TaxSalesTaxAdjustTrans_IN();
            }
            else
            {
                localTaxReport = new TaxSalesTaxPayment_IN();
            }
        }
        else
        //</GIN>
        if (TaxIntegrationUtils::isApplyReportAdjustmentToSettlementPeriodEnabled())
        {
            // Put report adjustment selection into reinstantiateTaxReport.
            localTaxReport = new TaxReport();
        }
        else
        {
            if (TaxParameters::find().ReportAdjustment)
            {
                localTaxReport = new TaxReportAdjustTrans();
            }
            else
            {
                localTaxReport = new TaxReport();
            }
        }

        return localTaxReport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reinstantiateTaxReportAsExtension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiate the <c>TaxReport</c> object based on values read from the parameters dialog.
    /// </summary>
    /// <param name = "_taxReport">The current <c>TaxReport</c> object to reinstantiate as an extension class.</param>
    /// <returns>An instance of the <c>TaxReport</c> object instantiated as its child class; otherwise it is the same instance as the input <c>TaxReport</c>.</returns>
    protected static TaxReport reinstantiateTaxReportAsExtension(TaxReport _taxReport)
    {
        Taxperiod taxPeriod = _taxReport.taxPeriod();
        TaxReport localTaxReport = TaxIntegrationUtils::isReportAdjustmentEnabled(TaxPeriodHead::find(taxPeriod)) 
            ? TaxReport::reinstantiateTaxReportAsExtensionForReportAdjustment(_taxReport)
            : _taxReport;

        if (_taxReport.isMultipleTaxIdEnabled)
        {
            LogisticsAddressCountryRegionISOCode iSOCode = TaxReportMultipleTaxIdHelper::getTaxRegistrationNumberISOCodeByTaxPeriod(taxPeriod);

            if (iSOCode == #isoBE)
            {
                return TaxReport::reinstantiateTaxReportAsExtensionForBE(_taxReport);
            }
            else if (iSOCode == #isoIT)
            {
                return TaxReport::reinstantiateTaxReportAsExtensionForIT(_taxReport);
            }
        }

        TaxAuthorityAddress taxAuthorityAddress = TaxAuthorityAddress::find(TaxPeriodHead::find(taxPeriod).TaxAuthority);

        switch (taxAuthorityAddress.TaxReportLayout)
        {
            case TaxReportLayout::Belgium  :
                localTaxReport = TaxReport::reinstantiateTaxReportAsExtensionForBE(_taxReport);
                break;

            case TaxReportLayout::Italy  :
                localTaxReport = TaxReport::reinstantiateTaxReportAsExtensionForIT(_taxReport);
                break;

            case TaxReportLayout::Default  :
                if (TaxReportERHelper_IT::isERReportShouldBeUsed(taxAuthorityAddress.TaxAuthority))
                {
                    localTaxReport = TaxReport::reinstantiateTaxReportAsExtensionForIT(_taxReport);
                }
                break;
        }

        return localTaxReport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executePostRunOperations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Extension point to allow customization of <c>TaxReport</c>. This code is run after the run method is called.
    /// </summary>
    public void executePostRunOperations()
    {
        // <GIN>
        if (countryRegion_IN)
        {
            this.updateTaxRegistrationGroup_IN(this.taxRegistrationGroupName_IN());

            TaxSalesTaxPaymentFacade_IN::clearSalesTaxPaymentHistory();
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>executePreRunOperations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Extension point to allow customization of <c>TaxReport</c>. This code is run before the batch operation is created or the Run operation is called.
    /// </summary>
    public void executePreRunOperations()
    {
        // <GIN>
        if (countryRegion_IN)
        {
            taxRegistrationGroupName = this.taxRegistrationGroupName_IN();
            taxRegistrationNumber    = this.taxRegistrationNumber_IN();

            if (taxRegistrationNumber || taxRegistrationGroupName)
            {
                this.validate();
            }

            this.setIndirectTax_IN();
            this.markInUseForTaxRegistrationGroup_IN();
        }
        // </GIN>

        if (this is TaxReport_IT)
        {
            if (!this.validate())
            {
                throw Exception::Error;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the batch object for batch scheduling.
    /// </summary>
    /// <returns>
    /// The created batch header.
    /// </returns>
    protected BatchHeader initializeBatch()
    {
        BatchInfo batchInformation = this.batchInfo();

        BatchHeader batch = batchInformation.parmBatchHeader();
        batch.parmBatchJobActivePeriodId(TaxPeriodHead::find(this.taxPeriod()).BatchJobActivePeriod);
        batch.clearAllAlerts();
        batch.addUserAlerts(curUserId(),
            NoYes::Yes, // ended
            NoYes::Yes, // error
            NoYes::Yes, // cancelled
            NoYes::Yes, // pop-up
            NoYes::No); // email

        batch.parmCaption(strFmt("@Tax:TaxReportBatchCaption", this.taxPeriod(), this.fromDate(), this.transDate()));

        batch.addTask(this);

        return batch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxVersion</Name>
				<Source><![CDATA[
    static Name taxVersion(TaxRepVersion _taxRepVersion,
                                  TaxPeriod     _taxPeriod,
                                  TransDate     _fromDate,
                                  NoYes         _reported = NoYes::No)
    {
        Name    name;
        Counter latestVersion;

        switch (_taxRepVersion)
        {
            case TaxRepVersion::Original :
                name = strFmt('%1',0);
                break;

            case TaxRepVersion::Correct :
                name = strFmt('%1..',1);
                break;
            case TaxRepVersion::Latest  :
                latestVersion = TaxReportPeriod::version(_taxPeriod, _fromDate);
                if (_reported)
                {
                    latestVersion -= 1;
                }
                name = strFmt('%1',latestVersion);
                break;

            case TaxRepVersion::Total :
                name = strFmt('%1..',0);
                break;
        }
        return name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxVersion_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the generated name for given tax version
    /// </summary>
    /// <param name="_taxRepVersion">
    /// The tax version is used to decide which name will be generated.
    /// </param>
    /// <param name="_taxPeriod">
    /// The tax period is used to get version.
    /// </param>
    /// <param name="_taxRegistrationNum">
    /// The tax registration number is used to get version.
    /// </param>
    /// <param name="_fromDate">
    /// The from date is used to get version.
    /// </param>
    /// <param name="_reported">
    /// This param checked whether update latest version.
    /// </param>
    /// <returns>
    /// Returns the generated name.
    /// </returns>
    static Name taxVersion_IN(TaxRepVersion                  _taxRepVersion,
                                     TaxPeriod                      _taxPeriod,
                                     RefRecId       _taxRegistrationNum,
                                     TransDate                      _fromDate,
                                     NoYes                          _reported = NoYes::No)
    {
        Name    name;
        Counter latestVersion;
        ;

        switch (_taxRepVersion)
        {
            case TaxRepVersion::Original :
                name = strFmt('%1',0);
                break;

            case TaxRepVersion::Correct :
                name = strFmt('%1..',1);
                break;

            case TaxRepVersion::Latest  :
                latestVersion = TaxReportPeriod_IN::version(_taxPeriod,_taxRegistrationNum, _fromDate);
                if (_reported)
                {
                    latestVersion -= 1;
                }
                name = strFmt('%1',latestVersion);
                break;

            case TaxRepVersion::Total :
                name = strFmt('%1..',0);
                break;
        }
        return name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// All concrete Runbase classes must implement a method desribing whether the class is designed for running in the Sandbox;
    /// essentially whether they are designed for execution in a new session.
    /// </summary>
    /// <returns>True if this Runbase-extending class is meant to run in a new session; false otherwise.</returns>
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDifferentCurrencyBetweenTaxCodeAndAuthority</Name>
				<Source><![CDATA[
    public static boolean isDifferentCurrencyBetweenTaxCodeAndAuthority(TaxPeriod _taxPeriod)
    {
        boolean result;
        TaxPeriodHead taxPeriodHead;
        TaxAuthorityAddress authorityAddress;
        VendTable vendTable;
        TaxTable taxTable;

        select firstonly RecId from taxPeriodHead
            where taxPeriodHead.TaxPeriod == _taxPeriod
            join RecId from authorityAddress
                where authorityAddress.TaxAuthority == taxPeriodHead.TaxAuthority
            join RecId from vendTable
                where vendTable.AccountNum == authorityAddress.AccountNum
            join RecId from taxTable
                where taxTable.TaxPeriod == _taxPeriod
                    && taxtable.TaxCurrencyCode != vendTable.Currency;

        if (taxPeriodHead.RecId)
        {
            result = true;
        }
        else
        {
            result = false;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogTaxRegistrationNumber_lookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Lookup registration number.
    /// </summary>
    /// <param name="_formReferenceControl">
    /// The form reference control.
    /// </param>
    /// <returns>
    /// The registration number.
    /// </returns>
    public Common dialogTaxRegistrationNumber_lookup(FormReferenceControl _formReferenceControl)
    {
        Query                   query;
        QueryBuildDataSource    registrationNumerDataSource;
        QueryBuildDataSource    groupSetupDataSource;
        QueryBuildRange         registrationTypeRange;
        QueryBuildRange         registrationGroupRange;

        SysReferenceTableLookup sysTableLookup = SysReferenceTableLookup::newParameters(tablenum(TaxRegistrationNumbers_IN), _formReferenceControl);

        query                           = new Query();
        registrationNumerDataSource     = query.addDataSource(tablenum(TaxRegistrationNumbers_IN));
        registrationTypeRange           = registrationNumerDataSource.addRange(fieldNum(TaxRegistrationNumbers_IN, RegistrationType));

        registrationTypeRange.value(queryValue(TaxRegistrationType_IN::Company));

        if (dialogTaxRegistrationGroupName.value())
        {
            groupSetupDataSource = registrationNumerDataSource.addDataSource(tableNum(TaxRegistrationGroupSetup_IN));
            groupSetupDataSource.relations(true);
            registrationGroupRange = groupSetupDataSource.addRange(fieldNum(TaxRegistrationGroupSetup_IN, TaxRegistrationGroupName));
            registrationGroupRange.value(queryValue(dialogTaxRegistrationGroupName.value()));
        }

        sysTableLookup.addLookupfield(fieldnum(TaxRegistrationNumbers_IN, RegistrationNumber));
        sysTableLookup.addLookupfield(fieldnum(TaxRegistrationNumbers_IN, TaxType));
        sysTableLookup.parmQuery(query);
        return sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPostLegacyWithAccountingDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves and posts tax transaction with distribution.
    /// </summary>
    /// <param name = "_taxTrans">The buffer of <c>TaxTrans</c>.</param>
    /// <param name = "_useTaxPayableLedgerDimension">The tax payable ledger dimension.</param>
    /// <param name = "_currencyExchangeHelper">The instance of <c>CurrencyExchangeHelper</c>.</param>
    /// <param name = "_taxTransOffsetRecId">The offset tax transaction recId.</param>
    /// <param name = "_taxLedgerDimension">The tax ledger dimension.</param>
    protected void saveAndPostLegacyWithAccountingDistributions(
        TaxTrans                _taxTrans,
        LedgerDimensionAccount  _useTaxPayableLedgerDimension,
        CurrencyExchangeHelper  _currencyExchangeHelper,
        RefRecId                _taxTransOffsetRecId,
        LedgerDimensionAccount  _taxLedgerDimension = 0)
    {
        TaxAmountCur   totalTaxAmountCur;
        TaxAmount      totalTaxAmountRep;
        TaxAmount      totalTaxAmount;
        TaxTrans       originalTaxTrans;

        AccountingDistribution accountingDistribution;
        AccountingDistribution reversingAccountingDistribution;

        LedgerDimensionAccount taxLedgerDimension = _taxLedgerDimension;
        TaxData taxData = taxData::find(_taxTrans.TaxCode, _taxTrans.TransDate, _taxTrans.TaxBaseAmount);

        // If US tax rules are on then the use tax expense is non-recoverable VAT.
        // Find that record anyways so that the Use Tax Payable (the offset) can be backed out.
        boolean includeTaxNonRecoverable =
            _taxTrans.TaxDirection == TaxDirection::UseTax &&
            (taxParametersLocal.PurchTaxOnOperations || taxData.VATExemptPct);

        select firstonly SourceRegulateAmountCur from originalTaxTrans
            where originalTaxTrans.SourceDocumentLine == _taxTrans.SourceDocumentLine
                && originalTaxTrans.RecId != _taxtrans.RecId
                && originalTaxTrans.TaxOrigin != TaxOrigin::Payment
                && originalTaxTrans.TaxOrigin != TaxOrigin::TaxReversed
                && originalTaxTrans.TaxOrigin != TaxOrigin::CashDisc;

        select count(RecId), sum(TransactionCurrencyAmount) from accountingDistribution
            where accountingDistribution.SourceDocumentLine == _taxTrans.SourceDocumentLine
                && accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing
                && (accountingDistribution.MonetaryAmount == MonetaryAmount::Tax
                    || accountingDistribution.MonetaryAmount == MonetaryAmount::TaxVariance
                    || (accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable && includeTaxNonRecoverable)
                    || (accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance && includeTaxNonRecoverable))
                notexists join reversingAccountingDistribution
                    where reversingAccountingDistribution.ReferenceDistribution == accountingDistribution.RecId
                        && reversingAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing;

        int64 lineCount = accountingDistribution.RecId;
        int64 currentLine = 0;

        if (!lineCount)
        {
            return;
        }
        AllocationFactor totalAllocationFactor = originalTaxTrans.SourceRegulateAmountCur ? accountingDistribution.TransactionCurrencyAmount / originalTaxTrans.SourceRegulateAmountCur : 0;

        while select LedgerDimension, TransactionCurrencyAmount, MonetaryAmount
            from accountingDistribution
            where accountingDistribution.SourceDocumentLine == _taxTrans.SourceDocumentLine
                && accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing
                && (accountingDistribution.MonetaryAmount == MonetaryAmount::Tax
                    || accountingDistribution.MonetaryAmount == MonetaryAmount::TaxVariance
                    || (accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable && includeTaxNonRecoverable)
                    || (accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance && includeTaxNonRecoverable))
            notexists join reversingAccountingDistribution
                where reversingAccountingDistribution.ReferenceDistribution == accountingDistribution.RecId
                    && reversingAccountingDistribution.ReferenceRole == AccountingDistributionReferenceRole::Reversing
        {
            TaxAmountCur    taxAmountCur;
            TaxAmountCur    taxAmountRep;
            TaxAmount       taxAmount;
            AllocationFactor effectiveAllocationFactor;
            currentLine++;

            // Check if last line.
            if (currentLine < lineCount)
            {
                effectiveAllocationFactor = 0;

                // The _taxTrans.SourceRegulateAmountCur may be the sum of multiple accounting distributions (e.g. Tax and TaxVariance),
                // so calculate an effective allocation factor to be applied to the other amounts based on the ratio between
                // the distributed amount and the total amount.
                
                if (originalTaxTrans.SourceRegulateAmountCur != 0)
                {
                    effectiveAllocationFactor= accountingDistribution.TransactionCurrencyAmount / originalTaxTrans.SourceRegulateAmountCur;
                }
                // Apply the effective allocation factor to the other amounts.
                taxAmountCur = _taxtrans.TaxAmountCur * effectiveAllocationFactor;
                taxAmount = _taxTrans.TaxAmount * effectiveAllocationFactor;

                if (isTaxCurrencyConversionFeatureEnabled)
                {
                    taxAmountRep = _taxTrans.TaxAmountRep * effectiveAllocationFactor;
                }
            }
            else
            {
                // Allocate the remainder to the last posting.
                taxAmountCur = _taxTrans.TaxAmountCur * totalAllocationFactor - totalTaxAmountCur;
                taxAmount = _taxTrans.TaxAmount * totalAllocationFactor - totalTaxAmount;

                if (isTaxCurrencyConversionFeatureEnabled)
                {
                    taxAmountRep = _taxTrans.TaxAmountRep * totalAllocationFactor - totalTaxAmountRep;
                }
            }

            totalTaxAmountCur += taxAmountCur;
            totalTaxAmount += taxAmount;

            if (isTaxCurrencyConversionFeatureEnabled)
            {
                totalTaxAmountRep += taxAmountRep;
            }

            // Post the distributed amounts.
            CurrencyCode currencyCode;

            if (_taxTrans.CurrencyCode && _taxTrans.CurrencyCode != companyStandardCurrency)
            {
                currencyCode = _taxTrans.CurrencyCode;
            }
            else
            {
                currencyCode = companyStandardCurrency;
            }

            AmountMST taxAmountMST = CurrencyExchangeHelper::amount(taxAmount);
            AmountMST taxAmountCurrency = CurrencyExchangeHelper::amount(taxAmountCur);

            AmountMST taxAmountRepCurrency;
            if (isTaxCurrencyConversionFeatureEnabled)
            {
                taxAmountRepCurrency = CurrencyExchangeHelper::amount(taxAmountRep);
            }

            LedgerDimensionAccount useTaxPayableLedgerDimension;
            LedgerDimensionAccount ledgerDimensionAccount;
            DimensionDefault dimensionDefault;

            if (_taxTrans.TaxDirection == TaxDirection::UseTax && !_useTaxPayableLedgerDimension)
            {
                useTaxPayableLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(TaxLedgerAccountGroup::offsetUseTaxLedgerDimension(_taxTrans.TaxCode));
            }
            else if ((_taxTrans.TaxDirection == TaxDirection::IncomingTax || TaxDirection::OutgoingTax) && !_useTaxPayableLedgerDimension)
            {
                ledgerDimensionAccount = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(_taxLedgerDimension);
                dimensionDefault = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_taxLedgerDimension);
                useTaxPayableLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionAccount, dimensionDefault);
            }
            else
            {
                useTaxPayableLedgerDimension = _useTaxPayableLedgerDimension;
            }

            taxClearingLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(TaxLedgerAccountGroup::clearingLedgerDimension(_taxTrans.TaxCode), LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(useTaxPayableLedgerDimension));

            if ((accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable ||
                 accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance)
                 && _taxTrans.TaxDirection == TaxDirection::UseTax
                 && taxData.VATExemptPct)
            {
                taxLedgerDimension = 0;
            }
            else
            {
                if (taxParametersLocal.ConditionalTax == NoYes::Yes && _taxTrans.TaxOrigin == TaxOrigin::Payment && _taxTrans.TaxDirection != TaxDirection::UseTax)
                {
                    taxLedgerDimension = this.getLedgerDimensionByTaxTransGeneralJourAccEntry(_taxTrans, accountingDistribution, TaxTransRelationshipType::Tax);
                }
                else
                {
                    taxLedgerDimension = accountingDistribution.LedgerDimension;
                }
            }

            if (_taxTrans.TaxDirection != TaxDirection::TaxExemptPurchase &&
                _taxTrans.TaxDirection != TaxDirection::TaxExemptSales &&
                _taxTrans.TaxDirection != TaxDirection::TaxTransaction)
            {
                // Maintaining the call for compatibility.
                this.post(
                    _taxTrans.TaxDirection,
                    taxLedgerDimension,
                    useTaxPayableLedgerDimension,
                    taxClearingLedgerDimension,
                    currencyCode,
                    taxAmountCurrency * -1,
                    0,
                    taxAmountMST * -1,
                    _currencyExchangeHelper,
                    _taxTransOffsetRecId,
                    _taxTrans.TaxCode,
                    _taxTrans.TaxOrigin);

                this.postV2(
                    _taxTrans.TaxDirection,
                    taxLedgerDimension,
                    useTaxPayableLedgerDimension,
                    taxClearingLedgerDimension,
                    currencyCode,
                    taxAmountCurrency * -1,
                    0,
                    taxAmountMST * -1,
                    _currencyExchangeHelper,
                    _taxTransOffsetRecId,
                    _taxTrans.TaxCode,
                    _taxTrans.TaxOrigin,
                    0,
                    isTaxCurrencyConversionFeatureEnabled ? taxAmountRepCurrency * -1 : 0,
                    0);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markInUseForTaxRegistrationGroup_IN</Name>
				<Source><![CDATA[
    private void markInUseForTaxRegistrationGroup_IN()
    {
        if (countryRegion_IN)
        {
            if (taxRegistrationGroupName)
            {
                TaxRegistrationGroup_IN::setInUse(taxRegistrationGroupName);
                instanceInUse = false;
                inUse = true;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>combineLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the combined ledger dimension.
    /// </summary>
    /// <param name = "_mainAccountDimension">The ledger dimension account contains main account information.</param>
    /// <param name = "_defaultDimension">The ledger dimension account contains default dimension information.</param>
    /// <returns>The combined ledger dimension.</returns>
    private LedgerDimensionAccount combineLedgerDimension(LedgerDimensionAccount _mainAccountDimension, LedgerDimensionAccount _defaultDimension)
    {
        LedgerDimensionDefaultAccount mainAccount = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(_mainAccountDimension);
        DimensionDefault defaultDimension = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_defaultDimension);

        return LedgerDimensionFacade::serviceCreateLedgerDimension(mainAccount, defaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionByTaxTransGeneralJourAccEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets ledger dimension from <c>TaxTransGeneralJournalAccountEntry</c>.
    /// </summary>
    /// <param name = "_taxTrans">The tax trans.</param>
    /// <param name = "_accountingDistribution">The accounting distribution.</param>
    /// <param name = "_relationshipType">Tax trans relation ship type.</param>
    /// <returns>Ledger dimension.</returns>
    private LedgerDimensionAccount getLedgerDimensionByTaxTransGeneralJourAccEntry(TaxTrans _taxTrans, AccountingDistribution _accountingDistribution, TaxTransRelationshipType _relationshipType)
    {
        TaxTransGeneralJournalAccountEntry taxTransGeneralJournalAccountEntry;

        select firstonly LedgerDimension from taxTransGeneralJournalAccountEntry
            where taxTransGeneralJournalAccountEntry.TaxTrans == _taxTrans.RecId
            && taxTransGeneralJournalAccountEntry.TaxTransRelationship == _relationshipType;

        return this.combineLedgerDimension(taxTransGeneralJournalAccountEntry.LedgerDimension, _accountingDistribution.LedgerDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processExchangeRateGainLoss</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the tax amount should post to exchange rate gain or loss account.
    /// </summary>
    /// <param name = "_ledgerPostingController">The instance of <c>LedgerPostingController</c>.</param>
    /// <param name = "_currencyCode">The currency code of tax amount.</param>
    /// <param name = "_exchangeRateGainLossAmountMST">The accounting currency amount for exchange rate gain or loss account.</param>
    /// <param name = "_exchangeRateGainLossAmountRep">The reporting currency amount for exchange rate gain or loss account.</param>
    /// <param name = "_ledgerDimensionId">The ledger dimension id.</param>
    private void processExchangeRateGainLoss(
        LedgerPostingController _ledgerPostingController,
        CurrencyCode _currencyCode,
        Amount _exchangeRateGainLossAmountMST,
        Amount _exchangeRateGainLossAmountRep,
        LedgerDimensionAccount _ledgerDimensionId)
    {
        LedgerPostingType postingType;
        LedgerVoucherTransObject ledgerVoucherTransObject;

        if ((isTaxCurrencyConversionFeatureEnabled
                && ((_exchangeRateGainLossAmountMST != 0 && _exchangeRateGainLossAmountRep == 0)
                    || (_exchangeRateGainLossAmountMST == 0 && _exchangeRateGainLossAmountRep != 0)))
            || _exchangeRateGainLossAmountMST != 0)
        {
            boolean isLoss = _exchangeRateGainLossAmountMST > 0 || _exchangeRateGainLossAmountRep > 0;
            postingType = isLoss ? LedgerPostingType::ExchRateLoss : LedgerPostingType::ExchRateGain;

            if (isPopulateDimensionForExchGainLossAccount)
            {
                LedgerDimensionBase combinedGainLossLedgerDimension;

                if (isLoss)
                {
                    if (!lossMainAccount)
                    {
                        lossMainAccount = this.initGainLossMainAccount(CurrencyGainLossAccountType::RealizedLoss);
                    }

                    combinedGainLossLedgerDimension = this.combineLedgerDimension(lossMainAccount, _ledgerDimensionId);
                }
                else
                {
                    if (!gainMainAccount)
                    {
                        gainMainAccount = this.initGainLossMainAccount(CurrencyGainLossAccountType::RealizedGain);
                    }

                    combinedGainLossLedgerDimension = this.combineLedgerDimension(gainMainAccount, _ledgerDimensionId);
                }

                if (isTaxReportPerfImprovByVoucherTransCombineFlightEnabled
                    && isTaxReportCombineVoucherForGainLoss)
                {
                    taxReportVoucherTransCombine.addAdjustTransToMap(
                        postingType,
                        combinedGainLossLedgerDimension,
                        _currencyCode,
                        _exchangeRateGainLossAmountMST,
                        _exchangeRateGainLossAmountRep,
                        true);

                    taxReportVoucherTransCombine.addAdjustTransToMap(
                        ledgerPostingType::Tax,
                        _ledgerDimensionId,
                        _currencyCode,
                        -_exchangeRateGainLossAmountMST,
                        -_exchangeRateGainLossAmountRep,
                        true);
                }
                else
                {
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
                        _ledgerPostingController.getReference(),
                        postingType,
                        combinedGainLossLedgerDimension,
                        _currencyCode,
                        _exchangeRateGainLossAmountMST,
                        _exchangeRateGainLossAmountRep);
                    //Skip dimension validation for gain & loss account even if the account structure is changed
                    ledgerVoucherTransObject.parmSkipDimensionValidation(true);
                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);

                    ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
                        _ledgerPostingController.getReference(),
                        ledgerPostingType::Tax,
                        _ledgerDimensionId,
                        _currencyCode,
                        -_exchangeRateGainLossAmountMST,
                        -_exchangeRateGainLossAmountRep);
                    ledgerVoucherTransObject.parmSkipDimensionValidation(true);
                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }
            }
            else
            {
                if (isLoss && !lossLedgerDimension)
                {
                    lossLedgerDimension = this.initGainLossLedgerDimenison(CurrencyGainLossAccountType::RealizedLoss);
                }
                else if (!isLoss && !gainLedgerDimension)
                {
                    gainLedgerDimension = this.initGainLossLedgerDimenison(CurrencyGainLossAccountType::RealizedGain);
                }

                if (isTaxReportCombineVoucherForGainLoss)
                {
                    this.processCombineExchangeRateGainLoss(_currencyCode, _exchangeRateGainLossAmountMST, _exchangeRateGainLossAmountRep);
                }
                else
                {
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
                        _ledgerPostingController.getReference(),
                        postingType,
                        isLoss ? lossLedgerDimension : gainLedgerDimension,
                        _currencyCode,
                        _exchangeRateGainLossAmountMST,
                        _exchangeRateGainLossAmountRep);

                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }

                if (isTaxReportPerfImprovByVoucherTransCombineFlightEnabled
                    && isTaxReportCombineVoucherForGainLoss)
                {
                    taxReportVoucherTransCombine.addAdjustTransToMap(
                        ledgerPostingType::Tax,
                        _ledgerDimensionId,
                        _currencyCode,
                        -_exchangeRateGainLossAmountMST,
                        -_exchangeRateGainLossAmountRep,
                        true);
                }
                else
                {
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
                        _ledgerPostingController.getReference(),
                        ledgerPostingType::Tax,
                        _ledgerDimensionId,
                        _currencyCode,
                        -_exchangeRateGainLossAmountMST,
                        -_exchangeRateGainLossAmountRep);

                    ledgerVoucherTransObject.parmSkipDimensionValidation(true);
                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCombineExchangeRateGainLoss</Name>
				<Source><![CDATA[
    /// <summary>
    /// Summarizes the exchange rate gain and loss amount per tax currency code.
    /// </summary>
    /// <param name = "_currencyCode">The tax trans currency code.</param>
    /// <param name = "_exchangeRateGainLossAmountMST">The exchange rate gain or loss amount in accounting currency.</param>
    /// <param name = "_exchangeRateGainLossAmountRep">The exchange rate gain or loss amount in reporting currency.</param>
    private void processCombineExchangeRateGainLoss(
        CurrencyCode _currencyCode,
        Amount _exchangeRateGainLossAmountMST,
        Amount _exchangeRateGainLossAmountRep)
    {
        if (_exchangeRateGainLossAmountMST > 0 || _exchangeRateGainLossAmountRep > 0)
        {
            Amount totalExchangeRateLossAmtMSTLoc;
            Amount totalExchangeRateLossAmtRepLoc;

            if (currencyExchRateLossAmtMap.exists(_currencyCode))
            {
                [totalExchangeRateLossAmtMSTLoc, totalExchangeRateLossAmtRepLoc] = currencyExchRateLossAmtMap.lookup(_currencyCode);
            }

            currencyExchRateLossAmtMap.insert(_currencyCode, [totalExchangeRateLossAmtMSTLoc + _exchangeRateGainLossAmountMST, totalExchangeRateLossAmtRepLoc + _exchangeRateGainLossAmountRep]);
        }
        else
        {
            Amount totalExchangeRateGainAmtMSTLoc;
            Amount totalExchangeRateGainAmtRepLoc;

            if (currencyExchRateGainAmtMap.exists(_currencyCode))
            {
                [totalExchangeRateGainAmtMSTLoc, totalExchangeRateGainAmtRepLoc] = currencyExchRateGainAmtMap.lookup(_currencyCode);
            }

            currencyExchRateGainAmtMap.insert(_currencyCode, [totalExchangeRateGainAmtMSTLoc + _exchangeRateGainLossAmountMST, totalExchangeRateGainAmtRepLoc + _exchangeRateGainLossAmountRep]);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCombinedLedgerVoucherTransObjectForExchRateGainLoss</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts combined <c>LedgerVoucherTransObject</c> for exchange rate gain and loss amount.
    /// </summary>
    /// <param name = "_currencyExchRateGainLossAmtMap">The currency exchange rate gain or loss amount map.</param>
    /// <param name = "_ledgerPostingType">The ledger posting type.</param>
    /// <param name = "_ledgerDimensionId">The ledger dimension for exchange rate gain or loss account.</param>
    internal protected void postCombinedLedgerVoucherTransObjectForExchRateGainLoss(
        Map _currencyExchRateGainLossAmtMap,
        LedgerPostingType _ledgerPostingType,
        LedgerDimensionAccount _ledgerDimensionId)
    {
        CurrencyCode currencyCodeLoc;
        LedgerVoucherTransObject ledgerVoucherTransObject;

        if (_currencyExchRateGainLossAmtMap.elements())
        {
            MapEnumerator enumerator = _currencyExchRateGainLossAmtMap.getEnumerator();

            while (enumerator.moveNext())
            {
                Amount totalExchangeRateGainLossAmtMSTLoc;
                Amount totalExchangeRateGainLossAmtRepLoc;

                currencyCodeLoc = enumerator.currentKey();
                [totalExchangeRateGainLossAmtMSTLoc, totalExchangeRateGainLossAmtRepLoc] = enumerator.currentValue();

                ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
                    ledgerPostingController.getReference(),
                    _ledgerPostingType,
                    _ledgerDimensionId,
                    currencyCodeLoc,
                    totalExchangeRateGainLossAmtMSTLoc,
                    0);

                ledgerPostingController.addTrans(ledgerVoucherTransObject);

                ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
                    ledgerPostingController.getReference(),
                    _ledgerPostingType,
                    _ledgerDimensionId,
                    currencyCodeLoc,
                    0,
                    totalExchangeRateGainLossAmtRepLoc);

                ledgerPostingController.addTrans(ledgerVoucherTransObject);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerVoucherTransObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds <c>LedgerVoucherTransObject</c> instance.
    /// </summary>
    /// <param name = "_ledgerPostingController">The instance of <c>LedgerPostingController</c>.</param>
    /// <param name = "_ledgerPostingType">The ledger posting type.</param>
    /// <param name = "_taxledgerDimension">The tax ledger dimension.</param>
    /// <param name = "_currencyCode">The currency code.</param>
    /// <param name = "_taxAmount">The tax amount.</param>
    /// <param name = "_currencyHelper">The instance of <c>CurrencyExchangeHelper</c>.</param>
    /// <param name = "_taxTransRecId">The recId of <c>TaxTrans</c>.</param>
    /// <param name = "_taxTransRelationshipType">The taxtrans relationship type.</param>
    /// <returns>The instance of <c>LedgerVoucherTransObject</c>.</returns>
    private LedgerVoucherTransObject addLedgerVoucherTransObject(
        LedgerPostingController   _ledgerPostingController,
        LedgerPostingType         _ledgerPostingType,
        LedgerDimensionAccount    _taxledgerDimension,
        CurrencyCode              _currencyCode,
        TaxAmount                 _taxAmount,
        CurrencyExchangeHelper    _currencyHelper,
        RefRecId                  _taxTransRecId,
        TaxTransRelationshipType  _taxTransRelationshipType)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject;

        if (!isTaxReportPerfImprovByVoucherTransCombineFlightEnabled)
        {
            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                _ledgerPostingController.getReference(),
                _ledgerPostingType,
                _taxledgerDimension,
                _currencyCode,
                _taxAmount,
                _currencyHelper);

            if (_taxTransRecId != 0)
            {
                ledgerVoucherTransObject.addTaxTransRelationship(
                    _taxTransRecId,
                    _taxTransRelationshipType,
                    curext(),
                    ledgerVoucherTransObject.parmAccountingCurrencyAmount(),
                    ledgerVoucherTransObject.parmTransactionCurrencyAmount());
            }

            ledgerVoucherTransObject.parmSkipDimensionValidation(true);
        }
        else
        {
            taxReportVoucherTransCombine.addTransToMap(
                _ledgerPostingType,
                _taxledgerDimension,
                _currencyCode,
                _taxAmount,
                true,
                _currencyHelper,
                isNotGenerateOffsetTaxTrans? 0 : _taxTransRecId,
                isNotGenerateOffsetTaxTrans? TaxTransRelationshipType::Tax : _taxTransRelationshipType);
        }

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a posting transaction to the ledger voucher object.
    /// </summary>
    /// <param name = "_ledgerPostingController">The instance of <c>LedgerPostingController</c>.</param>
    /// <param name = "_ledgerPostingtype">The instance of <c>LedgerPostingType</c>.</param>
    /// <param name = "_ledgerDimensionAccount">The dimension attribute value combination of the general journal entry.</param>
    /// <param name = "_currencyCode">The currency code.</param>
    /// <param name = "_taxAmount">The tax amount.</param>
    /// <param name = "_currencyHelper">The instance of <c>CurrencyExchangeHelper</c>.</param>
    /// <param name = "_taxledgerDimension">The tax ledger dimension.</param>
    /// <param name = "_taxCode">The tax code.</param>
    /// <param name = "_taxOrigin">The tax origin.</param>
    /// <returns>The ledger dimension account.</returns>
    private LedgerDimensionAccount addTrans(
        LedgerPostingController   _ledgerPostingController,
        LedgerPostingType         _ledgerPostingtype,
        LedgerDimensionAccount    _ledgerDimensionAccount,
        CurrencyCode              _currencyCode,
        TaxAmount                 _taxAmount,
        CurrencyExchangeHelper    _currencyHelper,
        LedgerDimensionAccount    _taxledgerDimension,
        TaxCode                   _taxCode,
        TaxOrigin                 _taxOrigin)
    {
        LedgerDimensionAccount ledgerDimensionAccount;
        if (!isTaxReportPerfImprovByVoucherTransCombineFlightEnabled)
        {
            LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                _ledgerPostingController.getReference(),
                _ledgerPostingtype,
                _ledgerDimensionAccount,
                _currencyCode,
                _taxAmount,
                _currencyHelper);

            ledgerDimensionAccount = this.determineLedgerDimensionDueToAccountStructureChange(
                _taxledgerDimension,
                _ledgerDimensionAccount,
                _taxOrigin,
                _taxCode,
                ledgerVoucherTransObject);

            _ledgerPostingController.addTrans(ledgerVoucherTransObject);
        }
        else
        {
            boolean skipDimensionValidation;
            [skipDimensionValidation, ledgerDimensionAccount] = this.getLedgerDimensionDueToAccountStructureChange(
                _taxledgerDimension,
                _ledgerDimensionAccount,
                _taxOrigin,
                _taxCode);

            taxReportVoucherTransCombine.addTransToMap(
                _ledgerPostingType,
                ledgerDimensionAccount,
                _currencyCode,
                _taxAmount,
                skipDimensionValidation,
                _currencyHelper);
        }

        return ledgerDimensionAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initGainLossLedgerDimenison</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the gainLossLedgerDimension that is ledger dimension for gain or loss account.
    /// </summary>
    /// <param name = "_accountType">The account type for gain or loss.</param>
    /// <returns>The ledger dimension for gain or loss.</returns>
    private LedgerDimensionBase initGainLossLedgerDimenison(CurrencyGainLossAccountType _accountType)
    {
        LedgerDimensionDefaultAccount gainLossLedgerDimension = this.initGainLossMainAccount(_accountType);

        DimensionDefault mainAccountDefaultDimension = MainAccountLegalEntity::findByMainAccountLegalEntity(
            LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(gainLossLedgerDimension),
            CompanyInfo::current()).DefaultDimension;

        return LedgerDimensionFacade::serviceCreateLedgerDimension(gainLossLedgerDimension, mainAccountDefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initGainLossMainAccount</Name>
				<Source><![CDATA[
    private LedgerDimensionDefaultAccount initGainLossMainAccount(CurrencyGainLossAccountType _accountType)
    {
        LedgerGainLossAccount ledgerGainLossAccount;

        select firstonly LedgerDimension from ledgerGainLossAccount
            where ledgerGainLossAccount.AccountType == _accountType
                && ledgerGainLossAccount.Ledger == Ledger::current();

        return ledgerGainLossAccount.LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isGenOffsetTaxTransPerRecordSetEnabled</Name>
				<Source><![CDATA[
    private boolean isGenOffsetTaxTransPerRecordSetEnabled ()
    {
        #ISOCountryRegionCodes

        return !SysCountryRegionCode::isLegalEntityInCountryRegion([#isoTH, #isoPL, #isoHU, #isoLT, #isoMY, #isoIN, #isoIT, #isoRU, #isoCZ, #isoEE, #isoLV])
            && !TaxParameters::reportUseVATDueDateByFeature();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertOffsetTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts offset <c>TaxTrans</c> by using insert_recordset and update_recordset,
    /// and skips the insert and update method of <t>TaxTrans</t> at the same time.
    /// </summary>
    /// <param name = "_fromDate">The from date.</param>
    /// <param name = "_toDate">The to date.</param>
    /// <param name = "_versionMin">The min version.</param>
    /// <param name = "_versionMax">The max version.</param>
    protected void insertOffsetTaxTrans(
        FromDate _fromDate,
        ToDate   _toDate,
        Counter  _versionMin,
        Counter  _versionMax)
    {
        if (this.isGenOffsetTaxTransPerRecordSetEnabled ())
        {
            TaxTrans taxTrans;

            select count(RecId) from taxTrans
                where #TaxTransWhereClause;

            totalTaxTransSettled = taxTrans.RecId;
            isGenOffsetTaxTransPerRecordSetEnabled = this.taxTransExtensionCheck();

            if (isGenOffsetTaxTransPerRecordSetEnabled)
            {
                Voucher voucherLoc = voucher;
                TaxPeriod taxPeriodLoc = taxPeriod;
                TaxModuleType taxModuleType = TaxModuleType::Tax;
                TaxOrigin taxOriginReporting = TaxOrigin::TaxReporting;
                TaxVersion taxReportCounter = TaxReportPeriod::version(taxPeriod, _fromDate);

                TaxTrans offsetTaxTrans;

                offsetTaxTrans.skipDatabaseLog(true);
                offsetTaxTrans.skipDataMethods(true);
                offsetTaxTrans.skipEvents(true);
                insert_recordset offsetTaxTrans (
                    Voucher, TransDate, Source, TaxOrigin, TaxPeriod, TaxRepCounter,
                    Taxcode, TaxDirection, CurrencyCode, TaxBaseAmountCur, TaxBaseAmountRep,
                    TaxAmountCur, TaxAmountRep, TaxBaseAmount, TaxBaseQty, TaxAmount,
                    TaxInCostPrice, TaxInCostPriceMST, TaxInCostPriceCur, TaxInCostPriceRep,
                    SourceCurrencyCode, SourceBaseAmountCur, SourceTaxAmountCur, SourceRegulateAmountCur, ExemptTax,
                    ExemptCode, TaxValue, VATExemptPct, PrintCode, OriginTaxTransRecId, TaxID, PartyTaxId)
                    select voucherLoc, transactionDate, taxModuleType, taxOriginReporting, taxPeriodLoc, taxReportCounter,
                        Taxcode, TaxDirection, CurrencyCode, TaxBaseAmountCur, TaxBaseAmountRep,
                        TaxAmountCur, TaxAmountRep, TaxBaseAmount, TaxBaseQty, TaxAmount,
                        TaxInCostPrice, TaxInCostPriceMST, TaxInCostPriceCur, TaxInCostPriceRep,
                        SourceCurrencyCode, SourceBaseAmountCur, SourceTaxAmountCur, SourceRegulateAmountCur, ExemptTax,
                        ExemptCode, TaxValue, VATExemptPct, PrintCode, RecId, TaxID, PartyTaxId
                        from taxTrans
                            where #TaxTransWhereClause;

                TaxTrans offsetTaxTransUpdated;

                offsetTaxTransUpdated.skipDataMethods(true);
                update_recordset offsetTaxTransUpdated setting
                    TaxBaseAmountCur = -offsetTaxTrans.TaxBaseAmountCur,
                    TaxBaseAmountRep = -offsetTaxTrans.TaxBaseAmountRep,
                    TaxAmountCur = -offsetTaxTrans.TaxAmountCur,
                    TaxAmountRep = -offsetTaxTrans.TaxAmountRep,
                    TaxBaseAmount = -offsetTaxTrans.TaxBaseAmount,
                    TaxBaseQty = -offsetTaxTrans.TaxBaseQty,
                    TaxAmount = -offsetTaxTrans.TaxAmount,
                    TaxInCostPrice = -offsetTaxTrans.TaxInCostPrice,
                    TaxInCostPriceMST = -offsetTaxTrans.TaxInCostPriceMST,
                    TaxInCostPriceCur = -offsetTaxTrans.TaxInCostPriceCur,
                    TaxInCostPriceRep = -offsetTaxTrans.TaxInCostPriceRep,
                    SourceBaseAmountCur = -offsetTaxTrans.SourceBaseAmountCur,
                    SourceTaxAmountCur = -offsetTaxTrans.SourceTaxAmountCur,
                    SourceRegulateAmountCur = -offsetTaxTrans.SourceRegulateAmountCur
                        join offsetTaxTrans
                            where offsetTaxTrans.RecId == offsetTaxTransUpdated.RecId
                        join RecId from taxTrans
                            where offsetTaxTrans.OriginTaxTransRecId == taxTrans.RecId
                                && #TaxTransWhereClause;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxTransExtensionCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether can generate offset <c>TaxTrans</c> per insert record set and update record set.
    /// </summary>
    /// <returns>true if the extension check is successful, otherwise, false.</returns>
    protected boolean taxTransExtensionCheck()
    {
        // From the point view of performance, if the total number of settled <c>TaxTrans</c> is more than 5000, do not use record set to generate offset taxtrans.
        // Checks whether extension exists for insert and update method of <c>TaxTrans</c>.
        if (totalTaxTransSettled >= 5000
            && !TaxTableMethodsExtensionChecker::extensionExists(
                tableStr(TaxTrans),
                [tableMethodStr(TaxTrans, insert), tableMethodStr(TaxTrans, update)],
                [DataEventType::Inserting, DataEventType::Inserted, DataEventType::Updating, DataEventType::Updated]))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDisplaySettlementCompleteMsg</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the settlement complete message should be shown.
    /// </summary>
    /// <returns> true if the settlement complete message should be shown; otherwise, false.</returns>
    private boolean canDisplaySettlementCompleteMsg()
    {
        return printout
            && !this.isInBatch()
            && (isMultipleTaxIdEnabled || !printReport)
            && updateNow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reinstantiateTaxReportAsExtensionForBE</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates the <c>TaxReport</c> object based on values read from the parameters dialog for Belgium.
    /// </summary>
    /// <param name = "_taxReport">The current <c>TaxReport</c> object to reinstantiate as an extension class.</param>
    /// <returns>An instance of the <c>TaxReport</c> object instantiated as its child class.</returns>
    private static TaxReport reinstantiateTaxReportAsExtensionForBE(TaxReport _taxReport)
    {
        TaxReport localTaxReport = new TaxReport_BE();
        localTaxReport.getDialogValues(_taxReport.update(), _taxReport.taxPeriod(), _taxReport.fromDate(), _taxReport.transDate());
        localTaxReport.parmSettlementAccount(_taxReport.parmSettlementAccount());
        localTaxReport.parmTaxRepVersion(_taxReport.taxRepVersion());
        localTaxReport.parmIsPreview(_taxReport.parmIsPreview());
        localTaxReport.parmPrintReport(_taxReport.parmPrintReport());

        return localTaxReport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reinstantiateTaxReportAsExtensionForIT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates the <c>TaxReport</c> object based on values read from the parameters dialog for Italy.
    /// </summary>
    /// <param name = "_taxReport">The current <c>TaxReport</c> object to reinstantiate as an extension class.</param>
    /// <returns>An instance of the <c>TaxReport</c> object instantiated as its child class.</returns>
    private static TaxReport reinstantiateTaxReportAsExtensionForIT(TaxReport _taxReport)
    {
        TaxReport localTaxReport = new TaxReport_IT();
        localTaxReport.getDialogValues(_taxReport.update(), _taxReport.taxPeriod(), _taxReport.fromDate(), _taxReport.transDate());
        localTaxReport.parmFileName(_taxReport.parmFileName());
        localTaxReport.parmIsPreview(_taxReport.parmIsPreview());
        localTaxReport.parmPrintReport(_taxReport.parmPrintReport());

        if (TaxReportERHelper_IT::isERReportShouldBeUsed(
            TaxPeriodHead::find(_taxReport.taxPeriod()).TaxAuthority))
        {
            localTaxReport.parmTaxRepVersion(_taxReport.taxRepVersion());
        }

        return localTaxReport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reinstantiateTaxReportAsExtensionForReportAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates the <c>TaxReport</c> object based on values read from the parameters dialog for report adjustment enabled.
    /// </summary>
    /// <param name = "_taxReport">The current <c>TaxReport</c> object to reinstantiate as an extension class.</param>
    /// <returns>An instance of the <c>TaxReport</c> object instantiated as its child class.</returns>
    private static TaxReport reinstantiateTaxReportAsExtensionForReportAdjustment(TaxReport _taxReport)
    {
        TaxReport localTaxReport = new TaxReportAdjustTrans();
        localTaxReport.getDialogValues(_taxReport.update(), _taxReport.taxPeriod(), _taxReport.fromDate(), _taxReport.transDate());
        localTaxReport.parmFileName(_taxReport.parmFileName());
        localTaxReport.parmIsPreview(_taxReport.parmIsPreview());
        localTaxReport.parmPrintReport(_taxReport.parmPrintReport());

        return localTaxReport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the <c>voucher</c> of the tax report.
    /// </summary>
    /// <param name="_voucher">The voucher; optional.</param>
    /// <returns>The tax report voucher.</returns>
    private Voucher parmVoucher(Voucher _voucher = voucher)
    {
        voucher = _voucher;
        return voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransactionDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the <c>transactionDate</c> of the tax report.
    /// </summary>
    /// <param name="_transactionDate">The transaction date; optional.</param>
    /// <returns>The tax report transaction date.</returns>
    private TransDate parmTransactionDate(TransDate _transactionDate = transactionDate)
    {
        transactionDate = _transactionDate;
        return transactionDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxEnterpriseNumberForBE</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks tax enterpise number for Belgium.
    /// </summary>
    /// <returns> true if enterprise number validation passed; otherwise, false.</returns>
    private boolean checkTaxEnterpriseNumberForBE()
    {
        boolean ret = true;
        TaxEnterpriseNumber taxEnterpriseNumber = CompanyInfo::find().getPrimaryRegistrationNumber(TaxRegistrationTypesList::UID, transactionDate);

        if (!taxEnterpriseNumber)
        {
            ret = checkFailed(strfmt("@SYS89866", "@SYS77429"));
        }
        else if (!TaxEnterpriseBranchNumber_BE::checkEnterPriseNumber(taxEnterpriseNumber))
        {
            ret = checkFailed(strfmt("@SYS94000", taxEnterpriseNumber));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls whether the batch task should be retried in case of transient errors.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    [Hookable(false)]
    public boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPostWithBankExchangeRate</Name>
				<Source><![CDATA[
    private void saveAndPostWithBankExchangeRate(
        TaxTrans _taxTrans,
        RefRecId _taxTransOffsetRecId,
        LedgerDimensionAccount _taxLedgerDimension = 0)
    {
        // Use tax is not posted for bank exchange rate, you need to change this if use tax is supported for bank excchange rate
        if (_taxTrans.TaxDirection == TaxDirection::UseTax)
        {
            return;
        }

        TaxTransGeneralJournalAccountEntry taxTransGeneralJournalAccountEntry;
        select count(RecId) from taxTransGeneralJournalAccountEntry
            where taxTransGeneralJournalAccountEntry.taxTrans == _taxTrans.recid
                && taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::Tax
                && taxTransGeneralJournalAccountEntry.MonetaryAmountType == MonetaryAmount::Tax;

        int64 taxTransGeneralJournalAccountEntryCounts = taxTransGeneralJournalAccountEntry.recid;
        if (taxTransGeneralJournalAccountEntryCounts == 0)
        {
            return;
        }

        int taxTransGeneralJournalAccountEntryCurrentCount;
        Amount totalSettledTaxAmountMST;

        while select LedgerDimension, AccountingCurrencyAmount
            from taxTransGeneralJournalAccountEntry
            where taxTransGeneralJournalAccountEntry.taxTrans == _taxTrans.recid
                && taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::Tax
                && taxTransGeneralJournalAccountEntry.MonetaryAmountType == MonetaryAmount::Tax
        {
            TaxAmount accountingTaxAmount;
            taxTransGeneralJournalAccountEntryCurrentCount++;

            taxClearingLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(
                TaxLedgerAccountGroup::clearingLedgerDimension(_taxTrans.TaxCode),
                LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(taxTransGeneralJournalAccountEntry.LedgerDimension));

            if (taxTransGeneralJournalAccountEntryCurrentCount == taxTransGeneralJournalAccountEntryCounts)
            {
                accountingTaxAmount = _taxTrans.TaxAmount - totalSettledTaxAmountMST;
                accountingTaxAmount = CurrencyExchangeHelper::amount(accountingTaxAmount, companyStandardCurrency);
            }
            else
            {
                accountingTaxAmount = taxTransGeneralJournalAccountEntry.AccountingCurrencyAmount;
                accountingTaxAmount = CurrencyExchangeHelper::amount(accountingTaxAmount, companyStandardCurrency);
                totalSettledTaxAmountMST += accountingTaxAmount;
            }

            this.postBankExchangeRate(_taxTrans.TaxDirection,
                taxTransGeneralJournalAccountEntry.LedgerDimension,
                taxClearingLedgerDimension,
                accountingTaxAmount * -1,
                _taxTransOffsetRecId,
                _taxTrans.TaxCode,
                _taxTrans.TaxOrigin);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postBankExchangeRate</Name>
				<Source><![CDATA[
    private void postBankExchangeRate(
        TaxDirection _taxDirection,
        LedgerDimensionAccount _taxledgerDimension,
        LedgerDimensionAccount _clearingLedgerDimension,
        TaxAmount _taxAmountMST,
        RefRecId _taxTransRecId,
        TaxCode _taxCode,
        TaxOrigin _taxOrigin = TaxOrigin::Tax)
    {
        // Use tax is not considererd since bank exchange rate is not consider use tax in tax posting
        // Configuration key public sector is not considered since supported country in tax settlement is US/CA/FR/GB and for bank exchange rate supported country is CZ,HU,PL.
        // Exchange rate gain & loss is not considered since no currency conversion and no gain & loss
        // Rounrding rule on tax authority is not considerred since this feature only impact accounting currency, 0 for transaction currency.
        if (_taxAmountMST
            && (!taxParametersLocal.PurchTaxOnOperations || _taxDirection == TaxDirection::OutgoingTax)
            && _taxledgerDimension)
        {
            LedgerVoucherTransObject ledgerVoucherTransObject = this.addLedgerVoucherTransObjectForBankExchangeRate(
                ledgerPostingController,
                LedgerPostingType::Tax,
                _taxledgerDimension,
                _taxAmountMST,
                _taxTransRecId,
                TaxTransRelationshipType::Tax);

            ledgerPostingController.addTrans(ledgerVoucherTransObject);

            if (!vendAccount)
            {
                ledgerDimensionAccount clearingLedgerDimensionLocal = _clearingLedgerDimension;
                clearingLedgerDimensionLocal = this.addTransForBankExchangeRate(
                    ledgerPostingController,
                    LedgerPostingType::Tax,
                    clearingLedgerDimensionLocal,
                    -_taxAmountMST,
                    _taxledgerDimension,
                    _taxCode,
                    _taxOrigin);
            }

            totalClearingAmountMST += _taxAmountMST * -1;

            transactions++;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerVoucherTransObjectForBankExchangeRate</Name>
				<Source><![CDATA[
    private LedgerVoucherTransObject addLedgerVoucherTransObjectForBankExchangeRate(
        LedgerPostingController _ledgerPostingController,
        LedgerPostingType _ledgerPostingType,
        LedgerDimensionAccount _taxledgerDimension,
        TaxAmount _taxAmountMST,
        RefRecId _taxTransRecId,
        TaxTransRelationshipType _taxTransRelationshipType)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
            _ledgerPostingController.getReference(),
            _ledgerPostingType,
            _taxledgerDimension,
            companyStandardCurrency,
            _taxAmountMST,
            0); //Reporting currency amount is 0

        if (_taxTransRecId != 0)
        {
            ledgerVoucherTransObject.addTaxTransRelationship(
                _taxTransRecId,
                _taxTransRelationshipType,
                curext(),
                _taxAmountMST,
                0);
        }

        ledgerVoucherTransObject.parmSkipDimensionValidation(true);

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTransForBankExchangeRate</Name>
				<Source><![CDATA[
    private LedgerDimensionAccount addTransForBankExchangeRate(
        LedgerPostingController _ledgerPostingController,
        LedgerPostingType _ledgerPostingtype,
        LedgerDimensionAccount _ledgerDimensionAccount,
        TaxAmount _taxAmountMST,
        LedgerDimensionAccount _taxledgerDimension,
        TaxCode _taxCode,
        TaxOrigin _taxOrigin)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
            _ledgerPostingController.getReference(),
            _ledgerPostingType,
            _ledgerDimensionAccount,
            companyStandardCurrency,
            _taxAmountMST,
            0); //Reporting currency amount is 0

        LedgerDimensionAccount ledgerDimensionAccount = this.determineLedgerDimensionDueToAccountStructureChange(
            _taxledgerDimension,
            _ledgerDimensionAccount,
            _taxOrigin,
            _taxCode,
            ledgerVoucherTransObject);

        _ledgerPostingController.addTrans(ledgerVoucherTransObject);

        return ledgerDimensionAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unlockTaxPeriodBeforeRetry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unlock tax report period.
    /// </summary>
    /// <param name="_taxReportPeriodLock">The instance of TaxReportPeriodLock.</param>
    /// <param name="_taxReportPeriod">The instance of TaxReportPeriod.</param>
    internal protected void unlockTaxPeriodBeforeRetry(TaxReportPeriodLock _taxReportPeriodLock, TaxReportPeriod _taxReportPeriod)
    {
        _taxReportPeriodLock.unlockSettlementPeriod(_taxReportPeriod.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDialogFileNameVisible</Name>
				<Source><![CDATA[
    private boolean isDialogFileNameVisible(TaxPeriod _taxPeriod)
    {
        return countryRegion_IT
            && !TaxReportERHelper_IT::isERReportShouldBeUsed(
                TaxPeriodHead::find(_taxPeriod).TaxAuthority);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDialogPrintReportVisible</Name>
				<Source><![CDATA[
    private boolean isDialogPrintReportVisible(TaxPeriodHead _taxPeriodHead)
    {
        return !this.parmIsPreview();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePrintReportControl</Name>
				<Source><![CDATA[
    protected void updatePrintReportControl(TaxPeriod _taxPeriod)
    {
        if (dialogPrintReport)
        {
            // Currently, the control is hidden in case preview. In the future,
            // we may consider disabling the control if the print report parameter cannot be changed for other cases.
            dialogPrintReport.visible(this.isDialogPrintReportVisible(TaxPeriodHead::find(_taxPeriod)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateNow</Name>
				<Source><![CDATA[
    internal NoYes parmUpdateNow(NoYes _updateNow = updateNow)
    {
        updateNow = _updateNow;
        return updateNow;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>