<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>Tax</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Tax.Instrumentation;

/// <summary>
/// The <c>Tax</c> class is the tax calculation class.
/// </summary>
class Tax
{
    TmpTax                  tmpTax;
    Map                     amountInclTaxMap;
    Map                     amountExclTaxMap;
    DataAreaId              dataAreaIdPost;

    TmpTaxWorkTrans         taxWorkTrans;
    TaxTable                tmpTaxTable1, tmpTaxTable2;
    SelectableDataArea      tmpTaxTableCompany1, tmpTaxTableCompany2;

    Set                 totalValidationPctPerGross;
    Set                 totalValidationInvoiceInclVAT;

    TaxModuleType       taxModuleType;
    Voucher             voucher;
    TransDate           taxDate;

    RefTableId          headingTableId;
    RefRecId            headingRecId;

    TaxAmount           taxAmountCalc;
    TaxAmount           taxAmountCalcCur;
    TaxAmount           taxAmountCalcSourceCur;
    TaxAmountCur        taxAmountCalcSourceCurReal;
    TaxBase             taxBaseAmountCalc;
    TaxBase             taxBaseAmountCalcRaw;
    TaxBase             taxBaseAmountCalcCur;
    TaxBase             taxBaseAmountCalcSourceCurRaw;
    TaxBase             taxBaseAmountCalcSourceCur;
    TaxBase             taxBaseQtyCalc;
    TaxAmount           taxInCostPriceCalc;
    TaxAmount           taxInCostPriceMSTCalc;
    TaxAmount           taxInCostPriceCurCalc;
    TaxWarning          taxWarning;

    TaxParameters       taxParameters;
    CompanyInfo         companyInfo;

    CurrencyCode        sourceCurrencyCode;
    Currency            cachedSourceCurrency;
    Currency            cachedCompanyCurrency;

    boolean             taxIncludedInItemPrice;
    boolean             taxCalculateLine;
    boolean             taxCalculateTotal;

    NoYes               post;
    EUROTriangulation   triangulation;

    boolean             sourceSingleLine;
    boolean             taxRegulationExist;
    boolean             skipTaxCalculations;
    boolean             skipTaxCalculationsChecked;

    RecordSortedList    baseAmountSum;
    TmpTaxWorkTrans     tmpTaxWorkTransSum;

    private TaxCodeCombinationIdMaker taxCodeCombinationIdMaker;

    AmountCur               cashDiscAmount;
    Percent                 cashDiscPercent;

    ExchRate                exchRate;
    ExchRate                exchRateSecond;
    ReportingCurrencyExchRate reportingCurrencyExchRate;
    ReportingCurrencyExchRateSecondary reportingCurrencyExchRateSecondary;
    RefTableId          origHeadingTableId;
    RefRecId            origHeadingRecId;

    // tells tax to update existing TaxUncommitted records with the results of
    // the new tax lines in taxWorkTrans.
    boolean maintainExistingTaxUncommitted;

    // this field is a bridge to legacy tax references
    // this field is not for ledger posting general use and will be removed in M2
    LedgerVoucher temporaryLedgerPostingJournal;

    TaxSourceLineSummaryTmp     taxSourceLineSummaryTmp;

    protected Map reconcileMap;

    // <GEEU>
    VATNum                      vatNum;
    #EECountryRegionCodes
    // </GEEU>
    // <GEERU>
    Addressing                  addressing;
    InvoiceId                   invoiceId;
    DocumentDate                documentDate;
    RoundOff                    roundOff;
    // </GEERU>
    // <GIN>
    TaxUncommitted              taxUnCommittedbuffer;
    CustomsAmount_IN            customsTaxAmountCalc;
    CustomsAmount_IN            customsDuty;
    CustomsAmount_IN            sourceRegulateAmountCustomsCur;
    CustomsAmount_IN            sourceRegulateAmountCustomsMST;
    DocumentStatus              documentStatus;
    TaxAmountCur                totLOIAmount,nonRecAmount,loadOnInventry,abatementAmount, abatementAmountInq;
    TaxOnItem                   taxOnItemLoc;
    SalesPurchJournalLine       salesPurchJournalLineLoc;
    TaxBase                     taxQty;
    AmountCur                   assessableValue;
    AmountMST                   assessableValueAccountingCurrency;
    AmountCur                   maximumRetailPrice;
    NoYes                       post_IN;
    LedgerPostingType           taxPostingType;
    TmpTaxWorkTrans             tmpTaxWorkTransLoc;
    TaxBase                     baseQty;
    TaxItemGroup                freeTaxItemGroup;
    TaxGroup                    freeTaxGroup;
    RefRecId                    freeRecId;
    boolean                     freeText;
    boolean                     createDeferment;
    LedgerJournalTrans          ledgerJournalTransLoc;
    InventTransferUpdateType    inventTransferUpdateType;
    TaxBase                     mrpExclTax, accessableExclTax, lineExclTax;
    TmpTaxCalc_IN               tmpTaxCalc_IN;
    LedgerJournalTrans          ledgerJournalTransProject;
    AmountCur                   abatementMRP, abatementAssessable, abatementLine;
    AmountCur                   cashDiscPercent_IN;
    TaxAmount                   claimdeferedAmount;
    TaxAmount                   claimdeferedInvAmountLoc;
    RefRecId                    deferredInvAcc;
    AmountCur                   slsInvTaxAmtLoc;
    AmountCur                   vatInvTaxAmtLoc;
    AmountCur                   excInvTaxAmtLoc;
    NumberSequenceCode          exciseRG23CNumberSeqCode;
    NumberSequenceCode          exciseRG23ANumberSeqCode;
    LedgerDimensionDefaultAccount inventReceiptAcc;

    boolean                     localTaxes;
    AmountCur                   inventAssessableVal;
    AmountCur                   inventMaxRetailPrice;

    TaxGroupJournal             taxItemGroupLJT;

    RefRecId                    customsExpAccNum;
    RefRecId                    customsImpAccNum;
    RefRecId                    exciseDeferredAccount;

    CompanyId                   invoiceCompanyId;
    boolean                     isInterCompanyTrans;
    InventTransferParmLine      inventTransferParmLineLoc;
    InventTransferVoucherId     stockTransferVoucherId;
    boolean                     isNumSeqExist;
    InventTransId               inventTransNum;
    Num                         numberSequence;
    TaxCode                     customsTaxCode;
    TaxDirection                customsTaxDirection;
    TaxAmountCur                customsTaxAllocated;
    TaxTable                    taxTableExcise;
    boolean                     isAppliedLoadOnInventory;
    boolean                     shipReceive;
    InventQualityOrderTable     inventQualityOrderTable;
    Qty                         lineQty;
    InventQualityOrderQty       destructiveQty;
    TaxAmount                   eximTaxAmount;
    TaxAmount                   eximTaxAmountCalc;
    TaxAmount                   eximBalanceTaxAmtCalc;

    TaxAmount                   claimDeferredAmountMST;
    TaxAmount                   customsAmountMST;
    TaxAmount                   deferredAmountMST;
    TaxAmount                   exciseLOIMST;
    TaxAmountCur                eximTaxAmountCur;
    TaxAmountCur                eximBalanceTaxAmountCur;
    TaxAmountCur                totalTaxAmountCur_IN;

    TaxAmountCur                loadOnInventryExim;
    TaxAmountCur                loadOnInventryBalance;
    TaxAmount                   depbAmountCalc;
    TaxAmountCur                depbAmountCalcCur;

    container                   depbSetOffRules;
    container                   dutyavailed;
    boolean                     isEximEPCG;
    boolean                     isEximTaxAmount;
    boolean                     isDEPBUtilizedAmount;
    TaxAmountCur                eximTotalTaxAmountCur;
    TaxAmountCur                eximTotalBalanceTaxAmountCur;
    TaxAmount                   eximTotalTaxAmount;
    TaxAmount                   eximTotalBalanceTaxAmount;
    TaxAmountCur                eximTaxLOIAmountCur;
    TaxAmount                   eximTaxLOIAmount;
    TaxAmountCur                eximBalTaxLOIAmountCur;
    TaxAmount                   eximBalTaxLOIAmount;
    TaxAmount                   eximdepbLOIAmount;
    TaxAmountCur                eximdepbLOIAmountCur;
    container                   epcgImportTransDetails;
    RefRecId                    customsImportExportLedgerDimension;
    Voucher                     serviceTaxRelatedVoucher;
    LedgerDimensionDefaultAccount   excisePostingAccount;
    boolean                     isApplyExciseForDeffered;
    boolean                     isEximAdjusted;
    TaxModelTaxable_IN          taxModelTaxable;
    Voucher                     relatedVoucher;
    RefRecId                    interimTaxTrans;
    Voucher                     taxOffsetVoucher;
    boolean                     isCustomsEnabled;
    boolean                     isExciseEnabled;
    boolean                     isEximIncentiveSchemEnabled;
    boolean                     isSalesTaxEnabled;
    boolean                     isServiceTaxEnabled;
    boolean                     isVATEnabled;
    boolean                     isTaxRecoverabled;
    boolean                     isIndiaCountryRegionEnabled;
    boolean                     isTaxParametersEnabled;
    LedgerJournalTrans          ledgerJournalTransPay;

    Set                         taxTypesExcludedInPosting;
    TransTaxInformationHelper transTaxInformationHelper;
    // </GIN>
    // <GBR>
    NoYes   directImport_BR;
    NoYes   useAndConsumption_BR;
    Set     calculatedTaxes_BR;
    NoYes   isBrazilEnabled;

    protected boolean isTaxExcludeIssFromAmountOrigin_BRFlightEnabled;
    protected boolean isTaxExcludeIcmsFromAmountOrigin_BRFlightEnabled;

    // used in sumUpCode
    AmountMST       taxSubstitutionAmountAddedMST_BR;
    AmountCur       sourceTaxSubstitutionAmountAddedCur_BR;

    TaxAmountCur    icmsAmountToSubtractCur;
    TaxAmount       icmsAmountToSubtractMST;

    boolean         assetICMSReceivableLongTerm_BR;
    boolean         assetPISCOFINSReceivableLongTerm_BR;
    // </GBR>

    // <GEERU>
    TaxSourceType_RU sourceType;
    // </GEERU>

    Set     taxAdjustmentTypes;

    // <GEEU>
    VatDueDate_W            vatDate;
    PlCustVendName          custVendName;
    PlTaxPeriodPaymentCode  taxPeriodPaymentCode;
    CzPostponeVAT           postponeVAT;
    IntraComVATDueDate_W    intraComVatDate;
    VatDueDate_W            dueDate_W;
    boolean                 skipException;
    // </GEEU>

    ReasonTableRefRecId     reasonTableRefRecIdBeingCalculated;

    // <GEEU>
    boolean                 useTaxExchangeRate;
    CurrencyCode            accountingCurrency;
    // </GEEU>
    private CurrencyCode reportingCurrencyForTaxSpecificExchRate;

    // <GEEHU>
    LedgerVoucherObject     ledgerContinuousVoucherObject;
    boolean                 initializeContinuousHU;
    // </GEEHU>

    boolean                 skipLineMarkup;
    boolean                 skipTableMarkup;

    int                     numberOfInsertedTaxLines;
    int                     taxableDocumentLines;
    protected int markupTransTaxableDocumentLines;
    Map                     taxCurrencyConversionByCompanyMap;
    protected container grossUnitTaxAmounts;

    private Map taxOriginDiffMap;
    private Map pctTaxCodeMap;
    private Map nonePctTaxCodeMap;

    protected Map taxSpecificExchangeRateMap;
    private Map defaultExchRateMap;

    protected boolean isSourceTaxAmountCurAdjustToZero;

    #ISOCountryRegionCodes
    #define.CurrentVersion(2)
    #localmacro.CurrentList
        taxModuleType,
        voucher,
        taxDate,
        headingRecId,
        sourceCurrencyCode,
        post,
        triangulation,
        sourceSingleLine,
        taxRegulationExist,
        cashDiscAmount,
        cashDiscPercent,
        exchRate,
        exchRateSecond
    #endmacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmDataAreaIdPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets and gets the value DataAreaId to post tax.
    /// </summary>
    /// <param name="_dataAreaIdPost">
    ///    To set dataAreaIdPost.
    /// </param>
    /// <returns>
    ///   Returns the value DataAreaId to post tax.
    /// </returns>
    public DataAreaId parmDataAreaIdPost(DataAreaId _dataAreaIdPost = dataAreaIdPost)
    {
        dataAreaIdPost = _dataAreaIdPost;
        return dataAreaIdPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTaxAdjustmentType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the specified tax adjustment type to the collection of tax adjustment types.
    /// </summary>
    /// <param name="_taxAdjustmentType">
    /// The tax adjustment type to add.
    /// </param>
    protected final void addTaxAdjustmentType(TaxAdjustmentType _taxAdjustmentType)
    {
        if (!taxAdjustmentTypes.in(_taxAdjustmentType))
        {
            taxAdjustmentTypes.add(_taxAdjustmentType);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberOfInsertedTaxLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the number of tax lines inserted during tax calculation.
    /// </summary>
    /// <returns>The number of inserted tax lines.</returns>
    internal int getNumberOfInsertedTaxLines()
    {
        return numberOfInsertedTaxLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTaxAdjustmentTypes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the collection of tax adjustment types that can be used to make tax adjustments.
    /// </summary>
    /// <remarks>
    /// All transactions that uses tax adjustment functions support summary tax adjustment type by default.
    /// </remarks>
    protected void addTaxAdjustmentTypes()
    {
        this.addTaxAdjustmentType(TaxAdjustmentType::Summary);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTaxTypeExcludedInPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds tax type excluded in the posting.
    /// </summary>
    /// <param name="_taxType">
    /// The tax type excluded in the posting.
    /// </param>
    public void addTaxTypeExcludedInPosting(TaxType_IN _taxType)
    {
        this.parmTaxTypesExcludedInPosting().add(_taxType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustAmount</Name>
				<Source><![CDATA[
    void adjustAmount(ExchRate   _exchRate,
                      ExchRate   _exchrateSecondary,
                      boolean    _fixedExchRate = false)
    {
        // For taxCalculateLine case, looping taxWorkTrans by headingRecId causing adjustAmountData method called too much times for each line than expected.
        // To improve the performance, call adjustAmountLine method instead.
        // When calculate principle is 'Line' and tax marginal base is 'Net amount of invoice balance' or 'Invoice total include other sales tax amount',
        // taxCalculateTotal and taxCalculateLine are both true. In this case, it should adjust amount per total. So using !taxCalculateTotal but not taxCalculateLine here.
        if (!taxCalculateTotal)
        {
            this.adjustAmountLine(_exchRate, _exchrateSecondary);
        }
        else
        {
            TmpTaxWorkTrans sumTaxWorkTrans;
            TmpTaxWorkTrans taxWorkTransRep;
            taxWorkTransRep.setTmpData(taxWorkTrans);

            if (_exchRate)
            {
                ttsbegin;

                //
                //  Create a summary TaxWorkTrans for the current transaction
                //  and adjust the internal values for currency exchange.
                //
                while select sum(TaxInCostPrice),
                             sum(TaxBaseQty),
                             sum(SourceTaxAmountCur),
                             sum(SourceTaxAmountCurReal)
                      from taxWorkTrans
                      group by TaxCode, TaxDirection, CurrencyCode, SourceCurrencyCode, CalculationDate, ExchRate, ReportingCurrencyExchRate
                        // <GBR>
                        , FiscalValue_BR, TaxReceivableLongTerm_BR, TaxType_BR, TaxValue_BR
                        // </GBR>
                        where taxWorkTrans.HeadingRecId == headingRecId
                        && taxWorkTrans.HeadingTableId == headingTableId
                        && taxWorkTrans.TaxOrigin != TaxOrigin::Transfer
                {
                    sumTaxWorkTrans.data(taxWorkTrans.data());
                    sumTaxWorkTrans.insert(this.ignoreCalculatedSalesTax());
                    // <GIN>
                    if (isTaxParametersEnabled)
                    {
                        taxWorkTrans.CompanyId_IN = this.parmInvoiceCompany_IN() ? this.parmInvoiceCompany_IN() : curext();
                    }
                    // </GIN>

                    this.adjustAmountData(sumTaxWorkTrans, _exchRate, _exchrateSecondary);
                }

                //
                //  Update the TaxWorkTrans records for the current transaction for
                //  currency exchange.
                //
                while select forupdate taxWorkTrans
                where taxWorkTrans.HeadingRecId == headingRecId
                    && taxWorkTrans.HeadingTableId == headingTableId
                {
                    this.adjustAmountData(taxWorkTrans, _exchRate, _exchrateSecondary);
                }

                //
                //  Use the TaxWorkTrans summary values to properly
                //  allocate the taxes for the current transaction.
                //  This will also adjust the taxes for any rounding
                //  differences caused by currency exchange.
                //
                // <GEERU>
                if (!_fixedExchRate && taxCalculateTotal)
                {
                    // </GEERU>
                    while select sum(TaxAmount),
                                 sum(TaxAmountCur),
                                 sum(TaxInCostPrice),
                                 sum(TaxInCostPriceMST),
                                 sum(TaxInCostPriceCur),
                                 sum(TaxBaseAmount),
                                 sum(TaxBaseQty),
                                 sum(SourceTaxAmountCur),
                                 sum(SourceTaxAmountCurReal)
                          from sumTaxWorkTrans
                    group by TaxCode, TaxDirection, CalculationDate, SourceCurrencyCode
                        // <GBR>
                        , FiscalValue_BR, TaxReceivableLongTerm_BR
                        // </GBR>
                    {
                        // here we need to select reporting currency fixed exchange rate again in case for journals, each line may have different fixed exchange rate with the differnet transaction currency.
                        // so we need to update reportingCurrencyExchRate here in each sourceCurrrencyCode loop, then use it to do reporting currecny conversion in method allocateInTaxWorkTransWithCompany
                        select firstonly ReportingCurrencyExchRate from taxWorkTransRep
                            where taxWorkTransRep.SourceCurrencyCode    ==  sumTaxWorkTrans.SourceCurrencyCode
                                && taxWorkTransRep.TaxCode               ==  sumTaxWorkTrans.TaxCode
                                && taxWorkTransRep.TaxDirection          ==  sumTaxWorkTrans.TaxDirection
                                && taxWorkTransRep.CalculationDate       ==  sumTaxWorkTrans.CalculationDate;
                        this.reportingCurrencyExchRate = taxWorkTransRep.reportingCurrencyExchRate;
                        this.allocateInTaxWorkTransWithCompany(
                                                    sumTaxWorkTrans.TaxCode,
                                                    sumTaxWorkTrans.TaxDirection,
                                                    sumTaxWorkTrans.TaxAmount,
                                                    sumTaxWorkTrans.TaxAmountCur,
                                                    sumTaxWorkTrans.TaxInCostPrice,
                                                    sumTaxWorkTrans.TaxInCostPriceMST,
                                                    sumTaxWorkTrans.TaxInCostPriceCur,
                                                    sumTaxWorkTrans.TaxBaseAmount,
                                                    sumTaxWorkTrans.TaxBaseQty,
                                                    sumTaxWorkTrans.SourceTaxAmountCur,
                                                    sumTaxWorkTrans.SourceTaxAmountCurReal,
                                                    NoYes::Yes,
                                                    sumTaxWorkTrans.CalculationDate,
                                                    TaxWarning::NoWarning,
                                                    // <GBR>
                                                    sumTaxWorkTrans.FiscalValue_BR,
                                                    sumTaxWorkTrans.TaxReceivableLongTerm_BR,
                                                    // </GBR>
                                                    sumTaxWorkTrans.SourceCurrencyCode
                            );
                    }
                    // <GEERU>
                }
                // </GEERU>

                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustAmountData</Name>
				<Source><![CDATA[
    //
    //  This method will adjust the passed in TmpTaxWorkTrans to the
    //  correct currency exchange rate for the transaction.
    //
    void adjustAmountData(TmpTaxWorkTrans   _taxWorkTrans,
                          ExchRate          _exchRate,
                          ExchRate   _exchrateSecondary)

    {
        ;

        ExchRate exchRateLoc;
        TaxCurrencyConversionRoutineHandler handler = TaxCurrencyConversionRoutineHandler::instance();

        if (_taxWorkTrans.ExchRate)
        {
            exchRateLoc = _taxWorkTrans.ExchRate;
        }
        else
        {
            exchRateLoc = _exchRate;
        }

        _taxWorkTrans.TaxAmount      = CurrencyExchangeHelper::mstAmount(_taxWorkTrans.SourceTaxAmountCur, _taxWorkTrans.SourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), exchRateLoc, _exchrateSecondary);
        _taxWorkTrans.TaxBaseAmount  = CurrencyExchangeHelper::mstAmount(_taxWorkTrans.SourceBaseAmountCur, _taxWorkTrans.SourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), exchRateLoc, _exchrateSecondary);

        //Feature Sales Tax Conversion
        if (this.isTaxCurrencyConversionFeatureEnabled())
        {
            // here we retrieve reporting currency amount immediately to use cached data from tax currency amount conversion for case conversion routine is reporting currency
            _taxWorkTrans.TaxAmountCur      = handler.transCurrencyToTaxCurrency(_taxWorkTrans.SourceCurrencyCode, _taxWorkTrans.CurrencyCode, _taxWorkTrans.SourceTaxAmountCur,
                                                                                exchRateLoc, _taxWorkTrans.ReportingCurrencyExchRate, taxDate);
            _taxWorkTrans.TaxAmountRep      = handler.transCurrencyToReportingCurrency(_taxWorkTrans.SourceCurrencyCode, _taxWorkTrans.SourceTaxAmountCur,
                                                                                        _taxWorkTrans.ReportingCurrencyExchRate, taxDate);

            _taxWorkTrans.TaxBaseAmountCur  = handler.transCurrencyToTaxCurrency(_taxWorkTrans.SourceCurrencyCode, _taxWorkTrans.CurrencyCode, _taxWorkTrans.SourceBaseAmountCur,
                                                                                exchRateLoc, _taxWorkTrans.ReportingCurrencyExchRate, taxDate);
            _taxWorkTrans.TaxBaseAmountRep  = handler.transCurrencyToReportingCurrency(_taxWorkTrans.SourceCurrencyCode, _taxWorkTrans.SourceBaseAmountCur,
                                                                                        _taxWorkTrans.ReportingCurrencyExchRate, taxDate);

        }
        else
        {
            if (_taxWorkTrans.CurrencyCode == _taxWorkTrans.SourceCurrencyCode)
            {
                _taxWorkTrans.TaxAmountCur     = _taxWorkTrans.SourceTaxAmountCur;
                _taxWorkTrans.TaxBaseAmountCur = _taxWorkTrans.SourceBaseAmountCur;
            }
            else
            {
                _taxWorkTrans.TaxAmountCur       = CurrencyExchangeHelper::curAmount(_taxWorkTrans.TaxAmount, _taxWorkTrans.CurrencyCode, taxDate);
                _taxWorkTrans.TaxBaseAmountCur   = CurrencyExchangeHelper::curAmount(_taxWorkTrans.TaxBaseAmount, _taxWorkTrans.CurrencyCode, taxDate);
            }
            _taxWorkTrans.TaxAmountRep       = handler.transCurrencyToReportingCurrency(_taxWorkTrans.SourceCurrencyCode, _taxWorkTrans.SourceTaxAmountCur,
                                                                                        _taxWorkTrans.ReportingCurrencyExchRate, taxDate);
            _taxWorkTrans.TaxBaseAmountRep   = handler.transCurrencyToReportingCurrency(_taxWorkTrans.SourceCurrencyCode, _taxWorkTrans.SourceBaseAmountCur,
                                                                                        _taxWorkTrans.ReportingCurrencyExchRate, taxDate);
        }
        _taxWorkTrans.TaxInCostPriceMST  = CurrencyExchangeHelper::mstAmount(_taxWorkTrans.TaxInCostPrice, _taxWorkTrans.SourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), exchRateLoc, _exchrateSecondary);
        //Feature Sales Tax Conversion
        if (this.isTaxCurrencyConversionFeatureEnabled())
        {
            _taxWorkTrans.TaxInCostPriceCur  = handler.transCurrencyToTaxCurrency(_taxWorkTrans.SourceCurrencyCode, _taxWorkTrans.CurrencyCode, _taxWorkTrans.TaxInCostPrice,
                                                                                exchRateLoc, _taxWorkTrans.ReportingCurrencyExchRate, taxDate);
        }
        else
        {
            if (_taxWorkTrans.CurrencyCode == _taxWorkTrans.SourceCurrencyCode)
            {
                _taxWorkTrans.TaxInCostPriceCur = _taxWorkTrans.TaxInCostPrice;
            }
            else
            {
                _taxWorkTrans.TaxInCostPriceCur  = CurrencyExchangeHelper::curAmount(_taxWorkTrans.TaxInCostPriceMST, _taxWorkTrans.CurrencyCode, taxDate);
            }
        }
        _taxWorkTrans.TaxInCostPriceRep  = handler.transCurrencyToReportingCurrency(_taxWorkTrans.SourceCurrencyCode, _taxWorkTrans.TaxInCostPrice,
                                                                                        _taxWorkTrans.ReportingCurrencyExchRate, taxDate);

        // <GBR>
        if (isBrazilEnabled)
        {
            if (TaxTable::TaxMustMatchBaseAndPercentage_BR(_taxWorkTrans.TaxType_BR))
            {
                _taxWorkTrans.TaxBaseAmount += TaxTable::calcPennyDiffFromTaxBasePercentageTaxCode_BR(_taxWorkTrans.TaxBaseAmount, _taxWorkTrans.TaxValue_BR, _taxWorkTrans.TaxAmount, _taxWorkTrans.TaxCode);
            }

            _taxWorkTrans.SourceOtherBaseAmountMST_BR   = CurrencyExchangeHelper::mstAmount(_taxWorkTrans.SourceOtherBaseAmount_BR, _taxWorkTrans.SourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), exchRateLoc, _exchrateSecondary);

            _taxWorkTrans.SourceOtherTaxAmountMST_BR  = CurrencyExchangeHelper::mstAmount(_taxWorkTrans.SourceOtherBaseTaxAmount_BR, _taxWorkTrans.SourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), exchRateLoc, _exchrateSecondary);

            _taxWorkTrans.SourceExemptTaxAmountMST_BR  = CurrencyExchangeHelper::mstAmount(_taxWorkTrans.SourceExemptTaxAmount_BR, _taxWorkTrans.SourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), exchRateLoc, _exchrateSecondary);

            _taxWorkTrans.SourceExemptBaseAmountMST_BR  = CurrencyExchangeHelper::mstAmount(_taxWorkTrans.SourceExemptBaseAmount_BR, _taxWorkTrans.SourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), exchRateLoc, _exchrateSecondary);
        }
        // </GBR>

        _taxWorkTrans.update(this.ignoreCalculatedSalesTax());
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustAmountLine</Name>
				<Source><![CDATA[
    void adjustAmountLine(ExchRate   _exchRate,
                          ExchRate   _exchrateSecondary)

    {
        if (_exchRate)

        {
            ttsbegin;

            //
            //  Adjust each taxWorkTrans record for currency exchange.
            //
            while select forupdate taxWorkTrans

            where taxWorkTrans.HeadingRecId == headingRecId &&
                  taxWorkTrans.HeadingTableId == headingTableId &&
                  taxWorkTrans.SourceTableId == this.sourceTableId() &&
                  taxWorkTrans.SourceRecId == this.sourceRecId()
            {
                this.adjustAmountData(taxWorkTrans, _exchRate, _exchrateSecondary);
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustBaseAmount</Name>
				<Source><![CDATA[
    private void adjustBaseAmount()
    {
        boolean     more;
        TaxTable    taxTable;

        CurrencyCode accountingCurrencyCode = Ledger::accountingCurrency();

        this.initBaseAmountSum();
        while select  sum(TaxBaseAmountRaw),sum(TaxBaseAmount), sum(SourceBaseAmountCurRaw)
            from taxWorkTrans
            group by TaxCode, TaxDirection, sourceCurrencyCode
            where taxWorkTrans.HeadingRecId == headingRecId &&
                taxWorkTrans.HeadingTableId == headingTableId &&
                taxWorkTrans.SourceCurrencyCode != accountingCurrencyCode &&
                taxWorkTrans.TaxOrigin != TaxOrigin::Transfer &&
                /* <SYS>
                taxWorkTrans.ExemptTax       == NoYes::No
                </SYS> */
                // <GEERU>
                (taxWorkTrans.ExemptTax == NoYes::No ||
                this.processExemptTax_RU())
                // </GEERU>
                join RecId from taxTable
                where taxWorkTrans.TaxCode == taxTable.TaxCode &&
                    taxTable.TaxBase != TaxBaseType::PctPerTax &&
                    taxTable.TaxBase != TaxBaseType::AmountByUnit
        {
            tmpTaxWorkTransSum.TaxCode = taxWorkTrans.TaxCode;
            tmpTaxWorkTransSum.TaxDirection = taxWorkTrans.TaxDirection;
            tmpTaxWorkTransSum.SourceCurrencyCode = taxWorkTrans.SourceCurrencyCode;
            baseAmountSum.find(tmpTaxWorkTransSum);

            tmpTaxWorkTransSum.TaxAmount = CurrencyExchangeHelper::amount(CurrencyExchangeHelper::amount(CurrencyExchangeHelper::mstAmount(tmpTaxWorkTransSum.SourceBaseAmountCurRaw, tmpTaxWorkTransSum.SourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), 0, 0, false)) - taxWorkTrans.TaxBaseAmount);

            // TaxAmountCur here is used as a temporary container which used to store transaction currency base amount diff but not tax currency amount.
            tmpTaxWorkTransSum.TaxAmountCur = CurrencyExchangeHelper::amount(tmpTaxWorkTransSum.SourceBaseAmountCurRaw - taxWorkTrans.SourceBaseAmountCurRaw, tmpTaxWorkTransSum.SourceCurrencyCode);
            baseAmountSum.ins(tmpTaxWorkTransSum,true);
        }

        for (more = baseAmountSum.first(tmpTaxWorkTransSum);
        more;
        more = baseAmountSum.next(tmpTaxWorkTransSum))
        {
            if (tmpTaxWorkTransSum.TaxAmount || tmpTaxWorkTransSum.TaxAmountCur)
            {
                select forupdate taxWorkTrans
                    where taxWorkTrans.HeadingRecId == headingRecId &&
                        taxWorkTrans.HeadingTableId == headingTableId &&
                        /* <SYS>
                        taxWorkTrans.ExemptTax == NoYes::No         &&
                        </SYS> */
                        // <GEERU>
                        (taxWorkTrans.ExemptTax == NoYes::No ||
                         this.processExemptTax_RU()) &&
                        // </GEERU>
                        taxWorkTrans.TaxCode == tmpTaxWorkTransSum.TaxCode &&
                        taxWorkTrans.TaxDirection == tmpTaxWorkTransSum.TaxDirection &&
                        taxWorkTrans.TaxOrigin != TaxOrigin::Transfer &&
                        taxWorkTrans.SourceCurrencyCode == tmpTaxWorkTransSum.SourceCurrencyCode;
                // <GIN>
                if (isTaxParametersEnabled)
                {
                    if (TaxTable::find(taxWorkTrans.TaxCode).TaxType_IN != TaxType_IN::None)
                    {
                        continue;
                    }
                }
                // </GIN>
                taxWorkTrans.TaxBaseAmount += CurrencyExchangeHelper::amount(tmpTaxWorkTransSum.TaxAmount);
                if (!TaxRawAmountRoundWithDiffTaxAndAccountingCurrencyCodeFlight::instance().isEnabled()
                        || taxWorkTrans.CurrencyCode != Ledger::accountingCurrency())
                {
                    taxWorkTrans.TaxBaseAmountCur += CurrencyExchangeHelper::amount(tmpTaxWorkTransSum.TaxAmountCur);
                }
                else
                {
                    taxWorkTrans.TaxBaseAmountCur += CurrencyExchangeHelper::amount(tmpTaxWorkTransSum.TaxAmount);
                }

                if (taxWorkTrans.SourceCurrencyCode == Ledger::accountingCurrency(CompanyInfo::current()))
                {
                    // if transactional currency and accounting currency are the same, then the origins should
                    // be the same.
                    taxWorkTrans.SourceBaseAmountCur = taxWorkTrans.TaxBaseAmount;
                }
                else
                {
                    taxWorkTrans.SourceBaseAmountCur += CurrencyExchangeHelper::amount(tmpTaxWorkTransSum.TaxAmountCur, tmpTaxWorkTransSum.SourceCurrencyCode);
                }

                taxWorkTrans.update(this.ignoreCalculatedSalesTax());
            }

        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustBaseAmountForTaxAmount</Name>
				<Source><![CDATA[
    private TaxBase adjustBaseAmountForTaxAmount(TaxCode _taxCode, TaxBase _baseAmount, AmountCur _lineAmount, TaxAmountCur _taxAmount, boolean _rounding)
    {
        TaxBase         roundedTaxBase;

        roundedTaxBase = CurrencyExchangeHelper::amount(_baseAmount, sourceCurrencyCode);

        if (roundedTaxBase + _taxAmount != _lineAmount)
        {
            return (_lineAmount - _taxAmount);
        }

        return _baseAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustPennyDiff</Name>
				<Source><![CDATA[
    public void adjustPennyDiff(AmountCur  _amountDiff,
                         RefTableId _sourceTableId = 0,
                         RefRecId   _sourceRecId   = 0)
    {
        boolean   adjustTaxInCostPrice;
        TaxTable taxTable;
        TaxCurrencyConversionRoutineHandler handler = TaxCurrencyConversionRoutineHandler::instance();

        while select forupdate taxWorkTrans

        where taxWorkTrans.SourceRecId == _sourceRecId &&
              taxWorkTrans.SourceTableId == _sourceTableId
        join RecId from taxTable
        where taxTable.TaxCode == taxWorkTrans.TaxCode &&
              !taxTable.TaxOnTax &&
              (taxTable.TaxBase != TaxBaseType::PctPerGross &&
               taxTable.TaxBase != TaxBaseType::AmountByUnit)
        {
            if (taxWorkTrans)
            {
                // TaxInCostPrice is only used in certain scenarios.  In those scenarios in which it is used, then
                // it will always be equal to the tax amount.  So, the flag adjustTaxInCostPrice, if true, will
                // indicate that TaxInCostPrice is used in this scenario.  If TaxInCostPrice is not used then it is 0.
                adjustTaxInCostPrice = taxWorkTrans.TaxInCostPrice == taxWorkTrans.SourceTaxAmountCur;

                // <GIN>
                if (isTaxParametersEnabled

                    && TaxTable::find(taxWorkTrans.TaxCode).TaxType_IN != TaxType_IN::None
                    && this.parmLocalTaxes_IN())
                {
                    _amountDiff = 0;
                }
                // </GIN>

                taxWorkTrans.SourceBaseAmountCur -= _amountDiff;

                if (adjustTaxInCostPrice)
                {
                    taxWorkTrans.TaxInCostPrice = taxWorkTrans.SourceTaxAmountCur;
                    taxWorkTrans.TaxInCostPriceMST = taxWorkTrans.TaxAmount;
                    taxWorkTrans.TaxInCostPriceCur = taxWorkTrans.TaxAmountCur;
                    taxWorkTrans.TaxInCostPriceRep = taxWorkTrans.TaxAmountRep;
                }

                taxWorkTrans.SourceBaseAmountCur = CurrencyExchangeHelper::amount(taxWorkTrans.SourceBaseAmountCur, taxWorkTrans.SourceCurrencyCode);
                taxWorkTrans.SourceBaseAmountCurCalculated = taxWorkTrans.SourceBaseAmountCur;

                // Adjust MST Amounts
                if (taxWorkTrans.SourceCurrencyCode == Ledger::accountingCurrency(this.companyInfo().RecId))
                {
                    taxWorkTrans.TaxBaseAmount = taxWorkTrans.SourceBaseAmountCur;
                }
                else
                {
                    taxWorkTrans.TaxBaseAmount = CurrencyExchangeHelper::mstAmount(taxWorkTrans.SourceBaseAmountCur, taxWorkTrans.SourceCurrencyCode, taxWorkTrans.TransDate, Currency::noYes2UnknownNoYes(taxWorkTrans.euroTriangulation), taxWorkTrans.ExchRate);
                }

                //Feature Sales Tax Conversion
                if (this.isTaxCurrencyConversionFeatureEnabled())
                {
                    taxWorkTrans.TaxBaseAmountCur = handler.transCurrencyToTaxCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.CurrencyCode, taxWorkTrans.SourceBaseAmountCur,
                                                                                        taxWorkTrans.ExchRate, taxWorkTrans.ReportingCurrencyExchRate,taxWorkTrans.TransDate);
                }
                else
                {
                    // Adjust Reporting Currency Amounts
                    if (taxWorkTrans.CurrencyCode && taxWorkTrans.CurrencyCode == taxWorkTrans.SourceCurrencyCode)
                    {
                        taxWorkTrans.TaxBaseAmountCur = taxWorkTrans.SourceBaseAmountCur;
                    }
                    else
                    {
                        if (TaxBaseAmountCurCalcWithTaxExchRateInAdjustPennyDiffFlight::instance().isEnabled())
                        {
                            taxWorkTrans.TaxBaseAmountCur = CurrencyExchangeHelper::curAmount(taxWorkTrans.TaxBaseAmount, taxWorkTrans.CurrencyCode, taxWorkTrans.TransDate, Currency::noYes2UnknownNoYes(taxWorkTrans.euroTriangulation));
                        }
                        else
                        {
                            taxWorkTrans.TaxBaseAmountCur = CurrencyExchangeHelper::curAmount(taxWorkTrans.TaxBaseAmount, taxWorkTrans.CurrencyCode, taxWorkTrans.TransDate, Currency::noYes2UnknownNoYes(taxWorkTrans.euroTriangulation), this.exchRate());
                        }
                    }
                }
                taxWorkTrans.TaxBaseAmountRep = handler.transCurrencyToReportingCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.SourceBaseAmountCur,
                                                                                            taxWorkTrans.ReportingCurrencyExchRate, taxWorkTrans.TransDate);

                taxWorkTrans.update(this.ignoreCalculatedSalesTax());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustRoundingDiff</Name>
				<Source><![CDATA[
    protected AmountCur adjustRoundingDiff(AmountCur _amountDiff,
                                 RecId     _recId)
    {
        TaxTable                taxTable;
        TaxData                 taxData;
        CurrencyCode            companyCurrecyCode;
        RealBase                factor;
        ;

        if (!_amountDiff)

            return _amountDiff;

        TaxCurrencyConversionRoutineHandler handler = TaxCurrencyConversionRoutineHandler::instance();
        companyCurrecyCode  =  Ledger::accountingCurrency(this.companyInfo().RecId);
        CurrencyCode reportingCurrency = Ledger::reportingCurrency(this.companyInfo().RecId);

        select firstonly forupdate taxWorkTrans

        where taxWorkTrans.RecId == _recId;

        taxTable = TaxTable::find(taxWorkTrans.TaxCode);

        if (taxWorkTrans.SourceTaxAmountCur)
        {
            // Same calculation as the update done in tax.allocateInWorkTrans
            factor = (taxWorkTrans.SourceTaxAmountCur - _amountDiff) / taxWorkTrans.SourceTaxAmountCur;

            taxWorkTrans.TaxAmount              = CurrencyExchangeHelper::amount(taxWorkTrans.TaxAmount * factor, companyCurrecyCode);
            taxWorkTrans.SourceTaxAmountCur     = CurrencyExchangeHelper::amount(taxWorkTrans.SourceTaxAmountCur * factor, taxWorkTrans.SourceCurrencyCode);
            taxWorkTrans.TaxAmountCur           = CurrencyExchangeHelper::amount(taxWorkTrans.TaxAmountCur * factor, taxTable.TaxCurrencyCode);
            taxWorkTrans.TaxAmountRep           = CurrencyExchangeHelper::amount(taxWorkTrans.TaxAmountRep * factor, reportingCurrency);
            taxWorkTrans.TaxInCostPrice         = CurrencyExchangeHelper::amount(taxWorkTrans.TaxInCostPrice * factor, taxWorkTrans.SourceCurrencyCode);
            taxWorkTrans.TaxInCostPriceMST      = CurrencyExchangeHelper::amount(taxWorkTrans.TaxInCostPriceMST * factor, companyCurrecyCode);
            taxWorkTrans.TaxInCostPriceCur      = CurrencyExchangeHelper::amount(taxWorkTrans.TaxInCostPriceCur * factor, taxTable.TaxCurrencyCode);
            taxWorkTrans.TaxInCostPriceRep      = CurrencyExchangeHelper::amount(taxWorkTrans.TaxInCostPriceRep * factor, reportingCurrency);
        }
        else
        {
            // Same calculation as the update in taxRegulation.calcManualInserted
            taxData     = TaxData::find(taxWorkTrans.TaxCode,

                                        taxWorkTrans.TransDate,
                                        taxWorkTrans.SourceBaseAmountCurRegulated);

            taxWorkTrans.SourceTaxAmountCur = -_amountDiff;

            if (taxData.vatExemptPct

                // <GTH>
                && !(TaxThaiGovCertificationFeatureChecker::isAverageVATEnabled()
                    && TaxTable::isNormalVAT(taxWorkTrans.TaxCode))
                // </GTH>
                )
                taxWorkTrans.TaxInCostPrice = CurrencyExchangeHelper::amount(taxWorkTrans.SourceTaxAmountCur * taxData.vatExemptPct / 100, sourceCurrencyCode);
            else
                taxWorkTrans.TaxInCostPrice = 0;

            if (taxWorkTrans.SourceCurrencyCode == companyCurrecyCode)
            {
                taxWorkTrans.TaxInCostPriceMST = taxWorkTrans.TaxInCostPrice;
                taxWorkTrans.TaxAmount         = taxWorkTrans.SourceTaxAmountCur;
                taxWorkTrans.TaxBaseAmount     = taxWorkTrans.SourceBaseAmountCur;
            }
            else
            {
                UnknownNoYes euroTriangulation = Currency::noYes2UnknownNoYes(taxWorkTrans.EUROTriangulation);

                taxWorkTrans.TaxInCostPriceMST = CurrencyExchangeHelper::mstAmount(taxWorkTrans.TaxInCostPrice, taxWorkTrans.SourceCurrencyCode, taxWorkTrans.TransDate, euroTriangulation, taxWorkTrans.ExchRate);
                taxWorkTrans.TaxAmount = CurrencyExchangeHelper::mstAmount(taxWorkTrans.SourceTaxAmountCur, taxWorkTrans.SourceCurrencyCode, taxWorkTrans.TransDate, euroTriangulation, taxWorkTrans.ExchRate);
                taxWorkTrans.TaxBaseAmount = CurrencyExchangeHelper::mstAmount(taxWorkTrans.SourceBaseAmountCur, taxWorkTrans.SourceCurrencyCode, taxWorkTrans.TransDate, euroTriangulation, taxWorkTrans.ExchRate);
            }
            if (taxTable.TaxCurrencyCode)
            {
                //Feature Sales Tax Conversion
                if (this.isTaxCurrencyConversionFeatureEnabled())
                {
                    taxWorkTrans.TaxInCostPriceCur = handler.transCurrencyToTaxCurrency(taxWorkTrans.SourceCurrencyCode, taxTable.TaxCurrencyCode, taxWorkTrans.TaxInCostPrice,
                                                                                        taxWorkTrans.ExchRate, taxWorkTrans.ReportingCurrencyExchRate, taxWorkTrans.TransDate);

                    taxWorkTrans.TaxInCostPriceRep = handler.transCurrencyToReportingCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.TaxInCostPrice,
                                                                                                taxWorkTrans.ReportingCurrencyExchRate, taxWorkTrans.TransDate);

                    taxWorkTrans.TaxAmountCur      = handler.transCurrencyToTaxCurrency(taxWorkTrans.SourceCurrencyCode, taxTable.TaxCurrencyCode, taxWorkTrans.SourceTaxAmountCur,
                                                                                        taxWorkTrans.ExchRate, taxWorkTrans.ReportingCurrencyExchRate, taxWorkTrans.TransDate);

                    taxWorkTrans.TaxAmountRep      = handler.transCurrencyToReportingCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.SourceTaxAmountCur,
                                                                                                taxWorkTrans.ReportingCurrencyExchRate, taxWorkTrans.TransDate);

                    taxWorkTrans.TaxBaseAmountCur  = handler.transCurrencyToTaxCurrency(taxWorkTrans.SourceCurrencyCode, taxTable.TaxCurrencyCode, taxWorkTrans.SourceBaseAmountCur,
                                                                                        taxWorkTrans.ExchRate, taxWorkTrans.ReportingCurrencyExchRate, taxWorkTrans.TransDate);

                    taxWorkTrans.TaxBaseAmountRep  = handler.transCurrencyToReportingCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.SourceBaseAmountCur,
                                                                                                taxWorkTrans.ReportingCurrencyExchRate, taxWorkTrans.TransDate);

                }
                else
                {
                    if (taxTable.TaxCurrencyCode == taxWorkTrans.SourceCurrencyCode)
                    {
                        taxWorkTrans.TaxInCostPriceCur = taxWorkTrans.TaxInCostPrice;
                        taxWorkTrans.TaxAmountCur      = taxWorkTrans.SourceTaxAmountCur;
                        taxWorkTrans.TaxBaseAmountCur  = taxWorkTrans.SourceBaseAmountCur;
                    }
                    else
                    {
                        if (taxTable.TaxCurrencyCode == companyCurrecyCode)
                        {
                            taxWorkTrans.TaxInCostPriceCur = taxWorkTrans.TaxInCostPriceMST;
                            taxWorkTrans.TaxAmountCur      = taxWorkTrans.TaxAmount;
                            taxWorkTrans.TaxBaseAmountCur  = taxWorkTrans.TaxBaseAmount;
                        }
                        else
                        {
                            taxWorkTrans.TaxInCostPriceCur = CurrencyExchangeHelper::curAmount(taxWorkTrans.TaxInCostPriceMST, taxTable.TaxCurrencyCode, taxWorkTrans.TransDate);

                            taxWorkTrans.TaxAmountCur      = CurrencyExchangeHelper::curAmount(taxWorkTrans.TaxAmount, taxTable.TaxCurrencyCode, taxWorkTrans.TransDate);

                            taxWorkTrans.TaxBaseAmountCur  = CurrencyExchangeHelper::curAmount(taxWorkTrans.TaxBaseAmount, taxTable.TaxCurrencyCode, taxWorkTrans.TransDate);
                        }
                    }
                    taxWorkTrans.TaxInCostPriceRep = handler.transCurrencyToReportingCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.TaxInCostPrice,
                                                                                                taxWorkTrans.ReportingCurrencyExchRate, taxWorkTrans.TransDate);

                    taxWorkTrans.TaxAmountRep      = handler.transCurrencyToReportingCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.SourceTaxAmountCur,
                                                                                                taxWorkTrans.ReportingCurrencyExchRate, taxWorkTrans.TransDate);

                    taxWorkTrans.TaxBaseAmountRep  = handler.transCurrencyToReportingCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.SourceBaseAmountCur,
                                                                                                taxWorkTrans.ReportingCurrencyExchRate, taxWorkTrans.TransDate);
                }
            }
        }
        taxWorkTrans.update(this.ignoreCalculatedSalesTax());
        return _amountDiff;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustTaxInCostPrice</Name>
				<Source><![CDATA[
    void adjustTaxInCostPrice(ExchRate _exchRate)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>afterTaxTransInserted_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// The method should be called after <c>TaxTrans</c> is inserted. To be overriden by subclasses.
    /// </summary>
    /// <param name="_taxTrans">Tax transaction inserted</param>
    protected void afterTaxTransInserted_RU(TaxTrans _taxTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateBaseInTaxWorkTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allocates the base amount for table <c>TmpTaxWorkTrans</c>.
    /// </summary>
    /// <param name = "_taxCode">The tax code.</param>
    /// <param name = "_taxDirection">The tax direction.</param>
    /// <param name = "_taxBaseAmountRaw">The raw tax base amount.</param>
    /// <param name = "_totalTaxBaseMST">The total MST tax amount.</param>
    /// <param name = "_totalTaxBaseMSTRaw">The total raw MST tax base amount.</param>
    /// <param name = "_calculationDate">The calculation date.</param>
    /// <param name = "_totalTaxBaseCur">The tatal current tax base amount.</param>
    /// <param name = "_sourceCurrencyCode">The source currency code.</param>
    protected void allocateBaseInTaxWorkTrans(TaxCode       _taxCode,
                                              TaxDirection  _taxDirection,
                                              TaxBase       _taxBaseAmountRaw,
                                              TaxBase       _totalTaxBaseMST,
                                              TaxBase       _totalTaxBaseMSTRaw,
                                              TransDate     _calculationDate,
                                              TaxBase       _totalTaxBaseCur,
                                              CurrencyCode  _sourceCurrencyCode)
    {
        TaxTable         taxTable;
        RecId            taxWorkTransRecId;
        TaxBase          highestTaxBaseAmount;
        TaxBase          savedTaxBase, savedTaxBaseCur;
        Factor           factor;
        ;
        taxTable = TaxTable::find(_taxCode);

        highestTaxBaseAmount    = 0;
        savedTaxBase            = 0;

        while select forupdate taxWorkTrans
            where taxWorkTrans.HeadingRecId == headingRecId &&
                taxWorkTrans.HeadingTableId == headingTableId &&
                /* <SYS>
                taxWorkTrans.ExemptTax == NoYes::No &&
                </SYS> */
                // <GEERU>
                (taxWorkTrans.ExemptTax == NoYes::No ||
                    this.processExemptTax_RU()) &&
                // </GEERU>
                taxWorkTrans.TaxCode == _taxCode &&
                taxWorkTrans.TaxDirection == _taxDirection &&
                taxWorkTrans.CalculationDate == _calculationDate &&
                taxWorkTrans.SourceCurrencyCode == _sourceCurrencyCode
        {
            if (_taxBaseAmountRaw)
                factor = _totalTaxBaseMSTRaw / _taxBaseAmountRaw;
            else
                factor = 1;

            taxWorkTrans.TaxBaseAmount       = CurrencyExchangeHelper::amount(taxWorkTrans.TaxBaseAmount * factor, Ledger::accountingCurrency(this.companyInfo().RecId));
            taxWorkTrans.TaxBaseAmountRaw    = taxWorkTrans.TaxBaseAmountRaw * factor;
            taxWorkTrans.TaxBaseAmountCur    = CurrencyExchangeHelper::amount(taxWorkTrans.TaxBaseAmountCur * factor, taxTable.TaxCurrencyCode);
            taxWorkTrans.TaxBaseAmountRep    = CurrencyExchangeHelper::amount(taxWorkTrans.TaxBaseAmountRep * factor, Ledger::reportingCurrency(this.companyInfo().RecId));
            taxWorkTrans.SourceBaseAmountCur = CurrencyExchangeHelper::amount(taxWorkTrans.SourceBaseAmountCur * factor, taxWorkTrans.SourceCurrencyCode);
            taxWorkTrans.SourceBaseAmountCurRaw = taxWorkTrans.SourceBaseAmountCurRaw * factor;

            taxWorkTrans.update(this.ignoreCalculatedSalesTax());

            savedTaxBase += taxWorkTrans.TaxBaseAmount;
            savedTaxBaseCur += taxWorkTrans.TaxBaseAmountCur;

            if (abs(taxWorkTrans.TaxBaseAmount) > abs(highestTaxBaseAmount))
            {
                highestTaxBaseAmount   = taxWorkTrans.TaxBaseAmount;
                taxWorkTransRecId      = taxWorkTrans.RecId;
            }
        }

        if (savedTaxBase != _totalTaxBaseMST)
        {
            select firstonly forupdate taxWorkTrans
                where taxWorkTrans.RecId == taxWorkTransRecId;

            if (taxWorkTrans)
            {
                if (savedTaxBase != _totalTaxBaseMST)

                {
                    // _taxBaseMST and savedTaxBase are unrounded amounts so round difference before adjusting TaxBaseAmount
                    taxWorkTrans.TaxBaseAmount  += CurrencyExchangeHelper::amount(_totalTaxBaseMST - savedTaxBase, Ledger::accountingCurrency(this.companyInfo().RecId));
                    taxWorkTrans.TaxBaseAmountCur += CurrencyExchangeHelper::amount(_totalTaxBaseCur - savedTaxBaseCur, taxTable.TaxCurrencyCode);
                }

                taxWorkTrans.update(this.ignoreCalculatedSalesTax());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateInTaxWorkTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allocates values for table <c>TmpTaxWorkTrans</c>.
    /// </summary>
    /// <param name = "_taxCode">The tax code.</param>
    /// <param name = "_taxDirection">The tax direction.</param>
    /// <param name = "_taxAmount">The tax amount.</param>
    /// <param name = "_taxAmountCur">The current tax amount.</param>
    /// <param name = "_taxInCostPrice">The tax in cost price.</param>
    /// <param name = "_taxInCostPriceMST">The tax in MST cost price.</param>
    /// <param name = "_taxInCostPriceCur">The tax in current cost price.</param>
    /// <param name = "_taxBaseAmountRaw">The raw tax base amount.</param>
    /// <param name = "_taxBaseQty">The tax base quantity.</param>
    /// <param name = "_sourceTaxAmountCur">The source current tax amount.</param>
    /// <param name = "_sourceTaxAmountCurReal">The source currenct real tax amount</param>
    /// <param name = "_adjustment">Whether to adjust.</param>
    /// <param name = "_calculationDate">The calculation date.</param>
    /// <param name = "_taxWarning">The tax warning.</param>
    /// <param name = "_fiscalValue">The tax fiscal value.</param>
    /// <param name = "_taxReceivableLongTerm">The tax receivalble term.</param>
    /// <param name = "_sourceCurrencyCode">The source currency code.</param>
    [SysObsolete('Please use allocateInTaxWorkTransWithCompany instead', false, 11\12\2018)]
    protected void allocateInTaxWorkTrans(TaxCode                   _taxCode,
                                          TaxDirection              _taxDirection,
                                          TaxAmount                 _taxAmount,
                                          TaxAmountCur              _taxAmountCur,
                                          TaxAmount                 _taxInCostPrice,
                                          TaxAmount                 _taxInCostPriceMST,
                                          TaxAmount                 _taxInCostPriceCur,
                                          TaxBase                   _taxBaseAmountRaw,
                                          TaxBase                   _taxBaseQty,
                                          TaxAmountCur              _sourceTaxAmountCur,
                                          TaxAmountCur              _sourceTaxAmountCurReal,
                                          NoYes                     _adjustment,
                                          TransDate                 _calculationDate,
                                          TaxWarning                _taxWarning,
                                         // <GBR>
                                         TaxFiscalValue_BR          _fiscalValue = TaxFiscalValue_BR::Blank,
                                         TaxReceivableLongTerm_BR   _taxReceivableLongTerm = false,
                                         // </GBR>
                                         CurrencyCode              _sourceCurrencyCode = ''
        )
    {
        this.allocateInTaxWorkTransWithCompany(_taxCode, _taxDirection, _taxAmount, _taxAmountCur, _taxInCostPrice, _taxInCostPriceMST, _taxInCostPriceCur, _taxBaseAmountRaw,
                                                _taxBaseQty, _sourceTaxAmountCur, _sourceTaxAmountCurReal, _adjustment, _calculationDate, _taxWarning, _fiscalValue, _taxReceivableLongTerm, _sourceCurrencyCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateInTaxWorkTransWithCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allocates values for table <c>TmpTaxWorkTrans</c>.
    /// </summary>
    /// <param name = "_taxCode">The tax code.</param>
    /// <param name = "_taxDirection">The tax direction.</param>
    /// <param name = "_taxAmount">The tax amount.</param>
    /// <param name = "_taxAmountCur">The current tax amount.</param>
    /// <param name = "_taxInCostPrice">The tax in cost price.</param>
    /// <param name = "_taxInCostPriceMST">The tax in MST cost price.</param>
    /// <param name = "_taxInCostPriceCur">The tax in current cost price.</param>
    /// <param name = "_taxBaseAmountRaw">The raw tax base amount.</param>
    /// <param name = "_taxBaseQty">The tax base quantity.</param>
    /// <param name = "_sourceTaxAmountCur">The source current tax amount.</param>
    /// <param name = "_sourceTaxAmountCurReal">The source currenct real tax amount</param>
    /// <param name = "_adjustment">Whether to adjust.</param>
    /// <param name = "_calculationDate">The calculation date.</param>
    /// <param name = "_taxWarning">The tax warning.</param>
    /// <param name = "_fiscalValue">The tax fiscal value.</param>
    /// <param name = "_taxReceivableLongTerm">The tax receivalble term.</param>
    /// <param name = "_sourceCurrencyCode">The source currency code.</param>
    /// <param name = "_company">The tmpTax company.</param>
    protected void allocateInTaxWorkTransWithCompany(TaxCode                   _taxCode,
                                                   TaxDirection              _taxDirection,
                                                   TaxAmount                 _taxAmount,
                                                   TaxAmountCur              _taxAmountCur,
                                                   TaxAmount                 _taxInCostPrice,
                                                   TaxAmount                 _taxInCostPriceMST,
                                                   TaxAmount                 _taxInCostPriceCur,
                                                   TaxBase                   _taxBaseAmountRaw,
                                                   TaxBase                   _taxBaseQty,
                                                   TaxAmountCur              _sourceTaxAmountCur,
                                                   TaxAmountCur              _sourceTaxAmountCurReal,
                                                   NoYes                     _adjustment,
                                                   TransDate                 _calculationDate,
                                                   TaxWarning                _taxWarning,
                                                   // <GBR>
                                                   TaxFiscalValue_BR          _fiscalValue = TaxFiscalValue_BR::Blank,
                                                   TaxReceivableLongTerm_BR   _taxReceivableLongTerm = false,
                                                   // </GBR>
                                                   CurrencyCode              _sourceCurrencyCode = '',
                                                   DataAreaId                 _company = ''
        )
    {
        TaxTable                taxTable;
        RecId                   taxWorkTransRecId;
        TaxAmount               highestTaxAmount;
        TaxAmount               savedTax;
        TaxAmountCur            savedTaxCur;
        TaxAmountCur            savedTaxRep;
        TaxAmountCur            savedSourceTaxCur;
        TaxAmountCur            savedSourceTaxCurReal;
        TaxAmount               savedTaxInCostPrice;
        TaxAmount               savedTaxInCostPriceCur;
        TaxAmount               savedTaxInCostPriceRep;
        TaxAmount               savedTaxInCostPriceMST;
        TaxAmount               taxMin;
        TaxAmount               taxMax;
        TaxAmount               taxAmount;
        TaxAmountCur            taxAmountCur;
        TaxAmountCur            taxAmountRep;
        TaxAmount               taxInCostPrice;
        TaxAmount               taxInCostPriceMST;
        TaxAmount               taxInCostPriceCur;
        TaxAmount               taxInCostPriceRep;
        TaxAmountCur            sourceTaxAmountCur;
        TaxAmountCur            sourceTaxAmountCurReal;
        RefRecId                taxWorkTransRecIdFirst;
        RealBase                factor;
        TaxLimitReached         taxLimitReached = NoYes::No;
        Currency                companyCurrency;
        Currency                taxCurrency;
        Currency                sourceCurrency;
        TaxCurrencyConversionRoutineHandler handler = TaxCurrencyConversionRoutineHandler::instance();

        taxTable            = this.getTaxTable(_taxCode);
        taxMin              = TaxCollectLimit::taxMin(_taxCode, taxDate);
        taxMax              = TaxCollectLimit::taxMax(_taxCode, taxDate);
        companyCurrency     = this.getCompanyCurrency();

        if (companyCurrency.CurrencyCode == taxTable.TaxCurrencyCode)
        {
            taxCurrency = companyCurrency;
        }
        else
        {
            taxCurrency = Currency::find(taxTable.TaxCurrencyCode);
        }

        sourceCurrency = this.getSourceCurrency(_sourceCurrencyCode);

        if (taxMax && abs(_taxAmount) > taxMax)
        {
            factor                   = taxMax / abs(_taxAmount);
            taxAmount                = companyCurrency.amount_Instance(_taxAmount * factor);
            taxAmountCur             = taxCurrency.amount_Instance(_taxAmountCur * factor);
            taxInCostPrice           = sourceCurrency.amount_Instance(_taxInCostPrice * factor);
            taxInCostPriceCur        = taxCurrency.amount_Instance(_taxInCostPriceCur * factor);
            taxInCostPriceMST        = companyCurrency.amount_Instance(_taxInCostPriceMST * factor);
            sourceTaxAmountCur       = sourceCurrency.amount_Instance(_sourceTaxAmountCur * factor);
            sourceTaxAmountCurReal   = sourceTaxAmountCur;
        }
        else if (abs(_taxAmount) >= taxMin)
        {
            taxAmount                = companyCurrency.amount_Instance(_taxAmount);
            taxAmountCur             = taxCurrency.amount_Instance(_taxAmountCur);
            taxInCostPrice           = sourceCurrency.amount_Instance(_taxInCostPrice);
            taxInCostPriceCur        = taxCurrency.amount_Instance(_taxInCostPriceCur);
            taxInCostPriceMST        = companyCurrency.amount_Instance(_taxInCostPriceMST);
            sourceTaxAmountCur       = sourceCurrency.amount_Instance(_sourceTaxAmountCur);
            sourceTaxAmountCurReal   = _sourceTaxAmountCurReal;
        }
        else
        {
            taxAmount               = 0;
            taxAmountCur            = 0;
            taxInCostPrice          = 0;
            taxInCostPriceCur       = 0;
            taxInCostPriceMST       = 0;
            sourceTaxAmountCur      = 0;
            sourceTaxAmountCurReal  = 0;
        }
        //converting reporting currency since no input parameter for reporting currency
        taxAmountRep        = handler.transCurrencyToReportingCurrency(_sourceCurrencyCode, sourceTaxAmountCur,
                                                                        reportingCurrencyExchRate, taxDate);
        taxInCostPriceRep   = handler.transCurrencyToReportingCurrency(_sourceCurrencyCode, taxInCostPrice,
                                                                        reportingCurrencyExchRate, taxDate);
        
        if ((taxMax && abs(_taxAmount) >= taxMax) ||

            (taxMin && _taxAmount && abs(_taxAmount) <= taxMin))
        {
            taxLimitReached = NoYes::Yes;
        }

        highestTaxAmount            = 0;
        savedTax                    = 0;
        savedTaxCur                 = 0;
        savedTaxRep                 = 0;
        savedTaxInCostPrice         = 0;
        savedTaxInCostPriceMST      = 0;
        savedTaxInCostPriceCur      = 0;
        savedTaxInCostPriceRep      = 0;

        while select forupdate taxWorkTrans
            where taxWorkTrans.HeadingRecId == headingRecId
                && taxWorkTrans.HeadingTableId == headingTableId
                // <GEERU>
                && (taxWorkTrans.ExemptTax == NoYes::No
                    || this.processExemptTax_RU())
                // </GEERU>
                && taxWorkTrans.TaxCode == _taxCode
                && taxWorkTrans.TaxDirection == _taxDirection
                && taxWorkTrans.CalculationDate == _calculationDate
                && taxWorkTrans.SourceCurrencyCode == _sourceCurrencyCode
                && taxWorkTrans.TaxOrigin != TaxOrigin::Transfer
                // <GBR>
                && taxWorkTrans.FiscalValue_BR == _fiscalValue
                && taxWorkTrans.TaxReceivableLongTerm_BR == _taxReceivableLongTerm
                // </GBR>
                && (_company == '' || taxWorkTrans.Company == _company)
        {
            if (!taxWorkTransRecIdFirst)
                 taxWorkTransRecIdFirst = taxWorkTrans.RecId;

            taxWorkTrans.Warning = _taxWarning;

            if (taxMin != 0 || taxMax != 0)
            {
                this.setValidateWarning(taxTable.TaxLimitBase, TaxWarning::InvalidTaxIncludedTaxCode, taxWorkTrans);
            }

            if (_adjustment == NoYes::No)
            {
                taxWorkTrans.TaxAmount              = 0;
                taxWorkTrans.TaxAmountCur           = 0;
                taxWorkTrans.TaxAmountRep           = 0;
                taxWorkTrans.SourceTaxAmountCur     = 0;
                taxWorkTrans.SourceTaxAmountCurReal = 0;
                taxWorkTrans.TaxInCostPrice         = 0;
                taxWorkTrans.TaxInCostPriceCur      = 0;
                taxWorkTrans.TaxInCostPricerep      = 0;
                taxWorkTrans.TaxInCostPriceMST      = 0;
            }

            if (taxTable.TaxBase == TaxBaseType::AmountByUnit)
            {
                if (_taxBaseQty)
                {
                    taxWorkTrans.SourceTaxAmountCur      += sourceTaxAmountCur      * (taxWorkTrans.TaxBaseQty   / _taxBaseQty);
                    taxWorkTrans.SourceTaxAmountCurReal  += sourceTaxAmountCurReal  * (taxWorkTrans.TaxBaseQty   / _taxBaseQty);
                    taxWorkTrans.TaxInCostPrice          += taxInCostPrice          * (taxWorkTrans.TaxBaseQty   / _taxBaseQty);
                    taxWorkTrans.TaxInCostPriceCur       += taxInCostPriceCur       * (taxWorkTrans.TaxBaseQty   / _taxBaseQty);
                    taxWorkTrans.TaxInCostPriceMST       += taxInCostPriceMST       * (taxWorkTrans.TaxBaseQty   / _taxBaseQty);

                    //round the tax amount
                    taxWorkTrans.SourceTaxAmountCur     = sourceCurrency.amount_Instance(taxWorkTrans.SourceTaxAmountCur);
                    taxWorkTrans.TaxAmount              += CurrencyExchangeHelper::mstAmount(taxWorkTrans.SourceTaxAmountCur, sourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), exchRate, exchRateSecond, true);
                    //Feature Sales Tax Conversion
                    if (this.isTaxCurrencyConversionFeatureEnabled())
                    {
                        taxWorkTrans.TaxAmountCur += handler.transCurrencyToTaxCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.CurrencyCode, taxWorkTrans.SourceTaxAmountCur,
                                                                                        taxWorkTrans.ExchRate, taxWorkTrans.ReportingCurrencyExchRate, taxDate);
                    }
                    else
                    {
                        if ( taxWorkTrans.CurrencyCode == accountingCurrency)
                        {
                            taxWorkTrans.TaxAmountCur += taxWorkTrans.TaxAmount;
                        }
                        else if (taxWorkTrans.CurrencyCode == taxWorkTrans.SourceCurrencyCode)
                        {
                            taxWorkTrans.TaxAmountCur += taxWorkTrans.SourceTaxAmountCur;
                        }
                        else
                        {
                            taxWorkTrans.TaxAmountCur   += CurrencyExchangeHelper::curAmount(taxWorkTrans.TaxAmount, taxWorkTrans.CurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), 0, 0, true);
                        }
                    }
                    taxWorkTrans.TaxAmountRep       += handler.transCurrencyToReportingCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.SourceTaxAmountCur,
                                                                                            taxWorkTrans.ReportingCurrencyExchRate, taxDate);
                    //reporting currency of taxInCostPrice has been rounded during conversion
                    taxWorkTrans.TaxInCostPriceRep  += handler.transCurrencyToReportingCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.taxInCostPrice,
                                                                                            taxWorkTrans.ReportingCurrencyExchRate, taxDate);

                }
            }
            else
            {
                if (_taxBaseAmountRaw)
                {
                    // <GBR>
                    if (isBrazilEnabled
                        && taxTable.TaxOnTax
                        && (taxTable.TaxSubstitution_BR == TaxSubstitutionEnum_BR::Markup
                            || taxTable.TaxSubstitution_BR == TaxSubstitutionEnum_BR::MarkupConfaz_52_2017
                            || this.isDualBase_BR(taxTable, tmpTax)))
                    {
                        taxWorkTrans.SourceBaseAmountCur          += tmpTax.SourceTaxSubstitutionAmountAddedCur_BR * taxWorkTrans.TaxBaseAmountRaw  / (_taxBaseAmountRaw - tmpTax.TaxSubstitutionAmountAddedMST_BR);
                        taxWorkTrans.SourceBaseAmountCurRaw       += tmpTax.SourceTaxSubstitutionAmountAddedCur_BR * taxWorkTrans.TaxBaseAmountRaw  / (_taxBaseAmountRaw - tmpTax.TaxSubstitutionAmountAddedMST_BR);
                        taxWorkTrans.TaxBaseAmount                += tmpTax.TaxSubstitutionAmountAddedMST_BR       * taxWorkTrans.TaxBaseAmountRaw  / (_taxBaseAmountRaw - tmpTax.TaxSubstitutionAmountAddedMST_BR);
                        taxWorkTrans.TaxBaseAmountRaw             += tmpTax.TaxSubstitutionAmountAddedMST_BR       * taxWorkTrans.TaxBaseAmountRaw  / (_taxBaseAmountRaw - tmpTax.TaxSubstitutionAmountAddedMST_BR);

                        taxWorkTrans.TaxBaseAmount                = companyCurrency.amount_Instance(taxWorkTrans.TaxBaseAmount);
                        taxWorkTrans.SourceBaseAmountCur          = sourceCurrency.amount_Instance(taxWorkTrans.SourceBaseAmountCur);
                    }
                    // </GBR>

                    if (abs(taxWorkTrans.TaxBaseAmountRaw) > abs(_taxBaseAmountRaw))
                    {
                        taxWorkTrans.SourceTaxAmountCur += sourceTaxAmountCurReal * (taxWorkTrans.TaxBaseAmountRaw / _taxBaseAmountRaw);
                    }
                    else
                    {
                        taxWorkTrans.SourceTaxAmountCur += sourceTaxAmountCur * (taxWorkTrans.TaxBaseAmountRaw / _taxBaseAmountRaw);
                    }
                    taxWorkTrans.SourceTaxAmountCurReal  += sourceTaxAmountCurReal      * (taxWorkTrans.TaxBaseAmountRaw / _taxBaseAmountRaw);
                    taxWorkTrans.TaxInCostPrice          += taxInCostPrice              * (taxWorkTrans.TaxBaseAmountRaw / _taxBaseAmountRaw);
                    taxWorkTrans.TaxInCostPriceCur       += taxInCostPriceCur           * (taxWorkTrans.TaxBaseAmountRaw / _taxBaseAmountRaw);
                    taxWorkTrans.TaxInCostPriceMST       += taxInCostPriceMST           * (taxWorkTrans.TaxBaseAmountRaw / _taxBaseAmountRaw);

                    taxWorkTrans.SourceTaxAmountCur     = sourceCurrency.amount_Instance(taxWorkTrans.SourceTaxAmountCur);
                    taxWorkTrans.TaxAmount               += CurrencyExchangeHelper::mstAmount(taxWorkTrans.SourceTaxAmountCur, sourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), exchRate, exchRateSecond, true);

                    //Feature Sales Tax Conversion
                    if (this.isTaxCurrencyConversionFeatureEnabled())
                    {
                        taxWorkTrans.TaxAmountCur += handler.transCurrencyToTaxCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.CurrencyCode, taxWorkTrans.SourceTaxAmountCur,
                                                                                        taxWorkTrans.ExchRate, taxWorkTrans.ReportingCurrencyExchRate, taxDate);
                    }
                    else
                    {
                        if ( taxWorkTrans.CurrencyCode == accountingCurrency)
                        {
                            taxWorkTrans.TaxAmountCur += taxWorkTrans.TaxAmount;
                        }
                        else if (taxWorkTrans.CurrencyCode == taxWorkTrans.SourceCurrencyCode)
                        {
                            taxWorkTrans.TaxAmountCur += taxWorkTrans.SourceTaxAmountCur;
                        }
                        else
                        {
                            taxWorkTrans.TaxAmountCur               += CurrencyExchangeHelper::curAmount(taxWorkTrans.TaxAmount, taxWorkTrans.CurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), 0, 0, true);
                        }
                    }
                    taxWorkTrans.TaxAmountRep       += handler.transCurrencyToReportingCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.SourceTaxAmountCur,
                                                                                            taxWorkTrans.ReportingCurrencyExchRate, taxDate);
                    //reporting currency of taxInCostPrice has been rounded during conversion
                    taxWorkTrans.TaxInCostPriceRep  += handler.transCurrencyToReportingCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.taxInCostPrice,
                                                                                            taxWorkTrans.ReportingCurrencyExchRate, taxDate);
                    // <GBR>
                    if (isBrazilEnabled && taxTable.TaxSubstitution_BR == TaxSubstitutionEnum_BR::SimplifiedEstimate)
                    {
                        taxWorkTrans.SourceBaseAmountCur          += tmpTax.SourceTaxSubstitutionAmountAddedCur_BR * taxWorkTrans.TaxBaseAmountRaw  / (_taxBaseAmountRaw);
                        taxWorkTrans.SourceBaseAmountCurRaw       += tmpTax.SourceTaxSubstitutionAmountAddedCur_BR * taxWorkTrans.TaxBaseAmountRaw  / (_taxBaseAmountRaw);
                        taxWorkTrans.TaxBaseAmount                += tmpTax.TaxSubstitutionAmountAddedMST_BR       * taxWorkTrans.TaxBaseAmountRaw  / (_taxBaseAmountRaw);
                        taxWorkTrans.TaxBaseAmountRaw             += tmpTax.TaxSubstitutionAmountAddedMST_BR       * taxWorkTrans.TaxBaseAmountRaw  / (_taxBaseAmountRaw);

                        taxWorkTrans.TaxBaseAmount                = companyCurrency.amount_Instance(taxWorkTrans.TaxBaseAmount);
                        taxWorkTrans.SourceBaseAmountCur          = sourceCurrency.amount_Instance(taxWorkTrans.SourceBaseAmountCur);
                    }
                    // </GBR>
                }
            }

            taxWorkTrans.TaxInCostPrice         = sourceCurrency.amount_Instance(taxWorkTrans.TaxInCostPrice);
            taxWorkTrans.TaxInCostPriceMST      = companyCurrency.amount_Instance(taxWorkTrans.TaxInCostPriceMST);
            taxWorkTrans.TaxInCostPriceCur      = taxCurrency.amount_Instance(taxWorkTrans.TaxInCostPriceCur);

            taxWorkTrans.SourceBaseAmountCurCalculated = taxWorkTrans.SourceBaseAmountCur;

            taxWorkTrans.TaxLimitReached        = taxLimitReached;
            // <GIN>
            if (isCustomsEnabled)
            {
                if (taxTable.TaxType_IN == TaxType_IN::Customs)

                {
                    if (customsDuty)
                    {
                        taxWorkTrans.CustomsDuty_IN         = customsDuty;
                    }
                    if (EximParameters_IN::checkParameters()
                        || EximParameters_IN::checkDEPBParameters()
                        || EximParameters_IN::checkEPCGParameters())
                    {
                        taxWorkTrans.EximTaxAmount_IN = eximTaxAmount;
                    }
                }
            }

            if (taxWorkTrans.Source == TaxModuleType::Project)
            {
                TaxTrans taxTrans = TaxRegulation::updateAdjustedSalesTaxAmount(taxWorkTrans);
                if (taxTrans && taxTrans.SourceBaseAmountCurRegulated)
                {
                    taxWorkTrans.SourceBaseAmountCurRegulated = taxTrans.SourceBaseAmountCurRegulated;
                }
            }

            // </GIN>
            taxWorkTrans.update(this.ignoreCalculatedSalesTax());

            savedTax                      += taxWorkTrans.TaxAmount;
            savedTaxCur                   += taxWorkTrans.TaxAmountCur;
            savedTaxRep                   += taxWorkTrans.TaxAmountRep;
            savedSourceTaxCur             += taxWorkTrans.SourceTaxAmountCur;
            savedSourceTaxCurReal         += taxWorkTrans.SourceTaxAmountCurReal;
            savedTaxInCostPrice           += taxWorkTrans.TaxInCostPrice;
            savedTaxInCostPriceMST        += taxWorkTrans.TaxInCostPriceMST;
            savedTaxInCostPriceCur        += taxWorkTrans.TaxInCostPriceCur;
            savedTaxInCostPriceRep        += taxWorkTrans.TaxInCostPriceRep;

            if (abs(taxWorkTrans.TaxAmount) > abs(highestTaxAmount))
            {
                highestTaxAmount       = taxWorkTrans.TaxAmount;
                taxWorkTransRecId      = taxWorkTrans.RecId;
            }

            // <GBR>
            if (isBrazilEnabled)
            {
                taxWorkTrans.TaxValue_BR = taxWorkTrans.showTaxValue();

                if (calculatedTaxes_BR.in(taxWorkTrans.TaxCode))
                {
                    this.applyFiscalValueInCalculatedTaxes_BR();
                }
            }
            // </GBR>
        }

        if (savedTax                    != taxAmount              ||

            savedTaxCur                 != taxAmountCur           ||
            savedTaxRep                 != taxAmountRep           ||
            savedSourceTaxCurReal       != sourceTaxAmountCurReal ||
            savedTaxInCostPrice         != taxInCostPrice         ||
            savedTaxInCostPriceMST      != taxInCostPriceMST      ||
            savedTaxInCostPriceCur      != taxInCostPriceCur      ||
            savedTaxInCostPriceRep      != taxInCostPriceRep      ||
            savedSourceTaxCur           != sourceTaxAmountCur      )
        {
            // If a tax amount must be allocated and there are no other lines with tax, use the first line
            // to place the tax on.
            if (taxAmount && !taxWorkTransRecId)
                taxWorkTransRecId = taxWorkTransRecIdFirst;

            select firstonly forupdate taxWorkTrans

                where taxWorkTrans.RecId == taxWorkTransRecId;

            if (taxWorkTrans)
            {
                if (savedTax != taxAmount)

                    taxWorkTrans.TaxAmount += taxAmount - savedTax;

                if (savedTaxCur != taxAmountCur)

                    taxWorkTrans.TaxAmountCur += taxAmountCur - savedTaxCur;

                if (savedTaxRep != taxAmountRep)

                    taxWorkTrans.TaxAmountRep += taxAmountRep - savedTaxRep;

                if (savedTaxInCostPrice != taxInCostPrice)

                    taxWorkTrans.TaxInCostPrice += taxInCostPrice - savedTaxInCostPrice;

                if (savedTaxInCostPriceMST != taxInCostPriceMST)

                    taxWorkTrans.TaxInCostPriceMST += taxInCostPriceMST - savedTaxInCostPriceMST;

                if (savedTaxInCostPriceCur != taxInCostPriceCur)

                    taxWorkTrans.TaxInCostPriceCur += taxInCostPriceCur - savedTaxInCostPriceCur;

                if (savedTaxInCostPriceRep != taxInCostPriceRep)

                    taxWorkTrans.TaxInCostPriceRep += taxInCostPriceRep - savedTaxInCostPriceRep;

                if (savedSourceTaxCur != sourceTaxAmountCur)
                {
                    if (taxWorkTrans.SourceTaxAmountCur
                        && TaxAdjustSourcebaseWhenTaxAmountAdjustedToZeroFlight::instance().isEnabled()
                        && taxWorkTrans.SourceTaxAmountCur + sourceTaxAmountCur - savedSourceTaxCur == 0)
                    {
                        isSourceTaxAmountCurAdjustToZero = true;
                    }

                    taxWorkTrans.SourceTaxAmountCur += sourceTaxAmountCur - savedSourceTaxCur;
                }

                if (savedSourceTaxCurReal != sourceTaxAmountCurReal)

                    taxWorkTrans.SourceTaxAmountCurReal += sourceTaxAmountCurReal - savedSourceTaxCurReal;

                // <GBR>
                if (isBrazilEnabled)
                {
                    this.applyFiscalValueInCalculatedTaxes_BR();
                }
                // </GBR>

                taxWorkTrans.update(this.ignoreCalculatedSalesTax());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowAdjustBaseAmountForTaxAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines whether the transaction supports adjusting the calculated base amount
    ///   when tax is included in item price and the users adjusts the tax amount.
    /// </summary>
    /// <returns>
    ///   true if adjusting the calculated base amount is supported; otherwise, false.
    /// </returns>
    public boolean allowAdjustBaseAmountForTaxAdjustment()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowPostingOfReversals</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether tax posting should post reversal records.
    /// </summary>
    /// <returns>
    ///    Always returns false.
    /// </returns>
    protected boolean allowPostingOfReversals()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowSingleLineAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines whether the transaction supports adjusting a single line.
    /// </summary>
    /// <returns>
    ///   true if adjusting a single line is supported; otherwise, false.
    /// </returns>
    public boolean allowSingleLineAdjustment()
    {
        if (TaxIntegrationAdjustment::isEnabledForTransaction(this.headingTableId(), this.headingRecId()))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountBaseForTaxOnTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets amount base for tax.
    /// </summary>
    /// <param name="_formulaDesigner">
    /// The formala designer.
    /// </param>
    /// <param name="_formula">
    /// The formula.
    /// </param>
    /// <param name="_tmpTaxLoc">
    /// The temporary tax location.
    /// </param>
    /// <param name="_taxBaseQty">
    /// The tax base quantity.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxAmountCur</c> class.
    /// </returns>
    TaxAmountCur  amountBaseForTaxOnTax_IN(FormulaDesigner_IN  _formulaDesigner,
                                           CalcExp_IN          _formula,
                                           TmpTax              _tmpTaxLoc,
                                           TaxBase             _taxBaseQty)
    {
        TaxBase             calculatedBase;
        CalcExp_IN          code;
        str                 resultStr, delimiterVal;
        real                codeNum;
        ExecutePermission   permission;
        TmpTax              tmpTaxlocal;
        Counter             position = 1, leftPosition, rightPosition;
        char                operator;
        int                 length;
        PurchStatus         purchStatus;
        SalesStatus         salesStatus;
        SalesLine           salesLine;

        switch (salesPurchJournalLineLoc.SourceTableId)
        {
            case tableNum(PurchLine):
                purchStatus = PurchLine::findRecId(salesPurchJournalLineLoc.SourceRecId).PurchStatus;
                break;
            case tableNum(SalesLine):
                salesLine = salesPurchJournalLineLoc;
                salesStatus = salesLine.SalesStatus;
                break;
        }

        if (purchStatus == PurchStatus::Invoiced
            || (salesStatus == SalesStatus::Invoiced
                && !this.isSalesLineFromExportOrder(salesLine)))
        {
            //TmpTax form should display taxes after SO-posting; during shipping bill for customs.
            return 0;
        }

        tmpTaxlocal.setTmpData(_tmpTaxLoc);
        permission = new ExecutePermission();
        permission.assert();

        length = strLen(_formulaDesigner.CalcExp1);
        while (position <= length)
        {
            codenum = 0;
            operator = subStr(_formulaDesigner.CalcExp1, position, 1);
            delimiterVal    = subStr(_formulaDesigner.CalcExp1, position+1, 1);
            leftPosition    = position+1;
            rightPosition   = strFind(_formulaDesigner.CalcExp1, delimiterVal, position + 2, length - (position+1));
            code            = subStr(_formulaDesigner.CalcExp1, leftPosition + 1, rightPosition - leftPosition - 1);

            if (delimiterVal == num2char(164))
            {
                if (isEximEPCG)
                {
                    codenum = abs(TmpTax::sumEximTaxAmountCur_IN(tmpTaxlocal, code));
                }
                else
                {
                    codenum = abs(TmpTax::sumSourceTaxAmountCur_IN(tmpTaxlocal, code, _tmpTaxLoc.IsScrapQtyLine_IN));
                }
            }
            if (delimiterVal == num2char(240) || delimiterVal == num2char(356))
            {
                codeNum = this.getChargeAmount_IN(code, delimiterVal, _taxBaseQty, _formula);
                // As all base amount excl tax are calculated by abs(), correct the sign of charge amount based on the sign of line amount.
                if (codeNum != 0)
                {
                    // For the cases that codeNum != 0, field "salesPurchJournalLineLoc.LineAmount" must have been mapped in the map.
                    if (salesPurchJournalLineLoc.SalesPurchJournalLine::getLineAmount() < 0)
                    {
                        codeNum = -1 * codeNum;
                    }
                }
            }

            if (delimiterVal != num2char(164)
                && lineQty   != 0
                && this.sourceTableId() == tableNum(InventQualityOrderTable)
                && (isVATEnabled
                    || isExciseEnabled))
            {
                codeNum = codeNum * destructiveQty / lineQty;
            }

            code        = num2str(codeNum, 1, 6, 1, 0);
            if (!(operator == '/' && str2num(code) == 0))
            {
                if (operator == '-' && str2num(code) < 0)
                {
                    code      = num2str(abs(codeNum), 1, 6, 1, 0);
                    operator  = '+';
                }

                _formula    += operator + code;
            }

            position    = rightPosition + 1;

            _formula = Tax::evaluate_IN(_formula);
        }

        resultStr = _formula;
        calculatedBase = str2num(resultStr);
        return calculatedBase;
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountExclTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates and returns the amount of exclusive tax for a journal line.
    /// </summary>
    /// <param name="_baseAmountCur">
    /// The line amount that includes taxes.
    /// </param>
    /// <param name="_rounding">
    /// A Boolean value that indicates whether the value will be rounded according to the tax round off
    /// rules; optional.
    /// </param>
    /// <param name="_calculateAmountByUnit">
    /// A Boolean value that indicates whether the "per unit" calculations will occur; optional.
    /// </param>
    /// <param name="_baseQty">
    /// The quantity on the line used for unit calculations; optional.
    /// </param>
    /// <param name="_baseUnit">
    /// The unit of quantity for the line that is used in unit calculations; optional.
    /// </param>
    /// <param name="_itemId">
    /// The item ID of the item on the line that is used for unit calculations; optional.
    /// </param>
    /// <param name="_sourceRecId">
    /// The record ID of the transaction line.
    /// </param>
    /// <param name="_sourceTableId">
    /// The table ID of the transaction line.
    /// </param>
    /// <returns>
    /// The base amount exclusive of taxes.
    /// </returns>
    /// <remarks>
    /// This method should be used when the line amount includes taxes.Values that are obtained from this
    /// method and used in tax calculations should not be rounded.
    /// </remarks>
    public TaxBase amountExclTax(AmountCur              _baseAmountCur,
                                    boolean             _rounding = true,
                                    boolean             _calculateAmountByUnit = true,
                                    TaxBase             _baseQty                = 0,
                                    UnitOfMeasureSymbol _baseUnit               = '',
                                    ItemId              _itemId                 = '',
                                    RefRecId            _sourceRecId            = 0,
                                    RefTableId          _sourceTableId          = 0)
    {
        TaxTable        taxTable;
        TaxBase         taxLimitMax;
        TaxBase         taxLimitMin;
        TaxBase         amount;
        TaxBase         startAmount;
        TaxBase         endAmount;
        TaxBase         baseCur;
        TaxBase         tmpBase;
        TaxBase         taxBaseQty;
        AmountCur       amountExclTax;

        TaxCode         taxCodes[];
        TaxAmount       deductedTax[];
        boolean         calcTax[];
        boolean         removePercent[];

        TaxBaseType     taxBaseType[];
        CurrencyCode    taxCurrencyCode[];
        boolean         taxIncludeInTax[];
        boolean         taxPackagingTax[];
        TaxCalcMode     taxCalcMode[];
        TaxCode         taxOnTax[];
        TransDate       taxRateDate[];

        TaxCollectLimit taxCollectLimit;
        TaxData         taxData;
        boolean         collectLimits;
        boolean         multiplePercentage;
        boolean         simpleBasis;
        boolean         taxRoundOff;

        Counter         counter;
        Counter         numOfTaxCodes;
        Counter         sign    = 1;
        Counter         idx;

        TaxValue        percent;
        TaxValue        percentTotal;
        TaxValue        percentLocal;

        TaxAmount       taxMax;
        TaxAmount       taxMin;
        TaxAmount       taxCalc;
        TaxAmount       totalTax;
        TaxAmountCur    totalTaxCur;
        TaxAmount       taxAmountByUnit;
        TaxAmount       taxAmountByUnitInclude;

        TaxBase         baseInclTax;
        TaxBase         baseExclTax;

        CurrencyCode    currencyCode;
        boolean         importTax;
        Currency        currencyMST;
        ;
        TaxAmount               grossTaxAmountForTaxAmountByUnit;
        TaxAmount               taxTotalWithTaxAmountByUnit;
        boolean                 hasPctPerGross;

        changecompany(this.getCompany())
        {
            currencyMST = this.getCompanyCurrency();

            if (!_baseAmountCur)
                return 0;

            if (cashDiscAmount && cashDiscPercent)
            {
                // both of these cannot be set, if they are, the amount will be used.
                cashDiscPercent = 0;
            }

            counter             = 1;
            importTax           = false;
            collectLimits       = false;
            multiplePercentage  = false;
            simpleBasis         = true;
            taxRoundOff         = false;

            InventTransId taxWorkTransId[];

            while select TaxDirection, TaxCode, InventTransId from taxWorkTrans
                where  taxWorkTrans.SourceRecId == _sourceRecId
                    && taxWorkTrans.SourceTableId == _sourceTableId
                    /* <SYS>
                    && taxWorkTrans.ExemptTax == NoYes::No
                    </SYS> */
                    // <GEERU>
                    && (   taxWorkTrans.ExemptTax == NoYes::No
                        || this.processExemptTax_RU())
                    // </GEERU>
                    && taxWorkTrans.TaxDirection != TaxDirection::UseTax
            {
                DataAreaId postCompany = taxWorkTrans.Company;
                postCompany = postCompany ? postCompany : curext();
                changecompany(postCompany)
                {
                    // <GIN>
                    if (isTaxParametersEnabled
                        && TaxTable::find(taxWorkTrans.TaxCode).TaxType_IN != TaxType_IN::None)
                    {
                        continue;
                    }
                    // </GIN>

                    taxWorkTransId[counter] = taxWorkTrans.InventTransId;

                    taxTable = this.getTaxTable(taxWorkTrans.TaxCode);
                    taxCodes[counter]        = taxWorkTrans.TaxCode;
                    taxRateDate[counter]     = taxWorkTrans.CalculationDate;
                    taxBaseType[counter]     = taxTable.TaxBase;
                    taxCurrencyCode[counter] = taxTable.TaxCurrencyCode;
                    taxIncludeInTax[counter] = taxTable.TaxIncludeInTax;
                    taxPackagingTax[counter] = taxTable.TaxPackagingTax;
                    taxCalcMode[counter]     = taxTable.TaxCalcMethod;
                    taxOnTax[counter]        = taxTable.TaxOnTax;

                    if (taxTable.TaxBase    == TaxBaseType::AmountByUnit ||
                        (taxTable.TaxBase   == TaxBaseType::PctPerTax &&
                         TaxTable::find(TaxTable::taxOnTax(taxCodes[counter])).TaxBase == TaxBaseType::AmountByUnit))
                    {
                        calcTax[counter]    = false;
                        simpleBasis         = false;
                    }
                    else
                    {
                        calcTax[counter] = true;
                        if (taxTable.TaxBase != TaxBaseType::PctPerNet &&
                            taxTable.TaxBase != TaxBaseType::PctGrosOnNet)
                            simpleBasis = false;
                    }
                    if (taxTable.TaxRoundOff != 0)
                        taxRoundOff = true;

                    taxCollectLimit = TaxCollectLimit::find(taxWorkTrans.TaxCode, taxRateDate[counter]);
                    if (taxCollectLimit &&
                        taxCollectLimit.TaxMin != 0 ||
                        taxCollectLimit.TaxMax != 0)
                        collectLimits = true;
                    select count(TaxValue) from taxData
                    where taxData.TaxCode == taxWorkTrans.TaxCode &&
                          ((taxData.TaxFromDate <= taxRateDate[counter] &&
                            taxData.TaxToDate   >= taxRateDate[counter]) ||
                            ! taxData.TaxFromDate);
                    if (taxData.TaxValue > 1)
                        multiplePercentage = true;
                    else
                    {
                        select TaxLimitMin, TaxLimitMax from taxData
                        where taxData.TaxCode == taxWorkTrans.TaxCode &&
                          ((taxData.TaxFromDate <= taxRateDate[counter] &&
                            taxData.TaxToDate   >= taxRateDate[counter]) ||
                            ! taxData.TaxFromDate);
                        if (taxData.TaxLimitMin || taxData.TaxLimitMax)
                            simpleBasis = false;
                    }

                    counter ++;
                }
            }

            if (sourceCurrencyCode!= Ledger::accountingCurrency(CompanyInfo::current()))
                endAmount = CurrencyExchangeHelper::mstAmount(_baseAmountCur - cashDiscAmount, sourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), exchRate, exchRateSecond, _rounding);
            else
                endAmount = _baseAmountCur - cashDiscAmount;

            numOfTaxCodes = counter;

            if (! collectLimits &&
                ! multiplePercentage &&
                ! taxRoundOff &&
                simpleBasis)
            {
                counter = 1;
                while (counter < numOfTaxCodes)
                {
                    if (calcTax[counter])
                    {
                        if (taxBaseType[counter] == TaxBaseType::PctGrosOnNet)
                        {
                            percentTotal  += Tax::calcPctGrosOnNet(TaxData::percent(taxCodes[counter],
                                                                                    taxRateDate[counter],
                                                                                    0));
                        }
                        else
                            percentTotal  += TaxData::percentPerTax(taxCodes[counter],
                                                              taxRateDate[counter],
                                                              0);
                    }
                    counter+= 1;
                }

                endAmount = _baseAmountCur - cashDiscAmount;

                percentTotal = percentTotal - (percentTotal * cashDiscPercent / 100);

                baseExclTax = endAmount * 100 / (100 + percentTotal);

                if (percentTotal)
                {
                    if (_rounding)
                    {
                        return this.adjustBaseAmountForTaxAmount(
                                       taxCodes[counter - 1],
                                       CurrencyExchangeHelper::amount(baseExclTax + cashDiscAmount, sourceCurrencyCode),
                                       _baseAmountCur,
                                       CurrencyExchangeHelper::amount(baseExclTax * percentTotal / 100, sourceCurrencyCode) * sign,
                                        _rounding);
                    }
                    else
                    {
                        return baseExclTax + cashDiscAmount;
                    }
                }
                else
                // <GEEU>
                {
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU))
                    {
                        return endAmount + cashDiscAmount;
                    }
                    else
                    {
                        //</GEEU>
                        return _baseAmountCur;
                        //<GEEU>
                    }
                }
                //</GEEU>
            }

            if (endAmount < 0)
                sign = -1;

            if (_calculateAmountByUnit)
            {
                counter = 1;
                while (counter < numOfTaxCodes)
                {
                    if (taxBaseType[counter] == TaxBaseType::AmountByUnit)
                    {
                        changecompany(this.getCompany())
                        {
                            if (taxPackagingTax[counter])
                                taxBaseQty = Tax::packagingQuantity(
                                                _baseQty,
                                                _baseUnit,
                                                _itemId,
                                                InventTransOrigin::findByInventTransId(taxWorkTransId[counter]).ItemInventDimId);
                            else
                                taxBaseQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_itemId,
                                                                                    InventTransOrigin::findByInventTransId(taxWorkTransId[counter]).ItemInventDimId,
                                                                                    _baseQty,
                                                                                    _baseUnit,
                                                                                    this.getTaxTable(taxCodes[counter]).TaxUnit,
                                                                                    NoYes::Yes);
                        }

                        if (taxIncludeInTax[counter])
                        {
                            if (_rounding)
                                taxAmountByUnitInclude += currencyMST.amount_Instance(taxBaseQty * TaxData::percent(taxCodes[counter],
                                                                                                         taxRateDate[counter],
                                                                                                         0));
                            else
                                taxAmountByUnitInclude += taxBaseQty * TaxData::percent(taxCodes[counter],
                                                                                        taxRateDate[counter],
                                                                                        0);
                        }
                        else
                        {
                            if (_rounding)
                                taxAmountByUnit += currencyMST.amount_Instance(taxBaseQty * TaxData::percent(taxCodes[counter],
                                                                                                  taxRateDate[counter],
                                                                                                  0));
                            else
                                taxAmountByUnit += taxBaseQty * TaxData::percent(taxCodes[counter],
                                                                                 taxRateDate[counter],
                                                                                 0);
                        }
                    }
                    else if (taxBaseType[counter] == TaxBaseType::PctPerTax)
                    {
                        taxTable = TaxTable::find(TaxTable::taxOnTax(taxCodes[counter]));

                        if (taxTable.TaxBase == TaxBaseType::AmountByUnit)
                        {
                            if (taxTable.TaxPackagingTax)
                                taxBaseQty = Tax::packagingQuantity(
                                                    _baseQty,
                                                    _baseUnit,
                                                    _itemId,
                                                    InventTransOrigin::findByInventTransId(taxWorkTransId[counter]).ItemInventDimId);
                            else
                                taxBaseQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_itemId,
                                                                                    InventTransOrigin::findByInventTransId(taxWorkTransId[counter]).ItemInventDimId,
                                                                                    _baseQty,
                                                                                    _baseUnit,
                                                                                    TaxTable::find(taxTable.TaxCode).TaxUnit,
                                                                                    NoYes::Yes);

                            if (taxTable.TaxIncludeInTax)
                            {
                                if (_rounding)
                                    taxAmountByUnitInclude += currencyMST.amount_Instance(taxBaseQty
                                                                                        * TaxData::percent(taxTable.TaxCode, taxRateDate[counter], 0)
                                                                                        * TaxData::percent(taxCodes[counter], taxRateDate[counter], 0) / 100);
                                else
                                    taxAmountByUnitInclude += taxBaseQty
                                                            * TaxData::percent(taxTable.TaxCode, taxRateDate[counter], 0)
                                                            * TaxData::percent(taxCodes[counter], taxRateDate[counter], 0) / 100;
                            }
                            else
                            {
                                if (_rounding)
                                    taxAmountByUnit += currencyMST.amount_Instance(taxBaseQty
                                                    * TaxData::percent(taxTable.TaxCode, taxRateDate[counter], 0)
                                                    * TaxData::percent(taxCodes[counter], taxRateDate[counter], 0) / 100);
                                else
                                    taxAmountByUnit += taxBaseQty
                                                    * TaxData::percent(taxTable.TaxCode, taxRateDate[counter], 0)
                                                    * TaxData::percent(taxCodes[counter], taxRateDate[counter], 0) / 100;
                            }
                        }
                    }
                    counter++;
                }

                endAmount = abs(endAmount) - abs(taxAmountByUnit);
                endAmount = endAmount * sign;
            }

            endAmount = abs(endAmount);

            taxLimitMax = 0;
            taxLimitMin = 0;
            startAmount = 0;

            while (startAmount < endAmount)
            {
                counter     = 1;
                taxCalc     = 0;
                taxLimitMax = 0;
                while (counter < numOfTaxCodes)
                {
                    if (taxCalcMode[counter] == TaxCalcMode::FullAmounts)
                    {
                        taxLimitMax = 0;
                    }
                    else
                    {
                        currencyCode = taxCurrencyCode[counter];
                        if (currencyCode != Ledger::accountingCurrency(CompanyInfo::current()))
                            baseCur     = CurrencyExchangeHelper::curAmount(taxLimitMin, currencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), exchRate, exchRateSecond, _rounding);
                        else
                            baseCur     = taxLimitMin;

                        baseCur += 1;
                        if (TaxData::existAmountInterval(taxCodes[counter],
                                                         taxRateDate[counter],
                                                         baseCur))
                        {
                            amount= TaxData::limitAmountMax(taxCodes[counter],
                                                            taxRateDate[counter],
                                                            taxLimitMin + 1,
                                                            _rounding);

                            if (amount != 0 && amount < endAmount)
                                taxLimitMax   = amount;
                            else
                                taxLimitMax = endAmount;
                        }
                    }

                    taxCalc      += deductedTax[counter];
                    counter++;
                }

                counter         = 1;
                percentTotal    = 0;

                if (taxLimitMax   > 0)
                    tmpBase = taxLimitMax;
                else
                    tmpBase = endAmount;

                while (counter < numOfTaxCodes)
                {
                    if (calcTax[counter])
                    {
                        if (taxBaseType[counter] == TaxBaseType::PctPerGross &&
                            !taxOnTax[counter])
                        {
                            percentLocal = 0;
                            for (idx = 1; idx < numOfTaxCodes; idx++)
                            {
                                if (idx != counter && taxBaseType[idx] != TaxBaseType::AmountByUnit)
                                    percentLocal += TaxData::percentPerTax(taxCodes[idx],
                                                               taxRateDate[counter],
                                                               tmpBase);
                            }
                            percentLocal = percentLocal * TaxData::percentPerTax(taxCodes[counter],
                                                               taxRateDate[counter],
                                                               tmpBase) / 100;
                            percentTotal += percentLocal;
                        }
                        if (taxBaseType[counter] == TaxBaseType::PctGrosOnNet)
                        {
                            percentTotal  += Tax::calcPctGrosOnNet(TaxData::percent(taxCodes[counter],
                                                                                    taxRateDate[counter],
                                                                                    tmpBase));
                        }
                        else
                            percentTotal  += TaxData::percentPerTax(taxCodes[counter],
                                                              taxRateDate[counter],
                                                              tmpBase);
                    }
                    counter++;
                }

                percentTotal = percentTotal - (percentTotal * cashDiscPercent / 100);

                if (taxLimitMax == 0)
                {
                    counter = 1;
                    while (counter < numOfTaxCodes)
                    {
                        if (calcTax[counter])
                        {
                            taxMax  = TaxCollectLimit::taxMax(taxCodes[counter],
                                                              taxRateDate[counter],
                                                              _rounding);

                            baseInclTax = endAmount - taxLimitMin - taxCalc;
                            baseExclTax = baseInclTax * 100 / (100 + percentTotal);

                            if (taxMax)
                            {
                                tmpBase = endAmount;

                                percentLocal = 0;
                                if (taxBaseType[counter] == TaxBaseType::PctPerGross &&
                                    !taxOnTax[counter])
                                {
                                    percentLocal = 0;
                                    for (idx = 1; idx < numOfTaxCodes; idx++)
                                    {
                                        if (idx != counter && taxBaseType[idx] != TaxBaseType::AmountByUnit)
                                            percentLocal += TaxData::percentPerTax(taxCodes[idx],
                                                                             taxRateDate[counter],
                                                                             tmpBase);
                                    }
                                    percentLocal = percentLocal * TaxData::percentPerTax(taxCodes[counter],
                                                                                   taxRateDate[counter],
                                                                                   tmpBase) / 100;
                                }
                                if (taxBaseType[counter] == TaxBaseType::PctGrosOnNet)
                                {
                                    percent = percentLocal + Tax::calcPctGrosOnNet(TaxData::percent(taxCodes[counter],
                                                                                                    taxRateDate[counter],
                                                                                                    tmpBase));
                                }
                                else
                                    percent = percentLocal + TaxData::percentPerTax(taxCodes[counter],
                                                                              taxRateDate[counter],
                                                                              tmpBase);

                                percent = percent - (percent * cashDiscPercent / 100);

                                if ((deductedTax[counter] + baseExclTax * percent / 100) > taxMax)
                                {
                                    deductedTax[counter] = taxMax;
                                    removePercent[counter] = true;
                                }
                            }
                        }
                        counter++;
                    }

                    counter = 1;
                    taxCalc = 0;
                    while (counter < numOfTaxCodes)
                    {
                        if (removePercent[counter] && calcTax[counter])
                        {
                            tmpBase = endAmount;

                            if (taxBaseType[counter] == TaxBaseType::PctPerGross &&
                                !taxOnTax[counter])
                            {
                                percentLocal = 0;
                                for (idx = 1; idx < numOfTaxCodes; idx++)
                                {
                                    if (idx != counter && taxBaseType[idx] != TaxBaseType::AmountByUnit)
                                        percentLocal += TaxData::percentPerTax(taxCodes[idx],
                                                                         taxRateDate[counter],
                                                                         tmpBase);
                                }
                                percentLocal = percentLocal * TaxData::percentPerTax(taxCodes[counter],
                                                               taxRateDate[counter],
                                                               tmpBase) / 100;
                                percentTotal -= percentLocal;
                            }
                            if (taxBaseType[counter] == TaxBaseType::PctGrosOnNet)
                            {
                                percentTotal  -= Tax::calcPctGrosOnNet(TaxData::percent(taxCodes[counter],
                                                                                        taxRateDate[counter],
                                                                                        tmpBase));
                            }
                            else
                                percentTotal  -= TaxData::percentPerTax(taxCodes[counter],
                                                                  taxRateDate[counter],
                                                                  tmpBase);
                            calcTax[counter] = false;
                        }
                        taxCalc += deductedTax[counter];

                        counter++;
                    }
                }

                totalTax    = 0;
                counter     = 1;
                while (counter < numOfTaxCodes)
                {
                    if (calcTax[counter])
                    {
                        if (taxLimitMax   > 0)
                            tmpBase = taxLimitMax;
                        else
                            tmpBase = endAmount;

                        percentLocal = 0;
                        if (taxBaseType[counter] == TaxBaseType::PctPerGross &&
                            !taxOnTax[counter])
                        {
                            for (idx = 1; idx < numOfTaxCodes; idx++)
                            {
                                if (idx != counter && taxBaseType[idx] != TaxBaseType::AmountByUnit)
                                    percentLocal += TaxData::percentPerTax(taxCodes[idx],
                                                               taxRateDate[counter],
                                                               tmpBase);
                            }
                            percentLocal = percentLocal * TaxData::percentPerTax(taxCodes[counter],
                                                               taxRateDate[counter],
                                                               tmpBase) / 100;
                        }
                        if (taxBaseType[counter] == TaxBaseType::PctGrosOnNet)
                        {
                            percent = percentLocal  + Tax::calcPctGrosOnNet(TaxData::percent(taxCodes[counter],
                                                                                             taxRateDate[counter],
                                                                                             tmpBase));
                        }
                        else
                            percent = percentLocal + TaxData::percentPerTax(taxCodes[counter],
                                                                      taxRateDate[counter],
                                                                      tmpBase);

                        percent = percent - (percent * cashDiscPercent / 100);

                        if (taxLimitMax > 0 && taxLimitMax < endAmount)
                            deductedTax[counter] += (taxLimitMax   - taxLimitMin) * percent / 100;
                        else
                        {
                            // if there is tax amount by unit, we should add this back to the base amount since it should be taken for gross amount calculation
                            if (taxAmountByUnit && taxBaseType[counter] == TaxBaseType::PctPerGross && !taxOnTax[counter])
                            {
                                baseInclTax      = abs(endAmount) - abs(taxLimitMin) - abs(taxCalc) + abs(taxAmountByUnit);
                                baseInclTax      = baseInclTax * sign;
                                // here we need to calculate gross tax amount for tax per unit part
                                grossTaxAmountForTaxAmountByUnit += taxAmountByUnit * (percentTotal) / 100;
                                hasPctPerGross   = true;
                            }
                            else
                            {
                                baseInclTax      = endAmount - taxLimitMin - taxCalc;
                            }

                            baseExclTax      = baseInclTax  * 100 / (100 + percentTotal);
                            deductedTax[counter] += baseExclTax * percent / 100;
                            deductedTax[counter] = this.getTaxTable(taxCodes[counter]).roundedOffTax(deductedTax[counter], _rounding);
                        }

                        taxMin  = TaxCollectLimit::taxMin(taxCodes[counter], taxRateDate[counter], _rounding);
                        if (collectLimits && deductedTax[counter] < taxMin)
                        {
                            // redo this loop but this time don't consider this tax code that is below the min.
                            calcTax[counter] = false;
                            counter = 1;
                            totalTax = 0;
                            deductedTax[0] = 0;
                            percentTotal -= percent;
                            continue;
                        }
                        else
                        {
                            taxMax  = TaxCollectLimit::taxMax(taxCodes[counter],
                                                                taxRateDate[counter],
                                                                _rounding);

                            if ((taxMax > 0) && (deductedTax[counter] > taxMax))
                            {
                                deductedTax[counter] = taxMax;
                            }
                        }
                    }

                    totalTax += deductedTax[counter];
                    counter++;
                }

                if (taxLimitMax > 0)
                {
                    taxLimitMin = taxLimitMax;
                    startAmount = taxLimitMin + totalTax;
                }
                else
                    startAmount = endAmount;
            }

            if (percentTotal < 0)
            {
                totalTax = totalTax - abs(taxAmountByUnitInclude);
            }
            else
            {
                totalTax = abs(totalTax) - abs(taxAmountByUnitInclude);
            }

            cashDiscAmount = abs(cashDiscAmount);

            if (sourceCurrencyCode != Ledger::accountingCurrency(CompanyInfo::current()))
            {
                totalTaxCur = CurrencyExchangeHelper::curAmount(totalTax, sourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), exchRate, exchRateSecond, _rounding);
                if (totalTaxCur)
                {
                    amountExclTax = (CurrencyExchangeHelper::curAmount((endAmount - totalTax + cashDiscAmount) * sign, sourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), exchRate, exchRateSecond, _rounding));
                }
                else
                {
                    amountExclTax = (_baseAmountCur - cashDiscAmount);
                }
            }
            else
            {
                totalTaxCur = totalTax;
                if (currencyMST.amount_Instance(totalTax) && _rounding)
                {
                    amountExclTax = ((endAmount - currencyMST.amount_Instance(totalTax + cashDiscAmount)) * sign);
                }
                else if (!_rounding)
                {
                    amountExclTax = (endAmount - totalTax + cashDiscAmount) * sign;
                }
                else
                {
                    amountExclTax = endAmount * sign;
                }
            }

            // need to pass total tax amount and gross tax amount for tax per unit part, and tax per unit amount
            if (taxAmountByUnit && hasPctPerGross)
            {
                taxTotalWithTaxAmountByUnit = totalTax;
                grossUnitTaxAmounts = [sign * taxTotalWithTaxAmountByUnit, grossTaxAmountForTaxAmountByUnit, taxAmountByUnit];
                totalTax = abs(totalTax) + abs(taxAmountByUnit);
                totalTaxCur = CurrencyExchangeHelper::curAmount(totalTax,
                            sourceCurrencyCode,
                            taxDate,
                            Currency::noYes2UnknownNoYes(triangulation),
                            exchRate,
                            exchRateSecond,
                            _rounding);
            }

            if (_rounding)
            {
                return this.adjustBaseAmountForTaxAmount(taxCodes[counter - 1], CurrencyExchangeHelper::amount(_baseAmountCur - totalTaxCur + cashDiscAmount, sourceCurrencyCode), _baseAmountCur, totalTaxCur * sign, _rounding);
            }
            else
            {
                return amountExclTax;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGrossUnitTaxAmounts</Name>
				<Source><![CDATA[
    public container getGrossUnitTaxAmounts()
    {
        return this.grossUnitTaxAmounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyExemptFiscalValue_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Applies Exempt Fiscal Value and tax base amount in <c>TaxWorkTrans</c>.
    /// </summary>
    /// <param name="_taxTable">
    ///  A <c>TaxTable</c> record with field TaxType_BR filled.
    /// </param>
    /// <param name="_baseAmount">
    ///  The tax base amount.
    /// </param>
    protected void applyExemptFiscalValue_BR(TaxTable _taxTable, TaxBase _baseAmount)
    {
        switch (taxModuleType)
        {
            case TaxModuleType::Sales,
                    TaxModuleType::SalesInvoice,

                 TaxModuleType::CustInterestNote,
                 TaxModuleType::CustCollectionLetter,
                 TaxModuleType::Project,
                 TaxModuleType::ProjectInvoice,
                 TaxModuleType::FreeTxtInvoice :

                if (taxWorkTrans.ExemptTax == NoYes::Yes)
                {
                    taxWorkTrans.TaxDirection = TaxDirection::TaxExemptSales;
                }
                break;

            case TaxModuleType::Purch,
                    TaxModuleType::PurchInvoice  :

                if (taxWorkTrans.TaxDirection == TaxDirection::UseTax && taxWorkTrans.FiscalValue_BR == TaxFiscalValue_BR::WithoutCreditDebitExempt)
                {
                    taxWorkTrans.ExemptTax = true;
                }

                if (taxWorkTrans.ExemptTax == NoYes::Yes)
                {
                    taxWorkTrans.TaxDirection = TaxDirection::TaxExemptPurchase;
                }
                break;
        }

        switch (_taxTable.TaxType_BR)
        {
            case TaxType_BR::ICMS :
            case TaxType_BR::IPI  :

                switch (taxWorkTrans.FiscalValue_BR)
                {
                    case TaxFiscalValue_BR::WithoutCreditDebitExempt :
                            if (taxWorkTrans.TaxReductionPct_BR !=0)
                        {
                            taxWorkTrans.SourceExemptBaseAmount_BR = taxWorkTrans.TaxBaseAmountOrig;
                        }
                        else
                        {
                            taxWorkTrans.SourceExemptBaseAmount_BR = _baseAmount;
                        }
                        break;
                }
                break;

            default :
                switch (taxWorkTrans.FiscalValue_BR)
                {
                    case TaxFiscalValue_BR::WithoutCreditDebitExempt :
                        taxWorkTrans.SourceExemptBaseAmount_BR = _baseAmount;
                        break;
                }
        }

        taxWorkTrans.SourceExemptBaseAmountMST_BR   = CurrencyExchangeHelper::amountCur2MST(taxWorkTrans.SourceExemptBaseAmount_BR, taxWorkTrans.SourceCurrencyCode, exchRate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyFiscalValueInCalculatedTaxes_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies Fiscal value requirement to the current <c>tmpTaxWorkTrans</c>
    /// </summary>
    /// <remarks>
    /// General Fiscal Value usage:
    /// <list type="number">
    /// <item>
    ///     <description>
    ///         WithCreditDebit - tax is full taxable, tax base and calculated amount will be used as standard.
    ///         When TaxReductionPct is different from zero, meaning a fraction of the base amount is exempt, the exempted amount is filled in SourceExemptBaseAmount_BR.
    ///     </description>
    /// </item>
    /// <item>
    ///     <description>
    ///         WithoutCreditDebitExempt - tax is exempt, the base amount and calculated amount will be filled in SourceExemptBaseAmount_BR and SourceExemptTaxAmount_BR.
    ///     </description>
    /// </item>
    /// <item>
    ///     <description>
    ///         WithoutCreditDebitOther - tax is exempt/suspended by other reasons, the base amount and calculated amount will be filled in SourceOtherBaseAmount_BR and SourceOtherBaseTaxAmount_BR.
    ///     </description>
    /// </item>
    /// </list>
    /// </remarks>
    protected void applyFiscalValueInCalculatedTaxes_BR()
    {
        TaxTable        taxTable;

        void clearTaxAmountFields()

        {
            taxWorkTrans.TaxBaseAmount       = 0;
            taxWorkTrans.TaxAmount           = 0;
            taxWorkTrans.SourceBaseAmountCur = 0;
            taxWorkTrans.SourceTaxAmountCur  = 0;
            taxWorkTrans.TaxAmountCur        = 0;
            taxWorkTrans.TaxAmountRep        = 0;
            taxWorkTrans.TaxBaseAmountCur    = 0;
            taxWorkTrans.TaxBaseAmountRep    = 0;
        }

        taxTable = TaxTable::find(taxWorkTrans.TaxCode);

        switch (taxTable.TaxType_BR)
        {
            case TaxType_BR::ICMS :
            case TaxType_BR::ICMSST :
            case TaxType_BR::IPI  :

                switch (taxWorkTrans.FiscalValue_BR)
                {
                    case TaxFiscalValue_BR::WithCreditDebit :
                            if (taxWorkTrans.TaxReductionPct_BR != 0)
                        {
                            taxWorkTrans.SourceExemptBaseAmount_BR = abs(taxWorkTrans.TaxBaseAmountOrig - taxWorkTrans.SourceBaseAmountCur) * sign(taxWorkTrans.SourceBaseAmountCur);
                        }
                        break;

                    case TaxFiscalValue_BR::WithoutCreditDebitOther :
                        this.calculateWithoutCreditDebitOther();

                        if (this.canClearTaxAmountFields_BR())
                        {
                            clearTaxAmountFields();
                        }
                        break;
                }
                break;

            default :
                switch (taxWorkTrans.FiscalValue_BR)
                {
                    case TaxFiscalValue_BR::WithoutCreditDebitOther :
                        taxWorkTrans.SourceOtherBaseAmount_BR = taxWorkTrans.SourceBaseAmountCur;
                        taxWorkTrans.SourceOtherBaseTaxAmount_BR = taxWorkTrans.SourceTaxAmountCur;

                        taxWorkTrans.SourceOtherBaseAmountMST_BR = taxWorkTrans.TaxBaseAmount;
                        taxWorkTrans.SourceOtherTaxAmountMST_BR = taxWorkTrans.TaxAmount;

                        if (this.canClearTaxAmountFields_BR())
                        {
                            clearTaxAmountFields();
                        }

                        break;

                    case TaxFiscalValue_BR::WithCreditDebit :

                        taxWorkTrans.SourceOtherTaxAmountMST_BR = taxWorkTrans.TaxInCostPriceMST;

                        break;
                }
        }

        taxWorkTrans.SourceExemptBaseAmountMST_BR   = CurrencyExchangeHelper::amountCur2MST(taxWorkTrans.SourceExemptBaseAmount_BR, taxWorkTrans.SourceCurrencyCode, exchRate);

        taxWorkTrans.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>beforeAddTrans_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Method should be called bore adding transaction to voucher
    /// </summary>
    /// <param name="_trans">
    /// LedgerVoucherTransObject
    /// </param>
    protected void beforeAddTrans_W(LedgerVoucherTransObject _trans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildTaxModel_IN</Name>
				<Source><![CDATA[
    private TaxModelTaxable_IN buildTaxModel_IN(
        SalesPurchJournalLine _documentMap,
        boolean _isScrap)
    {
        TaxModelTaxable_IN ret;

        if (_isScrap)

        {
            ret = TaxModelDocLineFactory::newTaxModelDocLineScrap(_documentMap);
        }
        else
        {
            ret = TaxModelDocLineFactory::newTaxModelDocLine(_documentMap);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcBaseAmtExclTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates base amount excl tax.
    /// </summary>
    /// <param name="_baseAmount">
    /// The base amount.
    /// </param>
    /// <param name="_calculationDate">
    /// The calculation date.
    /// </param>
    /// <param name="_taxBaseQty">
    /// The tax base quantity.
    /// </param>
    /// <remarks>
    /// 1. If there are more than one kind of tax basis (not include Excl. line), only one of them is considered as including all these taxes.
    /// 2. The rule to determine which tax basis includes all these taxes is:
    ///    a. If there is one tax basis (Price incl. tax is marked) is MRP, then it is MRP
    ///    b. Otherwise, it is Line amount.
    ///    c. Assessable value is never to be considered to include tax.
    /// 3. For other tax basis, directly use its value to calculate the tax, no need to do backward calculation.
    ///    It means we only do backward calculation on MRP or Line amount, and never on both.
    /// </remarks>
    public void calcBaseAmtExclTax_IN(
        TaxBaseCur      _baseAmount,
        TransDate       _calculationDate,
        TaxBase         _taxBaseQty)
    {
        FormulaDesigner_IN      formulaDesigner;
        str                     taxCodeValue, delimiterVal;
        char                    operator;
        real                    taxVal, amtPerUnit, amtPerUnitVal;
        CalcExp_IN              formula, code;
        Counter                 position = 1, leftPosition, rightPosition;
        ExecutePermission       permission;
        TaxBase                 baseMRP, baseAccessable, baseLine;
        int                     length;
        TaxValue                taxValueLoc;
        TaxGroupData            taxGroupLoc;
        real                    cashDiscPercentLoc;
        CashDiscCode            cashDiscCode;
        VendInvoiceInfoLine     vendInvoiceInfoLineCreditNote;
        PurchLine               purchlineCreditNote;
        Percent                 ratio;
        TaxableBasis_IN         taxableBasis;
        TaxAmount               staticTaxAmount;
        str                     taxCodeAmount;
        CalcExp_IN              formulaForAmount;
        CalcExp_IN              codeForAmount;
        real                    taxValueSum         = 0.0;
        real                    staticTaxAmountSum  = 0.0;
        real                    amtPerUnitSum       = 0.0;
        Percent                 abatmentPercentLoc;
        VendInvoiceInfoLine     vendInvoiceInfoLine;

        permission = new ExecutePermission();
        permission.assert();

        if (salesPurchJournalLineLoc.SourceTableId != tableNum(MarkupTrans))
        {
            ratio = this.getRatioAmount_IN(salesPurchJournalLineLoc);
            if (maximumRetailPrice != 0)
            {
                baseMRP  = _taxBaseQty * maximumRetailPrice;
            }
            else
            {
                if (_taxBaseQty != 0)
                {
                    if (ratio)
                    {
                        baseMRP =  salesPurchJournalLineLoc.SalesPurchJournalLine::parmMaximumRetailPrice() * ratio * _taxBaseQty ;
                    }
                    else
                    {
                        baseMRP =  salesPurchJournalLineLoc.SalesPurchJournalLine::parmMaximumRetailPrice() * _taxBaseQty ;
                    }
                }
                else
                {
                    if (ratio)
                    {
                        baseMRP = salesPurchJournalLineLoc.SalesPurchJournalLine::parmMaximumRetailPrice() * ratio;
                    }
                    else
                    {
                        baseMRP = salesPurchJournalLineLoc.SalesPurchJournalLine::parmMaximumRetailPrice();
                    }
                }
                if (classIdGet(this) == classNum(TaxFreeInvoice) || classIdGet(this) == classNum(TaxFreeInvoice_Invoice))
                {
                    baseMRP = salesPurchJournalLineLoc.SalesPurchJournalLine::parmMaximumRetailPrice();
                }
            }
            baseMRP = sign(_baseAmount) * abs(baseMRP);

            if (assessableValue != 0)
            {
                baseAccessable  = assessableValue;
            }
            else
            {
                // AssessableValue field for VendInvoiceInfoLine table is present in the VendInvoiceInfoLine_W table.
                if (salesPurchJournalLineLoc.SourceTableId == tableNum(VendInvoiceInfoLine))
                {
                    vendInvoiceInfoLine = VendInvoiceInfoLine::findRecId(salesPurchJournalLineLoc.SourceRecId);
                    if (ratio)
                    {
                        baseAccessable = vendInvoiceInfoLine.vendInvoiceInfoLine_W().AssessableValue_IN * ratio;
                    }
                    else
                    {
                        baseAccessable = vendInvoiceInfoLine.vendInvoiceInfoLine_W().AssessableValue_IN;
                    }
                }
                else
                {
                    if (ratio)
                    {
                        baseAccessable = salesPurchJournalLineLoc.SalesPurchJournalLine::getSalesPurchJournalLineExtension_IN().AssessableValue * ratio;
                    }
                    else
                    {
                        baseAccessable = salesPurchJournalLineLoc.SalesPurchJournalLine::getSalesPurchJournalLineExtension_IN().AssessableValue;
                    }
                }
            }
            // The sign of the accessable value should be updated based on the sign of _taxBaseQty like other base amount.
            baseAccessable = sign(_baseAmount) * abs(baseAccessable);

            if (lineQty != 0
                && this.sourceTableId() == tableNum(InventQualityOrderTable)
                && (isVATEnabled
                    || isExciseEnabled))
            {
                baseAccessable = salesPurchJournalLineLoc.SalesPurchJournalLine::getSalesPurchJournalLineExtension_IN().AssessableValue * destructiveQty / lineQty;
            }
        }

        baseLine = _baseAmount;
        if (salesPurchJournalLineLoc.SourceTableId == tableNum(VendInvoiceInfoLine))
        {
            vendInvoiceInfoLineCreditNote = salesPurchJournalLineLoc;
            purchlineCreditNote           = vendInvoiceInfoLineCreditNote.purchLine();
        }

        TaxItemGroup            taxItemGroup;
        TaxGroup                taxGroup;

        if (salesPurchJournalLineLoc.SourceTableId == tableNum(InventTransferLine))
        {
            InventtransferLine_IN inventtransferLine_IN = inventtransferLine_IN::findByinventTransferLine(salesPurchJournalLineLoc.SourceRecId);
            taxItemGroup = inventtransferLine_IN.TaxItemGroup;
            taxGroup = inventtransferLine_IN.TaxGroup;
        }
        else
        {
            taxItemGroup = salesPurchJournalLineLoc.TaxItemGroup;
            taxGroup = salesPurchJournalLineLoc.TaxGroup;
        }

        // No matter there are mixed tax basis (Line/ASSESS/MRP) or not, only one of them is considered to be included all taxes that are marked as "Price incl. tax".
        // That means only need to do backward calculation on one tax basis.
        taxableBasis = FormulaDesigner_IN::determinTaxableBasisForPriceIncl_IN(taxItemGroup);

        while select TaxCode, CalcExp1, TaxableBasis, PriceInclTax
            from formulaDesigner order by id asc
            where formulaDesigner.TaxItemGroup == taxItemGroup
        {
            amtPerUnit      = 0;
            taxCodeValue    = '';
            taxCodeAmount   = '';
            taxGroupLoc = TaxGroupData::find(taxGroup, formulaDesigner.TaxCode);
            if (taxGroupLoc && !taxGroupLoc.ExemptTax)
            {
                formula = "0.000000";
                formulaForAmount = '0.000000';
                amtPerUnit = 0;
                length = strLen(formulaDesigner.CalcExp1);
                while (position <= length)
                {
                    operator = subStr(formulaDesigner.CalcExp1, position, 1);
                    delimiterVal = subStr(formulaDesigner.CalcExp1, position+1, 1);
                    leftPosition = position+1;
                    rightPosition   = strFind(formulaDesigner.CalcExp1, delimiterVal, position + 2, length - (position+1));
                    code            = subStr(formulaDesigner.CalcExp1, leftPosition + 1, rightPosition - leftPosition - 1);
                    if (delimiterVal == num2char(164))
                    {
                        select tmpTaxCalc_IN where
                            tmpTaxCalc_IN.TaxCode       == code &&
                            tmpTaxCalc_IN.SourceTableID == this.sourceTableId() &&
                            tmpTaxCalc_IN.SourceRecID   == this.sourceRecId();

                        code            = num2str(abs(tmpTaxCalc_IN.TaxValue), 1, 6, 1, 0);
                        codeForAmount   = num2str(tmpTaxCalc_IN.StaticTaxAmount, 1, 6, 1, 0);

                        if (operator == '-')
                            amtPerUnit -= tmpTaxCalc_IN.AmtPerUnitVal;
                        else
                            amtPerUnit += tmpTaxCalc_IN.AmtPerUnitVal;
                    }
                    else if (delimiterVal == num2char(240) || delimiterVal == num2char(356))
                    {
                        if (delimiterVal == num2char(240))
                        {
                            // AP
                            codeForAmount = num2str(this.getChargeAmount_IN(code, delimiterVal, _taxBaseQty), 1, 6, 1, 0);
                        }
                        else
                        {
                            // AR
                            // Update the sign of charge amount for AR as the sign of base amount is reversed.
                            codeForAmount = num2str(-1 * this.getChargeAmount_IN(code, delimiterVal, _taxBaseQty), 1, 6, 1, 0);
                        }

                        code = num2str(00, 1, 6, 1, 0);
                    }
                    if (!(operator == '/' && str2num(code) == 0))
                    {
                        formula             += operator + code;
                        formulaForAmount    += operator + '(' + codeForAmount + ')';
                    }
                    taxCodeValue        = Tax::evaluate_IN(formula);
                    formula             = taxCodeValue;
                    taxCodeAmount       = Tax::evaluate_IN(formulaForAmount);
                    formulaForAmount    = taxCodeAmount;
                    position            = rightPosition + 1;
                }
                position = 1;

                if (((salesPurchJournalLineLoc.SourceTableId == tableNum(PurchLine) || salesPurchJournalLineLoc.SourceTableId == tableNum(SalesLine)) &&
                      salesPurchJournalLineLoc.SalesPurchJournalLine::getSalesPurchJournalLineExtension_IN().TaxAsPerOriginalInvoice)
                            ||
                    (salesPurchJournalLineLoc.SourceTableId == tableNum(VendInvoiceInfoLine) &&
                     purchlineCreditNote.RecId != 0 &&
                     purchlineCreditNote.purchLine_IN().TaxAsPerOriginalInvoice == true))
                {
                    taxValueLoc = Tax::determineTaxValue_IN(formulaDesigner.TaxCode,
                                                            salesPurchJournalLineLoc);
                }
                else
                {
                    taxValueLoc = Tax::getTaxValue_IN(_calculationDate,
                                                   formulaDesigner.TaxCode,
                                                   _baseAmount,
                                                   salesPurchJournalLineLoc);
                }

                if (TaxTable::find(formulaDesigner.TaxCode).TaxBase == TaxBaseType::AmountByUnit)
                {
                    taxVal = 0;
                    staticTaxAmount = 0;
                    amtPerUnitVal = abs(_taxBaseQty * taxValueLoc);
                }
                else
                {
                    if (formulaDesigner.TaxableBasis == taxableBasis)
                    {
                        taxVal              = ((1 + str2num(taxCodeValue)) * taxValueLoc)/100;
                        staticTaxAmount     = str2num(taxCodeAmount) * taxValueLoc / 100;
                    }
                    else
                    {
                        taxVal      = ((str2num(taxCodeValue)) * taxValueLoc)/100;
                        switch (formulaDesigner.TaxableBasis)
                        {
                            case TaxableBasis_IN::LineAmount:
                                staticTaxAmount = baseLine * taxValueLoc / 100 + str2num(taxCodeAmount) * taxValueLoc / 100;
                                break;

                            case TaxableBasis_IN::ExclAmount:
                                staticTaxAmount = str2num(taxCodeAmount) * taxValueLoc / 100;
                                break;

                            case TaxableBasis_IN::Assessable:
                                staticTaxAmount = baseAccessable * taxValueLoc / 100 + str2num(taxCodeAmount) * taxValueLoc / 100;
                                break;

                            case TaxableBasis_IN::MRP:
                                staticTaxAmount = baseMRP * taxValueLoc / 100 + str2num(taxCodeAmount) * taxValueLoc / 100;
                                break;
                        }
                    }

                    amtPerUnitVal = amtPerUnit * taxValueLoc / 100;
                }

                if (formulaDesigner.PriceInclTax == NoYes::Yes)
                {
                    abatmentPercentLoc = TaxOnItem::find(taxItemGroup, formulaDesigner.TaxCode).AbatementPercent_IN;
                    if (abatmentPercentLoc)
                    {
                        taxVal          = taxVal * (100 - abatmentPercentLoc) / 100;
                        staticTaxAmount = staticTaxAmount * (100 - abatmentPercentLoc) / 100;
                        amtPerUnitVal   = amtPerUnitVal * (100 - abatmentPercentLoc) / 100;
                    }

                    // As there is only one taxable basis includes all taxes that are marked as "Price incl. tax", directly summarize below values which will be used
                    // for backward calculation.
                    taxValueSum         += taxVal;
                    staticTaxAmountSum  += staticTaxAmount;
                    amtPerUnitSum       += amtPerUnitVal;
                }
                select tmpTaxCalc_IN;

                // This new record means: the tax amount of the specified tax code = taxVal * original amount of taxableBasis + staticTaxAmount + amtPerUnitVal
                // Note: "taxableBasis" in above line is the method varable "taxableBasis", not the current formulaDesigner.TaxableBasis
                tmpTaxCalc_IN.TaxCode           = formulaDesigner.TaxCode;
                tmpTaxCalc_IN.TaxValue          = taxVal;
                tmpTaxCalc_IN.StaticTaxAmount   = staticTaxAmount;
                tmpTaxCalc_IN.AmtPerUnitVal     = amtPerUnitVal;
                tmpTaxCalc_IN.SourceTableID     = this.sourceTableId();
                tmpTaxCalc_IN.SourceRecID       = this.sourceRecId();
                tmpTaxCalc_IN.insert();
            }
        }
        if (TaxParameters::find().TaxLessCashDisc)
        {
            switch (salesPurchJournalLineLoc.SourceTableId)
            {
                case tableNum(PurchLine):
                    cashDiscPercentLoc = PurchLine::findRecId(salesPurchJournalLineLoc.SourceRecId).purchTable().CashDiscPercent;
                    break;
                case tableNum(SalesLine):
                    cashDiscPercentLoc = SalesLine::findRecId(salesPurchJournalLineLoc.SourceRecId).salesTable().CashDiscPercent;
                    break;
                case tableNum(CustInvoiceLine):
                    cashDiscCode    = CustInvoiceLine::find(salesPurchJournalLineLoc.SourceRecId).custInvoiceTable().CashDiscCode;
                    cashDiscPercentLoc = CashDisc::find(cashDiscCode).Percent;
                    break;
                case tableNum(LedgerJournalTrans):
                    if (!LedgerJournalTrans::findRecId(salesPurchJournalLineLoc.SourceRecId, false).CashDiscAmount)
                        cashDiscPercentLoc = cashDiscPercent_IN;
                    break;
            }
            if (cashDiscPercentLoc)
            {
                baseLine    = baseLine * 100/(100 - cashDiscPercentLoc);
                if (taxableBasis == TaxableBasis_IN::LineAmount)
                {
                    taxValueSum  = taxValueSum * (100 - cashDiscPercentLoc) / 100;
                }
            }
        }
        mrpExclTax          = abs(baseMRP);
        accessableExclTax   = abs(baseAccessable);
        lineExclTax         = abs(baseLine);

        // Do backward calculation for the taxable basis that include all taxes which are marked as "Price incl. tax"
        if (taxableBasis == TaxableBasis_IN::LineAmount)
        {
            lineExclTax = (abs(baseLine - staticTaxAmountSum) - amtPerUnitSum) / (1 + taxValueSum);
        }
        else if (taxableBasis == TaxableBasis_IN::MRP)
        {
            mrpExclTax = (abs(baseMRP - staticTaxAmountSum) - amtPerUnitSum) / (1 + taxValueSum);
        }

        if (cashDiscPercentLoc)
        {
            lineExclTax = lineExclTax * (100 - cashDiscPercentLoc)/100;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcChargeExclTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the charge of excl tax.
    /// </summary>
    /// <param name="_chargeCode">
    /// The charge code.
    /// </param>
    /// <param name="_chargeValue">
    /// The charge value.
    /// </param>
    /// <param name="_calculationDate">
    /// The calculation date.
    /// </param>
    /// <param name="_markupTrans">
    /// The markup transaction.
    /// </param>
    /// <param name="_delimiterVal">
    /// The delimiter val.
    /// </param>
    /// <returns>
    /// The charge excel tax amount.
    /// </returns>
    real calcChargeExclTax_IN(MarkupCode   _chargeCode,
                              MarkupValue  _chargeValue,
                              date         _calculationDate,
                              MarkupTrans  _markupTrans,
                              str          _delimiterVal = '')
    {
        FormulaDesigner_IN  formulaDesigner;
        Counter             position = 1, initPos = 1;
        int                 length;
        real                pctVal, chargeExclTax;
        TaxValue            taxValueLoc;
        str                 code;
        MarkupTable         markupTable;
        TaxGroupData        taxGroupLoc;
        TaxOnItem           taxOnItemLoc1;
        real                sumAbatementOnCode;
        MarkupValue         taxOnChargeAbatement;
        VendInvoiceInfoLine vendInvoiceInfoLineCreditNote;
        PurchLine           purchlineCreditNote;
        InventTransferLine_IN inventTransferLineIN;
        TaxItemGroup taxItemGroup;
        TaxGroup taxGroup;
        CurrencyCode currencyCode;

        if (salesPurchJournalLineLoc.SourceTableId == tableNum(InventTransferLine))
        {
            inventTransferLineIN = InventTransferLine_IN::findByinventTransferLine(salesPurchJournalLineLoc.SourceRecId);
            taxItemGroup = inventTransferLineIN.TaxItemGroup;
            taxGroup = inventTransferLineIN.TaxGroup;
            currencyCode = inventTransferLineIN.CurrencyCode;
        }
        else
        {
            taxItemGroup = salesPurchJournalLineLoc.TaxItemGroup;
            taxGroup = salesPurchJournalLineLoc.TaxGroup;
            currencyCode = salesPurchJournalLineLoc.CurrencyCode;
        }

        code = strFmt("%1%2%1", _delimiterVal, _chargeCode);

        if (salesPurchJournalLineLoc.SourceTableId == tableNum(VendInvoiceInfoLine))
        {
            vendInvoiceInfoLineCreditNote = salesPurchJournalLineLoc;
            purchlineCreditNote           = vendInvoiceInfoLineCreditNote.purchLine();
        }
        while select TaxItemGroup, PriceInclTax, TaxCode, CalcExp1, TaxableBasis from formulaDesigner where
            formulaDesigner.TaxItemGroup == taxItemGroup &&
            formulaDesigner.PriceInclTax == NoYes::Yes
        {
            taxGroupLoc = TaxGroupData::find(taxGroup, formulaDesigner.TaxCode);
            taxOnItemLoc1 = TaxOnItem::find(taxItemGroup, formulaDesigner.TaxCode);
            if (taxGroupLoc && !taxGroupLoc.ExemptTax)
            {
                if (((salesPurchJournalLineLoc.SourceTableId == tableNum(PurchLine) || salesPurchJournalLineLoc.SourceTableId == tableNum(SalesLine)) &&
                      salesPurchJournalLineLoc.SalesPurchJournalLine::getSalesPurchJournalLineExtension_IN().TaxAsPerOriginalInvoice)
                            ||
                    (salesPurchJournalLineLoc.SourceTableId == tableNum(VendInvoiceInfoLine) &&
                     purchlineCreditNote.RecId != 0 &&
                     purchlineCreditNote.purchLine_IN().TaxAsPerOriginalInvoice == true))
                {
                    taxValueLoc = Tax::determineTaxValue_IN(formulaDesigner.TaxCode,
                                                         salesPurchJournalLineLoc);
                }
                else
                {
                    taxValueLoc = Tax::getTaxValue_IN(_calculationDate,
                                                   formulaDesigner.TaxCode,
                                                   _chargeValue,
                                                   salesPurchJournalLineLoc);
                }
                length  = strLen(formulaDesigner.CalcExp1);
                initPos     = 1;
                position    = 1;
                while (initPos != 0 && position <= length)
                {
                    initPos = strScan(formulaDesigner.CalcExp1, code, position, length-position);
                    if (initPos == 0)
                    continue;
                    position = initPos + strLen(code);
                    pctVal += taxValueLoc/100;
                }

                if (taxOnItemLoc1.AbatementPercent_IN)
                {
                    switch (formulaDesigner.TaxableBasis)
                    {
                        case TaxableBasis_IN::LineAmount:
                            if (abatementLine)
                            {
                                sumAbatementOnCode += abatementLine;
                            }
                            break;

                        case TaxableBasis_IN::MRP:
                            if (abatementMRP)
                            {
                                sumAbatementOnCode += abatementMRP;
                            }
                            break;
                        case TaxableBasis_IN::Assessable:
                            if (abatementAssessable)
                            {
                                sumAbatementOnCode += abatementAssessable;
                            }
                            break;
                    }
                }
            }
        }
        chargeExclTax = _chargeValue/(1+pctVal);

        taxOnChargeAbatement = (_chargeValue - chargeExclTax) * (sumAbatementOnCode)/100;

        markupTable = _markupTrans.markupTable();
        if ((markupTable.CustType == MarkupType::CustVend && _markupTrans.Value < 0) ||
           (markupTable.VendType == MarkupType::CustVend && _markupTrans.Value > 0))
        {
            chargeExclTax = -chargeExclTax;
        }
        tmpTaxCalc_IN.ChargeCode    = _chargeCode;
        tmpTaxCalc_IN.OrigChargeAmt = CurrencyExchangeHelper::amount(chargeExclTax - taxOnChargeAbatement, currencyCode);
        tmpTaxCalc_IN.SourceTableID = salesPurchJournalLineLoc.SourceTableId;
        tmpTaxCalc_IN.SourceRecID   = salesPurchJournalLineLoc.SourceRecId;
        tmpTaxCalc_IN.insert();

        return abs(chargeExclTax);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCorrectedTaxExim_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates corrected tax exim.
    /// </summary>
    /// <param name="_tmpTaxWorkTrans">
    /// The temporary work transaction.
    /// </param>
    /// <returns>
    /// If 'True', the calculation is corrected.
    /// </returns>
    public boolean calcCorrectedTaxExim_IN(TmpTaxWorkTrans _tmpTaxWorkTrans)
    {
        AmountCur       taxAmountCur;
        TaxAmount       incentiveTaxAmount;

        if (_tmpTaxWorkTrans.EximIncentiveScheme_IN == EximIncentiveScheme_IN::DEPB)
        {
            taxAmountCur = _tmpTaxWorkTrans.SourceRegulateAmountCustoms_IN ? _tmpTaxWorkTrans.SourceRegulateAmountCustoms_IN : _tmpTaxWorkTrans.CustomsDuty_IN;

            [incentiveTaxAmount , depbSetOffRules, dutyavailed]  = EximTaxTable_IN::calcDEPBIncentiveTaxAmount(
                                                                                        _tmpTaxWorkTrans.SourceRecId,
                                                                                        _tmpTaxWorkTrans.TaxCode,
                                                                                        depbSetOffRules,
                                                                                        _tmpTaxWorkTrans.TransDate,
                                                                                        dutyavailed,
                                                                                        taxAmountCur,
                                                                                        EximAuthorizationType_IN::DEPB);

            if (!incentiveTaxAmount)
            {
                _tmpTaxWorkTrans.EximIncentiveScheme_IN = EximIncentiveScheme_IN::None;
            }
            _tmpTaxWorkTrans.EximTaxAmount_IN = incentiveTaxAmount;
            _tmpTaxWorkTrans.EximBalanceTaxAmount_IN = (_tmpTaxWorkTrans.CustomsDuty_IN - _tmpTaxWorkTrans.EximTaxAmount_IN);
            if (_tmpTaxWorkTrans.SourceRegulateAmountCustoms_IN)
            {
                _tmpTaxWorkTrans.EximTaxCorrectedAmount_IN = incentiveTaxAmount;
                _tmpTaxWorkTrans.EximBalanceTaxCorrectedAmount_IN = (_tmpTaxWorkTrans.SourceRegulateAmountCustoms_IN - _tmpTaxWorkTrans.EximTaxCorrectedAmount_IN);
            }
            this.parmDEPBSetOffRules_IN(depbSetOffRules);
            this.parmDEPBDutyAvailed_IN(dutyavailed);
        }
        else if (_tmpTaxWorkTrans.EximIncentiveScheme_IN == EximIncentiveScheme_IN::EPCG)
        {
            _tmpTaxWorkTrans.EximTaxCorrectedAmount_IN = _tmpTaxWorkTrans.SourceRegulateAmountCustoms_IN && (_tmpTaxWorkTrans.EximTaxAmount_IN || _tmpTaxWorkTrans.EximBalanceTaxAmount_IN)?
                                                        CurrencyExchangeHelper::amount(_tmpTaxWorkTrans.EximTaxAmount_IN * _tmpTaxWorkTrans.SourceRegulateAmountCustoms_IN / (_tmpTaxWorkTrans.EximTaxAmount_IN + _tmpTaxWorkTrans.EximBalanceTaxAmount_IN)) : 0;

            _tmpTaxWorkTrans.EximBalanceTaxCorrectedAmount_IN = _tmpTaxWorkTrans.EximBalanceTaxAmount_IN ?
                                                                (_tmpTaxWorkTrans.SourceRegulateAmountCustoms_IN - _tmpTaxWorkTrans.EximTaxCorrectedAmount_IN) :
                                                                0 ;

            taxAmountCur = _tmpTaxWorkTrans.SourceRegulateAmountCustoms_IN ? _tmpTaxWorkTrans.EximTaxCorrectedAmount_IN : _tmpTaxWorkTrans.EximTaxAmount_IN;
            if (_tmpTaxWorkTrans.SourceTableId == tableNum(PurchLine)
                && EximPurchLine_IN::findByPurchLineRecId(_tmpTaxWorkTrans.SourceRecId).ApplyDEPB
                && _tmpTaxWorkTrans.EximTaxAmount_IN)
            {
                [incentiveTaxAmount , depbSetOffRules, dutyavailed]  = EximTaxTable_IN::calcDEPBIncentiveTaxAmount(
                                                                                            _tmpTaxWorkTrans.SourceRecId,
                                                                                            _tmpTaxWorkTrans.TaxCode,
                                                                                            depbSetOffRules,
                                                                                            _tmpTaxWorkTrans.TransDate,
                                                                                            dutyavailed,
                                                                                            taxAmountCur,
                                                                                            EximAuthorizationType_IN::EPCG);
            }

            _tmpTaxWorkTrans.EximDEPBAmount_IN = incentiveTaxAmount;
            this.parmDEPBSetOffRules_IN(depbSetOffRules);
            this.parmDEPBDutyAvailed_IN(dutyavailed);
        }
        else if (_tmpTaxWorkTrans.EximIncentiveScheme_IN == EximIncentiveScheme_IN::AA
                 || _tmpTaxWorkTrans.EximIncentiveScheme_IN == EximIncentiveScheme_IN::DFIA)
        {
            _tmpTaxWorkTrans.EximTaxCorrectedAmount_IN = _tmpTaxWorkTrans.SourceRegulateAmountCustoms_IN && _tmpTaxWorkTrans.CustomsDuty_IN?
                                                     CurrencyExchangeHelper::amount(_tmpTaxWorkTrans.EximTaxAmount_IN * _tmpTaxWorkTrans.SourceRegulateAmountCustoms_IN / _tmpTaxWorkTrans.CustomsDuty_IN) : 0;

            _tmpTaxWorkTrans.EximBalanceTaxCorrectedAmount_IN =  _tmpTaxWorkTrans.SourceRegulateAmountCustoms_IN - _tmpTaxWorkTrans.EximTaxCorrectedAmount_IN;
        }
        return (_tmpTaxWorkTrans.EximTaxCorrectedAmount_IN != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcEPCGIncentiveTaxBaseAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates EPCG incentive tax base amount.
    /// </summary>
    /// <param name="_salesPurchJournalLine">
    /// The sales purch journal line.
    /// </param>
    /// <param name="_sourceCurrencyCode">
    /// The source currency code.
    /// </param>
    /// <param name="_tmpTax">
    /// The temporary tax.
    /// </param>
    /// <param name="_taxDate">
    /// The tax date.
    /// </param>
    /// <param name="_taxQty">
    /// The tax quantity.
    /// </param>
    /// <param name="_formulaDesigner">
    /// The formula designer.
    /// </param>
    /// <returns>
    /// The EOCG incentive tax base amount.
    /// </returns>
    public container calcEPCGIncentiveTaxBaseAmount_IN(
        SalesPurchJournalLine    _salesPurchJournalLine,
        CurrencyCode             _sourceCurrencyCode,
        TmpTax                   _tmpTax,
        TransDate                _taxDate,
        TaxQty                   _taxQty,
        FormulaDesigner_IN       _formulaDesigner)
    {
        EximPurchLine_IN                    eximPurchLine;
        EximIncentiveSchemeData_IN          eximIncentiveSchemeData;
        EximEPCGImportTrans_IN              eximImportTrans;
        EximTaxTable_IN                     eximTaxTable;
        PurchLine                           purchLine;
        AmountMST                           totalAssessbleVal;
        AmountMST                           importValue;
        EximEPCGSchemeTable_IN              eximEPCGSchemeTable;
        EximParameters_IN                   eximParameters = EximParameters_IN::find();
        TaxBase                             incentiveTaxBaseAmount;
        TaxBase                             balanceTaxBaseAmount;
        boolean                             proceed;
        Counter                             i;
        AmountMST                           utilizedImportValue;
        AmountMST                           balanceImportValue;
        TaxData                             taxData;
        TaxValue                            taxPercent;

        select firstonly RecId from eximPurchLine
                where eximPurchLine.PurchLineRecId == _salesPurchJournalLine.SourceRecId
            join RecId, EximIncentiveSchemeGroup, AuthorizationId, IncentiveScheme
                from eximIncentiveSchemeData
                    where eximIncentiveSchemeData.EximIncentiveSchemeGroup == eximPurchLine.EximIncentiveSchemeGroup
                join  RecId, EximIncentiveSchemeGroup, TaxCode, TaxPct
                    from eximTaxTable
                        where eximTaxTable.EximIncentiveSchemeGroup == eximPurchLine.EximIncentiveSchemeGroup
                           && eximTaxTable.TaxCode              == _tmpTax.TaxCode
                    join  RecId, SchemeId, EximPorts, ImportValueMST
                        from eximEPCGSchemeTable
                            where eximEPCGSchemeTable.SchemeId == eximIncentiveSchemeData.AuthorizationId
                               && eximEPCGSchemeTable.ImportExpiryDateTime   >= DateTimeUtil::newDateTime(_taxDate,0,DateTimeUtil::getUserPreferredTimeZone());

        if (eximPurchLine.RecId)
        {
            purchLine = PurchLine::findRecId(_salesPurchJournalLine.SourceRecId);

            select sum(ImportValue)
               from eximImportTrans
                  where eximImportTrans.SchemeTableRecId == eximEPCGSchemeTable.RecId;

            if (_formulaDesigner.TaxableBasis == TaxableBasis_IN::MRP)
            {
                totalAssessbleVal = purchLine.purchLine_IN().CustomsMaxRetailPrice * _taxQty;
            }
            else
            {
                totalAssessbleVal = CurrencyHelper_IN::customsMSTAmount_IN(this.getAmountBase_IN(_formulaDesigner, _tmpTax.SourceTaxBaseAmountCur, _tmpTax, _taxQty),
                                                                  _sourceCurrencyCode,
                                                                  Direction_IN::Import);
            }

            importValue = eximEPCGSchemeTable.ImportValueMST + (eximEPCGSchemeTable.ImportValueMST * eximParameters.epcgMaxUtilizationPct / 100);

            if ( this.findPurchLineInEPCGImportTransDetails_IN(purchLine.RecId) )
            {
                proceed = true;
                balanceImportValue = importValue - eximImportTrans.ImportValue;
            }
            else
            {
                for (i=1; i<= conLen(epcgImportTransDetails); i = i + 3)
                {
                    if (eximEPCGSchemeTable.RecId == conPeek(epcgImportTransDetails, i + 1))
                    {
                        utilizedImportValue += conPeek(epcgImportTransDetails, i + 2);
                    }
                }
                balanceImportValue = (importValue - (eximImportTrans.ImportValue + utilizedImportValue));
                proceed =  balanceImportValue > 0 ? true : false;
            }

            if (proceed && balanceImportValue)
            {
                if (balanceImportValue >= totalAssessbleVal)
                {
                    incentiveTaxBaseAmount = totalAssessbleVal;
                    balanceTaxBaseAmount = 0;
                }
                else
                {
                    incentiveTaxBaseAmount = balanceImportValue;
                    balanceTaxBaseAmount = (totalAssessbleVal - balanceImportValue) ;
                }
                epcgImportTransDetails = conPoke(epcgImportTransDetails,
                                                 conLen(epcgImportTransDetails) + 1,
                                                 purchLine.RecId,
                                                 eximEPCGSchemeTable.RecId,
                                                 totalAssessbleVal);
            }
            else
            {
                incentiveTaxBaseAmount = 0;
                balanceTaxBaseAmount = totalAssessbleVal;
            }
        }

        taxPercent = taxData.percentForTax_IN(_tmpTax.TaxCode, _taxDate, CurrencyHelper_IN::customsCurAmount_IN(balanceTaxBaseAmount, _sourceCurrencyCode, Direction_IN::Import, _taxDate), _salesPurchJournalLine);

        return [incentiveTaxBaseAmount, balanceTaxBaseAmount, eximTaxTable.TaxPct, taxPercent];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the tax mount
    /// </summary>
    /// <param name = "_tmpTax">The buffer for table <c>TmpTax</c>.</param>
    /// <param name = "_taxOnTaxBasedOnInvoiceTotalCalculation">Whether calculate total tax on tax based on invoice.</param>
    /// <returns>The calculated tax amount.</returns>
    TaxAmount calcTax(TmpTax _tmpTax = tmpTax, boolean _taxOnTaxBasedOnInvoiceTotalCalculation = false)
    {
        TaxBase         taxLimitAmount;
        TaxBase         amountBase;
        TaxCode         lastTaxCode;
        TaxAmount       taxAmount;
        TaxTable        taxTable;
        TaxTable        taxTableBasis;
        TaxAmount       taxAmountSum;
        TaxAmount       taxAmountToIncludeMST;
        TaxAmountCur    taxAmountToIncludeCur;
        TmpTax          tmpTaxTaxOnTax;
        Counter         sign;
        boolean         taxOnTaxBasedOnInvoiceTotal = false;
        TaxBase         taxBaseAmountForTaxOnTax;
        TaxBaseCur      taxBaseAmountForTaxOnTaxCur;
        int             invoiceTotalCount = 0;
        TaxCalcPrin     taxCalculationPrinciple;
        // <GIN>
        FormulaDesigner_IN  formulaDesigner;
        boolean             inclTax;
        Percent             epcgTaxPct;
        TaxValue            taxPct;
        TaxItemGroup        taxItemGroup;
        // </GIN>
        // <GBR>
        TaxData         taxData;
        // <GBR/>
        DataAreaId currentCompany = curext();
        TaxAmount issTaxAmount;

        TaxBase adjustAmountIfTaxBaseQty(TaxBase amount, TaxQty taxBaseQty)
        {
            if (taxBaseQty)
            {
                return amount / abs(taxBaseQty);
            }
            else
            {
                return amount;
            }
        }

        void calcTaxInternal()
        {
            DataAreaId postCompany = _tmpTax.Company;
            postCompany = postCompany ? postCompany : currentCompany;
            changecompany(postCompany)
            {
                invoiceTotalCount++;

                taxTable = this.getTaxTable(_tmpTax.TaxCode);

                // <GIN>
                if (isTaxParametersEnabled)
                {
                    if (taxTable.TaxType_IN != TaxType_IN::None)
                    {
                        abatementAmount = 0;
                        if (salesPurchJournalLineLoc.SourceTableId == tableNum(InventTransferLine))
                        {
                            this.getSalesPurchJournalforInventTranfer_IN();
                            taxItemGroup = InventTransferLine_IN::findByinventTransferLine(salesPurchJournalLineLoc.SourceRecId).TaxItemGroup;
                        }
                        else
                        {
                            taxItemGroup = salesPurchJournalLineLoc.TaxItemGroup;
                            if (this.sourceTableId() == tableNum(VendInvoiceInfoLine))
                            {
                                salesPurchJournalLineLoc = VendInvoiceInfoLine::findRecId(this.sourceRecId());
                            }
                        }
                        this.parmLocalTaxes_IN(true);
                        formulaDesigner = FormulaDesigner_IN::findByTaxCode(taxItemGroup,tmpTax.TaxCode);

                        if ((!inclTax || _tmpTax.IsScrapQtyLine_IN) && FormulaDesigner_IN::findPriceInclTax(taxItemGroup))
                        {
                            inclTax = true;
                            this.calcBaseAmtExclTax_IN(tmpTax.SourceTaxBaseAmountCur, tmpTax.CalculationDate, taxQty);
                        }
                    }
                }
                // </GIN>

                if (_tmpTax.TaxCode   != lastTaxCode)
                {
                    taxLimitAmount  = 0;
                    taxAmountSum    = 0;
                }

                lastTaxCode = _tmpTax.TaxCode;
                sign        = 1;
                switch (_tmpTax.TaxCalculationOrder)
                {
                    case TaxCalculationOrder::CalculateBeforeOtherSalesTax:
                        if (taxTable.TaxCalcMethod == TaxCalcMode::Interval)
                        {
                            amountBase = _tmpTax.TaxBaseAmountMSTRaw;
                            if (amountBase < 0)
                            {
                                sign = -1;
                            }

                            _tmpTax.TaxAmountMST = taxTable.calcTax(
                                taxDate,
                                _tmpTax,
                                // <GIN>
                                (taxTable.TaxType_IN != TaxType_IN::None) ?
                                    this.getAmountBase_IN(formulaDesigner, amountBase, tmpTax, taxQty) :
                                // </GIN>
                                    _tmpTax.TaxBaseAmountMSTRaw,
                                taxLimitAmount,
                                _tmpTax.SourceCurrencyCode,
                                triangulation,
                                _tmpTax.CalculationDate
                                 // <GIN>
                                , salesPurchJournalLineLoc
                                 // </GIN>
                            );

                            taxLimitAmount = taxLimitAmount + _tmpTax.TaxBaseAmountMSTRaw + sign;
                        }
                        else
                        {
                            taxTable.calcTaxSimple(
                                taxDate,
                                _tmpTax,
                                 // <GIN>
                                 (taxTable.TaxType_IN != TaxType_IN::None) ?
                                     this.getAmountBase_IN(formulaDesigner, tmpTax.SourceTaxBaseAmountCur, tmpTax, taxQty) :
                                 // </GIN>
                                    _tmpTax.SourceTaxBaseAmountCurRaw,
                                _tmpTax.SourceCurrencyCode,
                                triangulation,
                                _tmpTax.CalculationDate
                                // <GIN>
                                , salesPurchJournalLineLoc
                                // </GIN>
                            );
                        }
                        taxAmountToIncludeMST += _tmpTax.TaxAmountMST;
                        taxAmountToIncludeCur += _tmpTax.SourceTaxAmountCur;
                        break;

                    case TaxCalculationOrder::PercentageOfNetAmount:
                        if (taxTable.TaxCalcMethod == TaxCalcMode::Interval)
                        {
                            amountBase = _tmpTax.TaxBaseAmountMSTRaw;
                            if (amountBase < 0)
                            {
                                sign = -1;
                            }

                            _tmpTax.TaxAmountMST = taxTable.calcTax(
                                taxDate,
                                _tmpTax,
                                // <GIN>
                                (taxTable.TaxType_IN != TaxType_IN::None) ?
                                    this.getAmountBase_IN(formulaDesigner, tmpTax.TaxBaseAmountMST + taxAmountToIncludeMST, tmpTax, taxQty) :
                                // </GIN>
                                    _tmpTax.TaxBaseAmountMSTRaw + taxAmountToIncludeMST,
                                taxLimitAmount,
                                _tmpTax.SourceCurrencyCode,
                                triangulation,
                                _tmpTax.CalculationDate
                                // <GIN>
                                , salesPurchJournalLineLoc
                                // </GIN>
                            );
                            taxLimitAmount    = taxLimitAmount + _tmpTax.TaxBaseAmountMSTRaw + sign;
                        }
                        else
                        {
                            TaxAmount amountExcludeFromBase;
                            if (isBrazilEnabled
                                && (taxTable.TaxType_BR == TaxType_BR::COFINS || taxTable.TaxType_BR == TaxType_BR::PIS)
                                && !directImport_BR)
                            {
                                if (taxTable.ExcludeICMS_BR && isTaxExcludeIcmsFromAmountOrigin_BRFlightEnabled)
                                {
                                    amountExcludeFromBase += icmsAmountToSubtractCur;
                                }

                                if (taxTable.ExcludeISS_BR && isTaxExcludeIssFromAmountOrigin_BRFlightEnabled)
                                {
                                    amountExcludeFromBase += issTaxAmount;
                                }
                            }

                            taxTable.calcTaxSimple(
                                taxDate,
                                _tmpTax,
                                // <GIN>
                                (taxTable.TaxType_IN != TaxType_IN::None) ? this.getAmountBase_IN(formulaDesigner, tmpTax.SourceTaxBaseAmountCur + taxAmountToIncludeCur, tmpTax, taxQty) :
                                // </GIN>
                                _tmpTax.SourceTaxBaseAmountCurRaw + taxAmountToIncludeCur - amountExcludeFromBase,
                                _tmpTax.SourceCurrencyCode,
                                triangulation,
                                _tmpTax.CalculationDate
                                // <GIN>
                                , salesPurchJournalLineLoc
                                // </GIN>
                            );
                        }

                        // <GBR>
                        if (isBrazilEnabled
                            && taxTable.TaxType_BR == TaxType_BR::ICMS)
                        {
                            icmsAmountToSubtractCur += _tmpTax.SourceTaxAmountCur;
                            icmsAmountToSubtractMST += _tmpTax.TaxAmountMST;
                        }

                        if (isBrazilEnabled
                            && taxTable.TaxType_BR == TaxType_BR::ISS
                            && taxTable.IncludedTax_BR == NoYes::Yes)
                        {
                            issTaxAmount += _tmpTax.SourceTaxAmountCur;
                        }

                        // </GBR>
                        break;

                    case TaxCalculationOrder::PercentageOfSalesTax:
                    case TaxCalculationOrder::PercentageOfSalesTaxOnGross:
                        taxTableBasis  = TaxTable::find(taxTable.TaxOnTax);
                        taxCalculationPrinciple = this.taxParameters().CalculatePrinciple;
                        if ((!_taxOnTaxBasedOnInvoiceTotalCalculation
                            || (_tmpTax.TaxCalculationOrder == TaxCalculationOrder::PercentageOfSalesTaxOnGross
                                && _taxOnTaxBasedOnInvoiceTotalCalculation
                                && invoiceTotalCount > 1)) &&
                            // Tax code we are based on is based on invoice total.
                        ((taxTableBasis.TaxLimitBase == TaxLimitBase::InvoiceWithoutVAT ||
                            taxTableBasis.TaxLimitBase == TaxLimitBase::InvoiceInclVAT ||
                            taxCalculationPrinciple == TaxCalcPrin::Total) ||

                            // or current tax code is per line.
                        ((taxTable.TaxLimitBase != TaxLimitBase::InvoiceWithoutVAT &&
                            taxTable.TaxLimitBase != TaxLimitBase::InvoiceInclVAT &&
                            taxCalculationPrinciple != TaxCalcPrin::Total) &&

                            // and tax code we are based on is per line.
                        (taxTableBasis.TaxLimitBase != TaxLimitBase::InvoiceWithoutVAT &&
                            taxTableBasis.TaxLimitBase != TaxLimitBase::InvoiceInclVAT &&
                            taxCalculationPrinciple != TaxCalcPrin::Total))))
                        {
                            [taxBaseAmountForTaxOnTax, taxBaseAmountForTaxOnTaxCur] = this.taxAmountForTaxOnTax(taxTable.TaxOnTax, _tmpTax);

                            this.insertInternalStructureWithCompany(
                                tmpTaxTaxOnTax,
                                _tmpTax.TaxCode,
                                CurrencyExchangeHelper::amount(taxBaseAmountForTaxOnTax),
                                taxBaseAmountForTaxOnTax,
                                _tmpTax.TaxBaseQty,
                                _tmpTax.TaxDirection,
                                0,
                                CurrencyExchangeHelper::amount(taxBaseAmountForTaxOnTaxCur, _tmpTax.SourceCurrencyCode),
                                taxBaseAmountForTaxOnTaxCur,
                                _tmpTax.CalculationDate,
                                _tmpTax.Warning,
                                false,
                                TaxFiscalValue_BR::Blank,
                                false,
                                _tmpTax.SourceCurrencyCode);
                            taxOnTaxBasedOnInvoiceTotal = true;
                        }
                        else
                        {
                            if (taxTable.TaxCalcMethod == TaxCalcMode::Interval)
                            {
                                _tmpTax.TaxAmountMST = taxTable.calcTax(
                                    taxDate,
                                    _tmpTax,
                                    _tmpTax.TaxBaseAmountMSTRaw,
                                    0,
                                    _tmpTax.SourceCurrencyCode,
                                    triangulation,
                                    _tmpTax.CalculationDate);
                            }
                            else
                            {
                                amountBase = adjustAmountIfTaxBaseQty(amountBase, _tmpTax.TaxBaseQty);

                                taxTable.calcTaxSimple(
                                    taxDate,
                                    _tmpTax,
                                    _tmpTax.SourceTaxBaseAmountCurRaw,
                                    _tmpTax.SourceCurrencyCode,
                                    triangulation,
                                    _tmpTax.CalculationDate);
                            }
                        }
                        break;
                    case TaxCalculationOrder::PercentageOfGrossAmountTaxOnTax:
                    case TaxCalculationOrder::PercentageOfGrossAmount:
                        taxTableBasis  = TaxTable::find(taxTable.TaxOnTax);
                        if (!_taxOnTaxBasedOnInvoiceTotalCalculation ||
                        (_taxOnTaxBasedOnInvoiceTotalCalculation && invoiceTotalCount > 1))
                        {
                            // if there was a tax on tax and a gross code then we may need to recall InsertInternalStructure on
                            // every recursion so that we pick up the tax on tax amount from the previous recursion level.
                            [taxBaseAmountForTaxOnTax, taxBaseAmountForTaxOnTaxCur] = this.taxAmountForTaxOnTax(taxTable.TaxOnTax, _tmpTax, taxTable);

                            // <GBR>
                            if (isBrazilEnabled
                                && (taxTable.TaxSubstitution_BR == TaxSubstitutionEnum_BR::Markup
                                    || taxTable.TaxSubstitution_BR == TaxSubstitutionEnum_BR::MarkupConfaz_52_2017)
                                && !calculatedTaxes_BR.in(_tmpTax.TaxCode))
                            {
                                [taxBaseAmountForTaxOnTax,
                                 taxBaseAmountForTaxOnTaxCur,
                                 taxSubstitutionAmountAddedMST_BR,
                                 sourceTaxSubstitutionAmountAddedCur_BR] = TaxSubstitutionCalculation_BR::calcTaxSubstitutionBase(
                                    _tmpTax,
                                    taxDate,
                                    taxBaseAmountForTaxOnTax,
                                    taxBaseAmountForTaxOnTaxCur,
                                    icmsAmountToSubtractCur,
                                    icmsAmountToSubtractMST,
                                    taxTable.TaxSubstitution_BR == TaxSubstitutionEnum_BR::MarkupConfaz_52_2017);
                            }
                            else
                            {
                                if (isBrazilEnabled && this.isDualBase_BR(taxTable, _tmpTax))
                                {
                                    taxData = TaxData::find(taxTable.TaxCode, taxDate, taxBaseAmountForTaxOnTax);

                                    taxBaseAmountForTaxOnTax    += _tmpTax.TaxBaseAmountMSTRaw;
                                    taxBaseAmountForTaxOnTaxCur += _tmpTax.SourceTaxBaseAmountCurRaw;

                                    taxSubstitutionAmountAddedMST_BR        = taxBaseAmountForTaxOnTax;
                                    sourceTaxSubstitutionAmountAddedCur_BR  = taxBaseAmountForTaxOnTaxCur;

                                    if (taxCalculateTotal && !icmsAmountToSubtractCur && !icmsAmountToSubtractMST)
                                    {
                                        [icmsAmountToSubtractCur, icmsAmountToSubtractMST] = this.icmsTaxAmountForSubtract_BR(_tmpTax.TaxFiscalValue_BR);
                                    }

                                    taxBaseAmountForTaxOnTax    -= icmsAmountToSubtractMST;
                                    taxBaseAmountForTaxOnTaxCur -= icmsAmountToSubtractCur;

                                    taxBaseAmountForTaxOnTax    = taxBaseAmountForTaxOnTax / (1 - (taxData.TaxValue / 100));
                                    taxBaseAmountForTaxOnTaxCur = taxBaseAmountForTaxOnTaxCur / (1 - (taxData.TaxValue / 100));
                                }
                                else
                                {
                                    // </GBR>
                                    taxBaseAmountForTaxOnTax += _tmpTax.TaxBaseAmountMSTRaw;
                                    taxBaseAmountForTaxOnTaxCur += _tmpTax.SourceTaxBaseAmountCurRaw;
                                    // <GBR>
                                }
                            }
                            // </GBR>

                            this.insertInternalStructureWithCompany(
                                tmpTaxTaxOnTax,
                                _tmpTax.TaxCode,
                                CurrencyExchangeHelper::amount(taxBaseAmountForTaxOnTax),
                                taxBaseAmountForTaxOnTax,
                                _tmpTax.TaxBaseQty,
                                _tmpTax.TaxDirection,
                                0,
                                CurrencyExchangeHelper::amount(taxBaseAmountForTaxOnTaxCur, _tmpTax.SourceCurrencyCode),
                                taxBaseAmountForTaxOnTaxCur,
                                _tmpTax.CalculationDate,
                                _tmpTax.Warning
                                // <GBR>
                                , false
                                , _tmpTax.TaxFiscalValue_BR
                                , false
                                // </GBR>
                                , _tmpTax.SourceCurrencyCode
                                );

                            // <GBR>
                            if (isBrazilEnabled
                                && (taxTable.TaxSubstitution_BR == TaxSubstitutionEnum_BR::Markup
                                    || taxTable.TaxSubstitution_BR == TaxSubstitutionEnum_BR::MarkupConfaz_52_2017
                                    || this.isDualBase_BR(taxTable, _tmpTax)))
                            {
                                tmpTaxTaxOnTax.TaxSubstitutionAmountAddedMST_BR = taxBaseAmountForTaxOnTax - taxSubstitutionAmountAddedMST_BR;
                                tmpTaxTaxOnTax.SourceTaxSubstitutionAmountAddedCur_BR = taxBaseAmountForTaxOnTaxCur - sourceTaxSubstitutionAmountAddedCur_BR;
                                tmpTaxTaxOnTax.update();
                            }
                            // </GBR>

                            taxOnTaxBasedOnInvoiceTotal = true;
                        }
                        else
                        {
                            if (taxTable.TaxCalcMethod == TaxCalcMode::Interval)
                            {
                                if (amountBase < 0)
                                {
                                    sign = -1;
                                }

                                amountBase = adjustAmountIfTaxBaseQty(amountBase, _tmpTax.TaxBaseQty);

                                _tmpTax.TaxAmountMST = taxTable.calcTax(
                                    taxDate,
                                    _tmpTax,
                                    _tmpTax.TaxBaseAmountMSTRaw,
                                    taxLimitAmount,
                                    _tmpTax.SourceCurrencyCode,
                                    triangulation,
                                    _tmpTax.CalculationDate);

                                taxLimitAmount        = taxLimitAmount + amountBase + sign;
                            }
                            else
                            {
                                amountBase = adjustAmountIfTaxBaseQty(amountBase, _tmpTax.TaxBaseQty);

                                taxTable.calcTaxSimple(
                                    taxDate,
                                   _tmpTax,
                                   _tmpTax.SourceTaxBaseAmountCurRaw,
                                   _tmpTax.SourceCurrencyCode,
                                   triangulation,
                                   _tmpTax.CalculationDate);
                            }

                            // <GBR>
                            if (isBrazilEnabled
                                && (taxTable.TaxSubstitution_BR != TaxSubstitutionEnum_BR::None
                                    || this.isDualBase_BR(taxTable, _tmpTax)))
                            {
                                if (taxCalculateTotal && !icmsAmountToSubtractCur && !icmsAmountToSubtractMST)
                                {
                                    [icmsAmountToSubtractCur, icmsAmountToSubtractMST] = this.icmsTaxAmountForSubtract_BR(_tmpTax.TaxFiscalValue_BR);
                                }

                                TaxSubstitutionCalculation_BR::adjustCalculatedTaxSubstitutionAmounts(
                                    _tmpTax,
                                    taxDate,
                                    taxBaseAmountForTaxOnTax,
                                    icmsAmountToSubtractCur,
                                    icmsAmountToSubtractMST,
                                    this.isDualBase_BR(taxTable, _tmpTax));
                            }
                            // </GBR>
                        }
                        break;

                    default:
                        Debug::assert(false);
                }
                // <GIN>
                if (isTaxParametersEnabled && taxTable.TaxType_IN != TaxType_IN::None)
                {
                    tmpTax.AbatementAmount_IN = abatementAmountInq;
                }
                if (isTaxParametersEnabled
                    && isEximIncentiveSchemEnabled
                    && EximParameters_IN::find().ActivateEPCG
                    && tmpTax.EximIncentiveScheme_IN == EximIncentiveScheme_IN::EPCG
                    && salesPurchJournalLineLoc.SourceTableId == tableNum(PurchLine)
                    && taxQty > 0)
                {
                    isEximEPCG = true;
                    [tmpTax.EximTaxBaseAmountMST_IN ,tmpTax.EximBalanceTaxBaseAmountMST_IN, epcgTaxPct, taxPct] = this.calcEPCGIncentiveTaxBaseAmount_IN(
                        salesPurchJournalLineLoc,
                        sourceCurrencyCode,
                        tmpTax,
                        tmpTax.CalculationDate,
                        taxQty,
                        formulaDesigner);
                    isEximEPCG = false;
                    [tmpTax.EximTaxAmount_IN, tmpTax.EximTaxAmountCur_IN, tmpTax.EximBalanceTaxAmount_IN, tmpTax.EximBalanceTaxAmountCur_IN]  = EximTaxTable_IN::calcEPCGIncentiveTaxAmount(
                        tmpTax.TaxCode,
                        tmpTax.CalculationDate,
                        tmpTax.EximTaxBaseAmountMST_IN,
                        tmpTax.EximBalanceTaxBaseAmountMST_IN,
                        formulaDesigner,
                        epcgTaxPct,
                        sourceCurrencyCode,
                        taxPct);
                }
                // </GIN>
                // <GBR>
                if (isBrazilEnabled)
                {
                    calculatedTaxes_BR.add(_tmpTax.TaxCode);

                    if (EFiscalDocument_BR::shouldUpdateTaxationCode_BR(this))
                    {
                        TmpTax::findAndUpdateTaxationCode_BR(
                            tmpTaxTaxOnTax,
                            _tmpTax.TaxationCode_BR,
                            _tmpTax.TaxCode,
                            _tmpTax.TaxDirection,
                            _tmpTax.CalculationDate,
                            _tmpTax.SourceCurrencyCode,
                            _tmpTax.TaxFiscalValue_BR,
                            _tmpTax.TaxReceivableLongTerm_BR,
                            _tmpTax.Company,
                            true);
                    }
                }
                // </GBR>
                boolean isTaxICMSST60FiscalValue3 = false;

                isTaxICMSST60FiscalValue3 = FiscalDocumentTaxTrans_BR::isTaxTypeICMSST60FiscalValue3(taxTable.TaxType_BR, _tmpTax.TaxFiscalValue_BR, _tmpTax.TaxationCode_BR);

                if (EFiscalDocument_BR::shouldIncludeTaxInTaxTotal(isTaxICMSST60FiscalValue3, this))
                {
                    taxAmountSum += _tmpTax.TaxAmountMST;
                    taxAmount += _tmpTax.TaxAmountMST;
                }

                _tmpTax.update();

                // <GIN>
                if (isIndiaCountryRegionEnabled
                    && _tmpTax.IsScrapQtyLine_IN)
                {
                    taxAmount -= _tmpTax.TaxAmountMST;
                }
                // </GIN>
            }
        }
        ;

        lastTaxCode     = '';
        taxLimitAmount  = 0;
        taxAmountSum    = 0;

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            return 0;
        }

        // <GIN>
        if (isIndiaCountryRegionEnabled)
        {
            if (!this.parmInvoiceCompany_IN())
            {
                this.parmInvoiceCompany_IN(curext());
            }

            if (LedgerInterCompany::existForCompanyPair(curExt(), this.parmInvoiceCompany_IN()) && !salesPurchJournalLineLoc)
            {
                salesPurchJournalLineLoc = Tax::getSalesPurchJournalLine(this.sourceRecId(), this.sourceTableId());
            }
            if (this.parmInvoiceCompany_IN() != curext())
            {
                changecompany(this.parmInvoiceCompany_IN())
                {
                    return this.calcTax(_tmpTax, _taxOnTaxBasedOnInvoiceTotalCalculation);
                }
            }
        }
        // </GIN>

        if (isBrazilEnabled)
        {
            if (!calculatedTaxes_BR)
            {
                calculatedTaxes_BR = new Set(Types::String);
            }

            if (!_taxOnTaxBasedOnInvoiceTotalCalculation)
            {
                icmsAmountToSubtractCur = 0;
                icmsAmountToSubtractMST = 0;
            }
        }

        if (isBrazilEnabled
            && (isTaxExcludeIcmsFromAmountOrigin_BRFlightEnabled || isTaxExcludeIssFromAmountOrigin_BRFlightEnabled))
        {
            while select _tmpTax
                order by TaxCalculationOrder, TaxCalculationSubOrderNum_BR, IntervalNum
                where _tmpTax.Warning == TaxWarning::NoWarning
            {
                calcTaxInternal();
            }
        }
        else
        {
            while select _tmpTax
                order by TaxCalculationOrder, IntervalNum
                where _tmpTax.Warning == TaxWarning::NoWarning
            {
                calcTaxInternal();
            }
        }

        if (taxOnTaxBasedOnInvoiceTotal)
        {
            taxAmount += this.calcTax(tmpTaxTaxOnTax, true);

            // <GBR>
            if (isBrazilEnabled)
            {
                icmsAmountToSubtractCur = 0;
                icmsAmountToSubtractMST = 0;
            }
            // </GBR>

            lastTaxCode = '';
            while select tmpTaxTaxOnTax
            order by tmpTaxTaxOnTax.TaxCode
            {
                if (tmpTaxTaxOnTax.TaxCode != lastTaxCode)
                {
                    delete_from _tmpTax
                    where _tmpTax.TaxCode == tmpTaxTaxOnTax.TaxCode;

                    lastTaxCode = tmpTaxTaxOnTax.TaxCode;
                }

                _tmpTax.data(tmpTaxTaxOnTax);
                _tmpTax.insert();
            }
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTaxExim_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates tax exim.
    /// </summary>
    /// <param name="_purchCalcTax">
    /// The purch calculate tax.
    /// </param>
    public void calcTaxExim_IN(PurchCalcTax _purchCalcTax)
    {
        TmpTaxWorkTrans tmpTaxWorkTrans;
        boolean         moreLines;
        Common          line;
        Qty             qty;
        PurchCalcTax_ParmTrans  purchCalcTax_ParmTrans;
        PurchParmLine           purchParmLineBlank;

        tmpTaxWorkTrans.setTmpData(taxWorkTrans);

        ttsbegin;
        while select forupdate tmpTaxWorkTrans
            where tmpTaxWorkTrans.ExemptTax == NoYes::No
        {
            if (tmpTaxWorkTrans.EximIncentiveScheme_IN != EximIncentiveScheme_IN::None)
            {
                _purchCalcTax.initCursor();
                moreLines   = true;

                while (moreLines)
                {
                    line = _purchCalcTax.nextLine();
                    if (line.RecId)
                    {
                        if (line.RecId == tmpTaxWorkTrans.SourceRecId)
                        {
                            qty = _purchCalcTax.transQty();
                            moreLines = false;
                        }
                    }
                    else
                    {
                        moreLines = false;
                    }
                }
            }

            if (documentStatus    == DocumentStatus::None
                || documentStatus == DocumentStatus::BillOfEntry_IN)
            {
                if (tmpTaxWorkTrans.EximIncentiveScheme_IN == EximIncentiveScheme_IN::DEPB
                    && qty > 0)
                {
                    [tmpTaxWorkTrans.EximTaxAmount_IN ,
                     depbSetOffRules,
                     dutyavailed]  = EximTaxTable_IN::calcDEPBIncentiveTaxAmount(tmpTaxWorkTrans.SourceRecId,
                                                                                 tmpTaxWorkTrans.TaxCode,
                                                                                 depbSetOffRules,
                                                                                 taxDate,
                                                                                 dutyavailed,
                                                                                 tmpTaxWorkTrans.CustomsDuty_IN,
                                                                                 EximAuthorizationType_IN::DEPB);
                }
                else if (tmpTaxWorkTrans.EximIncentiveScheme_IN == EximIncentiveScheme_IN::EPCG
                    && tmpTaxWorkTrans.SourceTableId == tableNum(PurchLine)
                    && EximPurchLine_IN::findByPurchLineRecId(tmpTaxWorkTrans.SourceRecId).ApplyDEPB
                    && tmpTaxWorkTrans.EximTaxAmount_IN)
                {
                    [tmpTaxWorkTrans.EximDEPBAmount_IN ,
                     depbSetOffRules,
                     dutyavailed]  = EximTaxTable_IN::calcDEPBIncentiveTaxAmount(tmpTaxWorkTrans.SourceRecId,
                                                                                 tmpTaxWorkTrans.TaxCode,
                                                                                 depbSetOffRules,
                                                                                 taxDate,
                                                                                 dutyavailed,
                                                                                 tmpTaxWorkTrans.EximTaxAmount_IN,
                                                                                 EximAuthorizationType_IN::EPCG);
                }
                else if ((tmpTaxWorkTrans.EximIncentiveScheme_IN == EximIncentiveScheme_IN::AA
                    || tmpTaxWorkTrans.EximIncentiveScheme_IN == EximIncentiveScheme_IN::DFIA)
                    && qty > 0)
                {
                    if (classIdGet(_purchCalcTax) == classNum(PurchCalcTax_ParmTrans))
                    {
                        purchCalcTax_ParmTrans = _purchCalcTax;
                    }
                    tmpTaxWorkTrans.EximTaxAmount_IN = EximTaxTable_IN::calcIncentiveTaxAmount(tmpTaxWorkTrans, qty, purchCalcTax_ParmTrans ? purchCalcTax_ParmTrans.getPurchParmLine_IN() : purchParmLineBlank);
                }

                if (tmpTaxWorkTrans.EximIncentiveScheme_IN != EximIncentiveScheme_IN::None)
                {
                    if (tmpTaxWorkTrans.EximIncentiveScheme_IN == EximIncentiveScheme_IN::DEPB
                        || (tmpTaxWorkTrans.EximIncentiveScheme_IN == EximIncentiveScheme_IN::EPCG
                        && tmpTaxWorkTrans.SourceTableId == tableNum(PurchLine)
                        && EximPurchLine_IN::findByPurchLineRecId(tmpTaxWorkTrans.SourceRecId).ApplyDEPB))
                    {
                        this.parmDEPBSetOffRules_IN(depbSetOffRules);
                        this.parmDEPBDutyAvailed_IN(dutyavailed);
                    }

                    if (tmpTaxWorkTrans.EximTaxAmount_IN
                        && tmpTaxWorkTrans.EximIncentiveScheme_IN != EximIncentiveScheme_IN::EPCG)
                    {
                        // Incentive scheme balance tax amount might be greater than customs duty because of round diff,
                        // In this case, set Incentive scheme balance tax amount same as customs duty
                        if (tmpTaxWorkTrans.CustomsDuty_IN < tmpTaxWorkTrans.EximTaxAmount_IN)
                        {
                            tmpTaxWorkTrans.EximTaxAmount_IN = tmpTaxWorkTrans.CustomsDuty_IN;
                        }
                        tmpTaxWorkTrans.EximBalanceTaxAmount_IN = (tmpTaxWorkTrans.CustomsDuty_IN - tmpTaxWorkTrans.EximTaxAmount_IN);
                    }
                }
                if (tmpTaxWorkTrans.EximTaxAmount_IN)
                {
                    tmpTaxWorkTrans.EximTaxAmountCur_IN = CurrencyHelper_IN::customsCurAmount_IN(tmpTaxWorkTrans.EximTaxAmount_IN, tmpTaxWorkTrans.SourceCurrencyCode, Direction_IN::Import, tmpTaxWorkTrans.TransDate);
                }
                if (tmpTaxWorkTrans.EximBalanceTaxAmount_IN)
                {
                    tmpTaxWorkTrans.EximBalanceTaxAmountCur_IN = CurrencyHelper_IN::customsCurAmount_IN(tmpTaxWorkTrans.EximBalanceTaxAmount_IN, tmpTaxWorkTrans.SourceCurrencyCode, Direction_IN::Import, tmpTaxWorkTrans.TransDate);
                }
            }
            if ((!tmpTaxWorkTrans.EximTaxAmount_IN
                || qty < 0)
                && tmpTaxWorkTrans.EximIncentiveScheme_IN != EximIncentiveScheme_IN::EPCG)
            {
                tmpTaxWorkTrans.EximIncentiveScheme_IN = EximIncentiveScheme_IN::None;
            }
            tmpTaxWorkTrans.update();
        }
        while select forupdate tmpTaxWorkTrans
            where tmpTaxWorkTrans.ExemptTax == NoYes::Yes
        {
            tmpTaxWorkTrans.EximIncentiveScheme_IN = EximIncentiveScheme_IN::None;
            tmpTaxWorkTrans.update();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTaxDifferenceAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates tax difference amount in accounting currency by the difference between accounting exchange rate and tax exchange rate.
    /// </summary>
    protected void calculateTaxDifferenceAmount()
    {
        VatDueDate_W dateOfVATRegister;
        boolean exchangeRateIsSame;
        CurrencyExchangeRate taxExchangeRate;
        CurrencyExchangeRate accountingExchangeRate;
        CurrencyExchangeRate reportingExchangeRate;
        boolean isTaxSpecificExchRateEnabledByTable = TaxSpecificExchangeRateHelper::isTaxSpecificExchRateEnabledByTable(this.headingTableId(), this.headingRecId());

        if (isTaxSpecificExchRateEnabledByTable)
        {
            if (!taxSpecificExchangeRateMap)
            {
                taxSpecificExchangeRateMap = TaxSpecificExchangeRateHelper::getExchangeRateMap(this.headingTableId(), this.headingRecId());
                dateOfVATRegister = TaxSpecificExchangeRate::getDateOfVATRegister(this.headingTableId(), this.headingRecId());
            }

            if (!taxSpecificExchangeRateMap.elements())
            {
                return;
            }

            accountingExchangeRate = this.getTaxSpecificExchangeRate(accountingCurrency);
            reportingExchangeRate = this.getTaxSpecificExchangeRate(reportingCurrencyForTaxSpecificExchRate);
        }
        else
        {
            SalesTaxTransactionExchangeRate salesTaxTransactionExchangeRate
                = SalesTaxTransactionExchangeRate::findBySourceRecord(this.headingTableId(), this.headingRecId());

            if (salesTaxTransactionExchangeRate)
            {
                dateOfVATRegister = salesTaxTransactionExchangeRate.DateOfVATRegister;
                taxExchangeRate = salesTaxTransactionExchangeRate.SalesTaxExchangeRate;

                if (taxExchangeRate == this.parmExchRate())
                {
                    exchangeRateIsSame = true;
                }
            }
            else
            {
                dateOfVATRegister = this.parmTaxDate();
                taxExchangeRate = this.parmExchRate();
                exchangeRateIsSame = true;
                SalesTaxExchangeRateHelper::saveSalesTaxTransactionExchangeRate(
                    this.headingTableId(),
                    this.headingRecId(),
                    this.getTransactionalCurrency(),
                    taxExchangeRate,
                    dateOfVATRegister);
            }
        }

        while select forupdate taxWorkTrans
            where taxWorkTrans.HeadingRecId == this.headingRecId()
                && taxWorkTrans.HeadingTableId == this.headingTableId()
        {
            if (isTaxSpecificExchRateEnabledByTable)
            {
                taxWorkTrans.VatDueDate_W = dateOfVATRegister;
                taxWorkTrans.SalesTaxExchangeRate = accountingExchangeRate;
                taxWorkTrans.SalesTaxExchangeRateRep = reportingExchangeRate;
                taxWorkTrans.SalesTaxExchangeRateCur = this.getTaxSpecificExchangeRate(taxWorkTrans.CurrencyCode);

                this.updateTaxDifferenceAmount(taxWorkTrans);
                this.updateTaxDifferenceAmountRep(taxWorkTrans);
                this.updateTaxDifferenceAmountCur(taxWorkTrans);
            }
            else
            {
                taxWorkTrans.VatDueDate_W = dateOfVATRegister;
                taxWorkTrans.SalesTaxExchangeRate = taxExchangeRate;

                if ((this.headingTableId() == tableNum(CustInvoiceTable) || this.headingTableId() == tableNum(SalesTable))
                    && CustInvoiceBankExchangeRateEligibility_PL::isBankExchangeRateNotApplicableOnInvoice())
                {
                    ///On the current <b>Accounts Receivable</b> invoice. In case of CountryRegion Poland(PL), if the Accounts Receivable Parameter
                    ///"Exchange Rate Date" is set as automatic date determination, we bypass the bank exchange rate functionality.
                    taxWorkTrans.SalesTaxExchangeRate = this.parmExchRate();
                    taxWorkTrans.ExchangeRateTaxBaseAmount = taxWorkTrans.TaxBaseAmount;
                    taxWorkTrans.ExchangeRateTaxAmount = taxWorkTrans.TaxAmount;
                    SalesTaxExchangeRateHelper::saveSalesTaxTransactionExchangeRate(this.headingTableId(), this.headingRecId(),
                        this.getTransactionalCurrency(), taxWorkTrans.SalesTaxExchangeRate, taxWorkTrans.VatDueDate_W);
                }
                else if (exchangeRateIsSame)
                {
                    taxWorkTrans.ExchangeRateTaxBaseAmount = taxWorkTrans.TaxBaseAmount;
                    taxWorkTrans.ExchangeRateTaxAmount = taxWorkTrans.TaxAmount;
                }
                else
                {
                    this.updateTaxDifferenceAmount(taxWorkTrans);
                }
            }

            taxWorkTrans.update(this.ignoreCalculatedSalesTax());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTaxDifferenceAmountInternal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Call calculateTaxDifferenceAmount when saving TaxRegulation.
    /// </summary>
    internal void calculateTaxDifferenceAmountInternal()
    {
        this.calculateTaxDifferenceAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxSpecificExchangeRate</Name>
				<Source><![CDATA[
    internal CurrencyExchangeRate getTaxSpecificExchangeRate(CurrencyCode _currencyCode, Map _taxSpecificExchangeRateMap = taxSpecificExchangeRateMap)
    {
        CurrencyExchangeRate exchangeRate;
        if (_taxSpecificExchangeRateMap.exists(_currencyCode))
        {
            exchangeRate = _taxSpecificExchangeRateMap.lookup(_currencyCode);
        }

        return exchangeRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canChargeBePostedByTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the sales tax charge can be posted by tax.
    /// </summary>
    /// <returns>
    ///    Always returns false.
    /// </returns>
    protected boolean canChargeBePostedByTax()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canClearTaxAmountFields_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Controls if <c>tmpTaxWorkTrans</c> tax amount fields had to be cleared
    /// </summary>
    /// <returns>
    ///     True always the module is not related to purchase, otherwise false;
    /// </returns>

    protected boolean canClearTaxAmountFields_BR()
    {
        return taxWorkTrans.Source != TaxModuleType::Purch

                    && taxWorkTrans.Source != TaxModuleType::PurchInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfSkipIntersection_IN</Name>
				<Source><![CDATA[
    private boolean checkIfSkipIntersection_IN(TaxOnItem _taxOnItem)
    {
        TaxType_IN taxType;
        boolean    ret ;

        switch (this.sourceTableId())
        {
            case tableNum(InventTransferLine):
                if (TaxTable::find(_taxOnItem.TaxCode).TaxType_IN == TaxType_IN::Customs)
                {
                    ret = true;
                }
                else if (TaxTable::find(_taxOnItem.TaxCode).TaxType_IN == TaxType_IN::ServiceTax)
                {
                    ret = true;
                }
                break;

            case tableNum(InventQualityOrderTable):
                taxType = TaxTable::find(_taxOnItem.TaxCode).TaxType_IN;
                switch (taxType)
                {
                    case TaxType_IN::Excise:
                        if (inventQualityOrderTable.ApplyIndiaTaxes_IN == ApplyIndiaTaxes_IN::VAT)
                        {
                            ret = true;
                        }
                        break;

                    case TaxType_IN::VAT:
                        if (inventQualityOrderTable.ApplyIndiaTaxes_IN == ApplyIndiaTaxes_IN::Excise)
                        {
                            ret = true;
                        }
                        break;

                    default:
                        ret = true;
                        break;
                }
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfTransactionExists_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if transaction exists.
    /// </summary>
    /// <param name="_inventTransId">
    /// The invent transaction id.
    /// </param>
    /// <param name="_taxCode">
    /// The tax code.
    /// </param>
    /// <returns>
    /// Returns true if the transaction exist.
    /// </returns>
    boolean checkIfTransactionExists_IN(InventTransId _inventTransId, TaxCode _taxCode)
    {
        boolean                     exist;
        CustomsVendBOESubTrans_IN   customsVendBOESubTrans;

        select firstonly RecId from customsVendBOESubTrans
            where   customsVendBOESubTrans.InventTransId == _inventTransId &&
                    customsVendBOESubTrans.TaxCode       == _taxCode;
        if (customsVendBOESubTrans.RecId)
        {
            exist = true;
        }
        return exist;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIntersection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides the default implementation of an error condition which occurs when the tax groups are
    /// intersected.
    /// </summary>
    /// <param name="_found">
    /// A Boolean value that indicates whether tax codes that match were found in both the tax group and
    /// the item tax group.
    /// </param>
    /// <param name="_taxGroup">
    /// The tax group from the transaction line.
    /// </param>
    /// <param name="_taxItemGroup">
    /// The item tax group from the transaction line.
    /// </param>
    /// <returns>
    /// true if this is a supported tax scenario; otherwise, false.
    /// </returns>
    [Hookable(true)]
    protected boolean checkIntersection(boolean         _found,
                                        TaxGroup        _taxGroup,
                                        TaxItemGroup    _taxItemGroup)
    {
        // Note: there is no uniform agreement in the market regarding the behavior when one or both of _taxGroup/_taxItemGroup
        // are not specified. This behavior changed several times based on market feedback. It has then been discussed and
        // analyzed based on all of the customer feedback to date, and the decision has been made that validation should
        // pass when either _taxGroup or _taxItemGroup are blank. This behavior should not be changed without considering
        // all of the prior feedback.
        return (!_found && (_taxGroup && _taxItemGroup));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for tax parameters.
    /// </summary>
    /// <returns>The default value true.</returns>
    boolean checkParameters()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxCodesByLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for tax code values from <c>TaxWorkTrans</c> table by line.
    /// </summary>
    /// <returns>true if the tax verification was successful; otherwise, false.</returns>
    protected boolean checkTaxCodesByLine()
    {
        TmpTaxWorkTrans  taxWorkTransCopy;
        TaxTable         taxTable, taxOnTaxTable;
        TaxCode          lastTaxCode        = '';
        Counter          qtyGrossLineLimit  = 0;
        Counter          numOfCalcGross     = 0;
        // <GBR>
        TaxTable         taxSubstitutionTable;
        // <GBR>

        taxWorkTransCopy.setTmpData(taxWorkTrans);

        while select taxWorkTrans

            order by TaxCode
            where taxWorkTrans.SourceTableId    == this.sourceTableId() &&
                  taxWorkTrans.SourceRecId      == this.sourceRecId() &&
                  taxWorkTrans.IsDeleted        == NoYes::No
        {
            if (lastTaxCode != taxWorkTrans.TaxCode)
            {
                DataAreaId taxWorkTransCompany = curext();
                if(taxWorkTrans.Company)
                {
                    taxWorkTransCompany = taxWorkTrans.Company;
                }
                changecompany(taxWorkTransCompany)
                {
                    taxTable = this.getTaxTable(taxWorkTrans.TaxCode);
                }
                if (! taxTable.checkTaxTotal())
                {
                    return false;
                }

                if (taxTable.TaxOnTax &&

                    (taxTable.TaxBase   == TaxBaseType::PctPerGross ||
                     taxTable.TaxBase   == TaxBaseType::PctPerTax))
                {
                    select firstonly taxWorkTransCopy
                        where taxWorkTransCopy.SourceTableId    == this.sourceTableId() &&
                              taxWorkTransCopy.SourceRecId      == this.sourceRecId() &&
                              taxWorkTransCopy.TaxCode          == taxTable.TaxOnTax;

                    taxOnTaxTable = this.getTaxTable(taxTable.TaxOnTax);
                    if (taxWorkTransCopy &&

                        !taxOnTaxTable.TaxOnTax &&
                       (taxOnTaxTable.TaxBase == TaxBaseType::PctPerGross  ||
                        taxOnTaxTable.TaxBase == TaxBaseType::PctPerTax ))
                    {
                        return checkFailed(strFmt("@SYS24542", taxWorkTrans.TaxCode));
                    }
                }

                // <GBR>
                if (isBrazilEnabled && taxTable.TaxSubstitution_BR && this.shouldCheckTaxCodeForTaxSubstitution_BR())
                {
                    select firstonly taxWorkTransCopy

                        join taxSubstitutionTable
                        where taxSubstitutionTable.TaxCode == taxWorkTransCopy.TaxCode
                            && taxSubstitutionTable.TaxSubstitution_BR != taxTable.TaxSubstitution_BR
                            && taxSubstitutionTable.TaxSubstitution_BR != TaxSubstitutionEnum_BR::None;

                    if (taxWorkTransCopy)
                    {
                        return checkFailed("@SYS4000275");
                    }
                }
                // </GBR>

                if (taxTable.TaxLimitBase == TaxLimitBase::LineInclVAT)

                    qtyGrossLineLimit +=1;

                if (taxTable.TaxLimitBase == TaxLimitBase::UnitInclVAT)

                    qtyGrossLineLimit +=1;

                if (taxTable.TaxBase == TaxBaseType::PctPerGross && ! taxTable.TaxOnTax)

                    numOfCalcGross += 1;

                lastTaxCode = taxWorkTrans.TaxCode;
            }

            if (qtyGrossLineLimit > 1)

                return checkFailed("@SYS22542");

            if (numOfCalcGross > 1)

                return checkFailed("@SYS22543");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxCodesByOperationAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks for the tax direction and tax code values that uses the <c>OperationAccount</c> field from
    ///    <c>TaxWorkTrans</c> table.
    /// </summary>
    /// <returns>
    ///    true if the tax verification was successful; otherwise, false.
    /// </returns>

    public boolean checkTaxCodesByOperationAccount()
    {
        boolean         returnValue = true;
        MainAccount     mainAccount, nextMainAccount;
        MainAccountNum  mainAccountId;
        DataAreaId      companyId;

        if (this.taxParameters().ValidateTaxCode || this.taxParameters().MandatoryTaxDirection)

        {
            while select OperationLedgerDimension, TaxCode, Company from taxWorkTrans
                order by TaxCode
                where taxWorkTrans.HeadingRecId == headingRecId
                    && taxWorkTrans.IsDeleted == NoYes::No
            {
                // Retrieve the GL Ledger Account specified as OperationAccount in the tax record,
                //
                nextMainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(taxWorkTrans.OperationLedgerDimension);
                if (!mainAccountId ||

                    (mainAccountId != nextMainAccount.MainAccountId || companyId != taxWorkTrans.Company))
                {
                    mainAccount = null;
                    // Verify that the company exists.
                    if (xDataArea::exist(taxWorkTrans.Company))
                    {
                        companyId = taxWorkTrans.Company;
                    }
                    else
                    {
                        companyId = curext();
                    }

                    changecompany(companyId)

                    {
                        mainAccount = nextMainAccount;
                        mainAccountId = mainAccount.MainAccountId;
                    }
                }

                if (this.taxParameters().MandatoryTaxDirection && taxWorkTrans.HeadingTableId != tableNum(InventTransferJour))
                {
                    returnValue = this.checkTaxDirection(mainAccount);
                }

                if (returnValue && this.taxParameters().ValidateTaxCode)
                {
                    returnValue = Tax::checkTaxCode(mainAccount, taxWorkTrans.TaxCode);
                }

                if (!returnValue)
                {
                    break;
                }
            }
        }
        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxCodesInTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the total tax codes.
    /// </summary>
    /// <returns>true if the tax verification was successful; otherwise, false.</returns>
    protected boolean checkTaxCodesInTotal()
    {
        if (totalValidationInvoiceInclVAT.elements() > 1)
        {
            return checkFailed("@SYS22542");
        }
        if (totalValidationPctPerGross.elements() > 1)
        {
            return checkFailed("@SYS22543");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxData_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks tax data.
    /// </summary>
    /// <param name="_taxTable">
    /// The tax table.
    /// </param>
    /// <returns>
    /// Returns true if the check succeed.
    /// </returns>
    boolean checkTaxData_IN(TaxTable _taxTable)
    {
        TaxData                 taxData;
        TransTaxInformation     transTaxInformation;

        transTaxInformation = transTaxInformationHelper.getTransTaxInformation(salesPurchJournalLineLoc.SourceTableId, salesPurchJournalLineLoc.SourceRecId);

        switch (_taxTable.TaxType_IN)
        {
            case TaxType_IN::SalesTax:
                return(select firstonly taxData
                    where  taxData.TaxCode                  == _taxTable.TaxCode                          &&
                           taxData.SalesTaxFormTypes_IN     == transTaxInformation.SalesTaxFormTypes &&
                         ((taxData.TaxFromDate            <= taxWorkTrans.CalculationDate                 &&
                           taxData.TaxToDate                >= taxWorkTrans.CalculationDate)                ||
                           !taxData.TaxFromDate)).RecId != 0;

            case TaxType_IN::Excise:
                return(select firstonly taxData
                    where  taxData.TaxCode              == _taxTable.TaxCode                          &&
                           taxData.ExciseTariffCodes_IN == transTaxInformation.ExciseTariffCodes &&
                         ((taxData.TaxFromDate          <= taxWorkTrans.CalculationDate               &&
                           taxData.TaxToDate            >= taxWorkTrans.CalculationDate)              ||
                           !taxData.TaxFromDate)).RecId != 0;

            case TaxType_IN::Customs:
                switch (salesPurchJournalLineLoc.SourceTableId)
                {
                    case tableNum(PurchReqLine)      :
                    case tableNum(PurchLine)         :
                    case tableNum(SalesLine)         :
                    case tableNum(CustInvoiceLine)   :
                    case tableNum(SalesQuotationLine):
                    case tableNum(LedgerJournalTrans):

                        return(select firstonly taxData
                                where  taxData.TaxCode                   == _taxTable.TaxCode                               &&
                                       taxData.CustomsTariffCodeTable_IN == transTaxInformation.CustomsTariffCode &&
                                       ((taxData.TaxFromDate             <= taxWorkTrans.CalculationDate                    &&
                                         taxData.TaxToDate               >= taxWorkTrans.CalculationDate)                   ||
                                         !taxData.TaxFromDate)).RecId != 0;
                }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxDirection</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the value for tax direction is specified for the account.
    /// </summary>
    /// <param name="_mainAccount">
    ///    The general ledger account number for which the check will be done.
    /// </param>
    /// <returns>
    ///    true if the <c>MandatoryTaxDirection</c> field is not marked on the <c>TaxParameters</c> table and
    ///    the account has a specified tax direction; otherwise, false.
    /// </returns>

    public boolean checkTaxDirection(MainAccount _mainAccount)
    {
        boolean returnValue = true;

        MainAccountLegalEntity  mainAccountLegalEntity = MainAccountLegalEntity::findByMainAccountLegalEntity(_mainAccount.RecId, CompanyInfo::findDataArea(curext()).RecId);
        if (!mainAccountLegalEntity.TaxDirection)
        {
            returnValue = checkFailed(strFmt("@SYS113309", _mainAccount.MainAccountId));
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxTypeExcluded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the tax type is excluded in posting.
    /// </summary>
    /// <param name="_taxType">
    /// The tax type.
    /// </param>
    /// <returns>
    /// True if it is excluded; otherwise, false.
    /// </returns>
    protected boolean checkTaxTypeExcluded(TaxType_IN _taxType)
    {
        boolean result;

        //check if it is in excluding set
        if (this.parmTaxTypesExcludedInPosting().in(_taxType))
        {
            result = true;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>companyInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current company information for<c>CompanyInfo</c> table.
    /// </summary>
    /// <returns>The currenct comany information for <c>ComanyInfo</c> table.</returns>
    public CompanyInfo companyInfo()
    {
        if (!companyInfo.RecId || companyInfo.DataArea != curext())
            companyInfo = CompanyInfo::find();
        return companyInfo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertSourceTable_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the sourceTableId and SourceRecId on the tax transactions
    /// </summary>
    /// <param name="_sourceTableId">
    /// The orignal sourceTableId
    /// </param>
    /// <param name="_sourceRecId">
    /// The orignal sourceRecId
    /// </param>
    /// <returns>
    /// The coverted
    /// </returns>
    protected container convertSourceTable_IN(TableId _sourceTableId, RefRecId _sourceRecId)
    {
        return [_sourceTableId, _sourceRecId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrphanLinkInsteadPost_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Creates link <c>TaxTransGeneralJournalAccountEntry</c> with given ledger dimensions
    /// </summary>
    /// <param name="_taxTrans">
    ///   <c>TaxTrans</c> record link created for
    /// </param>
    /// <param name="_ledgerDimension">
    ///   Ledger dimension used for Tax relation
    /// </param>
    /// <param name="_operationLedgerDimension">
    ///   Ledger dimension used for Offset relation
    /// </param>
    /// <param name="_taxOffsetUseTaxLedgerDimension">
    ///   Ledger dimension used for Offset relation when tax is incoming
    /// </param>
    /// <param name="_offsetLedgerDimension">
    ///   Ledger dimension used for Use Tax relation
    /// </param>
    [Replaceable(true)]
    protected void createOrphanLinkInsteadPost_RU(TaxTrans                _taxTrans,
                                                  LedgerDimensionAccount  _ledgerDimension,
                                                  LedgerDimensionAccount  _operationLedgerDimension,
                                                  LedgerDimensionAccount  _taxOffsetUseTaxLedgerDimension,
                                                  LedgerDimensionAccount  _offsetLedgerDimension = _taxTrans.taxTrans_RU().OffsetLedgerDimension_RU)
    {
        if (!_taxTrans || _taxTrans.TaxAmount)
        {
            return;
        }

        if (! this.taxParameters().PurchTaxOnOperations || _taxTrans.TaxDirection == TaxDirection::OutgoingTax)
        {
            TaxTransGeneralJournalAccountEntry::createOrphanLink_RU(_taxTrans, _ledgerDimension, TaxTransRelationshipType::Tax);
            if (_offsetLedgerDimension)
            {
                TaxTransGeneralJournalAccountEntry::createOrphanLink_RU(_taxTrans, _offsetLedgerDimension, TaxTransRelationshipType::Offset_RU);
            }
            if (this.taxParameters().PurchTaxOnOperations &&
                ((_taxTrans.TaxDirection == TaxDirection::IncomingTax || _taxTrans.TaxDirection == TaxDirection::UseTax)
                && this.postSalesTaxReceivableAmounts()))
            {
                TaxTransGeneralJournalAccountEntry::createOrphanLink_RU(_taxTrans, _operationLedgerDimension, TaxTransRelationshipType::Offset_RU);
            }
        }

        if (_taxTrans.TaxDirection == TaxDirection::UseTax)
        {
            TaxTransGeneralJournalAccountEntry::createOrphanLink_RU(_taxTrans, _taxOffsetUseTaxLedgerDimension, TaxTransRelationshipType::UseTaxPayable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the source currency code.
    /// </summary>
    /// <returns>The source currency code.</returns>
    protected CurrencyCode currencyCode()
    {
        return sourceCurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>customsAllocate_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to update TaxAutogenerated field based on related amount.
    /// </summary>
    public void customsAllocate_IN()
    {
        TaxTable taxTable;

        while select forupdate taxWorkTrans
            where taxWorkTrans.HeadingRecId == headingRecId
               && taxWorkTrans.HeadingTableId == headingTableId
               && taxWorkTrans.TaxOrigin != TaxOrigin::TaxReversed
               && taxWorkTrans.SourceRegulateAmountCustoms_IN != 0
        exists join taxTable
            where   taxTable.TaxCode == taxWorkTrans.TaxCode
                &&  taxTable.TaxType_IN == TaxType_IN::Customs
        {
            taxWorkTrans.TaxAutogenerated = NoYes::No;
            taxWorkTrans.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>customsAllocateRegulation_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to allocate regulated amount.
    /// </summary>
    public void customsAllocateRegulation_IN()
    {
        TaxAmountCur      taxAmount;
        TaxAmountCur      taxAllocated;
        TaxAmountCur      taxTransactionCurrencyAllocated;
        RecId             taxWorkTransRecId;
        TaxWorkRegulation taxWorkRegulation;
        CustomsAmount_IN  totalCustomsAmount;
        boolean           emptyTaxAllocated;
        CustomsAmount_IN  totalCustomsAmountCur;

        if (this.isImportOrder_IN())
        {
            this.customsImportAllocateRegulation_IN();
        }
        else
        {
            while select TaxCode, TaxDirection, TaxRegulationAmountCustoms_IN, TaxRegulationAmountCur from taxWorkRegulation
            where taxWorkRegulation.HeadingTableId == this.headingTableId()
               && taxWorkRegulation.HeadingRecId == this.headingRecId()
               && taxWorkRegulation.TaxRegulationAmountCustoms_IN != 0
            {
                taxAmount                       = 0;
                taxAllocated                    = 0;
                taxTransactionCurrencyAllocated = 0;
                totalCustomsAmount              = 0;
                totalCustomsAmountCur           = 0;
                emptyTaxAllocated               = false;

                while select taxWorkTrans
                where taxWorkTrans.TaxCode      == taxWorkRegulation.TaxCode &&
                        taxWorkTrans.TaxDirection == taxWorkRegulation.TaxDirection &&
                        !taxWorkTrans.ManualInsertedTax
                {
                    if (taxWorkTrans.EximIncentiveScheme_IN != EximIncentiveScheme_IN::None)
                    {
                        totalCustomsAmount += taxWorkTrans.EximTaxAmount_IN + taxWorkTrans.EximBalanceTaxAmount_IN;
                        totalCustomsAmountCur += taxWorkTrans.EximTaxAmountCur_IN + taxWorkTrans.EximBalanceTaxAmountCur_IN;
                    }
                    else
                    {
                        totalCustomsAmount += taxWorkTrans.CustomsDuty_IN;
                        totalCustomsAmountCur += taxWorkTrans.SourceTaxAmountCur;
                    }
                }

                while select forupdate taxWorkTrans
                where taxWorkTrans.TaxCode      == taxWorkRegulation.TaxCode
                   && taxWorkTrans.TaxDirection == taxWorkRegulation.TaxDirection
                   && !taxWorkTrans.ManualInsertedTax
                {
                    if (totalCustomsAmount)
                    {
                        if (taxWorkTrans.EximIncentiveScheme_IN != EximIncentiveScheme_IN::None)
                        {
                            taxWorkTrans.SourceRegulateAmountCustoms_IN =
                            CurrencyExchangeHelper::amount((abs(taxWorkTrans.EximTaxAmount_IN) + abs(taxWorkTrans.EximBalanceTaxAmount_IN)) * taxWorkRegulation.TaxRegulationAmountCustoms_IN / totalCustomsAmount, taxWorkTrans.SourceCurrencyCode);

                            taxWorkTrans.SourceRegulateAmountCur =
                            CurrencyExchangeHelper::amount((abs(taxWorkTrans.EximTaxAmountCur_IN) + abs(taxWorkTrans.EximBalanceTaxAmountCur_IN)) * taxWorkRegulation.TaxRegulationAmountCur / totalCustomsAmountCur, taxWorkTrans.SourceCurrencyCode);
                        }
                        else
                        {
                            taxWorkTrans.SourceRegulateAmountCustoms_IN =
                            CurrencyExchangeHelper::amount(taxWorkTrans.CustomsDuty_IN * taxWorkRegulation.TaxRegulationAmountCustoms_IN / totalCustomsAmount, taxWorkTrans.SourceCurrencyCode);

                            taxWorkTrans.SourceRegulateAmountCur =
                            CurrencyExchangeHelper::amount(taxWorkTrans.SourceTaxAmountCur * taxWorkRegulation.TaxRegulationAmountCur / totalCustomsAmountCur, taxWorkTrans.SourceCurrencyCode);
                        }
                    }
                    else if (!emptyTaxAllocated)
                    {
                        taxWorkTrans.SourceRegulateAmountCustoms_IN =
                        CurrencyExchangeHelper::amount(taxWorkRegulation.TaxRegulationAmountCustoms_IN, taxWorkTrans.SourceCurrencyCode);

                        emptyTaxAllocated = true;
                    }

                    if (abs(taxWorkTrans.SourceRegulateAmountCustoms_IN) > taxAmount)
                    {
                        taxAmount         = abs(taxWorkTrans.SourceRegulateAmountCustoms_IN);
                        taxWorkTransRecId = taxWorkTrans.RecId;
                    }

                    if ((taxWorkTrans.SourceTaxAmountCur < 0 && taxWorkTrans.SourceRegulateAmountCur > 0)
                   || (taxWorkTrans.SourceTaxAmountCur > 0 && taxWorkTrans.SourceRegulateAmountCur < 0))
                    {
                        taxWorkTrans.SourceRegulateAmountCustoms_IN = -taxWorkTrans.SourceRegulateAmountCustoms_IN;
                    }

                    taxAllocated += taxWorkTrans.SourceRegulateAmountCustoms_IN;
                    taxTransactionCurrencyAllocated += taxWorkTrans.SourceRegulateAmountCur;

                    if (taxWorkTrans.SourceRegulateAmountCur != 0)
                    {
                        taxWorkTrans.TaxAutogenerated = NoYes::No;
                    }

                    if (isEximIncentiveSchemEnabled)
                    {
                        isEximAdjusted = this.calcCorrectedTaxExim_IN(taxWorkTrans);
                    }

                    taxWorkTrans.update();
                }

                if (taxAllocated != taxWorkRegulation.TaxRegulationAmountCustoms_IN)
                {
                    select firstonly forupdate taxWorkTrans
                    where taxWorkTrans.RecId == taxWorkTransRecId;

                    taxWorkTrans.SourceRegulateAmountCustoms_IN += (taxWorkRegulation.TaxRegulationAmountCustoms_IN - taxAllocated);
                    taxWorkTrans.update();
                }
                if (taxTransactionCurrencyAllocated != taxWorkRegulation.TaxRegulationAmountCur)
                {
                    select firstonly forupdate taxWorkTrans
                    where taxWorkTrans.RecId == taxWorkTransRecId;

                    taxWorkTrans.SourceRegulateAmountCur += (taxWorkRegulation.TaxRegulationAmountCur - taxTransactionCurrencyAllocated);
                    taxWorkTrans.update();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>customsImportAllocateRegulation_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to allocate regulated amount for import order.
    /// </summary>
    private void customsImportAllocateRegulation_IN()
    {
        TaxAmountCur      taxAmount;
        TaxAmountCur      taxAllocated;
        TaxAmountCur      taxTransactionCurrencyAllocated;
        RecId             taxWorkTransRecId;
        TaxWorkRegulation taxWorkRegulation;
        CustomsAmount_IN  totalCustomsAmount;
        boolean           emptyTaxAllocated;
        CustomsAmount_IN  totalCustomsAmountCur;
        boolean           isCustomsBOE = (isCustomsEnabled && this.documentStatus_IN() == DocumentStatus::BillOfEntry_IN);

        while select forupdate taxWorkTrans join TaxCode, TaxDirection, TaxRegulationAmountCustoms_IN, TaxRegulationAmountCur, HeadingTableId, HeadingRecId from taxWorkRegulation
            where taxWorkRegulation.TaxRegulationAmountCustoms_IN != 0
                && taxWorkTrans.TaxCode      == taxWorkRegulation.TaxCode
                && ((taxWorkTrans.SourceTableId == taxWorkRegulation.HeadingTableId
                        && taxWorkTrans.SourceRecId == taxWorkRegulation.HeadingRecId)
                    || (isCustomsBOE
                        && taxWorkTrans.ParentSourceTableId == taxWorkRegulation.HeadingTableId
                        && taxWorkTrans.ParentSourceRecId == taxWorkRegulation.HeadingRecId))
        {
            taxAmount                       = 0;
            taxAllocated                    = 0;
            taxTransactionCurrencyAllocated = 0;
            totalCustomsAmount              = 0;
            totalCustomsAmountCur           = 0;
            emptyTaxAllocated               = false;

            if (taxWorkTrans.EximIncentiveScheme_IN != EximIncentiveScheme_IN::None)
            {
                totalCustomsAmount += taxWorkTrans.EximTaxAmount_IN + taxWorkTrans.EximBalanceTaxAmount_IN;
                totalCustomsAmountCur += taxWorkTrans.EximTaxAmountCur_IN + taxWorkTrans.EximBalanceTaxAmountCur_IN;
            }
            else
            {
                totalCustomsAmount += taxWorkTrans.CustomsDuty_IN;
                totalCustomsAmountCur += taxWorkTrans.SourceTaxAmountCur;
            }

            if (totalCustomsAmount)
            {
                if (taxWorkTrans.EximIncentiveScheme_IN != EximIncentiveScheme_IN::None)
                {
                    taxWorkTrans.SourceRegulateAmountCustoms_IN =
                        CurrencyExchangeHelper::amount((abs(taxWorkTrans.EximTaxAmount_IN) + abs(taxWorkTrans.EximBalanceTaxAmount_IN)) * taxWorkRegulation.TaxRegulationAmountCustoms_IN / totalCustomsAmount, taxWorkTrans.SourceCurrencyCode);

                    taxWorkTrans.SourceRegulateAmountCur =
                        CurrencyExchangeHelper::amount((abs(taxWorkTrans.EximTaxAmountCur_IN) + abs(taxWorkTrans.EximBalanceTaxAmountCur_IN)) * taxWorkRegulation.TaxRegulationAmountCur / totalCustomsAmountCur, taxWorkTrans.SourceCurrencyCode);
                }
                else
                {
                    taxWorkTrans.SourceRegulateAmountCustoms_IN = taxWorkRegulation.TaxRegulationAmountCustoms_IN;

                    taxWorkTrans.SourceRegulateAmountCur = taxWorkRegulation.TaxRegulationAmountCur;
                }
            }
            else if (!emptyTaxAllocated)
            {
                taxWorkTrans.SourceRegulateAmountCustoms_IN =
                    CurrencyExchangeHelper::amount(taxWorkRegulation.TaxRegulationAmountCustoms_IN, taxWorkTrans.SourceCurrencyCode);

                emptyTaxAllocated = true;
            }

            if (abs(taxWorkTrans.SourceRegulateAmountCustoms_IN) > taxAmount)
            {
                taxAmount         = abs(taxWorkTrans.SourceRegulateAmountCustoms_IN);
                taxWorkTransRecId = taxWorkTrans.RecId;
            }

            if ((taxWorkTrans.SourceTaxAmountCur < 0 && taxWorkTrans.SourceRegulateAmountCur > 0)
                || (taxWorkTrans.SourceTaxAmountCur > 0 && taxWorkTrans.SourceRegulateAmountCur < 0))
            {
                taxWorkTrans.SourceRegulateAmountCustoms_IN = -taxWorkTrans.SourceRegulateAmountCustoms_IN;
            }

            taxAllocated += taxWorkTrans.SourceRegulateAmountCustoms_IN;
            taxTransactionCurrencyAllocated += taxWorkTrans.SourceRegulateAmountCur;

            if (taxWorkTrans.SourceRegulateAmountCur != 0)
            {
                taxWorkTrans.TaxAutogenerated = NoYes::No;
            }

            if (isEximIncentiveSchemEnabled)
            {
                isEximAdjusted = this.calcCorrectedTaxExim_IN(taxWorkTrans);
            }

            taxWorkTrans.update();

            if (taxAllocated != taxWorkRegulation.TaxRegulationAmountCustoms_IN)
            {
                select firstonly forupdate taxWorkTrans
                    where taxWorkTrans.RecId == taxWorkTransRecId;

                taxWorkTrans.SourceRegulateAmountCustoms_IN += (taxWorkRegulation.TaxRegulationAmountCustoms_IN - taxAllocated);
                taxWorkTrans.update();
            }

            if (taxTransactionCurrencyAllocated != taxWorkRegulation.TaxRegulationAmountCur)
            {
                select firstonly forupdate taxWorkTrans
                    where taxWorkTrans.RecId == taxWorkTransRecId;

                taxWorkTrans.SourceRegulateAmountCur += (taxWorkRegulation.TaxRegulationAmountCur - taxTransactionCurrencyAllocated);
                taxWorkTrans.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>customsTaxSum_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates customs tax sum.
    /// </summary>
    /// <param name="_taxWorkTrans">
    /// The temporary tax work transaction.
    /// </param>
    // Populates the class variables [which are assigned to tmpTaxWorkTrans] with pre-calculated customs duty (during BOE update), for voucher genaration during import order invoicing.
    // Also proportionates the customs duty as per invoice quantities.
    public void customsTaxSum_IN(TmpTaxWorkTrans _taxWorkTrans)
    {
        CustomsVendBOESubTrans_IN   customsVendBOESubTrans;
        CustomsVendBOETrans_IN      customsVendBOETrans;
        TaxAmount                   taxAmount;
        TaxAmount                   taxAmountCur;
        TaxAmount                   taxInCostPrice;
        TaxAmount                   taxInCostPriceMST;
        TaxAmount                   taxInCostPriceCur;
        TaxAmountCur                sourceTaxAmountCur;
        TaxAmountCur                sourceTaxAmountCurReal;
        TaxAmountCur                sourceTaxAmountRegulateCustomsCur;
        TaxAmount                   sourceTaxAmountRegulateCustomsMST;
        CustomsAmount_IN            customsDutyLoc;
        CustomsQty_IN               qty;
        RealBase                    factor;
        CurrencyCode                currencyCode;
        TaxBase                     taxQtyLoc;
        CurrencyCode                currencyCodeMST = Ledger::accountingCurrency();
        TaxAmount                   eximTaxAmountCopy;
        TaxAmount                   eximBalTaxAmountCopy;
        TaxAmount                   taxAmountCurLoc;
        TaxAmount                   balanceTaxAmountCurLoc;
        TaxAmount                   depbAmountCopy;
        TaxAmountCur                depbAmountCopyCur;

        TaxAmount                   totalTaxAmount;
        TaxAmount                   totalBalanceTaxAmount;
        TaxAmountCur                taxTotalAmountCur;
        TaxAmountCur                totalBalanceTaxAmountCur;
        EximVendBOESubTrans_IN      eximVendBOESubTrans;
        boolean                     isEximTaxRegulated;
        boolean                     isEximBalanceAmount;

        TaxBase                     taxQtyConsidered;
        boolean                     isCustomsTaxRegulated;
        VendInvoiceInfoLine         vendInvoiceInfoLineCopy;

        vendInvoiceInfoLineCopy = VendInvoiceInfoLine::findRecId(_taxWorkTrans.SourceRecId);

        if (vendInvoiceInfoLineCopy)
        {
            this.updateCustomsDutyPerExchangeRate_IN(_taxWorkTrans);
        }
        else
        {
            taxQtyLoc = abs(baseQty);//Credit note
            while select boeTransRefRecId, TaxAmount, TaxAmountCur,
                         TaxInCostPrice, TaxInCostPriceMST, TaxInCostPriceCur,
                         SourceTaxAmountCur, SourceTaxAmountCurReal,
                         SourceRegulateAmountCustomsCur_IN, SourceRegulateAmountCustoms_IN, CustomsDuty, RecId
                from customsVendBOESubTrans
                order by RecId, BillOfEntryDate
                where customsVendBOESubTrans.InventTransId == _taxWorkTrans.InventTransId
                   && customsVendBOESubTrans.TaxCode       == _taxWorkTrans.TaxCode
            {
                if (taxQtyConsidered >= abs(baseQty))
                    break;
                customsVendBOETrans = CustomsVendBOETrans_IN::findRecId(customsVendBOESubTrans.boeTransRefRecId);
                taxQtyConsidered += customsVendBOETrans.RemainingQty;
                if (abs(customsVendBOETrans.RemainingQty) > 0)
                {
                    qty = abs(customsVendBOETrans.RemainingQty) - taxQtyLoc;
                    if (qty >= 0)
                    {
                        factor = (taxQtyLoc / abs(customsVendBOETrans.BillOfEntryQty));
                    }
                    else // invoiced qty is more than the current subTrans qty
                    {
                        factor = abs(customsVendBOETrans.RemainingQty) / abs(customsVendBOETrans.BillOfEntryQty);
                        taxQtyLoc = taxQtyLoc - abs(customsVendBOETrans.RemainingQty);
                    }

                    taxAmount                   += factor * customsVendBOESubTrans.TaxAmount;
                    taxAmountCur                += factor * customsVendBOESubTrans.TaxAmountCur;
                    taxInCostPrice              += factor * customsVendBOESubTrans.TaxInCostPrice;
                    taxInCostPriceMST           += factor * customsVendBOESubTrans.TaxInCostPriceMST;
                    taxInCostPriceCur           += factor * customsVendBOESubTrans.TaxInCostPriceCur;
                    sourceTaxAmountCur          += factor * customsVendBOESubTrans.SourceTaxAmountCur;
                    sourceTaxAmountCurReal      += factor * customsVendBOESubTrans.SourceTaxAmountCurReal;
                    customsDutyLoc              += factor * customsVendBOESubTrans.CustomsDuty;

                    if (EximParameters_IN::checkParameters()
                        || EximParameters_IN::checkDEPBParameters()
                        || EximParameters_IN::checkEPCGParameters())
                    {
                        eximVendBOESubTrans = EximVendBOESubTrans_IN::findRefRecId(customsVendBOESubTrans.RecId);

                        eximTaxAmountCopy += factor * eximVendBOESubTrans.TaxAmount;
                        taxAmountCurLoc   += factor * eximVendBOESubTrans.TaxAmountCur;
                        depbAmountCopy    += factor * eximVendBOESubTrans.depbAmount;
                        depbAmountCopyCur += factor * eximVendBOESubTrans.depbAmountCur;

                        if (eximVendBOESubTrans.IncentiveScheme == EximIncentiveScheme_IN::None)
                        {
                            eximBalTaxAmountCopy     += factor * customsVendBOESubTrans.CustomsDuty;
                            totalBalanceTaxAmount    += customsVendBOESubTrans.SourceRegulateAmountCustoms_IN ?
                                                        factor * customsVendBOESubTrans.SourceRegulateAmountCustoms_IN :
                                                        factor * customsVendBOESubTrans.CustomsDuty;
                            balanceTaxAmountCurLoc   += factor * customsVendBOESubTrans.SourceTaxAmountCur;
                            totalBalanceTaxAmountCur += customsVendBOESubTrans.SourceRegulateAmountCustomsCur_IN ?
                                                        factor * customsVendBOESubTrans.SourceRegulateAmountCustomsCur_IN :
                                                        factor * customsVendBOESubTrans.SourceTaxAmountCur;
                        }
                        else
                        {
                            eximBalTaxAmountCopy   += factor * eximVendBOESubTrans.BalanceTaxAmount;
                            totalTaxAmount         += eximVendBOESubTrans.TaxCorrectedAmount ?
                                                      factor * eximVendBOESubTrans.TaxCorrectedAmount :
                                                      factor * eximVendBOESubTrans.TaxAmount;
                            balanceTaxAmountCurLoc += factor * eximVendBOESubTrans.BalanceTaxAmountCur;
                            taxTotalAmountCur      += eximVendBOESubTrans.TaxCorrectedAmountCur ?
                                                      factor * eximVendBOESubTrans.TaxCorrectedAmountCur :
                                                      factor * eximVendBOESubTrans.TaxAmountCur;

                            if (eximVendBOESubTrans.IncentiveScheme == EximIncentiveScheme_IN::EPCG)
                            {
                                totalBalanceTaxAmount    += eximVendBOESubTrans.BalanceTaxCorrectedAmount ?
                                                            factor * eximVendBOESubTrans.BalanceTaxCorrectedAmount :
                                                            factor * eximVendBOESubTrans.BalanceTaxAmount;
                                totalBalanceTaxAmountCur += eximVendBOESubTrans.BalanceTaxCorrectedAmountCur ?
                                                            factor * eximVendBOESubTrans.BalanceTaxCorrectedAmountCur :
                                                            factor * eximVendBOESubTrans.BalanceTaxAmountCur;
                            }
                            else
                            {
                                totalBalanceTaxAmount    += eximVendBOESubTrans.TaxCorrectedAmount ?
                                                            factor * eximVendBOESubTrans.BalanceTaxCorrectedAmount :
                                                            factor * eximVendBOESubTrans.BalanceTaxAmount;
                                totalBalanceTaxAmountCur += eximVendBOESubTrans.TaxCorrectedAmountCur ?
                                                            factor * eximVendBOESubTrans.BalanceTaxCorrectedAmountCur :
                                                            factor * eximVendBOESubTrans.BalanceTaxAmountCur;
                            }
                        }

                        if (eximVendBOESubTrans.TaxCorrectedAmount
                            || eximVendBOESubTrans.BalanceTaxCorrectedAmount)
                        {
                            isEximTaxRegulated = true;
                        }
                        if (eximVendBOESubTrans.BalanceTaxAmountCur
                            || eximVendBOESubTrans.BalanceTaxAmount)
                        {
                            isEximBalanceAmount = true;
                        }
                    }

                    if (customsVendBOESubTrans.SourceRegulateAmountCustoms_IN)
                    {
                        sourceTaxAmountRegulateCustomsMST += factor * customsVendBOESubTrans.SourceRegulateAmountCustoms_IN;
                        isCustomsTaxRegulated = true;
                    }
                    else
                    {
                        sourceTaxAmountRegulateCustomsMST += factor * customsVendBOESubTrans.CustomsDuty;
                    }

                    if (customsVendBOESubTrans.SourceRegulateAmountCustomsCur_IN)
                    {
                        sourceTaxAmountRegulateCustomsCur += factor * customsVendBOESubTrans.SourceRegulateAmountCustomsCur_IN;
                        isCustomsTaxRegulated = true;
                    }
                    else
                    {
                        sourceTaxAmountRegulateCustomsCur += factor * customsVendBOESubTrans.SourceTaxAmountCur;
                    }
                }
            }
            select sum(TaxBaseAmountMST),
                   sum(TaxBaseQty),
                   sum(SourceTaxBaseAmountCur),
                   sum(TaxBaseAmountCur)
                from tmpTax
                where tmpTax.TaxCode == _taxWorkTrans.TaxCode;

            currencyCode                    = TaxTable::find(_taxWorkTrans.TaxCode).TaxCurrencyCode;
            taxBaseAmountCalc               = CurrencyExchangeHelper::amount(tmpTax.TaxBaseAmountMST, currencyCodeMST);
            taxBaseQtyCalc                  = tmpTax.TaxBaseQty;
            taxBaseAmountCalcSourceCur      = CurrencyExchangeHelper::amount(tmpTax.SourceTaxBaseAmountCur, sourceCurrencyCode);
            taxBaseAmountCalcCur            = CurrencyExchangeHelper::amount(tmpTax.TaxBaseAmountCur, currencyCode);
            taxAmountCalc                   = taxAmount;
            taxAmountCalcCur                = taxAmountCur;
            taxInCostPriceCalc              = taxInCostPrice;
            taxInCostPriceMSTCalc           = taxInCostPriceMST;
            taxInCostPriceCurCalc           = taxInCostPriceCur;
            taxAmountCalcSourceCur          = CurrencyExchangeHelper::amount(sourceTaxAmountCur, sourceCurrencyCode);
            taxAmountCalcSourceCurReal      = CurrencyExchangeHelper::amount(sourceTaxAmountCurReal, sourceCurrencyCode);

            if (isCustomsTaxRegulated)
            {
                sourceRegulateAmountCustomsCur  = CurrencyExchangeHelper::amount(sourceTaxAmountRegulateCustomsCur, sourceCurrencyCode);
                sourceRegulateAmountCustomsMST  = CurrencyExchangeHelper::amount(sourceTaxAmountRegulateCustomsMST, sourceCurrencyCode);
            }
            else
            {
                sourceRegulateAmountCustomsCur  = 0;
                sourceRegulateAmountCustomsMST  = 0;
            }

            customsTaxAmountCalc            = CurrencyExchangeHelper::amount(customsDutyLoc, currencyCodeMST);

            if (EximParameters_IN::checkParameters()
                || EximParameters_IN::checkDEPBParameters()
                || EximParameters_IN::checkEPCGParameters())
            {
                eximTaxAmountCalc = CurrencyExchangeHelper::amount(eximTaxAmountCopy, currencyCodeMST);
                eximTaxAmountCur  = CurrencyExchangeHelper::amount(taxAmountCurLoc, sourceCurrencyCode);
                depbAmountCalc    = CurrencyExchangeHelper::amount(depbAmountCopy, currencyCodeMST);
                depbAmountCalcCur = CurrencyExchangeHelper::amount(depbAmountCopyCur, sourceCurrencyCode);

                if (isEximBalanceAmount)
                {
                    eximBalanceTaxAmtCalc   = CurrencyExchangeHelper::amount(eximBalTaxAmountCopy, currencyCodeMST);
                    eximBalanceTaxAmountCur = CurrencyExchangeHelper::amount(balanceTaxAmountCurLoc, sourceCurrencyCode);
                }
                else
                {
                    eximBalanceTaxAmtCalc   = 0;
                    eximBalanceTaxAmountCur = 0;
                }
                if (isEximTaxRegulated)
                {
                    eximTotalTaxAmount           = CurrencyExchangeHelper::amount(totalTaxAmount, sourceCurrencyCode);
                    eximTotalBalanceTaxAmount    = CurrencyExchangeHelper::amount(totalBalanceTaxAmount, sourceCurrencyCode);
                    eximTotalTaxAmountCur        = CurrencyExchangeHelper::amount(taxTotalAmountCur, sourceCurrencyCode);
                    eximTotalBalanceTaxAmountCur = CurrencyExchangeHelper::amount(totalBalanceTaxAmountCur, sourceCurrencyCode);
                }
                else
                {
                    eximTotalTaxAmount           = 0;
                    eximTotalBalanceTaxAmount    = 0;
                    eximTotalTaxAmountCur        = 0;
                    eximTotalBalanceTaxAmountCur = 0;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultSign</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the default sign.
    /// </summary>
    /// <returns>The default sign.</returns>
    Counter defaultSign()
    {
        return 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defermentPeriodic_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process and post Vat deferment.
    /// </summary>
    /// <param name="_vatDefermentBal">
    /// This buffer is used to calculate vat deferment.
    /// </param>
    /// <param name="_vatDefermentBalLine">
    /// This buffer is used to calculate vat deferment.
    /// </param>
    /// <param name="_ledgerPostingController">
    /// This buffer is used to calculate vat deferment.
    /// </param>
    /// <exception cref="Exception::Error">
    /// If number sequence is not given then this method will throw the error.
    /// </exception>
    public void defermentPeriodic_IN(TmpVATDefermentBal_IN      _vatDefermentBal,
                                     TmpVATDefermentBalLine_IN  _vatDefermentBalLine,
                                     LedgerPostingController    _ledgerPostingController)
    {
        VATDefermentTransaction_IN      vatDeferment;
        TaxTrans                        taxTrans,taxTransOrig;
        TaxTrans                        taxTransLoc;
        TaxLedgerAccounts_IN            taxLedgerAccounts;
        TaxAmount                       taxAmountCur;
        TaxAmount                       amountBasis;
        TaxTrans_IN                     taxTransLocal,taxTransLocalOrig;
        TaxTrans_IN                     taxTransCopy;
        Voucher                         voucherToPost;
        LedgerVoucherObject             ledgerVoucherObject;
        DefermentScheduleTransLines_IN  defermentLines;
        CurrencyExchangeHelper          exchangeRateHelper;
        container                       deferredRecords;
        container                       recRecords;
        int                             defCounter;
        int                             recCounter;
        int                             deferred;
        int                             recoverable;
        int                             loop;
        int                             defermentLength;
        VendInvoiceTrans                vendInvoiceTrans;
        container                       taxes;
        VATPeriodicVouchers_IN          vatPeriodicVoucher;
        boolean                         createVoucher;
        boolean                         ledger;
        container                       taxTransLines;
        int                             taxLines;
        RecId                           taxTransRecId;
        LedgerDimensionAccount          defaultLedgerDimensionAccount;

        TaxTransGeneralJournalAccountEntry  taxTransGeneralJournalAccountEntry;
        NumberSequenceCode                  numberSequenceCode;

        defCounter = 1;
        recCounter = 1;
        defermentLength = 1;
        taxLines = 1;

        exchangeRateHelper = CurrencyExchangeHelper::newLedger(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));
        ttsbegin;
        while select * from vatDeferment
            where vatDeferment.DefermentDate    <= _vatDefermentBalLine.To
               && vatDeferment.Mark             == NoYes::Yes
        {
            while select taxTransLoc
                where taxTransLoc.Voucher       == vatDeferment.Voucher
                   && taxTransLoc.TransDate     == vatDeferment.Date
                   && taxTransLoc.JournalNum    == (vatDeferment.PurchaseOrder ? '' : vatDeferment.JounrnalNumber)
                   && taxTransLoc.InventTransId == vatDeferment.InventTransId
                   && taxTransLoc.TaxOrigin     == TaxOrigin::Tax
                   && taxTransLoc.TaxPeriod     == _vatDefermentBal.TaxPeriod
            {
                select taxTransLocal
                    where taxTransLocal.RefRecId == taxTransLoc.RecId;

                if (TaxTable::find(taxTransLoc.TaxCode).TaxType_IN == TaxType_IN::VAT)
                {
                    taxAmountCur = 0;
                    taxTrans.data(taxTransLoc);
                    taxTransCopy.data(taxTransLocal);

                    if (TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTransLocal.TaxLedgerAccountGroup,TaxAccountCode_IN::Table,_vatDefermentBal.TaxIdentificationNumber))
                    {
                        taxLedgerAccounts = TaxLedgerAccounts_IN::findByTaxAccounts(taxTransLocal.TaxLedgerAccountGroup,
                                                                                    TaxAccountType_IN::VATRecoverableAccount,
                                                                                    taxTransLocal.TaxComponentTable);
                    }

                    if (!taxLedgerAccounts)
                    {
                        select firstonly taxLedgerAccounts
                            where taxLedgerAccounts.TaxLedgerAccountSetup == taxTransLocal.TaxLedgerAccountGroup
                               && taxLedgerAccounts.AccountType           == TaxAccountType_IN::VATRecoverableAccount
                               && taxLedgerAccounts.TaxComponentTable     == taxTransLocal.TaxComponentTable;
                    }

                    defaultLedgerDimensionAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(taxLedgerAccounts.LedgerDimension);

                    defermentLines = DefermentScheduleTransLines_IN::find(vatDeferment.RefRecId);
                    sourceCurrencyCode = taxTransLoc.SourceCurrencyCode;

                    taxTransGeneralJournalAccountEntry = TaxTransGeneralJournalAccountEntry::getLedgerDimensionForTaxTrans_IN(
                                                                taxTransLoc.RecId,
                                                                TaxTransRelationshipType::Tax,
                                                                fieldStr(TaxTrans_IN, DeferredLedgerDimension));

                    if (taxTransLoc.Source == TaxModuleType::Voucher)
                    {
                        amountBasis = vatDeferment.DeferredAmount < 0
                                      ? -defermentLines.Credit
                                      : defermentLines.Debit;
                    }
                    else
                    {
                        select InventRefTransId from vendInvoiceTrans
                            where vendInvoiceTrans.InventTransId == taxTransLoc.InventTransId;

                        if (vendInvoiceTrans.InventRefTransId)
                        {
                            amountBasis = -defermentLines.Credit;

                            select RecId from taxTransOrig
                                where taxTransOrig.InventTransId == vendInvoiceTrans.InventRefTransId
                                   && taxTransOrig.TaxCode       == taxTransLoc.TaxCode;

                            taxTransLocalOrig = TaxTrans_IN::findRefRecId(taxTransOrig.RecId);

                            taxAmountCur = CurrencyExchangeHelper::amount(taxTransLocalOrig.PostedTaxAmout / DefermentScheduleTrans_IN::find(vatDeferment.FatherRecId).vatDefermentAmount * amountBasis, sourceCurrencyCode);
                        }
                        else
                        {
                            amountBasis = defermentLines.Debit;
                        }
                    }

                    if (!taxAmountCur)
                    {
                        taxAmountCur = CurrencyExchangeHelper::amount(taxTransLocal.PostedTaxAmout / vatDeferment.DeferredAmount * amountBasis, sourceCurrencyCode)   ;
                    }

                    if (!taxTransLoc.TaxAutogenerated)
                    {
                        taxTrans.SourceRegulateAmountCur = -taxAmountCur;
                    }
                    else
                    {
                        taxTrans.SourceTaxAmountCur = -taxAmountCur;
                    }

                    taxTrans.TaxAmount      = -taxAmountCur;
                    taxTrans.TransDate      = _vatDefermentBal.TransDate;
                    taxTrans.Voucher        = '';
                    taxTrans.JournalNum     = '';
                    taxTrans.InventTransId  = '';
                    taxTrans.TaxInCostPrice = 0;
                    taxTrans.TaxInCostPriceCur = 0;
                    taxTrans.TaxInCostPriceMST = 0;
                    taxTrans.TaxInCostPriceRegulated = 0;
                    taxTrans.insert();

                    taxTransLines = conPoke(taxTransLines,taxLines,taxTrans.RecId);
                    taxLines ++ ;

                    taxTransCopy.RefRecId       = taxTrans.RecId;
                    taxTransCopy.TransDate      = _vatDefermentBal.TransDate;
                    taxTransCopy.PostedTaxAmout = taxTrans.TaxAmount;
                    taxTransCopy.DeferredLedgerDimension = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(taxTransGeneralJournalAccountEntry.LedgerDimension);
                    taxTransCopy.insert();

                    TaxTransGeneralJournalAccountEntry::createVATDeferredEntry_IN(taxTransGeneralJournalAccountEntry.LedgerDimension, taxTrans.RecId);

                    if (!taxTrans.TaxAutogenerated)
                    {
                        taxTrans.SourceRegulateAmountCur = taxAmountCur;
                    }
                    else
                    {
                        taxTrans.SourceTaxAmountCur = taxAmountCur;
                    }

                    taxTrans.TaxAmount      = taxAmountCur;
                    taxTrans.TransDate      = _vatDefermentBal.TransDate;
                    taxTrans.Voucher        = '';
                    taxTrans.JournalNum     = '';
                    taxTrans.InventTransId  = '';
                    taxTrans.TaxInCostPrice = 0;
                    taxTrans.TaxInCostPriceCur = 0;
                    taxTrans.TaxInCostPriceMST = 0;
                    taxTrans.TaxInCostPriceRegulated = 0;
                    taxTrans.insert();

                    taxTransLines = conPoke(taxTransLines,taxLines,taxTrans.RecId);
                    taxLines ++ ;

                    taxTransCopy.RefRecId                   = taxTrans.RecId;
                    taxTransCopy.TaxTransVATRefRecId        = taxTransLoc.RecId;
                    taxTransCopy.vatDefLineRefRecId         = defermentLines.RecId;
                    taxTransCopy.PostedTaxAmout             = taxTrans.TaxAmount;
                    taxTransCopy.TransDate                  = _vatDefermentBal.TransDate;
                    taxTransCopy.RecoverableLedgerDimension = taxLedgerAccounts.LedgerDimension;
                    taxTransCopy.DeferredLedgerDimension    = 0;
                    taxTransCopy.insert();

                    TaxTransGeneralJournalAccountEntry::createVATDeferredEntry_IN(defaultLedgerDimensionAccount, taxTrans.RecId);

                    taxes = defermentLines.TransferDetails;
                    if (conLen(taxes))
                    {
                        defermentLength = conLen(defermentLines.TransferDetails) ;
                    }
                    if (!conFind(taxes,taxTransLoc.RecId))
                    {
                        taxes = conPoke(taxes,defermentLength+1,taxTransLoc.RecId);
                        defermentLength ++;
                    }
                }

                defermentLines = DefermentScheduleTransLines_IN::find(defermentLines.RecId, true);
                if (defermentLines)
                {
                    if (taxAmountCur > 0)
                    {
                        defermentLines.TransferDebitAmount += taxAmountCur;
                    }
                    else
                    {
                        defermentLines.TransferCrebitAmount += abs(taxAmountCur);
                    }
                    defermentLines.TransferDetails = taxes;
                    if (defermentLines.TransferDebitAmount  == CurrencyExchangeHelper::amount(defermentLines.Debit, taxTransLoc.CurrencyCode) &&
                        defermentLines.TransferCrebitAmount == CurrencyExchangeHelper::amount(defermentLines.Credit, taxTransLoc.CurrencyCode))
                    {
                        defermentLines.Transferred = NoYes::Yes;
                    }
                    defermentLines.update();
                }

                deferred    =  conFind(deferredRecords,LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(taxTransGeneralJournalAccountEntry.LedgerDimension));

                recoverable =  conFind(recRecords, defaultLedgerDimensionAccount);

                if (deferred)
                {
                    deferredRecords = conPoke(deferredRecords,deferred+1,(conPeek(deferredRecords,deferred+1) + taxAmountCur));
                }
                else
                {
                    deferredRecords = conPoke(deferredRecords, defCounter, taxTransGeneralJournalAccountEntry.LedgerDimension, taxAmountCur);
                    defCounter         = defCounter + 2;
                }
                if (recoverable)
                {
                    recRecords = conPoke(recRecords,recoverable+1,(conPeek(recRecords,recoverable+1) + taxAmountCur));
                }
                else
                {
                    recRecords      = conPoke(recRecords, recCounter,defaultLedgerDimensionAccount,taxAmountCur);
                    recCounter         = recCounter + 2;
                }
            }
        }

        this.getPostingType_IN(TaxType_IN::VAT);

        for (loop = 1 ; loop <= conLen(deferredRecords); loop ++)
        {
            taxAmountCur = conPeek(deferredRecords,loop+1);
            if (taxAmountCur)
            {
                if (!createVoucher)
                {
                    numberSequenceCode = NumberSequenceTable::find(NumberSeqReference::findReference(extendedTypeNum(DefermentVoucher_IN)).NumberSequenceId).NumberSequence;

                    if (numberSequenceCode)
                    {
                        temporaryLedgerPostingJournal = LedgerVoucher::newLedgerPost(DetailSummary::Summary,SysModule::None,numberSequenceCode);
                        ledger = true;
                        voucherToPost = NumberSeq::newGetVoucherFromCode(numberSequenceCode).voucher();
                    }
                    else
                    {
                        for (taxLines = 1 ; taxLines <= conLen(taxTransLines) ; taxLines ++)
                        {
                            taxTransRecId = conPeek(taxTransLines,taxLines);
                            while select RefRecId from vatDeferment
                                where vatDeferment.Date <= _vatDefermentBalLine.To
                                   && vatDeferment.Mark == NoYes::Yes
                            {
                                defermentLines = DefermentScheduleTransLines_IN::find(vatDeferment.RefRecId,true);
                                defermentLines.TransferCrebitAmount = 0;
                                defermentLines.TransferDebitAmount  = 0;
                                defermentLines.TransferDetails      = conNull();
                                defermentLines.Transferred          = NoYes::No;
                                defermentLines.doUpdate();
                            }
                            delete_from taxTrans
                                    where taxTrans.RecId == taxTransRecId;
                        }

                        throw error (strFmt("@SYS53911","@GLS6044","@SYS24097"));
                    }

                    ledgerVoucherObject = LedgerVoucherObject::newVoucher(voucherToPost,_vatDefermentBal.TransDate,SysModule::Ledger);
                    _ledgerPostingController.setJournal(temporaryLedgerPostingJournal);
                    _ledgerPostingController.addReference(ledgerVoucherObject);

                    vatPeriodicVoucher.TaxIdentificationNumber = _vatDefermentBal.TaxIdentificationNumber;
                    vatPeriodicVoucher.TaxPeriod               = _vatDefermentBal.TaxPeriod;
                    vatPeriodicVoucher.FromDate                = _vatDefermentBalLine.From;
                    vatPeriodicVoucher.ToDate                  = _vatDefermentBalLine.To;
                    vatPeriodicVoucher.Voucher                 = voucherToPost;
                    vatPeriodicVoucher.insert();
                }

                exchangeRateHelper.parmExchangeRate1(exchRate);
                exchangeRateHelper.parmExchangeRate2(exchRateSecond);
                exchangeRateHelper.parmExchangeDate(taxTrans.TransDate);
                this.post(_ledgerPostingController, taxTrans, -taxAmountCur, 0, exchangeRateHelper,conPeek(deferredRecords, loop),0,0);
            }
            loop ++;
            createVoucher = true;
        }
        for (loop = 1 ; loop <= conLen(recRecords) ; loop ++)
        {
            taxAmountCur = conPeek(recRecords,loop+1);
            if (taxAmountCur)
            {
                this.post(_ledgerPostingController, taxTrans, taxAmountCur, 0, exchangeRateHelper,conPeek(recRecords, loop),0,0);
            }
            loop ++;
            createVoucher = true;
        }

        for (taxLines = 1 ; taxLines <= conLen(taxTransLines) ; taxLines ++)
        {
            taxTransRecId = conPeek(taxTransLines,taxLines);

            if (!_vatDefermentBal.TransDate || !voucherToPost)
            {
                while select RefRecId from vatDeferment
                    where vatDeferment.Date <= _vatDefermentBalLine.To
                       && vatDeferment.Mark == NoYes::Yes
                {
                    defermentLines = DefermentScheduleTransLines_IN::find(vatDeferment.RefRecId,true);
                    defermentLines.TransferCrebitAmount = 0;
                    defermentLines.TransferDebitAmount  = 0;
                    defermentLines.TransferDetails      = conNull();
                    defermentLines.Transferred          = NoYes::No;
                    defermentLines.doUpdate();
                }

                delete_from taxTrans

                        where taxTrans.RecId == taxTransRecId;
            }
            else
            {
                select forupdate taxTrans
                    where taxTrans.RecId == taxTransRecId;
                taxTrans.Voucher = voucherToPost;
                taxTrans.update();

                update_recordset taxTransCopy
                    setting Voucher = voucherToPost
                    where taxTransCopy.RefRecId ==  taxTransRecId;
            }
        }

        if (ledger)
        {
            temporaryLedgerPostingJournal.parmIsVATDeferment_IN(true);
            temporaryLedgerPostingJournal.end();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineAccountType_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine account type.
    /// </summary>
    /// <param name="_taxTable">
    /// The tax table.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxAccountType_IN</c> class.
    /// </returns>
    public TaxAccountType_IN determineAccountType_IN(TaxTable   _taxTable)
    {
        TaxAccountType_IN    taxAccountType;
        ;

        taxAccountType = this.determineTaxAccountType_IN(taxModuleType, _taxTable);

        return taxAccountType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDirectImportBase_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the direct import base amount.
    /// </summary>
    /// <param name = "_baseAmount">The base amount.</param>
    /// <returns>The determined base amount.</returns>
    protected TaxBase determineDirectImportBase_BR(TaxBase _baseAmount)
    {
        return _baseAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDirection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the tax direction.
    /// </summary>
    /// <param name = "_taxGroupData">The record of <c>TaxGroupData</c>.</param>
    /// <returns>The determined tax direction.</returns>
    protected TaxDirection determineDirection(TaxGroupData   _taxGroupData)
    {
        TaxDirection    taxDirection;
        ;

        changecompany(this.getCompany())
        {
            taxDirection = Tax::determineTaxDirection(taxModuleType, _taxGroupData);
        }

        return taxDirection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReasonData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the reason reference table with company and reference using current object state and returns container with reason data.
    /// </summary>
    /// <returns>
    ///    Container with 2 elements - Reason Code and Reason Comment respectively.
    /// </returns>
    protected container getReasonData()
    {
        return FinancialReasonGlobalFeatureHelper::getReasonDataByTableRef(
            this.reasonTableRefRecId(),
            this.getCompany()
            );
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReasonTableRefRecIdBeingCalculated</Name>
				<Source><![CDATA[
    protected void setReasonTableRefRecIdBeingCalculated(ReasonRefRecID _priorityReasonRefRecID, ReasonRefRecID _secondaryReasonRefRecID = 0)
    {
        reasonTableRefRecIdBeingCalculated = _priorityReasonRefRecID
            ? _priorityReasonRefRecID
            : _secondaryReasonRefRecID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineFinalUserBase_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sums IPI amount in ICMS tax base.
    /// </summary>
    /// <param name="_baseAmount">
    /// Base amount for final user calculation
    /// </param>
    /// <returns>
    /// ICMS tax base including IPI.
    /// </returns>
    protected TaxBase determineFinalUserBase_BR(TaxBase _baseAmount)
    {
        TaxValue              ipIvalue;
        TaxBase               baseAmount = _baseAmount;
        TaxData               ipiTaxData;

        TaxData ipiTaxData(TableId _tableId, RecId _recId)
        {
            TmpTaxWorkTrans      localTmpTaxWorkTrans;
            TaxData              localTaxData;
            TaxationCodeTable_BR taxationCodeTable;
            TaxFiscalValue_BR    fiscalValue;

            localTmpTaxWorkTrans.setTmpData(taxWorkTrans);

            // Select the IPI line
            select firstonly localTmpTaxWorkTrans
                    where localTmpTaxWorkTrans.TaxType_BR == TaxType_BR::IPI
                        && localTmpTaxWorkTrans.SourceTableId == _tableId
                        && localTmpTaxWorkTrans.SourceRecId == _recId;

            taxationCodeTable = this.determineTaxationCode_BR(localTmpTaxWorkTrans.TaxCode,
                                                              TaxOnItem::find(localTmpTaxWorkTrans.TaxItemGroup, localTmpTaxWorkTrans.TaxCode),
                                                              TaxGroupData::find(localTmpTaxWorkTrans.TaxGroup, localTmpTaxWorkTrans.TaxCode));

            fiscalValue = this.determineFiscalValue_BR(taxationCodeTable,
                                                       localTmpTaxWorkTrans.ExemptTax,
                                                       TaxOnItem::find(localTmpTaxWorkTrans.TaxItemGroup, localTmpTaxWorkTrans.TaxCode).WithoutTaxCredit_BR);

            if (fiscalValue != TaxFiscalValue_BR::WithoutCreditDebitExempt)
            {
                localTaxData = TaxData::find(localTmpTaxWorkTrans.TaxCode, localTmpTaxWorkTrans.TransDate, _baseAmount);
            }

            return localTaxData;
        }

        if (taxWorkTrans.TaxType_BR == TaxType_BR::ICMS || taxWorkTrans.TaxType_BR == TaxType_BR::ICMSDiff)
        {
            ipiTaxData = ipiTaxData(taxWorkTrans.SourceTableId, taxWorkTrans.SourceRecId);

            if (ipiTaxData.TaxReductionPct_BR)
            {
                if (taxWorkTrans.FiscalValue_BR != TaxFiscalValue_BR::WithoutCreditDebitExempt)
                {
                    ipIvalue = (baseAmount * (1 - ipiTaxData.TaxReductionPct_BR/100)) * ipiTaxData.TaxValue/100;
                }
                else
                {
                    ipIvalue = 0;
                }
            }
            else
            {
                ipIvalue = baseAmount * (ipiTaxData.TaxValue/100);
            }

            baseAmount += ipIvalue;
        }

        return baseAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineFiscalValue_BR</Name>
				<Source><![CDATA[
    private TaxFiscalValue_BR determineFiscalValue_BR(TaxationCodeTable_BR _taxationCodeTable, boolean _exemptTax, boolean _withoutTaxCredit)
    {
        TaxFiscalValue_BR fiscalValue_BR;

        if (_taxationCodeTable)
        {
            fiscalValue_BR = _taxationCodeTable.FiscalValue;
        }
        else
        {
            if (_exemptTax)
            {
                fiscalValue_BR = TaxFiscalValue_BR::WithoutCreditDebitExempt;
            }
            else if (_withoutTaxCredit)
            {
                fiscalValue_BR = TaxFiscalValue_BR::WithoutCreditDebitOther;
            }
            else
            {
                fiscalValue_BR = TaxFiscalValue_BR::WithCreditDebit;
            }
        }

        return fiscalValue_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineSign_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the tax amount by sign.
    /// </summary>
    /// <param name = "_baseAmount">The base amount.</param>
    /// <returns>The determined base amount.</returns>
    protected TaxBase determineSign_BR(TaxBase       _baseAmount)
    {
        if (TaxTable::find(taxWorkTrans.TaxCode).RetainedTax_BR)
            _baseAmount = _baseAmount * -1;

        return _baseAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineTaxAccountType_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to determine the tax account type.
    /// </summary>
    /// <param name="_taxModuleType">
    /// A tax module type.
    /// </param>
    /// <param name="_taxTable">
    /// A buffer of <c>TaxTable</c> table.
    /// </param>
    /// <param name="_taxAccountType">
    /// A tax account type.
    /// </param>
    /// <returns>
    /// Returns the tax account type.
    /// </returns>
    /// <remarks>
    /// Add a post-method handler for returning the right value when extending the <c>TaxModuleType</c> enumeration.
    /// </remarks>
    public  TaxAccountType_IN determineTaxAccountType_IN(
        TaxModuleType      _taxModuleType,
        TaxTable           _taxTable,
        TaxAccountType_IN  _taxAccountType = TaxAccountType_IN::SalesTaxPayableAccount)
    {
        TaxAccountType_IN                   taxAccountType;
        PurchLine                           purchLine;
        PurchLine_IN                        purchLine_IN;
        SalesLine                           salesLineLoc;
        VendInvoiceInfoLine                 vendInvoiceInfoLine;
        SalesReturn_IN                      salesReturn = new SalesReturn_IN();
        TransTaxInformation                 transTaxInformation;

        transTaxInformation = transTaxInformationHelper.getTransTaxInformation(taxWorkTrans.SourceTableId, taxWorkTrans.SourceRecId);

        switch (_taxModuleType)
        {
            case TaxModuleType::Sales,
                 TaxModuleType::SalesInvoice,
                 TaxModuleType::CustInterestNote,
                 TaxModuleType::CustCollectionLetter,
                 TaxModuleType::Project,
                 TaxModuleType::ProjectInvoice,
                 TaxModuleType::FreeTxtInvoice :

                if (_taxTable.TaxType_IN == TaxType_IN::SalesTax)
                {
                    salesLineLoc = SalesLine::findRecId(salesPurchJournalLineLoc.SourceRecId);
                    if ((salesLineLoc.SalesType == SalesType::ReturnItem
                        && ReturnDispositionCode::find(salesLineLoc.ReturnDispositionCodeId).DispositionAction == DispositionAction::CreditOnly)
                        ||
                        salesReturn.isSalesReturn(salesLineLoc))
                    {
                        taxAccountType = TaxAccountType_IN::SalesTaxExpenseAccount;
                    }
                    else
                    {
                        taxAccountType = TaxAccountType_IN::SalesTaxPayableAccount;
                    }
                }
                if (_taxTable.TaxType_IN == TaxType_IN::VAT)
                {
                    salesLineLoc = SalesLine::findRecId(salesPurchJournalLineLoc.SourceRecId);
                    if ((salesLineLoc.SalesType == SalesType::ReturnItem
                        && ReturnDispositionCode::find(salesLineLoc.ReturnDispositionCodeId).DispositionAction == DispositionAction::CreditOnly)
                        ||
                        salesReturn.isSalesReturn(salesLineLoc))
                    {
                        taxAccountType = TaxAccountType_IN::VATExpenseAccount;
                    }
                    else
                    {
                        taxAccountType = TaxAccountType_IN::VATPayableAccount;
                    }
                }
                if (_taxTable.TaxType_IN == TaxType_IN::Customs)
                {
                    taxAccountType = TaxAccountType_IN::CustomsExportDutyPayableAccount;
                }
                if (_taxTable.TaxType_IN == TaxType_IN::ServiceTax)
                {
                    taxAccountType = TaxAccountType_IN::ServiceTaxPayableAccount;
                }
                break;

            case TaxModuleType::Purch,
                 TaxModuleType::PurchInvoice  :

                if (_taxTable.TaxType_IN == TaxType_IN::SalesTax)
                {
                    taxAccountType = TaxAccountType_IN::SalesTaxExpenseAccount;
                }
                if (_taxTable.TaxType_IN == TaxType_IN::VAT)
                {
                    taxAccountType = TaxAccountType_IN::VATPayableAccount;

                    switch (taxWorkTrans.SourceTableId)
                    {
                        case tableNum(PurchLine):
                            purchLine = PurchLine::findRecId(taxWorkTrans.SourceRecId);
                            purchLine_IN = purchLine.purchLine_IN();

                            if (purchLine.LineAmount > 0)
                            {
                                taxAccountType = transTaxInformation.VATGoodsType == VATGoodsType_IN::Input
                                                    ? TaxAccountType_IN::VATRecoverableAccount
                                                    : TaxAccountType_IN::VATDeferredAccount;
                            }
                            else if (purchLine.LineAmount < 0
                                     && (! purchLine.InventRefId
                                         || (purchLine.InventRefId
                                             && !TaxTrans_IN::isTaxSettledForTransaction(tableNum(VendInvoiceTrans), VendInvoiceTrans::findInventTransId(purchLine.InventRefTransId).RecId))))
                            {
                                taxAccountType = transTaxInformation.VATGoodsType == VATGoodsType_IN::Input
                                                 ? TaxAccountType_IN::VATRecoverableAccount
                                                 : TaxAccountType_IN::VATDeferredAccount;
                            }
                            break;

                        case tableNum(VendInvoiceInfoLine):
                            vendInvoiceInfoLine = VendInvoiceInfoLine::findRecId(taxWorkTrans.SourceRecId);

                            if (vendInvoiceInfoLine.LineAmount > 0 )
                            {
                                taxAccountType = transTaxInformation.VATGoodsType == VATGoodsType_IN::Input
                                                 ? TaxAccountType_IN::VATRecoverableAccount
                                                 : TaxAccountType_IN::VATDeferredAccount;
                            }
                            else if (! vendInvoiceInfoLine.isNonPO())
                            {
                                purchLine = PurchLine::findRecId(VendInvoiceInfoLine::findRecId(taxWorkTrans.SourceRecId).PurchLineRecId);

                                if (purchLine.LineAmount < 0
                                     && (! purchLine.InventRefId
                                         || (purchLine.InventRefId
                                             && !TaxTrans_IN::isTaxSettledForTransaction(tableNum(VendInvoiceTrans), VendInvoiceTrans::findInventTransId(purchLine.InventRefTransId).RecId))))
                                {
                                    taxAccountType = transTaxInformation.VATGoodsType == VATGoodsType_IN::Input
                                                     ? TaxAccountType_IN::VATRecoverableAccount
                                                     : TaxAccountType_IN::VATDeferredAccount;
                                }
                            }
                            break;

                        case tableNum(InventQualityOrderTable):
                            if (isExciseEnabled || isVATEnabled)
                            {
                                taxAccountType = TaxAccountType_IN::VATRecoverableAccount;
                            }
                            break;

                        default:
                            break;
                    }
                }

                if (_taxTable.TaxType_IN == TaxType_IN::Customs)
                {
                    taxAccountType = TaxAccountType_IN::CustomsImportDutyExpenseAccount;
                }
                break;

            case TaxModuleType::Voucher :
                if (this is TaxCalculationJournal
                    && salesPurchJournalLineLoc)
                {
                    taxAccountType = this.getAccountTypeForJournal_IN(_taxTable);
                }
                break;

            case TaxModuleType::StockTransfer_IN :

                if (_taxTable.TaxType_IN == TaxType_IN::VAT)
                {
                    if (inventTransferUpdateType == InventTransferUpdateType::Shipment)
                    {
                        taxAccountType = TaxAccountType_IN::VATPayableAccount;
                    }
                    else if (inventTransferUpdateType == InventTransferUpdateType::Receive)
                    {
                        taxAccountType = TaxAccountType_IN::VATRecoverableAccount;
                    }
                }

                if (_taxTable.TaxType_IN == TaxType_IN::SalesTax)
                {
                    if (inventTransferUpdateType == InventTransferUpdateType::Shipment)
                    {
                        taxAccountType = TaxAccountType_IN::SalesTaxPayableAccount;
                    }
                    else if (inventTransferUpdateType == InventTransferUpdateType::Receive)
                    {
                        taxAccountType = TaxAccountType_IN::SalesTaxExpenseAccount;
                    }
                }
                break;

            default:
                break;
        }

        return taxAccountType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineTaxationCode_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Determines <c>TaxationCodeTable_BR</c> by <c>TaxOnItem</c>, <c>TaxGroupData</c> or <c>TaxCode</c>.
    /// </summary>
    /// <param name="_taxCode">
    ///  A <c>TaxCode</c> to find <c>TaxationCodeTable_BR</c>.
    /// </param>
    /// <param name="_taxOnItem">
    ///  A <c>TaxOnItem</c> to find <c>TaxationCodeTable_BR</c> when TaxOnItem.TaxationCodeTable_BR is filled.
    /// </param>
    /// <param name="_taxGroupData">
    ///  A <c>TaxGroupData</c> to find <c>TaxationCodeTable_BR</c> when TaxGroupData.ExemptTax is true.
    /// </param>
    /// <returns>
    ///  <c>TaxationCodeTable_BR</c> filled when finded, otherwise <c>TaxationCodeTable_BR</c> empty.
    /// </returns>
    protected TaxationCodeTable_BR determineTaxationCode_BR(TaxCode _taxCode, TaxOnItem _taxOnItem, TaxGroupData _taxGroupData)
    {
        TaxationCodeTable_BR taxationCodeTable;

        if (_taxGroupData.ExemptTax)
        {
            taxationCodeTable = TaxationCodeTable_BR::findRecId(_taxGroupData.TaxationCodeTable_BR);
        }
        else if (_taxOnItem.TaxationCodeTable_BR)
        {
            taxationCodeTable = TaxationCodeTable_BR::findRecId(_taxOnItem.TaxationCodeTable_BR);
        }

        return taxationCodeTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineTaxRegistrationNumber_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine tax registration number.
    /// </summary>
    /// <param name="_taxType">
    /// The tax type.
    /// </param>
    /// <returns>
    /// The instance of the <c>RefRecId</c> class.
    /// </returns>
    public  RefRecId determineTaxRegistrationNumber_IN(TaxType_IN  _taxType)
    {
        RefRecId                registrationNumber;
        TaxInformation_IN       taxInformation;
        VendInvoiceInfoLine     vendInvoiceInfoLineLoc;
        InventTransferLine      inventTransferLine;
        CompanyId               company = curext();
        LedgerJournalTrans      ledgerJournalTransPayment;
        TransTaxInformation     transTaxInformation;

        transTaxInformation = transTaxInformationHelper.getTransTaxInformation(salesPurchJournalLineLoc.SourceTableId, salesPurchJournalLineLoc.SourceRecId);

        switch (salesPurchJournalLineLoc.SourceTableId)
        {
            case tableNum(InventTransferLine):
                if (inventTransferUpdateType != InventTransferUpdateType::Shipment)
                {
                    transTaxInformation = transTaxInformationHelper.getTransTaxInformation(salesPurchJournalLineLoc.SourceTableId, salesPurchJournalLineLoc.SourceRecId, TransTaxInformationType_IN::InventTransferTo);
                }
            case tableNum(VendInvoiceInfoLine):
            case tableNum(ProjEmplTrans):
            case tableNum(ProjRevenueTrans):
            case tableNum(MarkupTrans):
                registrationNumber = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, _taxType).RecId;
                break;

            default:
                // For Servicetax centralized payment
                if (salesPurchJournalLineLoc.TableId == tableNum(LedgerJournalTrans))
                {
                    ledgerJournalTransPayment = salesPurchJournalLineLoc;
                    if (ledgerJournalTransPayment.RecId != 0
                        && LedgerJournalTrans_IN_Extension::isCentralizedAdvancePayment_IN(ledgerJournalTransPayment))
                    {
                        company = ledgerJournalTransPayment.DataAreaId;
                    }
                }
                changecompany(company)
                {
                    transTaxInformation = transTaxInformationHelper.getTransTaxInformation(salesPurchJournalLineLoc.SourceTableId, salesPurchJournalLineLoc.SourceRecId);
                }
                registrationNumber = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, _taxType).RecId;
        }

        return registrationNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>distributeTotalTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Distribute total tax amount of the specified <c>TaxCalculationOrder</c> to individual tax lines
    /// </summary>
    /// <param name = "_taxCalculationOrder">Value of <c>TaxCalculationOrder</c></param>
    protected void distributeTotalTax(TaxCalculationOrder _taxCalculationOrder)
    {
        TaxCode onTaxCode;
        TaxData TaxData;

        // Sets the base tax amount on a TaxOnTax coded transaction.
        // The base tax amount for the TaxOnTax transaction comes from the tax amount
        // of the origin tax transaction.  For instance, if the "SuperCity" tax code calculates
        // taxes on the result of the "City" tax code, this routine copies the calculated taxes fields
        // from the "City" tax transactions to the corresponding "SuperCity" tax transactions
        // base tax amount fields.  This is important because the allocation routines that follow
        // use the base tax amount fields as the basis for allocation.
        void updateTaxBaseAmount(TaxCode _fromTaxCode, TaxCode _toTaxCode, TaxDirection _taxDirection, TransDate _calculationDate)
        {
            TmpTaxWorkTrans toTaxWorkTrans;
            TaxTable taxTable;

            taxTable = this.getTaxTable(_toTaxCode);
            toTaxWorkTrans.setTmpData(taxWorkTrans);

            ttsbegin;

            while select taxWorkTrans
                where
                    taxWorkTrans.TaxCode            == _fromTaxCode &&
                    taxWorkTrans.TaxDirection       == _taxDirection &&
                    taxWorkTrans.CalculationDate    == _calculationDate
            {
                select firstonly forupdate toTaxWorkTrans
                    where
                        toTaxWorkTrans.TaxCode          == _toTaxCode &&
                        toTaxWorkTrans.TaxDirection     == _taxDirection &&
                        toTaxWorkTrans.CalculationDate  == _calculationDate &&
                        toTaxWorkTrans.SourceTableId    == taxWorkTrans.SourceTableId &&
                        toTaxWorkTrans.SourceRecId      == taxWorkTrans.SourceRecId;

                if (toTaxWorkTrans)
                {
                    // <GBR>
                    if (isBrazilEnabled && taxTable.TaxSubstitution_BR == TaxSubstitutionEnum_BR::Markup
                         && taxTable.TaxSubstitutionBaseRedCalcMode_BR == TaxSubstitutionBaseRedCalculationMode_BR::OwnOperationOnly )
                    {
                        taxData = TaxData::find(_toTaxCode, _calculationDate,toTaxWorkTrans.TaxBaseAmount);
                        toTaxWorkTrans.TaxBaseAmount = toTaxWorkTrans.TaxBaseAmount * (1 - (taxData.TaxReductionPct_BR / 100));

                        toTaxWorkTrans.TaxBaseAmountRaw = toTaxWorkTrans.TaxBaseAmountRaw * (1 - (taxData.TaxReductionPct_BR / 100));
                        toTaxWorkTrans.TaxBaseAmountCur = toTaxWorkTrans.TaxBaseAmountCur * (1 - (taxData.TaxReductionPct_BR / 100));
                        toTaxWorkTrans.TaxBaseAmountRep = toTaxWorkTrans.TaxBaseAmountRep * (1 - (taxData.TaxReductionPct_BR / 100));
                        toTaxWorkTrans.SourceBaseAmountCur = toTaxWorkTrans.SourceBaseAmountCur * (1 - (taxData.TaxReductionPct_BR / 100));
                        toTaxWorkTrans.SourceBaseAmountCurRaw = toTaxWorkTrans.SourceBaseAmountCurRaw * (1 - (taxData.TaxReductionPct_BR / 100));
                    }
                    // <GBR>

                    if (taxTable.TaxBase == TaxBaseType::PctPerGross)
                    {
                        toTaxWorkTrans.TaxBaseAmount += taxWorkTrans.TaxAmount;
                        toTaxWorkTrans.TaxBaseAmountRaw += taxWorkTrans.TaxAmount;
                        toTaxWorkTrans.TaxBaseAmountCur += taxWorkTrans.TaxAmountCur;
                        toTaxWorkTrans.TaxBaseAmountRep += taxWorkTrans.TaxAmountRep;
                        toTaxWorkTrans.SourceBaseAmountCur += taxWorkTrans.SourceTaxAmountCur;
                        toTaxWorkTrans.SourceBaseAmountCurRaw += taxWorkTrans.SourceTaxAmountCurReal;

                        toTaxWorkTrans.update(this.ignoreCalculatedSalesTax());
                    }
                    else
                    {
                        toTaxWorkTrans.TaxBaseAmount = taxWorkTrans.TaxAmount;
                        toTaxWorkTrans.TaxBaseAmountRaw = taxWorkTrans.TaxAmount;
                        toTaxWorkTrans.TaxBaseAmountCur = taxWorkTrans.TaxAmountCur;
                        toTaxWorkTrans.TaxBaseAmountRep = taxWorkTrans.TaxAmountRep;
                        toTaxWorkTrans.SourceBaseAmountCur = taxWorkTrans.SourceTaxAmountCur;
                        toTaxWorkTrans.SourceBaseAmountCurRaw = taxWorkTrans.SourceTaxAmountCurReal;

                        toTaxWorkTrans.update(this.ignoreCalculatedSalesTax());
                    }
                }
            }

            ttscommit;
        }

        QueryRun queryRun =  this.query(_taxCalculationOrder);

        while(queryRun.next())
        {
            tmpTax = queryRun.get(tableNum(TmpTax));

            onTaxCode = TaxTable::find(tmpTax.TaxCode).TaxOnTax;
            if (onTaxCode)
            {
                // Tax-on-tax so update the base tax amount fields
                updateTaxBaseAmount(onTaxCode, tmpTax.TaxCode, tmpTax.TaxDirection, tmpTax.CalculationDate);
            }

            select sum(TaxBaseAmountRaw)
            from taxWorkTrans
            where taxWorkTrans.TaxCode == tmpTax.TaxCode &&
                  taxWorkTrans.TaxDirection == tmpTax.TaxDirection &&
                  taxWorkTrans.CalculationDate == tmpTax.CalculationDate &&
                  taxWorkTrans.SourceCurrencyCode == tmpTax.SourceCurrencyCode &&
                  taxWorkTrans.Company == tmpTax.Company &&
                 (taxWorkTrans.ExemptTax == NoYes::No || taxWorkTrans.ReverseCharge_W == NoYes::No)
            // <GBR>
            && taxWorkTrans.FiscalValue_BR == tmpTax.TaxFiscalValue_BR &&
                taxWorkTrans.TaxReceivableLongTerm_BR == tmpTax.TaxReceivableLongTerm_BR;
            // </GBR>

            if (taxWorkTrans.TaxBaseAmountRaw != tmpTax.TaxBaseAmountMSTRaw &&
               !onTaxCode)
                this.allocateBaseInTaxWorkTrans(tmpTax.TaxCode,
                                                tmpTax.TaxDirection,
                                                taxWorkTrans.TaxBaseAmountRaw,
                                                tmpTax.TaxBaseAmountMST,
                                                tmpTax.TaxBaseAmountMSTRaw,
                                                tmpTax.CalculationDate,
                                                tmpTax.TaxBaseAmountCur,
                                                tmpTax.SourceCurrencyCode);

            if (tmpTax.TaxAmountMST || tmpTax.Warning != TaxWarning::NoWarning
                // <GIN>
                || (isCustomsEnabled && (tmpTax.CustomsDuty_IN
                                               || tmpTax.EximTaxAmount_IN))
                // </GIN>
                )
            {
                // <GIN>
                if (isCustomsEnabled)
                {
                    this.parmCustomsDuty_IN(tmpTax.CustomsDuty_IN);
                }

                if (isCustomsEnabled
                    && tmpTax.EximTaxAmount_IN)
                {
                    this.parmEximTaxAmount_IN(tmpTax.EximTaxAmount_IN);
                    this.parmEximBalanceTaxAmt_IN(tmpTax.EximBalanceTaxAmount_IN);
                    this.parmEximDEPBAmount_IN(tmpTax.EximDEPBAmount_IN);
                }
                // </GIN>

                this.allocateInTaxWorkTransWithCompany(tmpTax.TaxCode,
                                                       tmpTax.TaxDirection,
                                                       tmpTax.TaxAmountMST,
                                                       tmpTax.TaxAmountCur,
                                                       tmpTax.TaxInCostPrice,
                                                       tmpTax.TaxInCostPriceMST,
                                                       tmpTax.TaxInCostPriceCur,
                                                       tmpTax.TaxBaseAmountMSTRaw,
                                                       tmpTax.TaxBaseQty,
                                                       tmpTax.SourceTaxAmountCur,
                                                       tmpTax.SourceTaxAmountCurReal,
                                                       NoYes::No,
                                                       tmpTax.CalculationDate,
                                                       tmpTax.Warning,
                                                       // <GBR>
                                                       tmpTax.TaxFiscalValue_BR,
                                                       tmpTax.TaxReceivableLongTerm_BR,
                                                       // </GBR>
                                                       tmpTax.sourceCurrencyCode,
                                                       tmpTax.Company);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doAdjustmentsExist</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets a value that indicates if tax adjustments exist for the source document.
    /// </summary>
    /// <param name="_headingTableId">
    ///   The table ID of the source transaction header.
    /// </param>
    /// <param name="_headingRecId">
    ///   The record ID of the source transaction header.
    /// </param>
    /// <returns>
    ///   true if tax adjustments exist for the source document; otherwise, false.
    /// </returns>
    protected boolean doAdjustmentsExist(RefTableId _headingTableId = headingTableId, RefRecId _headingRecId = headingRecId)
    {
        return TaxWorkRegulation::exist(_headingTableId, _headingRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentStatus_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets document status.
    /// </summary>
    /// <returns>
    /// The instance of the <c>DocumentStatus</c> class.
    /// </returns>
    public DocumentStatus documentStatus_IN()
    {
        return documentStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEmptyBaseForOutgoingTax_W</Name>
				<Source><![CDATA[
    internal NoYes getEmptyBaseForOutgoingTax_W(TaxGroupData _taxGroupData)
    {
        SelectableDataArea company = this.getCompany();
        changecompany(company)
        {
            return this.emptyBaseForOutgoingTax_W(_taxGroupData);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEmptyBaseForOutgoingTax_WWithTransRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Indicates, that tax base amount should not be calculated for inverted outgoing tax transactions
    ///   for reverse charge with recId of transaction line.
    /// </summary>
    /// <param name="_taxGroupData">
    ///   <c>TaxGroupData</c> record related to current tax calculation.
    /// </param>
    /// <param name="_transRecId">
    ///   RecId of transaction line.
    /// </param>
    /// <returns>
    ///   Whether the reverse charge rule for the tax group has an empty base for outgoing tax.
    /// </returns>
    internal NoYes getEmptyBaseForOutgoingTax_WWithTransRecId(TaxGroupData _taxGroupData, RecId _transRecId)
    {
        SelectableDataArea company = this.getCompany();
        changecompany(company)
        {
            return this.emptyBaseForOutgoingTax_WWithTransRecId(_taxGroupData, _transRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>emptyBaseForOutgoingTax_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Indicates, that tax base amount should not be calculated for inverted outgoing tax transactions
    ///   for reverse charge.
    /// </summary>
    /// <param name="_taxGroupData">
    ///   <c>TaxGroupData</c> record related to current tax calculation.
    /// </param>
    /// <returns>
    ///   True, if tax base must be ingnored by UK VAT 100 report; Otherwise, false.
    /// </returns>
    protected NoYes emptyBaseForOutgoingTax_W(TaxGroupData _taxGroupData)
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>emptyBaseForOutgoingTax_WWithTransRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Indicates, that tax base amount should not be calculated for inverted outgoing tax transactions
    ///   for reverse charge with recId of transaction line.
    /// </summary>
    /// <param name="_taxGroupData">
    ///   <c>TaxGroupData</c> record related to current tax calculation.
    /// </param>
    /// <param name="_transRecId">
    ///   RecId of transaction line.
    /// </param>
    /// <returns>
    ///   Whether the reverse charge rule for the tax group has an empty base for outgoing tax.
    /// </returns>
    protected internal NoYes emptyBaseForOutgoingTax_WWithTransRecId(TaxGroupData _taxGroupData, RecId _transRecId)
    {
        return this.emptyBaseForOutgoingTax_W(_taxGroupData);
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the exchange rate.
    /// </summary>
    /// <returns>The exchange rate.</returns>
    public ExchRate exchRate()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateSecondary</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the secondary exchange rate.
    /// </summary>
    /// <returns>The secondary exchange rate.</returns>
    public ExchrateSecondary exchRateSecondary()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportingCurrencyExchangeRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the reporting currency exchange rate.
    /// </summary>
    /// <returns>The reporting currency exchange rate.</returns>
    [Hookable(false)]
    protected ExchRate reportingCurrencyExchangeRate()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the cash discount amount.
    /// </summary>
    /// <returns>The cash discount amount.</returns>
    [Hookable(false)]
    internal AmountCur getCashDiscAmount()
    {
        return cashDiscAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscPercent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the cash discount percent.
    /// </summary>
    /// <returns>The cash discount percent.</returns>
    [Hookable(false)]
    internal Percent getCashDiscPercent()
    {
        return cashDiscPercent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exciseDeferredAmt_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets excise deferred amount.
    /// </summary>
    /// <param name="_claimPercentage">
    /// The claim percentage.
    /// </param>
    /// <param name="_taxAmount">
    /// The tax amount.
    /// </param>
    /// <param name="_exciseRecordType">
    /// The excise record type.
    /// </param>
    /// <param name="_exciseType">
    /// The excise type.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxAmountCur</c> class.
    /// </returns>
    public TaxAmountCur exciseDeferredAmt_IN(Percent            _claimPercentage,
                                            TaxAmount           _taxAmount,
                                            ExciseRecordType_IN _exciseRecordType,
                                            ExciseType_IN       _exciseType)
    {
        TaxAmount               deferredAmt;

        if ( _claimPercentage)
        {
            if (_exciseType == ExciseType_IN::Manufacturer
                && (_exciseRecordType == ExciseRecordType_IN::RG23A || _exciseRecordType == ExciseRecordType_IN::RG23C))
            {
                deferredAmt = isAppliedLoadOnInventory ? (_taxAmount) * (100 - _claimPercentage)/100 : (_taxAmount - totLOIAmount) * (100 - _claimPercentage)/100;
            }

            return  (CurrencyExchangeHelper::amount(deferredAmt, sourceCurrencyCode));
        }

        return 0.00;
    }

]]></Source>
			</Method>
			<Method>
				<Name>excisePurchClaim_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns amount based on the ClaimPercentage defined for respective components.
    /// </summary>
    /// <param name="_salesPurchJournalLine">
    ///    The <c>_salesPurchJournalLine</c> buffer to find type of register.
    /// </param>
    /// <param name="_taxAmount">
    ///    The <c>_taxAmount</c> to use to find the Claim percentage amount.
    /// </param>
    /// <returns>
    ///    Amounts based on the ClaimPercentage defined for respective components.
    /// </returns>
    public TaxAmountCur excisePurchClaim_IN(
        SalesPurchJournalLine       _salesPurchJournalLine,
        TaxAmount                   _taxAmount)
    {
        ClaimPercentage_IN      claimPercentage;
        RGRegister_IN           rgRegister;
        TransDateTime           calculationDateTime;
        TransTaxInformation     transTaxInformation;

        transTaxInformation = transTaxInformationHelper.getTransTaxInformation(_salesPurchJournalLine.SourceTableId, _salesPurchJournalLine.SourceRecId);

        claimdeferedAmount = 0;
        claimDeferredAmountMST = 0;

        calculationDateTime = DateTimeUtil::newDateTime(taxWorkTrans.CalculationDate, DateTimeUtil::getTimeNow(DateTimeUtil::getUserPreferredTimeZone()), DateTimeUtil::getUserPreferredTimeZone());
        if (transTaxInformation.ExciseRecordType == ExciseRecordType_IN::RG23A || transTaxInformation.ExciseRecordType == ExciseRecordType_IN::RG23C)
        {
            rgRegister = transTaxInformation.ExciseRecordType == ExciseRecordType_IN::RG23A ? RGRegister_IN::RG23A : RGRegister_IN::RG23C;
            claimPercentage = ClaimPercentage_IN::findClaimPercentage(TaxTable::find(taxTableExcise.TaxCode ? taxTableExcise.TaxCode : taxWorkTrans.TaxCode).TaxComponentTable_IN, calculationDateTime, calculationDateTime, rgRegister);
        }

        if (claimPercentage)
        {
            if (isAppliedLoadOnInventory)
            {
                claimdeferedAmount = (_taxAmount + totLOIAmount) * (100 - claimPercentage.Percentage)/100;
                claimDeferredAmountMST = (customsAmountMST) * (100 - claimPercentage.Percentage)/100;
            }
            else
            {
                claimdeferedAmount = (_taxAmount) * (100 - claimPercentage.Percentage)/100;
                claimDeferredAmountMST = (customsAmountMST) * (100 - claimPercentage.Percentage)/100;
            }
        }

        return  (CurrencyExchangeHelper::amount(claimdeferedAmount, sourceCurrencyCode));
    }

]]></Source>
			</Method>
			<Method>
				<Name>exciseTaxCalculationdate_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Excise the tax calculation date.
    /// </summary>
    /// <param name="_sourceRecId">
    /// The source rec id.
    /// </param>
    /// <param name="_sourceTableId">
    /// The source table id.
    /// </param>
    /// <returns>
    /// The instance of the <c>TransDateTime</c> class.
    /// </returns>
    protected TransDateTime exciseTaxCalculationdate_IN(
        RefRecId _sourceRecId,
        TableId  _sourceTableId)
    {
        CustInvoiceLine                 custInvoiceLineLoc;
        CustInvoiceTable                custInvoiceTableloc;
        TransDateTime                   taxCalculationDateTime;
        LedgerJournalTrans              ledgerJournalTrans;
        CustomerCalculationDateType_IN  customerCalculationDateType = this.taxParameters().CustomerCalculationDateType_IN;

        if (_sourceRecId)
        {
            switch (_sourceTableId)
            {
                case tableNum(PurchLine),
                     tableNum(PurchReqLine),
                     tableNum(PurchRFQLine),
                     tableNum(SalesLine),
                     tableNum(SalesQuotationLine),
                     tableNum(InventTransferLine):
                        return taxCalculationDateTime;
                case tableNum(CustInvoiceLine):
                    select firstonly RecId, ParentRecId from custInvoiceLineLoc
                                where custInvoiceLineLoc.RecId   == _sourceRecId;

                    custInvoiceTableloc = CustInvoiceTable::findRecId(custInvoiceLineLoc.ParentRecId);
                    if (taxModuleType == TaxModuleType::FreeTxtInvoice)
                    {
                        switch (customerCalculationDateType)
                        {
                            case CustomerCalculationDateType_IN::DeliveryDate,
                                 CustomerCalculationDateType_IN::InvoiceDate:
                                 taxCalculationDateTime = DateTimeUtil::newDateTime(custInvoiceTableloc.InvoiceDate, 0, DateTimeUtil::getUserPreferredTimeZone());
                                break;
                        }
                    }

                    break;
                case tableNum(LedgerJournalTrans) :
                    ledgerJournalTrans = LedgerJournalTrans::findRecId(_sourceRecId, false);
                    if (isExciseEnabled)
                    {
                        if (ledgerJournalTrans.AccountType          == LedgerJournalACType::Vend
                            || ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
                        {
                            if (ledgerJournalTrans.DocumentDate
                                && taxParameters.VendorCalculationDateType_IN == VendorCalculationDateType_IN::DocumentDate)
                            {
                                taxCalculationDateTime = DateTimeUtil::newDateTime(ledgerJournalTrans.DocumentDate, 0, DateTimeUtil::getUserPreferredTimeZone());
                            }
                            else
                            {
                                taxCalculationDateTime = DateTimeUtil::newDateTime(ledgerJournalTrans.TransDate, 0, DateTimeUtil::getUserPreferredTimeZone());
                            }
                        }
                        else if (ledgerJournalTrans.AccountType          == LedgerJournalACType::Cust
                                 || ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
                        {
                            if (taxParameters.CustomerCalculationDateType_IN == CustomerCalculationDateType_IN::DeliveryDate
                                || taxParameters.CustomerCalculationDateType_IN == CustomerCalculationDateType_IN::InvoiceDate)
                            {
                                taxCalculationDateTime = DateTimeUtil::newDateTime(ledgerJournalTrans.TransDate, 0, DateTimeUtil::getUserPreferredTimeZone());
                            }
                        }
                    }
                    break;
            }
        }

        return  taxCalculationDateTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>eximBalTaxRegSingleLineInclUseTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The inclusive use tax of exim bal tax reg single line.
    /// </summary>
    /// <param name="_tableId">
    /// The table id.
    /// </param>
    /// <param name="_recId">
    /// The record id.
    /// </param>
    /// <returns>
    /// The instance of the <c>AmountMST</c> class.
    /// </returns>
    public AmountMST eximBalTaxRegSingleLineInclUseTax_IN(
        TableId     _tableId,
        RefRecId    _recId)
    {
        TaxAmount   taxAmount;
        TaxTable    taxTableLoc;

        while select  taxWorkTrans
            where (taxWorkTrans.SourceTableId == _tableId &&
                    taxWorkTrans.SourceRecId == _recId) ||
                    (taxWorkTrans.ParentSourceTableId == _tableId &&
                        taxWorkTrans.ParentSourceRecId == _recId) &&
                    taxWorkTrans.TaxOrigin != TaxOrigin::TaxReversed
            join TaxCode, TaxType_IN from taxTableLoc
            where taxTableLoc.TaxCode == taxWorkTrans.TaxCode
               && taxTableLoc.TaxType_IN == TaxType_IN::Customs
        {
            taxAmount += CurrencyHelper_IN::customsMSTAmount_IN(this.taxAmountSign(taxWorkTrans.SourceRegulateAmountCur, taxWorkTrans.TaxDirection),
                                                       taxWorkTrans.CurrencyCode,
                                                       Direction_IN::Import,
                                                       taxWorkTrans.TransDate);
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>eximBalTaxSingleLineInclUseTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The inclusive use tax of exim bal tax single line.
    /// </summary>
    /// <param name="_tableId">
    /// The table id.
    /// </param>
    /// <param name="_recId">
    /// The record id.
    /// </param>
    /// <param name="_adjustTaxSign">
    /// The adjust tax sign.
    /// </param>
    /// <returns>
    /// The instance of the <c>AmountMST</c> class.
    /// </returns>
    public AmountMST eximBalTaxSingleLineInclUseTax_IN(TableId _tableId, RefRecId _recId, boolean _adjustTaxSign = true)
    {
        TaxTable  taxTableLoc;
        AmountMST eximBalanceTaxAmountMST;

        while select taxWorkTrans
            where (taxWorkTrans.SourceTableId == _tableId &&
                    taxWorkTrans.SourceRecId == _recId) ||
                    (taxWorkTrans.ParentSourceTableId == _tableId &&
                        taxWorkTrans.ParentSourceRecId == _recId) &&
                    taxWorkTrans.TaxOrigin != TaxOrigin::TaxReversed
            join TaxCode, TaxType_IN from taxTableLoc
            where taxTableLoc.TaxCode == taxWorkTrans.TaxCode
               && taxTableLoc.TaxType_IN == TaxType_IN::Customs
        {
            if (_adjustTaxSign)
            {
                eximBalanceTaxAmountMST += (taxWorkTrans.EximBalanceTaxAmount_IN * Tax::changeDisplaySign(taxWorkTrans.TaxDirection));
            }
            else
            {
                eximBalanceTaxAmountMST += taxWorkTrans.EximBalanceTaxAmount_IN;
            }
        }

        return eximBalanceTaxAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidTaxCodeIntersection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows an extension class to determine if the current tax code is valid
    /// for processing.
    /// </summary>
    /// <param name = "_taxCode">
    /// The <c>TaxCode</c> value to validate.
    /// </param>
    /// <returns>
    /// True for the base method.
    /// </returns>
    protected boolean isValidTaxCodeIntersection(TaxCode _taxCode)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidTaxCodeIntersectionByCalculationDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows an extension class to determine if the current tax code is valid by the calculation date specified.
    /// for processing.
    /// </summary>
    /// <param name = "_taxCode">
    /// The <c>TaxCode</c> value to validate.
    /// </param>
    /// <param name = "_taxCalculationDate">
    /// The calculation date that used for validating.
    /// </param>
    /// <returns>
    /// true if the <c>TaxCode</c> parameter value is valid; otherwise, false.
    /// </returns>
    protected boolean isValidTaxCodeIntersectionByCalculationDate(TaxCode _taxCode, TransDate _taxCalculationDate)
    {
        return this.isValidTaxCodeIntersection(_taxCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>eximInsertIntersection_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the exim intersection.
    /// </summary>
    /// <param name="_incentiveSchemeData">
    /// The incentive scheme data.
    /// </param>
    /// <param name="_eximTaxTable">
    /// The exim tax table.
    /// </param>
    protected void eximInsertIntersection_IN(
        EximIncentiveSchemeData_IN _incentiveSchemeData,
        EximTaxTable_IN            _eximTaxTable)
    {
        EximImportDetails_IN             importDetails;
        PurchLine                        purchLine;
        EximAuthorizationSchemesTable_IN authorizationSchemesTable;
        EximAuthorizationSchemesLine_IN  authorizationSchemesLine;
        EximIncentiveScheme_IN           incentiveScheme;
        EximEPCGSchemeTable_IN           eximEPCGSchemeTable;
        RefRecId                         purchLineRecId;

        taxWorkTrans.EximAuthorizationId_IN = _incentiveSchemeData.AuthorizationId;
        if (((EximParameters_IN::checkAAParameters()      && _eximTaxTable.IncentiveScheme    == EximAuthorizationType_IN::AA))
            || ((EximParameters_IN::checkDFIAParameters() && _eximTaxTable.IncentiveScheme == EximAuthorizationType_IN::DFIA)))
        {
            // When Tax calculation is fired from posting form (VendEditInvoice) the taxWorkTrans buffer SourceTableId is VendInvoiceInfoLine.
            // So here we get the PurchLine recid using the same table.If we fire Tax calculation from PO>setup>SalesTax, taxWorkTrans SourceTable will be PurchLine.
            purchLineRecId = (taxWorkTrans.SourceTableId == tableNum(VendInvoiceInfoLine)) ? VendInvoiceInfoLine::findRecId(taxWorkTrans.SourceRecId).PurchLineRecId : taxWorkTrans.SourceRecId;
            select ItemId
                from purchLine
                    where purchLine.RecId == purchLineRecId
                join RecId, AuthorizationSchemesTableRecId
                    from importDetails
                        where importDetails.ItemId == purchLine.ItemId
                    join RecId, AuthorizationType
                        from authorizationSchemesTable
                            where authorizationSchemesTable.AuthorizationType  == _eximTaxTable.IncentiveScheme
                                && authorizationSchemesTable.AuthorizationId   == _incentiveSchemeData.AuthorizationId
                                && authorizationSchemesTable.RecId             == importDetails.AuthorizationSchemesTableRecId
                                && authorizationSchemesTable.IssueDate         <= taxWorkTrans.TransDate
                                && !authorizationSchemesTable.Closed
                        join reverse firstonly AuthorizationSchemesTableRecId
                            from authorizationSchemesLine
                                where authorizationSchemesLine.AuthorizationSchemesTableRecId == authorizationSchemesTable.RecId
                                    && authorizationSchemesLine.LicenseStatus                  != EximLicenseStatus_IN::Sold
                                    && authorizationSchemesLine.ImportExpiryDate               >= taxWorkTrans.TransDate;

            if (authorizationSchemesTable.RecId)
            {
                taxWorkTrans.EximIncentiveScheme_IN = str2enum(incentiveScheme, enum2str(authorizationSchemesTable.AuthorizationType));
            }
        }
        else if (EximParameters_IN::checkDEPBParameters() && _eximTaxTable.IncentiveScheme == EximAuthorizationType_IN::DEPB)
        {
            taxWorkTrans.EximIncentiveScheme_IN = EximIncentiveScheme_IN::DEPB;
        }
        else if (EximParameters_IN::checkEPCGParameters() && _eximTaxTable.IncentiveScheme == EximAuthorizationType_IN::EPCG)
        {
            eximEPCGSchemeTable = EximEPCGSchemeTable_IN::findSchemeId(_incentiveSchemeData.AuthorizationId);
            if (taxWorkTrans.TransDate    >= DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(eximEPCGSchemeTable.IssueDateTime, DateTimeUtil::getUserPreferredTimeZone()))
                && taxWorkTrans.TransDate <= DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(eximEPCGSchemeTable.ImportExpiryDateTime, DateTimeUtil::getUserPreferredTimeZone()))
                && !eximEPCGSchemeTable.Closed)
            {
                taxWorkTrans.EximIncentiveScheme_IN = EximIncentiveScheme_IN::EPCG;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>eximShowTaxesNotSourceSingleLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The not source single line exim.
    /// </summary>
    /// <returns>
    /// The not source single line exim.
    /// </returns>
    public container eximShowTaxesNotSourceSingleLine_IN()
    {
        if (sourceSingleLine)
            return [sourceSingleLine, 0];

        return [sourceSingleLine,
                this.totalTaxAmountCalculated(),
                this.totalEximTaxAmountMST_IN(),
                this.totalEximBalanceTaxAmountMST_IN(),
                this.totalCorrectedCustomsDuty_IN(),
                this.eximTotalCorrectedAmount_IN(),
                this.eximTotalBalanceCorrectedAmount_IN()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>eximTaxSingleLineInclUseTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The inclusive use tax of exim tax single line.
    /// </summary>
    /// <param name="_tableId">
    /// The table id.
    /// </param>
    /// <param name="_recId">
    /// The record id.
    /// </param>
    /// <param name="_adjustTaxSign">
    /// The adjust tax sign.
    /// </param>
    /// <returns>
    /// The instance of the <c>AmountMST</c> class.
    /// </returns>
    public AmountMST eximTaxSingleLineInclUseTax_IN(TableId _tableId, RefRecId _recId, boolean _adjustTaxSign = true)
    {
        AmountMST    taxAmount;
        TaxTable     taxTableLoc;

        while select taxWorkTrans
            where (taxWorkTrans.SourceTableId == _tableId &&
                    taxWorkTrans.SourceRecId == _recId) ||
                    (taxWorkTrans.ParentSourceTableId == _tableId &&
                        taxWorkTrans.ParentSourceRecId == _recId) &&
                    taxWorkTrans.TaxOrigin != TaxOrigin::TaxReversed
            join TaxCode, TaxType_IN from taxTableLoc
            where taxTableLoc.TaxCode == taxWorkTrans.TaxCode
               && taxTableLoc.TaxType_IN == TaxType_IN::Customs
        {
            if (_adjustTaxSign)
            {
                taxAmount += (taxWorkTrans.EximTaxAmount_IN * Tax::changeDisplaySign(taxWorkTrans.TaxDirection));
            }
            else
            {
                taxAmount += taxWorkTrans.EximTaxAmount_IN;
            }
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>eximTotalBalanceCorrectedAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The exim total balance corrected amount.
    /// </summary>
    /// <returns>
    /// The instance of the <c>AmountMST</c> class.
    /// </returns>
    public AmountMST eximTotalBalanceCorrectedAmount_IN()
    {
        AmountMST totalBalanceCorrectedAmount;
        TaxTable  taxTableLoc;

        while select taxWorkTrans
            where taxWorkTrans.TaxOrigin != TaxOrigin::TaxReversed
            join TaxCode, TaxType_IN from taxTableLoc
            where taxTableLoc.TaxCode     == taxWorkTrans.TaxCode
                && taxTableLoc.TaxType_IN == TaxType_IN::Customs
        {
            totalBalanceCorrectedAmount += this.taxAmountSign(taxWorkTrans.EximBalanceTaxCorrectedAmount_IN, taxWorkTrans.TaxDirection);
        }

        return totalBalanceCorrectedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>eximTotalCorrectedAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The exim total corrected amount.
    /// </summary>
    /// <returns>
    /// The instance of the <c>AmountMST</c> class.
    /// </returns>
    public AmountMST eximTotalCorrectedAmount_IN()
    {
        AmountMST totalCorrectedAmount;
        TaxTable  taxTableLoc;

        while select taxWorkTrans
            where taxWorkTrans.TaxOrigin != TaxOrigin::TaxReversed
            join TaxCode, TaxType_IN from taxTableLoc
            where taxTableLoc.TaxCode     == taxWorkTrans.TaxCode
                && taxTableLoc.TaxType_IN == TaxType_IN::Customs
        {
            totalCorrectedAmount += this.taxAmountSign(taxWorkTrans.EximTaxCorrectedAmount_IN, taxWorkTrans.TaxDirection);
        }

        return totalCorrectedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPurchLineInEPCGImportTransDetails_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///  checks whether specific purch line can be found in epcgImportTransDetails container
    /// </summary>
    /// <param name="_recid">
    ///  <c>PurchLine</c> <c>RecId</c>
    /// </param>
    /// <returns>
    ///  True, if the line existed; Otherwise, false.
    /// </returns>
    private boolean findPurchLineInEPCGImportTransDetails_IN(RefRecId _recid)
    {
        boolean bResult = false;
        int     nIndex;

        for (nIndex = 1; nIndex <= conLen(epcgImportTransDetails); nIndex += 3)
        {
            if (conPeek(epcgImportTransDetails, nIndex) == _recid)
            {
                bResult = true;
                break;
            }
        }

        return bResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTaxCodeCombinationId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax code combination Id.
    /// </summary>
    /// <param name = "_taxCodeCombination">The set of tax code combination.</param>
    /// <returns>The tax code combination id.</returns>
    protected TaxCodeCombinationId findTaxCodeCombinationId(Set _taxCodeCombination)
    {
        return taxCodeCombinationIdMaker.getUniqueId(_taxCodeCombination);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTaxCodeCombinationIdInternal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax code combination Id.
    /// </summary>
    /// <param name = "_taxCodeCombination">The set of tax code combination.</param>
    /// <returns>The tax code combination id.</returns>
    internal TaxCodeCombinationId findTaxCodeCombinationIdInternal(Set _taxCodeCombination)
    {
        return this.findTaxCodeCombinationId(_taxCodeCombination);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAbatementAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets abatement amount.
    /// </summary>
    /// <returns>
    /// The instance of the <c>TaxAmountCur</c> class.
    /// </returns>
    public TaxAmountCur getAbatementAmount_IN()
    {
        return abatementAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountTypeForJournal_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the ledgerDirection for the jounrals based on taxTable.
    /// </summary>
    /// <param name="_taxTable">
    ///    The taxTable buffer.
    /// </param>
    /// <returns>
    /// Returns TaxAccountType_IN value.
    /// </returns>
    public TaxAccountType_IN getAccountTypeForJournal_IN(TaxTable _taxTable)
    {
        LedgerJournalACType     mainAccountTypeForCurrentVoucher;
        LedgerDimensionAccount  ledgerAccount;
        TaxAccountType_IN       taxAccountType;
        TaxBase                 journalAmount;
        TaxCalculationJournal   taxCalculationJournal;
        TransTaxInformation     transTaxInformation;

        mainAccountTypeForCurrentVoucher = ledgerJournalTransLoc.displayMainAccountType();
        if (mainAccountTypeForCurrentVoucher == LedgerJournalACType::Ledger && !ledgerJournalTransLoc.RecId)
        {
            mainAccountTypeForCurrentVoucher = ledgerJournalTransLoc.AccountType;
        }

        transTaxInformation = transTaxInformationHelper.getTransTaxInformationByRecord(ledgerJournalTransLoc);

        if (this is TaxCalculationJournal)
        {
            taxCalculationJournal = this as TaxCalculationJournal;
            journalAmount = (_taxTable.TaxType_IN                        == TaxType_IN::VAT                  &&
                                (transTaxInformation.VATGoodsType   == VATGoodsType_IN::CapitalGoods)   &&
                                (ledgerJournalTransLoc.AccountType       == LedgerJournalACType::FixedAssets ||
                                    ledgerJournalTransLoc.OffsetAccountType == LedgerJournalACType::FixedAssets)) ? taxCalculationJournal.capitalGoodsAmount_IN() : ledgerJournalTransLoc.amount();
        }

        switch (mainAccountTypeForCurrentVoucher)
        {
            case LedgerJournalACType::Cust :
                if (_taxTable.TaxType_IN == TaxType_IN::SalesTax)
                {
                    taxAccountType = TaxAccountType_IN::SalesTaxPayableAccount;
                }
                if (_taxTable.TaxType_IN == TaxType_IN::VAT)
                {
                    taxAccountType = TaxAccountType_IN::VATPayableAccount;
                }
                if (_taxTable.TaxType_IN == TaxType_IN::Customs)
                {
                    taxAccountType = TaxAccountType_IN::CustomsExportDutyPayableAccount;
                }

                break;
            case LedgerJournalACType::Vend :
                if (_taxTable.TaxType_IN == TaxType_IN::SalesTax)
                {
                    taxAccountType = TaxAccountType_IN::SalesTaxExpenseAccount;
                }

                if (_taxTable.TaxType_IN == TaxType_IN::VAT)
                {
                    taxAccountType = transTaxInformation.VATGoodsType == VATGoodsType_IN::CapitalGoods
                                     ? TaxAccountType_IN::VATDeferredAccount
                                     : TaxAccountType_IN::VATRecoverableAccount;
                }

                if (_taxTable.TaxType_IN == TaxType_IN::Customs)
                {
                    taxAccountType = TaxAccountType_IN::CustomsImportDutyExpenseAccount;
                }
                break;
            case LedgerJournalACType::Project :
                if (_taxTable.TaxType_IN == TaxType_IN::SalesTax)
                {
                    taxAccountType = TaxAccountType_IN::SalesTaxExpenseAccount;
                }
                if (_taxTable.TaxType_IN == TaxType_IN::VAT)
                {
                    taxAccountType = TaxAccountType_IN::VATRecoverableAccount;
                }
                if (_taxTable.TaxType_IN == TaxType_IN::Customs)
                {
                    if (ledgerJournalTransLoc.RecId)
                    {
                        if (ledgerJournalTransLoc.AccountType          == LedgerJournalACType::Vend ||
                            ledgerJournalTransLoc.OffsetAccountType    == LedgerJournalACType::Vend)
                        {
                            //Vendor to Project
                            taxAccountType = TaxAccountType_IN::CustomsImportDutyExpenseAccount;
                            taxWorkTrans.TaxDirection = TaxDirection::IncomingTax;
                        }
                        if (ledgerJournalTransLoc.AccountType          == LedgerJournalACType::Cust ||
                            ledgerJournalTransLoc.OffsetAccountType    == LedgerJournalACType::Cust)
                        {
                            //Customer to Project
                            taxAccountType = TaxAccountType_IN::CustomsExportDutyPayableAccount;
                            taxWorkTrans.TaxDirection = TaxDirection::OutgoingTax;
                        }
                    }
                }

                if (_taxTable.TaxType_IN == TaxType_IN::ServiceTax)
                {
                    taxAccountType = TaxAccountType_IN::ServiceTaxRecoverableAccount;
                }
                break;
            case LedgerJournalACType::Ledger :
                if (ledgerJournalTransLoc.AccountType == LedgerJournalACType::Bank)
                {
                    ledgerAccount = ledgerJournalTransLoc.OffsetLedgerDimension;
                }
                else
                {
                    ledgerAccount = ledgerJournalTransLoc.LedgerDimension;
                }
                taxAccountType = this.ledgerDirection_IN(ledgerAccount, _taxTable);
                break;

            case LedgerJournalACType::FixedAssets :
                break;
        }
        return taxAccountType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAmountBase_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets amount base.
    /// </summary>
    /// <param name="_formulaDesigner">
    /// The formula designer.
    /// </param>
    /// <param name="_amountBaseCur">
    /// The amount base cur.
    /// </param>
    /// <param name="_tmpTax">
    /// The temporary tax.
    /// </param>
    /// <param name="_taxBaseQty">
    /// The tax base quantity.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxBaseCur</c> class.
    /// </returns>
    TaxBaseCur getAmountBase_IN(FormulaDesigner_IN  _formulaDesigner,
                                TaxBaseCur          _amountBaseCur,
                                TmpTax              _tmpTax,
                                TaxBase             _taxBaseQty)
    {
        TaxBaseCur          calculatedBase;
        CalcExp_IN          taxAmountBase;
        TaxBaseCur          amountBase, amountBaseInq;
        TaxOnItem           taxOnItem;

        abatementAmountInq = 0;
        switch (_formulaDesigner.TaxableBasis)
        {
            case TaxableBasis_IN::LineAmount :
                if (_tmpTax.IsScrapQtyLine_IN || !_formulaDesigner.PriceInclTax)
                {
                    amountBase = _amountBaseCur;
                }
                else
                {
                    amountBase = lineExclTax;
                }
                taxAmountBase = num2str(abs(amountBase),1,6,1,0);
                break;
            case TaxableBasis_IN::ExclAmount :
                if (_tmpTax.IsScrapQtyLine_IN)
                {
                    amountbase    = _amountBaseCur;
                }
                taxAmountBase         = "0.000000";
                break;
            case TaxableBasis_IN::MRP :

                if (salesPurchJournalLineLoc.SourceTableId != tableNum(MarkupTrans))
                {
                    amountBaseInq = this.getMRPAmountBase_IN(_taxBaseQty);

                    if (_tmpTax.IsScrapQtyLine_IN)
                    {
                        amountBaseInq = 0;
                        amountbase    = _amountBaseCur;
                    }
                    else if (_formulaDesigner.PriceInclTax)
                    {
                        amountBase = mrpExclTax;
                    }
                    else
                    {
                        amountBase = this.getMRPAmountBase_IN(_taxBaseQty);
                    }
                }

                taxAmountBase   = num2str(abs(amountBase),1,6,1,0);
                break;
            case TaxableBasis_IN::Assessable :

                if (_tmpTax.IsScrapQtyLine_IN)
                {
                    amountBaseInq = 0;
                    amountBase    = _amountBaseCur;
                }
                else if (salesPurchJournalLineLoc.SourceTableId != tableNum(MarkupTrans))
                {
                    amountBaseInq = this.getAssessableAmountBase_IN();
                    amountBase = amountBaseInq;
                }

                taxAmountBase = num2str(abs(amountBase),1,6,1,0);
                break;
        }

        calculatedBase  =  this.amountBaseForTaxOnTax_IN(_formulaDesigner, taxAmountBase, _tmpTax, _taxBaseQty);

        TaxItemGroup        taxItemGroup;

        if (salesPurchJournalLineLoc.SourceTableId == tableNum(InventTransferLine))
        {
            taxItemGroup = InventTransferLine_IN::findByinventTransferLine(salesPurchJournalLineLoc.SourceRecId).TaxItemGroup;
        }
        else
        {
            taxItemGroup = salesPurchJournalLineLoc.TaxItemGroup;
        }

        if (TaxTable::find(_tmpTax.TaxCode).TaxType_IN != TaxType_IN::None)
        {
            select TaxCode, TaxItemGroup, AbatementPercent_IN from taxOnItem
                where taxOnItem.TaxCode      == _tmpTax.TaxCode &&
                        taxOnItem.TaxItemGroup == taxItemGroup;
            if (taxOnItem.AbatementPercent_IN)
            {
                abatementAmount     = calculatedBase * taxOnItem.AbatementPercent_IN/100;
                abatementAmountInq  = abatementAmount;
                calculatedBase      = calculatedBase * (100 - taxOnItem.AbatementPercent_IN)/100;
            }
        }
        // normal AR with lineamount
        if (_amountBaseCur < 0)
        {
            return -calculatedBase;
        }
        else if (_amountBaseCur == 0) // free item
        {
            if (salesPurchJournalLineLoc.SalesPurchJournalLine::parmMaximumRetailPrice())
            {
                return -calculatedBase;
            }
            else if (_taxBaseQty < 0) // negative transaction with qty
            {
                return -calculatedBase;
            }
            else if (_taxBaseQty == 0)
            {
                // negative transaction without qty
                if ((_tmpTax.TaxDirection == TaxDirection::OutgoingTax && amountBase > 0)   ||
                    (_tmpTax.TaxDirection == TaxDirection::IncomingTax && amountBase < 0))
                {
                    return -calculatedBase;
                }
                else
                {
                    return calculatedBase;
                }
            }
            else
            {
                return calculatedBase;
            }
        }
        else
        {
            return calculatedBase;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAmountInclTaxMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the map that contains the amount including tax for transaction lines.
    /// </summary>
    /// <returns>
    ///    The map that contains the amount including tax for the transaction lines.
    /// </returns>
    public Map getAmountInclTaxMap()
    {
        return amountInclTaxMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssessableAmountBase_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets assessable amount base.
    /// </summary>
    /// <returns>
    /// The instance of the <c>TaxBaseCur</c> class.
    /// </returns>
    TaxBaseCur getAssessableAmountBase_IN()
    {
        TaxBaseCur  amountBase;
        Percent     ratio;
        TaxItemGroupHeading                 taxItemGroupHeadingRev;
        LedgerJournalTrans                  ledgerJournalTransRev;
        VendInvoiceInfoLine                 vendInvoiceInfoLine;
        boolean                             isNonPOLine;
        // <GIN>
        CustomsVendBOETrans_IN              customsVendBOETransIN;
        VendInvoiceInfoLineTaxExtension_IN  vendInvoiceInfoLineTaxExtensionIN;
        // </GIN>

        if (lineQty != 0
            && this.sourceTableId() == tableNum(InventQualityOrderTable)
            && (isExciseEnabled
                || isVATEnabled))
        {
            amountBase = salesPurchJournalLineLoc.SalesPurchJournalLine::getSalesPurchJournalLineExtension_IN().AssessableValue * destructiveQty / lineQty;
        }
        else
        {
            if (assessableValue != 0)
            {
                amountBase = assessableValue;
            }
            // Also this code should not execute for Assessable value basis for Non-PO line.
            else if (salesPurchJournalLineLoc.SourceTableId != tableNum(PurchRFQLine))
            {
                if (salesPurchJournalLineLoc.SourceTableId == tableNum(VendInvoiceInfoLine))
                {
                    vendInvoiceInfoLine = salesPurchJournalLineLoc;
                    isNonPOLine = vendInvoiceInfoLine.isNonPO();
                }
                if (!isNonPOLine)
                {
                    if (inventTransferParmLineLoc)
                    {
                        amountBase = inventTransferParmLineLoc.getAssessableValue();
                    }
                    else
                    {
                        amountBase = salesPurchJournalLineLoc.SalesPurchJournalLine::getSalesPurchJournalLineExtension_IN().SalesPurchJournalLineExtension_IN::getAssessableValue();
                    }
                }
            }

            if (salesPurchJournalLineLoc.SourceTableId == tableNum(LedgerJournalTrans))
            {
                ledgerJournalTransRev  = salesPurchJournalLineLoc;
                taxItemGroupHeadingRev = TaxItemGroupHeading::find(ledgerJournalTransRev.TaxItemGroup);
                // If Invoice First and then the same settled by attaching to the payment && Payment is more.
                // Upto the Invoice amount the tax is posted from TaxSettlement_IN.
                // So for the excess amount only the tax Shuould calculate. Below method returns Invoice- Payment which is used as Base for Tax Calulation.
                if (taxItemGroupHeadingRev.ReverseChargePercentage_IN != 0
                   && ServiceTaxRevChargePostingController_IN::isInvoiceFirstThenPayment_IN(ledgerJournalTransRev.TableId, ledgerJournalTransRev.RecId)
                   && LedgerJournalTrans_IN_Extension::existsAdvancePaymentForServiceTax_IN(ledgerJournalTransRev))
                {
                    amountBase = ledgerJournalTransRev.servicetaxBaseamountForAdvancePayment_IN();
                }
            }

            // <GIN>
            // Customs duty is finalized in BOE stage of import order
            if (isCustomsEnabled
                && salesPurchJournalLineLoc.SourceTableId == tableNum(VendInvoiceInfoLine)
                && TaxTable::find(tmpTax.TaxCode).TaxType_IN == TaxType_IN::Customs)
            {
                vendInvoiceInfoLine = salesPurchJournalLineLoc;
                if (vendInvoiceInfoLine.purchTable().isCustomsImportOrder_IN())
                {
                    vendInvoiceInfoLineTaxExtensionIN = vendInvoiceInfoLine.vendInvoiceInfoLineTaxExtension_IN();
                    if (vendInvoiceInfoLineTaxExtensionIN
                        && vendInvoiceInfoLineTaxExtensionIN.SourceTableId == tableNum(CustomsVendBOETrans_IN)
                        && vendInvoiceInfoLineTaxExtensionIN.SourceRecId != 0)
                    {
                        customsVendBOETransIN = CustomsVendBOETrans_IN::find(vendInvoiceInfoLineTaxExtensionIN.SourceRecId);
                        if (customsVendBOETransIN)
                        {
                            amountBase = CurrencyExchangeHelper::amount(customsVendBOETransIN.AssessableValue * vendInvoiceInfoLine.ReceiveNow / customsVendBOETransIN.BillOfEntryQty, vendInvoiceInfoLine.currencyCode);
                        }
                    }
                }
            }
            // </GIN>

            ratio = this.getRatioAmount_IN(salesPurchJournalLineLoc);
            if (ratio)
            {
                amountBase = salesPurchJournalLineLoc.SalesPurchJournalLine::getSalesPurchJournalLineExtension_IN().AssessableValue * ratio;
            }
        }

        return amountBase;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBaseAmountPartition_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets base amount partition.
    /// </summary>
    /// <param name="_taxWorkTrans">
    /// The tax work transaction.
    /// </param>
    /// <param name="_baseAmount">
    /// The base amount.
    /// </param>
    /// <param name="_baseQty">
    /// The base quantity.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxBase</c> class.
    /// </returns>
    protected TaxBase getBaseAmountPartition_IN(
        TmpTaxWorkTrans _taxWorkTrans,
        TaxBase         _baseAmount,
        TaxBase         _baseQty)
    {
        return _baseAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChargeAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the charge amount for specified markup code in current line.
    /// </summary>
    /// <param name="_markupCode">
    /// The markup code.
    /// </param>
    /// <param name="_delimiterVal">
    /// The delimiter for the markup code in the expression.
    /// </param>
    /// <param name="_taxBaseQty">
    /// The tax base quantity.
    /// </param>
    /// <param name="_formula">
    /// The calculation formula, default is 0.000000.
    /// </param>
    /// <returns>
    /// The charge amount.
    /// </returns>
    protected MarkupAmount getChargeAmount_IN(
        MarkupCode  _markupCode,
        str         _delimiterVal,
        TaxBase     _taxBaseQty,
        CalcExp_IN  _formula = "0.000000")
    {
        real                codeNum = 0;
        TableId             markupTransTableId;
        RecId               markupTransRecid;
        MarkupTrans         markupTrans;
        AmountCur           taxBaseAmount;
        real                qtyLoc;
        real                orderQtyLoc;
        AmountCur           lineAmount;

        if (_markupCode == '')
        {
            return codeNum;
        }

        markupTransTableId = salesPurchJournalLineLoc.SourceTableId;
        markupTransRecid   = salesPurchJournalLineLoc.SourceRecId;

        switch (salesPurchJournalLineLoc.SourceTableId)
        {
            case tableNum(PurchLine):
                qtyLoc = PurchLine::findRecId(salesPurchJournalLineLoc.SourceRecId).QtyOrdered;
                orderQtyLoc = baseQty;
                break;
            case tableNum(SalesLine):
                qtyLoc = (SalesLine::findRecId(salesPurchJournalLineLoc.SourceRecId).QtyOrdered);
                orderQtyLoc = baseQty * -1;
                break;
            case tableNum(VendInvoiceInfoLine):
                qtyLoc = (VendInvoiceInfoLine::findRecId(salesPurchJournalLineLoc.SourceRecId).ReceiveNow);
                orderQtyLoc = baseQty;
                break;
            case tableNum(CustInvoiceLine):
                qtyLoc = (CustInvoiceLine::findByParentRecId(salesPurchJournalLineLoc.SourceRecId).Quantity);
                orderQtyLoc = baseQty * -1;
                break;
            case tableNum(SalesQuotationLine):
                qtyLoc = (SalesQuotationLine::findRecId(salesPurchJournalLineLoc.SourceRecId).QtyOrdered);
                orderQtyLoc = baseQty * -1;
                break;
        }

        if ((_delimiterVal == num2char(240)
                && (markupTransTableId      == tableNum(PurchLine)
                    || markupTransTableId   == tableNum(VendInvoiceInfoLine)))
            || (_delimiterVal == num2char(356)
                && (markupTransTableId      == tableNum(SalesLine)
                    || markupTransTableId   == tableNum(CustInvoiceLine)
                    || markupTransTableId   == tableNum(SalesQuotationLine))))
        {
            while select markupTrans
                where markupTrans.TransTableId  == markupTransTableId
                    && markupTrans.TransRecId   == markupTransRecid
                    && markupTrans.MarkupCode   == _markupCode
            {
                lineAmount = salesPurchJournalLineLoc.SalesPurchJournalLine::getLineAmount();

                if (_formula)
                {
                    taxBaseAmount = lineAmount >= 0 ? str2num(_formula) : -str2num(_formula);
                }
                else
                {
                    taxBaseAmount = lineAmount;
                }

                MarkupAmount markupAmount = this.getMarkupAmountFromMarkupCategory(markupTrans, qtyLoc, orderQtyLoc, taxBaseAmount);
                codeNum += markupAmount;
            }
        }

        return codeNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkupAmountFromMarkupCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the charge amount for specified markup transaction based on the markup category.
    /// </summary>
    /// <param name = "_markupTrans">The <c>MarkupTrans</c> record to get the amount for.</param>
    /// <param name = "_qtyLoc">Source document line order quantity.</param>
    /// <param name = "_orderQtyLoc">Order base quantity with the appropriate sign.</param>
    /// <param name = "_taxBaseAmount">Tax base amount.</param>
    /// <returns>The markup amount.</returns>
    protected MarkupAmount getMarkupAmountFromMarkupCategory(MarkupTrans _markupTrans, real _qtyLoc, real _orderQtyLoc, AmountCur _taxBaseAmount)
    {
        MarkupAmount markupAmount;
        switch (_markupTrans.MarkupCategory)
        {
            case MarkupCategory::Fixed:
                if (_qtyLoc == 0 || (this.sourceTableId() == tableNum(InventQualityOrderTable) && (isVATEnabled || isExciseEnabled)))
                {
                    markupAmount = CurrencyExchangeHelper::amount(_markupTrans.Value, _markupTrans.CurrencyCode);
                }
                else
                {
                    markupAmount = CurrencyExchangeHelper::amount(_orderQtyLoc * _markupTrans.Value / _qtyLoc, _markupTrans.CurrencyCode);
                }
                break;
            case MarkupCategory::Pcs:
                markupAmount = CurrencyExchangeHelper::amount(_orderQtyLoc * _markupTrans.Value, _markupTrans.CurrencyCode);
                break;
            case MarkupCategory::UnitSpecific:
            case MarkupCategory::UnitSpecificMatch:
                if (AutoChargesSetupLineLevelUnitOfMeasureFeature::instance().IsEnabled())
                {
                    real orderQtySpecificUoM = Markup::markupUnitOfMeasureQuantity(_markupTrans, _orderQtyLoc);
                    markupAmount = CurrencyExchangeHelper::amount(orderQtySpecificUoM * _markupTrans.Value, _markupTrans.CurrencyCode);
                }
                break;
            case MarkupCategory::Percent:
                markupAmount = CurrencyExchangeHelper::amount(_taxBaseAmount * _markupTrans.Value / 100, _markupTrans.CurrencyCode);
                break;
        }
        return markupAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the company which has the tax obligation.
    /// </summary>
    /// <returns>
    ///   The company which has the tax obligation.
    /// </returns>
    /// <remarks>
    ///   If the current source document does not support intercompany transactions
    ///   then the return value will always be the current logged in company.
    /// </remarks>
    public SelectableDataArea getCompany()
    {
        return curext();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompanyCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>Currency</c> record for the accounting currency.
    /// </summary>
    /// <returns>
    /// A <c>Currency</c> record.
    /// </returns>
    protected Currency getCompanyCurrency()
    {
        if (!cachedCompanyCurrency)
        {
            cachedCompanyCurrency = Currency::find(Ledger::accountingCurrency());
        }

        return cachedCompanyCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustInvoiceJour_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to get the <c>CustInvoiceJour</c> table.
    /// </summary>
    /// <param name="_taxTrans">
    /// A buffer of <c>TaxTrans</c> table.
    /// </param>
    /// <returns>
    /// Returns the <c>CustInvoiceJour</c> table.
    /// </returns>
    public CustInvoiceJour getCustInvoiceJour_IN(TaxTrans _taxTrans)
    {
        CustInvoiceJour  custInvoiceJour;

        select custInvoiceJour
                where custInvoiceJour.LedgerVoucher == _taxTrans.Voucher
                   && custInvoiceJour.InvoiceDate   == _taxTrans.TransDate;

        return custInvoiceJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustInvoiceTransLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to get the <c>CustInvoiceTrans</c> table.
    /// </summary>
    /// <param name="_taxTrans">
    /// A buffer of <c>TaxTrans</c> table.
    /// </param>
    /// <param name="_custInvoiceJour">
    /// A buffer of <c>CustInvoiceJour</c> table.
    /// </param>
    /// <returns>
    /// Returns the <c>CustInvoiceTrans</c> table.
    /// </returns>
    CustInvoiceTrans getCustInvoiceTransLine_IN(TaxTrans _taxTrans, CustInvoiceJour  _custInvoiceJour)
    {
        CustInvoiceTrans custInvoiceTrans;

        select custInvoiceTrans
            where custInvoiceTrans.SalesId              == _custInvoiceJour.SalesId
               && custInvoiceTrans.InvoiceId            == _custInvoiceJour.InvoiceId
               && custInvoiceTrans.InvoiceDate          == _custInvoiceJour.InvoiceDate
               && custInvoiceTrans.NumberSequenceGroup  == _custInvoiceJour.NumberSequenceGroup
               && custInvoiceTrans.InventTransId        == _taxTrans.InventTransId;

        return custInvoiceTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomsAccNum_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets customs account number.
    /// </summary>
    /// <param name="_direction">
    /// The direction.
    /// </param>
    /// <returns>
    /// The instance of the <c>RefRecId</c> class.
    /// </returns>
    public RefRecId getCustomsAccNum_IN(Direction_IN   _direction)
    {
        RefRecId   accountNum;

        if (_direction == Direction_IN::Export)
        {
            accountNum =  customsExpAccNum;
        }
        else if (_direction == Direction_IN::Import)
        {
            accountNum =  customsImpAccNum;
        }

        return accountNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomsDuty_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates total CustomsDuty looping thru tmptaxWorkTrans table based on sourceTableId and sourceRecId.
    /// </summary>
    /// <param name = "_inventTransId">The inventTransId.</param>
    /// <returns>
    /// returns CustomsDuty amount.
    /// </returns>
    public TaxAmount getCustomsDuty_IN(TradeInventTransId _inventTransId = '')
    {
        TaxAmount customsDutyLoc;
        TaxTable  taxTableLoc;

        while select SourceRegulateAmountCur, SourceTaxAmountCur from  taxWorkTrans
            join RecId from taxTableLoc
                where taxTableLoc.TaxCode    == taxWorkTrans.TaxCode
                   && taxTableLoc.TaxType_IN == TaxType_IN::Customs
        {
            customsDutyLoc += (!taxWorkTrans.SourceRegulateAmountCur) ? taxWorkTrans.SourceTaxAmountCur : taxWorkTrans.SourceRegulateAmountCur;
        }

        return customsDutyLoc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomsDutyProjects_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates total CustomsDuty looping thru tmptaxWorkTrans table based on sourceTableId
    /// </summary>
    /// <param name="_tableId">
    /// The sourceTableId.
    /// </param>
    /// <returns>
    /// returns CustomsDuty amount.
    /// </returns>
    public TaxAmount getCustomsDutyProjects_IN(RefTableId _tableId)
    {
        TaxAmount   taxAmount;

        while select SourceTaxAmountCur, SourceRegulateAmountCur from taxWorkTrans
            where   taxWorkTrans.SourceTableId   == _tableId
        {
            if (TaxTable::find(taxWorkTrans.TaxCode).TaxType_IN == TaxType_IN::Customs)
            {
                if (taxWorkTrans.SourceRegulateAmountCur)
                {
                    taxAmount += taxWorkTrans.SourceRegulateAmountCur;
                }
                else
                {
                    taxAmount += taxWorkTrans.SourceTaxAmountCur;
                }
            }
        }
        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomsExchRate_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets customs exchange rate.
    /// </summary>
    /// <param name="_sourceCurrencyCode">
    /// The source currency code.
    /// </param>
    /// <returns>
    /// The instance of the <c>CustomsExchangeRate_IN</c> class.
    /// </returns>
    protected CustomsExchangeRate_IN getCustomsExchRate_IN(CurrencyCode _sourceCurrencyCode)
    {
        CustomsVendBOESubTrans_IN   customsVendBOESubTrans;
        CustomsVendBOETrans_IN      customsVendBOETrans;
        CustomsExchangeRate_IN      customsExchRate = 1;
        TransDate                   transDateLoc;

        select firstonly boeTransRefRecId
            from customsVendBOESubTrans
            order by BillOfEntryDate
            where customsVendBOESubTrans.InventTransId == taxWorkTrans.InventTransId
               && customsVendBOESubTrans.TaxCode       == taxWorkTrans.TaxCode;

        transDateLoc = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

        if (customsVendBOESubTrans)
        {
            customsVendBOETrans = CustomsVendBOETrans_IN::findRecId(customsVendBOESubTrans.boeTransRefRecId);
            transDateLoc = customsVendBOETrans.BillOfEntryDate;
            customsExchRate = TaxExchangeRateHelper::getCustomsExchangeRate_IN(
                                                            _sourceCurrencyCode,
                                                            Direction_IN::Import,
                                                            transDateLoc);
        }

        return customsExchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultAmountMSTSecondaryToPost_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Returns default amount in secondary currency to post (to be overriden by subclasses)
    /// </summary>
    /// <param name="_taxTrans">Tax transaction</param>
    /// <returns>amount for post method</returns>
    protected AmountMSTSecondary getDefaultAmountMSTSecondaryToPost_RU(TaxTrans _taxTrans)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the default dimension.
    /// </summary>
    /// <param name="_sourceRecId">
    /// The record Id of the parent of the tax line.
    /// </param>
    /// <returns>
    ///  A <c>DimensionDefault</c> value.
    /// </returns>
    /// <remarks>
    /// This method will be overridden.
    /// </remarks>
    public DimensionDefault getDefaultDimension(RefRecId _sourceRecId)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the invoice ID for the current transaction.
    /// </summary>
    /// <returns>
    ///    The invoice ID for the current transaction line.
    /// </returns>
    public InvoiceId getInvoiceId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaintainExistingTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether new records will be added to the <c>TaxUncommitted</c> table.
    /// </summary>
    /// <returns>
    ///    true if newly calculated tax lines will be added to the <c>TaxUncommitted</c> table; otherwise,
    ///    false.
    /// </returns>
    public boolean getMaintainExistingTaxUncommitted()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMRPAmountBase_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the MRP amount base.
    /// </summary>
    /// <param name="_taxBaseQty">
    /// The tax base quantity.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxBaseCur</c> class.
    /// </returns>
    TaxBaseCur getMRPAmountBase_IN(TaxBase  _taxBaseQty)
    {
        TaxBaseCur  amountBase;
        Percent     ratio;

        if (maximumRetailPrice != 0)
        {
            amountBase  = _taxBaseQty * maximumRetailPrice;
        }
        else
        {
            if (_taxBaseQty != 0)
            {
                amountBase  = _taxBaseQty * salesPurchJournalLineLoc.SalesPurchJournalLine::parmMaximumRetailPrice();
            }
            else
            {
                amountBase = salesPurchJournalLineLoc.SalesPurchJournalLine::parmMaximumRetailPrice();
            }
        }
        if (classIdGet(this) == classNum(TaxFreeInvoice) || classIdGet(this) == classNum(TaxFreeInvoice_Invoice))
        {
            amountBase = salesPurchJournalLineLoc.SalesPurchJournalLine::parmMaximumRetailPrice();
        }
        ratio = this.getRatioAmount_IN(salesPurchJournalLineLoc);
        if (ratio)
        {
            amountBase = salesPurchJournalLineLoc.SalesPurchJournalLine::getSalesPurchJournalLineExtension_IN().AssessableValue * ratio;
        }
        return amountBase;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOperationLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Retrieves the operation account.
    /// </summary>
    /// <param name="_sourceRecId">
    ///    The record Id of the parent of the tax line.
    /// </param>
    /// <returns>
    ///   A <c>LedgerDimensionAccount</c> value.
    /// </returns>
    public LedgerDimensionAccount getOperationLedgerDimension(RefRecId _sourceRecId)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginForSourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines the origin for the transaction line.
    /// </summary>
    /// <param name="_tableId">
    ///    Table ID of the transaction line.
    /// </param>
    /// <param name="_recId">
    ///    Record ID of the transaction line.
    /// </param>
    /// <param name="_useDisplaySign">
    ///    true if the tax amount should have the proper sign for displaying on the user interface; otherwise, false.
    /// </param>
    /// <param name="_lineAmount">
    ///    Line amount including tax.
    /// </param>
    /// <param name="_roundedResult">
    ///    true if the result should be rounded; otherwise, false.
    /// </param>
    /// <returns>
    ///    The tax origin for the transaction line if an origin could be determined; otherwise 0.
    /// </returns>
    public TaxBase getOriginForSourceLine(RefTableId _tableId, RefRecId _recId, boolean _useDisplaySign = false, AmountCur _lineAmount = 0, boolean _roundedResult = true)
    {
        TaxTable    taxTable;
        TaxAmountCur    taxAmountCur;
        // <GEECZ>
        TaxBaseCur  sourceBaseAmount;
        boolean     isIntracomVAT = false;
        // </GEECZ>

        select firstonly SourceBaseAmountCur, SourceBaseAmountCurRaw, TaxDirection
            //<GEECZ>
            ,TaxGroup, TaxCode
            //</GEECZ>
            from taxWorkTrans
            where taxWorkTrans.SourceRecId == _recId &&
                taxWorkTrans.SourceTableId == _tableId &&
                taxWorkTrans.TaxDirection != TaxDirection::UseTax &&
                taxWorkTrans.IsDeleted == NoYes::No &&
                (taxWorkTrans.Source != taxModuleType::Purch
                    || (taxWorkTrans.Source == taxModuleType::Purch && taxWorkTrans.ReverseCharge_W == NoYes::No))
            join RecId, TaxLimitBase, TaxBase from taxTable
                where taxTable.TaxBase != TaxBaseType::PctPerGross &&
                    //<GEEU>
                    taxTable.TaxCode == taxWorkTrans.TaxCode &&
                    //</GEEU>
                    // <GIN>
                    taxTable.TaxType_IN == TaxType_IN::None &&
                    // </GIN>
                    taxTable.TaxBase != TaxBaseType::AmountByUnit &&
                    taxTable.TaxOnTax == '';

        if (taxTable
            && taxTable.TaxBase == TaxBaseType::PctPerMargin
            && Tax::isTaxIntegrationEnabledForTable(_tableId))
        {
            sourceBaseAmount = this.getOriginForSourceLineFromTransactionLine(taxWorkTrans, _useDisplaySign);
            if (sourceBaseAmount)
            {
                return sourceBaseAmount;
            }
        }

        if (!taxWorkTrans.RecId)
        {
            select firstonly SourceBaseAmountCur, SourceBaseAmountCurRaw, TaxDirection
                //<GEECZ>
                ,IntracomVAT
                //</GEECZ>
                from taxWorkTrans
                where taxWorkTrans.SourceRecId == _recId &&
                    taxWorkTrans.SourceTableId == _tableId &&
                    taxWorkTrans.IsDeleted == NoYes::No &&
                    (taxWorkTrans.Source != taxModuleType::Purch
                        || (taxWorkTrans.Source == taxModuleType::Purch && taxWorkTrans.ReverseCharge_W == NoYes::No))
                join RecId from taxTable
                    where taxTable.TaxBase != TaxBaseType::AmountByUnit &&
                    taxTable.TaxCode == taxWorkTrans.TaxCode &&
                    // <GIN>
                    taxTable.TaxType_IN == TaxType_IN::None &&
                    // </GIN>
                    taxTable.TaxOnTax == '';
        }

        // <GEECZ>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoES]) &&

        TaxGroupData::find(taxWorkTrans.TaxGroup, taxWorkTrans.TaxCode).IntracomVAT)
        {
            isIntracomVAT = true;
        }
        // </GEECZ>

        boolean taxAmountCalculated;
        if (_roundedResult && taxWorkTrans.SourceBaseAmountCur)
        {
            sourceBaseAmount = taxWorkTrans.SourceBaseAmountCur;
        }
        else
        {
            if (!_roundedResult && taxWorkTrans.SourceBaseAmountCurRaw)
            {
                if (taxTable.TaxLimitBase == TaxLimitBase::LineWithoutVAT && this.taxParameters().CalculatePrinciple == TaxCalcPrin::Line)
                {
                    sourceBaseAmount = taxWorkTrans.SourceBaseAmountCur;
                }
                else
                {
                    sourceBaseAmount = taxWorkTrans.SourceBaseAmountCurRaw;

                    if (taxTable.taxRoundOff != 0)
                    {
                        Amount diffSourceAmount = CurrencyExchangeHelper::amount(abs(sourceBaseAmount + taxWorkTrans.SourceRegulateAmountCur) - abs(_lineAmount), taxWorkTrans.CurrencyCode);

                        if (diffSourceAmount == 0.01)
                        {
                            sourceBaseAmount = CurrencyExchange::roundWithRule(sourceBaseAmount, taxTable.TaxRoundOff, RoundOffType::RoundDown);
                        }
                        else if (diffSourceAmount == -0.01)
                        {
                            sourceBaseAmount = CurrencyExchange::roundWithRule(sourceBaseAmount, taxTable.TaxRoundOff, RoundOffType::RoundUp);
                        }
                    }
 
                }
            }
            else
            {
                taxAmountCur = this.totalRegulatedTaxAmountSingleLine(_tableId, _recId, false, false

                                                                // <GIN>
                                                                ,false
                                                                // </GIN>
                                                                );
                if (taxAmountCur && !prmisDefault(_lineAmount))
                {
                    sourceBaseAmount = _lineAmount - taxAmountCur;
                }
                taxAmountCalculated = true;
            }
        }

        if (_useDisplaySign

        // <GEECZ>
        && !isIntracomVAT)
    // </GEECZ>
        {
            sourceBaseAmount = Tax::changeDisplaySign(taxWorkTrans.TaxDirection) * sourceBaseAmount;
        }

        // fix tax per unit and gross amount combination issue and tax per unit, tax inclusive, tax rate is positive, transaction is SO or FTI issue
        select firstonly SourceBaseAmountCur, SourceBaseAmountCurRaw, TaxDirection ,TaxGroup, TaxCode
            from taxWorkTrans
            where taxWorkTrans.SourceRecId == _recId
                && taxWorkTrans.SourceTableId == _tableId
                && taxWorkTrans.TaxDirection != TaxDirection::UseTax
                && taxWorkTrans.IsDeleted == NoYes::No
            join RecId, TaxLimitBase from taxTable
                where taxTable.TaxBase == TaxBaseType::AmountByUnit
                    && taxTable.TaxCode == taxWorkTrans.TaxCode
                    && taxTable.TaxType_IN == TaxType_IN::None
                    && taxTable.TaxOnTax == '';

        if (taxWorkTrans.RecId)
        {
            TaxCode amountByUnitTaxCode = taxWorkTrans.TaxCode;

            select firstonly SourceBaseAmountCur, SourceBaseAmountCurRaw, TaxDirection, TaxGroup, TaxCode
                from taxWorkTrans
                where taxWorkTrans.SourceRecId == _recId
                    && taxWorkTrans.SourceTableId == _tableId
                    && taxWorkTrans.TaxDirection != TaxDirection::UseTax
                    && taxWorkTrans.IsDeleted == NoYes::No
                join RecId, TaxLimitBase from taxTable
                    where taxTable.TaxBase == TaxBaseType::PctPerGross
                        && taxTable.TaxCode == taxWorkTrans.TaxCode
                        && taxTable.TaxType_IN == TaxType_IN::None
                        && taxTable.TaxOnTax == '';

            if (taxWorkTrans.RecId)
            {
                if (!taxAmountCalculated)
                {
                    taxAmountCur = this.totalRegulatedTaxAmountSingleLine(_tableId, _recId, false, false ,false);
                }
                if (taxAmountCur && !prmisDefault(_lineAmount))
                {
                    sourceBaseAmount = abs(_lineAmount) - abs(taxAmountCur);
                    sourceBaseAmount = (_lineAmount > 0 ? 1: -1) * sourceBaseAmount;
                }
            }
            else if (taxAmountCalculated
                && (_tableId == tableNum(SalesLine) || _tableId == tableNum(CustInvoiceLine)))
            {
                // Fix tax per unit, tax inclusive, tax value is positive, transaction is SO or FTI issue. Bug 606098.
                TaxData taxData;
                select firstonly TaxValue from taxData
                    where taxData.TaxCode == amountByUnitTaxCode;

                if (taxData.TaxValue >= 0
                    && taxAmountCur
                    && !prmisDefault(_lineAmount))
                {
                    sourceBaseAmount = abs(_lineAmount) - abs(taxAmountCur);
                    sourceBaseAmount = (_lineAmount > 0 ? 1: -1) * sourceBaseAmount;
                }
            }
        }

        return sourceBaseAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginForSourceLineFromTransactionLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the origin for the source line from transaction line. This works for the case tax calculation service is enabled.
    /// </summary>
    /// <param name = "_taxWorkTrans">
    /// The related <c>TmpTaxWorkTrans</c> record.
    /// </param>
    /// <param name = "_useDisplaySign">
    /// true if the tax amount should have the proper sign for displaying on the user interface; otherwise, false.
    /// </param>
    /// <returns>
    /// The tax origin for the transaction line if an origin could be determined; otherwise 0.
    /// </returns>
    private AmountCur getOriginForSourceLineFromTransactionLine(TmpTaxWorkTrans _taxWorkTrans, boolean _useDisplaySign = false)
    {
        AmountCur result;

        // Get the line amount excluding tax from SalesParmLine in case the tax is calculated as "Percentage of margin".
        if (_taxWorkTrans.SourceTableId == tableNum(SalesLine) && _taxWorkTrans.ParentSourceTableId == tableNum(SalesParmTable))
        {
            SalesLine salesLine;
            SalesParmLine salesParmLine;
            SalesParmTable salesParmTable;

            select firstonly RecId from salesLine
                where salesLine.RecId == _taxWorkTrans.SourceRecId
                join RecId, LineAmountExcludeTax from salesParmLine
                    where salesParmLine.SalesLineRecId == salesLine.RecId
                    join RecId from salesParmTable
                        where salesParmTable.RecId == _taxWorkTrans.ParentSourceRecId
                            && salesParmTable.ParmId == salesParmLine.ParmId;

            if (salesParmLine)
            {
                result = salesParmLine.LineAmountExcludeTax;
            }
            else
            {
                return result;
            }
        }

        boolean isIntracomVAT = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoES])
            && TaxGroupData::find(_taxWorkTrans.TaxGroup, _taxWorkTrans.TaxCode).IntracomVAT;

        if (_useDisplaySign && !isIntracomVAT)
        {
            result = Tax::changeDisplaySign(_taxWorkTrans.TaxDirection) * result;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginForSourceLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines the origin for the transaction line.
    /// </summary>
    /// <param name="_tableId">
    ///    Table ID of the transaction line.
    /// </param>
    /// <param name="_recId">
    ///    Record ID of the transaction line.
    /// </param>
    /// <returns>
    ///    The tax origin for the transaction line if an origin could be determined; otherwise 0.
    /// </returns>
    public TaxBase getOriginForSourceLine_IN(RefTableId _tableId, RefRecId _recId)
    {
        TaxTable    taxTable;
        TaxBaseCur  sourceBaseAmount;

        select firstonly SourceBaseAmountCur, RecId

                  from taxWorkTrans
        where taxWorkTrans.SourceRecId == _recId &&
              taxWorkTrans.SourceTableId == _tableId &&
              taxWorkTrans.TaxDirection != TaxDirection::UseTax &&
              taxWorkTrans.IsDeleted == NoYes::No
        exists join taxTable
        where taxTable.TaxCode == taxWorkTrans.TaxCode &&
              taxTable.TaxType_IN != TaxType_IN::None &&
              taxTable.TaxBase != TaxBaseType::PctPerGross &&
              taxTable.TaxBase != TaxBaseType::AmountByUnit &&
              taxTable.TaxOnTax == '';

        if (!taxWorkTrans.RecId)
        {
            select firstonly SourceBaseAmountCur

                  from taxWorkTrans
            where taxWorkTrans.SourceRecId == _recId &&
                  taxWorkTrans.SourceTableId == _tableId &&
                  taxWorkTrans.IsDeleted == NoYes::No
            exists join taxTable
            where taxTable.TaxBase != TaxBaseType::AmountByUnit &&
                  taxTable.TaxCode == taxWorkTrans.TaxCode &&
                  taxTable.TaxType_IN != TaxType_IN::None &&
                  taxTable.TaxOnTax == '';
        }

        if (taxWorkTrans.SourceBaseAmountCur)
        {
            sourceBaseAmount = taxWorkTrans.SourceBaseAmountCur;
        }

        return sourceBaseAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPostingType_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets posting type.
    /// </summary>
    /// <param name="_taxType">
    /// The tax type.
    /// </param>
    /// <returns>
    /// The instance of the <c>LedgerPostingType</c> class.
    /// </returns>
    public LedgerPostingType getPostingType_IN(TaxType_IN _taxType)
    {
        switch (_taxType)
        {
            case TaxType_IN::VAT:
                taxPostingType = LedgerPostingType::VAT_IN;
                break;

            case TaxType_IN::SalesTax:
                taxPostingType = LedgerPostingType::SalesTax_IN;
                break;

            case TaxType_IN::ServiceTax:
                taxPostingType = LedgerPostingType::ServiceTax_IN;
                break;

            case TaxType_IN::Excise:
                taxPostingType = LedgerPostingType::Excise_IN;
                break;

            case TaxType_IN::Customs:
                taxPostingType = LedgerPostingType::Customs_IN;
                break;
            default :
                taxPostingType = LedgerPostingType::Tax;
        }
        return taxPostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRatioAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the funding source perecnt for the respective transaction.
    /// </summary>
    /// <param name="_salesPurchJournalLineLoc">
    /// salesPurchJournalLine tabled id set.
    /// </param>
    /// <returns>
    /// The funding source perecnt for the respective transaction.
    /// </returns>
    public Percent getRatioAmount_IN(SalesPurchJournalLine _salesPurchJournalLineLoc)
    {
        Percent                     ratio;
        AmountCur                   transTurnover;
        ProjProposalEmpl            projProposalEmpl;
        ProjProposalEmplDetail      projProposalEmplDetail;
        ProjProposalRevenue         projProposalRevenue;
        ProjProposalRevenueDetail   projProposalRevenueDetail;
        ProjProposalItem            projProposalItem;
        ProjProposalItemDetail      projProposalItemDetail;
        ProjProposalCost            projProposalCost;
        ProjProposalCostDetail      projProposalCostDetail;
        ProjProposalOnAcc           projProposalOnAcc;
        ProjProposalOnAccDetail     projProposalOnAccDetail;
        ProjEmplTransSale           projEmplTransSale;
        ProjCostTransSale           projCostTransSale;
        ProjRevenueTransSale        projRevenueTransSale;
        ProjItemTransSale           projItemTransSale;
        ProjOnAccTransSale          projOnAccTransSale;

        if (_salesPurchJournalLineLoc.SourceTableId == tableNum(ProjEmplTrans))
        {
            select firstonly LineAmount, TransId from projEmplTransSale
                join SaleRefRecId from projProposalEmplDetail
                    where projEmplTransSale.RecId == projProposalEmplDetail.SaleRefRecId
                join RecId from projProposalEmpl
                    where projProposalEmplDetail.ProposalRefRecId == projProposalEmpl.RecId
                        && projProposalEmpl.RecId == this.sourceRecId()
                        && projProposalEmpl.TableId == this.sourceTableId();

            if (projEmplTransSale.LineAmount)
            {
                transTurnover = projEmplTransSale.projEmplTrans().transTurnover();
                if (transTurnover)
                {
                    ratio = projEmplTransSale.LineAmount / transTurnover;
                }
            }
        }
        else if (_salesPurchJournalLineLoc.SourceTableId == tableNum(ProjRevenueTrans))
        {
            select firstonly LineAmount, TransId from projRevenueTransSale
                join SaleRefRecId from projProposalRevenueDetail
                    where projRevenueTransSale.RecId == projProposalRevenueDetail.SaleRefRecId
                join RecId from projProposalEmpl
                    where projProposalRevenueDetail.ProposalRefRecId == projProposalRevenue.RecId
                        && projProposalRevenue.RecId == this.sourceRecId()
                        && projProposalRevenue.TableId == this.sourceTableId();

            if (projRevenueTransSale.LineAmount)
            {
                transTurnover = projRevenueTransSale.projRevenueTrans().transTurnover();
                if (transTurnover)
                {
                    ratio = projRevenueTransSale.LineAmount / transTurnover;
                }
            }
        }
        else if (_salesPurchJournalLineLoc.SourceTableId == tableNum(ProjItemTrans))
        {
            select firstonly LineAmount, ProjTransId from projItemTransSale
                join SaleRefRecId from projProposalItemDetail
                    where projItemTransSale.RecId == projProposalItemDetail.SaleRefRecId
                join RecId from projProposalItem
                    where projProposalItemDetail.ProposalRefRecId == projProposalItem.RecId
                        && projProposalItem.RecId == this.sourceRecId()
                        && projProposalItem.TableId == this.sourceTableId();

            if (projItemTransSale.LineAmount)
            {
                transTurnover = projItemTransSale.projItemTrans().transTurnover();
                if (transTurnover)
                {
                    ratio = projItemTransSale.LineAmount / transTurnover;
                }
            }
        }
        else if (_salesPurchJournalLineLoc.SourceTableId == tableNum(ProjCostTrans))
        {
            select firstonly LineAmount, TransId from projCostTransSale
                join SaleRefRecId from projProposalCostDetail
                    where projCostTransSale.RecId == projProposalCostDetail.SaleRefRecId
                join RecId from projProposalCost
                    where projProposalCostDetail.ProposalRefRecId == projProposalCost.RecId
                        && projProposalCost.RecId == this.sourceRecId()
                        && projProposalCost.TableId == this.sourceTableId();

            if (projCostTransSale.LineAmount)
            {
                transTurnover = projCostTransSale.projCostTrans().transTurnover();
                if (transTurnover)
                {
                    ratio = projCostTransSale.LineAmount / transTurnover;
                }
            }
        }
        else if (_salesPurchJournalLineLoc.SourceTableId == tableNum(ProjOnAccTrans))
        {
            select firstonly Amount, TransId from projOnAccTransSale
                join SaleRefRecId from projProposalCostDetail
                    where projOnAccTransSale.RecId == projProposalOnAccDetail.SaleRefRecId
                join RecId from projProposalOnAcc
                    where projProposalOnAccDetail.ProposalRefRecId == projProposalOnAcc.RecId
                        && projProposalOnAcc.RecId == this.sourceRecId()
                        && projProposalOnAcc.TableId == this.sourceTableId();

            if (projOnAccTransSale.Amount)
            {
                transTurnover = projOnAccTransSale.projOnAccTrans().transTurnover();
                if (transTurnover)
                {
                    ratio = projOnAccTransSale.Amount / transTurnover;
                }
            }
        }
        return ratio;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRegistrationNumber_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets registration number.
    /// </summary>
    /// <param name="_taxtype">
    /// The tax type.
    /// </param>
    /// <param name="_salesPurchJournalLine">
    /// The sales purch journal line.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxRegistrationNumber_IN</c> class.
    /// </returns>
    public TaxRegistrationNumber_IN getRegistrationNumber_IN(TaxType_IN _taxtype, SalesPurchJournalLine _salesPurchJournalLine)
    {
        TaxRegistrationNumber_IN registrationNumber;
        LedgerJournalTrans       ledgerJournalTrans;
        CustInvoiceTable         custInvoiceTable;
        TransTaxInformation      transTaxInformation;

        transTaxInformation = transTaxInformationHelper.getTransTaxInformation(_salesPurchJournalLine.SourceTableId, _salesPurchJournalLine.SourceRecId);

        if (_salesPurchJournalLine.SourceTableId == tableNum(CustInvoiceLine))
        {
            select OrderAccount from custInvoiceTable
                where custInvoiceTable.InvoiceId == CustInvoiceJour::findRecId(headingRecId).InvoiceId;
        }

        switch (_taxtype)
        {
            case TaxType_IN::VAT:
            case TaxType_IN::SalesTax:
                if (_salesPurchJournalLine.SourceTableId == tableNum(CustInvoiceLine))
                {
                    registrationNumber  = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(CustTable::find(custInvoiceTable.OrderAccount).Party)).getTaxRegistrationNumbersTable(_taxtype).RegistrationNumber;
                }
                else if (_salesPurchJournalLine.SourceTableId == tableNum(PurchLine))
                {
                    registrationNumber = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(VendTable::find(PurchLine::findRecId(_salesPurchJournalLine.SourceRecId).VendAccount).Party)).getTaxRegistrationNumbersTable(_taxtype).RegistrationNumber;
                }
                else if (_salesPurchJournalLine.SourceTableId == tableNum(SalesLine))
                {
                    registrationNumber = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(CustTable::find(SalesLine::findRecId(_salesPurchJournalLine.SourceRecId).CustAccount).Party)).getTaxRegistrationNumbersTable(_taxtype).RegistrationNumber;
                }
                else if (_salesPurchJournalLine.SourceTableId == tableNum(LedgerJournalTrans))
                {
                    ledgerJournalTrans  = LedgerJournalTrans::findRecId(_salesPurchJournalLine.SourceRecId, false);

                    if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
                    {
                        registrationNumber = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(VendTable::findByLedgerDimension(ledgerJournalTrans.LedgerDimension).Party)).getTaxRegistrationNumbersTable(_taxtype).RegistrationNumber;
                    }
                    else if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
                    {
                        registrationNumber = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(VendTable::findByLedgerDimension(ledgerJournalTrans.OffsetLedgerDimension).Party)).getTaxRegistrationNumbersTable(_taxtype).RegistrationNumber;
                    }
                    if (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
                    {
                        registrationNumber = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(CustTable::findByLedgerDimension(ledgerJournalTrans.LedgerDimension).Party)).getTaxRegistrationNumbersTable(_taxtype).RegistrationNumber;
                    }
                    else if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
                    {
                        registrationNumber = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(CustTable::findByLedgerDimension(ledgerJournalTrans.OffsetLedgerDimension).Party)).getTaxRegistrationNumbersTable(_taxtype).RegistrationNumber;
                    }
                }
                break;
            case TaxType_IN::Excise:
            case TaxType_IN::ServiceTax:
            case TaxType_IN::Customs:
                if (_salesPurchJournalLine.SourceTableId == tableNum(CustInvoiceLine))
                {
                    registrationNumber = TaxInformation_IN::findDefaultbyLocation(
                        DirParty::primaryPostalAddressLocationRecId(
                            CustTable::find(custInvoiceTable.OrderAccount).Party)).getTaxRegistrationNumbersTable(
                                _taxType, transTaxInformation.ExciseType).RegistrationNumber;
                }
                else if (_salesPurchJournalLine.SourceTableId == tableNum(PurchLine))
                {
                    registrationNumber = TaxInformation_IN::findDefaultbyLocation(
                        DirParty::primaryPostalAddressLocationRecId(
                            VendTable::find(
                                PurchLine::findRecId(
                                    _salesPurchJournalLine.SourceRecId).VendAccount).Party)).getTaxRegistrationNumbersTable(
                                        _taxType, transTaxInformation.ExciseType).RegistrationNumber;
                }
                else if (_salesPurchJournalLine.SourceTableId == tableNum(SalesLine))
                {
                    registrationNumber = TaxInformation_IN::findDefaultbyLocation(
                        DirParty::primaryPostalAddressLocationRecId(
                            CustTable::find(
                                SalesLine::findRecId(
                                    _salesPurchJournalLine.SourceRecId).CustAccount).Party)).getTaxRegistrationNumbersTable(
                                        _taxType, transTaxInformation.ExciseType).RegistrationNumber;
                }
                break;
            default:
                break;
        }
        return registrationNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRelatedVoucher_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets related voucher.
    /// </summary>
    /// <returns>
    /// The instance of the <c>Voucher</c> class.
    /// </returns>
    public Voucher getRelatedVoucher_IN()
    {
        NumberSeq               numberSeqRelatedVoucher;
        NumberSequenceReference numberSeqRefRelatedVoucher;

        if (relatedVoucher == '')
        {
            numberSeqRefRelatedVoucher = VendParameters::numRefVendPaymentVoucher();
            numberSeqRelatedVoucher = NumberSeq::newGetVoucher(numberSeqRefRelatedVoucher, true);
            relatedVoucher = numberSeqRelatedVoucher.voucher();
        }

        return relatedVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalePurchJourLineFrmTaxUnCommitted_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to get sales purch journal line based on the invent Id.
    /// </summary>
    /// <param name="_taxUncommitted">
    /// The <c>TaxUncommitted</c> Buffer passed to get the SalesPurchJournalLine map value.
    /// </param>
    /// <returns>
    /// Returns the <c>SalesPurchJournalLine</c> map.
    /// </returns>
    SalesPurchJournalLine  getSalePurchJourLineFrmTaxUnCommitted_IN(TaxUncommitted _taxUncommitted)
    {
        SalesPurchJournalLine               salesPurchJournalLine;
        SalesPurchJournalLineExtension_IN   salesPurchJournalLineExt;
        InventTransferLine                  inventTransferLine;
        VendInvoiceInfoLine                 vendInvoiceInfoLineLoc;
        VendInvoiceInfoLine_W               vendInvoiceInfoLine_W;

        switch (_taxUncommitted.Source)
        {
            case TaxModuleType::Purch:
                if (_taxUncommitted.SourceTableId == tableNum(VendInvoiceTrans)
                    || (_taxUncommitted.SourceTableId == tableNum(VendInvoiceInfoLine) && !_taxUncommitted.InventTransId))
                {
                    vendInvoiceInfoLineLoc = VendInvoiceInfoLine::findSourceDocumentLine(_taxUncommitted.parmParentSourceDocumentLine().RecId);
                    if (vendInvoiceInfoLineLoc.RecId && vendInvoiceInfoLineLoc.isNonPO())
                    {
                        vendInvoiceInfoLine_W = vendInvoiceInfoLineLoc.vendInvoiceInfoLine_W();

                        salesPurchJournalLine = vendInvoiceInfoLineLoc;
                        salesPurchJournalLine.SourceTableId                 = vendInvoiceInfoLineLoc.TableId;
                        salesPurchJournalLine.SourceRecId                   = vendInvoiceInfoLineLoc.RecId;
                        salesPurchJournalLine.TaxItemGroup                  = vendInvoiceInfoLineLoc.TaxItemGroup;
                        salesPurchJournalLine.CurrencyCode                  = vendInvoiceInfoLineLoc.CurrencyCode;
                        salesPurchJournalLine.TaxGroup                      = vendInvoiceInfoLineLoc.TaxGroup;
                        salesPurchJournalLine.LineNum                       = vendInvoiceInfoLineLoc.LineNum;
                        salesPurchJournalLine.SalesPurchJournalLine::parmAssessableValue(vendInvoiceInfoLine_W.AssessableValue_IN);
                        salesPurchJournalLine.SalesPurchJournalLine::parmMaximumRetailPrice(vendInvoiceInfoLine_W.MaximumRetailPrice_IN);
                    }
                    else if (vendInvoiceInfoLineLoc.RecId && !vendInvoiceInfoLineLoc.isNonPO())
                    {
                        salesPurchJournalLine = VendInvoiceInfoLine::findSourceDocumentLine(_taxUncommitted.parmParentSourceDocumentLine().RecId).purchLine();
                    }
                }
                else
                {
                    salesPurchJournalLine = PurchLine::findInventTransId(_taxUncommitted.InventTransId);
                }
                break;
            case TaxModuleType::Sales:
                salesPurchJournalLine = SalesLine::findInventTransId(_taxUncommitted.InventTransId);
                if (! salesPurchJournalLine)
                {
                    salesPurchJournalLine = SalesQuotationLine::findInventTransId(_taxUncommitted.InventTransId);
                }
                break;

            case TaxModuleType::StockTransfer_IN:
                if (inventTransferUpdateType == InventTransferUpdateType::Shipment)
                {
                    salesPurchJournalLine                               = InventTransferLine::findTransIdShip(_taxUncommitted.InventTransId);
                }
                else if (inventTransferUpdateType == InventTransferUpdateType::Receive)
                {
                    inventTransferLine                                  = InventTransferLine::findTransIdReceiveforPost_IN(_taxUncommitted.InventTransId);
                    salesPurchJournalLine                               = inventTransferLine;

                    salesPurchJournalLineExt = salesPurchJournalLine.SalesPurchJournalLine::getSalesPurchJournalLineExtension_IN();
                    salesPurchJournalLine.SalesPurchJournalLine::packSalesPurchJournalLineExtension_IN(salesPurchJournalLineExt);
                }
                break;

            case TaxModuleType::FreeTxtInvoice:
                if (_taxUncommitted.SourceTableId == tableNum(CustInvoiceTrans))
                {
                    salesPurchJournalLine = CustInvoiceLine::findBySourceDocumentLine(CustInvoiceTrans::findRecId(_taxUncommitted.SourceRecId).SourceDocumentLine);
                }
                else if (_taxUncommitted.SourceTableId == tableNum(CustInvoiceLine))
                {
                    salesPurchJournalLine = CustInvoiceLine::find(_taxUncommitted.SourceRecId);
                }
                break;

            case TaxModuleType::Voucher:
                salesPurchJournalLine = LedgerJournalTrans::findRecId(_taxUncommitted.SourceRecId, false);
                ledgerJournalTransLoc = salesPurchJournalLine;
                break;
        }

        return  salesPurchJournalLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesPurchJournalforInventTranfer_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to get sales purch journal lines related to invent transfer table.
    /// </summary>
    /// <returns>
    /// Returns the <c>SalesPurchJournalLine</c> map.
    /// </returns>
    SalesPurchJournalLine getSalesPurchJournalforInventTranfer_IN()
    {
        SalesPurchJournalLineExtension_IN salesPurchJournalLineExtension_IN;

        if (inventTransferUpdateType == InventTransferUpdateType::Shipment)
        {
            salesPurchJournalLineExtension_IN = salesPurchJournalLineLoc.SalesPurchJournalLine::getSalesPurchJournalLineExtension_IN();
            salesPurchJournalLineExtension_IN.AssessableValue = inventAssessableVal;
            salesPurchJournalLineLoc.SalesPurchJournalLine::packSalesPurchJournalLineExtension_IN(salesPurchJournalLineExtension_IN);
        }
        else if (inventTransferUpdateType == InventTransferUpdateType::Receive)
        {
            salesPurchJournalLineExtension_IN = salesPurchJournalLineLoc.SalesPurchJournalLine::getSalesPurchJournalLineExtension_IN();
            salesPurchJournalLineExtension_IN.AssessableValue = inventAssessableVal;
            salesPurchJournalLineLoc.SalesPurchJournalLine::packSalesPurchJournalLineExtension_IN(salesPurchJournalLineExtension_IN);
        }

        return salesPurchJournalLineLoc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesPurchJournalLineFromInventId_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to get sales purch journal line based on the invent Id.
    /// </summary>
    /// <returns>
    /// Returns the <c>SalesPurchJournalLine</c> map.
    /// </returns>
    SalesPurchJournalLine  getSalesPurchJournalLineFromInventId_IN()
    {
        SalesPurchJournalLine       salesPurchJournalLine;
        SalesPurchJournalLineExtension_IN salesPurchJournalLineExtension_IN;
        InventTransferLine          inventTransferLine;
        ProjInvoiceEmpl             projInvoiceEmpl;
        ProjInvoiceItem             projInvoiceItem;
        ProjInvoiceCost             projInvoiceCost;
        ProjInvoiceRevenue          projInvoiceRevenue;
        ProjInvoiceOnAcc            projInvoiceOnAcc;

        switch (taxWorkTrans.Source)
        {
            case TaxModuleType::Purch:
                salesPurchJournalLine = PurchLine::findInventTransId(taxWorkTrans.InventTransId);
                break;
            case TaxModuleType::Sales:
                if (taxWorkTrans.SourceTableId == tableNum(MarkupTrans))
                {
                    salesPurchJournalLine = MarkupTrans::findRecId(taxWorkTrans.SourceRecId);
                }
                else
                {
                    salesPurchJournalLine = SalesLine::findInventTransId(taxWorkTrans.InventTransId);
                    if (! salesPurchJournalLine)
                    {
                        salesPurchJournalLine = SalesQuotationLine::findInventTransId(taxWorkTrans.InventTransId);
                    }
                }
                break;

            case TaxModuleType::StockTransfer_IN:
                if (inventTransferUpdateType == InventTransferUpdateType::Shipment)
                {
                    salesPurchJournalLine                               = InventTransferLine::findTransIdShip(taxWorkTrans.InventTransId);
                }
                else if (inventTransferUpdateType == InventTransferUpdateType::Receive)
                {
                    inventTransferLine                                  = InventTransferLine::findTransIdReceiveforPost_IN(taxWorkTrans.InventTransId);
                    salesPurchJournalLine                               = inventTransferLine;
                }
                break;

            case TaxModuleType::Voucher:
                salesPurchJournalLine = LedgerJournalTrans::findRecId(taxWorkTrans.SourceRecId, false);
                break;

            case TaxModuleType::Project :
                switch (taxWorkTrans.SourceTableId)
                {
                    case tableNum(ProjInvoiceEmpl) :
                        select firstonly TransId from projInvoiceEmpl
                            where projInvoiceEmpl.RecId == taxWorkTrans.SourceRecId;

                        salesPurchJournalLine = ProjEmplTrans::find(projInvoiceEmpl.TransId).projEmplTransView_IN();
                        break;

                    case tableNum(ProjInvoiceRevenue) :
                        select firstonly TransId from projInvoiceRevenue
                            where projInvoiceRevenue.RecId == taxWorkTrans.SourceRecId;

                        salesPurchJournalLine = ProjRevenueTrans::find(projInvoiceRevenue.TransId).projRevenueTransView_IN();
                        break;

                    case tableNum(ProjInvoiceItem) :
                        select firstonly InventTransId, SalesId, ProjTransId from projInvoiceItem
                            where projInvoiceItem.RecId == taxWorkTrans.SourceRecId;

                        if (projInvoiceItem.SalesId)
                        {
                            salesPurchJournalLine = SalesLine::findInventTransId(projInvoiceItem.InventTransId);
                        }
                        else
                        {
                            salesPurchJournalLine = ProjItemTrans::find(projInvoiceItem.ProjTransId).projItemTransView_IN();
                        }
                        break;

                    case tableNum(ProjInvoiceCost) :
                        select firstonly TransId from projInvoiceCost
                            where projInvoiceCost.RecId == taxWorkTrans.SourceRecId;

                        salesPurchJournalLine = ProjCostTrans::find(projInvoiceCost.TransId).projCostTransView_IN();
                        break;

                    case tableNum(ProjInvoiceOnAcc) :
                        select firstonly TransId from projInvoiceOnAcc
                            where projInvoiceOnAcc.RecId == taxWorkTrans.SourceRecId;

                        salesPurchJournalLine = ProjOnAccTrans::find(projInvoiceOnAcc.TransId).projOnAccTransView_IN();
                        break;
                }
        }
        return  salesPurchJournalLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesPurchJournalLineFromTaxTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to get sales purch journal line based on the taxtrans table.
    /// </summary>
    /// <param name="_taxTrans">
    ///    The taxTrans buffer of the <c>TaxTrans</c> record.
    /// </param>
    /// <returns>
    /// Returns the <c>SalesPurchJournalLine</c> map.
    /// </returns>
    SalesPurchJournalLine  getSalesPurchJournalLineFromTaxTrans_IN(TaxTrans _taxTrans)
    {
        SalesPurchJournalLine    salesPurchJournalLine;

        switch (_taxTrans.Source)
        {
            case TaxModuleType::Purch:
                salesPurchJournalLine = PurchLine::findRecId(_taxTrans.SourceRecId);
                break;
            case TaxModuleType::Sales:
                salesPurchJournalLine = SalesLine::findRecId(_taxTrans.SourceRecId);
                if (! salesPurchJournalLine)
                {
                    salesPurchJournalLine = SalesQuotationLine::findRecId(_taxTrans.SourceRecId);
                }
                break;

            case TaxModuleType::Voucher:
                salesPurchJournalLine = LedgerJournalTrans::findRecId(_taxTrans.SourceRecId, false);
                break;
        }
        return  salesPurchJournalLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getServiceTaxAccount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets service tax account.
    /// </summary>
    /// <param name="_taxLedgerAccountsetup">
    /// The tax ledger account setup.
    /// </param>
    /// <param name="_taxComponentTable">
    /// The tax component table.
    /// </param>
    /// <param name="_taxDirection">
    /// The tax direction.
    /// </param>
    /// <param name="_ledgerJournalService">
    /// The ledger journal service.
    /// </param>
    /// <returns>
    /// The instance of the <c>LedgerDimensionDefaultAccount</c> class.
    /// </returns>
    public LedgerDimensionDefaultAccount getServiceTaxAccount_IN(
        RefRecId           _taxLedgerAccountsetup,
        RefRecId           _taxComponentTable,
        TaxDirection       _taxDirection,
        LedgerJournalTrans _ledgerJournalService)
    {
        boolean                       post2InterimAC_IncomingTax = true;
        boolean                       post2InterimAC_OutgoingTax = true;
        TaxAccountType_IN             serviceTaxAccountType;
        TaxAmountCur                  advanceSourceTaxAmountCur;
        TaxAmountCur                  advanceSourceBaseAmountCur;
        LedgerDimensionDefaultAccount serviceAccount;
        TransTaxInformation           transTaxInformation;

        if ((_ledgerJournalService.AccountType       == LedgerJournalACType::Cust ||
            _ledgerJournalService.OffsetAccountType  == LedgerJournalACType::Cust ||
            _ledgerJournalService.AccountType        == LedgerJournalACType::Vend ||
            _ledgerJournalService.OffsetAccountType  == LedgerJournalACType::Vend ||
            _ledgerJournalService.AccountType        == LedgerJournalACType::FixedAssets ||
            _ledgerJournalService.OffsetAccountType  == LedgerJournalACType::FixedAssets)&&
            (_ledgerJournalService.AccountType        == LedgerJournalACType::Ledger ||
            _ledgerJournalService.OffsetAccountType  == LedgerJournalACType::Ledger ||
            _ledgerJournalService.AccountType        == LedgerJournalACType::FixedAssets ||
            _ledgerJournalService.OffsetAccountType  == LedgerJournalACType::FixedAssets ||
            _ledgerJournalService.AccountType        == LedgerJournalACType::Project ||
            _ledgerJournalService.OffsetAccountType  == LedgerJournalACType::Project))
        {
            if (TaxItemGroupHeading::find(taxWorkTrans.TaxItemGroup).ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis)
            {
                [advanceSourceBaseAmountCur, advanceSourceTaxAmountCur] = Tax::getAdvanceAmount_IN(taxWorkTrans.TaxCode, this.headingTableId(), this.headingRecId(),_ledgerJournalService);
                if (!advanceSourceTaxAmountCur)
                {
                    post2InterimAC_IncomingTax = false;
                    post2InterimAC_OutgoingTax = false;
                }
                if (TaxItemGroupHeading::isAccruePayableAtInvoicing_IN(taxWorkTrans.TaxItemGroup))
                {
                    post2InterimAC_OutgoingTax = false;
                }
            }
        }
        if (_taxDirection == TaxDirection::OutgoingTax)
        {
            serviceTaxAccountType = post2InterimAC_OutgoingTax ? TaxAccountType_IN::ServiceTaxInterimPayableAccount : TaxAccountType_IN::ServiceTaxPayableAccount;
        }
        else if (_taxDirection == TaxDirection::IncomingTax)
        {
            transTaxInformation = transTaxInformationHelper.getTransTaxInformationByRecord(_ledgerJournalService);

            if (TaxItemGroupHeading::find(taxWorkTrans.TaxItemGroup).ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis &&
                transTaxInformation.ServiceTaxGTAServiceCategory == GTAServiceCategory_IN::Others)
            {
                serviceTaxAccountType = TaxAccountType_IN::ServiceTaxExpenseAccount;
            }
            else
            {
                serviceTaxAccountType = post2InterimAC_IncomingTax ? TaxAccountType_IN::ServiceTaxInterimRecoverableAccount : TaxAccountType_IN::ServiceTaxRecoverableAccount;
            }
        }
        serviceAccount = TaxLedgerAccounts_IN::getAccountNum(_taxLedgerAccountsetup, serviceTaxAccountType, _taxComponentTable);

        return serviceAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSettledExcisePayableAcc_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets settled excise payable account.
    /// </summary>
    /// <param name="_taxTrans">
    /// The tax transaction.
    /// </param>
    /// <returns>
    /// The instance of the <c>RefRecId</c> class.
    /// </returns>
    public RefRecId getSettledExcisePayableAcc_IN(TaxTrans _taxTrans)
    {
        ComponentTransactions_IN        settleTransaction;
        TaxTrans_IN                     taxTransLocalOrig;
        TaxTrans                        taxTransOrig;
        RefRecId                        accountNumLocal;
        TaxTrans_W                      taxTransOrig_W;
        RefRecId                        taxLdgerAccountSetupRecId;

        select RecId from taxTransOrig
            where taxTransOrig.TaxCode    == _taxTrans.TaxCode
               && taxTransOrig.InventTransId == PurchLine::findInventTransId(_taxTrans.InventTransId).InventRefTransId
            join TaxRegistrationNumberTable_IN, RecId, TaxTrans from taxTransOrig_W
                where taxTransOrig_W.TaxTrans == taxTransOrig.RecId
                && taxTransOrig_W.TaxType_IN == TaxType_IN::Excise;

        taxTransLocalOrig = TaxTrans_IN::findRefRecId(taxTransOrig.RecId);
        if (taxTransLocalOrig.ExciseRecordType == ExciseRecordType_IN::RG23A ||
            taxTransLocalOrig.ExciseRecordType == ExciseRecordType_IN::RG23C)
        {
            select settleTransaction
                where settleTransaction.TransRecid == taxTransOrig.RecId;
            if (settleTransaction)
            {
                taxLdgerAccountSetupRecId = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTransLocalOrig.TaxLedgerAccountGroup, TaxAccountCode_IN::Table,taxTransOrig_W.TaxRegistrationNumberTable_IN).RecId;
                if (!taxLdgerAccountSetupRecId)
                {
                    taxLdgerAccountSetupRecId = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTransLocalOrig.TaxLedgerAccountGroup, TaxAccountCode_IN::All).RecId;
                }
                if (taxLdgerAccountSetupRecId)
                {
                    accountNumLocal = TaxLedgerAccounts_IN::findByTaxAccounts(taxLdgerAccountSetupRecId,
                                                                 TaxAccountType_IN::ExcisePayableAccount,
                                                                 taxTransLocalOrig.TaxComponentTable).LedgerDimension;
                }
            }
        }
        return accountNumLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSourceCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>Currency</c> record for the transactional currency.
    /// </summary>
    /// <param name="_sourceCurrencyCode">The source currency code.</param>
    /// <returns>
    /// A <c>Currency</c> record.
    /// </returns>
    protected Currency getSourceCurrency(CurrencyCode _sourceCurrencyCode = '')
    {
        if (cachedSourceCurrency.CurrencyCode != sourceCurrencyCode)
        {
            if (_sourceCurrencyCode)
            {
                cachedSourceCurrency = Currency::find(_sourceCurrencyCode);
            }

            else
            {
                cachedSourceCurrency = Currency::find(sourceCurrencyCode);
            }
        }

        return cachedSourceCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAdjustmentDetailDescription</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the description of the tax adjustment detail for the specified tax source.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The table ID of the specified tax source.
    /// </param>
    /// <param name="_sourceRecId">
    /// The record ID of the specified tax source.
    /// </param>
    /// <returns>
    /// The description of the tax adjustment detail for the specified tax source.
    /// </returns>
    public TaxAdjustmentDetailDescription getTaxAdjustmentDetailDescription(RefTableId _sourceTableId, RefRecId _sourceRecId)
    {
        TaxAdjustmentDetailDescription taxAdjustmentDetailDescription;

        return taxAdjustmentDetailDescription;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAdjustmentDetailReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the reference of the tax adjustment detail for the specified tax source.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The table ID of the specified tax source.
    /// </param>
    /// <param name="_sourceRecId">
    /// The record ID of the specified tax source.
    /// </param>
    /// <returns>
    /// The reference of the tax adjustment detail for the specified tax source.
    /// </returns>
    public TaxAdjustmentDetailReference getTaxAdjustmentDetailReference(RefTableId _sourceTableId, RefRecId _sourceRecId)
    {
        TaxAdjustmentDetailReference taxAdjustmentDetailReference;

        return taxAdjustmentDetailReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAdjustmentDetailType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the type of the tax adjustment detail for the specified tax source.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The table ID of the specified tax source.
    /// </param>
    /// <param name="_sourceRecId">
    /// The record ID of the specified tax source.
    /// </param>
    /// <returns>
    /// The type of the tax adjustment detail for the specified tax source.
    /// </returns>
    public TaxAdjustmentDetailType getTaxAdjustmentDetailType(RefTableId _sourceTableId, RefRecId _sourceRecId)
    {
        TaxAdjustmentDetailType taxAdjustmentDetailType;

        return taxAdjustmentDetailType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAdjustmentTypes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the collection of tax adjustment types that can be used to make tax adjustments.
    /// </summary>
    /// <returns>
    /// A collection of tax adjustment types.
    /// </returns>
    public final Set getTaxAdjustmentTypes()
    {
        this.initializeTaxAdjustmentTypes();

        return taxAdjustmentTypes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAmountForPrepayment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the tax amount for the specified pre-payment.
    /// </summary>
    /// <param name="_isPrepayment">
    ///    A Boolean value that indicates whether it is a pre-payment.
    /// </param>
    /// <param name="_invoiceId">
    ///    The invoice ID of the tax line to include.
    /// </param>
    /// <returns>
    ///    The tax amount.
    /// </returns>
    TaxAmount getTaxAmountForPrepayment(boolean _isPrepayment, InvoiceId _invoiceId)
    {
        TaxAmountCur taxAmount;

        select sum(SourceRegulateAmountCur)

        from taxWorkTrans
        where   taxWorkTrans.TaxDirection != TaxDirection::UseTax &&
                taxWorkTrans.TaxOrigin != TaxOrigin::TaxReversed &&
                taxWorkTrans.TaxOrigin != TaxOrigin::Transfer &&
                taxWorkTrans.Prepayment == _isPrepayment;

        taxAmount += taxWorkTrans.SourceRegulateAmountCur;

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxChargePostingType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the LedgerPostingType for the charge posting.
    /// </summary>
    /// <returns>
    ///     By default, it returns Tax.
    /// </returns>
    /// <remarks>
    ///     Method is overridden in the child classes which can require a different posting type for the charge.
    /// </remarks>
    protected LedgerPostingType getTaxChargePostingType()
    {
        return LedgerPostingType::Tax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines the tax date for this transaction.
    /// </summary>
    /// <param name="_sourceRecId">
    ///    The source record ID of the transaction line; optional.
    /// </param>
    /// <returns>
    ///   The tax date.
    /// </returns>
    public TransDate getTaxDate(RefRecId _sourceRecId = 0)
    {
        return taxDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxExchangeRateDifferencePosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the ledger dimension and the offset ledger dimension for posting tax difference to ledger.
    /// </summary>
    /// <param name="_taxTransExchangeRateDifference">
    /// The <c>TaxTrans</c> record.
    /// </param>
    /// <returns>
    /// Container with ledger dimension and offset ledger dimension.
    /// </returns>
    protected container getTaxExchangeRateDifferencePosting(
        TaxTrans                _taxTransExchangeRateDifference)
    {
        TaxLedgerAccountGroup           taxLedgerAccountGroup;
        LedgerDimensionDefaultAccount   sourceLedgerDimension;
        LedgerDimensionDefaultAccount   sourceOffsetLedgerDimension;
        boolean                         mustCheckDiffOffsetLedgerDimension;

        if (_taxTransExchangeRateDifference.TaxDirection == TaxDirection::OutgoingTax_W ||
            _taxTransExchangeRateDifference.TaxDirection == TaxDirection::IncomingTax_W)
        {
            mustCheckDiffOffsetLedgerDimension = true;
        }
        else
        {
            mustCheckDiffOffsetLedgerDimension = false;
        }

        taxLedgerAccountGroup = TaxLedgerAccountGroup::find(TaxTable::findAccountGroup(_taxTransExchangeRateDifference.TaxCode));
        taxLedgerAccountGroup.validateAccountForTaxDirection(
            _taxTransExchangeRateDifference.TaxDirection,
            false,
            true,
            mustCheckDiffOffsetLedgerDimension);

        if (_taxTransExchangeRateDifference.TaxDirection == TaxDirection::OutgoingTax_W)
        {
            sourceLedgerDimension       = taxLedgerAccountGroup.TaxOutgoingDifferenceLedgerDimension;
            sourceOffsetLedgerDimension = taxLedgerAccountGroup.TaxOutgoingDiffOffsetLedgerDimension;
        }
        else if (_taxTransExchangeRateDifference.TaxDirection == TaxDirection::IncomingTax_W)
        {
            sourceLedgerDimension       = taxLedgerAccountGroup.TaxIncomingDifferenceLedgerDimension;
            sourceOffsetLedgerDimension = taxLedgerAccountGroup.TaxIncomingDiffOffsetLedgerDimension;
        }
        else
        {
            sourceLedgerDimension       = taxLedgerAccountGroup.TaxIncomingDifferenceLedgerDimension;
            sourceOffsetLedgerDimension = taxLedgerAccountGroup.TaxOutgoingDifferenceLedgerDimension;
        }

        return [ sourceLedgerDimension, sourceOffsetLedgerDimension ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxIncludedInItemPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the tax is included in the item price.
    /// </summary>
    /// <returns>
    ///    true if tax is included in item price; otherwise, false.
    /// </returns>
    public boolean getTaxIncludedInItemPrice()
    {
        return taxIncludedInItemPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxModelTaxable_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets tax taxable model.
    /// </summary>
    /// <param name="_documentMap">
    /// The document map.
    /// </param>
    /// <param name="_isScrap">
    /// True if the model is scrap.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxModelTaxable_IN</c> class.
    /// </returns>
    protected TaxModelTaxable_IN getTaxModelTaxable_IN(
        SalesPurchJournalLine _documentMap,
        boolean _isScrap = false)
    {
        TaxModelTaxable_IN ret;
        boolean instanceOfScrap;

        if (taxModelTaxable)
        {
            if (taxModelTaxable.getDocumentLineMainTableId() != _documentMap.SourceTableId
                || taxModelTaxable.getDocumentLineMainTableRecId() != _documentMap.SourceRecId)
            {
                ret = this.buildTaxModel_IN(_documentMap, _isScrap);
            }
            else
            {
                instanceOfScrap = taxModelTaxable is TaxModelTaxableScrap_IN;
                if ((_isScrap && !instanceOfScrap)
                    || (!_isScrap && instanceOfScrap))
                {
                    ret = this.buildTaxModel_IN(_documentMap, _isScrap);
                }
                else
                {
                    ret = taxModelTaxable;
                }
            }
        }
        else
        {
            ret = this.buildTaxModel_IN(_documentMap, _isScrap);
        }

        taxModelTaxable = ret;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxModuleType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the <c>TaxModuleType</c> value for the current transaction.
    /// </summary>
    /// <returns>
    ///    The tax module type for the current transaction.
    /// </returns>
    public TaxModuleType getTaxModuleType()
    {
        return taxModuleType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxObligationCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the company which has the tax obligation.
    /// </summary>
    /// <returns>
    /// The company which has the tax obligation.
    /// </returns>
    protected TaxObligationCompany getTaxObligationCompany()
    {
        return TaxObligationCompany::Destination;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxRegistrationNumber_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets tax registration number.
    /// </summary>
    /// <param name="_taxtype">
    /// The tax type.
    /// </param>
    /// <param name="_salesPurchJournalLine">
    /// The sales purch journal line.
    /// </param>
    /// <returns>
    /// The tax registration number reference rec id.
    /// </returns>
    protected RefRecId getTaxRegistrationNumber_IN(TaxType_IN _taxtype, SalesPurchJournalLine _salesPurchJournalLine)
    {
        TransTaxInformation          transTaxInformation;

        transTaxInformation = transTaxInformationHelper.getTransTaxInformation(_salesPurchJournalLine.SourceTableId, _salesPurchJournalLine.SourceRecId);

        return TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, _taxtype).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxSourceLineSummaryTmp</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the <c>TaxSourceLineSummaryTmp</c> table which contains summary values for each
    ///   source line.
    /// </summary>
    /// <returns>
    ///   The <c>TaxSourceLineSummaryTmp</c> table.
    /// </returns>
    public TaxSourceLineSummaryTmp getTaxSourceLineSummaryTmp()
    {
        return taxSourceLineSummaryTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxTable</Name>
				<Source><![CDATA[
    protected TaxTable getTaxTable(TaxCode _taxCode)
    {
        TaxTable tmpTaxTable;
        SelectableDataArea tmpTaxTableCompany;

        // This abstration allows caching of the current tax code
        // being operated on to reduce kernel record cache lookups
        // since many tax operations will repeatedly operate on the
        // same tax code record
        if (tmpTaxTable1.TaxCode == _taxCode && curext() == tmpTaxTableCompany1)

        {
            return tmpTaxTable1;
        }

        if (tmpTaxTable2.TaxCode == _taxCode && curext() == tmpTaxTableCompany2)
        {
            // Tax table 2 is the one being searched for, so make it
            // the highest priority and return
            tmpTaxTable = tmpTaxTable1;
            tmpTaxTableCompany = tmpTaxTableCompany1;
            tmpTaxTable1 = tmpTaxTable2;
            tmpTaxTableCompany1 = tmpTaxTableCompany2;
            tmpTaxTable2 = tmpTaxTable;
            tmpTaxTableCompany2 = tmpTaxTableCompany;
            return tmpTaxTable1;
        }

        // Neither cache value contained the value being searched for
        // so look it up and cache a new one
        tmpTaxTable2 = tmpTaxTable1;
        tmpTaxTableCompany2 = tmpTaxTableCompany1;
        tmpTaxTable1 = TaxTable::find(_taxCode);
        tmpTaxTableCompany1 = curext();
        return tmpTaxTable1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxWorkTransBufferForTaxInCostPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the <c>TmpTaxWorkTrans</c> buffer that is required for the <c>totalTaxInCostPrice</c> method.
    /// </summary>
    /// <param name="_recId">
    /// record ID of the line to search for; optional.
    /// </param>
    /// <returns>
    ///    The <c>TmpTaxWorkTrans</c> buffer that is ready for consumption by the <c>totalTaxInCostPrice</c>
    ///    method.
    /// </returns>
    protected TmpTaxWorkTrans getTaxWorkTransBufferForTaxInCostPrice(RefRecId _recId = 0)
    {
        RefTableId  sourceTableId;
        ;

        if (_recId == 0)

        {
            select
                    sum (SourceTaxAmountCur),
                    sum (TaxInCostPrice),
                    sum (SourceRegulateAmountCur),
                    sum (TaxInCostPriceRegulated)
            from taxWorkTrans
            where taxWorkTrans.TaxOrigin != TaxOrigin::TaxReversed;
        }
        else
        {
            sourceTableId = this.sourceTableId();

            select

                    sum (SourceTaxAmountCur),
                    sum (TaxInCostPrice),
                    sum (SourceRegulateAmountCur),
                    sum (TaxInCostPriceRegulated)
            from taxWorkTrans
            where taxWorkTrans.SourceTableId == sourceTableId &&
                taxWorkTrans.SourceRecId == _recId &&
                taxWorkTrans.TaxOrigin != TaxOrigin::TaxReversed;
        }

        return taxWorkTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalTaxValue_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets total tax value.
    /// </summary>
    /// <param name="_taxComponent">
    /// The tax component.
    /// </param>
    /// <param name="_exciseTariffCode">
    /// The excise tariff code.
    /// </param>
    /// <param name="_calculationDate">
    /// The calculation date.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxValue</c> class.
    /// </returns>
    protected TaxValue getTotalTaxValue_IN(RefRecId  _taxComponent,
                                         RefRecId  _exciseTariffCode,
                                         TransDate _calculationDate)
    {
        CustomsComponentTaxCodes_IN customsComponentTaxCodes;
        TaxComponentTable_IN        taxComponentLoc;
        TaxData  taxDataLoc;

        select sum(TaxValue) from taxDataLoc
                where taxDataLoc.ExciseTariffCodes_IN     == _exciseTariffCode
                   && ((taxDataLoc.TaxFromDate            <= _calculationDate
                   && taxDataLoc.TaxToDate                >= _calculationDate)
                   || !taxDataLoc.TaxFromDate)
                join  TaxCode, TaxComponentTable from customsComponentTaxCodes
                    where customsComponentTaxCodes.TaxCode       == taxDataLoc.TaxCode
                join RecId from taxComponentLoc
                    where taxComponentLoc.RecId == customsComponentTaxCodes.TaxComponentTable
                       && taxComponentLoc.ApplyExcise == NoYes::Yes
                       && taxComponentLoc.RecId == _taxComponent;
        return taxDataLoc.TaxValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionalCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the default transactional currency for this transaction.
    /// </summary>
    /// <returns>
    ///    The default transactional currency.
    /// </returns>
    public CurrencyCode getTransactionalCurrency()
    {
        return sourceCurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTriangulation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>EUROTriangulation</c> value for the current transaction.
    /// </summary>
    /// <returns>
    ///    The <c>EUROTriangulation</c> value for the current transaction.
    /// </returns>
    public EUROTriangulation getTriangulation()
    {
        return triangulation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVATPayableAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a container which holds tax amount and other information related to Vat.
    /// </summary>
    /// <param name="_taxTrans">
    /// This buffer is used the find the record.
    /// </param>
    /// <returns>
    /// Returns a container.
    /// </returns>
    public container getVATPayableAmount_IN(TaxTrans _taxTrans)
    {
        TaxTrans                        taxTransOrig;
        TaxTrans                        taxTransPeriodic;
        TaxTrans_IN                     taxTransLocalOrig,taxTransLocalPeriodic;
        TaxAmount                       payableLoc;
        TaxLedgerAccounts_IN            taxLedgerAccounts;
        PurchLine                       purchLineLocal;
        TaxLedgerAccountSetup_IN        taxLedgerAccountSetup;
        ComponentTransactions_IN        settleTransLocal;
        container                       defermentPeriodic;
        VATGoodsType_IN                 goodsType;
        boolean                         isSettled;
        InventTransId                   inventRefTransId;

        inventRefTransId = PurchLine::findInventTransId(_taxTrans.InventTransId).InventRefTransId;

        if (inventRefTransId)
        {
            purchLineLocal = PurchLine::findInventTransId(inventRefTransId);

            select firstonly RecId from taxTransOrig
                where taxTransOrig.InventTransId    == VendInvoiceTrans::findInventTransId(purchLineLocal.InventTransId).InventTransId
                    && taxTransOrig.TaxCode         == _taxTrans.TaxCode;

            taxTransLocalOrig = TaxTrans_IN::findRefRecId(taxTransOrig.RecId);

            if (taxTransLocalOrig.vatGoodsType  == VATGoodsType_IN::CapitalGoods)
            {
                ttsbegin;
                while select forupdate RefRecId, vatDefLineTransferred from taxTransLocalPeriodic
                    where taxTransLocalPeriodic.TaxTransVATRefRecId   == taxTransOrig.RecId
                        && ! taxTransLocalPeriodic.vatDefLineTransferred
                join RecId from taxTransPeriodic
                    where taxTransPeriodic.RecId == taxTransLocalPeriodic.RefRecId
                join RecoverableAmount from settleTransLocal
                    where settleTransLocal.TransRecid == taxTransPeriodic.RecId
                {
                    if (settleTransLocal.RecoverableAmount)
                    {
                        isSettled = true;
                        payableLoc += settleTransLocal.RecoverableAmount;
                        goodsType = VATGoodsType_IN::CapitalGoods;

                        taxTransLocalPeriodic.vatDefLineTransferred = NoYes::Yes;
                        taxTransLocalPeriodic.doUpdate();
                    }
                }
                ttscommit;
            }
            else
            {
                select firstonly RecId from settleTransLocal
                    where settleTransLocal.TransRecid == taxTransOrig.RecId;
                if (settleTransLocal)
                {
                    isSettled = true;
                    goodsType = VATGoodsType_IN::Input;
                }
            }

            if (isSettled)
            {
                taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTransLocalOrig.TaxLedgerAccountGroup,TaxAccountCode_IN::Table,taxTransOrig.taxTrans_W().TaxRegistrationNumberTable_IN);
                if (taxLedgerAccountSetup)
                {
                    taxLedgerAccounts = TaxLedgerAccounts_IN::findByTaxAccounts(taxLedgerAccountSetup.RecId,
                                                                                TaxAccountType_IN::VATPayableAccount,
                                                                                taxTransLocalOrig.TaxComponentTable);
                }

                if (!taxLedgerAccounts)
                {
                    taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTransLocalOrig.TaxLedgerAccountGroup,TaxAccountCode_IN::All);
                    taxLedgerAccounts     = TaxLedgerAccounts_IN::findByTaxAccounts(taxLedgerAccountSetup.RecId,
                                                                                    TaxAccountType_IN::VATPayableAccount,
                                                                                    taxTransLocalOrig.TaxComponentTable);
                }
            }
        }

        defermentPeriodic = [payableLoc,taxLedgerAccounts.LedgerDimension,goodsType];
        return defermentPeriodic;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVendInvoiceJour_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to get the <c>VendInvoiceJour</c> table.
    /// </summary>
    /// <param name="_taxTrans">
    /// A buffer of <c>TaxTrans</c> table.
    /// </param>
    /// <returns>
    /// Returns the <c>VendInvoiceJour</c> table.
    /// </returns>
    public VendInvoiceJour getVendInvoiceJour_IN(TaxTrans _taxTrans)
    {
        VendInvoiceJour  vendInvoiceJour;

        select vendInvoiceJour
                where vendInvoiceJour.LedgerVoucher == _taxTrans.Voucher
                   && vendInvoiceJour.InvoiceDate   == _taxTrans.TransDate;

        return vendInvoiceJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVendInvoiceTransLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to get the <c>VendInvoiceTrans</c> table.
    /// </summary>
    /// <param name="_taxTrans">
    /// A buffer of <c>TaxTrans</c> table.
    /// </param>
    /// <param name="_vendInvoiceJour">
    /// A buffer of <c>VendInvoiceJour</c> table.
    /// </param>
    /// <returns>
    /// Returns the <c>VendInvoiceTrans</c> table.
    /// </returns>
    VendInvoiceTrans getVendInvoiceTransLine_IN(TaxTrans _taxTrans, VendInvoiceJour  _vendInvoiceJour)
    {
        VendInvoiceTrans vendInvoiceTrans;

        select vendInvoiceTrans
            where vendInvoiceTrans.PurchID              == _vendInvoiceJour.PurchId
               && vendInvoiceTrans.InvoiceId            == _vendInvoiceJour.InvoiceId
               && vendInvoiceTrans.InvoiceDate          == _vendInvoiceJour.InvoiceDate
               && vendInvoiceTrans.NumberSequenceGroup  == _vendInvoiceJour.NumberSequenceGroup
               && vendInvoiceTrans.InternalInvoiceId    == _vendInvoiceJour.InternalInvoiceId
               && vendInvoiceTrans.InventTransId        == _taxTrans.InventTransId;

        return vendInvoiceTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>voucher</c> value for the current transaction.
    /// </summary>
    /// <returns>
    ///    Voucher for the current transaction.
    /// </returns>
    public Voucher getVoucher()
    {
        return voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVoucherForContinuousHU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates or retrieves the voucher object for the additional transaction
    /// to be added for Hungary. If "Subscription" is checked, Hungary requires that
    /// two additional tax transactions be added on the VAT due date
    /// </summary>
    /// <param name="_vatDueDate">
    /// The VAT date for which the voucher is getting created
    /// </param>
    /// <param name="_ledgerPostingController">
    /// The ledgerPostingController to which the voucher is being added
    /// </param>
    /// <returns>
    ///    New voucher object for added transactions.
    /// </returns>
    public LedgerVoucherObject getVoucherForContinuousHU(date _vatDueDate, LedgerPostingController _ledgerPostingController)
    {
        NumberSeq       numberSeq;
        if (initializeContinuousHU)
        {
            numberSeq = NumberSeq::newGetVoucherFromCode(_ledgerPostingController.getReference().parmVoucherSeriesCode());
            ledgerContinuousVoucherObject = LedgerVoucherObject::newVoucher(numberSeq.voucher(), _vatDueDate, SysModule::Tax, LedgerTransType::Tax);
            initializeContinuousHU = false;
        }

        return ledgerContinuousVoucherObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleExciseAmountRegister_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The handler of the excise amount register.
    /// </summary>
    /// <param name="_taxModelExciseTaxable">
    /// Tha excise taxable tax model.
    /// </param>
    /// <param name="_taxTrans">
    /// the tax transaction.
    /// </param>
    protected void handleExciseAmountRegister_IN(
        TaxModelExciseTaxable_IN _taxModelExciseTaxable,
        TaxTrans _taxTrans)
    {
        TaxExciseAmountRegister_IN    register;
        TaxModelTaxTransactionImpl_IN taxModelTaxTransaction;
        TaxTransExtensionRGAmountHandler_IN rgAmountHandler;
        TaxTrans_IN taxTransIN;

        if (_taxModelExciseTaxable)
        {
            taxModelTaxTransaction = TaxModelTaxTransactionImpl_IN::construct(_taxTrans);

            if (_taxModelExciseTaxable.isExicseDSA() && _taxModelExciseTaxable.getExciseDirectSettlement() != DirectSettlement_IN::None)
            {
                if (_taxModelExciseTaxable.getExciseDirectSettlement() == DirectSettlement_IN::PLA)
                {
                    register = TaxExciseRegisterFacade_IN::updatePLARegister(_taxModelExciseTaxable, taxModelTaxTransaction);
                }
                else
                {
                    register = TaxExciseRegisterFacade_IN::updatePartIIRegister(_taxModelExciseTaxable, taxModelTaxTransaction);
                }

                if (register.RecId != 0)
                {
                    rgAmountHandler = new TaxTransExtensionRGAmountHandler_IN();
                    rgAmountHandler.setExciseRegister(register);
                    rgAmountHandler.setTaxModelTaxable(_taxModelExciseTaxable as TaxModelTaxable_IN);
                    rgAmountHandler.setTaxTransaction(taxModelTaxTransaction);
                    rgAmountHandler.init();
                    rgAmountHandler.setData();
                    taxTransIN = rgAmountHandler.post();

                    this.postHandleExciseAmountRegister_IN(
                        _taxModelExciseTaxable,
                        _taxTrans,
                        register,
                        taxTransIN);
                }

                register = TaxExciseRegisterFacade_IN::updateDSARegister(_taxModelExciseTaxable, taxModelTaxTransaction);
            }
            else if (_taxModelExciseTaxable.getExciseDirectSettlement() == DirectSettlement_IN::PLA)
            {
                register = TaxExciseRegisterFacade_IN::updatePLARegister(_taxModelExciseTaxable, taxModelTaxTransaction);
            }
            else if (_taxModelExciseTaxable.getExciseRecordType() != ExciseRecordType_IN::None)
            {
                register = TaxExciseRegisterFacade_IN::updatePartIIRegister(_taxModelExciseTaxable, taxModelTaxTransaction);
            }
            else if (_taxModelExciseTaxable.isExicseDSA())
            {
                register = TaxExciseRegisterFacade_IN::updateDSARegister(_taxModelExciseTaxable, taxModelTaxTransaction);
            }

            if (register.RecId != 0)
            {
                rgAmountHandler = new TaxTransExtensionRGAmountHandler_IN();
                rgAmountHandler.setExciseRegister(register);
                rgAmountHandler.setTaxModelTaxable(_taxModelExciseTaxable as TaxModelTaxable_IN);
                rgAmountHandler.setTaxTransaction(taxModelTaxTransaction);
                rgAmountHandler.init();
                rgAmountHandler.setData();
                taxTransIN = rgAmountHandler.post();

                this.postHandleExciseAmountRegister_IN(
                    _taxModelExciseTaxable,
                    _taxTrans,
                    register,
                    taxTransIN);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleExciseQuantityRegister_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The handler of the excise quantity register.
    /// </summary>
    /// <param name="_taxModelExciseTaxable">
    /// The excise taxable tax model.
    /// </param>
    protected void handleExciseQuantityRegister_IN(TaxModelExciseTaxable_IN _taxModelExciseTaxable)
    {
        TaxExciseQuantityRegister_IN            register;
        TaxTransExtensionRGQuantityHandler_IN   rgQuantityHandler;
        TaxTrans_IN taxTransIN;

        if (_taxModelExciseTaxable)
        {
            if (_taxModelExciseTaxable.getExciseRecordType() != ExciseRecordType_IN::None)
            {
                register = TaxExciseRegisterFacade_IN::updatePartIRegister(_taxModelExciseTaxable);
            }

            if (register.RecId != 0)
            {
                rgQuantityHandler = new TaxTransExtensionRGQuantityHandler_IN();
                rgQuantityHandler.setExciseRegister(register);
                rgQuantityHandler.setTaxModelTaxable(_taxModelExciseTaxable as TaxModelTaxable_IN);
                rgQuantityHandler.init();
                rgQuantityHandler.setData();
                taxTransIN = rgQuantityHandler.post();

                this.postHandleExciseQuantityRegister_IN(
                    _taxModelExciseTaxable,
                    register,
                    taxTransIN);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>headingRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the source document record ID.
    /// </summary>
    /// <returns>
    /// The source document record ID.
    /// </returns>
    RefRecId headingRecId()
    {
        return headingRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>headingTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the source document table ID.
    /// </summary>
    /// <returns>
    /// The source document table ID.
    /// </returns>
    RefTableId headingTableId()
    {
        return headingTableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>icmsTaxAmountForSubtract_BR</Name>
				<Source><![CDATA[
    private container icmsTaxAmountForSubtract_BR(TaxFiscalValue_BR _fiscalValue = TaxFiscalValue_BR::Blank)
    {
        TmpTaxWorkTrans tmpTaxWorkTransLocal;
        container result;

        tmpTaxWorkTransLocal.setTmpData(taxWorkTrans);

        select sum(SourceTaxAmountCur), sum(TaxAmount), sum(SourceOtherBaseTaxAmount_BR), sum(SourceOtherTaxAmountMST_BR) from tmpTaxWorkTransLocal
            where tmpTaxWorkTransLocal.TaxType_BR == TaxType_BR::ICMS
                    && tmpTaxWorkTransLocal.TaxTributarySubstitution == TaxSubstitutionEnum_BR::None;

        if (_fiscalValue == TaxFiscalValue_BR::WithoutCreditDebitOther)
        {
            result = [tmpTaxWorkTransLocal.SourceOtherTaxAmountMST_BR, tmpTaxWorkTransLocal.SourceOtherBaseTaxAmount_BR];
        }
        else
        {
            result = [tmpTaxWorkTransLocal.TaxAmount, tmpTaxWorkTransLocal.SourceTaxAmountCur];
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>iecNumber_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The iec number.
    /// </summary>
    /// <returns>
    /// The instance of the <c>TaxRegistrationNumber_IN</c> class.
    /// </returns>
    protected  TaxRegistrationNumber_IN iecNumber_IN()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>ignoreCalculatedSalesTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether to ignore the calculated sales tax and only use the tax amounts from tax
    ///    adjustments.
    /// </summary>
    /// <returns>
    ///    true if the calculated sales tax should be ignored and only tax amounts from tax adjustments should
    ///    be used; otherwise, false.
    /// </returns>
    public boolean ignoreCalculatedSalesTax()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBaseAmountSum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the sum base amount.
    /// </summary>
    void initBaseAmountSum()
    {
        if (!baseAmountSum)
        {
            baseAmountSum = new RecordSortedList(tableNum(TmpTaxWorkTrans));
            baseAmountSum.sortOrder(fieldNum(TmpTaxWorkTrans, TaxCode),fieldNum(TmpTaxWorkTrans, TaxDirection), fieldNum(TmpTaxWorkTrans, sourceCurrencyCode));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTaxAdjustmentTypes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the collection of tax adjustment types.
    /// </summary>
    private void initializeTaxAdjustmentTypes()
    {
        if (!taxAdjustmentTypes)
        {
            taxAdjustmentTypes = new Set(Types::Enum);
            this.addTaxAdjustmentTypes();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the voucher and tax date in posting ledger journal.
    /// </summary>
    /// <param name = "_ledgerPostingController">The instance of <c>LedgerPostingController</c>.</param>
    protected void initLedgerPosting(LedgerPostingController _ledgerPostingController)
    {
        LedgerVoucher ledgerPostingJournal = _ledgerPostingController.getJournal();

        if (post && (ledgerPostingJournal == null))

        {
            // two messages is the legacy behavior
            warning(strFmt("@SYS19386", funcName()));
            throw error("@SYS18447");
        }

        if (ledgerPostingJournal != null)
        {
            voucher = ledgerPostingJournal.lastVoucher();
            taxDate = ledgerPostingJournal.lastTransDate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxParameters_IN</Name>
				<Source><![CDATA[
    private void initTaxParameters_IN()
    {
        TaxParameters taxParametersLocal;

        isIndiaCountryRegionEnabled   = true;

        taxParametersLocal            = TaxParameters::find();

        isCustomsEnabled              = taxParametersLocal.Customs_IN;
        isExciseEnabled               = taxParametersLocal.Excise_IN;
        isSalesTaxEnabled             = taxParametersLocal.SalesTax_IN;
        isServiceTaxEnabled           = taxParametersLocal.ServiceTax_IN;
        isVATEnabled                  = taxParametersLocal.vat_in;
        isTaxRecoverabled             = taxParametersLocal.TaxRecoverable_IN;
        isEximIncentiveSchemEnabled   = taxParametersLocal.EximIncentiveSchemes_IN;

        isTaxParametersEnabled        =
            isCustomsEnabled
            || isExciseEnabled
            || isSalesTaxEnabled
            || isServiceTaxEnabled
            || isVATEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the tax transaction values.
    /// </summary>
    /// <param name = "taxTrans">The record of <c>TaxTrans</c>.</param>
    /// <param name = "_voucherSeriesCode">The number sequece code for voucher.</param>
    void initTaxTrans(TaxTrans taxTrans, NumberSequenceCode _voucherSeriesCode)
    {
        TaxBookSection     taxBookSection;
        #ISOCountryRegionCodes

        if (MultipleTaxIdReportingHelper::isLegalEntityOrTaxCodeInCountryRegion(
            taxTrans.TaxCode, [#isoIT], MultipleTaxIdScope::VATDeclaration))
        {
            taxBookSection = TaxBookSection::findVoucherSeries(
                    NumberSequenceTable::findByNaturalKey(_voucherSeriesCode).RecId);

            if (taxBookSection)
            {
                taxTrans.TaxBook        = taxBookSection.TaxBook;
                taxTrans.TaxBookSection   = taxBookSection.RecId;

                taxTrans.TaxPeriod        = TaxBook::find(taxBookSection.TaxBook).TaxPeriod;

                if (! TaxBookSection::checkTaxBookSection(taxBookSection.NumberSequenceTable, taxTrans.TransDate, taxTrans.Voucher, taxTrans.SourceTableId))
                {
                    post = false;
                    throw error("@SYS21533");
                }
            }
        }

        TaxTransGlobalInitializer initializerBySourceTable = TaxTransGlobalInitializer::construct(taxTrans);
        initializerBySourceTable.initializeTaxTrans();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTmpTaxWorkTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the TmpTaxWorkTrans values.
    /// </summary>
    /// <param name = "_taxWorkTrans">The records of <c>TmpTaxWorkTrans</c>.</param>
    /// <param name = "_baseQty">The base quantity for tax.</param>
    protected void initTmpTaxWorkTrans(TmpTaxWorkTrans _taxWorkTrans, TaxBase _baseQty)
    {
        _taxWorkTrans.TaxBaseQty = _baseQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initVatRegData_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize VAT register data from tax transaction.
    /// </summary>
    /// <param name = "_taxTrans">Input tax transaction.</param>
    final public void initVatRegData_W(VATRegData_W _taxTrans)
    {
        this.initVatRegData(_taxTrans, taxWorkTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initVatRegData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize VAT register data from tax transaction.
    /// </summary>
    /// <param name = "_taxTrans">Input tax transaction.</param>
    /// <param name = "_taxWorkTrans">The current tax transaction.</param>
    internal void initVatRegData(VATRegData_W _taxTrans, TmpTaxWorkTrans _taxWorkTrans)
    {
        #ISOCountryRegionCodes

        TaxTrans                taxTrans;
        TaxPeriod               taxPeriod;
        IntraComVATDueDate_W    tmpIntraComVatDate;
        // <GEEPL>
        VATNum                  vatNum_PL;
        PlTaxPeriodPaymentCode  taxPeriodPaymentCode_PL;
        DocumentDate            documentDate_PL;
        PlCustVendName          custVendName_PL;
        Addressing              addressing_PL;
        VatDueDate_W            vatDueDate_W;
        // </GEEPL>

        [ vatDueDate_W,
          documentDate_PL,
          custVendName_PL,
          vatNum_PL,
          addressing_PL,
          taxPeriodPaymentCode_PL,
          _taxTrans.PostponeVAT,
          tmpIntraComVatDate] = this.parmVatRegData_W();

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            _taxTrans.VATRegData_W::setAddresssing_PL(addressing_PL);
            _taxTrans.VATRegData_W::setCustVendName_PL(custVendName_PL);
            _taxTrans.VATRegData_W::setVatNum_PL(vatNum_PL);
            _taxTrans.VATRegData_W::setTaxPeriodPaymentCode_PL(taxPeriodPaymentCode_PL);
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL, #isoCZ]))
        {
            _taxTrans.VATRegData_W::setDocumentDate_PL(documentDate_PL);
        }

        if (this.shouldSetVATDueDate_W(_taxTrans))
        {
            _taxTrans.VATRegData_W::setVatDueDate_W(vatDueDate_W);

            if (! _taxTrans.VATRegData_W::getVatDueDate_W()
                && isConfigurationkeyEnabled(configurationKeyNum(LedgerBasicVatDueDate_W))
                && !SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU, #isoRU, #isoPL])
                && !VatDueDateFeature::isEnabled())
            {
                _taxTrans.VATRegData_W::setVatDueDate_W(_taxTrans.TransDate);
            }
        }

        if (_taxTrans.TableId == tableNum(TaxTrans))
        {
            taxTrans = _taxTrans;
        }

        //<GEECZ>
        if (tmpIntraComVatDate                                 &&

            _taxWorkTrans.DocumentDate_PL                           &&
            _taxWorkTrans.TaxDirection == TaxDirection::OutgoingTax &&
            _taxWorkTrans.IntracomVAT                               &&
            VendParameters::find().DocumentDateForIntracomVAT_W)
        {
            _taxWorkTrans.VATRegData_W::setVatDueDate_W(_taxTrans.VATRegData_W::getDocumentDate_PL());
        }
        //</GEECZ>

        if (taxTrans && isConfigurationkeyEnabled(configurationKeyNum(LedgerBasicVatDueDate_W)) && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU]))
        {
            taxPeriod = taxTrans.TaxPeriod ? taxTrans.TaxPeriod : TaxTable::taxPeriod(taxTrans.TaxCode);

            if (! taxTrans.taxTrans_W().VatDueDate_W)
            {
                throw error("@GLS110103");
            }
        }

        // <GEECZ>
        if (_taxTrans.PostponeVAT)
        {
            _taxTrans.VATRegData_W::setVatDueDate_W(dateNull());
        }
        // </GEECZ>
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSetVATDueDate_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether vatDueDate_W should be set for tax transaction.
    /// </summary>
    /// <param name = "_taxTrans">Input tax transaction.</param>
    /// <returns> true if vatDueDate_W should be set for tax transaction; otherwise, false.</returns>
    protected boolean shouldSetVATDueDate_W(VATRegData_W _taxTrans)
    {
        return TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertInternalStructure</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts internal structure of tmp tax.
    /// </summary>
    /// <param name = "_tmpTax">The buffer of <c>TmpTax</c>.</param>
    /// <param name = "_taxCode">The tax code.</param>
    /// <param name = "_taxBaseAmount">The tax base amount.</param>
    /// <param name = "_taxBaseAmountRaw">The raw tax base amount.</param>
    /// <param name = "_taxBaseQty">The tax base quantity.</param>
    /// <param name = "_taxDirection">The tax direction.</param>
    /// <param name = "_unitAmount">The unit amount.</param>
    /// <param name = "_sourceTaxBaseAmountCur">The source current tax base amount.</param>
    /// <param name = "_sourceTaxBaseAmountCurRaw">The source raw currenct tax base amount.</param>
    /// <param name = "_calculationDate">The calculation date.</param>
    /// <param name = "_taxWarning">The tax warning.</param>
    /// <param name = "_taxOnTaxBasedOnInvoiceBalance">Whether balance of tax on tax based on invoice.</param>
    /// <param name = "_fiscalValue">The tax fiscal value.</param>
    /// <param name = "_taxReceivableLongTerm">Whether is tax receivable long term.</param>
    /// <param name = "_sourceCurrencyCode">The source currency code.</param>
    [SysObsolete('Please use insertInternalStructureWithCompany instead', false, 11\12\2018)]
    protected void insertInternalStructure(TmpTax           _tmpTax,
                                           TaxCode          _taxCode,
                                           TaxBase          _taxBaseAmount,
                                           TaxBase          _taxBaseAmountRaw,
                                           TaxBase          _taxBaseQty,
                                           TaxDirection     _taxDirection,
                                           TaxBase          _unitAmount,
                                           TaxBaseCur       _sourceTaxBaseAmountCur,
                                           TaxBaseCur       _sourceTaxBaseAmountCurRaw,
                                           TransDate        _calculationDate,
                                           TaxWarning       _taxWarning,
                                           boolean          _taxOnTaxBasedOnInvoiceBalance = false,
                                           // <GBR>
                                           TaxFiscalValue_BR _fiscalValue = TaxFiscalValue_BR::Blank,
                                           boolean _taxReceivableLongTerm = false,
                                           // </GBR>
                                           CurrencyCode     _sourceCurrencyCode = '')
    {
        this.insertInternalStructureWithCompany(_tmpTax, _taxCode, _taxBaseAmount, _taxBaseAmountRaw, _taxBaseQty, _taxDirection, _unitAmount, _sourceTaxBaseAmountCur,
                                                _sourceTaxBaseAmountCurRaw, _calculationDate, _taxWarning, _taxOnTaxBasedOnInvoiceBalance, _fiscalValue, _taxReceivableLongTerm, _sourceCurrencyCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertInternalStructureWithCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts internal structure of tmp tax.
    /// </summary>
    /// <param name = "_tmpTax">The buffer of <c>TmpTax</c>.</param>
    /// <param name = "_taxCode">The tax code.</param>
    /// <param name = "_taxBaseAmount">The tax base amount.</param>
    /// <param name = "_taxBaseAmountRaw">The raw tax base amount.</param>
    /// <param name = "_taxBaseQty">The tax base quantity.</param>
    /// <param name = "_taxDirection">The tax direction.</param>
    /// <param name = "_unitAmount">The unit amount.</param>
    /// <param name = "_sourceTaxBaseAmountCur">The source current tax base amount.</param>
    /// <param name = "_sourceTaxBaseAmountCurRaw">The source raw currenct tax base amount.</param>
    /// <param name = "_calculationDate">The calculation date.</param>
    /// <param name = "_taxWarning">The tax warning.</param>
    /// <param name = "_taxOnTaxBasedOnInvoiceBalance">Whether balance of tax on tax based on invoice.</param>
    /// <param name = "_fiscalValue">The tax fiscal value.</param>
    /// <param name = "_taxReceivableLongTerm">Whether is tax receivable long term.</param>
    /// <param name = "_sourceCurrencyCode">The source currency code.</param>
    /// <param name = "_company">The tmpTaxWorkTrans Company.</param>
    protected void insertInternalStructureWithCompany(TmpTax           _tmpTax,
                                                    TaxCode          _taxCode,
                                                    TaxBase          _taxBaseAmount,
                                                    TaxBase          _taxBaseAmountRaw,
                                                    TaxBase          _taxBaseQty,
                                                    TaxDirection     _taxDirection,
                                                    TaxBase          _unitAmount,
                                                    TaxBaseCur       _sourceTaxBaseAmountCur,
                                                    TaxBaseCur       _sourceTaxBaseAmountCurRaw,
                                                    TransDate        _calculationDate,
                                                    TaxWarning       _taxWarning,
                                                    boolean          _taxOnTaxBasedOnInvoiceBalance = false,
                                                    // <GBR>
                                                    TaxFiscalValue_BR _fiscalValue = TaxFiscalValue_BR::Blank,
                                                    boolean _taxReceivableLongTerm = false,
                                                    // </GBR>
                                                    CurrencyCode     _sourceCurrencyCode = '',
                                                    DataAreaId _company = '')
    {
        TaxTable            taxTable;
        boolean             splitInterval;
        TaxBase             baseAmount;
        TaxBase             baseAmountCur;
        TaxBase             startAmount;
        TaxBase             startAmountCur;
        TaxBase             maxAmount;
        TaxBase             limitBaseAmount;
        TaxBase             limitBaseAmountCur;
        TaxData             taxData;

        TaxCalculationOrder taxCalculationOrder;
        Counter             intervalNum;
        Counter             sign;
        TaxCurrencyConversionRoutineHandler handler = TaxCurrencyConversionRoutineHandler::instance();
        TaxLimitAmountTaxTableParameter taxLimitAmountTaxTableParameter = new TaxLimitAmountTaxTableParameter();

        select firstonly RecId from _tmpTax
            where _tmpTax.TaxCode == _taxCode &&
                _tmpTax.TaxDirection == _taxDirection &&
                _tmpTax.CalculationDate == _calculationDate &&
                _tmpTax.SourceCurrencyCode == _sourceCurrencyCode &&
                // <GBR>
                _tmpTax.TaxFiscalValue_BR == _fiscalValue &&
                _tmpTax.TaxReceivableLongTerm_BR == _taxReceivableLongTerm &&
                // </GBR>
                (_company == '' || _tmpTax.Company == _company);

        if (_tmpTax.RecId > 0)
        {
            return;
        }

        if(_company)
        {
            _tmpTax.Company = _company;
        }
        else
        {
            _tmpTax.Company = this.getcompany();
        }

        taxTable  = this.getTaxTable(_taxCode);

        if (taxTable.TaxLimitBase == TaxLimitBase::UnitWithoutVAT ||

            taxTable.TaxLimitBase == TaxLimitBase::UnitInclVAT)
        {
            limitBaseAmount = _unitAmount * (_taxBaseQty < 0 ? -1 : 1);
            //Feature Sales Tax Conversion
            if (this.isTaxCurrencyConversionFeatureEnabled())
            {
                limitBaseAmountCur = CurrencyExchangeHelper::curAmount(limitBaseAmount, _sourceCurrencyCode, _calculationDate, UnknownNoYes::Unknown, exchRate, 0, false);
                limitBaseAmountCur = handler.transCurrencyToTaxCurrency(_sourceCurrencyCode, taxTable.TaxCurrencyCode, limitBaseAmountCur, exchRate, reportingCurrencyExchRate, _calculationDate, false);
            }
        }
        else
        {
            if (taxTable.TaxBase == TaxBaseType::AmountByUnit
            // <GEERU>
            &&  taxTable.CustomChargeType_RU != CustomChargeType_RU::AdministrationImport
            &&  taxTable.CustomChargeType_RU != CustomChargeType_RU::AdministrationExport
            // </GEERU>
            )
            {
                limitBaseAmount = (_taxBaseQty < 0 ? -1 : 1) * _taxBaseQty;
            }
            else
            {
                //Feature Sales Tax Conversion
                if (this.isTaxCurrencyConversionFeatureEnabled())
                {
                    //here we will use Accounting currency to do the condition validation and use Tax currency to do interval amount limit calculation directly (consider fixed exchRate??)
                    limitBaseAmountCur = handler.transCurrencyToTaxCurrency(_sourceCurrencyCode, taxTable.TaxCurrencyCode, _sourceTaxBaseAmountCurRaw,
                                                                            exchRate, reportingCurrencyExchRate, _calculationDate, false);
                    limitBaseAmount = _taxBaseAmountRaw;
                }
                else
                {
                    limitBaseAmount = _taxBaseAmountRaw;
                }
            }
        }

        intervalNum             = 0;

        _tmpTax.TaxCode          = _taxCode;
        _tmpTax.TaxDirection     = _taxDirection;
        _tmpTax.CalculationDate  = _calculationDate;
        _tmpTax.Warning = _taxWarning;
        _tmpTax.SourceCurrencyCode = _sourceCurrencyCode;

        // <GIN>
        if (isCustomsEnabled

            && (EximParameters_IN::checkParameters()
           || EximParameters_IN::checkDEPBParameters()
           || EximParameters_IN::checkEPCGParameters()))
        {
            tmpTax.EximIncentiveScheme_IN = taxWorkTrans.EximIncentiveScheme_IN;
        }
        if (isIndiaCountryRegionEnabled)
        {
            tmpTax.IsScrapQtyLine_IN = taxWorkTrans.IsScrapQtyLine_IN;
        }
        // </GIN>

        switch (taxTable.TaxBase)
        {
            case TaxBaseType::AmountByUnit:
                taxCalculationOrder = taxTable.TaxIncludeInTax ? TaxCalculationOrder::CalculateBeforeOtherSalesTax : TaxCalculationOrder::PercentageOfNetAmount;
                break;

            case TaxBaseType::PctPerNet:
                taxCalculationOrder = TaxCalculationOrder::PercentageOfNetAmount;

                if (isBrazilEnabled
                    && ((taxTable.TaxType_BR == TaxType_BR::ICMS && isTaxExcludeIcmsFromAmountOrigin_BRFlightEnabled)
                        || (taxTable.TaxType_BR == TaxType_BR::ISS && isTaxExcludeIssFromAmountOrigin_BRFlightEnabled))
                    )
                {
                    // Adjust TaxCalculationSubOrderNum_BR to calculate ICMS/ISS before other tax code.
                    _tmpTax.TaxCalculationSubOrderNum_BR -= 1;
                }
                break;

            case TaxBaseType::PctPerTax:
                taxCalculationOrder = taxTable::find(taxTable.TaxOnTax).TaxBase == TaxBaseType::PctPerGross ? TaxCalculationOrder::PercentageOfSalesTaxOnGross : TaxCalculationOrder::PercentageOfSalesTax;
                break;

            case TaxBaseType::PctPerGross:
                taxCalculationOrder = taxTable.TaxOnTax ? TaxCalculationOrder::PercentageOfGrossAmountTaxOnTax : TaxCalculationOrder::PercentageOfGrossAmount;
                break;
        }

        _tmpTax.TaxCalculationOrder = taxCalculationOrder;

        if (taxTable.TaxCalcMethod == TaxCalcMode::Interval &&

            TaxData::numOfIntervals(_taxCode, _calculationDate) >= 1 &&
            !_taxOnTaxBasedOnInvoiceBalance)
        {
            splitInterval   = true;
            startAmount     = 0;
            sign            = limitBaseAmount < 0 ? -1 : 1;

            this.setValidateWarning(taxTable.TaxLimitBase, TaxWarning::InvalidTaxIncludedTaxCode, _tmpTax);

            while (splitInterval)
            {
                _tmpTax.TaxCode          = _taxCode;
                _tmpTax.TaxCalculationOrder = taxCalculationOrder;
                _tmpTax.TaxDirection     = _taxDirection;
                _tmpTax.TaxBaseAmountMST = 0;
                _tmpTax.TaxBaseQty       = _taxBaseQty;
                _tmpTax.TaxBaseLimit     = 0;
                _tmpTax.SourceCurrencyCode = _sourceCurrencyCode;


                //Feature Sales Tax Conversion
                if (this.isTaxCurrencyConversionFeatureEnabled())
                {
                    taxLimitAmountTaxTableParameter.paramTaxTable(taxTable);
                    taxLimitAmountTaxTableParameter.paramTransDate(_calculationDate);
                    taxLimitAmountTaxTableParameter.paramAmount(startAmountCur + Currency::roundingPrecisionAdjusted(taxTable.TaxCurrencyCode));
                    // use Accounting currency to do condition validation as is, use Tax currency to calculate TaxBaseAmountcur.
                    baseAmountCur   = TaxData::limitAmountCurMaxWithTaxTable(taxLimitAmountTaxTableParameter);
                }

                
                baseAmount = TaxData::limitAmountMaxWithTaxTable(taxTable,

                                                        _calculationDate,
                                                        startAmount + Currency::roundingPrecisionAdjusted(taxTable.TaxCurrencyCode));

                if (baseAmount == 0 || baseAmount > abs(limitBaseAmount))
                {
                    baseAmount    = abs(limitBaseAmount);
                    //Feature Sales Tax Conversion
                    if (this.isTaxCurrencyConversionFeatureEnabled())
                    {
                        baseAmountCur = abs(limitBaseAmountCur);
                    }
                    splitInterval = false;
                }
                if (baseAmount != 0)
                {
                    _tmpTax.TaxBaseAmountMSTRaw = (baseAmount - startAmount)* sign;
                    _tmpTax.TaxBaseAmountMST = CurrencyExchangeHelper::amount(_tmpTax.TaxBaseAmountMSTRaw);
                    //Feature Sales Tax Conversion
                    if (this.isTaxCurrencyConversionFeatureEnabled())
                    {
                        _tmpTax.TaxBaseAmountCur = CurrencyExchangeHelper::amount((baseAmountCur - startAmountCur) * sign);
                    }
                    else
                    {
                        _tmpTax.TaxBaseAmountCur = CurrencyExchangeHelper::curAmount((baseAmount - startAmount) * sign, taxTable.TaxCurrencyCode, taxDate);
                    }
                    startAmount = baseAmount;
                    //Feature Sales Tax Conversion
                    if (this.isTaxCurrencyConversionFeatureEnabled())
                    {
                        startAmountCur = baseAmountCur;
                        _tmpTax.TaxBaseLimitCur = startAmountCur;
                    }
                    _tmpTax.TaxBaseLimit = startAmount;
                    _tmpTax.IntervalNum  = intervalNum;

                    _tmpTax.insert();
                    intervalNum++;
                }
                else
                {
                    splitInterval = false;
                }
            }
        }
        else
        {
            if (taxTable.TaxLimitBase   != TaxLimitBase::UnitWithoutVAT &&
                taxTable.TaxLimitBase   != TaxLimitBase::UnitInclVAT)
            {
                maxAmount = TaxData::limitAmountMaxWithTaxTable(taxTable,
                                                    _calculationDate,
                                                    _taxBaseAmount);

                if (maxAmount && (abs(maxAmount) < abs(_taxBaseAmount)))
                {
                    _tmpTax.TaxBaseAmountMST = maxAmount;
                }
                else
                {
                    _tmpTax.TaxBaseAmountMST         = _taxBaseAmount;
                    _tmpTax.TaxBaseAmountMSTRaw      = _taxBaseAmountRaw;
                    _tmpTax.SourceTaxBaseAmountCur   = _sourceTaxBaseAmountCur;
                    _tmpTax.SourceTaxBaseAmountCurRaw = _sourceTaxBaseAmountCurRaw;
                    limitBaseAmount                 = abs(_taxBaseAmount);
                }
            }
            else
            {
                if (_taxBaseQty)
                {
                    _tmpTax.TaxBaseAmountMST          = _taxBaseAmount / abs(_taxBaseQty);
                    _tmpTax.TaxBaseAmountMSTRaw       = _taxBaseAmountRaw / abs(_taxBaseQty);
                    _tmpTax.SourceTaxBaseAmountCur    = _sourceTaxBaseAmountCur / abs(_taxBaseQty);
                    _tmpTax.SourceTaxBaseAmountCurRaw = _sourceTaxBaseAmountCurRaw/ abs(_taxBaseQty);
                }
                else
                {
                    _tmpTax.TaxBaseAmountMST          = _taxBaseAmount;
                    _tmpTax.TaxBaseAmountMSTRaw       = _taxBaseAmountRaw;
                    _tmpTax.SourceTaxBaseAmountCur    = _sourceTaxBaseAmountCur;
                    _tmpTax.SourceTaxBaseAmountCurRaw = _sourceTaxBaseAmountCurRaw;
                }
            }

            taxData = TaxData::isGreaterThanTaxableLimit(taxTable, _calculationDate, limitBaseAmount);
            if (taxData.RecId != 0)
            {
                _tmpTax.TaxBaseLimit = abs(limitBaseAmount);
            }
            else
            {
                _tmpTax.TaxBaseLimit = 0;
            }

            if (maxAmount != 0 || taxData.TaxLimitMin != 0)
            {
                this.setValidateWarning(taxTable.TaxLimitBase, TaxWarning::InvalidTaxIncludedTaxCode, _tmpTax);
            }

            //Feature Sales Tax Conversion
            if (this.isTaxCurrencyConversionFeatureEnabled())
            {
                _tmpTax.TaxBaseAmountCur = handler.transCurrencyToTaxCurrency(_sourceCurrencyCode, taxTable.TaxCurrencyCode, _tmpTax.SourceTaxBaseAmountCur,
                                                                                exchRate, reportingCurrencyExchRate, taxDate);
            }
            else
            {
                _tmpTax.TaxBaseAmountCur = CurrencyExchangeHelper::curAmount(_tmpTax.TaxBaseAmountMST, taxTable.TaxCurrencyCode, taxDate);
            }
            _tmpTax.TaxBaseQty       = _taxBaseQty;
            _tmpTax.IntervalNum      = 0;

            // <GBR>
            if (isBrazilEnabled)
            {
                _tmpTax.TaxFiscalValue_BR = _fiscalValue;
                _tmpTax.TaxReceivableLongTerm_BR = _taxReceivableLongTerm;
            }
            // </GBR>

            // <GIN>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
            {
                _tmpTax.SourceTableId_IN = this.sourceTableId();
                _tmpTax.SourceRecId_IN   = this.sourceRecId();
            }
            // </GIN>

            _tmpTax.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntersection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the intersection of the tax group.
    /// </summary>
    /// <param name = "_taxGroup">The tax group.</param>
    /// <param name = "_taxItemGroup">The tax item group.</param>
    /// <param name = "_inventTransId">The invent transaction Id.</param>
    /// <param name = "_txt">The name.</param>
    /// <param name = "_taxCalculationDate">The tax calculation date.</param>
    /// <param name = "_invoiceId">The invoice Id.</param>
    /// <param name = "_gsthstTaxType_CA">The GST tax type.</param>
    [Hookable(true)]
    protected void insertIntersection(TaxGroup               _taxGroup,
                                      TaxItemGroup           _taxItemGroup,
                                      InventTransId          _inventTransId,
                                      TransactionTextlarge   _txt,
                                      TransDate              _taxCalculationDate,
                                      InvoiceId              _invoiceId        = '',
                                      GSTHSTTaxType_CA       _gsthstTaxType_CA = GSTHSTTaxType_CA::None)

    {
        // make sure this method has difference with that in SYS layer
        TaxGroupData        taxGroupData;
        TaxOnItem           taxOnItem;
        boolean             found, intracomVAT;
        SelectableDataArea  company;
        Set                 taxCodeCombination = new Set(Types::String);
        #ISOCountryRegionCodes
        // <GEERU>
        boolean             countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        int                 i;
        container           cachedResult;
        TaxGroup            taxGroup;
        TaxCode             taxCode;
        TaxExemptTax        exemptTax;
        NoYes               icVat;

        #DEFINE.TaxIntersectionList(

            taxGroup,
            taxCode,
            exemptTax,
            icVat
        )

        company = this.getCompany();

        if (_taxGroup && _taxItemGroup)
        {
            changecompany(company)
            {
                // Determine if intracom vat should be used
                intracomVAT = VendParameters::find().IntracomVAT;

                // Pull the intersection information from cache
                cachedResult = TaxCache::getValue(

                    TaxCacheScope::IntersectionData,
                    [curext(), _taxGroup, _taxItemGroup]);
                if (cachedResult == conNull())
                {
                    // Data not yet cached, look it up
                    while select TaxGroup, TaxCode, ExemptTax, IntracomVAT from taxGroupData
                        where taxGroupData.TaxGroup             == _taxGroup
                        join TaxItemGroup, TaxCode
                            // <GBR>
                            ,ExemptTax_BR
                            // </GBR>
                            from taxOnItem
                        where taxOnItem.TaxItemGroup            == _taxItemGroup     &&
                              taxOnItem.TaxCode                 == taxGroupData.TaxCode
                    {
                        cachedResult += [[
                            taxGroupData.TaxGroup,
                            taxGroupData.TaxCode,
                            taxGroupData.ExemptTax
                            // <GBR>
                            || taxOnItem.ExemptTax_BR
                            // </GBR>
                            ,
                            taxGroupData.IntracomVAT
                            ]];
                    }
                    if (cachedResult == conNull())
                    {
                        // Special case where intersection is empty, cache [connull()] to ensure the selection isn't done again
                        cachedResult = [conNull()];
                    }

                    TaxCache::insertValue(

                        TaxCacheScope::IntersectionData,
                        [curext(), _taxGroup, _taxItemGroup],
                        cachedResult);
                }
            }

            if (cachedResult != [conNull()])
            {
                for (i = 1; i <= conLen(cachedResult); i++)
                {
                    [#TaxIntersectionList] = conPeek(cachedResult, i);

                    if (!this.isValidTaxCodeIntersectionByCalculationDate(taxCode, _taxCalculationDate))
                    {
                        continue;
                    }

                    found = true;
                    // <GIN>
                    // If current tax is for India skip the standard insertion of TaxWorkTrans, as this is taken care down, seperatly
                    // because of formula designer dependency.
                    changecompany(company)
                    {
                        if (isIndiaCountryRegionEnabled
                            && TaxTable::find(taxCode).TaxType_IN != TaxType_IN::None)
                        {
                            continue;
                        }
                        // </GIN>

                        taxGroupData = TaxGroupData::find(taxGroup, taxCode);
                        // <GEERU>
                        if (countryRegion_RU)
                        {
                            taxWorkTrans.TaxCode               = this.taxCode_RU(taxCode);
                            taxWorkTrans.vatOperationCode_RU   = this.vatOperationCode_RU();
                        }
                        else
                        {
                            // </GEERU>
                            taxWorkTrans.TaxCode               = taxCode;
                            // <GEERU>
                        }
                        // </GEERU>
                        taxWorkTrans.EmptyTaxBaseForOutgoingTax_W = this.emptyBaseForOutgoingTax_W(taxGroupData);
                        // <GBR>
                        if (isBrazilEnabled)
                        {
                            taxWorkTrans.TaxType_BR         = TaxTable::find(taxCode).TaxType_BR;
                        }
                        // </GBR>
                    }
                    taxWorkTrans.ExchRate = this.parmExchRate();
                    taxWorkTrans.ReportingCurrencyExchRate = this.parmReportingCurrencyExchRate();

                    if(this.sourceTableId() == tableNum(LedgerJournalTrans))
                    {
                        LedgerJournalTrans currentLedgerJournalTrans;
                        currentLedgerJournalTrans = LedgerJournalTrans::findRecId(this.sourceRecId(), false);
                        this.parmReportingCurrencyExchRate(currentLedgerJournalTrans.ReportingCurrencyExchRate);
                        taxWorkTrans.ReportingCurrencyExchRate = currentLedgerJournalTrans.ReportingCurrencyExchRate;

                        if(company != currentLedgerJournalTrans.Company && currentLedgerJournalTrans.CurrencyCode)
                        {
                            TransDate exchRateDateCurrent;
                            UnknownNoYes triangulationCurrent;
                            ExchRate exchRateCurrent;
                            changecompany(company)
                            {
                                exchRateDateCurrent = currentLedgerJournalTrans.exchRateDate_W();
                                triangulationCurrent = Currency::noYes2UnknownNoYes(Currency::triangulation(currentLedgerJournalTrans.CurrencyCode,exchRateDateCurrent));
                                exchRateCurrent = ExchangeRateHelper::exchRate(currentLedgerJournalTrans.CurrencyCode, exchRateDateCurrent, triangulationCurrent);
                            }
                            taxWorkTrans.ExchRate = exchRateCurrent;
                        }
                    }
                    taxWorkTrans.TaxDirection          = this.determineDirection(taxGroupData);
                    taxWorkTrans.HeadingRecId          = headingRecId;
                    taxWorkTrans.ParentSourceTableId   = this.parmParentSourceTableId();
                    taxWorkTrans.ParentSourceRecId     = this.parmParentSourceRecId();
                    taxWorkTrans.SourceTableId         = this.sourceTableId();
                    taxWorkTrans.SourceRecId           = this.sourceRecId();
                    taxWorkTrans.Company               = company;
                    taxWorkTrans.Prepayment            = this.isPrePayment();
                    taxWorkTrans.Txt                   = _txt;
                    taxWorkTrans.Voucher               = voucher;
                    taxWorkTrans.TransDate             = taxDate;
                    taxWorkTrans.TaxGroup              = _taxGroup;
                    taxWorkTrans.TaxItemGroup          = _taxItemGroup;

                    taxWorkTrans.InventTransId         = _inventTransId;
                    taxWorkTrans.SourceCurrencyCode    = sourceCurrencyCode;
                    taxWorkTrans.Source                = taxModuleType;
                    taxWorkTrans.TaxAutogenerated      = NoYes::Yes;
                    taxWorkTrans.TaxReports            = NoYes::Yes;
                    taxWorkTrans.ExemptTax = taxWorkTrans.TaxDirection != TaxDirection::UseTax ? exemptTax : NoYes::No;
                    taxWorkTrans.CalculationDate       = _taxCalculationDate;
                    taxWorkTrans.InvoiceId             = _invoiceId;
                    taxWorkTrans.HeadingTableId        = this.headingTableId();
                    taxWorkTrans.Posted                = false;
                    taxWorkTrans.gsthstTaxType_CA      = _gsthstTaxType_CA;
                    taxWorkTrans.ReverseCharge_W       = taxGroupData.ReverseCharge_W;

                    if (intracomVAT)
                    {
                        taxWorkTrans.IntracomVAT        = icVat;
                    }

                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        this.updateTaxWorkTrans_RU(taxWorkTrans);
                    }
                    // </GEERU>

                    // <GEEU>
                    changecompany(company)
                    {
                        this.initVatRegData_W(taxWorkTrans);
                    }
                    // </GEEU>

                    [taxWorkTrans.Reason, taxWorkTrans.ReasonComment] = this.getReasonData();
                    taxWorkTrans.insert(this.ignoreCalculatedSalesTax());

                    taxCodeCombination.add(taxWorkTrans.TaxCode);
                }
            }
        }

        this.checkForIntersectionAndDisplayErrorMessage(_taxGroup, _taxItemGroup, found, company);
        
        // if we are updating existing lines then we need to soft delete
        // all the tax lines for this source line since there were no taxes
        // derived.
        if (maintainExistingTaxUncommitted && !found)
        {
            boolean deleteSourceDocumentLineFalse = false;
            boolean maintainExistingTaxUncommittedTrue = true;
            boolean doIsolateTransactionScopeFalse = false;

            TaxUncommitted::deleteForDocumentLine(this.sourceTableId(), this.sourceRecId(), deleteSourceDocumentLineFalse, maintainExistingTaxUncommittedTrue, doIsolateTransactionScopeFalse);
        }
        // <GIN>
        if (isIndiaCountryRegionEnabled)
        {
            // India has formula designer dependency, perform India specific insertIntersection
            this.insertIntersection_IN(_taxGroup, _taxItemGroup, _inventTransId, _txt, _taxCalculationDate, _invoiceId);
            return;
        }
        // </GIN>

        update_recordset taxWorkTrans
            setting TaxCodeCombinationId = this.findTaxCodeCombinationId(taxCodeCombination)
            where taxWorkTrans.HeadingRecId == headingRecId
               && taxWorkTrans.HeadingTableId == headingTableId
               && taxWorkTrans.SourceTableId == this.sourceTableId()
               && taxWorkTrans.SourceRecId == this.sourceRecId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntersection_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the intersection of the tax group.
    /// </summary>
    /// <param name="_taxGroup">
    /// The tax group.
    /// </param>
    /// <param name="_taxItemGroup">
    /// The tax item group.
    /// </param>
    /// <param name="_inventTransId">
    /// The invent transaction id.
    /// </param>
    /// <param name="_txt">
    /// The name of the intersection.
    /// </param>
    /// <param name="_taxCalculationDate">
    /// The tax calculation date.
    /// </param>
    /// <param name="_invoiceId">
    /// The invoice id.
    /// </param>
    protected void insertIntersection_IN(
        TaxGroup        _taxGroup,
        TaxItemGroup    _taxItemGroup,
        InventTransId   _inventTransId,
        Name            _txt,
        TransDate       _taxCalculationDate,
        InvoiceId       _invoiceId = '')

    {
        TaxGroupData        taxGroupData;
        TaxOnItem           taxOnItem;
        FormulaDesigner_IN  formulaDesigner;
        TaxTable            taxTableLoc;
        TaxTable            taxTableLocal;
        Set                 taxCodeCombination = new Set(Types::String);

        if (_taxItemGroup && _taxGroup)
        {
            // Perform intersection only if India Taxcode is pressent at least once.
            select firstonly RecId, TaxCode from taxGroupData
                where taxGroupData.TaxGroup == _taxGroup
                join TaxItemGroup, TaxCode from taxOnItem
                    where taxOnItem.TaxItemGroup == _taxItemGroup
                        && taxOnItem.TaxCode     == taxGroupData.TaxCode
                        join RecId from taxTableLoc
                            where taxTableLoc.TaxCode     == taxOnItem.TaxCode
                                && taxTableLoc.TaxType_IN != TaxType_IN::None;
        }
        if (taxGroupData.RecId)
        {
            if (!this.parmInvoiceCompany_IN())
            {
                this.parmInvoiceCompany_IN(curext());
            }
            changecompany(this.parmInvoiceCompany_IN())
            {
                while select taxGroupData
                    where taxGroupData.TaxGroup == _taxGroup
                        join TaxCode from taxOnItem
                            where taxOnItem.TaxItemGroup == _taxItemGroup
                            && taxOnItem.TaxCode         == taxGroupData.TaxCode
                            join taxTableLocal
                                where taxTableLocal.TaxCode == taxOnItem.TaxCode
                                join RecId, id from formulaDesigner
                                    order by id
                                    where formulaDesigner.TaxItemGroup == _taxItemGroup
                                        && taxOnItem.TaxCode           == taxGroupData.TaxCode
                                        && formulaDesigner.TaxCode     == taxOnItem.TaxCode
                {
                    //check the tax type, if not enable, throw error.
                    TaxParameters::checkParameter_IN(taxTableLocal.TaxType_IN, true);

                    if (!this.isTaxableCombination_IN(taxGroupData.TaxCode)
                        || this.checkIfSkipIntersection_IN(taxOnItem)
                        || !this.isTaxableOnMarkupTrans_IN(taxTableLocal.TaxType_IN))
                    {
                        continue;
                    }
                    taxCodeCombination.add(this.insertUpdateTaxTmpWorkTrans_IN(
                                            _taxGroup,
                                            _taxItemGroup,
                                            taxGroupData,
                                            formulaDesigner,
                                            taxOnItem,
                                            _inventTransId,
                                            _txt,
                                            _taxCalculationDate,
                                            taxTableLocal,
                                            _invoiceId));
                }
                relatedVoucher = '';
            }
            update_recordset taxWorkTrans
                setting TaxCodeCombinationId = this.findTaxCodeCombinationId(taxCodeCombination)
                where taxWorkTrans.HeadingRecId == headingRecId
                    && taxWorkTrans.HeadingTableId == headingTableId
                    && taxWorkTrans.SourceTableId == this.sourceTableId()
                    && taxWorkTrans.SourceRecId == this.sourceRecId();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntersection_LV</Name>
				<Source><![CDATA[
    // The method should be an exact copy of insertIntersection, but with LVNR* tax settings
    private void insertIntersection_LV(TaxGroup         _taxGroup,
                                       LvNRTaxGroup     _nrTaxGroup,
                                       InventTransId    _inventTransId,
                                       Name             _txt,
                                       TransDate        _taxCalculationDate)

    {
        TaxGroupData        taxGroupData;
        LvNRTaxOnItem       taxOnItem;
        boolean             found, intracomVAT;
        SelectableDataArea  company;
        Set                 taxCodeCombination = new Set(Types::String);

        int                 i;
        container           cachedResult;
        TaxGroup            taxGroup;
        TaxCode             taxCode;
        TaxExemptTax        exemptTax;
        NoYes               icVat;

        #DEFINE.TaxIntersectionList(
            taxGroup,
            taxCode,
            exemptTax,
            icVat
        )

        // Determine if intracom vat should be used
        company = this.getCompany();

        if (_taxGroup && _nrTaxGroup)
        {
            changecompany(company)
            {
                intracomVAT = VendParameters::find().IntracomVAT;
            }

            // Pull the intersection information from cache
            cachedResult = TaxCache::getValue(
                TaxCacheScope::IntersectionData,
                [curext(), _taxGroup, _nrTaxGroup]);
            if (cachedResult == conNull())
            {
                // Data not yet cached, look it up
                while select TaxGroup, TaxCode, ExemptTax, IntracomVAT from taxGroupData
                    where taxGroupData.TaxGroup             == _taxGroup
                join TaxGroup, TaxCode from taxOnItem
                    where taxOnItem.TaxGroup                == _nrTaxGroup     &&
                          taxOnItem.TaxCode                 == taxGroupData.TaxCode
                {
                    cachedResult += [[
                        taxGroupData.TaxGroup,
                        taxGroupData.TaxCode,
                        taxGroupData.ExemptTax,
                        taxGroupData.IntracomVAT
                        ]];
                }
                if (cachedResult == conNull())
                {
                    // Special case where intersection is empty, cache [connull()] to ensure the selection isn't done again
                    cachedResult = [conNull()];
                }

                TaxCache::insertValue(
                    TaxCacheScope::IntersectionData,
                    [curext(), _taxGroup, _nrTaxGroup],
                    cachedResult);
            }

            if (cachedResult != [conNull()])
            {
                for (i = 1; i <= conLen(cachedResult); i++)
                {
                    [#TaxIntersectionList] = conPeek(cachedResult, i);

                    found = true;

                    taxWorkTrans.HeadingRecId          = headingRecId;
                    taxWorkTrans.SourceTableId         = this.sourceTableId();
                    taxWorkTrans.SourceRecId           = this.sourceRecId();
                    taxWorkTrans.Company               = company;
                    taxWorkTrans.Prepayment            = this.isPrePayment();
                    taxWorkTrans.Txt                   = _txt;
                    taxWorkTrans.Voucher               = voucher;
                    taxWorkTrans.TransDate             = taxDate;
                    taxWorkTrans.TaxCode               = taxCode;
                    taxWorkTrans.TaxGroup              = _taxGroup;

                    taxWorkTrans.InventTransId         = _inventTransId;
                    taxWorkTrans.SourceCurrencyCode    = sourceCurrencyCode;
                    taxWorkTrans.TaxDirection          = this.determineDirection(TaxGroupData::find(taxGroup, taxCode));
                    taxWorkTrans.Source                = taxModuleType;
                    taxWorkTrans.TaxAutogenerated      = NoYes::Yes;
                    taxWorkTrans.TaxReports            = NoYes::Yes;
                    taxWorkTrans.ExemptTax             = taxWorkTrans.TaxDirection != TaxDirection::UseTax ? exemptTax : NoYes::No;
                    taxWorkTrans.CalculationDate       = _taxCalculationDate;
                    taxWorkTrans.HeadingTableId        = this.headingTableId();
                    taxWorkTrans.Posted                = false;

                    if (intracomVAT)
                    {
                        taxWorkTrans.IntracomVAT        = icVat;
                    }

                    taxWorkTrans.insert();
                    taxCodeCombination.add(taxWorkTrans.TaxCode);
                }
            }
        }

        if (!found && (_taxGroup || _nrTaxGroup))
        {
            changecompany(company)
            {
                switch (this.taxParameters().CheckIntersection)
                {
                    case CheckTaxGroups::Warning :
                        warning(strFmt("@GLS113436", _taxGroup, _nrTaxGroup));
                        break;

                    case CheckTaxGroups::Error :
                        throw error(strFmt("@GLS113436", _taxGroup, _nrTaxGroup));

                    default :
                        break;
                }
            }
        }

        // if we are updating existing lines then we need to soft delete
        // all the tax lines for this source line since there were no taxes
        // derived.
        if (maintainExistingTaxUncommitted && !found)
        {
            TaxUncommitted::deleteForDocumentLine(this.sourceTableId(), this.sourceRecId(), false, true);
        }

        update_recordset taxWorkTrans
            setting TaxCodeCombinationId = this.findTaxCodeCombinationId(taxCodeCombination)
            where taxWorkTrans.HeadingRecId == headingRecId
               && taxWorkTrans.HeadingTableId == headingTableId
               && taxWorkTrans.SourceTableId == this.sourceTableId()
               && taxWorkTrans.SourceRecId == this.sourceRecId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLineInInternal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts line in internal.
    /// </summary>
    /// <param name="_baseAmount">
    /// The tax base amount.
    /// </param>
    /// <param name="_baseQty">
    /// The tax base quantity.
    /// </param>
    /// <param name="_baseUnit">
    /// The tax base unit.
    /// </param>
    /// <param name="_itemId">
    /// The item id.
    /// </param>
    /// <param name="_unitAmount">
    /// The tax base unit amount.
    /// </param>
    /// <param name="_dimensionDefault">
    /// The dimension default.
    /// </param>
    /// <param name="_operationLedgerDimension">
    /// The ledger dimension account.
    /// </param>
    /// <param name="_operationPostingType">
    /// The ledger posting type.
    /// </param>
    /// <param name="_exchRate_W">
    /// The exchange rate.
    /// </param>
    /// <param name="_vatDueDate_W">
    /// The vat due date.
    /// </param>
    protected void insertLineInInternal(TaxBase                _baseAmount,
                                        TaxBase                _baseQty,
                                        UnitOfMeasureSymbol    _baseUnit,
                                        ItemId                 _itemId,
                                        TaxBase                _unitAmount,
                                        DimensionDefault       _dimensionDefault,
                                        LedgerDimensionAccount _operationLedgerDimension,
                                        LedgerPostingType      _operationPostingType = LedgerPostingType::None
                                        ,ExchRate            _exchRate_W = 0,
                                        VatDueDate_W        _vatDueDate_W = dateNull()
                                        )
    {
        TaxTable                taxTable;
        TaxTable                taxTableTaxOnTax;
        TaxBase                 baseAmountMST;
        TaxBase                 unitAmountMST;
        TaxBase                 unitAmountRecalculated;
        TaxCalcPrin             taxCalcPrin;
        TaxData                 taxData;
        Currency                currencySource;
        Currency                currencyMST;
        CurrencyCode            currencyMSTCode;
        boolean                 currenciesFound;

        // <GBR>
        TaxBase                 oldBaseAmount;
        boolean                 taxValidated = true;
        TaxationCodeTable_BR    taxationCodeTable;
        // </GBR>
        // <GEERU>
        boolean                 countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        TaxCurrencyConversionRoutineHandler handler = TaxCurrencyConversionRoutineHandler::instance();

        changecompany(this.getCompany())
        {
            currencyMSTCode = Ledger::accountingCurrency(this.companyInfo().RecId);

            // <GBR>
            if (isBrazilEnabled)
            {
                oldBaseAmount = _baseAmount;
            }
            else
            {
                // </GBR>
                if (sourceCurrencyCode != currencyMSTCode)
                {
                    baseAmountMST = CurrencyExchangeHelper::mstAmount(_baseAmount, sourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), 0, 0, false);

                    unitAmountMST = CurrencyExchangeHelper::mstAmount(_unitAmount, sourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), 0, 0, false);
                }
                else
                {
                    baseAmountMST = _baseAmount;
                    unitAmountMST = _unitAmount;
                }
                // <GBR>
            }
            // </GBR>
        }
        this.purgeInternalStructure();

        taxCalcPrin = this.taxParameters().CalculatePrinciple;

        while select forupdate taxWorkTrans
            where taxWorkTrans.HeadingRecId == headingRecId
               && taxWorkTrans.HeadingTableId == headingTableId
               && taxWorkTrans.SourceTableId == this.sourceTableId()
               && taxWorkTrans.SourceRecId == this.sourceRecId()
        {
            this.initTmpTaxWorkTrans(taxWorkTrans, _baseQty);

            changecompany(this.getCompany())
            {
                if (!currenciesFound)
                {
                    currencySource = this.getSourceCurrency();
                    currencyMST    = this.getCompanyCurrency();
                    currenciesFound = true;
                }
                taxTable = this.getTaxTable(taxWorkTrans.TaxCode);
                if (taxTable.RecId == 0)
                {
                    throw error(strFmt("@SYS344547", taxWorkTrans.TaxCode, this.getCompany()));
                }
                // <GIN>
                // Skip India Tax codes for Standard AX-scenarios.
                if (isIndiaCountryRegionEnabled
                    && taxTable.TaxType_IN != TaxType_IN::None)
                {
                    continue;
                }
                // </GIN>

                if (this.removeInvalidTaxCode(taxWorkTrans))
                {
                    taxWorkTrans.delete();
                    continue;
                }

                // <GBR>
                if (isBrazilEnabled)
                {
                    taxWorkTrans.IncludedInPrice_BR = taxTable.IncludedTax_BR || taxTable.RetainedTax_BR;

                    taxWorkTrans.TaxTributarySubstitution = taxTable.TaxSubstitution_BR;

                    taxationCodeTable               = this.determineTaxationCode_BR(taxWorkTrans.TaxCode,
                                                                                    TaxOnItem::find(taxWorkTrans.TaxItemGroup, taxWorkTrans.TaxCode),
                                                                                    TaxGroupData::find(taxWorkTrans.TaxGroup, taxWorkTrans.TaxCode));

                    taxWorkTrans.TaxationCode_BR    = taxationCodeTable.TaxationCode;
                    taxWorkTrans.FiscalValue_BR     = this.determineFiscalValue_BR(taxationCodeTable,
                                                                                   taxWorkTrans.ExemptTax,
                                                                                   TaxOnItem::find(taxWorkTrans.TaxItemGroup, taxWorkTrans.TaxCode).WithoutTaxCredit_BR);

                    taxValidated = this.validateTaxWorkTrans_BR(taxWorkTrans) && taxValidated;
                }
                // </GBR>

                // For InvoiceInclVAT and PctPerGross, keep running record of how many tax codes of each type exist for future validation
                if (taxTable.TaxLimitBase == TaxLimitBase::InvoiceInclVAT)
                {
                    totalValidationInvoiceInclVAT.add(taxTable.TaxCode);
                }
                if (taxTable.TaxBase == TaxBaseType::PctPerGross && !taxTable.TaxOnTax)
                {
                    totalValidationPctPerGross.add(taxTable.TaxCode);
                }

                if (taxTable.TaxBase == TaxBaseType::AmountByUnit)
                {
                    taxData = TaxData::find(taxWorkTrans.TaxCode,
                                            taxWorkTrans.CalculationDate,
                                            0);
                }
                else
                {
                    taxData = TaxData::find(taxWorkTrans.TaxCode,
                                            taxWorkTrans.CalculationDate,
                                            _baseAmount);
                }

                // <GBR>
                if (isBrazilEnabled)
                {
                    _baseAmount = this.determineSign_BR(oldBaseAmount);

                    if (useAndConsumption_BR)
                    {
                        _baseAmount = this.determineFinalUserBase_BR(_baseAmount);
                    }
                    if (directImport_BR)
                    {
                        _baseAmount = this.determineDirectImportBase_BR(_baseAmount);
                    }

                    taxWorkTrans.TaxBaseAmountOrig = _baseAmount;

                    if (taxWorkTrans.FiscalValue_BR != TaxFiscalValue_BR::WithoutCreditDebitExempt
                        && !taxTable.TaxSubstitution_BR && taxData.TaxReductionPct_BR)
                    {
                        _baseAmount = _baseAmount * (1 - taxData.TaxReductionPct_BR/100);
                    }

                    taxWorkTrans.TaxReductionPct_BR = taxData.TaxReductionPct_BR;

                    if ((taxWorkTrans.TaxType_BR == TaxType_BR::ICMS && assetICMSReceivableLongTerm_BR)
                        || (taxWorkTrans.TaxType_BR == TaxType_BR::COFINS && assetPISCOFINSReceivableLongTerm_BR)
                        || (taxWorkTrans.TaxType_BR == TaxType_BR::PIS && assetPISCOFINSReceivableLongTerm_BR))
                    {
                        taxWorkTrans.TaxReceivableLongTerm_BR = true;
                    }

                    //***Copied from above for GBR
                    if (sourceCurrencyCode != Ledger::accountingCurrency(this.companyInfo().RecId))
                    {
                        baseAmountMST = CurrencyExchangeHelper::mstAmount(_baseAmount, sourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), 0, 0, false);

                        unitAmountMST = CurrencyExchangeHelper::mstAmount(_unitAmount, sourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), 0, 0, false);
                    }
                    else
                    {
                        baseAmountMST = _baseAmount;
                        unitAmountMST = _unitAmount;
                    }
                    //***

                    if (taxWorkTrans.FiscalValue_BR == TaxFiscalValue_BR::WithoutCreditDebitExempt)
                    {
                        this.applyExemptFiscalValue_BR(taxTable, _baseAmount);
                    }
                }
                // </GBR>

                if (taxCalcPrin != TaxCalcPrin::Total)
                {
                    if (taxTable.TaxLimitBase == TaxLimitBase::InvoiceWithoutVAT ||
                        taxTable.TaxLimitBase == TaxLimitBase::InvoiceInclVAT)
                    {
                        taxCalculateTotal = true;
                    }
                    taxCalculateLine = true;
                }
                else
                {
                    taxCalculateTotal = true;
                }

                this.setLedgerDimensions(taxWorkTrans, taxTable, _dimensionDefault, _operationLedgerDimension);

                // <GEERU>
                if (countryRegion_RU)
                {
                    taxWorkTrans.WithoutTaxTrans_RU  = !this.inventProfileTaxTrans_RU();
                    taxWorkTrans.InventProfileType_RU = this.inventProfileType_RU();
                }
                // </GEERU>

                // <GEERU>
                if (taxWorkTrans.ExemptTax == NoYes::No
                    || this.processExemptTax_RU())
                // </GEERU>
                {
                    // <GEERU>
                    taxWorkTrans.MarkupTransRecId_RU = this.markupTransRecId_RU();
                    // </GEERU>

                    if (taxData.TaxValue < 0)
                        taxWorkTrans.NegativeTax = true;
                }

                taxWorkTrans.OperationPostingType = _operationPostingType;
                taxWorkTrans.CurrencyCode = taxTable.TaxCurrencyCode;

                if ((taxTable.TaxBase == TaxBaseType::AmountByUnit) ||
                    (taxTable.TaxLimitBase == TaxLimitBase::UnitWithoutVAT ||
                     taxTable.TaxLimitBase == TaxLimitBase::UnitInclVAT))

                {
                    changecompany(this.getCompany())
                    {
                        if (taxTable.TaxPackagingTax)
                            taxWorkTrans.TaxBaseQty = Tax::packagingQuantity(
                            _baseQty,
                            _baseUnit,
                            _itemId,
                            InventTransOrigin::findByInventTransId(taxWorkTrans.InventTransId).ItemInventDimId
                            // <GEELV>
                            ,
                            skipException
                            // </GEELV>
                            );
                        else
                        {
                            EcoResProductUnitConverter ecoResConverter = EcoResProductUnitConverter::newGivenUnitSymbolsForReleasedProduct(_itemId,
                                                                                        InventTransOrigin::findByInventTransId(taxWorkTrans.InventTransId).ItemInventDimId,
                                                                                        _baseUnit,
                                                                                        taxTable.TaxUnit,
                                                                                        NoYes::Yes,
                                                                                        NoYes::Yes);
                            ecoResConverter.parmSkipException(skipException);

                            taxWorkTrans.TaxBaseQty = ecoResConverter.convertValue(_baseQty);
                        }
                    }
                }
                if (taxTable.TaxBase == TaxBaseType::PctPerTax)
                {
                    // Since taxTableTaxOnTax will be cleared in some cases, don't pull the cached version of the record
                    taxTableTaxOnTax = TaxTable::find(taxTable.TaxOnTax);
                }
                else
                {
                    taxTableTaxOnTax.clear();
                }

                if (taxTable.TaxBase != TaxBaseType::AmountByUnit)
                {
                    taxWorkTrans.TaxBaseAmountRaw       = baseAmountMST;

                    if (taxTable.TaxBase == TaxBaseType::PctPerNet //Pct of net amount
                        && taxTable.TaxLimitBase == TaxLimitBase::InvoiceWithoutVAT //Net amount of invoice balance
                        && taxTable.ReconcileAmountOrigin == NoYes::Yes
                        && this is TaxSales)
                    {
                        TaxBase taxOriginDiff = 0;
                        if (taxOriginDiffMap.exists(taxTable.RecId))
                        {
                            taxOriginDiff = taxOriginDiffMap.lookup(taxTable.RecId);
                        }
                        taxWorkTrans.SourceBaseAmountCur = currencySource.amount_Instance(_baseAmount);
                        reconcileMap.insert([taxWorkTrans.SourceTableId, taxWorkTrans.SourceRecId, taxWorkTrans.TaxCode], currencySource.amount_Instance(_baseAmount + taxOriginDiff));
                        taxOriginDiff += _baseAmount - currencySource.amount_Instance(_baseAmount + taxOriginDiff);
                        taxOriginDiffMap.insert(taxTable.RecId, taxOriginDiff);
                    }
                    else
                    {
                        taxWorkTrans.SourceBaseAmountCur = currencySource.amount_Instance(_baseAmount);
                    }

                    taxWorkTrans.SourceBaseAmountCurCalculated = taxWorkTrans.SourceBaseAmountCur;

                    // baseAmountMST was converted from a raw transactional amount, for the rounded base in MST
                    // we need to convert from a rounded transactional base amount
                    taxWorkTrans.TaxBaseAmount          = CurrencyExchangeHelper::mstAmount(taxWorkTrans.SourceBaseAmountCur, sourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), 0, 0, true);
                    taxWorkTrans.SourceBaseAmountCurRaw = _baseAmount;
                    taxWorkTrans.CurrencyCode           = taxTable.TaxCurrencyCode;
                    //Feature Sales Tax Conversion
                    if(this.isTaxCurrencyConversionFeatureEnabled())
                    {
                        taxWorkTrans.TaxBaseAmountCur = handler.transCurrencyToTaxCurrency(sourceCurrencyCode, taxWorkTrans.CurrencyCode, taxWorkTrans.SourceBaseAmountCur,
                                                                                            taxWorkTrans.ExchRate, taxWorkTrans.ReportingCurrencyExchRate, taxDate);
                    }
                    else
                    {
                        if (taxTable.TaxCurrencyCode == sourceCurrencyCode)
                        {
                            taxWorkTrans.TaxBaseAmountCur       = taxWorkTrans.SourceBaseAmountCur;
                        }
                        else
                        {
                            taxWorkTrans.TaxBaseAmountCur       = CurrencyExchangeHelper::curAmount(taxWorkTrans.TaxBaseAmount, taxWorkTrans.CurrencyCode, taxDate);
                        }
                    }
                    taxWorkTrans.TaxBaseAmountRep = handler.transCurrencyToReportingCurrency(sourceCurrencyCode, taxWorkTrans.SourceBaseAmountCur,
                                                                                                taxWorkTrans.ReportingCurrencyExchRate, taxDate);
                }

                /* <SYS>
                if (taxWorkTrans.ExemptTax == NoYes::No)
                </SYS> */
                // <GEERU>
                if (   taxWorkTrans.ExemptTax == NoYes::No
                    || this.processExemptTax_RU())
                // </GEERU>
                {
                    if ((taxTable.TaxBase == TaxBaseType::AmountByUnit && !taxTable.TaxPackagingTax) ||
                        (taxTable.TaxLimitBase == TaxLimitBase::UnitWithoutVAT ||
                         taxTable.TaxLimitBase == TaxLimitBase::UnitInclVAT))
                    {
                        EcoResProductUnitConverter ecoResConverter = EcoResProductUnitConverter::newGivenUnitSymbolsForReleasedProduct(_itemId,
                                                                                        InventTransOrigin::findByInventTransId(taxWorkTrans.InventTransId).ItemInventDimId,
                                                                                        _baseUnit,
                                                                                        taxTable.TaxUnit,
                                                                                        NoYes::Yes,
                                                                                        NoYes::No);
                        ecoResConverter.parmSkipException(skipException);

                        unitAmountRecalculated = ecoResConverter.convertValue(unitAmountMST);
                    }

                    TaxInsertInternalStructureParameters insertInternalStructureParameters = TaxInsertInternalStructureParameters::construct();

                    insertInternalStructureParameters.TaxCalcPrin = taxCalcPrin;
                    insertInternalStructureParameters.TaxLimitBase = taxTable.TaxLimitBase;
                    insertInternalStructureParameters.TaxTableTaxOnTax = taxTableTaxOnTax;
                    insertInternalStructureParameters.TaxWorkTrans = taxWorkTrans;
                    insertInternalStructureParameters.TaxBaseAmount = currencyMST.amount_Instance(baseAmountMST);
                    insertInternalStructureParameters.TaxBaseAmountRaw = baseAmountMST;
                    insertInternalStructureParameters.UnitAmount = unitAmountRecalculated;
                    insertInternalStructureParameters.SourceTaxBaseAmountCur = currencySource.amount_Instance(_baseAmount);
                    insertInternalStructureParameters.SourceTaxBaseAmountCurRaw = _baseAmount;

                    this.insertInternalStructureWithCompanyForLine(insertInternalStructureParameters);
                }

                taxWorkTrans.euroTriangulation        = triangulation;

                //<GMX>

                if (EInvoiceParameters_MX::isElectronicInvoiceEnabled() || EInvoiceCFDIParameters_MX::isElectronicInvoiceEnabled())
                {
                    taxWorkTrans.TaxType_MX = taxTable.TaxType_MX;
                }
                //</GMX>

                // <GEERU>
                if (countryRegion_RU)
                {
                    taxWorkTrans.TaxSourceType_RU = sourceType;
                }
                // </GEERU>

                taxWorkTrans.update(this.ignoreCalculatedSalesTax());

                numberOfInsertedTaxLines++;
                this.updateBaseAmountSum(taxWorkTrans.TaxCode,
                                         taxWorkTrans.TaxDirection,
                                         _baseAmount,
                                         currencySource.amount_Instance(_baseAmount),
                                         taxWorkTrans.SourceCurrencyCode);
            }
        }
        // <GIN>
        // Give priority for standard TaxCodes, afterwards India. We can have Mix of India & Standard codes.
        if (isTaxParametersEnabled)
        {
            // Call 'iff' one India Taxcode is there.
            select firstonly RecId from taxWorkTrans
                where taxWorkTrans.HeadingRecId == headingRecId
                    && taxWorkTrans.HeadingTableId == headingTableId
                    && taxWorkTrans.SourceTableId == this.sourceTableId()
                    && taxWorkTrans.SourceRecId == this.sourceRecId()
                join taxTable
                    where taxTable.TaxCode   == taxWorkTrans.TaxCode
                        && taxTable.TaxType_IN != TaxType_IN::None;
            if (taxWorkTrans.RecId)
            {
                this.insertLineInInternal_IN(_baseAmount,
                                _baseQty,
                                _baseUnit,
                                _itemId,
                                _unitAmount,
                                _dimensionDefault,
                                _operationLedgerDimension,
                                _operationPostingType);
            }
            // Explicit return is added to avoid executing any code that could be added by others after this, in future.
            return;
        }
        // </GIN>

        // <GBR>
        if (!taxValidated)
        {
            throw Exception::Error;
        }
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertInternalStructureWithCompanyForLine</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void insertInternalStructureWithCompanyForLine(TaxInsertInternalStructureParameters _parameters)
    {
        if (_parameters.TaxCalcPrin != TaxCalcPrin::Total &&
            _parameters.TaxLimitBase != TaxLimitBase::InvoiceWithoutVAT &&
            _parameters.TaxLimitBase != TaxLimitBase::InvoiceInclVAT &&
            (!_parameters.TaxTableTaxOnTax.TaxCode ||
            (_parameters.TaxTableTaxOnTax.TaxCode &&
            _parameters.TaxTableTaxOnTax.TaxLimitBase != TaxLimitBase::InvoiceWithoutVAT &&
            _parameters.TaxTableTaxOnTax.TaxLimitBase != TaxLimitBase::InvoiceWithoutVAT)))
        {
            this.insertInternalStructureWithCompany(tmpTax,
                                                    _parameters.TaxWorkTrans.TaxCode,
                                                    _parameters.TaxBaseAmount,
                                                    _parameters.TaxBaseAmountRaw,
                                                    _parameters.TaxWorkTrans.TaxBaseQty,
                                                    _parameters.TaxWorkTrans.TaxDirection,
                                                    _parameters.UnitAmount,
                                                    _parameters.SourceTaxBaseAmountCur,
                                                    _parameters.SourceTaxBaseAmountCurRaw,
                                                    _parameters.TaxWorkTrans.CalculationDate,
                                                    _parameters.TaxWorkTrans.Warning,
                                                    false,
                                                    _parameters.TaxWorkTrans.FiscalValue_BR,
                                                    _parameters.TaxWorkTrans.TaxReceivableLongTerm_BR,
                                                    _parameters.TaxWorkTrans.SourceCurrencyCode,
                                                    _parameters.TaxWorkTrans.Company
                                                    );

            if (EFiscalDocument_BR::shouldUpdateTaxationCode_BR(this))
            {
                TmpTax::findAndUpdateTaxationCode_BR(
                    tmpTax,
                    _parameters.TaxWorkTrans.TaxationCode_BR,
                    _parameters.TaxWorkTrans.TaxCode,
                    _parameters.TaxWorkTrans.TaxDirection,
                    _parameters.TaxWorkTrans.CalculationDate,
                    _parameters.TaxWorkTrans.SourceCurrencyCode,
                    _parameters.TaxWorkTrans.FiscalValue_BR,
                    _parameters.TaxWorkTrans.TaxReceivableLongTerm_BR,
                    _parameters.TaxWorkTrans.Company,
                    true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLineInInternal_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts Line in interanl for Indian.
    /// </summary>
    /// <param name = "_baseAmount">The base amount.</param>
    /// <param name = "_baseQty">The base quantity.</param>
    /// <param name = "_baseUnit">The base unit.</param>
    /// <param name = "_itemId">The item Id.</param>
    /// <param name = "_unitAmount">The unit amount.</param>
    /// <param name = "_dimensionDefault">The default dimension.</param>
    /// <param name = "_operationLedgerDimension">The operation ledger dimension.</param>
    /// <param name = "_operationPostingType">The operation posting type.</param>
    protected void insertLineInInternal_IN(
        TaxBase                _baseAmount,
        TaxBase                _baseQty,
        UnitOfMeasureSymbol    _baseUnit,
        ItemId                 _itemId,
        TaxBase                _unitAmount,
        DimensionDefault       _dimensionDefault,
        LedgerDimensionAccount _operationLedgerDimension,
        LedgerPostingType      _operationPostingType = LedgerPostingType::None)
    {
        TaxTable                    taxTable;
        TaxTable                    taxTableTaxOnTax;
        TaxBase                     baseAmountMST = _baseAmount;
        TaxBase                     unitAmountMST = _unitAmount;
        TaxBase                     unitAmountRecalculated;
        TaxData                     taxData;
        TaxBase                     finalBaseAmount;
        boolean                     isIndianTax;
        Currency                    currencySource;
        Currency                    currencyMST;
        ReturnDispositionCodeId     returnDispositionCodeId;
        boolean                     isTaxesFromJournal = this is TaxCalculationJournal;
        CurrencyCode                accountingCurrencyLoc = Ledger::accountingCurrency(this.companyInfo().RecId);
        TaxBase                     lineBaseAmountMST;
        TaxBase                     lineUnitAmountMST;
        InventTransferLine          inventTransferLine;
        TaxBase                     scrapBaseAmount;

        if (this.taxParameters().CalculatePrinciple   != TaxCalcPrin::Line
            || this.taxParameters().JournalInclTax    == NoYes::Yes
            || this.taxParameters().PurchTaxOnOperations  == NoYes::Yes)
        {
            throw error("@SYS4081919");
        }

        //Total taxcode not supported for India.
        taxCalculateLine  = true;

        if (!this.parmInvoiceCompany_IN())
        {
            this.parmInvoiceCompany_IN(curext());
        }
        changecompany(this.parmInvoiceCompany_IN())
        {
            currencySource = this.getSourceCurrency();
            currencyMST    = Currency::find(accountingCurrencyLoc);
            this.parmBaseQty_IN(_baseQty);// Customs - Qty before unit conversion is done (ParmLine qty)

            if (isTaxesFromJournal)
            {
                if (ledgerJournalTransLoc.RecId == 0)
                {
                    ledgerJournalTransLoc = LedgerJournalTrans::findRecId(this.sourceRecId(), false);
                }
                salesPurchJournalLineLoc = ledgerJournalTransLoc;
            }
            else
            {
                salesPurchJournalLineLoc = Tax::getSalesPurchJournalLine(this.sourceRecId(), this.sourceTableId());
            }
            if (sourceCurrencyCode != currencyMST.CurrencyCode)
            {
                baseAmountMST = CurrencyExchangeHelper::mstAmount(_baseAmount, sourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), 0, 0, false);
                unitAmountMST = CurrencyExchangeHelper::mstAmount(_unitAmount, sourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation));
            }
            else
            {
                baseAmountMST = _baseAmount;
                unitAmountMST = _unitAmount;
            }

            if (isIndiaCountryRegionEnabled
                && inventTransferParmLineLoc.QtyScrapNow)
            {
                lineBaseAmountMST = baseAmountMST;
                lineUnitAmountMST = unitAmountMST;
            }
            while select forupdate taxWorkTrans
                where taxWorkTrans.HeadingRecId == headingRecId
                   && taxWorkTrans.HeadingTableId == headingTableId
                   && taxWorkTrans.SourceTableId == this.sourceTableId()
                   && taxWorkTrans.SourceRecId == this.sourceRecId()
                join taxTable
                    where taxTable.TaxCode     == taxWorkTrans.TaxCode
                        // Loop only for India if a combination of standard & India taxcodes exist.
                        && taxTable.TaxType_IN != TaxType_IN::None
            {
                scrapBaseAmount = 0;
                finalBaseAmount = (taxTable.TaxBase != TaxBaseType::AmountByUnit) ? _baseAmount : 0;
                taxData = TaxData::find(taxWorkTrans.TaxCode,
                                        taxWorkTrans.CalculationDate,
                                        finalBaseAmount);
                if (inventTransferParmLineLoc.QtyScrapNow)
                {
                    baseAmountMST = lineBaseAmountMST;
                    unitAmountMST = lineUnitAmountMST;
                }
                if (taxWorkTrans.IsScrapQtyLine_IN)
                {
                    inventTransferLine = InventTransferLine::findTransIdReceive(inventTransferParmLineLoc.InventTransId);
                    scrapBaseAmount    = inventTransferLine.itemCostPrice_IN() * _baseQty;
                    if (sourceCurrencyCode != currencyMST.CurrencyCode)
                    {
                        baseAmountMST = CurrencyExchangeHelper::mstAmount(this.getBaseAmountPartition_IN(taxWorkTrans, scrapBaseAmount, _baseQty), sourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), 0, 0, false);
                        unitAmountMST = CurrencyExchangeHelper::mstAmount(this.getBaseAmountPartition_IN(taxWorkTrans, _unitAmount, _baseQty), sourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation));
                    }
                    else
                    {
                        baseAmountMST = this.getBaseAmountPartition_IN(taxWorkTrans,scrapBaseAmount,_baseQty);
                        unitAmountMST = this.getBaseAmountPartition_IN(taxWorkTrans,_unitAmount,_baseQty);
                    }
                }
                if (taxTable.TaxType_IN != TaxType_IN::None)
                {
                    isIndianTax = this.updateTmpTaxWorkTrans_IN(taxTable, _dimensionDefault);
                    // Customs check for journals only
                    if (isIndianTax
                        && isTaxesFromJournal
                        && taxTable.TaxType_IN == TaxType_IN::Customs)
                    {
                        if (ledgerJournalTransLoc.RecId
                            && ledgerJournalTransLoc.parmOffsetAccount())
                        {
                            this.validCustomsJournal_IN(ledgerJournalTransLoc);
                        }
                    }
                    // BEGIN
                    if (isIndianTax)
                    {
                        this.setTaxAmountQty_IN(taxTable,
                                                (taxWorkTrans.IsScrapQtyLine_IN) ? inventTransferParmLineLoc.QtyScrapNow :_baseQty,
                                                _baseUnit,
                                                _itemId,
                                                currencyMST,
                                                baseAmountMST,
                                                taxWorkTrans,
                                                this.getBaseAmountPartition_IN(taxWorkTrans, (taxWorkTrans.IsScrapQtyLine_IN) ? scrapBaseAmount :_baseAmount, _baseQty));

                        if (taxWorkTrans.ExemptTax == NoYes::No)
                        {
                            if (taxTable.TaxBase == TaxBaseType::AmountByUnit
                                && !taxTable.TaxPackagingTax)
                            {
                                unitAmountRecalculated = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_itemId,
                                                                                InventTransOrigin::findByInventTransId(taxWorkTrans.InventTransId).ItemInventDimId,
                                                                                unitAmountMST,
                                                                                _baseUnit,
                                                                                taxTable.TaxUnit,
                                                                                NoYes::Yes,
                                                                                NoYes::No);
                            }
                            if (taxTable.TaxType_IN != TaxType_IN::None)
                            {
                                switch (taxModuleType)
                                {
                                    case TaxModuleType::Sales,
                                        TaxModuleType::SalesInvoice:
                                        returnDispositionCodeId = SalesLine::findRecId(salesPurchJournalLineLoc.SourceRecId).ReturnDispositionCodeId;
                                        break;

                                    case TaxModuleType::Purch,
                                        TaxModuleType::PurchInvoice:
                                        returnDispositionCodeId = PurchLine::findRecId(salesPurchJournalLineLoc.SourceRecId).ReturnDispositionCodeId;
                                        break;
                                }
                                if ((taxTable.TaxType_IN == TaxType_IN::Excise
                                     || taxTable.TaxType_IN == TaxType_IN::VAT)
                                     && ReturnDispositionCode::find(returnDispositionCodeId).DispositionAction == DispositionAction::ReturnToCust)
                                {
                                    if (taxTable.TaxLimitBase    != TaxLimitBase::InvoiceWithoutVAT
                                        && taxTable.TaxLimitBase != TaxLimitBase::InvoiceInclVAT
                                        && (!taxTableTaxOnTax.TaxCode
                                        || (taxTableTaxOnTax.TaxCode
                                        && taxTableTaxOnTax.TaxLimitBase != TaxLimitBase::InvoiceWithoutVAT
                                        && taxTableTaxOnTax.TaxLimitBase != TaxLimitBase::InvoiceWithoutVAT)))
                                    {
                                        this.insertInternalStructureWithCompany(tmpTax,
                                                                                taxWorkTrans.TaxCode,
                                                                                currencyMST.amount_Instance(baseAmountMST),
                                                                                baseAmountMST,
                                                                                taxWorkTrans.TaxBaseQty,
                                                                                taxWorkTrans.TaxDirection,
                                                                                unitAmountRecalculated,
                                                                                currencySource.amount_Instance(this.getBaseAmountPartition_IN(taxWorkTrans, (taxWorkTrans.IsScrapQtyLine_IN) ? scrapBaseAmount :_baseAmount, _baseQty)),
                                                                                this.getBaseAmountPartition_IN(taxWorkTrans, (taxWorkTrans.IsScrapQtyLine_IN) ? scrapBaseAmount :_baseAmount, _baseQty),
                                                                                taxWorkTrans.CalculationDate,
                                                                                taxWorkTrans.Warning,
                                                                                false,
                                                                                TaxFiscalValue_BR::Blank,
                                                                                false,
                                                                                taxWorkTrans.SourceCurrencyCode,
                                                                                taxWorkTrans.Company);
                                    }
                                }
                                // India works only when Taxcode origin is 'Percentage of net amount' OR 'Amount per unit'
                                // Also 'Marginal base' functionality is not applicable for India because of formula designer, hence no check is done here.
                                // This will work for all India taxes. (But Excise/Vat-'Return order' should handle Disposition code dependency explicitly)
                                this.insertInternalStructureWithCompany(
                                                        tmpTax,
                                                        taxWorkTrans.TaxCode,
                                                        currencyMST.amount_Instance(baseAmountMST),
                                                        baseAmountMST,
                                                        taxWorkTrans.TaxBaseQty,
                                                        taxWorkTrans.TaxDirection,
                                                        unitAmountRecalculated,
                                                        currencySource.amount_Instance(this.getBaseAmountPartition_IN(taxWorkTrans, (taxWorkTrans.IsScrapQtyLine_IN) ? scrapBaseAmount :_baseAmount, _baseQty)),
                                                        this.getBaseAmountPartition_IN(taxWorkTrans, (taxWorkTrans.IsScrapQtyLine_IN) ? scrapBaseAmount :_baseAmount, _baseQty),
                                                        taxWorkTrans.CalculationDate,
                                                        taxWorkTrans.Warning,
                                                        false,
                                                        TaxFiscalValue_BR::Blank,
                                                        false,
                                                        taxWorkTrans.SourceCurrencyCode);
                            }
                        }
                        taxWorkTrans.OperationLedgerDimension   = _operationLedgerDimension;
                        taxWorkTrans.OperationPostingType       = _operationPostingType;

                        taxWorkTrans.update();

                        this.updateBaseAmountSum(taxWorkTrans.TaxCode,
                                                 taxWorkTrans.TaxDirection,
                                                 this.getBaseAmountPartition_IN(taxWorkTrans, (taxWorkTrans.IsScrapQtyLine_IN) ? scrapBaseAmount :_baseAmount, _baseQty),
                                                 currencySource.amount_Instance(this.getBaseAmountPartition_IN(taxWorkTrans, (taxWorkTrans.IsScrapQtyLine_IN) ? scrapBaseAmount :_baseAmount, _baseQty)),
                                                 taxWorkTrans.SourceCurrencyCode);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTaxTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used insert the data in the <c>TaxTrans_IN</c> table.
    /// </summary>
    /// <param name="_taxTrans">
    /// A buffer of <c>TaxTrans</c> table.
    /// </param>
    /// <param name="_salesPurchJournalLine">
    /// A buffer of <c>SalesPurchJournalLine</c> map.
    /// </param>
    /// <param name="_ledgerDimension">
    /// A buffer of <c>LedgerDimensionAccount</c> table.
    /// </param>
    /// <param name="_operatingDimension">
    /// A buffer of <c>LedgerDimensionDefaultAccount</c> table.
    /// </param>
    public void insertTaxTrans_IN(
        TaxTrans                        _taxTrans,
        SalesPurchJournalLine           _salesPurchJournalLine = null,
        LedgerDimensionAccount          _ledgerDimension = 0,
        LedgerDimensionDefaultAccount   _operatingDimension = 0)
    {
        TaxTable                        taxTable;
        TaxTrans_IN                     taxTrans;
        TaxLedgerAccounts_IN            taxLedger;
        TaxOnItem                       taxOnItem;
        VendTable                       vendTable;
        CustTable                       custTable;
        TaxGroupData                    taxGroupData;
        CustInvoiceTable                custInvoiceTable;
        PurchLine                       purchLine;
        SalesLine                       salesLine;
        PurchTable                      purchTable;
        SalesTable                      salesTable;
        Amount                          miscCharge;
        AmountCur                       transactionAmount;
        UnitIDBase                      unit;
        ExciseRecordType_IN             exciseRecordType;
        RefRecId                        exciseTariffCodes;

        VendInvoiceJour                 vendInvoiceJour;
        VendInvoiceTrans                vendInvoiceTrans;
        VendInvoiceTrans_IN             vendInvoiceTransIN;
        CustInvoiceJour                 custInvoiceJour;
        CustInvoiceTrans                custInvoiceTrans;
        PurchParmTable                  purchParmTable;
        ConsignmentNum_IN               consignmentNum;
        GTAServiceCategory_IN           gtaServiceCategory;
        RefRecId                        serviceCodeTable;

        TransDate                       billOfEntryDate;
        RefRecId                        customsBillOfEntryNumber;
        RefRecId                        customsTariffCode;
        CustomsShippingBillJour_IN      customsShippingBillJour;
        CustomsDate_IN                  customsShippingBillDate;
        RefRecId                        customsShippingBillNumber;
        RefRecId                        customsImporterInvoiceNumber;
        RefRecId                        tmpcustomsShippingBillNumber;
        Direction_IN                    direction;

        CustomsImportAssessableValue_IN customsImportAssessableValue;
        AmountCur                       customsCIFAmount;
        AmountCur                       customsFOBAmount;
        AmountCur                       deferredExciseAmount;
        Percent                         customsLandingChargesPct;
        CustomsAmount_IN                customsLandingChargesPctAmt;
        TaxType_IN                      taxType;
        VendPackingSlipTrans            vendPackingSlipTrans;
        CustPackingSlipTrans            custPackingSlipTrans;
        InventDim                       inventDim;
        CompanyInfo                     companyInfoLoc;
        AssetTable                      assetTable;
        AssetBook                       assetBook;
        CustomsQty_IN                   billOfEntryQty;
        CustomsVendBOETrans_IN          customsVendBOETrans;
        RecId                           recId;
        CustInvoiceJour                 custInvoiceJourLoc;
        InventTransferLine              inventTransferLine;
        InventTransferLine_IN           inventTransferLineIN;
        InventTransferTable             inventTransferTable;
        CustomsVendBOESubTrans_IN       customsVendBOESubTrans;
        CustomsVendBOETrans_IN          customsVendBOETransLoc;
        TransDate                       transDateLoc;
        TaxLedgerAccountSetup_IN        taxLedgerAccountSetup;
        TaxInformation_IN               custTaxInformation;
        TaxInformation_IN               vendTaxInformation;
        TaxInformation_IN               companyTaxInformation;

        LedgerJournalTrans              ledgerJournalTrans;
        VendInvoiceInfoLine             vendInvoiceInfoLine;
        VendInvoiceInfoTable            vendInvoiceInfoTable;
        LedgerDimensionAccount          ledgerDimension;
        LedgerDimensionDefaultAccount   defaultAccount;
        Num                             numSequence;
        TaxInformationVendTable_IN      taxInformationVendTableLoc;
        SalesPurchJournalLineExtension_IN salesPurchJournalLineExtension_IN;
        CustomsVendInvoiceBOETransLink_IN customsVendInvoiceBOETransLinkIN;
        LedgerJournalTransTaxExtensionIN  ledgerJournalTransTaxExtensionIN;

        TransTaxInformation             transTaxInformation;
        TransTaxInformation             toTransTaxInformation;

        transTaxInformation = transTaxInformationHelper.getTransTaxInformation(_salesPurchJournalLine.SourceTableId, _salesPurchJournalLine.SourceRecId);

        taxTable                = TaxTable::find(_taxTrans.TaxCode);
        taxType                 = taxTable.TaxType_IN;
        taxOnItem               = TaxOnItem::find(_taxTrans.TaxItemGroup, _taxTrans.TaxCode);
        taxGroupData            = TaxGroupData::find(_taxTrans.TaxGroup, _taxTrans.TaxCode);
        taxTrans.TaxDirection   = _taxTrans.TaxDirection;

        ledgerDimension  = TaxTransGeneralJournalAccountEntry::getTaxLedgerDimensionForTaxTrans(_taxTrans.RecId);

        if (!ledgerDimension && _ledgerDimension)
        {
            ledgerDimension = _ledgerDimension;
        }
        else if (!ledgerDimension && !_ledgerDimension)
        {
            ledgerDimension = this.tmpTaxWorkTrans().LedgerDimension;
        }

        defaultAccount  = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(ledgerDimension);

        if (taxType == TaxType_IN::ServiceTax)
        {
            select firstonly AccountType from taxLedger
                where taxLedger.LedgerDimension   == defaultAccount
                    join RecId from taxLedgerAccountSetup
                        where taxLedgerAccountSetup.TaxLedgerAccountGroup == taxTable.TaxLedgerAccountGroup_IN
                           && taxLedger.TaxLedgerAccountSetup == taxLedgerAccountSetup.RecId;
        }

        if (_salesPurchJournalLine.SourceTableId == tableNum(PurchLine))
        {
            vendInvoiceJour     = this.getVendInvoiceJour_IN(_taxTrans);
            vendInvoiceTrans    = VendInvoiceTrans::findVendInvoiceTrans(vendInvoiceJour.PurchId,
                                                                         vendInvoiceJour.InvoiceId,
                                                                         vendInvoiceJour.InvoiceDate,
                                                                         vendInvoiceJour.NumberSequenceGroup,
                                                                         vendInvoiceJour.InternalInvoiceId,
                                                                         _taxTrans.InventTransId);
            vendInvoiceTransIN = vendInvoiceTrans.VendInvoiceTrans_IN();
        }
        else if (_salesPurchJournalLine.SourceTableId == tableNum(SalesLine)
                 || _salesPurchJournalLine.SourceTableId == tableNum(CustInvoiceTrans)
                 || _salesPurchJournalLine.SourceTableId == tableNum(CustInvoiceLine))
        {
            custInvoiceJour     = CustInvoiceJour::findFromTaxTrans(_taxTrans.Voucher, _taxTrans.TransDate);
            if (_salesPurchJournalLine.SourceTableId == tableNum(CustInvoiceTrans))
            {
                custInvoiceTrans = _salesPurchJournalLine;
            }
            else if (_salesPurchJournalLine.SourceTableId == tableNum(CustInvoiceLine))
            {
                custInvoiceTrans = CustInvoiceTrans::findBySourceDocumentLine(CustInvoiceLine::find(_salesPurchJournalLine.SourceRecId).SourceDocumentLine);
            }
            else
            {
                custInvoiceTrans = CustInvoiceTrans::findCustInvoiceTrans(custInvoiceJour.SalesId,
                                                                          custInvoiceJour.InvoiceId,
                                                                          custInvoiceJour.InvoiceDate,
                                                                          custInvoiceJour.NumberSequenceGroup,
                                                                          _taxTrans.InventTransId);
            }
        }
        else if (_salesPurchJournalLine.SourceTableId == tableNum(LedgerJournalTrans))
        {
            ledgerJournalTrans   = LedgerJournalTrans::findRecId(_salesPurchJournalLine.SourceRecId, false);
            ledgerJournalTransTaxExtensionIN = ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
        }

        if (_taxTrans.InventTransId)
        {
            inventDim = InventDim::find(InventTrans::findTransId(_taxTrans.InventTransId).InventDimId);
            if (inventDim)
            {
                taxTrans.InventDimFieldsMap::initAllDimensionsFrom(inventDim);
            }
        }

        if (_taxTrans.Source == TaxModuleType::Voucher)
        {
            recId                        = ledgerJournalTrans.RecId;
            taxTrans.JournalType         = ledgerJournalTrans.ledgerJournalTable().JournalType;
            taxTrans.LineNum             = ledgerJournalTrans.LineNum;

            if ( ledgerJournalTrans.orig().AccountType == LedgerJournalACType::Vend)
            {
                vendTable                = VendTable::find(ledgerJournalTrans.orig().parmAccount());
                vendTaxInformation       = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(vendTable.Party));
                taxTrans.Vendor          = ledgerJournalTrans.orig().parmAccount();
                taxTrans.CustVendRegistrationNumber = vendTaxInformation.getTaxRegistrationNumbersTable(taxType, transTaxInformation.ExciseType).RecId;
                taxTrans.ssiValidityDate = vendTable.getTaxInformationVendTable_IN().ssiValidityDate;

                if (transTaxInformation.ExciseType != ExciseType_IN::None)
                {
                    if (transTaxInformation.ExciseType == ExciseType_IN::Manufacturer)
                    {
                        taxTrans.CustVendRegistrationNumber = vendTaxInformation.ManECCRegistrationNumberTable;
                    }
                    else
                    {
                        taxTrans.CustVendRegistrationNumber = vendTaxInformation.TraderECCRegistrationNumberTable;
                    }
                }
            }
            else if (ledgerJournalTrans.orig().OffsetAccountType == LedgerJournalACType::Vend)
            {
                vendTable                = VendTable::find(ledgerJournalTrans.orig().parmOffsetAccount());
                vendTaxInformation       = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(vendTable.Party));
                taxInformationVendTableLoc = vendTable.getTaxInformationVendTable_IN();
                taxTrans.Vendor          = ledgerJournalTrans.orig().parmOffsetAccount();
                taxTrans.CustVendRegistrationNumber = vendTaxInformation.getTaxRegistrationNumbersTable(taxType, transTaxInformation.ExciseType).RecId;
                taxTrans.ssiValidityDate = taxInformationVendTableLoc.ssiValidityDate;
            }
            if (ledgerJournalTrans.orig().AccountType == LedgerJournalACType::Cust)
            {
                custTable                  = CustTable::find(ledgerJournalTrans.orig().parmAccount());
                custTaxInformation         = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(custTable.Party));
                taxTrans.Customer          = ledgerJournalTrans.orig().parmAccount();
                taxTrans.CustVendRegistrationNumber = custTaxInformation.getTaxRegistrationNumbersTable(taxType, transTaxInformation.ExciseType).RecId;
            }
            else if (ledgerJournalTrans.orig().OffsetAccountType == LedgerJournalACType::Cust)
            {
                custTable                  = CustTable::find(ledgerJournalTrans.orig().parmOffsetAccount());
                custTaxInformation         = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(custTable.Party));
                taxTrans.Customer          = ledgerJournalTrans.orig().parmOffsetAccount();
                taxTrans.CustVendRegistrationNumber = custTaxInformation.getTaxRegistrationNumbersTable(taxType, transTaxInformation.ExciseType).RecId;
            }

            transactionAmount              =  (ledgerJournalTrans.AmountCurCredit ? ledgerJournalTrans.AmountCurCredit : ledgerJournalTrans.AmountCurDebit);

            assessableValue                = ledgerJournalTransTaxExtensionIN.AssessableValueTransactionCurrency;
            if (taxType == TaxType_IN::Excise)
            {
                assetTable                          = ledgerJournalTrans.findAssetTable();
                assetBook                           = assetTable.book();
                exciseRecordType                    = transTaxInformation.ExciseRecordType;
                exciseTariffCodes                   = transTaxInformation.ExciseTariffCodes;
                taxTrans.CreditAmount               = ledgerJournalTrans.AmountCurCredit;
                taxTrans.DebitAmount                = ledgerJournalTrans.AmountCurDebit;
                taxTrans.FixedAssetSerialNumber     = assetTable.SerialNum;
                taxTrans.Make                       = assetTable.Make;
                taxTrans.Model                      = assetTable.Model;
                taxTrans.PlacedInService            = assetBook.UsedFromDate;
                taxTrans.AssetLocation              = assetTable.Location;
                taxTrans.JournalInvoice             = ledgerJournalTrans.Invoice;
                taxTrans.JournalInvoiceAmount       = ledgerJournalTrans.amount();
                taxTrans.JournalInvoiceDate         = ledgerJournalTrans.TransDate;
                taxTrans.JournalNum                 = ledgerJournalTrans.JournalNum;
                taxTrans.CompanyRegistrationNumber  = transTaxInformation.ExciseECCRegistrationNumber;
                taxTrans.getExciseLedgerAccounts(exciseRecordType, _taxTrans, taxTable.TaxLedgerAccountGroup_IN, DirectSettlement_IN::None, exciseDeferredAccount, 0);
            }
            if (taxType == TaxType_IN::ServiceTax)
            {
                taxTrans.JournalNum                 = ledgerJournalTrans.JournalNum;
                consignmentNum                      = transTaxInformation.ServiceTaxConsignmentNoteNum;
                gtaServiceCategory                  = transTaxInformation.ServiceTaxGTAServiceCategory;
                serviceCodeTable                    = transTaxInformation.ServiceCode;
                taxTrans.CustVendRegistrationNumber = vendTaxInformation.stcRegistrationNumberTable;
                taxTrans.CompanyRegistrationNumber  = transTaxInformation.ServiceTaxRegistrationNumber;

                if (taxLedger.AccountType == TaxAccountType_IN::ServiceTaxInterimRecoverableAccount)
                {
                    taxTrans.InterimRecoverableLedgerDimension  = defaultAccount;
                    // for indirect tax inquiry
                    taxTrans.RecoverableLedgerDimension  = defaultAccount;
                }
                if (taxLedger.AccountType == TaxAccountType_IN::ServiceTaxRecoverableAccount)
                {
                    taxTrans.ServiceRecoverableLedgerDimension  = defaultAccount;
                    // for indirect tax inquiry
                    taxTrans.RecoverableLedgerDimension  = defaultAccount;
                }
                if (taxLedger.AccountType == TaxAccountType_IN::ServiceTaxInterimPayableAccount)
                {
                    taxTrans.InterimPayableLedgerDimension  = defaultAccount;
                    // for indirect tax inquiry
                    taxTrans.PayableLedgerDimension  = defaultAccount;
                }
                if (taxLedger.AccountType == TaxAccountType_IN::ServiceTaxPayableAccount)
                {
                    taxTrans.ServicePayableLedgerDimension  =  defaultAccount;
                    // for indirect tax inquiry
                    taxTrans.PayableLedgerDimension  = defaultAccount;
                }
                if (taxLedger.AccountType == TaxAccountType_IN::ServiceTaxExpenseAccount)
                {
                    taxTrans.ExpenseLedgerDimension  =  defaultAccount;
                }
            }
            if (taxType == TaxType_IN::Customs)
            {
                customsTariffCode                   = transTaxInformation.CustomsTariffCode;
                direction                           = transTaxInformation.CustomsTariffDirection;
                taxTrans.MaximumRetailPrice         = ledgerJournalTransTaxExtensionIN.MaximumRetailPrice;
                taxTrans.TotalMaximumRetailPrice    = ledgerJournalTransTaxExtensionIN.MaximumRetailPrice;
            }
        }
        else
        {
            recId  = _taxTrans.RecId;
            if (_salesPurchJournalLine.TableId != tableNum(PurchLine)
                && _salesPurchJournalLine.TableId != tableNum(ProjItemTrans)
                && _taxTrans.Source != TaxModuleType::Project)
            {
                taxTrans.LineNum  = _salesPurchJournalLine.LineNum;
            }
            if (_taxTrans.Source ==  TaxModuleType::Purch)
            {
                vendTable               = VendTable::find(PurchLine::findInventTransId(_taxTrans.InventTransId).VendAccount);
                vendTaxInformation      = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(vendTable.Party));
                purchLine               = PurchLine::findInventTransId(_taxTrans.InventTransId);
                purchTable              = purchLine.purchTable();
                transactionAmount       = vendInvoiceTrans.LineAmount + vendInvoiceTrans.LineAmountTax;
                unit                    = vendInvoiceTrans.PurchUnit;
                assessableValue         = vendInvoiceTrans.AssessableValue_IN;
                assessableValueAccountingCurrency   = vendInvoiceTransIN.AssessableValueAccountingCurrency;

                miscCharge              = MarkupTrans::findSumValue_IN(vendInvoiceTrans.TableId, vendInvoiceTrans.RecId, '');

                if (taxType == TaxType_IN::Excise)
                {
                    exciseRecordType                        = transTaxInformation.ExciseRecordType;
                    exciseTariffCodes                       = transTaxInformation.ExciseTariffCodes;
                    taxTrans.ssiValidityDate                = vendTable.getTaxInformationVendTable_IN().ssiValidityDate;
                    taxTrans.Consignment                    = transTaxInformation.ExciseConsignment;
                    taxTrans.DirectSettlement               = transTaxInformation.ExciseDirectSettlement;
                    taxTrans.PurchaseOrderQuantity          = purchLine.PurchQty;
                    taxTrans.CustVendRegistrationNumber     = vendTaxInformation.getTaxRegistrationNumbersTable(taxType, transTaxInformation.ExciseType).RecId;
                    taxTrans.CompanyRegistrationNumber      = transTaxInformation.ExciseECCRegistrationNumber;
                    taxTrans.CommissionarateVendorMaster    = vendTaxInformation.Commissionarate;
                    taxTrans.DivisionVendorMaster           = vendTaxInformation.Division;
                    taxTrans.VendorAddress                  = LogisticsPostalAddress::findByLocation(vendTaxInformation.RegistrationLocation).Address;
                    taxTrans.RangeVendorMaster              = vendTaxInformation.Range;
                    taxTrans.Vendor                         = vendTable.AccountNum;
                    taxTrans.SourceTaxAmountCur             = _taxTrans.SourceTaxAmountCur;

                    if (transTaxInformation.ExciseDirectSettlement == DirectSettlement_IN::PLA)
                    {
                        taxTrans.plaAmount          =  taxTrans.PostedTaxAmout - deferredExciseAmount;
                        taxTrans.plaLedgerDimension = defaultAccount;
                    }

                    if (_taxTrans.taxTrans_W().ApplyExcise_IN)
                    {
                        taxTrans.getExciseLedgerAccounts(exciseRecordType, _taxTrans, taxTable.TaxLedgerAccountGroup_IN, taxTrans.DirectSettlement,0,exciseDeferredAccount);
                    }
                    else
                    {
                        taxTrans.getExciseLedgerAccounts(exciseRecordType, _taxTrans, taxTable.TaxLedgerAccountGroup_IN, taxTrans.DirectSettlement,0,tmpTaxWorkTransLoc.LedgerDimension_IN);
                    }
                }
                if (taxType == TaxType_IN::ServiceTax)
                {
                    gtaServiceCategory = transTaxInformation.ServiceTaxGTAServiceCategory;
                    serviceCodeTable   = transTaxInformation.ServiceCode;

                    if (taxLedger.AccountType == TaxAccountType_IN::ServiceTaxInterimRecoverableAccount)
                    {
                        taxTrans.InterimRecoverableLedgerDimension = defaultAccount;
                        // for indirect tax inquiry
                        taxTrans.RecoverableLedgerDimension  = defaultAccount;
                    }
                    if (taxLedger.AccountType == TaxAccountType_IN::ServiceTaxRecoverableAccount)
                    {
                        taxTrans.ServiceRecoverableLedgerDimension  = defaultAccount;
                        // for indirect tax inquiry
                        taxTrans.RecoverableLedgerDimension  = defaultAccount;
                    }
                    if (taxLedger.AccountType == TaxAccountType_IN::ServiceTaxInterimPayableAccount)
                    {
                        taxTrans.InterimPayableLedgerDimension  = defaultAccount;
                        // for indirect tax inquiry
                        taxTrans.PayableLedgerDimension  = defaultAccount;
                    }
                    if (taxLedger.AccountType == TaxAccountType_IN::ServiceTaxPayableAccount)
                    {
                        taxTrans.ServicePayableLedgerDimension  =  defaultAccount;
                        // for indirect tax inquiry
                        taxTrans.PayableLedgerDimension  = defaultAccount;
                    }
                    if (taxLedger.AccountType == TaxAccountType_IN::ServiceTaxExpenseAccount)
                    {
                        taxTrans.ExpenseLedgerDimension  =  defaultAccount;
                    }

                    taxTrans.CustVendRegistrationNumber = vendTaxInformation.stcRegistrationNumberTable;
                    taxTrans.CompanyRegistrationNumber  = transTaxInformation.ServiceTaxRegistrationNumber;
                }
                if (taxType == TaxType_IN::Customs)
                {
                    select firstonly CustomsVendBOETrans_IN from customsVendInvoiceBOETransLinkIN
                        where customsVendInvoiceBOETransLinkIN.VendInvoiceTrans == vendInvoiceTrans.RecId;

                    customsVendBOETrans = CustomsVendBOETrans_IN::find(customsVendInvoiceBOETransLinkIN.CustomsVendBOETrans_IN);

                    billOfEntryDate              = customsVendBOETrans.BillOfEntryDate;
                    customsBillOfEntryNumber     = customsVendBOETrans.CustomsBillOfEntryNumberTable;
                    customsImporterInvoiceNumber = customsVendBOETrans.CustomsImportInvoiceNumberTable;
                    billOfEntryQty               = customsVendBOETrans.BillOfEntryQty;

                    customsTariffCode                   = transTaxInformation.CustomsTariffCode;
                    direction                           = Direction_IN::Import;
                    customsImportAssessableValue        = CustomsImportAssessableValue_IN::findInventTransId(_taxTrans.InventTransId);
                    if (customsImportAssessableValue.RecId)
                    {
                        customsLandingChargesPct        = customsImportAssessableValue.LandingChargesPct;
                    }
                    else
                    {
                        customsLandingChargesPct        = VendParameters::find().CustomsLandingChargesPct_IN;
                    }
                    customsCIFAmount                    = transactionAmount + miscCharge;
                    customsFOBAmount                    = transactionAmount;
                    customsLandingChargesPctAmt         = customsCIFAmount * (customsLandingChargesPct /100);
                    taxTrans.ApplyExcise                = TaxComponentTable_IN::find(taxTable.TaxComponentTable_IN).ApplyExcise;
                }

                select RecId from purchLine
                    where purchLine.InventTransId == taxWorkTrans.InventTransId
                        join ParmId, TableRefId from vendInvoiceInfoLine
                        where vendInvoiceInfoLine.PurchLineRecId == purchLine.RecId
                            && vendInvoiceInfoLine.ParmId != ''
                            join VendInvoiceGroup from vendInvoiceInfoTable
                                where vendInvoiceInfoTable.ParmId     == vendInvoiceInfoLine.ParmId
                                    && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLine.TableRefId;
                taxTrans.VendInvoiceInternalDefaultGroup = vendInvoiceInfoTable.VendInvoiceGroup;
            }
            else if (_taxTrans.Source   ==  TaxModuleType::Sales)
            {
                custTable               = CustTable::find(SalesLine::findInventTransId(_taxTrans.InventTransId).CustAccount);
                custTaxInformation      = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(custTable.Party));
                salesLine               = SalesLine::findInventTransId(_taxTrans.InventTransId);
                salesTable              = salesLine.salesTable();

                if (taxType == TaxType_IN::Customs)
                {
                    select firstonly customsShippingBillJour
                        where customsShippingBillJour.SalesId == _salesPurchJournalLine.SourceId;

                    select firstonly custInvoiceJourLoc
                        where custInvoiceJourLoc.SalesId   == customsShippingBillJour.SalesId &&
                              custInvoiceJourLoc.InvoiceId == customsShippingBillJour.InvoiceId;

                    custInvoiceTrans  = this.getCustInvoiceTransLine_IN(_taxTrans, custInvoiceJourLoc);
                }

                transactionAmount       = custInvoiceTrans.LineAmount + custInvoiceTrans.LineAmountTax;
                unit                    = custInvoiceTrans.SalesUnit;
                assessableValue         = custInvoiceTrans.custInvoiceTrans_IN().AssessableValue_IN;

                miscCharge              = MarkupTrans::findSumValue_IN(custInvoiceTrans.TableId, custInvoiceTrans.RecId, '');

                if (taxType == TaxType_IN::Excise)
                {
                    exciseRecordType                        = transTaxInformation.ExciseRecordType;
                    exciseTariffCodes                       = transTaxInformation.ExciseTariffCodes;
                    taxTrans.Consignment                    = transTaxInformation.ExciseConsignment;
                    taxTrans.DirectSettlement               = transTaxInformation.ExciseDirectSettlement;
                    taxTrans.CustVendRegistrationNumber     = custTaxInformation.getTaxRegistrationNumbersTable(taxType, transTaxInformation.ExciseType).RecId;
                    custTaxInformation      = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(custTable.Party));
                    taxTrans.CommissionarateCustomerMaster    = custTaxInformation.Commissionarate;
                    taxTrans.DivisionCustomerMaster           = custTaxInformation.Division;
                    taxTrans.CustomerAddress                  = LogisticsPostalAddress::findByLocation(custTaxInformation.RegistrationLocation).Address;
                    taxTrans.RangeCustomerMaster              = custTaxInformation.Range;
                    taxTrans.Customer                       = custTable.AccountNum;
                    taxTrans.SalesOrderDate                 = DateTimeUtil::date(salesLine.CreatedDateTime);
                    taxTrans.SalesOrderQty                  = salesLine.SalesQty;
                    taxTrans.SourceTaxAmountCur             = _taxTrans.SourceTaxAmountCur;

                    taxTrans.getExciseLedgerAccounts(exciseRecordType, _taxTrans, taxTable.TaxLedgerAccountGroup_IN, taxTrans.DirectSettlement, 0, 0);

                    if (transTaxInformation.ExciseDirectSettlement == DirectSettlement_IN::PLA)
                    {
                        taxTrans.plaAmount          =  taxTrans.PostedTaxAmout - deferredExciseAmount;
                        taxTrans.plaLedgerDimension = defaultAccount;
                    }
                }
                if (taxType == TaxType_IN::ServiceTax)
                {
                    serviceCodeTable                        = transTaxInformation.ServiceCode;

                    if (taxLedger.AccountType == TaxAccountType_IN::ServiceTaxInterimPayableAccount)
                    {
                        taxTrans.InterimPayableLedgerDimension  = defaultAccount;
                    }
                    if (taxLedger.AccountType == TaxAccountType_IN::ServiceTaxPayableAccount)
                    {
                        taxTrans.ServicePayableLedgerDimension  =  defaultAccount;
                    }
                    // for indirect tax inquiry
                    taxTrans.PayableLedgerDimension         = defaultAccount;
                    taxTrans.CustVendRegistrationNumber     = custTaxInformation.stcRegistrationNumberTable;
                    taxTrans.CompanyRegistrationNumber      = transTaxInformation.ServiceTaxRegistrationNumber;
                }
                if (taxType == TaxType_IN::Customs)
                {
                    customsTariffCode           = transTaxInformation.CustomsTariffCode;
                    customsShippingBillDate     = customsShippingBillJour.ShippingBillDate;
                    customsShippingBillNumber   = customsShippingBillJour.CustomsShippingBillNumberTable;

                    select count(RecId) from customsShippingBillJour
                        where customsShippingBillJour.SalesId == _salesPurchJournalLine.SourceId;

                    if (customsShippingBillJour.RecId > 1)
                    {
                        select firstonly customsShippingBillJour
                            where customsShippingBillJour.SalesId == _salesPurchJournalLine.SourceId;

                        tmpcustomsShippingBillNumber = customsShippingBillJour.CustomsShippingBillNumberTable;

                        while select CustomsShippingBillNumberTable from customsShippingBillJour
                            where customsShippingBillJour.SalesId == _salesPurchJournalLine.SourceId
                        {
                            if (customsShippingBillJour.CustomsShippingBillNumberTable != tmpcustomsShippingBillNumber)
                            {
                                while select forupdate taxTrans
                                    where taxTrans.SourceRecId               == _salesPurchJournalLine.SourceRecId &&
                                          taxTrans.CustomsShippingBillNumberTable != 0
                                {
                                    ttsbegin;
                                    taxTrans.CustomsShippingBillDate   = dateNull();
                                    taxTrans.CustomsShippingBillNumberTable = 0;
                                    taxTrans.update();
                                    ttscommit;
                                }
                                customsShippingBillDate   = dateNull();
                                customsShippingBillNumber   = 0;
                            }
                        }
                    }
                    direction                       = Direction_IN::Export;
                    customsCIFAmount                = transactionAmount;
                    customsFOBAmount                = transactionAmount - miscCharge;
                }
            }
            else if (_taxTrans.Source  ==  TaxModuleType::FreeTxtInvoice)
            {
                select firstonly custInvoiceTable
                    where custInvoiceTable.InvoiceId == custInvoiceJour.InvoiceId;

                taxTrans.InvoiceAccount    = custInvoiceTable.InvoiceAccount;
                taxTrans.InvoiceAmount     = custInvoiceJour.InvoiceAmount;
                taxTrans.Customer          = custInvoiceJour.OrderAccount;
                transactionAmount          = custInvoiceTrans.LineAmount + custInvoiceTrans.LineAmountTax;
                taxTrans.InvoiceId         = custInvoiceJour.InvoiceId;
                taxTrans.TransTableId      = custInvoiceTrans.TableId;
                taxTrans.TransRecId        = custInvoiceTrans.RecId;
                if (custInvoiceTable)
                {
                    custTable               = CustTable::find(custInvoiceTable.InvoiceAccount);
                    miscCharge              = MarkupTrans::findSumValue_IN(custInvoiceTrans.TableId, custInvoiceTrans.RecId, '');
                    custTaxInformation      = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(custTable.Party));
                }
                if (taxType == TaxType_IN::Excise)
                {
                    exciseRecordType            = transTaxInformation.ExciseRecordType;
                    exciseTariffCodes           = transTaxInformation.ExciseTariffCodes;
                    taxTrans.CustVendRegistrationNumber = custTaxInformation.getTaxRegistrationNumbersTable(taxType, transTaxInformation.ExciseType).RecId;
                    taxTrans.CompanyRegistrationNumber  = transTaxInformation.ExciseECCRegistrationNumber;
                    taxTrans.getExciseLedgerAccounts(exciseRecordType, _taxTrans, taxTable.TaxLedgerAccountGroup_IN, DirectSettlement_IN::None, 0, 0);
                }
                if (taxType == TaxType_IN::Customs)
                {
                    customsTariffCode           = transTaxInformation.CustomsTariffCode;
                    direction                   = Direction_IN::Export;
                }
                if (taxType == TaxType_IN::ServiceTax)
                {
                    serviceCodeTable                = transTaxInformation.ServiceCode;
                    taxTrans.CustVendRegistrationNumber = custTaxInformation.getTaxRegistrationNumbersTable(taxType).RecId;
                    taxTrans.CompanyRegistrationNumber  = transTaxInformation.ServiceTaxRegistrationNumber;
                    if (taxLedger.AccountType == TaxAccountType_IN::ServiceTaxInterimPayableAccount)
                    {
                        taxTrans.InterimPayableLedgerDimension  = defaultAccount;
                    }
                    if (taxLedger.AccountType == TaxAccountType_IN::ServiceTaxPayableAccount)
                    {
                        taxTrans.ServicePayableLedgerDimension  =  defaultAccount;
                    }
                    // for indirect tax inquiry
                    taxTrans.PayableLedgerDimension  = defaultAccount;
                }
            }
        }

        if (_taxTrans.Source  ==  TaxModuleType::StockTransfer_IN)
        {
            inventTransferLine              = InventTransferLine::findTransIdReceiveforPost_IN(_taxTrans.InventTransId);
            inventTransferLineIN            = inventTransferLine.inventTransferLine_IN();
            unit                            = inventTransferLineIN.UnitId;
            taxTrans.SalesTaxFormTypes      = transTaxInformation.SalesTaxFormTypes;
            taxTrans.ItemId                 = inventTransferLine.ItemId;
            taxTrans.SourceTaxAmountCur     = _taxTrans.SourceTaxAmountCur;
            taxTrans.TransferOrderNumber    = inventTransferLine.TransferId;
            taxTrans.PriceType              = inventTransferLineIN.PriceType;
            inventTransferTable             = InventTransferTable::find(inventTransferLine.TransferId);

            if (taxType == TaxType_IN::Excise)
            {
                if (inventTransferUpdateType == InventTransferUpdateType::Shipment)
                {
                    exciseRecordType            = transTaxInformation.ExciseRecordType;
                    taxTrans.CompanyRegistrationNumber = transTaxInformation.ExciseECCRegistrationNumber;
                    taxTrans.DirectSettlement   = transTaxInformation.ExciseDirectSettlement;
                    if (transTaxInformation.ExciseDirectSettlement == DirectSettlement_IN::PLA)
                    {
                        taxTrans.plaAmount          =  taxTrans.PostedTaxAmout - deferredExciseAmount;
                        taxTrans.plaLedgerDimension = defaultAccount;
                    }
                }
                else if (inventTransferUpdateType == InventTransferUpdateType::Receive)
                {
                    toTransTaxInformation = transTaxInformationHelper.getTransTaxInformation(_salesPurchJournalLine.SourceTableId, _salesPurchJournalLine.SourceRecId, TransTaxInformationType_IN::InventTransferTo);
                    exciseRecordType = toTransTaxInformation.ExciseRecordType;
                    taxTrans.CompanyRegistrationNumber = toTransTaxInformation.ExciseECCRegistrationNumber;
                    taxTrans.DirectSettlement   = toTransTaxInformation.ExciseDirectSettlement;
                    if (toTransTaxInformation.ExciseDirectSettlement == DirectSettlement_IN::PLA)
                    {
                        taxTrans.plaAmount          =  taxTrans.PostedTaxAmout - deferredExciseAmount;
                        taxTrans.plaLedgerDimension = defaultAccount;
                    }
                }

                exciseTariffCodes = transTaxInformation.ExciseTariffCodes;

                taxTrans.getExciseLedgerAccounts(exciseRecordType, _taxTrans, taxTable.TaxLedgerAccountGroup_IN,taxTrans.DirectSettlement, 0,tmpTaxWorkTransLoc.LedgerDimension_IN, inventTransferUpdateType);
            }
        }

        if (_taxTrans.Source     == TaxModuleType::Voucher)
        {
            taxTrans.SourceRecId         = ledgerJournalTrans.RecId;
            taxTrans.SourceTableId       = ledgerJournalTrans.TableId;
        }
        else
        {
            taxTrans.SourceRecId         = _salesPurchJournalLine.SourceRecId;
            taxTrans.SourceTableId       = _salesPurchJournalLine.SourceTableId;
        }
        taxTrans.RefRecId                = _taxTrans.RecId;
        taxTrans.LoadOnInventoryPercent  = taxOnItem.LoadOnInventoryPercent_IN;

        if (taxType == TaxType_IN::Customs)
        {
            taxTrans.PostedTaxAmout = _taxTrans.taxTrans_W().TaxAmountCustoms_IN - _taxTrans.TaxInCostPriceMST;
            taxTrans.CustomsChargeAsExpensePercent_IN = taxOnItem.CustomsChargeAsExpensePercent_IN;
        }
        else
        {
            taxTrans.PostedTaxAmout = _taxTrans.TaxAmount - CurrencyExchangeHelper::amount(_taxTrans.TaxInCostPriceMST);
        }

        if (_taxTrans.TaxInCostPriceMST)
        {
            taxTrans.LoadOnInventoryAmount = _taxTrans.TaxAmount * taxTrans.LoadOnInventoryPercent / 100;
            if (taxType == TaxType_IN::VAT
                && _salesPurchJournalLine)
            {
                taxTrans.NonRecoverablePct = transTaxInformation.VATNonRecoverablePercent;
                taxTrans.NonRecoverableAmt = (_taxTrans.TaxAmount - taxTrans.LoadOnInventoryAmount) * taxTrans.NonRecoverablePct / 100;
            }
        }

        taxTrans.vatScheduleName    = taxGroupData.vatScheduleName_IN;

        taxTrans.AbatementPercent                = taxOnItem.AbatementPercent_IN;
        if (taxTrans.AbatementPercent)
        {
            taxTrans.AbatementAmount             = abatementAmount;
            if (_taxTrans.SourceBaseAmountCur < 0)
            {
                taxTrans.AbatementAmount         = -abatementAmount;
            }
        }
        taxTrans.SourceBaseAmountCurRegulated    = _taxTrans.SourceBaseAmountCurRegulated;

        taxTrans.SourceRegulateAmountCur         = _taxTrans.SourceRegulateAmountCur;
        if (_salesPurchJournalLine.SourceTableId != tableNum(LedgerJournalTrans))
        {
            if (_salesPurchJournalLine.SourceTableId == tableNum(SalesLine))
            {
                taxTrans.ItemId = SalesLine::findInventTransId(_taxTrans.InventTransId).ItemId;
            }
            else if (_salesPurchJournalLine.SourceTableId == tableNum(PurchLine))
            {
                taxTrans.ItemId = PurchLine::findInventTransId(_taxTrans.InventTransId).ItemId;
            }
        }
        if (_salesPurchJournalLine.SourceTableId == tableNum(PurchLine))
        {
            taxTrans.PurchaseOrder                  = _salesPurchJournalLine.SourceId;
            taxTrans.NonRecoverablePct              = transTaxInformation.VATNonRecoverablePercent;
            taxTrans.SalesTaxFormTypes              = transTaxInformation.SalesTaxFormTypes;
            taxTrans.Quantity                       = vendInvoiceTrans.Qty;

            taxTrans.vatGoodsType                   = transTaxInformation.VATGoodsType;
            taxTrans.Vendor                         = vendInvoiceJour.OrderAccount;
            taxTrans.InvoiceAccount                 = vendInvoiceJour.InvoiceAccount;
            taxTrans.InvoiceId                      = vendInvoiceJour.InvoiceId;
            taxTrans.InvoiceAmount                  = vendInvoiceJour.InvoiceAmount;
            taxTrans.PurchaseInvoiceDate            = vendInvoiceJour.InvoiceDate;
            taxTrans.CostLedgerVoucher              = vendInvoiceJour.CostLedgerVoucher;
            taxTrans.PurchaseItem                   = vendInvoiceTrans.ItemId;
            taxTrans.PurchaseOrderDate              = purchTable.lastPurchaseOrderDate();
            taxTrans.PurchasePackingSlipDate        = purchTable.lastPackingSlipDate();
            taxTrans.PurchasePackingSlipNumber      = purchTable.lastPackingSlip();
            taxTrans.PurchasePackingSlipQuantity    = vendPackingSlipTrans.Qty;
            taxTrans.ReceiptListDate                = purchTable.lastReceiptsListDate();
            taxTrans.ReceiptListNumber              = purchTable.lastReceiptsList();
            taxTrans.Warehouse                      = InventDim::find(vendInvoiceTrans.InventDimId).InventLocationId;
            taxTrans.TransTableId                   = vendInvoiceTrans.TableId;
            taxTrans.TransRecId                     = vendInvoiceTrans.RecId;
            taxTrans.MaximumRetailPrice             = maximumRetailPrice ? maximumRetailPrice : _salesPurchJournalLine.SalesPurchJournalLine::parmMaximumRetailPrice();
            taxTrans.TotalMaximumRetailPrice        = maximumRetailPrice ? maximumRetailPrice*vendInvoiceTrans.Qty : _salesPurchJournalLine.SalesPurchJournalLine::parmMaximumRetailPrice()*vendInvoiceTrans.Qty;
        }
        else if (_salesPurchJournalLine.SourceTableId == tableNum(SalesLine))
        {
            taxTrans.SalesOrder                     = _salesPurchJournalLine.SourceId;
            taxTrans.SalesTaxFormTypes              = transTaxInformation.SalesTaxFormTypes;
            taxTrans.Quantity                       = custInvoiceTrans.Qty;
            taxTrans.Customer                       = custInvoiceJour.OrderAccount;
            taxTrans.InvoiceAccount                 = custInvoiceJour.InvoiceAccount;
            taxTrans.InvoiceId                      = custInvoiceJour.InvoiceId;
            taxTrans.InvoiceAmount                  = custInvoiceJour.InvoiceAmount;
            taxTrans.Warehouse                      = InventDim::find(custInvoiceTrans.InventDimId).InventLocationId;
            taxTrans.TransTableId                   = custInvoiceTrans.TableId;
            taxTrans.TransRecId                     = custInvoiceTrans.RecId;
            taxTrans.MaximumRetailPrice             = maximumRetailPrice ? maximumRetailPrice : _salesPurchJournalLine.SalesPurchJournalLine::parmMaximumRetailPrice();
            taxTrans.TotalMaximumRetailPrice        = maximumRetailPrice ? maximumRetailPrice*custInvoiceTrans.Qty : _salesPurchJournalLine.SalesPurchJournalLine::parmMaximumRetailPrice()*custInvoiceTrans.Qty;
            taxTrans.SalesInvoiceDate               = custInvoiceJour.InvoiceDate;
            taxTrans.SalesPackingSlipDate           = salesTable.lastPackingSlipDate();
            taxTrans.SalesPackingSlipNumber         = salesTable.lastPackingSlip();
            taxTrans.SalesPackingSlipQuantity       = custPackingSlipTrans.Qty;
            if (taxType == TaxType_IN::Customs  &&  salesTable.CustomsExportOrder_IN == NoYes::Yes)
            {
                taxTrans.InvoiceAmount                  = custInvoiceJourLoc.InvoiceAmount;
                taxTrans.Customer                       = custInvoiceJourLoc.OrderAccount;
                taxTrans.InvoiceAccount                 = custInvoiceJourLoc.InvoiceAccount;
                taxTrans.InvoiceId                      = custInvoiceJourLoc.InvoiceId;
                taxTrans.SalesInvoiceDate               = custInvoiceJourLoc.InvoiceDate;
            }
        }
        else if (_salesPurchJournalLine.SourceTableId == tableNum(LedgerJournalTrans))
        {
            taxTrans.SalesTaxFormTypes       = transTaxInformation.SalesTaxFormTypes;
            taxTrans.vatGoodsType            = transTaxInformation.VATGoodsType;
            taxTrans.NonRecoverablePct       = transTaxInformation.VATNonRecoverablePercent;
            taxTrans.MaximumRetailPrice      = ledgerJournalTransTaxExtensionIN.MaximumRetailPrice;
            taxTrans.TotalMaximumRetailPrice = ledgerJournalTransTaxExtensionIN.MaximumRetailPrice;
            taxTrans.JournalName             = ledgerJournalTrans.ledgerJournalTable().JournalName;
            taxTrans.JournalNum              = ledgerJournalTrans.JournalNum;
            taxWorkTrans.CalculationDate     = ledgerJournalTrans.TransDate;
            taxTrans.InvoiceId               = ledgerJournalTrans.MarkedInvoice ? ledgerJournalTrans.MarkedInvoice :ledgerJournalTrans.Invoice;
        }
        else if (_salesPurchJournalLine.SourceTableId == tableNum(CustInvoiceLine))
        {
            salesPurchJournalLineExtension_IN = _salesPurchJournalLine.SalesPurchJournalLine::getSalesPurchJournalLineExtension_IN();

            taxTrans.SalesTaxFormTypes       = transTaxInformation.SalesTaxFormTypes;
            taxTrans.MaximumRetailPrice      = _salesPurchJournalLine.SalesPurchJournalLine::parmMaximumRetailPrice();
            taxTrans.TotalMaximumRetailPrice = _salesPurchJournalLine.SalesPurchJournalLine::parmMaximumRetailPrice();
            assessableValue                  = salesPurchJournalLineExtension_IN.AssessableValue;
        }

        custTaxInformation = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(custTable.Party));
        vendTaxInformation = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(vendTable.Party));

        switch (taxType)
        {
            case TaxType_IN::VAT:

                select firstonly AccountType, RecId from taxLedger
                where taxLedger.LedgerDimension   == defaultAccount
                exists join taxLedgerAccountSetup
                    where taxLedgerAccountSetup.TaxLedgerAccountGroup == taxTable.TaxLedgerAccountGroup_IN
                        && taxLedger.TaxLedgerAccountSetup == taxLedgerAccountSetup.RecId
                        && taxLedger.TaxComponentTable     == taxTable.TaxComponentTable_IN;

                if (taxLedger.AccountType == TaxAccountType_IN::VATRecoverableAccount)
                {
                    taxTrans.RecoverableAmount  =  taxTrans.PostedTaxAmout;
                    taxTrans.RecoverableLedgerDimension = defaultAccount;
                }
                else if (taxLedger.AccountType == TaxAccountType_IN::VATPayableAccount)
                {
                    taxTrans.PayableAmount  =  taxTrans.PostedTaxAmout;
                    taxTrans.PayableLedgerDimension = defaultAccount;
                }
                else if (taxLedger.AccountType == TaxAccountType_IN::VATDeferredAccount)
                {
                    taxTrans.DeferredAmount  =  taxTrans.PostedTaxAmout;
                    taxTrans.DeferredLedgerDimension = defaultAccount;
                }

                if (_taxTrans.Source == TaxModuleType::Purch
                    && _salesPurchJournalLine.SourceTableId == tableNum(PurchLine)
                    && transTaxInformation.VATGoodsType  == VATGoodsType_IN::CapitalGoods
                    && DefermentScheduleTrans_IN::existExtRecId(vendInvoiceTrans.RecId))
                {
                    taxTrans.vatDefermentExtRecId    = vendInvoiceTrans.RecId;
                    taxTrans.vatDeferementExtTableId = vendInvoiceTrans.TableId;
                }

                if (inventTransferLine && inventTransferUpdateType == InventTransferUpdateType::Shipment)
                {
                    taxTrans.CompanyRegistrationNumber = transTaxInformation.VATTIN;
                }
                else if (inventTransferLine && inventTransferUpdateType == InventTransferUpdateType::Receive)
                {
                    taxTrans.CompanyRegistrationNumber = toTransTaxInformation.VATTIN;
                }
                else
                {
                    taxTrans.CompanyRegistrationNumber = transTaxInformation.VATTIN;
                }

                taxTrans.CustVendRegistrationNumber = vendTaxInformation.tin ? vendTaxInformation.getTaxRegistrationNumbersTable(taxType).RecId : custTaxInformation.getTaxRegistrationNumbersTable(taxType).RecId;

                break;

            case TaxType_IN::SalesTax:

                select firstonly AccountType, RecId from taxLedger
                where taxLedger.LedgerDimension   == defaultAccount
                exists join taxLedgerAccountSetup
                    where taxLedgerAccountSetup.TaxLedgerAccountGroup == taxTable.TaxLedgerAccountGroup_IN
                        && taxLedger.TaxLedgerAccountSetup == taxLedgerAccountSetup.RecId
                        && taxLedger.TaxComponentTable     == taxTable.TaxComponentTable_IN;

                if (inventTransferLine && inventTransferUpdateType == InventTransferUpdateType::Shipment)
                {
                    taxTrans.CompanyRegistrationNumber = transTaxInformation.SalesTaxRegistrationNumber;
                }
                else if (inventTransferLine && inventTransferUpdateType == InventTransferUpdateType::Receive)
                {
                    taxTrans.CompanyRegistrationNumber = toTransTaxInformation.SalesTaxRegistrationNumber;
                }
                else
                {
                    taxTrans.CompanyRegistrationNumber = transTaxInformation.SalesTaxRegistrationNumber;
                }
                taxTrans.CustVendRegistrationNumber = vendTaxInformation.SalesTaxRegistrationNumber ? vendTaxInformation.getTaxRegistrationNumbersTable(taxType).RecId
                                                                                                        : custTaxInformation.getTaxRegistrationNumbersTable(taxType).RecId;

                if (taxLedger.AccountType == TaxAccountType_IN::SalesTaxPayableAccount)
                {
                    taxTrans.PayableLedgerDimension = defaultAccount;
                }
                else if (taxLedger.AccountType == TaxAccountType_IN::SalesTaxExpenseAccount)
                {
                    taxTrans.ExpenseLedgerDimension = defaultAccount;
                }
                break;

            case TaxType_IN::Excise:
                companyInfoLoc =  CompanyInfo::find();

                if (_salesPurchJournalLine.SourceTableId != tableNum(InventTransferLine))
                {
                    taxTrans.CompanyRegistrationNumber = transTaxInformation.ExciseECCRegistrationNumber;
                }

                taxTrans.VendorCalculationDateType          = TaxParameters::find().VendorCalculationDateType_IN;
                taxTrans.CustomerCalculationDateType        = TaxParameters::find().CustomerCalculationDateType_IN;
                taxTrans.ExciseRecordType                   = exciseRecordType;
                taxTrans.ExciseTariffCodes                  = exciseTariffCodes;
                taxTrans.CompanyBankName                    = companyInfoLoc.Bank;
                taxTrans.CompanyName                        = companyInfoLoc.Name;
                taxTrans.Exempt                             = _taxTrans.ExemptTax;
                taxTrans.ExemptCode                         = _taxTrans.ExemptCode;

                numSequence                                 = Tax::exciseNumberSequence_IN(taxTrans.CompanyRegistrationNumber,
                                                                                            taxTrans.ExciseRecordType,
                                                                                            false);
                if (taxTrans.SourceRecId && taxTrans.ExciseRecordType == ExciseRecordType_IN::RG23A)
                {
                    taxTrans.rg23aiiNumberSequenceCode = numSequence;
                }
                else if (taxTrans.SourceRecId && taxTrans.ExciseRecordType == ExciseRecordType_IN::RG23C)
                {
                    taxTrans.rg23ciiNumberSequenceCode = numSequence;
                }

                companyTaxInformation = TaxInformation_IN::findDefaultByLocation(DirParty::primaryPostalAddressLocationRecId(companyInfoLoc.RecId));
                taxTrans.CommissionarateCompanyInformation  = companyTaxInformation.Commissionarate;
                taxTrans.CompanyAddress                     = LogisticsPostalAddress::findByLocation(companyTaxInformation.RegistrationLocation).Address;
                taxTrans.CompanyBankAddress                 = LogisticsPostalAddress::findByLocation(BankAccountTable::find(companyInfoLoc.Bank).Location).Address;
                taxTrans.DivisionCompanyInformation         = companyTaxInformation.Division;
                taxTrans.RangeCompanyInformation            = companyTaxInformation.Range;
                taxTrans.BillOfEntryQty                     = billOfEntryQty;
                if (!taxTableExcise)
                {
                    taxTableExcise = taxTable;
                }

                deferredExciseAmount                        = this.excisePurchClaim_IN(_salesPurchJournalLine, taxTrans.PostedTaxAmout);
                if (taxTrans.ExciseRecordType == ExciseRecordType_IN::RG23A
                    || taxTrans.ExciseRecordType == ExciseRecordType_IN::RG23C
                    || taxTrans.ExciseRecordType == ExciseRecordType_IN::None)
                {
                    if (taxTrans.TaxDirection == TaxDirection::IncomingTax &&
                        taxTrans.DirectSettlement != DirectSettlement_IN::PLA)
                    {
                        if (_salesPurchJournalLine.SourceTableId == tableNum(PurchLine))
                        {
                            purchLine = PurchLine::findRecId(_salesPurchJournalLine.SourceRecId);
                        }
                        if (purchLine.InventRefId
                            && TaxTrans_IN::isTaxSettledForTransaction(tableNum(VendInvoiceTrans), VendInvoiceTrans::findInventTransId(purchLine.InventRefTransId).RecId)
                            && taxTrans.DirectSettlement == DirectSettlement_IN::None)
                        {
                            taxTrans.PayableAmount = taxTrans.PostedTaxAmout- deferredExciseAmount;
                            taxTrans.PayableLedgerDimension = defaultAccount;
                        }
                        else
                        {
                            taxTrans.RecoverableAmount  =  taxTrans.PostedTaxAmout- deferredExciseAmount;
                            taxTrans.RecoverableLedgerDimension = defaultAccount;
                        }
                    }
                    else if (taxTrans.TaxDirection == TaxDirection::OutgoingTax
                            && taxTrans.DirectSettlement != DirectSettlement_IN::PLA)
                    {
                        if ((salesLine.InventRefId || salesLine.SalesType == SalesType::ReturnItem)
                            && taxTrans.DirectSettlement == DirectSettlement_IN::None)
                        {
                            taxTrans.RecoverableAmount = taxTrans.PostedTaxAmout- deferredExciseAmount;
                            taxTrans.RecoverableLedgerDimension = defaultAccount;
                        }
                        else
                        {
                            taxTrans.PayableAmount = taxTrans.PostedTaxAmout- deferredExciseAmount;
                            taxTrans.PayableLedgerDimension = defaultAccount;
                        }
                    }
                    if (deferredExciseAmount && taxTrans.ExciseRecordType == ExciseRecordType_IN::RG23A)
                    {
                        taxTrans.rg23aDeferredAmount = deferredExciseAmount;
                        taxTrans.rg23aDeferredLedgerDimension       = TaxLedgerAccounts_IN::findByTaxAccounts(taxTable.TaxLedgerAccountGroup_IN,
                                                                                                        TaxAccountType_IN::ExciseDeferredRG23AAccount,
                                                                                                        taxTable.TaxComponentTable_IN).LedgerDimension;
                    }
                    else if (deferredExciseAmount && taxTrans.ExciseRecordType == ExciseRecordType_IN::RG23C)
                    {
                        taxTrans.rg23cDeferredAmount = deferredExciseAmount;
                        taxTrans.rg23cDeferredLedgerDimension       = TaxLedgerAccounts_IN::findByTaxAccounts(taxTable.TaxLedgerAccountGroup_IN,
                                                                                                        TaxAccountType_IN::ExciseDeferredRG23CAccount,
                                                                                                        taxTable.TaxComponentTable_IN).LedgerDimension;
                    }
                }
                else if (taxTrans.ExciseRecordType == ExciseRecordType_IN::RG23D && taxTrans.TaxDirection == TaxDirection::IncomingTax)
                {
                    taxTrans.rg23dcenvatCreditAmount = taxTrans.PostedTaxAmout;
                    taxTrans.rg23dcenvatCreditLedgerDimension   = TaxLedgerAccounts_IN::findByTaxAccounts(taxTable.TaxLedgerAccountGroup_IN,
                                                                                                    TaxAccountType_IN::ExciseRG23DRecoverableAccount,
                                                                                                    taxTable.TaxComponentTable_IN).LedgerDimension;
                }
                else if (taxTrans.ExciseRecordType == ExciseRecordType_IN::RG23D && taxTrans.TaxDirection == TaxDirection::OutgoingTax)
                {
                    taxTrans.rg23dcenvatCreditTransferredAmount = taxTrans.PostedTaxAmout;
                    taxTrans.rg23dcenvatCreditTransLedgerDimension = TaxLedgerAccounts_IN::findByTaxAccounts(taxTable.TaxLedgerAccountGroup_IN,
                                                                                                    TaxAccountType_IN::ExciseRG23DPayableAccount,
                                                                                                    taxTable.TaxComponentTable_IN).LedgerDimension;
                }
                break;

            case TaxType_IN::ServiceTax:
                taxTrans.CompanyRegistrationNumber       = transTaxInformation.ServiceTaxRegistrationNumber;
                taxTrans.ServiceCodeTable                = serviceCodeTable;
                taxTrans.gtaServiceCategory              = gtaServiceCategory;
                taxTrans.ConsignmentNoteNum              = consignmentNum;
                taxTrans.MinorHead                       = ServiceCodeTable_IN::find(serviceCodeTable).MinorHead;
                break;

            case TaxType_IN::Customs:
                taxTrans.CompanyRegistrationNumber       = transTaxInformation.CustomsIECRegistrationNumber;
                taxTrans.CustomsShippingBillDate         = customsShippingBillDate;
                taxTrans.CustomsBillOfEntryDate          = billOfEntryDate;
                taxTrans.CustomsShippingBillNumberTable  = customsShippingBillNumber;
                taxTrans.CustomsBillOfEntryNumberTable   = customsBillOfEntryNumber;
                taxTrans.CustomsCIFAmount                = customsCIFAmount;
                taxTrans.CustomsFOBAmount                = customsFOBAmount;
                taxTrans.CustomsTaxRegulationAmountCur   = CurrencyHelper_IN::customsMSTAmount_IN(_taxTrans.SourceRegulateAmountCur, _taxTrans.SourceCurrencyCode,
                                                            CurrencyHelper_IN::taxDirection2CustomsDirection_New_IN(_taxTrans.TaxDirection));
                taxTrans.CustomsCurrency                 = Ledger::accountingCurrency();
                select firstonly customsVendBOESubTrans
                    order by BillOfEntryDate
                    where   customsVendBOESubTrans.InventTransId == _taxTrans.InventTransId  &&
                            customsVendBOESubTrans.TaxCode       == _taxTrans.TaxCode;
                if (customsVendBOESubTrans)
                {
                    // During PO Invoicing, Exchange rate should be that of BOE, not Invoice.
                    customsVendBOETransLoc          = CustomsVendBOETrans_IN::findRecId(customsVendBOESubTrans.boeTransRefRecId);
                    transDateLoc                    = customsVendBOETransLoc.BillOfEntryDate;
                }
                else
                {
                    transDateLoc = _taxTrans.TransDate;
                }
                taxTrans.CustomsExchangeRate             = TaxExchangeRateHelper::getCustomsExchangeRate_IN(_taxTrans.SourceCurrencyCode,
                                                                                                            CurrencyHelper_IN::taxDirection2CustomsDirection_New_IN(_taxTrans.TaxDirection),
                                                                                                            transDateLoc);
                taxTrans.CustomsTariffCodeTable          = customsTariffCode;
                taxTrans.CustomsDirection                = direction;
                taxTrans.CustomsLandingChargesPct        = customsLandingChargesPct;
                taxTrans.CustomsLandingChargesAmount     = customsLandingChargesPctAmt;
                taxTrans.CustomsImportInvoiceNumberTable = customsImporterInvoiceNumber;
                taxTrans.CustomsPreferentialValue        = _taxTrans.TaxValue;
                taxTrans.ExciseRecordType                = exciseRecordType;

                if (taxTrans.TaxDirection == TaxDirection::IncomingTax)
                {
                    taxTrans.IndirectTaxLedgerDimension = this.getCustomsAccNum_IN(Direction_IN::Import);
                    if (taxTrans.IndirectTaxLedgerDimension == 0
                        && this.tmpTaxWorkTrans() != null )
                    {
                        taxTrans.IndirectTaxLedgerDimension = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(this.tmpTaxWorkTrans().LedgerDimension_IN);
                    }
                    taxTrans.ImportDutyExpenseLedgerDimension = defaultAccount;
                    taxTrans.ImportDutyPayLedgerDimension     = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(taxTrans.IndirectTaxLedgerDimension);
                }
                else if (taxTrans.TaxDirection == TaxDirection::OutgoingTax)
                {
                    taxTrans.IndirectTaxLedgerDimension = this.getCustomsAccNum_IN(Direction_IN::Export);
                    if (taxTrans.IndirectTaxLedgerDimension == 0
                        && this.tmpTaxWorkTrans() != null )
                    {
                        taxTrans.IndirectTaxLedgerDimension = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(this.tmpTaxWorkTrans().LedgerDimension_IN);
                    }
                    taxTrans.ExportDutyPayLedgerDimension     = defaultAccount;
                    taxTrans.ExportDutyExpenseLedgerDimension = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(taxTrans.IndirectTaxLedgerDimension);
                }
                break;

            default:
                break;
        }

        taxTrans.VoucherCurrency                 = _taxTrans.CurrencyCode;
        taxTrans.InventTransId                   = _taxTrans.InventTransId;
        taxTrans.TaxPeriod                       = _taxTrans.TaxPeriod;
        taxTrans.Source                          = _taxTrans.Source;
        taxTrans.TaxDirection                    = _taxTrans.TaxDirection;
        taxTrans.TaxGroup                        = _taxTrans.TaxGroup;
        taxTrans.TaxItemGroup                    = _taxTrans.TaxItemGroup;
        taxTrans.MiscChargeAmount                = miscCharge;
        taxTrans.TransactionAmount               = transactionAmount;
        taxTrans.Unit                            = unit;
        taxTrans.TaxValue                        = _taxTrans.TaxValue;
        taxTrans.AssessableValue                 = assessableValue;
        taxTrans.AssessableValueAccountingCurrency  = assessableValueAccountingCurrency;
        taxTrans.SourceCurrencyCode              = _taxTrans.SourceCurrencyCode;
        taxTrans.TaxCalculationDateType          = TaxParameters::find().TaxCalculationDateType;
        taxTrans.Voucher                         = _taxTrans.Voucher;
        taxTrans.TaxCode                         = _taxTrans.TaxCode;
        taxTrans.SourceBaseAmountCur             = _taxTrans.SourceBaseAmountCur;
        taxTrans.SourceTaxAmountCur              = _taxTrans.SourceTaxAmountCur;
        taxTrans.TransDate                       = _taxTrans.TransDate;
        taxTrans.TaxType                         = taxType;

        if (_taxTrans.SourceCurrencyCode != Ledger::accountingCurrency() && taxType == TaxType_IN::Customs)
        {
            taxTrans.TaxAmount                   = _taxTrans.taxTrans_W().TaxAmountCustoms_IN;
        }
        else
        {
            taxTrans.TaxAmount                   = _taxTrans.TaxAmount;
        }

        taxTrans.ClaimPercentage                 = _taxTrans.taxTrans_W().ClaimPercentage_IN;

        if (taxTrans.ClaimPercentage)
        {
            taxTrans.DeferredAmount              = CurrencyExchangeHelper::amount(taxTrans.PostedTaxAmout * (100 - taxTrans.ClaimPercentage) / 100);
        }
        taxTrans.ExciseRegister                  = ExciseRegister_IN::None;
        taxTrans.TaxAmountSecondary              = CurrencyExchangeHelper::amountMST2MSTSecond_RU(_taxTrans.TaxAmount, _taxTrans.TransDate);
        taxTrans.TaxLedgerAccountGroup           = taxTable.TaxLedgerAccountGroup_IN;
        taxTrans.TaxComponentTable               = taxTable.TaxComponentTable_IN;
        taxTrans.TaxCurrency                     = _taxTrans.CurrencyCode;
        taxTrans.LedgerDimension                 = ledgerDimension;

        taxTrans.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTaxTransOffset_serviceTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts the Tax transactions of tax offset Ledgerdimensions being Posted
    /// </summary>
    /// <param name="_taxTrans">
    ///    Transaction line being posted.
    /// </param>
    /// <param name="_taxAmountCur">
    ///    Tax amount to be posted.
    /// </param>
    /// <param name="_taxInCostPrice">
    ///    Load on Inventory on tax code.
    /// </param>
    /// <param name="_ledgerDimensionIN">
    ///    Secondary Ledger Dimension for Service Tax.
    /// </param>
    public void insertTaxTransOffset_serviceTax_IN(
        TaxTrans                _taxTrans,
        TaxAmountCur            _taxAmountCur,
        TaxAmountCur            _taxInCostPrice,
        LedgerDimensionAccount  _ledgerDimensionIN)
    {
        TaxTrans            taxTransOffset;
        TaxTrans_W          taxTransOffset_W;
        TaxTable            taxTableLoc;
        LedgerJournalTrans  ledgerJournalTransOffset;
        TaxTrans_W          taxTrans_W;

        taxTrans_W = _taxTrans.taxTrans_W();

        taxTableLoc = TaxTable::find(_taxTrans.TaxCode);

        if (isServiceTaxEnabled
            && taxTrans_W.TaxType_IN == TaxType_IN::ServiceTax)
        {
            select tmpTaxWorkTransLoc
                where tmpTaxWorkTransLoc.TaxCode == taxWorkTrans.TaxCode
                    && TmpTaxWorkTransLoc.SourceTableId == taxWorkTrans.SourceTableId
                    && tmpTaxWorkTransLoc.SourceRecId == taxWorkTrans.SourceRecId;
        }
        if (isServiceTaxEnabled
            && _ledgerDimensionIN
            && taxTableLoc.TaxType_IN == TaxType_IN::ServiceTax)
        {
            taxTransOffset.data(_taxTrans);
            taxTransOffset_W = taxTransOffset.taxTrans_W();
            taxTransOffset.TaxDirection             = TaxDirection::OutgoingTax;
            taxTransOffset.TaxAmount                = -_taxTrans.TaxAmount;
            taxTransOffset.TaxAmountCur             = -_taxTrans.TaxAmountCur;
            taxTransOffset.TaxBaseAmount            = -_taxTrans.TaxBaseAmount;
            taxTransOffset.SourceBaseAmountCur      = -_taxTrans.SourceBaseAmountCur;
            taxTransOffset.TaxBaseAmountCur         = -_taxTrans.TaxBaseAmountCur;
            taxTransOffset.SourceTaxAmountCur       = -_taxTrans.SourceTaxAmountCur;
            taxTransOffset.SourceRegulateAmountCur  = -_taxTrans.SourceRegulateAmountCur;
            taxTransOffset_W.TaxRegistrationNumberTable_IN = _taxTrans.taxTrans_W().TaxRegistrationNumberTable_IN;
            taxTransOffset.packTaxTrans_W(taxTransOffset_W);

            if (taxTransOffset.TaxDirection  == TaxDirection::OutgoingTax)
            {
                taxTransOffset.TaxInCostPrice           = 0;
                taxTransOffset.TaxInCostPriceCur        = 0;
                taxTransOffset.TaxInCostPriceMST        = 0;
                taxTransOffset.TaxInCostPriceRegulated  = 0;
            }
            // Tax should not reverse for GTA vendor.
            if (_taxTrans.SourceTableId == tableNum(LedgerJournalTrans))
            {
                ledgerJournalTransOffset = LedgerJournalTrans::findRecId(_taxTrans.SourceRecId, false);
                if (!ledgerJournalTransOffset.isGTAVendorAccount_IN())
                {
                    taxTransOffset.TaxOrigin = TaxOrigin::TaxReversed;
                }
            }
            taxTransOffset.insert();
            interimTaxTrans = taxTransOffset.RecId;
            //For transaction with checkbox of 'Accrue payable at invoicing' is marked, update the taxTrans_w's field TaxTransRefRecId_IN
            if (TaxItemGroupHeading::isAccruePayableAtInvoicing_IN(taxTransOffset.TaxItemGroup))
            {
                taxTransOffset_W = taxTransOffset.taxTrans_W();
                taxTransOffset_W.TaxTransRefRecId_IN = taxTransOffset.RecId;
                taxTransOffset_W.update();
                taxTransOffset.packTaxTrans_W(taxTransOffset_W);
            }
            this.insertTaxTrans_IN(taxTransOffset, salesPurchJournalLineLoc,_ledgerDimensionIN);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTotalInInternal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts total in internal.
    /// </summary>
    /// <param name = "_possibleCashDisc">The possible cash disc.</param>
    protected void insertTotalInInternal(Percent    _possibleCashDisc)
    {
        TaxTable    taxTable;
        TaxTable    taxTableBasis;
        TaxCalcPrin taxCalcPrin;
        TaxBase     taxBaseAmountForTaxOnTax;
        TaxBaseCur  taxBaseAmountForTaxOnTaxCur;
        boolean     taxOnTaxBasedOnInvoiceBalance;

        taxCalcPrin = this.taxParameters().CalculatePrinciple;

        this.adjustBaseAmount();
        this.purgeInternalStructure();

        while select sum(TaxBaseAmount),
                     sum(TaxBaseAmountRaw),
                     sum(SourceBaseAmountCur),
                     sum(SourceBaseAmountCurRaw),
                     sum(TaxBaseQty),
                     Company
              from taxWorkTrans
              group by TaxCode, TaxDirection, SourceCurrencyCode, CalculationDate, Warning, Company
                // <GBR>
                ,FiscalValue_BR, TaxReceivableLongTerm_BR
                // </GBR>
                // <GEERU>
                where (   taxWorkTrans.ExemptTax == NoYes::No
                     || this.processExemptTax_RU())
              // </GEERU>

        {
            DataAreaId taxWorkTransCompany = curext();
            if(taxWorkTrans.Company)
            {
                taxWorkTransCompany = taxWorkTrans.Company;
            }
            changecompany(taxWorkTransCompany)
            {
                taxOnTaxBasedOnInvoiceBalance = false;
                taxTable = this.getTaxTable(taxWorkTrans.TaxCode);
                // <GIN>
                if (isTaxParametersEnabled
                    && taxTable.TaxType_IN != TaxType_IN::None)
                {
                    continue;
                }
                // </GIN>

                if (taxCalcPrin == TaxCalcPrin::Line)
                {
                    switch (taxTable.TaxBase)
                    {
                        case TaxBaseType::PctPerTax:
                            taxTableBasis = this.getTaxTable(taxTable.TaxOnTax);

                            // if both tax codes are per line, then they were already calculated
                            if (taxTable.TaxLimitBase != TaxLimitBase::InvoiceWithoutVAT &&
                                taxTable.TaxLimitBase != TaxLimitBase::InvoiceInclVAT &&
                                taxTableBasis.TaxLimitBase != TaxLimitBase::InvoiceWithoutVAT &&
                                taxTableBasis.TaxLimitBase != TaxLimitBase::InvoiceInclVAT)
                            {
                                continue;
                            }

                            // if the tax code we are based on is a total code then
                            // it hasn't been calculated yet.  So we will have
                            // to wait until calcTax() to set the base amounts.
                            if (taxTableBasis.TaxLimitBase != TaxLimitBase::InvoiceWithoutVAT &&
                                taxTableBasis.TaxLimitBase != TaxLimitBase::InvoiceInclVAT)
                            {
                                [taxWorkTrans.TaxBaseAmount, taxWorkTrans.SourceBaseAmountCur] = this.taxAmountForTaxOnTax(taxTable.TaxOnTax);

                                // tax on tax doesn't use raw values since it is based on another
                                // tax lines rounded values.
                                taxWorkTrans.TaxBaseAmountRaw = taxWorkTrans.TaxBaseAmount;
                                taxWorkTrans.SourceBaseAmountCurRaw = taxWorkTrans.SourceBaseAmountCur;
                            }
                            else if ((taxTableBasis.TaxLimitBase == TaxLimitBase::InvoiceWithoutVAT ||
                                     taxTableBasis.TaxLimitBase == TaxLimitBase::InvoiceInclVAT) &&
                                     taxTable.TaxLimitBase != TaxLimitBase::InvoiceWithoutVAT &&
                                     taxTable.TaxLimitBase != TaxLimitBase::InvoiceInclVAT)
                            {
                                // if the tax code we are based on is based on invoice total and the
                                // current tax code is per line, then it will have to be calculated as if it was
                                // based on invoice total but we don't know the base amounts yet.
                                taxOnTaxBasedOnInvoiceBalance = true;
                            }
                            break;
                        case TaxBaseType::PctPerGross:
                            taxTableBasis = this.getTaxTable(taxTable.TaxOnTax);

                            // if the tax code we are based on is a total code then
                            // it hasn't been calculated yet.  So we will have
                            // to wait until calcTax() to set the base amounts.
                            if (taxTableBasis.TaxLimitBase != TaxLimitBase::InvoiceWithoutVAT &&
                                taxTableBasis.TaxLimitBase != TaxLimitBase::InvoiceInclVAT ||
                                !taxTable.TaxOnTax)
                            {
                                [taxBaseAmountForTaxOnTax, taxBaseAmountForTaxOnTaxCur] = this.taxAmountForTaxOnTax(taxTable.TaxOnTax, null, taxTable);
                                taxWorkTrans.TaxBaseAmount += taxBaseAmountForTaxOnTax;
                                taxWorkTrans.SourceBaseAmountCur += taxBaseAmountForTaxOnTaxCur;

                                // tax on tax doesn't use raw values since it is based on another
                                // tax lines rounded values.
                                taxWorkTrans.TaxBaseAmountRaw += taxBaseAmountForTaxOnTax;
                                taxWorkTrans.SourceBaseAmountCurRaw += taxBaseAmountForTaxOnTaxCur;
                            }
                            break;
                        default:
                            taxTableBasis = null;
                    }
                }

                if (taxCalcPrin                  == TaxCalcPrin::Total                 ||
                    taxTable.TaxLimitBase        == TaxLimitBase::InvoiceWithoutVAT    ||
                    taxTable.TaxLimitBase        == TaxLimitBase::InvoiceInclVAT       ||
                    taxTableBasis.TaxCode ||
                    taxOnTaxBasedOnInvoiceBalance)
                {
                    this.insertInternalStructureWithCompany(tmpTax,
                                                            taxWorkTrans.TaxCode,
                                                            taxWorkTrans.TaxBaseAmount,
                                                            taxWorkTrans.TaxBaseAmountRaw,
                                                            taxWorkTrans.TaxBaseQty,
                                                            taxWorkTrans.TaxDirection,
                                                            0,
                                                            taxWorkTrans.SourceBaseAmountCur,
                                                            taxWorkTrans.SourceBaseAmountCurRaw,
                                                            taxWorkTrans.CalculationDate,
                                                            taxWorkTrans.Warning,
                                                            taxOnTaxBasedOnInvoiceBalance
                                                            // <GBR>
                                                            ,taxWorkTrans.FiscalValue_BR
                                                            ,taxWorkTrans.TaxReceivableLongTerm_BR
                                                            // </GBR>
                                                            ,taxWorkTrans.SourceCurrencyCode,
                                                            taxWorkTrans.Company
                                                            );
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertUpdateTaxTmpWorkTrans_IN</Name>
				<Source><![CDATA[
    private TaxCode insertUpdateTaxTmpWorkTrans_IN(
        TaxGroup            _taxGroup,
        TaxItemGroup        _taxItemGroup,
        TaxGroupData        _taxGroupData,
        FormulaDesigner_IN  _formulaDesigner,
        TaxOnItem           _taxOnItem,
        InventTransId       _inventTransId,
        Name                _txt,
        TransDate           _taxCalculationDate,
        TaxTable            _taxTable,
        InvoiceId           _invoiceId = '')
    {
        EximPurchLine_IN                    eximPurchLine;
        EximTaxTable_IN                     eximTaxTable;
        RefRecId                            purchLineRecId;
        EximIncentiveSchemeData_IN          incentiveSchemeData;
        EximIncentiveSchemeGroup_IN         incentiveSchemeGroup;
        SelectableDataArea                  company;
        TaxType_IN                          taxTypeIN = _taxTable.TaxType_IN;
        TmpTaxWorkTrans                     tmpTaxWorkTransScrap;
        boolean                             isfromVendinvoiceInfoline = false;
        ClaimPercentage_IN                  claimPercentage;
        PurchLine_IN                        purchLine_IN;
        VendInvoiceInfoLine                 vendInvoiceInfoLine;
        ExciseRecordType_IN                 exciseRecordType;
        ExciseType_IN                       exciseType;
        NoYesId                             cenvatCreditAvailed_IN;
        InventTransferLine                  inventTransferLine;
        TransDateTime                       exciseCalculationDateTimeloc;

        TransTaxInformation                 transTaxInformation;
        TransTaxInformation                 toTransTaxInformation;

        taxWorkTrans.clear();
        // For intercompany scenario
        company = this.getCompany();
        ledgerJournalTransPay = LedgerJournalTrans::findRecId(this.sourceRecId(), false);
        if (ledgerJournalTransPay.RecId == 0
            && ledgerJournalTransLoc.RecId != 0
            && ledgerJournalTransLoc.Company != ''
            && ledgerJournalTransLoc.OffsetCompany != ''
            && (ledgerJournalTransLoc.Company != ledgerJournalTransLoc.OffsetCompany))

        {
            ledgerJournalTransPay = ledgerJournalTransLoc;
        }

        if (inventQualityOrderTable)
        {
            taxWorkTrans.HeadingRecId   = inventQualityOrderTable.RecId;
            taxWorkTrans.HeadingTableId = inventQualityOrderTable.TableId;
        }
        else
        {
            taxWorkTrans.HeadingRecId   = headingRecId;
            taxWorkTrans.HeadingTableId = this.headingTableId();
        }
        taxWorkTrans.SourceTableId         = this.sourceTableId();
        taxWorkTrans.SourceRecId           = this.sourceRecId();
        taxWorkTrans.ParentSourceTableId   = this.parmParentSourceTableId();
        taxWorkTrans.ParentSourceRecId     = this.parmParentSourceRecId();
        taxWorkTrans.Txt                   = _txt;

        if (taxTypeIN == TaxType_IN::ServiceTax
            && taxWorkTrans.SourceTableId == tableNum(LedgerJournalTrans)
            && ledgerJournalTransPay.isPaymentJournal_IN())
        {
            taxWorkTrans.Voucher = this.getRelatedVoucher_IN();
        }
        else
        {
            taxWorkTrans.Voucher = voucher;
        }
        if (taxTypeIN == TaxType_IN::ServiceTax)
        {
            taxWorkTrans.ServiceTaxReverseChargePercentage_IN = TaxItemGroupHeading::find(_taxItemGroup).ReverseChargePercentage_IN;
        }
        taxWorkTrans.TransDate             = taxDate;
        taxWorkTrans.TaxCode               = _taxGroupData.TaxCode;
        taxWorkTrans.TaxGroup              = _taxGroup;
        taxWorkTrans.TaxItemGroup          = _taxItemGroup;
        taxWorkTrans.Source                = taxModuleType;
        taxWorkTrans.InventTransId         = _inventTransId;
        taxWorkTrans.SourceCurrencyCode    = sourceCurrencyCode;
        taxWorkTrans.InvoiceId             = _invoiceId;
        taxWorkTrans.Company               = company;

        if (this.sourceTableId() == tableNum(InventTransferParmLine))
        {
            InventTransferParmLine inventTransferParmLine;

            select firstonly inventTransferParmLine
                where inventTransferParmLine.RecId == this.sourceRecId();

            if (inventTransferParmLine)
            {
                inventTransferLine = inventTransferParmLine.inventTransferLine();

                transTaxInformation = transTaxInformationHelper.getTransTaxInformationByRecord(inventTransferLine, TransTaxInformationType_IN::InventTransferFrom);
                if (transTaxInformation)
                {
                    exciseRecordType = transTaxInformation.ExciseRecordType;
                    exciseType = transTaxInformation.ExciseType;
                    cenvatCreditAvailed_IN = transTaxInformation.ExciseCENVATCreditAvailed;
                }
            }
        }
        else
        {
            transTaxInformation = transTaxInformationHelper.getTransTaxInformation(this.sourceTableId(), this.sourceRecId());
            if (transTaxInformation)
            {
                exciseRecordType = transTaxInformation.ExciseRecordType;
                exciseType = transTaxInformation.ExciseType;
                cenvatCreditAvailed_IN = transTaxInformation.ExciseCENVATCreditAvailed;
            }
        }

        if (taxModuleType == TaxModuleType::StockTransfer_IN)
        {
            if (inventTransferUpdateType == InventTransferUpdateType::Receive)
            {
                taxWorkTrans.TaxDirection = TaxDirection::IncomingTax;

                toTransTaxInformation = transTaxInformationHelper.getTransTaxInformationByRecord(inventTransferLine, TransTaxInformationType_IN::InventTransferTo);

                if (toTransTaxInformation)
                {
                    exciseRecordType = toTransTaxInformation.ExciseRecordType;
                    exciseType = toTransTaxInformation.ExciseType;
                    cenvatCreditAvailed_IN = toTransTaxInformation.ExciseCENVATCreditAvailed;
                }
            }
            else
            {
                taxWorkTrans.TaxDirection = TaxDirection::OutgoingTax;
            }
        }
        else
        {
            taxWorkTrans.TaxDirection = this.determineDirection(_taxGroupData);
        }

        taxWorkTrans.TaxAutogenerated      = NoYes::Yes;
        taxWorkTrans.TaxReports            = NoYes::Yes;
        taxWorkTrans.ExemptTax             = taxWorkTrans.TaxDirection != TaxDirection::UseTax ? _taxGroupData.ExemptTax : NoYes::No;
        taxWorkTrans.CalculationDate       = _taxCalculationDate;
        taxWorkTrans.FormulaID_IN          = _formulaDesigner.id;
        taxWorkTrans.CompanyId_IN          = this.parmInvoiceCompany_IN() ? this.parmInvoiceCompany_IN() : curext();

        if (taxTypeIN == TaxType_IN::Excise)
        {
            exciseCalculationDateTimeloc = this.exciseTaxCalculationdate_IN(this.sourceRecId(), this.sourceTableId());
            if (exciseCalculationDateTimeloc)
            {
                // The Date is converted Back from the UTC to User Prefered Time Zone.
                taxWorkTrans.CalculationDate = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(exciseCalculationDateTimeloc, DateTimeUtil::getUserPreferredTimeZone()));
            }
            else
            {
                exciseCalculationDateTimeloc = DateTimeUtil::newDateTime(taxWorkTrans.CalculationDate, 0, DateTimeUtil::getUserPreferredTimeZone());
            }
        }

        if (exciseType != ExciseType_IN::Trader && taxWorkTrans.TaxDirection == TaxDirection::IncomingTax)
        {
            if (exciseRecordType == ExciseRecordType_IN::RG23A)
            {
                claimPercentage = ClaimPercentage_IN::findClaimPercentage(TaxTable::find(_taxGroupData.TaxCode).TaxComponentTable_IN,exciseCalculationDateTimeloc ,exciseCalculationDateTimeloc, RGRegister_IN::RG23A);
                taxWorkTrans.ClaimPercentage_IN    = claimPercentage.Percentage;
            }
            else if (exciseRecordType == ExciseRecordType_IN::RG23C && !cenvatCreditAvailed_IN)
            {
                claimPercentage = ClaimPercentage_IN::findClaimPercentage(TaxTable::find(_taxGroupData.TaxCode).TaxComponentTable_IN,exciseCalculationDateTimeloc ,exciseCalculationDateTimeloc, RGRegister_IN::RG23C);
                taxWorkTrans.ClaimPercentage_IN    = claimPercentage.Percentage;
            }
        }

        if (this is TaxPurchInvoice
                || this is TaxPurch
            && (taxTypeIN == TaxType_IN::Customs))
        {
            if (taxWorkTrans.SourceTableId == tableNum(VendInvoiceInfoLine))
            {
                purchLineRecId = VendInvoiceInfoLine::findRecId(taxWorkTrans.SourceRecId).PurchLineRecId;
                isfromVendinvoiceInfoline = true;
            }
            else if (taxWorkTrans.SourceTableId == tableNum(PurchLine))
            {
                purchLineRecId =  taxWorkTrans.SourceRecId;
            }
            if (purchLineRecId && this.documentStatus_IN() != DocumentStatus::BillOfEntry_IN)
            {
                TaxUncommitted_IN::initFromPostedBillOfEntry(taxWorkTrans, purchLineRecId, isfromVendinvoiceInfoline);
                taxWorkTrans.TaxAutogenerated = (taxWorkTrans.SourceRegulateAmountCur == taxWorkTrans.SourceTaxAmountCur);
            }
            // Exim Tax is calculated on following condition -:
            // (TaxCodes of 'SalesTaxGroup' n TaxCodes of 'ItemSalesTaxGroup' n TaxCodes of 'Incentive scheme group')
            // Plus license should pass certain set of criteria.
            if (EximParameters_IN::checkParameters()
                || EximParameters_IN::checkDEPBParameters()
                || EximParameters_IN::checkEPCGParameters())
            {
                select firstonly TaxCode, IncentiveScheme
                    from eximTaxTable
                        where eximTaxTable.TaxCode == taxWorkTrans.TaxCode
                    join RecId
                        from eximPurchLine
                            where eximPurchLine.PurchLineRecId            == purchLineRecId
                                && eximPurchLine.EximIncentiveSchemeGroup == eximTaxTable.EximIncentiveSchemeGroup
                        join RecId
                            from incentiveSchemeGroup
                                where incentiveSchemeGroup.RecId       == eximPurchLine.EximIncentiveSchemeGroup
                                    && incentiveSchemeGroup.EximPortId == eximPurchLine.EximPorts
                            join RecId, AuthorizationId
                                from incentiveSchemeData
                                    where incentiveSchemeData.EximIncentiveSchemeGroup  == incentiveSchemeGroup.RecId
                                        && incentiveSchemeData.IncentiveScheme           == eximTaxTable.IncentiveScheme
                                        && ((incentiveSchemeData.EximProductGroupTable   == eximPurchLine.EximProductGroupTable
                                        && (incentiveSchemeData.IncentiveScheme          == EximAuthorizationType_IN::AA
                                        || incentiveSchemeData.IncentiveScheme           == EximAuthorizationType_IN::DFIA))
                                        || (!incentiveSchemeData.EximProductGroupTable
                                        && (incentiveSchemeData.IncentiveScheme          == EximAuthorizationType_IN::DEPB
                                        || incentiveSchemeData.IncentiveScheme           == EximAuthorizationType_IN::EPCG)));
                if (eximTaxTable.TaxCode)
                {
                    this.eximInsertIntersection_IN(incentiveSchemeData, eximTaxTable);
                }
                else
                {
                    taxWorkTrans.EximIncentiveScheme_IN = EximIncentiveScheme_IN::None;
                }
            }
        }
        taxWorkTrans.insert();
        // inserts records into tmptaxworkTrans for scrapQuantity tax.
        if (isIndiaCountryRegionEnabled
            && inventTransferParmLineLoc.QtyScrapNow
            && taxTypeIN == TaxType_IN::Excise)
        {
            tmpTaxWorkTransScrap.data(taxWorkTrans);
            taxWorkTrans.IsScrapQtyLine_IN  = NoYes::Yes;
            taxWorkTrans.TaxDirection       = TaxDirection::OutgoingTax;
            taxWorkTrans.ClaimPercentage_IN = 0;
            taxWorkTrans.insert();
            taxWorkTrans.data(tmpTaxWorkTransScrap);
        }
        return taxWorkTrans.TaxCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventProfileTaxTrans_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the tax trans is with invent profile.
    /// </summary>
    /// <returns>true if validation is passed; otherwise false.</returns>
    protected boolean inventProfileTaxTrans_RU()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventProfileType_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the invent profile type.
    /// </summary>
    /// <returns>The invent profile type.</returns>
    protected InventProfileType_RU inventProfileType_RU()
    {
        return InventProfileType_RU::General;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isImportOrder_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to determine whether this is import order scenario or not
    /// </summary>
    /// <returns>
    /// True if the current scenario is for import order, otherwise false
    /// </returns>
    public boolean isImportOrder_IN()
    {
        boolean isImportOrder;

        switch (this.headingTableId())
        {
            case tablenum(PurchTable):
                isImportOrder = PurchTable::findRecId(this.headingRecId()).isCustomsImportOrder_IN();
                break;

            case tablenum(PurchParmTable):
                isImportOrder = PurchParmTable::findRecId(this.headingRecId()).purchTable().isCustomsImportOrder_IN();
                break;

            case tableNum(VendInvoiceInfoTable):
                isImportOrder = VendInvoiceInfoTable::findRecId(this.headingRecId()).purchTable().isCustomsImportOrder_IN();
                break;

            default:
                break;
        }
        return isImportOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPrePayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether it is prepayment.
    /// </summary>
    /// <returns>true if it is prepayment; otherwise false.</returns>
    protected boolean isPrePayment()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSalesLineFromExportOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether current line is from export order.
    /// </summary>
    /// <param name="_salesLine">
    /// The current line.
    /// </param>
    /// <returns>
    /// True if it is from export order; otherwise, false.
    /// </returns>
    private boolean isSalesLineFromExportOrder(SalesLine _salesLine)
    {
        boolean result;

        if (SalesTable::find(_salesLine.SalesId).CustomsExportOrder_IN == NoYes::Yes)
        {
            result = true;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxableCombination_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to check the taxable combination.
    /// </summary>
    /// <param name="_code">
    /// A tax code.
    /// </param>
    /// <returns>
    /// Returns false if its find the record.
    /// </returns>
    boolean isTaxableCombination_IN(TaxCode    _code)
    {
        boolean             ret = true;
        LedgerJournalTrans  ledgerJournalService;

        if (this.sourceTableId() != tableNum(LedgerJournalTrans))
        {
            return true;
        }

        select ledgerJournalService where
               ledgerJournalService.TableId == this.sourceTableId() &&
               ledgerJournalService.RecId   == this.sourceRecId();

        if ((ledgerJournalService.AccountType       ==  LedgerJournalACType::Bank       &&
            (ledgerJournalService.OffsetAccountType ==  LedgerJournalACType::Cust       ||
             ledgerJournalService.OffsetAccountType ==  LedgerJournalACType::Vend))     ||
            (ledgerJournalService.OffsetAccountType ==  LedgerJournalACType::Bank       &&
            (ledgerJournalService.AccountType       ==  LedgerJournalACType::Cust       ||
             ledgerJournalService.AccountType       ==  LedgerJournalACType::Vend)))
        {
            if (TaxTable::find(_code).TaxType_IN != TaxType_IN::ServiceTax)
            {
                ret = false;
            }
        }

        ret = ret || this.prePaymentIsTaxable_IN(ledgerJournalService);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxableOnMarkupTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prevents tax type which is Customs, SalesTax, Excise or VAT when source table is MarkupTrans.
    /// </summary>
    /// <param name="_taxType">
    /// The tax type.
    /// </param>
    /// <returns>
    /// true if the tax type is taxable; otherwise, false.
    /// </returns>
    protected boolean isTaxableOnMarkupTrans_IN(TaxType_IN _taxType)
    {
        if (this.sourceTableId() == tableNum(MarkupTrans) &&
            (_taxType == TaxType_IN::VAT ||
            _taxType == TaxType_IN::Customs ||
            _taxType == TaxType_IN::Excise ||
            _taxType == TaxType_IN::SalesTax))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the journal number.
    /// </summary>
    /// <returns>The journal number.</returns>
    LedgerJournalId journalNum()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>keepSalesTaxAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether sales tax adjustments should be deleted when the sales tax groups are changed on
    ///    the transaction.
    /// </summary>
    /// <returns>
    ///    true if the sales tax adjustments should not be deleted when the sales tax groups are changed on
    ///    the transaction; otherwise, false.
    /// </returns>
    public boolean keepSalesTaxAdjustments()
    {
        return this.ignoreCalculatedSalesTax();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDimension_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Returns ledger dimension account for given <c>TaxLedgerAccountGroup</c>
    /// </summary>
    /// <param name="_tmpTaxWorkTrans">
    ///   Parameter to take direction from
    /// </param>
    /// <param name="_taxLedgerAccountGroup">
    ///   <c>TaxLedgerAccountGroup</c> record which is the source of ledger dimension
    /// </param>
    /// <returns>
    ///   Ledger dimension account for given <c>TaxLedgerAccountGroup</c>
    /// </returns>
    protected LedgerDimensionDefaultAccount ledgerDimension_RU(TmpTaxWorkTrans _tmpTaxWorkTrans, TaxLedgerAccountGroup _taxLedgerAccountGroup)
    {
        return _taxLedgerAccountGroup.taxLedgerDimension(_tmpTaxWorkTrans.TaxDirection);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDirection_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the ledgerDirection for the jounrals based on taxTable.
    /// </summary>
    /// <param name="_accountNum">
    ///    The _accountNum posting account.
    /// </param>
    /// <param name="_taxTable">
    ///    The taxTable buffer.
    /// </param>
    /// <returns>
    /// Returns TaxAccountType_IN value.
    /// </returns>
    protected TaxAccountType_IN ledgerDirection_IN(
        LedgerDimensionAccount _accountNum,
        TaxTable               _taxTable)
    {
        SalesPurch              salesPurch = SalesPurch::None;
        TaxAccountType_IN       taxAccountType;
        MainAccount             mainAccount;
        MainAccountLegalEntity  mainAccountLegalEntity;
        TransTaxInformation     transTaxInformation;

        select RecId from mainAccount
            where mainAccount.MainAccountId == LedgerDimensionFacade::getMainAccountFromLedgerDimension(_accountNum).MainAccountId
            join TaxDirection from mainAccountLegalEntity
                where mainAccountLegalEntity.MainAccount == mainAccount.RecId &&
                    mainAccountLegalEntity.LegalEntity   == CompanyInfo::findDataArea(curext()).RecId;
        if (mainAccountLegalEntity)
        {
            salesPurch = mainAccountLegalEntity.TaxDirection;
        }
        if (ledgerJournalTransLoc.ledgerJournalTable().JournalType == LedgerJournalType::Approval
            && !ledgerJournalTransLoc.TaxDirectionControl)
        {
            salesPurch = SalesPurch::Purch;
        }

        transTaxInformation = transTaxInformationHelper.getTransTaxInformationByRecord(ledgerJournalTransLoc);

        switch (salesPurch)
        {
            case SalesPurch::Sales :
                if (_taxTable.TaxType_IN == TaxType_IN::SalesTax)
                {
                    taxAccountType = TaxAccountType_IN::SalesTaxPayableAccount;
                }
                if (_taxTable.TaxType_IN == TaxType_IN::VAT)
                {
                    taxAccountType = TaxAccountType_IN::VATPayableAccount;
                }
                if (_taxTable.TaxType_IN == TaxType_IN::Customs)
                {
                    taxAccountType = TaxAccountType_IN::CustomsExportDutyPayableAccount;
                }

                break;

            case SalesPurch::Purch :
                if (_taxTable.TaxType_IN == TaxType_IN::SalesTax)
                {
                    taxAccountType = TaxAccountType_IN::SalesTaxExpenseAccount;
                }
                if (_taxTable.TaxType_IN == TaxType_IN::VAT)
                {
                    if (transTaxInformation.VATGoodsType == VATGoodsType_IN::CapitalGoods)
                    {
                        taxAccountType = TaxAccountType_IN::VATDeferredAccount;
                    }
                    else
                    {
                        taxAccountType = TaxAccountType_IN::VATRecoverableAccount;
                    }
                }
                if (_taxTable.TaxType_IN == TaxType_IN::Customs)
                {
                    taxAccountType = TaxAccountType_IN::CustomsImportDutyExpenseAccount;
                }
                break;

            case SalesPurch::None :
                if (ledgerJournalTransLoc.AmountCurDebit)
                {
                    if (_taxTable.TaxType_IN == TaxType_IN::SalesTax)
                    {
                        taxAccountType = TaxAccountType_IN::SalesTaxExpenseAccount;
                    }
                    if (_taxTable.TaxType_IN == TaxType_IN::VAT)
                    {
                        if (ledgerJournalTransLoc.AccountType == LedgerJournalACType::Ledger
                            && ledgerJournalTransLoc.OffsetAccountType == LedgerJournalACType::Ledger)
                        {
                            taxAccountType = TaxAccountType_IN::VATRecoverableAccount;
                        }
                        else
                        {
                            taxAccountType = transTaxInformation.VATGoodsType == VATGoodsType_IN::CapitalGoods
                                             ? TaxAccountType_IN::VATDeferredAccount
                                             : TaxAccountType_IN::VATRecoverableAccount;
                        }
                    }
                    if (_taxTable.TaxType_IN == TaxType_IN::Customs)
                    {
                        if (transTaxInformation.CustomsTariffDirection == Direction_IN::Import)
                        {
                            taxAccountType = TaxAccountType_IN::CustomsImportDutyExpenseAccount;
                        }
                        else
                        {
                            taxAccountType = TaxAccountType_IN::CustomsExportDutyExpenseAccount;
                        }
                    }
                }
                if (ledgerJournalTransLoc.AmountCurCredit)
                {
                    if (_taxTable.TaxType_IN == TaxType_IN::SalesTax)
                    {
                        taxAccountType = TaxAccountType_IN::SalesTaxPayableAccount;
                    }
                    if (_taxTable.TaxType_IN == TaxType_IN::VAT)
                    {
                        if (ledgerJournalTransLoc.AccountType == LedgerJournalACType::Ledger
                            && ledgerJournalTransLoc.OffsetAccountType == LedgerJournalACType::Ledger)
                        {
                            taxAccountType = TaxAccountType_IN::VATPayableAccount;
                        }
                        else
                        {
                            taxAccountType = transTaxInformation.VATGoodsType == VATGoodsType_IN::CapitalGoods
                                            ? TaxAccountType_IN::VATDeferredAccount
                                            : TaxAccountType_IN::VATPayableAccount;
                        }
                    }
                    if (_taxTable.TaxType_IN == TaxType_IN::Customs)
                    {
                        if (transTaxInformation.CustomsTariffDirection == Direction_IN::Import)
                        {
                            taxAccountType = TaxAccountType_IN::CustomsImportDutyPayableAccount;
                        }
                        else
                        {
                            taxAccountType = TaxAccountType_IN::CustomsExportDutyPayableAccount;
                        }
                    }
                }
                break;
        }
        return taxAccountType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax amount for line.
    /// </summary>
    /// <param name = "_sign">The amount sign.</param>
    /// <returns>The tax amount.</returns>
    protected TaxAmount lineTaxAmount(Integer _sign)
    {
        TaxUncommitted  taxUncommitted;

        if (this.taxParameters().TaxSpecifyLine)
        {
            select firstonly RecId from taxWorkTrans;

            if (taxWorkTrans.RecId > 0 && !this.useSubLedgerJournalLines())
            {
                // Posting out of TmpTaxWorkTrans
                select
                    sum(SourceRegulateAmountCur),
                    // <GBR>
                    sum(SourceOtherBaseTaxAmount_BR)
                    // </GBR>
                    from taxWorkTrans
                where taxWorkTrans.SourceTableId   == this.sourceTableId()   &&
                      taxWorkTrans.SourceRecId     == this.sourceRecId();

                // <GBR>
                if (isBrazilEnabled &&
                    taxModuleType != TaxModuleType::Purch &&
                    taxModuleType != TaxModuleType::PurchInvoice)
                {
                    return abs(taxWorkTrans.SourceRegulateAmountCur + taxWorkTrans.SourceOtherBaseTaxAmount_BR) * _sign;
                }
                // <GBR>

                return abs(taxWorkTrans.SourceRegulateAmountCur) * _sign;
            }
            else
            {
                // Posting out of TaxUncommitted
                select
                    sum(SourceRegulateAmountCur),
                    // <GBR>
                    sum(SourceOtherBaseTaxAmount_BR)
                    // </GBR>
                    from taxUncommitted
                where
                    taxUncommitted.SourceTableId    == this.sourceTableId() &&
                    taxUncommitted.SourceRecId      == this.sourceRecId();

                // <GBR>
                if (isBrazilEnabled &&
                    taxModuleType != TaxModuleType::Purch &&
                    taxModuleType != TaxModuleType::PurchInvoice)
                {
                    return abs(taxUncommitted.SourceRegulateAmountCur + taxUncommitted.SourceOtherBaseTaxAmount_BR) * _sign;
                }
                // <GBR>

                return abs(taxUncommitted.SourceRegulateAmountCur) * _sign;
            }
        }
        else
            return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupTransRecId_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the markup transaction recId.
    /// </summary>
    /// <returns>The recId of the markup transaction.</returns>
    public RecId markupTransRecId_RU()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrFindReturnTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds the return tax for the return line or markup trans record attached to a return line.
    /// </summary>
    /// <param name="_taxWorkTrans">
    ///     The <c>TmpTaxWorkTrans</c> record buffer.
    /// </param>
    /// <param name="_sourceRegulateAmountCur">
    ///     A <c>boolean</c> value that indicates whether or not to source tax amount.
    /// </param>
    /// <returns>
    ///     The return tax amount.
    /// </returns>
    TaxAmountCur mcrFindReturnTax(TmpTaxWorkTrans _taxWorkTrans, boolean _sourceRegulateAmountCur)
    {
        TaxAmountCur returnTaxAmountCur;
        MarkupTrans markupTrans;
        SalesLine   salesLine;
        boolean     isReturnTax;

        if (taxWorkTrans.SourceTableId == tableNum(MarkupTrans))
        {
            select firstonly TransTableId, TransRecId from markupTrans

                where _taxWorkTrans.SourceRecId == markupTrans.RecId;
            if (markupTrans.TransTableId == tableNum(SalesLine))
            {
                select firstonly InventTransIdReturn from salesLine
                    where salesLine.RecId == markupTrans.TransRecId;
                if (salesLine.InventTransIdReturn)
                {
                    isReturnTax = true;
                }
            }
            else if (markupTrans.TransTableId == tableNum(SalesTable))
            {
                // Don't count for now.
                isReturnTax = false;
            }
        }
        else if (_taxWorkTrans.SourceTableId == tableNum(SalesLine))
        {
            select firstonly InventTransIdReturn from salesLine
                where salesLine.RecId == _taxWorkTrans.SourceRecId;
            if (salesLine.InventTransIdReturn)
            {
                isReturnTax = true;
            }
        }

        if (isReturnTax)
        {
            if (_sourceRegulateAmountCur)
            {
                returnTaxAmountCur = _taxWorkTrans.SourceTaxAmountCur;
            }
            else
            {
                returnTaxAmountCur = taxWorkTrans.SourceTaxAmountCur;
            }
        }

        return returnTaxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrReturnTotalTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the tax associated to the return portion of the order.
    /// </summary>
    /// <returns>
    ///     The tax for the return portion of the order.
    /// </returns>
    TaxAmountCur mcrReturnTotalTaxAmount()
    {
        TaxAmountCur returnTaxAmountCur;

        while select taxWorkTrans

            where taxWorkTrans.TaxDirection != TaxDirection::UseTax &&
                  taxWorkTrans.TaxOrigin    != TaxOrigin::TaxReversed
        {
            if (!taxWorkTrans.SourceRegulateAmountCur)
            {
                returnTaxAmountCur += this.mcrFindReturnTax(taxWorkTrans, false);
            }
            else
            {
                returnTaxAmountCur += this.mcrFindReturnTax(taxWorkTrans, true);
            }
        }

        return returnTaxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new()
    {
        // <GIN>
        #ISOCountryRegionCodes
        // </GIN>

        dataAreaIdPost = curext();
        totalValidationPctPerGross = new Set(Types::String);
        totalValidationInvoiceInclVAT = new Set(Types::String);

        taxCodeCombinationIdMaker = TaxCodeCombinationIdMaker::construct();
        taxIncludedInItemPrice = false;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            this.initTaxParameters_IN();
            transTaxInformationHelper = TransTaxInformationHelper::newHelper();
        }

        // <GEEU>
        if (TaxParameters::isBankExchRateEnabled_W()
            || TaxSpecificExchangeRateHelper::isTaxSpecificExchangeRateEnabled())
        {
            useTaxExchangeRate = true;
            accountingCurrency = Ledger::accountingCurrency();
            reportingCurrencyForTaxSpecificExchRate = Ledger::reportingCurrency();
        }
        // </GEEU>

        // <GEEHU>
        initializeContinuousHU = true;
        // </GEEHU>

        // <GBR>
        isBrazilEnabled = BrazilParameters::isEnabled();
        if (isBrazilEnabled)
        {
            isTaxExcludeIssFromAmountOrigin_BRFlightEnabled = true;
            isTaxExcludeIcmsFromAmountOrigin_BRFlightEnabled = true;
        }
        // </GBR>

        taxCurrencyConversionByCompanyMap = new Map(Types::String, Types::AnyType);
        taxCurrencyConversionByCompanyMap.insert(curext(), TaxCurrencyConversionFeatureExposure::isEnabled());

        taxOriginDiffMap = new Map(Types::Int64, Types::Real);
        reconcileMap = new Map(Types::Container, Types::Real);
    }

]]></Source>
			</Method>
			<Method>
				<Name>nrTaxCalcWithoutSource_LV</Name>
				<Source><![CDATA[
    private TaxAmountCur nrTaxCalcWithoutSource_LV(TaxGroup              _taxGroup,
                                                   LvNRTaxGroup          _nrTaxGroup,
                                                   TransDate             _taxDate,
                                                   CurrencyCode          _sourceCurrencyCode,
                                                   AmountCur             _baseAmountCur,
                                                   TaxModuleType         _taxModuleType,
                                                   TaxBase               _baseQty        = 0,
                                                   UnitOfMeasureSymbol   _baseUnit       = '',
                                                   ItemId                _itemId         = '')
    {
        TaxAmountCur taxAmountCur;

        taxDate = _taxDate;

        if (_taxModuleType == TaxModuleType::Voucher)
        {
            if (_baseAmountCur  > 0)
                taxModuleType = TaxModuleType::Purch;
            else
                taxModuleType = TaxModuleType::Sales;
        }
        else
        {
            taxModuleType = _taxModuleType;
        }

        sourceCurrencyCode = _sourceCurrencyCode;
        this.insertIntersection_LV(_taxGroup,
                                   _nrTaxGroup,
                                   _itemId,
                                   '',
                                   _taxDate);

        this.parmSkipException_LV(true);// don't throw error when create NR tax
        this.insertLineInInternal(_baseAmountCur,
                                  _baseQty,
                                  _baseUnit,
                                  _itemId,
                                  0,
                                  0,
                                  0);
        this.parmSkipException_LV(false);

        taxAmountCur = this.calcTax();
        this.saveInProcessTransaction();

        this.insertTotalInInternal(0);
        taxAmountCur = this.calcTax();
        this.saveTotalInProcessTransaction();

        taxAmountCur = this.totalTaxAmount();
        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetLedgerDimension_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Returns ledger dimension account for given <c>TaxLedgerAccountGroup</c>
    /// </summary>
    /// <param name="_taxLedgerAccountGroup">
    ///   <c>TaxLedgerAccountGroup</c> record which is the source of ledger dimension
    /// </param>
    /// <returns>
    ///   Ledger dimension account for given <c>TaxLedgerAccountGroup</c>
    /// </returns>
    protected LedgerDimensionDefaultAccount offsetLedgerDimension_RU(TaxLedgerAccountGroup _taxLedgerAccountGroup)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>origHeadingRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the original record Id of <c>SalesTable</c> or <c>PurchTable</c>, where the <c>origHeadingTableId</c> is
    /// assigned a value in the subclasses of the <c>Tax</c> class.
    /// </summary>
    /// <returns>
    /// The original record Id of <c>SalesTable</c> or <c>PurchTable</c>.
    /// </returns>
    RefRecId origHeadingRecId()
    {
        return origHeadingRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>origHeadingTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the original table Id of the <c>SalesTable</c> or <c>PurchTable</c>, where <c>origHeadingRecId</c>
    /// is assigned a value in the subclasses of the <c>Tax</c> class.
    /// </summary>
    /// <returns>
    /// The original table Id of the <c>SalesTable</c> or <c>PurchTable</c>.
    /// </returns>
    RefTableId origHeadingTableId()
    {
        return origHeadingTableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        throw error(strFmt("@SYS19306",funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountingCurrency</Name>
				<Source><![CDATA[
    public CurrencyCode parmAccountingCurrency()
    {
        return accountingCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAssessableValue_IN</Name>
				<Source><![CDATA[
    public AmountCur parmAssessableValue_IN(AmountCur _assessableValue = assessableValue)
    {
        assessableValue = _assessableValue;

        return assessableValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBaseQty_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The parameter of the base quantity.
    /// </summary>
    /// <param name="_baseQty">
    /// The tax base quantity.
    /// </param>
    void parmBaseQty_IN(TaxBase _baseQty = baseQty)
    {
        baseQty = _baseQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCashDiscountPercent_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The cash discount percent parameter.
    /// </summary>
    /// <param name="_cashDiscountPercent">
    /// The cash discount percent.
    /// </param>
    /// <returns>
    /// The instance of the <c>AmountCur</c> class.
    /// </returns>
    public AmountCur parmCashDiscountPercent_IN(real _cashDiscountPercent = cashDiscPercent_IN)
    {
        cashDiscPercent_IN = _cashDiscountPercent;
        return cashDiscPercent_IN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustomsDuty_IN</Name>
				<Source><![CDATA[
    private void parmCustomsDuty_IN(CustomsAmount_IN _customsDuty = customsDuty)
    {
        customsDuty = _customsDuty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDEPBDutyAvailed_IN</Name>
				<Source><![CDATA[
    public container parmDEPBDutyAvailed_IN(container _dutyavailed = dutyavailed)
    {
        dutyavailed = _dutyavailed;
        return dutyavailed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDEPBSetOffRules_IN</Name>
				<Source><![CDATA[
    public container parmDEPBSetOffRules_IN(container _depbSetOffRules = depbSetOffRules)
    {
        depbSetOffRules = _depbSetOffRules;
        return depbSetOffRules;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This will get/set the exchange rate.
    /// </summary>
    /// <param name="_exchRate">
    ///    The exchange rate to use.
    /// </param>
    /// <returns>
    ///    The exchange rate.
    /// </returns>
    public ExchRate parmExchRate(ExchRate _exchRate = exchRate)
    {
        exchRate = _exchRate;
        return exchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchRateSecond</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This will get/set the secondary exchange rate.
    /// </summary>
    /// <param name="_exchRateSecond">
    ///    The secondary exchange rate to use.
    /// </param>
    /// <returns>
    ///    The secondary exchange rate.
    /// </returns>
    public ExchrateSecondary parmExchRateSecond(ExchrateSecondary _exchRateSecond = exchRateSecond)
    {
        exchRateSecond = _exchRateSecond;
        return exchRateSecond;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEximBalanceTaxAmt_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The exim balance tax amount parameter.
    /// </summary>
    /// <param name="_eximBalTaxAmount">
    /// The exim balance tax amount.
    /// </param>
    public void parmEximBalanceTaxAmt_IN(Amount _eximBalTaxAmount = eximBalanceTaxAmtCalc)
    {
        eximBalanceTaxAmtCalc = _eximBalTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEximDEPBAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the parm exim DEPB amount.
    /// </summary>
    /// <param name="_eximDEPBAmount">
    /// The exim DEPB amount.
    /// </param>
    public void parmEximDEPBAmount_IN(Amount _eximDEPBAmount = depbAmountCalc)
    {
        depbAmountCalc = _eximDEPBAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEximTaxAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the exim tax amount parameter.
    /// </summary>
    /// <param name="_eximTaxAmount">
    /// The exim tax amount.
    /// </param>
    public void parmEximTaxAmount_IN(Amount _eximTaxAmount = eximTaxAmount)
    {
        eximTaxAmount = _eximTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterimTaxTrans_IN</Name>
				<Source><![CDATA[
    public RefRecId parmInterimTaxTrans_IN(RefRecId _interimTaxTrans = interimTaxTrans)
    {
        interimTaxTrans = _interimTaxTrans;

        return interimTaxTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventTransferParmLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets and gets the value of InventTransferParmLine class variable.
    /// </summary>
    /// <param name="_inventTransferParmLineLoc">
    ///    To set InventTransferParmLine
    /// </param>
    /// <returns>
    ///   Returns the value of InventTransferParmLine class variable.
    /// </returns>
    public InventTransferParmLine parmInventTransferParmLine_IN(InventTransferParmLine _inventTransferParmLineLoc = inventTransferParmLineLoc)
    {
        inventTransferParmLineLoc = _inventTransferParmLineLoc;

        if (inventTransferParmLineLoc)
        {
            inventTransferUpdateType = inventTransferParmLineLoc.inventTransferParmTable().UpdateType;
        }

        return inventTransferParmLineLoc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvoiceCompany_IN</Name>
				<Source><![CDATA[
    CompanyId parmInvoiceCompany_IN(CompanyId _invoiceCompanyId = invoiceCompanyId)
    {
        invoiceCompanyId = _invoiceCompanyId;

        return invoiceCompanyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmisApplyExciseForDeffered_IN</Name>
				<Source><![CDATA[
    public boolean parmisApplyExciseForDeffered_IN(boolean _isApplyExciseForDeffered = isApplyExciseForDeffered)
    {
        isApplyExciseForDeffered = _isApplyExciseForDeffered;

        return isApplyExciseForDeffered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalTrans_IN</Name>
				<Source><![CDATA[
    public LedgerJournalTrans parmLedgerJournalTrans_IN(LedgerJournalTrans _ledgerJournalTransLoc = ledgerJournalTransLoc)
    {
        ledgerJournalTransLoc = _ledgerJournalTransLoc;
        return ledgerJournalTransLoc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalTransPay_IN</Name>
				<Source><![CDATA[
    public LedgerJournalTrans parmLedgerJournalTransPay_IN(LedgerJournalTrans _ledgerJournalTransPay = ledgerJournalTransPay)
    {
        ledgerJournalTransPay = _ledgerJournalTransPay;

        return ledgerJournalTransPay;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLJT_IN</Name>
				<Source><![CDATA[
    public LedgerJournalTrans parmLJT_IN(LedgerJournalTrans _ledgerJournalTrans = ledgerJournalTransProject)
    {
        ledgerJournalTransProject = _ledgerJournalTrans;
        return ledgerJournalTransProject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLocalTaxes_IN</Name>
				<Source><![CDATA[
    public boolean parmLocalTaxes_IN(boolean _localTaxes = localTaxes)
    {
        localTaxes = _localTaxes;
        return localTaxes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMaximumRetailPrice_IN</Name>
				<Source><![CDATA[
    public MaximumRetailPrice_IN parmMaximumRetailPrice_IN(MaximumRetailPrice_IN _maximumRetailPrice = maximumRetailPrice)
    {
        maximumRetailPrice = _maximumRetailPrice;

        return maximumRetailPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParentSourceRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the record ID of the parent transaction line for the tax amounts.
    /// </summary>
    /// <returns>
    /// The record ID of the parent transaction line for the tax amounts.
    /// </returns>
    /// <remarks>
    /// This method is designed to be overridden by derived classes. The base implementation returns 0.
    /// </remarks>
    public RefRecId parmParentSourceRecId()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParentSourceTableId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the table ID of the parent transaction to tax amounts.
    /// </summary>
    /// <returns>
    ///    The ID of the parent transaction to tax amounts.
    /// </returns>
    /// <remarks>
    ///    This method is overridden by derived classes. The base implementation returns 0.
    /// </remarks>
    public RefTableId parmParentSourceTableId()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPost</Name>
				<Source><![CDATA[
    public NoYes parmPost(NoYes _post = post)
    {
        ;
        post = _post;

        return post;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmServiceTaxRelatedVoucher_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or gets the serviceTaxRelatedVoucher for which service tax are being calculated for advance payment.
    /// </summary>
    /// <param name="_serviceTaxRelatedVoucher">
    ///    The Voucher for which we are calculating taxes; optional.
    /// </param>
    /// <returns>
    ///    The Voucher for which we are calculating taxes.
    /// </returns>
    public Voucher parmServiceTaxRelatedVoucher_IN(Voucher _serviceTaxRelatedVoucher = serviceTaxRelatedVoucher)
    {
        serviceTaxRelatedVoucher = _serviceTaxRelatedVoucher;
        return serviceTaxRelatedVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipException_LV</Name>
				<Source><![CDATA[
    public boolean parmSkipException_LV(boolean _skipException = skipException)
    {
        skipException = _skipException;
        return skipException;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipLineMarkup</Name>
				<Source><![CDATA[
    public boolean parmSkipLineMarkup(boolean _skipLineMarkup = skipLineMarkup)
    {
        skipLineMarkup = _skipLineMarkup;
        return skipLineMarkup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipTableMarkup</Name>
				<Source><![CDATA[
    public boolean parmSkipTableMarkup(boolean _skipTableMarkup = skipTableMarkup)
    {
        skipTableMarkup = _skipTableMarkup;
        return skipTableMarkup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the effective tax date for tax calculations.
    /// </summary>
    /// <param name="_taxDate">
    ///    The date to set or get; optional.
    /// </param>
    /// <returns>
    ///    The effective tax date set on the <c>Tax</c> class.
    /// </returns>
    TransDate parmTaxDate(TransDate _taxDate = taxDate)
    {
        taxDate = _taxDate;
        return taxDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxItemGroup_IN</Name>
				<Source><![CDATA[
    TaxGroupJournal parmTaxItemGroup_IN(TaxGroupJournal _taxItemGroup = taxItemGroupLJT)
    {
        taxItemGroupLJT = _taxItemGroup;
        return taxItemGroupLJT;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxSourceType_RU</Name>
				<Source><![CDATA[
    public TaxSourceType_RU parmTaxSourceType_RU(TaxSourceType_RU _sourceType = sourceType)
    {
        sourceType = _sourceType;
        return sourceType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxTypesExcludedInPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Set of tax types excluded from posting.
    /// </summary>
    /// <param name="_taxTypes">
    /// The tax type.
    /// </param>
    /// <returns>
    /// The Set of tax types excluded from posting.
    /// </returns>
    protected Set parmTaxTypesExcludedInPosting(Set _taxTypes = taxTypesExcludedInPosting)
    {
        taxTypesExcludedInPosting = _taxTypes;
        if (taxTypesExcludedInPosting == null)
        {
            taxTypesExcludedInPosting = new Set(Types::Enum);
        }

        return taxTypesExcludedInPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxUncommited</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the <c>TaxUncommitted</c> buffer to the <c>Taxpost</c> class required during service tax
    /// posting
    /// </summary>
    /// <param name="_taxUncommited">
    /// The <c>TaxUncommitted</c> table buffer.
    /// </param>
    public void parmTaxUncommited(TaxUncommitted _taxUncommited = taxUnCommittedbuffer)
    {
        taxUnCommittedbuffer = _taxUncommited;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseTaxExchangeRate</Name>
				<Source><![CDATA[
    public boolean parmUseTaxExchangeRate()
    {
        return useTaxExchangeRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVatRegData_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets VAT registration data to the <c>Tax</c> class.
    /// </summary>
    /// <param name = "_vatReg">VAT registration data.</param>
    /// <returns>Current VAT registration data.</returns>
    public container parmVatRegData_W(container _vatReg = [ vatDate,
                                                            documentDate,
                                                            custVendName,
                                                            vatNum,
                                                            addressing,
                                                            taxPeriodPaymentCode,
                                                            postponeVAT,
                                                            intraComVatDate ])
    {
        [ vatDate,
          documentDate,
          custVendName,
          vatNum,
          addressing,
          taxPeriodPaymentCode,
          postponeVAT,
          intraComVatDate] = _vatReg;

        return _vatReg;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or gets the Voucher for which taxes are being calculated.
    /// </summary>
    /// <param name="_voucher">
    ///    The Voucher for which we are calculating taxes; optional.
    /// </param>
    /// <returns>
    ///    The Voucher for which we are calculating taxes.
    /// </returns>
    public Voucher parmVoucher(Voucher _voucher = voucher)
    {
        voucher = _voucher;
        return voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the tax transaction.
    /// </summary>
    /// <param name = "_ledgerPostingController">The instance jof <c>LedgerPostingController</c>.</param>
    /// <param name = "_taxTrans">The buffer of <c>TaxTrans</c>.</param>
    /// <param name = "_taxAmount">The tax mount.</param>
    /// <param name = "_chargeAmount">The charge amount.</param>
    /// <param name = "_exchRateHelper">The instance of <c>CurrencyExchangeHelper</c>.</param>
    /// <param name = "_ledgerDimension">The ledger dimension.</param>
    /// <param name = "_operationLedgerDimension">The operation ledger dimension.</param>
    /// <param name = "_taxOffsetUseTaxLedgerDimension">The tax offset ledger dimension.</param>
    /// <param name = "_ledgerDetailLevel">The ledger detail level.</param>
    /// <param name = "_projLedger">The project ledger.</param>
    /// <param name = "_offsetLedgerDimension">The offset ledger dimension.</param>
    /// <param name = "_amountMSTSecondary">The second MST amount.</param>
    [HookableAttribute(true)]
    protected void post(LedgerPostingController _ledgerPostingController,

                        TaxTrans                _taxTrans,
                        TaxAmount               _taxAmount,
                        TaxAmount               _chargeAmount,
                        CurrencyExchangeHelper  _exchRateHelper,
                        LedgerDimensionAccount  _ledgerDimension,
                        LedgerDimensionAccount  _operationLedgerDimension,
                        LedgerDimensionAccount  _taxOffsetUseTaxLedgerDimension,
                        LedgerDetailLevel       _ledgerDetailLevel  = LedgerDetailLevel::AsDefault,
                        ProjLedger              _projLedger = null
                        ,LedgerDimensionAccount _offsetLedgerDimension = 0,
                        AmountMSTSecondary      _amountMSTSecondary    = 0
                        )

    {
        LedgerVoucherTransObject ledgerVoucherTransObject;

        // <GEERU><GIN>
        #isoCountryRegionCodes
        TaxTrans_W taxTrans_W;
        // </GIN></GEERU>

        // <GEEPL>
        boolean                     countryRegion_PL = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]);
        // </GEEPL>

        // <GEERU>
        LedgerBondClient_RU         ledgerBondClient;
        boolean                     countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        if (countryRegion_RU)
        {
            if (prmisDefault(_offsetLedgerDimension))
            {
                _offsetLedgerDimension = _taxTrans.taxTrans_RU().OffsetLedgerDimension_RU;
            }
        }

        if (countryRegion_RU)
        {
            ledgerBondClient = _ledgerPostingController.getReference().ledgerBondClient_RU();
        }
        // </GEERU>

        if (this.canPostTrans(_taxAmount, _ledgerPostingController))
        {
            if (this.isOutGoingTaxPost(_taxTrans))
            {
                // <GIN>

                if (isIndiaCountryRegionEnabled)
                {
                    taxTrans_W = _taxTrans.taxTrans_W();
                }

                if (isIndiaCountryRegionEnabled
               && (taxTrans_W.TaxType_IN != TaxType_IN::None
               && (this is TaxPurchInvoice
               || this is TaxSalesInvoice)
               || this is TaxProjInvoice))
                {
                    if (this is TaxPurchInvoice)
                    {
                        this.postTaxPurchInvoice_IN(_ledgerPostingController,

                                                _taxTrans,
                                                _taxAmount,
                                                _chargeAmount,
                                                _exchRateHelper,
                                                _ledgerDetailLevel);
                    }
                    else if (this is TaxSalesInvoice)
                    {
                        this.postTaxSalesInvoice_IN(_ledgerPostingController,

                                                _taxTrans,
                                                _taxAmount,
                                                _chargeAmount,
                                                _exchRateHelper,
                                                _ledgerDetailLevel,
                                                _ledgerDimension);
                    }
                    else if (this is TaxProjInvoice)
                    {
                        this.postTaxProjInvoice_IN(_ledgerPostingController,

                                               _taxTrans,
                                               _taxAmount,
                                               _chargeAmount,
                                               _exchRateHelper,
                                               _ledgerDetailLevel,
                                               _ledgerDimension);
                    }
                }
                else if (isTaxParametersEnabled &&
                taxPostingType != LedgerPostingType::Tax &&
                TaxTable::find(_taxTrans.TaxCode).TaxType_IN == TaxType_IN::ServiceTax)
                {
                    this.postServiceTax_IN(_ledgerPostingController,
                                        _taxTrans,
                                        _taxAmount,
                                        _chargeAmount,
                                        _exchRateHelper,
                                        _ledgerDimension,
                                        taxUnCommittedbuffer.LedgerDimension_IN,
                                       _ledgerDetailLevel);
                }
                else
                {
                    // </GIN>
                    this.validateLedgerDimensionForPosting(_ledgerDimension, _taxTrans.TaxDirection, _taxTrans.TaxCode, false);
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                            LedgerPostingType::Tax,
                                                                            _ledgerDimension,
                                                                            _taxTrans.SourceCurrencyCode,
                                                                            _taxAmount - _chargeAmount,
                                                                            _exchRateHelper);

                    // <GIN>
                    if (isIndiaCountryRegionEnabled)
                    {
                        taxTrans_W = _taxTrans.taxTrans_W();
                    }

                    if (isIndiaCountryRegionEnabled
                    && (taxTrans_W.TaxType_IN != TaxType_IN::None)
                    && this is TaxPostJournal)
                    {
                        ledgerVoucherTransObject.parmPostingType(this.getPostingType_IN(taxTrans_W.TaxType_IN));
                    }
                    // </GIN>

                    // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                    if (_taxTrans)
                    {
                        // TaxTrans will not exist in the case where a transaction is only being validated,
                        // and in that case the tax trans relationship should not be created
                        ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId,
                                                                         TaxTransRelationshipType::Tax,
                                                                         curext(),
                                                                         ledgerVoucherTransObject.parmAccountingCurrencyAmount(),
                                                                         ledgerVoucherTransObject.parmTransactionCurrencyAmount());
                    }

                    if (this is TaxProjInvoice && ProjParameters::find().DisplayDefaultDescriptionTextOfProjectSalesTax == NoYes::Yes)
                    {
                        TransactionTxt transTxt = TransactionTxt::construct();
                     
                        transTxt.setType    (LedgerTransTxt::ProjectSalesTax);
                        transTxt.setVoucher (_taxTrans.Voucher);
                        transTxt.setKey1    (_taxTrans.TaxPeriod);
                        transTxt.setKey2    (_taxTrans.TaxCode);

                        _ledgerPostingController.getReference().lastTransTxt(transTxt.txt());
                    }

                    ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);

                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        if (_amountMSTSecondary)
                        {
                            ledgerVoucherTransObject.parmAmountMSTSecondary(_amountMSTSecondary);
                        }

                        this.beforeAddTrans_W(ledgerVoucherTransObject);
                    }
                    // </GEERU>

                    if (_taxTrans.TaxOrigin == TaxOrigin::TaxReversed || _taxTrans.TaxOrigin == TaxOrigin::CashDisc)
                    {
                        ledgerVoucherTransObject.parmSkipDimensionValidation(true);
                    }

                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }
                // <GEERU>
                if (

                    // <GEEPL>
                    (
                    // <GEEPL>
                    countryRegion_RU
                    // <GEEPL>
                    || countryRegion_PL)
                    // </GEEPL>
                    && _offsetLedgerDimension
                    )
                {
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                                     LedgerPostingType::Tax,
                                                                                                     _offsetLedgerDimension,
                                                                                                     sourceCurrencyCode,
                                                                                                     - (_taxAmount - _chargeAmount),
                                                                                                     _exchRateHelper);
                    ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);

                    if (_amountMSTSecondary)
                    {
                        ledgerVoucherTransObject.parmAmountMSTSecondary(-_amountMSTSecondary);
                    }

                    if (_taxTrans)
                    {
                        if (countryRegion_PL)
                        {
                            if (TaxOverdueVendorVATJournalFlight::instance().isEnabled()
                                && this is TaxOverdueVAT_W
                                && _taxTrans.TaxDirection == TaxDirection::IncomingTax)
                            {
                                ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId,
                                                                            TaxTransRelationshipType::TaxReversed,
                                                                            curext(),
                                                                            ledgerVoucherTransObject.parmAccountingCurrencyAmount(),
                                                                            ledgerVoucherTransObject.parmTransactionCurrencyAmount());
                            }
                        }
                        else
                        {
                            // TaxTrans will not exist in the case where a transaction is only being validated,
                            // and in that case the tax trans relationship should not be created
                            ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId,
                                                                         TaxTransRelationshipType::Offset_RU,
                                                                         curext(),
                                                                         ledgerVoucherTransObject.parmAccountingCurrencyAmount(),
                                                                         ledgerVoucherTransObject.parmTransactionCurrencyAmount());
                        }
                    }

                    this.beforeAddTrans_W(ledgerVoucherTransObject);
                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);

                    if (ledgerBondClient && (_taxAmount - _chargeAmount))
                    {
                        ledgerBondClient.bondLast2();
                    }
                }
                // </GEERU>

                // <GIN>
            }
            // </GIN>

            if (this.isTaxIncomingPost(_taxTrans))
            {
                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                    LedgerPostingType::Tax,
                                                                                    _operationLedgerDimension,
                                                                                    _taxTrans.SourceCurrencyCode,
                                                                                    _taxAmount,
                                                                                    _exchRateHelper);

                // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                if (_taxTrans)
                {
                    // TaxTrans will not exist in the case where a transaction is only being validated,
                    // and in that case the tax trans relationship should not be created
                    ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId,
                                                                     TaxTransRelationshipType::Tax,
                                                                     curext(),
                                                                     ledgerVoucherTransObject.parmAccountingCurrencyAmount(),
                                                                     ledgerVoucherTransObject.parmTransactionCurrencyAmount());
                }

                ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);

                if (_taxTrans.TaxOrigin == TaxOrigin::TaxReversed || _taxTrans.TaxOrigin == TaxOrigin::CashDisc)
                {
                    ledgerVoucherTransObject.parmSkipDimensionValidation(true);
                }

                if (_projLedger)
                {
                    ledgerVoucherTransObject.parmProjLedger(_projLedger);
                }

                // <GEERU>
                if (countryRegion_RU)
                {
                    if (_amountMSTSecondary)
                    {
                        ledgerVoucherTransObject.parmAmountMSTSecondary(_amountMSTSecondary);
                    }
                    this.beforeAddTrans_W(ledgerVoucherTransObject);
                }
                // </GEERU>

                _ledgerPostingController.addTrans(ledgerVoucherTransObject);
            }

            if (_taxTrans.TaxDirection == TaxDirection::UseTax)
            {
                this.validateLedgerDimensionForPosting(_taxOffsetUseTaxLedgerDimension, _taxTrans.TaxDirection, _taxTrans.TaxCode, true);

                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                    LedgerPostingType::Tax,
                                                                                    _taxOffsetUseTaxLedgerDimension,
                                                                                    _taxTrans.SourceCurrencyCode,
                                                                                    _taxAmount * -1,
                                                                                    _exchRateHelper);

                // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                if (_taxTrans)
                {
                    // TaxTrans will not exist in the case where a transaction is only being validated,
                    // and in that case the tax trans relationship should not be created
                    ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId,
                                                                     TaxTransRelationshipType::UseTaxPayable,
                                                                     curext(),
                                                                     ledgerVoucherTransObject.parmAccountingCurrencyAmount(),
                                                                     ledgerVoucherTransObject.parmTransactionCurrencyAmount());
                }

                ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);

                // <GEERU>
                if (countryRegion_RU)
                {
                    this.beforeAddTrans_W(ledgerVoucherTransObject);
                    if (_amountMSTSecondary)
                    {
                        ledgerVoucherTransObject.parmAmountMSTSecondary(_amountMSTSecondary);
                    }
                }
                // </GEERU>

                if (_taxTrans.TaxOrigin == TaxOrigin::TaxReversed || _taxTrans.TaxOrigin == TaxOrigin::CashDisc)
                {
                    ledgerVoucherTransObject.parmSkipDimensionValidation(true);
                }

                _ledgerPostingController.addTrans(ledgerVoucherTransObject);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postApplyExciseDeferedAccount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts apply excise defered account.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller.
    /// </param>
    /// <param name="_taxTrans">
    /// The tax transaction.
    /// </param>
    /// <param name="_deferedAmount">
    /// The defered amount.
    /// </param>
    /// <param name="_exchRateHelper">
    /// The exchange rate helper.
    /// </param>
    /// <param name="_ledgerDetailLevel">
    /// The ledger detailed level.
    /// </param>
    /// <param name="_exciseDeferredAccount">
    /// The excise deferred account.
    /// </param>
    // Post defered Amount during ApplyExcise for purchase Journals.
    protected void postApplyExciseDeferedAccount_IN(
        LedgerPostingController _ledgerPostingController,
        TaxTrans                _taxTrans,
        AmountCur               _deferedAmount,
        CurrencyExchangeHelper  _exchRateHelper,
        LedgerDetailLevel       _ledgerDetailLevel = LedgerDetailLevel::AsDefault,
        LedgerDimensionAccount  _exciseDeferredAccount = 0)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject;

        if (_deferedAmount)
        {
            // User has not setup the Excise deffered Account, hence stack trace error.
            Debug::assert(_exciseDeferredAccount != 0);
            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                             LedgerPostingType::Excise_IN,
                                                                                             _exciseDeferredAccount,
                                                                                             sourceCurrencyCode,
                                                                                             _deferedAmount,
                                                                                             _exchRateHelper);
            // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
            if (_taxTrans.RecId)
            {
                // TaxTrans will not exist in the case where a transaction is only being validated,
                // and in that case the tax trans relationship should not be created
                ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
            }

            ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
            _ledgerPostingController.addTrans(ledgerVoucherTransObject);
        }
        isApplyExciseForDeffered = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postApplyExciseTaxCodes_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts apply excise tax codes.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller.
    /// </param>
    /// <param name="_taxTrans">
    /// The tax transaction.
    /// </param>
    /// <param name="_taxAmountCur">
    /// The tax amount cur.
    /// </param>
    /// <param name="_taxInCostPrice">
    /// The tax in cost price.
    /// </param>
    /// <param name="_exchRateHelper">
    /// The exchange rate helper.
    /// </param>
    /// <param name="_ledgerDetailLevel">
    /// The ledger detail level.
    /// </param>
    /// <param name="_taxUncommitted">
    /// The tax uncommitted status.
    /// </param>
    protected void postApplyExciseTaxCodes_IN(
        LedgerPostingController  _ledgerPostingController,
        TaxTrans                 _taxTrans,
        TaxAmountCur             _taxAmountCur,
        TaxAmountCur             _taxInCostPrice,
        CurrencyExchangeHelper   _exchRateHelper,
        LedgerDetailLevel        _ledgerDetailLevel = LedgerDetailLevel::AsDefault,
        TaxUncommitted           _taxUncommitted    = null)

    {
        TaxTrans                    taxTransExcise;
        TaxTrans                    taxTransReverse;
        TaxTrans_W                  taxTransReverseW;
        CustomsComponentTaxCodes_IN customsComponentTaxCodes;
        TaxComponentTable_IN        taxComponentLoc;
        TaxData                     taxDataLoc;
        TaxLedgerAccounts_IN        taxLedgerAccounts;
        TaxValue                    taxDataTaxValue;
        AmountMST                   amountMST;
        NumberOfRecords             taxCodeRowCount;
        NumberOfRecords             currentTaxCodeRow;
        AmountCur                   sumTaxAmount;
        AmountCur                   taxAmount;
        RefRecId                    postingAccount;
        TaxAmount                   sumTaxAmountMST;
        RefRecId                    eccNumber;
        AllocationFactor            taxAmountFactor;
        AllocationFactor            taxAmountFactorRecoverable;
        AllocationFactor            taxAmountFactorDefered;
        AmountCur                   deferedTaxAmount;
        TransDate                   calculationDate;
        DimensionDefault            dimensionDefault = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_taxUncommitted.LedgerDimension);
        LedgerVoucherObject         ledgerVoucherObject;
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        VendInvoiceJour             vendInvoiceJourLoc;
        LedgerJournalTrans          ledgerJournalTrans;
        ClaimPercentage_IN          exciseClaimPercentage;
        TransDateTime               exciseClaimPercentDateTime;
        date                        billOfEntryDate;
        TaxTrans_W                  taxTransExcise_W;
        TaxTrans_IN                 taxTransIN = TaxTrans_IN::findRefRecId(_taxTrans.RecId);
        TransTaxInformation         transTaxInformation;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt;

        transTaxInformation = transTaxInformationHelper.getTransTaxInformation(_taxTrans.SourceTableId, _taxTrans.SourceRecId);

        sourceCurrencyCode = !sourceCurrencyCode ? _taxTrans.SourceCurrencyCode : sourceCurrencyCode;

        // If no Charge as expense defined on the Customs tax Code, then no apply excise will be posted as the total amount is loaded on to Inventory, but excise register Part I would be updated.
        if (taxTransIN && !taxTransIN.CustomsChargeAsExpensePercent_IN)
        {
            this.updateExciseRegister_IN(
                null,
                SalesPurchJournalLine::findRecId(_taxTrans.SourceTableId, _taxTrans.SourceRecId),
                TaxOnItem::find(_taxTrans.TaxItemGroup, _taxTrans.TaxCode));
            return;
        }

        if (_taxTrans.SourceRegulateAmountCur && _taxAmountCur != _taxTrans.SourceRegulateAmountCur)
        {
            _taxAmountCur = _taxTrans.SourceRegulateAmountCur;
        }

        // Only up to the extent of Charge as expense defined on the Customs Tax Code should be applicable for the Apply excise voucher creation.
        _taxAmountCur = _taxAmountCur * taxTransIN.CustomsChargeAsExpensePercent_IN/ 100;
        _taxAmountCur = roundZeroDec(_taxAmountCur, 2);

        // Creating new numberSequence for the TaxSetoffVoucher
        if (!taxOffsetVoucher || _taxTrans.Source == TaxModuleType::Voucher)
        {
            taxOffsetVoucher = NumberSeq::newGetVoucher(TaxParameters::numRefTaxSettoffDocumentVoucher()).voucher();
        }

        if (isCustomsEnabled)
        {
            billOfEntryDate = CustomsVendBOETrans_IN::getCustomsBillOfEntryDate_IN(_taxTrans.SourceTableId, _taxTrans.SourceRecId);

            // During PO Invoice and BOE is done then exchange rate should be considered based on BOE date, not Invoice date.
            if (billOfEntryDate)
            {
                _exchRateHelper.parmExchangeRate1(
                                TaxExchangeRateHelper::getCustomsExchangeRate_IN(
                                                            _taxTrans ? _taxTrans.SourceCurrencyCode : taxWorkTrans.SourceCurrencyCode,
                                                            CurrencyHelper_IN::taxDirection2CustomsDirection_New_IN(_taxTrans ? _taxTrans.TaxDirection : taxWorkTrans.TaxDirection),
                                                            billOfEntryDate));
            }
            else
            {
                _exchRateHelper.parmExchangeRate1(
                                TaxExchangeRateHelper::getCustomsExchangeRate_IN(
                                                            _taxTrans ? _taxTrans.SourceCurrencyCode : taxWorkTrans.SourceCurrencyCode,
                                                            CurrencyHelper_IN::taxDirection2CustomsDirection_New_IN(_taxTrans ? _taxTrans.TaxDirection : taxWorkTrans.TaxDirection),
                                                            _exchRateHelper.parmExchangeDate()));
            }
        }

        // Excise tax calculattion date arrival for journals.
        if (this is TaxPostJournal)
        {
            taxDate = _taxTrans.TransDate;
            if (!ledgerJournalTransLoc.RecId)
            {
                ledgerJournalTransLoc = LedgerJournalTrans::findRecId(_taxTrans.SourceRecId, false);
            }
            if (ledgerJournalTransLoc.ledgerJournalTable().JournalType != LedgerJournalType::Approval)
            {
                if (ledgerJournalTransLoc.orig().AccountType == LedgerJournalACType::Vend ||
                    ledgerJournalTransLoc.orig().OffsetAccountType == LedgerJournalACType::Vend)
                {
                    if (ledgerJournalTransLoc.DocumentDate &&
                        this.taxParameters().VendorCalculationDateType_IN == VendorCalculationDateType_IN::DocumentDate)
                    {
                        exciseClaimPercentDateTime = DateTimeUtil::newDateTime(ledgerJournalTransLoc.DocumentDate, 0, DateTimeUtil::getUserPreferredTimeZone());
                    }
                    else
                    {
                        exciseClaimPercentDateTime = DateTimeUtil::newDateTime(taxDate, 0, DateTimeUtil::getUserPreferredTimeZone());
                    }
                }
                else if (ledgerJournalTransLoc.orig().AccountType == LedgerJournalACType::Cust ||
                            ledgerJournalTransLoc.orig().OffsetAccountType == LedgerJournalACType::Cust)
                {
                    if (this.taxParameters().CustomerCalculationDateType_IN == CustomerCalculationDateType_IN::DeliveryDate ||
                        this.taxParameters().CustomerCalculationDateType_IN == CustomerCalculationDateType_IN::InvoiceDate)
                    {
                        exciseClaimPercentDateTime = DateTimeUtil::newDateTime(taxDate, 0, DateTimeUtil::getUserPreferredTimeZone());
                    }
                }
                else
                {
                    exciseClaimPercentDateTime = DateTimeUtil::newDateTime(taxDate, 0, DateTimeUtil::getUserPreferredTimeZone());
                }
            }

            ledgerVoucherObject = LedgerVoucherObject::newVoucher(taxOffsetVoucher, ledgerJournalTransLoc.TransDate, SysModule::Ledger);
            ledgerVoucherObject.parmDocumentNumber(ledgerJournalTransLoc.DocumentNum);
            ledgerVoucherObject.parmDocumentDate(ledgerJournalTransLoc.DocumentDate);

            _ledgerPostingController.addReference(ledgerVoucherObject);
        }
        else
        {
            exciseClaimPercentDateTime = this.exciseTaxCalculationdate_IN(this.sourceRecId(), this.sourceTableId());
        }

        if (loadOnInventry)
        {
            isAppliedLoadOnInventory = true;
        }
        // Find the number of Excise Taxcodes mapped against the Customs TaxComponent.
        select count(RecId) from customsComponentTaxCodes
            where customsComponentTaxCodes.TaxComponentTable == _taxTrans.taxTrans_W().TaxComponentTable_IN
            join RecId
                from taxComponentLoc
                where taxComponentLoc.RecId   == customsComponentTaxCodes.TaxComponentTable
                   && taxComponentLoc.ApplyExcise == NoYes::Yes;
        if (customsComponentTaxCodes.RecId > 0)
        {
            taxCodeRowCount = customsComponentTaxCodes.RecId;
        }

        // inserts reverse entry for customs tax

        taxTransReverse.data(_taxTrans);
        taxTransReverse.TaxDirection = TaxDirection::IncomingTax;
        taxTransReverse.SourceBaseAmountCur = -_taxTrans.SourceBaseAmountCur;
        taxTransReverse.SourceTaxAmountCur = -_taxTrans.SourceTaxAmountCur;
        taxTransReverse.TaxAmount = -_taxTrans.TaxAmount;
        taxTransReverse.TaxValue = _taxTrans.TaxValue;
        taxTransReverse.VATExemptPct = _taxTrans.VATExemptPct;
        taxTransReverse.SourceRegulateAmountCur = -_taxTrans.SourceRegulateAmountCur;
        taxTransReverse.SourceBaseAmountCurRegulated = -_taxTrans.SourceBaseAmountCurRegulated;
        taxTransReverse.TaxOrigin = TaxOrigin::TaxReversed;
        taxTransReverse.Voucher = taxOffsetVoucher;
        taxTransReverseW = taxTransReverse.taxTrans_w();
        taxTransReverseW.TaxAmountCustoms_IN = -_taxTrans.taxTrans_w().TaxAmountCustoms_IN;
        taxTransReverse.packTaxTrans_W(taxTransReverseW);
        taxTransReverse.insert();

        this.insertTaxTrans_IN(taxTransReverse, salesPurchJournalLineLoc);

        if (_taxTrans.SourceTableId == tableNum(VendInvoiceTrans)
            || _taxTrans.SourceTableId == tableNum(VendInvoiceInfoLine))
        {
            vendInvoiceJourLoc = VendInvoiceJour::findFromTaxTrans(_taxTrans.Voucher, _taxTrans.TransDate);
            vendInvoiceJourLoc.selectForUpdate(true);
            vendInvoiceJourLoc.TaxSetoffVoucher_IN = taxOffsetVoucher;
            vendInvoiceJourLoc.update();
        }

        if (taxModuleType == TaxModuleType::Voucher)
        {
            ledgerJournalTrans = LedgerJournalTrans::findJournalForVoucher(_taxTrans.Voucher, _taxTrans.TransDate);
            ledgerJournalTransTaxExt = ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
            ledgerJournalTrans.selectForUpdate(true);
            ledgerJournalTransTaxExt.TaxSetoffVoucher = taxOffsetVoucher;
            ledgerJournalTrans.packledgerJournalTransTaxExtensionIN(ledgerJournalTransTaxExt);
            ledgerJournalTrans.update();
        }

        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                    LedgerPostingType::Excise_IN,
                                                                                    _taxUncommitted.LedgerDimension,
                                                                                    sourceCurrencyCode,
                                                                                    -_taxAmountCur,
                                                                                    _exchRateHelper);

        // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
        if (taxTransReverse.RecId)
        {
            // TaxTrans will not exist in the case where a transaction is only being validated,
            // and in that case the tax trans relationship should not be created
            ledgerVoucherTransObject.addTaxTransRelationship(taxTransReverse.RecId, TaxTransRelationshipType::Tax);
        }

        ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
        _ledgerPostingController.addTrans(ledgerVoucherTransObject);

        // Loop for each Excise Taxcode and update Excise register and post entries.
        while select TaxCode
            from customsComponentTaxCodes
            where customsComponentTaxCodes.TaxComponentTable == _taxTrans.taxTrans_W().TaxComponentTable_IN
            join RecId
                from taxComponentLoc
                where taxComponentLoc.RecId   == customsComponentTaxCodes.TaxComponentTable
                   && taxComponentLoc.ApplyExcise == NoYes::Yes
        {
            currentTaxCodeRow++;
            taxTableExcise = TaxTable::find(customsComponentTaxCodes.TaxCode);
            taxTransExcise.data(_taxTrans);
            taxTransExcise_W = taxTransExcise.taxTrans_W();
            taxTransExcise.TaxCode              = customsComponentTaxCodes.TaxCode;
            taxTransExcise_W.TaxType_IN           = TaxType_IN::Excise;
            taxTransExcise_W.ApplyExcise_IN       = NoYes::Yes;
            taxTransExcise.TaxPeriod            = taxTableExcise.TaxPeriod;
            taxTransExcise_W.TaxComponentTable_IN = taxTableExcise.TaxComponentTable_IN;
            taxTransExcise.Voucher              = taxOffsetVoucher;

            if (transTaxInformation.ExciseRecordType == ExciseRecordType_IN::RG23A)
            {
                exciseClaimPercentage = ClaimPercentage_IN::findClaimPercentage(TaxTable::find(taxTransExcise.TaxCode).TaxComponentTable_IN,exciseClaimPercentDateTime ,exciseClaimPercentDateTime, RGRegister_IN::RG23A);
            }
            else if (transTaxInformation.ExciseRecordType == ExciseRecordType_IN::RG23C)
            {
                exciseClaimPercentage = ClaimPercentage_IN::findClaimPercentage(TaxTable::find(taxTransExcise.TaxCode).TaxComponentTable_IN,exciseClaimPercentDateTime ,exciseClaimPercentDateTime, RGRegister_IN::RG23C);
            }
            taxTransExcise_W.ClaimPercentage_IN = exciseClaimPercentage.Percentage;

            // Excise has different ECC numbers for Excise type - Manufaturer & Trader.
            eccNumber = transTaxInformation.ExciseECCRegistrationNumber;
            taxTransExcise_W.TaxRegistrationNumberTable_IN = eccNumber;
            taxTransExcise.packTaxTrans_W(taxTransExcise_W);

            postingAccount = this.getSettledExcisePayableAcc_IN(taxTransExcise);
            // TaxTrans.LedgerDimension field is moved to taxTransGeneralJournalEntry which is populated at posting.
            // Class variable is created to store the ledger posting account

            // We are getting Recoverable A/C here
            excisePostingAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(postingAccount ? postingAccount : taxLedgerAccounts.exciseTaxAccountNum(taxTableExcise, eccNumber, transTaxInformation.ExciseRecordType, taxWorkTrans.TaxDirection).LedgerDimension, dimensionDefault);
            if (!taxDataTaxValue)
            {
                calculationDate = DateTimeUtil::date(exciseClaimPercentDateTime);
                calculationDate = calculationDate ? calculationDate : taxWorkTrans.CalculationDate;
                // This is the sum of Tax values of all concerned Excise taxcodes used for pro-rating the Customs duty against each Excise Taxcode.
                taxDataTaxValue = this.getTotalTaxValue_IN(_taxTrans.taxTrans_W().TaxComponentTable_IN,
                                                           transTaxInformation.ExciseTariffCodes,
                                                           calculationDate);
            }
            // Tax value for the current scanned Excise Taxcode.
            select firstonly TaxValue
                from taxDataLoc
                where taxDataLoc.TaxCode              == taxTransExcise.TaxCode
                   && taxDataLoc.ExciseTariffCodes_IN == transTaxInformation.ExciseTariffCodes
                   && ((taxDataLoc.TaxFromDate        <= calculationDate
                   && taxDataLoc.TaxToDate            >= calculationDate)
                   || !taxDataLoc.TaxFromDate);

            if (taxDataTaxValue != 0)
            {
                if (currentTaxCodeRow == taxCodeRowCount)
                {
                    taxAmount = (_taxAmountCur - sumTaxAmount);
                    if (taxTransExcise.SourceRegulateAmountCur != taxTransExcise.SourceTaxAmountCur)
                    {
                        customsAmountMST = ((taxTransExcise.taxTrans_W().TaxAmountCustoms_IN  * taxTransIN.CustomsChargeAsExpensePercent_IN/ 100) - sumTaxAmountMST);
                    }
                    else
                    {
                        customsAmountMST = ((taxTransExcise.taxTrans_W().CustomsDuty_IN * taxTransIN.CustomsChargeAsExpensePercent_IN/ 100) - sumTaxAmountMST);
                    }
                    if (taxCodeRowCount == 1)
                    {
                        taxAmountFactor = 1;// Single Excise Code.
                    }
                    else
                    {
                        taxAmountFactor = (taxDataLoc.TaxValue / taxDataTaxValue);
                    }
                }
                else
                {
                    // Factor for each Excise TaxCode = Individual Excise TaxValue divided by Total Excise taxValues against all Taxcodes.
                    taxAmountFactor = (taxDataLoc.TaxValue / taxDataTaxValue);
                    taxAmount = (_taxAmountCur * taxAmountFactor);// Share of Tax for current Excise Taxcode
                    taxAmount = CurrencyExchangeHelper::amount(taxAmount);

                    // The prorated Amount is used for to the CustomsAmount. This is to fix the rounding Issues
                    customsAmountMST = _exchRateHelper.calculateTransactionToAccounting(taxTransExcise.SourceCurrencyCode, taxAmount, NoYes::Yes);

                    sumTaxAmount += taxAmount;

                    sumTaxAmountMST += customsAmountMST;
                }

                if (taxTransExcise.SourceRegulateAmountCur)
                {
                    taxTransExcise.SourceRegulateAmountCur = taxAmount;
                }
                else
                {
                    taxTransExcise.SourceTaxAmountCur = taxAmount;
                }
                amountMST = customsAmountMST;

                taxTransExcise.TaxAmount    = amountMST;
                taxTransExcise.TaxAmountCur = amountMST;
            }

            if (isAppliedLoadOnInventory)
            {
                taxTransExcise.TaxInCostPrice          = 0;
                taxTransExcise.TaxInCostPriceMST       = 0;
                taxTransExcise.TaxInCostPriceCur       = 0;
                taxTransExcise.TaxInCostPriceRegulated = 0;
            }
            // One entry in TaxTrans per loop(Excise Taxcode). Same for RG23 registers also.
            taxTransExcise.insert();

            if (taxAmount != 0)
            {
                this.updateExciseRegister_IN(
                    taxTransExcise,
                    salesPurchJournalLineLoc,
                    TaxOnItem::find(_taxTrans.TaxItemGroup, _taxTrans.TaxCode));

                // If there are any deffered A/C determined by the Excise claim %, then posting has to go to those accounts also.
                // Deffered A/C is required only if claim % is there.If Claim% = 100% OR 0% then post all to Recoverable A/C

                taxTransExcise_W = taxTransExcise.taxTrans_W();
                if (taxTransExcise_W.ClaimPercentage_IN != 0 && taxTransExcise_W.ClaimPercentage_IN != 100)
                {
                    exciseDeferredAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(taxLedgerAccounts.exciseDeferredTaxAccountNum(taxTableExcise, eccNumber, transTaxInformation.ExciseRecordType, _taxUncommitted.TaxDirection, taxTransExcise_W.ClaimPercentage_IN).LedgerDimension, dimensionDefault);
                    isApplyExciseForDeffered = true;// This will be used to control posting deffered offsets.
                    // 'taxAmountFactor' is distributed among Recoverable & defered posting amount.
                    taxAmountFactorRecoverable = (taxAmountFactor * taxTransExcise.taxTrans_W().ClaimPercentage_IN / 100);
                    taxAmountFactorDefered     = (taxAmountFactor - taxAmountFactorRecoverable);
                    // Info: PO ApplyExcise is handled with distribution from - \Classes\DimensionDerivationRule & TaxMainAccDimensionListDirectIndirect_IN
                    if (taxAmountFactorDefered)

                    {
                        deferedTaxAmount = CurrencyExchangeHelper::amount(taxAmount - _taxAmountCur * taxAmountFactorRecoverable);
                        // For ApplyExcise post the defered A/C if applicable.
                        this.postApplyExciseDeferedAccount_IN(_ledgerPostingController,

                                                                  _taxTrans,
                                                                  deferedTaxAmount,
                                                                  _exchRateHelper,
                                                                  LedgerDetailLevel::AsDefault,
                                                                  exciseDeferredAccount);
                    }
                }
                // Recoverable A/C is posted here for journals, ApplyExcise.
                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                    LedgerPostingType::Excise_IN,
                                                                                    excisePostingAccount,
                                                                                    sourceCurrencyCode,
                                                                                    (taxAmount - deferedTaxAmount),
                                                                                    _exchRateHelper);

                // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                if (taxTransExcise.RecId)
                {
                    // TaxTrans will not exist in the case where a transaction is only being validated,
                    // and in that case the tax trans relationship should not be created
                    ledgerVoucherTransObject.addTaxTransRelationship(taxTransExcise.RecId, TaxTransRelationshipType::Tax);
                }

                ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                _ledgerPostingController.addTrans(ledgerVoucherTransObject);

                taxAmountFactor = 0;
                deferedTaxAmount = 0;
                taxAmountFactorDefered = 0;
                taxAmountFactorRecoverable = 0;
                taxTransExcise.update();
            }
            // Inquiry table population.
            this.insertTaxTrans_IN(taxTransExcise, salesPurchJournalLineLoc, excisePostingAccount);
        }

        taxTableExcise = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCharge</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Posts the sales tax charge.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_taxTrans">
    ///   The Tax Trans record holding the amount to be posted.
    /// </param>
    /// <param name="_chargeAmount">
    ///   The charge amount to post
    /// </param>
    /// <param name="_exchRateHelper">
    ///    The <c>CurrencyExchHelper</c> instance for the <c>TaxTrans</c> record being posted.
    /// </param>
    /// <param name="_transactionLineAccount">
    ///    The <c>LedgerDimensionAccount</c> from the parent of this tax line.
    /// </param>
    /// <remarks>
    ///   This functionality was originally a part of Tax.Post() but was broken out to a seperate method
    ///   since most of the callers of Tax.Post() do not need this.
    /// </remarks>
    void postCharge(LedgerPostingController _ledgerPostingController,
                    TaxTrans                _taxTrans,
                    TaxAmountCur            _chargeAmount,
                    CurrencyExchangeHelper  _exchRateHelper,
                    LedgerDimensionAccount  _transactionLineAccount)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject;
        boolean isFound;

        if (this.isPostCharges(_taxTrans, _chargeAmount))
        {
            // <GIN>
            if (isServiceTaxEnabled
                && _taxTrans.taxTrans_W().TaxType_IN == TaxType_IN::ServiceTax
                && _taxTrans.TaxInCostPrice)
            {
                ledgerJournalTransLoc = LedgerJournalTrans::findRecId(_taxTrans.SourceRecId, false);
                if (ledgerJournalTransLoc.RecId
                    &&
                    (
                        ledgerJournalTransLoc.isPaymentJournal_IN() || ledgerJournalTransLoc.isLedgerBankJournal_IN()
                    )
                   )
                {
                    return;//Skip posting of LOI amount seperaltly.
                }
            }

            if (isTaxParametersEnabled
                && taxPostingType != LedgerPostingType::Tax)
            {
                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                    _ledgerPostingController.getReference(),
                    taxPostingType,
                    _transactionLineAccount,
                    _taxTrans.SourceCurrencyCode,
                    _chargeAmount,
                    _exchRateHelper);
            }
            else
            {
                // </GIN>

                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                this.getTaxChargePostingType(),
                                                                                _transactionLineAccount,
                                                                                _taxTrans.SourceCurrencyCode,
                                                                                _chargeAmount,
                                                                                _exchRateHelper);
                // <GIN>
            }
            // </GIN>

            ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId,
                                                             TaxTransRelationshipType::TaxInCostPrice,
                                                             curext(),
                                                             ledgerVoucherTransObject.parmAccountingCurrencyAmount(),
                                                             ledgerVoucherTransObject.parmTransactionCurrencyAmount());
            ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::Detail);

            isFound = _ledgerPostingController.findReference(_taxTrans.Voucher, _taxTrans.TransDate);
            if (!isFound)
            {
                // when tax is using document date, the date tax has will differ from the date
                // the Journals use.
                isFound = _ledgerPostingController.findReference(_taxTrans.Voucher, _ledgerPostingController.getJournal().lastTransDate());
                Debug::assert(isFound);
            }

            _ledgerPostingController.addTrans(ledgerVoucherTransObject);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postedTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the posted tax amount.
    /// </summary>
    /// <param name = "_voucher">The voucher.</param>
    /// <param name = "_invoiceDate">The invoice date.</param>
    /// <returns>The current tax amount.</returns>
    TaxAmountCur postedTaxAmount(Voucher _voucher, InvoiceDate _invoiceDate)
    {
        TaxTrans taxTrans;
        TaxAmountCur    taxAmountCur;

        select sum(SourceTaxAmountCur) from taxTrans

                where taxTrans.Voucher          == _voucher  &&
                        taxTrans.TransDate      == _invoiceDate &&
                        taxTrans.TaxDirection != TaxDirection::UseTax &&
                        taxTrans.TaxOrigin    != TaxOrigin::TaxReversed &&
                        taxTrans.TaxAutogenerated;

        taxAmountCur = taxTrans.SourceTaxAmountCur;

        select sum(SourceRegulateAmountCur) from taxTrans

                where taxTrans.Voucher          == _voucher  &&
                        taxTrans.TransDate      == _invoiceDate &&
                        taxTrans.TaxDirection != TaxDirection::UseTax &&
                        taxTrans.TaxOrigin    != TaxOrigin::TaxReversed &&
                        !taxTrans.TaxAutogenerated;

        taxAmountCur += taxTrans.SourceRegulateAmountCur;

        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postHandleExciseAmountRegister_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts handle excise amount register.
    /// </summary>
    /// <param name="_taxModelExciseTaxable">
    /// The excise taxable tax model.
    /// </param>
    /// <param name="_taxTrans">
    /// The tax transaction.
    /// </param>
    /// <param name="_register">
    /// The tax excise amount register.
    /// </param>
    /// <param name="_taxTransIN">
    /// The tax transaction.
    /// </param>
    protected void postHandleExciseAmountRegister_IN(
        TaxModelExciseTaxable_IN    _taxModelExciseTaxable,
        TaxTrans                    _taxTrans,
        TaxExciseAmountRegister_IN  _register,
        TaxTrans_IN                 _taxTransIN)
    {
        _register.selectForUpdate(true);
        _register.TaxTrans_IN = _taxTransIN.RecId;
        _register.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postHandleExciseQuantityRegister_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts handle excise quantity register.
    /// </summary>
    /// <param name="_taxModelExciseTaxable">
    /// The excise taxable tax model.
    /// </param>
    /// <param name="_register">
    /// The tax excise quantity register.
    /// </param>
    /// <param name="_taxTransIN">
    /// The tax transaction.
    /// </param>
    protected void postHandleExciseQuantityRegister_IN(
        TaxModelExciseTaxable_IN        _taxModelExciseTaxable,
        TaxExciseQuantityRegister_IN    _register,
        TaxTrans_IN                     _taxTransIN)
    {
        _register.selectForUpdate(true);
        _register.TaxTrans_IN = _taxTransIN.RecId;
        _register.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingProfile_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the posting profile.
    /// </summary>
    /// <returns>The posting profile.</returns>
    protected PostingProfile postingProfile_RU()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPost_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defines specifics parameters for Localizarion BR. It is a subscriber to event post_br in post method.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// A <c>LedgerPostingController</c> passed by the method <c>post</c>.
    /// </param>
    /// <param name="_taxTrans">
    /// A <c>TaxTrans</c> passed by the method <c>post</c>.
    /// </param>
    /// <param name="_taxAmount">
    /// The tax amount passed by the method <c>post</c>.
    /// </param>
    /// <param name="_chargeAmount">
    /// The charge amoount passed by the method <c>post</c>.
    /// </param>
    /// <param name="_exchRateHelper">
    /// A <c>CurrencyExchangeHelper</c> passed by the method <c>post</c>.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The ledger dimension account passed by the method <c>post</c>.
    /// </param>
    /// <param name="_operationLedgerDimension">
    /// The operation ledger dimension passed by the method <c>post</c>.
    /// </param>
    /// <param name="_taxOffsetUseTaxLedgerDimension">
    /// The tax off set use tax ledger dimenssion passed by the method <c>post</c>.
    /// </param>
    /// <param name="_ledgerDetailLevel">
    /// A <c>LedgerDetailLevel</c> passed by the method <c>post</c>.
    /// </param>
    protected void postPost_BR(LedgerPostingController _ledgerPostingController,
                               TaxTrans                _taxTrans,
                               TaxAmount               _taxAmount,
                               TaxAmount               _chargeAmount,
                               CurrencyExchangeHelper  _exchRateHelper,
                               LedgerDimensionAccount  _ledgerDimension,
                               LedgerDimensionAccount  _operationLedgerDimension,
                               LedgerDimensionAccount  _taxOffsetUseTaxLedgerDimension,
                               LedgerDetailLevel       _ledgerDetailLevel  = LedgerDetailLevel::AsDefault)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject;

        if (_taxTrans.TaxDirection == TaxDirection::OutgoingTax && !TaxTable::find(_taxTrans.TaxCode).RetainedTax_BR)
        {
            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),

                                                                                LedgerPostingType::TaxExpense_BR,
                                                                                _taxTrans.taxTrans_BR().TaxSalesOffsetLedgerDimension_BR,
                                                                                _taxTrans.SourceCurrencyCode,
                                                                                -(_taxAmount - _chargeAmount),
                                                                                _exchRateHelper);

            // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
            if (_taxTrans)
            {
                // TaxTrans will not exist in the case where a transaction is only being validated,
                // and in that case the tax trans relationship should not be created
                ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Offset_RU);
            }

            ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);

            _ledgerPostingController.addTrans(ledgerVoucherTransObject);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSalesTaxExchangeRateDifferenceAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the tax difference amount.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The <c>LedgerPostingController</c> instance.
    /// </param>
    /// <param name="_currencyExchangeHelper">
    /// The <c>CurrencyExchangeHelper</c> instance.
    /// </param>
    /// <param name="_taxTransExchangeRateDifference">
    /// The <c>TaxTrans</c> record.
    /// </param>
    /// <param name="_originalLedgerDimension">
    /// The original ledger dimension.
    /// </param>
    protected void postSalesTaxExchangeRateDifferenceAmount(
        LedgerPostingController _ledgerPostingController,
        CurrencyExchangeHelper  _currencyExchangeHelper,
        TaxTrans                _taxTransExchangeRateDifference,
        LedgerDimensionAccount  _originalLedgerDimension)
    {
        LedgerDimensionAccount          differenceLedgerDimension;
        LedgerDimensionAccount          differenceOffsetLedgerDimension;
        LedgerDimensionDefaultAccount   sourceLedgerDimension;
        LedgerDimensionDefaultAccount   sourceOffsetLedgerDimension;
        DimensionDefault                dimensionDefault;
        LedgerVoucherTransObject        ledgerVoucherTransObject;

        [ sourceLedgerDimension, sourceOffsetLedgerDimension ] = this.getTaxExchangeRateDifferencePosting(_taxTransExchangeRateDifference);

        dimensionDefault = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_originalLedgerDimension);

        if (sourceLedgerDimension)
        {
            differenceLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(sourceLedgerDimension, dimensionDefault);

            if (TaxBankExchangeRateDifferenceV2Flight::instance().isEnabled())
            {
                ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
                    _ledgerPostingController.getReference(),
                    LedgerPostingType::Tax,
                    differenceLedgerDimension,
                    _taxTransExchangeRateDifference.SourceCurrencyCode,
                    0,
                    _taxTransExchangeRateDifference.TaxAmount,
                    _taxTransExchangeRateDifference.TaxAmountRep);
            }
            else
            {
                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAccountingAmountsDefault(
                    _ledgerPostingController.getReference(),
                    LedgerPostingType::Tax,
                    differenceLedgerDimension,
                    _taxTransExchangeRateDifference.SourceCurrencyCode,
                    0,
                    _taxTransExchangeRateDifference.TaxAmount,
                    _currencyExchangeHelper);
            }

            ledgerVoucherTransObject.addTaxTransRelationship(_taxTransExchangeRateDifference.RecId,
                                                             TaxTransRelationshipType::Tax,
                                                             curext(),
                                                             _taxTransExchangeRateDifference.TaxAmount,
                                                             _taxTransExchangeRateDifference.TaxAmountCur);
            _ledgerPostingController.addTrans(ledgerVoucherTransObject);
        }

        if (sourceOffsetLedgerDimension)
        {
            differenceOffsetLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(sourceOffsetLedgerDimension, dimensionDefault);

            if (TaxBankExchangeRateDifferenceV2Flight::instance().isEnabled())
            {
                ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
                    _ledgerPostingController.getReference(),
                    LedgerPostingType::Tax,
                    differenceOffsetLedgerDimension,
                    _taxTransExchangeRateDifference.SourceCurrencyCode,
                    0,
                    -_taxTransExchangeRateDifference.TaxAmount,
                    -_taxTransExchangeRateDifference.TaxAmountRep);
            }
            else
            {
                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAccountingAmountsDefault(
                    _ledgerPostingController.getReference(),
                    LedgerPostingType::Tax,
                    differenceOffsetLedgerDimension,
                    _taxTransExchangeRateDifference.SourceCurrencyCode,
                    0,
                    -_taxTransExchangeRateDifference.TaxAmount,
                    _currencyExchangeHelper);
            }

            // <GEECZ>
            if ((SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ])
                || (TaxIntegrationExchangeRateDifferenceLinkForUseTaxFlight::instance().isEnabled()
                    && TaxSpecificExchangeRateHelper::isTaxSpecificExchangeRateEnabled()))
                && _taxTransExchangeRateDifference.TaxDirection == TaxDirection::UseTax)
            {
                ledgerVoucherTransObject.addTaxTransRelationship(
                    _taxTransExchangeRateDifference.RecId,
                    TaxTransRelationshipType::UseTaxPayable,
                    curext(),
                    _taxTransExchangeRateDifference.TaxAmount,
                    _taxTransExchangeRateDifference.TaxAmountCur);
            }
            // </GEECZ>
            _ledgerPostingController.addTrans(ledgerVoucherTransObject);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSalesTaxReceivableAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the <c>Tax</c> class must handle the ledger posts for the tax direction of the
    ///    sales tax receivable.
    /// </summary>
    /// <returns>
    ///    A Boolean value that indicates whether the <c>Tax</c> class must handle the ledger posting for the
    ///    tax direction of the sales tax receivable.
    /// </returns>
    protected boolean postSalesTaxReceivableAmounts()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postServiceTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts to the Service Tax transactions to Ledger based on Ledgerdimensions
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_taxTrans">
    ///    Transaction line being posted.
    /// </param>
    /// <param name="_taxAmount">
    ///    Tax amount to be posted.
    /// </param>
    /// <param name="_loiAmount">
    ///    Tax amount to be charged.
    /// </param>
    /// <param name="_exchRateHelper">
    ///    The <c>CurrencyExchangeHelper</c> instance for the <c>TaxTrans</c> record being posted.
    /// </param>
    /// <param name="_ledgerDimension">
    ///    The ledger dimension.
    /// </param>
    /// <param name="_ledgerDimension_IN">
    ///    The ledger dimension for India.
    /// </param>
    /// <param name="_ledgerDetailLevel">
    ///    The ledger detail level.
    /// </param>

    // For payables incoming LOI is zero.
    // Case1. Plain payment = [Interim recoverable & Recoverable]. Deduct LOI from both [Interim Rec & Recov]
    // Case2. Payment with GTA Vendor = [Interim payable & Payable]. [Payable & Interim Payable] - Don't Deduct, LOI
    // Case3. Plain Invoice = [For cash basis post to Interim recoverable AND For 'POT' Post to Recoverable]. Deduct from interim recoverable/Recoverable and offset Main A/C.
    // Case4. Invoice with GTA vendor = [For cash basis post to SINGLE A/C ie, Interim recoverable.
    //        AND For 'POT' Post to TWO interim A/Cs. ie, interim recoverable A/C & Interim payable account]. Deduct from Interim Recov only
    public void postServiceTax_IN(LedgerPostingController _ledgerPostingController,

        TaxTrans                _taxTrans,
        TaxAmount               _taxAmount,
        TaxAmount               _loiAmount,
        CurrencyExchangeHelper  _exchRateHelper,
        LedgerDimensionAccount  _ledgerDimension,
        LedgerDimensionAccount  _ledgerDimension_IN = 0,
        LedgerDetailLevel       _ledgerDetailLevel  = LedgerDetailLevel::AsDefault)
    {
        TaxAmountCur                serviceTaxPostingAmount      = (_taxAmount - _loiAmount);
        TaxAmountCur                serviceTaxOfsetPostingAmount = _taxAmount;
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        LedgerVoucher               paymentLedgerVoucher;
        LedgerVoucherGroup          ledgerVoucherGroup = LedgerVoucherGroup::construct();
        LedgerJournalTrans          ledgerJournalTrans;
        ServiceTaxRevChargePostingController_IN  serviceTaxRevChargePostingControllerIN;
        boolean                     relatedVoucherDoneForPayment;

        if (isServiceTaxEnabled

           && TaxTable::find(_taxTrans.TaxCode).TaxType_IN == TaxType_IN::ServiceTax)
        {
            if (_ledgerDimension)
            {
                if (_taxTrans.SourceTableId == tableNum(LedgerJournalTrans))
                {
                    ledgerJournalTrans = LedgerJournalTrans::findRecId(_taxTrans.SourceRecId, false);
                }
                if (
                    ledgerJournalTrans.RecId != 0
                    &&
                    (ledgerJournalTrans.isPaymentJournal_IN() || ledgerJournalTrans.isPurchaseCashAccount_IN())
                                            &&
                    (ledgerJournalTrans.isForeignVendorAccount_IN() || ledgerJournalTrans.isGTAVendorAccount_IN())
                  )
                {
                    serviceTaxPostingAmount = _taxAmount;
                }
                if (ledgerJournalTrans.RecId && _taxTrans.taxTrans_W().ServiceTaxReverseChargePercentage_IN)
                {
                    serviceTaxRevChargePostingControllerIN = ServiceTaxRevChargePostingController_IN::construct(_taxTrans, taxPostingType, this, salesPurchJournalLineLoc);
                    serviceTaxRevChargePostingControllerIN.serviceTaxReversePostingController(_ledgerPostingController, _taxTrans, _exchRateHelper, _ledgerDimension, _ledgerDimension_IN ,taxUnCommittedbuffer.LedgerDimensionRev_IN ,_ledgerDetailLevel);
                    return;
                }

                if (serviceTaxPostingAmount)
                {
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(

                        _ledgerPostingController.getReference(),
                        taxPostingType,
                        _ledgerDimension,
                        _taxTrans.SourceCurrencyCode,
                        serviceTaxPostingAmount,
                        _exchRateHelper);

                    // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                    if (_taxTrans)
                    {
                        // TaxTrans will not exist in the case where a transaction is only being validated,
                        // and in that case the tax trans relationship should not be created
                        ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
                    }

                    ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }

                if (ledgerJournalTrans.RecId != 0 && ledgerJournalTrans.isPaymentJournal_IN())
                {
                    relatedVoucherDoneForPayment = LedgerTransVoucherLink::findVoucherGroupId(ledgerJournalTrans.Voucher, _taxTrans.TransDate)

                                                   && LedgerTransVoucherLink::findVoucherGroupId(_taxTrans.Voucher, _taxTrans.TransDate);
                    if (!relatedVoucherDoneForPayment)
                    {
                        ttsbegin;
                        paymentLedgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Summary,
                                                                            _ledgerPostingController.getJournal().parmSysModuleDefault(),
                                                                            _ledgerPostingController.getJournal().parmVoucherSeriesCode());
                        if (paymentLedgerVoucher != null)
                        {
                            paymentLedgerVoucher.addVoucher(
                                LedgerVoucherObject::newVoucher(_ledgerPostingController.getJournal().lastVoucher(),
                                                                _ledgerPostingController.getJournal().lastTransDate(),
                                                                _ledgerPostingController.getJournal().parmSysModuleDefault(),
                                                                ledgerJournalTrans.TransactionType));
                            paymentLedgerVoucher.createVoucherLinks(ledgerJournalTrans.Voucher, paymentLedgerVoucher.lastTransDate());
                        }
                        ttscommit;
                    }
                }
            }
            // When does taxUnCommittedbuffer.LedgerDimension_IN has a value?
            // Case 1: All service tax payments. GTA & Non-GTA.
            // Case 2: GTA invoice, Interim Payable is available in taxUnCommittedbuffer.LedgerDimension_IN
            if (taxUnCommittedbuffer.LedgerDimension_IN)
            {
                if (
                    ledgerJournalTrans.RecId != 0
                    &&
                    (ledgerJournalTrans.isPaymentJournal_IN() || ledgerJournalTrans.isPurchaseCashAccount_IN())
                                            &&
                    (!ledgerJournalTrans.isForeignVendorAccount_IN() && !ledgerJournalTrans.isGTAVendorAccount_IN())
                  )
                {
                    serviceTaxOfsetPostingAmount = (_taxAmount - _loiAmount);
                }
                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                                 taxPostingType,
                                                                                                 taxUnCommittedbuffer.LedgerDimension_IN,
                                                                                                 _taxTrans.SourceCurrencyCode,
                                                                                                 - serviceTaxOfsetPostingAmount,
                                                                                                 _exchRateHelper);
                // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                if (interimTaxTrans)
                {
                    // TaxTrans will not exist in the case where a transaction is only being validated,
                    // and in that case the tax trans relationship should not be created
                    ledgerVoucherTransObject.addTaxTransRelationship(interimTaxTrans, TaxTransRelationshipType::Tax);
                    interimTaxTrans = 0; //reset
                }
                ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                _ledgerPostingController.addTrans(ledgerVoucherTransObject);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxProjInvoice_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts to the Service Tax transactions to Ledger based on Ledgerdimensions
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_taxTrans">
    ///    Transaction line being posted.
    /// </param>
    /// <param name="_taxAmount">
    ///    Tax amount to be posted.
    /// </param>
    /// <param name="_chargeAmount">
    ///    Tax amount to be charged.
    /// </param>
    /// <param name="_exchRateHelper">
    ///    The <c>CurrencyExchangeHelper</c> instance for the <c>TaxTrans</c> record being posted.
    /// </param>
    /// <param name="_ledgerDetailLevel">
    ///    The ledger detail level.
    /// </param>
    /// <param name="_ledgerDimension">
    ///    The ledger dimension.
    /// </param>
    public void postTaxProjInvoice_IN(
        LedgerPostingController _ledgerPostingController,
        TaxTrans                _taxTrans,
        TaxAmount               _taxAmount,
        TaxAmount               _chargeAmount,
        CurrencyExchangeHelper  _exchRateHelper,
        LedgerDetailLevel       _ledgerDetailLevel = LedgerDetailLevel::AsDefault,
        LedgerDimensionAccount  _ledgerDimension   = 0)
    {
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        AmountMST                   amountMST;
        CustomsExchangeRate_IN      customsExchRate;
        LedgerDimensionAccount      ledgerDimension;

        ledgerDimension = _ledgerDimension;

        if (this.isPostSourceTaxAmount(_taxTrans))
        {
            if (isTaxParametersEnabled)
            {
                if ((taxWorkTrans.SourceTaxAmountCur || taxWorkTrans.SourceRegulateAmountCur)
                    && isCustomsEnabled
                    && TaxTable::find(taxWorkTrans.TaxCode).TaxType_IN == TaxType_IN::Customs)
                {
                    customsExchRate = TaxExchangeRateHelper::getCustomsExchangeRate_IN(taxWorkTrans.SourceCurrencyCode,
                                                                                    Direction_IN::Export,
                                                                                    taxWorkTrans.TransDate);
                    amountMST       = CurrencyExchangeHelper::amount((_taxAmount - _chargeAmount) * customsExchRate / 100);

                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                                     taxPostingType,
                                                                                                     customsImportExportLedgerDimension ? customsImportExportLedgerDimension : ledgerDimension,
                                                                                                     sourceCurrencyCode,
                                                                                                     _taxAmount - _chargeAmount,
                                                                                                     _exchRateHelper);
                    // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount

                    if (_taxTrans)
                    {
                        // TaxTrans will not exist in the case where a transaction is only being validated,
                        // and in that case the tax trans relationship should not be created
                        ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
                    }

                    ledgerVoucherTransObject.parmAccountingCurrencyAmount(amountMST);
                    ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }
                else
                {
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                                     taxPostingType,
                                                                                                     taxWorkTrans.LedgerDimension,
                                                                                                     sourceCurrencyCode,
                                                                                                     _taxAmount - _chargeAmount,
                                                                                                     _exchRateHelper);

                    // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount

                    if (_taxTrans)
                    {
                        // TaxTrans will not exist in the case where a transaction is only being validated,
                        // and in that case the tax trans relationship should not be created
                        ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
                    }

                    ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxPurchInvoice_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the tax purch invoice.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller.
    /// </param>
    /// <param name="_taxTrans">
    /// The tax transaction.
    /// </param>
    /// <param name="_taxAmount">
    /// The tax amount.
    /// </param>
    /// <param name="_chargeAmount">
    /// The charge amount.
    /// </param>
    /// <param name="_exchRateHelper">
    /// The exchange rate helper.
    /// </param>
    /// <param name="_ledgerDetailLevel">
    /// The ledger detail level.
    /// </param>
    protected void postTaxPurchInvoice_IN(
        LedgerPostingController _ledgerPostingController,
        TaxTrans                _taxTrans,
        TaxAmount               _taxAmount,
        TaxAmount               _chargeAmount,
        CurrencyExchangeHelper  _exchRateHelper,
        LedgerDetailLevel       _ledgerDetailLevel = LedgerDetailLevel::AsDefault)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject;
        TaxAmount                   claimdeferredAmt_IN;
        SalesPurchJournalLine       salesPurchJournalLine;
        AmountMST                   amountMST;
        AmountMST                   totalBalanceTaxAmount;
        AmountMST                   totalTaxAmount;
        LedgerDimensionAccount      ledgerDimension;
        TransTaxInformation         transTaxInformation;

        transTaxInformation = transTaxInformationHelper.getTransTaxInformation(_taxTrans.SourceTableId, _taxTrans.SourceRecId);

        ledgerDimension = TaxTransGeneralJournalAccountEntry::getTaxLedgerDimensionForTaxTrans(_taxTrans.RecId);

        if (isExciseEnabled
            && TaxTable::find(taxWorkTrans.TaxCode).TaxType_IN == TaxType_IN::Excise
            || taxTableExcise.TaxCode)
        {
            salesPurchJournalLine = this.getSalesPurchJournalLineFromInventId_IN();

            if ((transTaxInformation.ExciseRecordType == ExciseRecordType_IN::RG23A) ||
               (transTaxInformation.ExciseRecordType == ExciseRecordType_IN::RG23C))
            {
                claimdeferredAmt_IN    = this.excisePurchClaim_IN(salesPurchJournalLine,_taxAmount);
                claimDeferredAmountMST = CurrencyExchangeHelper::amount(claimDeferredAmountMST);

                if (transTaxInformation.ExciseDirectSettlement == DirectSettlement_IN::PLA &&
                    transTaxInformation.ExciseCENVATCreditAvailed)
                {
                    claimdeferredAmt_IN    = 0;
                    claimDeferredAmountMST = 0;
                }
            }

            if (transTaxInformation.ExciseDirectSettlement == DirectSettlement_IN::RG23A ||
               transTaxInformation.ExciseDirectSettlement == DirectSettlement_IN::RG23C)
            {
                claimdeferredAmt_IN    = 0;
                claimDeferredAmountMST = 0;
            }

            if (taxWorkTrans.LedgerDimension_IN && claimdeferredAmt_IN && !taxTableExcise.TaxCode)
            {
                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                LedgerPostingType::Excise_IN,
                                                                                deferredInvAcc,
                                                                                sourceCurrencyCode,
                                                                                claimdeferredAmt_IN,
                                                                                _exchRateHelper);

                // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                if (_taxTrans)
                {
                    // TaxTrans will not exist in the case where a transaction is only being validated,
                    // and in that case the tax trans relationship should not be created
                    ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
                }

                ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                _ledgerPostingController.addTrans(ledgerVoucherTransObject);
            }
        }

        if (this.isPostOutGoingTax(_taxTrans))
        {
            if (isTaxParametersEnabled)
            {
                if (TaxTable::find(taxWorkTrans.TaxCode).TaxType_IN != TaxType_IN::Customs)
                {
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                taxPostingType,
                                                                                LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimension),
                                                                                sourceCurrencyCode,
                                                                                 _taxAmount - _chargeAmount - totLOIAmount - claimdeferredAmt_IN ,
                                                                                _exchRateHelper);

                    // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                    if (_taxTrans)
                    {
                        // TaxTrans will not exist in the case where a transaction is only being validated,
                        // and in that case the tax trans relationship should not be created
                        ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
                    }

                    ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }

                if (taxWorkTrans.LedgerDimension_IN && taxPostingType == LedgerPostingType::ServiceTax_IN)
                {
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                taxPostingType,
                                                                                LedgerDimensionFacade::serviceCreateLedgerDimension(taxWorkTrans.LedgerDimension_IN),
                                                                                sourceCurrencyCode,
                                                                                (_taxAmount - _chargeAmount)*-1,
                                                                                _exchRateHelper);

                    // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                    if (_taxTrans)
                    {
                        // TaxTrans will not exist in the case where a transaction is only being validated,
                        // and in that case the tax trans relationship should not be created
                        ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
                    }

                    ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }

                if (((taxWorkTrans.SourceTaxAmountCur  ||
                       (!taxWorkTrans.SourceTaxAmountCur
                       && taxWorkTrans.EximIncentiveScheme_IN == EximIncentiveScheme_IN::EPCG
                       ))
                       || taxWorkTrans.SourceRegulateAmountCur) &&
                     isCustomsEnabled                           &&
                     TaxTable::find(taxWorkTrans.TaxCode).TaxType_IN == TaxType_IN::Customs)
                {
                    if (taxTableExcise.TaxCode)
                    {
                        if (claimdeferredAmt_IN)
                        {
                            amountMST = claimDeferredAmountMST;

                            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),

                                                                                 LedgerPostingType::Excise_IN,
                                                                                 LedgerDimensionFacade::serviceCreateLedgerDimension(exciseDeferredAccount),
                                                                                 sourceCurrencyCode,
                                                                                 claimdeferredAmt_IN,
                                                                                 _exchRateHelper);

                            // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                            if (_taxTrans)
                            {
                                // TaxTrans will not exist in the case where a transaction is only being validated,
                                // and in that case the tax trans relationship should not be created
                                ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
                            }
                            ledgerVoucherTransObject.parmAccountingCurrencyAmount(amountMST);
                            ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                            _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                        }

                        amountMST = CurrencyExchangeHelper::amount(customsAmountMST) - claimDeferredAmountMST;

                        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                                _ledgerPostingController.getReference(),
                                                                                LedgerPostingType::Excise_IN,
                                                                                customsImportExportLedgerDimension ? customsImportExportLedgerDimension : ledgerDimension,
                                                                                sourceCurrencyCode,
                                                                                _taxAmount - claimdeferredAmt_IN,
                                                                                _exchRateHelper);

                        // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                        if (_taxTrans)
                        {
                            // TaxTrans will not exist in the case where a transaction is only being validated,
                            // and in that case the tax trans relationship should not be created
                            ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
                        }
                        ledgerVoucherTransObject.parmAccountingCurrencyAmount(amountMST);
                        ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                        _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                    }
                    else
                    {
                        amountMST = CurrencyExchangeHelper::amount(taxWorkTrans.CustomsDuty_IN);
                        if (taxWorkTrans.EximIncentiveScheme_IN == EximIncentiveScheme_IN::None)
                        {
                            amountMST = CurrencyExchangeHelper::amount(taxWorkTrans.CustomsDuty_IN);
                        }
                        else
                        {
                            if (isEximTaxAmount)
                            {
                                totalTaxAmount = taxWorkTrans.EximTaxCorrectedAmount_IN ?
                                                 taxWorkTrans.EximTaxCorrectedAmount_IN  :
                                                 taxWorkTrans.EximTaxAmount_IN;

                                if (taxWorkTrans.EximIncentiveScheme_IN == EximIncentiveScheme_IN::EPCG && isDEPBUtilizedAmount)
                                {
                                    amountMST = CurrencyExchangeHelper::amount(_taxAmount > 0 ? taxWorkTrans.EximDEPBAmount_IN : -taxWorkTrans.EximDEPBAmount_IN);
                                }
                                else
                                {
                                    amountMST = CurrencyExchangeHelper::amount(_taxAmount > 0 ? totalTaxAmount - taxWorkTrans.EximDEPBAmount_IN : -(totalTaxAmount - taxWorkTrans.EximDEPBAmount_IN));
                                }
                            }
                            else
                            {
                                totalBalanceTaxAmount = taxWorkTrans.EximBalanceTaxCorrectedAmount_IN ?
                                                        taxWorkTrans.EximBalanceTaxCorrectedAmount_IN :
                                                        ((taxWorkTrans.EximIncentiveScheme_IN == EximIncentiveScheme_IN::EPCG) ?
                                                        taxWorkTrans.EximBalanceTaxAmount_IN :
                                                        (taxWorkTrans.CustomsDuty_IN - taxWorkTrans.EximTaxAmount_IN));

                                if (totalBalanceTaxAmount)
                                {
                                    amountMST = CurrencyExchangeHelper::amount(_taxAmount > 0 ? totalBalanceTaxAmount : -totalBalanceTaxAmount);
                                }
                            }
                        }

                        if (taxWorkTrans.EximIncentiveScheme_IN == EximIncentiveScheme_IN::None)
                        {
                            if (taxWorkTrans.SourceRegulateAmountCustoms_IN)
                            {
                                if (abs(_taxAmount - _chargeAmount - loadOnInventry) == taxWorkTrans.SourceRegulateAmountCur)
                                {
                                    if ((_taxAmount - _chargeAmount - loadOnInventry) < 0)
                                    {
                                        amountMST = taxWorkTrans.SourceRegulateAmountCustoms_IN * -1;
                                    }
                                    else
                                    {
                                        amountMST = taxWorkTrans.SourceRegulateAmountCustoms_IN;
                                    }
                                }
                                else
                                {
                                    if (_taxAmount > 0)
                                    {
                                        amountMST = taxWorkTrans.SourceRegulateAmountCustoms_IN;
                                    }
                                    else
                                    {
                                        amountMST = -taxWorkTrans.SourceRegulateAmountCustoms_IN;
                                    }
                                }
                            }
                        }

                        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(

                                                                                    _ledgerPostingController.getReference(),
                                                                                    taxPostingType,
                                                                                    customsImportExportLedgerDimension ? customsImportExportLedgerDimension : ledgerDimension,
                                                                                    sourceCurrencyCode,
                                                                                    _taxAmount - _chargeAmount - loadOnInventry,
                                                                                    _exchRateHelper);

                        // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                        if (_taxTrans)
                        {
                            // TaxTrans will not exist in the case where a transaction is only being validated,
                            // and in that case the tax trans relationship should not be created
                            ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
                        }
                        ledgerVoucherTransObject.parmAccountingCurrencyAmount(amountMST);
                        ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                        _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxSalesInvoice_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts tax sales invoice.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller.
    /// </param>
    /// <param name="_taxTrans">
    /// The tax transaction.
    /// </param>
    /// <param name="_taxAmount">
    /// The tax amount.
    /// </param>
    /// <param name="_chargeAmount">
    /// The charge amount.
    /// </param>
    /// <param name="_exchRateHelper">
    /// The exchange rate helper.
    /// </param>
    /// <param name="_ledgerDetailLevel">
    /// The ledger detail level.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The ledger dimension.
    /// </param>
    protected void postTaxSalesInvoice_IN(
        LedgerPostingController _ledgerPostingController,
        TaxTrans               _taxTrans,
        TaxAmount              _taxAmount,
        TaxAmount              _chargeAmount,
        CurrencyExchangeHelper _exchRateHelper,
        LedgerDetailLevel      _ledgerDetailLevel = LedgerDetailLevel::AsDefault,
        LedgerDimensionAccount _ledgerDimension   = 0)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject;
        AmountMST               amountMST;
        CustomsExchangeRate_IN  customsExchRate;
        LedgerDimensionAccount          ledgerDimension;

        ledgerDimension = _ledgerDimension;

        if (this.isPostOutGoingTax(_taxTrans))
        {
            if (isTaxParametersEnabled)
            {
                if ((taxWorkTrans.SourceTaxAmountCur || taxWorkTrans.SourceRegulateAmountCur)
                    && isCustomsEnabled
                    && TaxTable::find(taxWorkTrans.TaxCode).TaxType_IN == TaxType_IN::Customs)
                {
                    customsExchRate = TaxExchangeRateHelper::getCustomsExchangeRate_IN(
                                                    taxWorkTrans.SourceCurrencyCode,
                                                    Direction_IN::Export,
                                                    taxWorkTrans.TransDate);
                    amountMST       = CurrencyExchangeHelper::amount((_taxAmount - _chargeAmount) * customsExchRate / 100);

                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                                _ledgerPostingController.getReference(),
                                                                                taxPostingType,
                                                                                customsImportExportLedgerDimension ? customsImportExportLedgerDimension : ledgerDimension,
                                                                                sourceCurrencyCode,
                                                                                _taxAmount - _chargeAmount,
                                                                                _exchRateHelper);
                    // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                    if (_taxTrans)
                    {
                        // TaxTrans will not exist in the case where a transaction is only being validated,
                        // and in that case the tax trans relationship should not be created
                        ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
                    }

                    ledgerVoucherTransObject.parmAccountingCurrencyAmount(amountMST);
                    ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }
                else
                {
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                                 _ledgerPostingController.getReference(),
                                                                                taxPostingType,
                                                                                taxWorkTrans.LedgerDimension,
                                                                                sourceCurrencyCode,
                                                                                _taxAmount - _chargeAmount,
                                                                                _exchRateHelper);

                    // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                    if (_taxTrans)
                    {
                        // TaxTrans will not exist in the case where a transaction is only being validated,
                        // and in that case the tax trans relationship should not be created
                        ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
                    }

                    ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postToLedgerCustomsEximTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts to the Customs/Exim transactions to Ledger.
    /// </summary>
    /// <param name="_taxTrans">
    ///    Transaction line being posted.
    /// </param>
    /// <param name="_taxAmountCur">
    ///    Tax amount to be posted.
    /// </param>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_taxInCostPrice">
    ///    TaxinCostPrice Amount.
    /// </param>
    /// <param name="_exchangeRateHelper">
    ///    The <c>CurrencyExchHelper</c> instance for the <c>TaxTrans</c> record being posted.
    /// </param>
    public void postToLedgerCustomsEximTrans_IN(
        TaxTrans                _taxTrans,
        TaxAmountCur            _taxAmountCur,
        LedgerPostingController _ledgerPostingController,
        TaxAmountCur            _taxInCostPrice,
        CurrencyExchangeHelper  _exchangeRateHelper)
    {
        TaxUncommitted      taxUncommitted2Post;
        EximTaxTrans_IN     eximTaxTrans;
        TaxUncommitted_IN   taxUncommittedIN;
        boolean             isEximTaxCalculated;
        TaxTable            taxTableLoc;
        CurrencyExchangeHelper  exchangeRateHelperLoc;
        TransTaxInformation     transTaxInformation;
        exchangeRateHelperLoc = _exchangeRateHelper;

        taxTableLoc = TaxTable::find(_taxTrans.TaxCode);
        if (_taxTrans.taxTrans_W().TaxType_IN == TaxType_IN::Customs
            && this.validCustomsScenario_IN())
        {
            select firstonly taxUncommitted2Post
                where taxUncommitted2Post.TaxCode       == _taxTrans.TaxCode
                    && taxUncommitted2Post.SourceTableId == _taxTrans.SourceTableId
                    && taxUncommitted2Post.SourceRecId   == _taxTrans.SourceRecId
                join EximBalanceTaxCorrectedAmountCur, EximBalanceTaxAmountCur, EximTaxAmountCur, EximTaxCorrectedAmountCur,
                     EximIncentiveScheme, CustomsDuty, RecId
                    from taxUncommittedIN
                    where taxUncommittedIN.TaxUncommitted == taxUncommitted2Post.RecId;

            exchangeRateHelperLoc.parmExchangeRate1(
                                    TaxExchangeRateHelper::getCustomsExchangeRate_IN(
                                                                taxUncommitted2Post ? taxUncommitted2Post.SourceCurrencyCode : taxWorkTrans.SourceCurrencyCode,
                                                                CurrencyHelper_IN::taxDirection2CustomsDirection_New_IN(taxUncommitted2Post ? taxUncommitted2Post.TaxDirection : taxWorkTrans.TaxDirection),
                                                                exchangeRateHelperLoc.parmExchangeDate()));

            transTaxInformation = transTaxInformationHelper.getTransTaxInformationByRecord(ledgerJournalTransLoc);

            if (_taxAmountCur)
            {
                if (ledgerJournalTransLoc
                    && this is TaxPostJournal
                    && taxUncommitted2Post.Source == TaxModuleType::Voucher
                    && taxUncommitted2Post.SourceTableId == ledgerJournalTransLoc.TableId
                    && taxUncommitted2Post.SourceRecId == ledgerJournalTransLoc.RecId
                    && transTaxInformation.CustomsTariffDirection == Direction_IN::Import
                    && transTaxInformation.CustomsTariffCode)
                {
                    // Customs duty ExpenseVoucher Voucher is posted here.
                    this.post(_ledgerPostingController,// Case a)
                                _taxTrans,
                                _taxAmountCur,
                                _taxInCostPrice,
                                exchangeRateHelperLoc,
                                taxUncommitted2Post.RecId
                                    ? taxUncommitted2Post.OperationLedgerDimension//LedgerDimension
                                    : taxWorkTrans.OperationLedgerDimension,//LedgerDimension,
                                0,
                                0);
                }
                else
                {
                    // Customs duty ExpenseVoucher Voucher is posted here.
                    this.post(_ledgerPostingController,// Case a)
                                _taxTrans,
                                _taxAmountCur,
                                _taxInCostPrice,
                                exchangeRateHelperLoc,
                                taxUncommitted2Post.RecId
                                    ? taxUncommitted2Post.LedgerDimension
                                    : taxWorkTrans.LedgerDimension,
                                0,
                                0);
                }
                if (taxUncommittedIN.EximIncentiveScheme == EximIncentiveScheme_IN::None
                    && (taxUncommitted2Post.Source       == TaxModuleType::Purch
                    ||  taxUncommitted2Post.Source       == TaxModuleType::PurchInvoice))
                {
                    taxUncommittedIN.CustomsDuty = - taxUncommittedIN.CustomsDuty;
                }
                customsImportExportLedgerDimension = taxUncommitted2Post.LedgerDimension_IN;
                // Customs duty PayableVoucher Voucher is posted here. Stop posting the Apply excise deffered A/C
                // It already happened in postApplyExciseTaxCodes_IN(..) with proper splits.
                if (!isApplyExciseForDeffered)
                {
                    this.post(_ledgerPostingController,
                              _taxTrans,
                              -_taxAmountCur,
                              0,
                              exchangeRateHelperLoc,
                              taxUncommitted2Post.RecId
                                ? taxUncommitted2Post.LedgerDimension_IN
                                : taxWorkTrans.LedgerDimension_IN,
                              0,
                              0);
                    //Voucher Imbalance was due to ,excise posting using the customs exchange rate. Excise should post using normal exchange rate,
                    //but since it was taking the customs import exchange rate, there was a Voucher imbalance error.
                    //Even though the  exchangeRateHelperLoc is a local variable it sets the class variable "exchRate" of the  ExchangeRateHelper class.
                    // So after posting the custom taxes using the customs exchange rate , we are resetting the exchangeRateHelperLoc to normal exchange rate.
                    exchangeRateHelperLoc.parmExchangeRate1(this.exchRate());
                }
                customsImportExportLedgerDimension = 0;

                if ((taxWorkTrans.EximIncentiveScheme_IN != EximIncentiveScheme_IN::None)
                    &&
                        (EximParameters_IN::checkParameters()
                            || EximParameters_IN::checkDEPBParameters()
                            || EximParameters_IN::checkEPCGParameters()))
                {
                    eximTaxTrans.IncentiveScheme           = taxWorkTrans.EximIncentiveScheme_IN;
                    eximTaxTrans.TaxAmount                 = taxWorkTrans.EximTaxAmount_IN;
                    eximTaxTrans.BalanceTaxAmount          = taxWorkTrans.EximBalanceTaxAmount_IN;
                    eximTaxTrans.AuthorizationId           = taxWorkTrans.EximAuthorizationId_IN;
                    eximTaxTrans.depbAmount                = taxWorkTrans.EximDEPBAmount_IN;
                    eximTaxTrans.depbAmountCur             = taxWorkTrans.EximDEPBAmountCur_IN;
                    eximTaxTrans.TaxCorrectedAmount        = taxWorkTrans.EximTaxCorrectedAmount_IN;
                    eximTaxTrans.BalanceTaxCorrectedAmount = taxWorkTrans.EximBalanceTaxCorrectedAmount_IN;
                    eximTaxTrans.AssessableValue = taxWorkTrans.displayCustomsAssessableValue_IN();
                    eximTaxTrans.TaxTransRecId   = _taxTrans.RecId;
                    eximTaxTrans.insert();
                }

                // Posting:- a)Customs Expense Account is reversed(creditted for apply excise),
                // b)Excise Recoverable/Deffered A/C(Apply Excise) as the case may be.
                if (isExciseEnabled
                    && (_taxTrans.Source == TaxModuleType::Purch
                    || _taxTrans.Source  == TaxModuleType::PurchInvoice || _taxTrans.Source  == TaxModuleType::Voucher)
                    && TaxComponentTable_IN::isApplyExciseMarked_IN(taxUncommitted2Post.TaxCode)
                    && !isEximTaxCalculated
                    && _taxTrans.TaxDirection == TaxDirection::IncomingTax
                    )
                {
                    salesPurchJournalLineLoc = this.getSalePurchJourLineFrmTaxUnCommitted_IN(taxUncommitted2Post);
                    // Customs duty ExpenseVoucher Voucher is replaced by Excise recoverable here, for Apply Excise.
                    this.postApplyExciseTaxCodes_IN(_ledgerPostingController,// Case b)
                                                    _taxTrans,
                                                    _taxAmountCur,
                                                    _taxInCostPrice,
                                                    exchangeRateHelperLoc,
                                                    LedgerDetailLevel::AsDefault,
                                                    taxUncommitted2Post
                                                   );
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postVoucherForContinuousHU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adds the voucher object for the additional Hungarian transactions.
    /// If "Subscription" is checked, Hungary requires that
    /// two additional tax transactions be added on the VAT due date
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledgerPostingController to which the voucher is being added
    /// </param>
    /// <param name="_lastVoucher">
    /// Original voucher value for transaction on the "transDate".
    /// Voucher has to point to original voucher value
    /// </param>
    /// <param name="_lastTransDate">
    /// Voucher has to point to transaction date
    /// </param>
    public void postVoucherForContinuousHU(LedgerPostingController _ledgerPostingController, Voucher _lastVoucher, TransDate _lastTransDate)
    {
        LedgerVoucher       ledgerVoucherHungary;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU]) && !initializeContinuousHU)
        {
            ledgerVoucherHungary = _ledgerPostingController.getJournal();
            ledgerVoucherHungary.addVoucher(ledgerContinuousVoucherObject);
            ledgerVoucherHungary.lastTransDate(_lastTransDate);
            ledgerVoucherHungary.lastVoucher(_lastVoucher);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prePaymentIsTaxable_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to check the pre payment of tax.
    /// </summary>
    /// <param name="_ledgerJournalTransLoc">
    /// A buffer of <c>LedgerJournalTrans</c> table.
    /// </param>
    /// <returns>
    /// Returns true if LedgerJournalACType if of type Cust or vend.
    /// </returns>
    boolean prePaymentIsTaxable_IN(LedgerJournalTrans  _ledgerJournalTransLoc)
    {
        switch (_ledgerJournalTransLoc.AccountType)
        {
            case LedgerJournalACType::Cust:
                return _ledgerJournalTransLoc.Prepayment && CustParameters::find().TaxOnPrepayment;

            case LedgerJournalACType::Vend:
                return _ledgerJournalTransLoc.Prepayment && VendParameters::find().TaxOnPrepayment;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processExemptTax_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows whether to perform the calculation of the exempt tax codes.
    /// </summary>
    /// <returns>
    ///    always false.
    /// </returns>
    protected boolean processExemptTax_RU()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTaxExchangeRateDifferenceAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Processes the tax difference amount.
    /// </summary>
    /// <param name="_originalTaxTrans">
    ///     The original tax transaction.
    /// </param>
    /// <param name="_ledgerPostingController">
    ///     The <c>LedgerPostingController</c> instance.
    /// </param>
    /// <param name="_exchangeRateHelper">
    ///     The <c>CurrencyExchangeHelper</c> instance.
    /// </param>
    /// <param name="_originalLedgerDimension">
    ///     The original ledger dimension.
    /// </param>
    /// <param name="_exchangeRateTaxBaseAmount">
    ///     The exchange rate base tax amount.
    /// </param>
    /// <param name="_exchangeRateSourceBaseAmountRegulated">
    ///     The exchange rate source base tax amount.
    /// </param>
    /// <param name="_exchangeRateTaxAmount">
    ///     The exchange rate tax amount.
    /// </param>
    /// <param name="_exchangeRateSourceRegulateAmount">
    ///     The exchange rate source tax amount.
    /// </param>
    protected void processTaxExchangeRateDifferenceAmount(
        TaxTrans                _originalTaxTrans,
        LedgerPostingController _ledgerPostingController,
        CurrencyExchangeHelper  _exchangeRateHelper,
        LedgerDimensionAccount  _originalLedgerDimension,
        TaxBase                 _exchangeRateTaxBaseAmount,
        TaxBase                 _exchangeRateSourceBaseAmountRegulated,
        TaxAmount               _exchangeRateTaxAmount,
        TaxAmount               _exchangeRateSourceRegulateAmount)
    {
        TaxTrans    taxTransExchangeRateDifference;

        taxTransExchangeRateDifference = this.saveTaxExchangeRateDifferenceAmount(
            _exchangeRateSourceBaseAmountRegulated,
            _exchangeRateTaxBaseAmount,
            _exchangeRateSourceRegulateAmount,
            _exchangeRateTaxAmount,
            _originalTaxTrans);

        if (taxTransExchangeRateDifference)
        {
            this.postSalesTaxExchangeRateDifferenceAmount(
                _ledgerPostingController,
                _exchangeRateHelper,
                taxTransExchangeRateDifference,
                _originalLedgerDimension);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTaxSpecificExchangeRateDifferenceAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the VAT specific exchange rate tax transactions.
    /// </summary>
    /// <param name = "_originalTaxTrans">The origin tax transaction.</param>
    /// <param name = "_ledgerPostingController">The <c>LedgerPostingController</c> instance.</param>
    /// <param name = "_exchangeRateHelper">The <c>CurrencyExchangeHelper</c> instance.</param>
    /// <param name = "_originalLedgerDimension">The original ledger dimension.</param>
    /// <param name = "_taxSepcificExchangeRateAmountParameters">The tax specific exchange rate amount parameters.</param>
    internal void processTaxSpecificExchangeRateDifferenceAmount(
        TaxTrans _originalTaxTrans,
        LedgerPostingController _ledgerPostingController,
        CurrencyExchangeHelper _exchangeRateHelper,
        LedgerDimensionAccount _originalLedgerDimension,
        TaxSepcificExchangeRateAmountParameters _taxSepcificExchangeRateAmountParameters)
    {
        TaxTrans taxTransExchangeRateDifference = this.saveTaxSpecificExchangeRateDifferenceAmount(
            _taxSepcificExchangeRateAmountParameters,
            _originalTaxTrans);

        if (taxTransExchangeRateDifference)
        {
            this.postSalesTaxExchangeRateDifferenceAmount(
                _ledgerPostingController,
                _exchangeRateHelper,
                taxTransExchangeRateDifference,
                _originalLedgerDimension);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchCalcTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the instance of <c>PurchCalcTax</c>.
    /// </summary>
    /// <param name = "_purchCalcTax">The instance of <c>PurchCalcTax</c>.</param>
    /// <returns>The instance of <c>PurchCalcTax</c>.</returns>
    public PurchCalcTax purchCalcTax(PurchCalcTax _purchCalcTax = null)
    {
        throw error(strFmt("@SYS19306",funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>purgeInternalStructure</Name>
				<Source><![CDATA[
    /// <summary>
    /// Purges the internal structure.
    /// </summary>
    protected void purgeInternalStructure()
    {
        taxAmountCalc       = 0;
        taxAmountCalcCur    = 0;
        taxBaseAmountCalc   = 0;
        taxBaseQtyCalc      = 0;
        taxInCostPriceCalc  = 0;
        tmpTax = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeInvalidTaxCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Prevents any tax codes from being calculated in various scenarios, which are considered invalid.
    /// </summary>
    /// <param name="_taxWorkTrans">
    ///    The <c>TmpTaxWorkTrans</c> record to be checked.
    /// </param>
    /// <returns>
    ///    true if the tax code is invalid; otherwise, false.
    /// </returns>
    private boolean removeInvalidTaxCode(TmpTaxWorkTrans _taxWorkTrans)
    {
        TaxTable        taxTable;
        boolean         removeTaxCode;
        TmpTaxWorkTrans tmptaxWorkTransLocal;

        tmptaxWorkTransLocal.setTmpData(_taxWorkTrans);

        removeTaxCode=false;

        if (!removeTaxCode &&

            !TaxData::existCodeAndDate(_taxWorkTrans.TaxCode, _taxWorkTrans.CalculationDate))
        {
            removeTaxCode = true;
        }

        if (!removeTaxCode)
        {
            taxTable = this.getTaxTable(_taxWorkTrans.TaxCode);
            if (taxTable.TaxBase == TaxBaseType::PctPerTax &&

                taxTable.TaxOnTax)
            {
                select tmptaxWorkTransLocal
                where tmptaxWorkTransLocal.TaxCode == taxTable.TaxOnTax;
                if (!tmptaxWorkTransLocal)
                {
                    removeTaxCode = true;
                }
            }

            if ((taxTable.TaxBase == TaxBaseType::AmountByUnit) &&

                    (!this.supportAmountByUnit()))
            {
                removeTaxCode = true;
            }
        }

        return removeTaxCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseChargeAmount_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns amount of reverse charge being posted.
    /// </summary>
    /// <returns>
    ///   Amount of tax reverse charge in transactional currency.
    /// </returns>
    public TaxAmountCur reverseChargeAmount_W()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundTaxOnTaxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rounds the tax amount on tax group.
    /// </summary>
    /// <returns>The round tax amount.</returns>
    protected TaxAmountCur roundTaxOnTaxGroup()
    {
        TaxGroupHeading         taxGroupHeading;
        TmpTaxWorkTrans         trans;
        TaxGroup                taxGroup;
        TaxCodeCombinationId    taxCodeCombinationId;
        TaxAmountCur            taxAmountCur;
        TaxAmountCur            taxAmountCurReal;
        TaxAmountCur            totalTaxDiffCur;
        TaxAmountCur            taxDiffCur;
        TaxTable                taxTable;
        Map                     taxGroupRounding;
        boolean                 roundOnCombinations;

        // cache the setting from TaxGroupHeading which controls rounding on
        // tax group combinations.
        taxGroupRounding = new Map(Types::String, Types::Integer);

        totalTaxDiffCur = 0;
        trans.setTmpData(taxWorkTrans);

        // Round tax on tax code combinations.
        // The records is ordered by sourceRecId to get the total tax for each line
        // as close as possible to the total calculated for that line.

        taxGroup                = '';
        taxCodeCombinationId    = 0;

        while select RecId, SourceTaxAmountCur, SourceTaxAmountCurReal, CurrencyCode

            from trans
            order by TaxGroup, TaxCodeCombinationId, SourceTableId, SourceRecId, TaxCode
            where trans.TaxOrigin    != TaxOrigin::TaxReversed &&
                  trans.TaxGroup     != ''
        {
            // only round on tax group combinations if the Tax Group is configured to allow for it.
            if (taxGroupRounding.exists(trans.TaxGroup))
            {
                roundOnCombinations = taxGroupRounding.lookup(trans.TaxGroup) == 1;
            }
            else
            {
                taxGroupHeading = TaxGroupHeading::find(trans.TaxGroup);
                roundOnCombinations = taxGroupHeading.TaxGroupRounding == TaxGroupRounding::TaxCodeSet;
                taxGroupRounding.insert(trans.TaxGroup, roundOnCombinations);
            }

            if (roundOnCombinations)
            {
                if (taxGroup != trans.TaxGroup || taxCodeCombinationId != trans.TaxCodeCombinationId)
                {
                    taxAmountCur            = 0;
                    taxAmountCurReal        = 0;
                    taxGroup                = trans.TaxGroup;
                    taxCodeCombinationId    = trans.TaxCodeCombinationId;
                }
                if (!trans.TaxLimitReached)
                {
                    taxAmountCur        += trans.SourceTaxAmountCur;
                    taxAmountCurReal    += trans.SourceTaxAmountCurReal;
                    taxTable             = TaxTable::find(trans.TaxCode);

                    if (!taxTable.TaxCurrencyCode ||

                        taxTable.TaxCurrencyCode == trans.CurrencyCode)
                    {
                        taxDiffCur           = taxAmountCur - taxTable.roundedOffTax(taxAmountCurReal);
                    }
                    else
                    {
                        taxDiffCur           = taxAmountCur - CurrencyExchangeHelper::amount(taxAmountCurReal, trans.CurrencyCode);
                    }
                    totalTaxDiffCur     += this.adjustRoundingDiff(taxDiffCur, trans.RecId);
                    taxAmountCur        -= taxDiffCur;
                }
            }
        }

        return totalTaxDiffCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundTaxOnTaxGroupInternal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rounds the tax amount on tax group.
    /// </summary>
    /// <returns>The round tax amount.</returns>
    internal TaxAmountCur roundTaxOnTaxGroupInternal()
    {
        return this.roundTaxOnTaxGroup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves and posts the tax transaction.
    /// </summary>
    /// <param name = "_ledgerPostingController">The instance of <c>LedgerPostingController</c>.</param>
    public void saveAndPost(LedgerPostingController _ledgerPostingController)
    {
        TaxTrans            taxTrans;
        TaxAmountCur        taxAmountCur;
        TaxAmountCur        taxInCostPrice;
        boolean             vatBookEnabled;
        CurrencyExchangeHelper  exchangeRateHelper;
        RecordInsertList        insertList;
        TaxTable                taxTable;
        List                    codesList = new List(Types::String);

        // <GIN>
        TaxTrans                            taxTransOffset;
        SalesPurchJournalLine               salesPurchJournalLine;
        TaxTable                            taxTableLoc;
        InventTransferLine                  inventTransferLine;
        InventTransId                       inventTransId = '';
        DimensionDefault                    dimensionDefault;
        InventTransferTable                 inventTransferTable;
        TaxAmountCur                        deferredtaxAmountCur;
        SalesLine_IN                        salesLine_IN;
        TaxTrans_W                          taxTrans_W;
        taxTrans_W                          taxTransOffset_W;
        TransTaxInformation                 transTaxInformation;
        TransTaxInformation                 toTransTaxInformation;
        // </GIN>

        #ISOCountryRegionCodes
        // <GEERU>
        boolean                             countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        boolean                             usePostingLog    = CustVendTransPostingLog_RU::usePostingLog();
        // </GEERU>
        // <GEECZ>
        boolean                             countryRegion_CZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]);
        // </GEECZ>

        ExchRate                            localExchRate;

        if (usePostingLog)
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceEEU00029, funcName());
        }

        this.calcTaxableDocumentLineCount();

        TaxEventSource taxEventSourceLog = TaxEventSource::Log;
        guid identifier = newGuid();
        taxEventSourceLog.PostTaxStart(identifier);

        System.Diagnostics.Stopwatch stopWatch = new System.Diagnostics.Stopwatch();
        stopWatch.Start();

        insertList = new RecordInsertList(taxSourceLineSummaryTmp.TableId, false, false, false, false, true, taxSourceLineSummaryTmp);

        vatBookEnabled = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT]);
        this.validateForPost();

        exchangeRateHelper = CurrencyExchangeHelper::newLedger(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));
        exchangeRateHelper.parmExchangeRate1(this.exchRate());
        exchangeRateHelper.parmExchangeRate2(this.exchRateSecondary());

        ExchRate exchRateReporting = this.reportingCurrencyExchangeRate();

        if(exchRateReporting)
        {
            exchangeRateHelper.parmReportingExchangeRate1(exchRateReporting);
        }

        // <GIN>
        if (isTaxParametersEnabled)
        {
            tmpTaxWorkTransLoc.setTmpData(taxworkTrans);
        }
        if (isServiceTaxEnabled)
        {
            this.serviceTaxPOTAdvanceVoucher_IN();
        }
        // </GIN>

        ttsbegin;

        // <GIN>
        // Comment sys code to add the order by for india.
        // The sys behavior should be kept as orignal.
        if (isIndiaCountryRegionEnabled)
        {
            select *

            from taxworkTrans
            order by SourceRecId, IsScrapQtyLine_IN
            where taxworkTrans.HeadingRecId  == this.headingRecId() &&
                  (taxworkTrans.TaxOrigin     != TaxOrigin::TaxReversed ||
                  this.allowPostingOfReversals()) &&
                  taxworkTrans.IsDeleted      == NoYes::No;
        }
        else
        {
            select *
            from taxworkTrans
            order by taxWorkTrans.SourceRecId
            where taxworkTrans.HeadingRecId  == this.headingRecId() &&
                  (taxworkTrans.TaxOrigin     != TaxOrigin::TaxReversed ||
                  this.allowPostingOfReversals()) &&
                  taxworkTrans.IsDeleted      == NoYes::No;
        }
        // </GIN>

        while (taxWorkTrans)
        {
            if (this.isPostTaxAmount(taxWorkTrans))
            {
                this.validateWarningsForPost(taxworkTrans.Warning, taxworkTrans.TaxCode, false);

                if (taxSourceLineSummaryTmp.SourceRecId != taxWorkTrans.SourceRecId)
                {
                    taxSourceLineSummaryTmp.PrintCode = strList2str(codesList, ', ');
                    if (taxSourceLineSummaryTmp.PrintCode)
                    {
                        insertList.add(taxSourceLineSummaryTmp);
                    }

                    taxSourceLineSummaryTmp.SourceRecId = taxWorkTrans.SourceRecId;
                    taxSourceLineSummaryTmp.SourceTableId = taxWorkTrans.SourceTableId;
                    taxSourceLineSummaryTmp.ActualTransactionTaxAmount = 0;

                    // <GBR>
                    taxSourceLineSummaryTmp.TaxBaseAmountOther_BR = 0;
                    // </GBR>

                    codesList = new List(Types::String);
                }

                // <GEEHU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU]))
                {
                    codesList.addEnd(TaxData::find(taxWorkTrans.TaxCode, taxWorkTrans.TransDate, taxWorkTrans.TaxBaseAmountCur).PrintCode);
                }
                else
                {
                    // </GEEHU>
                    taxTable = taxTable::find(taxWorkTrans.TaxCode);
                    if (taxTable.PrintCode)
                    {
                        codesList.addEnd(taxTable.PrintCode);
                    }

                    taxSourceLineSummaryTmp.ActualTransactionTaxAmount += taxWorkTrans.SourceRegulateAmountCur;

                    // <GBR>
                    if (BrazilParameters::isEnabled())
                    {
                        TaxSourceLineSummaryTmp.TaxBaseAmountOther_BR += taxWorkTrans.SourceOtherBaseTaxAmount_BR;
                    }
                    // </GBR>

                    // <GEEHU>
                }
                // </GEEHU>

                taxTrans.clear();
                // <GIN>
                if (isTaxParametersEnabled)
                {
                    deferredInvAcc    = 0;
                    taxTableLoc = TaxTable::find(taxworkTrans.TaxCode);
                    dimensionDefault = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(taxworkTrans.LedgerDimension);

                    if (this.checkTaxTypeExcluded(taxTableLoc.TaxType_IN))
                    {
                        next taxWorkTrans;
                        continue;
                    }
                }
                // </GIN>

                this.initFromTaxWorkTrans(taxTrans, taxworkTrans, this.taxOrigin(taxworkTrans.TaxOrigin));

                if (taxRegulationExist)  // why override the setting from initFromTaxWorkTrans() above?
                                        taxTrans.TaxAutogenerated = NoYes::No; // likely needs to be left at taxWorkTrans.TaxAutogenerated
                taxTrans.euroTriangulation = triangulation;
                taxTrans.Voucher           = voucher;
                taxTrans.JournalNum        = this.journalNum();
                if (!taxTrans.TaxAutogenerated)
                {
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        if (taxTrans.SourceRegulateAmountCur)
                        {
                            taxAmountCur = taxTrans.SourceRegulateAmountCur;
                            taxInCostPrice = taxTrans.TaxInCostPriceRegulated;
                            this.taxAmountRegulation(taxTrans,

                                                        taxTrans.SourceRegulateAmountCur,
                                                        this.exchRate(),
                                                        this.exchRateSecondary());
                            this.taxInCostPriceReporting(taxTrans,
                                                        taxTrans.TaxInCostPriceRegulated,
                                                        this.exchRate(),
                                                        this.exchRateSecondary());
                        }
                    }
                    else
                    {
                        // </GEERU>
                        taxAmountCur = taxTrans.SourceRegulateAmountCur;
                        taxInCostPrice = taxTrans.TaxInCostPriceRegulated;
                        this.taxAmountRegulation(taxTrans,

                                             taxTrans.SourceRegulateAmountCur,
                                             this.exchRate(),
                                             this.exchRateSecondary());
                        this.taxInCostPriceReporting(taxTrans,

                                                 taxTrans.TaxInCostPriceRegulated,
                                                 this.exchRate(),
                                                 this.exchRateSecondary());
                        // <GEERU>
                    }
                    // </GEERU>
                    // <GIN>
                    if (taxworkTrans.IsScrapQtyLine_IN)
                    {
                        taxTrans.TaxAmount    = - taxTrans.TaxAmount;
                        taxTrans.TaxAmountCur = - taxTrans.TaxAmountCur;
                    }
                    // </GIN>
                }
                else
                {
                    taxAmountCur           = taxTrans.SourceTaxAmountCur;
                    taxInCostPrice         = taxTrans.TaxInCostPrice;
                }

                // <GIN>
                if (isTaxParametersEnabled)
                {
                    if (taxTableLoc.TaxType_IN != TaxType_IN::None)
                    {
                        abatementAmount             = taxworkTrans.AbatementAmount_IN;
                        salesPurchJournalLine       = this.getSalesPurchJournalLineFromInventId_IN();
                        taxTrans.TaxValue           = taxworkTrans.showTaxValue_IN(salesPurchJournalLine);
                        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
                        {
                            taxTrans_W = taxTrans.taxTrans_W();
                            taxTrans_W.TaxComponentTable_IN    = taxTableLoc.TaxComponentTable_IN;
                            taxTrans.packTaxTrans_W(taxTrans_W);
                        }
                    }
                }

                if (isServiceTaxEnabled
                    && taxTableLoc.TaxType_IN == TaxType_IN::ServiceTax)
                {
                    salesLine_IN.SysExtensionSerializerExtensionMap::loadByBase(salesPurchJournalLine.SourceRecId);

                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
                    {
                        SalesLine salesLine = SalesLine::findRecId(salesLine_IN.SalesLine);

                        transTaxInformation = transTaxInformationHelper.getTransTaxInformationByRecord(salesLine);

                        taxTrans_W = taxTrans.taxTrans_W();
                        taxTrans_W.TaxRegistrationNumberTable_IN = transTaxInformation.ServiceTaxRegistrationNumber;
                        taxTrans.packTaxTrans_W(taxTrans_W);
                    }
                }

                if (isTaxParametersEnabled)
                {
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
                    {
                        transTaxInformation = transTaxInformationHelper.getTransTaxInformation(salesPurchJournalLine.SourceTableId, salesPurchJournalLine.SourceRecId);
                    }

                    if (salesPurchJournalLine.TableId == tableNum(InventTransferLine))
                    {
                        inventTransferLine = InventTransferLine::findRecId(salesPurchJournalLine.SourceRecId);
                        inventTransferTable = InventTransferTable::find(inventTransferLine.TransferId);
                        if (inventTransferUpdateType == InventTransferUpdateType::Receive)
                        {
                            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
                            {
                                toTransTaxInformation = transTaxInformationHelper.getTransTaxInformation(salesPurchJournalLine.SourceTableId, salesPurchJournalLine.SourceRecId, TransTaxInformationType_IN::InventTransferTo);

                                taxTrans_W = taxTrans.taxTrans_W();
                                taxTrans_W.TaxRegistrationNumberTable_IN = TaxInformation_IN::find(toTransTaxInformation.TaxInformation).getTaxRegistrationNumbersTable(taxTableLoc.TaxType_IN, toTransTaxInformation.ExciseType).RecId;
                                taxTrans.packTaxTrans_W(taxTrans_W);
                            }
                        }
                        else
                        {
                            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
                            {
                                taxTrans_W = taxTrans.taxTrans_W();
                                taxTrans_W.TaxRegistrationNumberTable_IN = TaxInformation_IN::find(transTaxInformation.TaxInformation).getTaxRegistrationNumbersTable(taxTableLoc.TaxType_IN, transTaxInformation.ExciseType).RecId;
                                taxTrans.packTaxTrans_W(taxTrans_W);
                            }
                        }
                    }

                    // <GIN>
                    else if (salesPurchJournalLine.SourceTableId == tableNum(ProjEmplTrans)

                            || salesPurchJournalLine.SourceTableId == tableNum(ProjRevenueTrans)
                            || salesPurchJournalLine.SourceTableId == tableNum(MarkupTrans))
                    {
                        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
                        {
                            taxTrans_W = taxTrans.taxTrans_W();
                            taxTrans_W.TaxRegistrationNumberTable_IN = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTableLoc.TaxType_IN).RecId;
                            taxTrans.packTaxTrans_W(taxTrans_W);
                        }
                    }
                    // </GIN>

                    else
                    {
                        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
                        {
                            taxTrans_W = taxTrans.taxTrans_W();
                            taxTrans_W.TaxRegistrationNumberTable_IN = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTableLoc.TaxType_IN).RecId;
                            taxTrans.packTaxTrans_W(taxTrans_W);
                        }
                    }

                    if (taxModuleType == TaxModuleType::StockTransfer_IN)
                    {
                        taxTrans.Voucher = voucher;
                    }

                    this.getPostingType_IN(taxTableLoc.TaxType_IN);
                }

                // </GIN>

                this.initTaxTrans(taxTrans, _ledgerPostingController.getJournal().parmVoucherSeriesCode());
                // <GIN>

                if (isTaxParametersEnabled)
                {
                    taxTrans_W = taxTrans.taxTrans_W();
                    this.getPostingType_IN(taxTrans_W.TaxType_IN);
                }
                // </GIN>

                // <GMY>
                TaxGSTTaxInformation_MY::createGAFInformation(taxTrans);
                // </GMY>

                taxTrans.insert();
                // <GEEU>
                if (usePostingLog)
                {
                    this.afterTaxTransInserted_RU(taxTrans);
                }
                // </GEEU>

                // <GIN>
                if (isTaxParametersEnabled)
                {
                    if (taxModuleType == TaxModuleType::StockTransfer_IN)
                    {
                        select tmpTaxWorkTransLoc

                            where tmpTaxWorkTransLoc.TaxCode       == taxworkTrans.TaxCode
                               && tmpTaxWorkTransLoc.SourceRecId   == taxworkTrans.SourceRecId;

                        if (inventTransferUpdateType == InventTransferUpdateType::Shipment)
                        {
                            loadOnInventry = 0;
                        }

                        if (taxTableLoc.TaxType_IN == TaxType_IN::Excise)
                        {
                            excInvTaxAmtLoc +=  taxAmountCur;
                        }

                        if (taxTableLoc.TaxType_IN == TaxType_IN::SalesTax)
                        {
                            slsInvTaxAmtLoc += taxAmountCur;
                        }

                        if (taxTableLoc.TaxType_IN == TaxType_IN::VAT)
                        {
                            vatInvTaxAmtLoc += taxAmountCur;
                        }
                    }
                }

                if (isServiceTaxEnabled

                    && taxTableLoc.TaxType_IN == TaxType_IN::ServiceTax)
                {
                    select tmpTaxWorkTransLoc
                        where tmpTaxWorkTransLoc.TaxCode     == taxworkTrans.TaxCode
                           && tmpTaxWorkTransLoc.SourceRecId == taxworkTrans.SourceRecId;
                }
                // </GIN>

                if (this.canSaveAndPostTrans(taxWorkTrans, taxTrans, taxAmountCur, _ledgerPostingController))
                {
                    exchangeRateHelper.parmExchangeDate(taxTrans.TransDate);
                    if (taxAmountCur)
                    {
                        localExchRate = CurrencyExchange::calculateExchangeRate(taxAmountCur, taxTrans.TaxAmount);
                        exchangeRateHelper.parmExchangeRate1(localExchRate);
                        exchangeRateHelper.parmExchangeRate2(0);
                    }

                    // <GIN>
                    if (isTaxParametersEnabled)
                    {
                        if (isCustomsEnabled

                            && taxTrans.taxTrans_W().TaxType_IN == TaxType_IN::Customs)
                        {
                            this.postToLedgerCustomsEximTrans_IN(taxTrans, taxAmountCur, _ledgerPostingController, taxInCostPrice, exchangeRateHelper);
                        }
                        // posts the scrap Quantity taxes. scrap quantity taxes has different accounts to post.
                        else if (taxworkTrans.IsScrapQtyLine_IN)
                        {
                            this.post(_ledgerPostingController,
                                      taxTrans,
                                      taxAmountCur,
                                      0,
                                      exchangeRateHelper,
                                      taxworkTrans.LedgerDimension_IN,
                                      taxworkTrans.OperationLedgerDimension,
                                      taxworkTrans.TaxOffsetUseTaxLedgerDimension);

                            this.post(_ledgerPostingController,

                                      taxTrans,
                                      -taxAmountCur,
                                      0,
                                      exchangeRateHelper,
                                      taxworkTrans.LedgerDimension,
                                      taxworkTrans.OperationLedgerDimension,
                                      taxworkTrans.TaxOffsetUseTaxLedgerDimension);
                        }
                        else
                        {
                            if (isServiceTaxEnabled
                                && taxTableLoc.TaxType_IN == TaxType_IN::ServiceTax)
                            {
                                select tmpTaxWorkTransLoc

                                    where tmpTaxWorkTransLoc.TaxCode     == taxworkTrans.TaxCode
                                    && tmpTaxWorkTransLoc.SourceRecId == taxworkTrans.SourceRecId;

                                if (tmpTaxWorkTransLoc.LedgerDimension_IN

                                    && taxTableLoc.TaxType_IN == TaxType_IN::ServiceTax)
                                {
                                    taxTransOffset.data(taxTrans);
                                    taxTransOffset.TaxDirection                  = TaxDirection::OutgoingTax;
                                    taxTransOffset.TaxAmount                     = -taxTrans.TaxAmount;
                                    taxTransOffset.TaxAmountCur                  = -taxTrans.TaxAmountCur;
                                    taxTransOffset.TaxBaseAmount                 = -taxTrans.TaxBaseAmount;
                                    taxTransOffset.SourceBaseAmountCur           = -taxTrans.SourceBaseAmountCur;
                                    taxTransOffset.TaxBaseAmountCur              = -taxTrans.TaxBaseAmountCur;
                                    taxTransOffset.SourceTaxAmountCur            = -taxTrans.SourceTaxAmountCur;
                                    if ( SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
                                    {
                                        taxTransOffset_W = taxTransOffset.taxTrans_W();
                                        taxTransOffset_W.TaxRegistrationNumberTable_IN = taxTrans.taxTrans_W().TaxRegistrationNumberTable_IN;
                                        taxTransOffset.packTaxTrans_W(taxTransOffset_W);
                                    }

                                    if (taxTransOffset.TaxDirection  == TaxDirection::OutgoingTax)
                                    {
                                        taxTransOffset.TaxInCostPrice           = 0;
                                        taxTransOffset.TaxInCostPriceCur        = 0;
                                        taxTransOffset.TaxInCostPriceMST        = 0;
                                        taxTransOffset.TaxInCostPriceRegulated  = 0;
                                    }
                                    taxTransOffset.insert();
                                    this.insertTaxTrans_IN(taxTransOffset,salesPurchJournalLine);
                                }
                            }

                            if (taxTableLoc.TaxType_IN == TaxType_IN::Excise

                                && taxworkTrans.ClaimPercentage_IN
                                && inventTransferLine.RecId
                                && inventTransferUpdateType == InventTransferUpdateType::Receive
                                && taxworkTrans.TaxDirection == TaxDirection::IncomingTax)
                            {
                                deferredtaxAmountCur = taxAmountCur - (taxAmountCur * taxworkTrans.ClaimPercentage_IN / 100);
                                taxAmountCur         = taxAmountCur - deferredtaxAmountCur;

                                this.post(_ledgerPostingController,

                                          taxTrans,
                                          deferredtaxAmountCur,
                                          taxInCostPrice * (100 - taxWorkTrans.ClaimPercentage_IN) / 100,
                                          exchangeRateHelper,
                                          taxworkTrans.LedgerDimension_IN,
                                          taxworkTrans.OperationLedgerDimension,
                                          taxworkTrans.TaxOffsetUseTaxLedgerDimension);

                                this.post(_ledgerPostingController,

                                        taxTrans,
                                        taxAmountCur,
                                        taxInCostPrice * taxWorkTrans.ClaimPercentage_IN / 100,
                                        exchangeRateHelper,
                                        taxworkTrans.LedgerDimension,
                                        taxworkTrans.OperationLedgerDimension,
                                        taxworkTrans.TaxOffsetUseTaxLedgerDimension);
                            }
                            else
                            {
                                this.post(_ledgerPostingController,
                                        taxTrans,
                                        taxAmountCur,
                                        taxInCostPrice,
                                        exchangeRateHelper,
                                        taxworkTrans.LedgerDimension,
                                        taxworkTrans.OperationLedgerDimension,
                                        taxworkTrans.TaxOffsetUseTaxLedgerDimension);
                            }

                            if (this.canChargeBePostedByTax())
                            {
                                this.postCharge(

                                    _ledgerPostingController,
                                    taxTrans,
                                    taxInCostPrice,
                                    exchangeRateHelper,
                                    LedgerDimensionFacade::serviceCreateLedgerDimension(inventReceiptAcc, dimensionDefault));
                            }
                        }
                    }
                    else
                    {
                        // </GIN>
                        // <GEERU><GEECZ>
                        if ((countryRegion_RU || countryRegion_CZ) && this.getDefaultAmountMSTSecondaryToPost_RU(taxTrans))

                        // </GEECZ>
                        {
                            this.post(_ledgerPostingController, taxTrans, taxAmountCur, taxInCostPrice, exchangeRateHelper, taxworkTrans.LedgerDimension, taxworkTrans.OperationLedgerDimension, taxworkTrans.TaxOffsetUseTaxLedgerDimension,
                                      LedgerDetailLevel::AsDefault,
                                      null,
                                      taxTrans.taxTrans_RU().OffsetLedgerDimension_RU,
                                      this.getDefaultAmountMSTSecondaryToPost_RU(taxTrans)
                                     );
                        }
                        else
                        {
                            // </GEERU>
                            this.post(_ledgerPostingController, taxTrans, taxAmountCur, taxInCostPrice, exchangeRateHelper, taxworkTrans.LedgerDimension, taxworkTrans.OperationLedgerDimension, taxworkTrans.TaxOffsetUseTaxLedgerDimension);
                            // <GEERU>
                        }
                        // </GEERU>

                        if (this.canChargeBePostedByTax())
                        {
                            this.postCharge(_ledgerPostingController, taxTrans, taxTrans.TaxInCostPrice, exchangeRateHelper, taxworkTrans.OperationLedgerDimension);
                        }
                        // <GIN>
                    }
                    // </GIN>
                }
                // <GEERU>
                else if (countryRegion_RU)
                {
                    this.createOrphanLinkInsteadPost_RU(taxTrans,

                                                        taxworkTrans.LedgerDimension,
                                                        taxworkTrans.OperationLedgerDimension,
                                                        taxworkTrans.TaxOffsetUseTaxLedgerDimension);
                }
                // </GEERU>

                // <GIN>
                if (isTaxParametersEnabled)
                {
                    //default TaxTrans populating
                    if (taxTrans)
                    {
                        if (taxTableLoc.TaxType_IN != TaxType_IN::None)
                        {
                            this.insertTaxTrans_IN(taxTrans, salesPurchJournalLine,taxworkTrans.LedgerDimension);
                        }

                        if (taxTableLoc.TaxType_IN == TaxType_IN::Excise)
                        {
                            this.updateExciseRegister_IN(TaxTrans, salesPurchJournalLine);
                        }
                    }
                }
                // </GIN>

                // <GEEU>
                if (TaxSpecificExchangeRateHelper::isTaxSpecificExchRateEnabledByTable(this.headingTableId(), this.headingRecId()))
                {
                    TaxSepcificExchangeRateAmountParameters taxSepcificExchangeRateAmountParameters = TaxSepcificExchangeRateAmountParameters::construct(
                        taxWorkTrans.ExchangeRateTaxAmount,
                        taxWorkTrans.ExchangeRateTaxBaseAmount,
                        taxWorkTrans.ExchangeRateSourceRegulateAmount,
                        taxWorkTrans.ExchangeRateSourceBaseAmountRegulated,
                        taxWorkTrans.ExchangeRateTaxAmountRep,
                        taxWorkTrans.ExchangeRateTaxBaseAmountRep,
                        taxWorkTrans.ExchangeRateTaxAmountCur,
                        taxWorkTrans.ExchangeRateTaxBaseAmountCur,
                        taxWorkTrans.ExchangeRateRegulateAmountCur,
                        taxWorkTrans.ExchangeRateBaseAmountCurRegulated);

                    this.processTaxSpecificExchangeRateDifferenceAmount(
                        taxTrans,
                        _ledgerPostingController,
                        exchangeRateHelper,
                        taxworkTrans.LedgerDimension,
                        taxSepcificExchangeRateAmountParameters);
                }
                else if (this.parmUseTaxExchangeRate()
                    && this.parmAccountingCurrency() != this.getTransactionalCurrency())
                {
                    this.processTaxExchangeRateDifferenceAmount(taxTrans, _ledgerPostingController, exchangeRateHelper,
                        taxworkTrans.LedgerDimension, taxworkTrans.ExchangeRateTaxBaseAmount, taxworkTrans.ExchangeRateSourceBaseAmountRegulated,
                        taxworkTrans.ExchangeRateTaxAmount, taxworkTrans.ExchangeRateSourceRegulateAmount);
                }
                // </GEEU>
            }

            // <GIN>
            next taxWorkTrans;
            // </GIN>
        }

        if (taxSourceLineSummaryTmp.SourceRecId && taxSourceLineSummaryTmp.SourceTableId)
        {
            taxSourceLineSummaryTmp.PrintCode = strList2str(codesList, ', ');
            if (taxSourceLineSummaryTmp.PrintCode)
            {
                insertList.add(taxSourceLineSummaryTmp);
            }
        }

        insertList.insertDatabase();

        TaxCalculationAdjustment::deleteTaxRegulation(this);

        ttscommit;

        if (MultipleTaxIdReportingHelper::isLegalEntityOrTaxCodeInCountryRegion(
            taxTrans.TaxCode, [#isoIT], MultipleTaxIdScope::VATDeclaration))
        {
            info(strFmt("@SYS75076", taxTrans.Voucher));
        }

        stopWatch.Stop();

        taxEventSourceLog.PostTaxStop(identifier, SysCountryRegionCode::countryInfo(), stopWatch.ElapsedMilliseconds, tableId2Name(headingTableId), headingTableId, headingRecId, taxableDocumentLines);
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveInJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Called during the posting of a purchase order. This method is used to persist information from the
    ///    <c>TmpTaxWorkTrans</c> table to the <c>TaxJournalTrans</c> table.
    /// </summary>
    /// <param name="_transTableId">
    ///    The ID of the table associated with the <c>TaxJournalTrans</c> record.
    /// </param>
    /// <param name="_transRecId">
    ///    The ID of the record on the transaction table associated with the <c>TaxJournalTrans</c> record.
    /// </param>
    protected void saveInJournalTrans(TableId _transTableId, RecId _transRecId)
    {
        TaxJournalTrans taxJournalTrans;
        RecordInsertList taxJournalTransInsertList = new RecordInsertList(tableNum(TaxJournalTrans));

        // <GIN>
        TaxType_IN          taxType;
        // </GIN>

        // <GEEU>
        TaxJournalTransExchangeRateAmount   taxJournalTransExchangeRateAmount;
        // </GEEU>

        ttsbegin;

        // The headingTableId is not checked here because sales scenario is different with other scenarios.
        // In SO invoice, field HeadingTableId in table TmpTaxWorkTrans is SalesTable in both before and during posting stage.
        // But in sales quotation, it is changed during sending quotation  from SalesQuotation to CustQuotationJour.
        // In other scenarios it is changed from transaction table to transaction journal table.
        // Thus it is not possible to have a single check for both scenarios.
        
        while select
            sum(TaxBaseAmount),
            sum(TaxBaseAmountCur),
            sum(TaxBaseQty),
            sum(TaxAmount),
            sum(TaxAmountCur),
            sum(TaxInCostPrice),
            sum(SourceTaxAmountCur),
            sum(SourceBaseAmountCur),
            sum(SourceRegulateAmountCur),
            sum(TaxInCostPriceRegulated)
            // <GEEU>
            , sum(ExchangeRateSourceBaseAmountRegulated)
            , sum(ExchangeRateSourceRegulateAmount)
            , sum(ExchangeRateTaxAmount)
            , sum(ExchangeRateTaxBaseAmount)
            // </GEEU>
            from taxWorkTrans
        group by Voucher, TransDate, CalculationDate, InventTransId, TaxCode, TaxDirection, ExemptTax,
                    TaxOrigin, SourceCurrencyCode, TaxAutogenerated, OperationLedgerDimension, TaxGroup
        where taxWorkTrans.HeadingRecId == headingRecId &&
                taxWorkTrans.TaxOrigin != TaxOrigin::TaxReversed &&
                taxWorkTrans.IsDeleted == NoYes::No
        {
            // <GIN>
            if (isTaxParametersEnabled)
            {
                taxType = TaxTable::find(taxWorkTrans.TaxCode).TaxType_IN;
            }
            // </GIN>

            taxJournalTrans.initFromTaxWorkTrans(taxWorkTrans);

            // <GIN>
            if (isTaxParametersEnabled)
            {
                if (taxType != TaxType_IN::None)
                {
                    salesPurchJournalLineLoc = this.getSalesPurchJournalLineFromInventId_IN();
                    taxJournalTrans.TaxValue = taxWorkTrans.showTaxValue_IN(salesPurchJournalLineLoc);
                }
            }
            // </GIN>

            taxJournalTrans.TransTableId    = _transTableId;
            taxJournalTrans.TransRecId      = _transRecId;

            if (taxRegulationExist)
                taxJournalTrans.TaxAutoGenerated = NoYes::No;
            taxJournalTrans.euroTriangulation = triangulation;
            taxJournalTrans.TaxOrigin         = taxWorkTrans.TaxOrigin;

            // <GEEU>
            if (taxWorkTrans.ExchangeRateTaxBaseAmount ||
                taxWorkTrans.ExchangeRateTaxAmount ||
                taxWorkTrans.ExchangeRateSourceRegulateAmount ||
                taxWorkTrans.ExchangeRateSourceBaseAmountRegulated)
            {
                taxJournalTrans.insert();

                taxJournalTransExchangeRateAmount.TaxJournalTrans = taxJournalTrans.RecId;
                taxJournalTransExchangeRateAmount.ExchangeRateSourceBaseAmountRegulated = taxWorkTrans.ExchangeRateSourceBaseAmountRegulated;
                taxJournalTransExchangeRateAmount.ExchangeRateSourceRegulateAmount = taxWorkTrans.ExchangeRateSourceRegulateAmount;
                taxJournalTransExchangeRateAmount.ExchangeRateTaxAmount = taxWorkTrans.ExchangeRateTaxAmount;
                taxJournalTransExchangeRateAmount.ExchangeRateTaxBaseAmount = taxWorkTrans.ExchangeRateTaxBaseAmount;
                taxJournalTransExchangeRateAmount.insert();
            }
            // </GEEU>
            else
            {
                // If the RecId is not needed right away, then delay insert and batch with an insert list
                taxJournalTransInsertList.add(taxJournalTrans);
            }
        }

        // Insert all the remaining records from the record insert list
        taxJournalTransInsertList.insertDatabase();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveInProcessTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves in process transaction.
    /// </summary>
    protected void saveInProcessTransaction()
    {
        TaxAmount       taxMin;
        TaxAmount       taxMax;
        TaxTable        taxTable;
        boolean         vatBookDisabled;
        RealBase        factor;
        Currency        currency;
        Currency        currencyMST;
        Currency        currencySource;
        #ISOCountryRegionCodes
        // <GIN>

        TaxType_IN              taxTypeLoc;
        ReturnDispositionCodeId returnDispositionCodeId;
        EximExportImport_IN     direction;
        TaxAmount               customsTaxMin;
        TaxAmount               customsTaxMax;
        // </GIN>
        TaxCurrencyConversionRoutineHandler handler = TaxCurrencyConversionRoutineHandler::instance();

        // <GIN>
        if (isTaxParametersEnabled)
        {
            if (!this.parmInvoiceCompany_IN())
            {
                this.parmInvoiceCompany_IN(curext());
            }
            if (this.parmInvoiceCompany_IN() != curext())
            {
                changecompany(this.parmInvoiceCompany_IN())
                {
                    this.saveInProcessTransaction();
                    return;
                }
            }
        }
        // </GIN>

        currencyMST = this.getCompanyCurrency();

        currencySource = this.getSourceCurrency();

        while select forupdate taxWorkTrans

            order by taxWorkTrans.TaxCode
            where taxWorkTrans.HeadingRecId == headingRecId &&
                  taxWorkTrans.HeadingTableId == headingTableId &&
                  taxWorkTrans.SourceTableId == this.sourceTableId() &&
                  taxWorkTrans.SourceRecId == this.sourceRecId() &&
                  /* <SYS>
                  taxWorkTrans.ExemptTax        == NoYes::No
                  </SYS> */
                  // <GEERU>
                  (taxWorkTrans.ExemptTax       == NoYes::No            ||
                   this.processExemptTax_RU())
                  // </GEERU>
        {
            DataAreaId taxWorkTransCompany = curext();
            if(taxWorkTrans.Company)
            {
                taxWorkTransCompany = taxWorkTrans.Company;
            }
            changecompany(taxWorkTransCompany)
            {
                taxTable = this.getTaxTable(taxWorkTrans.TaxCode);
                currency = Currency::find(taxTable.TaxCurrencyCode);
                // <GIN>
                //This method checks whether transactions exist in BOESubTrans table for the current taxCode.
                if (isCustomsEnabled                                                               &&

                    documentStatus                                  == DocumentStatus::Invoice          &&
                    taxWorkTrans.TaxDirection                       == TaxDirection::IncomingTax        &&
                    TaxTable::find(taxWorkTrans.TaxCode).TaxType_IN == TaxType_IN::Customs              &&
                    this.checkIfTransactionExists_IN(taxWorkTrans.InventTransId, taxWorkTrans.TaxCode))
                {
                    this.customsTaxSum_IN(taxWorkTrans);
                }
                else
                {
                    if (isIndiaCountryRegionEnabled)
                    {
                        this.sumUpTaxCode(taxWorkTrans.TaxCode, taxWorkTrans.IsScrapQtyLine_IN);
                    }
                    else
                    {
                        // </GIN>
                        this.sumUpTaxCode(taxWorkTrans.TaxCode);
                        // <GIN>
                    }
                }
            }
            // </GIN>

            taxMin = TaxCollectLimit::taxMin(taxWorkTrans.TaxCode, taxDate);
            taxMax = TaxCollectLimit::taxMax(taxWorkTrans.TaxCode, taxDate);
            // <GIN>
            if (isCustomsEnabled

                && (taxMax || taxMin)
                && abs(customsTaxAmountCalc))
            {
                if (taxWorkTrans.TaxDirection == TaxDirection::OutgoingTax)
                {
                    direction = Direction_IN::Export;
                }
                else if (taxWorkTrans.TaxDirection == TaxDirection::IncomingTax)
                {
                    direction = Direction_IN::Import;
                }

                [customsTaxMin, customsTaxMax]  = TaxCollectLimit::customsTaxLimits_IN(taxWorkTrans.TaxCode, taxDate, direction);
            }
            // </GIN>
            if (taxMax && abs(taxAmountCalc) > taxMax

            // <GIN>
            || (isCustomsEnabled
                && customsTaxMax
                && abs(customsTaxAmountCalc) > customsTaxMax)
            // </GIN>
            )
            {
                // <GIN>
                if (isCustomsEnabled
                    && abs(customsTaxAmountCalc))
                {
                    if (taxTable.TaxLimitBase == TaxLimitBase::LineWithoutVAT)
                    {
                        factor = (customsTaxMax / abs(customsTaxAmountCalc));
                    }
                    else
                    {
                        factor = 1;
                    }

                    taxWorkTrans.TaxAmount = currencyMST.amount_Instance(customsTaxAmountCalc * factor);
                }
                else
                {
                    // </GIN>
                    factor                                = taxMax / abs(taxAmountCalc);
                    taxWorkTrans.TaxAmount                = currencyMST.amount_Instance(taxAmountCalc * factor);
                    // <GIN>
                }
                // </GIN>
                taxWorkTrans.TaxAmountCur             = currency.amount_Instance(taxAmountCalcCur * factor);
                taxWorkTrans.TaxInCostPrice           = currencySource.amount_Instance(taxInCostPriceCalc  * factor);
                taxWorkTrans.TaxInCostPriceCur        = currency.amount_Instance(taxInCostPriceCurCalc * factor);
                taxWorkTrans.TaxInCostPriceMST        = currencyMST.amount_Instance(taxInCostPriceMSTCalc * factor);
                taxWorkTrans.SourceTaxAmountCur       = currencySource.amount_Instance(taxAmountCalcSourceCur * factor);
                taxWorkTrans.SourceTaxAmountCurReal   = taxWorkTrans.SourceTaxAmountCur;
                // <GIN>
                if (isCustomsEnabled        &&

                    taxTable.TaxType_IN == TaxType_IN::Customs)
                {
                    taxWorkTrans.CustomsDuty_IN                      = CurrencyExchangeHelper::amount(customsTaxAmountCalc * factor);
                    taxWorkTrans.SourceRegulateAmountCur             = sourceRegulateAmountCustomsCur * factor;
                    taxWorkTrans.SourceRegulateAmountCustoms_IN      = sourceRegulateAmountCustomsMST * factor;

                    if (isEximIncentiveSchemEnabled && taxWorkTrans.EximIncentiveScheme_IN != EximIncentiveScheme_IN::EPCG)
                    {
                        this.setEximTaxes_IN();
                    }
                }
                // </GIN>
            }
            else if (abs(taxAmountCalc) >= taxMin

            // <GIN>
            || (isCustomsEnabled
                && taxTable.TaxType_IN == TaxType_IN::Customs
                && abs(customsTaxAmountCalc) >= customsTaxMin)
            // </GIN>
            )
            {
                taxWorkTrans.TaxAmount                = taxAmountCalc;
                taxWorkTrans.TaxAmountCur             = taxAmountCalcCur;
                taxWorkTrans.TaxInCostPrice           = taxInCostPriceCalc;
                taxWorkTrans.TaxInCostPriceCur        = taxInCostPriceCurCalc;
                taxWorkTrans.TaxInCostPriceMST        = taxInCostPriceMSTCalc;
                taxWorkTrans.SourceTaxAmountCur       = taxAmountCalcSourceCur;
                taxWorkTrans.SourceTaxAmountCurReal   = taxAmountCalcSourceCurReal;
                // <GIN>
                if (isCustomsEnabled        &&
                    taxTable.TaxType_IN == TaxType_IN::Customs)
                {
                    taxWorkTrans.CustomsDuty_IN                      = customsTaxAmountCalc;
                    taxWorkTrans.SourceRegulateAmountCur             = sourceRegulateAmountCustomsCur;
                    taxWorkTrans.SourceRegulateAmountCustoms_IN      = sourceRegulateAmountCustomsMST;
                    if (isEximIncentiveSchemEnabled && taxWorkTrans.EximIncentiveScheme_IN != EximIncentiveScheme_IN::EPCG)
                    {
                        this.setEximTaxes_IN();
                    }
                }
                // </GIN>
            }

            if ((taxMax && abs(taxAmountCalc) >= taxMax) ||

                (taxMin && taxAmountCalc && abs(taxAmountCalc) <= taxMin)
                // <GIN>
                || (isCustomsEnabled
                    && (customsTaxMax && abs(customsTaxAmountCalc) >= customsTaxMax)
                        || (customsTaxMin && customsTaxAmountCalc && abs(customsTaxAmountCalc) <= customsTaxMin))
                // </GIN>
                )
            {
                taxWorkTrans.TaxLimitReached = NoYes::Yes;
            }

            if (taxMin != 0 || taxMax != 0)
            {
                this.setValidateWarning(taxTable.TaxLimitBase, TaxWarning::InvalidTaxIncludedTaxCode, taxWorkTrans);
            }

            taxWorkTrans.CurrencyCode       = taxTable.TaxCurrencyCode;
            taxWorkTrans.SourceCurrencyCode = sourceCurrencyCode;
            taxWorkTrans.TaxOrigin          = TaxOrigin::Tax;

            // <GIN>
            if (isTaxParametersEnabled

                && isExciseEnabled)
                //|| TaxParameters::find().vat_in)
            {
                switch (taxModuleType)
                {
                    case TaxModuleType::Sales,
                                                        TaxModuleType::SalesInvoice:

                         returnDispositionCodeId = SalesLine::findRecId(salesPurchJournalLineLoc.SourceRecId).ReturnDispositionCodeId;
                        break;

                    case TaxModuleType::Purch,
                                                        TaxModuleType::PurchInvoice:

                         returnDispositionCodeId = PurchLine::findRecId(salesPurchJournalLineLoc.SourceRecId).ReturnDispositionCodeId;
                        break;
                }
            }

            if (isTaxParametersEnabled

                && ReturnDispositionCode::find(returnDispositionCodeId).DispositionAction != DispositionAction::ReturnToCust)
            {
                if (taxTable.TaxType_IN != TaxType_IN::None)
                {
                    taxWorkTrans.AbatementAmount_IN = abatementAmount;
                    if (taxWorkTrans.TaxAutogenerated == NoYes::Yes)
                    {
                        if (taxTable.TaxLimitBase == TaxLimitBase::UnitWithoutVAT ||
                            taxTable.TaxLimitBase == TaxLimitBase::UnitInclVAT)
                        {
                            taxWorkTrans.TaxBaseAmount      = taxBaseAmountCalc * abs(taxWorkTrans.TaxBaseQty);
                            taxWorkTrans.TaxBaseAmountCur   = taxBaseAmountCalcCur * abs(taxWorkTrans.TaxBaseQty);
                        }
                        else
                        {
                            taxWorkTrans.TaxBaseAmount      = taxBaseAmountCalc;
                            taxWorkTrans.TaxBaseAmountCur   = taxBaseAmountCalcCur;
                            taxWorkTrans.TaxBaseQty         = taxBaseQtyCalc;
                        }
                    }

                    if (taxWorkTrans.TaxAutogenerated == NoYes::Yes  || taxWorkTrans.SourceBaseAmountCur == 0)
                    {
                        if (taxTable.TaxLimitBase == TaxLimitBase::UnitWithoutVAT ||

                            taxTable.TaxLimitBase == TaxLimitBase::UnitInclVAT)
                        {
                            taxWorkTrans.SourceBaseAmountCur    = taxBaseAmountCalcSourceCur * abs(taxWorkTrans.TaxBaseQty);
                        }
                        else
                        {
                            taxWorkTrans.SourceBaseAmountCur    = taxBaseAmountCalcSourceCur;
                        }
                    }
                }
            }
            else
            {
                // </GIN>

                if (taxTable.TaxLimitBase != TaxLimitBase::InvoiceWithoutVAT &&

                    taxTable.TaxLimitBase != TaxLimitBase::InvoiceInclVAT &&
                    this.taxParameters().CalculatePrinciple != TaxCalcPrin::Total)

                {
                    if (taxWorkTrans.TaxAutogenerated == NoYes::Yes)
                    {
                        if (taxTable.TaxLimitBase == TaxLimitBase::UnitWithoutVAT ||

                            taxTable.TaxLimitBase == TaxLimitBase::UnitInclVAT)
                        {
                            taxWorkTrans.TaxBaseAmount      = taxBaseAmountCalc * abs(taxWorkTrans.TaxBaseQty);
                            taxWorkTrans.TaxBaseAmountRaw   = taxBaseAmountCalcRaw * abs(taxWorkTrans.TaxBaseQty);
                            taxWorkTrans.TaxBaseAmountCur   = taxBaseAmountCalcCur * abs(taxWorkTrans.TaxBaseQty);
                        }
                        else
                        {
                            taxWorkTrans.TaxBaseAmount      = taxBaseAmountCalc;
                            taxWorkTrans.TaxBaseAmountRaw   = taxBaseAmountCalcRaw;
                            taxWorkTrans.TaxBaseAmountCur   = taxBaseAmountCalcCur;
                            taxWorkTrans.TaxBaseQty         = taxBaseQtyCalc;
                            // <GBR>
                            if (isBrazilEnabled)
                            {
                                if (taxTable.TaxSubstitution_BR != TaxSubstitutionEnum_BR::None)
                                {
                                    taxWorkTrans.TaxSubstitutionAmountAddedMST_BR = taxSubstitutionAmountAddedMST_BR;
                                    taxWorkTrans.SourceTaxSubstitutionAmountAddedCur_BR = taxSubstitutionAmountAddedMST_BR;
                                }
                            }
                            // </GBR>
                        }
                    }

                    if (taxWorkTrans.TaxAutogenerated == NoYes::Yes  || taxWorkTrans.SourceBaseAmountCur == 0)
                    {
                        if (taxTable.TaxLimitBase == TaxLimitBase::UnitWithoutVAT ||

                            taxTable.TaxLimitBase == TaxLimitBase::UnitInclVAT)
                        {
                            taxWorkTrans.SourceBaseAmountCur    = taxBaseAmountCalcSourceCur * abs(taxWorkTrans.TaxBaseQty);
                            taxWorkTrans.SourceBaseAmountCurRaw = taxBaseAmountCalcSourceCurRaw * abs(taxWorkTrans.TaxBaseQty);
                        }
                        else
                        {
                            taxWorkTrans.SourceBaseAmountCur    = taxBaseAmountCalcSourceCur;
                            taxWorkTrans.SourceBaseAmountCurRaw = taxBaseAmountCalcSourceCurRaw;
                        }
                    }
                }
                // <GIN>
            }
            // </GIN>

            vatBookDisabled = !MultipleTaxIdReportingHelper::isLegalEntityOrTaxCodeInCountryRegion(
                taxWorkTrans.TaxCode, [#isoIT], MultipleTaxIdScope::VATDeclaration);

            if (vatBookDisabled                 &&

                taxWorkTrans.TaxBaseAmount == 0 &&
                taxWorkTrans.TaxBaseQty    == 0 &&
                taxWorkTrans.TaxAmount     == 0 )
            {
                this.updateBaseAmountSum(taxWorkTrans.TaxCode,
                    taxWorkTrans.TaxDirection,
                    -taxWorkTrans.orig().SourceBaseAmountCurRaw,
                    -taxWorkTrans.orig().SourceBaseAmountCur,
                    taxWorkTrans.SourceCurrencyCode);
            }

            taxWorkTrans.SourceBaseAmountCurCalculated = taxWorkTrans.SourceBaseAmountCur;

            // <GIN>
            if (isTaxParametersEnabled)
            {
                taxTypeLoc  = TaxTable::find(taxWorkTrans.TaxCode).TaxType_IN;

                if (taxWorkTrans.EximIncentiveScheme_IN == EximIncentiveScheme_IN::EPCG)
                {
                    this.setEximTaxes_IN();
                }
                taxWorkTrans.AbatementAmount_IN = abatementAmount;
                if (taxTypeLoc == TaxType_IN::Customs)
                {
                    taxWorkTrans.TaxBaseAmount       = taxBaseAmountCalc;
                    taxWorkTrans.TaxBaseAmountCur    = taxBaseAmountCalcCur;
                    taxWorkTrans.TaxBaseQty          = taxBaseQtyCalc;
                    taxWorkTrans.SourceBaseAmountCur = taxBaseAmountCalcSourceCur;
                }
            }
            // </GIN>

            taxWorkTrans.TaxBaseAmountRep   = handler.transCurrencyToReportingCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.SourceBaseAmountCur, reportingCurrencyExchRate, taxWorkTrans.TransDate);
            taxWorkTrans.TaxAmountRep       = handler.transCurrencyToReportingCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.SourceTaxAmountCur, reportingCurrencyExchRate, taxWorkTrans.TransDate);
            taxWorkTrans.TaxInCostPriceRep  = handler.transCurrencyToReportingCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.TaxInCostPrice, reportingCurrencyExchRate, taxWorkTrans.TransDate);

            // taxWarning was set when the Tax code was calculated.
            this.setValidateWarning(taxTable.TaxLimitBase, taxWarning, taxWorkTrans);

            // <GBR>
            if (isBrazilEnabled)
            {
                if (calculatedTaxes_BR.in(taxWorkTrans.TaxCode))
                {
                    this.applyFiscalValueInCalculatedTaxes_BR();
                }
            }
            // </GBR>

            taxWorkTrans.update(this.ignoreCalculatedSalesTax());
            // <GIN>
            if (isTaxParametersEnabled

                && ((!isCustomsEnabled         && taxTypeLoc == TaxType_IN::Customs)
                    || (!isExciseEnabled      && taxTypeLoc == TaxType_IN::Excise)
                    || (!isSalesTaxEnabled    && taxTypeLoc == TaxType_IN::SalesTax)
                    || (!isServiceTaxEnabled  && taxTypeLoc == TaxType_IN::ServiceTax)
                    || (!isVATEnabled         && taxTypeLoc == TaxType_IN::VAT)))
            {
                taxWorkTrans.delete();
            }
            // </GIN>
        }

        // <GBR>
        if (isBrazilEnabled)
        {
            calculatedTaxes_BR = null;
        }
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveTaxExchangeRateDifferenceAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the tax difference amount to the <c>TaxTrans</c> record.
    /// </summary>
    /// <param name="_exchangeRateSourceBaseAmountRegulated">
    /// The adjusted tax base amount for sales tax exchange rate.
    /// </param>
    /// <param name="_exchangeRateTaxBaseAmount">
    /// The tax base amount for sales tax exchange rate.
    /// </param>
    /// <param name="_exchangeRateSourceRegulateAmount">
    /// The adjusted tax amount for sales tax exchange rate.
    /// </param>
    /// <param name="_exchangeRateTaxAmount">
    /// The tax amount for sales tax exchange rate.
    /// </param>
    /// <param name="_taxTrans">
    /// The original <c>TaxTrans</c> record.
    /// </param>
    /// <returns>
    /// The exchange rate difference <c>TaxTrans</c> record.
    /// </returns>
    protected TaxTrans saveTaxExchangeRateDifferenceAmount(
        TaxBase     _exchangeRateSourceBaseAmountRegulated,
        TaxBase     _exchangeRateTaxBaseAmount,
        TaxAmount   _exchangeRateSourceRegulateAmount,
        TaxAmount   _exchangeRateTaxAmount,
        TaxTrans    _taxTrans)
    {
        TaxBase taxBaseDifferenceAmount;
        TaxAmount taxDifferenceAmount;
        TaxTrans taxTransExchangeRateDifference;
        boolean isCzCountryEnabled = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]);
        boolean isAllowZeroAmountInCzCountry = isCzCountryEnabled
            && (!FeatureStateProvider::isFeatureEnabled(TaxDifferenceZeroAmountCZControlFeature::instance()));

        taxDifferenceAmount = _exchangeRateSourceRegulateAmount ? _exchangeRateSourceRegulateAmount : _exchangeRateTaxAmount;

        if (!isCzCountryEnabled || taxDifferenceAmount != 0)
        {
            taxDifferenceAmount = taxDifferenceAmount - _taxTrans.TaxAmount;
        }

        if (taxDifferenceAmount != 0 || _taxTrans.TaxValue == 0 || isAllowZeroAmountInCzCountry)
        {
            taxTransExchangeRateDifference.initForTaxExchangeRateDifference(_taxTrans);
            taxBaseDifferenceAmount = _exchangeRateSourceBaseAmountRegulated ? _exchangeRateSourceBaseAmountRegulated : _exchangeRateTaxBaseAmount;

            if (!isCzCountryEnabled || taxBaseDifferenceAmount != 0)
            {
                taxBaseDifferenceAmount = taxBaseDifferenceAmount - _taxTrans.TaxBaseAmount;
            }
            taxTransExchangeRateDifference.TaxBaseAmount = taxBaseDifferenceAmount;
            taxTransExchangeRateDifference.TaxAmount     = taxDifferenceAmount;

            TaxAmount exchangeRateSourceTaxAmount = _exchangeRateSourceRegulateAmount
                    ? _exchangeRateSourceRegulateAmount
                    : _exchangeRateTaxAmount;

            TaxBase exchangeRateSourceBaseAmount = _exchangeRateSourceBaseAmountRegulated
                    ? _exchangeRateSourceBaseAmountRegulated
                    : _exchangeRateTaxBaseAmount;
            CurrencyCode accountingCurrencyCode = Ledger::accountingCurrency(this.companyInfo().RecId);

            // Calculate TaxBaseAmountCur and TaxAmountCur(tax base amount and tax amount of tax currency) from TaxBaseAmount and TaxAmount(tax base amount and tax amount of accounting currency).
            if (taxTransExchangeRateDifference.CurrencyCode == accountingCurrencyCode)
            {
                taxTransExchangeRateDifference.TaxAmountCur = taxTransExchangeRateDifference.TaxAmount;
                taxTransExchangeRateDifference.TaxBaseAmountCur = taxTransExchangeRateDifference.TaxBaseAmount;
            }
            else
            {
                // Avoid the tax amount difference is too small to round, exchange the currency amount before the difference, instead of exchanging TaxAmount directly, make sure the sum of them is correct.
                TaxAmountCur exchangeRateSourceTaxAmountCur = CurrencyExchangeHelper::curAmount(exchangeRateSourceTaxAmount, _taxTrans.CurrencyCode, _taxTrans.TransDate);
                taxTransExchangeRateDifference.TaxAmountCur = exchangeRateSourceTaxAmountCur - _taxTrans.TaxAmountCur;

                TaxBase exchangeRateSourceBaseAmountCur = CurrencyExchangeHelper::curAmount(exchangeRateSourceBaseAmount, _taxTrans.CurrencyCode, _taxTrans.TransDate);
                taxTransExchangeRateDifference.TaxBaseAmountCur = exchangeRateSourceBaseAmountCur -_taxTrans.TaxBaseAmountCur;
            }

            // Calculate TaxBaseAmountRep and TaxAmountRep(tax base amount and tax amount of reporting currency) from TaxBaseAmount and TaxAmount(tax base amount and tax amount of accounting currency).
            if (TaxBankExchangeRateDifferenceV2Flight::instance().isEnabled())
            {
                CurrencyCode reportingCurrencyCode = Ledger::reportingCurrency(this.companyInfo().RecId);

                if (reportingCurrencyCode)
                {
                    if (reportingCurrencyCode == accountingCurrencyCode)
                    {
                        taxTransExchangeRateDifference.TaxAmountRep = taxTransExchangeRateDifference.TaxAmount;
                        taxTransExchangeRateDifference.TaxBaseAmountRep = taxTransExchangeRateDifference.TaxBaseAmount;
                    }
                    else if (TaxBankExchangeRateRepCurConversionFlight::instance().isEnabled() && reportingCurrencyCode == _taxTrans.SourceCurrencyCode)
                    {
                        taxTransExchangeRateDifference.TaxAmountRep = taxTransExchangeRateDifference.SourceTaxAmountCur;
                        taxTransExchangeRateDifference.TaxBaseAmountRep = taxTransExchangeRateDifference.SourceBaseAmountCur;
                    }
                    else
                    {
                        // Avoid the tax amount difference is too small to round, exchange the currency amount before the difference, instead of exchanging TaxAmount directly, make sure the sum of them is correct.
                        TaxAmountCur exchangeRateSourceTaxAmountRep = CurrencyExchangeHelper::curAmount(exchangeRateSourceTaxAmount, reportingCurrencyCode, _taxTrans.TransDate);
                        taxTransExchangeRateDifference.TaxAmountRep = exchangeRateSourceTaxAmountRep - _taxTrans.TaxAmountRep;

                        TaxBase exchangeRateSourceBaseAmountRep = CurrencyExchangeHelper::curAmount(exchangeRateSourceBaseAmount, reportingCurrencyCode, _taxTrans.TransDate);
                        taxTransExchangeRateDifference.TaxBaseAmountRep = exchangeRateSourceBaseAmountRep - _taxTrans.TaxBaseAmountRep;
                    }
                }
            }

            taxTransExchangeRateDifference.SourceDocumentLine = 0;
            if ((FeatureStateProvider::isFeatureEnabled(TaxBankExchangeRateDifferenceFlighting::instance()) || TaxBankExchangeRateDifferenceV2Flight::instance().isEnabled())
                && this.useSubLedgerJournalLines())
            {
                SourceDocumentLineProcessor::submitSourceDocumentLineImplementation(taxTransExchangeRateDifference);
            }
            taxTransExchangeRateDifference.ExchRateDiffOrigRecId = _taxTrans.RecId;
            taxTransExchangeRateDifference.insert();
        }

        return taxTransExchangeRateDifference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveTaxSpecificExchangeRateDifferenceAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves the tax specific exchange rate difference amounts into new created <c>TaxTrans</c> record.
    /// </summary>
    /// <param name = "_taxSepcificExchangeRateAmountParameters">Tax specific exchange rate amount parameters.</param>
    /// <param name = "_taxTrans">The origin <c>TaxTrans</c> record.</param>
    /// <returns>The <c>TaxTrans</c> record.</returns>
    /// <remarks>
    /// A sales tax difference should be generated solely in instances where there is a discrepancy in the tax amount, the tax base amount, or when a zero amount is permissible.
    /// </remarks>
    internal TaxTrans saveTaxSpecificExchangeRateDifferenceAmount(
        TaxSepcificExchangeRateAmountParameters _taxSepcificExchangeRateAmountParameters,
        TaxTrans _taxTrans)
    {
        TaxTrans taxTransExchangeRateDifference;
        boolean isCzCountryEnabled = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]);
        boolean isAllowZeroAmountInCzCountry = isCzCountryEnabled
            && (!FeatureStateProvider::isFeatureEnabled(TaxDifferenceZeroAmountCZControlFeature::instance()));

        TaxAmount taxDifferenceAmount = this.getTaxSpecificExchangeRateDifferenceAmount(
            _taxSepcificExchangeRateAmountParameters.parmExchangeRateTaxAmount(),
            _taxSepcificExchangeRateAmountParameters.parmExchangeRateSourceRegulateAmount(),
            _taxTrans.TaxAmount,
            isCzCountryEnabled);
        TaxAmount taxDifferenceAmountRep = this.getTaxSpecificExchangeRateDifferenceAmount(
            _taxSepcificExchangeRateAmountParameters.parmExchangeRateTaxAmountRep(),
            0,
            _taxTrans.TaxAmountRep,
            isCzCountryEnabled);
        TaxAmount taxDifferenceAmountCur = this.getTaxSpecificExchangeRateDifferenceAmount(
            _taxSepcificExchangeRateAmountParameters.parmExchangeRateTaxAmountCur(),
            _taxSepcificExchangeRateAmountParameters.parmExchangeRateRegulateAmountCur(),
            _taxTrans.TaxAmountCur,
            isCzCountryEnabled);

        boolean isTaxIntegrationCreateTaxDifferenceFlightEnabled = TaxIntegrationCreateTaxDifferenceFlight::instance().isEnabled();
        boolean hasTaxDifference = taxDifferenceAmount != 0 || taxDifferenceAmountRep!= 0 || taxDifferenceAmountCur != 0;
        TaxBase taxBaseDifferenceAmount;
        TaxBase taxBaseDifferenceAmountRep;
        TaxBase taxBaseDifferenceAmountCur;

        if (isTaxIntegrationCreateTaxDifferenceFlightEnabled || hasTaxDifference || _taxTrans.TaxValue == 0 || _taxTrans.ExemptTax || isAllowZeroAmountInCzCountry)
        {
            taxBaseDifferenceAmount = this.getTaxSpecificExchangeRateDifferenceAmount(
                _taxSepcificExchangeRateAmountParameters.parmExchangeRateTaxBaseAmount(),
                _taxSepcificExchangeRateAmountParameters.parmExchangeRateSourceBaseAmountRegulated(),
                _taxTrans.TaxBaseAmount,
                isCzCountryEnabled);
            taxBaseDifferenceAmountRep = this.getTaxSpecificExchangeRateDifferenceAmount(
                _taxSepcificExchangeRateAmountParameters.parmExchangeRateTaxBaseAmountRep(),
                0,
                _taxTrans.TaxBaseAmountRep,
                isCzCountryEnabled);
            taxBaseDifferenceAmountCur = this.getTaxSpecificExchangeRateDifferenceAmount(
                _taxSepcificExchangeRateAmountParameters.parmExchangeRateTaxBaseAmountCur(),
                _taxSepcificExchangeRateAmountParameters.parmExchangeRateBaseAmountCurRegulated(),
                _taxTrans.TaxBaseAmountCur,
                isCzCountryEnabled);
        }

        boolean hasTaxBaseDifference = taxBaseDifferenceAmount != 0 || taxBaseDifferenceAmountRep != 0 || taxBaseDifferenceAmountCur != 0;

        // A sales tax difference <c>TaxTrans</c> should only be generated when there is a discrepancy in the tax amount or the tax base amount or zero amount allowed.
        if ((isTaxIntegrationCreateTaxDifferenceFlightEnabled
                && (hasTaxDifference || hasTaxBaseDifference || isAllowZeroAmountInCzCountry))
            || (!isTaxIntegrationCreateTaxDifferenceFlightEnabled
                && (hasTaxDifference || _taxTrans.TaxValue == 0 || _taxTrans.ExemptTax || isAllowZeroAmountInCzCountry)))
        {
            taxTransExchangeRateDifference.initForTaxExchangeRateDifference(_taxTrans);

            taxTransExchangeRateDifference.TaxBaseAmount = taxBaseDifferenceAmount;
            taxTransExchangeRateDifference.TaxAmount = taxDifferenceAmount;
            taxTransExchangeRateDifference.TaxBaseAmountRep = taxBaseDifferenceAmountRep;
            taxTransExchangeRateDifference.TaxAmountRep = taxDifferenceAmountRep;
            taxTransExchangeRateDifference.TaxBaseAmountCur = taxBaseDifferenceAmountCur;
            taxTransExchangeRateDifference.TaxAmountCur = taxDifferenceAmountCur;

            taxTransExchangeRateDifference.SourceDocumentLine = 0;
            if ((FeatureStateProvider::isFeatureEnabled(TaxBankExchangeRateDifferenceFlighting::instance()) || TaxBankExchangeRateDifferenceV2Flight::instance().isEnabled())
                && this.useSubLedgerJournalLines())
            {
                SourceDocumentLineProcessor::submitSourceDocumentLineImplementation(taxTransExchangeRateDifference);
            }

            taxTransExchangeRateDifference.ExchRateDiffOrigRecId = _taxTrans.RecId;
            taxTransExchangeRateDifference.insert();
        }

        return taxTransExchangeRateDifference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxSpecificExchangeRateDifferenceAmount</Name>
				<Source><![CDATA[
    private AmountCur getTaxSpecificExchangeRateDifferenceAmount(
        AmountCur _exchangeRateAmount,
        AmountCur _regulatedExchangeRateAmount,
        AmountCur _originAmount,
        boolean _isCzCountryEnabled)
    {
        AmountCur differenceAmount = _regulatedExchangeRateAmount ? _regulatedExchangeRateAmount : _exchangeRateAmount;

        if (!_isCzCountryEnabled || differenceAmount != 0)
        {
            differenceAmount = differenceAmount - _originAmount;
        }

        return differenceAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveTotalInProcessTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves total in process transaction.
    /// </summary>
    protected void saveTotalInProcessTransaction()
    {
        this.distributeTotalTax(TaxCalculationOrder::CalculateBeforeOtherSalesTax);
        this.distributeTotalTax(TaxCalculationOrder::PercentageOfNetAmount);
        this.distributeTotalTax(TaxCalculationOrder::PercentageOfSalesTax);
        this.distributeTotalTax(TaxCalculationOrder::PercentageOfGrossAmountTaxOnTax);
        this.distributeTotalTax(TaxCalculationOrder::PercentageOfGrossAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveTaxIdToCustVendJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves TaxId and PartyTaxId from <c>TmpTaxWorkTrans</c> and them to journal table.
    /// </summary>
    /// <param name = "_jour">The journal table to save to.</param>
    public void saveTaxIdToCustVendJour(SalesPurchJournalTable _jour)
    {
        TmpTaxWorkTrans taxWorkTransLoc = this.tmpTaxWorkTrans();
        select firstonly TaxId, PartyTaxId, RecId from taxWorkTransLoc;
        if (taxWorkTransLoc.TaxId)
        {
            _jour.TaxId = taxWorkTransLoc.TaxId;
            _jour.PartyTaxId = taxWorkTransLoc.PartyTaxId;
        }
        else if(taxWorkTransLoc.RecId)
        {
            warning("@TaxMultipleVATID:VATIDNotFoundForJourTable");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>serviceTaxAccountNum_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets service tax account number.
    /// </summary>
    /// <param name="_taxLedgerAccountGroupRecId">
    /// The tax ledger account group RecId.
    /// </param>
    /// <param name="_taxTable">
    /// The tax table.
    /// </param>
    /// <param name="_taxDirection">
    /// The tax direction.
    /// </param>
    /// <param name="_dimensionDefault">
    /// The dimension default.
    /// </param>
    /// <returns>
    /// The instance of the <c>RefRecId</c> class.
    /// </returns>
    public RefRecId serviceTaxAccountNum_IN(
        RefRecId     _taxLedgerAccountGroupRecId,
        TaxTable     _taxTable,
        TaxDirection _taxDirection,
        DimensionDefault _dimensionDefault)
    {
        RefRecId                                    tmpAccount;
        LedgerJournalTrans                          ledgerJournalService;
        LedgerJournalTrans                          ledgerJournalServiceLoc;
        RefRecId                                    stcNumber;
        RefRecId                                    taxLedgerAccountsetupRecId;
        LedgerJournalTrans                          ledgerJournalTransLoc1;
        LedgerDimensionDefaultAccount               serviceAccount;
        LedgerDimensionDefaultAccount               defaultAccount_IN;
        // For NON PO Line.
        boolean                                     isThisNONPOLine;
        boolean                                     post2InterimAC = true;
        DataAreaId                                  dataAreaId;
        TaxItemGroupHeading                         taxItemGroupHeadingRev;
        LedgerJournalACType                         tmpAccountType;
        TransTaxInformation                         transTaxInformation;

        transTaxInformation = transTaxInformationHelper.getTransTaxInformation(salesPurchJournalLineLoc.SourceTableId, salesPurchJournalLineLoc.SourceRecId);

        if (!this.parmInvoiceCompany_IN())
        {
            this.parmInvoiceCompany_IN(curext());
        }

        taxWorkTrans.TaxRegistrationNumberTable_IN =  transTaxInformation.ServiceTaxRegistrationNumber;

        changecompany (this.parmInvoiceCompany_IN())
        {
            dataAreaId = curext();
            if (taxModuleType == TaxModuleType::Voucher)
            {
                if (salesPurchJournalLineLoc.TableId == tableNum(LedgerJournalTrans))
                {
                    ledgerJournalService = salesPurchJournalLineLoc;
                    if (ledgerJournalService.Company != ''
                        && ledgerJournalService.OffsetCompany != ''
                        && (ledgerJournalService.Company != ledgerJournalService.OffsetCompany)
                       )
                    {
                        dataAreaId = ledgerJournalService.OffsetCompany;
                    }
                }

                stcNumber = transTaxInformation.ServiceTaxRegistrationNumber;
                taxLedgerAccountsetupRecId = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(_taxLedgerAccountGroupRecId, TaxAccountCode_IN::Table, stcNumber).RecId;
                taxItemGroupHeadingRev = TaxItemGroupHeading::find(ledgerJournalService.orig().TaxItemGroup);
                if (!taxLedgerAccountsetupRecId)
                {
                    taxLedgerAccountsetupRecId = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(_taxLedgerAccountGroupRecId, TaxAccountCode_IN::All).RecId;
                }

                _taxDirection = ledgerJournalService.determineVendBankDirection_IN(_taxDirection);
                if (_taxDirection == TaxDirection::IncomingTax)
                {
                    if (ledgerJournalService.orig().OffsetLedgerDimension)
                    {
                        if ((ledgerJournalService.orig().AccountType        == LedgerJournalACType::Ledger  &&
                            ledgerJournalService.orig().OffsetAccountType   == LedgerJournalACType::Ledger  &&
                            ledgerJournalService.orig().ForeignCompany      == '')                          ||
                            ((ledgerJournalService.orig().AccountType       == LedgerJournalACType::Ledger  ||
                            ledgerJournalService.orig().OffsetAccountType   == LedgerJournalACType::Ledger) &&
                            (ledgerJournalService.orig().AccountType        == LedgerJournalACType::Bank    ||
                            ledgerJournalService.orig().OffsetAccountType   == LedgerJournalACType::Bank))  ||
                            ledgerJournalService.orig().isPurchaseCashAccount_IN()
                             && (!ledgerJournalService.isGTAVendorAccount_IN() || !ledgerJournalService.isForeignVendorAccount_IN()))
                        {
                            if (transTaxInformation.ServiceTaxGTAServiceCategory  == GTAServiceCategory_IN::Others    &&
                               taxItemGroupHeadingRev.ServiceTaxBasis_IN    == ServiceTaxBasis_IN::POTBasis)
                            {
                                serviceAccount = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId,
                                                                                   TaxAccountType_IN::ServiceTaxExpenseAccount,
                                                                                   _taxTable.TaxComponentTable_IN);
                            }
                            else
                            {
                                serviceAccount = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId,
                                                                                 TaxAccountType_IN::ServiceTaxRecoverableAccount,
                                                                                 _taxTable.TaxComponentTable_IN);
                            }
                        }
                        else
                        {
                            if (!isInterCompanyTrans)
                            {
                                serviceAccount = this.getServiceTaxAccount_IN(taxLedgerAccountsetupRecId, _taxTable.TaxComponentTable_IN, _taxDirection, ledgerJournalService.orig());
                            }
                        }
                    }
                    else
                    {
                        changecompany (dataAreaId)
                        {
                            select ledgerJournalTransLoc1
                                where ledgerJournalTransLoc1.Voucher    == ledgerJournalService.orig().Voucher                  &&
                                      ledgerJournalTransLoc1.RecId      != ledgerJournalService.orig().RecId                    &&
                                      ((ledgerJournalTransLoc1.AmountCurDebit && ledgerJournalService.orig().AmountCurCredit)   ||
                                       (ledgerJournalTransLoc1.AmountCurCredit && ledgerJournalService.orig().AmountCurDebit));
                        }

                        if (ledgerJournalTransLoc1)
                        {
                            if ((ledgerJournalTransLoc1.AccountType             == LedgerJournalACType::Ledger  &&
                                ledgerJournalService.orig().AccountType         == LedgerJournalACType::Ledger  &&
                                ledgerJournalTransLoc1.ForeignCompany           == ''                           &&
                                ledgerJournalService.orig().ForeignCompany      == '')                          ||
                                ((ledgerJournalTransLoc1.AccountType            == LedgerJournalACType::Ledger  ||
                                ledgerJournalService.orig().AccountType         == LedgerJournalACType::Ledger) &&
                                (ledgerJournalService.orig().AccountType        == LedgerJournalACType::Bank    ||
                                ledgerJournalTransLoc1.AccountType              == LedgerJournalACType::Bank)))
                            {
                                if (transTaxInformation.ServiceTaxGTAServiceCategory  == GTAServiceCategory_IN::Others    &&
                                   taxItemGroupHeadingRev.ServiceTaxBasis_IN    == ServiceTaxBasis_IN::POTBasis)
                                {
                                    serviceAccount  = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId,
                                                                                       TaxAccountType_IN::ServiceTaxExpenseAccount,
                                                                                       _taxTable.TaxComponentTable_IN);
                                }
                                else
                                {
                                    serviceAccount   =   TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId,
                                                                                         TaxAccountType_IN::ServiceTaxRecoverableAccount,
                                                                                         _taxTable.TaxComponentTable_IN);
                                }
                            }
                            else
                            {
                                if (!isInterCompanyTrans)
                                {
                                    tmpAccountType = ledgerJournalService.OffsetAccountType;
                                    ledgerJournalService.OffsetAccountType = ledgerJournalTransLoc1.AccountType;
                                    serviceAccount = this.getServiceTaxAccount_IN(taxLedgerAccountsetupRecId, _taxTable.TaxComponentTable_IN, _taxDirection, ledgerJournalService);
                                    ledgerJournalService.OffsetAccountType = tmpAccountType;
                                }
                            }
                        }
                    }
                    if (ledgerJournalService.orig().OffsetLedgerDimension)
                    {
                        if ((ledgerJournalService.orig().AccountType        == LedgerJournalACType::Bank ||
                            ledgerJournalService.orig().OffsetAccountType   == LedgerJournalACType::Bank) &&
                            (ledgerJournalService.orig().AccountType        == LedgerJournalACType::Vend ||
                            ledgerJournalService.orig().OffsetAccountType   == LedgerJournalACType::Vend)||
                            (ledgerJournalService.orig().AccountType        == LedgerJournalACType::Ledger &&
                             ledgerJournalService.orig().OffsetAccountType  == LedgerJournalACType::Ledger &&
                             ledgerJournalService.orig().ForeignCompany     != ''))
                        {
                            defaultAccount_IN = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId,
                                                                                    TaxAccountType_IN::ServiceTaxRecoverableAccount,
                                                                                    _taxTable.TaxComponentTable_IN);

                            if (!defaultAccount_IN && post)
                            {
                                checkFailed(strFmt("@GLS5614", TaxRegistrationNumbers_IN::find(taxWorkTrans.TaxRegistrationNumberTable_IN).RegistrationNumber));
                                throw error("@SYS21533");
                            }
                        }
                    }
                    else
                    {
                        if ((ledgerJournalTransLoc1.AccountType            == LedgerJournalACType::Bank    ||
                            ledgerJournalTransLoc1.OffsetAccountType       == LedgerJournalACType::Bank)   &&
                            (ledgerJournalTransLoc1.AccountType            == LedgerJournalACType::Vend    ||
                            ledgerJournalTransLoc1.OffsetAccountType       == LedgerJournalACType::Vend)   ||
                            (ledgerJournalTransLoc1.AccountType            == LedgerJournalACType::Ledger  &&
                            ledgerJournalTransLoc1.OffsetAccountType       == LedgerJournalACType::Ledger  &&
                            ledgerJournalService.orig().ForeignCompany     != ''                           &&
                            ledgerJournalTransLoc1.ForeignCompany          != ''))
                        {
                            defaultAccount_IN = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId,
                                                                                    TaxAccountType_IN::ServiceTaxRecoverableAccount,
                                                                                    _taxTable.TaxComponentTable_IN);

                            if (!defaultAccount_IN && post)
                            {
                                checkFailed(strFmt("@GLS5614", TaxRegistrationNumbers_IN::find(taxWorkTrans.TaxRegistrationNumberTable_IN).RegistrationNumber));
                                throw error("@SYS21533");
                            }
                        }
                    }
                }

                else if (_taxDirection == TaxDirection::OutgoingTax)
                {
                    if (ledgerJournalService.orig().OffsetLedgerDimension)
                    {
                        if ((ledgerJournalService.orig().AccountType          == LedgerJournalACType::Ledger &&
                           ledgerJournalService.orig().OffsetAccountType     == LedgerJournalACType::Ledger)||
                           ((ledgerJournalService.orig().AccountType         == LedgerJournalACType::Ledger ||
                             ledgerJournalService.orig().OffsetAccountType   == LedgerJournalACType::Ledger)&&
                            (ledgerJournalService.orig().AccountType         == LedgerJournalACType::Bank   ||
                            ledgerJournalService.orig().OffsetAccountType    == LedgerJournalACType::Bank))  &&
                            ledgerJournalService.orig().ForeignCompany       == '')
                        {
                            serviceAccount = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId,
                                                                                 TaxAccountType_IN::ServiceTaxPayableAccount,
                                                                                 _taxTable.TaxComponentTable_IN);
                        }
                        else
                        {
                            if (!isInterCompanyTrans)
                            {
                                serviceAccount = this.getServiceTaxAccount_IN(taxLedgerAccountsetupRecId, _taxTable.TaxComponentTable_IN, _taxDirection, ledgerJournalService.orig());
                            }
                        }
                    }
                    else
                    {
                        changecompany (dataAreaId)
                        {
                            select ledgerJournalTransLoc1
                                where ledgerJournalTransLoc1.Voucher    == ledgerJournalService.orig().Voucher                  &&
                                      ledgerJournalTransLoc1.RecId      != ledgerJournalService.orig().RecId                    &&
                                      ((ledgerJournalTransLoc1.AmountCurDebit && ledgerJournalService.orig().AmountCurCredit)   ||
                                       (ledgerJournalTransLoc1.AmountCurCredit && ledgerJournalService.orig().AmountCurDebit));
                        }

                        if (ledgerJournalTransLoc1)
                        {
                            if ((ledgerJournalTransLoc1.AccountType              == LedgerJournalACType::Ledger &&
                              ledgerJournalService.orig().AccountType           == LedgerJournalACType::Ledger)||
                              ((ledgerJournalService.orig().AccountType         == LedgerJournalACType::Ledger ||
                              ledgerJournalService.orig().AccountType           == LedgerJournalACType::Ledger)&&
                              (ledgerJournalTransLoc1.AccountType               == LedgerJournalACType::Bank   ||
                              ledgerJournalService.orig().AccountType           == LedgerJournalACType::Bank)) &&
                              ledgerJournalService.orig().ForeignCompany        == ''                          &&
                              ledgerJournalTransLoc1.ForeignCompany             == '')
                            {
                                serviceAccount   =   TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId,
                                                                                         TaxAccountType_IN::ServiceTaxPayableAccount,
                                                                                         _taxTable.TaxComponentTable_IN);
                            }
                            else
                            {
                                if (!isInterCompanyTrans)
                                {
                                    if  (ledgerJournalService.isGTAVendorAccount_IN()
                                         && MainAccount::findByLedgerDimension(serviceAccount).PostingType == LedgerPostingType::PurchCash)
                                    {
                                        serviceAccount = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId,
                                                                                             TaxItemGroupHeading::isAccruePayableAtInvoicing_IN(ledgerJournalService.TaxItemGroup) ? TaxAccountType_IN::ServiceTaxPayableAccount : TaxAccountType_IN::ServiceTaxInterimPayableAccount,
                                                                                             _taxTable.TaxComponentTable_IN);
                                    }

                                    else
                                    {
                                        serviceAccount = this.getServiceTaxAccount_IN(taxLedgerAccountsetupRecId, _taxTable.TaxComponentTable_IN, _taxDirection, ledgerJournalService.orig());
                                    }
                                }
                            }
                        }
                    }
                    if (ledgerJournalService.orig().OffsetLedgerDimension)
                    {
                        if ((ledgerJournalService.orig().AccountType        == LedgerJournalACType::Bank ||
                            ledgerJournalService.orig().OffsetAccountType   == LedgerJournalACType::Bank) &&
                            (ledgerJournalService.orig().AccountType        == LedgerJournalACType::Vend ||
                            ledgerJournalService.orig().OffsetAccountType   == LedgerJournalACType::Vend ||
                            ledgerJournalService.orig().AccountType         == LedgerJournalACType::Cust ||
                            ledgerJournalService.orig().OffsetAccountType   == LedgerJournalACType::Cust) ||
                            (ledgerJournalService.orig().AccountType        == LedgerJournalACType::Ledger &&
                             ledgerJournalService.orig().OffsetAccountType  == LedgerJournalACType::Ledger &&
                             ledgerJournalService.orig().ForeignCompany     != ''))
                        {
                            defaultAccount_IN = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId,
                                                                                    TaxAccountType_IN::ServiceTaxPayableAccount,
                                                                                    _taxTable.TaxComponentTable_IN);
                            if (!defaultAccount_IN && post)
                            {
                                checkFailed(strFmt("@GLS5614", TaxRegistrationNumbers_IN::find(taxWorkTrans.TaxRegistrationNumberTable_IN).RegistrationNumber));
                                throw error("@SYS21533");
                            }
                        }
                    }
                    else
                    {
                        if ((ledgerJournalTransLoc1.AccountType             == LedgerJournalACType::Bank    ||
                            ledgerJournalTransLoc1.OffsetAccountType        == LedgerJournalACType::Bank)   &&
                            (ledgerJournalTransLoc1.AccountType             == LedgerJournalACType::Vend    ||
                            ledgerJournalTransLoc1.OffsetAccountType        == LedgerJournalACType::Vend    ||
                            ledgerJournalTransLoc1.AccountType              == LedgerJournalACType::Cust    ||
                            ledgerJournalTransLoc1.OffsetAccountType        == LedgerJournalACType::Cust)   ||
                            (ledgerJournalTransLoc1.AccountType             == LedgerJournalACType::Ledger  &&
                            ledgerJournalTransLoc1.OffsetAccountType        == LedgerJournalACType::Ledger  &&
                            ledgerJournalService.orig().ForeignCompany      != ''                           &&
                            ledgerJournalTransLoc1.ForeignCompany           != ''))
                        {
                            taxWorkTrans.LedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId, TaxAccountType_IN::ServiceTaxPayableAccount, _taxTable.TaxComponentTable_IN), _dimensionDefault);

                            if (!taxWorkTrans.LedgerDimension && post)
                            {
                                checkFailed(strFmt("@GLS5614", TaxRegistrationNumbers_IN::find(taxWorkTrans.TaxRegistrationNumberTable_IN).RegistrationNumber));
                                throw error("@SYS21533");
                            }
                        }
                    }
                }
                if (((ledgerJournalService.isGTAVendorAccount_IN() || ledgerJournalService.isForeignVendorAccount_IN())
                     || taxItemGroupHeadingRev.ReverseChargePercentage_IN != 0) &&
                    (ledgerJournalService.orig().AccountType        != LedgerJournalACType::Bank &&
                    ledgerJournalService.orig().OffsetAccountType   != LedgerJournalACType::Bank))
                {
                    defaultAccount_IN =  TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId,
                                                                             TaxItemGroupHeading::isAccruePayableAtInvoicing_IN(ledgerJournalService.TaxItemGroup) ? TaxAccountType_IN::ServiceTaxPayableAccount : TaxAccountType_IN::ServiceTaxInterimPayableAccount,
                                                                             _taxTable.TaxComponentTable_IN);

                    if (!defaultAccount_IN && post)
                    {
                        checkFailed(strFmt("@GLS5614", TaxRegistrationNumbers_IN::find(taxWorkTrans.TaxRegistrationNumberTable_IN).RegistrationNumber));
                        throw error("@SYS21533");
                    }
                }

                changecompany (dataAreaId)
                {
                    select firstonly ledgerJournalServiceLoc where
                        ledgerJournalServiceLoc.Voucher == ledgerJournalService.orig().Voucher;
                }
                if ((ledgerJournalService.orig().AccountType       == LedgerJournalACType::Ledger  &&
                     ledgerJournalService.orig().OffsetAccountType == LedgerJournalACType::Ledger) &&
                     ledgerJournalService.orig().ForeignCompany    != ''                           &&
                     (VendTable::find(ledgerJournalServiceLoc.parmAccount()).isGTA() ||
                      VendTable::find(ledgerJournalServiceLoc.parmAccount()).isForeign()))
                {
                    defaultAccount_IN = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId,
                                                                            TaxAccountType_IN::ServiceTaxInterimPayableAccount,
                                                                            _taxTable.TaxComponentTable_IN);

                    serviceAccount = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId,
                                                                         TaxAccountType_IN::ServiceTaxPayableAccount,
                                                                         _taxTable.TaxComponentTable_IN);

                    if (!defaultAccount_IN && post)
                    {
                        checkFailed(strFmt("@GLS5614", TaxRegistrationNumbers_IN::find(taxWorkTrans.TaxRegistrationNumberTable_IN).RegistrationNumber));
                        throw error("@SYS21533");
                    }
                }

                if (ledgerJournalService.isPurchaseCashAccount_IN()
                    && !ledgerJournalService.isGTAVendorAccount_IN())
                {
                    if (((ledgerJournalService.AccountType         ==  LedgerJournalACType::Ledger     &&
                        ledgerJournalService.OffsetAccountType     ==  LedgerJournalACType::Vend)      ||
                        (ledgerJournalService.OffsetAccountType    ==  LedgerJournalACType::Ledger     &&
                        ledgerJournalService.AccountType           ==  LedgerJournalACType::Vend)))
                    {
                        defaultAccount_IN =  TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId,
                                                                                 TaxAccountType_IN::ServiceTaxInterimRecoverableAccount,
                                                                                 _taxTable.TaxComponentTable_IN);
                    }
                    else if (((ledgerJournalService.AccountType        ==  LedgerJournalACType::Ledger     &&
                             ledgerJournalService.OffsetAccountType    ==  LedgerJournalACType::Cust)      ||
                             (ledgerJournalService.OffsetAccountType   ==  LedgerJournalACType::Ledger     &&
                             ledgerJournalService.AccountType          ==  LedgerJournalACType::Cust)))
                    {
                        defaultAccount_IN =  TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId,
                                                                                 TaxAccountType_IN::ServiceTaxInterimPayableAccount,
                                                                                 _taxTable.TaxComponentTable_IN);
                    }
                }

                if ((ledgerJournalService.orig().AccountType        == LedgerJournalACType::Cust ||
                     ledgerJournalService.orig().OffsetAccountType  == LedgerJournalACType::Cust ||
                     ledgerJournalService.orig().AccountType        == LedgerJournalACType::Vend ||
                     ledgerJournalService.orig().OffsetAccountType  == LedgerJournalACType::Vend)&&
                    (ledgerJournalService.orig().AccountType        == LedgerJournalACType::Bank ||
                     ledgerJournalService.orig().OffsetAccountType  == LedgerJournalACType::Bank) &&
                    !(ledgerJournalService.isGTAVendorAccount_IN() && taxItemGroupHeadingRev.ServiceTaxBasis_IN == ServiceTaxBasis_IN::CashBasis))
                {
                    tmpAccount        = defaultAccount_IN;
                    defaultAccount_IN = serviceAccount;
                    serviceAccount    = tmpAccount;
                }

                if (defaultAccount_IN &&
                   !serviceAccount                 &&
                   isInterCompanyTrans)
                {
                    serviceAccount = defaultAccount_IN;
                    defaultAccount_IN = 0;
                }
                if (!serviceAccount && post)
                {
                    checkFailed(strFmt("@GLS5614", TaxRegistrationNumbers_IN::find(taxWorkTrans.TaxRegistrationNumberTable_IN).RegistrationNumber));
                    throw error("@SYS21533");
                }
            }
            //For Non PO lines
            stcNumber = transTaxInformation.ServiceTaxRegistrationNumber;

            taxLedgerAccountsetupRecId = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(_taxLedgerAccountGroupRecId, TaxAccountCode_IN::Table, stcNumber).RecId;
            if (!taxLedgerAccountsetupRecId)
            {
                taxLedgerAccountsetupRecId = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(_taxLedgerAccountGroupRecId, TaxAccountCode_IN::All).RecId;
            }
            if ((taxWorkTrans.Source == TaxModuleType::Purch) || (taxWorkTrans.Source == TaxModuleType::Sales) || (taxWorkTrans.Source == TaxModuleType::FreeTxtInvoice) || (taxWorkTrans.Source == TaxModuleType::Project))
            {
                serviceAccount = Tax::getDefaultLedgerACServiceTax_IN(taxWorkTrans);// PO, FTI, SO default Account.
            }
            if (defaultAccount_IN)
            {
                taxWorkTrans.LedgerDimension_IN = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount_IN, _dimensionDefault);
            }
            if (taxWorkTrans.ServiceTaxReverseChargePercentage_IN != 0)// For reverse charge feature (Only POT)
            {
                if (ledgerJournalService.orig().isPaymentJournal_IN() == false // For Invoice only
                    && ledgerJournalService.ledgerJournalTable().canApplyServiceReverseCharge_IN(ledgerJournalService.Voucher))
                {
                    // variable 'serviceAccount' for POT invoice is already populated by Legacy code with 'Recoverable account'. We are reusing the value for reverse charge.
                    // So 'LedgerDimensionRev_IN' will contain 'Recoverable'. LedgerDimension contains 'IR' filled by legacy code. LedgerDimension_IN contains 'IP' populated.
                    // This account distribution across the 3- Ledger dimensions is to create minimal disturbance to existing logic.
                    taxWorkTrans.LedgerDimensionRev_IN = LedgerDimensionFacade::serviceCreateLedgerDimension(serviceAccount, _dimensionDefault);
                    serviceAccount = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId,TaxAccountType_IN::ServiceTaxInterimRecoverableAccount, _taxTable.TaxComponentTable_IN);

                    if (transTaxInformation.ServiceTaxGTAServiceCategory == GTAServiceCategory_IN::Others)
                    {
                        serviceAccount = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId,TaxAccountType_IN::ServiceTaxExpenseAccount, _taxTable.TaxComponentTable_IN);
                        taxWorkTrans.LedgerDimensionRev_IN = LedgerDimensionFacade::serviceCreateLedgerDimension(serviceAccount, _dimensionDefault);
                    }
                }
                else if (taxWorkTrans.Source == TaxModuleType::Purch
                         && ((isThisNONPOLine == true && transTaxInformation.ServiceTaxGTAServiceCategory  == GTAServiceCategory_IN::Others)))
                {
                    // For Non-Po Lines salesPurchJournalLineLoc will not have GTAServiceCategory field.The Same field is available in VendInvoiceInfoLineTaxExtension_IN.
                    // IR for reverse tax is populated up, by legacy code.
                    serviceAccount = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId,TaxAccountType_IN::ServiceTaxExpenseAccount, _taxTable.TaxComponentTable_IN);
                    taxWorkTrans.LedgerDimensionRev_IN = LedgerDimensionFacade::serviceCreateLedgerDimension(serviceAccount, _dimensionDefault);
                }
            }
        }

        return serviceAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>serviceTaxAmountCalculated_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates service tax amount.
    /// </summary>
    /// <returns>
    /// The instance of the <c>TaxAmount</c> class.
    /// </returns>
    public TaxAmount serviceTaxAmountCalculated_IN()
    {
        TaxAmount taxAmount;

        while select taxWorkTrans
            where taxWorkTrans.SourceRecId      == this.sourceRecId()       &&
                  taxWorkTrans.SourceTableId    == this.sourceTableId()     &&
                  taxWorkTrans.TaxDirection     != TaxDirection::UseTax     &&
                  taxWorkTrans.TaxOrigin        != TaxOrigin::TaxReversed
        {
            if (TaxTable::find(taxWorkTrans.TaxCode).TaxType_IN == TaxType_IN::ServiceTax)
            {
                if (taxWorkTrans.TaxAutogenerated)
                     taxAmount += taxWorkTrans.SourceTaxAmountCur;
                else
                     taxAmount += taxWorkTrans.SourceRegulateAmountCur;
            }
        }
        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>serviceTaxPOTAdvanceVoucher_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets service tax POT advance voucher.
    /// </summary>
    public void serviceTaxPOTAdvanceVoucher_IN()
    {
        TaxTable            taxTableLoc;
        Sign                taxSign;
        TaxAmountCur        advanceSourceTaxAmountCur;
        TaxAmountCur        advanceSourceBaseAmountCur;
        TaxAmountCur        advanceSourceBaseAmountProrated;
        TaxAmountCur        payableTaxAmountCur;
        TaxAmountCur        payableBaseAmountCur;
        TaxAmountCur        interimPayableTaxAmountCur;
        TaxAmountCur        interimPayableBaseAmountCur;
        TaxItemGroupHeading taxItemGroup;
        TmpTaxWorkTrans     tmpTaxWorkTransPOT;
        MarkupTrans         markupTrans;

        void resetAmountValues()
        {
            payableTaxAmountCur  = 0;
            payableBaseAmountCur = 0;
            interimPayableTaxAmountCur  = 0;
            interimPayableBaseAmountCur = 0;
        }

        void processTmpTaxWorkTransPOT()
        {
            taxSign = (tmpTaxWorkTransPOT.SourceRegulateAmountCur != tmpTaxWorkTransPOT.SourceTaxAmountCur) ? 1 : -1;

            if (advanceSourceTaxAmountCur != 0)
            {
                if (abs(advanceSourceTaxAmountCur) > abs(tmpTaxWorkTransPOT.SourceRegulateAmountCur))
                {
                    payableTaxAmountCur    = 0;
                    payableBaseAmountCur   = 0;
                    interimPayableTaxAmountCur  = abs(tmpTaxWorkTransPOT.SourceRegulateAmountCur);
                    interimPayableBaseAmountCur = abs(tmpTaxWorkTransPOT.SourceBaseAmountCur);
                    advanceSourceTaxAmountCur   = advanceSourceTaxAmountCur - tmpTaxWorkTransPOT.SourceRegulateAmountCur;
                    advanceSourceBaseAmountProrated  = advanceSourceBaseAmountProrated - tmpTaxWorkTransPOT.SourceBaseAmountCur;
                }
                else if (abs(advanceSourceTaxAmountCur) <= abs(tmpTaxWorkTransPOT.SourceRegulateAmountCur))
                {
                    payableTaxAmountCur  = abs(tmpTaxWorkTransPOT.SourceRegulateAmountCur) - abs(advanceSourceTaxAmountCur);
                    payableBaseAmountCur = abs(tmpTaxWorkTransPOT.SourceBaseAmountCur) - abs(advanceSourceBaseAmountProrated);
                    interimPayableTaxAmountCur  = abs(advanceSourceTaxAmountCur);
                    interimPayableBaseAmountCur = abs(advanceSourceBaseAmountProrated);
                    advanceSourceTaxAmountCur   = 0;
                    advanceSourceBaseAmountProrated  = 0;
                }
            }
            else
            {
                //reset the local variables.
                resetAmountValues();
            }

            if (payableTaxAmountCur)
            {
                tmpTaxWorkTransLoc.data(tmpTaxWorkTransPOT);

                if (payableTaxAmountCur)
                {
                    tmpTaxWorkTransLoc.SourceTaxAmountCur = CurrencyExchangeHelper::amount(taxSign * payableTaxAmountCur, sourceCurrencyCode);
                    // By default 'Adjusted amnt = actual amnt' in AX 6.0, if not manually adjusted to different amnt.
                    tmpTaxWorkTransLoc.SourceRegulateAmountCur  = tmpTaxWorkTransLoc.SourceTaxAmountCur;
                }
                if (payableBaseAmountCur)
                {
                    tmpTaxWorkTransLoc.SourceBaseAmountCur = CurrencyExchangeHelper::amount(taxSign * payableBaseAmountCur, sourceCurrencyCode);
                    tmpTaxWorkTransLoc.SourceBaseAmountCurRegulated = 0;
                }

                if (sourceCurrencyCode == Ledger::accountingCurrency())
                {
                    tmpTaxWorkTransLoc.TaxAmount     = tmpTaxWorkTransLoc.SourceTaxAmountCur;
                    tmpTaxWorkTransLoc.TaxBaseAmount = tmpTaxWorkTransLoc.SourceBaseAmountCur;
                }
                else
                {
                    tmpTaxWorkTransLoc.TaxAmount = CurrencyExchangeHelper::mstAmount(tmpTaxWorkTransLoc.SourceRegulateAmountCur, tmpTaxWorkTransLoc.SourceCurrencyCode, tmpTaxWorkTransLoc.TransDate, tmpTaxWorkTransLoc.euroTriangulation ? UnknownNoYes::Unknown : UnknownNoYes::No, exchRate, exchRateSecond);
                    tmpTaxWorkTransLoc.TaxBaseAmount = CurrencyExchangeHelper::mstAmount(tmpTaxWorkTransLoc.SourceBaseAmountCur, tmpTaxWorkTransLoc.SourceCurrencyCode, tmpTaxWorkTransLoc.TransDate, tmpTaxWorkTransLoc.euroTriangulation ? UnknownNoYes::Unknown : UnknownNoYes::No, exchRate, exchRateSecond);
                }
                if (tmpTaxWorkTransLoc.CurrencyCode == tmpTaxWorkTransLoc.SourceCurrencyCode)
                {
                    tmpTaxWorkTransLoc.TaxAmountCur = tmpTaxWorkTransLoc.TaxAmount;
                    tmpTaxWorkTransLoc.TaxBaseAmountCur = tmpTaxWorkTransLoc.TaxBaseAmount;
                }
                else
                {
                    tmpTaxWorkTransLoc.TaxAmountCur = CurrencyExchangeHelper::curAmount(tmpTaxWorkTransLoc.TaxAmount, tmpTaxWorkTransLoc.CurrencyCode, tmpTaxWorkTransLoc.TransDate);
                    tmpTaxWorkTransLoc.TaxBaseAmountCur = CurrencyExchangeHelper::curAmount(tmpTaxWorkTransLoc.TaxBaseAmount, tmpTaxWorkTransLoc.CurrencyCode, tmpTaxWorkTransLoc.TransDate);
                }

                tmpTaxWorkTransLoc.SourceTaxAmountCurReal = tmpTaxWorkTransLoc.SourceTaxAmountCur;
                tmpTaxWorkTransLoc.LedgerDimension = Tax::getPOTAdvanceLedgerDimension_IN(tmpTaxWorkTransLoc);
                tmpTaxWorkTransLoc.insert();
            }

            // After creating the entry to post to ServiceTaxPayable A/C, modify the amount to be posted to InterimPayableA/C, to nullify the same
            // w.r.t the advance payment entry made during payment.
            if (interimPayableTaxAmountCur)
            {
                tmpTaxWorkTransPOT.SourceBaseAmountCur    = CurrencyExchangeHelper::amount(taxSign * interimPayableBaseAmountCur, sourceCurrencyCode);
                tmpTaxWorkTransPOT.SourceTaxAmountCur     = CurrencyExchangeHelper::amount(taxSign * interimPayableTaxAmountCur, sourceCurrencyCode);
                tmpTaxWorkTransPOT.SourceTaxAmountCurReal = tmpTaxWorkTransPOT.SourceTaxAmountCur;
                tmpTaxWorkTransPOT.TaxAmountCur = CurrencyExchangeHelper::amount(taxSign * interimPayableTaxAmountCur, sourceCurrencyCode);

                if (sourceCurrencyCode == Ledger::accountingCurrency())
                {
                    tmpTaxWorkTransPOT.TaxAmount     = tmpTaxWorkTransPOT.SourceTaxAmountCur;
                    tmpTaxWorkTransPOT.TaxBaseAmount = tmpTaxWorkTransPOT.SourceBaseAmountCur;
                    tmpTaxWorkTransPOT.TaxBaseAmountCur = tmpTaxWorkTransPOT.SourceBaseAmountCur;
                }
                else
                {
                    tmpTaxWorkTransPOT.TaxAmount = CurrencyExchangeHelper::mstAmount(tmpTaxWorkTransPOT.SourceRegulateAmountCur, tmpTaxWorkTransPOT.SourceCurrencyCode, tmpTaxWorkTransPOT.TransDate, tmpTaxWorkTransPOT.euroTriangulation ? UnknownNoYes::Unknown : UnknownNoYes::No, exchRate, exchRateSecond);
                    tmpTaxWorkTransPOT.TaxBaseAmount = CurrencyExchangeHelper::mstAmount(tmpTaxWorkTransPOT.SourceBaseAmountCur, tmpTaxWorkTransPOT.SourceCurrencyCode, tmpTaxWorkTransPOT.TransDate, tmpTaxWorkTransPOT.euroTriangulation ? UnknownNoYes::Unknown : UnknownNoYes::No, exchRate, exchRateSecond);
                }
                if (tmpTaxWorkTransPOT.CurrencyCode == tmpTaxWorkTransPOT.SourceCurrencyCode)
                {
                    tmpTaxWorkTransPOT.TaxAmountCur = tmpTaxWorkTransPOT.TaxAmount;
                    tmpTaxWorkTransPOT.TaxBaseAmountCur = tmpTaxWorkTransPOT.TaxBaseAmount;
                }
                else
                {
                    tmpTaxWorkTransPOT.TaxAmountCur = CurrencyExchangeHelper::curAmount(tmpTaxWorkTransPOT.TaxAmount, tmpTaxWorkTransPOT.CurrencyCode, tmpTaxWorkTransPOT.TransDate);
                    tmpTaxWorkTransPOT.TaxBaseAmountCur = CurrencyExchangeHelper::curAmount(tmpTaxWorkTransPOT.TaxBaseAmount, tmpTaxWorkTransPOT.CurrencyCode, tmpTaxWorkTransPOT.TransDate);
                }

                tmpTaxWorkTransPOT.update();
            }
            else
            {
                //Updates the LedgerDimension with the serviceTaxPayableAccount.
                //By default when payement is attached ledgerDimension stores ServiceTaxinterimPayable Account.
                tmpTaxWorkTransPOT.LedgerDimension = Tax::getPOTAdvanceLedgerDimension_IN(tmpTaxWorkTransPOT);
                tmpTaxWorkTransPOT.update();
            }
        }

        //Group by TaxCode and compare the totalTaxAmount per TaxCode exceeds the Advance payment taxAmount.
        while select sum(SourceRegulateAmountCur),
                TaxCode, Company, CurrencyCode, TransDate, HeadingTableId, HeadingRecId
            from taxWorkTrans
            group by TaxCode, Company, CurrencyCode, TransDate, HeadingTableId, HeadingRecId
            where taxWorkTrans.HeadingRecId == headingRecId
               && taxWorkTrans.HeadingTableId == headingTableId
               && taxWorkTrans.TaxOrigin != TaxOrigin::TaxReversed
                    exists join taxTableLoc
                    where taxTableLoc.TaxCode    == taxWorkTrans.TaxCode
                       && taxTableLoc.TaxType_IN == TaxType_IN::ServiceTax
                    exists join taxItemGroup
                    where taxItemGroup.TaxItemGroup       == taxWorkTrans.TaxItemGroup
                       && taxItemGroup.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis
        {
            [advanceSourceBaseAmountCur, advanceSourceTaxAmountCur, advanceSourceBaseAmountProrated] = Tax::getAdvanceAmount_IN(taxWorkTrans.TaxCode, this.headingTableId(), this.headingRecId(),null,taxWorkTrans);

            if (advanceSourceTaxAmountCur != 0
                && (abs(advanceSourceTaxAmountCur) - abs(taxWorkTrans.SourceRegulateAmountCur) < 0))
            {
                ttsbegin;
                tmpTaxWorkTransPOT.setTmpData(taxWorkTrans);
                //reset the local variables.
                resetAmountValues();

                //Loop for all the lines for given TaxCode and insert the payable records and interim payable records after comparing with the advance payment taxAmount.
                while select forupdate tmpTaxWorkTransPOT
                    order by SourceRecId
                    where tmpTaxWorkTransPOT.TaxCode == taxWorkTrans.TaxCode
                        && tmpTaxWorkTransPOT.HeadingTableId == taxWorkTrans.HeadingTableId
                        && tmpTaxWorkTransPOT.HeadingRecId   == taxWorkTrans.HeadingRecId
                        && tmpTaxWorkTransPOT.SourceTableId  != tableNum(MarkupTrans)
                {
                    processTmpTaxWorkTransPOT();
                }

                while select forupdate tmpTaxWorkTransPOT
                    order by SourceRecId
                    where tmpTaxWorkTransPOT.TaxCode == taxWorkTrans.TaxCode
                        && tmpTaxWorkTransPOT.HeadingTableId == taxWorkTrans.HeadingTableId
                        && tmpTaxWorkTransPOT.HeadingRecId   == taxWorkTrans.HeadingRecId
                        && tmpTaxWorkTransPOT.SourceTableId  == tableNum(MarkupTrans)
                    exists join markupTrans
                        where markupTrans.RecId == tmpTaxWorkTransPOT.SourceRecId
                            && markupTrans.TransTableId == tableNum(CustInvoiceJour)
                {
                    processTmpTaxWorkTransPOT();
                }

                while select forupdate tmpTaxWorkTransPOT
                    where tmpTaxWorkTransPOT.TaxCode == taxWorkTrans.TaxCode
                        && tmpTaxWorkTransPOT.HeadingTableId == taxWorkTrans.HeadingTableId
                        && tmpTaxWorkTransPOT.HeadingRecId   == taxWorkTrans.HeadingRecId
                        && tmpTaxWorkTransPOT.SourceTableId  == tableNum(MarkupTrans)
                    join TransRecId, RecId from markupTrans
                        order by TransRecId, RecId
                        where markupTrans.RecId == tmpTaxWorkTransPOT.SourceRecId
                            && markupTrans.TransTableId == tableNum(CustInvoiceTrans)
                {
                    processTmpTaxWorkTransPOT();
                }

                ttscommit;
            }
        }
        // End outer while
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCashDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the <c>cashDiscAmount</c> field and may set the <c>cashDiscPercent</c> field.
    /// </summary>
    /// <param name="_cashDiscPercent">
    ///    The value to set the <c>cashDiscPercent</c> field to, if the amount includes tax. If the amount
    ///    does not include tax and the <paramref name="_cashDiscAmount" /> parameter is not provided, this
    ///    parameter is used to calculate the <c>cashDiscAmount</c> field.
    /// </param>
    /// <param name="_cashDiscAmount">
    ///    The value to set the <c>cashDiscAmount</c> field to. If this value is provided, the <paramref
    ///    name="_cashDiscPercent" /> parameter will be ignored.
    /// </param>
    void setCashDiscount(Percent   _cashDiscPercent,
                          AmountCur _cashDiscAmount)
    {
        ;
        cashDiscAmount = 0;
        cashDiscPercent = 0;

        if (TaxIntegrationUtils::shouldRetrieveCashDiscParametersFromTaxService(this.headingTableId(), this.headingRecId())
            || this.taxParameters().TaxLessCashDisc)
        {
            cashDiscAmount  = _cashDiscAmount;
            if (!cashDiscAmount)

                cashDiscPercent = _cashDiscPercent;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustomsAccNum_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets customs account number.
    /// </summary>
    /// <param name="_accountNum">
    /// The account number.
    /// </param>
    /// <param name="_taxAccountType">
    /// The tax account type.
    /// </param>
    public void setCustomsAccNum_IN(RefRecId _accountNum,  TaxAccountType_IN  _taxAccountType)
    {
        if (_taxAccountType == TaxAccountType_IN::CustomsExportDutyExpenseAccount)
        {
            customsExpAccNum = _accountNum;
        }
        else if (_taxAccountType == TaxAccountType_IN::CustomsImportDutyPayableAccount)
        {
            customsImpAccNum = _accountNum;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setExchRates</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets and sets the currency and exchange rate information about tax.
    /// </summary>
    /// <param name="_sourceCurrencyCode">
    ///    The currency code of the transaction; optional.
    /// </param>
    /// <param name="_exchRate">
    ///    The primary exchange rate that will be used for currency conversions between transactional and
    ///    master currency; optional.
    /// </param>
    /// <param name="_exchRateSecond">
    ///    The secondary exchange rate that will be used for currency conversions between transactional and
    ///    master currency; optional.
    /// </param>
    /// <param name="_exchRatesTriangulation">
    ///    A Boolean value that specifies whether triangulation is required; optional.
    /// </param>
    /// <param name="_exchRateDate">
    ///    The date for the given exchange rate; optional.
    /// </param>
    void setExchRates(  CurrencyCode            _sourceCurrencyCode     = sourceCurrencyCode,
                        ExchRate                _exchRate               = exchRate,
                        ExchRate                _exchRateSecond         = exchRateSecond,
                        ExchRatesTriangulation  _exchRatesTriangulation = UnknownNoYes::Unknown,
                        TransDate               _exchRateDate                = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        ;

        sourceCurrencyCode  = _sourceCurrencyCode;
        triangulation = Currency::unknownNoYes2Noyes(_exchRatesTriangulation, _sourceCurrencyCode, _exchRateDate);
        exchRate = _exchRate;
        exchRateSecond = _exchRateSecond;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReportingCurrencyExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the reporting currency exchnage rate
    /// </summary>
    /// <param name = "_reportingCurrencyExchRate">Reporting currency exchange rate</param>
    /// <param name = "_reportingCurrencyExchRateSecondary">Secondary reporting currency exchange rate</param>
    public void setReportingCurrencyExchRate( ReportingCurrencyExchRate _reportingCurrencyExchRate,
                                       ReportingCurrencyExchRate _reportingCurrencyExchRateSecondary)
    {
        reportingCurrencyExchRate = _reportingCurrencyExchRate;
        reportingCurrencyExchRateSecondary = _reportingCurrencyExchRateSecondary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setEximTaxes_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets exim taxes.
    /// </summary>
    public void setEximTaxes_IN()
    {
        taxWorkTrans.EximTaxAmount_IN                    = eximTaxAmountCalc;
        taxWorkTrans.EximBalanceTaxAmount_IN             = eximBalanceTaxAmtCalc;
        taxWorkTrans.EximTaxAmountCur_IN                 = eximTaxAmountCur;
        taxWorkTrans.EximBalanceTaxAmountCur_IN          = eximBalanceTaxAmountCur;
        taxWorkTrans.EximDEPBAmount_IN                   = depbAmountCalc;
        taxWorkTrans.EximDEPBAmountCur_IN                = depbAmountCalcCur;
        taxWorkTrans.EximTaxCorrectedAmount_IN           = eximTotalTaxAmount;
        taxWorkTrans.EximBalanceTaxCorrectedAmount_IN    = eximTotalBalanceTaxAmount;
        taxWorkTrans.EximTaxCorrectedAmountCur_IN        = eximTotalTaxAmountCur;
        taxWorkTrans.EximBalanceTaxCorrectedAmountCur_IN = eximTotalBalanceTaxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLedgerDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the ledger dimensions for the <c>TmpTaxWorkTrans</c> record.
    /// </summary>
    /// <param name="_taxWorkTrans">
    ///    The <c>TmpTaxWorkTrans</c> table buffer.
    /// </param>
    /// <param name="_taxTable">
    ///    The <c>TaxTable</c> table buffer.
    /// </param>
    /// <param name="_dimensionDefault">
    ///    The default dimensions.
    /// </param>
    /// <param name="_operationLedgerDimension">
    ///    The default operation ledger dimension.
    /// </param>
    protected void setLedgerDimensions(TmpTaxWorkTrans _taxWorkTrans, TaxTable _taxTable, DimensionDefault _dimensionDefault, LedgerDimensionAccount _operationLedgerDimension)
    {
        TaxLedgerAccountGroup           taxLedgerAccountGroup;
        LedgerDimensionDefaultAccount   defaultAccount;
        LedgerJournalTrans              ledgerJournalTrans;
        ItemId                          itemId;
        SalesLine                       salesLineLoc;
        PurchLine                       purchLineLoc;
        EcoResCategoryId                categoryId;
        // <GEERU>
        #ISOCountryRegionCodes

        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        if (DimensionAttributeValueCombination::find(_operationLedgerDimension).LedgerDimensionType == LedgerDimensionType::DefaultAccount)
        {
            _taxWorkTrans.OperationLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(_operationLedgerDimension);
        }
        else
        {
            _taxWorkTrans.OperationLedgerDimension = _operationLedgerDimension;
        }

        if (_taxWorkTrans.ExemptTax == NoYes::No)
        {
            changecompany(this.getCompany())
            {
                taxLedgerAccountGroup   = TaxLedgerAccountGroup::find(_taxTable.TaxAccountGroup);

                // get the default tax LedgerDimension
                // <GEERU>
                if (countryRegion_RU)
                {
                    defaultAccount                        = this.ledgerDimension_RU(taxWorkTrans,taxLedgerAccountGroup);
                    taxWorkTrans.OffsetLedgerDimension_RU = LedgerDimensionFacade::serviceCreateLedgerDimension(this.offsetLedgerDimension_RU(taxLedgerAccountGroup), _dimensionDefault);
                    taxWorkTrans.PostingProfile_RU        = this.postingProfile_RU();
                    taxWorkTrans.InventProfileType_RU     = this.inventProfileType_RU();
                }
                else
                {
                    // </GEERU>
                    defaultAccount = taxLedgerAccountGroup.taxLedgerDimension(_taxWorkTrans.TaxDirection);
                    // <GEERU>
                }
                // </GEERU>

                // Apply the default dimensions passed in.
                if (defaultAccount != 0)
                {
                    _taxWorkTrans.LedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount, _dimensionDefault);
                }
            }

            if (_taxWorkTrans.TaxDirection == TaxDirection::UseTax)
            {
                changecompany(this.getCompany())
                {
                    // get the use tax payable account
                    defaultAccount = taxLedgerAccountGroup.TaxOffsetUseTaxLedgerDimension;

                    if (defaultAccount != 0)
                    {
                        // Apply the default dimensions passed in.
                        _taxWorkTrans.TaxOffsetUseTaxLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount, _dimensionDefault);
                    }
                }
            }
            // <GBR>
            if (isBrazilEnabled)
            {
                if (_taxWorkTrans.TaxDirection == TaxDirection::OutgoingTax && !TaxTable::find(_taxWorkTrans.TaxCode).RetainedTax_BR)
                {
                    defaultAccount = taxLedgerAccountGroup.TaxSalesOffsetLedgerDimension_BR;

                    if (defaultAccount != 0)
                    {
                        _taxWorkTrans.TaxSalesOffsetLedgerDimension_BR = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount, _dimensionDefault);
                    }
                }
            }
            // </GBR>
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX]))
        {
            if (_taxWorkTrans.Source == TaxModuleType::Sales)
            {
                salesLineLoc = SalesLine::findInventTransId(_taxWorkTrans.InventTransId);
                itemId       = salesLineLoc.ItemId;
                categoryId   = salesLineLoc.SalesCategory;
            }
            else if (_taxWorkTrans.Source == TaxModuleType::Purch)
            {
                purchLineLoc = PurchLine::findInventTransId(_taxWorkTrans.InventTransId);
                itemId       = purchLineLoc.ItemId;
                categoryId   = purchLineLoc.ProcurementCategory;
            }

            if (((itemId || categoryId) || _taxWorkTrans.Source == TaxModuleType::Voucher) && TaxTable::find(_taxWorkTrans.TaxCode).UnrealizedTax)
            {
                taxLedgerAccountGroup = TaxLedgerAccountGroup::find(TaxTable::find(_taxWorkTrans.TaxCode).TaxAccountGroup);

                _taxWorkTrans.LedgerDimension = taxLedgerAccountGroup.TaxUnrealizedPayablesLedgerDimension;

                if (itemId)
                {
                    if (_taxWorkTrans.Source == TaxModuleType::Purch)
                    {
                        if (InventTable::find(itemId).ItemType == ItemType::Service)
                        {
                            _taxWorkTrans.LedgerDimension = taxLedgerAccountGroup.TaxUnrealizedReceivablesLedgerDimension;
                        }
                        else
                        {
                            _taxWorkTrans.LedgerDimension = taxLedgerAccountGroup.TaxIncomingLedgerDimension;
                        }
                    }
                    else if (_taxWorkTrans.Source == TaxModuleType::Sales)
                    {
                        if (InventTable::find(itemId).ItemType == ItemType::Service)
                        {
                            _taxWorkTrans.LedgerDimension = taxLedgerAccountGroup.TaxUnrealizedPayablesLedgerDimension;
                        }
                        else
                        {
                            _taxWorkTrans.LedgerDimension = taxLedgerAccountGroup.TaxOutgoingLedgerDimension;
                        }
                    }
                }
                else if (_taxWorkTrans.Source == TaxModuleType::Voucher)
                {
                    ledgerJournalTrans = LedgerJournalTrans::findLedgerJournalId(_taxWorkTrans.Voucher);
                    if (ledgerJournalTrans)
                    {
                        if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
                        {
                            taxWorkTrans.LedgerDimension = taxLedgerAccountGroup.TaxUnrealizedReceivablesLedgerDimension;
                        }
                        else if (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
                        {
                            taxWorkTrans.LedgerDimension = taxLedgerAccountGroup.TaxUnrealizedPayablesLedgerDimension;
                        }
                    }
                }
                if (_taxWorkTrans.LedgerDimension != 0)
                {
                    _taxWorkTrans.LedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(_taxWorkTrans.LedgerDimension, _dimensionDefault);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLedgerDimensionsInternal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the ledger dimensions for the <c>TmpTaxWorkTrans</c> record.
    /// </summary>
    /// <param name="_taxWorkTrans">
    ///    The <c>TmpTaxWorkTrans</c> table buffer.
    /// </param>
    /// <param name="_taxTable">
    ///    The <c>TaxTable</c> table buffer.
    /// </param>
    /// <param name="_dimensionDefault">
    ///    The default dimensions.
    /// </param>
    /// <param name="_operationLedgerDimension">
    ///    The default operation ledger dimension.
    /// </param>
    internal void setLedgerDimensionsInternal(TmpTaxWorkTrans _taxWorkTrans, TaxTable _taxTable, DimensionDefault _dimensionDefault, LedgerDimensionAccount _operationLedgerDimension)
    {
        this.setLedgerDimensions(_taxWorkTrans, _taxTable, _dimensionDefault, _operationLedgerDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxAmountQty_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets tax amount quantity.
    /// </summary>
    /// <param name="_taxTable">
    /// The tax table.
    /// </param>
    /// <param name="_baseQty">
    /// The base quantity.
    /// </param>
    /// <param name="_baseUnit">
    /// The base unit.
    /// </param>
    /// <param name="_itemId">
    /// The item id.
    /// </param>
    /// <param name="_currencyMST">
    /// The currency MST.
    /// </param>
    /// <param name="_baseAmountMST">
    /// The base amount MST.
    /// </param>
    /// <param name="_taxWorkTrans">
    /// The tax work transaction.
    /// </param>
    /// <param name="_baseAmount">
    /// The base amount.
    /// </param>
    public void setTaxAmountQty_IN(
        TaxTable            _taxTable,
        TaxBase             _baseQty,
        UnitOfMeasureSymbol _baseUnit,
        ItemId              _itemId,
        Currency            _currencyMST,
        TaxBase             _baseAmountMST,
        TmpTaxWorkTrans     _taxWorkTrans,
        TaxBase             _baseAmount)
    {
        TaxTable taxTable;
        taxTable = _taxTable;

        InventDimId convertDimId = InventTransOrigin::findByInventTransId(_taxWorkTrans.InventTransId).ItemInventDimId;

        if (taxTable.TaxBase == TaxBaseType::PctPerNet
            && taxTable.TaxUnit)
        {
            taxQty = EcoResProductUnitConverter::convertForReleasedProduct(_itemId,
                                                                           convertDimId,
                                                                           _baseQty,
                                                                           UnitOfMeasure::unitOfMeasureIdBySymbol(_baseUnit),
                                                                           0,
                                                                           NoYes::Yes);
        }
        else
        {
            taxQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_itemId,
                                                                                           convertDimId,
                                                                                           _baseQty,
                                                                                           _baseUnit,
                                                                                           taxTable.TaxUnit,
                                                                                           NoYes::Yes);
        }
        if (taxTable.TaxBase == TaxBaseType::AmountByUnit)
        {
            if (taxTable.TaxPackagingTax)
            {
                _taxWorkTrans.TaxBaseQty = Tax::packagingQuantity(
                                            _baseQty,
                                            _baseUnit,
                                            _itemId,
                                            convertDimId);
            }
            else
            {
                _taxWorkTrans.TaxBaseQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_itemId,
                                                                                                                 convertDimId,
                                                                                                                 _baseQty,
                                                                                                                 _baseUnit,
                                                                                                                 taxTable.TaxUnit,
                                                                                                                 NoYes::Yes);
            }
        }
        else
        {
            _taxWorkTrans.TaxBaseAmount          = _currencyMST.amount_Instance(_baseAmountMST);
            _taxWorkTrans.TaxBaseAmountRaw       = _baseAmountMST;
            _taxWorkTrans.SourceBaseAmountCur    = this.getSourceCurrency().amount_Instance(_baseAmount);
            _taxWorkTrans.SourceBaseAmountCurRaw = _baseAmount;
            _taxWorkTrans.CurrencyCode           = taxTable.TaxCurrencyCode;
            _taxWorkTrans.TaxBaseAmountCur       = CurrencyExchangeHelper::curAmount(_taxWorkTrans.TaxBaseAmount, _taxTable.TaxCurrencyCode, taxDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setValidateWarning</Name>
				<Source><![CDATA[
    private void setValidateWarning(TaxLimitBase _taxLimitBase, TaxWarning _taxWarning, Common source)
    {
        boolean warningDisplayed = false;
        TmpTax tmpTaxLocal;
        TmpTaxWorkTrans tmpTaxWorkTrans;

        if (_taxWarning == TaxWarning::NoWarning)
        {
            return;
        }

        if (taxIncludedInItemPrice &&
           (_taxLimitBase == TaxLimitBase::InvoiceWithoutVAT ||
            _taxLimitBase == TaxLimitBase::InvoiceInclVAT))
        {
            switch (source.TableId)
            {
                case tmpTax.TableId:
                    tmpTaxLocal = source as TmpTax;
                    if (tmpTaxLocal.Warning == TaxWarning::NoWarning)
                    {
                        tmpTaxLocal.Warning = _taxWarning;

                        if (tmpTaxLocal.Warning == TaxWarning::InvalidTaxIncludedTaxCode && !warningDisplayed)
                        {
                            warning(strFmt("@Tax:TaxInclPerTotalCalcWithTaxLimitWarning", tmpTaxLocal.TaxCode));
                            warningDisplayed = true;
                        }
                    }
                    break;
                case tmpTaxWorkTrans.TableId:
                    tmpTaxWorkTrans = source as TmpTaxWorkTrans;
                    if (tmpTaxWorkTrans.Warning == TaxWarning::NoWarning)
                    {
                        tmpTaxWorkTrans.Warning = _taxWarning;

                        if (tmpTaxWorkTrans.Warning == TaxWarning::InvalidTaxIncludedTaxCode)
                        {
                            warning(strFmt("@Tax:TaxInclPerTotalCalcWithTaxLimitWarning", tmpTaxWorkTrans.TaxCode));
                            warningDisplayed = true;
                        }
                    }
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showInventTransTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Shows invent transaction tax.
    /// </summary>
    /// <param name="_taxGroup">
    /// The tax group.
    /// </param>
    /// <param name="_itemGroup">
    /// The item group.
    /// </param>
    /// <param name="_transferId">
    /// The transfer id.
    /// </param>
    /// <param name="_itemId">
    /// The item id.
    /// </param>
    /// <param name="_date">
    /// The transaction date.
    /// </param>
    public void showInventTransTax_IN(TaxGroup                  _taxGroup,
                                      TaxItemGroup              _itemGroup,
                                      InventTransferId          _transferId,
                                      ItemId                    _itemId,
                                      InventTransferShipDate    _date)
    {
        this.insertIntersection(_taxGroup, _itemGroup, _transferId, _itemId, _date);
    }

]]></Source>
			</Method>
			<Method>
				<Name>showTaxesNotSourceSingleLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax amount for not source single line.
    /// </summary>
    /// <returns>The tax amounts in container.</returns>
    container showTaxesNotSourceSingleLine()
    {
        ;
        if (sourceSingleLine)
            return [sourceSingleLine, 0];

        return [sourceSingleLine, this.totalTaxAmountCalculated()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>showTaxesSourceSingleLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax amount for source single line.
    /// </summary>
    /// <param name = "_sourceTableId">The source table id.</param>
    /// <param name = "_sourceRecId">The source recid.</param>
    /// <param name = "_includeUseTax">Whether include use tax.</param>
    /// <returns>The tax amounts in container.</returns>
    container showTaxesSourceSingleLine(TableId _sourceTableId, RecId _sourceRecId, boolean _includeUseTax = false)
    {
        AmountCur   taxAmountCur;
        AmountCur   taxRegulation;
        // <GIN>
        AmountMST   eximTaxAmountMST;
        AmountMST   eximBalanceTaxAmountMST;
        AmountMST   correctedCustomsDuty;
        boolean     isImportOrderExim;
        // </GIN>
        ;

        // <GIN>
        if (isCustomsEnabled

            && PurchLine::findRecId(_sourceRecId).purchTable().purchTable_W().CustomsImportOrder_IN
            && isEximIncentiveSchemEnabled)
        {
            isImportOrderExim = true;
        }
        // </GIN>

        if (_includeUseTax)
        {
            taxAmountCur = this.totalTaxAmountSingleLineIncludeUseTax(_sourceTableId, _sourceRecId);
            taxRegulation = this.totalRegTaxAmountSingleLineIncludeUseTax(_sourceTableId, _sourceRecId);
            // <GIN>
            if (isCustomsEnabled

                && isImportOrderExim)
            {
                eximTaxAmountMST        = this.eximTaxSingleLineInclUseTax_IN(_sourceTableId, _sourceRecId);
                eximBalanceTaxAmountMST = this.eximBalTaxSingleLineInclUseTax_IN(_sourceTableId, _sourceRecId);
                correctedCustomsDuty    = this.eximBalTaxRegSingleLineInclUseTax_IN(_sourceTableId, _sourceRecId);
            }
            // </GIN>
        }
        else
        {
            taxAmountCur  = this.totalTaxAmountSingleLine(_sourceTableId, _sourceRecId);
            taxRegulation = this.totalRegulatedTaxAmountSingleLine(_sourceTableId, _sourceRecId);
        }

        // <GIN>
        if (isCustomsEnabled

            && isImportOrderExim)
        {
            return [taxAmountCur, taxRegulation, eximTaxAmountMST, eximBalanceTaxAmountMST, correctedCustomsDuty];
        }
        else
        {
            // </GIN>
            return [taxAmountCur, taxRegulation];
            // <GIN>
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>singleLineTaxRegulationAmountAccCur_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total customs amount for single line in accounting currency.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The source table id.
    /// </param>
    /// <param name="_sourceRecId">
    /// The source rec id.
    /// </param>
    /// <returns>
    /// The regulated tax amount for single line in accounting currency
    /// </returns>
    public AmountMST singleLineTaxRegulationAmountAccCur_IN(
        RefTableId _sourceTableId = 0,
        RefRecId   _sourceRecId = 0)
    {
        TaxTable    taxTable;

        select sum(SourceRegulateAmountCustoms_IN) from taxWorkTrans
            where taxWorkTrans.SourceTableId == _sourceTableId
                && taxWorkTrans.SourceRecId   == _sourceRecId
                && taxWorkTrans.TaxDirection  != TaxDirection::UseTax
                && taxWorkTrans.TaxOrigin     != TaxOrigin::TaxReversed
            join TaxCode, TaxType_IN from taxTable
                where taxTable.TaxCode    == taxWorkTrans.TaxCode
                    && taxTable.TaxType_IN == TaxType_IN::Customs;

        return taxWorkTrans.SourceRegulateAmountCustoms_IN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipTaxCalculations</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines if taxes need to be calculated.
    /// </summary>
    /// <returns>
    ///   true if taxes need to be calculated for the source document; otherwise, false.
    /// </returns>
    public boolean skipTaxCalculations()
    {
        if (!skipTaxCalculationsChecked)
        {
            if (this.doAdjustmentsExist())
            {
                skipTaxCalculations = false;
            }
            else
            {
                //<GTE>
                if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
                {
                    skipTaxCalculations = false;
                }
                else
                {
                    //</GTE>
                    skipTaxCalculations = !this.sourceLinesHaveTaxGroups();
                    //<GTE>
                }
                //</GTE>
            }
            skipTaxCalculationsChecked = true;
        }

        return skipTaxCalculations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceLinesHaveTaxGroups</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets a value that indicates if the source transactions have lines with sales or item tax groups.
    /// </summary>
    /// <returns>
    ///   true if at least one source transaction line has a sales or item tax group; otherwise, false.
    /// </returns>
    /// <remarks>
    ///   This default implementation always returns true.
    /// </remarks>
    protected boolean sourceLinesHaveTaxGroups()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the record ID of the transaction line to calculate.
    /// </summary>
    /// <returns>
    ///    The record ID of the transaction line to calculate.
    /// </returns>
    /// <remarks>
    ///    This method is designed to be overridden by derived classes. The base implementation returns 0.
    /// </remarks>
    public RecId sourceRecId()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceSingleLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether it is a source single line.
    /// </summary>
    /// <param name = "_set">The set.</param>
    /// <param name = "_sourceSingleLine">The source single line</param>
    /// <returns>true if it is a source singel line; otherwise false.</returns>
    boolean sourceSingleLine(boolean _set               = false,
                             boolean _sourceSingleLine  = false)
    {
        if (_set)
            sourceSingleLine = _sourceSingleLine;

        return sourceSingleLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTableId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the table ID of the transaction to tax.
    /// </summary>
    /// <returns>
    ///    The ID of the transaction to tax.
    /// </returns>
    /// <remarks>
    ///    This method is overridden by derived classes. The base implementation returns 0.
    /// </remarks>
    public RefTableId sourceTableId()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reasonTableRefRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the record ID of the reason reference.
    /// </summary>
    /// <returns>
    ///    The record ID of the reason reference.
    /// </returns>
    /// <remarks>
    ///    This method presumes backing field assignment is implemented by derived classes.
    /// </remarks>
    public ReasonTableRefRecId reasonTableRefRecId()
    {
        return reasonTableRefRecIdBeingCalculated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumUpTaxCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sums the tax amounts by tax code.
    /// </summary>
    /// <param name = "_taxCode">The tax code.</param>
    /// <param name = "_isScrapQtyLine_IN">Whether is scrap quantity line.</param>
    protected void sumUpTaxCode(
        TaxCode   _taxCode
        , NoYes   _isScrapQtyLine_IN = NoYes::No
        )
    {
        // this method is the same as sys, revert the change of 1689872
        CurrencyCode            currencyCode;
        Currency                currency;
        Currency                currencyMST;
        Currency                currencySource;
        // <GIN>
        SalesLine               salesLineLoc;
        // </GIN>
        changecompany(this.getCompany())
        {
            currencyCode = this.getTaxTable(_taxCode).TaxCurrencyCode;
            currency = Currency::find(currencyCode);

            currencyMST = this.getCompanyCurrency();
            currencySource = this.getSourceCurrency();
        }
        // <GIN>
        if (isTaxParametersEnabled &&

            salesPurchJournalLineLoc.SourceTableId == tableNum(SalesLine))
        {
            salesLineLoc = SalesLine::findRecId(salesPurchJournalLineLoc.SourceRecId);
        }
        // </GIN>

        select sum(TaxAmountMST),

               sum(TaxBaseAmountMST),
               sum(TaxBaseAmountMSTRaw),
               sum(TaxBaseQty),
               sum(TaxInCostPrice),
               sum(TaxInCostPriceCur),
               sum(TaxInCostPriceMST),
               sum(TaxAmountCur),
               sum(SourceTaxAmountCur),
               sum(SourceTaxAmountCurReal),
               sum(SourceTaxBaseAmountCur),
               sum(SourceTaxBaseAmountCurRaw),
               sum(TaxBaseAmountCur)
               // <GIN>
               ,sum(CustomsDuty_IN),
               sum(AbatementAmount_IN),
               sum(EximTaxAmount_IN),
               sum(EximTaxAmountCur_IN),
               sum(EximBalanceTaxAmount_IN),
               sum(EximBalanceTaxAmountCur_IN),
               sum(EximDEPBAmount_IN),
               // </GIN>
               // <GBR>
               sum(TaxSubstitutionAmountAddedMST_BR),
               sum(SourceTaxSubstitutionAmountAddedCur_BR)
               // </GBR>
               from tmpTax
               group by tmpTax.Warning
               where tmpTax.TaxCode == _taxCode
                    // <GIN>
                    && (!isIndiaCountryRegionEnabled || tmpTax.IsScrapQtyLine_IN == _isScrapQtyLine_IN)
                    // </GIN>
                    ;

        taxBaseQtyCalc = tmpTax.TaxBaseQty;

        taxAmountCalc                   = currencyMST.amount_Instance(tmpTax.TaxAmountMST);
        taxAmountCalcCur                = currency.amount_Instance(tmpTax.TaxAmountCur);
        taxBaseAmountCalc               = currencyMST.amount_Instance(tmpTax.TaxBaseAmountMST);
        taxBaseAmountCalcRaw            = tmpTax.TaxBaseAmountMSTRaw;
        taxBaseAmountCalcCur            = currency.amount_Instance(tmpTax.TaxBaseAmountCur);
        taxInCostPriceCalc              = currencySource.amount_Instance(tmpTax.TaxInCostPrice);
        taxInCostPriceMSTCalc           = currencyMST.amount_Instance(tmpTax.TaxInCostPriceMST);
        taxInCostPriceCurCalc           = currency.amount_Instance(tmpTax.TaxInCostPriceCur);
        taxAmountCalcSourceCur          = currencySource.amount_Instance(tmpTax.SourceTaxAmountCur);
        taxAmountCalcSourceCurReal      = tmpTax.SourceTaxAmountCurReal;

        // <GIN>
        if ((isExciseEnabled || isVATEnabled) &&

            salesLineLoc.RecId &&
            ReturnDispositionCode::find(salesLineLoc.ReturnDispositionCodeId).DispositionAction == DispositionAction::ReturnToCust
            )
        {
            taxAmountCalcSourceCur          = 0;
            taxAmountCalcSourceCurReal      = 0;
        }
        // </GIN>
        taxBaseAmountCalcSourceCur      = currencySource.amount_Instance(tmpTax.SourceTaxBaseAmountCur);
        taxBaseAmountCalcSourceCurRaw   = tmpTax.SourceTaxBaseAmountCurRaw;
        taxWarning                      = tmpTax.Warning;

        // <GIN>
        if (isCustomsEnabled                &&

            TaxTable::find(_taxCode).TaxType_IN == TaxType_IN::Customs)
        {
            customsTaxAmountCalc    = CurrencyExchangeHelper::amount(tmpTax.CustomsDuty_IN, currencyMST.CurrencyCode);

            if (isEximIncentiveSchemEnabled)
            {
                eximTaxAmountCalc       = CurrencyExchangeHelper::amount(tmpTax.EximTaxAmount_IN, currencyMST.CurrencyCode);
                eximTaxAmountCur       = currency.amount_Instance(tmpTax.EximTaxAmountCur_IN);
                eximBalanceTaxAmtCalc   = CurrencyExchangeHelper::amount(tmpTax.EximBalanceTaxAmount_IN, currencyMST.CurrencyCode);
                eximBalanceTaxAmountCur   = currency.amount_Instance(tmpTax.EximBalanceTaxAmountCur_IN);
                depbAmountCalc          = CurrencyExchangeHelper::amount(tmpTax.EximDEPBAmount_IN, currencyMST.CurrencyCode);
            }
        }
        if (isTaxParametersEnabled)
        {
            abatementAmount = tmpTax.AbatementAmount_IN;
        }
        // </GIN>

        // <GBR>
        if (isBrazilEnabled)
        {
            taxSubstitutionAmountAddedMST_BR        = tmpTax.TaxSubstitutionAmountAddedMST_BR;
            sourceTaxSubstitutionAmountAddedCur_BR  = tmpTax.SourceTaxSubstitutionAmountAddedCur_BR;
        }
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>supportAmountByUnit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the tax calculation engine should calculate tax for the tax code origin of
    ///    amount per unit.
    /// </summary>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    public boolean supportAmountByUnit()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountCalculated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the calculated tax amount.
    /// </summary>
    /// <returns>The calculated tax amount.</returns>
    TaxAmount taxAmountCalculated()
    {
        TaxAmount taxAmount
        ;

        while select taxWorkTrans

        where taxWorkTrans.SourceRecId      == this.sourceRecId()   &&
              taxWorkTrans.SourceTableId    == this.sourceTableId()     &&
              taxWorkTrans.TaxDirection     != TaxDirection::UseTax &&
              taxWorkTrans.TaxOrigin        != TaxOrigin::TaxReversed
        {
            if (taxWorkTrans.TaxAutogenerated)
                 taxAmount += taxWorkTrans.SourceTaxAmountCur;
            else
                 taxAmount += taxWorkTrans.SourceRegulateAmountCur;
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountCalculatedRaw</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the calculated raw tax amount.
    /// </summary>
    /// <returns>The calculated raw tax amount.</returns>
    TaxAmount taxAmountCalculatedRaw()
    {
        TaxAmount taxAmountRaw
        ;

        while select SourceTaxAmountCurReal, SourceRegulateAmountCur

        from taxWorkTrans
        where taxWorkTrans.SourceRecId      == this.sourceRecId()   &&
              taxWorkTrans.SourceTableId    == this.sourceTableId()     &&
              taxWorkTrans.TaxDirection     != TaxDirection::UseTax &&
              taxWorkTrans.TaxOrigin        != TaxOrigin::TaxReversed
        {
            if (taxWorkTrans.TaxAutogenerated)
                 taxAmountRaw += taxWorkTrans.SourceTaxAmountCurReal;
            else
                 taxAmountRaw += taxWorkTrans.SourceRegulateAmountCur;
        }

        return taxAmountRaw;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountForTaxOnTax</Name>
				<Source><![CDATA[
    private container taxAmountForTaxOnTax(
        TaxCode _taxCode,
        TmpTax _tmpTax = null,
        TaxTable _taxTable = null)
    {
        TmpTaxWorkTrans tmpTaxWorkTransLocal;
        TmpTax          tmpTaxLocal;
        TaxTable taxTable;

        // BR dual base tax rate feature use taxOnTaxCode to determin the ICMS DIFF Rate, it should skip standard tax on tax logic here.
        if (_taxCode
            && _taxTable.TaxType_BR == TaxType_BR::ICMSDiff
            && BrazilParameters::isEnabled())
        {
            _taxCode = null;
        }

        if (_tmpTax)
        {
            tmpTaxLocal.setTmpData(_tmpTax);

            if (_taxCode)
            {
                select sum(SourceTaxAmountCur), sum(TaxAmountMST) from tmpTaxLocal
                    where tmpTaxLocal.TaxCode == _taxCode;
            }
            else
            {
                if (!BrazilParameters::isEnabled())
                {
                    select sum(SourceTaxAmountCur), sum(TaxAmountMST) from tmpTaxLocal;
                }
                else if (_taxTable.TaxType_BR == TaxType_BR::ICMSDiff)
                {
                    select sum(SourceTaxAmountCur), sum(TaxAmountMST) from tmpTaxLocal
                        exists join taxTable
                            where taxTable.TaxCode == tmpTaxLocal.TaxCode
                                && taxTable.IncludedTax_BR == false
                                && taxTable.RetainedTax_BR == false
                                && taxTable.TaxType_BR != TaxType_BR::IPI;
                }
                else
                {
                    select sum(SourceTaxAmountCur), sum(TaxAmountMST) from tmpTaxLocal
                        exists join taxTable
                            where taxTable.TaxCode == tmpTaxLocal.TaxCode
                                && taxTable.IncludedTax_BR == false
                                && taxTable.RetainedTax_BR == false;
                }
            }

            return [tmpTaxLocal.TaxAmountMST, tmpTaxLocal.SourceTaxAmountCur];
        }
        else
        {
            tmpTaxWorkTransLocal.setTmpData(taxWorkTrans);

            if (_taxCode)
            {
                select sum(SourceTaxAmountCur), sum(TaxAmount) from tmpTaxWorkTransLocal
                    where tmpTaxWorkTransLocal.TaxCode == _taxCode;
            }
            else
            {
                if (!BrazilParameters::isEnabled())
                {
                    select sum(SourceTaxAmountCur), sum(TaxAmount) from tmpTaxWorkTransLocal;
                }
                else if (_taxTable.TaxType_BR == TaxType_BR::ICMSDiff)
                {
                    select sum(SourceTaxAmountCur), sum(TaxAmount) from tmpTaxWorkTransLocal
                        exists join taxTable
                            where taxTable.TaxCode == tmpTaxWorkTransLocal.TaxCode
                                && taxTable.IncludedTax_BR == false
                                && taxTable.RetainedTax_BR == false
                                && taxTable.TaxType_BR != TaxType_BR::IPI;
                }
                else
                {
                    select sum(SourceTaxAmountCur), sum(TaxAmount) from tmpTaxWorkTransLocal
                        exists join taxTable
                            where taxTable.TaxCode == tmpTaxWorkTransLocal.TaxCode
                                && taxTable.IncludedTax_BR == false
                                && taxTable.RetainedTax_BR == false;
                }
            }

            return [tmpTaxWorkTransLocal.TaxAmount, tmpTaxWorkTransLocal.SourceTaxAmountCur];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountRegulation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Regulates the tax amount.
    /// </summary>
    /// <param name = "_taxTrans">The buffer jof <c>TaxTrans</c>.</param>
    /// <param name = "_sourceTaxAmountCur">The source current tax amount.</param>
    /// <param name = "_exchRate">The exchange rate.</param>
    /// <param name = "_exchRateSecond">The second exchange rate.</param>
    void taxAmountRegulation(TaxTrans           _taxTrans,
                             TaxAmountCur       _sourceTaxAmountCur,
                             ExchRate           _exchRate = 0,
                             ExchrateSecondary  _exchRateSecond = 0)
    {
        TaxCurrencyConversionRoutineHandler handler = TaxCurrencyConversionRoutineHandler::instance();
        ;

        if (_taxTrans.SourceCurrencyCode == Ledger::accountingCurrency(this.companyInfo().RecId))

            _taxTrans.TaxAmount = _sourceTaxAmountCur;
        else
            _taxTrans.TaxAmount = CurrencyExchangeHelper::mstAmount(_sourceTaxAmountCur, _taxTrans.SourceCurrencyCode, taxDate, _taxTrans.euroTriangulation ? UnknownNoYes::Unknown : UnknownNoYes::No, _exchRate, _exchRateSecond);

        //Feature Sales Tax Conversion
        if (this.isTaxCurrencyConversionFeatureEnabled()
            || (TaxIntegrationSpecExchRateTotalAdjForTaxCurConversionFlight::instance().isEnabled()
                && TaxSpecificExchangeRateHelper::isTaxSpecificExchRateEnabledByTable(this.headingTableId(), this.headingRecId())))
        {
            _taxTrans.TaxAmountCur = handler.transCurrencyToTaxCurrency(_taxTrans.SourceCurrencyCode, _taxTrans.CurrencyCode, _sourceTaxAmountCur,
                                                                        _exchRate, reportingCurrencyExchRate, taxDate);
        }
        else
        {
            if (_taxTrans.CurrencyCode == Ledger::accountingCurrency(this.companyInfo().RecId))

                _taxTrans.TaxAmountCur = _taxTrans.TaxAmount;
            else
            if (_taxTrans.SourceCurrencyCode == _taxTrans.CurrencyCode)
                _taxTrans.TaxAmountCur = _sourceTaxAmountCur;
            else

                _taxTrans.TaxAmountCur = CurrencyExchangeHelper::curAmount(_taxTrans.TaxAmount, _taxTrans.CurrencyCode, taxDate);
        }

        if (_taxTrans.SourceCurrencyCode == Ledger::reportingCurrency(this.companyInfo().RecId))
        {
            _taxTrans.TaxAmountRep = _sourceTaxAmountCur;
        }
        else
        {
            _taxTrans.TaxAmountRep = handler.transCurrencyToReportingCurrency(_taxTrans.SourceCurrencyCode, _sourceTaxAmountCur, reportingCurrencyExchRate, taxDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountSign</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax amount by sign.
    /// </summary>
    /// <param name = "_amountCur">The current amount.</param>
    /// <param name = "_taxDirection">The tax direction.</param>
    /// <returns>The tax amount.</returns>
    AmountCur taxAmountSign(AmountCur       _amountCur,
                            TaxDirection    _taxDirection)
    {
        ;

        return _amountCur * Tax::changeDisplaySign(_taxDirection);
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountSignUI</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the amount by sign for UI.
    /// </summary>
    /// <param name = "_amountCur">The current amount.</param>
    /// <param name = "_accountType">The ledger journal account type.</param>
    /// <param name = "_salesPurch">Sales or purchase.</param>
    /// <param name = "_tmpTaxWorkTrans">The buffer of <c>TmpTaxWorkTrans</c>.</param>
    /// <returns>The tax amount.</returns>
    AmountCur taxAmountSignUI(AmountCur         _amountCur,
                            LedgerJournalACType _accountType,
                            SalesPurch          _salesPurch,
                            TmpTaxWorkTrans     _tmpTaxWorkTrans)
    {
        ;
        return _amountCur * Tax::changeDisplaySignTmpTaxWorkTrans(
                                        _accountType,
                                        _salesPurch,
                                        _tmpTaxWorkTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxBaseAmountRegulation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Regulates tax base amount.
    /// </summary>
    /// <param name = "_taxTrans">The buffer of <c>TransTax</c>.</param>
    /// <param name = "_sourceBaseAmountCurRegulated">The regulated source base amount.</param>
    /// <param name = "_exchRate">The exchange rate.</param>
    /// <param name = "_exchRateSecond">The seconde exchange rate.</param>
    void taxBaseAmountRegulation(TaxTrans           _taxTrans,
                                 AmountCur          _sourceBaseAmountCurRegulated,
                                 ExchRate           _exchRate = 0,
                                 ExchrateSecondary  _exchRateSecond = 0)
    {
        TaxCurrencyConversionRoutineHandler handler = TaxCurrencyConversionRoutineHandler::instance();
        ;

        if (_sourceBaseAmountCurRegulated)
        {
            _taxTrans.SourceBaseAmountCur = _sourceBaseAmountCurRegulated;
            if (_taxTrans.SourceCurrencyCode == Ledger::accountingCurrency(this.companyInfo().RecId))

                _taxTrans.TaxBaseAmount = _sourceBaseAmountCurRegulated;
            else
                _taxTrans.TaxBaseAmount = CurrencyExchangeHelper::mstAmount(_sourceBaseAmountCurRegulated, _taxTrans.SourceCurrencyCode, taxDate, _taxTrans.euroTriangulation ? UnknownNoYes::Unknown : UnknownNoYes::No, _exchRate, _exchRateSecond);

            //Feature Sales Tax Conversion
            if (this.isTaxCurrencyConversionFeatureEnabled())
            {
                _taxTrans.TaxBaseAmountCur = handler.transCurrencyToTaxCurrency(_taxTrans.SourceCurrencyCode, _taxTrans.CurrencyCode, _sourceBaseAmountCurRegulated,
                                                                                _exchRate, reportingCurrencyExchRate, taxDate);
            }
            else
            {
                if (_taxTrans.CurrencyCode == Ledger::accountingCurrency(this.companyInfo().RecId))

                    _taxTrans.TaxBaseAmountCur = _taxTrans.TaxBaseAmount;
                else
                    if (_taxTrans.CurrencyCode == _taxTrans.SourceCurrencyCode)
                        _taxTrans.TaxBaseAmountCur = _sourceBaseAmountCurRegulated;
                else

                        _taxTrans.TaxBaseAmountCur = CurrencyExchangeHelper::curAmount(_taxTrans.TaxBaseAmount, _taxTrans.CurrencyCode, taxDate);
            }

            _taxTrans.TaxBaseAmountRep = handler.transCurrencyToReportingCurrency(_taxTrans.SourceCurrencyCode, _sourceBaseAmountCurRegulated, 
                                                                                  reportingCurrencyExchRate, taxDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxCalcWithoutSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates tax amount without source.
    /// </summary>
    /// <param name = "_taxGroup">The tax group.</param>
    /// <param name = "_taxItemGroup">The tax item group.</param>
    /// <param name = "_taxDate">The tax date.</param>
    /// <param name = "_sourceCurrencyCode">the source currecy code.</param>
    /// <param name = "_baseAmountCur">The base amount.</param>
    /// <param name = "_taxModuleType">The tax module type.</param>
    /// <param name = "_baseQty">The base quantity.</param>
    /// <param name = "_baseUnit">The base unit.</param>
    /// <param name = "_itemId">The item Id.</param>
    /// <param name = "_taxDirection">The tax direction.</param>
    /// <param name = "_gsthstTaxType_CA">The GST tax type.</param>
    /// <param name = "_calculationDate">The calculation date.</param>
    /// <returns>The calculated tax amount.</returns>
    TaxAmountCur taxCalcWithoutSource(TaxGroup              _taxGroup,
                                      TaxItemGroup          _taxItemGroup,
                                      TransDate             _taxDate,
                                      CurrencyCode          _sourceCurrencyCode,
                                      AmountCur             _baseAmountCur,
                                      TaxModuleType         _taxModuleType,
                                      TaxBase               _baseQty          = 0,
                                      UnitOfMeasureSymbol   _baseUnit         = '',
                                      ItemId                _itemId           = '',
                                      TaxDirection          _taxDirection     = TaxDirection::OutgoingTax,
                                      GSTHSTTaxType_CA      _gsthstTaxType_CA = GSTHSTTaxType_CA::None
                                      ,TransDate            _calculationDate = _taxDate
                                      )
    {
        TaxAmountCur taxAmountCur;

        // <GEERU>
        #isoCountryRegionCodes
        // </GEERU>

        ;
        taxDate = _taxDate;

        if (_taxModuleType == TaxModuleType::Voucher)
        {
            if (_baseAmountCur  > 0)

                taxModuleType = TaxModuleType::Purch;
            else
                taxModuleType = TaxModuleType::Sales;
        }
        else
        {
            taxModuleType = _taxModuleType;
        }

        sourceCurrencyCode = _sourceCurrencyCode;

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            this.insertIntersection(_taxGroup,

                                    _taxItemGroup,
                                    _itemId,
                                    '',
                                    _calculationDate);
        }
        else
        {
            // </GEERU>
            this.insertIntersection(_taxGroup,

                                    _taxItemGroup,
                                    _itemId,
                                    '',
                                    _taxDate,
                                    '',
                                    _gsthstTaxType_CA);
            // <GEERU>
        }
        // </GEERU>

        this.insertLineInInternal(_baseAmountCur,

                                  _baseQty,
                                  _baseUnit,
                                  _itemId,
                                  0,
                                  0,
                                  0);

        taxAmountCur = this.calcTax();
        this.saveInProcessTransaction();

        this.insertTotalInInternal(0);
        taxAmountCur = this.calcTax();
        this.saveTotalInProcessTransaction();

        taxAmountCur = this.totalTaxAmount();
        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxCalcWithoutSource_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates tax amount without source.
    /// </summary>
    /// <param name = "_taxCode">The tax code.</param>
    /// <param name = "_taxDate">The tax date.</param>
    /// <param name = "_sourceCurrencyCode">The source currency code.</param>
    /// <param name = "_baseAmountCur">The base amount.</param>
    /// <param name = "_taxModuleType">The tax module type.</param>
    /// <param name = "_baseQty">The base quantity.</param>
    /// <param name = "_baseUnit">The base unit.</param>
    /// <param name = "_itemId">The item Id.</param>
    /// <param name = "_taxDirection">The tax direction.</param>
    /// <param name = "_calculationDate">The calculation date.</param>
    /// <returns>The calculated tax amount.</returns>
    public TaxAmountCur taxCalcWithoutSource_RU(TaxCode             _taxCode,
                                                TransDate           _taxDate,
                                                CurrencyCode        _sourceCurrencyCode,
                                                AmountCur           _baseAmountCur,
                                                TaxModuleType       _taxModuleType,
                                                TaxBase             _baseQty = 0,
                                                UnitOfMeasureSymbol _baseUnit = '',
                                                ItemId              _itemId   = '',
                                                TaxDirection        _taxDirection = TaxDirection::OutgoingTax,
                                                TransDate           _calculationDate = _taxDate)
    {
        TaxAmountCur taxAmountCur;
        TaxGroupData taxGroupData;
        ;
        taxDate      = _taxDate;
        if (_taxModuleType == TaxModuleType::Voucher)
        {
            if (_baseAmountCur  > 0)
            {
                taxModuleType = TaxModuleType::Purch;
            }
            else
            {
                taxModuleType = TaxModuleType::Sales;
            }
        }
        else
        {
            taxModuleType = _taxModuleType;
        }

        sourceCurrencyCode = _sourceCurrencyCode;
        taxWorkTrans.clear();
        taxWorkTrans.HeadingRecId          = headingRecId;
        taxWorkTrans.HeadingTableId        = headingTableId;
        taxWorkTrans.SourceTableId         = this.sourceTableId();
        taxWorkTrans.SourceRecId           = this.sourceRecId();
        taxWorkTrans.Voucher               = voucher;
        taxWorkTrans.TransDate             = taxDate;
        taxWorkTrans.TaxCode               = _taxCode;
        taxWorkTrans.Source                = taxModuleType;
        taxWorkTrans.InventTransId         = _itemId;
        taxWorkTrans.SourceCurrencyCode    = sourceCurrencyCode;
        taxWorkTrans.TaxDirection          = this.determineDirection(taxGroupData);
        taxWorkTrans.TaxAutogenerated      = NoYes::Yes;
        taxWorkTrans.TaxReports            = NoYes::Yes;
        taxWorkTrans.ExemptTax             = NoYes::No;
        taxWorkTrans.CalculationDate       = _calculationDate;

        taxWorkTrans.insert();

        this.insertLineInInternal(_baseAmountCur,

                                  _baseQty,
                                  _baseUnit,
                                  _itemId,
                                  0,
                                  0,
                                  0);

        taxAmountCur = this.calcTax();
        this.saveInProcessTransaction();

        this.insertTotalInInternal(0);
        taxAmountCur = this.calcTax();
        this.saveTotalInProcessTransaction();

        taxAmountCur = this.totalTaxAmount();
        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxCode_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax code.
    /// </summary>
    /// <param name = "_originalCode">The original tax code.</param>
    /// <returns>The tax code.</returns>
    protected TaxCode taxCode_RU(TaxCode _originalCode)
    {
        return _originalCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxGTAVendor_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets tax GTA vendor.
    /// </summary>
    /// <param name="_purchLine">
    /// The purch line.
    /// </param>
    /// <returns>
    /// The TaxAmount.
    /// </returns>
    public TaxAmount taxGTAVendor_IN(
        PurchLine _purchLine)
    {
        TaxAmount       taxAmount;
        TaxOnItem       taxOnItemGta;

        while select TaxCode from taxOnItemGta
            where taxOnItemGta.TaxItemGroup == _purchLine.TaxItemGroup
        {
            if (TaxTable::find(taxOnItemGta.TaxCode).TaxType_IN == TaxType_IN::ServiceTax)
            {
                select taxWorkTrans
                    where taxWorkTrans.TaxCode          == taxOnItemGta.TaxCode
                       && taxWorkTrans.InventTransId    == _purchLine.InventTransId;

                taxAmount += CurrencyExchangeHelper::amount(taxWorkTrans.SourceRegulateAmountCur);
            }
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxGTAVendorForNonPO_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets tax GTA vendor for no po.
    /// </summary>
    /// <param name="_vendInvoiceInfoLine">
    /// The vend invoice info line.
    /// </param>
    /// <param name="_reverseChargePercent">
    /// The reverse charge percentage.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxAmount</c> class.
    /// </returns>
    public TaxAmount taxGTAVendorForNonPO_IN(VendInvoiceInfoLine _vendInvoiceInfoLine, Percent _reverseChargePercent = 0)

    {
        TaxAmount taxAmount;
        TaxOnItem taxOnItemGta;
        TaxTable  taxTable;

        if (_vendInvoiceInfoLine.isNonPO() == false)
        {
            return 0;
        }
        while select TaxCode from taxOnItemGta
          where taxOnItemGta.TaxItemGroup == _vendInvoiceInfoLine.TaxItemGroup
             join TaxCode,TaxType_IN from taxTable
                where taxTable.TaxCode    == taxOnItemGta.TaxCode
                   && taxTable.TaxType_IN == TaxType_IN::ServiceTax
        {
            select firstonly TaxCode,InventTransId,SourceRegulateAmountCur from taxWorkTrans
                    where taxWorkTrans.TaxCode       == taxOnItemGta.TaxCode
                       && taxWorkTrans.InventTransId == _vendInvoiceInfoLine.InventTransId;
            if (_reverseChargePercent)
            {
                CurrencyExchangeHelper::amount(taxWorkTrans.SourceRegulateAmountCur - CurrencyExchangeHelper::amount(taxWorkTrans.SourceRegulateAmountCur * (100 - _reverseChargePercent) / 100));
            }
            else
            {
                taxAmount += taxWorkTrans.SourceRegulateAmountCur;
            }
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxInCostPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total tax included in sales price to be subtracted from inventory cost.
    /// </summary>
    /// <param name = "_tableId">The source table Id.</param>
    /// <param name = "_recId">The source recId.</param>
    /// <returns>The total tax amount included in sales price to be subtracted from inventory cost.</returns>
    public TaxAmount taxInCostPrice(TableId    _tableId,
                             RecId      _recId)
    {
        TaxAmount   taxAmount;
        ;

        select
            sum (TaxInCostPrice),
            sum (SourceRegulateAmountCur),
            sum (TaxInCostPriceRegulated)
        from taxWorkTrans
        where taxWorkTrans.SourceTableId   == _tableId      &&
              taxWorkTrans.SourceRecId     == _recId        &&

              (taxWorkTrans.TaxDirection    == TaxDirection::IncomingTax ||
               taxWorkTrans.TaxDirection    == TaxDirection::UseTax)
            // <GBR>
            && (!isBrazilEnabled || (taxWorkTrans.IncludedInPrice_BR == false));
        // </GBR>

        if (this.taxParameters().PurchTaxOnOperations)
        {
            taxAmount = taxWorkTrans.SourceRegulateAmountCur;
        }
        else
        {
            if (taxWorkTrans.TaxAutogenerated)
            {
                taxAmount = taxWorkTrans.TaxInCostPrice;
            }
            else
            {
                taxAmount = taxWorkTrans.TaxInCostPriceRegulated;
            }
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxInCostPrice_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total tax included in sales price to be subtracted from inventory cost.
    /// </summary>
    /// <param name="_tableId">Tableid from the source table</param>
    /// <param name="_recId">RecId from the source table</param>
    /// <returns>Return the sum of reatined tax for a given sourceTableId and sourceRecId</returns>
    public TaxAmount taxInCostPrice_BR(TableId _tableId, RecId _recId)
    {
        TaxAmount   taxAmountCur;
        TaxAmount   taxAmount;
        TaxAmount   taxInCostPrice;
        TaxTable    taxTable;

        while select

            sum (SourceRegulateAmountCur), sum(TaxInCostPrice), sum(TaxInCostPriceRegulated), maxof(SourceCurrencyCode), maxof(TransDate)
        from taxWorkTrans
            group by ExchangeRateTaxAmount, ExchangeRateTaxBaseAmount
            where taxWorkTrans.SourceTableId   == _tableId      &&
                  taxWorkTrans.SourceRecId     == _recId        &&
                  taxWorkTrans.TaxDirection != TaxDirection::UseTax &&
                  taxWorkTrans.IncludedInPrice_BR
            join RetainedTax_BR, TaxCode from taxTable
            where taxTable.TaxCode == taxWorkTrans.TaxCode      &&
                  taxTable.RetainedTax_BR == false
        {
            taxInCostPrice = taxWorkTrans.TaxInCostPriceRegulated ? taxWorkTrans.TaxInCostPriceRegulated : taxWorkTrans.TaxInCostPrice;
            taxAmountCur = taxWorkTrans.SourceRegulateAmountCur - taxInCostPrice;

            if (taxWorkTrans.SourceCurrencyCode != CompanyInfoHelper::standardCurrency())
            {
                taxAmount += CurrencyExchangeHelper::mstAmount(taxAmountCur, taxWorkTrans.SourceCurrencyCode, taxWorkTrans.TransDate, 0, exchRate);
            }
            else
            {
                taxAmount += taxAmountCur;
            }
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxInCostPriceLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets tax amount in cost price line.
    /// </summary>
    /// <param name="_purchLine">
    /// The purch line.
    /// </param>
    /// <param name="_taxOnItem">
    /// The tax on item.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxAmount</c> class.
    /// </returns>
    TaxAmount taxInCostPriceLine_IN(PurchLine    _purchLine,
                                    TaxOnItem    _taxOnItem)
    {
        TaxAmount       taxAmount;

        if (TaxTable::find(_taxOnItem.TaxCode).TaxType_IN == TaxType_IN::ServiceTax)
        {
            select TaxAmount from taxWorkTrans
                where taxWorkTrans.TaxCode          == _taxOnItem.TaxCode
                   && taxWorkTrans.InventTransId    == _purchLine.InventTransId;

            taxAmount = taxWorkTrans.TaxAmount;
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxInCostPriceMSTCalc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the tax amount included in sales price MST.
    /// </summary>
    /// <returns>The calculated tax amount.</returns>
    TaxAmount taxInCostPriceMSTCalc()
    {
        return taxInCostPriceMSTCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxInCostPriceReporting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Regulates the values included cost price for reporting.
    /// </summary>
    /// <param name = "_taxTrans">The buffer of <c>TaxTrans</c>.</param>
    /// <param name = "_taxInCostPriceRegulated">The regulated tax amount included cost price.</param>
    /// <param name = "_exchRate">The exchange rate.</param>
    /// <param name = "_exchRateSecond">The second exchange rate.</param>
    void taxInCostPriceReporting(TaxTrans           _taxTrans,
                                 TaxAmountCur       _taxInCostPriceRegulated,
                                 ExchRate           _exchRate = 0,
                                 ExchrateSecondary  _exchRateSecond = 0)
    {
        CurrencyCode    companyCurrencyCode;
        TaxCurrencyConversionRoutineHandler handler = TaxCurrencyConversionRoutineHandler::instance();
        ;

        companyCurrencyCode = Ledger::accountingCurrency(this.companyInfo().RecId);

        if (_taxTrans.SourceCurrencyCode == companyCurrencyCode)

            _taxTrans.TaxInCostPriceMST = _taxInCostPriceRegulated;
        else
            _taxTrans.TaxInCostPriceMST = CurrencyExchangeHelper::mstAmount(_taxInCostPriceRegulated, _taxTrans.SourceCurrencyCode, taxDate, _taxTrans.euroTriangulation ? UnknownNoYes::Unknown : UnknownNoYes::No, _exchRate, _exchRateSecond);

        //Feature Sales Tax Conversion
        if (this.isTaxCurrencyConversionFeatureEnabled())
        {
            _taxTrans.TaxInCostPriceCur = handler.transCurrencyToTaxCurrency(_taxTrans.SourceCurrencyCode, _taxTrans.CurrencyCode, _taxInCostPriceRegulated,
                                                                            _exchRate, reportingCurrencyExchRate, taxDate);
        }
        else
        {
            if (_taxTrans.CurrencyCode == companyCurrencyCode)

                _taxTrans.TaxInCostPriceCur = _taxTrans.TaxInCostPriceMST;
            else
                if (_taxTrans.SourceCurrencyCode == _taxTrans.CurrencyCode)
                    _taxTrans.TaxInCostPriceCur = _taxInCostPriceRegulated;
            else

                    _taxTrans.TaxInCostPriceCur = CurrencyExchangeHelper::curAmount(_taxTrans.TaxInCostPriceMST, _taxTrans.CurrencyCode, taxDate);
        }
        _taxTrans.TaxInCostPriceRep = handler.transCurrencyToReportingCurrency(_taxTrans.SourceCurrencyCode, _taxInCostPriceRegulated,
                                                                                reportingCurrencyExchRate, taxDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxInSalesRevenue_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the sum of taxes not included in sales price.
    /// </summary>
    /// <param name="_tableId">SourceTableId of the taxWorkTrans</param>
    /// <param name="_recId">SourceRecId of the taxWorkTrans</param>
    /// <returns>Sum of taxes in transaction currency</returns>
    public TaxAmount taxInSalesRevenue_BR(TableId    _tableId,
                                          RecId      _recId)
    {
        TaxAmount taxAmount, sourceRegulateAmountCur, sourceOtherBaseTaxAmount_BR;

        boolean isTaxICMSST60FiscalValue3 = false;

        while select SourceRegulateAmountCur, SourceOtherBaseTaxAmount_BR, TaxType_BR,
            FiscalValue_BR, TaxationCode_BR
        from taxWorkTrans
        where taxWorkTrans.SourceTableId == _tableId
            && taxWorkTrans.SourceRecId == _recId
            && taxWorkTrans.IncludedInPrice_BR == false
        {
            isTaxICMSST60FiscalValue3 = FiscalDocumentTaxTrans_BR::isTaxTypeICMSST60FiscalValue3(taxWorkTrans.TaxType_BR, taxWorkTrans.FiscalValue_BR, taxWorkTrans.TaxationCode_BR);
            
            if (EFiscalDocument_BR::shouldIncludeTaxInTaxTotal(isTaxICMSST60FiscalValue3, this))
            {
                sourceRegulateAmountCur += taxWorkTrans.SourceRegulateAmountCur;
                sourceOtherBaseTaxAmount_BR += taxWorkTrans.SourceOtherBaseTaxAmount_BR;
            }
        }

        taxAmount = sourceRegulateAmountCur + sourceOtherBaseTaxAmount_BR;

        return -taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the default tax origin.
    /// </summary>
    /// <param name="_defaultTaxOrigin">
    ///    The default tax origin.
    /// </param>
    /// <returns>
    ///    The default tax origin.
    /// </returns>
    /// <remarks>
    ///    Derived classes will override the <paramref name="_defaultTaxOrigin" /> parameter and may return
    ///    something other than the default tax origin passed in. Derived classes may also override this
    ///    method to enable transaction specific behavior.
    /// </remarks>
    protected TaxOrigin taxOrigin(TaxOrigin _defaultTaxOrigin)
    {
        return _defaultTaxOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxPack</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs the records of <c>TmpTaxWorkTrans</c>.
    /// </summary>
    /// <returns>The container of the packed records.</returns>
    public container taxPack()
    {
        container packedContainer;
        //Record lists for copying the temp tables.
        List                taxWorkTransList = new List(Types::Container);

        //pack the temp tables
        while select taxWorkTrans
        {
            taxWorkTransList.addEnd(buf2Con(taxWorkTrans));
        }

        packedContainer = [#CurrentVersion, #CurrentList, taxWorkTransList.pack(), tableId2name(headingTableId)];

        return packedContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the buffer of <c>TaxParameters</c> for current company.
    /// </summary>
    /// <returns>The buffer of <c>TaxParameters</c>.</returns>
    public TaxParameters taxParameters()
    {
        if (taxParameters.DataAreaId != curext() || !taxParameters.RecId)
        {
            changecompany(this.getCompany())
            {
                taxParameters = TaxParameters::find();
            }
        }

        return taxParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxPrLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax amount by line.
    /// </summary>
    /// <param name = "_sourceTableId">The source table Id.</param>
    /// <param name = "_sourceRecId">The source recId.</param>
    /// <returns>The tax amount.</returns>
    TaxAmountCur taxPrLine(TableId _sourceTableId,
                           RecId   _sourceRecId)
    {
        if (! _sourceRecId || ! _sourceTableId)

            return 0;

        select

            sum(SourceRegulateAmountCur)
        from taxWorkTrans
        where taxWorkTrans.SourceTableId    == _sourceTableId &&
              taxWorkTrans.SourceRecId      == _sourceRecId &&
              taxWorkTrans.TaxDirection     != TaxDirection::UseTax &&
              taxWorkTrans.TaxOrigin        != TaxOrigin::TaxReversed &&
              taxWorkTrans.TaxOrigin        != TaxOrigin::Transfer;

        return taxWorkTrans.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxServiceSettlement_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Settle tax service.
    /// </summary>
    /// <param name="_invLedPostCtrl">
    /// The ledger posting controller.
    /// </param>
    public void taxServiceSettlement_IN(LedgerPostingController _invLedPostCtrl)
    {
        TaxSettlement_IN        taxSettlement;
        Percent                 percent = 100;
        boolean                 finalPayment = true;
        LedgerJournalTrans      ledgerJournalTrans;
        VendTrans               vendInvoiceTrans;
        VendTrans               vendPaymentTrans;
        LedgerVoucherGroup      ledgerVoucherGroup;
        LedgerVoucher           taxTransLedgerVoucher;
        NumberSequenceReference numberSeqRef;
        NumberSeq               numberSeq;
        LedgerVoucherObject     ledgerVoucherObject;
        LedgerVoucher           settlementLedgerVoucher;
        LedgerPostingController ledgerPostingController;
        LedgerVoucher           invoiceLedgerVoucher;
        VendInvoiceJour         vendInvoiceJourLoc;
        CustInvoiceJour         custInvoiceJourLoc;
        SysModule               sysModule;
        CompanyId               companyId;
        TransDate               transDate;
        Voucher                 invoiceVoucher;
        TableId                 invoiceTableId;
        Voucher                 paymentVoucher;
        TransDate               paymentTransDate;
        RefRecId                invoiceRecId;
        CurrencyCode            currencyCode;
        TableId                 paymentTableId;
        RefRecId                paymentRecId;
        ExchRate                exchRateCurToMst;
        CustTrans               custInvoiceTrans;
        CustTrans               custPaymentTrans;
        boolean                 canExecute;

        if (this.headingTableId() == tableNum(VendInvoiceJour))
        {
            vendInvoiceJourLoc = VendInvoiceJour::findRecId(this.headingRecId());

            select vendInvoiceTrans
                where vendInvoiceTrans.Voucher == vendInvoiceJourLoc.LedgerVoucher
                   && vendInvoiceTrans.TransDate == vendInvoiceJourLoc.InvoiceDate
                   && vendInvoiceTrans.AccountNum == vendInvoiceJourLoc.InvoiceAccount
                   && vendInvoiceTrans.Invoice != '';
            sysModule           = SysModule::Vend;
            companyId           = vendInvoiceTrans.company();
            transDate           = vendInvoiceTrans.TransDate;
            invoiceVoucher      = vendInvoiceTrans.Voucher;
            invoiceTableId      = vendInvoiceTrans.TableId;
            invoiceRecId        = vendInvoiceTrans.RecId;
            currencyCode        = vendInvoiceTrans.CurrencyCode;
            paymentTableId      = vendPaymentTrans.TableId;
            paymentRecId        = vendPaymentTrans.RecId;
            paymentVoucher      = vendPaymentTrans.Voucher;
            paymentTransDate    = vendPaymentTrans.TransDate;
            exchRateCurToMst    = vendInvoiceTrans.exchRateCurToMst();
            canExecute          = (vendInvoiceTrans && vendPaymentTrans.RecId);
        }
        if (this.headingTableId() == tableNum(CustInvoiceJour))
        {
            custInvoiceJourLoc = CustInvoiceJour::findRecId(this.headingRecId());

            select custInvoiceTrans
                where custInvoiceTrans.Voucher      == custInvoiceJourLoc.LedgerVoucher
                   && custInvoiceTrans.TransDate    == custInvoiceJourLoc.InvoiceDate
                   && custInvoiceTrans.AccountNum   == custInvoiceJourLoc.InvoiceAccount
                   && custInvoiceTrans.Invoice      != '';

            sysModule           = SysModule::Cust;
            companyId           = custInvoiceTrans.company();
            transDate           = custInvoiceTrans.TransDate;
            invoiceVoucher      = custInvoiceTrans.Voucher;
            invoiceTableId      = custInvoiceTrans.TableId;
            invoiceRecId        = custInvoiceTrans.RecId;
            currencyCode        = custInvoiceTrans.CurrencyCode;
            paymentTableId      = custPaymentTrans.TableId;
            paymentRecId        = custPaymentTrans.RecId;
            paymentVoucher      = custPaymentTrans.Voucher;
            paymentTransDate    = custPaymentTrans.TransDate;
            exchRateCurToMst    = custInvoiceTrans.exchRateCurToMst();
            canExecute          = (custInvoiceTrans && custPaymentTrans.RecId);
        }

        if (canExecute)
        {
            ledgerVoucherGroup = LedgerVoucherGroup::construct();
            numberSeqRef = VendParameters::numRefVendPaymentVoucher();
            numberSeq = NumberSeq::newGetVoucher(numberSeqRef);

            taxTransLedgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail,
                                                                 sysModule,
                                                                 NumberSequenceTable::find(numberSeqRef.NumberSequenceId).NumberSequence);

            taxTransLedgerVoucher.parmCompanyId(companyId);
            ledgerVoucherGroup.addLedgerVoucher(taxTransLedgerVoucher);
            ledgerVoucherObject = taxTransLedgerVoucher.findLedgerVoucherObject();

            if (ledgerVoucherObject == null || ledgerVoucherObject.transElements() != 0)
            {
                taxTransLedgerVoucher.addVoucher(LedgerVoucherObject::newVoucher(numberSeq.voucher(), transDate, sysModule, LedgerTransType::Payment));
            }

            ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(taxTransLedgerVoucher);

            taxSettlement = new TaxSettlement_IN(invoiceVoucher,
                                                 transDate,
                                                 paymentVoucher,
                                                 paymentTransDate,
                                                 invoiceTableId,
                                                 invoiceRecId,
                                                 currencyCode,
                                                 paymentTableId,
                                                 paymentRecId,
                                                 percent,
                                                 exchRateCurToMst,
                                                 0,
                                                 UnknownNoYes::No,
                                                 ledgerJournalTrans,
                                                 finalPayment,
                                                 companyId);
            ledgerVoucherGroup.end();

            settlementLedgerVoucher = ledgerVoucherGroup.findLedgerVoucher(curext(), taxTransLedgerVoucher.parmVoucherSeriesCode());

            if (settlementLedgerVoucher != null)
            {
                invoiceLedgerVoucher = _invLedPostCtrl.getJournal();
                settlementLedgerVoucher.createVoucherLinks(invoiceLedgerVoucher.lastVoucher(), invoiceLedgerVoucher.lastTransDate());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax amount.
    /// </summary>
    /// <param name = "_taxTotals">The record sorted list of <c>TmpTaxTotals</c>.</param>
    /// <param name = "_reverseSign">The sign for reverse.</param>
    /// <returns>The total tax amount.</returns>
    [Replaceable(true)]
    TaxAmountCur taxTotals(RecordSortedList _taxTotals,
                           boolean          _reverseSign)
    {
        TmpTaxTotals    tmpTaxTotals;
        TaxAmountCur    taxAmountCur;
        Query           query;
        Counter         signReverse = 1;
        TmpTaxWorkTrans taxWorkTransLoc;

        if (_reverseSign)
            signReverse = -1;

        query = this.getTaxTotalQuery(voucher, taxDate, this.sourceRecId());
        QueryRun queryRun = new QueryRun(query);
        queryRun.setCursor(taxWorkTrans);

        while(queryRun.next())
        {
            taxWorkTransLoc = queryRun.get(tableNum(TmpTaxWorkTrans));
            tmpTaxTotals.clear();

            this.initFromTmpTaxWorkTrans(tmpTaxTotals, taxWorkTransLoc);
            _taxTotals.find(tmpTaxTotals);

            tmpTaxTotals.addByTaxWorkTrans(taxWorkTransLoc, signReverse);

            if (taxWorkTransLoc.TaxOrigin != TaxOrigin::TaxReversed)
                if (taxWorkTransLoc.NegativeTax)
                    taxAmountCur -= abs(taxWorkTransLoc.SourceTaxAmountCur);
            else
                    taxAmountCur += abs(taxWorkTransLoc.SourceTaxAmountCur);

            _taxTotals.ins(tmpTaxTotals, true);
        }
        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a container that consists of the table and record IDs of the specified record.
    /// </summary>
    /// <param name="_originRecord">
    ///    The record for which a key container should be constructed.
    /// </param>
    /// <returns>
    ///    A container that consists of the table and record IDs of the specified record.
    /// </returns>
    /// <remarks>
    ///    The container returned by this method is used as the key to maps that contain heterogeneous record
    ///    types to avoid issues if the IDs of multiple records collide.
    /// </remarks>
    protected container taxTransOrigin(Common _originRecord)
    {
        return [_originRecord.TableId, _originRecord.RecId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxUnpack</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unpacks the records of <c>TmpTaxWorkTrans</c> from container.
    /// </summary>
    /// <param name = "packedClass">The container of records.</param>
    /// <returns>true if version is correct; otherwise false.</returns>
    public boolean taxUnpack(container packedClass)
    {
        str                     headingTableIdPacked;
        container               taxWorkTransPacked;

        Version                 version = RunBase::getVersion(packedClass);

        //enumerator for unpacking lists
        ListEnumerator          listEnumerator;
        //table to store records in temporarily
        TmpTaxWorkTrans         tmpTaxWorkTransCopy;

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList, taxWorkTransPacked, headingTableIdPacked] = packedClass;

                //unpack the temp tables
                listEnumerator = List::create(taxWorkTransPacked).getEnumerator();
                while (listEnumerator.moveNext())
                {
                    con2Buf(listEnumerator.current(), tmpTaxWorkTransCopy);
                    taxWorkTrans.data(tmpTaxWorkTransCopy.data());
                    taxWorkTrans.insert(this.ignoreCalculatedSalesTax());
                }

                headingTableId = tableName2id(headingTableIdPacked);

                companyInfo = CompanyInfo::find();
                break;
            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWorkTransSource</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a container that consists of the source table and source record IDs of the specified
    ///    <c>TmpTaxWorkTrans</c> record.
    /// </summary>
    /// <param name="_tmpTaxWorkTrans">
    ///    The record for which a key container should be constructed.
    /// </param>
    /// <returns>
    ///    A container that consists of the source table and source record IDs of the specified
    ///    <c>TmpTaxWorkTrans</c> record.
    /// </returns>
    /// <remarks>
    ///    The container returned by this method is used as the key to maps that contain heterogeneous record
    ///    types to avoid issues if the IDs of multiple records collide.
    /// </remarks>
    protected container taxWorkTransSource(TmpTaxWorkTrans _tmpTaxWorkTrans)
    {
        return [_tmpTaxWorkTrans.SourceTableId, _tmpTaxWorkTrans.SourceRecId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWriteCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax write code.
    /// </summary>
    /// <returns>The tax write code.</returns>
    public TaxWriteCode  taxWriteCode()
    {
        TaxWriteCode    taxWriteCode;
        TaxUncommitted  taxUncommitted;
        List            codesList = new List(Types::String);

        if (!this.useTaxUncommitted())
        {
            // Posting out of TmpTaxWorkTrans
            while select taxWorkTrans

                where taxWorkTrans.SourceTableId  == this.sourceTableId()  &&
                      taxWorkTrans.SourceRecId    == this.sourceRecId() &&
                      taxWorkTrans.IsDeleted      == NoYes::No
            {
                TaxTable taxTable = TaxTable::find(taxWorkTrans.TaxCode);
                if ((SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU, #isoLT]) && taxTable.ExcludeFromInvoice))
                {
                    continue;
                }

                taxWriteCode = TaxTable::printCode(taxWorkTrans.TaxCode, taxWorkTrans.TransDate, taxWorkTrans.TaxBaseAmountCur);
                if (taxWriteCode)
                {
                    codesList.addEnd(taxWriteCode);
                }
            }
        }
        else
        {
            // Posting out of TaxUncommitted
            while select TaxCode, SourceTableId, SourceRecId from taxUncommitted
                where taxUncommitted.SourceTableId  == this.sourceTableId()  &&
                      taxUncommitted.SourceRecId    == this.sourceRecId() &&
                      taxUncommitted.IsDeleted      == NoYes::No
            {
                TaxTable taxTable = TaxTable::find(taxWorkTrans.TaxCode);
                if ((SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU, #isoLT]) && taxTable.ExcludeFromInvoice))
                {
                    continue;
                }

                taxWriteCode = TaxTable::printCode(taxUncommitted.TaxCode, taxUncommitted.TransDate, taxUncommitted.TaxBaseAmountCur);
                if (taxWriteCode)
                {
                    codesList.addEnd(taxWriteCode);
                }
            }
        }

        return strList2str(codesList, ', ');
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpTaxCalc_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tmp tax calculation.
    /// </summary>
    /// <returns>
    /// The instance of the <c>TmpTaxCalc_IN</c> class.
    /// </returns>
    TmpTaxCalc_IN  tmpTaxCalc_IN()
    {
        return tmpTaxCalc_IN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpTaxWorkTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the buffer of <c>TmpTaxWorkTrans</c>.
    /// </summary>
    /// <param name = "_tmpTaxWorkTrans">The buffer of <c>TmpTaxWorkTrans</c>.</param>
    /// <returns>The buffer of <c>TmpTaxWorkTrans</c>.</returns>
    TmpTaxWorkTrans tmpTaxWorkTrans(TmpTaxWorkTrans _tmpTaxWorkTrans = null)
    {
        if (!prmisDefault(_tmpTaxWorkTrans))
        {
            taxWorkTrans.setTmpData(_tmpTaxWorkTrans);
        }

        return taxWorkTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpTaxWorkTransExclInventProfileType_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets teh buffer of <c>TmpTaxWorkTrans</c> exclude invent profile type.
    /// </summary>
    /// <param name = "_tmpTaxWorkTrans">The buffer of <c>TmpTaxWorkTrans</c>.</param>
    /// <param name = "_inventProfileTypes">The container of excluded invent profile type.</param>
    /// <returns>The buffer of <c>TmpTaxWorkTrans</c>.</returns>
    public TmpTaxWorkTrans tmpTaxWorkTransExclInventProfileType_RU(TmpTaxWorkTrans _tmpTaxWorkTrans, container _inventProfileTypes)
    {
        TmpTaxWorkTrans tmpTaxWorkTrans;

        tmpTaxWorkTrans.setTmpData(_tmpTaxWorkTrans);
        while select tmpTaxWorkTrans
        {
            if (conFind(_inventProfileTypes, tmpTaxWorkTrans.InventProfileType_RU))
            {
                tmpTaxWorkTrans.delete();
            }
        }
        return tmpTaxWorkTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpTaxWorkTransMarkup_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records in <c>TmpTaxWorkTrans</c> for markup transaction.
    /// </summary>
    /// <param name = "_markupTable">Whether it is markup table.</param>
    /// <param name = "_checkMarkupAllowCostAdj">Whether markup is allowed for cost adjust.</param>
    /// <param name = "_checkMarkupAllowCustVend">Whether markup is allowed for cust or vend.</param>
    /// <returns>The buffer of <c>TmpTaxWorkTrans</c>.</returns>
    public TmpTaxWorkTrans tmpTaxWorkTransMarkup_RU(UnknownNoYes    _markupTable                = UnknownNoYes::Unknown,
                                                    UnknownNoYes    _checkMarkupAllowCostAdj    = UnknownNoYes::Unknown,
                                                    UnknownNoYes    _checkMarkupAllowCustVend   = UnknownNoYes::Unknown)
    // Yes = markup for table (purchase or sales order) only
    // No = exclude markup for table
    // Unknown = no chnanges
    {
        TmpTaxWorkTrans tmpTaxWorkTrans;
        MarkupTrans     markupTrans;
        boolean         insert;
        ;
        while select taxWorkTrans
        {
            insert = true;
            if (_markupTable != UnknownNoYes::Unknown &&
                taxWorkTrans.SourceTableId == tableNum(MarkupTrans))
            {
                markupTrans = MarkupTrans::findRecId_W(taxWorkTrans.SourceRecId);
                if (_markupTable == UnknownNoYes::Yes &&
                    markupTrans.TransTableId != tableNum(PurchTable) && markupTrans.TransTableId != tableNum(SalesTable))
                {
                    insert = false;
                }
                if (_markupTable == UnknownNoYes::No &&
                    (markupTrans.TransTableId == tableNum(PurchTable) || markupTrans.TransTableId == tableNum(SalesTable)))
                {
                    insert = false;
                }
                if ((_checkMarkupAllowCostAdj   == UnknownNoYes::Yes    && ! markupTrans.markupTypeItem()) ||
                    (_checkMarkupAllowCostAdj   == UnknownNoYes::No     &&   markupTrans.markupTypeItem()))
                {
                    insert = false;
                }
                if ((_checkMarkupAllowCustVend  == UnknownNoYes::Yes    && ! markupTrans.isMarkupOfTypeCustVend()) ||
                    (_checkMarkupAllowCustVend  == UnknownNoYes::No     &&   markupTrans.isMarkupOfTypeCustVend()))
                {
                    insert = false;
                }
            }
            if (_markupTable == UnknownNoYes::Yes &&
                taxWorkTrans.SourceTableId != tableNum(MarkupTrans))
            {
                insert = false;
            }
            if (insert)
            {
                tmpTaxWorkTrans.data(taxWorkTrans);
                tmpTaxWorkTrans.insert();
            }
        }
        return tmpTaxWorkTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalBaseAmountByType_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total base amount by tax type
    /// </summary>
    /// <param name="_taxType">
    /// Tax type used to filter
    /// </param>
    /// <returns>
    /// Returns the total base amount
    /// </returns>
    public TaxAmountCur totalBaseAmountByType_BR(TaxType_BR _taxType)
    {
        TaxAmountCur    sourceBaseAmountCur;

        while select taxWorkTrans
            where taxWorkTrans.TaxOrigin  != TaxOrigin::TaxReversed &&
                  taxWorkTrans.TaxType_BR == _taxType
        {
            if (!taxWorkTrans.SourceBaseAmountCurRegulated && taxWorkTrans.TaxAutogenerated == true)
            {
                sourceBaseAmountCur += taxWorkTrans.SourceBaseAmountCur;
            }
            else
            {
                sourceBaseAmountCur += taxWorkTrans.SourceBaseAmountCurRegulated;
            }
        }

        return sourceBaseAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalCorrectedCustomsDuty_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets total corrected customs duty.
    /// </summary>
    /// <returns>
    /// The instance of the <c>AmountMST</c> class.
    /// </returns>
    public AmountMST totalCorrectedCustomsDuty_IN()
    {
        AmountMST correctedCustomsDuty;
        AmountMST correctedCustomsDutyTotal;
        TaxTable  taxTableLoc;

        while select taxWorkTrans
            where taxWorkTrans.TaxOrigin != TaxOrigin::TaxReversed
            join RecId from taxTableLoc
            where taxTableLoc.TaxCode     == taxWorkTrans.TaxCode
                && taxTableLoc.TaxType_IN == TaxType_IN::Customs
        {
            correctedCustomsDuty = CurrencyHelper_IN::customsMSTAmount_IN(taxWorkTrans.SourceRegulateAmountCur,
                                                                 taxWorkTrans.SourceCurrencyCode,
                                                                 CurrencyHelper_IN::taxDirection2CustomsDirection_New_IN(taxWorkTrans.TaxDirection),
                                                                 taxWorkTrans.TransDate);
            correctedCustomsDutyTotal += this.taxAmountSign(correctedCustomsDuty, taxWorkTrans.TaxDirection);
        }

        return correctedCustomsDutyTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalCustomsAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total customs amount.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The source table id.
    /// </param>
    /// <param name="_sourceRecId">
    /// The source rec id.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxAmountCur</c> class.
    /// </returns>
    TaxAmountCur totalCustomsAmount_IN(
        RefTableId _sourceTableId = 0,
        RefRecId   _sourceRecId = 0)
    {
        TaxAmountCur customsAmount;
        TaxTable     taxTable;

        if (_sourceTableId && _sourceRecId)
        {
            while select taxWorkTrans
                where taxWorkTrans.SourceTableId == _sourceTableId
                   && taxWorkTrans.SourceRecId   == _sourceRecId
                   && taxWorkTrans.TaxDirection  != TaxDirection::UseTax
                   && taxWorkTrans.TaxOrigin     != TaxOrigin::TaxReversed
                join TaxCode, TaxType_IN
                    from taxTable
                        where taxTable.TaxCode    == taxWorkTrans.TaxCode
                           && taxTable.TaxType_IN == TaxType_IN::Customs
            {
                customsAmount += taxWorkTrans.CustomsDuty_IN;
            }
        }
        else
        {
            while select taxWorkTrans
                where taxWorkTrans.TaxDirection != TaxDirection::UseTax
                   && taxWorkTrans.TaxOrigin    != TaxOrigin::TaxReversed
                join TaxCode, TaxType_IN
                    from taxTable
                        where taxTable.TaxCode    == taxWorkTrans.TaxCode
                           && taxTable.TaxType_IN == TaxType_IN::Customs
            {
                customsAmount += taxWorkTrans.CustomsDuty_IN;
            }
        }

        return abs(customsAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalCustomsDuty_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total customs duty.
    /// </summary>
    /// <returns>
    /// The instance of the <c>TaxAmountCur</c> class.
    /// </returns>
    TaxAmountCur totalCustomsDuty_IN()
    {
        TaxAmountCur customsDutyLoc;

        while select taxWorkTrans
            where taxWorkTrans.TaxDirection != TaxDirection::UseTax &&
                  taxWorkTrans.TaxOrigin    != TaxOrigin::TaxReversed
        {
            if (TaxTable::find(taxWorkTrans.TaxCode).TaxType_IN == TaxType_IN::Customs)
            {
                if (!taxWorkTrans.SourceRegulateAmountCur)
                {
                    customsDutyLoc += taxWorkTrans.SourceTaxAmountCur;
                }
                else
                {
                    customsDutyLoc += taxWorkTrans.SourceRegulateAmountCur;
                }
            }
        }
        return abs(customsDutyLoc);
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalEximBalanceTaxAmountMST_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets total exim balance tax amount MST.
    /// </summary>
    /// <returns>
    /// The instance of the <c>AmountMST</c> class.
    /// </returns>
    public AmountMST totalEximBalanceTaxAmountMST_IN()
    {
        AmountMST eximBalanceTaxAmountMST;
        TaxTable  taxTableLoc;

        while select taxWorkTrans
            where taxWorkTrans.TaxOrigin != TaxOrigin::TaxReversed
            join RecId from taxTableLoc
            where taxTableLoc.TaxCode     == taxWorkTrans.TaxCode
                && taxTableLoc.TaxType_IN == TaxType_IN::Customs
        {
            eximBalanceTaxAmountMST += this.taxAmountSign(taxWorkTrans.EximBalanceTaxAmount_IN, taxWorkTrans.TaxDirection);
        }

        return eximBalanceTaxAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalEximTaxAmountMST_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets total exim tax amount MST.
    /// </summary>
    /// <returns>
    /// The instance of the <c>AmountMST</c> class.
    /// </returns>
    public AmountMST totalEximTaxAmountMST_IN()
    {
        AmountMST eximTaxAmountMST;

        TaxTable  taxTableLoc;

        while select taxWorkTrans
            where taxWorkTrans.TaxOrigin != TaxOrigin::TaxReversed
            join RecId from taxTableLoc
            where taxTableLoc.TaxCode     == taxWorkTrans.TaxCode
                && taxTableLoc.TaxType_IN == TaxType_IN::Customs
        {
            eximTaxAmountMST += this.taxAmountSign(taxWorkTrans.EximTaxAmount_IN, taxWorkTrans.TaxDirection);
        }

        return eximTaxAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalRegTaxAmountSingleLineIncludeUseTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax amount for single line include use tax.
    /// </summary>
    /// <param name = "_tableId">The table id.</param>
    /// <param name = "_recId">The recId.</param>
    /// <param name = "_setDisplaySign">Whether to set display sign.</param>
    /// <returns>The calculated total tax amount.</returns>
    TaxAmountCur totalRegTaxAmountSingleLineIncludeUseTax(TableId _tableId, RecId _recId, boolean _setDisplaySign = true)
    {
        TaxAmountCur            taxAmountCur;
        // <GEECZ>
        boolean                 isIntracomVAT = false;
        boolean                 isCZ          = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]);
        // </GEECZ>

        while select  taxWorkTrans
            where (taxWorkTrans.SourceTableId == _tableId &&
                    taxWorkTrans.SourceRecId == _recId) ||
                    (taxWorkTrans.ParentSourceTableId == _tableId &&
                    taxWorkTrans.ParentSourceRecId == _recId) &&
                  taxWorkTrans.TaxOrigin        != TaxOrigin::TaxReversed
        {
            // <GEECZ>
            if (isCZ && taxWorkTrans.IntracomVAT)
            {
                isIntracomVAT = true;
            }
            // </GEECZ>

            // <GEECZ>
            if (isIntracomVAT
                || !_setDisplaySign
                || (taxWorkTrans.ReverseCharge_W
                    && !Tax::changeSignForReverseCharge(taxWorkTrans)))
            // </GEECZ>
            {
                // <GEECZ>
                taxAmountCur += taxWorkTrans.SourceRegulateAmountCur;
                // </GEECZ>
            }
            else
            {
                // <GEECZ>
                taxAmountCur += this.taxAmountSign(taxWorkTrans.SourceRegulateAmountCur, taxWorkTrans.TaxDirection);
                // </GEECZ>
            }
        }
        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalRegulatedTaxAmountSingleLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax amount for singel line.
    /// </summary>
    /// <param name = "_tableId">The table id.</param>
    /// <param name = "_recId">The recId.</param>
    /// <param name = "_setDisplaySign">Wheteher to set display sign.</param>
    /// <param name = "_isIncludeParent">Whether include parent.</param>
    /// <param name = "_isIncludeIndiaTax">Whether include indian tax.</param>
    /// <returns>The calculated total tax amount.</returns>
    TaxAmountCur totalRegulatedTaxAmountSingleLine(TableId _tableId,
                                                   RecId   _recId,
                                                   boolean _setDisplaySign = true
                                                   ,boolean  _isIncludeParent = true
                                                   ,boolean _isIncludeIndiaTax = true
                                                   )
    {
        TaxAmountCur            taxAmountCur;
        // <GEECZ>
        boolean                 isIntracomVAT = false;
        boolean                 isCZ          = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]);
        // </GEECZ>
        // <GIN>
        TaxTable                taxTable;
        // </GIN>

        while select  taxWorkTrans

            where (taxWorkTrans.SourceTableId == _tableId &&
                    taxWorkTrans.SourceRecId == _recId) ||
                    (taxWorkTrans.ParentSourceTableId == _tableId &&
                        taxWorkTrans.ParentSourceRecId == _recId
                        // <GEEU>
                        && _isIncludeParent
                        // </GEEU>
                        ) &&
                  taxWorkTrans.TaxDirection     != TaxDirection::UseTax &&
                  taxWorkTrans.TaxOrigin        != TaxOrigin::TaxReversed
            // <GIN>
            join RecId from taxTable
                where taxTable.TaxCode == taxWorkTrans.TaxCode &&
                    (_isIncludeIndiaTax || taxTable.TaxType_IN == TaxType_IN::None)
            // </GIN>
        {
            // <GEECZ>
            if (isCZ && taxWorkTrans.IntracomVAT)
            {
                isIntracomVAT = true;
            }

            // </GEECZ>

            // <GEECZ>
            if (isIntracomVAT
                || !_setDisplaySign
                || (taxWorkTrans.ReverseCharge_W
                    && !Tax::changeSignForReverseCharge(taxWorkTrans)))
            // </GEECZ>
            {
                // <GEECZ>
                taxAmountCur += taxWorkTrans.SourceRegulateAmountCur;
                // </GEECZ>
            }
            else
            {
                // <GEECZ>
                taxAmountCur += this.taxAmountSign(taxWorkTrans.SourceRegulateAmountCur, taxWorkTrans.TaxDirection);
                // </GEECZ>
            }
        }
        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///   This method returns the actual tax amount.
    /// </summary>
    /// <param name="_includeUseTax">
    ///    A flag that indicates whether use tax should be included in the tax total.
    /// </param>
    /// <returns>
    ///   The actual tax amount in transactional currency.
    /// </returns>
    TaxAmountCur totalTaxAmount(boolean _includeUseTax = false)
    {
        TaxAmountCur totalTaxAmount;

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            return 0;
        }

        if (isBrazilEnabled)
        {
            TaxAmountCur sourceRegulateAmountCur, sourceOtherBaseTaxAmount_BR;
            boolean isTaxICMSST60FiscalValue3 = false;

            while select SourceRegulateAmountCur, SourceOtherBaseTaxAmount_BR, TaxType_BR,
                FiscalValue_BR, TaxationCode_BR
            from taxWorkTrans
            where (_includeUseTax || taxWorkTrans.TaxDirection != TaxDirection::UseTax) 
                && taxWorkTrans.TaxOrigin != TaxOrigin::TaxReversed
                && taxWorkTrans.IncludedInPrice_BR == false
            {
                isTaxICMSST60FiscalValue3 = FiscalDocumentTaxTrans_BR::isTaxTypeICMSST60FiscalValue3(taxWorkTrans.TaxType_BR, taxWorkTrans.FiscalValue_BR, taxWorkTrans.TaxationCode_BR);

                if (EFiscalDocument_BR::shouldIncludeTaxInTaxTotal(isTaxICMSST60FiscalValue3, this))
                {
                    sourceRegulateAmountCur += taxWorkTrans.SourceRegulateAmountCur;
                    sourceOtherBaseTaxAmount_BR += taxWorkTrans.SourceOtherBaseTaxAmount_BR;
                }
            }

            switch (taxModuleType)
            {
                case TaxModuleType::Purch :
                case TaxModuleType::PurchInvoice :
                case TaxModuleType::Tax :
                    totalTaxAmount = sourceRegulateAmountCur;
                    break;

                default :
                    totalTaxAmount = sourceRegulateAmountCur + sourceOtherBaseTaxAmount_BR;
            }
        }
        else
        {
            select sum(SourceRegulateAmountCur)
            from taxWorkTrans
            where (_includeUseTax || taxWorkTrans.TaxDirection != TaxDirection::UseTax) 
                && taxWorkTrans.TaxOrigin != TaxOrigin::TaxReversed
                && (!isIndiaCountryRegionEnabled || (taxWorkTrans.IsScrapQtyLine_IN == false));

            totalTaxAmount = taxWorkTrans.SourceRegulateAmountCur;
        }

        // <GIN>
        if (isIndiaCountryRegionEnabled)
        {
            // Select SUM cant be used since it will create "0.01" rounding issue.
            while select SourceRegulateAmountCur, ServiceTaxReverseChargePercentage_IN from taxWorkTrans

               where taxWorkTrans.ServiceTaxReverseChargePercentage_IN != 0
            {
                totalTaxAmount -= CurrencyExchangeHelper::amount(taxWorkTrans.SourceRegulateAmountCur - CurrencyExchangeHelper::amount(taxWorkTrans.SourceRegulateAmountCur * (100 - taxWorkTrans.ServiceTaxReverseChargePercentage_IN) / 100));
            }
        }
        // </GIN>

        return totalTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountByDirection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total actual tax amount for the specified tax direction.
    /// </summary>
    /// <param name="_taxDirection">
    /// The tax direction for which to search.
    /// </param>
    /// <returns>
    /// The total actual tax amount for the specified tax direction in transactional currency.
    /// </returns>
    TaxAmountCur totalTaxAmountByDirection(TaxDirection _taxDirection)
    {
        select sum(SourceRegulateAmountCur)
        from taxWorkTrans
        where (taxWorkTrans.TaxDirection  == _taxDirection) &&
              taxWorkTrans.TaxOrigin     != TaxOrigin::TaxReversed;

        return taxWorkTrans.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountByType_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax amount by tax type.
    /// </summary>
    /// <param name = "_taxType">The tax type.</param>
    /// <returns>The calculated total tax amount.</returns>
    TaxAmountCur totalTaxAmountByType_BR(TaxType_BR _taxType)
    {
        TaxAmountCur    sourceTaxAmountCur;
        ;
        while select taxWorkTrans
        where taxWorkTrans.TaxOrigin       != TaxOrigin::TaxReversed &&
                taxWorkTrans.TaxType_BR    == _taxType
        {
            if (!taxWorkTrans.SourceRegulateAmountCur && taxWorkTrans.TaxAutogenerated == true)
            {
                sourceTaxAmountCur += taxWorkTrans.SourceTaxAmountCur;
            }
            else
            {
                sourceTaxAmountCur += taxWorkTrans.SourceRegulateAmountCur;
            }
        }

        return sourceTaxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountByTypeFromTaxUncommitted_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax amount by tax type from <c>TaxUncommitted</c>.
    /// </summary>
    /// <param name = "_taxType">The value of enum <c>TaxModuleType</c>.</param>
    /// <returns>The calculated total tax amount.</returns>
    [Hookable(false)]
    public TaxAmountCur totalTaxAmountByTypeFromTaxUncommitted_BR(TaxType_BR _taxType)
    {
        TaxAmountCur    sourceTaxAmountCur;
        TaxUncommitted  taxuncommitted;
        while select taxuncommitted
        where taxuncommitted.TaxOrigin != TaxOrigin::TaxReversed
            && taxuncommitted.TaxType_BR == _taxType
            && taxuncommitted.HeadingTableId == this.headingTableId()
            && taxuncommitted.HeadingRecId == this.headingRecId()
        {
            if (!taxuncommitted.SourceRegulateAmountCur && taxuncommitted.TaxAutogenerated)
            {
                sourceTaxAmountCur += taxuncommitted.SourceTaxAmountCur;
            }
            else
            {
                sourceTaxAmountCur += taxuncommitted.SourceRegulateAmountCur;
            }
        }

        return sourceTaxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountByTypeFromTaxTrans_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax amount by tax type from <c>TaxTrans</c>.
    /// </summary>
    /// <param name = "_taxType">The tax type buffer of <c>TaxType_BR</c>.</param>
    /// <param name = "_sourceDocumentHeaderRecId">The recid of the <c>SourceDocumentHeader</c>.</param>
    /// <returns>The calculated total tax amount.</returns>
    [Hookable(false)]
    public TaxAmountCur totalTaxAmountByTypeFromTaxTrans_BR(TaxType_BR _taxType, SourceDocumentHeaderRecId _sourceDocumentHeaderRecId)
    {
        TaxAmountCur       sourceTaxAmountCur;
        TaxTrans           taxTrans;
        sourceDocumentLine sourceDocumentLine;
        TaxTrans_BR        taxTrans_BR;

        while select taxTrans
        where taxTrans.TaxOrigin != TaxOrigin::TaxReversed
            join RecId from taxTrans_BR
                where taxTrans_BR.TaxTrans == taxTrans.RecId
                    && taxTrans_BR.TaxType_BR == _taxType
                join RecId, SourceDocumentHeader from sourceDocumentLine
                    where sourceDocumentLine.RecId == taxTrans.SourceDocumentLine
                        && sourceDocumentLine.SourceDocumentHeader == _sourceDocumentHeaderRecId
        {
            if (!taxTrans.SourceRegulateAmountCur && taxTrans.TaxAutogenerated)
            {
                sourceTaxAmountCur += taxTrans.SourceTaxAmountCur;
            }
            else
            {
                sourceTaxAmountCur += taxTrans.SourceRegulateAmountCur;
            }
        }

        return sourceTaxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountCalculated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the calculated total tax amount.
    /// </summary>
    /// <param name = "_setDisplaySign">Whether to set display sign.</param>
    /// <returns>The calculated total tax amount.</returns>
    TaxAmountCur totalTaxAmountCalculated(boolean _setDisplaySign = true)
    {
        TaxAmountCur            taxAmountCur;
        // <GEECZ>
        boolean                 isCZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]);
        // </GEECZ>

        if (_setDisplaySign)
        {
            while select    taxWorkTrans
                where taxWorkTrans.TaxOrigin    != TaxOrigin::TaxReversed
            {
                //<GEECZ>
                if ((isCZ && taxWorkTrans.IntracomVAT) || (taxWorkTrans.ReverseCharge_W && !Tax::changeSignForReverseCharge(taxWorkTrans)))
                {
                    taxAmountCur += taxWorkTrans.SourceTaxAmountCur;
                }
                else
                {
                    //</GEECZ>
                    taxAmountCur += this.taxAmountSign(taxWorkTrans.SourceTaxAmountCur, taxWorkTrans.TaxDirection);
                    //<GEECZ>
                }
                //</GEECZ>
            }
        }
        else
        {
            select sum (SourceTaxAmountCur)
            from taxWorkTrans
            where taxWorkTrans.TaxOrigin != TaxOrigin::TaxReversed;

            taxAmountCur = taxWorkTrans.SourceTaxAmountCur;
        }
        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax amount MST.
    /// </summary>
    /// <returns>The calculated total tax amount.</returns>
    TaxAmountCur totalTaxAmountMST()
    {
        ;

        select sum(TaxAmount) from taxWorkTrans

            where taxWorkTrans.TaxDirection != TaxDirection::UseTax &&
                  taxWorkTrans.TaxOrigin    != TaxOrigin::TaxReversed;

        return taxWorkTrans.TaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountRetained_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///   This method returns the actual retained tax amount.
    /// </summary>
    /// <returns>
    ///   The actual retained tax amount in transactional currency.
    /// </returns>
    TaxAmountCur totalTaxAmountRetained_BR()
    {
        TaxTable taxTable;

        select sum(SourceRegulateAmountCur)

        from taxWorkTrans
            where taxWorkTrans.TaxOrigin     != TaxOrigin::TaxReversed
            join RetainedTax_BR from taxTable
                where taxWorkTrans.TaxCode == taxTable.TaxCode
                    && taxTable.RetainedTax_BR == true;

        if (taxModuleType == TaxModuleType::Purch

            || taxModuleType == TaxModuleType::PurchInvoice)
        {
            taxWorkTrans.SourceRegulateAmountCur = taxWorkTrans.SourceRegulateAmountCur * -1;
        }

        return taxWorkTrans.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountSingleLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax amount for single line.
    /// </summary>
    /// <param name = "_tableId">The table id.</param>
    /// <param name = "_recId">The recId.</param>
    /// <param name = "_adjustTaxSign">Whether to adjust tax.</param>
    /// <param name = "_includeUseTax">Whetehr include use tax.</param>
    /// <returns>The calculated total tax amount.</returns>
    TaxAmountCur totalTaxAmountSingleLine(TableId _tableId,
                                          RecId   _recId,
                                          boolean   _adjustTaxSign = true,
                                          boolean   _includeUseTax = false)
    {
        TaxAmountCur            taxAmountCur;
        // <GEECZ>
        boolean                 isIntracomVAT = false;
        boolean                 isCZES        = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoES]);
        // </GEECZ>
        ;

        while select taxWorkTrans

                where (taxWorkTrans.SourceTableId == _tableId &&
                        taxWorkTrans.SourceRecId == _recId) ||
                        (taxWorkTrans.ParentSourceTableId == _tableId &&
                        taxWorkTrans.ParentSourceRecId == _recId) &&
                  (taxWorkTrans.TaxDirection     != TaxDirection::UseTax || _includeUseTax) &&
                  taxWorkTrans.TaxOrigin        != TaxOrigin::TaxReversed
        {
            // <GEECZ>
            if (isCZES && taxWorkTrans.IntracomVAT)
            {
                isIntracomVAT = true;
            }

            // </GEECZ>

            // <GEECZ>
            if (isIntracomVAT || !_adjustTaxSign || (taxWorkTrans.ReverseCharge_W && !Tax::changeSignForReverseCharge(taxWorkTrans)))
            // </GEECZ>
            {
                // <GEECZ>
                taxAmountCur += taxWorkTrans.SourceTaxAmountCur;
                // </GEECZ>
            }
            else
            {
                // <GEECZ>
                taxAmountCur += this.taxAmountSign(taxWorkTrans.SourceTaxAmountCur, taxWorkTrans.TaxDirection);
                // </GEECZ>
            }
        }

        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountSingleLineIncludeUseTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax amount for singel line include use tax.
    /// </summary>
    /// <param name = "_tableId">The table id.</param>
    /// <param name = "_recId">The recId</param>
    /// <param name = "_adjustTaxSign">Whether to adjust tax.</param>
    /// <returns>The calculated total tax amount.</returns>
    TaxAmountCur totalTaxAmountSingleLineIncludeUseTax(TableId _tableId, RecId _recId, boolean _adjustTaxSign = true)
    {
        TaxAmountCur            taxAmountCur;
        // <GEECZ>
        boolean                 isIntracomVAT = false;
        boolean                 isCZ          = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]);
        // </GEECZ>
        ;

        while select taxWorkTrans

            where (taxWorkTrans.SourceTableId == _tableId &&
                    taxWorkTrans.SourceRecId == _recId) ||
                    (taxWorkTrans.ParentSourceTableId == _tableId &&
                        taxWorkTrans.ParentSourceRecId == _recId) &&
                  taxWorkTrans.TaxOrigin        != TaxOrigin::TaxReversed
        {
            // <GEECZ>
            if (isCZ && taxWorkTrans.IntracomVAT)
            {
                isIntracomVAT = true;
            }

            // </GEECZ>

            // <GEECZ>
            if (isIntracomVAT || !_adjustTaxSign || taxWorkTrans.ReverseCharge_W)
            // </GEECZ>
            {
                // <GEECZ>
                taxAmountCur += taxWorkTrans.SourceTaxAmountCur;
                // </GEECZ>
            }
            else
            {
                // <GEECZ>
                taxAmountCur += this.taxAmountSign(taxWorkTrans.SourceTaxAmountCur, taxWorkTrans.TaxDirection);
                // </GEECZ>
            }
        }

        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountSingleLineRaw</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total raw tax amount for single line.
    /// </summary>
    /// <param name = "_tableId">The table id.</param>
    /// <param name = "_recId">Teh recId.</param>
    /// <param name = "_adjustTaxSign">Whether to adjust tax.</param>
    /// <returns>The calculated total tax amount.</returns>
    TaxAmountCur totalTaxAmountSingleLineRaw(TableId _tableId,
                                          RecId   _recId,
                                          boolean   _adjustTaxSign = true)
    {
        TaxAmountCur taxAmountCurRaw;
        // <GEECZ>
        boolean                 isIntracomVAT = _adjustTaxSign;
        boolean                 isCZ          = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]);
        // </GEECZ>
        ;

        while select SourceTaxAmountCurReal, TaxDirection

        from taxWorkTrans
            where (taxWorkTrans.SourceTableId    == _tableId             &&
                  taxWorkTrans.SourceRecId      == _recId)               ||
                  (taxWorkTrans.ParentSourceTableId == _tableId &&
                  taxWorkTrans.ParentSourceRecId == _recId) &&
                  taxWorkTrans.TaxDirection     != TaxDirection::UseTax &&
                  taxWorkTrans.TaxOrigin        != TaxOrigin::TaxReversed
        {
            // <GEECZ>
            if (isCZ && taxWorkTrans.IntracomVAT)
            {
                isIntracomVAT = true;
            }

            // </GEECZ>

            // <GEECZ>
            if (isIntracomVAT || !_adjustTaxSign || taxWorkTrans.ReverseCharge_W)
            // </GEECZ>
            {
                // <GEECZ>
                taxAmountCurRaw += taxWorkTrans.SourceTaxAmountCurReal;
                // </GEECZ>
            }
            else
            {
                // <GEECZ>
                taxAmountCurRaw += this.taxAmountSign(taxWorkTrans.SourceTaxAmountCurReal, taxWorkTrans.TaxDirection);
                // </GEECZ>
            }
        }

        return taxAmountCurRaw;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxDetailsExclMarkup_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax amount exclude markup transaction.
    /// </summary>
    /// <param name = "includeWithoutTaxTrans_RU">Whether without tax transaction.</param>
    /// <returns>The container of total tax amounts.</returns>
    public container totalTaxDetailsExclMarkup_RU(NoYes includeWithoutTaxTrans_RU = NoYes::No)
    {
        Map             totalTaxDetails = new Map(Types::Container, Types::Real);
        TaxAmountCur    taxAmountCur;

        while select taxWorkTrans

            where taxWorkTrans.TaxDirection       != TaxDirection::UseTax
               && taxWorkTrans.TaxOrigin          != TaxOrigin::TaxReversed
               && taxWorkTrans.SourceTableId      != tableNum(MarkupTrans)
               && (includeWithoutTaxTrans_RU      == NoYes::Yes || taxWorkTrans.WithoutTaxTrans_RU == NoYes::No)
        {
            taxAmountCur = 0;
            if (totalTaxDetails.exists([taxWorkTrans.PostingProfile_RU, taxWorkTrans.InventProfileType_RU]))
            {
                taxAmountCur = totalTaxDetails.lookup([taxWorkTrans.PostingProfile_RU, taxWorkTrans.InventProfileType_RU]);
            }

            if (!taxWorkTrans.SourceRegulateAmountCur)
            {
                taxAmountCur += taxWorkTrans.SourceTaxAmountCur;
            }
            else

                 taxAmountCur += taxWorkTrans.SourceRegulateAmountCur;

            totalTaxDetails.insert([taxWorkTrans.PostingProfile_RU, taxWorkTrans.InventProfileType_RU], taxAmountCur);
        }
        return totalTaxDetails.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxDetailsMarkup_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax amount for markup transaction.
    /// </summary>
    /// <returns>The container of total tax amounts.</returns>
    public container totalTaxDetailsMarkup_RU()
    {
        Map             totalTaxDetailsTable = new Map(Types::Container, Types::Real);
        Map             totalTaxDetailsLine = new Map(Types::Container, Types::Real);
        TaxAmountCur    taxAmountCur;
        TaxAmountCur    totalTaxAmountCurTableCustVend;
        TaxAmountCur    totalTaxAmountCurTableItem;
        TaxAmountCur    totalTaxAmountCurLine;
        MarkupTrans     markupTrans;
        ;

        while select TransTableId from markupTrans

            where (markupTrans.TransTableId     == tableNum(PurchTable) ||
                   markupTrans.TransTableId     == tableNum(SalesTable) ||
                   markupTrans.TransTableId     == tableNum(PurchLine) ||
                   markupTrans.TransTableId     == tableNum(SalesLine))
        join taxWorkTrans
            where taxWorkTrans.SourceRecId      == markupTrans.RecId
               && taxWorkTrans.TaxDirection     != TaxDirection::UseTax
               && taxWorkTrans.SourceTableId    == tableNum(MarkupTrans)
               && taxWorkTrans.TaxOrigin        != TaxOrigin::TaxReversed
        {
            if (!(taxWorkTrans.SourceRegulateAmountCur + taxWorkTrans.SourceTaxAmountCur))
            {
                continue;
            }

            switch (markupTrans.TransTableId)
            {
                case tableNum(PurchTable):
                case tableNum(SalesTable):
                                                                                    if (totalTaxDetailsTable.exists([taxWorkTrans.PostingProfile_RU, taxWorkTrans.InventProfileType_RU]))
                    {
                        taxAmountCur = totalTaxDetailsTable.lookup([taxWorkTrans.PostingProfile_RU, taxWorkTrans.InventProfileType_RU]);
                    }
                    if (taxWorkTrans.SourceRegulateAmountCur)
                    {
                        taxAmountCur += taxWorkTrans.SourceRegulateAmountCur;
                    }
                    else
                    {
                        taxAmountCur += taxWorkTrans.SourceTaxAmountCur;
                    }
                    totalTaxDetailsTable.insert([taxWorkTrans.PostingProfile_RU, taxWorkTrans.InventProfileType_RU], taxAmountCur);
                    if (markupTrans.markupTypeItem())
                    {
                        totalTaxAmountCurTableItem += taxAmountCur;
                    }
                    else
                    {
                        totalTaxAmountCurTableCustVend += taxAmountCur;
                    }
                    break;
                case tableNum(PurchLine):
                case tableNum(SalesLine):
                                                                                    if (totalTaxDetailsLine.exists([taxWorkTrans.PostingProfile_RU, taxWorkTrans.InventProfileType_RU]))
                    {
                        taxAmountCur = totalTaxDetailsLine.lookup([taxWorkTrans.PostingProfile_RU, taxWorkTrans.InventProfileType_RU]);
                    }
                    if (taxWorkTrans.SourceRegulateAmountCur)
                    {
                        taxAmountCur += taxWorkTrans.SourceRegulateAmountCur;
                    }
                    else
                    {
                        taxAmountCur += taxWorkTrans.SourceTaxAmountCur;
                    }
                    totalTaxDetailsLine.insert([taxWorkTrans.PostingProfile_RU, taxWorkTrans.InventProfileType_RU], taxAmountCur);
                    totalTaxAmountCurLine += taxAmountCur;
                    break;
                default:
                    continue;
            }
        }
        return [totalTaxDetailsTable.pack(),

                totalTaxAmountCurTableCustVend,
                totalTaxAmountCurTableItem,
                totalTaxDetailsLine.pack(),
                totalTaxAmountCurLine];
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxIncludedInPrice_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total tax included in sales price to be subtracted from sales revenue.
    /// </summary>
    /// <returns>Return the sum of taxes included in price</returns>
    public TaxAmount totalTaxIncludedInPrice_BR()
    {
        TaxAmount   taxAmount;
        ;

        select

            sum (SourceRegulateAmountCur), sum(TaxInCostPrice)
        from taxWorkTrans
            where taxWorkTrans.IncludedInPrice_BR;

        taxAmount = taxWorkTrans.SourceRegulateAmountCur - taxWorkTrans.TaxInCostPrice;

        return -taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxInCostPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total tax included in sales price to be subtracted from sales revenue.
    /// </summary>
    /// <param name = "recId">The recId.</param>
    /// <returns>Return the sum of taxes included in price.</returns>
    TaxAmount totalTaxInCostPrice(RefRecId recId = 0)
    {
        TaxAmount   taxAmount;
        TmpTaxWorkTrans taxWorkTransLocal;
        ;

        taxWorkTransLocal = this.getTaxWorkTransBufferForTaxInCostPrice(recId);

        if (this.taxParameters().PurchTaxOnOperations)
        {
            taxAmount = taxWorkTransLocal.SourceRegulateAmountCur;
        }
        else
        {
            if (taxWorkTransLocal.TaxAutogenerated)
            {
                taxAmount = taxWorkTransLocal.TaxInCostPrice;
            }
            else
            {
                taxAmount = taxWorkTransLocal.TaxInCostPriceRegulated;
            }
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        throw error(strFmt("@SYS19306",funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBaseAmountSum</Name>
				<Source><![CDATA[
    private void updateBaseAmountSum(TaxCode                _taxCode,
                                     TaxDirection           _taxDirection,
                                     TaxBaseCur             _sourceBaseAmountCurRaw,
                                     TaxBaseCur             _sourceBaseAmountCur,
                                     CurrencyCode           _sourceCurrencyCode)

    {
        this.initBaseAmountSum();
        tmpTaxWorkTransSum.TaxCode      = _taxCode;
        tmpTaxWorkTransSum.TaxDirection = _taxDirection;
        tmpTaxWorkTransSum.SourceCurrencyCode = _sourceCurrencyCode;

        if (!baseAmountSum.find(tmpTaxWorkTransSum))
        {
            tmpTaxWorkTransSum.SourceRegulateAmountCur = 0;
            tmpTaxWorkTransSum.SourceBaseAmountCur     = 0;
            tmpTaxWorkTransSum.SourceBaseAmountCurRaw  = 0;
        }

        tmpTaxWorkTransSum.SourceBaseAmountCur     += _sourceBaseAmountCur;
        tmpTaxWorkTransSum.SourceBaseAmountCurRaw  += _sourceBaseAmountCurRaw;
        baseAmountSum.ins(tmpTaxWorkTransSum, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomsDutyPerExchangeRate_IN</Name>
				<Source><![CDATA[
    private void updateCustomsDutyPerExchangeRate_IN(TmpTaxWorkTrans _taxWorkTrans)
    {
        CustomsVendBOESubTrans_IN   customsVendBOESubTrans;
        CustomsVendBOETrans_IN      customsVendBOETrans;
        TaxAmount                   taxAmount;
        TaxAmount                   taxAmountCur;
        TaxAmount                   taxInCostPrice;
        TaxAmount                   taxInCostPriceMST;
        TaxAmount                   taxInCostPriceCur;
        TaxAmountCur                sourceTaxAmountCur;
        TaxAmountCur                sourceTaxAmountCurReal;
        TaxAmountCur                sourceTaxAmountRegulateCustomsCur;
        TaxAmount                   sourceTaxAmountRegulateCustomsMST;
        CustomsAmount_IN            customsDutyLoc;
        CustomsQty_IN               qty;
        RealBase                    factor;
        CurrencyCode                currencyCode;
        TaxBase                     taxQtyLoc;
        CurrencyCode                currencyCodeMST = Ledger::accountingCurrency();
        TaxAmount                   eximTaxAmountCopy;
        TaxAmount                   eximBalTaxAmountCopy;
        TaxAmount                   taxAmountCurLoc;
        TaxAmount                   balanceTaxAmountCurLoc;
        TaxAmount                   depbAmountCopy;
        TaxAmountCur                depbAmountCopyCur;

        TaxAmount                   totalTaxAmount;
        TaxAmount                   totalBalanceTaxAmount;
        TaxAmountCur                taxTotalAmountCur;
        TaxAmountCur                totalBalanceTaxAmountCur;
        EximVendBOESubTrans_IN      eximVendBOESubTrans;
        boolean                     isEximTaxRegulated;
        boolean                     isEximBalanceAmount;

        TaxBase                     taxQtyConsidered;
        boolean                     isCustomsTaxRegulated;
        VendInvoiceInfoLine         vendInvoiceInfoLineCopy;
        CustomsVendBOETrans_IN      customsVendBOETransCopy;

        vendInvoiceInfoLineCopy = VendInvoiceInfoLine::findRecId(_taxWorkTrans.SourceRecId);

        customsVendBOETransCopy = VendDocumentLineMap::getCustomsVendBOETrans_IN(vendInvoiceInfoLineCopy.RecId, vendInvoiceInfoLineCopy.ParmId, vendInvoiceInfoLineCopy.TableId);

        taxQtyLoc = abs(baseQty);//Credit note
        while select boeTransRefRecId, TaxAmount, TaxAmountCur,

                        TaxInCostPrice, TaxInCostPriceMST, TaxInCostPriceCur,
                        SourceTaxAmountCur, SourceTaxAmountCurReal, SourceBaseAmountCur,
                        SourceRegulateAmountCustomsCur_IN, SourceRegulateAmountCustoms_IN, CustomsDuty, RecId
            from customsVendBOESubTrans
            order by RecId, BillOfEntryDate
            where customsVendBOESubTrans.InventTransId == _taxWorkTrans.InventTransId
                && customsVendBOESubTrans.TaxCode       == _taxWorkTrans.TaxCode
                && customsVendBOESubTrans.boeTransRefRecId == customsVendBOETransCopy.RecId
        {
            if (taxQtyConsidered >= abs(baseQty))
                break;
            customsVendBOETrans = CustomsVendBOETrans_IN::findRecId(customsVendBOESubTrans.boeTransRefRecId);
            taxQtyConsidered += customsVendBOETrans.RemainingQty;
            if (abs(customsVendBOETrans.RemainingQty) > 0)
            {
                if (_taxWorkTrans.SourceBaseAmountCur != customsVendBOESubTrans.SourceBaseAmountCur)
                {
                    _taxWorkTrans.SourceBaseAmountCur = customsVendBOESubTrans.SourceBaseAmountCur;
                }
                qty = abs(customsVendBOETrans.RemainingQty) - taxQtyLoc;
                if (qty >= 0)
                {
                    factor = (taxQtyLoc / abs(customsVendBOETrans.BillOfEntryQty));
                }
                else // invoiced qty is more than the current subTrans qty
                {
                    factor = abs(customsVendBOETrans.RemainingQty) / abs(customsVendBOETrans.BillOfEntryQty);
                    taxQtyLoc = taxQtyLoc - abs(customsVendBOETrans.RemainingQty);
                }

                taxAmount                   += factor * customsVendBOESubTrans.TaxAmount;
                taxAmountCur                += factor * customsVendBOESubTrans.TaxAmountCur;
                taxInCostPrice              += factor * customsVendBOESubTrans.TaxInCostPrice;
                taxInCostPriceMST           += factor * customsVendBOESubTrans.TaxInCostPriceMST;
                taxInCostPriceCur           += factor * customsVendBOESubTrans.TaxInCostPriceCur;
                sourceTaxAmountCur          += factor * customsVendBOESubTrans.SourceTaxAmountCur;
                sourceTaxAmountCurReal      += factor * customsVendBOESubTrans.SourceTaxAmountCurReal;
                customsDutyLoc              += factor * customsVendBOESubTrans.CustomsDuty;

                if (EximParameters_IN::checkParameters()

                    || EximParameters_IN::checkDEPBParameters()
                    || EximParameters_IN::checkEPCGParameters())
                {
                    eximVendBOESubTrans = EximVendBOESubTrans_IN::findRefRecId(customsVendBOESubTrans.RecId);

                    eximTaxAmountCopy += factor * eximVendBOESubTrans.TaxAmount;
                    taxAmountCurLoc   += factor * eximVendBOESubTrans.TaxAmountCur;
                    depbAmountCopy    += factor * eximVendBOESubTrans.depbAmount;
                    depbAmountCopyCur += factor * eximVendBOESubTrans.depbAmountCur;

                    if (eximVendBOESubTrans.IncentiveScheme == EximIncentiveScheme_IN::None)
                    {
                        eximBalTaxAmountCopy     += factor * customsVendBOESubTrans.CustomsDuty;
                        totalBalanceTaxAmount    += customsVendBOESubTrans.SourceRegulateAmountCustoms_IN ?

                                                    factor * customsVendBOESubTrans.SourceRegulateAmountCustoms_IN :
                                                    factor * customsVendBOESubTrans.CustomsDuty;
                        balanceTaxAmountCurLoc   += factor * customsVendBOESubTrans.SourceTaxAmountCur;
                        totalBalanceTaxAmountCur += customsVendBOESubTrans.SourceRegulateAmountCustomsCur_IN ?
                                                    factor * customsVendBOESubTrans.SourceRegulateAmountCustomsCur_IN :
                                                    factor * customsVendBOESubTrans.SourceTaxAmountCur;
                    }
                    else
                    {
                        eximBalTaxAmountCopy   += factor * eximVendBOESubTrans.BalanceTaxAmount;
                        totalTaxAmount         += eximVendBOESubTrans.TaxCorrectedAmount ?
                                                    factor * eximVendBOESubTrans.TaxCorrectedAmount :
                                                    factor * eximVendBOESubTrans.TaxAmount;
                        balanceTaxAmountCurLoc += factor * eximVendBOESubTrans.BalanceTaxAmountCur;
                        taxTotalAmountCur      += eximVendBOESubTrans.TaxCorrectedAmountCur ?
                                                    factor * eximVendBOESubTrans.TaxCorrectedAmountCur :
                                                    factor * eximVendBOESubTrans.TaxAmountCur;

                        if (eximVendBOESubTrans.IncentiveScheme == EximIncentiveScheme_IN::EPCG)
                        {
                            totalBalanceTaxAmount    += eximVendBOESubTrans.BalanceTaxCorrectedAmount ?

                                                        factor * eximVendBOESubTrans.BalanceTaxCorrectedAmount :
                                                        factor * eximVendBOESubTrans.BalanceTaxAmount;
                            totalBalanceTaxAmountCur += eximVendBOESubTrans.BalanceTaxCorrectedAmountCur ?
                                                        factor * eximVendBOESubTrans.BalanceTaxCorrectedAmountCur :
                                                        factor * eximVendBOESubTrans.BalanceTaxAmountCur;
                        }
                        else
                        {
                            totalBalanceTaxAmount    += eximVendBOESubTrans.TaxCorrectedAmount ?

                                                        factor * eximVendBOESubTrans.BalanceTaxCorrectedAmount :
                                                        factor * eximVendBOESubTrans.BalanceTaxAmount;
                            totalBalanceTaxAmountCur += eximVendBOESubTrans.TaxCorrectedAmountCur ?
                                                        factor * eximVendBOESubTrans.BalanceTaxCorrectedAmountCur :
                                                        factor * eximVendBOESubTrans.BalanceTaxAmountCur;
                        }
                    }

                    if (eximVendBOESubTrans.TaxCorrectedAmount

                        || eximVendBOESubTrans.BalanceTaxCorrectedAmount)
                    {
                        isEximTaxRegulated = true;
                    }
                    if (eximVendBOESubTrans.BalanceTaxAmountCur
                        || eximVendBOESubTrans.BalanceTaxAmount)
                    {
                        isEximBalanceAmount = true;
                    }
                }

                if (customsVendBOESubTrans.SourceRegulateAmountCustoms_IN)
                {
                    sourceTaxAmountRegulateCustomsMST += factor * customsVendBOESubTrans.SourceRegulateAmountCustoms_IN;
                    isCustomsTaxRegulated = true;
                }
                else
                {
                    sourceTaxAmountRegulateCustomsMST += factor * customsVendBOESubTrans.CustomsDuty;
                }

                if (customsVendBOESubTrans.SourceRegulateAmountCustomsCur_IN)
                {
                    sourceTaxAmountRegulateCustomsCur += factor * customsVendBOESubTrans.SourceRegulateAmountCustomsCur_IN;
                    isCustomsTaxRegulated = true;
                }
                else
                {
                    sourceTaxAmountRegulateCustomsCur += factor * customsVendBOESubTrans.SourceTaxAmountCur;
                }
            }
        }
        select sum(TaxBaseAmountMST),

                sum(TaxBaseQty),
                sum(SourceTaxBaseAmountCur),
                sum(TaxBaseAmountCur)
            from tmpTax
            where tmpTax.TaxCode == _taxWorkTrans.TaxCode;

        currencyCode                    = TaxTable::find(_taxWorkTrans.TaxCode).TaxCurrencyCode;
        taxBaseAmountCalc               = CurrencyExchangeHelper::amount(tmpTax.TaxBaseAmountMST, currencyCodeMST);
        taxBaseQtyCalc                  = tmpTax.TaxBaseQty;
        taxBaseAmountCalcSourceCur      = CurrencyExchangeHelper::amount(tmpTax.SourceTaxBaseAmountCur, sourceCurrencyCode);
        taxBaseAmountCalcCur            = CurrencyExchangeHelper::amount(tmpTax.TaxBaseAmountCur, currencyCode);
        taxAmountCalc                   = taxAmount;
        taxAmountCalcCur                = taxAmountCur;
        taxInCostPriceCalc              = taxInCostPrice;
        taxInCostPriceMSTCalc           = taxInCostPriceMST;
        taxInCostPriceCurCalc           = taxInCostPriceCur;
        taxAmountCalcSourceCur          = CurrencyExchangeHelper::amount(sourceTaxAmountCur, sourceCurrencyCode);
        taxAmountCalcSourceCurReal      = CurrencyExchangeHelper::amount(sourceTaxAmountCurReal, sourceCurrencyCode);

        sourceRegulateAmountCustomsCur  = CurrencyExchangeHelper::amount(sourceTaxAmountRegulateCustomsCur, sourceCurrencyCode);
        sourceRegulateAmountCustomsMST  = CurrencyExchangeHelper::amount(sourceTaxAmountRegulateCustomsMST, sourceCurrencyCode);

        customsTaxAmountCalc            = CurrencyExchangeHelper::amount(customsDutyLoc, currencyCodeMST);

        if (EximParameters_IN::checkParameters()

            || EximParameters_IN::checkDEPBParameters()
            || EximParameters_IN::checkEPCGParameters())
        {
            eximTaxAmountCalc = CurrencyExchangeHelper::amount(eximTaxAmountCopy, currencyCodeMST);
            eximTaxAmountCur  = CurrencyExchangeHelper::amount(taxAmountCurLoc, sourceCurrencyCode);
            depbAmountCalc    = CurrencyExchangeHelper::amount(depbAmountCopy, currencyCodeMST);
            depbAmountCalcCur = CurrencyExchangeHelper::amount(depbAmountCopyCur, sourceCurrencyCode);

            if (isEximBalanceAmount)
            {
                eximBalanceTaxAmtCalc   = CurrencyExchangeHelper::amount(eximBalTaxAmountCopy, currencyCodeMST);
                eximBalanceTaxAmountCur = CurrencyExchangeHelper::amount(balanceTaxAmountCurLoc, sourceCurrencyCode);
            }
            else
            {
                eximBalanceTaxAmtCalc   = 0;
                eximBalanceTaxAmountCur = 0;
            }
            if (isEximTaxRegulated)
            {
                eximTotalTaxAmount           = CurrencyExchangeHelper::amount(totalTaxAmount, sourceCurrencyCode);
                eximTotalBalanceTaxAmount    = CurrencyExchangeHelper::amount(totalBalanceTaxAmount, sourceCurrencyCode);
                eximTotalTaxAmountCur        = CurrencyExchangeHelper::amount(taxTotalAmountCur, sourceCurrencyCode);
                eximTotalBalanceTaxAmountCur = CurrencyExchangeHelper::amount(totalBalanceTaxAmountCur, sourceCurrencyCode);
            }
            else
            {
                eximTotalTaxAmount           = 0;
                eximTotalBalanceTaxAmount    = 0;
                eximTotalTaxAmountCur        = 0;
                eximTotalBalanceTaxAmountCur = 0;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExciseRegister_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates excise register.
    /// </summary>
    /// <param name="_taxTrans">
    /// The tax transaction.
    /// </param>
    /// <param name="salesPurchJournalLine">
    /// The sales purch journal line.
    /// </param>
    /// <param name="_taxOnItem">
    /// The tax on item.
    /// </param>
    public void updateExciseRegister_IN(
        TaxTrans _taxTrans,
        SalesPurchJournalLine salesPurchJournalLine,
        TaxOnItem _taxOnItem = null)
    {
        TaxModelExciseTaxable_IN            taxModelExciseTaxable;
        TaxModelCustomsTaxable_IN           taxModelCustomsTaxable;
        container                           numberSeq;

        if (salesPurchJournalLine.SourceRecId != 0)
        {
            if (_taxTrans.RecId != 0)
            {
                switch (salesPurchJournalLine.SourceTableId)
                {
                    case tableNum(InventTransferLine) :
                        taxModelExciseTaxable = this.getTaxModelTaxable_IN(inventTransferParmLineLoc, taxWorkTrans.IsScrapQtyLine_IN) as TaxModelExciseTaxable_IN;
                        break;
                    case tableNum(SalesLine) :
                        if (_taxTrans.SourceTableId == tableNum(ProjInvoiceItem))
                        {
                            taxModelExciseTaxable = this.getTaxModelTaxable_IN(salesPurchJournalLine) as TaxModelExciseTaxable_IN;
                        }
                        else
                        {
                            taxModelExciseTaxable = this.getTaxModelTaxable_IN(SalesPurchJournalLine::findRecId(_taxTrans.SourceTableId, _taxTrans.SourceRecId)) as TaxModelExciseTaxable_IN;
                        }
                        break;
                    case tableNum(PurchLine) :
                        taxModelExciseTaxable = this.getTaxModelTaxable_IN(SalesPurchJournalLine::findRecId(_taxTrans.SourceTableId, _taxTrans.SourceRecId)) as TaxModelExciseTaxable_IN;
                        break;
                    case tableNum(InventQualityOrderTable) :
                        taxModelExciseTaxable = this.getTaxModelTaxable_IN(salesPurchJournalLine, true) as TaxModelExciseTaxable_IN;
                        break;
                    default :
                        if (salesPurchJournalLine)
                        {
                            taxModelExciseTaxable = this.getTaxModelTaxable_IN(salesPurchJournalLine) as TaxModelExciseTaxable_IN;
                        }
                        else
                        {
                            taxModelExciseTaxable = this.getTaxModelTaxable_IN(SalesPurchJournalLine::findRecId(_taxTrans.SourceTableId, _taxTrans.SourceRecId)) as TaxModelExciseTaxable_IN;
                        }

                        break;
                }
            }
            else
            {
                taxModelExciseTaxable = this.getTaxModelTaxable_IN(salesPurchJournalLine) as TaxModelExciseTaxable_IN;
            }
        }
        else
        {
            if (_taxTrans.RecId != 0)
            {
                taxModelExciseTaxable = this.getTaxModelTaxable_IN(SalesPurchJournalLine::findRecId(_taxTrans.SourceTableId, _taxTrans.SourceRecId)) as TaxModelExciseTaxable_IN;
            }
        }

        if (!taxModelExciseTaxable.shouldSkipExciseTax(_taxOnItem))
        {
            numberSeq = taxModelExciseTaxable.getExciseNumberSeq();
            // Check this is done before
            if (conLen(numberSeq) == 0 || conPeek(numberSeq, 1) == '')
            {
                if (_taxOnItem.RecId && TaxTable::find(_taxOnItem.TaxCode).TaxType_IN == TaxType_IN::Customs)
                {
                    if (!taxModelTaxable.isTaxTypeAttached(TaxType_IN::Excise))
                    {
                        taxModelCustomsTaxable = taxModelTaxable as TaxModelCustomsTaxable_IN;
                        if (taxModelCustomsTaxable.hasApplyExcise())
                        {
                            if (taxModelExciseTaxable.shouldPostQuantityRegister())
                            {
                                this.handleExciseQuantityRegister_IN(taxModelExciseTaxable);
                            }
                        }
                    }
                }
                else
                {
                    // for normal
                    if (taxModelExciseTaxable.shouldPostQuantityRegister())
                    {
                        this.handleExciseQuantityRegister_IN(taxModelExciseTaxable);
                    }
                }
            }

            if (_taxTrans != null && taxModelExciseTaxable.shouldPostAmountRegister())
            {
                this.handleExciseAmountRegister_IN(taxModelExciseTaxable, _taxTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxationOriginOnTaxWorkTrans_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>TmpTaxWorkTrans</c> records related to the order line with the specified taxation origin.
    /// </summary>
    /// <param name="_taxationOrigin">
    /// The taxation origin to be set on the <c>TmpTaxWorkTrans</c> records.
    /// </param>
    protected void updateTaxationOriginOnTaxWorkTrans_BR(FITaxationOrigin_BR _taxationOrigin)
    {
        update_recordset taxWorkTrans
            setting TaxationOrigin_BR = _taxationOrigin
                where taxWorkTrans.HeadingRecId == headingRecId
                   && taxWorkTrans.HeadingTableId == headingTableId
                   && taxWorkTrans.SourceTableId == this.sourceTableId()
                   && taxWorkTrans.SourceRecId == this.sourceRecId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxDifferenceAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates tax difference amount in accounting currency by the difference between accounting exchange rate and tax exchange rate.
    /// </summary>
    /// <param name="_tmpTaxWorkTrans">
    /// A <c>TmpTaxWorkTrans</c> record.
    /// </param>
    protected void updateTaxDifferenceAmount(TmpTaxWorkTrans _tmpTaxWorkTrans)
    {
        boolean isTaxSpecificExchRateEnabledByTable = TaxSpecificExchangeRateHelper::isTaxSpecificExchRateEnabledByTable(this.headingTableId(), this.headingRecId());

        CurrencyCode accountingCurrencyLocal = accountingCurrency;
        if (TaxIntegrationBankOrTaxSpecificExchangeRateIntercompanyFlight::instance().isEnabled()
            && isTaxSpecificExchRateEnabledByTable
            && _tmpTaxWorkTrans.SourceTableId == tableNum(LedgerJournalTrans)
            && _tmpTaxWorkTrans.Company
            && _tmpTaxWorkTrans.Company != curExt())
        {
            accountingCurrencyLocal = _tmpTaxWorkTrans.accountingCurrency();
        }

        if (isTaxSpecificExchRateEnabledByTable
            && this.getTransactionalCurrency() == accountingCurrencyLocal)
        {
            taxWorkTrans.ExchangeRateTaxBaseAmount = taxWorkTrans.SourceBaseAmountCur;
            taxWorkTrans.ExchangeRateTaxAmount = taxWorkTrans.SourceRegulateAmountCur;
        }
        else if (isTaxSpecificExchRateEnabledByTable
            && (!_tmpTaxWorkTrans.SalesTaxExchangeRate
                || this.isExchRateEquals(this.parmExchRate(), _tmpTaxWorkTrans.SalesTaxExchangeRate)))
        {
            taxWorkTrans.ExchangeRateTaxBaseAmount = taxWorkTrans.TaxBaseAmount;
            taxWorkTrans.ExchangeRateTaxAmount = taxWorkTrans.TaxAmount;
        }
        else if (isTaxSpecificExchRateEnabledByTable
            && (this.headingTableId() == tableNum(CustInvoiceTable) || this.headingTableId() == tableNum(SalesTable))
            && CustInvoiceBankExchangeRateEligibility_PL::isBankExchangeRateNotApplicableOnInvoice())
        {
            taxWorkTrans.SalesTaxExchangeRate = this.parmExchRate();
            taxWorkTrans.ExchangeRateTaxBaseAmount = taxWorkTrans.TaxBaseAmount;
            taxWorkTrans.ExchangeRateTaxAmount = taxWorkTrans.TaxAmount;

            TaxSpecificExchangeRate::saveTaxSpecificExchangeRate(
                this.headingTableId(),
                this.headingRecId(),
                this.getTransactionalCurrency(),
                accountingCurrency,
                taxWorkTrans.SalesTaxExchangeRate,
                _tmpTaxWorkTrans.VatDueDate_W);
        }
        else
        {
            if (_tmpTaxWorkTrans.SourceTableId == tableNum(LedgerJournalTrans)
                && _tmpTaxWorkTrans.Company
                && _tmpTaxWorkTrans.Company != curExt() 
                && TaxSalesTaxExchangeRateSpecificLegalEntity_PLFlight::instance().isEnabled())
            {
                changecompany (_tmpTaxWorkTrans.Company)
                {
                    this.calcExchangeRateTaxBaseAmount(_tmpTaxWorkTrans);
                }
            }
            else
            {
                this.calcExchangeRateTaxBaseAmount(_tmpTaxWorkTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcExchangeRateTaxBaseAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates amount origin (VAT exchange rate) and sales tax amount (VAT exchange rate).
    /// </summary>
    /// <param name="_tmpTaxWorkTrans">
    /// A <c>TmpTaxWorkTrans</c> record.
    /// </param>
    internal void calcExchangeRateTaxBaseAmount(TmpTaxWorkTrans _tmpTaxWorkTrans)
    {
        _tmpTaxWorkTrans.ExchangeRateTaxBaseAmount = CurrencyExchangeHelper::amountCur2MST(
            _tmpTaxWorkTrans.SourceBaseAmountCur,
            _tmpTaxWorkTrans.SourceCurrencyCode,
            _tmpTaxWorkTrans.SalesTaxExchangeRate);
        if (_tmpTaxWorkTrans.ExemptTax == NoYes::No)
        {
            TaxAmount exchangeRateTaxAmount = CurrencyExchangeHelper::amountCur2MST(
                _tmpTaxWorkTrans.SourceRegulateAmountCur,
                _tmpTaxWorkTrans.SourceCurrencyCode,
                _tmpTaxWorkTrans.SalesTaxExchangeRate);
            TaxTable taxTable = this.getTaxTable(_tmpTaxWorkTrans.TaxCode);
            if (taxTable.TaxRoundOff)
            {
                exchangeRateTaxAmount = taxTable.roundedOffTax(exchangeRateTaxAmount);
            }

            _tmpTaxWorkTrans.ExchangeRateTaxAmount = exchangeRateTaxAmount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxDifferenceAmountCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the tax amount and base amount in tax currency calculated with sales tax exchange rate type.
    /// </summary>
    /// <param name = "_tmpTaxWorkTrans">The <c>TmpTaxWorkTrans</c> record.</param>
    /// <remarks>
    /// This method is only used in advanced tax calculation feature "Enable exchange rates for sales tax".
    /// </remarks>
    protected void updateTaxDifferenceAmountCur(TmpTaxWorkTrans _tmpTaxWorkTrans)
    {
        if (this.getTransactionalCurrency() == _tmpTaxWorkTrans.CurrencyCode)
        {
            _tmpTaxWorkTrans.ExchangeRateTaxBaseAmountCur = _tmpTaxWorkTrans.SourceBaseAmountCur;
            _tmpTaxWorkTrans.ExchangeRateTaxAmountCur = _tmpTaxWorkTrans.SourceRegulateAmountCur;
        }
        else if (!_tmpTaxWorkTrans.SalesTaxExchangeRateCur
            || this.isExchRateEqualsToDefault(
                _tmpTaxWorkTrans.SourceCurrencyCode,
                _tmpTaxWorkTrans.CurrencyCode,
                _tmpTaxWorkTrans.TransDate,
                _tmpTaxWorkTrans.SalesTaxExchangeRateCur))
        {
            _tmpTaxWorkTrans.ExchangeRateTaxBaseAmountCur = _tmpTaxWorkTrans.TaxBaseAmountCur;
            _tmpTaxWorkTrans.ExchangeRateTaxAmountCur = _tmpTaxWorkTrans.TaxAmountCur;
        }
        else if ((this.headingTableId() == tableNum(CustInvoiceTable) || this.headingTableId() == tableNum(SalesTable))
            && CustInvoiceBankExchangeRateEligibility_PL::isBankExchangeRateNotApplicableOnInvoice())
        {
            taxWorkTrans.ExchangeRateTaxBaseAmountCur = taxWorkTrans.TaxBaseAmountCur;
            taxWorkTrans.ExchangeRateTaxAmountCur = taxWorkTrans.TaxAmountCur;

            CurrencyExchangeRate exchRateLoc = this.getDefaultExchRate(
                this.getTransactionalCurrency(),
                _tmpTaxWorkTrans.CurrencyCode,
                _tmpTaxWorkTrans.VatDueDate_W);
            taxWorkTrans.SalesTaxExchangeRateCur = exchRateLoc;

            TaxSpecificExchangeRate::saveTaxSpecificExchangeRate(
                this.headingTableId(),
                this.headingRecId(),
                this.getTransactionalCurrency(),
                _tmpTaxWorkTrans.CurrencyCode,
                taxWorkTrans.SalesTaxExchangeRateCur,
                _tmpTaxWorkTrans.VatDueDate_W);
        }
        else
        {
            _tmpTaxWorkTrans.ExchangeRateTaxBaseAmountCur = CurrencyExchange::calculateAmount(
                _tmpTaxWorkTrans.SourceBaseAmountCur,
                _tmpTaxWorkTrans.SalesTaxExchangeRateCur);
            _tmpTaxWorkTrans.ExchangeRateTaxBaseAmountCur = CurrencyExchange::roundWithRuleTypeCurrencyTable(
                _tmpTaxWorkTrans.ExchangeRateTaxBaseAmountCur,
                Currency::find(_tmpTaxWorkTrans.CurrencyCode),
                CurrencyRoundingRuleType::Amount);

            if (_tmpTaxWorkTrans.ExemptTax == NoYes::No)
            {
                TaxAmount exchangeRateTaxAmountCur = CurrencyExchange::calculateAmount(
                    _tmpTaxWorkTrans.SourceRegulateAmountCur,
                    _tmpTaxWorkTrans.SalesTaxExchangeRateCur);
                exchangeRateTaxAmountCur = CurrencyExchange::roundWithRuleTypeCurrencyTable(
                    exchangeRateTaxAmountCur,
                    Currency::find(_tmpTaxWorkTrans.CurrencyCode),
                    CurrencyRoundingRuleType::Amount);

                TaxTable taxTable = this.getTaxTable(_tmpTaxWorkTrans.TaxCode);
                if (taxTable.TaxRoundOff)
                {
                    exchangeRateTaxAmountCur = taxTable.roundedOffTax(exchangeRateTaxAmountCur);
                }

                _tmpTaxWorkTrans.ExchangeRateTaxAmountCur = exchangeRateTaxAmountCur;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxDifferenceAmountRep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the tax amount and base amount in reporting currency calculated with sales tax exchange rate type.
    /// </summary>
    /// <param name = "_tmpTaxWorkTrans">The <c>TmpTaxWorkTrans</c> record.</param>
    /// <remarks>
    /// This method is only used in advanced tax calculation feature "Enable exchange rates for sales tax".
    /// </remarks>
    protected void updateTaxDifferenceAmountRep(TmpTaxWorkTrans _tmpTaxWorkTrans)
    {
        if (TaxIntegrationBankOrTaxSpecificExchangeRateIntercompanyFlight::instance().isEnabled()
            && _tmpTaxWorkTrans.SourceTableId == tableNum(LedgerJournalTrans)
            && _tmpTaxWorkTrans.Company
            && _tmpTaxWorkTrans.Company != curExt())
        {
            reportingCurrencyForTaxSpecificExchRate = _tmpTaxWorkTrans.reportingCurrency();
        }

        if (this.getTransactionalCurrency() == reportingCurrencyForTaxSpecificExchRate)
        {
            _tmpTaxWorkTrans.ExchangeRateTaxBaseAmountRep = _tmpTaxWorkTrans.SourceBaseAmountCur;
            _tmpTaxWorkTrans.ExchangeRateTaxAmountRep = _tmpTaxWorkTrans.SourceRegulateAmountCur;
        }
        else if (!_tmpTaxWorkTrans.SalesTaxExchangeRateRep
            || this.isExchRateEquals(this.parmReportingCurrencyExchRate(), _tmpTaxWorkTrans.SalesTaxExchangeRateRep)
            || (!reportingCurrencyForTaxSpecificExchRate
                && TaxIntegrationNoReportingCurrencyFlight::instance().isEnabled())
            || (this.isExchRateEqualsToDefault(
                    _tmpTaxWorkTrans.SourceCurrencyCode,
                    reportingCurrencyForTaxSpecificExchRate,
                    _tmpTaxWorkTrans.TransDate,
                    _tmpTaxWorkTrans.SalesTaxExchangeRateRep)))
        {
            _tmpTaxWorkTrans.ExchangeRateTaxBaseAmountRep = _tmpTaxWorkTrans.TaxBaseAmountRep;
            _tmpTaxWorkTrans.ExchangeRateTaxAmountRep = _tmpTaxWorkTrans.TaxAmountRep;
        }
        else if ((this.headingTableId() == tableNum(CustInvoiceTable) || this.headingTableId() == tableNum(SalesTable))
            && CustInvoiceBankExchangeRateEligibility_PL::isBankExchangeRateNotApplicableOnInvoice())
        {
            taxWorkTrans.ExchangeRateTaxBaseAmountRep = taxWorkTrans.TaxBaseAmountRep;
            taxWorkTrans.ExchangeRateTaxAmountRep = taxWorkTrans.TaxAmountRep;

            CurrencyExchangeRate exchRateLoc = this.getDefaultExchRate(
                this.getTransactionalCurrency(),
                reportingCurrencyForTaxSpecificExchRate,
                _tmpTaxWorkTrans.VatDueDate_W);
            taxWorkTrans.SalesTaxExchangeRateRep = exchRateLoc;

            TaxSpecificExchangeRate::saveTaxSpecificExchangeRate(
                this.headingTableId(),
                this.headingRecId(),
                this.getTransactionalCurrency(),
                reportingCurrencyForTaxSpecificExchRate,
                taxWorkTrans.SalesTaxExchangeRateRep,
                _tmpTaxWorkTrans.VatDueDate_W);
        }
        else
        {
            Currency currencyToRound;
            if (TaxIntegrationReportingCurrencyRoundFlight::instance().isEnabled())
            {
                currencyToRound = Currency::find(reportingCurrencyForTaxSpecificExchRate ? reportingCurrencyForTaxSpecificExchRate : accountingCurrency);
            }
            else
            {
                currencyToRound = Currency::find(_tmpTaxWorkTrans.CurrencyCode);
            }

            _tmpTaxWorkTrans.ExchangeRateTaxBaseAmountRep = CurrencyExchange::calculateAmount(
                _tmpTaxWorkTrans.SourceBaseAmountCur,
                _tmpTaxWorkTrans.SalesTaxExchangeRateRep);
            _tmpTaxWorkTrans.ExchangeRateTaxBaseAmountRep = CurrencyExchange::roundWithRuleTypeCurrencyTable(
                    _tmpTaxWorkTrans.ExchangeRateTaxBaseAmountRep,
                    currencyToRound,
                    CurrencyRoundingRuleType::Amount);

            if (_tmpTaxWorkTrans.ExemptTax == NoYes::No)
            {
                TaxAmount exchangeRateTaxAmountRep = CurrencyExchange::calculateAmount(
                    _tmpTaxWorkTrans.SourceRegulateAmountCur,
                    _tmpTaxWorkTrans.SalesTaxExchangeRateRep);
                exchangeRateTaxAmountRep = CurrencyExchange::roundWithRuleTypeCurrencyTable(
                    exchangeRateTaxAmountRep,
                    currencyToRound,
                    CurrencyRoundingRuleType::Amount);

                TaxTable taxTable = this.getTaxTable(_tmpTaxWorkTrans.TaxCode);
                if (taxTable.TaxRoundOff)
                {
                    exchangeRateTaxAmountRep = taxTable.roundedOffTax(exchangeRateTaxAmountRep);
                }

                _tmpTaxWorkTrans.ExchangeRateTaxAmountRep = exchangeRateTaxAmountRep;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultExchRate</Name>
				<Source><![CDATA[
    private CurrencyExchangeRate getDefaultExchRate(
        CurrencyCode _sourceCurrencyCode,
        CurrencyCode _currencyCode,
        VatDueDate_W _exchRateDate)
    {
        CurrencyExchangeRate defaultExchRate;

        if (!defaultExchRateMap)
        {
            defaultExchRateMap = new Map(Types::String, Types::Real);
        }

        if (defaultExchRateMap.exists(_currencyCode))
        {
            defaultExchRate = defaultExchRateMap.lookup(_currencyCode);
        }
        else
        {
            ExchangeRateHelper exchangeRateHelperLoc = ExchangeRateHelper::newCurrencyToCurrency(_sourceCurrencyCode, _currencyCode);
            exchangeRateHelperLoc.parmExchangeDate(_exchRateDate);
            defaultExchRate = exchangeRateHelperLoc.getExchangeRate1();
            defaultExchRateMap.add(_currencyCode, defaultExchRate);
        }

        return defaultExchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isExchRateEquals</Name>
				<Source><![CDATA[
    private boolean isExchRateEquals(CurrencyExchangeRate _exchangeRate1, CurrencyExchangeRate _exchangeRate2)
    {
        const real MinimumExchRateDiffAmount = 0.0000000000001;

        return abs(_exchangeRate1 - _exchangeRate2) < MinimumExchRateDiffAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isExchRateEqualsToDefault</Name>
				<Source><![CDATA[
    private boolean isExchRateEqualsToDefault(
        CurrencyCode _sourceCurrencyCode,
        CurrencyCode _currencyCode,
        VatDueDate_W _exchRateDate,
        CurrencyExchangeRate _exchangeRate)
    {
        if (_exchRateDate)
        {
            CurrencyExchangeRate defaultExchRate = this.getDefaultExchRate(_sourceCurrencyCode, _currencyCode, _exchRateDate);

            return this.isExchRateEquals(defaultExchRate, _exchangeRate);
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>TaxUncommitted</c> records by using the <c>TmpTaxWorkTrans</c> table.
    /// </summary>
    /// <param name="_doIsolateTransactionScope">
    /// true if <c>TaxUncommitted</c> should be maintained in a independent transaction scope; otherwise false.
    /// </param>
    public void updateTaxUncommitted(boolean _doIsolateTransactionScope = false)
    {
        if (this.useTaxUncommitted())
        {
            if (this is TaxSales)
            {
                // 1. For the subclass of <c>Tax</c>, if it is not inherited from <c>TaxCalculation</c>,
                // it can't call <c>TaxUncommitted::updateTaxUncommitted</c> because the method uses <c>TaxCalculation</c> as a parameter.
                // 2. For sales order, the <c>TaxSales::useTaxUncommitted</c> method returns true only when tax calculation service is enabled.
                TaxUncommitted::deleteForDocumentHeader(this.headingTableId(), this.headingRecId(), false);
                TaxUncommitted::createTaxUncommitted(this);
            }
            else
            {
                TaxUncommitted::updateTaxUncommitted(this, _doIsolateTransactionScope);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxWorkTrans_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates <c>TmpTaxWorkTrans</c> record.
    /// </summary>
    /// <param name="_taxWorkTrans">
    ///    The <c>TmpTaxWorkTrans</c> record to be updated.
    /// </param>
    protected void updateTaxWorkTrans_RU(TmpTaxWorkTrans _taxWorkTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTmpTaxWorkTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates temporary tax work transaction.
    /// </summary>
    /// <param name="_taxTable">
    /// The tax table.
    /// </param>
    /// <param name="_dimensionDefault">
    /// The default dimension.
    /// </param>
    /// <returns>
    /// If 'True', the update is succeed.
    /// </returns>
    public boolean updateTmpTaxWorkTrans_IN(
        TaxTable         _taxTable,
        DimensionDefault _dimensionDefault)
    {
        TaxLedgerAccounts_IN            taxLedgerAccounts;
        TaxLedgerAccountGroup_IN        taxLedgerAccountGroup;
        boolean                         ret = true;
        SalesLine                       salesLineLoc;
        SalesLine_IN                    salesLineLoc_IN;
        TaxLedgerAccountSetup_IN        taxLedgerAccountSetup;
        TaxAccountType_IN               taxAccountTypeLoc;
        LedgerDimensionDefaultAccount   defaultAccount;
        LedgerDimensionDefaultAccount   defaultAccount_IN;

        //For NON PO line
        boolean                             isThisNONPOLine;
        TaxInformationRefRecId_IN           taxInformationRecId;
        VendInvoiceInfoLine                 vendInvoiceInfoLineLoc;
        InventTransferLine                  inventTransferLineLoc;
        ExciseRecordType_IN                 exciseRecordType;
        ExciseType_IN                       exciseType;
        DirectSettlement_IN                 directSettleMent;
        PurchLine                           purchLineExcise;
        TaxDirection                        taxDirection;
        TransTaxInformation                 transTaxInformation;

        if (salesPurchJournalLineLoc.SourceTableId == tableNum(PurchRFQLine)
            || salesPurchJournalLineLoc.SourceTableId == tableNum(SalesQuotationLine))
        {
            return true;
        }

        if (inventTransferUpdateType == InventTransferUpdateType::Receive)
        {
            transTaxInformation = transTaxInformationHelper.getTransTaxInformation(salesPurchJournalLineLoc.SourceTableId, salesPurchJournalLineLoc.SourceRecId, TransTaxInformationType_IN::InventTransferTo);
        }
        else
        {
            transTaxInformation = transTaxInformationHelper.getTransTaxInformation(salesPurchJournalLineLoc.SourceTableId, salesPurchJournalLineLoc.SourceRecId);
        }

        exciseRecordType = transTaxInformation.ExciseRecordType;
        exciseType = transTaxInformation.ExciseType;
        directSettleMent = transTaxInformation.ExciseDirectSettlement;

        taxDirection = taxWorkTrans.TaxDirection;

        switch (salesPurchJournalLineLoc.SourceTableId)
        {
            case tableNum(InventTransferLine):
                inventTransferLineLoc = InventTransferLine::findRecId(salesPurchJournalLineLoc.SourceRecId);
                break;

            case tableNum(VendInvoiceInfoLine):

                vendInvoiceInfoLineLoc      = VendInvoiceInfoLine::findRecId(salesPurchJournalLineLoc.SourceRecId);

                if (vendInvoiceInfoLineLoc.RecId && vendInvoiceInfoLineLoc.isNonPO())
                {
                    //For NON PO line
                    isThisNONPOLine = true;
                }
                else
                {
                    isThisNONPOLine = false;
                }

                if (! isThisNONPOLine
                    && TaxTable::find(taxWorkTrans.TaxCode).TaxType_IN == TaxType_IN::Excise
                    && directSettleMent == DirectSettlement_IN::None)
                {
                    purchLineExcise = PurchLine::findRecId(vendInvoiceInfoLineLoc.PurchLineRecId);
                    if (purchLineExcise.InventRefId
                        && TaxTrans_IN::isTaxSettledForTransaction(tableNum(VendInvoiceTrans), VendInvoiceTrans::findInventTransId(purchLineExcise.InventRefTransId).RecId))
                    {
                        taxDirection = TaxDirection::OutgoingTax;
                    }
                }

                if (directSettleMent == DirectSettlement_IN::PLA)
                {
                    taxDirection = TaxDirection::OutgoingTax;
                }
                else if (directSettleMent == DirectSettlement_IN::RG23A || directSettleMent == DirectSettlement_IN::RG23C)
                {
                    taxDirection = TaxDirection::IncomingTax;
                }

                break;

            case tableNum(PurchLine),
                 tableNum(SalesLine),
                 tableNum(CustInvoiceTrans),
                 tableNum(ProjCostTrans),
                 tableNum(ProjItemTrans),
                 tableNum(ProjOnAccTrans):

                if (salesPurchJournalLineLoc.SourceTableId == tableNum(PurchLine)
                    && TaxTable::find(taxWorkTrans.TaxCode).TaxType_IN == TaxType_IN::Excise
                    && directSettleMent == DirectSettlement_IN::None)
                {
                    purchLineExcise = PurchLine::findRecId(salesPurchJournalLineLoc.SourceRecId);
                    if (purchLineExcise.InventRefId
                        && TaxTrans_IN::isTaxSettledForTransaction(tableNum(VendInvoiceTrans), VendInvoiceTrans::findInventTransId(purchLineExcise.InventRefTransId).RecId))
                    {
                        taxDirection = TaxDirection::OutgoingTax;
                    }
                }

                if (directSettleMent == DirectSettlement_IN::PLA)
                {
                    taxDirection = TaxDirection::OutgoingTax;
                }
                else if (directSettleMent == DirectSettlement_IN::RG23A || directSettleMent == DirectSettlement_IN::RG23C)
                {
                    taxDirection = TaxDirection::IncomingTax;
                }

                break;

            default:
                break;
        }

        ret =
            (_taxTable.TaxType_IN == TaxType_IN::Customs          && isCustomsEnabled)
            || (_taxTable.TaxType_IN == TaxType_IN::Excise        && isExciseEnabled)
            || (_taxTable.TaxType_IN == TaxType_IN::SalesTax      && isSalesTaxEnabled)
            || (_taxTable.TaxType_IN == TaxType_IN::ServiceTax    && isServiceTaxEnabled)
            || (_taxTable.TaxType_IN == TaxType_IN::VAT           && isVATEnabled);

        taxWorkTrans.TaxAccountType_IN = this.determineAccountType_IN(_taxTable);

        if (ret
            && taxWorkTrans.TaxAmount)
        {
            ret = this.checkTaxData_IN(_taxTable);
        }

        if (ret)
        {
            taxWorkTrans.TaxRegistrationNumberTable_IN = this.determineTaxRegistrationNumber_IN(_taxTable.TaxType_IN);
            if (taxWorkTrans.TaxRegistrationNumberTable_IN)
            {
                if (_taxTable.TaxType_IN == TaxType_IN::Excise)
                {
                    if (salesPurchJournalLineLoc.SourceTableId == tableNum(SalesLine))
                    {
                        salesLineLoc = SalesLine::findRecId(salesPurchJournalLineLoc.SourceRecId);
                        salesLineLoc_IN = salesLineLoc.salesLine_IN();
                    }
                    if (taxWorkTrans.Source == TaxModuleType::Sales
                        && (salesLineLoc.SalesType == SalesType::ReturnItem
                        || (salesLineLoc_IN.CreditNoteDate
                        && salesLineLoc.InventTransIdReturn)
                        || (salesLineLoc.SalesType == SalesType::Sales
                        && SalesTable::find(salesLineLoc.SalesId).InterCompanyCompanyId
                        && salesLineLoc_IN.CreditNoteDate)))
                    {
                        // defaultAccount value is set from taxLedgerAccounts.End of method _dimensionDefault is consider to get the ledgerDimension.
                        defaultAccount  = taxLedgerAccounts.getExciseAccountsForReturnOrder(_taxTable.TaxLedgerAccountGroup_IN,
                                                                                                     _taxTable.TaxComponentTable_IN,
                                                                                                     taxWorkTrans.TaxRegistrationNumberTable_IN,
                                                                                                     salesLineLoc.ReturnDispositionCodeId,
                                                                                                     exciseRecordType);
                    }
                    else
                    {
                        defaultAccount  = taxLedgerAccounts.exciseTaxAccountNum(_taxTable,
                                                                                taxWorkTrans.TaxRegistrationNumberTable_IN,
                                                                                exciseRecordType,
                                                                                taxDirection,
                                                                                inventTransferUpdateType == InventTransferUpdateType::Receive? DirectSettlement_IN::None : directSettleMent).LedgerDimension;

                        // defaultAccount_IN value is set from taxLedgerAccounts.End of method _dimensionDefault is consider to get the ledgerDimension_IN.
                        defaultAccount_IN  = taxLedgerAccounts.exciseDeferredTaxAccountNum(_taxTable,
                                                                                                    taxWorkTrans.TaxRegistrationNumberTable_IN,
                                                                                                    exciseRecordType,
                                                                                                    taxWorkTrans.TaxDirection,
                                                                                                    taxWorkTrans.ClaimPercentage_IN).LedgerDimension;
                    }
                    if (inventTransferUpdateType == InventTransferUpdateType::Receive
                        && taxWorkTrans.IsScrapQtyLine_IN
                        && salesPurchJournalLineLoc.SourceTableId == tableNum(InventTransferLine))
                    {
                        [defaultAccount_IN, defaultAccount] = taxLedgerAccounts.exciseTaxAccountNumForScrapQty(_taxTable,
                                                                                                               taxWorkTrans.TaxRegistrationNumberTable_IN,
                                                                                                               exciseRecordType,
                                                                                                               exciseType,
                                                                                                               directSettleMent);
                    }
                }
                else if (_taxTable.TaxType_IN == TaxType_IN::ServiceTax)
                {
                    taxLedgerAccountGroup    = TaxLedgerAccountGroup_IN::find(_taxTable.TaxLedgerAccountGroup_IN);

                    defaultAccount  = this.serviceTaxAccountNum_IN(taxLedgerAccountGroup.RecId,
                                                                            _taxTable,
                                                                            taxWorkTrans.TaxDirection,
                                                                            _dimensionDefault);
                }
                else if (_taxTable.TaxType_IN == TaxType_IN::Customs)
                {
                    if (TaxLedgerAccountSetup_IN::findByTaxAccountGroup(_taxTable.TaxLedgerAccountGroup_IN,
                                                                       TaxAccountCode_IN::Table,
                                                                       taxWorkTrans.TaxRegistrationNumberTable_IN))
                    {
                        defaultAccount = TaxLedgerAccounts_IN::findByTaxAccounts(TaxLedgerAccountSetup_IN::findByTaxAccountGroup(_taxTable.TaxLedgerAccountGroup_IN,
                                                                                 TaxAccountCode_IN::Table,
                                                                                 taxWorkTrans.TaxRegistrationNumberTable_IN).RecId,
                                                                                 taxWorkTrans.TaxAccountType_IN,
                                                                                 _taxTable.TaxComponentTable_IN).LedgerDimension;
                    }
                    if (this.validCustomsScenario_IN())
                    {
                        if (taxWorkTrans.TaxDirection == TaxDirection::OutgoingTax)
                        {
                            taxAccountTypeLoc = TaxAccountType_IN::CustomsExportDutyExpenseAccount;
                        }
                        else if (taxWorkTrans.TaxDirection == TaxDirection::IncomingTax)
                        {
                            taxAccountTypeLoc = TaxAccountType_IN::CustomsImportDutyPayableAccount;
                        }
                        //Since it involve both PO and Non PO line, here i'm replacing below salesPurchJournalLineLoc.CompanyLocation to companyLocation
                        if (TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, _taxTable.TaxType_IN).RecId)
                        {
                            // Corresponding to a (TaxLedgerA/CGroup + LedgerA/CSetup) & 'TaxAccountCode' enum value Table & All; there can be
                            // multiple LedgerA/C's. The uniqueness is identified only when the tax component & type is identified.
                            // ie, Unique A/C for India = [(TaxLedgerA/CGroup + LedgerA/CSetup) + 'TaxAccountCode' + TaxComponent + A/C Type ]attached to the TaxCode under consideration.
                            if (TaxLedgerAccountSetup_IN::findByTaxAccountGroup(_taxTable.TaxLedgerAccountGroup_IN,
                                                               TaxAccountCode_IN::Table,
                                                               TaxInformation_IN::find(taxInformationRecId).getTaxRegistrationNumbersTable(_taxTable.TaxType_IN).RecId))
                            {
                                defaultAccount_IN = TaxLedgerAccounts_IN::findByTaxAccounts(TaxLedgerAccountSetup_IN::findByTaxAccountGroup(_taxTable.TaxLedgerAccountGroup_IN,
                                                                                            TaxAccountCode_IN::Table,
                                                                                            TaxInformation_IN::find(taxInformationRecId).getTaxRegistrationNumbersTable(_taxTable.TaxType_IN).RecId).RecId,
                                                                                            taxAccountTypeLoc,
                                                                                            _taxTable.TaxComponentTable_IN).LedgerDimension;
                                if (!defaultAccount_IN)
                                {
                                    select firstonly LedgerDimension from taxLedgerAccounts
                                        join taxLedgerAccountSetup
                                        where taxLedgerAccountSetup.TaxLedgerAccountGroup == _taxTable.TaxLedgerAccountGroup_IN
                                           && taxLedgerAccountSetup.AccountCode           == TaxAccountCode_IN::All
                                           && taxLedgerAccounts.TaxLedgerAccountSetup     == taxLedgerAccountSetup.RecId
                                           && taxLedgerAccounts.AccountType               == taxAccountTypeLoc
                                           && taxLedgerAccounts.TaxComponentTable         == _taxTable.TaxComponentTable_IN;
                                    defaultAccount_IN = taxLedgerAccounts.LedgerDimension;
                                }
                            }
                            else
                            {
                                select firstonly LedgerDimension from taxLedgerAccounts
                                        join RecId, TaxLedgerAccountGroup from taxLedgerAccountSetup
                                        where taxLedgerAccountSetup.TaxLedgerAccountGroup == _taxTable.TaxLedgerAccountGroup_IN
                                           && taxLedgerAccountSetup.AccountCode           == TaxAccountCode_IN::All
                                           && taxLedgerAccounts.TaxLedgerAccountSetup     == taxLedgerAccountSetup.RecId
                                           && taxLedgerAccounts.AccountType               == taxAccountTypeLoc
                                           && taxLedgerAccounts.TaxComponentTable         == _taxTable.TaxComponentTable_IN;
                                defaultAccount_IN = taxLedgerAccounts.LedgerDimension;
                            }
                            this.setCustomsAccNum_IN(LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount_IN, _dimensionDefault), taxAccountTypeLoc);
                        }
                    }
                }
                else
                {
                    if (TaxLedgerAccountSetup_IN::findByTaxAccountGroup(_taxTable.TaxLedgerAccountGroup_IN,
                                                                       TaxAccountCode_IN::Table,
                                                                       taxWorkTrans.TaxRegistrationNumberTable_IN))
                    {
                        defaultAccount = TaxLedgerAccounts_IN::findByTaxAccounts(TaxLedgerAccountSetup_IN::findByTaxAccountGroup(_taxTable.TaxLedgerAccountGroup_IN,
                                                                                 TaxAccountCode_IN::Table,
                                                                                 taxWorkTrans.TaxRegistrationNumberTable_IN).RecId,
                                                                                 taxWorkTrans.TaxAccountType_IN,
                                                                                 _taxTable.TaxComponentTable_IN).LedgerDimension;
                    }
                }

                if (!defaultAccount)
                {
                    taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(_taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::All, 0);
                    if (!taxLedgerAccountSetup)
                    {
                        taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(_taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::Table, taxWorkTrans.TaxRegistrationNumberTable_IN);
                    }
                    select firstonly LedgerDimension from taxLedgerAccounts
                        join RecId from taxLedgerAccountSetup
                        where taxLedgerAccountSetup.TaxLedgerAccountGroup == _taxTable.TaxLedgerAccountGroup_IN
                           && taxLedgerAccountSetup.AccountCode           == TaxAccountCode_IN::All
                           && taxLedgerAccounts.TaxLedgerAccountSetup     == taxLedgerAccountSetup.RecId
                           && taxLedgerAccounts.AccountType               == taxWorkTrans.TaxAccountType_IN
                           && taxLedgerAccounts.TaxComponentTable         == _taxTable.TaxComponentTable_IN;

                    defaultAccount = taxLedgerAccounts.LedgerDimension;
                }
            }
            if (defaultAccount)
            {
                taxWorkTrans.LedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount, _dimensionDefault);
            }
            if (defaultAccount_IN)
            {
                taxWorkTrans.LedgerDimension_IN = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount_IN, _dimensionDefault);
            }

            taxWorkTrans.update();
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVATExchRate_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates temporary sales tax transactions for the current document with the specified date of VAT register and VAT exchange rate
    /// </summary>
    /// <param name="_dateOfVATRegister">
    /// Date of VAT register
    /// </param>
    /// <param name="_vatExchRate">
    /// VAT exchange rate
    /// </param>
    public void updateVATExchRate_W(VatDueDate_W _dateOfVATRegister = dateNull(),
                                    ExchRate     _vatExchRate       = 0)
    {
        while select forupdate taxWorkTrans
            where taxWorkTrans.HeadingRecId == headingRecId
                && taxWorkTrans.HeadingTableId == headingTableId
        {
            taxWorkTrans.VatDueDate_W = _dateOfVATRegister;
            taxWorkTrans.SalesTaxExchangeRate = _vatExchRate;
            TaxAmountCur sourceTaxAmountCurLoc = taxWorkTrans.SourceRegulateAmountCur ? taxWorkTrans.SourceRegulateAmountCur : taxWorkTrans.SourceTaxAmountCur;

            if (TaxSpecificExchangeRateHelper::isTaxSpecificExchRateEnabledByTable(this.headingRecId(), this.headingRecId()))
            {
                taxWorkTrans.ExchangeRateTaxBaseAmount = CurrencyExchange::calculateAmount(taxWorkTrans.SourceBaseAmountCur, _vatExchRate);
                taxWorkTrans.ExchangeRateTaxBaseAmount = CurrencyExchangeHelper::amount(taxWorkTrans.ExchangeRateTaxBaseAmount);
                taxWorkTrans.ExchangeRateTaxAmount = CurrencyExchange::calculateAmount(sourceTaxAmountCurLoc, _vatExchRate);
                taxWorkTrans.ExchangeRateTaxAmount = CurrencyExchangeHelper::amount(taxWorkTrans.ExchangeRateTaxAmount);
            }
            else
            {
                taxWorkTrans.ExchangeRateTaxBaseAmount = CurrencyExchangeHelper::amount(taxWorkTrans.SourceBaseAmountCur * _vatExchRate / 100);
                taxWorkTrans.ExchangeRateTaxAmount = CurrencyExchangeHelper::amount(sourceTaxAmountCurLoc * _vatExchRate / 100);
            }

            TaxTable taxTable = TaxTable::find(taxWorkTrans.TaxCode);
            roundOff = taxTable.TaxRoundOff;

            if (roundOff)
            {
                taxWorkTrans.ExchangeRateTaxAmount = taxTable.roundedOffTax(taxWorkTrans.ExchangeRateTaxAmount);
            }

            taxWorkTrans.update(this.ignoreCalculatedSalesTax());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVATExchRateRep_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates temporary sales tax transactions for the current document with the specified date of VAT register and reporting currency VAT exchange rate
    /// </summary>
    /// <param name="_dateOfVATRegister">
    /// Date of VAT register.
    /// </param>
    /// <param name="_vatExchRate">
    /// Exchange rate.
    /// </param>
    internal void updateVATExchRateRep_W(VatDueDate_W _dateOfVATRegister, ExchRate _vatExchRate)
    {
        while select forupdate taxWorkTrans
            where taxWorkTrans.HeadingRecId == headingRecId
                && taxWorkTrans.HeadingTableId == headingTableId
        {
            taxWorkTrans.VatDueDate_W  = _dateOfVATRegister;
            taxWorkTrans.SalesTaxExchangeRateRep = _vatExchRate;
            TaxAmountCur sourceTaxAmountCurLoc = taxWorkTrans.SourceRegulateAmountCur ? taxWorkTrans.SourceRegulateAmountCur : taxWorkTrans.SourceTaxAmountCur;

            taxWorkTrans.ExchangeRateTaxBaseAmountRep = CurrencyExchange::calculateAmount(taxWorkTrans.SourceBaseAmountCur, _vatExchRate);
            taxWorkTrans.ExchangeRateTaxBaseAmountRep = CurrencyExchangeHelper::amount(taxWorkTrans.ExchangeRateTaxBaseAmountRep);
            taxWorkTrans.ExchangeRateTaxAmountRep = CurrencyExchange::calculateAmount(sourceTaxAmountCurLoc, _vatExchRate);
            taxWorkTrans.ExchangeRateTaxAmountRep = CurrencyExchangeHelper::amount(taxWorkTrans.ExchangeRateTaxAmountRep);

            TaxTable taxTable = TaxTable::find(taxWorkTrans.TaxCode);
            roundOff = taxTable.TaxRoundOff;

            if (roundOff)
            {
                taxWorkTrans.ExchangeRateTaxAmountRep = taxTable.roundedOffTax(taxWorkTrans.ExchangeRateTaxAmountRep);
            }

            taxWorkTrans.update(this.ignoreCalculatedSalesTax());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVATExchRateCur_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates temporary sales tax transactions for the current document with the specified date of VAT register and tax currency VAT exchange rate
    /// </summary>
    /// <param name="_dateOfVATRegister">
    /// Date of VAT register.
    /// </param>
    /// <param name="_vatExchRate">
    /// Exchange rate.
    /// </param>
    /// <param name="_currencyCode">
    /// Currency code.
    /// </param>
    internal void updateVATExchRateCur_W(
        VatDueDate_W _dateOfVATRegister,
        ExchRate _vatExchRate,
        CurrencyCode _currencyCode)
    {
        while select forupdate taxWorkTrans
            where taxWorkTrans.HeadingRecId == headingRecId
                && taxWorkTrans.HeadingTableId == headingTableId
                && taxWorkTrans.CurrencyCode == _currencyCode
        {
            taxWorkTrans.VatDueDate_W  = _dateOfVATRegister;
            taxWorkTrans.SalesTaxExchangeRateCur = _vatExchRate;
            TaxAmountCur sourceTaxAmountCurLoc = taxWorkTrans.SourceRegulateAmountCur ? taxWorkTrans.SourceRegulateAmountCur : taxWorkTrans.SourceTaxAmountCur;

            taxWorkTrans.ExchangeRateTaxBaseAmountCur = CurrencyExchange::calculateAmount(taxWorkTrans.SourceBaseAmountCur, _vatExchRate);
            taxWorkTrans.ExchangeRateTaxBaseAmountCur = CurrencyExchangeHelper::amount(taxWorkTrans.ExchangeRateTaxBaseAmountCur);
            taxWorkTrans.ExchangeRateTaxAmountCur = CurrencyExchange::calculateAmount(sourceTaxAmountCurLoc, _vatExchRate);
            taxWorkTrans.ExchangeRateTaxAmountCur = CurrencyExchangeHelper::amount(taxWorkTrans.ExchangeRateTaxAmountCur);

            TaxTable taxTable = TaxTable::find(taxWorkTrans.TaxCode);
            roundOff = taxTable.TaxRoundOff;

            if (roundOff)
            {
                taxWorkTrans.ExchangeRateTaxAmountCur = taxTable.roundedOffTax(taxWorkTrans.ExchangeRateTaxAmountCur);
            }

            taxWorkTrans.update(this.ignoreCalculatedSalesTax());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxSpecificExchRates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the tax amount and base amount with sales tax exchange rate type.
    /// </summary>
    /// <param name = "_dateOfVATRegister">Date of VAT register</param>
    /// <param name = "_exchRateMap">A map object</param>
    /// <remarks>
    /// This method is only used in tax integration.
    /// </remarks>
    internal void updateTaxSpecificExchRates(VatDueDate_W _dateOfVATRegister, Map _exchRateMap)
    {
        CurrencyExchangeRate accountingExchRate = _exchRateMap.exists(accountingCurrency) ? _exchRateMap.lookup(accountingCurrency) : 0;
        CurrencyExchangeRate reportingExchRate = _exchRateMap.exists(reportingCurrencyForTaxSpecificExchRate) ? _exchRateMap.lookup(reportingCurrencyForTaxSpecificExchRate) : 0;

        while select forupdate taxWorkTrans
            where taxWorkTrans.HeadingRecId == headingRecId
                && taxWorkTrans.HeadingTableId == headingTableId
        {
            if (TaxIntegrationBankOrTaxSpecificExchangeRateIntercompanyFlight::instance().isEnabled() && taxWorkTrans.SourceTableId == tableNum(LedgerJournalTrans))
            {
                CurrencyCode accountingCurrencyLocal = taxWorkTrans.accountingCurrency();
                accountingExchRate = _exchRateMap.exists(accountingCurrencyLocal) ? _exchRateMap.lookup(accountingCurrencyLocal) : 0;

                CurrencyCode reportingCurrencyLocal = taxWorkTrans.reportingCurrency();
                reportingExchRate = _exchRateMap.exists(reportingCurrencyLocal) ? _exchRateMap.lookup(reportingCurrencyLocal) : 0;
            }

            taxWorkTrans.VatDueDate_W  = _dateOfVATRegister;
            TaxAmountCur sourceTaxAmountCurLoc = taxWorkTrans.SourceRegulateAmountCur ? taxWorkTrans.SourceRegulateAmountCur : taxWorkTrans.SourceTaxAmountCur;

            if (accountingExchRate && !this.isExchRateEquals(accountingExchRate, taxWorkTrans.SalesTaxExchangeRate))
            {
                taxWorkTrans.SalesTaxExchangeRate = accountingExchRate;
                taxWorkTrans.ExchangeRateTaxBaseAmount = CurrencyExchange::calculateAmount(taxWorkTrans.SourceBaseAmountCur, accountingExchRate);
                taxWorkTrans.ExchangeRateTaxBaseAmount = CurrencyExchangeHelper::amount(taxWorkTrans.ExchangeRateTaxBaseAmount);
                taxWorkTrans.ExchangeRateTaxAmount = CurrencyExchange::calculateAmount(sourceTaxAmountCurLoc, accountingExchRate);
                taxWorkTrans.ExchangeRateTaxAmount = CurrencyExchangeHelper::amount(taxWorkTrans.ExchangeRateTaxAmount);
            }

            if (reportingExchRate && !this.isExchRateEquals(reportingExchRate, taxWorkTrans.SalesTaxExchangeRateRep))
            {
                taxWorkTrans.SalesTaxExchangeRateRep = reportingExchRate;
                taxWorkTrans.ExchangeRateTaxBaseAmountRep = CurrencyExchange::calculateAmount(taxWorkTrans.SourceBaseAmountCur, reportingExchRate);
                taxWorkTrans.ExchangeRateTaxBaseAmountRep = CurrencyExchangeHelper::amount(taxWorkTrans.ExchangeRateTaxBaseAmountRep);
                taxWorkTrans.ExchangeRateTaxAmountRep = CurrencyExchange::calculateAmount(sourceTaxAmountCurLoc, reportingExchRate);
                taxWorkTrans.ExchangeRateTaxAmountRep = CurrencyExchangeHelper::amount(taxWorkTrans.ExchangeRateTaxAmountRep);
            }

            CurrencyExchangeRate taxExchRate = _exchRateMap.exists(taxWorkTrans.CurrencyCode) ? _exchRateMap.lookup(taxWorkTrans.CurrencyCode) : 0;
            if (taxExchRate && !this.isExchRateEquals(taxExchRate, taxWorkTrans.SalesTaxExchangeRateCur))
            {
                taxWorkTrans.SalesTaxExchangeRateCur = taxExchRate;
                taxWorkTrans.ExchangeRateTaxBaseAmountCur = CurrencyExchange::calculateAmount(taxWorkTrans.SourceBaseAmountCur, taxWorkTrans.SalesTaxExchangeRateCur);
                taxWorkTrans.ExchangeRateTaxBaseAmountCur = CurrencyExchangeHelper::amount(taxWorkTrans.ExchangeRateTaxBaseAmountCur);
                taxWorkTrans.ExchangeRateTaxAmountCur = CurrencyExchange::calculateAmount(sourceTaxAmountCurLoc, taxWorkTrans.SalesTaxExchangeRateCur);
                taxWorkTrans.ExchangeRateTaxAmountCur = CurrencyExchangeHelper::amount(taxWorkTrans.ExchangeRateTaxAmountCur);
            }

            TaxTable taxTable = TaxTable::find(taxWorkTrans.TaxCode);
            roundOff = taxTable.TaxRoundOff;

            if (roundOff)
            {
                taxWorkTrans.ExchangeRateTaxAmount = taxTable.roundedOffTax(taxWorkTrans.ExchangeRateTaxAmount);
                taxWorkTrans.ExchangeRateTaxAmountRep = taxTable.roundedOffTax(taxWorkTrans.ExchangeRateTaxAmountRep);
                taxWorkTrans.ExchangeRateTaxAmountCur = taxTable.roundedOffTax(taxWorkTrans.ExchangeRateTaxAmountCur);
            }

            taxWorkTrans.update(this.ignoreCalculatedSalesTax());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSalesTaxAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a Boolean value that indicates whether the current transaction being calculated supports
    /// sales tax adjustments.
    /// </summary>
    /// <returns>
    /// true if the current transaction supports sales tax adjustment; otherwise, false.
    /// </returns>
    /// <remarks>
    /// By default, the current transaction does not supports sales tax adjustments.
    /// </remarks>
    public boolean useSalesTaxAdjustments()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSubLedgerJournalLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the current transaction to calculate supports the <c>SubLedgerDistributions</c>
    ///    or <c>SubLedgerJournalLines</c> records. By default, this base implementation is that they do not
    ///    support them. As the individual transaction support the sub-ledger, they must inherit from the
    ///    <c>TaxCalculation</c> class, override this method, and return true.
    /// </summary>
    /// <returns>
    ///    true if the current transaction supports <c>SubLedgerDistributions</c> or
    ///    <c>SubLedgerJournalLines</c> records; otherwise, false.
    /// </returns>
    public boolean useSubLedgerJournalLines()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useTaxTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total of use taxes for the current instance of the Tax class.
    /// </summary>
    /// <returns>
    /// The sum of use taxes.
    /// </returns>
    /// <remarks>
    /// The <c>SourceRegulateAmountCur</c> field in the <c>TmpTaxWorkTrans</c> table contains either the
    /// calculated amount or the adjusted amount.
    /// </remarks>
    public AmountCur useTaxTotal()
    {
        select sum(SourceRegulateAmountCur) from taxWorkTrans
            where (taxWorkTrans.TaxDirection == TaxDirection::UseTax &&
                   taxWorkTrans.TaxOrigin    != TaxOrigin::TaxReversed);

        return taxWorkTrans.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether use tax uncommitted.
    /// </summary>
    /// <returns>true if use tax uncommitted; otherwise false.</returns>
    public boolean useTaxUncommitted()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to validate.
    /// </summary>
    /// <exception cref="Exception::Error">
    /// To throw the error.
    /// </exception>
    public void validate_IN()
    {
        TaxTable                taxTableLoc;
        TaxUncommitted          taxUncommitted;
        RefRecId                sourceRecId;
        LedgerDimensionAccount  ledgerDimension;
        InventTransId           inventTransId;
        TaxDirection            taxDirection;
        TaxCode                 taxCode;
        TransDate               calculationDate;
        TaxItemGroup            taxItemGroup;
        RefTableId              sourceTableId;
        TaxModuleType           source;
        TaxType_IN              taxType;
        LedgerDimensionAccount  ledgerDimensionIN;
        RefRecId                taxRegistrationNumberTable;
        Percent                 claimPercentage;
        TaxUncommitted_IN       taxUncommittedIN;

        Set sourceLines_type = new Set(Types::Container);

        #LocalMacro.fieldList
            RecId,
            SourceRecId,
            LedgerDimension,
            InventTransId,
            TaxDirection,
            TaxCode,
            CalculationDate,
            TaxItemGroup,
            SourceTableId,
            Source,
            LedgerDimension_IN,
            TaxAmountCur
        #EndMacro

        void validate()
        {
            boolean validationResult = true;

            [sourceTableId, sourceRecId] = this.convertSourceTable_IN(sourceTableId, sourceRecId);

            if (!sourceLines_type.in([sourceRecId,taxType]))
            {
                validationResult = this.validatePerSourceLineTaxType_IN(sourceTableId,
                                                                        sourceRecId,
                                                                        taxType,
                                                                        inventTransId);
                if (validationResult)
                {
                    validationResult = this.validatePerTaxLine_IN(taxRegistrationNumberTable,
                                                            taxType,
                                                            ledgerDimension,
                                                            source,
                                                            ledgerDimensionIN,
                                                            sourceTableId,
                                                            sourceRecId,
                                                            taxCode,
                                                            taxItemGroup,
                                                            claimPercentage);
                }

                sourceLines_type.add([sourceRecId,taxType]);
            }
            else
            {
                validationResult = this.validatePerTaxLine_IN(taxRegistrationNumberTable,
                                                            taxType,
                                                            ledgerDimension,
                                                            source,
                                                            ledgerDimensionIN,
                                                            sourceTableId,
                                                            sourceRecId,
                                                            taxCode,
                                                            taxItemGroup,
                                                            claimPercentage);
            }

            if (!validationResult)
            {
                throw error("@SYS21533");
            }
        }

        select count(RecId) from taxWorkTrans;

        if (taxWorkTrans.RecId > 0)
        {
            // Validation for posting directly out of TmpTaxWorkTrans(Tax/saveAndPost()).
            while select #fieldList, TaxRegistrationNumberTable_IN
                from taxWorkTrans
                where taxWorkTrans.HeadingRecId == this.headingRecId() &&
                      taxWorkTrans.HeadingTableId == this.headingTableId() &&
                      (taxWorkTrans.TaxOrigin     != TaxOrigin::TaxReversed ||
                      this.allowPostingOfReversals()) &&
                      taxWorkTrans.IsDeleted      == NoYes::No &&
                      taxWorkTrans.TaxAmountCur
                    join RecId, TaxType_IN from taxTableLoc
                        where taxTableLoc.TaxCode     == taxWorkTrans.TaxCode
                           && taxTableLoc.TaxType_IN  != TaxType_IN::None

            {
                sourceRecId     = taxWorkTrans.SourceRecId;
                ledgerDimension = taxWorkTrans.LedgerDimension;
                inventTransId   = taxWorkTrans.InventTransId;
                taxDirection    = taxWorkTrans.TaxDirection;
                taxCode         = taxWorkTrans.TaxCode;
                calculationDate = taxWorkTrans.CalculationDate;
                taxItemGroup    = taxWorkTrans.TaxItemGroup;
                sourceTableId   = taxWorkTrans.SourceTableId;
                source          = taxWorkTrans.Source;
                claimPercentage = taxWorkTrans.ClaimPercentage_IN;
                taxType         = taxTableLoc.TaxType_IN;
                ledgerDimensionIN = taxWorkTrans.LedgerDimension_IN;
                taxRegistrationNumberTable = taxWorkTrans.TaxRegistrationNumberTable_IN;
                validate();
            }
        }
        else
        {
            // Validation for posting out of TaxUncommitted.
            while select #fieldList from taxUncommitted
                where taxUncommitted.HeadingRecId   == this.headingRecId()
                   && taxUncommitted.HeadingTableId == this.headingTableId()
                   && taxUncommitted.ExemptTax      == NoYes::No
                   && taxUncommitted.TaxAmountCur
                join RecId, TaxType_IN from taxTableLoc
                    where taxTableLoc.TaxCode       == taxUncommitted.TaxCode
                       && taxTableLoc.TaxType_IN    != TaxType_IN::None
            {
                sourceRecId     = taxUncommitted.SourceRecId;
                ledgerDimension = taxUncommitted.LedgerDimension;
                inventTransId   = taxUncommitted.InventTransId;
                taxDirection    = taxUncommitted.TaxDirection;
                taxCode         = taxUncommitted.TaxCode;
                calculationDate = taxUncommitted.CalculationDate;
                taxItemGroup    = taxUncommitted.TaxItemGroup;
                sourceTableId   = taxUncommitted.SourceTableId;
                source          = taxUncommitted.Source;
                ledgerDimensionIN = taxUncommitted.LedgerDimension_IN;
                taxType         = taxTableLoc.TaxType_IN;
                taxUncommittedIN = TaxUncommitted_IN::findByTaxUncommitted(taxUncommitted.RecId);
                claimPercentage = taxUncommittedIN.ClaimPercentage;
                taxRegistrationNumberTable = taxUncommittedIN.TaxRegistrationNumberTable_IN;
                salesPurchJournalLineLoc = this.getSalePurchJourLineFrmTaxUnCommitted_IN(taxUncommitted);
                validate();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAccruePayableAtInvoicing_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the setting of checkbox'Accrue payable at invoicing'.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The source table Id.
    /// </param>
    /// <param name="_sourceRecId">
    /// The source rec Id.
    /// </param>
    /// <returns>
    /// True or false.
    /// </returns>
    public boolean validateAccruePayableAtInvoicing_IN(
        TableId  _sourceTableId,
        RefRecId _sourceRecId)
    {
        boolean ok = true;
        TaxItemGroupHeading     taxItemGroupHeadingLocRev;
        TaxItemGroupHeading     taxItemGroupHeadingInvalid;
        LedgerJournalTrans      ledgerJournalTransLocRev;
        LedgerJournalTrans      ledgerJournalTransInvalid;
        LedgerJournalTable      ledgerJournalTableLocRev;
        VendInvoiceInfoLine     vendInvoiceInfoLineLocRev;
        VendInvoiceInfoLine     vendInvoiceInfoLineInvalid;
        VendInvoiceInfoTable    vendInvoiceInfoTableLocRev;
        VendInvoiceTrans        vendInvoiceTransLocRev;
        VendInvoiceTrans        vendInvoiceTransInvalid;
        PurchLine               purchLineLocRev;
        PurchLine               purchLineInvalid;

        switch (_sourceTableId)
        {
            case tableNum(LedgerJournalTrans) :
                ledgerJournalTransLocRev = LedgerJournalTrans::findRecId(_sourceRecId, false);
                ledgerJournalTableLocRev = ledgerJournalTransLocRev.ledgerJournalTable();

                if (ledgerJournalTransLocRev.TaxGroup && ledgerJournalTransLocRev.TaxItemGroup)
                {
                    taxItemGroupHeadingLocRev = TaxItemGroupHeading::find(ledgerJournalTransLocRev.TaxItemGroup);
                    select firstOnly Recid from ledgerJournalTransInvalid
                        where ledgerJournalTransInvalid.Voucher         == ledgerJournalTransLocRev.Voucher
                            && ledgerJournalTransInvalid.JournalNum     == ledgerJournalTransLoc.JournalNum
                            && ledgerJournalTransInvalid.TaxItemGroup   != ''
                            && ledgerJournalTransInvalid.RecId          != ledgerJournalTransLocRev.RecId
                        exists join taxItemGroupHeadingInvalid
                            where taxItemGroupHeadingInvalid.TaxItemGroup                 == ledgerJournalTransInvalid.TaxItemGroup
                                && taxItemGroupHeadingInvalid.ServiceTaxBasis_IN          == ServiceTaxBasis_IN::POTBasis
                                && taxItemGroupHeadingInvalid.AccruePayableAtInvoicing_IN != taxItemGroupHeadingLocRev.AccruePayableAtInvoicing_IN;

                    if (ledgerJournalTransInvalid.RecId)
                    {
                        ok = checkFailed("@SYP4860527");
                    }
                }

                break;
            case tableNum(VendInvoiceInfoLine) :
                vendInvoiceInfoLineLocRev  = VendInvoiceInfoLine::findRecId(_sourceRecId);
                vendInvoiceInfoTableLocRev = vendInvoiceInfoLineLocRev.vendInvoiceInfoTable();

                if (vendInvoiceInfoLineLocRev.TaxGroup && vendInvoiceInfoLineLocRev.TaxItemGroup)
                {
                    taxItemGroupHeadingLocRev  = TaxItemGroupHeading::find(vendInvoiceInfoLineLocRev.TaxItemGroup);
                    select firstOnly RecId from vendInvoiceInfoLineInvalid
                        where vendInvoiceInfoLineInvalid.TableRefId     == vendInvoiceInfoTableLocRev.TableRefId
                            && vendInvoiceInfoLineInvalid.ParmId        == vendInvoiceInfoTableLocRev.ParmId
                            && vendInvoiceInfoLineInvalid.RecId         != vendInvoiceInfoLineLocRev.RecId
                            && vendInvoiceInfoLineInvalid.TaxItemGroup  != ''
                        exists join taxItemGroupHeadingInvalid
                            where taxItemGroupHeadingInvalid.TaxItemGroup                   == vendInvoiceInfoLineInvalid.TaxItemGroup
                                && taxItemGroupHeadingInvalid.ServiceTaxBasis_IN            == ServiceTaxBasis_IN::POTBasis
                                && taxItemGroupHeadingInvalid.AccruePayableAtInvoicing_IN   != taxItemGroupHeadingLocRev.AccruePayableAtInvoicing_IN;
                }

                if (vendInvoiceInfoLineInvalid.RecId)
                {
                    ok = checkFailed("@SYP4860527");
                }

                break;
            case tableNum(VendInvoiceTrans) :
                vendInvoiceTransLocRev = VendInvoiceTrans::findRecId(_sourceRecId);
                if (vendInvoiceTransLocRev.TaxGroup && vendInvoiceTransLocRev.TaxItemGroup)
                {
                    taxItemGroupHeadingLocRev = TaxItemGroupHeading::find(vendInvoiceTransLocRev.TaxItemGroup);

                    select firstOnly RecId from vendInvoiceTransInvalid
                        where vendInvoiceTransInvalid.PurchID              == vendInvoiceTransLocRev.PurchID
                            && vendInvoiceTransInvalid.InvoiceDate         == vendInvoiceTransLocRev.InvoiceDate
                            && vendInvoiceTransInvalid.InvoiceId           == vendInvoiceTransLocRev.InvoiceId
                            && vendInvoiceTransInvalid.numberSequenceGroup == vendInvoiceTransLocRev.numberSequenceGroup
                            && vendInvoiceTransInvalid.InternalInvoiceId   == vendInvoiceTransLocRev.InternalInvoiceId
                            && vendInvoiceTransInvalid.TaxGroup            != ''
                            && vendInvoiceTransInvalid.TaxItemGroup        != ''
                            && vendInvoiceTransInvalid.RecId               != vendInvoiceTransLocRev.RecId
                        exists join taxItemGroupHeadingInvalid
                            where taxItemGroupHeadingInvalid.TaxItemGroup                   == vendInvoiceTransInvalid.TaxItemGroup
                                && taxItemGroupHeadingInvalid.ServiceTaxBasis_IN            == ServiceTaxBasis_IN::POTBasis
                                && taxItemGroupHeadingInvalid.AccruePayableAtInvoicing_IN   != taxItemGroupHeadingLocRev.AccruePayableAtInvoicing_IN;
                }

                if (vendInvoiceTransInvalid.RecId)
                {
                    ok = checkFailed("@SYP4860527");
                }

                break;
            case tableNum(PurchLine):
                purchLineLocRev = PurchLine::findRecId(_sourceRecId);

                if (purchLineLocRev.TaxGroup && purchLineLocRev.TaxItemGroup)
                {
                    taxItemGroupHeadingLocRev =  TaxItemGroupHeading::find(purchLineLocRev.TaxItemGroup);

                    select firstOnly purchLineInvalid
                        where purchLineInvalid.PurchId          == purchLineLocRev.PurchId
                            && purchLineInvalid.TaxGroup        != ''
                            && purchLineInvalid.TaxItemGroup    != ''
                            && purchLineInvalid.RecId           != purchLineLocRev.RecId
                        exists join taxItemGroupHeadingInvalid
                            where taxItemGroupHeadingInvalid.TaxItemGroup                   == purchLineInvalid.TaxItemGroup
                                && taxItemGroupHeadingInvalid.ServiceTaxBasis_IN            == ServiceTaxBasis_IN::POTBasis
                                && taxItemGroupHeadingInvalid.AccruePayableAtInvoicing_IN   != taxItemGroupHeadingLocRev.AccruePayableAtInvoicing_IN;
                }

                if (purchLineInvalid.RecId)
                {
                    ok = checkFailed("@SYP4860527");
                }

                break;
            default:
                break;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateApplyExcise_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the apply excise.
    /// </summary>
    /// <param name="_eccNumber">
    /// The ecc number id.
    /// </param>
    /// <param name="_exciseRecordType">
    /// The excise record type.
    /// </param>
    /// <param name="_taxTable">
    /// The tax table.
    /// </param>
    /// <param name="_taxDirection">
    /// The tax direction.
    /// </param>
    /// <returns>
    /// Returns true if the validation succeed.
    /// </returns>
    protected boolean validateApplyExcise_IN(
        RefRecId            _eccNumber,
        ExciseRecordType_IN _exciseRecordType,
        TaxTable            _taxTable,
        TaxDirection        _taxDirection = TaxDirection::IncomingTax)
    {
        CustomsComponentTaxCodes_IN customsComponentTaxCodes;
        TaxTable                    taxTableLocal;
        TaxLedgerAccounts_IN        taxLedgerAccounts;
        TaxBaseType                 prevTaxBaseType;
        boolean                     isNotFirstRec;
        boolean                     ok = true;

        select count(RecId)
            from customsComponentTaxCodes
            where customsComponentTaxCodes.TaxComponentTable == _taxTable.TaxComponentTable_IN;
        if (customsComponentTaxCodes.RecId == 0)
        {
            ok = checkFailed(strFmt("@GLS60814", _taxTable.TaxCode));
        }

        while select TaxBase
            from taxTableLocal
            join RecId
            from customsComponentTaxCodes
                where customsComponentTaxCodes.TaxCode      == taxTableLocal.TaxCode
                    && customsComponentTaxCodes.TaxComponentTable == _taxTable.TaxComponentTable_IN
        {
            if (isNotFirstRec && prevTaxBaseType != taxTableLocal.TaxBase)
            {
                ok = checkFailed("@GLS60795");
            }
            prevTaxBaseType   = taxTableLocal.TaxBase;
            isNotFirstRec = true;
        }

        if (!_eccNumber)
        {
            ok = checkFailed(strFmt("@SYS26332", "@GLS5102"));
        }

        if (_eccNumber)
        {
            while select TaxLedgerAccountGroup_IN, TaxComponentTable_IN
                from taxTableLocal
                join RecId
                from customsComponentTaxCodes
                    where customsComponentTaxCodes.TaxCode      == taxTableLocal.TaxCode
                        && customsComponentTaxCodes.TaxComponentTable == _taxTable.TaxComponentTable_IN
            {
                if (!taxLedgerAccounts.exciseTaxAccountNum(taxTableLocal,
                                                            _eccNumber,
                                                            _exciseRecordType,
                                                            _taxDirection).LedgerDimension)
                {
                    ok = checkFailed(strFmt("@GLS5633",TaxRegistrationNumbers_IN::find(_eccNumber).RegistrationNumber));
                    break;
                }
            }
        }

        if (_exciseRecordType == ExciseRecordType_IN::None)
        {
            ok = checkFailed("@GLS60815");
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateConsignmentNoteNum_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the consignment note number.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The source table id.
    /// </param>
    /// <param name="_sourceRecId">
    /// The source rec id.
    /// </param>
    /// <returns>
    /// Returns true if the validation succeed.
    /// </returns>
    protected boolean validateConsignmentNoteNum_IN(
        TableId         _sourceTableId,
        RefRecId        _sourceRecId)
    {
        LedgerJournalTrans      ledgerJournalTransLocal;
        boolean                 ok = true;
        TransTaxInformation     transTaxInformation;

        if (_sourceTableId == tableNum(LedgerJournalTrans))
        {
            ledgerJournalTransLocal = LedgerJournalTrans::findRecId(_sourceRecId, false);

            transTaxInformation = transTaxInformationHelper.getTransTaxInformationByRecord(ledgerJournalTransLocal);

            if (ledgerJournalTransLocal.AccountType == LedgerJournalACType::Vend)
            {
                if (ledgerJournalTransLocal.AmountCurCredit && !transTaxInformation.ServiceTaxConsignmentNoteNum)
                {
                    if (TaxItemGroupHeading::find(ledgerJournalTransLocal.TaxItemGroup).ServiceTaxBasis_IN == ServiceTaxBasis_IN::CashBasis)
                    {
                        if (ledgerJournalTransLocal.findVendTable().isGTA())
                        {
                            ok = checkFailed(strFmt("@SYS26332" , "@GLS5616"));
                        }
                    }
                }
            }
            else if (ledgerJournalTransLocal.OffsetAccountType == LedgerJournalACType::Vend)
            {
                if (ledgerJournalTransLocal.AmountCurDebit && !transTaxInformation.ServiceTaxConsignmentNoteNum)
                {
                    if (TaxItemGroupHeading::find(ledgerJournalTransLocal.TaxItemGroup).ServiceTaxBasis_IN == ServiceTaxBasis_IN::CashBasis)
                    {
                        if (ledgerJournalTransLocal.findVendForOffset().isGTA())
                        {
                            ok = checkFailed(strFmt("@SYS26332" , "@GLS5616"));
                        }
                    }
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCzechTaxPeriodClosed</Name>
				<Source><![CDATA[
    private void validateCzechTaxPeriodClosed(TaxPeriod _taxPeriod, TaxCode _taxCode, VatDueDate_W _vatDueDate_W)
    {
        TaxPeriod   taxPeriod;

        taxPeriod = _taxPeriod ? _taxPeriod : TaxTable::taxPeriod(_taxCode);

        //cannot find a period if the date is null
        if (_vatDueDate_W == dateNull())
        {
            return;
        }

        #ISOCountryRegionCodes
        TaxReportPeriod taxReportPeriod = TaxReportPeriod::find(taxPeriod, _vatDueDate_W);
        if (   (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]) && taxReportPeriod.Closed_CZ)
            || (MultipleTaxIdReportingHelper::isLegalEntityOrTaxPeriodInCountryRegion(
                taxPeriod, [#isoIT], MultipleTaxIdScope::VATDeclaration) && taxReportPeriod.Closed))
        {
            throw error(strFmt("@GLS111767", _vatDueDate_W, taxPeriod));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCzechTaxPeriodsClosed</Name>
				<Source><![CDATA[
    private void validateCzechTaxPeriodsClosed(TmpTaxWorkTrans _taxWorkTrans, RefTableId _headingTableId, RefRecId _headingRecId)
    {
        TaxUncommitted taxUncommitted;

        while select VatDueDate_W, TaxCode from _taxWorkTrans
            where (_taxWorkTrans.HeadingTableId == _headingTableId
                || (_headingTableId == tableNum(CustInvoiceJour)
                    && _taxWorkTrans.HeadingTableId == tableNum(SalesTable)))
                && _taxWorkTrans.HeadingRecId == _headingRecId
        {
            this.validateCzechTaxPeriodClosed('', _taxWorkTrans.TaxCode, _taxWorkTrans.VatDueDate_W);
        }
        
        while select VatDueDate_W, TaxCode from taxUncommitted
            where taxUncommitted.HeadingTableId == _headingTableId
                && taxUncommitted.HeadingRecId == _headingRecId
        {
            this.validateCzechTaxPeriodClosed('', taxUncommitted.TaxCode, taxUncommitted.VatDueDate_W);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateExciseRecordType_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates excise record type.
    /// </summary>
    /// <param name="_sourceRecId">
    /// SourceTable RecId from TmpTaxWorkTrans/TaxUncommitted.
    /// </param>
    /// <param name="_inventTransId">
    /// InventTransId from TmpTaxWorkTrans/TaxUncommitted.
    /// </param>
    /// <param name="_sourceTableId">
    /// SourceTableId from TmpTaxWorkTrans/TaxUncommitted.
    /// </param>
    /// <returns>
    /// Returns false if excise record type enter wrong.
    /// </returns>
    public boolean validateExciseRecordType_IN(
        RefRecId                _sourceRecId,
        InventTransId           _inventTransId,
        RefTableId              _sourceTableId)
    {
        boolean                 ok = true;

        PurchLine               purchLine;
        SalesLine               salesLine;
        InventTransferLine      inventTransLine;
        InventTransferTable     inventTransTable;

        ExciseRecordType_IN     exciseRecordType;
        boolean                 isDSA;
        VendInvoiceTrans        vendInvoiceTransLoc;
        TransTaxInformation     transTaxInformation;
        TransTaxInformation     toTransTaxInformation;

        transTaxInformation = transTaxInformationHelper.getTransTaxInformation(_sourceTableId, _sourceRecId);

        if (salesPurchJournalLineLoc.SourceTableId == tableNum(InventTransferLine))
        {
            inventTransLine     = InventTransferLine::findRecId(_sourceRecId);
            inventTransTable    = InventTransferTable::find(inventTransLine.TransferId, false);

            toTransTaxInformation = transTaxInformationHelper.getTransTaxInformation(_sourceTableId, _sourceRecId, TransTaxInformationType_IN::InventTransferTo);

            if (transTaxInformation.ExciseRecordType == ExciseRecordType_IN::None
                && transTaxInformation.ExciseDSA == NoYes::No
                && inventTransferUpdateType == InventTransferUpdateType::Shipment)
            {
                ok = checkFailed(strFmt("@GLS6036", "@SYS25253"));
            }
            else if (toTransTaxInformation.ExciseRecordType  == ExciseRecordType_IN::None
                    && toTransTaxInformation.ExciseDSA == NoYes::No
                    && inventTransferUpdateType == InventTransferUpdateType::Receive)
            {
                ok = checkFailed(strFmt("@GLS6036", "@SYS8519"));
            }
        }
        else if (_inventTransId)
        {
            if (_sourceTableId == tableNum(PurchLine)
                || _sourceTableId == tableNum(VendInvoiceInfoLine))
            {
                purchLine = PurchLine::findInventTransId(_inventTransId);
                isDSA = transTaxInformation.ExciseDSA;
                exciseRecordType = transTaxInformation.ExciseRecordType;
            }
            else if (_sourceTableId == tableNum(SalesLine)
                || _sourceTableId == tableNum(CustInvoiceTrans))
            {
                salesLine = SalesLine::findInventTransId(_inventTransId);
                isDSA = transTaxInformation.ExciseDSA;
                exciseRecordType = transTaxInformation.ExciseRecordType;
            }
            else if (_sourceTableId == tableNum(VendInvoiceTrans))
            {
                vendInvoiceTransLoc = VendInvoiceTrans::findRecId(_sourceRecId);
                isDSA = transTaxInformation.ExciseDSA;
                exciseRecordType = transTaxInformation.ExciseRecordType;
            }
        }

        if (purchLine)
        {
            if (exciseRecordType == ExciseRecordType_IN::None && isDSA == NoYes::No)
            {
                ok = checkFailed(strFmt("@GLS5637", TaxType_IN::Excise, exciseRecordType, TaxType_IN::Excise));
            }
        }

        // if TaxWithholdLineNum_IN is 1, it is allowed.
        if (vendInvoiceTransLoc && vendInvoiceTransLoc.TaxWithholdLineNum_IN == 0)
        {
            if (exciseRecordType == ExciseRecordType_IN::None && isDSA == NoYes::No)
            {
                ok = checkFailed(strFmt("@GLS5637", TaxType_IN::Excise, exciseRecordType, TaxType_IN::Excise));
            }
        }

        if (salesLine)
        {
            if (isDSA == NoYes::No && exciseRecordType == ExciseRecordType_IN::None)
            {
                // if salesLine is from return order, it is allowed to have both DSA false and excise record type none.
                if (salesLine.SalesType != SalesType::ReturnItem)
                {
                    ok = checkFailed(strFmt("@GLS5637", TaxType_IN::Excise, exciseRecordType, TaxType_IN::Excise));
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateForExcise_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Validates whether ECC number is defined or not.
    /// If so, check whether ledger accounts are defined
    /// </summary>
    /// <param name="_eccNumber">
    ///   ECC number defined at line level
    /// </param>
    /// <param name="_exciseRecordType">
    ///    Excise record type defined at line level
    /// </param>
    /// <param name="_taxCode">
    ///   Tax code for line
    /// </param>
    /// <param name="_taxDirection">
    ///   Indictates whether it is incoming or outgoing tax
    /// </param>
    public void validateForExcise_IN(
        RefRecId            _eccNumber,
        ExciseRecordType_IN _exciseRecordType,
        TaxCode             _taxCode = '',
        TaxDirection        _taxDirection = TaxDirection::IncomingTax
        )
    {
        TaxTable                    taxTableLoc;
        TaxLedgerAccounts_IN        taxLedgerAccounts;
        boolean                     ok = true;

        taxTableLoc = TaxTable::find(_taxCode);

        if (!_eccNumber)
        {
            ok = checkFailed(strFmt("@SYS26332", "@GLS5102"));
        }

        if (_eccNumber && (!taxLedgerAccounts.exciseTaxAccountNum(taxTableLoc,
                                                    _eccNumber,
                                                    _exciseRecordType,
                                                    _taxDirection).LedgerDimension))
        {
            ok = checkFailed(strFmt("@GLS5633",TaxRegistrationNumbers_IN::find(_eccNumber).RegistrationNumber));
        }

        if (_exciseRecordType == ExciseRecordType_IN::None)
        {
            ok = checkFailed("@GLS60815");
        }

        if (!ok)
        {
            throw error("@SYS21533");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateForOpenTaxReportPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates whether the tax line date of VAT register is within a tax report period that is not yet reported.
    /// </summary>
    /// <param name="_taxWorkTrans">
    ///    The buffer that holds tax lines.
    /// </param>
    /// <param name="_headingTableId">
    ///    The table ID of the transaction header. Default value comes from the <c>Tax</c> object; optional.
    /// </param>
    /// <param name="_headingRecId">
    ///    The record ID of the transaction header. Default value comes from the <c>Tax</c> object; optional.
    /// </param>
    /// <exception cref="Exception::Error">
    ///    Tax transaction with date of VAT register cannot be posted, as the tax period is already closed.
    /// </exception>
    private void validateForOpenTaxReportPeriod(TmpTaxWorkTrans _taxWorkTrans, RefTableId _headingTableId, RefRecId _headingRecId)
    {
        TaxTable        taxTable;
        TaxReportPeriod taxReportPeriod;
        TaxUncommitted  taxUncommitted;

        select RecId, VatDueDate_W from _taxWorkTrans
            join TaxPeriod from taxTable
                where taxTable.TaxCode == _taxWorkTrans.TaxCode
            exists join taxReportPeriod
                where taxReportPeriod.TaxPeriod == taxTable.TaxPeriod &&
                    taxReportPeriod.Reported_HU &&
                    taxReportPeriod.FromDate <= _taxWorkTrans.VatDueDate_W &&
                    taxReportPeriod.ToDate >= _taxWorkTrans.VatDueDate_W;

        if (_taxWorkTrans)
        {
            throw error(strFmt("@GLS111767", _taxWorkTrans.VatDueDate_W, taxTable.TaxPeriod));
        }
        else
        {
            select RecId, VatDueDate_W from taxUncommitted
                    where taxUncommitted.HeadingTableId == _headingTableId &&
                        taxUncommitted.HeadingRecId == _headingRecId
                join TaxPeriod from taxTable
                    where taxTable.TaxCode == taxUncommitted.TaxCode
                exists join taxReportPeriod
                    where taxReportPeriod.TaxPeriod == taxTable.TaxPeriod &&
                        taxReportPeriod.Reported_HU &&
                        taxReportPeriod.FromDate <= taxUncommitted.VatDueDate_W &&
                        taxReportPeriod.ToDate >= taxUncommitted.VatDueDate_W;

            if (taxUncommitted)
            {
                throw error(strFmt("@GLS111767", taxUncommitted.VatDueDate_W, taxTable.TaxPeriod));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateForPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the posting validation.
    /// </summary>
    /// <exception cref="Exception::Error">
    ///   The Legal entity for intercompany tax posting field cannot be set to source if the Apply U.S. taxation rules check box is checked in General ledger parameters form.
    /// </exception>
    public void validateForPost()
    {
        if (this.getTaxObligationCompany() == TaxObligationCompany::Source
            && this.taxParameters().PurchTaxOnOperations)
        {
            throw error("@SYS4003093");
        }

        if (this.useTaxUncommitted())
        {
            if (!TaxUncommitted::checkTaxLinesByOperationAccount(this))
            {
                throw error("@SYS18447");
            }
        }
        else
        {
            if (!this.checkTaxCodesByOperationAccount())
            {
                throw error("@SYS18447");
            }
        }

        if (TaxCalculationAdjustment::checkForNonDerivedTaxLine(taxWorkTrans, this.headingTableId(), this.headingRecId()))
        {
            //Posting failed because there is a sales tax amount for a tax code that is not derived from the tax groups on the invoice.
            throw error("@SYS300104");
        }

        if (this.ignoreCalculatedSalesTax())
        {
            if (TaxCalculationAdjustment::checkForTaxLineWithoutAdjustment(taxWorkTrans, this.headingTableId(), this.headingRecId()))
            {
                //Posting failed because there is no sales tax amount on the electronic invoice, and the sales tax code is derived from the tax groups on the invoice.
                throw error("@SYS300105");
            }
        }

        // <GEEHU>
        if (isConfigurationkeyEnabled(configurationKeyNum(LedgerBasicVatDueDate_W)) && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU]))
        {
            this.validateForOpenTaxReportPeriod(taxWorkTrans, this.headingTableId(), this.headingRecId());
        }
        // </GEEHU>

        // <GIN>
        if (isTaxParametersEnabled

            && !(this is TaxProjInvoice))
        {
            this.validate_IN();
        }
        // </GIN>

        if (isConfigurationkeyEnabled(configurationKeyNum(LedgerBasicVatDueDate_W))
            && (   SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ])
                || MultipleTaxIdReportingHelper::isLegalEntityOrAddressInCountryRegion(
                    [#isoIT], MultipleTaxIdScope::VATDeclaration)))
        {
            this.validateCzechTaxPeriodsClosed(taxWorkTrans, this.headingTableId(), this.headingRecId());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLedgerDimensionForPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the ledger dimension specified is valid.
    /// </summary>
    /// <param name="_ledgerDimension">
    /// The ledger dimension to validate.
    /// </param>
    /// <param name="_taxDirection">
    /// The tax direction.
    /// </param>
    /// <param name="_taxCode">
    /// The tax code.
    /// </param>
    /// <param name="_validatingUseTaxPayable">
    /// true if the use tax payable account is to be validated; otherwise, false; optional.
    /// </param>
    private void validateLedgerDimensionForPosting(LedgerDimensionAccount _ledgerDimension, TaxDirection _taxDirection, TaxCode _taxCode, boolean _validatingUseTaxPayable = false)
    {
        TaxTable taxTable;
        TaxLedgerAccountGroup taxLedgerAccountGroup;

        if (!_ledgerDimension)
        {
            taxTable = TaxTable::find(_taxCode);
            // <GIN>
            if (taxTable.TaxType_IN != TaxType_IN::None)
            {
                // Skip the standard posting profile validation for India. India posting profile validation is handled differently.
                return;
            }
            // </GIN>
            taxLedgerAccountGroup = TaxLedgerAccountGroup::find(taxTable.TaxAccountGroup);
            if (taxLedgerAccountGroup)
            {
                taxLedgerAccountGroup.validateAccountForTaxDirection(_taxDirection, _validatingUseTaxPayable);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePerSourceLineTaxType_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates per source line tax type.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The source table id.
    /// </param>
    /// <param name="_sourceRecId">
    /// The source rec id.
    /// </param>
    /// <param name="_taxtype">
    /// The tax type.
    /// </param>
    /// <param name="_inventTransId">
    /// The invent trans id.
    /// </param>
    /// <returns>
    /// Returns true if the validation succeed.
    /// </returns>
    protected boolean validatePerSourceLineTaxType_IN(
        TableId         _sourceTableId,
        RefRecId        _sourceRecId,
        TaxType_IN      _taxtype,
        InventTransId   _inventTransId)
    {
        boolean ok = true;

        if (_taxtype == TaxType_IN::Excise)
        {
            ok = this.validateExciseRecordType_IN(_sourceRecId, _inventTransId, _sourceTableId);
        }

        if (ok
            && (_taxtype == TaxType_IN::ServiceTax))
        {
            ok = this.validateConsignmentNoteNum_IN(_sourceTableId, _sourceRecId);
            ok = ok && this.validatePOTInquiry_IN(_sourceTableId, _sourceRecId);
            ok = ok && this.validateReverseChargePOT_IN(_sourceTableId, _sourceRecId);
            ok = ok && this.validateReverseCharge_AR_IN(_sourceTableId, _sourceRecId);
            ok = ok && this.validateAccruePayableAtInvoicing_IN(_sourceTableId, _sourceRecId);
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePerTaxLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates per tax line.
    /// </summary>
    /// <param name="_taxRegistrationNumberTableRefRecId">
    /// The tax registration number table reference rec id.
    /// </param>
    /// <param name="_taxType">
    /// The tax type.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The ledger dimension.
    /// </param>
    /// <param name="_source">
    /// The tax module type.
    /// </param>
    /// <param name="_ledgerDimensionIN">
    /// The ledger dimension account.
    /// </param>
    /// <param name="_sourceTableId">
    /// The source table id.
    /// </param>
    /// <param name="_sourceRecId">
    /// The source rec id.
    /// </param>
    /// <param name="_taxCode">
    /// The tax code.
    /// </param>
    /// <param name="_taxItemGroup">
    /// The tax item group.
    /// </param>
    /// <param name="_claimPercentage">
    /// The claim percentage.
    /// </param>
    /// <returns>
    /// Returns true if the validation succeed.
    /// </returns>
    [Replaceable]
    protected boolean validatePerTaxLine_IN(
        RecId                   _taxRegistrationNumberTableRefRecId,
        TaxType_IN              _taxType,
        LedgerDimensionAccount  _ledgerDimension,
        TaxModuleType           _source,
        LedgerDimensionAccount  _ledgerDimensionIN,
        TableId                 _sourceTableId,
        RecId                   _sourceRecId,
        TaxCode                 _taxCode,
        TaxItemGroup            _taxItemGroup,
        Percent                 _claimPercentage)
    {
        boolean                   ok = true;
        VendTable                 vendTableLocal;
        InventTransId             inventTransId;
        VendInvoiceTrans          vendInvoiceTransLocal;
        TaxTable                  taxTableLocal;
        LedgerJournalTrans        ledgerJournalTransLocal;
        RefRecId                  eccNumber;
        TransTaxInformation       transTaxInformation;

        if (_taxRegistrationNumberTableRefRecId == 0)
        {
            switch (_taxType)
            {
                case TaxType_IN::SalesTax :
                    if (_source == TaxModuleType::StockTransfer_IN)
                    {
                        if (inventTransferUpdateType == InventTransferUpdateType::Shipment)
                        {
                            ok = checkFailed(strFmt("@GLS5901", "@SYS59571", "@SYS25253"));
                        }
                        else if (inventTransferUpdateType == InventTransferUpdateType::Receive)
                        {
                            ok = checkFailed(strFmt("@GLS5901", "@SYS59571", "@SYS8519"));
                        }
                    }
                    else
                    {
                        ok = checkFailed(strFmt("@SYS26332", "@SYS59571"));
                    }
                    break;
                case TaxType_IN::VAT :
                    if (_source == TaxModuleType::StockTransfer_IN)
                    {
                        if (inventTransferUpdateType == InventTransferUpdateType::Shipment)
                        {
                            ok = checkFailed(strFmt("@GLS5901", "@GLS5096", "@SYS25253"));
                        }
                        else if (inventTransferUpdateType == InventTransferUpdateType::Receive)
                        {
                            ok = checkFailed(strFmt("@GLS5901", "@GLS5096", "@SYS8519"));
                        }
                    }
                    else
                    {
                        ok = checkFailed(strFmt("@SYS26332", "@GLS5096"));
                    }
                    break;
                case TaxType_IN::Excise :
                    if (_source == TaxModuleType::StockTransfer_IN)
                    {
                        if (inventTransferUpdateType == InventTransferUpdateType::Shipment)
                        {
                            ok = checkFailed(strFmt("@GLS5901", "@GLS5102", "@SYS25253"));
                        }
                        else if (inventTransferUpdateType == InventTransferUpdateType::Receive)
                        {
                            ok = checkFailed(strFmt("@GLS5901", "@GLS5102", "@SYS8519"));
                        }
                    }
                    else
                    {
                        ok = checkFailed(strFmt("@SYS26332", "@GLS5102"));
                    }
                    break;
                case TaxType_IN::Customs :
                    if (_source == TaxModuleType::StockTransfer_IN)
                    {
                        if (inventTransferUpdateType == InventTransferUpdateType::Shipment)
                        {
                            ok = checkFailed(strFmt("@GLS5901", "@GLS5100", "@SYS25253"));
                        }
                        else if (inventTransferUpdateType == InventTransferUpdateType::Receive)
                        {
                            ok = checkFailed(strFmt("@GLS5901", "@GLS5100", "@SYS8519"));
                        }
                    }
                    else
                    {
                        ok = checkFailed(strFmt("@SYS26332","@GLS5100"));
                    }
                    break;
                case TaxType_IN::ServiceTax :
                    if (_source == TaxModuleType::StockTransfer_IN)
                    {
                        if (inventTransferUpdateType == InventTransferUpdateType::Shipment)
                        {
                            ok = checkFailed(strFmt("@GLS5901", "@GLS5098", "@SYS25253"));
                        }
                        else if (inventTransferUpdateType == InventTransferUpdateType::Receive)
                        {
                            ok = checkFailed(strFmt("@GLS5901", "@GLS5098", "@SYS8519"));
                        }
                    }
                    else
                    {
                        ok = checkFailed(strFmt("@SYS26332","@GLS5098"));
                    }
                    break;
            }
        }

        if (ok)
        {
            if (_ledgerDimension == 0)
            {
                if (_source == TaxModuleType::StockTransfer_IN)
                {
                    if (inventTransferUpdateType == InventTransferUpdateType::Shipment)
                    {
                        switch (_taxType)
                        {
                            case TaxType_IN::SalesTax :
                                ok = checkFailed(strFmt("@GLS6035", "@SYS25253", "@SYS59571"));
                                break;
                            case TaxType_IN::VAT :
                                ok = checkFailed(strFmt("@GLS6035", "@SYS25253", "@GLS5096"));
                                break;
                            case TaxType_IN::Excise :
                                ok = checkFailed(strFmt("@GLS6035", "@SYS25253", "@GLS5102"));
                                break;
                            case TaxType_IN::Customs :
                                ok = checkFailed(strFmt("@GLS6035", "@SYS25253", "@GLS5100"));
                                break;
                            case TaxType_IN::ServiceTax :
                                ok = checkFailed(strFmt("@GLS6035", "@SYS25253", "@GLS5098"));
                                break;
                        }
                    }
                    else if (inventTransferUpdateType == InventTransferUpdateType::Receive)
                    {
                        switch (_taxType)
                        {
                            case TaxType_IN::SalesTax :
                                ok = checkFailed(strFmt("@GLS6035", "@SYS8519", "@SYS59571"));
                                break;
                            case TaxType_IN::VAT :
                                ok = checkFailed(strFmt("@GLS6035", "@SYS8519", "@GLS5096"));
                                break;
                            case TaxType_IN::Excise :
                                ok = checkFailed(strFmt("@GLS6035", "@SYS8519", "@GLS5102"));
                                break;
                            case TaxType_IN::Customs :
                                ok = checkFailed(strFmt("@GLS6035", "@SYS8519", "@GLS5100"));
                                break;
                            case TaxType_IN::ServiceTax :
                                ok = checkFailed(strFmt("@GLS6035", "@SYS8519", "@GLS5098"));
                                break;
                        }
                    }
                }
                else
                {
                    if (_taxType != TaxType_IN::ServiceTax
                        && !(_source == TaxModuleType::Purch
                            || _source == TaxModuleType::PurchInvoice
                            || _source == TaxModuleType::FreeTxtInvoice))
                    {
                        ok = checkFailed(strFmt("@GLS5582", TaxRegistrationNumbers_IN::find(_taxRegistrationNumberTableRefRecId).RegistrationNumber));
                    }
                }
            }
        }

        if (ok)
        {
            switch (_taxType)
            {
                case TaxType_IN::Excise :
                    if (_claimPercentage != 0 && _ledgerDimensionIN == 0)
                    {
                        ok = checkFailed(strFmt("@GLS5633", TaxRegistrationNumbers_IN::find(_taxRegistrationNumberTableRefRecId).RegistrationNumber));
                    }
                    break;
                case TaxType_IN::ServiceTax :
                    if (_sourceTableId == tableNum(VendInvoiceTrans))
                    {
                        vendInvoiceTransLocal = VendInvoiceTrans::findRecId(_sourceRecId);
                        inventTransId = vendInvoiceTransLocal.InventTransId;
                        vendTableLocal = vendInvoiceTransLocal.vendTable_InvoiceAccount();

                        if (vendTableLocal.isForeign()
                            && PurchLine::findInventTransId(inventTransId).purchTable().purchTable_W().CustomsImportOrder_IN)
                        {
                            if (FormulaDesigner_IN::findByTaxCode(_taxItemGroup, _taxCode).PriceInclTax)
                            {
                                ok = checkFailed(strFmt("@GLS62299", "@GLS5277"));
                            }
                        }
                        ok = ok && this.validateAccruePayableAtInvoicing_IN(_sourceTableId, _sourceRecId);
                    }
                    else if ((taxworkTrans.SourceTableId == tablenum(VendInvoiceInfoLine) || taxworkTrans.SourceTableId == tablenum(VendInvoiceTrans)))
                    {
                        ok = this.validateReverseChargePOT_IN(taxworkTrans.SourceTableId, taxworkTrans.SourceRecId);
                        ok = ok && this.validateAccruePayableAtInvoicing_IN(taxWorkTrans.SourceTableId, taxWorkTrans.SourceRecId);
                    }
                    else if (_sourceTableId == tableNum(LedgerJournalTrans))
                    {
                        ledgerJournalTransLocal = LedgerJournalTrans::findRecId(_sourceRecId, false);
                        if (ledgerJournalTransLocal.AccountType == LedgerJournalACType::Vend)
                        {
                            vendTableLocal = ledgerJournalTransLocal.findVendTable();
                        }
                        else if (ledgerJournalTransLocal.OffsetAccountType == LedgerJournalACType::Vend)
                        {
                            vendTableLocal = ledgerJournalTransLocal.findVendForOffset();
                        }
                        if (ledgerJournalTransLocal.RecId)
                        {
                            ok = this.validateReverseChargePOT_IN(taxworkTrans.SourceTableId, taxworkTrans.SourceRecId);
                            ok = ok && this.validateAccruePayableAtInvoicing_IN(taxWorkTrans.SourceTableId, taxWorkTrans.SourceRecId);
                        }
                    }

                    if (
                        vendTableLocal
                        && vendTableLocal.isGTA()
                        )
                    {
                        if (_ledgerDimensionIN == 0)
                        {
                            ok = checkFailed(strFmt("@GLS5614",TaxRegistrationNumbers_IN::find(_taxRegistrationNumberTableRefRecId).RegistrationNumber));
                        }
                        if (ok)
                        {
                            if (FormulaDesigner_IN::findByTaxCode(_taxItemGroup, _taxCode).PriceInclTax)
                            {
                                throw error("@GLS5615");
                            }
                        }
                    }
                    break;
            }
        }

        if (ok)
        {
            if (_taxType == TaxType_IN::Customs)
            {
                if ((_sourceTableId == tableNum(VendInvoiceTrans)
                        || _sourceTableId == tableNum(LedgerJournalTrans))
                    && isExciseEnabled)
                {
                    taxTableLocal = TaxTable::find(_taxCode);
                    if (TaxComponentTable_IN::find(taxTableLocal.TaxComponentTable_IN).ApplyExcise == NoYes::Yes)
                    {
                        transTaxInformation = transTaxInformationHelper.getTransTaxInformation(_sourceTableId, _sourceRecId);

                        if (_sourceTableId == tableNum(VendInvoiceTrans))
                        {
                            if (vendInvoiceTransLocal.RecId == 0)
                            {
                                vendInvoiceTransLocal = VendInvoiceTrans::findRecId(_sourceRecId);
                                eccNumber = transTaxInformation.ExciseECCRegistrationNumber;
                                ok = this.validateApplyExcise_IN(eccNumber,
                                                    transTaxInformation.ExciseRecordType,
                                                    taxTableLocal);
                            }
                        }
                        else if (_sourceTableId == tableNum(LedgerJournalTrans))
                        {
                            if (ledgerJournalTransLocal.RecId == 0)
                            {
                                ledgerJournalTransLocal = LedgerJournalTrans::findRecId(_sourceRecId, false);
                                eccNumber = transTaxInformation.ExciseECCRegistrationNumber;
                                ok = this.validateApplyExcise_IN(eccNumber,
                                                    transTaxInformation.ExciseRecordType,
                                                    taxTableLocal);
                            }
                        }
                    }
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePOTInquiry_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validations for Service tax POT Inquiry.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The Source table id passed.
    /// </param>
    /// <param name="_sourceRecId">
    /// The source recId passed.
    /// </param>
    /// <exception cref="Exception::Error">
    /// You must specify date in the document date field.
    /// You cannot post a transaction with ifferent accounting basis.
    /// </exception>
    /// <returns>
    /// True if the validation passes.
    /// </returns>

    protected boolean validatePOTInquiry_IN(
        TableId  _sourceTableId,
        RefRecId _sourceRecId)
    {
        VendInvoiceTrans        vendInvoiceTrans;
        LedgerJournalTrans      ledgerJournalTrans;
        TaxItemGroupHeading     taxItemGroupHeading;
        VendInvoiceJour         vendInvoiceJour;
        VendInvoiceInfoTable    vendInvoiceInfoTable;
        boolean                 throwDocDateError;
        boolean                 potBasisAvailable;
        boolean                 cashBasisAvailable;
        boolean                 isCreditNote;
        boolean                 ok = true;
        LedgerJournalId         ledgerJournalNum;
        PurchLine               purchLineCash;
        Voucher                 ledgerJournalTransVoucher;
        TransDate               transDate;

        #LocalMacro.FieldList
            RecId,
            InvoiceId,
            InvoiceDate,
            PurchID,
            NumberSequenceGroup,
            InternalInvoiceId,
            TaxItemGroup,
            LineAmount
        #EndMacro

        switch (_sourceTableId)
        {
            case tableNum(VendInvoiceTrans) :
                select firstonly #FieldList from vendInvoiceTrans
                    where vendInvoiceTrans.RecId == _sourceRecId
                        join RecId, InvoiceId, PurchId, InvoiceAccount from vendInvoiceJour
                            where vendInvoiceJour.InvoiceId             == vendInvoiceTrans.InvoiceId
                               && vendInvoiceJour.InvoiceDate           == vendInvoiceTrans.InvoiceDate
                               && vendInvoiceJour.PurchId               == vendInvoiceTrans.PurchID
                               && vendInvoiceJour.NumberSequenceGroup   == vendInvoiceTrans.NumberSequenceGroup
                               && vendInvoiceJour.InternalInvoiceId     == vendInvoiceTrans.InternalInvoiceId
                                    join reverse RecId, DocumentDate from vendInvoiceInfoTable
                                        where vendInvoiceInfoTable.Num              == vendInvoiceJour.InvoiceId
                                            && vendInvoiceInfoTable.PurchId         == vendInvoiceJour.PurchId
                                            && vendInvoiceInfoTable.InvoiceAccount  == vendInvoiceJour.InvoiceAccount
                                    exists join taxItemGroupHeading
                                        where taxItemGroupHeading.TaxItemGroup == vendInvoiceTrans.TaxItemGroup
                                            && taxItemGroupHeading.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis;
                potBasisAvailable = vendInvoiceTrans.RecId != 0;
                isCreditNote = (vendInvoiceTrans.LineAmount < 0);
                if (vendInvoiceInfoTable.RecId != 0
                    && vendInvoiceInfoTable.DocumentDate == dateNull()
                    && isCreditNote == false)// No valiation for CrNote.
                {
                    throwDocDateError = true;
                }
                if (throwDocDateError == false)
                {
                    if (cashBasisAvailable == false)
                    {
                        select firstonly #FieldList from vendInvoiceTrans
                            where vendInvoiceTrans.RecId == _sourceRecId
                               join RecId, TaxItemGroup from purchLineCash
                                  where purchLineCash.PurchId == vendInvoiceTrans.PurchID
                                     exists join taxItemGroupHeading
                                        where taxItemGroupHeading.TaxItemGroup == purchLineCash.TaxItemGroup
                                           && taxItemGroupHeading.ServiceTaxBasis_IN == ServiceTaxBasis_IN::CashBasis;
                        cashBasisAvailable = purchLineCash.RecId != 0;
                    }
                    if (potBasisAvailable == false)
                    {
                        select firstonly #FieldList from vendInvoiceTrans
                            where vendInvoiceTrans.RecId == _sourceRecId
                               join RecId, TaxItemGroup from purchLineCash
                                  where purchLineCash.PurchId == vendInvoiceTrans.PurchID
                                     exists join taxItemGroupHeading
                                        where taxItemGroupHeading.TaxItemGroup == purchLineCash.TaxItemGroup
                                           && taxItemGroupHeading.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis;
                        potBasisAvailable = purchLineCash.RecId != 0;
                    }
                }
                break;
            case tableNum(LedgerJournalTrans) :
                select firstonly RecId, JournalNum, Voucher, TransDate  from ledgerJournalTrans
                    where ledgerJournalTrans.RecId == _sourceRecId;
                ledgerJournalNum          = ledgerJournalTrans.JournalNum;
                ledgerJournalTransVoucher = ledgerJournalTrans.Voucher;
                transDate                 = ledgerJournalTrans.TransDate;
                if (ledgerJournalNum)
                {
                    select firstonly * from ledgerJournalTrans
                        where ledgerJournalTrans.JournalNum == ledgerJournalNum
                            && ledgerJournalTrans.Voucher    == ledgerJournalTransVoucher
                            && ledgerJournalTrans.TransDate  == transDate
                                exists join taxItemGroupHeading
                                    where taxItemGroupHeading.TaxItemGroup == ledgerJournalTrans.TaxItemGroup
                                       && taxItemGroupHeading.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis;
                    potBasisAvailable = ledgerJournalTrans.RecId != 0;
                    if (ledgerJournalTrans.RecId
                        && ledgerJournalTrans.Invoice// Invoice number is mandatory for POT transactions. If its blank then no error required for document date.
                        && !ledgerJournalTrans.DocumentDate)
                    {
                        throwDocDateError = true;
                    }
                    else
                    {
                        select firstonly * from ledgerJournalTrans
                            where ledgerJournalTrans.JournalNum == ledgerJournalNum
                               && ledgerJournalTrans.Voucher    == ledgerJournalTransVoucher
                               && ledgerJournalTrans.TransDate  == transDate
                                exists join taxItemGroupHeading
                                    where taxItemGroupHeading.TaxItemGroup == ledgerJournalTrans.TaxItemGroup
                                        && taxItemGroupHeading.ServiceTaxBasis_IN == ServiceTaxBasis_IN::CashBasis;
                        cashBasisAvailable = ledgerJournalTrans.RecId != 0;
                    }
                }
                break;
            case tableNum(CustInvoiceTrans) ://TmpTaxWorkTrans is available here for SO only
                select firstonly RecId from taxWorkTrans
                    where taxWorkTrans.HeadingRecId == this.headingRecId()
                        && taxWorkTrans.HeadingTableId == this.headingTableId()
                        exists join taxItemGroupHeading
                            where taxItemGroupHeading.TaxItemGroup == taxWorkTrans.TaxItemGroup
                            && taxItemGroupHeading.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis;
                potBasisAvailable = taxWorkTrans.RecId != 0;
                select firstonly RecId from taxWorkTrans
                    where taxWorkTrans.HeadingRecId == this.headingRecId()
                        && taxWorkTrans.HeadingTableId == this.headingTableId()
                        exists join taxItemGroupHeading
                            where taxItemGroupHeading.TaxItemGroup == taxWorkTrans.TaxItemGroup
                            && taxItemGroupHeading.ServiceTaxBasis_IN == ServiceTaxBasis_IN::CashBasis;
                cashBasisAvailable = taxWorkTrans.RecId != 0;
                break;
        }
        // End swith
        if (throwDocDateError     == false
            && cashBasisAvailable == true // This validation is only for POT (not for cash basis)
            && potBasisAvailable  == false)
        {
            ok = true;
        }
        else
        {
            if (throwDocDateError == true)
            {
                switch (_sourceTableId)
                {
                    case tableNum(VendInvoiceTrans) :
                        ok = checkFailed("@SYS4000964");
                        break;
                    case tableNum(LedgerJournalTrans) :
                        ok = checkFailed("@SYS4082389");
                        break;
                }
            }
            else if (cashBasisAvailable == true // You cant Mix both basis in a transaction.
                     && potBasisAvailable == true)
            {
                ok = checkFailed("@SYS4082384");
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateReverseCharge_AR_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validations for Service tax POT Inquiry for customers. Customers should not use this feature.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The Source table id passed.
    /// </param>
    /// <param name="_sourceRecId">
    /// The source recId passed.
    /// </param>
    /// <exception cref="Exception::Error">
    /// You must specify date in the document date field.
    /// You cannot post a transaction with different accounting basis.
    /// </exception>
    /// <returns>
    /// True if the validation passes.
    /// </returns>
    protected boolean validateReverseCharge_AR_IN(
        TableId  _sourceTableId,
        RefRecId _sourceRecId)
    {
        LedgerJournalTrans      ledgerJournalTransRev;
        TaxItemGroupHeading     taxItemGroupHeading;
        CustInvoiceLine         custInvoiceLineRev;
        boolean                 ok = true;

        switch (_sourceTableId)
        {
            case tableNum(LedgerJournalTrans) :
                select firstonly RecId, AccountType, OffsetAccountType
                    from ledgerJournalTransRev
                    where ledgerJournalTransRev.RecId == _sourceRecId
                        exists join taxItemGroupHeading
                            where taxItemGroupHeading.TaxItemGroup == ledgerJournalTransRev.TaxItemGroup
                                && taxItemGroupHeading.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis
                                && taxItemGroupHeading.ReverseChargePercentage_IN != 0;
                if (ledgerJournalTransRev.AccountType == LedgerJournalACType::Cust
                    || ledgerJournalTransRev.OffsetAccountType  == LedgerJournalACType::Cust)
                {
                    ok = false;
                }
                break;
            case tableNum(CustInvoiceTrans) ://TmpTaxWorkTrans is available here for SO only
                select firstonly RecId from taxWorkTrans
                    where taxWorkTrans.HeadingRecId == this.headingRecId()
                        && taxWorkTrans.HeadingTableId == this.headingTableId()
                        exists join taxItemGroupHeading
                            where taxItemGroupHeading.TaxItemGroup == taxWorkTrans.TaxItemGroup
                            && taxItemGroupHeading.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis
                            && taxItemGroupHeading.ReverseChargePercentage_IN != 0;
                if (taxWorkTrans.RecId)
                {
                    ok = false;
                }
                break;
            case tableNum(CustInvoiceLine) :
                select firstonly RecId from custInvoiceLineRev
                    where custInvoiceLineRev.RecId == _sourceRecId
                        exists join taxItemGroupHeading
                            where taxItemGroupHeading.TaxItemGroup == custInvoiceLineRev.TaxItemGroup
                                && taxItemGroupHeading.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis
                                && taxItemGroupHeading.ReverseChargePercentage_IN != 0;
                if (custInvoiceLineRev.RecId)
                {
                    ok = false;
                }
                break;
        }
        // End swith
        if (!ok)
        {
            ok = checkFailed("@SYS4002037");
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateReverseChargePOT_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validations for Service tax POT Inquiry.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The Source table id passed.
    /// </param>
    /// <param name="_sourceRecId">
    /// The source recId passed.
    /// </param>
    /// <returns>
    /// True if the validation passes.
    /// </returns>
    protected boolean validateReverseChargePOT_IN(
        TableId  _sourceTableId,
        RefRecId _sourceRecId)
    {
        LedgerJournalTrans      ledgerJournalTransInvalid;
        LedgerJournalTrans      ledgerJournalTransRev;
        boolean                 ok = true;
        PurchLine               purchLineLocRev;
        PurchLine               purchLineInvalid;
        TaxItemGroupHeading     taxItemGroupHeadingRev;
        TaxItemGroupHeading     taxItemGroupHeadingLoc;
        VendInvoiceInfoLine     vendInvoiceInfoLineRev;
        VendInvoiceInfoLine     vendInvoiceinfolineInvalid;
        VendInvoiceTrans        vendInvoiceTransRev;
        VendInvoiceTrans        vendInvoiceTransInvalid;
        LedgerJournalTable      ledgerJournalTable;
        VendTable               vendTable;
        TransTaxInformation     transTaxInformation;

        transTaxInformation = transTaxInformationHelper.getTransTaxInformation(_sourceTableId, _sourceRecId);

        switch (_sourceTableId)
        {
            case tableNum(PurchLine) :
                // Between order lines
                purchLineLocRev = PurchLine::findRecId(_sourceRecId, false);
                if (purchLineLocRev.TaxGroup && purchLineLocRev.TaxItemGroup)
                {
                    taxItemGroupHeadingRev = TaxItemGroupHeading::find(purchLineLocRev.TaxItemGroup);
                    if (taxItemGroupHeadingRev.ReverseChargePercentage_IN != 0)
                    {
                        select firstonly RecId from purchLineInvalid
                            where purchLineInvalid.PurchId          == purchLineLocRev.PurchId
                                && purchLineInvalid.RecId           != _sourceRecId
                                && purchLineInvalid.TaxItemGroup    != ''
                                && purchLineInvalid.TaxGroup        != ''
                            exists join taxItemGroupHeadingLoc
                                where taxItemGroupHeadingLoc.TaxItemGroup == purchLineInvalid.TaxItemGroup
                                    && taxItemGroupHeadingLoc.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis
                                    && taxItemGroupHeadingLoc.ReverseChargePercentage_IN != 0
                                    && taxItemGroupHeadingLoc.ReverseChargePercentage_IN != taxItemGroupHeadingRev.ReverseChargePercentage_IN;

                        if (purchLineInvalid.RecId)
                        {
                            ok = checkFailed("@SYS4002041");
                        }
                    }
                }

                break;
            case tableNum(VendInvoiceInfoLine) :
                // Between invoice lines
                vendInvoiceInfoLineRev = VendInvoiceInfoLine::findRecId(_sourceRecId, false);
                if (vendInvoiceInfoLineRev.TaxGroup && vendInvoiceInfoLineRev.TaxItemGroup)
                {
                    taxItemGroupHeadingRev = TaxItemGroupHeading::find(vendInvoiceInfoLineRev.TaxItemGroup);
                    if (taxItemGroupHeadingRev.ReverseChargePercentage_IN != 0)
                    {
                        select firstonly RecId from vendInvoiceinfolineInvalid
                            where vendInvoiceinfolineInvalid.ParmId         == vendInvoiceInfoLineRev.ParmId
                                && vendInvoiceinfolineInvalid.TableRefId    == vendInvoiceInfoLineRev.TableRefId
                                && vendInvoiceinfolineInvalid.RecId         != _sourceRecId
                                && vendInvoiceinfolineInvalid.TaxItemGroup  != ''
                                && vendInvoiceinfolineInvalid.TaxGroup      != ''
                            exists join taxItemGroupHeadingLoc
                                where taxItemGroupHeadingLoc.TaxItemGroup == vendInvoiceinfolineInvalid.TaxItemGroup
                                    && taxItemGroupHeadingLoc.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis
                                    && taxItemGroupHeadingLoc.ReverseChargePercentage_IN != 0
                                    && taxItemGroupHeadingLoc.ReverseChargePercentage_IN != taxItemGroupHeadingRev.ReverseChargePercentage_IN;

                        if (vendInvoiceinfolineInvalid.RecId)
                        {
                            ok = checkFailed("@SYS4002041");
                        }
                    }
                    if (ok
                        && transTaxInformation.ServiceTaxGTAServiceCategory == GTAServiceCategory_IN::OutwardInterUnit
                        && !VendTable::find(vendInvoiceInfoLineRev.InvoiceAccount).isGTA())
                    {
                        ok = checkFailed(strFmt("@SYS4003185", "@SYS4002984"));
                    }
                }
                break;

            case tableNum(VendInvoiceTrans) :
                vendInvoiceTransRev = VendInvoiceTrans::findRecId(_sourceRecId);
                if (vendInvoiceTransRev.TaxGroup && vendInvoiceTransRev.TaxItemGroup)
                {
                    taxItemGroupHeadingRev = TaxItemGroupHeading::find(vendInvoiceTransRev.TaxItemGroup);
                    if (taxItemGroupHeadingRev.ReverseChargePercentage_IN)
                    {
                        select firstonly RecId from vendInvoiceTransInvalid
                            where vendInvoiceTransInvalid.PurchID               == vendInvoiceTransRev.PurchID
                                && vendInvoiceTransInvalid.TaxItemGroup         != ''
                                && vendInvoiceTransInvalid.TaxGroup             != ''
                                && vendInvoiceTransInvalid.InvoiceId            == vendInvoiceTransRev.InvoiceId
                                && vendInvoiceTransInvalid.InvoiceDate          == vendInvoiceTransRev.InvoiceDate
                                && vendInvoiceTransInvalid.NumberSequenceGroup  == vendInvoiceTransRev.NumberSequenceGroup
                                && vendInvoiceTransInvalid.InternalInvoiceId    == vendInvoiceTransRev.InternalInvoiceId
                            exists join taxItemGroupHeadingLoc
                                where taxItemGroupHeadingLoc.TaxItemGroup   == vendInvoiceTransInvalid.TaxItemGroup
                                    && taxItemGroupHeadingLoc.ReverseChargePercentage_IN    != taxItemGroupHeadingRev.ReverseChargePercentage_IN
                                    && taxItemGroupHeadingLoc.ReverseChargePercentage_IN    != 0
                                    && taxItemGroupHeadingLoc.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis;

                        if (vendInvoiceTransInvalid.RecId)
                        {
                            ok = checkFailed("@SYS4002041");
                        }
                    }
                    if (ok
                        && vendInvoiceTransRev.gtaServiceCategory_IN == GTAServiceCategory_IN::OutwardInterUnit
                        && !PurchTable::find(vendInvoiceTransRev.PurchID).vendTable_OrderAccount().isGTA())
                    {
                        ok = checkFailed(strFmt("@SYS4003185", "@SYS4002984"));
                    }
                }

                break;

            case tableNum(LedgerJournalTrans) :
                ledgerJournalTransRev   = LedgerJournalTrans::findRecId(_sourceRecId, false);
                ledgerJournalTable      = ledgerJournalTransRev.ledgerJournalTable();
                if (ledgerJournalTransRev.TaxItemGroup && ledgerJournalTransRev.TaxGroup)
                {
                    taxItemGroupHeadingRev = TaxItemGroupHeading::find(ledgerJournalTransRev.TaxItemGroup);
                    if (taxItemGroupHeadingRev.ReverseChargePercentage_IN != 0)
                    {
                        if (!ledgerJournalTable.canApplyServiceReverseCharge_IN(ledgerJournalTransRev.Voucher))
                        {
                            ok = checkFailed("@SYS4002408");
                        }
                        else
                        {
                            select firstonly RecId from ledgerJournalTransInvalid
                                where ledgerJournalTransInvalid.Voucher         == ledgerJournalTransRev.Voucher
                                    && ledgerJournalTransInvalid.JournalNum     == ledgerJournalTable.JournalNum
                                    && ledgerJournalTransInvalid.RecId          != _sourceRecId
                                    && ledgerJournalTransInvalid.TaxItemGroup   != ''
                                exists join taxItemGroupHeadingLoc
                                    where taxItemGroupHeadingLoc.TaxItemGroup == ledgerJournalTransInvalid.TaxItemGroup
                                        && taxItemGroupHeadingLoc.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis
                                        && taxItemGroupHeadingLoc.ReverseChargePercentage_IN != 0
                                        && taxItemGroupHeadingLoc.ReverseChargePercentage_IN != taxItemGroupHeadingRev.ReverseChargePercentage_IN;

                            if (ledgerJournalTransInvalid.RecId)
                            {
                                ok = checkFailed("@SYS4002041");
                            }
                        }
                    }

                    if (ledgerJournalTransRev.AccountType == LedgerJournalACType::Vend)
                    {
                        vendTable = VendTable::find(ledgerJournalTransRev.parmAccount());
                    }
                    else if (ledgerJournalTransRev.OffsetAccountType == LedgerJournalACType::Vend)
                    {
                        vendTable = VendTable::find(ledgerJournalTransRev.parmOffsetAccount());
                    }
                    if (transTaxInformation.ServiceTaxGTAServiceCategory == GTAServiceCategory_IN::OutwardInterUnit
                        && !vendTable.isGTA())
                    {
                        ok = checkFailed(strFmt("@SYS4003185", "@SYS4002984"));
                    }
                }
                break;
        }
        // End swith

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTaxWorkTrans_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates TmpTaxWorkTrans with brazillian requirements
    /// </summary>
    /// <param name="_tmpTaxWorkTrans">
    /// TmpTaxWorkTrans to be validated
    /// </param>
    /// <returns>
    /// Returns false is taxation code is required and is blank.
    /// </returns>
    protected boolean validateTaxWorkTrans_BR(TmpTaxWorkTrans _tmpTaxWorkTrans)
    {
        boolean ok = true;
        if (TaxationCodeSetup_BR::isTaxationCodeRequired(_tmpTaxWorkTrans.TaxType_BR)
            && !_tmpTaxWorkTrans.TaxationCode_BR)
        {
            ok = checkFailed(strFmt("@GLS60394", _tmpTaxWorkTrans.TaxType_BR));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWarningsForPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates for posting.
    /// </summary>
    /// <param name = "_warning">The tax warning.</param>
    /// <param name = "_taxCode">The tax code.</param>
    /// <param name = "_issueWarning">Whether is warning issue.</param>
    protected void validateWarningsForPost(TaxWarning _warning, TaxCode _taxCode, boolean _issueWarning)
    {
        if (_warning == TaxWarning::InvalidTaxIncludedTaxCode)
        {
            if (_issueWarning)
            {
                warning(strFmt("@Tax:TaxInclPerTotalCalcWithTaxLimitWarning", _taxCode));
            }
            throw error("@SYS300937");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validCustomsDutyCombinations_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates customs duty combinations.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal transaction.
    /// </param>
    /// <returns>
    /// If 'True', the customs duty combinations is valid.
    /// </returns>
    //Identification of taxable combinations for journals in customs.
    public boolean validCustomsDutyCombinations_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean ret = true;
        if (_ledgerJournalTrans.RecId)
        {
            if ((_ledgerJournalTrans.AccountType  == LedgerJournalACType::Cust          &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger         && abs(_ledgerJournalTrans.AmountCurDebit)   > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust          &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project        && abs(_ledgerJournalTrans.AmountCurDebit)   > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust          &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets    && abs(_ledgerJournalTrans.AmountCurDebit)   > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend          &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger         && abs(_ledgerJournalTrans.AmountCurDebit)   > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend          &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project        && abs(_ledgerJournalTrans.AmountCurDebit)   > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend          &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets    && abs(_ledgerJournalTrans.AmountCurDebit)   > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project       &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend           && abs(_ledgerJournalTrans.AmountCurDebit)   > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project       &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust           && abs(_ledgerJournalTrans.AmountCurDebit)   > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets   &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust           && abs(_ledgerJournalTrans.AmountCurDebit)   > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets   &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend           && abs(_ledgerJournalTrans.AmountCurDebit)   > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger        &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust           && abs(_ledgerJournalTrans.AmountCurDebit)   > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger        &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend           && abs(_ledgerJournalTrans.AmountCurDebit)   > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust          &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger         && abs(_ledgerJournalTrans.AmountCurCredit)  > 0)     ||//Credit amount
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust          &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project        && abs(_ledgerJournalTrans.AmountCurCredit)  > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust          &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets    && abs(_ledgerJournalTrans.AmountCurCredit)  > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend          &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger         && abs(_ledgerJournalTrans.AmountCurCredit)  > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend          &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project        && abs(_ledgerJournalTrans.AmountCurCredit)  > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend          &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets    && abs(_ledgerJournalTrans.AmountCurCredit)  > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project       &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend           && abs(_ledgerJournalTrans.AmountCurCredit)  > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project       &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust           && abs(_ledgerJournalTrans.AmountCurCredit)  > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets   &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust           && abs(_ledgerJournalTrans.AmountCurCredit)  > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets   &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend           && abs(_ledgerJournalTrans.AmountCurCredit)  > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger        &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust           && abs(_ledgerJournalTrans.AmountCurCredit)  > 0)     ||
                 (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger        &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend           && abs(_ledgerJournalTrans.AmountCurCredit)  > 0))
            {
                ret = true;
                if ((_ledgerJournalTrans.AccountType         == LedgerJournalACType::Project     ||
                    _ledgerJournalTrans.OffsetAccountType    == LedgerJournalACType::Project)    &&
                    (_ledgerJournalTrans.AccountType         == LedgerJournalACType::Vend        ||
                    _ledgerJournalTrans.AccountType          == LedgerJournalACType::Cust        ||
                    _ledgerJournalTrans.OffsetAccountType    == LedgerJournalACType::Vend        ||
                    _ledgerJournalTrans.OffsetAccountType    == LedgerJournalACType::Cust))
                {
                    this.parmLJT_IN(_ledgerJournalTrans);
                }
            }
            else
            {
                ret = false;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validCustomsJournal_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates customs journal.
    /// </summary>
    /// <param name="_ledgerJournalTransCustoms">
    /// The ledger journal transaction customs.
    /// </param>
    public void validCustomsJournal_IN(LedgerJournalTrans _ledgerJournalTransCustoms)
    {
        boolean isIndianTax;

        //General validation to see if Types are allowed for Customs duty calculation.
        isIndianTax = this.validCustomsDutyCombinations_IN(_ledgerJournalTransCustoms);

        // Project type can be used in journals for Customs?
        if (isIndianTax
                &&
            (_ledgerJournalTransCustoms.AccountType          == LedgerJournalACType::Project
            || _ledgerJournalTransCustoms.OffsetAccountType  == LedgerJournalACType::Project)
                &&
                (_ledgerJournalTransCustoms.AccountType       == LedgerJournalACType::Vend
            || _ledgerJournalTransCustoms.AccountType        == LedgerJournalACType::Cust
            || _ledgerJournalTransCustoms.OffsetAccountType  == LedgerJournalACType::Vend
            || _ledgerJournalTransCustoms.OffsetAccountType  == LedgerJournalACType::Cust))
        {
            this.parmLJT_IN(_ledgerJournalTransCustoms);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validCustomsScenario_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///   This method returns true if its a valid transaction (with Customs tax codes) that can be posted.
    /// </summary>
    /// <returns>
    ///   True if its a valid transaction (with Customs tax codes) that can be posted.
    /// </returns>
    public boolean validCustomsScenario_IN()
    {
        SalesTable salesTable = SalesLine::findRecId(taxWorkTrans.SourceRecId).salesTable();

        return(
            // For Export order during Shipping Bill.
            ((taxWorkTrans.TaxDirection  == TaxDirection::OutgoingTax
                && (salesTable.DocumentStatus == DocumentStatus::Invoice)
                && salesTable.CustomsExportOrder_IN)
                    ||
                this is TaxSalesShippingBill_IN)
            ||
            // For all PO
            (taxWorkTrans.TaxDirection == TaxDirection::IncomingTax)
            ||
            //Valid Customs journals.
            this is TaxCalculationJournal
            ||
            // For FTI
            (this is TaxFreeInvoice_Invoice || this is TaxFreeInvoice)
            ||
            // For normal SO Invoicing
            ((taxWorkTrans.TaxDirection == TaxDirection::OutgoingTax)
                && (this.sourceTableId()    == tableNum(CustInvoiceTrans)
                    || this.sourceTableId() == tableNum(SalesLine)
                    // <GIN>
                    || this.sourceTableId() == tableNum(ProjInvoiceItem)
                    || this.sourceTableId() == tableNum(ProjInvoiceCost)
                    || this.sourceTableId() == tableNum(ProjInvoiceOnAcc))
                    // </GIN>
                    && SalesTable::find(salesPurchJournalLineLoc.SourceId).CustomsExportOrder_IN == NoYes::No)
            ||
            // <GIN>
            ((taxWorkTrans.TaxDirection == TaxDirection::OutgoingTax)
                && (this.sourceTableId() == tableNum(ProjInvoiceItem)
                    || this.sourceTableId() == tableNum(ProjInvoiceCost)
                    || this.sourceTableId() == tableNum(ProjInvoiceOnAcc)
                    || this is TaxProj
                    ))
            // </GIN>
            );
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatAmountOfCapitalGoods_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the total VAT tax amount of CapitalGoods on PurchTable.
    /// </summary>
    /// <returns>
    /// The total VAT tax amount
    /// </returns>
    TaxAmount vatAmountOfCapitalGoods_IN()
    {
        TaxAmount   vatTaxAmount;

        select sum(TaxAmount) from taxWorkTrans
           where taxWorkTrans.TaxAccountType_IN == TaxAccountType_IN::VATDeferredAccount;

        vatTaxAmount = taxWorkTrans.TaxAmount;

        return vatTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatAmountPerLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the table buffer and set the records.
    /// </summary>
    /// <param name="_sourceTableId">
    /// Table id is used to find TaxUncommitted.
    /// </param>
    /// <param name="_sourceRecId">
    /// RecId is used to find TaxUncommitted.
    /// </param>
    /// <returns>
    /// Returns the amount.
    /// </returns>
    TaxAmount vatAmountPerLine_IN(
        RefTableId   _sourceTableId,
        RefRecId     _sourceRecId)
    {
        TaxAmount       vatTaxAmounttPerLine;
        TaxUncommitted  taxUncommitted;
        TaxOnItem       taxOnItem;
        TaxTable        taxTable;

        while select TaxAutogenerated, TaxAmount, SourceRegulateAmountCur from taxUncommitted
            where taxUncommitted.SourceTableId == _sourceTableId
               && taxUncommitted.SourceRecId == _sourceRecId
        exists join TaxCode from taxOnItem
            where taxOnItem.TaxItemGroup == taxUncommitted.TaxItemGroup
               && taxOnItem.TaxCode == taxUncommitted.TaxCode
        exists join TaxType_IN from taxTable
            where taxTable.TaxCode == taxOnItem.TaxCode
               && taxTable.TaxType_IN == TaxType_IN::VAT
        {
            vatTaxAmounttPerLine +=  taxUncommitted.TaxAutogenerated
                                    ? taxUncommitted.TaxAmount
                                    : taxUncommitted.SourceRegulateAmountCur;
        }

        return vatTaxAmounttPerLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatDeferredAmountPerLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the table buffer and set the records.
    /// </summary>
    /// <param name="_purchLine">
    /// The table buffer is used to find the record.
    /// </param>
    /// <returns>
    /// Returns the amount.
    /// </returns>
    TaxAmount  vatDeferredAmountPerLine_IN(PurchLine _purchLine)
    {
        TaxAmount                   vatTaxAmounttPerLine,payableAmount, taxAmountWithoutNonRec;
        TaxTrans                    taxTransOrig,taxTransPeriodic;
        TaxTrans_IN                 taxTransLocalPeriodic;
        ComponentTransactions_IN    settleTransLocal;
        TaxTable                    taxTableLoc;
        payableAmount        = 0;
        vatTaxAmounttPerLine = 0;

        while select taxOnItemLoc
            where taxOnItemLoc.TaxItemGroup == _purchLine.TaxItemGroup
                exists join TaxType_IN from taxTableLoc
                 where taxTableLoc.TaxCode == taxOnItemLoc.TaxCode
                    && taxTableLoc.TaxType_IN == TaxType_IN::VAT
        {
            while select RefRecId from taxTransLocalPeriodic
                join RecId from taxTransOrig
                where taxTransOrig.InventTransId    == _purchLine.InventRefTransId
                    && taxTransOrig.TaxCode         == taxOnItemLoc.TaxCode
                    && taxTransLocalPeriodic.TaxTransVATRefRecId   == taxTransOrig.RecId
                    && ! taxTransLocalPeriodic.vatDefLineTransferred
                join RecId from taxTransPeriodic
                where taxTransPeriodic.RecId == taxTransLocalPeriodic.RefRecId
                    join RecoverableAmount from settleTransLocal
                    where settleTransLocal.TransRecid == taxTransPeriodic.RecId
            {
                payableAmount += settleTransLocal.RecoverableAmount;
            }

            select TaxAmountCur, TaxInCostPriceCur from taxWorkTrans
                where taxWorkTrans.InventTransId == _purchLine.InventTransId &&
                    taxWorkTrans.TaxCode       == taxOnItemLoc.TaxCode;

            taxAmountWithoutNonRec = taxWorkTrans.TaxAmountCur - taxWorkTrans.TaxInCostPriceCur;

            vatTaxAmounttPerLine += taxAmountWithoutNonRec;
        }

        return vatTaxAmounttPerLine + payableAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatOperationCode_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Returns VAT operation code for current tax calculation
    /// </summary>
    /// <returns>
    ///   VAT operation code for current tax calculation
    /// </returns>
    protected VATOperationCode_RU vatOperationCode_RU()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>baseAmountExclTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and retrieves the amount exclusive of tax for a journal line and should be used when the
    ///    line amount includes taxes.
    /// </summary>
    /// <param name="_taxGroup">
    ///    The sales tax group used for tax calculations.
    /// </param>
    /// <param name="_taxItemGroup">
    ///    The item sales tax group used for tax calculations. This group will be compared with the sales tax
    ///    groups to see which tax codes have to be calculated.
    /// </param>
    /// <param name="_taxDate">
    ///    The as of date used to calculate the taxes.
    /// </param>
    /// <param name="_sourceCurrencyCode">
    ///    The currency on the transaction.
    /// </param>
    /// <param name="_baseAmountCur">
    ///    The line amount which includes taxes.
    /// </param>
    /// <param name="_taxModuleType">
    ///    The module for which we are calculating taxes.
    /// </param>
    /// <param name="_baseQty">
    ///    The quantity available on the line, used for unit calculations; optional.
    /// </param>
    /// <param name="_baseUnit">
    ///    The unit of quantity for the line. Used in unit calculations; optional.
    /// </param>
    /// <param name="_itemId">
    ///    The item ID of the item on the line. Used for unit calculations; optional.
    /// </param>
    /// <param name="_taxDirection">
    ///    A description of how the sales tax is stated; optional.
    /// </param>
    /// <param name="_cashDiscPercent">
    ///    A Boolean value that specifies whether a cash discounts percentage is to be subtracted before taxes
    ///    being calculated; optional.
    /// </param>
    /// <param name="_rounding">
    ///    If true, the value returned will be rounded according to the tax round off rules. If false, the
    ///    value will be full precision. This should be false if the amount returned will be used as input to
    ///    tax calculations; optional.
    /// </param>
    /// <param name="_cashDiscAmount">
    ///    A Boolean value that specifies whether the cash discounts amount is to be subtracted before taxes
    ///    being calculated. Typically, provide either percentage or amount, but not both; optional.
    /// </param>
    /// <param name="_exchRatesTriangulation">
    ///    A Boolean value that specifies whether triangulation is required; optional.
    /// </param>
    /// <param name="_exchRate">
    ///    The value of the primary exchange rate that will be used for currency conversions between
    ///    transactional and master currency; optional.
    /// </param>
    /// <param name="_exchRateSecond">
    ///    The secondary exchange rate that will be used for currency conversions between transactional and
    ///    master currency; optional.
    /// </param>
    /// <param name="_calculateAmountByUnit">
    ///    A Boolean value that specifies whether the "per unit" calculations will occur; optional.
    /// </param>
    /// <returns>
    ///    The base amount exclusive of taxes.
    /// </returns>
    static TaxBaseCur baseAmountExclTax(TaxGroup                 _taxGroup,
                                               TaxItemGroup             _taxItemGroup,
                                               TransDate                _taxDate,
                                               CurrencyCode             _sourceCurrencyCode,
                                               AmountCur                _baseAmountCur,
                                               TaxModuleType            _taxModuleType,
                                               TaxBase                  _baseQty                = 0,
                                               UnitOfMeasureSymbol      _baseUnit               = '',
                                               ItemId                   _itemId                 = '',
                                               TaxDirection             _taxDirection           = TaxDirection::OutgoingTax,
                                               Percent                  _cashDiscPercent        = 0,
                                               boolean                  _rounding               = true,
                                               AmountCur                _cashDiscAmount         = 0,
                                               ExchRatesTriangulation   _exchRatesTriangulation = UnknownNoYes::Unknown,
                                               ExchRate                 _exchRate               = 0,
                                               ExchRate                 _exchRateSecond         = 0,
                                               boolean                  _calculateAmountByUnit  = true)
    {
        TaxGroupData    taxGroupData;
        TaxOnItem       taxOnItem;
        TmpTaxWorkTrans tmpTaxWorkTrans;

        Tax             tax;
        // <GIN>
        boolean         taxesMarked = TaxParameters::checkTaxParameters_IN();
        // </GIN>

        ;

        if (_taxDate == dateNull())
        {
            _taxDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }

        tax = Tax::construct();

        while select TaxGroup, TaxCode, ExemptTax, UseTax, IntracomVAT from taxGroupData

            where taxGroupData.TaxGroup     == _taxGroup
            join TaxItemGroup, TaxCode from taxOnItem
            where taxOnItem.TaxItemGroup    == _taxItemGroup     &&
                  taxOnItem.TaxCode         == taxGroupData.TaxCode
        {
            // <GIN>
            if (taxesMarked)
            {
                tmpTaxWorkTrans.CompanyId_IN        = curext();
            }
            // </GIN>

            tmpTaxWorkTrans.TransDate           = _taxDate;
            tmpTaxWorkTrans.CalculationDate     = _taxDate;
            tmpTaxWorkTrans.TaxCode             = taxGroupData.TaxCode;
            tmpTaxWorkTrans.TaxDirection        = Tax::determineTaxDirection(_taxModuleType, taxGroupData, _taxDirection);
            tmpTaxWorkTrans.Source              = _taxModuleType;
            tmpTaxWorkTrans.SourceCurrencyCode  = _sourceCurrencyCode;
            tmpTaxWorkTrans.ExemptTax           = taxGroupData.ExemptTax;
            tmpTaxWorkTrans.Company             = tax.getCompany();

            tmpTaxWorkTrans.insert();
        }

        tax.tmpTaxWorkTrans(tmpTaxWorkTrans);
        tax.parmTaxDate(_taxDate);
        tax.setCashDiscount(_cashDiscPercent, _cashDiscAmount);
        tax.setExchRates(_sourceCurrencyCode, _exchRate, _exchRateSecond, _exchRatesTriangulation);

        return tax.amountExclTax(_baseAmountCur,

                            _rounding,
                            _calculateAmountByUnit,
                            _baseQty,
                            _baseUnit,
                            _itemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>baseAmountExclTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates and retrieves the amount exclusive of tax for a journal line and should be used when the
    ///     line amount includes taxes.
    /// </summary>
    /// <param name="_common">
    ///     The salesPurchLine table.
    /// </param>
    /// <param name="_taxDate">
    ///     The as of date used to calculate the taxes.
    /// </param>
    /// <param name="_lineAmount">
    ///     The original line amount of the transaction.
    /// </param>
    /// <param name="_baseAmountCur">
    ///     The actual base amount that includes taxes.
    /// </param>
    /// <param name="_discPercent">
    ///     The total discount percentage on the line; optional.
    /// </param>
    /// <param name="_tax">
    ///     The tax object; optional.
    /// </param>
    /// <returns>
    ///     The base amount exclusive of taxes.
    /// </returns>
    static TaxBaseCur baseAmountExclTax_IN(Common                   _common,
                                                  TransDate                _taxDate,
                                                  AmountCur                _lineAmount,
                                                  AmountCur                _baseAmountCur,
                                                  EndDiscPct               _discPercent = 0,
                                                  Tax                      _tax = null)
    {
        AmountCur       taxOrigin;
        TaxAmountCur    totalTaxAmount;
        TaxBase         taxBaseAmount;
        Counter         sign    = 1;

        if (_taxDate == dateNull())
        {
            _taxDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }

        switch (_common.TableId)
        {
            case    tableNum(PurchLine),
                                                                                tableNum(PurchReqLine),

                    tableNum(PurchRFQLine),
                    tableNum(VendInvoiceInfoLine):
                    totalTaxAmount = abs(PurchTotals_ParmTrans::getInclTaxAmountForPosting_IN(_common, _tax));
                break;

            case    tableNum(SalesLine),
                                                                                tableNum(SalesBasketLine),

                    tableNum(SalesQuotationLine),
                    tableNum(CustInvoiceLine):
                    totalTaxAmount = abs(Tax::getInclTaxAmount_IN(_common, _tax));
                break;

            default:
                break;
        }

        if (_baseAmountCur < 0)
        {
            sign = -1;
        }

        if (_discPercent != 100)
        {
            if (_baseAmountCur == _lineAmount)
            {
                taxOrigin = _baseAmountCur * ( 1 - _discPercent / 100) - totalTaxAmount * sign;
            }
            else
            {
                // This will calculate the tax amount by adding back the total discount
                totalTaxAmount = totalTaxAmount * sign / ( 1 - _discPercent / 100);
                if (_tax)
                {
                    // This will calculate the lineExclTax amount by adding back the total discount
                    taxBaseAmount = abs(_tax.getOriginForSourceLine_IN(_common.TableId, _common.RecId)) / ( 1 - _discPercent / 100);
                }
                else
                {
                    // This will calculate the lineExclTax amount by adding back the total discount
                    taxBaseAmount = abs(TaxUncommitted::getOriginForSourceLine_IN(_common.TableId, _common.RecId)) / ( 1 - _discPercent / 100);
                }

                if (taxBaseAmount)
                {
                    taxOrigin = _baseAmountCur - totalTaxAmount * sign * _baseAmountCur /  (taxBaseAmount + totalTaxAmount * sign);
                }
            }
        }
        return taxOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>baseAmountExclTaxRaw</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates and retrieves the amount exclusive tax for a journal line and should be used when the
    /// line amount includes taxes.
    /// </summary>
    /// <param name="_taxGroup">
    /// The sales tax group used for tax calculations.
    /// </param>
    /// <param name="_taxItemGroup">
    /// The item sales tax group used for tax calculations. This group will be compared to the sales tax
    /// groups to see which tax codes have to be calculated.
    /// </param>
    /// <param name="_taxDate">
    /// The as of date used to calculate the taxes.
    /// </param>
    /// <param name="_sourceCurrencyCode">
    /// The currency on the transaction.
    /// </param>
    /// <param name="_baseAmountCur">
    /// The line amount which includes taxes.
    /// </param>
    /// <param name="_taxModuleType">
    /// The module for which we are calculating taxes.
    /// </param>
    /// <param name="_baseQty">
    /// The quantity available on the line, used for unit calculations; optional.
    /// </param>
    /// <param name="_baseUnit">
    /// The unit of quantity for the line. Used in unit calculations; optional.
    /// </param>
    /// <param name="_itemId">
    /// The item ID of the item on the line. Used for unit calculations; optional.
    /// </param>
    /// <param name="_taxDirection">
    /// A description of how the sales tax is stated; optional.
    /// </param>
    /// <param name="_cashDiscPercent">
    /// A Boolean value that specifies whether a cash discounts percentage is to be subtracted before taxes
    /// being calculated; optional.
    /// </param>
    /// <param name="_initTmpTaxWorkTrans">
    /// true if the passed in tax groups will be compared and codes that match will have corresponding
    /// records inserted into the <c>TmpTaxWorkTrans</c> table; false if the General Ledger will initialize
    /// the <c>TmpTaxWorkTrans</c> table. The General Ledger module would typically pass in false for this,
    /// as General Ledger, will initialize the <c>TmpTaxWorkTrans</c> table. Other modules should pass
    /// true; optional.
    /// </param>
    /// <param name="_cashDiscAmount">
    /// A Boolean value that specifies whether the cash discounts amount is to be subtracted before taxes
    /// being calculated. Typically, provide either percentage or amount, but not both; optional.
    /// </param>
    /// <param name="_exchRatesTriangulation">
    /// A Boolean value that specifies whether triangulation is required; optional.
    /// </param>
    /// <param name="_exchRate">
    /// The value of the primary exchange rate that will be used for currency conversions between
    /// transactional and master currency; optional.
    /// </param>
    /// <param name="_exchRateSecond">
    /// The secondary exchange rate that will be used for currency conversions between transactional and
    /// master currency; optional.
    /// </param>
    /// <param name="_calculateAmountByUnit">
    /// A Boolean value that specifies whether the "per unit" calculations will occur; optional.
    /// </param>
    /// <returns>
    /// The base amount exclusive of taxes.
    /// </returns>
    static TaxBaseCur baseAmountExclTaxRaw(TaxGroup              _taxGroup,
                                               TaxItemGroup             _taxItemGroup,
                                               TransDate                _taxDate,
                                               CurrencyCode             _sourceCurrencyCode,
                                               AmountCur                _baseAmountCur,
                                               TaxModuleType            _taxModuleType,
                                               TaxBase                  _baseQty                = 0,
                                               UnitOfMeasureSymbol      _baseUnit               = '',
                                               ItemId                   _itemId                 = '',
                                               TaxDirection             _taxDirection           = TaxDirection::OutgoingTax,
                                               Percent                  _cashDiscPercent        = 0,
                                               boolean                  _initTmpTaxWorkTrans    = true,
                                               AmountCur                _cashDiscAmount         = 0,
                                               ExchRatesTriangulation   _exchRatesTriangulation = UnknownNoYes::Unknown,
                                               ExchRate                 _exchRate               = 0,
                                               ExchRate                 _exchRateSecond         = 0,
                                               boolean                  _calculateAmountByUnit  = true)
    {
        TaxBaseCur  baseAmountExclTaxNoRnd;
        ;
        baseAmountExclTaxNoRnd = Tax::baseAmountExclTax(_taxGroup,
                                       _taxItemGroup,
                                       _taxDate,
                                       _sourceCurrencyCode,
                                       _baseAmountCur,
                                       _taxModuleType,
                                       _baseQty,
                                       _baseUnit,
                                       _itemId,
                                       _taxDirection,
                                       _cashDiscPercent,
                                       false,
                                       _cashDiscAmount,
                                       _exchRatesTriangulation,
                                       _exchRate,
                                       _exchRateSecond,
                                       _calculateAmountByUnit);

        return baseAmountExclTaxNoRnd;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcNRTax_LV</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates tax amount for natural resources tax group.
    /// </summary>
    /// <param name="_taxGroup">
    /// The value of <c>TaxGroup</c>.
    /// </param>
    /// <param name="_nrTaxGroup">
    /// The value of <c>LvNRTaxGroup</c>.
    /// </param>
    /// <param name="_taxDate">
    /// Tax calculation date.
    /// </param>
    /// <param name="_sourceCurrencyCode">
    /// The source currency code.
    /// </param>
    /// <param name="_baseAmountCur">
    /// Base amount.
    /// </param>
    /// <param name="_taxModuleType">
    /// The tax modul type.
    /// </param>
    /// <param name="_baseQty">
    /// Base quantity.
    /// </param>
    /// <param name="_baseUnit">
    /// The base unit Id.
    /// </param>
    /// <param name="_itemId">
    /// The item Id.
    /// </param>
    /// <returns>
    /// The buffer of <c>TmpTaxWorkTrans</c> table.
    /// </returns>
    public static TmpTaxWorkTrans calcNRTax_LV (TaxGroup               _taxGroup,
                                                       LvNRTaxGroup           _nrTaxGroup,
                                                       TransDate              _taxDate,
                                                       CurrencyCode           _sourceCurrencyCode,
                                                       AmountCur              _baseAmountCur,
                                                       TaxModuleType          _taxModuleType,
                                                       TaxBase                _baseQty         = 0,
                                                       UnitOfMeasureSymbol    _baseUnit        = '',
                                                       ItemId                 _itemId          = '')
    {
        TmpTaxWorkTrans taxWorkTrans;
        Tax             tax = new Tax();

        tax.nrTaxCalcWithoutSource_LV(_taxGroup,
                                      _nrTaxGroup,
                                      _taxDate,
                                      _sourceCurrencyCode,
                                      _baseAmountCur,
                                      _taxModuleType,
                                      _baseQty,
                                      _baseUnit,
                                      _itemId);

        taxWorkTrans.setTmpData(tax.tmpTaxWorkTrans());

        return taxWorkTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPctGrosOnNet</Name>
				<Source><![CDATA[
    static Percent calcPctGrosOnNet(Percent _percent)
    {
        if (_percent == 100)
            return 100;
        else
            return (_percent / (100 - _percent)) * 100;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTaxAmount</Name>
				<Source><![CDATA[
    static TaxAmountCur calcTaxAmount(TaxGroup               _taxGroup,
                                             TaxItemGroup           _taxItemGroup,
                                             TransDate              _taxDate,
                                             CurrencyCode           _sourceCurrencyCode,
                                             AmountCur              _baseAmountCur,
                                             TaxModuleType          _taxModuleType,
                                             TaxBase                _baseQty          = 0,
                                             UnitOfMeasureSymbol    _baseUnit         = '',
                                             ItemId                 _itemId           = '',
                                             TaxDirection           _taxDirection     = TaxDirection::OutgoingTax,
                                             GSTHSTTaxType_CA       _gsthstTaxType_CA = GSTHSTTaxType_CA::None)
    {
        Tax             tax = Tax::construct();
        TaxAmountCur    taxAmountCur;
        ;
        taxAmountCur = tax.taxCalcWithoutSource(_taxGroup,
                                                _taxItemGroup,
                                                _taxDate,
                                                _sourceCurrencyCode,
                                                _baseAmountCur,
                                                _taxModuleType,
                                                _baseQty,
                                                _baseUnit,
                                                _itemId,
                                                _taxDirection,
                                                _gsthstTaxType_CA);

        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTaxAmountPerVatCode_PL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the domestic sales tax for the export sales.
    /// </summary>
    /// <param name="_taxGroup">
    /// The sales tax group.
    /// </param>
    /// <param name="_taxItemGroup">
    /// The item sales tax group.
    /// </param>
    /// <param name="_taxDate">
    /// The tax date.
    /// </param>
    /// <param name="_sourceCurrencyCode">
    /// The export sales transaction currency code.
    /// </param>
    /// <param name="_baseAmountCur">
    /// The export sales transaction currency amount.
    /// </param>
    /// <param name="_taxModuleType">
    /// The tax module type.
    /// </param>
    /// <returns>
    /// A <c>TmpTaxWorkTrans</c> record with the domestic sales tax for the export sales.
    /// </returns>
    public static TmpTaxWorkTrans calcTaxAmountPerVatCode_PL(TaxGroup      _taxGroup,
                                                                    TaxItemGroup  _taxItemGroup,
                                                                    TransDate     _taxDate,
                                                                    CurrencyCode  _sourceCurrencyCode,
                                                                    AmountCur     _baseAmountCur,
                                                                    TaxModuleType _taxModuleType)
    {
        TmpTaxWorkTrans taxWorkTrans;
        TaxTable        taxTable;
        Tax             tax;

        tax = new Tax();

        tax.taxCalcWithoutSource(_taxGroup,

                                 _taxItemGroup,
                                 _taxDate,
                                 _sourceCurrencyCode,
                                 _baseAmountCur,
                                 _taxModuleType);

        taxWorkTrans.setTmpData(tax.tmpTaxWorkTrans());

        while select sum(SourceTaxAmountCur), sum(SourceBaseAmountCur), TaxCode

            from taxWorkTrans group by TaxCode
        {
            if (taxWorkTrans.SourceTaxAmountCur)
            {
                taxTable = TaxTable::find(taxWorkTrans.TaxCode);

                if (taxTable.TaxType_W)
                {
                    break;
                }
            }
        }

        return taxWorkTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeDisplaySign</Name>
				<Source><![CDATA[
    public static int changeDisplaySign(TaxDirection _taxDirection)
    {
        if (_taxDirection == TaxDirection::OutgoingTax ||
            _taxDirection == TaxDirection::TaxExemptSales
            // <GEEU>
            || (_taxDirection == TaxDirection::OutgoingTax_W
                && (TaxParameters::isBankExchRateEnabled_W()
                    || TaxSpecificExchangeRateHelper::isTaxSpecificExchangeRateEnabled()))
            // </GEEU>
            )
        {
            return -1;
        }
        else
        {
            return 1;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeDisplaySignTaxTrans</Name>
				<Source><![CDATA[
    static int changeDisplaySignTaxTrans(TaxDirection _taxDirection)
    {
        //Change the sign of values as appropriate for data coming from the TaxTrans table
        if (_taxDirection == TaxDirection::OutgoingTax ||
            _taxDirection == TaxDirection::TaxExemptSales)
        {
            return -1;
        }
        else
        {
            return 1;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeDisplaySignTmpTaxWorkTrans</Name>
				<Source><![CDATA[
    static int changeDisplaySignTmpTaxWorkTrans(LedgerJournalACType _accountType,
                                                SalesPurch _salesPurch,
                                                TmpTaxWorkTrans _tmpTaxWorkTrans)
    {
        //Change the sign of values as appropriate for data coming from the TmpTaxWorkTrans table
        if (_accountType == LedgerJournalACType::Ledger)
        {
            if (_salesPurch == SalesPurch::Sales)
                return 1;
            else
                if ((_tmpTaxWorkTrans.SourceTableId == tableNum(SalesLine)) ||
                    (_tmpTaxWorkTrans.SourceTableId == tableNum(SalesQuotationLine)) ||
                    (_tmpTaxWorkTrans.SourceTableId == tableNum(CustInvoiceLine)) ||
                    (_tmpTaxWorkTrans.SourceTableId == tableNum(MarkupTrans)))
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }
        else
        {
            if (_tmpTaxWorkTrans.TaxDirection == TaxDirection::OutgoingTax ||

                _tmpTaxWorkTrans.TaxDirection == TaxDirection::TaxExemptSales)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLedgerPostingType_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the ledger posting type is for india
    /// </summary>
    /// <param name="_ledgerPostingType">
    /// Ledger posting type
    /// </param>
    /// <returns>
    /// True if india posting type
    /// </returns>
    public static boolean checkLedgerPostingType_IN(LedgerPostingType   _ledgerPostingType)
    {
        boolean     ret;

        switch (_ledgerPostingType)
        {
            case LedgerPostingType::VAT_IN:
            case LedgerPostingType::SalesTax_IN:
            case LedgerPostingType::Excise_IN:
            case LedgerPostingType::ServiceTax_IN:
            case LedgerPostingType::Customs_IN:
                ret = true;
                break;
            default:
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNoTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verifies whether the corresponding records from the sales tax group and the item sales tax group
    ///    have a common tax code.
    /// </summary>
    /// <param name="_mainAccount">
    ///    The general ledger module account record for which the check will be done.
    /// </param>
    /// <param name="_taxGroup">
    ///    The tax group number to check.
    /// </param>
    /// <param name="_taxItemGroup">
    ///    The tax item group number to check.
    /// </param>
    /// <param name="_taxCode">
    ///    The tax code number to check.
    /// </param>
    /// <returns>
    ///    true if the tax code is specified, but it is not required for the posting account; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    If the tax code cannot be found, this method will check if the general ledger account requires a
    ///    tax code specified on the transaction.
    /// </remarks>
    static public boolean checkNoTax(MainAccount _mainAccount,
                              TaxGroup _taxGroup,
                              TaxItemGroup _taxItemGroup,
                              TaxCode      _taxCode = '')
    {
        TaxGroupData            taxGroupData;
        TaxOnItem               taxOnItem;
        boolean                 returnValue = true;
        MainAccountLegalEntity  mainAccountLegalEntity = MainAccountLegalEntity::findByMainAccountLegalEntity(_mainAccount.RecId, CompanyInfo::findDataArea(curext()).RecId);

        if (mainAccountLegalEntity.ValidateTaxCode)
        {
            if (_taxCode)
            {
                returnValue = Tax::checkTaxCode(_mainAccount, _taxCode);
            }
            else
            {
                select TaxCode, TaxGroup from taxGroupData
                    where taxGroupData.TaxGroup == _taxGroup
                    join TaxItemGroup, TaxCode from taxOnItem
                        where taxOnItem.TaxItemGroup == _taxItemGroup
                            && taxOnItem.TaxCode == taxGroupData.TaxCode;

                if (!taxGroupData.TaxCode)
                {
                    returnValue = Tax::checkTaxCode(_mainAccount, '');
                }
            }
        }
        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verifies that the user entered a correct tax code.
    /// </summary>
    /// <param name="_mainAccount">
    ///    The general ledger table buffer for which the check will be done.
    /// </param>
    /// <param name="_taxCode">
    ///    The tax code for which the check will be done.
    /// </param>
    /// <returns>
    ///    true if the validation is successful; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The value of the tax code will be compared by the method specified in the <c>MandatoryTaxCode</c>
    ///    field. The tax code is specified by the user on the transaction record only. The transaction tax
    ///    code will be compared to the code specified on the account record in the table. The transaction tax
    ///    code will be looked up in the <c>MainAccountLegalEntity</c> table list.
    /// </remarks>
    static public boolean checkTaxCode(MainAccount _mainAccount, TaxCode _taxCode)
    {
        boolean                 returnValue = true;
        DataAreaId              companyId;
        MainAccountLegalEntity  mainAccountLegalEntity = MainAccountLegalEntity::findByMainAccountLegalEntity(_mainAccount.RecId, CompanyInfo::findDataArea(curext()).RecId);

        switch (mainAccountLegalEntity.ValidateTaxCode)
        {
            case FieldControl::FillIn:
                                                                                if (! _taxCode)
                {
                    returnValue = checkFailed(strFmt("@SYS113280", _mainAccount.MainAccountId));
                }
                break;

            case FieldControl::Table:
                                                                                if (_taxCode != mainAccountLegalEntity.TaxCode)
                {
                    if (mainAccountLegalEntity.TaxCode)
                    {
                        returnValue = checkFailed(strFmt("@SYS113281",

                                          mainAccountLegalEntity.TaxCode,
                                          _mainAccount.MainAccountId));
                    }
                    else
                    {
                        returnValue = checkFailed(strFmt("@SYS113282",
                                          _mainAccount.MainAccountId));
                    }
                }
                break;

            case FieldControl::List:
                // Verify that the company exists.
                if (xDataArea::exist(_mainAccount.company()))
                {
                    companyId = _mainAccount.company();
                }
                else
                {
                    companyId = curext();
                }

                changecompany(companyId)
                {
                    if (!MainAccountControlTaxCode::exist(MainAccount::findByMainAccountId(_mainAccount.MainAccountId).RecId, _taxCode))
                    {
                        returnValue = checkFailed(strFmt("@SYS113283",

                                          _taxCode,
                                          _mainAccount.MainAccountId));
                    }
                }
                break;
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVATChargeSource_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if tax codes calculated based on tax groups mathes given VAT charge source
    /// </summary>
    /// <param name="_source">
    /// VAT charge source to check
    /// </param>
    /// <param name="_taxGroup">
    /// Tax group to check
    /// </param>
    /// <param name="_taxItemGroup">
    /// Tax item group to check
    /// </param>
    /// <returns>
    /// True if all tax codes has specified vat charge source; Otherwise false
    /// </returns>
    static public boolean checkVATChargeSource_RU(VATChargeSource_RU _source,
                                                  TaxGroup           _taxGroup,
                                                  TaxItemGroup       _taxItemGroup)
    {
        TaxTable     taxTable;
        TaxGroupData taxGroup;
        TaxOnItem    taxItem;
        boolean      ret = true;

        select firstonly RecId, TaxCode from taxTable

            where taxTable.vatChargeSource_RU != _source
        exists join taxGroup
            where taxGroup.TaxGroup    == _taxGroup     &&
                    taxGroup.TaxCode   == taxTable.TaxCode
        exists join taxItem
            where taxItem.TaxItemGroup == _taxItemGroup &&
                    taxItem.TaxCode    == taxTable.TaxCode;

        if (taxTable.RecId)
        {
            ret = checkFailed(strFmt("@GLS112720", taxTable.TaxCode, enum2str(_source)));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static Tax construct(NoYes  _post = NoYes::No)
    {
        Tax tax;
        ;

        tax = new Tax();

        tax.parmPost(_post);

        tax.setCashDiscount(0, 0);

        return tax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>customsApplyExciseTaxTotal_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the customs apply excise tax total.
    /// </summary>
    /// <param name="_ledger">
    /// The ledger journal transaction.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxAmountCur</c> class.
    /// </returns>
    static TaxAmountCur customsApplyExciseTaxTotal_IN(LedgerJournalTrans _ledger)
    {
        TaxTrans taxTrans;
        TaxTrans_W taxTrans_W;

        taxTrans.selectLocked(false);

        select sum(SourceTaxAmountCur),
               sum(SourceRegulateAmountCur)
            from taxTrans
            where taxTrans.Voucher        == _ledger.Voucher
            join RecId, TaxTrans from taxTrans_W
                where taxTrans_W.TaxTrans == taxTrans.RecId
                && taxTrans_W.ApplyExcise_IN == NoYes::Yes;

        return (taxTrans.SourceTaxAmountCur + taxTrans.SourceRegulateAmountCur);
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineTaxDirection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines <c>TaxDirection</c>.
    /// </summary>
    /// <param name = "_taxModuleType">The <c>TaxModuleType</c> provided.</param>
    /// <param name = "_taxGroupData">The <c>TaxGroupData</c> provided, ignored for <c>TaxModuleType::Voucher</c>.</param>
    /// <param name = "_taxDirection">The default <c>TaxDirection</c> provided, ignored for any type other than <c>TaxModuleType::Voucher</c>.</param>
    /// <returns>The <c>TaxDirection</c> determined.</returns>
    public static TaxDirection determineTaxDirection(
        TaxModuleType   _taxModuleType,
        TaxGroupData    _taxGroupData,
        TaxDirection    _taxDirection = TaxDirection::OutgoingTax)
    {
        if (_taxModuleType == TaxModuleType::Voucher)
        {
            if (prmisDefault(_taxDirection))
            {
                throw error(Error::wrongUseOfFunction(funcName()));
            }
            return _taxDirection;
        }

        return Tax::determineTaxDirectionInternal(
            _taxModuleType,
            _taxGroupData.TaxCode,
            _taxGroupData.ExemptTax,
            _taxGroupData.ReverseCharge_W,
            _taxGroupData.UseTax,
            _taxGroupData.IntracomVAT);
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineTaxDirectionInternal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines <c>TaxDirection</c>.
    /// </summary>
    /// <param name = "_taxModuleType">The tax module type.</param>
    /// <param name = "_taxCode">The tax code.</param>
    /// <param name = "_taxExemptTax">The option of exempt tax.</param>
    /// <param name = "_taxReverseCharge">The option of reverse charge.</param>
    /// <param name = "_taxUseTax">The option of use tax.</param>
    /// <param name = "_intracomVAT">The option of intracom VAT.</param>
    /// <param name = "_negativeTax">The option to allow negative tax rate.</param>
    /// <returns>The <c>TaxDirection</c> determined.</returns>
    internal static TaxDirection determineTaxDirectionInternal(
        TaxModuleType _taxModuleType,
        TaxCode _taxCode,
        TaxExemptTax _taxExemptTax,
        TaxReverseCharge _taxReverseCharge,
        TaxUseTax _taxUseTax,
        NoYes _intracomVAT,
        UnknownNoYes _negativeTax = UnknownNoYes::Unknown)
    {
        TaxDirection    taxDirection;

        switch (_taxModuleType)
        {
            case TaxModuleType::Sales,
                 TaxModuleType::SalesInvoice,
                 TaxModuleType::CustInterestNote,
                 TaxModuleType::CustCollectionLetter,
                 TaxModuleType::Project,
                 TaxModuleType::ProjectInvoice,
                 TaxModuleType::Retail,
                 TaxModuleType::FreeTxtInvoice:

                if (_taxExemptTax == NoYes::No ||
                    _taxReverseCharge == NoYes::Yes)
                {
                    if (BrazilParameters::isEnabled() &&
                        TaxTable::find(_taxCode).RetainedTax_BR)
                    {
                        taxDirection = TaxDirection::IncomingTax;
                        break;
                    }

                    taxDirection = TaxDirection::OutgoingTax;
                    break;
                }

                taxDirection = TaxDirection::TaxExemptSales;
                break;

            case TaxModuleType::Purch,
                 TaxModuleType::PurchInvoice:

                if (_taxUseTax == NoYes::Yes)
                {
                    taxDirection = TaxDirection::UseTax;
                    break;
                }

                if (_taxExemptTax == NoYes::No)
                {
                    if ((_intracomVAT == NoYes::Yes && VendParameters::find().IntracomVAT) ||
                        (_taxReverseCharge == NoYes::Yes && (
                            _negativeTax == UnknownNoYes::Yes ||
                            (_negativeTax == UnknownNoYes::Unknown && TaxTable::find(_taxCode).NegativeTax == NoYes::Yes))))
                    {
                        taxDirection = TaxDirection::OutgoingTax;
                        break;
                    }

                    if (BrazilParameters::isEnabled() &&
                        TaxTable::find(_taxCode).RetainedTax_BR)
                    {
                        taxDirection = TaxDirection::OutgoingTax;
                        break;
                    }

                    taxDirection = TaxDirection::IncomingTax;
                    break;
                }

                taxDirection = TaxDirection::TaxExemptPurchase;
                break;

            case TaxModuleType::TransferOrderShipment:

                if (_taxExemptTax == NoYes::No || _taxReverseCharge == NoYes::Yes)
                {
                    taxDirection = taxDirection::OutgoingTax;
                    break;
                }

                taxDirection = TaxDirection::TaxExemptSales;
                break;

            case TaxModuleType::TransferOrderReceive:

                if (_taxUseTax == NoYes::Yes)
                {
                    taxDirection = TaxDirection::UseTax;
                    break;
                }

                if (_taxExemptTax == NoYes::Yes)
                {
                    taxDirection = TaxDirection::TaxExemptPurchase;
                    break;
                }

                if (_taxReverseCharge == NoYes::Yes && (
                    _negativeTax == UnknownNoYes::Yes ||
                    (_negativeTax == UnknownNoYes::Unknown && TaxTable::find(_taxCode).NegativeTax == NoYes::Yes)))
                {
                    taxDirection = TaxDirection::OutgoingTax;
                    break;
                }

                taxDirection = TaxDirection::IncomingTax;
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return taxDirection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineTaxValue_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the table buffer and get the required TaxValue.
    /// </summary>
    /// <param name="_taxCode">
    /// The field is used to find the record.
    /// </param>
    /// <param name="_salesPurchJournalLine">
    /// The map is used to get the brecord.
    /// </param>
    /// <returns>
    /// Returns the TaxValue.
    /// </returns>
    static TaxValue determineTaxValue_IN(TaxCode                     _taxCode,
                                         SalesPurchJournalLine      _salesPurchJournalLine)
    {
        TaxTrans            taxTrans;
        CustInvoiceJour     custInvoiceJour;
        VendInvoiceJour     vendInvoiceJour;
        TaxValue            taxValue;
        SalesLine           salesLineLoc;
        SalesLine_IN        salesLineLoc_IN;
        PurchLine           purchLineLoc;
        PurchLine_IN        purchLineLoc_IN;
        SalesLine           salesLineICompany;
        SalesLine           salesLineOriginal;
        InventRefTransId    inventRefId;

        ProjProposalJour            projProposalJourLoc;
        ProjProposalEmpl            projProposalEmpl;
        ProjEmplTransSale           projEmplTransSale;
        ProjProposalEmplDetail      projProposalEmplDetail;

        ProjProposalCost            projProposalCost;
        ProjCostTransSale           projCostTransSale;
        ProjProposalCostDetail      projProposalCostDetail;

        ProjProposalItem            projProposalItem;
        ProjItemTransSale           projItemTransSale;
        ProjProposalItemDetail      projProposalItemDetail;

        ProjProposalRevenue         projProposalRevenue;
        ProjRevenueTransSale        projRevenueTransSale;
        ProjProposalRevenueDetail   projProposalRevenueDetail;

        ProjProposalOnAcc           projProposalOnAcc;
        ProjOnAccTransSale          projOnAccTransSale;
        ProjProposalOnAccDetail     projProposalOnAccDetail;

        if (_salesPurchJournalLine.SourceTableId == tableNum(SalesLine))
        {
            salesLineLoc = SalesLine::findRecId(_salesPurchJournalLine.SourceRecId);
            salesLineLoc_IN = salesLineLoc.salesLine_IN();
            select custInvoiceJour
                where custInvoiceJour.SalesId       == salesLineLoc.InventRefId
                   && custInvoiceJour.LedgerVoucher == salesLineLoc_IN.TaxWithholdVoucher;
            if (custInvoiceJour)
            {
                select taxTrans
                    where taxTrans.Voucher      == custInvoiceJour.InvoiceId
                    &&  taxTrans.TransDate      == custInvoiceJour.InvoiceDate
                    &&  taxTrans.TaxCode        == _taxCode
                    &&   taxTrans.TaxItemGroup  == _salesPurchJournalLine.TaxItemGroup;
                if (taxTrans)
                {
                    taxValue = taxTrans.TaxValue;
                }
            }

            if (salesLineLoc.SalesType == SalesType::ReturnItem
                && (SalesTable::find(salesLineLoc.SalesId).InterCompanyDirectDelivery
                || SalesTable::find(salesLineLoc.SalesId).InterCompanyDirectDeliveryOrig)
                || (!custInvoiceJour
                || !salesLineLoc.InventRefId))
            {
                if (salesLineLoc.InterCompanyInventTransId)
                {
                    changecompany(SalesTable::find(salesLineLoc.SalesId).InterCompanyCompanyId)
                    {
                        select InventTransIdReturn
                            from salesLineICompany
                            where salesLineICompany.InventRefTransId == salesLineLoc.InterCompanyInventTransId;
                        if (salesLineICompany)
                        {
                            inventRefId = SalesLine::findInventTransId(salesLineICompany.InventTransIdReturn).InventRefTransId;
                        }
                    }
                    select InventTransId
                        from salesLineOriginal
                        where salesLineOriginal.InterCompanyInventTransId == inventRefId;
                    if (salesLineOriginal)
                    {
                        select firstonly InvoiceId, InvoiceDate
                            from custInvoiceJour
                            where custInvoiceJour.SalesId       == SalesLine::findInventTransId(salesLineOriginal.InventTransId).SalesId
                               && custInvoiceJour.LedgerVoucher == salesLineLoc_IN.TaxWithholdVoucher;
                    }
                }
                else
                {
                    select firstonly InvoiceId, InvoiceDate
                        from custInvoiceJour
                        where custInvoiceJour.SalesId       == SalesLine::findInventTransId(salesLineLoc.InventTransIdReturn).SalesId
                           && custInvoiceJour.LedgerVoucher == salesLineLoc_IN.TaxWithholdVoucher;
                }
                if (custInvoiceJour)
                {
                    select firstonly TaxValue
                        from taxTrans
                        where taxTrans.Voucher      == custInvoiceJour.InvoiceId
                           && taxTrans.TransDate    == custInvoiceJour.InvoiceDate
                           && taxTrans.TaxCode      == _taxCode
                           && taxTrans.TaxItemGroup == _salesPurchJournalLine.TaxItemGroup;
                    if (taxTrans)
                    {
                        taxValue = taxTrans.TaxValue;
                    }
                }
            }
        }
        else if (_salesPurchJournalLine.SourceTableId == tableNum(PurchLine)
                || _salesPurchJournalLine.SourceTableId == tableNum(VendInvoiceInfoLine))
        {
            if (_salesPurchJournalLine.SourceTableId == tableNum(VendInvoiceInfoLine))
            {
                purchLineLoc = PurchLine::findRecId(VendInvoiceInfoLine::findRecId(_salesPurchJournalLine.SourceRecId).PurchLineRecId);
            }
            else
            {
                purchLineLoc = PurchLine::findRecId(_salesPurchJournalLine.SourceRecId);
            }
            purchLineLoc_IN = purchLineLoc.purchLine_IN();

            select vendInvoiceJour
                where vendInvoiceJour.PurchId       == purchLineLoc.InventRefId
                   && vendInvoiceJour.LedgerVoucher == purchLineLoc_IN.TaxWithholdVoucher;
            if (vendInvoiceJour)
            {
                select taxTrans
                    where taxTrans.Voucher      == vendInvoiceJour.LedgerVoucher
                       && taxTrans.TransDate    == vendInvoiceJour.InvoiceDate
                       && taxTrans.TaxCode      == _taxCode
                       && taxTrans.TaxItemGroup == _salesPurchJournalLine.TaxItemGroup;
                if (taxTrans)
                {
                    taxValue = taxTrans.TaxValue;
                }
            }

            if (purchLineLoc.PurchaseType == PurchaseType::ReturnItem
                && PurchTable::find(purchLineLoc.PurchId).InterCompanyDirectDelivery
                && !vendInvoiceJour)
            {
                select firstonly LedgerVoucher, InvoiceDate
                    from vendInvoiceJour
                    where vendInvoiceJour.PurchId       == PurchLine::findInventTransId(SalesLine::findInventTransId(SalesLine::findInventTransId(purchLineLoc.InventRefTransId).InventTransIdReturn).InventRefTransId).PurchId
                       && vendInvoiceJour.LedgerVoucher == purchLineLoc_IN.TaxWithholdVoucher;
                if (vendInvoiceJour)
                {
                    select firstonly TaxValue
                        from taxTrans
                        where taxTrans.Voucher      == vendInvoiceJour.LedgerVoucher
                           && taxTrans.TransDate    == vendInvoiceJour.InvoiceDate
                           && taxTrans.TaxCode      == _taxCode
                           && taxTrans.TaxItemGroup == _salesPurchJournalLine.TaxItemGroup;
                    if (taxTrans)
                    {
                        taxValue = taxTrans.TaxValue;
                    }
                }
            }
        }
        else if (_salesPurchJournalLine.SourceTableId == tableNum(ProjEmplTrans))
        {
            select LedgerVoucher, InvoiceDate from projProposalJourLoc
                join RecId from projEmplTransSale
                    where projProposalJourLoc.ProposalId == projEmplTransSale.ProjProposalId_IN
                join RecId from projProposalEmplDetail
                    where projEmplTransSale.RecId == projProposalEmplDetail.SaleRefRecId
                join RecId from projProposalEmpl
                    where projProposalEmplDetail.ProposalRefRecId == projProposalEmpl.RecId &&
                          projProposalEmpl.TransId == _salesPurchJournalLine.SourceId;

            if (projProposalJourLoc)
            {
                select firstonly TaxValue
                    from taxTrans
                    where taxTrans.Voucher      == projProposalJourLoc.LedgerVoucher
                       && taxTrans.TransDate    == projProposalJourLoc.InvoiceDate
                       && taxTrans.TaxCode      == _taxCode
                       && taxTrans.TaxItemGroup == _salesPurchJournalLine.TaxItemGroup;
                if (taxTrans)
                {
                    taxValue = taxTrans.TaxValue;
                }
            }
        }
        else if (_salesPurchJournalLine.SourceTableId == tableNum(ProjItemTrans))
        {
            select LedgerVoucher, InvoiceDate from projProposalJourLoc
                join RecId from projItemTransSale
                    where projProposalJourLoc.ProposalId == projItemTransSale.ProjProposalId_IN
                join RecId from projProposalItemDetail
                    where projItemTransSale.RecId == projProposalItemDetail.SaleRefRecId
                join RecId from projProposalItem
                    where projProposalItemDetail.ProposalRefRecId == projProposalItem.RecId &&
                          projProposalItem.ProjTransId == _salesPurchJournalLine.SourceId;

            if (projProposalJourLoc)
            {
                select firstonly TaxValue
                    from taxTrans
                    where taxTrans.Voucher      == projProposalJourLoc.LedgerVoucher
                       && taxTrans.TransDate    == projProposalJourLoc.InvoiceDate
                       && taxTrans.TaxCode      == _taxCode
                       && taxTrans.TaxItemGroup == _salesPurchJournalLine.TaxItemGroup;
                if (taxTrans)
                {
                    taxValue = taxTrans.TaxValue;
                }
            }
        }
        else if (_salesPurchJournalLine.SourceTableId == tableNum(ProjRevenueTrans))
        {
            select LedgerVoucher, InvoiceDate from projProposalJourLoc
                join RecId from projRevenueTransSale
                    where projProposalJourLoc.ProposalId == projRevenueTransSale.ProjProposalId_IN
                join RecId from projProposalRevenueDetail
                    where projRevenueTransSale.RecId == projProposalRevenueDetail.SaleRefRecId
                join RecId from projProposalRevenue
                    where projProposalRevenueDetail.ProposalRefRecId == projProposalRevenue.RecId &&
                          projProposalRevenue.TransId == _salesPurchJournalLine.SourceId;

            if (projProposalJourLoc)
            {
                select firstonly TaxValue
                    from taxTrans
                    where taxTrans.Voucher      == projProposalJourLoc.LedgerVoucher
                       && taxTrans.TransDate    == projProposalJourLoc.InvoiceDate
                       && taxTrans.TaxCode      == _taxCode
                       && taxTrans.TaxItemGroup == _salesPurchJournalLine.TaxItemGroup;
                if (taxTrans)
                {
                    taxValue = taxTrans.TaxValue;
                }
            }
        }
        else if (_salesPurchJournalLine.SourceTableId == tableNum(ProjOnAccTrans))
        {
            select LedgerVoucher, InvoiceDate from projProposalJourLoc
                join RecId from projOnAccTransSale
                    where projProposalJourLoc.ProposalId == projOnAccTransSale.ProjProposalId_IN
                join RecId from projProposalOnAccDetail
                    where projOnAccTransSale.RecId == projProposalOnAccDetail.SaleRefRecId
                join RecId from projProposalOnAcc
                    where projProposalOnAccDetail.ProposalRefRecId == projProposalOnAcc.RecId &&
                          projProposalOnAcc.TransId == _salesPurchJournalLine.SourceId;

            if (projProposalJourLoc)
            {
                select firstonly TaxValue
                    from taxTrans
                    where taxTrans.Voucher      == projProposalJourLoc.LedgerVoucher
                       && taxTrans.TransDate    == projProposalJourLoc.InvoiceDate
                       && taxTrans.TaxCode      == _taxCode
                       && taxTrans.TaxItemGroup == _salesPurchJournalLine.TaxItemGroup;
                if (taxTrans)
                {
                    taxValue = taxTrans.TaxValue;
                }
            }
        }
        else if (_salesPurchJournalLine.SourceTableId == tableNum(ProjCostTrans))
        {
            select LedgerVoucher, InvoiceDate from projProposalJourLoc
                join RecId from projCostTransSale
                    where projProposalJourLoc.ProposalId == projCostTransSale.ProjProposalId_IN
                join RecId from projProposalCostDetail
                    where projCostTransSale.RecId == projProposalCostDetail.SaleRefRecId
                join RecId from projProposalCost
                    where projProposalCostDetail.ProposalRefRecId == projProposalCost.RecId &&
                          projProposalCost.TransId == _salesPurchJournalLine.SourceId;

            if (projProposalJourLoc)
            {
                select firstonly TaxValue
                    from taxTrans
                    where taxTrans.Voucher      == projProposalJourLoc.LedgerVoucher
                       && taxTrans.TransDate    == projProposalJourLoc.InvoiceDate
                       && taxTrans.TaxCode      == _taxCode
                       && taxTrans.TaxItemGroup == _salesPurchJournalLine.TaxItemGroup;
                if (taxTrans)
                {
                    taxValue = taxTrans.TaxValue;
                }
            }
        }
        return taxValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>evaluate_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Evaluation.
    /// </summary>
    /// <param name="_expression">
    /// The evaluation expression.
    /// </param>
    /// <returns>
    /// The evaluation result.
    /// </returns>
    public static str evaluate_IN(str _expression)
    {
        real result;
        Stack stackOper = new Stack();
        container conPostExp;

        int expLen;
        int i;
        int numStartPos = 1;
        str curChar, previousChar;
        str topOper;
        real numL;
        real numR;

        // define priority for operators
        str plus = '+';
        str minus = '-';
        str divide = '/';
        str multiply = '*';

        Map map = new Map(Types::String, Types::Integer);
        map.insert('+', 1);
        map.insert('-', 1);
        map.insert('*', 2);
        map.insert('/', 2);
        map.insert('(', 3);

        _expression = strRem(_expression, " ");

        expLen = strLen(_expression);
        for(i = 1; i <= expLen; i++)
        {
            curChar = subStr(_expression, i, 1);
            if (curChar == minus)
            {
                if ((previousChar == '+' || previousChar == '('))
                {
                    _expression = strIns(_expression, '0', i);
                    i++;
                }
                else if (previousChar == '-')
                {
                    _expression = strDel(_expression, i-1, 2);
                    _expression = strIns(_expression, '+', i-1);
                    i--;
                }
            }
            previousChar = curChar;
        }


        // change to postfix expression
        expLen = strLen(_expression);
        for(i = 1; i <=expLen; i++)
        {
            curChar = subStr(_expression, i, 1);
            if (curChar == plus || curChar == minus ||curChar == divide ||curChar == multiply || curChar == ')' || curChar == '(')
            {
                if (i > numStartPos)
                {
                    conPostExp += subStr(_expression, numStartPos, i - numStartPos);
                }

                if (curChar == '(')
                {
                    stackOper.push([curChar]);
                }
                else if (curChar == ')')
                {
                    while (stackOper.qty() > 0)
                    {
                        topOper = conPeek(stackOper.pop(), 1);
                        if (topOper == '(')
                        {
                            break;
                        }
                        conpostExp += topOper;
                    }
                }
                else
                {
                    while (stackOper.qty() > 0)
                    {
                        topOper = conPeek(stackOper.pop(), 1);
                        if (topOper == '(' || map.lookup(curChar) > map.lookup(topOper))
                        {
                            stackOper.push([topOper]);
                            break;
                        }
                        conpostExp += topOper;
                    }
                    stackOper.push([curChar]);
                }
                numStartPos = i + 1;
            }
            if (i == expLen && curChar != ')' && expLen >= numStartPos)
            {
                conPostExp +=  subStr(_expression, numStartPos, expLen - numStartPos + 1);
            }
        }

        while (stackOper.qty() > 0)
        {
            conpostExp += conPeek(stackOper.pop(), 1);
        }

        // calculate the postfix expression
        for( i =3; i <= conLen(conPostExp) && conLen(conPostExp) >= 3; i++)
        {
            curChar = conPeek(conPostExp, i);
            if (curChar == plus || curChar == minus ||curChar == divide ||curChar == multiply)
            {
                numL = conPeek(conPostExp, i - 2);
                numR = conPeek(conPostExp, i - 1);

                if (curChar == plus)
                result = numL + numR;
                else if (curChar == minus)
                result = numL - numR;
                else if (curChar == divide)
                result = numL / numR;
                else
                result = numL * numR;

                //
                conPostExp = conDel(conPostExp, i-2, 3);
                conPostExp = conIns(conPostExp, i-2, result);
                i = i - 2;
            }
        }

        if (conLen(conPostExp) == 1)
        {
            result = conPeek(conPostExp, 1);
        }

        return num2str(result, 0, 15, 1, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>exciseNumberSequence_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Checks whether Number sequence is defined for ECC number
    /// </summary>
    /// <param name="_taxRegistrationNumberTableRecId">
    ///   RecID value of Registration number from TaxRegistrationNumbers_IN table
    /// </param>
    /// <param name="_exciseRecordType">
    ///   excise record type defined on line level
    /// </param>
    /// <param name="_isQtyRegister">
    ///   Value to indicate whether is Qty register or not.
    /// </param>
    /// <param name="_directSettlement">
    ///   Direct settlement defined on line level
    /// </param>
    /// <param name="_dsa">
    ///  Value to indicate whether is DSA or not.
    /// </param>
    /// <remarks>
    ///   Throws warning message when ECC number is not filled
    ///   Checks whether Number sequence for particular ECC number
    /// </remarks>
    /// <returns>
    /// returns either warning message or Number sequence defined for ECC number.
    /// </returns>
    public static Num exciseNumberSequence_IN(RefRecId                 _taxRegistrationNumberTableRecId,
                                              ExciseRecordType_IN      _exciseRecordType,
                                              boolean                  _isQtyRegister,
                                              DirectSettlement_IN      _directSettlement = DirectSettlement_IN::None,
                                              NoYes                    _dsa = NoYes::No)
    {
        Num     numberSeq;

        if (!_taxRegistrationNumberTableRecId)
        {
            throw warning (strFmt("@SYS26332", "@GLS5102"));
        }
        if (_directSettlement == DirectSettlement_IN::None)
        {
            if (_isQtyRegister)
            {
                switch (_exciseRecordType)
                {
                    case ExciseRecordType_IN::RG23A :
                        numberSeq = NumberSeq::newGetNumFromCode(NumberSequenceTable::find(ExciseNumSequenceRef_IN::findByRegistrationNumber(
                                                                _taxRegistrationNumberTableRecId, ExciseReference_IN::RG23AI).NumberSequenceTable).NumberSequence, NumberSeqScopeFactory::createDefaultScope(), true, false).num();
                        break;
                    case ExciseRecordType_IN::RG23C :
                        numberSeq = NumberSeq::newGetNumFromCode(NumberSequenceTable::find(ExciseNumSequenceRef_IN::findByRegistrationNumber(
                                                            _taxRegistrationNumberTableRecId, ExciseReference_IN::RG23CI).NumberSequenceTable).NumberSequence, NumberSeqScopeFactory::createDefaultScope(), true, false).num();
                        break;
                    default :
                        break;
                }
            }
            else
            {
                switch (_exciseRecordType)
                {
                    case ExciseRecordType_IN::RG23A :
                        numberSeq = NumberSeq::newGetNumFromCode(NumberSequenceTable::find(ExciseNumSequenceRef_IN::findByRegistrationNumber(
                                                            _taxRegistrationNumberTableRecId, ExciseReference_IN::RG23AII).NumberSequenceTable).NumberSequence, NumberSeqScopeFactory::createDefaultScope(),true, false).num();
                        break;
                    case ExciseRecordType_IN::RG23C :
                        numberSeq = NumberSeq::newGetNumFromCode(NumberSequenceTable::find(ExciseNumSequenceRef_IN::findByRegistrationNumber(
                                                            _taxRegistrationNumberTableRecId, ExciseReference_IN::RG23CII).NumberSequenceTable).NumberSequence, NumberSeqScopeFactory::createDefaultScope(), true, false).num();
                        break;
                    case ExciseRecordType_IN::RG23D :
                        numberSeq = NumberSeq::newGetNumFromCode(NumberSequenceTable::find(ExciseNumSequenceRef_IN::findByRegistrationNumber(
                                                            _taxRegistrationNumberTableRecId, ExciseReference_IN::RG23D).NumberSequenceTable).NumberSequence, NumberSeqScopeFactory::createDefaultScope(), true, false).num();
                        break;
                    case ExciseRecordType_IN::None :
                        if (_dsa)
                        {
                            numberSeq = NumberSeq::newGetNumFromCode(NumberSequenceTable::find(ExciseNumSequenceRef_IN::findByRegistrationNumber(
                                                            _taxRegistrationNumberTableRecId, ExciseReference_IN::DSA).NumberSequenceTable).NumberSequence, NumberSeqScopeFactory::createDefaultScope(), true, false).num();
                        }
                        break;
                    default :
                        break;
                }
            }
        }
        else
        {
            switch (_directSettlement)
            {
                case DirectSettlement_IN::RG23A :
                    numberSeq = NumberSeq::newGetNumFromCode(NumberSequenceTable::find(ExciseNumSequenceRef_IN::findByRegistrationNumber(
                                                            _taxRegistrationNumberTableRecId, ExciseReference_IN::RG23AII).NumberSequenceTable).NumberSequence, NumberSeqScopeFactory::createDefaultScope(), true, false).num();
                    break;
                case DirectSettlement_IN::RG23C :
                    numberSeq = NumberSeq::newGetNumFromCode(NumberSequenceTable::find(ExciseNumSequenceRef_IN::findByRegistrationNumber(
                                                            _taxRegistrationNumberTableRecId, ExciseReference_IN::RG23CII).NumberSequenceTable).NumberSequence, NumberSeqScopeFactory::createDefaultScope(), true, false).num();
                    break;
                case DirectSettlement_IN::PLA :
                    numberSeq = NumberSeq::newGetNumFromCode(NumberSequenceTable::find(ExciseNumSequenceRef_IN::findByRegistrationNumber(
                                                            _taxRegistrationNumberTableRecId, ExciseReference_IN::PLA).NumberSequenceTable).NumberSequence, NumberSeqScopeFactory::createDefaultScope(), true, false).num();
                    break;
                default :
                    break;
            }
        }
        return numberSeq;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdvanceAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets advance amount.
    /// </summary>
    /// <param name="_taxCode">
    /// The tax code.
    /// </param>
    /// <param name="_headingTableId">
    /// The heading table id.
    /// </param>
    /// <param name="_headingRecId">
    /// The heading RecId.
    /// </param>
    /// <param name="_ledgerJournalService">
    /// The ledger journal service.
    /// </param>
    /// <param name="_common">
    /// The table bufer passed in.
    /// </param>
    /// <returns>
    /// The advance amount.
    /// </returns>
    public static container getAdvanceAmount_IN(
        TaxCode                 _taxCode,
        TableId                 _headingTableId,
        RefRecId                _headingRecId,
        LedgerJournalTrans      _ledgerJournalService = null,
        Common                  _common = null)
    {
        SpecTrans                               specTrans;
        CustTransOpen                           custTransOpen;
        CustTrans                               custTrans;
        LedgerTransVoucherLink                  ledgerTransVoucherLinkRel;
        LedgerTransVoucherLink                  ledgerTransVoucherLink;
        TaxTrans                                taxTrans;
        TaxTrans_W                           taxTrans_W;
        VendTransOpen                           vendTransOpen;
        VendTrans                               vendTrans;
        TaxUncommitted                          currentTaxUnCommitted;
        TaxTrans                                currentTaxTrans;
        TmpTaxWorkTrans                         currentTmpTaxWorkTrans;
        AmountCur                               amount;
        AmountCur                               baseAmount;
        AmountCur                               baseAmountProrated;
        TaxDirection                            taxDirection;
        DataAreaId                              headingCompany;
        Common                                  headingRecord;
        SysDictTable                            dictTable;
        PurchTable                              purchTable;
        VendTable                               vendTable;
        CustTable                               custTable;
        CurrencyCode                            sourceCurrencyCode = Ledger::accountingCurrency();
        CurrencyExchangeHelper                  currencyExchangeHelper = CurrencyExchangeHelper::construct();
        SubledgerVoucherGeneralJournalEntry     subledgerVoucherGeneralJournalEntry;
        GeneralJournalAccountEntry              generalJournalAccountEntry;
        GeneralJournalEntry                     generalJournalEntry;
        TaxInformationVendTable_IN              taxInformationVendTableLoc;
        TaxInformationCustTable_IN              taxInformationCustTableLoc;
        TableId                                 headingTableId = _headingTableId;
        RefRecId                                headingRecId   = _headingRecId;
        CustInvoiceJour                         custInvoiceJour;
        CustInvoiceTable                        custInvoiceTable;
        SourceDocumentLine                      sourceDocumentLine;
        AmountCur                               invoiceAmountForSettlement;
        AmountCur                               totalPaymentAmount;
        boolean                                 previousSettlemnt;

        void sumPaymentAmount()
        {
            // Get the voucher transactions for payment related to tax (i.e related voucher for payment)
            while select Voucher,TransDate from ledgerTransVoucherLinkRel group by Voucher,TransDate
                where ledgerTransVoucherLinkRel.VoucherGroupId == ledgerTransVoucherLink.VoucherGroupId &&
                      (ledgerTransVoucherLinkRel.Voucher != ledgerTransVoucherLink.Voucher ||
                      ledgerTransVoucherLinkRel.TransDate != ledgerTransVoucherLink.TransDate)
            {
                // Get the tax amount from payment using the related voucher
                while select sum(SourceBaseAmountCurRegulated),sum(SourceBaseAmountCur), sum(SourceRegulateAmountCur), sum(SourceTaxAmountCur), sum(TaxInCostPrice), SourceCurrencyCode from taxTrans
                    group by SourceCurrencyCode
                    where taxTrans.Voucher == ledgerTransVoucherLinkRel.Voucher &&
                          taxTrans.TransDate == ledgerTransVoucherLinkRel.TransDate &&
                          taxTrans.TaxCode == _taxCode &&
                          taxTrans.TaxDirection == taxDirection &&
                          taxTrans.TaxOrigin == TaxOrigin::Tax
                    join RecId, TaxTrans from taxTrans_W
                    where taxTrans_W.TaxTrans == taxTrans.RecId
                        && taxTrans_W.TaxType_IN == TaxType_IN::ServiceTax
                {
                    totalPaymentAmount += LedgerJournalTrans::findJournalForVoucher(ledgerTransVoucherLink.Voucher , ledgerTransVoucherLink.TransDate).amount();

                    if (sourceCurrencyCode == taxTrans.SourceCurrencyCode)
                    {
                        if (taxTrans.SourceRegulateAmountCur)
                        {
                            amount = CurrencyExchangeHelper::amount(amount + taxTrans.SourceRegulateAmountCur - taxTrans.TaxInCostPrice, sourceCurrencyCode);
                        }
                        if (taxTrans.SourceBaseAmountCurRegulated)
                        {
                            baseAmount = CurrencyExchangeHelper::amount(baseAmount + taxTrans.SourceBaseAmountCurRegulated, sourceCurrencyCode);
                        }
                        else
                        {
                            baseAmount = CurrencyExchangeHelper::amount(baseAmount + taxTrans.SourceBaseAmountCur, sourceCurrencyCode);
                        }
                    }
                    else
                    {
                        if (taxTrans.SourceRegulateAmountCur)
                        {
                            amount = currencyExchangeHelper.calculateTransactionToAccounting(taxTrans.SourceCurrencyCode, (taxTrans.SourceRegulateAmountCur - taxTrans.TaxInCostPrice),  true);
                        }
                        if (taxTrans.SourceBaseAmountCurRegulated)
                        {
                            baseAmount = currencyExchangeHelper.calculateTransactionToAccounting(taxTrans.SourceCurrencyCode, (taxTrans.SourceBaseAmountCurRegulated),  true);
                        }
                        else
                        {
                            baseAmount = currencyExchangeHelper.calculateTransactionToAccounting(taxTrans.SourceCurrencyCode, (taxTrans.SourceBaseAmountCur),  true);
                        }
                    }
                }
            }
        }

        currencyExchangeHelper.parmLedgerRecId(Ledger::current());
        dictTable = new SysDictTable(_headingTableId);
        if (dictTable)
        {
            headingRecord = dictTable.makeRecord();
            select headingRecord where headingRecord.RecId == _headingRecId;
            headingCompany = headingRecord.company();
        }

        if (_common.TableId == tableNum(TaxUncommitted))
        {
            currentTaxUnCommitted = _common;
        }
        else if (_common.TableId == tableNum(TaxTrans))
        {
            currentTaxTrans = _common;
        }
        else if (_common.TableId == tableNum(TmpTaxWorkTrans))
        {
            currentTmpTaxWorkTrans = _common;
        }
        if (_headingTableId    == tableNum(SalesTable)
            || _headingTableId == tableNum(CustInvoiceTable)
            || _headingTableId == tableNum(CustInvoiceJour)
            || _headingTableId == tableNum(CustInvoiceTrans))
        {
            if (_headingTableId == tableNum(CustInvoiceJour) || _headingTableId == tableNum(CustInvoiceTrans))
            {
                if (_headingTableId == tableNum(CustInvoiceTrans))
                {
                    custInvoiceJour = CustInvoiceTrans::findRecId(headingRecId).custInvoiceJour();
                }
                else
                {
                    custInvoiceJour = CustInvoiceJour::findRecId(headingRecId);
                }
                if (custInvoiceJour.SalesId)// Sales order
                {
                    headingTableId = tableNum(SalesTable);
                    headingRecId   = SalesTable::find(custInvoiceJour.SalesId).RecId;
                }
                else
                {
                    sourceDocumentLine = SourceDocumentLine::findBySourceDocumentHeader(custInvoiceJour.SourceDocumentHeader);
                    if (sourceDocumentLine.SourceRelationType == tableNum(CustInvoiceTable))// FTI
                    {
                        custInvoiceTable = CustInvoiceTable::findSourceDocumentLine(sourceDocumentLine.RecId);
                        if (custInvoiceTable.RecId != 0)
                        {
                            headingTableId = tableNum(CustInvoiceTable);
                            headingRecId   = custInvoiceTable.RecId;
                        }
                    }
                }
            }
            while select specTrans
                where specTrans.SpecTableId == headingTableId &&
                      specTrans.SpecRecId   == headingRecId &&
                      specTrans.SpecCompany == headingCompany &&
                      specTrans.RefTableId  == (tableNum(CustTransOpen))
                join custTransOpen
                    where custTransOpen.RecId == specTrans.RefRecId
                join RecId, AccountNum, LastSettleVoucher,ExchRate from custTrans group by LastSettleVoucher,AccountNum,RecId
                    where custTrans.RecId == custTransOpen.RefRecId
                join Voucher,AccountingDate from subledgerVoucherGeneralJournalEntry group by Voucher,AccountingDate
                    where subledgerVoucherGeneralJournalEntry.Voucher        == custTrans.Voucher &&
                          subledgerVoucherGeneralJournalEntry.AccountingDate == custTrans.TransDate
                join maxof(VoucherGroupId) from ledgerTransVoucherLink group by Voucher,TransDate
                    where ledgerTransVoucherLink.Voucher   == subledgerVoucherGeneralJournalEntry.Voucher &&
                          ledgerTransVoucherLink.TransDate == subledgerVoucherGeneralJournalEntry.AccountingDate

            {
                taxDirection = TaxDirection::OutgoingTax;
                // If invoice was settled before
                sumPaymentAmount();
                if (previousSettlemnt == false && custTrans.LastSettleVoucher)
                {
                    previousSettlemnt = true;
                }
            }
            if (previousSettlemnt == true
               && totalPaymentAmount != 0)
            {
                if (currentTmpTaxWorkTrans.SourceRegulateAmountCur !=0)
                {
                    invoiceAmountForSettlement = abs(SpecTransManager::getTotalSettleAmountForSpecReference(currentTmpTaxWorkTrans.company(),
                                                                                                            headingTableId,
                                                                                                            headingRecId,
                                                                                                            currentTmpTaxWorkTrans.CurrencyCode,
                                                                                                            currentTmpTaxWorkTrans.Company,
                                                                                                            currentTmpTaxWorkTrans.TransDate));

                    amount = (abs(invoiceAmountForSettlement / totalPaymentAmount) * amount);

                    baseAmountProrated = (abs(invoiceAmountForSettlement / totalPaymentAmount) * baseAmount);
                }
                else if (currentTaxUnCommitted.RecId != 0
                        && currentTaxUnCommitted.SourceTaxAmountCur != 0)
                {
                    invoiceAmountForSettlement = abs(SpecTransManager::getTotalSettleAmountForSpecReference(currentTaxUnCommitted.company(),
                                                                                                            headingTableId,
                                                                                                            headingRecId,
                                                                                                            currentTaxUnCommitted.CurrencyCode,
                                                                                                            currentTaxUnCommitted.Company,
                                                                                                            currentTaxUnCommitted.TransDate));
                    amount = (abs(invoiceAmountForSettlement /totalPaymentAmount) * amount);
                    baseAmountProrated = (abs(invoiceAmountForSettlement /totalPaymentAmount) * baseAmount);
                }
                else if (currentTaxTrans.RecId != 0
                        && currentTaxTrans.SourceTaxAmountCur != 0)
                {
                    invoiceAmountForSettlement = abs(SpecTransManager::getTotalSettleAmountForSpecReference(currentTaxTrans.company(),
                                                                                                            headingTableId,
                                                                                                            headingRecId,
                                                                                                            currentTaxTrans.CurrencyCode,
                                                                                                            currentTaxTrans.company(),
                                                                                                            currentTaxTrans.TransDate));

                    amount = (abs(invoiceAmountForSettlement /totalPaymentAmount) * amount);
                    baseAmountProrated = (abs(invoiceAmountForSettlement /totalPaymentAmount) * baseAmount);
                }
            }
        }
        else  if (_headingTableId == tableNum(PurchParmTable)
                  || _headingTableId == tableNum(PurchTable)
                  || _headingTableId ==tableNum(VendInvoiceInfoTable)
                  || _headingTableId ==tableNum(VendInvoiceJour))
        {
            if (_headingTableId == tableNum(PurchParmTable) || _headingTableId == tableNum(VendInvoiceInfoTable) || _headingTableId == tableNum(VendInvoiceJour))
            {
                purchTable = headingRecord.purchTable();
            }
            if (_headingTableId == tableNum(PurchTable))
            {
                purchTable = headingRecord;
            }
            while select specTrans
                where specTrans.SpecTableId == tableNum(PurchTable) &&
                      specTrans.SpecRecId == purchTable.RecId &&
                      specTrans.SpecCompany == purchTable.company() &&
                      specTrans.RefTableId == tableNum(VendTransOpen)
                join vendTransOpen
                    where vendTransOpen.RecId == specTrans.RefRecId
                join RecId, AccountNum, LastSettleVoucher from vendTrans group by AccountNum, LastSettleVoucher
                    where vendTrans.RecId == vendTransOpen.RefRecId
                join Voucher,AccountingDate from subledgerVoucherGeneralJournalEntry
                    where subledgerVoucherGeneralJournalEntry.Voucher == vendTrans.Voucher &&
                          subledgerVoucherGeneralJournalEntry.AccountingDate == vendTrans.TransDate
                join generalJournalEntry
                    where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                join generalJournalAccountEntry
                    where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                join maxof(VoucherGroupId) from ledgerTransVoucherLink group by Voucher,TransDate
                    where ledgerTransVoucherLink.Voucher == subledgerVoucherGeneralJournalEntry.Voucher &&
                          ledgerTransVoucherLink.TransDate == subledgerVoucherGeneralJournalEntry.AccountingDate

            {
                // If invoice was settled before
                taxDirection = TaxDirection::IncomingTax;
                sumPaymentAmount();
                if (previousSettlemnt == false && vendTrans.LastSettleVoucher)
                {
                    previousSettlemnt = true;
                }
            }
            if (previousSettlemnt == true
               && currentTaxUnCommitted.RecId != 0
               && currentTaxUnCommitted.SourceTaxAmountCur != 0
               && totalPaymentAmount != 0)
            {
                invoiceAmountForSettlement = abs(SpecTransManager::getTotalSettleAmountForSpecReference(currentTaxUnCommitted.company(),
                                                                                                        purchTable.TableId,
                                                                                                        purchTable.RecId,
                                                                                                        currentTaxUnCommitted.CurrencyCode,
                                                                                                        currentTaxUnCommitted.Company,
                                                                                                        currentTaxUnCommitted.TransDate,
                                                                                                        currentTaxUnCommitted.ExchRate));
                amount = (abs(invoiceAmountForSettlement / totalPaymentAmount) * amount);
                baseAmountProrated = (abs(invoiceAmountForSettlement / totalPaymentAmount) * baseAmount);
            }
        }
        else if (_headingTableId == tableNum(LedgerJournalTable))
        {
            if (_ledgerJournalService.AccountType == LedgerJournalACType::Vend ||
                _ledgerJournalService.OffsetAccountType == LedgerJournalACType::Vend)
            {
                while select specTrans
                where specTrans.SpecTableId == (tableNum(LedgerJournalTrans)) &&
                      specTrans.SpecRecId == _ledgerJournalService.RecId &&
                      specTrans.SpecCompany == _ledgerJournalService.company() &&
                      specTrans.RefTableId == (tableNum(VendTransOpen))
                join vendTransOpen
                    where vendTransOpen.RecId == specTrans.RefRecId
                join RecId, AccountNum, LastSettleVoucher from vendTrans group by LastSettleVoucher,AccountNum,RecId
                    where vendTrans.RecId == vendTransOpen.RefRecId
                join vendTable
                    where vendTable.AccountNum == vendTrans.AccountNum
                join taxInformationVendTableLoc
                   where taxInformationVendTableLoc.VendTable == vendTable.AccountNum
                      && taxInformationVendTableLoc.IsGTA     == NoYes::No
                      && taxInformationVendTableLoc.IsForeign == NoYes::No
                join Voucher,AccountingDate from subledgerVoucherGeneralJournalEntry group by Voucher,AccountingDate
                    where subledgerVoucherGeneralJournalEntry.Voucher == vendTrans.Voucher &&
                        subledgerVoucherGeneralJournalEntry.AccountingDate == vendTrans.TransDate
                join maxof(VoucherGroupId) from ledgerTransVoucherLink group by Voucher,TransDate
                    where ledgerTransVoucherLink.Voucher == subledgerVoucherGeneralJournalEntry.Voucher &&
                        ledgerTransVoucherLink.TransDate == subledgerVoucherGeneralJournalEntry.AccountingDate

                {
                    taxDirection = TaxDirection::IncomingTax;
                    sumPaymentAmount();
                    if (previousSettlemnt == false && vendTrans.LastSettleVoucher)
                    {
                        previousSettlemnt = true;
                    }
                }
            }
            if (_ledgerJournalService.AccountType == LedgerJournalACType::Cust ||
                _ledgerJournalService.OffsetAccountType == LedgerJournalACType::Cust)
            {
                while select specTrans
                where specTrans.SpecTableId == (tableNum(LedgerJournalTrans)) &&
                      specTrans.SpecRecId == _ledgerJournalService.RecId &&
                      specTrans.SpecCompany == _ledgerJournalService.company() &&
                      specTrans.RefTableId == (tableNum(CustTransOpen))
                join custTransOpen
                    where custTransOpen.RecId == specTrans.RefRecId
                join RecId, AccountNum, LastSettleVoucher from custTrans group by LastSettleVoucher,AccountNum,RecId
                    where custTrans.RecId == custTransOpen.RefRecId
                join custTable
                    where custTable.AccountNum == custTrans.AccountNum
                join taxInformationCustTableLoc
                   where taxInformationCustTableLoc.CustTable == custTable.AccountNum
                      && taxInformationCustTableLoc.IsForeign == NoYes::No
                join Voucher,AccountingDate from subledgerVoucherGeneralJournalEntry group by Voucher,AccountingDate
                    where subledgerVoucherGeneralJournalEntry.Voucher == custTrans.Voucher &&
                        subledgerVoucherGeneralJournalEntry.AccountingDate == custTrans.TransDate
                join maxof(VoucherGroupId) from ledgerTransVoucherLink group by Voucher,TransDate
                    where ledgerTransVoucherLink.Voucher == subledgerVoucherGeneralJournalEntry.Voucher &&
                        ledgerTransVoucherLink.TransDate == subledgerVoucherGeneralJournalEntry.AccountingDate

                {
                    taxDirection = TaxDirection::OutgoingTax;
                    sumPaymentAmount();
                    if (previousSettlemnt == false && custTrans.LastSettleVoucher)
                    {
                        previousSettlemnt = true;
                    }
                }
            }
            if (previousSettlemnt == true
               && currentTaxUnCommitted.RecId != 0
               && currentTaxUnCommitted.SourceTaxAmountCur != 0
               && totalPaymentAmount != 0)
            {
                invoiceAmountForSettlement = abs(SpecTransManager::getTotalSettleAmountForSpecReference(_ledgerJournalService.company(),
                                                                                                        _ledgerJournalService.TableId,
                                                                                                        _ledgerJournalService.RecId,
                                                                                                        _ledgerJournalService.CurrencyCode,
                                                                                                        _ledgerJournalService.Company,
                                                                                                        _ledgerJournalService.TransDate,
                                                                                                        _ledgerJournalService.crossrate()));
                amount = (abs(invoiceAmountForSettlement / totalPaymentAmount) * amount );
                baseAmountProrated = (abs(invoiceAmountForSettlement / totalPaymentAmount) * baseAmount);
            }
        }

        if (!previousSettlemnt)
        {
            baseAmountProrated = baseAmount;
        }

        return [CurrencyExchangeHelper::amount(baseAmount, sourceCurrencyCode), CurrencyExchangeHelper::amount(amount, sourceCurrencyCode), CurrencyExchangeHelper::amount(baseAmountProrated, sourceCurrencyCode)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultLedgerACServiceTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets default ledger AC service tax.
    /// </summary>
    /// <param name="_common">
    /// The instance of the <c>Common</c> class.
    /// </param>
    /// <returns>
    /// The instance of the <c>LedgerDimensionAccount</c> class.
    /// </returns>
    public static LedgerDimensionAccount getDefaultLedgerACServiceTax_IN(Common _common)
    {
        LedgerDimensionAccount              defaultLedgerAC;
        RefRecId                            taxLedgerAccountsetupRecId;
        TaxModuleType                       source;
        TmpTaxWorkTrans                     tmpTaxWorkTrans;
        TaxUncommitted                      taxUncommitted;
        TaxTrans                            taxTrans;
        TaxTable                            taxTable;
        RefRecId                            taxRegistrationNumberTable;
        TaxAccountType_IN                   taxAccountType;
        ServiceTaxBasis_IN                  serviceTaxBasis;
        TaxAmountCur                        advanceSourceBaseAmountCur;
        TaxAmountCur                        advanceSourceTaxAmountCur;
        PurchLine                           purchLine;
        SalesLine                           salesLine;
        CustInvoiceLine                     custInvoiceLine;
        CustInvoiceTrans                    custInvoiceTrans;
        TableId                             headingTableId;
        RefRecId                            headingRecId;
        TransTaxInformation                 transTaxInformation;
        LedgerDimensionAccount              gtaForeignLedgerDim;
        LedgerDimensionAccount              reverseChargeLedgerDim;
        VendInvoiceInfoLine                 vendInvoiceInfoLine;
        VendTable                           vendTable;
        ProjEmplTrans                       projEmplTrans;
        ProjEmplTransTaxExtensionIN         projEmplTransTaxExtension;
        percent                             reverseChargePercent;
        boolean                             isExpenseAccount;
        boolean                             isNormalReverseCharge;
        MarkupTrans                         markupTrans;
        boolean                             isAccruePayableAtInvoicing = false;

        switch (_common.TableId)
        {
            case tableNum(TmpTaxWorkTrans) :    tmpTaxWorkTrans = _common;
                source = tmpTaxWorkTrans.Source;
                taxTable = TaxTable::find(tmpTaxWorkTrans.TaxCode);
                taxRegistrationNumberTable = tmpTaxWorkTrans.TaxRegistrationNumberTable_IN;
                serviceTaxBasis  = TaxItemGroupHeading::find(tmpTaxWorkTrans.TaxItemGroup).ServiceTaxBasis_IN;
                isAccruePayableAtInvoicing = TaxItemGroupHeading::isAccruePayableAtInvoicing_IN(tmpTaxWorkTrans.TaxItemGroup);
                if (source == TaxModuleType::Purch)
                {
                    if (tmpTaxWorkTrans.SourceTableId == tableNum(purchLine))
                    {
                        purchLine = PurchLine::findRecId(tmpTaxWorkTrans.SourceRecId);
                        reverseChargePercent = TaxItemGroupHeading::find(purchLine.TaxItemGroup).ReverseChargePercentage_IN;
                        headingTableId = purchLine.purchTable().TableId;
                        headingRecId   = purchLine.purchTable().RecId;
                        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(purchLine);
                        taxRegistrationNumberTable = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTable.TaxType_IN).RecId;
                        isExpenseAccount = transTaxInformation.ServiceTaxGTAServiceCategory == GTAServiceCategory_IN::Others;
                    }

                    if (purchLine.RecId == 0)
                    {
                        vendInvoiceInfoLine = VendInvoiceInfoLine::findRecId(tmpTaxWorkTrans.SourceRecId);                                                                                                    //
                        if (vendInvoiceInfoLine.RecId)
                        {
                            reverseChargePercent = TaxItemGroupHeading::find(vendInvoiceInfoLine.TaxItemGroup).ReverseChargePercentage_IN;
                            if (vendInvoiceInfoLine.isNonPO())
                            {
                                headingTableId = vendInvoiceInfoLine.TableId;
                                headingRecId   = vendInvoiceInfoLine.RecId;
                                transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(vendInvoiceInfoLine);
                                taxRegistrationNumberTable = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTable.TaxType_IN).RecId;
                                isExpenseAccount = transTaxInformation.ServiceTaxGTAServiceCategory == GTAServiceCategory_IN::Others;
                            }
                            else
                            {
                                purchLine = vendInvoiceInfoLine.purchLine();
                                headingTableId = purchLine.purchTable().TableId;
                                headingRecId   = purchLine.purchTable().RecId;
                                transTaxInformation =TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(purchLine);
                                taxRegistrationNumberTable = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTable.TaxType_IN).RecId;
                                isExpenseAccount = transTaxInformation.ServiceTaxGTAServiceCategory == GTAServiceCategory_IN::Others;
                            }
                        }
                    }
                }
                if (source == TaxModuleType::Sales)
                {
                    if (tmpTaxWorkTrans.SourceTableId == tableNum(salesLine))
                    {
                        salesLine = SalesLine::findRecId(tmpTaxWorkTrans.SourceRecId);
                        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(salesLine);
                        taxRegistrationNumberTable = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTable.TaxType_IN).RecId;
                        headingTableId = salesLine.salesTable().TableId;
                        headingRecId   = salesLine.salesTable().RecId;
                    }
                    else if (tmpTaxWorkTrans.SourceTableId == tableNum(MarkupTrans))
                    {
                        markupTrans                 = MarkupTrans::findRecId(tmpTaxWorkTrans.SourceRecId);
                        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(markupTrans);
                        taxRegistrationNumberTable = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTable.TaxType_IN).RecId;

                        if (markupTrans.TransTableId == tableNum(SalesTable))
                        {
                            headingTableId  = markupTrans.TransTableId;
                            headingRecId    = markupTrans.TransRecId;
                        }
                        else if (markupTrans.TransTableId == tableNum(salesLine))
                        {
                            salesLine = SalesLine::findRecId(markupTrans.TransRecId);
                            headingTableId = salesLine.salesTable().TableId;
                            headingRecId   = salesLine.salesTable().RecId;
                        }
                    }
                }
                else if (source == TaxModuleType::FreeTxtInvoice)
                {
                    custInvoiceLine = CustInvoiceLine::find(tmpTaxWorkTrans.SourceRecId);
                    transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(custInvoiceLine);
                    taxRegistrationNumberTable = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTable.TaxType_IN).RecId;
                    headingTableId = custInvoiceLine.custInvoiceTable().TableId;
                    headingRecId   = custInvoiceLine.custInvoiceTable().RecId;
                }
                if (source == TaxModuleType::Project)
                {
                    projEmplTrans = ProjEmplTrans::find(ProjProposalEmpl::findRecId(tmpTaxWorkTrans.SourceRecId).TransId);
                    transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(projEmplTrans);
                    taxRegistrationNumberTable = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTable.TaxType_IN).RecId;
                    headingTableId = ProjEmplTrans.projTable().TableId;
                    headingRecId   = ProjEmplTrans.projTable().RecId;
                }
                break;

            case tableNum(TaxUncommitted) :     taxUncommitted = _common;
                source = taxUncommitted.Source;
                taxTable = TaxTable::find(taxUncommitted.TaxCode);
                isAccruePayableAtInvoicing = TaxItemGroupHeading::isAccruePayableAtInvoicing_IN(taxUncommitted.TaxItemGroup);
                if (source == TaxModuleType::Purch)
                {
                    purchLine = PurchLine::findRecId(taxUncommitted.SourceRecId);
                    reverseChargePercent = TaxItemGroupHeading::find(purchLine.TaxItemGroup).ReverseChargePercentage_IN;
                    headingTableId = purchLine.purchTable().TableId;
                    headingRecId   = purchLine.purchTable().RecId;
                    transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(purchLine);
                    taxRegistrationNumberTable = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTable.TaxType_IN).RecId;
                    isExpenseAccount = transTaxInformation.ServiceTaxGTAServiceCategory == GTAServiceCategory_IN::Others;
                    if (purchLine.RecId == 0)
                    {
                        vendInvoiceInfoLine = VendInvoiceInfoLine::findRecId(taxUncommitted.SourceRecId);
                        reverseChargePercent = TaxItemGroupHeading::find(vendInvoiceInfoLine.TaxItemGroup).ReverseChargePercentage_IN;                                                                                                    //
                        if (vendInvoiceInfoLine.RecId)
                        {
                            if (vendInvoiceInfoLine.isNonPO())
                            {
                                headingTableId = vendInvoiceInfoLine.TableId;
                                headingRecId   = vendInvoiceInfoLine.RecId;
                                transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(vendInvoiceInfoLine);
                                taxRegistrationNumberTable = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTable.TaxType_IN).RecId;
                                isExpenseAccount = transTaxInformation.ServiceTaxGTAServiceCategory == GTAServiceCategory_IN::Others;
                            }
                            else
                            {
                                purchLine = vendInvoiceInfoLine.purchLine();
                                headingTableId = purchLine.purchTable().TableId;
                                headingRecId   = purchLine.purchTable().RecId;
                                transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(purchLine);
                                taxRegistrationNumberTable = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTable.TaxType_IN).RecId;
                            }
                        }
                    }
                }
                // SalesOrder does not use TaxUncommitted.
                else if (source == TaxModuleType::FreeTxtInvoice)
                {
                    custInvoiceLine = CustInvoiceLine::find(taxUncommitted.SourceRecId);
                    transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(custInvoiceLine);
                    taxRegistrationNumberTable = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTable.TaxType_IN).RecId;
                    headingTableId = custInvoiceLine.custInvoiceTable().TableId;
                    headingRecId   = custInvoiceLine.custInvoiceTable().RecId;
                }
                serviceTaxBasis  = TaxItemGroupHeading::find(taxUncommitted.TaxItemGroup).ServiceTaxBasis_IN;
                break;

            case tableNum(TaxTrans) :           taxTrans = _common;
                source = taxTrans.Source;
                taxTable = TaxTable::find(taxTrans.TaxCode);
                isAccruePayableAtInvoicing = TaxItemGroupHeading::isAccruePayableAtInvoicing_IN(taxTrans.TaxItemGroup);
                if (source == TaxModuleType::Purch)
                {
                    if (taxTrans.SourceTableId == tableNum(PurchLine))
                    {
                        purchLine = PurchLine::findRecId(taxTrans.SourceRecId);
                        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(purchLine);
                        isExpenseAccount = transTaxInformation.ServiceTaxGTAServiceCategory == GTAServiceCategory_IN::Others;
                        reverseChargePercent = TaxItemGroupHeading::find(purchLine.TaxItemGroup).ReverseChargePercentage_IN;
                    }
                    else if (taxTrans.SourceTableId == tableNum(VendInvoiceInfoLine))
                    {
                        vendInvoiceInfoLine = VendInvoiceInfoLine::findRecId(taxTrans.SourceRecId);
                        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(vendInvoiceInfoLine);
                        isExpenseAccount = transTaxInformation.ServiceTaxGTAServiceCategory == GTAServiceCategory_IN::Others;
                        reverseChargePercent = TaxItemGroupHeading::find(vendInvoiceInfoLine.TaxItemGroup).ReverseChargePercentage_IN;
                        purchLine = vendInvoiceInfoLine.purchLine();
                    }
                    if (purchLine.RecId)
                    {
                        headingTableId = purchLine.purchTable().TableId;
                        headingRecId   = purchLine.purchTable().RecId;
                        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(purchLine);
                        taxRegistrationNumberTable = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTable.TaxType_IN).RecId;
                    }
                }
                if (source == TaxModuleType::Sales)
                {
                    if (taxTrans.SourceTableId == tableNum(SalesLine))
                    {
                        salesLine = SalesLine::findRecId(taxTrans.SourceRecId);
                        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(salesLine);
                        taxRegistrationNumberTable = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTable.TaxType_IN).RecId;
                        headingTableId = salesLine.salesTable().TableId;
                        headingRecId   = salesLine.salesTable().RecId;
                    }
                    else if (tmpTaxWorkTrans.SourceTableId == tableNum(MarkupTrans))
                    {
                        markupTrans                 = MarkupTrans::findRecId(tmpTaxWorkTrans.SourceRecId);
                        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(markupTrans);
                        taxRegistrationNumberTable = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTable.TaxType_IN).RecId;

                        if (markupTrans.TransTableId == tableNum(SalesTable))
                        {
                            headingTableId  = markupTrans.TransTableId;
                            headingRecId    = markupTrans.TransRecId;
                        }
                        else if (markupTrans.TransTableId == tableNum(salesLine))
                        {
                            salesLine = SalesLine::findRecId(markupTrans.TransRecId);
                            headingTableId = salesLine.salesTable().TableId;
                            headingRecId   = salesLine.salesTable().RecId;
                        }
                    }
                }
                else if (source == TaxModuleType::FreeTxtInvoice)
                {
                    if (taxTrans.SourceTableId == tableNum(CustInvoiceLine))
                    {
                        custInvoiceLine = CustInvoiceLine::find(taxTrans.SourceRecId);
                        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(custInvoiceLine);
                        taxRegistrationNumberTable = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTable.TaxType_IN).RecId;
                        headingTableId = custInvoiceLine.custInvoiceTable().TableId;
                        headingRecId   = custInvoiceLine.custInvoiceTable().RecId;
                    }
                    else if (taxTrans.SourceTableId == tableNum(CustInvoiceTrans))// When SLJL involved
                    {
                        custInvoiceTrans = CustInvoiceTrans::findRecId(taxTrans.SourceRecId);
                        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(custInvoiceTrans);
                        taxRegistrationNumberTable = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTable.TaxType_IN).RecId;
                        custInvoiceLine = CustInvoiceLine::findBySourceDocumentLine(custInvoiceTrans.SourceDocumentLine);
                        headingTableId  = custInvoiceLine.custInvoiceTable().TableId;
                        headingRecId    = custInvoiceLine.custInvoiceTable().RecId;
                    }
                }
                serviceTaxBasis  = TaxItemGroupHeading::find(taxTrans.TaxItemGroup).ServiceTaxBasis_IN;
                break;
            default:                                break;
        }
        if ((source == TaxModuleType::Purch) || (source == TaxModuleType::Sales) || (source == TaxModuleType::FreeTxtInvoice) || (source == TaxModuleType::Project))
        {
            [advanceSourceBaseAmountCur, advanceSourceTaxAmountCur] = Tax::getAdvanceAmount_IN(taxTable.TaxCode, headingTableId, headingRecId);
            taxLedgerAccountsetupRecId = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::Table, taxRegistrationNumberTable).RecId;
            // if POT 2 cases are there
            // a. Advance amount is available -> LedgerDimension = interim, or service tax reverse charge is applied
            // b. Advance amount is ZERO -> LedgerDimension = Actual
            // if cash basis
            // get interim AC to TmpTaxLedgerDim
            if (serviceTaxBasis == ServiceTaxBasis_IN::POTBasis && reverseChargePercent != 100)
            {
                if (source == TaxModuleType::Purch)
                {
                    taxAccountType = TaxAccountType_IN::ServiceTaxRecoverableAccount;
                    if (advanceSourceTaxAmountCur != 0)
                    {
                        taxAccountType = TaxAccountType_IN::ServiceTaxInterimRecoverableAccount;
                    }
                    if (isExpenseAccount)
                    {
                        taxAccountType = TaxAccountType_IN::ServiceTaxExpenseAccount;
                    }
                }
                else if ((source == TaxModuleType::Sales) || source == TaxModuleType::FreeTxtInvoice)
                {
                    taxAccountType = TaxAccountType_IN::ServiceTaxPayableAccount;
                    if (advanceSourceTaxAmountCur != 0)
                    {
                        taxAccountType = TaxAccountType_IN::ServiceTaxInterimPayableAccount;
                    }
                }
            }
            else// Cash basis
            {
                if (source == TaxModuleType::Purch)
                {
                    taxAccountType = TaxAccountType_IN::ServiceTaxInterimRecoverableAccount;
                }
                else if ((source == TaxModuleType::Sales) || source == TaxModuleType::FreeTxtInvoice)
                {
                    taxAccountType = TaxAccountType_IN::ServiceTaxInterimPayableAccount;
                }
            }
            if (!taxLedgerAccountsetupRecId)
            {
                taxLedgerAccountsetupRecId = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::All).RecId;
            }
            defaultLedgerAC = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId,
                                                                  taxAccountType,
                                                                  taxTable.TaxComponentTable_IN);

            if (vendInvoiceInfoLine.RecId != 0 && vendInvoiceInfoLine.isNonPO())
            {
                vendTable = VendTable::find(vendInvoiceInfoLine.vendInvoiceInfoTable().OrderAccount);
            }
            isNormalReverseCharge = reverseChargePercent > 0;
            if (
                (// Non -po Lines
                    (vendTable.isGTA() || vendTable.isForeign())
                )
                                       ||
                (
                    purchLine.vendTable_OrderAccount().isGTA()
                                       ||
                    (purchLine.vendTable_OrderAccount().isForeign()
                     && purchLine.purchTable().purchTable_W().CustomsImportOrder_IN)
                                       ||
                    isNormalReverseCharge
                )
              )
            {
                gtaForeignLedgerDim = LedgerDimensionFacade::serviceCreateLedgerDimension(TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId,
                                                                isAccruePayableAtInvoicing ? TaxAccountType_IN::ServiceTaxPayableAccount : TaxAccountType_IN::ServiceTaxInterimPayableAccount,
                                                                taxTable.TaxComponentTable_IN),
                                            vendInvoiceInfoLine.DefaultDimension != 0 ? vendInvoiceInfoLine.DefaultDimension : vendTable.DefaultDimension);

                reverseChargeLedgerDim = LedgerDimensionFacade::serviceCreateLedgerDimension(TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId, isExpenseAccount ? TaxAccountType_IN::ServiceTaxExpenseAccount : TaxAccountType_IN::ServiceTaxInterimRecoverableAccount, taxTable.TaxComponentTable_IN), vendInvoiceInfoLine.DefaultDimension != 0 ? vendInvoiceInfoLine.DefaultDimension : vendTable.DefaultDimension);

                ttsbegin;
                if (tmpTaxWorkTrans.RecId)
                {
                    tmpTaxWorkTrans.selectForUpdate(true);
                    tmpTaxWorkTrans.LedgerDimension_IN = gtaForeignLedgerDim;
                    if (isNormalReverseCharge)
                    {
                        tmpTaxWorkTrans.LedgerDimensionRev_IN = reverseChargeLedgerDim;
                        if (isExpenseAccount)
                        {
                            tmpTaxWorkTrans.LedgerDimension = reverseChargeLedgerDim;
                        }
                    }
                    tmpTaxWorkTrans.update();
                    tmpTaxWorkTrans.reread();// Open cursore shud be explicitly refreshed in AX 6.0, if there are subsequent updates.
                }
                else if (taxUncommitted.RecId)
                {
                    taxUncommitted.selectForUpdate(true);
                    taxUncommitted.LedgerDimension_IN = gtaForeignLedgerDim;
                    if (isNormalReverseCharge)
                    {
                        taxUncommitted.LedgerDimensionRev_IN = reverseChargeLedgerDim;
                        if (isExpenseAccount)
                        {
                            taxUncommitted.LedgerDimension = reverseChargeLedgerDim;
                        }
                    }
                    taxUncommitted.update();
                    taxUncommitted.reread();// Open cursore shud be explicitly refreshed in AX 6.0, if there are subsequent updates.
                }
                ttscommit;
            }
        }

        return defaultLedgerAC;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInclTaxAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates inclusive tax amount.
    /// </summary>
    /// <param name="_common">
    /// Recid of the PurchLine table.
    /// </param>
    /// <param name="_tax">
    /// The Tax object passed in.
    /// </param>
    /// <returns>
    /// The total tax amount committed.
    /// </returns>
    public static TaxAmountCur getInclTaxAmount_IN(Common   _common,
                                                   Tax      _tax = null)
    {
        TaxAmountCur        inclTaxAmount;
        TmpTaxWorkTrans     tmpTaxWorkTrans;
        FormulaDesigner_IN  formulaDesigner;
        TaxableBasis_IN     taxBasis;
        TmpTaxCalc_IN       tmpTaxCalc;

        if (_tax)
        {
            tmpTaxWorkTrans = _tax.tmpTaxWorkTrans();
            tmpTaxCalc      = _tax.tmpTaxCalc_IN();

            while select tmpTaxWorkTrans
                where tmpTaxWorkTrans.SourceRecId        == _common.RecId    &&
                        tmpTaxWorkTrans.SourceTableId    == _common.TableId  &&
                        tmpTaxWorkTrans.TaxDirection     != TaxDirection::UseTax &&
                        tmpTaxWorkTrans.TaxOrigin        != TaxOrigin::TaxReversed
                join formulaDesigner
                    where formulaDesigner.TaxItemGroup  == tmpTaxWorkTrans.TaxItemGroup
                        && formulaDesigner.TaxCode      == tmpTaxWorkTrans.TaxCode
                        && formulaDesigner.PriceInclTax == NoYes::Yes
            {
                taxBasis = formulaDesigner.TaxableBasis;

                if (taxBasis == TaxableBasis_IN::ExclAmount)
                {
                    taxBasis = Tax::getTaxableBasis_IN(formulaDesigner);
                }

                select TaxOnCharges from tmpTaxCalc
                    where tmpTaxCalc.TaxCode         == tmpTaxWorkTrans.TaxCode
                    && tmpTaxCalc.SourceRecID     == _common.RecId
                    && tmpTaxCalc.SourceTableID   == _common.TableId;

                if (TaxTable::find(tmpTaxWorkTrans.TaxCode).TaxType_IN != TaxType_IN::None
                    && (taxBasis == TaxableBasis_IN::LineAmount
                        || taxBasis == TaxableBasis_IN::Assessable))
                {
                    if (!tmpTaxWorkTrans.SourceRegulateAmountCur)
                    {
                        inclTaxAmount += tmpTaxWorkTrans.SourceTaxAmountCur;
                    }
                    else
                    {
                        inclTaxAmount += tmpTaxWorkTrans.SourceRegulateAmountCur;
                    }

                    if (inclTaxAmount < 0)
                    {
                        inclTaxAmount += tmpTaxCalc.TaxOnCharges;
                    }
                    else
                    {
                        inclTaxAmount -= tmpTaxCalc.TaxOnCharges;
                    }
                }
            }
        }

        return inclTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIncludedTaxPct_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets included/retained tax value of a specific tax group
    /// </summary>
    /// <param name="_taxGroup">
    /// Tax group to calculate included tax value
    /// </param>
    /// <param name="_taxItemGroup">
    /// Tax item group to calculate included tax value
    /// </param>
    /// <returns>
    /// The included/retained tax value
    /// </returns>
    public static TaxValue getIncludedTaxPct_BR(TaxGroup _taxGroup, TaxItemGroup _taxItemGroup)
    {
        TaxGroupData    taxGroupData;
        TaxOnItem       taxOnItem;
        TaxTable        taxTable;
        TaxData         taxData;
        TaxValue        taxPct;
        TaxValue totalTaxPctShouldBeExcluded;
        TaxValue totalTaxPctApplyBaseExcluding;

        while select ExemptTax from taxGroupData
          where taxGroupData.TaxGroup   == _taxGroup
        join TaxCode, WithoutTaxCredit_BR, ExemptTax_BR from taxOnItem
          where taxOnItem.TaxItemGroup  == _taxItemGroup
             && taxOnItem.TaxCode       == taxGroupData.TaxCode
        join RecId, TaxType_BR, ExcludeICMS_BR from taxTable
            where taxTable.TaxCode == taxOnItem.TaxCode
                && (taxTable.IncludedTax_BR || taxTable.RetainedTax_BR)
        {
            taxData     = TaxData::find(taxOnItem.TaxCode, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), 0);

            taxPct += (taxData.TaxValue * (1-taxData.TaxReductionPct_BR/100));

            // While excluding ICMS from the amount origin of PIS and Cofins, the included tax percent is
            // TaxValueICMS * (1 - TaxReductionPctICMS) + [1 - TaxValueICMS * (1 - TaxReductionPctICMS)] * [TaxValuePIS * (1 - TaxReductionPctPIS) + TaxValueCofins * (1 - TaxReductionPctCofins)]
            if (taxTable.TaxType_BR == TaxType_BR::ICMS)
            {
                totalTaxPctShouldBeExcluded += (taxData.TaxValue * (1 - taxData.TaxReductionPct_BR / 100));
            }
            else if (taxTable.ExcludeICMS_BR
                && (taxTable.TaxType_BR == TaxType_BR::COFINS || taxTable.TaxType_BR == TaxType_BR::PIS))
            {
                totalTaxPctApplyBaseExcluding += (taxData.TaxValue * (1 - taxData.TaxReductionPct_BR / 100));
            }
        }

        taxPct -= totalTaxPctShouldBeExcluded * totalTaxPctApplyBaseExcluding / 100;

        return taxPct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPostedVATDeferredAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets posted VAT deferred amount.
    /// </summary>
    /// <param name="_inventRefTransId">
    ///  The original InventTransId of transaction
    /// </param>
    /// <param name="_taxCode">
    ///  Transaction tax Code
    ///  </param>
    /// <returns>
    ///  retrun posted VAT deferred amount
    /// </returns>
    /// <remarks>
    ///  return amount will used to find the VAT deferred account for Cedit note transactions.
    /// </remarks>
    public static Amount getPostedVATDeferredAmount_IN(
        InventRefTransId  _inventRefTransId,
        TaxCode           _taxCode)
    {
        TaxTrans                    taxTransOrig;
        TaxTrans_IN                 taxTransLocalPeriodic;
        ComponentTransactions_IN    settleTransLocal;
        TaxTrans                    taxTransPeriodic;
        Amount                      recoverableAmount;

        while select RefRecId from taxTransLocalPeriodic
        join RecId from taxTransOrig
            where taxTransOrig.InventTransId  == _inventRefTransId
                && taxTransOrig.TaxCode == _taxCode
                && taxTransLocalPeriodic.TaxTransVATRefRecId  == taxTransOrig.RecId
        join RecId from taxTransPeriodic
            where taxTransPeriodic.RecId == taxTransLocalPeriodic.RefRecId
        join RecoverableAmount from settleTransLocal
            where settleTransLocal.TransRecid == taxTransPeriodic.RecId
        {
            recoverableAmount += settleTransLocal.RecoverableAmount;
        }

        return recoverableAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPOTAdvanceLedgerDimension_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the LedgerDimension to which advance payment amount shud be posted in service tax "POT" transaction.
    /// </summary>
    /// <param name="_common">
    /// The dynamic table buffer passed in for POT tax.
    /// </param>
    /// <returns>
    /// The Advance LedgerDimension RecId.
    /// </returns>

    public static LedgerDimensionAccount getPOTAdvanceLedgerDimension_IN(Common _common)
    {
        LedgerDimensionAccount  advanceLedgerDimension;
        RefRecId                taxLedgerAccountsetupRecId;
        DimensionDefault        dimensionDefault;
        TaxModuleType           source;
        TmpTaxWorkTrans         tmpTaxWorkTrans;
        TaxUncommitted          taxUncommitted;
        TaxTable                taxTable;
        RefRecId                taxRegistrationNumberTable;
        TaxTrans                taxTrans;
        CustInvoiceTrans        custInvoiceTrans;
        TaxAccountType_IN       taxAccountType;
        TransTaxInformation     transTaxInformation;

        switch (_common.TableId)
        {
            case tableNum(TmpTaxWorkTrans) :    tmpTaxWorkTrans = _common;
                source = tmpTaxWorkTrans.Source;
                taxTable = TaxTable::find(tmpTaxWorkTrans.TaxCode);
                taxRegistrationNumberTable = tmpTaxWorkTrans.TaxRegistrationNumberTable_IN;
                dimensionDefault = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(tmpTaxWorkTrans.LedgerDimension);
                if (source == TaxModuleType::Purch)
                {
                    taxAccountType = TaxAccountType_IN::ServiceTaxRecoverableAccount;
                }
                else if ((source == TaxModuleType::Sales) || (source == TaxModuleType::FreeTxtInvoice))
                {
                    taxAccountType = TaxAccountType_IN::ServiceTaxPayableAccount;
                }
                break;
            case tableNum(TaxUncommitted) :     taxUncommitted = _common;// NO SO here
                source = taxUncommitted.Source;
                taxTable = TaxTable::find(taxUncommitted.TaxCode);
                dimensionDefault = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(taxUncommitted.LedgerDimension);
                if (source == TaxModuleType::Purch)
                {
                    PurchLine purchLine = PurchLine::findInventTransId(taxUncommitted.InventTransId);
                    transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(purchLine);
                    taxRegistrationNumberTable = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTable.TaxType_IN).RecId;
                    taxAccountType = TaxAccountType_IN::ServiceTaxRecoverableAccount;
                }
                else if (source == TaxModuleType::FreeTxtInvoice)
                {
                    CustInvoiceLine custInvoliceLine = CustInvoiceLine::findBySourceDocumentLine(taxUncommitted.SourceDocumentLine);
                    transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(custInvoliceLine);
                    taxRegistrationNumberTable = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTable.TaxType_IN).RecId;
                    taxAccountType = TaxAccountType_IN::ServiceTaxPayableAccount;
                }
                break;
            case tableNum(TaxTrans) :           taxTrans = _common;
                source = taxTrans.Source;// Only FTI required.
                if (source == TaxModuleType::FreeTxtInvoice)
                {
                    taxAccountType = TaxAccountType_IN::ServiceTaxPayableAccount;
                    taxTable = TaxTable::find(taxTrans.TaxCode);
                    custInvoiceTrans = CustInvoiceTrans::findRecId(taxTrans.SourceRecId);
                    CustInvoiceLine custInvoliceLine = CustInvoiceLine::findBySourceDocumentLine(taxUncommitted.SourceDocumentLine);
                    transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(custInvoliceLine);
                    taxRegistrationNumberTable = TransTaxInformationHelper::getTaxRegistrationNumbers(transTaxInformation, taxTable.TaxType_IN).RecId;
                }
                dimensionDefault = custInvoiceTrans.DefaultDimension;
                break;
            default:                            break;
        }
        taxLedgerAccountsetupRecId = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::Table, taxRegistrationNumberTable).RecId;
        if (!taxLedgerAccountsetupRecId)
        {
            taxLedgerAccountsetupRecId = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::All).RecId;
        }
        advanceLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountsetupRecId, taxAccountType, taxTable.TaxComponentTable_IN), dimensionDefault);
        return advanceLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getpriceInclTaxAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the table buffer and get the required amount.
    /// </summary>
    /// <param name="_tableId">
    /// The field is used to find the record.
    /// </param>
    /// <param name="_recId">
    /// The field is used to find the record.
    /// </param>
    /// <param name="_taxItemGroup">
    /// The field is used to find the record.
    /// </param>
    /// <param name="_taxWorkTrans">
    /// The buffer is used to find the record.
    /// </param>
    /// <param name="_tmpTaxCalc">
    /// The buffer is used to find the record.
    /// </param>
    /// <returns>
    /// Returns the amount.
    /// </returns>
    static TaxAmountCur getpriceInclTaxAmount_IN(TableId         _tableId,
                                                 RecId           _recId,
                                                 TaxItemGroup    _taxItemGroup,
                                                 TmpTaxWorkTrans _taxWorkTrans,
                                                 TmpTaxCalc_IN   _tmpTaxCalc = null)
    {
        TaxAmountCur        priceInclTaxAmount;
        FormulaDesigner_IN  formulaDesigner;
        TaxableBasis_IN     taxBasis;

        while select _taxWorkTrans
            where _taxWorkTrans.SourceRecId      == _recId                   &&
                  _taxWorkTrans.SourceTableId    == _tableId                 &&
                  _taxWorkTrans.TaxDirection     != TaxDirection::UseTax     &&
                  _taxWorkTrans.TaxOrigin        != TaxOrigin::TaxReversed
        {
            formulaDesigner = FormulaDesigner_IN::findByTaxCode(_taxWorkTrans.TaxItemGroup, _taxWorkTrans.TaxCode);
            if (formulaDesigner.PriceInclTax)
            {
                taxBasis = formulaDesigner.TaxableBasis;
                if (taxBasis == TaxableBasis_IN::ExclAmount)
                {
                    taxBasis = Tax::getTaxableBasis_IN(formulaDesigner);
                }
                select _tmpTaxCalc where
                    _tmpTaxCalc.TaxCode         == _taxWorkTrans.TaxCode    &&
                    _tmpTaxCalc.SourceRecID     == _recId                   &&
                    _tmpTaxCalc.SourceTableID   == _tableId;

                if (TaxTable::find(_taxWorkTrans.TaxCode).TaxType_IN != TaxType_IN::None
                    && (taxBasis == TaxableBasis_IN::LineAmount
                        || taxBasis == TaxableBasis_IN::Assessable))
                {
                    if (!_taxWorkTrans.SourceRegulateAmountCur)
                        priceInclTaxAmount += _taxWorkTrans.SourceTaxAmountCur;
                    else
                        priceInclTaxAmount += _taxWorkTrans.SourceRegulateAmountCur;

                    if (priceInclTaxAmount < 0)
                        priceInclTaxAmount += _tmpTaxCalc.TaxOnCharges;
                    else
                        priceInclTaxAmount -= _tmpTaxCalc.TaxOnCharges;
                }
            }
        }
        return CurrencyExchangeHelper::amount(priceInclTaxAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesPurchJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to get the <c>SalesPurchJournalLine</c> map.
    /// </summary>
    /// <param name="_sourceRecId">
    /// A unique recid.
    /// </param>
    /// <param name="_sourceTableId">
    /// A unique tableId.
    /// </param>
    /// <returns>
    /// Returns the <c>SalesPurchJournalLine</c> map.
    /// </returns>
    static SalesPurchJournalLine  getSalesPurchJournalLine(RecId  _sourceRecId, TableId  _sourceTableId)
    {
        SalesPurchJournalLine       salesPurchJournalLine;
        SalesPurchJournalLineExtension_IN salesPurchJournalLineExtension_IN;
        CustInvoiceLine             custInvoiceLineLoc;
        CustInvoiceTable            custInvoiceTableloc;
        InventTransferLine          inventTransferLineLoc;
        InventQualityOrderTable     inventQualityOrderTableLoc;
        InventTransferTable         inventTransferTable;
        ProjProposalEmpl            projProposalEmpl;
        ProjProposalItem            projProposalItem;
        ProjProposalCost            projProposalCost;
        ProjProposalRevenue         projProposalRevenue;
        ProjProposalOnAcc           projProposalOnAcc;
        InventTransferParmLine      inventTransferParmLineLoc;

        if (_sourceRecId)
        {
            switch (_sourceTableId)
            {
                case tableNum(PurchLine):
                    salesPurchJournalLine = PurchLine::findRecId(_sourceRecId);
                    break;

                case tableNum(VendInvoiceInfoLine):
                    //Below lines of code is to get record from VendInvoiceInfoLine, if its a NON PO line for tax calculation.
                    if (VendInvoiceInfoLine::findRecId(_sourceRecId).isNonPO())
                    {
                        salesPurchJournalLine = VendInvoiceInfoLine::findRecId(_sourceRecId);
                    }
                    else
                    {
                        salesPurchJournalLine = VendInvoiceInfoLine::findRecId(_sourceRecId).purchLine();
                    }
                    break;

                case tableNum(PurchReqLine):
                    salesPurchJournalLine = PurchReqLine::find(_sourceRecId);
                    break;

                case tableNum(SalesLine):
                    salesPurchJournalLine = SalesLine::findRecId(_sourceRecId);
                    break;

                case tableNum(InventTransferLine):
                    inventTransferLineLoc = InventTransferLine::findRecId(_sourceRecId);
                    salesPurchJournalLine = inventTransferLineLoc;
                    break;

                case tableNum(InventTransferParmLine):
                    select firstonly inventTransferParmLineLoc
                        where inventTransferParmLineLoc.RecId == _sourceRecId;
                    inventTransferLineLoc = inventTransferParmLineLoc.inventTransferLine();
                    salesPurchJournalLine = inventTransferLineLoc;
                    break;

                case tableNum(SalesQuotationLine):
                    salesPurchJournalLine = SalesQuotationLine::findRecId(_sourceRecId);
                    break;

                case tableNum(LedgerJournalTrans):
                    salesPurchJournalLine = LedgerJournalTrans::findRecId(_sourceRecId, false);
                    break;

                case tableNum(CustInvoiceLine):
                    select firstonly RecId, ParentRecId, TaxItemGroup,
                        TaxGroup, AmountCur, LineNum from custInvoiceLineLoc
                    where custInvoiceLineLoc.RecId == _sourceRecId;

                    // 1) manually initialize the CurrencyCode and DeliveryLocation
                    // fields because they really exist in the CustInvoiceTable table
                    // 2) the CustInvoiceLine table contains non-persisted fields because
                    // they need to be a part of the SalesPurchJournalLine map
                    custInvoiceTableloc = CustInvoiceTable::findRecId(custInvoiceLineLoc.ParentRecId);
                    custInvoiceLineLoc.CurrencyCode = custInvoiceTableloc.CurrencyCode;
                    custInvoiceLineLoc.DeliveryLocation = custInvoiceTableloc.DeliveryLocation;

                    salesPurchJournalLine = custInvoiceLineLoc;

                    salesPurchJournalLine.SourceTableId = custInvoiceLineLoc.TableId;
                    salesPurchJournalLine.SourceRecId = custInvoiceLineLoc.RecId;

                    salesPurchJournalLineExtension_IN = salesPurchJournalLine.SalesPurchJournalLine::getSalesPurchJournalLineExtension_IN();
                    salesPurchJournalLineExtension_IN.AssessableValue           = custInvoiceLineLoc.custInvoiceLineTaxExtensionIN().AssessableValueTransactionCurrency;
                    salesPurchJournalLine.SalesPurchJournalLine::packSalesPurchJournalLineExtension_IN(salesPurchJournalLineExtension_IN);
                    break;

                case tableNum(PurchRFQLine):
                    salesPurchJournalLine = PurchRFQLine::findRecId(_sourceRecId);
                    break;

                case tableNum(VendInvoiceInfoLine):
                    salesPurchJournalLine  = VendInvoiceInfoLine::findRecId(_sourceRecId).purchLine();
                    break;

                case tableNum(InventQualityOrderTable):
                    if (InventParameters::find().UseQualityManagement)
                    {
                        select firstonly RecId, ReferenceType, InventRefTransId
                            from inventQualityOrderTableLoc
                            where inventQualityOrderTableLoc.RecId == _sourceRecId;

                        if (inventQualityOrderTableLoc.RecId)
                        {
                            switch (inventQualityOrderTableLoc.ReferenceType)
                            {
                                case InventTestReferenceType::Sales:
                                    salesPurchJournalLine = SalesLine::findInventTransId(inventQualityOrderTableLoc.InventRefTransId);
                                    break;

                                case InventTestReferenceType::Purch:
                                    salesPurchJournalLine = PurchLine::findInventTransId(inventQualityOrderTableLoc.InventRefTransId);
                                    break;
                            }
                        }
                    }
                    break;

                // For Project module
                case tableNum(ProjProposalEmpl) :
                    select firstonly TransId from projProposalEmpl
                        where projProposalEmpl.RecId == _sourceRecId;

                    salesPurchJournalLine = ProjEmplTrans::find(projProposalEmpl.TransId).projEmplTransView_IN();
                    break;

                case tableNum(ProjProposalRevenue) :
                    select firstonly TransId from projProposalRevenue
                        where projProposalRevenue.RecId == _sourceRecId;

                    salesPurchJournalLine = ProjRevenueTrans::find(projProposalRevenue.TransId).projRevenueTransView_IN();
                    break;

                case tableNum(ProjProposalItem) :
                    select firstonly ProjTransId, SalesId, InventTransId from projProposalItem
                        where projProposalItem.RecId == _sourceRecId;

                    if (projProposalItem.SalesId)
                    {
                        salesPurchJournalLine = SalesLine::findInventTransId(projProposalItem.InventTransId);
                    }
                    else
                    {
                        salesPurchJournalLine = ProjItemTrans::find(projProposalItem.ProjTransId).projItemTransView_IN();
                    }

                    break;

                case tableNum(ProjProposalCost) :
                    select firstonly TransId from projProposalCost
                        where projProposalCost.RecId == _sourceRecId;

                    salesPurchJournalLine = ProjCostTrans::find(projProposalCost.TransId).projCostTransView_IN();
                    break;

                case tableNum(ProjProposalOnAcc) :
                    select firstonly TransId from projProposalOnAcc
                        where projProposalOnAcc.RecId == _sourceRecId;

                    salesPurchJournalLine = ProjOnAccTrans::find(projProposalOnAcc.TransId).projOnAccTransView_IN();
                    break;
                case tableNum(MarkupTrans):
                    salesPurchJournalLine = MarkupTrans::findRecId(_sourceRecId);
                    break;
            }
        }
        return  salesPurchJournalLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSuframaDiscount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates Suframa discount in tax values
    /// </summary>
    /// <param name="_taxGroup">
    /// Tax group to calculate discount
    /// </param>
    /// <param name="_taxItemGroup">
    /// Item tax group to calculate discount
    /// </param>
    /// <param name="_onICMS">
    /// Defines if there is Suframa discount for ICMS tax
    /// </param>
    /// <param name="_onPISCOFINS">
    /// Defines if there is Suframa discount for PIS/COFINS taxes
    /// </param>
    /// <returns>
    /// A container with tax values discounts
    /// </returns>
    public static container getSuframaDiscount_BR(TaxGroup _taxGroup, TaxItemGroup _taxItemGroup, boolean _onICMS, boolean _onPISCOFINS)
    {
        TaxGroupData    taxGroupData;
        TaxOnItem       taxOnItem;
        TaxTable        taxTable;
        TaxData         taxData;
        TaxValue        amountICMS;
        TaxValue        amountPIS;
        TaxValue        amountCOFINS;

        while select ExemptTax from taxGroupData
          where taxGroupData.TaxGroup   == _taxGroup
        join WithoutTaxCredit_BR, ExemptTax_BR from taxOnItem
          where taxOnItem.TaxItemGroup  == _taxItemGroup
             && taxOnItem.TaxCode       == taxGroupData.TaxCode
        {
            taxTable    = TaxTable::find(taxOnItem.TaxCode);
            taxData     = TaxData::find(taxOnItem.TaxCode, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), 0);

            if (!taxTable.TaxSubstitution_BR
                && (taxOnItem.WithoutTaxCredit_BR || taxOnItem.ExemptTax_BR || taxGroupData.ExemptTax))
            {
                switch (taxTable.TaxType_BR)
                {
                    case TaxType_BR::ICMS:
                        amountICMS      += _onICMS      ? taxData.TaxValue : 0.0;
                        break;
                    case TaxType_BR::PIS:
                        amountPIS       += _onPISCOFINS ? taxData.TaxValue : 0.0;
                        break;
                    case TaxType_BR::COFINS:
                        amountCOFINS    += _onPISCOFINS ? taxData.TaxValue : 0.0;
                        break;
                }
            }
        }

        return [amountICMS, amountPIS, amountCOFINS];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxableBasis_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the table buffer and get the required field.
    /// </summary>
    /// <param name="_formulaDesigner">
    /// The buffer is used to find the record.
    /// </param>
    /// <returns>
    /// Returns the value.
    /// </returns>
    static TaxableBasis_IN getTaxableBasis_IN(FormulaDesigner_IN     _formulaDesigner)
    {
        str                     delimiterVal;
        Counter                 position = 1,
                                leftPosition,
                                rightPosition;
        CalcExp_IN              code;
        int                     length;
        FormulaDesigner_IN      formulaDesigner;
        TaxableBasis_IN         taxBasis;
        boolean                 isExclLineAmt;

        length = strLen(_formulaDesigner.CalcExp1);
        while (position <= length)
        {
            delimiterVal = subStr(_formulaDesigner.CalcExp1, position+1, 1);
            leftPosition = position+1;
            rightPosition   = strFind(_formulaDesigner.CalcExp1, delimiterVal, position + 2, length - (position+1));
            code            = subStr(_formulaDesigner.CalcExp1, leftPosition + 1, rightPosition - leftPosition - 1);
            if (delimiterVal == num2char(164))
            {
                formulaDesigner = FormulaDesigner_IN::findByTaxCode(_formulaDesigner.TaxItemGroup, code);
                taxBasis = formulaDesigner.TaxableBasis;
                if (taxBasis == TaxableBasis_IN::ExclAmount)
                {
                    isExclLineAmt = true;
                }
                else if (taxBasis != TaxableBasis_IN::ExclAmount)
                {
                    isExclLineAmt = false;
                }
            }
            position = rightPosition + 1;
        }
        if (isExclLineAmt)
        {
            taxBasis = Tax::getTaxableBasis_IN(formulaDesigner);
        }
        return taxBasis;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxValue_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the table buffer and get the required TaxValue.
    /// </summary>
    /// <param name="_transDate">
    /// The field is used to find the record.
    /// </param>
    /// <param name="_taxCode">
    /// The field is used to find the record.
    /// </param>
    /// <param name="_baseAmountCur">
    /// The field is used to find the record.
    /// </param>
    /// <param name="_salesPurchJournalLine">
    /// The map is used to find the record.
    /// </param>
    /// <returns>
    /// Returns TaxValue.
    /// </returns>
    static TaxValue getTaxValue_IN(TransDate                   _transDate,
                                   TaxCode                     _taxCode,
                                   AmountCur                   _baseAmountCur,
                                   SalesPurchJournalLine        _salesPurchJournalLine)

    {
        TaxValue                            taxValue;
        TaxType_IN                          taxType;
        LedgerJournalTrans                  ledgerJournalTrans;
        VendTable                           vendTable;
        VendTable                           vendTableOff;
        PurchLine                           purchLine;
        VendInvoiceInfoLine                 vendInvoiceInfoLine;
        TransTaxInformation                 transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformation(_salesPurchJournalLine.SourceTableId, _salesPurchJournalLine.SourceRecId);

        taxType = TaxTable::find(_taxCode).TaxType_IN;
        if (_salesPurchJournalLine.SourceTableId == tableNum(VendInvoiceInfoLine))
        {
            vendInvoiceInfoLine             = _salesPurchJournalLine;
        }
        switch (taxType)
        {
            case TaxType_IN::SalesTax :
                taxValue = TaxData::findFormType_IN(_taxCode, transTaxInformation.SalesTaxFormTypes,_transDate,_baseAmountCur).TaxValue;
                return  taxValue;
            case TaxType_IN::VAT:
                taxValue = TaxData::find(_taxCode, _transDate,_baseAmountCur).TaxValue;
                return  taxValue;

            case TaxType_IN::Excise:
                taxValue = TaxData::findExciseType_IN(_taxCode, transTaxInformation.ExciseTariffCodes,_transDate,_baseAmountCur).TaxValue;
                if (_salesPurchJournalLine.SourceTableId == tableNum(LedgerJournalTrans))
                {
                    ledgerJournalTrans = _salesPurchJournalLine;
                    if (ledgerJournalTrans)
                    {
                        vendTable    = VendTable::find(ledgerJournalTrans.parmAccount());
                        vendTableOff = VendTable::find(ledgerJournalTrans.parmOffsetAccount());
                    }
                }
                else if (_salesPurchJournalLine.SourceTableId == tableNum(PurchLine))
                {
                    if (purchLine)
                    {
                        vendTable    = VendTable::find(purchLine.purchTable().OrderAccount);
                    }
                }
                else if (_salesPurchJournalLine.SourceTableId == tableNum(VendInvoiceInfoLine))
                {
                    if (vendInvoiceInfoLine)
                    {
                        vendTable    = VendTable::find(vendInvoiceInfoLine.orderAccount());
                    }
                }
                if (vendTable || vendTableOff)
                {
                    if (vendTable.isSSI() || vendTableOff.isSSI())
                    {
                        taxValue = TaxData::findExciseType_IN(_taxCode, transTaxInformation.ExciseTariffCodes,_transDate,_baseAmountCur).ConcessionalValue_IN;
                    }
                }
                return  taxValue;

            case TaxType_IN::ServiceTax:
                taxValue = TaxData::find(_taxCode, _transDate,_baseAmountCur).TaxValue;
                return  taxValue;

            case TaxType_IN::Customs:
                taxValue = TaxData::getCustomsPercent_IN(_salesPurchJournalLine, _taxCode, _transDate, _baseAmountCur);
                return  taxValue;
        }
        return taxValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidTaxGroupIntersection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value which indicates if the combination of <c>TaxGroup</c> and <c>TaxItemGroup</c> are valid.
     /// Please consider to use isValidTaxGroupIntersectionV2 to handle tax integration case.
    /// </summary>
    /// <param name="_taxGroup">
    ///     The <c>TaxGroup</c> from the document line.
    /// </param>
    /// <param name="_taxItemGroup">
    ///     The <c>TaxItemGroup</c> from the document line.
    /// </param>
    /// <returns>
    ///     A value which indicates if an error or warning occured.
    /// </returns>
    public static CheckTaxGroups isValidTaxGroupIntersection(TaxGroup _taxGroup, TaxItemGroup _taxItemGroup)
    {
        return Tax::isValidTaxGroupIntersectionForInterCompany(_taxGroup, _taxItemGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidTaxGroupIntersectionV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value which indicates if the combination of <c>TaxGroup</c> and <c>TaxItemGroup</c> are valid.
    /// Bypasses the check if tax integration is enabled. Instead, the check is done in <c>TaxIntegrationTaxCodeCheckActivityOnLine</c>.
    /// </summary>
    /// <param name="_taxGroup">The <c>TaxGroup</c> from the document line.</param>
    /// <param name="_taxItemGroup">The <c>TaxItemGroup</c> from the document line.</param>
    /// <param name="_isTaxIntegrationEnabled">A boolean which indicates if tax integration is enabled for current transaction</param>
    /// <returns>A value which indicates if an error or warning occured.</returns>
    public static CheckTaxGroups isValidTaxGroupIntersectionV2(TaxGroup _taxGroup,
        TaxItemGroup _taxItemGroup,
        boolean _isTaxIntegrationEnabled = false)
    {
        if (_isTaxIntegrationEnabled)
        {
            return CheckTaxGroups::None;
        }
        return Tax::isValidTaxGroupIntersection(_taxGroup, _taxItemGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidTaxGroupIntersectionForInterCompanyV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value which indicates if the combination of <c>TaxGroup</c> and <c>TaxItemGroup</c> are valid.
    /// Bypasses the check if tax integration is enabled. Instead, the check is done in <c>TaxIntegrationTaxCodeCheckActivityOnLine</c>.
    /// </summary>
    /// <param name="_taxGroup">The <c>TaxGroup</c> from the document line.</param>
    /// <param name="_taxItemGroup">The <c>TaxItemGroup</c> from the document line.</param>
    /// <param name="_dataAreaIdPostInterCompany">The dataAreaId for intercompany.</param>
    /// <param name="_isTaxIntegrationEnabled">A boolean which indicates if tax integration is enabled for current transaction</param>
    /// <returns>A value which indicates if an error or warning occured.</returns>
    public static CheckTaxGroups isValidTaxGroupIntersectionForInterCompanyV2(
        TaxGroup _taxGroup,
        TaxItemGroup _taxItemGroup,
        DataAreaId _dataAreaIdPostInterCompany = '',
        boolean _isTaxIntegrationEnabled = false)
    {
        if (_isTaxIntegrationEnabled)
        {
            return CheckTaxGroups::None;
        }
        return Tax::isValidTaxGroupIntersectionForInterCompany(_taxGroup, _taxItemGroup, _dataAreaIdPostInterCompany);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidTaxGroupIntersectionForInterCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value which indicates if the combination of <c>TaxGroup</c> and <c>TaxItemGroup</c> are valid.
    /// Please consider to use isValidTaxGroupIntersectionV2 to handle tax integration case.
    /// </summary>
    /// <param name="_taxGroup">
    ///     The <c>TaxGroup</c> from the document line.
    /// </param>
    /// <param name="_taxItemGroup">
    ///     The <c>TaxItemGroup</c> from the document line.
    /// </param>
    /// <param name="_dataAreaIdPostInterCompany">
    ///     The dataAreaId for intercompany.
    /// </param>
    /// <returns>
    ///     A value which indicates if an error or warning occured.
    /// </returns>
    public static CheckTaxGroups isValidTaxGroupIntersectionForInterCompany(
        TaxGroup _taxGroup,
        TaxItemGroup _taxItemGroup,
        DataAreaId _dataAreaIdPostInterCompany = '')
    {
        TaxOnItem           taxOnItem;
        TaxGroupData        taxGroupData;
        CheckTaxGroups      checkIntersection;
        CheckTaxGroups      returnValue = CheckTaxGroups::None;

        if (_taxGroup && _taxItemGroup)
        {
            checkIntersection = TaxParameters::find().CheckIntersection;

            if (checkIntersection == CheckTaxGroups::Warning || checkIntersection == CheckTaxGroups::Error)
            {
                if (_dataAreaIdPostInterCompany)
                {
                    changecompany(_dataAreaIdPostInterCompany)
                    {
                        select firstonly RecId from taxGroupData
                            where taxGroupData.TaxGroup == _taxGroup
                            exists join taxOnItem
                                where taxOnItem.TaxCode == taxGroupData.TaxCode
                                    && taxOnItem.TaxItemGroup == _taxItemGroup;
                    }
                }
                else
                {
                    select firstonly RecId from taxGroupData
                        where taxGroupData.TaxGroup == _taxGroup
                        exists join taxOnItem
                            where taxOnItem.TaxCode == taxGroupData.TaxCode
                                && taxOnItem.TaxItemGroup == _taxItemGroup;
                }

                if (!taxGroupData)
                {
                    switch (checkIntersection)
                    {
                        case CheckTaxGroups::Error:
                            returnValue = CheckTaxGroups::Error;
                            error(strFmt('@Tax:Validation_GroupItemGroupIntersectionInvalid', _taxGroup, _taxItemGroup));
                            break;

                        case CheckTaxGroups::Warning:
                            returnValue = CheckTaxGroups::Warning;
                            warning(strFmt('@Tax:Validation_GroupItemGroupIntersectionInvalid', _taxGroup, _taxItemGroup));
                            break;

                        default:
                            break;
                    }
                }
            }
        }
        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>netTaxTotalMSTVoucherDate</Name>
				<Source><![CDATA[
    static AmountMST netTaxTotalMSTVoucherDate(Voucher           _voucher,
                                                      TransDate         _date,
                                                      LedgerJournalId   _ledgerJournalId)
    {
        TaxTrans     taxTrans;
        ;
        taxTrans.selectLocked(false);

        select

            sum(TaxAmount),
            sum(TaxInCostPriceMST)
        from taxTrans
        where taxTrans.Voucher          == _voucher                 &&
              taxTrans.TransDate        == _date                    &&
              taxTrans.JournalNum       != _ledgerJournalId         &&
              taxTrans.TaxDirection     != TaxDirection::UseTax     &&
              taxTrans.TaxOrigin        != TaxOrigin::TaxReversed   &&
              taxTrans.TaxOrigin        != TaxOrigin::Transfer;

        return taxTrans.TaxAmount - taxTrans.TaxInCostPriceMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>netTaxTotalVoucherDate</Name>
				<Source><![CDATA[
    static TaxAmountCur netTaxTotalVoucherDate(Voucher           _voucher,
                                                      TransDate         _date,
                                                      LedgerJournalId   _ledgerJournalId)
    {
        TaxTrans     taxTrans;
        TaxAmountCur taxAmountCur;
        ;
        taxTrans.selectLocked(false);

        while select

            sum(SourceTaxAmountCur), sum(SourceRegulateAmountCur),
            sum(TaxInCostPrice), sum(TaxInCostPriceRegulated)
        from taxTrans
        group by TaxAutogenerated
        where taxTrans.Voucher          == _voucher                 &&
              taxTrans.TransDate        == _date                    &&
              taxTrans.JournalNum       != _ledgerJournalId         &&
              taxTrans.TaxDirection     != TaxDirection::UseTax     &&
              taxTrans.TaxOrigin        != TaxOrigin::TaxReversed   &&
              taxTrans.TaxOrigin        != TaxOrigin::Transfer
        {
            if (!taxTrans.TaxAutogenerated)
                taxAmountCur += taxTrans.SourceRegulateAmountCur - taxTrans.TaxInCostPriceRegulated;
            else
                taxAmountCur += taxTrans.SourceTaxAmountCur - taxTrans.TaxInCostPrice;
        }

        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packagingQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates packaging quantity.
    /// </summary>
    /// <param name = "_qtyFrom">Starting quantity.</param>
    /// <param name = "_unitFrom">Unit converting from.</param>
    /// <param name = "_itemId">The item ID for the conversion.</param>
    /// <param name = "_inventDimId">The dimension ID for conversion.</param>
    /// <param name = "_skipException">Specifies whether to throw error or not on conversion.</param>
    /// <returns>The converted quantity.</returns>
    public static Qty packagingQuantity(
        Qty                  _qtyFrom,
        UnitOfMeasureSymbol  _unitFrom,
        ItemId               _itemId,
        InventDimId          _inventDimId,
        boolean              _skipException = false)
    {
        Qty                 packagingQty;
        InventTable         inventTable  = InventTable::find(_itemId);
        UnitOfMeasureSymbol inventUnitId = inventTable.inventUnitId();

        if (inventUnitId != _unitFrom)
        {
            EcoResProductUnitConverter ecoResConverter = EcoResProductUnitConverter::newGivenUnitSymbolsForReleasedProduct(_itemId,
                                                                                                                           _inventDimId,
                                                                                                                           _unitFrom,
                                                                                                                           inventUnitId,
                                                                                                                           NoYes::Yes,
                                                                                                                           NoYes::Yes);
            ecoResConverter.parmSkipException(_skipException);

            packagingQty = ecoResConverter.convertValue(_qtyFrom) * InventTable.TaxPackagingQty;
        }
        else
        {
            packagingQty = inventTable.TaxPackagingQty * _qtyFrom;
        }

        return packagingQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packagingQty</Name>
				<Source><![CDATA[
    [SysObsolete('This method is deprecated use packagingQuantity instead', false, 12\06\2020)]
    static Qty packagingQty(
        Qty                  _qtyFrom,
        UnitOfMeasureSymbol  _unitFrom,
        ItemId               _itemId,
        boolean              _skipException = false)
    {
        return Tax::packagingQuantity(_qtyFrom, _unitFrom, _itemId, '', _skipException);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postHandler_BR</Name>
				<Source><![CDATA[
    [PreHandlerFor(classStr(Tax), methodStr(Tax, post))]
    /// <summary>
    ///  Observes the event that fires after calling the post method.
    /// </summary>
    /// <param name="_args">
    /// A <c>XppPrePostArgs</c> that encapsulates the arguments passed in call of post method.
    /// </param>
    public static void postHandler_BR(XppPrePostArgs _args)
    {
        Tax tax = _args.getThis();

        if (!BrazilParameters::isEnabled())
        {
            return;
        }

        tax.postPost_BR(_args.getArg('_ledgerPostingController'),

                        _args.getArg('_taxTrans'),
                        _args.getArg('_taxAmount'),
                        _args.getArg('_chargeAmount'),
                        _args.getArg('_exchRateHelper'),
                        _args.getArg('_ledgerDimension'),
                        _args.getArg('_operationLedgerDimension'),
                        _args.getArg('_taxOffsetUseTaxLedgerDimension'));
    }

]]></Source>
			</Method>
			<Method>
				<Name>potentialSalesTax</Name>
				<Source><![CDATA[
    static boolean potentialSalesTax(TaxGroup         _taxGroup,
                                            TaxItemGroup     _taxItemGroup,
                                            TransDate        _taxDate,
                                            TaxModuleType    _taxModuleType,
                                            TaxDirection     _taxDirection   = TaxDirection::OutgoingTax)
    {
        TaxGroupData    taxGroupData;
        TaxOnItem       taxOnItem;

        TaxTable        taxTable;
        TaxData         taxData;
        ;
        if (_taxModuleType == TaxModuleType::Voucher && prmisDefault(_taxDirection))

            throw error(Error::wrongUseOfFunction(funcName()));

        if (!_taxGroup || !_taxItemGroup)

            return false;

        while select forceplaceholders taxGroupData

            where taxGroupData.TaxGroup     == _taxGroup
            join TableId from taxOnItem
            where taxOnItem.TaxItemGroup    == _taxItemGroup     &&
                  taxOnItem.TaxCode         == taxGroupData.TaxCode
            join TaxCode, TaxBase from taxTable
                where taxTable.TaxCode      == taxGroupData.TaxCode
        {
            if (taxGroupData.ExemptTax)
                return false;   //Only exemptTax

            if (Tax::determineTaxDirection(_taxModuleType, taxGroupData, _taxDirection) == TaxDirection::UseTax)

                return false;   //Only use tax

            boolean isTaxBaseTypeSupported;
            boolean hasPotentialSalesTax;
            [hasPotentialSalesTax, isTaxBaseTypeSupported] = Tax::potentialSalesTaxByTaxBaseType(
                taxTable.TaxBase,
                taxGroupData.TaxCode,
                _taxDate);
            if (!isTaxBaseTypeSupported)
            {
                throw error(Error::wrongUseOfFunction(funcName()));
            }
            if (hasPotentialSalesTax)
            {
                return true;
            }

            select count(TaxValue) from taxData

                where taxData.TaxCode == taxGroupData.TaxCode &&
                      ((taxData.TaxFromDate <= _taxDate &&
                        taxData.TaxToDate   >= _taxDate) ||
                        ! taxData.TaxFromDate);
            if (taxData.TaxValue > 1)
                return true;    //Multiple tax values
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>potentialSalesTaxByTaxBaseType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the percentage is not zero for the specific tax base type.
    /// </summary>
    /// <param name = "_taxBase">The tax base type.</param>
    /// <param name = "_taxCode">The tax code.</param>
    /// <param name = "_taxDate">The tax date.</param>
    /// <returns>
    /// Container with 2 boolean values:
    /// <list type="bullet">
    /// <item>
    /// <description>First boolean: true, if the percentage for the tax base type is not zero; otherwise, false.</description>
    /// </item>
    /// <item>
    /// <description>Second boolean: true, if the tax base type is supported; otherwise, false.</description>
    /// </item>
    /// </list>
    /// </returns>
    protected static container potentialSalesTaxByTaxBaseType(
        TaxBaseType _taxBase,
        TaxCode _taxCode,
        TransDate _taxDate)
    {
        boolean isTaxBaseTypeSupported = true;
        boolean hasPotentialSalesTax;
        switch (_taxBase)
        {
            case TaxBaseType::PctGrosOnNet:
                if (Tax::calcPctGrosOnNet(TaxData::percent(_taxCode,_taxDate,0)))
                {
                    hasPotentialSalesTax = true;    //Percentage is not zero
                }
                break;

            case TaxBaseType::PctPerGross:
            case TaxBaseType::PctPerNet:
            case TaxBaseType::PctPerTax:
                if (TaxData::percent(_taxCode,_taxDate,0))
                {
                    hasPotentialSalesTax = true;    //Percentage is not zero
                }
                break;

            case TaxBaseType::AmountByUnit:
                if (TaxData::percent(_taxCode,_taxDate,0))
                {
                    hasPotentialSalesTax = true;    //Percentage is not zero
                }
                break;

            default:
                isTaxBaseTypeSupported = false;
                break;
        }

        return [hasPotentialSalesTax, isTaxBaseTypeSupported];
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseChargeTotal_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates total reverse charge tax amount for voucher.
    /// </summary>
    /// <param name="_voucher">
    ///     Voucher for which amount is calculated.
    /// </param>
    /// <param name="_date">
    ///     Date for which amount is calculated.
    /// </param>
    /// <returns>
    ///     Calculated reverse charge amount.
    /// </returns>
    /// <remarks>
    ///     For sales orders, there's no amount in transactions, only base. For purchase orders amount is taken from reversed transaction.
    /// </remarks>
    public static TaxAmountCur reverseChargeTotal_W(
        Voucher            _voucher,
        TransDate          _date)
    {
        TaxAmountCur    reverseChargeTotal;
        TaxTrans        taxTrans;

        taxTrans.selectLocked(false);

        // Get the sum for all the tax records that have corrected tax amounts
        while select taxTrans
            where   taxTrans.Voucher          == _voucher
                &&  taxTrans.TransDate        == _date
                &&  taxTrans.ReverseCharge_W  == NoYes::Yes
                &&  taxTrans.TaxDirection     == TaxDirection::OutgoingTax
        {
            if (taxTrans.ExemptTax)
            {
                reverseChargeTotal -= CurrencyExchangeHelper::amount(taxTrans.SourceBaseAmountCur * taxTrans.TaxValue / 100, taxTrans.SourceCurrencyCode);
            }
            else
            {
                reverseChargeTotal -= taxTrans.SourceRegulateAmountCur;
            }
        }

        return reverseChargeTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundDeferredAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rounds deferred amount.
    /// </summary>
    /// <param name="_amount">
    /// The instance of the <c>Amount</c> class.
    /// </param>
    /// <returns>
    /// The result of the round amount.
    /// </returns>
    public static Amount roundDeferredAmount(Amount _amount)
    {
        return roundUpDec(_amount, 2);
    }

]]></Source>
			</Method>
			<Method>
				<Name>showTaxes</Name>
				<Source><![CDATA[
    static FormRun showTaxes(str _menuItemDisplayStr,
                                    Tax     _tax,
                                    Common  _record     = null,
                                    FormRun _formRun    = null,
                                    OpenMode _openMode  = OpenMode::Auto)
    {
        Args            args;
        FormRun         formRun;

        args = new Args();
        args.caller(_tax);
        args.record(_record);
        args.parmObject(_formRun);
        args.openMode(_openMode);

        formRun = new MenuFunction(_menuItemDisplayStr, MenuItemType::Display).create(args);

        formRun.run();

        return formRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountCorrectedPerLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total adjusted tax posted to <c>TaxTrans</c> in transaction currency for a given line. Reversed transactions with <c>TaxOrigin</c> set to tax reversed are not counted.
    /// </summary>
    /// <param name = "_voucher">The voucher number of the posting</param>
    /// <param name = "_date">The transaction date</param>
    /// <param name = "_sourceRecId">The recId of the source transaction</param>
    /// <returns>The total adjusted tax posted to <c>TaxTrans</c> in transaction currency for a given line.</returns>
    public static TaxAmountCur taxAmountCorrectedPerLine(Voucher   _voucher,
                                                 TransDate  _date,
                                                 RecId      _sourceRecId)
    {
        TaxTrans     taxTrans;

        taxTrans.selectLocked(false);

        select
            sum(SourceRegulateAmountCur)
        from taxTrans
        where taxTrans.Voucher          == _voucher  &&
              taxTrans.TransDate        == _date     &&
             (taxTrans.SourceRecId      == _sourceRecId ||
             (taxTrans.SourceRecId      == 0 && !_sourceRecId)) &&
              taxTrans.TaxOrigin        != TaxOrigin::TaxReversed;

        return taxTrans.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountCorrectedPerVoucher</Name>
				<Source><![CDATA[
    static TaxAmountCur taxAmountCorrectedPerVoucher(Voucher    _voucher,
                                                     TransDate  _date)
    {
        TaxTrans     taxTrans;
        ;
        taxTrans.selectLocked(false);

        select

            sum(SourceRegulateAmountCur)
        from taxTrans
        where taxTrans.Voucher          == _voucher  &&
              taxTrans.TransDate        == _date     &&
              taxTrans.TaxOrigin        != TaxOrigin::TaxReversed &&
              taxTrans.TaxOrigin        != TaxOrigin::Transfer;

        return taxTrans.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountToSubtract</Name>
				<Source><![CDATA[
    static TaxAmountCur taxAmountToSubtract(Voucher      _voucher,
                                                   TransDate    _date,
                                                   RecId        _sourceRecId)
    {
        TaxTrans     taxTrans;
        AmountCur    taxAmountCur;
        ;
        taxTrans.selectLocked(false);

        while select

            sum(SourceTaxAmountCur),
            sum(SourceRegulateAmountCur),
            sum(TaxInCostPrice),
            sum(TaxInCostPriceRegulated)
        from taxTrans
        group by TaxDirection, TaxAutogenerated
        where taxTrans.Voucher          == _voucher  &&
              taxTrans.TransDate        == _date     &&
             (taxTrans.SourceRecId      == _sourceRecId ||
              taxTrans.SourceRecId      == 0 )       &&
             (taxTrans.TaxDirection     == TaxDirection::IncomingTax ||
              taxTrans.TaxDirection     == TaxDirection::OutgoingTax ||
              taxTrans.TaxDirection     == TaxDirection::UseTax) &&
              taxTrans.TaxOrigin        != TaxOrigin::TaxReversed &&
              taxTrans.TaxOrigin        != TaxOrigin::Transfer
        {
            if (taxTrans.TaxDirection == TaxDirection::UseTax)
            {
                if (taxTrans.TaxInCostPriceRegulated)
                {
                    taxAmountCur -= taxTrans.TaxInCostPriceRegulated;
                }
                else
                {
                    taxAmountCur -= taxTrans.TaxInCostPrice;
                }
            }
            else
            {
                if (taxTrans.TaxAutogenerated)
                {
                    if (TaxParameters::find().PurchTaxOnOperations)
                    {
                        taxAmountCur += taxTrans.SourceTaxAmountCur;
                    }
                    else
                    {
                        taxAmountCur += taxTrans.SourceTaxAmountCur - taxTrans.TaxInCostPrice;
                    }
                }
                else
                {
                    if (TaxParameters::find().PurchTaxOnoperations)
                    {
                        taxAmountCur += taxTrans.SourceRegulateAmountCur;
                    }
                    else
                    {
                        taxAmountCur += taxTrans.SourceRegulateAmountCur - taxTrans.TaxInCostPriceRegulated;
                    }
                }
            }
        }
        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxItemGroup</Name>
				<Source><![CDATA[
    static TaxItemGroup taxItemGroup()
    {
        return TaxParameters::find().TaxItemGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxNegativeTotalVoucherDate</Name>
				<Source><![CDATA[
    static TaxAmountCur taxNegativeTotalVoucherDate(Voucher     _voucher,
                                                    TransDate   _date)
    {
        TaxTrans     taxTrans;
        TaxTable     taxTable;
        TaxAmountCur taxAmountCur;
        ;
        taxTrans.selectLocked(false);
        while select
            sum(SourceTaxAmountCur), sum(SourceRegulateAmountCur)
        from taxTrans
        index hint VoucherDateIdx
        group by TaxCode, TaxAutogenerated
        where taxTrans.Voucher          == _voucher  &&
              taxTrans.TransDate        == _date     &&
              taxTrans.TaxDirection     != TaxDirection::UseTax &&
              taxTrans.TaxOrigin        != TaxOrigin::TaxReversed &&
              taxTrans.TaxOrigin        != TaxOrigin::Transfer
        join TaxCode, NegativeTax from taxTable
            index hint TaxIdx
            where taxTable.TaxCode == taxTrans.TaxCode
            &&    taxTable.NegativeTax == NoYes::Yes
        {
            if (!taxTrans.TaxAutogenerated)
                taxAmountCur += taxTrans.SourceRegulateAmountCur;
            else
                taxAmountCur += taxTrans.SourceTaxAmountCur;
        }

        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxTotal</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the total tax for the voucher, date, and journal number.
    /// </summary>
    /// <param name="_voucher">
    ///   The voucher.
    /// </param>
    /// <param name="_date">
    ///   The transaction date.
    /// </param>
    /// <param name="_journalNum">
    ///   The journal number.
    /// </param>
    /// <param name="_includeReversed">
    ///   true if reversed taxes should be included in the total; otherwise, false; optional.
    /// </param>
    /// <param name="_includeUseTax">
    ///   true if use tax should be included in the total; otherwise, false; optional.
    /// </param>
    /// <returns>
    ///   The total actual tax in transactional currency.
    /// </returns>
    public static TaxAmountCur taxTotal(Voucher            _voucher,
                                        TransDate          _date,
                                        LedgerJournalId    _journalNum = '',
                                        boolean            _includeReversed = true,
                                        boolean            _includeUseTax = false)
    {
        TaxAmountCur taxTotal;
        TaxTrans    taxTrans;
        // <GBR>
        TaxTable    taxTable;
        // </GBR>

        taxTrans.selectLocked(false);

        // Get the sum for all the tax records that have corrected tax amounts
        select
            sum(SourceRegulateAmountCur)
        from taxTrans
        where   taxTrans.Voucher          == _voucher
            &&  taxTrans.TransDate        == _date
            &&  (taxTrans.TaxDirection     != TaxDirection::UseTax || _includeUseTax)
            &&  (taxTrans.TaxOrigin        != TaxOrigin::Transfer || taxTrans.Source == TaxModuleType::Voucher) &&
            (!_journalNum || taxTrans.JournalNum == _journalNum) &&
            (_includeReversed || taxTrans.TaxOrigin != TaxOrigin::TaxReversed);

        taxTotal = taxTrans.SourceRegulateAmountCur;

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            // Remove taxes included in price from total
            select

                sum(SourceRegulateAmountCur)
            from taxTrans
            where   taxTrans.Voucher          == _voucher
                &&  taxTrans.TransDate        == _date
                &&  (taxTrans.TaxDirection     != TaxDirection::UseTax || _includeUseTax)
                &&  taxTrans.TaxOrigin        != TaxOrigin::Transfer &&
                (!_journalNum || taxTrans.JournalNum == _journalNum) &&
                (_includeReversed || taxTrans.TaxOrigin != TaxOrigin::TaxReversed)
            exists join taxTable
                where taxTable.TaxCode == taxTrans.TaxCode
                    && (taxTable.IncludedTax_BR == NoYes::Yes || taxTable.RetainedTax_BR == NoYes::Yes);

            taxTotal -= taxTrans.SourceRegulateAmountCur;
        }
        // </GBR>

        return taxTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxTotal_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the table buffer and get the required amount.
    /// </summary>
    /// <param name="_ledger">
    /// The table buffer is used to find the record.
    /// </param>
    /// <returns>
    /// Returns the amount.
    /// </returns>
    static TaxAmountCur taxTotal_IN(LedgerJournalTrans _ledger)
    {
        TaxTrans    taxTrans;
        AmountCur   sourceRegulateAmountCur;

        taxTrans.selectLocked(false);

        while select SourceTaxAmountCur, TaxCode from taxTrans
            where taxTrans.Voucher == _ledger.Voucher
        {
            if (TaxTable::find(taxTrans.TaxCode).TaxType_IN == TaxType_IN::None)
            {
                sourceRegulateAmountCur += taxTrans.SourceTaxAmountCur;
            }
        }
        return sourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxTotalMSTVoucherDate</Name>
				<Source><![CDATA[
    static AmountMST taxTotalMSTVoucherDate(Voucher     _voucher,
                                            TransDate   _date)
    {
        TaxTrans     taxTrans;
        ;
        taxTrans.selectLocked(false);
        select
            sum(TaxAmount)
        from taxTrans
        where taxTrans.Voucher          == _voucher  &&
              taxTrans.TransDate        == _date     &&
              taxTrans.TaxDirection     != TaxDirection::UseTax &&
              taxTrans.TaxOrigin        != TaxOrigin::TaxReversed &&
              taxTrans.TaxOrigin        != TaxOrigin::Transfer;

        return taxTrans.TaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxTotalsPosted</Name>
				<Source><![CDATA[
    [Replaceable(true)]
    static TaxAmountCur taxTotalsPosted(Voucher          _voucher,
                                        TransDate        _date,
                                        RecId            _sourceRecId,
                                        RecordSortedList _taxTotals)
    {
        TaxTrans       taxTrans;
        TmpTaxTotals   tmpTaxTotals;
        TaxAmountCur   taxAmountCur;
        Query          query;

        query = Tax::getTaxTotalPostedQuery(_voucher, _date, _sourceRecId);
        QueryRun queryRun = new QueryRun(query);
        while(QueryRun.next())
        {
            taxTrans = queryRun.get(tableNum(TaxTrans));
            tmpTaxTotals.clear();

            Tax::initFromTaxTrans(tmpTaxTotals, taxTrans);
            _taxTotals.find(tmpTaxTotals);

            tmpTaxTotals.addByTaxTrans(taxTrans);
            _taxTotals.ins(tmpTaxTotals, true);
            taxAmountCur += taxTrans.SourceTaxAmountCur;
        }
        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxTotalVoucherDate</Name>
				<Source><![CDATA[
    static TaxAmountCur taxTotalVoucherDate(Voucher     _voucher,
                                            TransDate   _date)
    {
        TaxTrans     taxTrans;
        TaxAmountCur taxAmountCur;
        // <GIN>
        TaxTable     taxTable;
        // </GIN>
        ;
        taxTrans.selectLocked(false);
        //<GIN>
        // This the case for GTA vendor where Tax does not hit vendor and Dr & Cr entries post to seperate entries.
        // If we use standard routine the Dr & Cr entries will nullify and return zero, which is incorrect for service tax.
        if (TaxParameters::isServiceTaxEnable_IN())
        {
            select sum(SourceRegulateAmountCur) from taxTrans
                where taxTrans.Voucher       == _voucher
                    && taxTrans.TransDate    == _date
                    && taxTrans.TaxDirection != TaxDirection::UseTax
                    && taxTrans.TaxOrigin    != TaxOrigin::TaxReversed
                    && taxTrans.TaxOrigin    != TaxOrigin::Transfer
                    && taxTrans.SourceRegulateAmountCur > 0 // Filtering explicitly Debit entries, to avoid cancellation for GTA vendor scenario.
                exists join taxTable
                    where taxTable.TaxCode == taxTrans.TaxCode
                       && taxTable.TaxType_IN != TaxType_IN::None;
        }
        if (taxTrans.SourceRegulateAmountCur)
        {
            return taxTrans.SourceRegulateAmountCur;
        }
        else
        {
            //</GIN>
            while select

                sum(SourceTaxAmountCur), sum(SourceRegulateAmountCur)
            from taxTrans
            group by TaxAutogenerated
            where taxTrans.Voucher          == _voucher  &&
                  taxTrans.TransDate        == _date     &&
                  taxTrans.TaxDirection     != TaxDirection::UseTax &&
                  taxTrans.TaxOrigin        != TaxOrigin::TaxReversed &&
                  taxTrans.TaxOrigin        != TaxOrigin::Transfer
            {
                if (!taxTrans.TaxAutogenerated)
                    taxAmountCur += taxTrans.SourceRegulateAmountCur;
                else
                    taxAmountCur += taxTrans.SourceTaxAmountCur;
            }
            // <GIN>
        }
        // </GIN>

        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxTotalVoucherDateRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total tax on a given voucher, date and line.
    /// </summary>
    /// <param name = "_voucher">The voucher number to return the total tax for</param>
    /// <param name = "_date">The date of the transaction</param>
    /// <param name = "_sourceRecId">The RecId of the transaction</param>
    /// <param name = "_applyRegulateAmount">Should adjustments be taken into account; optional</param>
    /// <param name = "_detectTaxOrigin">Should reversed transactions be taken into account; optional</param>
    /// <param name = "_includeUseTax">Should use tax transactions be taken into account; optional</param>
    /// <returns>The total tax on a given voucher, date and line.</returns>
    static TaxAmountCur taxTotalVoucherDateRecId(Voucher    _voucher,
                                                 TransDate  _date,
                                                 RecId      _sourceRecId,
                                                 boolean    _applyRegulateAmount = false,
                                                 boolean    _detectTaxOrigin = true,
                                                 boolean    _includeUseTax = true)
    {
        TaxTrans     taxTrans;
        TaxAmountCur taxAmountCur;

        taxTrans.selectLocked(false);

        while select

            sum(SourceTaxAmountCur),
            sum(SourceRegulateAmountCur)
        from taxTrans
        group by TaxAutogenerated
        where taxTrans.Voucher          == _voucher  &&
              taxTrans.TransDate        == _date     &&
             (taxTrans.SourceRecId      == _sourceRecId ||
              (taxTrans.SourceRecId      == 0 && !_sourceRecId ))       &&
             (taxTrans.TaxOrigin        != TaxOrigin::TaxReversed || !_detectTaxOrigin) &&
             (taxTrans.TaxDirection     != TaxDirection::UseTax   || _includeUseTax)
        {
            if (_applyRegulateAmount && !taxTrans.TaxAutogenerated)

                taxAmountCur += taxTrans.SourceRegulateAmountCur;
            else
                taxAmountCur += taxTrans.SourceTaxAmountCur;
        }

        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxTotalVoucherDateRecId_RU</Name>
				<Source><![CDATA[
    public static TaxAmountCur taxTotalVoucherDateRecId_RU(Voucher   _voucher,
                                                           TransDate _date,
                                                           RecId     _sourceRecId)
    {
        TaxTrans     taxTrans;
        ;
        taxTrans.selectLocked(false);

        select sum(SourceTaxAmountCur), sum(SourceRegulateAmountCur) from taxTrans

            where taxTrans.Voucher          == _voucher               &&
                  taxTrans.TransDate        == _date                  &&
                 (taxTrans.SourceRecId      == _sourceRecId           ||
                  taxTrans.SourceRecId      == 0)                     &&
                  taxTrans.TaxDirection     != TaxDirection::UseTax   &&
                  taxTrans.TaxOrigin        != TaxOrigin::TaxReversed &&
                  taxTrans.TaxOrigin        != TaxOrigin::Transfer;

        if (taxTrans.SourceRegulateAmountCur)

        {
            return taxTrans.SourceRegulateAmountCur;
        }

        return taxTrans.SourceTaxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewLedgerDimensionDueToAccountStructureChange</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Get the ledger dimension of the posting transaction if the account structure has changed.
    /// </summary>
    /// <param name="_taxLedgerDimension">
    ///    The ledger dimension of the tax transaction.
    /// </param>
    /// <returns>
    ///    The ledger dimension according to new account structure.
    /// </returns>
    static LedgerDimensionAccount getNewLedgerDimensionDueToAccountStructureChange(LedgerDimensionAccount  _taxLedgerDimension = 0)
    {
        LedgerRecId ledgerRecId = Ledger::current();
        LedgerDimensionAccount ledgerDimensionAccount;
        DimensionDefault dimensionDefault;
        LedgerDimensionBase newLedgerDimension;

        // When the hierarchy is not associated with the ledger anymore, then create a new ledger dimension.
        ledgerDimensionAccount = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(_taxLedgerDimension);
        dimensionDefault = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_taxLedgerDimension);
        newLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionAccount, dimensionDefault);

        return newLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromTaxWorkTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the current <c>TaxTrans</c> record using the <c>TmpTaxWorkTrans</c> record passed in.
    /// </summary>
    /// <param name = "_taxTrans">The <c>TaxTrans</c> record.</param>
    /// <param name = "_taxWorkTrans">The <c>TmpTaxWorkTrans</c> record.</param>
    /// <param name = "_taxOrigin">The tax origin.</param>
    protected void initFromTaxWorkTrans(TaxTrans _taxTrans, TmpTaxWorkTrans _taxWorkTrans, TaxOrigin _taxOrigin)
    {
        _taxTrans.initFromTaxWorkTrans(_taxWorkTrans, _taxOrigin);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the current <c>TaxTrans</c> record using the <c>TaxUncommitted</c> record passed in.
    /// </summary>
    /// <param name="_taxTrans">
    /// The <c>TaxTrans</c> record.
    /// </param>
    /// <param name="_taxUncommitted">
    /// The <c>TaxUncommitted</c> record.
    /// </param>
    /// <param name = "_taxOrigin">The tax origin.</param>
    protected void initFromTaxUncommitted(TaxTrans _taxTrans, TaxUncommitted _taxUncommitted, TaxOrigin _taxOrigin)
    {
        _taxTrans.initFromTaxUncommitted(_taxUncommitted, _taxOrigin);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to post the tax transaction.
    /// </summary>
    /// <param name = "_taxAmount">
    /// The tax amount.
    /// </param>
    /// <param name = "_ledgerPostingController">
    /// The instance of <c>LedgerPostingController</c>.
    /// </param>
    /// <returns>
    /// True if there is tax amount, otherwise, false.
    /// </returns>
    public boolean canPostTrans(TaxAmount _taxAmount, LedgerPostingController _ledgerPostingController)
    {
        return _taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSaveAndPostTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to save and post the tax transaction.
    /// </summary>
    /// <param name = "_taxWorkTrans">
    /// The tax work transaction.
    /// </param>
    /// <param name = "_taxTrans">
    /// Tax transaction.
    /// </param>
    /// <param name = "_taxAmountCur">
    /// Tax amount in tax currency.
    /// </param>
    /// <param name = "_ledgerPostingController">
    /// The instance of <c>LedgerPostingController</c>.
    /// </param>
    /// <returns>
    /// True if it can save and post trans, otherwise, false.
    /// </returns>
    public boolean canSaveAndPostTrans(TmpTaxWorkTrans _taxWorkTrans, TaxTrans _taxTrans, TaxAmountCur _taxAmountCur, LedgerPostingController _ledgerPostingController)
    {
        return _taxWorkTrans.ExemptTax == NoYes::No && (_taxAmountCur || _taxTrans.TaxAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReportingCurrencyExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets reporting currency exchange rate.
    /// </summary>
    /// <param name = "_reportingCurrencyExchRate">The reporting currency exchange rate.</param>
    /// <returns>Returns the reporting currency exchange rate.</returns>
    public ReportingCurrencyExchRate parmReportingCurrencyExchRate(ReportingCurrencyExchRate _reportingCurrencyExchRate = reportingCurrencyExchRate)
    {
        reportingCurrencyExchRate = _reportingCurrencyExchRate;

        return reportingCurrencyExchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReportingCurrencyExchRateSecondary</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets reporting currency exchange rate secondary.
    /// </summary>
    /// <param name = "_reportingCurrencyExchRateSecondary">The reporting currency exchange rate secondary.</param>
    /// <returns>Returns the reporting currency exchange rate secondary.</returns>
    public ReportingCurrencyExchRateSecondary parmReportingCurrencyExchRateSecondary(ReportingCurrencyExchRateSecondary _reportingCurrencyExchRateSecondary = reportingCurrencyExchRateSecondary)
    {
        reportingCurrencyExchRateSecondary = _reportingCurrencyExchRateSecondary;

        return reportingCurrencyExchRateSecondary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxTotalQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the total tax amount.
    /// </summary>
    /// <param name = "_voucher">
    /// Voucher number.
    /// </param>
    /// <param name = "_date">
    /// Trans date.
    /// </param>
    /// <param name = "_sourceRecId">
    /// Source RecId.
    /// </param>
    /// <returns>
    /// The query object for get the total tax amount.
    /// </returns>
    [
        Hookable(true),
        Replaceable(true)
    ]
    protected Query getTaxTotalQuery(Voucher   _voucher,
                                     TransDate _date,
                                     RecId     _sourceRecId)
    {
        Query                   query;
        QueryBuildDataSource    qbds;

        query = new Query();
        qbds = query.addDataSource(tablenum(TmpTaxWorkTrans));

        qbds.orderMode(OrderMode::GroupBy);
        qbds.addGroupByField(FieldNum(TmpTaxWorkTrans, TaxCode));
        qbds.addGroupByField(FieldNum(TmpTaxWorkTrans, TaxDirection));
        qbds.addGroupByField(FieldNum(TmpTaxWorkTrans, SourceCurrencyCode));
        qbds.addGroupByField(FieldNum(TmpTaxWorkTrans, NegativeTax));
        qbds.addGroupByField(FieldNum(TmpTaxWorkTrans, TaxAutogenerated));
        qbds.addGroupByField(FieldNum(TmpTaxWorkTrans, TaxOrigin));

        qbds.addSelectionField(fieldNum(TmpTaxWorkTrans, TaxAmount), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(TmpTaxWorkTrans, SourceTaxAmountCur), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(TmpTaxWorkTrans, SourceRegulateAmountCur), SelectionField::Sum);

        qbds.addRange(FieldNum(TmpTaxWorkTrans, IsDeleted)).value(queryValue(NoYes::No));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxTotalPostedQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the total posted tax amount.
    /// </summary>
    /// <param name = "_voucher">
    /// Voucher number.
    /// </param>
    /// <param name = "_date">
    /// Trans date.
    /// </param>
    /// <param name = "_sourceRecId">
    /// Source RecId.
    /// </param>
    /// <returns>
    /// The query object for get the total posted tax amount.
    /// </returns>
    [
        Replaceable(true),
        Hookable(true)
    ]
    protected static query getTaxTotalPostedQuery(Voucher   _voucher,
                                                  TransDate _date,
                                                  RecId     _sourceRecId)
    {
        Query  query = new Query();
        QueryBuildDataSource    qbds;
        QueryBuildRange         qbr;

        qbds = query.addDataSource(tablenum(TaxTrans));

        qbds.orderMode(OrderMode::GroupBy);
        qbds.addGroupByField(FieldNum(TaxTrans, TaxCode));
        qbds.addGroupByField(FieldNum(TaxTrans, TaxDirection));
        qbds.addGroupByField(FieldNum(TaxTrans, SourceCurrencyCode));
        qbds.addGroupByField(FieldNum(TaxTrans, TaxAutogenerated));

        qbds.addSelectionField(fieldNum(TaxTrans, SourceTaxAmountCur), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(TaxTrans, SourceRegulateAmountCur), SelectionField::Sum);

        qbds.addRange(FieldNum(TaxTrans, Voucher)).value(queryValue(_voucher));
        qbds.addRange(FieldNum(TaxTrans, TransDate)).value(queryValue(_date));
        qbr = qbds.addRange(FieldNum(TaxTrans, SourceRecId));
        qbr.value(strfmt(
            '(%1 == %2) ||(%1 == %3)',
            fieldstr(TaxTrans, SourceRecId),
            SysQuery::value(_sourceRecId),
            0));

        qbds.addRange(FieldNum(TaxTrans, TaxOrigin)).value(SysQuery::valueNot(TaxOrigin::TaxReversed));
        qbds.addRange(FieldNum(TaxTrans, TaxOrigin)).value(SysQuery::valueNot(TaxOrigin::Transfer));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromTmpTaxWorkTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>TmpTaxTotals</c> from <c>TmpTaxWorkTrans</c>.
    /// </summary>
    /// <param name = "tmpTaxTotals">
    /// The instance of <c>TmpTaxTotals</c>.
    /// </param>
    /// <param name = "_taxWorkTrans">
    /// The buffer of <c>TmpTaxWorkTrans</c>.
    /// </param>
    [Replaceable(true)]
    protected void initFromTmpTaxWorkTrans(TmpTaxTotals tmpTaxTotals, TmpTaxWorkTrans _taxWorkTrans)
    {
        tmpTaxTotals.TaxCode      = _taxWorkTrans.TaxCode;
        tmpTaxTotals.TaxDirection = _taxWorkTrans.TaxDirection;
        tmpTaxTotals.CurrencyCode = _taxWorkTrans.SourceCurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>TmpTaxTotals</c> from <c>TaxTrans</c>.
    /// </summary>
    /// <param name = "tmpTaxTotals">
    /// The instance of <c>TmpTaxTotals</c>.
    /// </param>
    /// <param name = "_taxTrans">
    /// The buffer of <c>TaxTrans</c>.
    /// </param>
    [Replaceable(true)]
    protected static void initFromTaxTrans(TmpTaxTotals tmpTaxTotals, TaxTrans _taxTrans)
    {
        tmpTaxTotals.TaxCode      = _taxTrans.TaxCode;
        tmpTaxTotals.TaxDirection = _taxTrans.TaxDirection;
        tmpTaxTotals.CurrencyCode = _taxTrans.SourceCurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>query</Name>
				<Source><![CDATA[
    /// <summary>
    /// Query for <c>TmpTax</c>.
    /// </summary>
    /// <param name = "_taxCalculationOrder">
    /// Value of <c>TaxCalculationOrder</c>.
    /// </param>
    /// <returns>
    /// The queryRun object of <c>TmpTax</c>.
    /// </returns>
    [Hookable(true)]
    protected QueryRun query(TaxCalculationOrder _taxCalculationOrder)
    {
        Query                   query;
        QueryBuildDataSource    qbds;
        QueryRun                queryRun;
        query = new Query();
        qbds = query.addDataSource(tablenum(TmpTax));

        qbds.orderMode(OrderMode::GroupBy);
        qbds.addGroupByField(FieldNum(TmpTax, TaxCode));
        qbds.addGroupByField(FieldNum(TmpTax, TaxDirection));
        qbds.addGroupByField(FieldNum(TmpTax, CalculationDate));
        qbds.addGroupByField(FieldNum(TmpTax, Warning));
        qbds.addGroupByField(FieldNum(TmpTax, SourceCurrencyCode));
        qbds.addGroupByField(FieldNum(TmpTax, Company));

        // <GBR>
        qbds.addGroupByField(FieldNum(TmpTax, TaxFiscalValue_BR));
        qbds.addGroupByField(FieldNum(TmpTax, TaxReceivableLongTerm_BR));
        // </GBR>

        qbds.addSelectionField(fieldNum(TmpTax, TaxBaseAmountMSTRaw), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(TmpTax, TaxBaseAmountMST), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(TmpTax, TaxAmountCur), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(TmpTax, TaxBaseAmountCur), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(TmpTax, TaxAmountMST), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(TmpTax, TaxInCostPrice), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(TmpTax, TaxInCostPriceCur), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(TmpTax, TaxInCostPriceMST), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(TmpTax, TaxBaseQty), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(TmpTax, SourceTaxAmountCur), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(TmpTax, SourceTaxAmountCurReal), SelectionField::Sum);

        // <GIN>
        qbds.addSelectionField(fieldNum(TmpTax, CustomsDuty_IN), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(TmpTax, EximTaxAmount_IN), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(TmpTax, EximBalanceTaxAmount_IN), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(TmpTax, EximDEPBAmount_IN), SelectionField::Sum);
        // </GIN>

        // <GBR>
        qbds.addSelectionField(fieldNum(TmpTax, TaxSubstitutionAmountAddedMST_BR), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(TmpTax, SourceTaxSubstitutionAmountAddedCur_BR), SelectionField::Sum);
        // </GBR>

        qbds.addRange(FieldNum(TmpTax, TaxCalculationOrder)).value(queryValue(_taxCalculationOrder));

        queryRun = new QueryRun(query);
        queryRun.setRecord(tmpTax);

        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOutGoingTaxPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to post for out going tax.
    /// </summary>
    /// <param name = "_taxTrans">
    /// The <c>TaxTrans</c> record.
    /// </param>
    /// <returns>
    /// True if post for out going tax, otherwise, false.
    /// </returns>
    [Hookable(true)]
    Protected boolean isOutGoingTaxPost(TaxTrans _taxTrans)
    {
        return !this.taxParameters().PurchTaxOnOperations || _taxTrans.TaxDirection == TaxDirection::OutgoingTax;

    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxIncomingPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to post for in coming tax.
    /// </summary>
    /// <param name = "_taxTrans">
    /// The <c>TaxTrans</c> record.
    /// </param>
    /// <returns>
    /// True if post for in coming tax, otherwise, false.
    /// </returns>
    [Hookable(true)]
    Protected boolean isTaxIncomingPost(TaxTrans _taxTrans)
    {
        return this.taxParameters().PurchTaxOnOperations
            && (_taxTrans.TaxDirection == TaxDirection::IncomingTax
                || _taxTrans.TaxDirection == TaxDirection::UseTax)
            && this.postSalesTaxReceivableAmounts();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPostCharges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to post the charges.
    /// </summary>
    /// <param name = "_taxTrans">
    /// The instance of <c>TaxTrans</c> table.
    /// </param>
    /// <param name = "_chargeAmount">
    /// The charge amount.
    /// </param>
    /// <returns>
    /// True if there is charge amount and not apply sales tax taxation rules, otherwise, false.
    /// </returns>
    [Hookable(true)]
    Protected boolean isPostCharges(TaxTrans _taxTrans, TaxAmountCur _chargeAmount)
    {
        return _chargeAmount && !this.taxParameters().PurchTaxOnOperations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPostSourceTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to post the source tax amount.
    /// </summary>
    /// <param name = "_taxTrans">
    /// The <c>TaxTrans</c> record.
    /// </param>
    /// <returns>
    /// True if post the source tax amount, otherwise, flase.
    /// </returns>
    [Hookable(true)]
    protected boolean isPostSourceTaxAmount(TaxTrans _taxTrans)
    {
        return ! this.taxParameters().PurchTaxOnOperations || _taxTrans.TaxDirection == TaxDirection::OutgoingTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPostOutGoingTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to post the out going tax.
    /// </summary>
    /// <param name = "_taxTrans">
    /// The <c>TaxTrans</c> record.
    /// </param>
    /// <returns>
    /// True if post for out going tax, otherwise, false.
    /// </returns>
    [Hookable(true)]
    Protected boolean isPostOutGoingTax(TaxTrans _taxTrans)
    {
        return ! this.taxParameters().PurchTaxOnOperations || _taxTrans.TaxDirection == TaxDirection::OutgoingTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPostTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to post the tax amount.
    /// </summary>
    /// <param name = "_taxWorkTrans">
    /// The instance of <c>TmpTaxWorkTrans</c> table.
    /// </param>
    /// <returns>
    /// True if there is tax code, otherwise, false.
    /// </returns>
    [Hookable(true)]
    Protected boolean isPostTaxAmount(TmpTaxWorkTrans _taxWorkTrans)
    {
        if (_taxWorkTrans.TaxCode)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCheckTaxCodeForTaxSubstitution_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates if tax code should be checked for tax substitution for BR
    /// </summary>
    /// <returns>True if check should be copmleted; otherwise, false.</returns>
    [Replaceable]
    protected boolean shouldCheckTaxCodeForTaxSubstitution_BR()
    {
        //Per confirmation from PM, we will skip validation on purpose, however, we will still keep the logic just in case.
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTaxableDocumentLineCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the taxable transaction line count
    /// </summary>
    protected void calcTaxableDocumentLineCount()
    {
        TaxUncommitted          taxUncommitted;
        container               uncommitedTransactionLines;
        container               uncommitedTransactionLineRecord;
        TaxTable                taxTableLoc;

        if (taxableDocumentLines > 0)
        {
            return;
        }

        select count(RecId) from taxWorkTrans;
        if(taxWorkTrans.RecId > 0)
        {
            while select count(RecId) from taxWorkTrans group by SourceTableId, SourceRecId
            {
                taxableDocumentLines ++;
            }
        }
        else
        {
            while select SourceTableId, SourceRecId, TaxCode from taxUncommitted
                where taxUncommitted.HeadingRecId   == this.headingRecId()
                   && taxUncommitted.HeadingTableId == this.headingTableId()
                   && taxUncommitted.ExemptTax      == NoYes::No
                   && taxUncommitted.TaxAmountCur
                join RecId, TaxType_IN from taxTableLoc
                    where taxTableLoc.TaxCode       == taxUncommitted.TaxCode
                       && taxTableLoc.TaxType_IN    != TaxType_IN::None
            {
                uncommitedTransactionLineRecord = [taxUncommitted.SourceTableId, taxUncommitted.SourceRecId];
                if(conFind(uncommitedTransactionLines, uncommitedTransactionLineRecord) == 0)
                {
                    uncommitedTransactionLines = conIns(uncommitedTransactionLines, 1, uncommitedTransactionLineRecord);
                }
            }
            taxableDocumentLines = conLen(uncommitedTransactionLines);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForIntersectionAndDisplayErrorMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check for single intersection and send error message if found multiple intersection
    /// </summary>
    /// <param name = "_taxGroup">The tax group.</param>
    /// <param name = "_taxItemGroup">The tax item group.</param>
    /// <param name="_found">
    /// A Boolean value that indicates whether tax codes that match were found in both the tax group and
    /// the item tax group.
    /// </param>
    /// <param name = "_company">Company name.</param>
    /// <param name = "_cachedResult">The cached result.</param>
    [Replaceable]
    protected void checkForIntersectionAndDisplayErrorMessage(TaxGroup            _taxGroup,
                                                              TaxItemGroup        _taxItemGroup,
                                                              boolean             _found,
                                                              SelectableDataArea  _company,
                                                              container           _cachedResult = conNull())
    {
        if (this.checkIntersection(_found, _taxGroup, _taxItemGroup))
        {
            changecompany(_company)
            {
                switch (this.taxParameters().CheckIntersection)
                {
                    case CheckTaxGroups::Warning :
                        warning(strFmt("@Tax:Validation_GroupItemGroupIntersectionWithoutValidTaxCodes", _taxGroup, _taxItemGroup));
                        break;

                    case CheckTaxGroups::Error :
                        throw error(strFmt("@Tax:Validation_GroupItemGroupIntersectionWithoutValidTaxCodes", _taxGroup, _taxItemGroup));

                    default :
                        break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateWithoutCreditDebitOther</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates other amounts in case when taxation is without credit/debit.
    /// </summary>
    protected void calculateWithoutCreditDebitOther()
    {
        taxWorkTrans.SourceOtherBaseAmount_BR = taxWorkTrans.SourceBaseAmountCur;
        taxWorkTrans.SourceOtherBaseTaxAmount_BR = taxWorkTrans.SourceTaxAmountCur;
        
        taxWorkTrans.SourceOtherBaseAmountMST_BR = taxWorkTrans.TaxBaseAmount;
        taxWorkTrans.SourceOtherTaxAmountMST_BR = taxWorkTrans.TaxAmount;
        
        if (taxWorkTrans.TaxReductionPct_BR != 0)
        {
            taxWorkTrans.SourceExemptBaseAmount_BR = taxWorkTrans.TaxBaseAmountOrig - taxWorkTrans.SourceBaseAmountCur;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxCurrencyConversionFeatureEnabled</Name>
				<Source><![CDATA[
    protected boolean isTaxCurrencyConversionFeatureEnabled()
    {            
        DataAreaId currentCompany = curext();

        if (!taxCurrencyConversionByCompanyMap.exists(currentCompany))
        {
            taxCurrencyConversionByCompanyMap.insert(currentCompany, TaxCurrencyConversionFeatureExposure::isEnabled());
        }
        return taxCurrencyConversionByCompanyMap.lookup(currentCompany);
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeSignForReverseCharge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether change sign for reverse charge.
    /// </summary>
    /// <param name = "_common">The instance of the <c>Common</c> class.</param>
    /// <returns>true if change sign; otherwise, false.</returns>
    public static boolean changeSignForReverseCharge(Common _common)
    {
        TaxTrans taxTrans;
        TmpTaxWorkTrans tmpTaxWorkTrans;
        boolean changeSignForReverseCharge = true;

        if (_common is TaxTrans)
        {
            taxTrans = _common;
            if (taxTrans.ReverseCharge_W)
            {
                if (taxTrans.SourceTableId == tableNum(LedgerJournalTrans))
                {
                    LedgerJournalTrans ledgerJournalTrans = LedgerJournalTrans::findRecId(taxTrans.SourceRecId, false);
                    if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
                        || ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend
                        || ledgerJournalTrans.AccountType == LedgerJournalACType::Project
                        || ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project)
                    {
                        changeSignForReverseCharge = false;
                    }
                    else if (ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
                    {
                        LedgerJournalTrans ledgerJournalTransLoc;
                        select firstonly RecId from ledgerJournalTransLoc
                            where ledgerJournalTransLoc.Voucher == ledgerJournalTrans.Voucher
                                && ledgerJournalTransLoc.JournalNum == ledgerJournalTrans.JournalNum
                                && (ledgerJournalTransLoc.AccountType == LedgerJournalACType::Vend
                                    || ledgerJournalTransLoc.AccountType == LedgerJournalACType::Project);

                        if (ledgerJournalTransLoc)
                        {
                            changeSignForReverseCharge = false;
                        }

                        if (changeSignForReverseCharge
                           && MainAccountLegalEntity::findByMainAccountLegalEntity(ledgerJournalTrans.findMainAccount().RecId, CompanyInfo::current()).TaxDirection == SalesPurch::Purch)
                        {
                            select firstonly RecId from ledgerJournalTransLoc
                                where ledgerJournalTransLoc.Voucher == ledgerJournalTrans.Voucher
                                    && ledgerJournalTransLoc.JournalNum == ledgerJournalTrans.JournalNum
                                    && ledgerJournalTransLoc.AccountType != LedgerJournalACType::Ledger;

                            if (ledgerJournalTransLoc.RecId == 0)
                            {
                                changeSignForReverseCharge = false;
                            }
                        }
                    }
                }
                if (taxTrans.Source == TaxModuleType::Purch
                    || taxTrans.Source == TaxModuleType::PurchInvoice
                    || taxTrans.Source == TaxModuleType::TransferOrderReceive)
                {
                    changeSignForReverseCharge = false;
                }

                if (TaxCashDiscReverseChargeVendPaymentSignCorrectionFlight::instance().isEnabled()
                    && taxTrans.SourceTableId == tableNum(VendTrans) 
                    && taxTrans.HeadingTableId == tableNum(VendInvoiceJour))
                {
                    VendTrans vendTrans = VendTrans::find(taxTrans.SourceRecId);
                    VendTrans vendTransPayment = VendTrans::find(vendTrans.OffsetRecid);
                    if (vendTransPayment.TransType == LedgerTransType::Payment && vendTrans.CashDiscCode)
                    {
                        changeSignForReverseCharge = false;
                    }
                }
            }
        }
        else if(_common is TmpTaxWorkTrans)
        {
            tmpTaxWorkTrans = _common;
            if (tmpTaxWorkTrans.ReverseCharge_W)
            {
                if (tmpTaxWorkTrans.SourceTableId == tableNum(LedgerJournalTrans))
                {
                    LedgerJournalTrans ledgerJournalTrans = LedgerJournalTrans::findRecId(tmpTaxWorkTrans.SourceRecId, false);
                    if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
                        || ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend
                        || ledgerJournalTrans.AccountType == LedgerJournalACType::Project
                        || ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project)
                    {
                        changeSignForReverseCharge = false;
                    }
                    else if (ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
                    {
                        LedgerJournalTrans ledgerJournalTransLoc;
                        select firstonly RecId from ledgerJournalTransLoc
                            where ledgerJournalTransLoc.Voucher == ledgerJournalTrans.Voucher
                                && ledgerJournalTransLoc.JournalNum == ledgerJournalTrans.JournalNum
                                && (ledgerJournalTransLoc.AccountType == LedgerJournalACType::Vend
                                    || ledgerJournalTransLoc.AccountType == LedgerJournalACType::Project);

                        if (ledgerJournalTransLoc)
                        {
                            changeSignForReverseCharge = false;
                        }

                        if (changeSignForReverseCharge
                           && MainAccountLegalEntity::findByMainAccountLegalEntity(ledgerJournalTrans.findMainAccount().RecId, CompanyInfo::current()).TaxDirection == SalesPurch::Purch)
                        {
                            select firstonly RecId from ledgerJournalTransLoc
                                where ledgerJournalTransLoc.Voucher == ledgerJournalTrans.Voucher
                                    && ledgerJournalTransLoc.JournalNum == ledgerJournalTrans.JournalNum
                                    && ledgerJournalTransLoc.AccountType != LedgerJournalACType::Ledger;

                            if (ledgerJournalTransLoc.RecId == 0)
                            {
                                changeSignForReverseCharge = false;
                            }
                        }
                    }
                }
                if (tmpTaxWorkTrans.Source == TaxModuleType::Purch
                    || tmpTaxWorkTrans.Source == TaxModuleType::PurchInvoice
                    || tmpTaxWorkTrans.Source == TaxModuleType::TransferOrderReceive)
                {
                    changeSignForReverseCharge = false;
                }
            }
        }
        
        return changeSignForReverseCharge;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxIntegrationEnabledForTaxService</Name>
				<Source><![CDATA[
    internal static boolean isTaxIntegrationEnabledForTaxService()
    {
        return TaxIntegrationUtils::isTaxIntegrationEnabledForAdvancedTaxCalculation()
            || TaxIntegrationUtils::isTaxIntegrationEnabledForTaxSolutionProvider();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxIntegrationEnabledForBusinessProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether Tax Integration is enabled for specified business process.
    /// </summary>
    /// <param name = "_businessProcess">The business process.</param>
    /// <returns>Whether Tax Integration is enabled.</returns>
    public static boolean isTaxIntegrationEnabledForBusinessProcess(TaxIntegrationBusinessProcess _businessProcess)
    {
        boolean ret;
        TaxSolutionProviderType solutionProvider = TaxIntegrationUtils::getTaxSolutionProviderTypeByBusinessProcess(_businessProcess);

        switch (solutionProvider)
        {
            case TaxSolutionProviderType::Microsoft:
                ret = TaxIntegrationUtils::isTaxIntegrationEnabledForAdvancedTaxCalculation();
                break;
            case TaxSolutionProviderType::ISV:
                ret = TaxIntegrationUtils::isTaxIntegrationEnabledForTaxSolutionProvider();
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxIntegrationEnabledForTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether Tax Integration is enabled.
    /// </summary>
    /// <param name = "_refTableId">The table id.</param>
    /// <returns>Whether Tax Integration is enabled.</returns>
    public static boolean isTaxIntegrationEnabledForTable(RefTableId _refTableId)
    {
        switch (_refTableId)
        {
            case tableNum(SalesTable):
            case tableNum(SalesLine):
            case tableNum(SalesParmTable):
            case tableNum(SalesParmLine):
            case tableNum(SalesQuotationTable):
            case tableNum(SalesQuotationLine):
            case tableNum(CustPrepaymentInvoiceTable):
            case tableNum(CustPrepaymentInvoiceLine):
                return Tax::isTaxIntegrationEnabledForBusinessProcess(TaxIntegrationBusinessProcess::Sales);
            case tableNum(PurchTable):
            case tableNum(PurchLine):
            case tableNum(VendInvoiceInfoTable):
            case tableNum(VendInvoiceInfoSubTable):
            case tableNum(VendInvoiceInfoLine):
            case tableNum(PurchParmTable):
            case tableNum(PurchParmLine):
            case tableNum(PurchReqLine):
            case tableNum(PurchRFQCaseTable):
            case tableNum(PurchRFQCaseLine):
            case tableNum(PurchRFQTable):
            case tableNum(PurchRFQLine):
                return Tax::isTaxIntegrationEnabledForBusinessProcess(TaxIntegrationBusinessProcess::Purchase);
            case tableNum(InventTransferTable):
            case tableNum(InventTransferLine):
            case tableNum(InventTransferParmTable):
            case tableNum(InventTransferParmLine):
            case tableNum(InventTransferJour):
            case tableNum(InventTransferJourLine):
                return Tax::isTaxIntegrationEnabledForBusinessProcess(TaxIntegrationBusinessProcess::Inventory);
            case tableNum(CustInvoiceTable):
            case tableNum(CustInvoiceLine):
                return Tax::isTaxIntegrationEnabledForBusinessProcess(TaxIntegrationBusinessProcess::FTI);
            case tableNum(LedgerJournalTable):
            case tableNum(LedgerJournalTrans):
                return Tax::isTaxIntegrationEnabledForBusinessProcess(TaxIntegrationBusinessProcess::Journal);
            case tableNum(ProjProposalJour):
            case tableNum(ProjProposalCost):
            case tableNum(ProjProposalEmpl):
            case tableNum(ProjProposalItem):
            case tableNum(ProjProposalOnAcc):
            case tableNum(ProjProposalRevenue):
            case tableNum(ProjAdvancedJournal):
            case tableNum(ProjAdvancedJournalLine):
                return Tax::isTaxIntegrationEnabledForBusinessProcess(TaxIntegrationBusinessProcess::Project);
            case tableNum(PlSADTable):
            case tableNum(PlSADTrans):
            case tableNum(PlSADFinanceTable):
            case tableNum(PlSADFinanceLines):
                return Tax::isTaxIntegrationEnabledForBusinessProcess(TaxIntegrationBusinessProcess::SADDocument);
            default:
                return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUseTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the <c>LedgerJournalTrans</c> is use tax.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The <c>LedgerJournalTrans</c> object is used to relate <c>TaxTrans</c> to validate use tax.</param>
    /// <returns>true if it is use tax; otherwise, false.</returns>
    internal static boolean isUseTax(LedgerJournalTrans _ledgerJournalTrans)
    {
        TaxTrans taxTrans;

        select firstonly TaxDirection from taxTrans
            where taxTrans.Voucher == _ledgerJournalTrans.Voucher
                && taxTrans.TransDate == _ledgerJournalTrans.TransDate
                && taxTrans.SourceRecId == _ledgerJournalTrans.RecId
                && taxTrans.SourceTableId == _ledgerJournalTrans.TableId
                && taxTrans.ExemptTax == NoYes::No;

        return taxTrans.TaxDirection == TaxDirection::UseTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPctTaxCodeMap</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal Map parmPctTaxCodeMap(Map _pctTaxCodeMap = pctTaxCodeMap)
    {
        pctTaxCodeMap = _pctTaxCodeMap;
        return pctTaxCodeMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNonePctTaxCodeMap</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal Map parmNonePctTaxCodeMap(Map _nonePctTaxCodeMap = nonePctTaxCodeMap)
    {
        nonePctTaxCodeMap = _nonePctTaxCodeMap;
        return nonePctTaxCodeMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDualBase_BR</Name>
				<Source><![CDATA[
    private boolean isDualBase_BR(TaxTable _taxTable, TmpTax _tmpTax)
    {
        boolean ret;

        ret = _taxTable.TaxType_BR == TaxType_BR::ICMSDiff
            && (_tmpTax.TaxDirection == TaxDirection::UseTax
                || (FeatureStateProvider::isFeatureEnabled(TaxCalculationDualBaseForARFeature_BR::instance())
                    && (taxModuleType == TaxModuleType::Sales
                        || taxModuleType == TaxModuleType::FreeTxtInvoice)));

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateTaxCodeMap</Name>
				<Source><![CDATA[
    protected void generateTaxCodeMap()
    {
        if (this.allowAdjustBaseAmountForTaxAdjustment() && this.lineAmountIncludesTax())
        {
            Map pctTaxCodeMapLoc = new Map(Types::Int64, Types::Int64);
            Map nonePctTaxCodeMapLoc = new Map(Types::Int64, Types::Int64);

            TaxCalculationAdjustmentAdjustBaseForTaxIncludedMapHelper::generateTaxCodeMap(taxWorkTrans, pctTaxCodeMapLoc, nonePctTaxCodeMapLoc);
            this.parmPctTaxCodeMap(pctTaxCodeMapLoc);
            this.parmNonePctTaxCodeMap(nonePctTaxCodeMapLoc);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearTaxCodeMap</Name>
				<Source><![CDATA[
    protected void clearTaxCodeMap()
    {
        this.parmPctTaxCodeMap(null);
        this.parmNonePctTaxCodeMap(null);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineAmountIncludesTax</Name>
				<Source><![CDATA[
    protected boolean lineAmountIncludesTax()
    {
        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>