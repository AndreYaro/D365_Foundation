<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProdStatusType</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>ProdStatusType</c> class is used to control the status updates of a production order.
/// </summary>
/// <remarks>
///  The
///  <c>
///  ProdStatusType
///  </c>
///   class provides implementation of all production order status updates. Before running a specific
///  update, the
///  <c>
///  ProdStatusType
///  </c>
///   class verifies that this update is allowed in production parameters. The
///  <c>
///  ProdStatusType
///  </c>
///   class always creates an instance of one of derived the classes according to current status of the
///  production order. Every derived class must implement the following methods:
///  <list type="bullet">
///   <item>
///    <description>
///    In the <c>currentProdStatus</c> method the derived class must return a specific status representing
///    the production order.
///    </description>
///   </item>
///   <item>
///    <description>
///    In the <c>previousProdStatus</c> method the derived class must return a previous status of the
///    production order.
///    </description>
///   </item>
///  </list>
///   Using information supplied by the derived classes in the
///  <c>
///  currentProdStatus
///  </c>
///   and
///  <c>
///  previousProdStatus
///  </c>
///   methods, the
///  <c>
///  ProdStatusType
///  </c>
///   class can determine whether status update is allowed by production parameters and accurately
///  perform the update.
/// </remarks>
public abstract class ProdStatusType
{
    ProdTable prodTable;

    // used for method UpdateWarnings
    Dialog          dialogUpdWarnings;
    DialogText      dialogText;
    DialogField     dfReEstimate;
    DialogField     dfReSchedule;
    Args            argsProdTable;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>autoAuthorization</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether production order status is legal when firming is made automatically.
    /// </summary>
    /// <returns>
    ///    Always returns false.
    /// </returns>
    public boolean autoAuthorization()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bomAllowEdit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the bills of materials of a production order can be edited.
    /// </summary>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    public boolean bomAllowEdit()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeWMSRegistered</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether production order can be registered in Warehouse Management System.
    /// </summary>
    /// <returns>
    ///    Always returns false.
    /// </returns>
    public boolean canBeWMSRegistered()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllowEditOperationStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the operation status can be modified.
    /// </summary>
    /// <param name="_showInfo">
    ///    A Boolean value that determines whether an <c>Infolog</c> message should be displayed; optional.
    /// </param>
    /// <returns>
    ///    Always returns false.
    /// </returns>
    public boolean checkAllowEditOperationStatus(boolean _showInfo = true)
    {
        if (_showInfo)
        {
            return checkFailed(strFmt("@SYS134893", prodTable.ProdStatus));
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPostJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether journal posting is allowed for a production order.
    /// </summary>
    /// <returns>
    ///    Always returns false.
    /// </returns>
    [Replaceable]
    public boolean checkPostJournal()
    {
        return checkFailed(strFmt(
            "@SYS22068",
            prodTable.ProdStatus));
    }

]]></Source>
			</Method>
			<Method>
				<Name>currentProdStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Defines the specific status of a production order.
    /// </summary>
    /// <returns>
    ///    One of the <c>ProdStatusAll</c> enumeration values.
    /// </returns>
    /// <remarks>
    ///    Every derived class must implement this method and return a production order status which
    ///    represents the class.
    /// </remarks>
    public abstract ProdStatusAll currentProdStatus()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic before a production order record is deleted.
    /// </summary>
    public void deleting()
    {
        this.prodTableType().deleting();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic after a production order record has been deleted.
    /// </summary>
    public void deleted()
    {
        this.prodTableType().deleted();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deletingProdBOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic before a production bills of materials record is deleted.
    /// </summary>
    /// <param name="_prodBOM">
    /// The production bills of materials which will be deleted from production order.
    /// </param>
    public void deletingProdBOM(ProdBOM _prodBOM)
    {
        _prodBOM.type().deleting();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deletedProdBOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic after a production bills of materials record has been deleted.
    /// </summary>
    /// <param name="_prodBOM">
    /// The production bills of materials which has been deleted from production order.
    /// </param>    
    public void deletedProdBOM(ProdBOM _prodBOM)
    {
        _prodBOM.type().deleted();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deletingProdRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic before a production route record is deleted.
    /// </summary>
    /// <param name="_prodRoute">
    /// The production route which will be deleted from production order.
    /// </param>
    public void deletingProdRoute(ProdRoute _prodRoute)
    {
        _prodRoute.type().deleting();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deletedProdRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic after a production route record has been deleted.
    /// </summary>
    /// <param name="_prodRoute">
    /// The production route which has been deleted from production order.
    /// </param>
    public void deletedProdRoute(ProdRoute _prodRoute)
    {
        _prodRoute.type().deleted();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formFieldsActive</Name>
				<Source><![CDATA[
    public boolean formFieldsActive()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inserting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic before a production order record is inserted.
    /// </summary>
    public void inserting()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>inserted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic after a production order record has been inserted.
    /// </summary>
    public void inserted()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertingProdBOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic before a production bills of materials record is inserted.
    /// </summary>
    /// <param name="_prodBOM">
    /// The production bills of materials which will be added to production order.
    /// </param>
    public void insertingProdBOM(ProdBOM _prodBOM)
    {
        _prodBOM.type().inserting();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertedProdBOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic after a production bills of materials record has been inserted.
    /// </summary>
    /// <param name="_prodBOM">
    /// The production bills of materials which has been added to production order.
    /// </param>
    public void insertedProdBOM(ProdBOM _prodBOM)
    {
        _prodBOM.type().inserted();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertingProdRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic before a production route record is inserted.
    /// </summary>
    /// <param name="_prodRoute">
    /// The production route which will be added to production order.
    /// </param>
    public void insertingProdRoute(ProdRoute _prodRoute)
    {
        _prodRoute.type().inserting();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertedProdRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic after a production route record has been inserted.
    /// </summary>
    /// <param name="_prodRoute">
    /// The production route which has been added to production order.
    /// </param>
    public void insertedProdRoute(ProdRoute _prodRoute)
    {
        _prodRoute.type().inserted();
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCheckUpdEst</Name>
				<Source><![CDATA[
    public boolean inventCheckUpdEst()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBefore</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the status of a production order is before the <paramref name="_prodStatus" />
    ///    parameter.
    /// </summary>
    /// <param name="_prodStatus">
    ///    An arbitrary status which will be compared to the status of a production order.
    /// </param>
    /// <returns>
    ///    true if the status of a production order is before the status specified by the <paramref
    ///    name="_prodStatus" /> parameter; otherwise, false.
    /// </returns>
    public boolean isBefore(ProdStatus _prodStatus)
    {
        return ProdStatusOrderedList::newFromOrder().isBefore(prodTable.ProdStatus, _prodStatus);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBeforeOrEqualTo</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the status of a production order is before or equal to the <paramref name="_prodStatus" />
    ///    parameter.
    /// </summary>
    /// <param name="_prodStatus">
    ///    The status which will be compared to the status of a production order.
    /// </param>
    /// <returns>
    ///    true if the status of a production order is before or equal to the status specified by the <paramref
    ///    name="_prodStatus" /> parameter; otherwise, false.
    /// </returns>
    public boolean isBeforeOrEqualTo(ProdStatus _prodStatus)
    {
        return ProdStatusOrderedList::newFromOrder().isBeforeOrEqualTo(prodTable.prodStatus, _prodStatus);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAfter</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the status of a production order is after the <paramref name="_prodStatus" />
    ///    parameter.
    /// </summary>
    /// <param name="_prodStatus">
    ///    The status which will be compared to the status of a production order.
    /// </param>
    /// <returns>
    ///    true if the status of a production order is after the status specified by the <paramref
    ///    name="_prodStatus" /> parameter; otherwise, false.
    /// </returns>
    public boolean isAfter(ProdStatus _prodStatus)
    {
        return ProdStatusOrderedList::newFromOrder().isAfter(prodTable.prodStatus, _prodStatus);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAfterOrEqualTo</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the status of a production order is after or equal to the <paramref name="_prodStatus" />
    ///    parameter.
    /// </summary>
    /// <param name="_prodStatus">
    ///    The status which will be compared to the status of a production order.
    /// </param>
    /// <returns>
    ///    true if the status of a production order is after or equal to the status specified by the <paramref
    ///    name="_prodStatus" /> parameter; otherwise, false.
    /// </returns>
    public boolean isAfterOrEqualTo(ProdStatus _prodStatus)
    {
        return ProdStatusOrderedList::newFromOrder().isAfterOrEqualTo(prodTable.prodStatus, _prodStatus);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStatusUpdateAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a production order status is able to be updated to the status specified by the
    ///    <paramref name="_toStatus" /> parameter.
    /// </summary>
    /// <param name="_toStatus">
    ///    The status the production order status is to be updated to. The <c>isStatusUpdateAllowed</c> method
    ///    will verify whether production order status can be updated the status supplied by this parameter.
    /// </param>
    /// <returns>
    ///    true if the production order status can be updated to the status specified by the <paramref
    ///    name="_toStatus" /> parameter; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    <c>isStatusUpdateAllowed</c> verifies if production order status is allowed by parameters of a
    ///    production module. Production order status is always allowed to be updated to the same status.
    /// </remarks>
    protected boolean isStatusUpdateAllowed(ProdStatusAll _toStatus)
    {
        ProdStatusAll curProdStatus = this.currentProdStatus();

        return curProdStatus == _toStatus
               || prodTable.prodStatusParameters(
                    curProdStatus,
                    _toStatus);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustEstimateReferences</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether references of a production order must be estimated.
    /// </summary>
    /// <returns>
    ///    Always returns false.
    /// </returns>
    public boolean mustEstimateReferences()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(ProdTable _prodTable)
    {
        prodTable = _prodTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCanBeBatchBalanced</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value indicating if the production order can use batch balancing.
    /// </summary>
    /// <returns>
    /// true if the production order can use batch balancing; otherwise, false.
    /// </returns>
    /// <remarks>
    /// <para>Unless overridden by a subclass, this always returns false.</para>
    /// </remarks>
    public boolean pdsCanBeBatchBalanced()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfCheckRework</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if any of the production raw material inventory transactions are considered reserved by warehouse management and if the batch order is a rework batch order.
    /// </summary>
    /// <returns>
    /// Return true if reserved by warehouse management and is rework batch order; otherwise false.
    /// </returns>
    public boolean pmfCheckRework()
    {
        boolean             ret = true;
        ProdBOM             localProdBom;
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;

        if (#PmfReworkBatchEnabled
            && prodTable.PmfReworkBatch)
        {
            ret = false;
            while select InventTransId from localProdBom
                where localProdBom.ProdId == prodTable.ProdId
                join TableId
                from inventTransOrigin
                where inventTransOrigin.InventTransId     == localProdBom.InventTransId
                &&    inventTransOrigin.ReferenceCategory == InventTransType::ProdLine
                join inventTrans
                where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                &&    (inventTrans.StatusIssue  == StatusIssue::ReservOrdered
                       || inventTrans.StatusIssue == StatusIssue::ReservPhysical)
                &&    inventTrans.StatusReceipt == StatusReceipt::None

            {
                ret = inventTrans.isWMSReserved();

                if (!ret)
                {
                    break;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>previousProdStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Defines the previous status for a production order.
    /// </summary>
    /// <returns>
    ///    A <c>ProdStatus</c> enumeration value.
    /// </returns>
    /// <remarks>
    ///    Every derived class must implement this method and return a status representing a previous status
    ///    of the production order.
    /// </remarks>
    public abstract ProdStatus previousProdStatus()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodCheckCopying</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether production order allows copying.
    /// </summary>
    /// <returns>
    ///    Always returns false.
    /// </returns>
    public boolean prodCheckCopying()
    {
        return checkFailed(strFmt(
            "@SYS22145",
            prodTable.ProdStatus));
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodNumLookupJournal</Name>
				<Source><![CDATA[
    public boolean prodNumLookupJournal()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>ProdTable</c> buffer representing a production order.
    /// </summary>
    /// <returns>
    ///    A <c>ProdTable</c> buffer which was used to initialize the <c>ProdStatusType</c> class.
    /// </returns>
    public ProdTable prodTable()
    {
        return prodTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodTableType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>ProdTableType</c> object that is associated with the related production order
    /// </summary>
    /// <returns>
    ///     Returns the ProdTableType object for the related ProdTable object
    /// </returns>
    protected ProdTableType prodTableType()
    {
        return prodTable.type();
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryAddStatus</Name>
				<Source><![CDATA[
    public void queryAddStatus(Query _q)
    {
        QueryBuildRange qbR = _q.dataSourceNo(1).addRange(fieldNum(
                                                            ProdTable,
                                                            ProdStatus));
        qbR.value(enum2Value(prodTable.ProdStatus));
    }

]]></Source>
			</Method>
			<Method>
				<Name>routeAllowEdit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the route of a production order can be edited.
    /// </summary>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    public boolean routeAllowEdit()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runAutoUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Implements performing of an automatic update of a production order.
    /// </summary>
    /// <remarks>
    ///    This method always throws an exception because an automatic update must be uniquely implemented in
    ///    derived classes.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    A production order does not allow automatic update.
    /// </exception>
    public void runAutoUpdate()
    {
        throw error(strFmt(
            "@SYS24885",
            prodTable.ProdStatus));
    }

]]></Source>
			</Method>
			<Method>
				<Name>runBOMCalc</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the price calculation of a production order.
    /// </summary>
    /// <param name="_prodParmBOMCalc">
    ///    The production bills of materials parameters of price calculation.
    /// </param>
    /// <param name="_ask">
    ///    A value of TRUE indicates that method will only check whether BOM calculation is allowed. A value of FALSE
    ///    indicates that the method will also perform the BOM calculation.; optional
    /// </param>
    /// <param name="_multi">
    ///    A parameter that is used to perform the price calculation of multiple production orders at the same
    ///    time; optional.
    /// </param>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    public boolean runBOMCalc(
        ProdParmBOMCalc     _prodParmBOMCalc,
        boolean             _ask = false,
        RunbaseRecsMapable  _multi = null
        )
    {
        if (!_ask)
        {
            this.prodTableType().runBOMCalc(
                    _prodParmBOMCalc,
                    _multi);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runCopy</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs copying of the bills of materials or route of a production order.
    /// </summary>
    /// <param name="_ask">
    ///    A value of TRUE indicates that method will only check whether copying is allowed. A value of FALSE
    ///    indicates that the method will also perform the copy.; optional
    /// </param>
    /// <returns>
    ///    true if the <paramref name="_ask" /> parameter is false; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method has no meaningful implementation and is intended to be implemented in derived classes.
    /// </remarks>
    public boolean runCopy(boolean _ask = false)
    {
        if (_ask)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runCostEstimation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs a cost estimation of a production order.
    /// </summary>
    /// <param name="_prodParmCostEstimation">
    ///    The production cost estimation parameter that is used to perform a cost estimation.
    /// </param>
    /// <param name="_ask">
    ///    A value of TRUE indicates that method will only check whether cost estimation is allowed. A value of FALSE
    ///    indicates that the method will also perform the cost estimation.; optional
    /// </param>
    /// <param name="_prodPurch">
    ///    The <c>ProdPurch</c> table buffer used to perform cost estimation; optional.
    /// </param>
    /// <param name="_multi">
    ///    A parameter that is used to perform a cost estimation of multiple production orders at the same
    ///    time; optional.
    /// </param>
    /// <param name="_runningPreviousJob">
    ///     Indicates if this method has been triggered by a change to a higher status: optional.
    /// </param>
    /// <returns>
    ///    true if cost estimation is allowed for a production order status; otherwise, false.
    /// </returns>
    public boolean runCostEstimation(
        ProdParmCostEstimation      _prodParmCostEstimation,
        boolean                     _ask                        = false,
        ProdPurch                   _prodPurch                  = null,
        RunbaseRecsMapable          _multi                      = null,
        boolean                     _runningPreviousJob         = false
        )
    {
        boolean statusUpdAllowed = this.isStatusUpdateAllowed(ProdStatusAll::CostEstimated);

        //Try to run this job as no previous jobs exist.
        if ((!_ask && statusUpdAllowed) &&
            (!_runningPreviousJob || !this.statusAlreadyPosted(ProdStatusAll::CostEstimated)))
        {
            this.prodTableType().runCostEstimation(
                _prodParmCostEstimation,
                _prodPurch,
                _multi);
        }

        return statusUpdAllowed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runGanttChart</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the Gantt chart is enabled for a production order.
    /// </summary>
    /// <param name="_ask">
    ///    A Boolean parameter. This parameter is not used in method implementation.
    /// </param>
    /// <returns>
    ///    true if the production order has been job scheduled; otherwise, false.
    /// </returns>
    public boolean runGanttChart(boolean _ask = false)
    {
        return prodTable.SchedStatus == ProdSchedStatus::JobScheduled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runHistoricalCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Using the historical cost parameters, completes a production order.
    /// </summary>
    /// <param name="_prodParmHistoricalCost">
    ///    The production historical cost parameters that are used to complete a production order.
    /// </param>
    /// <param name="_ask">
    ///    A value of TRUE indicates that method will only check whether completion is allowed. A value of FALSE
    ///    indicates that the method will also perform the completion.; optional
    /// </param>
    /// <param name="_multi">
    ///    A parameter that is used to complete the multiple production orders at the same time; optional.
    /// </param>
    /// <param name="_runningPreviousJob">
    ///     Indicates if this method has been triggered by a change to a higher status: optional.
    /// </param>
    /// <returns>
    ///    true if completion is allowed for a production order status; otherwise, false.
    /// </returns>
    public boolean runHistoricalCost(
        ProdParmHistoricalCost      _prodParmHistoricalCost,
        boolean                     _ask                     = false,
        RunbaseRecsMapable          _multi                   = null,
        boolean                     _runningPreviousJob      = false
        )
    {
        boolean statusUpdAllowed = this.isStatusUpdateAllowed(ProdStatusAll::Completed);

        if (!_ask)
        {
            this.runPrevJobHistoricalCost(
                _prodParmHistoricalCost,
                _multi);

            if (statusUpdAllowed &&
                (!_runningPreviousJob || !this.statusAlreadyPosted(ProdStatusAll::Completed)))
            {
                this.prodTableType().runHistoricalCost(
                    _prodParmHistoricalCost,
                    _multi);
            }
        }

        return statusUpdAllowed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runJobScheduling</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Performs job scheduling of a production order.
    /// </summary>
    /// <param name="_prodParmScheduling">
    ///     Parameters used to perform job scheduling.
    /// </param>
    /// <param name="_ask">
    ///    A value of TRUE indicates that method will only check whether job scheduling is allowed. A value of FALSE
    ///    indicates that the method will also perform the job scheduling.; optional
    /// </param>
    /// <param name="_prodPurch">
    ///     ProdPurch table buffer used to perform job scheduling; optional.
    /// </param>
    /// <param name="_multi">
    ///     This parameter is used to perform job scheduling of multiple production orders at once; optional.
    /// </param>
    /// <param name="_wrkCtrScheduler">
    ///     A job scheduler instance that can be reused when performing scheduling; optional.
    /// </param>
    /// <param name="_runningPreviousJob">
    ///     Indicates if this method has been triggered by a change to a higher status: optional.
    /// </param>
    /// <returns>
    ///     true if job scheduling is allowed for a production order status; otherwise, false.
    /// </returns>
    public boolean runJobScheduling(
        ProdParmScheduling      _prodParmScheduling,
        boolean                 _ask                = false,
        ProdPurch               _prodPurch          = null,
        RunbaseRecsMapable      _multi              = null,
        WrkCtrScheduler_Prod    _wrkCtrScheduler    = null,
        boolean                 _runningPreviousJob = false
        )
    {
        boolean statusUpdAllowed = this.isStatusUpdateAllowed(ProdStatusAll::JobScheduled);

        if (!_ask)
        {
            this.runPrevJobJobScheduling(
                _prodParmScheduling,
                _prodPurch,
                _multi);

            if (statusUpdAllowed &&
                (!_runningPreviousJob || !this.statusAlreadyPosted(ProdStatusAll::JobScheduled)))
            {
                this.prodTableType().runJobScheduling(
                    _prodParmScheduling,
                    _multi,
                    _wrkCtrScheduler);
            }
        }

        return statusUpdAllowed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runJobUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the jobs of a production order.
    /// </summary>
    /// <param name="_ask">
    ///    A value of TRUE indicates that method will only check whether job update is allowed. A value of FALSE
    ///    indicates that the method will also perform the job update.; optional
    /// </param>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    public boolean runJobUpdate(boolean _ask = false)
    {
        if (!_ask)
        {
            this.prodTableType().runJobUpdate();
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runOperationScheduling</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Performs operation scheduling of a production order.
    /// </summary>
    /// <param name="_prodParmScheduling">
    ///     Parameters used to perform operation scheduling.
    /// </param>
    /// <param name="_ask">
    ///    A value of TRUE indicates that method will only check whether operation scheduling is allowed. A value of FALSE
    ///    indicates that the method will also perform the operation scheduling.; optional
    /// </param>
    /// <param name="_prodPurch">
    ///     ProdPurch table buffer used to perform operation scheduling; optional.
    /// </param>
    /// <param name="_multi">
    ///     This parameter is used to perform operation scheduling of multiple production orders at once; optional.
    /// </param>
    /// <param name="_wrkCtrScheduler">
    ///     A job scheduler instance that can be reused when performing scheduling; optional.
    /// </param>
    /// <param name="_runningPreviousJob">
    ///     Indicates if this method has been triggered by a change to a higher status: optional.
    /// </param>
    /// <returns>
    ///     true if operation scheduling is allowed for a production order status; otherwise, false.
    /// </returns>
    public boolean runOperationScheduling(
        ProdParmScheduling      _prodParmScheduling,
        boolean                 _ask                    = false,
        ProdPurch               _prodPurch              = null,
        RunbaseRecsMapable      _multi                  = null,
        WrkCtrScheduler_Prod    _wrkCtrScheduler        = null,
        boolean                 _runningPreviousJob     = false
        )
    {
        boolean statusUpdAllowed = this.isStatusUpdateAllowed(ProdStatusAll::OperationScheduled);

        if (!_ask)
        {
            this.runPrevJobOperationScheduling(
                _prodParmScheduling,
                _prodPurch,
                _multi);

            if (statusUpdAllowed &&
                (!_runningPreviousJob || !this.statusAlreadyPosted(ProdStatusAll::OperationScheduled)))
            {
                this.prodTableType().runOperationScheduling(
                    _prodParmScheduling,
                    _multi,
                    _wrkCtrScheduler);
            }
        }

        return statusUpdAllowed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPrevJobHistoricalCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Using the historical cost parameters, runs the jobs to update the prod order status to statuses preceding Completed.
    /// </summary>
    /// <param name="_prodParmHistoricalCost">
    ///    The production historical cost parameters that are used to complete a production order.
    /// </param>
    /// <param name="_multi">
    ///    A parameter that is used to complete the multiple production orders at the same time.
    /// </param>
    protected void runPrevJobHistoricalCost(
        ProdParmHistoricalCost      _prodParmHistoricalCost,
        RunbaseRecsMapable          _multi
        )
    {
        ProdUpdHistoricalCost::runPreviousJob(
            _prodParmHistoricalCost,
            _multi);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPrevJobJobScheduling</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Runs the jobs to update the prod order status to statuses preceding JobScheduled.
    /// </summary>
    /// <param name="_prodParmScheduling">
    ///     Parameters used to perform job scheduling.
    /// </param>
    /// <param name="_prodPurch">
    ///     ProdPurch table buffer used to perform job scheduling.
    /// </param>
    /// <param name="_multi">
    ///     This parameter is used to perform job scheduling of multiple production orders at once.
    /// </param>
    protected void runPrevJobJobScheduling(
        ProdParmScheduling      _prodParmScheduling,
        ProdPurch               _prodPurch,
        RunbaseRecsMapable      _multi
        )
    {
        ProdUpdScheduling::runPreviousJob(
            _prodParmScheduling,
            _prodPurch,
            _multi);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPrevJobOperationScheduling</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Runs the jobs to update the prod order status to statuses preceding OperationScheduled.
    /// </summary>
    /// <param name="_prodParmScheduling">
    ///     Parameters used to perform operation scheduling.
    /// </param>
    /// <param name="_prodPurch">
    ///     ProdPurch table buffer used to perform operation scheduling.
    /// </param>
    /// <param name="_multi">
    ///     This parameter is used to perform operation scheduling of multiple production orders at once.
    /// </param>
    protected void runPrevJobOperationScheduling(
        ProdParmScheduling      _prodParmScheduling,
        ProdPurch               _prodPurch,
        RunbaseRecsMapable      _multi
        )
    {
        ProdUpdScheduling::runPreviousJob(
            _prodParmScheduling,
            _prodPurch,
            _multi);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPrevJobRelease</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Runs the jobs to update the prod order status to statuses preceding Released.
    /// </summary>
    /// <param name="_prodParmRelease">
    ///    The parameters to use to release the production order.
    /// </param>
    /// <param name="_prodPurch">
    ///    The <c>ProdPurch</c> table buffer to use to release a production order.
    /// </param>
    /// <param name="_multi">
    ///    A Boolean value that indicates whether to release multiple production orders at once.
    /// </param>
    protected void runPrevJobRelease(
        ProdParmRelease     _prodParmRelease,
        ProdPurch           _prodPurch,
        RunbaseRecsMapable  _multi
        )
    {
        ProdUpdRelease::runPreviousJob(
            _prodParmRelease,
            _prodPurch,
            _multi);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPrevJobReportFinished</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Runs the jobs to update the prod order status to statuses preceding ReportedFinished.
    /// </summary>
    /// <param name="_prodParmReportFinished">
    ///    The parameters to use to report a production order as finished.
    /// </param>
    /// <param name="_multi">
    ///    A Boolean value that indicates whether to report multiple production orders as finished at once.
    /// </param>
    protected void runPrevJobReportFinished(
        ProdParmReportFinished  _prodParmReportFinished,
        RunbaseRecsMapable      _multi)
    {
        ProdUpdReportFinished::runPreviousJob(
            _prodParmReportFinished,
            _multi);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPrevJobStartUp</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Runs the jobs to update the prod order status to statuses preceding StartUp.
    /// </summary>
    /// <param name="_prodParmStartUp">
    ///    The production start up parameter used to start a production order.
    /// </param>
    /// <param name="_prodPurch">
    ///    The <c>ProdPurch</c> table buffer used to start a production order.
    /// </param>
    /// <param name="_multi">
    ///    A parameter that is used to start multiple production orders at once.
    /// </param>
    protected void runPrevJobStartUp(
        ProdParmStartUp     _prodParmStartUp,
        ProdPurch           _prodPurch,
        RunbaseRecsMapable  _multi)
    {
        ProdUpdStartUp::runPreviousJob(
            _prodParmStartUp,
            _prodPurch,
            _multi);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runRelease</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Releases a production order.
    /// </summary>
    /// <param name="_prodParmRelease">
    ///    The parameters to use to release the production order.
    /// </param>
    /// <param name="_ask">
    ///    A value of TRUE indicates that method will only check whether releasing is allowed. A value of FALSE
    ///    indicates that the method will also perform the release.; optional
    /// </param>
    /// <param name="_prodPurch">
    ///    The <c>ProdPurch</c> table buffer to use to release a production order; optional.
    /// </param>
    /// <param name="_multi">
    ///    A Boolean value that indicates whether to release multiple production orders at once; optional.
    /// </param>
    /// <param name="_runningPreviousJob">
    ///     Indicates if this method has been triggered by a change to a higher status: optional.
    /// </param>
    /// <returns>
    ///    true if releasing is allowed for a production order status; otherwise, false.
    /// </returns>
    public boolean runRelease(
        ProdParmRelease     _prodParmRelease,
        boolean             _ask                = false,
        ProdPurch           _prodPurch          = null,
        RunbaseRecsMapable  _multi              = null,
        boolean             _runningPreviousJob = false
        )
    {
        boolean statusUpdAllowed = this.isStatusUpdateAllowed(ProdStatusAll::Released);

        if (!_ask)
        {
            this.runPrevJobRelease(
                _prodParmRelease,
                _prodPurch,
                _multi);

            if (statusUpdAllowed &&
                (!_runningPreviousJob || !this.statusAlreadyPosted(ProdStatusAll::Released)))
            {
                this.prodTableType().runRelease(
                    _prodParmRelease,
                    _multi);
            }
        }

        return statusUpdAllowed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runReportFinished</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reports a production order as finished.
    /// </summary>
    /// <param name="_prodParmReportFinished">
    ///    The parameters to use to report a production order as finished.
    /// </param>
    /// <param name="_ask">
    ///    A value of TRUE indicates that method will only check whether reporting as finished is allowed. A value of FALSE
    ///    indicates that the method will also perform the report as finished.; optional
    /// </param>
    /// <param name="_multi">
    ///    A Boolean value that indicates whether to report multiple production orders as finished at once;
    ///    optional.
    /// </param>
    /// <param name="_runningPreviousJob">
    ///     Indicates if this method has been triggered by a change to a higher status: optional.
    /// </param>
    /// <returns>
    ///    true if reporting as finished is allowed for a production order status; otherwise, false.
    /// </returns>
    public boolean runReportFinished(
        ProdParmReportFinished  _prodParmReportFinished,
        boolean                 _ask                        = false,
        RunbaseRecsMapable      _multi                      = null,
        boolean                 _runningPreviousJob         = false
        )
    {
        boolean statusUpdAllowed = this.isStatusUpdateAllowed(ProdStatusAll::ReportedFinished);

        if (!_ask)
        {
            this.runPrevJobReportFinished(
                _prodParmReportFinished,
                _multi);

            if (statusUpdAllowed &&
                (!_runningPreviousJob || !this.statusAlreadyPosted(ProdStatusAll::ReportedFinished)))
            {
                this.prodTableType().runReportFinished(
                    _prodParmReportFinished,
                    _multi);
            }
        }

        return statusUpdAllowed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runRouteUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the route of a production order.
    /// </summary>
    /// <param name="_ask">
    ///    A value of TRUE indicates that method will only check whether route update is allowed. A value of FALSE
    ///    indicates that the method will also perform the route update.; optional
    /// </param>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    public boolean runRouteUpdate(boolean _ask = false)
    {
        if (!_ask)
        {
            this.prodTableType().runRouteUpdate();
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runSplit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Splits a production order into several production orders.
    /// </summary>
    /// <param name="_prodParmSplit">
    ///    The production split parameter that is used to split a production order.
    /// </param>
    /// <param name="_ask">
    ///    A value of TRUE indicates that method will only check whether splitting is allowed. A value of FALSE
    ///    indicates that the method will also perform the split.; optional
    /// </param>
    /// <param name="_multi">
    ///    A parameter that is used to split multiple production orders at the same time; optional.
    /// </param>
    /// <returns>
    ///    A value indicating whether the production order is not a sub production if the <paramref
    ///    name="_ask" /> parameter is true; otherwise, true.
    /// </returns>
    public boolean runSplit(
        ProdParmSplit       _prodParmSplit,
        boolean             _ask             = false,
        RunbaseRecsMapable  _multi           = null
        )
    {
        if (_ask)
        {
            return prodTable.CollectRefLevel == 0;
        }

        ProdUpdSplit prodUpdSplit = ProdUpdSplit::newParmBuffer(_prodParmSplit);
        prodUpdSplit.run();

        if (_multi)
        {
            _multi.mergeRecs(prodUpdSplit);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runStartUp</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Starts a production order.
    /// </summary>
    /// <param name="_prodParmStartUp">
    ///    The production start up parameter used to start a production order.
    /// </param>
    /// <param name="_ask">
    ///    A value of TRUE indicates that method will only check whether starting a production order is allowed.
    ///    A value of FALSE indicates that the method will also perform the start.; optional
    /// </param>
    /// <param name="_prodPurch">
    ///    The <c>ProdPurch</c> table buffer used to start a production order; optional.
    /// </param>
    /// <param name="_multi">
    ///    A parameter that is used to start multiple production orders at once; optional.
    /// </param>
    /// <param name="_runningPreviousJob">
    ///     Indicates if this method has been triggered by a change to a higher status: optional.
    /// </param>
    /// <returns>
    ///    true if starting a production order is allowed for a production order status; otherwise, false.
    /// </returns>
    public boolean runStartUp(
        ProdParmStartUp     _prodParmStartUp,
        boolean             _ask                = false,
        ProdPurch           _prodPurch          = null,
        RunbaseRecsMapable  _multi              = null,
        boolean             _runningPreviousJob = false
        )
    {
        boolean statusUpdAllowed = this.isStatusUpdateAllowed(ProdStatusAll::StartUp);

        if (!_ask)
        {
            this.runPrevJobStartUp(
                _prodParmStartUp,
                _prodPurch,
                _multi);

            if (statusUpdAllowed &&
                (!_runningPreviousJob || !this.statusAlreadyPosted(ProdStatusAll::StartUp)))
            {
                this.prodTableType().runStartUp(
                    _prodParmStartUp,
                    _multi);
            }
        }

        return statusUpdAllowed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runStatusDecrease</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Decreases the status of a production order.
    /// </summary>
    /// <param name="_prodStatusDecrease">
    ///    The production decrease parameter that is used to decrease the status of a production order.
    /// </param>
    /// <param name="_ask">
    ///    A value of TRUE indicates that method will only check whether decreasing status is allowed. A value of FALSE
    ///    indicates that the method will also perform the status decrease.; optional
    /// </param>
    /// <param name="_multi">
    ///    A parameter that is used to decrease status of multiple production orders at the same time;
    ///    optional.
    /// </param>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    public boolean runStatusDecrease(
        ProdParmStatusDecrease  _prodStatusDecrease,
        boolean                 _ask       = false,
        RunbaseRecsMapable      _multi = null
        )
    {
        if (!_ask)
        {
            this.prodTableType().runStatusDecrease(
                _prodStatusDecrease,
                _multi);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBackStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the backorder status on an underlying <c>ProdTable</c> buffer.
    /// </summary>
    public void setBackStatus()
    {
        this.prodTableType().setBackStatus();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPreviousProdStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets a previous production orders status.
    /// </summary>
    /// <remarks>
    ///    Previous production orders status is defined by the <c>ProdStatusType.previousProdStatus</c> method.
    /// </remarks>
    public void setPreviousProdStatus()
    {
        prodTable.ProdStatus = this.previousProdStatus();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setQtySched</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets a scheduled quantity of items to produce.
    /// </summary>
    /// <param name="_qty">
    ///    The scheduled quantity of items to produce.
    /// </param>
    public void setQtySched(ProdQty _qty)
    {
        prodTable.RemainInventPhysical += _qty - prodTable.QtySched;
        prodTable.QtySched = _qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>startUpUpdateRouteJobs</Name>
				<Source><![CDATA[
    public void startUpUpdateRouteJobs(ProdUpdStartUp _prodUpdStartUp)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>statusAlreadyPosted</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if the production order ever had the given status
    /// </summary>
    /// <param name="_status">
    ///     The status to check for
    /// </param>
    /// <returns>
    ///     A Boolean, if the production order had the given status,
    ///     somewhere in the past, False otherwise.
    /// </returns>
    /// <remarks>
    ///     When running previous jobs during a status change, it is
    ///     important to check if the production status had ever been set
    ///     to the status that is being set to now. If yes, the status
    ///     change should be skipped.
    /// </remarks>
    [Hookable]
    protected boolean statusAlreadyPosted(ProdStatusAll _status)
    {
        boolean ret;
        switch (_status)
        {
            case ProdStatusAll::Created:
                ret = this.prodTable().CreatedDateTime ? true : false;
                break;
            case ProdStatusAll::CostEstimated:
                ret = this.prodTable().CalcDate ? true: false;
                break;
            case ProdStatusAll::OperationScheduled:
            case ProdStatusAll::JobScheduled:
                ret = this.prodTable().SchedDate ? true : false;
                break;
            case ProdStatusAll::Released:
                ret = this.prodTable().ReleasedDate ? true : false;
                break;
            case ProdStatusAll::StartUp:
                ret = this.prodTable().StUpDate ? true: false;
                break;
            case ProdStatusAll::ReportedFinished:
                ret = this.prodTable().FinishedDate ? true: false;
                break;
            case ProdStatusAll::Completed:
                ret = this.prodTable().RealDate ? true: false;
                break;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updating</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic before a production order is updated.
    /// </summary>
    public void updating()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic after a production order record has been updated.
    /// </summary>
    /// <param name="_prodTableOrig">
    /// The original production order which is updated.
    /// </param>
    public void updated(ProdTable _prodTableOrig)
    {
        this.prodTableType().updated(_prodTableOrig);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateActivityRequirementSet</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the activity requirement set.
    /// </summary>
    /// <param name="_wrkCtrActivityRequirementSet">
    ///    The activity requirement set to update.
    /// </param>
    /// <param name="_prodRoute">
    ///    The production route that the set is connected to.
    /// </param>
    public void updateActivityRequirementSet(WrkCtrActivityRequirementSet _wrkCtrActivityRequirementSet, ProdRoute _prodRoute)
    {
        _wrkCtrActivityRequirementSet.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBOMRoute</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Empty method that does nothing. This method can be overwritten on derived classes in order to
    ///    update the production Bills of materials and the production route.
    /// </summary>
    public void updateBOMRoute()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatingProdBOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic before a production bills of materials record is updated.
    /// </summary>
    /// <param name="_prodBOM">
    /// The production bills of materials which is being updated.
    /// </param>
    public void updatingProdBOM(ProdBOM _prodBOM)
    {
        _prodBOM.type().updating();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatedProdBOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic after a production bills of materials record has been updated.
    /// </summary>
    /// <param name="_prodBOM">
    /// The production bills of materials which is being updated
    /// </param>
    /// <param name="_prodBOMOrig">
    /// The original production bills of materials which is updated.
    /// </param>
    public void updatedProdBOM(ProdBOM _prodBOM, ProdBOM _prodBOMOrig)
    {
        _prodBOM.type().updated(_prodBOMOrig);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatingProdRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic before a production route record is updated.
    /// </summary>
    /// <param name="_prodRoute">
    /// The production route which is being updated.
    /// </param>
    public void updatingProdRoute(ProdRoute _prodRoute)
    {
        _prodRoute.type().updating();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatedProdRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic after a production route record has been updated.
    /// </summary>
    /// <param name="_prodRoute">
    /// The production route which is being updated
    /// </param>
    /// <param name="_prodRouteOrig">
    /// The original production route which is updated
    /// </param>
    public void updatedProdRoute(ProdRoute _prodRoute, ProdRoute _prodRouteOrig)
    {
        _prodRoute.type().updated(_prodRouteOrig);

        if (this.mustProdRouteJobsBeUpdated(_prodRoute, _prodRouteOrig))
        {
            ProdJobUpdate::newProdIdOprNum(
                _prodRoute.ProdId,
                _prodRoute.OprNum,
                _prodRouteOrig.OprNum).run();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustProdRouteJobsBeUpdated</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected boolean mustProdRouteJobsBeUpdated(ProdRoute _prodRoute, ProdRoute _prodRouteOrig)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWarnings</Name>
				<Source><![CDATA[
    public void updateWarnings()
    {
        if (prodTable.QtySched
            && prodTable.QtyCalc
            && prodTable.QtySched != prodTable.QtyCalc
            && appl.ttsLevel() == 0)
        {
            prodTableChangeQtySched::newProdTable(prodTable).runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a production order can be deleted.
    /// </summary>
    /// <returns>
    ///    true if a production order can be deleted; otherwise, false.
    /// </returns>
    public boolean validateDelete()
    {
        return this.prodTableType().validateDelete();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDeleteProdBOM</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the production bills of materials can be deleted.
    /// </summary>
    /// <param name="_prodBOM">
    ///    The production bills of materials value which will be validated.
    /// </param>
    /// <returns>
    ///    true if production bills of materials can be deleted; otherwise, false.
    /// </returns>
    public boolean validateDeleteProdBOM(ProdBOM _prodBOM)
    {
        return _prodBOM.type().validateDelete();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDeleteProdRoute</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a production route can be deleted.
    /// </summary>
    /// <param name="_prodRoute">
    ///    A production route which will be validated.
    /// </param>
    /// <returns>
    ///    true if a production route can be deleted; otherwise, false.
    /// </returns>
    public boolean validateDeleteProdRoute(ProdRoute _prodRoute)
    {
        return _prodRoute.type().validateDelete();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a production order can be updated.
    /// </summary>
    /// <returns>
    ///    true if a production order can be updated; otherwise, false.
    /// </returns>
    public boolean validateWrite()
    {
        return this.prodTableType().validateWrite();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWriteProdBOM</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the production bills of materials can be updated.
    /// </summary>
    /// <param name="_prodBOM">
    ///    The production bills of materials which will be validated.
    /// </param>
    /// <returns>
    ///    true if production bills of materials can be updated; otherwise, false.
    /// </returns>
    public boolean validateWriteProdBOM(ProdBOM _prodBOM)
    {
        return _prodBOM.type().validateWrite();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWriteProdRoute</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a production route can be updated.
    /// </summary>
    /// <param name="_prodRoute">
    ///    A production route which will be validated.
    /// </param>
    /// <returns>
    ///    true if a production route can be updated; otherwise, false.
    /// </returns>
    public boolean validateWriteProdRoute(ProdRoute _prodRoute)
    {
        return _prodRoute.type().validateWrite();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateProdJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a production journal can be created.
    /// </summary>   
    /// <returns>
    ///    true if a production journal can be created; otherwise, false.
    /// </returns>
    public boolean canCreateProdJournal()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static ProdStatusType construct(ProdTable _prodTable)
    {
        ProdStatusType prodStatusType = ProdStatusType::constructNoThrow(_prodTable);
        
        if (!prodStatusType)
        {
            throw error("@SYS23417");
        }

        return prodStatusType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructNoThrow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs an instance of <c>ProdStatusType</c> based on the status of the production order.
    /// </summary>
    /// <param name = "_prodTable">A production order record.</param>
    /// <returns>An instance of <c>ProdStatusType</c>.</returns>
    protected static ProdStatusType constructNoThrow(ProdTable _prodTable)
    {
        switch (_prodTable.ProdStatus)
        {
            case ProdStatus::Created:           return ProdStatusType_Created::construct(_prodTable);
            case ProdStatus::CostEstimated:     return ProdStatusType_CostEstimate::construct(_prodTable);
            case ProdStatus::Scheduled:         return ProdStatusType_Scheduled::construct(_prodTable);
            case ProdStatus::Released:          return ProdStatusType_Released::construct(_prodTable);
            case ProdStatus::StartedUp:         return ProdStatusType_StartedUp::construct(_prodTable);
            case ProdStatus::ReportedFinished:  return ProdStatusType_ReportedFinished::construct(_prodTable);
            case ProdStatus::Completed:         return ProdStatusType_Completed::construct(_prodTable);
        }

        return null;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>