<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSSlotDemandLocate</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Finds a location to slot the generated demand records to based on a template.
/// </summary>
public final class WHSSlotDemandLocate
{
    protected WHSSlotTemplate     slotTemplate;

    private RecordInsertList    ril;
    private Set                 slottedLocations;
    private WHSAllowLetUps      allowLetUps;
    private List                slotTemplateLines;
    private Map                 onHandQuantities;
    private Map                 slottedLocationsPerItem;
    private const str           Separator = '~';              

    private WHSInstrumentationLogger instrumentationLogger;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    private void new()
    {
        instrumentationLogger = WHSInstrumentationLogger::createLogger(classId2Name(classIdGet(this)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>warehouseLocationKey</Name>
				<Source><![CDATA[
    private str warehouseLocationKey(WMSLocation _location)
    {
        return _location.InventLocationId + WHSSlotDemandLocate::Separator + _location.wMSLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>considerLocationsWithQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Slot to locations with inventory that match the demand.
    /// </summary>
    /// <param name="_slotTemplateLine">
    /// The slot template line being used to slot.
    /// </param>
    /// <param name="_itemId">
    /// The item ID for the demand.
    /// </param>
    /// <param name="_inventDimId">
    /// The invent dim ID for the demand.
    /// </param>
    /// <param name="_uom">
    /// The unit of measure symbol for the demand.
    /// </param>
    /// <param name="_runningQty">
    /// The qty to slot.
    /// </param>
    /// <returns>
    /// The qty that wasn't able to be slotted.
    /// </returns>
    private Qty considerLocationsWithQty(
        WHSSlotTemplateLine _slotTemplateLine,
        ItemId              _itemId,
        InventDimId         _inventDimId,
        UnitOfMeasureSymbol _uom,
        Qty                 _runningQty)
    {
        InventDim inventDim = InventDim::find(_inventDimId);
        QueryRun queryRun = new queryRun(_slotTemplateLine.PackedQueryRun);
        Query query = this.addFixedLocationRanges(queryRun.query(), _slotTemplateLine.UseFixedLocation, _itemId, inventDim);

        this.addWarehouseRange(_slotTemplateLine.SlotTemplate(), query.dataSourceTable(tableNum(WMSLocation)), inventDim.InventLocationId);

        queryRun = new QueryRun(query);

        Qty runningQty = _runningQty;
        if (runningQty 
            && _slotTemplateLine.AssignSlotCriteria == WHSAssignSlotCriteria::ConsiderOnHand)
        {
            runningQty = this.calculateRunningQuantity(_itemId, _inventDimId, _uom, runningQty, query);
        }

        while (queryRun.next() && runningQty > 0)
        {
            WMSLocation location = queryRun.get(tableNum(WMSLocation));

            if (this.slottedLocations().in(this.warehouseLocationKey(location)))
            {
                continue;
            }

            Qty locateQty;
            if (location.isReplenishmentOverflowEnabled())
            {
                locateQty = runningQty;
            }
            else
            {
                locateQty = this.validateItemFit(location.wMSLocationId,
                                                 location.inventLocationId,
                                                 _itemId,
                                                 runningQty,
                                                 _inventDimId,
                                                 _uom);
            }

            if (locateQty)
            {
                this.createNewSlottedRecord(_itemId,
                                            _inventDimId,
                                            _uom,
                                            locateQty,
                                            location,
                                            _slotTemplateLine.RecId);

                this.slottedLocations().add(this.warehouseLocationKey(location));

                if (_slotTemplateLine.SlotMixedUnits)
                {
                    this.addSlottedLocationsPerItem(this.warehouseLocationKey(location),
                        WHSSlotDemandLocateLocationsPerItem::construct(_itemId, _inventDimId, _uom, locateQty));
                }

                runningQty -= locateQty;
            }
        }

        return runningQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSlottedLocationsPerItem</Name>
				<Source><![CDATA[
    private void addSlottedLocationsPerItem(str _warehouseLocationKey, WHSSlotDemandLocateLocationsPerItem _slotDemandLocateLocationsPerItem)
    {
        if (this.slottedLocationsPerItem().exists(_warehouseLocationKey))
        {
            WHSSlotDemandLocateLocationsPerItem slotDemandLocateLocationPerItem = this.slottedLocationsPerItem().lookup(_warehouseLocationKey);
            this.slottedLocationsPerItem().insert(_warehouseLocationKey, slotDemandLocateLocationPerItem.merge(_slotDemandLocateLocationsPerItem));
        }
        else
        {
            this.slottedLocationsPerItem().insert(_warehouseLocationKey, _slotDemandLocateLocationsPerItem);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateRunningQuantity</Name>
				<Source><![CDATA[
    private Qty calculateRunningQuantity(ItemId _itemId, InventDimId _inventDimId, UnitOfMeasureSymbol _uom, Qty _runningQty, Query _locationQuery)
    {
        InventDim demandInventDim = InventDim::find(_inventDimId);
        demandInventDim.clearLocationAndBelowDim(_itemId);
        demandInventDim = InventDim::findOrCreate(demandInventDim);

        if (InventUseDimOfInventSumToggle::instance().isEnabled())
        {
            QueryBuildDataSource qbdsInventSum = _locationQuery.dataSourceTable(tableNum(InventSum));

            InventSum::queryAddRangeCriteriaForSelectedDims(qbdsInventSum, demandInventDim, demandInventDim.toDimParm());
        }
        else
        {
            QueryBuildDataSource qbdsInventDim = _locationQuery.dataSourceTable(tableNum(InventDim));
            InventDim::queryAddRange(qbdsInventDim, demandInventDim);
        }

        QueryRun queryRunLoc = new QueryRun(_locationQuery);

        container itemAndDimMapKey = [_itemId, demandInventDim.inventDimId];

        Qty availQtys;
        if (!this.onHandQuantitiesMap().exists(itemAndDimMapKey))
        {
            Set countedLocations = new Set(Types::String);

            while (queryRunLoc.next())
            {
                WMSLocation location = queryRunLoc.get(tableNum(WMSLocation));

                if (!countedLocations.in(location.wMSLocationId))
                {
                    countedLocations.add(location.wMSLocationId);
                }
                else
                {
                    continue;
                }

                demandInventDim.wMSLocationId = location.wMSLocationId;
                InventDim demandInventDimLoc = InventDim::findOrCreate(demandInventDim);

                availQtys += whsInventOnHand::getPhysicalAvailHandlingQty(_itemId, demandInventDimLoc, true, true);
            }

            this.onHandQuantitiesMap().insert(itemAndDimMapKey, availQtys);
        }
        else
        {
            availQtys = this.onHandQuantitiesMap().lookup(itemAndDimMapKey);
        }

        if (availQtys)
        {
            UnitOfMeasureSymbol handlingUnit = WHSCatchWeightHelper::inventHandlingUnitId(_itemId);
            Qty handlingUsedQty;
            if (_uom == handlingUnit)
            {
                if (availQtys >= _runningQty)
                {
                    handlingUsedQty = _runningQty;
                    _runningQty = 0;
                }
                else
                {
                    _runningQty = _runningQty - availQtys;
                    handlingUsedQty = availQtys;
                }
            }
            else
            {
                Qty availQtyInUom = roundDown(EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_itemId, _inventDimId, availQtys, handlingUnit, _uom, false, false), 1);

                if (availQtyInUom > 0)
                {
                    if (availQtyInUom >= _runningQty)
                    {
                        handlingUsedQty = WHSCatchWeightHelper::convertInventQuantity(_itemId, _uom, _runningQty, _inventDimId);
                        _runningQty = 0;
                    }
                    else
                    {
                        _runningQty = _runningQty - availQtyInUom;
                        handlingUsedQty = WHSCatchWeightHelper::convertInventQuantity(_itemId, _uom, availQtyInUom, _inventDimId);
                    }
                }
            }

            this.onHandQuantitiesMap().insert(itemAndDimMapKey, availQtys - handlingUsedQty);
        }

        return _runningQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFixedLocationRanges</Name>
				<Source><![CDATA[
    private Query addFixedLocationRanges(Query _query, WHSUseFixedLocations _useFixedLocations, ItemId _itemId, InventDim _inventDim)
    {

        TableId dataSource;
        FieldId itemField, inventLocationField, productVariantInventDimField, wmsLocationLinkField;
        InventDimId inventDimIdProd;

        switch (_useFixedLocations)
        {
            case WHSUseFixedLocations::ProductFixed:
                dataSource = tableNum(WHSInventFixedLocation);
                itemField = fieldNum(WHSInventFixedLocation, ItemId);
                inventLocationField = fieldNum(WHSInventFixedLocation, InventLocationId);
                wmsLocationLinkField = fieldNum(WHSInventFixedLocation, WMSLocationId);
                break;

            case WHSUseFixedLocations::ProductVariantFixed:
                dataSource = tableNum(WHSProductVariantFixedLocation);
                itemField = fieldNum(WHSProductVariantFixedLocation, ItemId);
                inventLocationField = fieldNum(WHSProductVariantFixedLocation, InventLocationId);
                wmsLocationLinkField = fieldNum(WHSProductVariantFixedLocation, WMSLocationId);
                productVariantInventDimField = fieldNum(WHSProductVariantFixedLocation, ProductVariantInventDimId);

                InventDim productDim;
                productDim.initFromInventDim(_inventDim, InventDim::dimProductDimFieldList());
                productDim = InventDim::findOrCreate(productDim);
                inventDimIdProd = productDim.inventDimId;
                break;

            case WHSUseFixedLocations::Any:
                dataSource = tableNum(WMSLocation);
                wmsLocationLinkField = fieldNum(WMSLocation, WMSLocationId);
                inventLocationField = fieldNum(WMSLocation, InventLocationId);
                break;
        }

        if (itemField && wmsLocationLinkField && inventLocationField)
        {
            QueryBuildDataSource qbdsFixedLoc;

            qbdsFixedLoc = _query.dataSourceTable(tableNum(WMSLocation)).addDataSource(dataSource);
            qbdsFixedLoc.joinMode(JoinMode::ExistsJoin);
            qbdsFixedLoc.addLink(fieldNum(WMSLocation, WMSLocationId), wmsLocationLinkField);
            qbdsFixedLoc.addRange(itemField).value(_itemId);
            qbdsFixedLoc.addRange(inventLocationField).value(_inventDim.InventLocationId);

            if (productVariantInventDimField && inventDimIdProd)
            {
                qbdsFixedLoc.addRange(productVariantInventDimField).value(inventDimIdProd);
            }
        }

        QueryBuildDataSource    qbdsInventDim;
        QueryBuildDataSource    qbdsInventSum;
        InventDim onlyProdDims = _inventDim;
        onlyProdDims.clearNotProductDim(InventDimGroupSetup::newItemId(_itemId));

        if (InventUseDimOfInventSumToggle::instance().isEnabled())
        {
            qbdsInventSum = _query.dataSourceTable(dataSource).addDataSource(tableNum(InventSum));
            qbdsInventSum.joinMode(JoinMode::InnerJoin);
            qbdsInventSum.addLink(wmsLocationLinkField, fieldNum(InventSum, WMSLocationId));
            qbdsInventSum.addLink(inventLocationField, fieldNum(InventSum, InventLocationId));

            InventSum::queryAddRangeCriteriaForSelectedDims(qbdsInventSum, onlyProdDims, onlyProdDims.toDimParm());
        }
        else
        {
            qbdsInventDim = _query.dataSourceTable(dataSource).addDataSource(tableNum(InventDim));
            qbdsInventDim.joinMode(JoinMode::InnerJoin);
            qbdsInventDim.addLink(wmsLocationLinkField, fieldNum(InventDim, WMSLocationId));
            qbdsInventDim.addLink(inventLocationField, fieldNum(InventDim, InventLocationId));

            InventDim::queryAddRange(qbdsInventDim, onlyProdDims);

            qbdsInventSum = qbdsInventDim.addDataSource(tableNum(InventSum));
            qbdsInventSum.joinMode(JoinMode::InnerJoin);
            qbdsInventSum.addLink(fieldNum(InventDim, InventDimId), fieldNum(InventSum, InventDimId));
        }

        qbdsInventSum.addRange(fieldNum(InventSum, ItemId)).value(queryValue(_itemId));
        qbdsInventSum.addRange(fieldNum(InventSum, PhysicalInvent)).value('>0');
        qbdsInventSum.addRange(fieldNum(InventSum, ClosedQty)).value(queryValue(NoYes::No));

        return _query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewSlottedRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create new slot record, adding it to the record insert list for insert later.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID for the demand to be slotted.
    /// </param>
    /// <param name="_inventDimId">
    /// The invent dim ID for the demand to be slotted.
    /// </param>
    /// <param name="_uom">
    /// The unit of measure symbol for the demand to be slotted.
    /// </param>
    /// <param name="_locatedQty">
    /// The quantity being slotted.
    /// </param>
    /// <param name="_wmsLocation">
    /// The location the demand is being slotted to.
    /// </param>
    /// <param name="_slotTemplateLine">
    /// The recId for the slot template line used to locate the demand.
    /// </param>
    /// <param name="_overFlowUsed">
    /// True if an overflow location is used; otherwise, false.
    /// </param>
    /// <param name="_createLetUp">
    /// True if a let up needs to be created for the location; otherwise, false.
    /// </param>
    private void createNewSlottedRecord(
        ItemId                      _itemId,
        InventDimId                 _inventDimId,
        UnitOfMeasureSymbol         _uom,
        Qty                         _locatedQty,
        WMSLocation                 _wmsLocation = null,
        WHSSlotTemplateLineRecId    _slotTemplateLine = 0,
        boolean                     _overFlowUsed = false,
        boolean                     _createLetUp = false)
    {
        WHSSlotDemandLocated slotDemandLocated;

        slotDemandLocated.ItemId                    = _itemId;
        slotDemandLocated.EcoResProductName         = InventTable::name(_itemId, InventDim::find(_inventDimId));
        slotDemandLocated.InventDimId               = _inventDimId;
        slotDemandLocated.InventLocationId          = _wmsLocation.inventLocationId;
        slotDemandLocated.WMSLocationId             = _wmsLocation.wMSLocationId;
        slotDemandLocated.LocatedQty                = _locatedQty;
        slotDemandLocated.UnitOfMeasureSymbol       = _uom;
        slotDemandLocated.SlotTemplate              = slotTemplate.RecId;
        slotDemandLocated.SlotTemplateLine          = _slotTemplateLine;
        slotDemandLocated.OverFlowLocationUsed      = _overFlowUsed;
        slotDemandLocated.CreateLetUp               = _createLetUp;
        ril.add(slotDemandLocated);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processLocationQueryRun</Name>
				<Source><![CDATA[
    private Qty processLocationQueryRun(QueryRun _queryRun,
                                        Qty _runningQty,
                                        ItemId _itemId,
                                        InventDimId _inventDimId,
                                        UnitOfMeasureSymbol _uom,
                                        WHSSlotTemplateLine _slotTemplateLine)
    {
        WMSLocation location;
        Qty locatedQty;
        Qty runningQty = _runningQty;

        while (_queryRun.next() && runningQty > 0)
        {
            location = _queryRun.get(tableNum(WMSLocation));

            locatedQty = this.validateLocation(_itemId,
                                                _inventDimId,
                                                runningQty,
                                                _uom,
                                                location,
                                                false,
                                                _slotTemplateLine.SlotMixedUnits);

            if (locatedQty > 0)
            {
                this.createNewSlottedRecord(_itemId, _inventDimId, _uom, locatedQty, location, _slotTemplateLine.RecId);

                this.slottedLocations().add(this.warehouseLocationKey(location));

                if (_slotTemplateLine.SlotMixedUnits)
                {
                    this.addSlottedLocationsPerItem(
                        this.warehouseLocationKey(location),
                        WHSSlotDemandLocateLocationsPerItem::construct(_itemId, _inventDimId, _uom, locatedQty));
                }

                runningQty -= locatedQty;
            }
        }

        return runningQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findEmptyFixedLocations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check for empty fixed item locations for slotting.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID for the demand to be located.
    /// </param>
    /// <param name="_inventDimId">
    /// The invent dim ID for the demand to be located.
    /// </param>
    /// <param name="_uom">
    /// The unit of measure symbol for the demand to be located.
    /// </param>
    /// <param name="_qty">
    /// The quantity for the demand to be located.
    /// </param>
    /// <param name="_slotTemplateLine">
    /// The template line used to locate.
    /// </param>
    /// <returns>
    /// The quantity that wasn't able to be located.
    /// </returns>
    private Qty findEmptyFixedLocations(
        ItemId              _itemId,
        InventDimId         _inventDimId,
        UnitOfMeasureSymbol _uom,
        Qty                 _qty,
        WHSSlotTemplateLine _slotTemplateLine,
        InventLocationId    _warehouseId)
    {
        // Try to locate to fixed locations
        QueryRun locQueryRun = new QueryRun(_slotTemplateLine.PackedQueryRun);

        Query query = locQueryRun.query();

        QueryBuildDataSource qbdsInventFixedLocation = query.dataSourceTable(tableNum(WMSLocation)).addDataSource(tableNum(WHSInventFixedLocation));
        qbdsInventFixedLocation.addLink(fieldNum(WMSLocation, InventLocationId), fieldNum(WHSInventFixedLocation, InventLocationId));
        qbdsInventFixedLocation.addLink(fieldNum(WMSLocation, WMSLocationId), fieldNum(WHSInventFixedLocation, WMSLocationId));
        qbdsInventFixedLocation.joinMode(JoinMode::InnerJoin);

        qbdsInventFixedLocation.addRange(fieldNum(WHSInventFixedLocation, ItemId)).value(_itemId);

        WHSSlotTemplate slotTemplateLocal = _slotTemplateLine.SlotTemplate();
        this.addWarehouseRange(slotTemplateLocal, query.dataSourceTable(tableNum(WMSLocation)), _warehouseId);

        Qty runningQty = _qty;

        runningQty = this.processLocationQueryRun(locQueryRun, runningQty, _itemId, _inventDimId, _uom, _slotTemplateLine);

        if (runningQty > 0)
        {
            // Try to locate to fixed locations with product dimensions
            InventDim inventDim = InventDim::find(_inventDimId);
            inventDim.clearNotProductDim(InventDimGroupSetup::newInventTable(InventTable::find(_itemId)));
            inventDim = InventDim::findOrCreate(inventDim);

            locQueryRun = new QueryRun(_slotTemplateLine.PackedQueryRun);
            query = locQueryRun.query();

            QueryBuildDataSource qbdsProductVariantFixedLocation = query.dataSourceTable(tableNum(WMSLocation)).addDataSource(tableNum(WHSProductVariantFixedLocation));
            qbdsProductVariantFixedLocation.relations(true);
            qbdsProductVariantFixedLocation.addRange(fieldNum(WHSProductVariantFixedLocation, ItemId)).value(_itemId);
            qbdsProductVariantFixedLocation.addRange(fieldNum(WHSProductVariantFixedLocation, ProductVariantInventDimId)).value(inventDim.inventDimId);

            this.addWarehouseRange(slotTemplateLocal, query.dataSourceTable(tableNum(WMSLocation)), _warehouseId);

            runningQty = this.processLocationQueryRun(locQueryRun, runningQty, _itemId, _inventDimId, _uom, _slotTemplateLine);
        }

        return runningQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addWarehouseRange</Name>
				<Source><![CDATA[
    private void addWarehouseRange(
        WHSSlotTemplate      _slotTemplate,
        QueryBuildDataSource _qbdsWMSLocation,
        InventLocationId     _warehouseId)
    {
        if (_slotTemplate)
        {
            QueryBuildRange range = _qbdsWMSLocation.addRange(fieldNum(WMSLocation, InventLocationId));
            range.value(_warehouseId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLocationForDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find the location to slot the demand.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID for the demand to be slotted.
    /// </param>
    /// <param name="_inventDimId">
    /// The invent dim ID for the demand to be slotted.
    /// </param>
    /// <param name="_uom">
    /// The unit of measure symbol for the demand to be slotted.
    /// </param>
    /// <param name="_slotTemplateLine">
    /// The current template line used to find the location.
    /// </param>
    /// <param name="_runningQty">
    /// The qty to locate.
    /// </param>
    /// <param name="_assumeEmptyOverride">
    /// True if locating should assume empty regardless of setup, otherwise; false.
    /// </param>
    /// <param name="_runLetUps">
    /// True if the method was called during the let up process, otherwise; false.
    /// </param>
    /// <returns>
    /// The qty that was able to be slotted.
    /// </returns>
    private Qty findLocationForDemand(
        ItemId              _itemId,
        InventDimId         _inventDimId,
        UnitOfMeasureSymbol _uom,
        WHSSlotTemplateLine _slotTemplateLine,
        Qty                 _runningQty,
        boolean             _assumeEmptyOverride = false,
        boolean             _runLetUps = false)
    {
        boolean assumeEmpty = _slotTemplateLine.AssignSlotCriteria == WHSAssignSlotCriteria::AssumeEmpty ? true : false;

        QueryRun locQueryRun = new QueryRun(_slotTemplateLine.PackedQueryRun);

        InventLocationId warehouseId =  InventDim::find(_inventDimId).InventLocationId;

        Qty runningQty = this.slotToPrevious(_itemId,
                                             _inventDimId,
                                             _runningQty,
                                             _uom,
                                             warehouseId,
                                             slotTemplate.RecId);

        if (runningQty && !assumeEmpty)
        {
            runningQty = this.considerLocationsWithQty(_slotTemplateLine,
                                                       _itemId,
                                                       _inventDimId,
                                                       _uom,
                                                       runningQty);
        }

        // If not looking specifically for fixed locations, attempt to at least slot to them first
        if (runningQty && _slotTemplateLine.UseFixedLocation == WHSUseFixedLocations::Any)
        {
            runningQty = this.findEmptyFixedLocations(_itemId, _inventDimId, _uom, runningQty, _slotTemplateLine, warehouseId);
        }

        // Add fixed location ranges if configured
        if (runningQty > 0)
        {
            this.addFixedLocRange(locQueryRun.query(), _slotTemplateLine, _itemId, _inventDimId);
        }

        WMSLocation location;

        while (locQueryRun.next() && runningQty > 0)
        {
            location = locQueryRun.get(tableNum(WMSLocation));

            Qty locatedQty = this.validateLocation(_itemId,
                                                   _inventDimId,
                                                   runningQty,
                                                   _uom,
                                                   location,
                                                   _assumeEmptyOverride ? true : assumeEmpty,
                                                   _slotTemplateLine.SlotMixedUnits);

            if (locatedQty > 0)
            {
                boolean createLetUp;

                // If running for let ups, need to see if the location needs let up work.
                if (_runLetUps && !location.whsLocationIdEmpty())
                {
                    createLetUp = true;
                }

                this.createNewSlottedRecord(_itemId, _inventDimId, _uom, locatedQty, location, _slotTemplateLine.RecId, false, createLetUp);

                this.slottedLocations().add(this.warehouseLocationKey(location));

                if (_slotTemplateLine.SlotMixedUnits)
                {
                    this.addSlottedLocationsPerItem(
                        this.warehouseLocationKey(location),
                        WHSSlotDemandLocateLocationsPerItem::construct(_itemId, _inventDimId, _uom, locatedQty));
                }

                runningQty -= locatedQty;
            }
        }

        if (runningQty)
        {
            WMSLocation overflowLocation = this.overflowLocation(_slotTemplateLine, warehouseId);

            if (overflowLocation)
            {
                this.createNewSlottedRecord(_itemId, _inventDimId, _uom, runningQty, overflowLocation, _slotTemplateLine.RecId, true);
                runningQty = 0;
            }
        }

        return runningQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>overflowLocation</Name>
				<Source><![CDATA[
    private WMSLocation overflowLocation(WHSSlotTemplateLine _slotTemplateLine, InventLocationId _warehouseId)
    {
        if (_slotTemplateLine.OverflowLocationId)
        {
            return WMSLocation::find(_slotTemplateLine.OverflowLocationId, _warehouseId);
        }

        if (_slotTemplateLine.OverflowLocation)
        {
            return WHSSlotTemplateLine::findLocationByOverflowLocationRecId(_slotTemplateLine.OverflowLocation);
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSlotTemplateTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the slot template table record to be able to find the template lines.
    /// </summary>
    /// <param name="_slotTemplate">
    /// The slot template record for the template used.
    /// </param>
    private void initSlotTemplateTable(WHSSlotTemplate _slotTemplate)
    {
        slotTemplate = _slotTemplate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>locate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Slot demand records for the current slot template to a location.
    /// </summary>
    protected void locate()
    {
        using (var activityContext = instrumentationLogger.demandSlottingActivities().locateDemand())
        {
            instrumentationLogger.logRecordInformation(slotTemplate);

            ttsbegin;

            this.deleteLocatedDemandSlots();

            this.locateDemandSlots();

            if (allowLetUps)
            {
                this.locateDemandSlotsForLetUps();
            }

            ttscommit;
        }
        
        if (!this.validateGeneratedPlan())
        {
            warning("@WAX:SlottingPlanNotGeneratedWarning");
        }
        else 
        {
            info("@WAX:SlottingPlanGenerated");

            if (this.slottedLocations().empty() || !this.validateGeneratedPlanHasLocations())
            {
                warning("@WAX:SlottingPlanHasLinesWithUnassignedLocationsWarning");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateGeneratedPlan</Name>
				<Source><![CDATA[
    private boolean validateGeneratedPlan()
    {
        WHSSlotDemandLocated slotDemandLocated;

        select firstonly RecId from slotDemandLocated
                        where slotDemandLocated.SlotTemplate == slotTemplate.RecId;
        
        return slotDemandLocated.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateGeneratedPlanHasLocations</Name>
				<Source><![CDATA[
    private boolean validateGeneratedPlanHasLocations()
    {
        WHSSlotDemandLocated slotDemandLocated;

        select firstonly RecId from slotDemandLocated
                        where slotDemandLocated.SlotTemplate    == slotTemplate.RecId
                        &&    slotDemandLocated.WMSLocationId   == '';
        
        return slotDemandLocated.RecId == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>locateOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Wrapper method used to call into locateDemand using SysOperation framework.
    /// </summary>
    /// <param name="_data">
    /// The contract that has selected parameters.
    /// </param>
    [Hookable(false)]
    internal void locateOperation(WHSSlotDemandGenerateContract _data)
    {
        WHSSlotDemandLocate::locateDemand(WHSSlotTemplate::find(_data.parmSlotTemplateId()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>slotTemplateLines</Name>
				<Source><![CDATA[
    private List slotTemplateLines()
    {
        if (!slotTemplateLines)
        {
            using (var activityContext = instrumentationLogger.demandSlottingActivities().slotTemplateLines())
            {
                int assignSlotCriteriaCount;
                int allowLetUpsCount;
                int overflowLocationCount;
                int slotUOMTierIdCount;
                int useFixedLocationCount;

                slotTemplateLines = new List(Types::Record);

                WHSSlotTemplateLine slotTemplateLine;

                while select slotTemplateLine
                    order by SequenceNumber
                    where slotTemplateLine.SlotTemplate == slotTemplate.RecId
                {
                    assignSlotCriteriaCount += slotTemplateLine.AssignSlotCriteria                              ? 1 : 0;
                    allowLetUpsCount        += slotTemplateLine.AllowLetUps                                     ? 1 : 0;
                    overflowLocationCount   += slotTemplateLine.OverflowLocation                                ? 1 : 0;
                    slotUOMTierIdCount      += slotTemplateLine.SlotUOMTierId                                   ? 1 : 0;
                    useFixedLocationCount   += slotTemplateLine.UseFixedLocation != WHSUseFixedLocations::Any   ? 1 : 0;

                    slotTemplateLines.addEnd(slotTemplateLine);
                }

                activityContext.addCustomProperty('SlotTemplateLines.AssignSlotCriteriaCount', any2Str(assignSlotCriteriaCount));
                activityContext.addCustomProperty('SlotTemplateLines.AllowLetUpsCount', any2Str(allowLetUps));
                activityContext.addCustomProperty('SlotTemplateLines.OverflowLocationCount', any2Str(overflowLocationCount));
                activityContext.addCustomProperty('SlotTemplateLines.SlotUOMTierIdCount', any2Str(slotUOMTierIdCount));
                activityContext.addCustomProperty('SlotTemplateLines.UseFixedLocationCount', any2Str(useFixedLocationCount));
                activityContext.addCustomProperty('SlotTemplateLines.LineCount', any2Str(slotTemplateLines.elements()));
            }
        }

        return slotTemplateLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>slottedLocations</Name>
				<Source><![CDATA[
    private Set slottedLocations()
    {
        if (!slottedLocations)
        {
            slottedLocations = new Set(Types::String);
        }

        return slottedLocations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>slottedLocationsPerItem</Name>
				<Source><![CDATA[
    private Map slottedLocationsPerItem()
    {
        if (!slottedLocationsPerItem)
        {
            slottedLocationsPerItem = new Map(Types::String, Types::Class);
        }

        return slottedLocationsPerItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onHandQuantitiesMap</Name>
				<Source><![CDATA[
    private Map onHandQuantitiesMap()
    {
        if (!onHandQuantities)
        {
            onHandQuantities = new Map(Types::Container, Types::Real);
        }

        return onHandQuantities;
    }

]]></Source>
			</Method>
			<Method>
				<Name>locateDemandSlots</Name>
				<Source><![CDATA[
    private void locateDemandSlots()
    {
        using (var activityContext = instrumentationLogger.demandSlottingActivities().locateDemandSlots())
        {
            ril = new RecordInsertList(tableNum(WHSSlotDemandLocated));

            WHSSlotDemand slotDemand;

            while select slotDemand
                where slotDemand.SlotTemplate == slotTemplate.RecId
            {
                this.loopTemplateLines(slotDemand);
            }

            ril.insertDatabase();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>locateDemandSlotsForLetUps</Name>
				<Source><![CDATA[
    private void locateDemandSlotsForLetUps()
    {
        using (var activityContext = instrumentationLogger.demandSlottingActivities().locateDemandSlotsForLetUps())
        {
            ril = new RecordInsertList(tableNum(WHSSlotDemandLocated));

            WHSSlotDemandLocated slotDemandLocated;

            // Try locating and setting let ups.
            while select forupdate slotDemandLocated
                where slotDemandLocated.SlotTemplate    == slotTemplate.RecId
                &&    slotDemandLocated.WMSLocationId   == ''
            {
                this.loopTemplateLinesForLetups(slotDemandLocated);
            }

            ril.insertDatabase();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loopTemplateLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loop over the slot template lines to slot demand.
    /// </summary>
    /// <param name="_slotDemand">
    /// The slot demand record that needs slotted.
    /// </param>
    private void loopTemplateLines(WHSSlotDemand _slotDemand)
    {
        WHSSlotTemplateLine slotTemplateLine;
        Qty                 runningQty = _slotDemand.DemandQty;

        Enumerator lineEnumerator = this.slotTemplateLines().getEnumerator();

        while (lineEnumerator.moveNext())
        {
            slotTemplateLine = lineEnumerator.current();

            if (!slotTemplateLine.isValidForDemand(_slotDemand.UnitOfMeasureSymbol, _slotDemand.DemandQty))
            {
                continue;
            }

            if (slotTemplateLine.AllowLetUps)
            {
                allowLetUps = NoYes::Yes;
            }

            runningQty = this.findLocationForDemand(_slotDemand.ItemId,
                                                    _slotDemand.InventDimId,
                                                    _slotDemand.UnitOfMeasureSymbol,
                                                    slotTemplateLine,
                                                    runningQty);

            if (runningQty == 0)
            {
                break;
            }
        }

        if (runningQty)
        {
            this.createNewSlottedRecord(_slotDemand.ItemId, _slotDemand.InventDimId, _slotDemand.UnitOfMeasureSymbol, runningQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loopTemplateLinesForLetups</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loop over the slot template lines to slot demand.
    /// </summary>
    /// <param name="_slotDemandLocated">
    /// The located slot demand record that initially failed slotting.
    /// </param>
    private void loopTemplateLinesForLetups(WHSSlotDemandLocated _slotDemandLocated)
    {
        WHSSlotTemplateLine     slotTemplateLine;
        WHSSlotDemandLocated    slotDemandLocated;
        Qty                     runningQty = _slotDemandLocated.LocatedQty;

        Enumerator lineEnumerator = this.slotTemplateLines().getEnumerator();

        while (lineEnumerator.moveNext())
        {
            slotTemplateLine = lineEnumerator.current();

            if (slotTemplateLine.AllowLetUps != NoYes::Yes)
            {
                continue;
            }

            if (!slotTemplateLine.isValidForDemand(_slotDemandLocated.UnitOfMeasureSymbol, _slotDemandLocated.LocatedQty))
            {
                continue;
            }

            runningQty = this.findLocationForDemand(_slotDemandLocated.ItemId,
                                                    _slotDemandLocated.InventDimId,
                                                    _slotDemandLocated.UnitOfMeasureSymbol,
                                                    slotTemplateLine,
                                                    runningQty,
                                                    true,
                                                    true);

            if (runningQty == 0)
            {
                _slotDemandLocated.delete();
                break;
            }
        }

        if (runningQty > 0 && runningQty != _slotDemandLocated.LocatedQty)
        {
            _slotDemandLocated.LocatedQty = runningQty;
            _slotDemandLocated.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteLocatedDemandSlots</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete old located slot demand records.
    /// </summary>
    private void deleteLocatedDemandSlots()
    {
        WHSSlotDemandLock::acquireSlottingLock(this.slotTemplate, instrumentationLogger.demandSlottingActivities());

        using (var activityContext = instrumentationLogger.demandSlottingActivities().deleteLocatedDemandSlots())
        {
            WHSSlotDemandLocated slotDemandLocated;

            delete_from slotDemandLocated
                where slotDemandLocated.SlotTemplate == slotTemplate.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>slotToPrevious</Name>
				<Source><![CDATA[
    /// <summary>
    /// Try to slot demand to previously slotted locations.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID of the demand.
    /// </param>
    /// <param name="_inventDimId">
    /// The inventDimId for the demand.
    /// </param>
    /// <param name="_qty">
    /// The qty to slot.
    /// </param>
    /// <param name="_uom">
    /// The unit of measure for the qty to slot.
    /// </param>
    /// <param name="_inventLocationId">
    /// The warehouse the slotting is running in.
    /// </param>
    /// <param name="_slotTemplateRecId">
    /// The Record Id for the slot template that is being run.
    /// </param>
    /// <returns>
    /// The qty that wasn't able to be slotted.
    /// </returns>
    private Qty slotToPrevious(
        ItemId                  _itemId,
        InventDimId             _inventDimId,
        Qty                     _qty,
        UnitOfMeasureSymbol     _uom,
        InventLocationId        _inventLocationId,
        WHSSlotTemplateRecId    _slotTemplateRecId)
    {
        Qty                     runningQty = _qty;
        WMSLocation             location;
        WHSSlotDemandLocated    slotDemandLocated;

        ttsbegin;

        select firstOnly forUpdate slotDemandLocated
            where slotDemandLocated.ItemId                  == _itemId
            &&    slotDemandLocated.InventDimId             == _inventDimId
            &&    slotDemandLocated.UnitOfMeasureSymbol     == _uom
            &&    slotDemandLocated.InventLocationId        == _inventLocationId
            &&    slotDemandLocated.SlotTemplate            == _slotTemplateRecId
            exists join location
                where location.wmslocationId    == slotDemandLocated.WMSLocationId
                &&    location.inventLocationId == _inventLocationId;

        if (slotDemandLocated.RecId)
        {
            Qty locateQty;

            if (location.isReplenishmentOverflowEnabled())
            {
                locateQty = runningQty;
            }
            else
            {
                locateQty = this.validateItemFit(slotDemandLocated.WMSLocationId, _inventLocationId, _itemId, runningQty, _inventDimId, _uom, false, slotDemandLocated.LocatedQty);
            }

            if (locateQty > 0)
            {
                slotDemandLocated.LocatedQty += locateQty;
                
                slotDemandLocated.update();
               
                runningQty -= locateQty;
            }
        }

        ttscommit;

        return runningQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateItemFit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate the item can be placed in the location.
    /// </summary>
    /// <param name="_wmsLocationId">
    /// The location to slot the item.
    /// </param>
    /// <param name="_inventLocationId">
    /// The warehouse for the location.
    /// </param>
    /// <param name="_itemId">
    /// The item being slotted to the location.
    /// </param>
    /// <param name="_qty">
    /// The demand qty.
    /// </param>
    /// <param name="_inventDimId">
    /// The inventory dimensions for the item.
    /// </param>
    /// <param name="_unitId">
    /// The unit of measure symbol for the item.
    /// </param>
    /// <param name="_assumeEmpty">
    /// True if the location should be assumed empty, otherwise; false.
    /// </param>
    /// <param name="_locatedQty">
    /// Already located quantity.
    /// </param>
    /// <param name="_locatedUom">
    /// Already located unit of measure.
    /// </param>
    /// <returns>
    /// The qty that fits in the location.
    /// </returns>
    private Qty validateItemFit(
        WMSLocationId       _wmsLocationId,
        InventLocationId    _inventLocationId,
        ItemId              _itemId,
        Qty                 _qty,
        InventDimId         _inventDimId,
        UnitOfMeasureSymbol _unitId,
        boolean             _assumeEmpty = false,
        Qty                 _locatedQty = 0,
        UnitOfMeasureSymbol _locatedUom = '')
    {
        Qty     returnQty;
        boolean allowMultiSku = WHSLocationProfile::find(WMSLocation::find(_wmsLocationId, _inventLocationId).LocProfileId).AllowMixedItems;

        Qty                 allowedQty;
        UnitOfMeasureSymbol allowedUnitId;

        [allowedQty, allowedUnitId] = WHSLocationLimit::retrieveQty(_inventLocationId,
                                                                    _wmsLocationId,
                                                                    _itemId,
                                                                    WHSCatchWeightHelper::inventHandlingUnitId(_itemId),
                                                                    false,
                                                                    _inventDimId);

        if (!allowedQty)
        {
            returnQty = this.validateVolumetrics(_wMSLocationId,
                                                 _inventLocationId,
                                                 _itemId,
                                                 _qty,
                                                 _inventDimId,
                                                 _unitId,
                                                 _assumeEmpty,
                                                 _locatedQty,
                                                 _locatedUom);
        }
        else
        {
            Qty availQty;

            if (_assumeEmpty)
            {
                availQty = allowedQty;
            }
            else
            {
                Qty         qtyInLocation;
                ItemId      itemIdInLocation;
                InventDimId inventDimInLocation;

                [itemIdInLocation, inventDimInLocation, qtyInLocation] = WHSLocationDirective::getTotalQtyInLocation(_inventLocationId,
                                                                                                                     _wmsLocationId,
                                                                                                                     allowedUnitId,
                                                                                                                     allowMultiSku);

                availQty = allowedQty - qtyInLocation;
            }

            EcoResProductUnitConverter productUnitConverter = EcoResProductUnitConverter::newGivenUnitSymbolsForReleasedProduct(_itemId, _inventDimId, allowedUnitId, _unitId, NoYes::No, NoYes::No);
            
            if (productUnitConverter.canValueBeConverted())
            {
                availQty = productUnitConverter.convertValue(availQty); 
            }
            else
            {
                warning(strFmt("@WAX:SlottingLocationSkipBecauseOfWrongConversionWarning", _wmsLocationId, _itemId));
                availQty = 0;
            }

            if (availQty > 0)
            {
                if (_locatedQty 
                    && _locatedUom)
                {
                    EcoResProductUnitConverter locatedProductUnitConverter = EcoResProductUnitConverter::newGivenUnitSymbolsForReleasedProduct(_itemId, _inventDimId, _locatedUom, _unitId, NoYes::No, NoYes::No);

                    if (locatedProductUnitConverter.canValueBeConverted())
                    {
                        availQty -= locatedProductUnitConverter.convertValue(_locatedQty);
                    }
                }
                else if (_locatedQty)
                {
                    availQty -= _locatedQty;
                }

                if (_qty > availQty)
                {
                    returnQty = availQty;
                }
                else
                {
                    returnQty = _qty;
                }
            }
            else
            {
                returnQty = 0;
            }
        }

        return returnQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate the location works to slot the current demand.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID to be slotted.
    /// </param>
    /// <param name="_inventDimId">
    /// The invent dim ID for the dimensions of the item.
    /// </param>
    /// <param name="_qty">
    /// The quantity to slot to the location.
    /// </param>
    /// <param name="_uom">
    /// The unit of measure for the qty.
    /// </param>
    /// <param name="_wmsLocation">
    /// The wmslocation to locate demand to.
    /// </param>
    /// <param name="_assumeEmpty">
    /// The flag on the template line to assume locations are empty.
    /// </param>
    /// <param name="_slotMixedUnits">
    /// True if mixing of units is allowed, otherwise; false.
    /// </param>
    /// <returns>
    /// The quantity that can be slotted to the location.
    /// </returns>
    private Qty validateLocation(
        ItemId                  _itemId,
        InventDimId             _inventDimId,
        Qty                     _qty,
        UnitOfMeasureSymbol     _uom,
        WMSLocation             _wmsLocation,
        boolean                 _assumeEmpty,
        boolean                 _slotMixedUnits = false)
    {
        Qty locatedQty = _qty;

        if (_slotMixedUnits)
        {
            if (!this.checkSameItemInLocation(
                this.warehouseLocationKey(_wmsLocation),
                _itemId, 
                _inventDimId))
            {
                locatedQty = 0;
            }
        }
        // Can't slot to an already slotted location.
        else if (this.slottedLocations().in(this.warehouseLocationKey(_wmsLocation)))
        {
            locatedQty = 0;
        }

        // Can't slot to a location with qty unless we are assuming empty.
        if (locatedQty > 0
        &&  !_assumeEmpty)
        {
            if (!_wmsLocation.whsLocationIdEmpty())
            {
                locatedQty = 0;
            }
        }

        if (locatedQty > 0)
        {
            WHSWorkLine     workLine;
            WHSWorkTable    workTable;

            // Can't slot to a location with open put work.
            select RecId from workLine
                where (workLine.WorkStatus      == WHSWorkStatus::Open
                ||     workLine.WorkStatus      == WHSWorkStatus::InProcess)
                &&     workLine.WorkType        == WHSWorkType::Put
                &&     workLine.wMSLocationId   == _wmsLocation.wMSLocationId
                exists join workTable
                    where workTable.InventLocationId    == _wmsLocation.inventLocationId
                    &&    workLine.WorkId               == workTable.WorkId;

            if (workLine.RecId != 0)
            {
                locatedQty = 0;
            }
        }

        if (locatedQty > 0
            && !_wmsLocation.isReplenishmentOverflowEnabled())
        {
            Qty alreadyLocatedQty;
            UnitOfMeasureSymbol locatedUOM;
            str wahouseLocationKey = this.warehouseLocationKey(_wmsLocation);

            if (this.slottedLocationsPerItem().exists(wahouseLocationKey))
            {
                WHSSlotDemandLocateLocationsPerItem slotDemandLocateLocationPerItem = this.slottedLocationsPerItem().lookup(wahouseLocationKey);
                alreadyLocatedQty = slotDemandLocateLocationPerItem.parmQty();
                locatedUOM = slotDemandLocateLocationPerItem.parmUnitOfMeasure();
            }

            locatedQty = this.validateItemFit(_wmsLocation.wMSLocationId,
                                              _wmsLocation.inventLocationId,
                                              _itemId,
                                              _qty,
                                              _inventDimId,
                                              _uom,
                                              _assumeEmpty,
                                              alreadyLocatedQty,
                                              locatedUOM);
        }

        return locatedQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSameItemInLocation</Name>
				<Source><![CDATA[
    private boolean checkSameItemInLocation(str _warehouseLocationKey, ItemId _itemId, InventDimId _inventDimId)
    {
        if (this.slottedLocationsPerItem().exists(_warehouseLocationKey))
        {
            WHSSlotDemandLocateLocationsPerItem slotDemandLocateLocationPerItem = this.slottedLocationsPerItem().lookup(_warehouseLocationKey);
            return slotDemandLocateLocationPerItem.isSameItem(_itemId, _inventDimId);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateVolumetrics</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate the item can be placed in the location.
    /// </summary>
    /// <param name="_wmsLocationId">
    /// The location to slot the item.
    /// </param>
    /// <param name="_inventLocationId">
    /// The warehouse for the location.
    /// </param>
    /// <param name="_itemId">
    /// The item being slotted to the location.
    /// </param>
    /// <param name="_qty">
    /// The demand qty.
    /// </param>
    /// <param name="_inventDimId">
    /// The inventory dimensions for the item.
    /// </param>
    /// <param name="_unitId">
    /// The unit of measure symbol for the item.
    /// </param>
    /// <param name="_assumeEmpty">
    /// True if the location should be assumed empty, otherwise; false.
    /// </param>
    /// <param name="_locatedQty">
    /// Already located quantity.
    /// </param>
    /// <param name="_locatedUOM">
    /// Already located unit of measure.
    /// </param>
    /// <returns>
    /// The qty that fits in the location.
    /// </returns>
    private Qty validateVolumetrics(
        WMSLocationId       _wmsLocationId,
        InventLocationId    _inventLocationId,
        ItemId              _itemId,
        Qty                 _qty,
        InventDimId         _inventDimId,
        UnitOfMeasureSymbol _unitId,
        boolean             _assumeEmpty = false,
        Qty                 _locatedQty = 0,
        UnitOfMeasureSymbol _locatedUOM = '')
    {
        Qty                 locatingQty = _qty;
        Qty                 returnQty;
        WMSLocation         wmsLocation = WMSLocation::find(_wmsLocationId, _inventLocationId);
        WHSLocationProfile  locProfile = WHSLocationProfile::find(WMSLocation::find(_wmsLocationId, _inventLocationId).LocProfileId);
        InventUnitId        unitId = _unitId;

        // Check to see if the location is set up with unlimited dimensions
        if (locProfile.DimensionFillPCT == WHSDimensionFillPCT::UsableDimensions
        &&  locProfile.UsableHeight     == 0
        &&  locProfile.UsableDepth      == 0
        &&  locProfile.UsableWidth      == 0)
        {
            return _qty;
        }
        else if (locProfile.DimensionFillPCT == WHSDimensionFillPCT::FillPercentage
        &&       locProfile.Height           == 0
        &&       locProfile.Depth            == 0
        &&       locProfile.Height           == 0)
        {
            return _qty;
        }

        WHSPhysDimUOM locatingPhysDimUOM = WHSPhysDimUOM::getPhysDimUOMByItem(_itemId, unitId);

        if (locatingPhysDimUOM.RecId != 0)
        {
            if (this.validateVolumetricsItemDims(locProfile, locatingPhysDimUOM))
            {
                returnQty = _qty;

                EcoResReleasedProductUnitConverter releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();

                WHSLocationTotalWeightVolumeCalculator totalWeightVolumeCalculator = WHSLocationTotalWeightVolumeCalculator::newFromLocationUnitSymbol(wmsLocation, unitId);
                totalWeightVolumeCalculator.parmUnitConverter(releasedProductUnitConverter);

                Weight  totalWeight;
                Volume  totalVolume;

                if (_assumeEmpty)
                {
                    [totalWeight, totalVolume] = totalWeightVolumeCalculator.calculateUnprocessedPutWeightAndVolume();
                }
                else
                {
                    totalWeight = totalWeightVolumeCalculator.calculateTotalWeight();
                    totalVolume = totalWeightVolumeCalculator.calculateTotalVolume();
                }

                // Add up the volume and weight of the item we are trying to locate
                totalWeight += locatingPhysDimUOM.Weight * locatingQty;
                totalVolume += locatingPhysDimUOM.displayVolume() * locatingQty;

                if (_locatedQty 
                    && _locatedUOM)
                {
                    WHSPhysDimUOM locatingPhysDimUOMLocal = WHSPhysDimUOM::getPhysDimUOMByItem(_itemId, _locatedUOM);

                    totalWeight += locatingPhysDimUOMLocal.Weight * _locatedQty;
                    totalVolume += locatingPhysDimUOMLocal.displayVolume() * _locatedQty;
                }
                else if (_locatedQty)
                {
                    totalWeight += locatingPhysDimUOM.Weight * _locatedQty;
                    totalVolume += locatingPhysDimUOM.displayVolume() * _locatedQty;
                }

                boolean checkHowMuchQty;

                // Check that the weight and volume doesn't exceed allowed
                if (locProfile.DimensionFillPCT == WHSDimensionFillPCT::UsableDimensions)
                {
                    if ((locProfile.MaxWeight != 0 && totalWeight > locProfile.MaxWeight)
                    ||  totalVolume > locProfile.UsableVolume)
                    {
                        checkHowMuchQty = true;
                        returnQty = 0;
                    }
                }
                else if ((locProfile.MaxWeight != 0 && totalWeight > locProfile.MaxWeight)
                     ||  totalVolume > (locProfile.TotalVolume * (locProfile.FillPercentage / 100)))
                {
                    checkHowMuchQty = true;
                    returnQty = 0;
                }

                if (checkHowMuchQty)
                {
                    totalWeight -= locatingPhysDimUOM.Weight * locatingQty;
                    totalVolume -= locatingPhysDimUOM.displayVolume() * locatingQty;

                    // Find out how much can be located
                    for (int i; i <= _qty; ++i)
                    {
                        returnQty = roundDown(_qty - i, 1);

                        if (locProfile.DimensionFillPCT == WHSDimensionFillPCT::UsableDimensions)
                        {
                            if (locProfile.MaxWeight != 0
                            &&  totalWeight + (returnQty * locatingPhysDimUOM.Weight) <= locProfile.MaxWeight
                            &&  totalVolume + (returnQty * locatingPhysDimUOM.displayVolume()) <= locProfile.UsableVolume)
                            {
                                break;
                            }
                        }
                        else if (locProfile.MaxWeight != 0
                             &&  totalWeight + (returnQty * locatingPhysDimUOM.Weight) <= locProfile.MaxWeight
                             &&  totalVolume + (returnQty * locatingPhysDimUOM.displayVolume()) <= locProfile.TotalVolume * (locProfile.FillPercentage / 100))
                        {
                            break;
                        }
                    }
                }
            }
        }
        else
        {
            returnQty = _qty;
        }

        return returnQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateVolumetricsItemDims</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the physical dimensions of the item will fit in the location.
    /// </summary>
    /// <param name="_locProfile">
    /// The location profile of the location we are evaluating.
    /// </param>
    /// <param name="_locatingPhysDimUOM">
    /// The phys dimensions of the item.
    /// </param>
    /// <returns>
    /// true if the item fits in the location; otherwise, false.
    /// </returns>
    private boolean validateVolumetricsItemDims(
        WHSLocationProfile  _locProfile,
        WHSPhysDimUOM       _locatingPhysDimUOM)
    {
        boolean ret;

        // Check if the item will fit in the location
        if (_locProfile.DimensionFillPCT == WHSDimensionFillPCT::UsableDimensions)
        {
            if (_locProfile.UsableHeight >= _locatingPhysDimUOM.Height
            &&  _locProfile.UsableWidth  >= _locatingPhysDimUOM.Width
            &&  _locProfile.UsableDepth  >= _locatingPhysDimUOM.Depth)
            {
                ret = true;
            }
        }
        else if (_locProfile.Height   >= _locatingPhysDimUOM.Height
             &&  _locProfile.Width    >= _locatingPhysDimUOM.Width
             &&  _locProfile.Depth    >= _locatingPhysDimUOM.Depth)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>letUpByTemplate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create movement work for slotted demand that needs let up.
    /// </summary>
    /// <param name="_slotDemandLocated">
    /// The slot demand record that needs movement work created.
    /// </param>
    [Hookable(false)]
    internal static void letUpByTemplate(WHSSlotDemandLocated _slotDemandLocated)
    {
        InventSum inventSum;
        InventDim inventDim;

        if (InventUseDimOfInventSumToggle::instance().isEnabled())
        {
            while select ItemId, InventDimId, PhysicalInvent, #InventDimGroupAllFields from inventSum
                where  inventSum.PhysicalInvent  >  0
                    && inventSum.ClosedQty      == NoYes::No
                    && inventSum.wmslocationId  == _slotDemandLocated.WMSLocationId
            {
                inventDim.clear();
                inventDim.initFromInventSum(inventSum);

                // Create movement work
                inventDim.clearLocationAndBelowDim(inventSum.ItemId);
                inventDim = InventDim::findOrCreate(inventDim);

                WHSTmpMovementWork tmpMovementWork;
                tmpMovementWork.InventDimId         = inventDim.InventDimId;
                tmpMovementWork.ItemId              = inventSum.ItemId;
                tmpMovementWork.Qty                 = WHSInventOnHand::getWorkPhysicalAvail(inventSum.ItemId, inventSum.InventDimId);
                tmpMovementWork.UnitID              = WHSCatchWeightHelper::inventHandlingUnitId(inventSum.ItemId);

                if (tmpMovementWork.Qty > 0)
                {
                    WHSWorkCreate workCreate = WHSWorkCreate::construct(tmpMovementWork);
                    workCreate.parmStartLocationId(_slotDemandLocated.wMSLocationId);
                    workCreate.createWork();
                }
            }
        }
        else
        {
            while select ItemId, InventDimId, PhysicalInvent from inventSum
                where  inventSum.PhysicalInvent >  0
                    && inventSum.ClosedQty      == NoYes::No
                join inventDim
                    where inventDim.inventDimId     == inventSum.InventDimId
                    &&    inventDim.wmslocationId   == _slotDemandLocated.WMSLocationId
            {
                // Create movement work
                inventDim.clearLocationAndBelowDim(inventSum.ItemId);
                inventDim = InventDim::findOrCreate(inventDim);

                WHSTmpMovementWork tmpMovementWork;
                tmpMovementWork.InventDimId         = inventDim.InventDimId;
                tmpMovementWork.ItemId              = inventSum.ItemId;
                tmpMovementWork.Qty                 = WHSInventOnHand::getWorkPhysicalAvail(inventSum.ItemId, inventSum.InventDimId);
                tmpMovementWork.UnitID              = WHSCatchWeightHelper::inventHandlingUnitId(inventSum.ItemId);

                if (tmpMovementWork.Qty > 0)
                {
                    WHSWorkCreate workCreate = WHSWorkCreate::construct(tmpMovementWork);
                    workCreate.parmStartLocationId(_slotDemandLocated.wMSLocationId);
                    workCreate.createWork();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromSlotTemplate</Name>
				<Source><![CDATA[
    private static WHSSlotDemandLocate newFromSlotTemplate(WHSSlotTemplate _slotTemplateTable)
    {
        WHSSlotDemandLocate slotDemandLocate = new WHSSlotDemandLocate();
        slotDemandLocate.initSlotTemplateTable(_slotTemplateTable);

        return slotDemandLocate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>locateDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Slot demand based on the slot template.
    /// </summary>
    /// <param name="_slotTemplateTable">
    /// The slotting template record used to slot the demand.
    /// </param>
    [Hookable(false)]
    internal static void locateDemand(WHSSlotTemplate _slotTemplateTable)
    {
        WHSSlotDemandLocate::newFromSlotTemplate(_slotTemplateTable).locate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFixedLocRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds ranges for fixed locations to the slotting query.
    /// </summary>
    /// <param name="_query">
    /// The current slotting query.
    /// </param>
    /// <param name="_slotTemplateLine">
    /// The slotting template detail record.
    /// </param>
    /// <param name="_itemId">
    /// The item being slotted.
    /// </param>
    /// <param name="_inventDimId">
    /// The inventory dimensions being slotted.
    /// </param>
    private void addFixedLocRange(
        Query               _query,
        WHSSlotTemplateLine _slotTemplateLine,
        ItemId              _itemId,
        InventDimId         _inventDimId)
    {
        QueryBuildDataSource qbdsFixedLoc;
        InventDim inventDim = InventDim::find(_inventDimId);

        switch (_slotTemplateLine.UseFixedLocation)
        {
            case WHSUseFixedLocations::ProductFixed:
                qbdsFixedLoc = _query.dataSourceTable(tableNum(WMSLocation)).addDataSource(tableNum(WHSInventFixedLocation));
                qbdsFixedLoc.joinMode(JoinMode::ExistsJoin);
                qbdsFixedLoc.addLink(fieldNum(WMSLocation, WMSLocationId), fieldNum(WHSInventFixedLocation, WMSLocationId));
                qbdsFixedLoc.addRange(fieldNum(WHSInventFixedLocation, ItemId)).value(_itemId);
                qbdsFixedLoc.addRange(fieldNum(WHSInventFixedLocation, InventLocationId)).value(inventDim.InventLocationId);
                break;

            case WHSUseFixedLocations::ProductVariantFixed:
                InventDim productDim;
                productDim.initFromInventDim(inventDim, InventDim::dimProductDimFieldList());
                productDim = InventDim::findOrCreate(productDim);

                qbdsFixedLoc = _query.dataSourceTable(tableNum(WMSLocation)).addDataSource(tableNum(WHSProductVariantFixedLocation));
                qbdsFixedLoc.joinMode(JoinMode::ExistsJoin);
                qbdsFixedLoc.addLink(fieldNum(WMSLocation, WMSLocationId), fieldNum(WHSProductVariantFixedLocation, WMSLocationId));
                qbdsFixedLoc.addRange(fieldNum(WHSProductVariantFixedLocation, ItemId)).value(_itemId);
                qbdsFixedLoc.addRange(fieldNum(WHSProductVariantFixedLocation, InventLocationId)).value(inventDim.InventLocationId);
                qbdsFixedLoc.addRange(fieldNum(WHSProductVariantFixedLocation, ProductVariantInventDimId)).value(productDim.inventDimId);
                break;
        }

        this.addWarehouseRange(_slotTemplateLine.SlotTemplate(), 
            _query.dataSourceTable(tableNum(WMSLocation)),
            InventDim::find(_inventDimId).InventLocationId);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>