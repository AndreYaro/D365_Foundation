<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TrvSubmitExpenseReportToWorkflow</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Class to handle the submission of expense report records to workflow.
/// </summary>
class TrvSubmitExpenseReportToWorkflow extends TrvSubmitToWorkflow
{
    private ExpenseInstrumentationLogger logger;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        super();
        this.logger = ExpenseInstrumentationLogger::createLogger(classStr(TrvSubmitExpenseReportToWorkflow));
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateApprovalStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the current status of the entity in the system with the workflow submitted record.
    /// </summary>
    /// <returns>
    /// False if the status is different from the workflow submitted record. Otherwise, true.
    /// </returns>
    protected boolean validateApprovalStatus()
    {
        TrvExpTable 	trvExpTableLocal;
        TrvExpTable 	trvExpTableInstance = this.parmEntity();
        boolean         canSubmit   = true;

        trvExpTableLocal.disableCache(true);
        select firstonly ApprovalStatus from trvExpTableLocal where trvExpTableLocal.RecId == trvExpTableInstance.RecId;

        // To check whether expense report is already submitted.
        return trvExpTableLocal.ApprovalStatus == trvExpTableInstance.ApprovalStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSubmitterUserId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets workflow submitter user id of the entity in the system with the workflow submitted record.
    /// </summary>
    /// <returns>
    /// The submitter user id of the workflow
    /// </returns>
    protected WorkflowUser getSubmitterUserId()
    {
        TrvExpTable 	trvExpTableInstance = this.parmEntity();
        WorkflowUser    submittingUserId;

        submittingUserId = trvExpTableInstance.getUserId();

        return submittingUserId ? submittingUserId : curuserid();
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Construct an instance of <c>TrvSubmitExpenseReportToWorkflow</c>.
    /// </summary>
    /// <param name = "_entity">Expense report entity that will be submitted.</param>
    /// <param name = "_workflowVersionTable">An instance of <c>WorkflowVersionTable</c>.</param>
    /// <param name = "_workflowComment">Workflow comments.</param>
    /// <returns>Created instance of <c>TrvSubmitExpenseReportToWorkflow</c></returns>
    public static TrvSubmitExpenseReportToWorkflow construct(Common _entity, WorkflowVersionTable _workflowVersionTable = null, WorkflowComment _workflowComment = '')
    {
        TrvSubmitExpenseReportToWorkflow submitToWorkflow = new TrvSubmitExpenseReportToWorkflow();
        submitToWorkflow.initialize(_entity, _workflowVersionTable, _workflowComment);
        return submitToWorkflow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doAsyncValidation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Do the submit validation asynchronously.
    /// </summary>
    /// <returns>The async task object.</returns>
    protected System.Threading.Tasks.Task doAsyncValidation(System.Threading.CancellationTokenSource _tokenSource)
    {
        System.Threading.Tasks.Task task = runAsync(classnum(TrvSubmitExpenseReportToWorkflow),
                                            "handleValidationAsync",
                                            [this.parmEntity()],
                                            _tokenSource.Token);
        return task;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleValidationAsync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handle submit validations. This is a wrapper method suitable for being called asynchronously.
    /// </summary>
    /// <param name = "params">A <c>TrvExpTable</c> record in a container.</param>
    /// <param name = "cancellationToken">A cancellation token to request cancellation of async method's execution.</param>
    /// <returns>A container with a single value: True if valid; otherwise, false.</returns>
    public static container handleValidationAsync(container _params, System.Threading.CancellationToken _cancellationToken)
    {
        if (conLen(_params) != 1)
        {
            error(strFmt("@SYS22828", funcName()));
        }

        TrvExpTable trvExpTable;
        [trvExpTable] = [_params];

        boolean valid = trvExpTable.validateSubmit();

        if (_cancellationToken.IsCancellationRequested)
        {
            _cancellationToken.ThrowIfCancellationRequested();
        }

        return [valid];
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSubmit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Submit validation logic for expense report.
    /// </summary>
    /// <returns>True if valid; otherwise, false.</returns>
    protected boolean validateSubmit()
    {
        // Including validateSubmit in the transaction scope will cause undesired behavior with budget checks.
        // The budget source records won't be updated until after the commit, so any budget error will be missed during validation.
        // Therefore, we don't include this line within the ttsbegin-ttscommit block.
        return this.parmEntity().validateSubmit();
    }

]]></Source>
			</Method>
			<Method>
				<Name>submit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Submit the expense report.
    /// </summary>
    /// <returns>True if successful, otherwise false.</returns>
    protected boolean submit()
    {
        WorkflowContext workflowContext = WorkflowContext::construct();
        boolean         success         = false;

        try
        {
            Microsoft.Dynamics.Application.Instrumentation.ApplicationEventSource::EventWriteTrvExpenseReportSubmitStart(0, 0, true);
            ExpenseInstrumentationSubmitActivities submitActivities = ExpenseInstrumentationSubmitActivities::construct(logger);
            ExpenseInstrumentationLoggerProperties properties = logger.properties();

            using (var submitExpenseReportContext = submitActivities.expenseReportHeaderContext())
            {
                ttsbegin;
                TrvSubmitExpenseReportToWorkflow::handleDistributionsForCashAdvance(this.parmEntity());
                this.submitToWorkflow();

                // Set expense report to pending status on submit.
                workflowContext.parmRecId(this.parmEntity().RecId);
                workflowContext.parmTableId(this.parmEntity().TableId);
                TrvWorkflowUtilities::setExpenseDocumentStatus(workflowContext, TrvAppStatus::Pending);
                success = true;
                ttscommit;

                logger.logInformation(strFmt('%1:%2', ExpenseInstrumentationLoggerProperties::ExpenseNum, (this.parmEntity() as TrvExpTable).ExpNumber));
                submitActivities.addCustomProperty(submitExpenseReportContext, properties.propertyByTableRecord(this.parmEntity()));
            }
        }
        finally
        {
            Microsoft.Dynamics.Application.Instrumentation.ApplicationEventSource::EventWriteTrvExpenseReportSubmitStop(TrvExpTable::getNumberOfNonItemizationExpenseLines(this.parmEntity().RecId), TrvExpTable::getNumberOfItemizedExpenseLines(this.parmEntity().RecId), success);
        }

        return success;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashAdvancesMappingsByAccountingEvent</Name>
				<Source><![CDATA[
    public static Map cashAdvancesMappingsByAccountingEvent(AccountingEventRecId _accountingEventRecId)
    {
        Map cashAdvanceMappings = new Map(Types::Int64, Types::Real);

        AccountingDistribution accountingDistributionLocal;
        TrvExpTrans trvExpTransLocal;
        TrvExpCashAdvanceMapping trvExpCashAdvanceMapping;
        TrvCashAdvance trvCashAdvance;

        while select trvExpTransLocal
            join  trvExpCashAdvanceMapping
            where trvExpCashAdvanceMapping.ExpLineRecId == trvExpTransLocal.RecId
                join  trvCashAdvance
                where trvCashAdvance.RecId == trvExpCashAdvanceMapping.CashAdvanceRecId
            exists join accountingDistributionLocal
            where accountingDistributionLocal.SourceDocumentLine == trvExpTransLocal.SourceDocumentLine
               && accountingDistributionLocal.AccountingEvent == _accountingEventRecId
        {
            LedgerDimensionAccount ledgerDimensionAccount = trvCashAdvance.ledgerDimensionAccount();

            if (cashAdvanceMappings.exists(trvCashAdvance.ledgerDimensionAccount()))
            {
                cashAdvanceMappings.insert(
                    trvCashAdvance.ledgerDimensionAccount(),
                    cashAdvanceMappings.lookup(trvCashAdvance.ledgerDimensionAccount()) + trvExpCashAdvanceMapping.AmountMST);
            }
            else
            {
                cashAdvanceMappings.insert(
                    trvCashAdvance.ledgerDimensionAccount(),
                    trvExpCashAdvanceMapping.AmountMST);
            }
        }

        return cashAdvanceMappings;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTempRecord</Name>
				<Source><![CDATA[
    public static SubledgerJournalAccountEntryTmpSummary  insertTempRecord(
        SubledgerJournalAccountEntryTmpSummary _tmpSummary,
        AmountMST _accountingCurrencyAmount,
        LedgerDimensionAccount _ledgerDimensionAccount)
    {
        SubledgerJournalAccountEntryTmpSummary _tmpSummaryToInsert;
        _accountingCurrencyAmount = _tmpSummary.AccountingCurrencyAmount < 0 ? -1 * _accountingCurrencyAmount : _accountingCurrencyAmount;

        AmountCur transactionCurrencyAmount = CurrencyExchangeHelper::curAmount(
            _accountingCurrencyAmount,
            _tmpSummary.TransactionCurrencyCode,
            _tmpSummary.AccountingDate,
            UnknownNoYes::Unknown,
            _tmpSummary.ExchangeRate1);

        AmountCur reportingCurrencyAmount = CurrencyExchangeHelper::curAmount(
            _accountingCurrencyAmount,
            _tmpSummary.ReportingCurrency,
            _tmpSummary.AccountingDate,
            UnknownNoYes::Unknown,
            _tmpSummary.ReportingExchangeRate1);

        _tmpSummaryToInsert.linkPhysicalTableInstance(_tmpSummary);
        _tmpSummaryToInsert.clear();
        _tmpSummaryToInsert.data(_tmpSummary);
        _tmpSummaryToInsert.RecId = 0;
        _tmpSummaryToInsert.AccountingCurrencyAmount = _accountingCurrencyAmount;
        _tmpSummaryToInsert.AccountingCurrencyAmountUnrounded = _accountingCurrencyAmount;
        _tmpSummaryToInsert.TransactionCurrencyAmount = transactionCurrencyAmount;
        _tmpSummaryToInsert.ReportingCurrencyAmount = reportingCurrencyAmount;
        _tmpSummaryToInsert.ReportingCurrencyAmountUnrounded = reportingCurrencyAmount;
        _tmpSummaryToInsert.IsCorrection = NoYes::Yes;
        _tmpSummaryToInsert.LedgerDimension =
            LedgerDimensionFacade::ServiceCreateLedgerDimension(_ledgerDimensionAccount,
            LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_tmpSummaryToInsert.LedgerDimension));

        return _tmpSummaryToInsert;
    }

]]></Source>
			</Method>
			<Method>
				<Name>SubledgerJournalizer_summarizedJournalAccountEntryDetail</Name>
				<Source><![CDATA[
    /// <summary>
    ///
    /// </summary>
    /// <param name="_tmpDetail"></param>
    /// <param name="_tmpSummary"></param>
    /// <param name="_accountingEventState"></param>
    [SubscribesTo(classStr(SubledgerJournalizer), delegateStr(SubledgerJournalizer, summarizedJournalAccountEntryDetail))]
    public static void SubledgerJournalizer_summarizedJournalAccountEntryDetail(SubledgerJournalAccountEntryTmpDetail _tmpDetail, SubledgerJournalAccountEntryTmpSummary _tmpSummary, AccountingEventState _accountingEventState)
    {
        AccountingEvent accountingEvent;
        select firstonly _tmpDetail exists join accountingEvent where accountingEvent.RecId == _tmpDetail.AccountingEvent;
        AccountingEvent accountingEventObj = AccountingEvent::find(_tmpDetail.AccountingEvent);
        SourceDocumentHeader sourceDocumentHeader = SourceDocumentHeader::find(accountingEventObj.SourceDocumentHeader);
        if (sourceDocumentHeader.TypeEnumName == enumStr(SourceDocument_ExpenseReport)
            && TrvExpenseHelper::isTrvApplyCashAdvanceMappingFlightEnabled())
        {
            boolean requiredInsert;
            AmountCur totalVendBalanceAmountCur;
            AmountCur totalVendBalanceAmountMst;
            AmountCur totalCashAdvanceToApplyMst;
            AmountCur totalCashAdvanceToApplyReporting;

            ttsbegin;
            Set accountingEvents = new Set(Types::Int64);
            SubledgerJournalAccountEntryTmpSummary _tmpSummaryToInsert;

            RecordInsertList subledgerEntries = new RecordInsertList(
                tableNum(SubledgerJournalAccountEntryTmpSummary),
                false,
                false,
                false,
                false,
                false,
                _tmpSummary);

            Map cashAdvanceMapping = TrvSubmitExpenseReportToWorkflow::cashAdvancesMappingsByAccountingEvent(_tmpDetail.AccountingEvent);

            if (cashAdvanceMapping.elements() > 0)
            {
                while select forUpdate _tmpSummary
                    where _tmpSummary.PostingType == LedgerPostingType::VendBalance
                    || _tmpSummary.PostingType == LedgerPostingType::CustBalance
                    || _tmpSummary.PostingType == LedgerPostingType::Bank
                {
                    AmountMST summaryAmountRemainingMst = abs(_tmpSummary.AccountingCurrencyAmount);
                    AmountMST summaryAmountRemainingCur = abs(_tmpSummary.AccountingCurrencyAmount);
                    AmountMST summaryAmountRemainingReporting = abs(_tmpSummary.AccountingCurrencyAmount);

                    MapIterator mapIterator = new MapIterator(cashAdvanceMapping);

                    while (mapIterator.more())
                    {
                        AmountMST currenctCashAdvanceAmountMST = mapIterator.value();
                        LedgerDimensionAccount cashAdvanceLedgerDimension = mapIterator.key();

                        if (currenctCashAdvanceAmountMST == 0)
                        {
                            continue;
                        }

                        if (currenctCashAdvanceAmountMST < summaryAmountRemainingMst)
                        {
                            SubledgerJournalAccountEntryTmpSummary tmpToBeInserted = TrvSubmitExpenseReportToWorkflow::insertTempRecord(_tmpSummary, currenctCashAdvanceAmountMST, cashAdvanceLedgerDimension);
                            subledgerEntries.add(tmpToBeInserted);
                            summaryAmountRemainingMst -= abs(tmpToBeInserted.AccountingCurrencyAmount);
                            summaryAmountRemainingCur -= abs(tmpToBeInserted.TransactionCurrencyAmount);
                            summaryAmountRemainingReporting -= abs(tmpToBeInserted.ReportingCurrencyAmount);
                            cashAdvanceMapping.insert(cashAdvanceLedgerDimension, 0);
                        }
                        else if (currenctCashAdvanceAmountMST >= summaryAmountRemainingMst)
                        {
                            SubledgerJournalAccountEntryTmpSummary tmpToBeInserted = TrvSubmitExpenseReportToWorkflow::insertTempRecord(_tmpSummary, summaryAmountRemainingMst, cashAdvanceLedgerDimension);
                            subledgerEntries.add(tmpToBeInserted);
                            summaryAmountRemainingMst -= abs(tmpToBeInserted.AccountingCurrencyAmount);
                            summaryAmountRemainingCur -= abs(tmpToBeInserted.TransactionCurrencyAmount);
                            summaryAmountRemainingReporting -= abs(tmpToBeInserted.ReportingCurrencyAmount);
                            if (summaryAmountRemainingMst > 0)
                                cashAdvanceMapping.insert(cashAdvanceLedgerDimension, currenctCashAdvanceAmountMST - tmpToBeInserted.AccountingCurrencyAmount);
                            break;
                        }

                        mapIterator.next();
                    }

                    if (summaryAmountRemainingMst == 0)
                    {
                        _tmpSummary.delete();
                    }
                    else
                    {
                        _tmpSummary.AccountingCurrencyAmount = _tmpSummary.AccountingCurrencyAmount < 0 ? -1 * summaryAmountRemainingMst : summaryAmountRemainingMst;
                        _tmpSummary.AccountingCurrencyAmountUnrounded = _tmpSummary.AccountingCurrencyAmountUnrounded < 0 ? -1 * summaryAmountRemainingMst : summaryAmountRemainingMst;
                        _tmpSummary.TransactionCurrencyAmount = _tmpSummary.AccountingCurrencyAmount < 0 ? -1 * summaryAmountRemainingCur : summaryAmountRemainingCur;
                        _tmpSummary.ReportingCurrencyAmount = _tmpSummary.AccountingCurrencyAmount < 0 ? -1 * summaryAmountRemainingReporting : summaryAmountRemainingReporting;
                        _tmpSummary.ReportingCurrencyAmountUnrounded = _tmpSummary.AccountingCurrencyAmount < 0 ? -1 * summaryAmountRemainingReporting : summaryAmountRemainingReporting;
                        _tmpSummary.update();
                    }
                }
            }

            subledgerEntries.insertDatabase();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateAccountingDistribution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Evaluates if accounting distributions should be updated on submit or not.
    /// </summary>
    /// <returns>
    /// true if accounting distributions should be updated; otherwise, false.
    /// </returns>
    protected static boolean shouldUpdateAccountingDistribution()
    {
        return !TrvApplyCashAdvanceMappingFlight::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleDistributionsForCashAdvance</Name>
				<Source><![CDATA[
    /// <summary>
    /// When expense report has lines with cash as payment method or lines with return cash type,
    /// updating/splitting the accounting distribution records will be handled by this method.
    /// </summary>
    /// <param name = "_trvExpTable">The report being submitted.</param>
    public static void handleDistributionsForCashAdvance(TrvExpTable _trvExpTable)
    {
        TrvSubmitAccDistribution        trvSubmitAccDistribution;
        TrvCashAdvance                  trvCashAdvance;
        TrvPartyEmployeeRelationship    trvEmpSetup;

        //Handle distribution during posting only
        if (TrvSubmitExpenseReportToWorkflow::skipCashAdvanceDistributionMapping(_trvExpTable))
        {
            return;
        }

        // Insert records in TrvAccountingDistribution for expense lines of return cash category type
        TrvSubmitExpenseReportToWorkflow::updateTrvDistributionsForCashAdvance(_trvExpTable);
        
        // Calculate accounting distributions split as per available Cash advances then update/insert accounting distributions in sync to the split
        // Consider only the cash advances which are >= 1 to avoid having distributions with zero amounts due to rounding off issues
        select firstonly RecId from trvCashAdvance
                where trvCashAdvance.RequestingWorker == _trvExpTable.CreatingWorker
                   && trvCashAdvance.BalanceMST >= 1;

        if (trvCashAdvance.RecId != 0)
        {
            select RecId from trvSubmitAccDistribution
                    where trvSubmitAccDistribution.SourceDocumentHeader == _trvExpTable.SourceDocumentHeader;
            if (trvSubmitAccDistribution.RecId || _trvExpTable.hasCashAdvanceReturnLine())
            {
                trvEmpSetup = TrvPartyEmployeeRelationship::find(_trvExpTable.CreatingWorker);
                if (trvEmpSetup.AccountType == LedgerJournalACType::Vend || trvEmpSetup.AccountType == LedgerJournalACType::Ledger)
                {
                    TrvSubmitExpenseReportToWorkflow::splitAccountingDistributions(_trvExpTable);
                    TrvSubmitExpenseReportToWorkflow::syncTrvAccountingDistribution(_trvExpTable);
                    TrvSubmitExpenseReportToWorkflow::updateAccountingDistributions(_trvExpTable);
                    TrvSubmitExpenseReportToWorkflow::updateAccountingDistributionsAllocFactor(_trvExpTable);
                    TrvSubmitExpenseReportToWorkflow::updateProjAccountingDistributions(_trvExpTable);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipCashAdvanceDistributionMapping</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies whether expense report is in approved state or expense has lines with cash as payment method, lines with return cash type
    /// and the approval status of lines will be checked by this method.
    /// </summary>
    /// <param name = "_trvExpTable">The report being submitted.</param>
    /// <returns>True, if cash advance mapping creation is not needed; otherwise, false.</returns>
    public static boolean skipCashAdvanceDistributionMapping(TrvExpTable _trvExpTable)
    {
        TrvExpTrans trvExpTrans;
        TrvCostType trvCostType;
        TrvCashAdvance trvCashAdvance;

        boolean ret = true;

        boolean isCashAdvanceFeatureEnabled = TrvExpCashAdvanceMappingHelper::isCashAdvanceMappingFeatureEnabled();
        
        if (!isCashAdvanceFeatureEnabled)
        {
            select firstonly RecId, ExpType from trvExpTrans
                where trvExpTrans.TrvExpTable == _trvExpTable.RecId
                    && trvExpTrans.ExpNumber == _trvExpTable.ExpNumber
                    && trvExpTrans.ApprovalStatus == TrvAppStatus::Approved
                exists join CostType, StdPaiMethod from trvCostType
                    where trvExpTrans.CostType == trvCostType.CostType
                        && trvExpTrans.PayMethod == trvCostType.StdPaiMethod
                exists join RequestingWorker, BalanceMST from trvCashAdvance
                    where trvCashAdvance.RequestingWorker == _trvExpTable.CreatingWorker
                        && trvCashAdvance.BalanceMST > 0;

            if (_trvExpTable.ApprovalStatus == TrvAppStatus::Approved || trvExpTrans.RecId)
            {
                ret = false;
            }
        }

        return ret;

    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTrvDistributionsForCashAdvance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert Trv accounting distributions for all the expense lines of return cash/advance type.
    /// </summary>
    /// <param name="_trvExpTable">
    /// The current <c>TrvExpTable</c> record.
    /// </param>
    /// <remarks>
    /// The Trv accounting distributions are inserted for all the expense lines of return cash/advance type.
    /// </remarks>
    private static void updateTrvDistributionsForCashAdvance(TrvExpTable _trvExpTable)
    {
        TrvAccountingDistribution   trvAccountingDistribution;
        AccountingDistribution      accountingDistribution;
        TrvExpTrans                 trvExpTrans;
        TrvCashAdvance              trvCashAdvance;
        RecordInsertList            trvAccountingCashAdvanceInsertList;

        trvAccountingCashAdvanceInsertList = new RecordInsertList(tableNum(TrvAccountingDistribution));

        ttsbegin;
        // Insert records into TrvAccountingDisitribution for all expense lines that are of ReturnCash category type
        while select RecId, TransactionCurrencyAmount, SourceDocumentHeader, SourceDocumentLine, TransactionCurrency from accountingDistribution
            where accountingDistribution.SourceDocumentHeader == _trvExpTable.SourceDocumentHeader
                join AmountCurr, AmountMST, CashAdvanceRecId from trvExpTrans
                    where trvExpTrans.SourceDocumentLine == accountingDistribution.SourceDocumentLine
                join CurrencyCode, RecId from trvCashAdvance
                    where trvCashAdvance.RecId == trvExpTrans.CashAdvanceRecId
        {
            trvAccountingDistribution.AccountingDistribution = accountingDistribution.RecId;
            trvAccountingDistribution.AdvanceAmountMST = ((accountingDistribution.TransactionCurrencyAmount / trvExpTrans.AmountCurr) * trvExpTrans.AmountMST);
            trvAccountingDistribution.AdvanceAmount = accountingDistribution.TransactionCurrencyAmount;
            trvAccountingDistribution.AdvanceCurrencyCode = trvCashAdvance.CurrencyCode;
            trvAccountingDistribution.CashAdvance = trvCashAdvance.RecId;
            trvAccountingDistribution.FullySplit = NoYes::Yes;
            trvAccountingDistribution.EqualToDistribution = NoYes::Yes;
            trvAccountingCashAdvanceInsertList.add(trvAccountingDistribution);
        }
        trvAccountingCashAdvanceInsertList.insertDatabase();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitAccountingDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Split the accounting distributions according to comparisions against available cash advances.
    /// </summary>
    /// <param name="_trvExpTable">
    /// The current <c>TrvExpTable</c> record.
    /// </param>
    /// <remarks>
    /// The accounting distributions are split and related information is stored in the <c>TrvAccountingDistribution</c> table.
    /// </remarks>
    public static void splitAccountingDistributions(TrvExpTable _trvExpTable)
    {
        TrvCashAdvance                      trvCashAdvanceVerify;
        TrvSubmitAccDistribution            accountingDistributionExpense;
        TrvTaxUncommittedDistributionView   taxUnCommittedDistribution;
        AmountCur                           totalBalance = 0;

        select sum(BalanceMST) from trvCashAdvanceVerify
            where trvCashAdvanceVerify.RequestingWorker == _trvExpTable.CreatingWorker
            && trvCashAdvanceVerify.BalanceMST > 0
            && trvCashAdvanceVerify.CashAdvanceStatus == TrvWorkflowCashAdvanceStatus::Paid;

        totalBalance =  trvCashAdvanceVerify.BalanceMST;

        ttsbegin;

        // Insert expense related records in TrvAccountingDistribution for those expense lines where expense line amount is more
        // than total cash advance balance available.
        select firstonly RecId, TransactionCurrencyAmount, TransactionCurrencyAmountMST from accountingDistributionExpense
            where accountingDistributionExpense.SourceDocumentHeader == _trvExpTable.SourceDocumentHeader
            && accountingDistributionExpense.TransactionCurrencyAmountMST >= totalBalance;

        if (accountingDistributionExpense.RecId)
        {
            TrvSubmitExpenseReportToWorkflow::insertTrvDistForExpAmountMoreThanCashAdv( accountingDistributionExpense.RecId,
                                                                                        accountingDistributionExpense.TransactionCurrencyAmount,
                                                                                        accountingDistributionExpense.TransactionCurrencyAmountMST);
            totalBalance = 0.0;
        }

        // Insert tax related records in TrvAccountingDistribution for those expense lines where expense line amount is more
        // than total cash advance balance available.
        select firstonly RecId, TransactionCurrencyAmount, TransactionCurrencyAmountMST from taxUnCommittedDistribution
            where taxUnCommittedDistribution.SourceDocumentHeader == _trvExpTable.SourceDocumentHeader
            && taxUnCommittedDistribution.TransactionCurrencyAmountMST >= totalBalance;

        if (taxUnCommittedDistribution.RecId)
        {
            TrvSubmitExpenseReportToWorkflow::insertTrvDistForExpAmountMoreThanCashAdv( taxUnCommittedDistribution.RecId,
                                                                                        taxUnCommittedDistribution.TransactionCurrencyAmount,
                                                                                        taxUnCommittedDistribution.TransactionCurrencyAmountMST);
            totalBalance = 0.0;
        }

        // Insert related records in TrvAccountingDistribution for those expense lines where expense line amount is less than
        // total cash advance balance available.
        if (totalBalance >= 1)
        {
            TrvSubmitExpenseReportToWorkflow::insertTrvDistForExpAmountLessThanCashAdv(_trvExpTable);
        }

        // Consume the left out cash advances
        TrvSubmitExpenseReportToWorkflow::insertTrvDistForLeftOutCashAdvances(_trvExpTable);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncTrvAccountingDistribution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sync <c>TrvAccountingDistribution</c> table with available accounting distributions.
    /// </summary>
    /// <param name="_trvExpTable">
    /// The current <c>TrvExpTable</c> record.
    /// </param>
    /// <remarks>
    /// Updates the  <c>TrvAccountingDistribution</c> table with the accounting distributions.
    /// </remarks>
    public static void syncTrvAccountingDistribution(TrvExpTable _trvExpTable)
    {
        TrvSubmitAccDistribution            accountingDistribution;
        TrvTaxUncommittedDistributionView   trvTaxUncommittedDistributionView;
        TrvAccountingDistribution           trvAccountingDistribution;
        RefRecId                            distributionRelatedRecId = 0;
        AmountCur                           distributionTransactionCurrencyAmount = 0;

        ttsbegin;

        while select AccountingDistribution from trvAccountingDistribution
            join RecId, TransactionCurrencyAmount from accountingDistribution
                where accountingDistribution.RecId == trvAccountingDistribution.AccountingDistribution
                && accountingDistribution.SourceDocumentHeader == _trvExptable.SourceDocumentHeader
        {
            TrvSubmitExpenseReportToWorkflow::updateEqualToDistributionForTrvDist(  accountingDistribution.RecId,
                                                                                    accountingDistribution.TransactionCurrencyAmount);
        }

        trvAccountingDistribution.clear();
        while select AccountingDistribution from trvAccountingDistribution
            join RecId, TransactionCurrencyAmount from trvTaxUncommittedDistributionView
                where trvTaxUncommittedDistributionView.RecId == trvAccountingDistribution.AccountingDistribution
                && trvTaxUncommittedDistributionView.SourceDocumentHeader == _trvExptable.SourceDocumentHeader
        {
            TrvSubmitExpenseReportToWorkflow::updateEqualToDistributionForTrvDist(  trvTaxUncommittedDistributionView.RecId,
                                                                                    trvTaxUncommittedDistributionView.TransactionCurrencyAmount);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAccountingDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert/Update accounting distributions in sync to trv accounting distributions split.
    /// </summary>
    /// <param name="_trvExpTable">
    /// The current <c>TrvExpTable</c> record.
    /// </param>
    /// <remarks>
    /// The accounting distributions are updated/inserted based on trv accounting distributions split.
    /// </remarks>
    public static void updateAccountingDistributions(TrvExpTable _trvExpTable)
    {
        AccountingDistribution      accountingDistribution;
        AccountingDistribution      accountingDistributionUpdate;
        AccountingDistribution      accountingDistributionInsert;
        AccountingDistribution      accountingDistributionVerify;
        AccountingDistribution      accountingDistributionSum;
        AccountingDistribution      accountingDistributionTrv;
        AccountingDistribution      accountingDistributionNumber;
        AccountingDistribution      accountingDistributionMaxNumber;
        AccountingDistribution      accountingDistributionTax;
        AccountingDistribution      accountingDistributionParent;
        TrvAccountingDistribution   trvAccountingDistribution;
        TrvAccountingDistribution   trvAccountingDistributionUpdate;
        TrvExpTrans                 trvExpTransTax;
        container                   accountingRecIds;
        str                         sourceDocLineEncode;
        int64                       sourceDocRecId;
        int64                       trvAccRecId;
        List                        sourceDocDetails;
        List                        accountingRecIdList;
        int                         sourceDocNum;
        Map                         sourceDocLineMap;
        Map                         referenceAccDistributionMap;
        Map                         sourceDocumentLineMap;
        Map                         accountingDistributionsMap;
        MapEnumerator               referenceEnumerator;
        ListEnumerator              sourceDocEnumerator;
        ListEnumerator              accountingListEnumerator;
        RecordInsertList            accountingSplitRecordInsertList;
        RecordInsertList            accountingDeficitRecordInsertList;

        if (!TrvSubmitExpenseReportToWorkflow::shouldUpdateAccountingDistribution())
        {
            return;
        }

        sourceDocLineMap = new Map(Types::Int64, Types::Integer);
        referenceAccDistributionMap = new Map(Types::Int64, Types::String);
        sourceDocDetails = new List(Types::String);
        sourceDocumentLineMap = new Map(Types::Int64, Types::Integer);
        accountingDistributionsMap = new Map(Types::Int64, Types::Real);

        accountingRecIdList = new List(Types::Int64);
        accountingSplitRecordInsertList = new RecordInsertList(tableNum(AccountingDistribution));
        accountingDeficitRecordInsertList = new RecordInsertList(tableNum(AccountingDistribution));

        ttsbegin;

        while select AccountingDistribution, AdvanceAmount from trvAccountingDistribution
            where trvAccountingDistribution.EqualToDistribution == NoYes::Yes
            join accountingDistribution
                where accountingDistribution.RecId == trvAccountingDistribution.AccountingDistribution
                && accountingDistribution.SourceDocumentHeader == _trvExpTable.SourceDocumentHeader
        {
            // Update existing accounting distribution record first
            if (!conFind(accountingRecIds, accountingDistribution.RecId))
            {
                accountingDistributionsMap.insert(accountingDistribution.RecId, accountingDistribution.TransactionCurrencyAmount);
                select forupdate accountingDistributionUpdate
                    where accountingDistributionUpdate.RecId == accountingDistribution.RecId;
                accountingDistributionUpdate.TransactionCurrencyAmount = trvAccountingDistribution.AdvanceAmount;
                accountingDistributionUpdate.update();
                accountingRecIds += [accountingDistribution.RecId];
            }
            else
            {
                // Insert new accounting distributions for the split amounts
                if (!sourceDocLineMap.exists(accountingDistribution.SourceDocumentLine))
                {
                    sourceDocLineMap.insert(accountingDistribution.SourceDocumentLine, accountingDistribution.Number);
                }
                accountingDistributionInsert.AccountingDate = accountingDistribution.AccountingDate;
                accountingDistributionInsert.AccountingEvent = accountingDistribution.AccountingEvent;
                accountingDistributionInsert.AccountingLegalEntity = accountingDistribution.AccountingLegalEntity;
                accountingDistributionInsert.AllocationFactor = accountingDistribution.AllocationFactor;
                accountingDistributionInsert.AmountSource = accountingDistribution.AmountSource;
                accountingDistributionInsert.FinalizeAccountingEvent = accountingDistribution.FinalizeAccountingEvent;
                accountingDistributionInsert.LedgerDimension = accountingDistribution.LedgerDimension;
                accountingDistributionInsert.MonetaryAmount = accountingDistribution.MonetaryAmount;
                if (sourceDocLineMap.exists(accountingDistribution.SourceDocumentLine))
                {
                    accountingDistributionInsert.Number = sourceDocLineMap.lookup(accountingDistribution.SourceDocumentLine) + 1;

                    // For cases where distributions are already done before submit
                    select accountingDistributionNumber
                        where accountingDistributionNumber.SourceDocumentHeader == accountingDistribution.SourceDocumentHeader
                           && accountingDistributionNumber.SourceDocumentLine == accountingDistribution.SourceDocumentLine
                           && accountingDistributionNumber.Number == accountingDistributionInsert.Number;
                    if (accountingDistributionNumber.RecId)
                    {
                        select maxof(Number) from accountingDistributionMaxNumber
                            where accountingDistributionMaxNumber.SourceDocumentHeader == accountingDistribution.SourceDocumentHeader
                               && accountingDistributionMaxNumber.SourceDocumentLine == accountingDistribution.SourceDocumentLine;
                        accountingDistributionInsert.Number = accountingDistributionMaxNumber.Number + 1;
                    }

                    sourceDocLineMap.insert(accountingDistribution.SourceDocumentLine, accountingDistributionInsert.Number);
                }
                else
                {
                    accountingDistributionInsert.Number = accountingDistribution.Number;
                }

                if (accountingDistributionInsert.MonetaryAmount != MonetaryAmount::Tax)
                {
                    accountingDistributionInsert.ParentDistribution = accountingDistribution.RecId;
                }
                else
                {
                    accountingDistributionInsert.ParentDistribution = accountingDistribution.ParentDistribution;
                }

                accountingDistributionInsert.ReferenceDistribution = accountingDistribution.ReferenceDistribution;
                accountingDistributionInsert.ReferenceRole = accountingDistribution.ReferenceRole;
                accountingDistributionInsert.SourceDocumentHeader = accountingDistribution.SourceDocumentHeader;
                accountingDistributionInsert.SourceDocumentLine = accountingDistribution.SourceDocumentLine;
                accountingDistributionInsert.TransactionCurrency = accountingDistribution.TransactionCurrency;
                accountingDistributionInsert.TransactionCurrencyAmount = trvAccountingDistribution.AdvanceAmount;
                accountingSplitRecordInsertList.add(accountingDistributionInsert);

                sourceDocLineEncode = strFmt("%1%2%3", int642str(accountingDistributionInsert.SourceDocumentLine), '&', int642str(accountingDistributionInsert.Number));
                referenceAccDistributionMap.insert(trvAccountingDistribution.RecId, sourceDocLineEncode);
            }
        }
        accountingSplitRecordInsertList.insertDatabase();

        // Update trvAccountingDistribution table with new accounting distribution recids
        referenceEnumerator = referenceAccDistributionMap.getEnumerator();

        while (referenceEnumerator.moveNext())
        {
            trvAccRecId = referenceEnumerator.currentKey();
            sourceDocDetails = strSplit(referenceEnumerator.currentValue(), '&');
            sourceDocEnumerator = sourceDocDetails.getEnumerator();
            sourceDocEnumerator.reset();
            sourceDocEnumerator.moveNext();
            sourceDocRecId = str2int64(sourceDocEnumerator.current());
            sourceDocEnumerator.moveNext();
            sourceDocNum = str2int(sourceDocEnumerator.current());

            select RecId from accountingDistributionTrv
                where accountingDistributionTrv.SourceDocumentLine == sourceDocRecId
                && accountingDistributionTrv.Number == sourceDocNum;

            select forupdate trvAccountingDistributionUpdate
                where trvAccountingDistributionUpdate.RecId == trvAccRecId;

            trvAccountingDistributionUpdate.ReferenceAccountingDistribution = accountingDistributionTrv.RecId;
            trvAccountingDistributionUpdate.update();
        }

        ttscommit;

        // Insert new accounting distributions if existing distribution is updated to split amount leaving a deficit in expense amount.
        accountingDistributionMaxNumber.clear();
        ttsbegin;

        accountingRecIdList = Global::con2List(accountingRecIds);
        accountingListEnumerator =accountingRecIdList.getEnumerator();

        while (accountingListEnumerator.moveNext())
        {
            select sum(TransactionCurrencyAmount) from accountingDistributionSum
                where accountingDistributionSum.ParentDistribution == accountingListEnumerator.current()
                    || accountingDistributionSum.RecId == accountingListEnumerator.current();
                    
            // Calculate tax related distribution amount for the given accounting distribution record.
            select sum(TransactionCurrencyAmount) from accountingDistributionTax
                where accountingDistributionTax.ParentDistribution == accountingListEnumerator.current()
                && (accountingDistributionTax.MonetaryAmount == MonetaryAmount::Tax || accountingDistributionTax.MonetaryAmount == MonetaryAmount::TaxNonRecoverable);

            accountingDistributionSum.TransactionCurrencyAmount -= accountingDistributionTax.TransactionCurrencyAmount;

            if (accountingDistributionSum.TransactionCurrencyAmount < accountingDistributionsMap.lookup(accountingListEnumerator.current()))
            {
                select firstonly accountingDistributionVerify
                    where accountingDistributionVerify.RecId == accountingListEnumerator.current();

                accountingDistributionInsert.AccountingDate = accountingDistributionVerify.AccountingDate;
                accountingDistributionInsert.AccountingEvent = accountingDistributionVerify.AccountingEvent;
                accountingDistributionInsert.AccountingLegalEntity = accountingDistributionVerify.AccountingLegalEntity;
                accountingDistributionInsert.AllocationFactor = accountingDistributionVerify.AllocationFactor;
                accountingDistributionInsert.AmountSource = accountingDistributionVerify.AmountSource;
                accountingDistributionInsert.FinalizeAccountingEvent = accountingDistributionVerify.FinalizeAccountingEvent;
                accountingDistributionInsert.LedgerDimension = accountingDistributionVerify.LedgerDimension;
                accountingDistributionInsert.MonetaryAmount = accountingDistributionVerify.MonetaryAmount;

                select maxof(Number) from accountingDistributionMaxNumber
                    where accountingDistributionMaxNumber.SourceDocumentHeader == accountingDistributionVerify.SourceDocumentHeader
                        && accountingDistributionMaxNumber.SourceDocumentLine == accountingDistributionVerify.SourceDocumentLine;

                accountingDistributionInsert.Number = accountingDistributionMaxNumber.Number + 1;

                if (accountingDistributionInsert.MonetaryAmount != MonetaryAmount::Tax)
                {
                    accountingDistributionInsert.ParentDistribution = accountingDistributionVerify.RecId;
                }
                else
                {
                    accountingDistributionInsert.ParentDistribution = accountingDistributionVerify.ParentDistribution;
                }
                accountingDistributionInsert.ReferenceDistribution = accountingDistributionVerify.ReferenceDistribution;
                accountingDistributionInsert.ReferenceRole = accountingDistributionVerify.ReferenceRole;
                accountingDistributionInsert.SourceDocumentHeader = accountingDistributionVerify.SourceDocumentHeader;
                accountingDistributionInsert.SourceDocumentLine = accountingDistributionVerify.SourceDocumentLine;
                accountingDistributionInsert.TransactionCurrency = accountingDistributionVerify.TransactionCurrency;
                accountingDistributionInsert.TransactionCurrencyAmount = accountingDistributionsMap.lookup(accountingListEnumerator.current()) - accountingDistributionSum.TransactionCurrencyAmount;
                accountingDeficitRecordInsertList.add(accountingDistributionInsert);
            }
        }

        accountingDeficitRecordInsertList.insertDatabase();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAccountingDistributionsAllocFactor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update accounting distributions allocatin factor in sync to accounting distributions split.
    /// </summary>
    /// <param name="_trvExpTable">
    /// The current <c>TrvExpTable</c> record.
    /// </param>
    /// <remarks>
    /// The accounting distributions allocation factor is updated based on accounting distributions split.
    /// </remarks>
    public static void updateAccountingDistributionsAllocFactor(TrvExpTable  _trvExpTable)
    {
        AccountingDistribution      accountingDistributionAllocationFactor;
        TrvExpTrans                 trvExpTransAllocation;
        TaxUncommitted              taxUncommitted;

        if (!TrvSubmitExpenseReportToWorkflow::shouldUpdateAccountingDistribution())
        {
            return;
        }
        
        ttsBegin;

        // Update allocation factor for expense line distributions
        _trvExpTable.updateDistributionAllocation();        

        // Update allocation factor for expense line related tax distributions
        update_recordset accountingDistributionAllocationFactor
                setting AllocationFactor = (accountingDistributionAllocationFactor.TransactionCurrencyAmount / taxUncommitted.TaxAmountCur)
                    where accountingDistributionAllocationFactor.SourceDocumentHeader == _trvExpTable.SourceDocumentHeader
            join TaxAmountCur, SourceDocumentLine from taxUncommitted
                where taxUncommitted.SourceDocumentLine == accountingDistributionAllocationFactor.SourceDocumentLine
                    && taxUncommitted.TaxAmountCur != 0;

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjAccountingDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert/Update project accounting distributions in sync to accounting distributions split.
    /// </summary>
    /// <param name="_trvExpTable">
    /// The current <c>TrvExpTable</c> record.
    /// </param>
    /// <remarks>
    /// The project accounting distributions are updated/inserted based on accounting distributions split.
    /// </remarks>
    public static void updateProjAccountingDistributions(TrvExpTable _trvExpTable)
    {
        ProjectAccountingDistribution   projAccountingDistribution;
        ProjectAccountingDistribution   projAccountingDistributionInsert;
        ProjectAccountingDistribution   projAccountingDistributionUpdate;
        ProjectAccountingDistribution   projAccountingDistributionAmount;
        AccountingDistribution          accountingDistribution;
        AccountingDistribution          accountingDistributionRelated;
        AccountingDistribution          accountingDistributionTransactionAmount;
        RecordInsertList                projAccountingInsertList;
        AmountCur                       originalCurrencyAmount;
        PriceCur                        originalCurrencyPrice;
        AmountCur                       totalTransactionCurrencyAmount;

        if (!TrvSubmitExpenseReportToWorkflow::shouldUpdateAccountingDistribution())
        {
            return;
        }
        
        projAccountingInsertList = new RecordInsertList(tableNum(ProjectAccountingDistribution));
        ttsbegin;

        while select projAccountingDistribution
            join TransactionCurrencyAmount, AllocationFactor, RecId from accountingDistribution
                where accountingDistribution.RecId == projAccountingDistribution.AccountingDistribution
                   && accountingDistribution.SourceDocumentHeader == _trvExpTable.SourceDocumentHeader
                   && accountingDistribution.AllocationFactor < 1
        {
            // Update existing project distribution with the new distribution amount & price
            select forupdate projAccountingDistributionUpdate
                where projAccountingDistributionUpdate.RecId == projAccountingDistribution.RecId;

            select sum(TransactionCurrencyAmount) from accountingDistributionTransactionAmount
                where accountingDistributionTransactionAmount.ParentDistribution == accountingDistribution.RecId;

            totalTransactionCurrencyAmount = accountingDistribution.TransactionCurrencyAmount + accountingDistributionTransactionAmount.TransactionCurrencyAmount;

            originalCurrencyAmount  = projAccountingDistributionUpdate.TransactionCurrencyAmount;
            originalCurrencyPrice = projAccountingDistributionUpdate.TransactionCurrencyPrice;
            projAccountingDistributionUpdate.TransactionCurrencyAmount = projAccountingDistributionUpdate.TransactionCurrencyAmount * (accountingDistribution.TransactionCurrencyAmount / totalTransactionCurrencyAmount);
            projAccountingDistributionUpdate.update();

            while select RecId, TransactionCurrencyAmount, AllocationFactor from accountingDistributionRelated
                where accountingDistributionRelated.ParentDistribution == accountingDistribution.RecId
            {
                if (ProjectAccountingDistribution::findByAccountingDistribution(accountingDistributionRelated.RecId).RecId == 0)
                {
                    // Create relevant project distribution for the newly splitted distribution
                    projAccountingDistributionInsert.AccountingDistribution = accountingDistributionRelated.RecId;
                    projAccountingDistributionInsert.Currency = projAccountingDistribution.Currency;
                    projAccountingDistributionInsert.ProjCategory = projAccountingDistribution.ProjCategory;
                    projAccountingDistributionInsert.ProjCostTransCost = projAccountingDistribution.ProjCostTransCost;
                    projAccountingDistributionInsert.ProjCostTransSale = projAccountingDistribution.ProjCostTransSale;
                    projAccountingDistributionInsert.ProjEmplTransCost = projAccountingDistribution.ProjEmplTransCost;
                    projAccountingDistributionInsert.ProjEmplTransSale = projAccountingDistribution.ProjEmplTransSale;
                    projAccountingDistributionInsert.ProjItemTransCost = projAccountingDistribution.ProjItemTransCost;
                    projAccountingDistributionInsert.ProjItemTransSale = projAccountingDistribution.ProjItemTransSale;
                    projAccountingDistributionInsert.ProjLineProperty = projAccountingDistribution.ProjLineProperty;
                    projAccountingDistributionInsert.ProjFundingSource = projAccountingDistribution.ProjFundingSource;
                    projAccountingDistributionInsert.ProjRevenueTransSale = projAccountingDistribution.ProjRevenueTransSale;
                    projAccountingDistributionInsert.ProjTable = projAccountingDistribution.ProjTable;
                    projAccountingDistributionInsert.SmmActivities = projAccountingDistribution.SmmActivities;
                    projAccountingDistributionInsert.TaxGroupHeading = projAccountingDistribution.TaxGroupHeading;
                    projAccountingDistributionInsert.TaxItemGroupHeading = projAccountingDistribution.TaxItemGroupHeading;
                    projAccountingDistributionInsert.TransactionCurrencyAmount = originalCurrencyAmount * (accountingDistributionRelated.TransactionCurrencyAmount / totalTransactionCurrencyAmount);
                    projAccountingDistributionInsert.TransactionCurrencyPrice = originalCurrencyPrice;
                    projAccountingInsertList.add(projAccountingDistributionInsert);
                }
                else
                {
                    // Update existing project distribution with the new distribution amount & price
                    select forupdate projAccountingDistributionAmount
                        where projAccountingDistributionAmount.RecId == accountingDistributionRelated.RecId;
                    projAccountingDistributionAmount.TransactionCurrencyAmount = originalCurrencyAmount * (accountingDistributionRelated.TransactionCurrencyAmount / totalTransactionCurrencyAmount);
                    projAccountingDistributionAmount.update();
                }
            }
            projAccountingInsertList.insertDatabase();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateEqualToDistributionForTrvDist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates Equal to distribution field for given distribution and its amount
    /// </summary>
    /// <param name="_accountingDistributionRecId">
    /// Accounting distribution recid
    /// </param>
    /// <param name="_transactionCurrencyAmount">
    /// Accounting distribution transaction currency amount
    /// </param>
    private static void updateEqualToDistributionForTrvDist(RefRecId _accountingDistributionRecId, AmountCur _transactionCurrencyAmount)
    {
        TrvAccountingDistribution           trvAccountingDistributionSum;
        TrvAccountingDistribution           trvAccountingDistributionUpdate;

        ttsBegin;

        select sum(AdvanceAmount) from trvAccountingDistributionSum
            where trvAccountingDistributionSum.AccountingDistribution == _accountingDistributionRecId;

        if (trvAccountingDistributionSum.AdvanceAmount == _transactionCurrencyAmount)
        {
            update_recordSet trvAccountingDistributionUpdate
                setting EqualToDistribution = NoYes::Yes
                    where trvAccountingDistributionUpdate.AccountingDistribution == _accountingDistributionRecId;
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTrvAccountingDistribution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert records into TrvAccountingDistribution table.
    /// </summary>
    /// <param name="_accountingDistributionRecId">
    /// Accounting distribution table record id
    /// </param>
    /// <param name="_advanceCurrencyCode">
    /// Cash advance currency code
    /// </param>
    /// <param name="_advanceAmountMST">
    /// Cash advance amount mst
    /// </param>
    /// <param name="_advanceAmount">
    /// Cash advance amount
    /// </param>
    /// <param name="_cashAdvanceRecId">
    /// Cash advance record id
    /// </param>
    /// <param name="_equalToDistribution">
    /// Amount is equal distribution or not, default value is Yes
    /// </param>
    /// <param name="_referenceAccountingDistributionRecId">
    /// Reference accounting distribution record id, default value is 0
    /// </param>
    /// <param name="_fullySplit">
    /// Distribution fully split, default value is Yes
    /// </param>
    [Hookable(false)]
    public static void insertTrvAccountingDistribution(RefRecId _accountingDistributionRecId,
                                                        TrvCurrencyCode _advanceCurrencyCode,
                                                        AmountMST _advanceAmountMST,
                                                        TrvTransactionCurrencyAmount _advanceAmount,
                                                        RefRecId _cashAdvanceRecId,
                                                        NoYes _equalToDistribution = NoYes::Yes,
                                                        RefRecId _referenceAccountingDistributionRecId = 0,
                                                        NoYes _fullySplit = NoYes::Yes)
    {
        TrvAccountingDistribution       trvAccountingDistributionInsert;

        ttsBegin;

        trvAccountingDistributionInsert.AccountingDistribution = _accountingDistributionRecId;
        trvAccountingDistributionInsert.AdvanceCurrencyCode = _advanceCurrencyCode;
        trvAccountingDistributionInsert.AdvanceAmountMST = _advanceAmountMST;
        trvAccountingDistributionInsert.AdvanceAmount = _advanceAmount;
        trvAccountingDistributionInsert.CashAdvance = _cashAdvanceRecId;
        trvAccountingDistributionInsert.ReferenceAccountingDistribution = _referenceAccountingDistributionRecId;
        trvAccountingDistributionInsert.EqualToDistribution = _equalToDistribution;
        trvAccountingDistributionInsert.FullySplit = _fullySplit;
        trvAccountingDistributionInsert.insert();

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTrvDistForExpAmountLessThanCashAdv</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert records into <c>TrvAccountingDistribution</c> when expense line (distribution) amount is less than available cash advance.
    /// </summary>
    /// <param name="_trvExpTable">
    /// The current <c>TrvExpTable</c> record.
    /// </param>
    private static void insertTrvDistForExpAmountLessThanCashAdv(TrvExpTable _trvExpTable)
    {
        TrvSubmitAccDistribution            trvSubmitAccDistributionView;
        TrvTaxUncommittedDistributionView   trvTaxUncommittedDistributionView;
        TrvAccountingDistribution           trvAccountingDistribution;
        TrvAccountingDistribution           trvAccountingDistributionSum;
        TrvCashAdvance                      trvCashAdvance;
        CurrencyCode                        cashAdvanceCurrencyCode;
        RefRecId                            cashAdvanceOldRecId;
        container                           remainingBalanceContainer;
        AmountMST                           trvAccountingDistributionAmountMST;
        AmountMST                           remainingExpenseLineAmount = 0;
        AmountMST                           remainingAdvanceAmount = 0;
        AmountMST                           cashAdvanceForContainer = 0;
        AmountMST                           cashAdvanceBalanceAmount = 0;
        int                                 numItems, i;

        ttsBegin;

        // Select all cash advances and consume them against each distribution of expense line.
        while select RecId, BalanceMST, CurrencyCode from trvCashAdvance
            order by trvCashAdvance.BalanceMST desc
            where trvCashAdvance.RequestingWorker == _trvExpTable.CreatingWorker
            && trvCashAdvance.CashAdvanceStatus == TrvWorkflowCashAdvanceStatus::Paid
            && trvCashAdvance.BalanceMST > 0
        {
            // The cash advance amount is "reserved" for the expense report at submit time, until that expense report is either posted or 
            // recalled. This link between cash advance records and expense lines is stored in TrvAccountDistribution table. However, the
            // balance amount for this cash advance record is unchanged. That means the "net" balance amount for this cash advance entry  
            // may not be what it is and it may depend on TrvAccountDistribution entries created for previous expense line submit. So, get 
            // sum of the amount in the TrvAccountDistribution records with matching cash advance record id.
            select sum(AdvanceAmountMST) from trvAccountingDistributionSum
                where trvAccountingDistributionSum.CashAdvance == trvCashAdvance.RecId;

            // The actual balance amount available in this cash advance record is balance indicated in the record minus the sum of amount
            // obtained from TrvAccountDistribution records.
            cashAdvanceForContainer = trvCashAdvance.BalanceMST - trvAccountingDistributionSum.AdvanceAmountMST;

            // Proceed with this cash advance entry only if there is any net balance available. Else continue the while loop with next record.
            if (trvAccountingDistributionSum.AdvanceAmountMST < trvCashAdvance.BalanceMST)
            {
                cashAdvanceBalanceAmount = trvCashAdvance.BalanceMST - trvAccountingDistributionSum.AdvanceAmountMST;

                // We might have skipped some cash advance records in previous iterations, because the expense amount was greater 
                // than the available balance. These are saved in "remaining balance container". Obtain those objects and compute 
                // the total balance available.
                numItems =  conLen(remainingBalanceContainer);

                for (i = 1; i <= numItems; i++)
                {
                    [remainingAdvanceAmount, cashAdvanceOldRecId, cashAdvanceCurrencyCode] = conPeek(remainingBalanceContainer, i);
                    cashAdvanceBalanceAmount += remainingAdvanceAmount;
                }

                // Now loop through the TrvSubmitAccDistributionView, which have not been processed already. This can be determined by checking 
                // the existance of matching record in TrvAccountingDistribution.
                while select SourceDocumentHeader, SourceDocumentLine, TransactionCurrencyAmount, TransactionCurrencyAmountMST, RecId from trvSubmitAccDistributionView
                    order by trvSubmitAccDistributionView.TransactionCurrencyAmountMST asc
                    where trvSubmitAccDistributionView.SourceDocumentHeader == _trvExpTable.SourceDocumentHeader
                        notexists join trvAccountingDistribution
                        where trvSubmitAccDistributionView.RecId == trvAccountingDistribution.AccountingDistribution
                        && trvAccountingDistribution.FullySplit == NoYes::Yes
                {
                    // Here we are processing the transactions, for which cash advances have not been consumed yet. 
                    // If the transaction amount is less than the total balance available, we will create entry in TrvAccountingDistribution. 
                    // If the transaction amount is greater than the total balance available, we will save this cash recaord id in a container 
                    // for later use and continue with the next cash advance record.
                    if (trvSubmitAccDistributionView.TransactionCurrencyAmountMST <= cashAdvanceBalanceAmount)
                    {
                        remainingExpenseLineAmount = roundUp(trvSubmitAccDistributionView.TransactionCurrencyAmountMST, 0.01);

                        // Now consume available balances from cash advance containers for this transaction amount.
                        while (remainingExpenseLineAmount > 0)
                        {
                            numItems =  conLen(remainingBalanceContainer);

                            if (numItems == 0)
                            {
                                // No cash advance containers from previous iterations, use the the current cash advance.
                                TrvSubmitExpenseReportToWorkflow::insertTrvAccountingDistribution(  trvSubmitAccDistributionView.RecId,
                                                                                                    trvCashAdvance.CurrencyCode,
                                                                                                    remainingExpenseLineAmount,
                                                                                                    ((trvSubmitAccDistributionView.TransactionCurrencyAmount / roundUp(trvSubmitAccDistributionView.TransactionCurrencyAmountMST, 0.01))
                                                                                                      * remainingExpenseLineAmount),
                                                                                                    trvCashAdvance.RecId,
                                                                                                    NoYes::No, 0, NoYes::Yes);

                                cashAdvanceForContainer = cashAdvanceForContainer - remainingExpenseLineAmount;
                                trvAccountingDistributionAmountMST = remainingExpenseLineAmount;
                                remainingExpenseLineAmount = 0;
                            }
                            else
                            {
                                // Extract the objects from cash advance container.
                                [remainingAdvanceAmount, cashAdvanceOldRecId, cashAdvanceCurrencyCode] = conPeek(remainingBalanceContainer, 1);

                                // If the remaining amount of current transaction is higher than the balance of this cash advance record, 
                                // let's consume remaining amount from this cash advance and delete its record from the container (as it has
                                // no balance left).
                                if (remainingExpenseLineAmount > remainingAdvanceAmount)
                                {
                                    TrvSubmitExpenseReportToWorkflow::insertTrvAccountingDistribution(  trvSubmitAccDistributionView.RecId,
                                                                                                        cashAdvanceCurrencyCode,
                                                                                                        remainingAdvanceAmount,
                                                                                                        ((trvSubmitAccDistributionView.TransactionCurrencyAmount / roundUp(trvSubmitAccDistributionView.TransactionCurrencyAmountMST, 0.01))
                                                                                                          * remainingAdvanceAmount),
                                                                                                        cashAdvanceOldRecId,
                                                                                                        NoYes::No, 0, NoYes::Yes);

                                    remainingBalanceContainer = conDel(remainingBalanceContainer, 1, 1);
                                    trvAccountingDistributionAmountMST = remainingAdvanceAmount;
                                    remainingExpenseLineAmount = remainingExpenseLineAmount - remainingAdvanceAmount;
                                    cashAdvanceForContainer = cashAdvanceForContainer - remainingAdvanceAmount;
                                }
                                else
                                {
                                    // If the remaining amount of current transaction is less than the balance of this cash advance record,
                                    // let's consume part of this cash advance and update the remaining balance correctly. 
                                    TrvSubmitExpenseReportToWorkflow::insertTrvAccountingDistribution(  trvSubmitAccDistributionView.RecId,
                                                                                                        cashAdvanceCurrencyCode,
                                                                                                        remainingExpenseLineAmount,
                                                                                                        ((trvSubmitAccDistributionView.TransactionCurrencyAmount / roundUp(trvSubmitAccDistributionView.TransactionCurrencyAmountMST, 0.01))
                                                                                                          * remainingExpenseLineAmount),
                                                                                                        cashAdvanceOldRecId,
                                                                                                        NoYes::No, 0, NoYes::Yes);
                                    remainingBalanceContainer = conPoke(remainingBalanceContainer, 1, [(remainingAdvanceAmount-remainingExpenseLineAmount), cashAdvanceOldRecId, cashAdvanceCurrencyCode]);
                                    cashAdvanceForContainer = cashAdvanceForContainer - remainingExpenseLineAmount;
                                    remainingExpenseLineAmount = 0;
                                    trvAccountingDistributionAmountMST = remainingExpenseLineAmount;
                                }
                            }

                            cashAdvanceBalanceAmount = cashAdvanceBalanceAmount - trvAccountingDistributionAmountMST;
                        }
                    }
                    else
                    {
                        // We are here because the transaction amount was higher than the total available cash advance so far.
                        // Add the record to the "remaining balance container".
                        if (cashAdvanceBalanceAmount > 0)
                        {
                            remainingBalanceContainer += [[cashAdvanceForContainer, trvCashAdvance.RecId, trvCashAdvance.CurrencyCode]];
                        }
                        break;
                    }
                }

                // Insert accounting distributions when expense line tax amount is less than cash advance.
                // The code block in below while loop is exact replica of code block in above while loop - only difference is that
                // here we are processing the tax transactions.
                while select SourceDocumentHeader, SourceDocumentLine, TransactionCurrencyAmount, TransactionCurrencyAmountMST, RecId from trvTaxUncommittedDistributionView
                    order by trvTaxUncommittedDistributionView.TransactionCurrencyAmountMST asc
                    where trvTaxUncommittedDistributionView.SourceDocumentHeader == _trvExpTable.SourceDocumentHeader
                        notexists join trvAccountingDistribution
                        where trvTaxUncommittedDistributionView.RecId == trvAccountingDistribution.AccountingDistribution
                        && trvAccountingDistribution.FullySplit == NoYes::Yes
                {
                    if (trvTaxUncommittedDistributionView.TransactionCurrencyAmountMST <= cashAdvanceBalanceAmount)
                    {
                        remainingExpenseLineAmount = roundUp(trvTaxUncommittedDistributionView.TransactionCurrencyAmountMST, 0.01);

                        while (remainingExpenseLineAmount > 0)
                        {
                            numItems =  conLen(remainingBalanceContainer);

                            if (numItems == 0)
                            {
                                TrvSubmitExpenseReportToWorkflow::insertTrvAccountingDistribution(  trvTaxUncommittedDistributionView.RecId,
                                                                                                    trvCashAdvance.CurrencyCode,
                                                                                                    remainingExpenseLineAmount,
                                                                                                    ((trvTaxUncommittedDistributionView.TransactionCurrencyAmount / roundUp(trvTaxUncommittedDistributionView.TransactionCurrencyAmountMST, 0.01))
                                                                                                      * remainingExpenseLineAmount),
                                                                                                    trvCashAdvance.RecId,
                                                                                                    NoYes::No, 0, NoYes::Yes);

                                cashAdvanceForContainer = cashAdvanceForContainer - remainingExpenseLineAmount;
                                trvAccountingDistributionAmountMST = remainingExpenseLineAmount;
                                remainingExpenseLineAmount = 0;
                            }
                            else
                            {
                                [remainingAdvanceAmount, cashAdvanceOldRecId, cashAdvanceCurrencyCode] = conPeek(remainingBalanceContainer, 1);

                                if (remainingExpenseLineAmount > remainingAdvanceAmount)
                                {
                                    TrvSubmitExpenseReportToWorkflow::insertTrvAccountingDistribution(  trvTaxUncommittedDistributionView.RecId,
                                                                                                        cashAdvanceCurrencyCode,
                                                                                                        remainingAdvanceAmount,
                                                                                                        ((trvTaxUncommittedDistributionView.TransactionCurrencyAmount / roundUp(trvTaxUncommittedDistributionView.TransactionCurrencyAmountMST, 0.01))
                                                                                                          * remainingAdvanceAmount),
                                                                                                        cashAdvanceOldRecId,
                                                                                                        NoYes::No, 0, NoYes::Yes);

                                    remainingBalanceContainer = conDel(remainingBalanceContainer, 1, 1);
                                    trvAccountingDistributionAmountMST = remainingAdvanceAmount;
                                    remainingExpenseLineAmount = remainingExpenseLineAmount - remainingAdvanceAmount;
                                    cashAdvanceForContainer = cashAdvanceForContainer - remainingAdvanceAmount;
                                }
                                else
                                {
                                    TrvSubmitExpenseReportToWorkflow::insertTrvAccountingDistribution(  trvTaxUncommittedDistributionView.RecId,
                                                                                                        cashAdvanceCurrencyCode,
                                                                                                        remainingExpenseLineAmount,
                                                                                                        ((trvTaxUncommittedDistributionView.TransactionCurrencyAmount / roundUp(trvTaxUncommittedDistributionView.TransactionCurrencyAmountMST, 0.01))
                                                                                                          * remainingExpenseLineAmount),
                                                                                                        cashAdvanceOldRecId,
                                                                                                        NoYes::No, 0, NoYes::Yes);

                                    remainingBalanceContainer = conPoke(remainingBalanceContainer, 1, [(remainingAdvanceAmount-remainingExpenseLineAmount), cashAdvanceOldRecId, cashAdvanceCurrencyCode]);
                                    cashAdvanceForContainer = cashAdvanceForContainer - remainingExpenseLineAmount;
                                    remainingExpenseLineAmount = 0;
                                    trvAccountingDistributionAmountMST = remainingExpenseLineAmount;
                                }
                            }

                            cashAdvanceBalanceAmount = cashAdvanceBalanceAmount - trvAccountingDistributionAmountMST;
                        }

                        //Insert accounting distributions when expense line tax amount is negetive.
                        if (remainingExpenseLineAmount < 0)
                        {
                            TrvSubmitExpenseReportToWorkflow::insertTrvAccountingDistribution(trvTaxUncommittedDistributionView.RecId,
                                                                                                trvCashAdvance.CurrencyCode,
                                                                                                remainingExpenseLineAmount,
                                                                                                ((trvTaxUncommittedDistributionView.TransactionCurrencyAmount / roundUp(trvTaxUncommittedDistributionView.TransactionCurrencyAmountMST, 0.01))
                                                                                                    * remainingExpenseLineAmount),
                                                                                                trvCashAdvance.RecId,
                                                                                                NoYes::No, 0, NoYes::Yes);
                        }
                    }
                    else
                    {
                        if (cashAdvanceBalanceAmount > 0)
                        {
                            remainingBalanceContainer += [[cashAdvanceForContainer, trvCashAdvance.RecId, trvCashAdvance.CurrencyCode]];
                        }

                        break;
                    }
                }
            }
        }
        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTrvDistForExpAmountMoreThanCashAdv</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert <c>TrvAccountingDistribution</c> records when expense line (distribution) amount is more than cash advance amount.
    /// </summary>
    /// <param name="_accountingDistributionRecId">
    /// Accounting distribution table record id
    /// </param>
    /// <param name="_distributionTransactionCurrencyAmount">
    /// Distribution transaction currency amount
    /// </param>
    /// <param name="_distributionTransactionCurrencyAmountMST">
    /// Distribution transaction currency amount mst
    /// </param>
    private static void insertTrvDistForExpAmountMoreThanCashAdv(RefRecId _accountingDistributionRecId,
                                                                 AmountCur _distributionTransactionCurrencyAmount,
                                                                 AmountMST _distributionTransactionCurrencyAmountMST)
    {
        TrvCashAdvance                      trvCashAdvanceAccDistribution;
        TrvAccountingDistribution           trvAccDistributionCashAdvanceSum;
        TrvAccountingDistribution           trvAccountingDistributionCashAdvance;
        RecordInsertList                    trvAccountingCashAdvanceInsertList;
        AmountMST                           remainingCashBalance = 0;
        TaxUncommitted						taxUncommitted;
        AccountingDistribution              accountingDistribution;
        TrvExpTable                         trvExpTable;
        TrvExptrans                         trvExptrans;

        trvAccountingCashAdvanceInsertList  = new RecordInsertList(tableNum(TrvAccountingDistribution));

        select MonetaryAmount, SourceDocumentLine from accountingDistribution
            where accountingDistribution.RecId == _accountingDistributionRecId;

        if (accountingDistribution.MonetaryAmount == MonetaryAmount::Tax || accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable)
        {
            select trvExpTable
                exists join  trvExptrans
                    where trvExptrans.TrvExpTable == trvExpTable.RecId
                exists join taxUncommitted
                    where taxUncommitted.SourceTableId == trvExptrans.TableId
                        && taxUncommitted.SourceRecId == trvExptrans.RecId
                        && taxUncommitted.SourceDocumentLine == accountingDistribution.SourceDocumentLine;
        }
        else
        {
            select trvExpTable
                exists join  trvExptrans
                where trvExptrans.TrvExpTable == trvExpTable.RecId
                    && trvExptrans.SourceDocumentLine == accountingDistribution.SourceDocumentLine;
        }
        ttsBegin;

        while select BalanceMST, CurrencyCode, RecId from trvCashAdvanceAccDistribution
            where trvCashAdvanceAccDistribution.BalanceMST > 0
            && trvCashAdvanceAccDistribution.RequestingWorker == trvExpTable.CreatingWorker
            && trvCashAdvanceAccDistribution.CashAdvanceStatus == TrvWorkflowCashAdvanceStatus::Paid
        {
            select sum(AdvanceAmountMST) from trvAccDistributionCashAdvanceSum
                where trvAccDistributionCashAdvanceSum.CashAdvance == trvCashAdvanceAccDistribution.RecId;

            remainingCashBalance = trvCashAdvanceAccDistribution.BalanceMST - trvAccDistributionCashAdvanceSum.AdvanceAmountMST;

            if (remainingCashBalance > 0)
            {
                trvAccountingDistributionCashAdvance.AccountingDistribution = _accountingDistributionRecId;
                trvAccountingDistributionCashAdvance.AdvanceAmountMST = remainingCashBalance;

                if (_distributionTransactionCurrencyAmountMST != 0)
                {
                    trvAccountingDistributionCashAdvance.AdvanceAmount = ((trvAccountingDistributionCashAdvance.AdvanceAmountMST / _distributionTransactionCurrencyAmountMST)
                                                                           * _distributionTransactionCurrencyAmount);
                }

                trvAccountingDistributionCashAdvance.AdvanceCurrencyCode = trvCashAdvanceAccDistribution.CurrencyCode;
                trvAccountingDistributionCashAdvance.CashAdvance = trvCashAdvanceAccDistribution.RecId;
                trvAccountingDistributionCashAdvance.FullySplit = NoYes::Yes;
                trvAccountingDistributionCashAdvance.EqualToDistribution = NoYes::Yes;
                trvAccountingCashAdvanceInsertList.add(trvAccountingDistributionCashAdvance);
            }
        }

        trvAccountingCashAdvanceInsertList.insertDatabase();

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTrvDistForLeftOutCashAdvances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert <c>TrvAccountingDistribution</c> record for expense line related distributions by consuming left out cash advances.
    /// </summary>
    /// <param name="_trvExpTable">
    /// The current <c>TrvExpTable</c> record.
    /// </param>
    private static void insertTrvDistForLeftOutCashAdvances(TrvExpTable _trvExpTable)
    {
        TrvSubmitAccDistribution            accountingDistributionTrvExpTrans;
        TrvTaxUncommittedDistributionView   trvTaxUncommittedDistributionView;
        TrvAccountingDistribution           trvAccountingDistributionReference;
        TrvAccountingDistribution           trvAccountingDistributionReferenceSum;
        TrvCashAdvance                      trvCashAdvanceReference;
        AmountMST                           expenseBalance;
        AmountCur                           remainingRefBalance = 0;

        ttsBegin;

        // Insert accounting distributions for expense line related distributions by consuming left out cash advances.
        while select SourceDocumentLine, TransactionCurrencyAmount, TransactionCurrencyAmountMST, RecId from accountingDistributionTrvExpTrans
            where accountingDistributionTrvExpTrans.SourceDocumentHeader == _trvExpTable.SourceDocumentHeader
            notexists join trvAccountingDistributionReference
                where trvAccountingDistributionReference.AccountingDistribution == accountingDistributionTrvExpTrans.RecId
        {
            expenseBalance = roundUp(accountingDistributionTrvExpTrans.TransactionCurrencyAmountMST, 0.01);

            while select RecId, BalanceMST, CurrencyCode from trvCashAdvanceReference
                where trvCashAdvanceReference.RequestingWorker == _trvExpTable.CreatingWorker
                && trvCashAdvanceReference.BalanceMST > 0
                && trvCashAdvanceReference.CashAdvanceStatus == TrvWorkflowCashAdvanceStatus::Paid
            {
                select sum(AdvanceAmountMST) from trvAccountingDistributionReferenceSum
                    where trvAccountingDistributionReferenceSum.CashAdvance == trvCashAdvanceReference.RecId;

                remainingRefBalance = trvCashAdvanceReference.BalanceMST - trvAccountingDistributionReferenceSum.AdvanceAmountMST;

                if (remainingRefBalance < expenseBalance && remainingRefBalance > 0)
                {
                    TrvSubmitExpenseReportToWorkflow::insertTrvAccountingDistribution(  accountingDistributionTrvExpTrans.RecId,
                                                                                        trvCashAdvanceReference.CurrencyCode,
                                                                                        remainingRefBalance,
                                                                                        ((accountingDistributionTrvExpTrans.TransactionCurrencyAmount / roundUp(accountingDistributionTrvExpTrans.TransactionCurrencyAmountMST, 0.01))
                                                                                          * remainingRefBalance),
                                                                                        trvCashAdvanceReference.RecId,
                                                                                        NoYes::Yes, 0, NoYes::Yes);

                    expenseBalance = expenseBalance - remainingRefBalance;
                }
                else if (expenseBalance > 0 && remainingRefBalance > 0)
                {
                    TrvSubmitExpenseReportToWorkflow::insertTrvAccountingDistribution(  accountingDistributionTrvExpTrans.RecId,
                                                                                        trvCashAdvanceReference.CurrencyCode,
                                                                                        expenseBalance,
                                                                                        ((accountingDistributionTrvExpTrans.TransactionCurrencyAmount / roundUp(accountingDistributionTrvExpTrans.TransactionCurrencyAmountMST, 0.01))
                                                                                          * expenseBalance),
                                                                                        trvCashAdvanceReference.RecId,
                                                                                        NoYes::Yes, 0, NoYes::Yes);

                }
            }
        }

        // Insert accounting distributions for expense line tax related distributions by consuming left out cash advances.
        while select SourceDocumentLine, TransactionCurrencyAmount, TransactionCurrencyAmountMST, RecId from trvTaxUncommittedDistributionView
            where trvTaxUncommittedDistributionView.SourceDocumentHeader == _trvExpTable.SourceDocumentHeader
            notexists join trvAccountingDistributionReference
                where trvAccountingDistributionReference.AccountingDistribution == trvTaxUncommittedDistributionView.RecId
        {
            expenseBalance = roundUp(trvTaxUncommittedDistributionView.TransactionCurrencyAmountMST, 0.01);

            while select RecId, BalanceMST, CurrencyCode from trvCashAdvanceReference
                where trvCashAdvanceReference.RequestingWorker == _trvExpTable.CreatingWorker
                && trvCashAdvanceReference.BalanceMST > 0
                && trvCashAdvanceReference.CashAdvanceStatus == TrvWorkflowCashAdvanceStatus::Paid
            {
                select sum(AdvanceAmountMST) from trvAccountingDistributionReferenceSum
                    where trvAccountingDistributionReferenceSum.CashAdvance == trvCashAdvanceReference.RecId;

                remainingRefBalance = trvCashAdvanceReference.BalanceMST - trvAccountingDistributionReferenceSum.AdvanceAmountMST;

                if (remainingRefBalance < expenseBalance && remainingRefBalance > 0)
                {
                    TrvSubmitExpenseReportToWorkflow::insertTrvAccountingDistribution(  trvTaxUncommittedDistributionView.RecId,
                                                                                        trvCashAdvanceReference.CurrencyCode,
                                                                                        remainingRefBalance,
                                                                                        ((trvTaxUncommittedDistributionView.TransactionCurrencyAmount / roundUp(trvTaxUncommittedDistributionView.TransactionCurrencyAmountMST, 0.01))
                                                                                          * remainingRefBalance),
                                                                                        trvCashAdvanceReference.RecId,
                                                                                        NoYes::Yes, 0, NoYes::Yes);

                    expenseBalance = expenseBalance - remainingRefBalance;
                }
                else if (expenseBalance > 0 && remainingRefBalance > 0)
                {
                    TrvSubmitExpenseReportToWorkflow::insertTrvAccountingDistribution(  trvTaxUncommittedDistributionView.RecId,
                                                                                        trvCashAdvanceReference.CurrencyCode,
                                                                                        expenseBalance,
                                                                                        ((trvTaxUncommittedDistributionView.TransactionCurrencyAmount / roundUp(trvTaxUncommittedDistributionView.TransactionCurrencyAmountMST, 0.01))
                                                                                          * expenseBalance),
                                                                                        trvCashAdvanceReference.RecId,
                                                                                        NoYes::Yes, 0, NoYes::Yes);

                }
            }
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTrvAccDisctributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// When expense report has lines with cash as payment method or lines with return cash type and if accounting distribution has been reset after workflow submission,
    /// TrvAccountingDisctribution and related records needs to repopulated and synced based on new accounting distribution records.
    /// </summary>
    /// <param name = "_trvExpTable">The table buffer containing expense report header information</param>
    public static void updateTrvAccDisctributions(TrvExpTable _trvExpTable)
    {
        TrvSubmitAccDistribution trvSubmitAccDistribution;
        TrvAccountingDistribution trvAccountingDistribution;
        AccountingDistribution accountingDistribution;

        select RecId from accountingDistribution
            where accountingDistribution.SourceDocumentHeader == _trvExpTable.SourceDocumentHeader
        join RecId from trvSubmitAccDistribution
            where trvSubmitAccDistribution.SourceDocumentHeader == accountingDistribution.SourceDocumentHeader
        notexists join trvAccountingDistribution
            where (trvAccountingDistribution.AccountingDistribution == accountingDistribution.RecId
                || trvAccountingDistribution.AccountingDistribution == accountingDistribution.ParentDistribution); //Added ParentDistribution condition to avoid source document error during line level posting due to under or over distribution and to consider the tax record.

        if (accountingDistribution || _trvExpTable.hasCashAdvanceReturnLine())
        {
            TrvSubmitExpenseReportToWorkflow::handleDistributionsForCashAdvance(_trvExpTable);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>