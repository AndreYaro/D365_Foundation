<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSOnHandSPHelper</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///     The <c>WHSOnHandSPHelper</c> class contains helper methods to manipulate the WHS on-hand stored procedure.
/// </summary>
public class WhsOnHandSPHelper
{
    const str CacheScope = 'WHSOnHandSPHelper';
    const str EnabledDimsParametersCacheKey = 'EnabledDimensionsCache';
    const str ProductDimsParametersCacheKey = 'ProductDimensionsCache';
    const str AvailPhysicalParmName = '@AVAILPHYSICAL';
    const str AvailOrderedParmName = '@AVAILORDERED';
    private const str CWAvailPhysicalParmName = '@CWAVAILPHYSICAL';
    private const str CWAvailOrderedParmName = '@CWAVAILORDERED';

    const str UpperLevelOfMinimumCalculationParamName = '@UPPERLEVELOFMINIMUMCALCULATION';
    const str TTSIdParmName = '@TTSId';
    const str AvailPhysicalResultFieldName = 'AVAILPHYSICALRESULT';
    const str AvailOrderedResultFieldName = 'AVAILORDEREDRESULT';
    const str AvailPhysicalFoundFieldName = 'AVAILPHYSICALFOUND';
    const str AvailOrderedFoundFieldName = 'AVAILORDEREDFOUND';
    readonly str ParentInventDimIdFieldName;
    readonly str HierarchyLevelFieldName;

    private const str CWAvailPhysicalResultFieldName = 'CWAVAILPHYSICALRESULT';
    private const str CWAvailOrderedResultFieldName = 'CWAVAILORDEREDRESULT';
    private const str CWAvailPhysicalFoundFieldName = 'CWAVAILPHYSICALFOUND';
    private const str CWAvailOrderedFoundFieldName = 'CWAVAILORDEREDFOUND';
    private const str CWWHSOnHandWithDeltaSPName = 'sp_CWWHSOnHandWithDelta';
    private const str CWWHSOnHandSPName = 'sp_CWWHSOnHand';
    private const str WHSOnHandUnionAllDeltaTVFCatchWeight = 'if_WHSCWInventReserveUnionDelta';
    private const str WHSOnHandWithInventDimSPName = 'WHSOnHandWithInventDim';
    private const str WHSOnHandWithDeltaWithInventDimSPName = 'WHSOnHandWithDeltaWithInventDim';
    private const str CWWHSOnHandWithDeltaWithInventDimSPName = 'CWWHSOnHandWithDeltaWithInventDim';
    private const str CWWHSOnHandWithInventDimSPName = 'CWWHSOnHandWithInventDim';
    private const str WHSOnHandUnionAllDeltaWithInventDimTVF = 'if_WHSInventReserveUnionDeltaWithInventDim';
    private const str WHSOnHandUnionAllDeltaWithInventDimTVFCatchWeight = 'if_WHSCWInventReserveUnionDeltaWithInventDim';
    private const str WHSInventReserveMinValuesForDimIdSPName = 'WHSInventReserveMinValuesForDimId';
    private const str WHSInventReserveMinValuesForDimIdWithDeltaSPName = 'WHSInventReserveMinValuesForDimIdWithDelta';
    private const str CWWHSInventReserveMinValuesForDimIdSPName = 'CWWHSInventReserveMinValuesForDimId';
    private const str CWWHSInventReserveMinValuesForDimIdWithDeltaSPName = 'CWWHSInventReserveMinValuesForDimIdWithDelta';
    private const str ValuesFoundParmName = '@VALUESFOUND';
    private const str WHSInventReserveMinValuesForDimIdCacheScope = 'WHSOnHandSPHelper_InventReserveMinValuesForDimId';
    private const str WHSInventReserveMinValuesForDimIdSPCallStmtCacheKey = 'SPCallStmt';

    private const str DataAreaIdParmValue = 'DataAreaIdParm';
    private const str PartitionParmValue = 'PartitionParm';
    private const str ItemIdParmValue = 'ItemIdParm';
    private const str LevelParmValue = 'LevelParm';
    private const str UpperLevelOfMinimumCalculationParmValue = 'UpperLevelOfMinimumCalculatioParm';
    private const str TTSIdParmValue = 'TTSIdParm';
    private const str InventParmValue = 'InventParm';
    private const str InventLevelParmValue = 'InventLevelParm';
    private const str InventDimParmValue = 'InventDimParm';
    private const str SkipFirstRecordValidationParmValue = 'SkipFirstRecordValidationParm';
    
    #WHSOnHandSP
    #WHSReservationHierarchy

    str resultTableVariableFields; // access using the resultTableVariableFields() method
    private str cwResultTableVariableFields; 

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calculateQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the <c>WHSInventReserveQuantities</c> reservation quantities.
    /// </summary>
    /// <param name="_inventTable">
    ///     <c>InventTable</c> record to use.
    /// </param>
    /// <param name="_inventDimCriteria">
    ///     <c>InventDim</c> criteria for the calculations.
    /// </param>
    /// <param name="_optimizedInventDimParm">
    ///     <c>InventDimParm</c> criteria for the calculations.
    /// </param>
    /// <param name="_level">
    ///     <c>WHSReservationHierarchyLevel</c> level to start the search at.
    /// </param>
    /// <param name="_includeDelta">
    ///     A boolean indicating whether delta records should be considered in the on hand calculation; optional.
    /// </param>
    /// <param name="_ttsId">
    ///     The id of the transaction that the deltas were created in.
    /// </param>
    /// <param name="_upperLevelOfMinimumCalculation">
    ///     The maximum hierarchy level to be considered for calculating the onhand; optional.
    /// </param>
    /// <returns>
    ///     The <c>WHSInventReserveQuantities</c> reservation quantities.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws an error no result was found based on the statement.
    /// </exception>
    [Hookable(false)]
    internal WHSInventReserveQuantities calculateQuantities(
        InventTable                     _inventTable,
        InventDim                       _inventDimCriteria,
        InventDimParm                   _optimizedInventDimParm,
        WHSReservationHierarchyLevel    _level,
        boolean                         _includeDelta,
        CreatedTransactionId            _ttsId,
        WHSReservationHierarchyLevel    _upperLevelOfMinimumCalculation)
    {
        str sqlStmt;
        WHSQueryWithParametersValues sqlWithParams;
        boolean includeCW = WHSOnHandSPHelper::canUseWHSCatchWeightForItem(_inventTable.ItemId);
        
        boolean isExecuteWithParamsEnabled = WHSExecuteWithParametersV3Flight::instance().isEnabled();

        if (isExecuteWithParamsEnabled)
        {
            if (includeCW)
            {
                sqlWithParams = WHSOnHandSPHelper::construct().buildSPCallStmtCWWithParameters(
                                                        _inventTable,
                                                        _inventDimCriteria,
                                                        _optimizedInventDimParm,
                                                        _level,
                                                        _includeDelta,
                                                        _ttsId,
                                                        _upperLevelOfMinimumCalculation);
            }
            else
            {
                sqlWithParams = WHSOnHandSPHelper::construct().buildSPCallStmtWithParameters(
                                                        _inventTable,
                                                        _inventDimCriteria,
                                                        _optimizedInventDimParm,
                                                        _level,
                                                        _includeDelta,
                                                        _ttsId,
                                                        _upperLevelOfMinimumCalculation);
            }
        }
        else {
            if (includeCW)
            {
                sqlStmt = WHSOnHandSPHelper::construct().buildSPCallStmtCW(
                                                        _inventTable,
                                                        _inventDimCriteria,
                                                        _optimizedInventDimParm,
                                                        _level,
                                                        _includeDelta,
                                                        _ttsId,
                                                        _upperLevelOfMinimumCalculation);
            }
            else
            {
                sqlStmt = WHSOnHandSPHelper::construct().buildSPCallStmt(
                                                        _inventTable,
                                                        _inventDimCriteria,
                                                        _optimizedInventDimParm,
                                                        _level,
                                                        _includeDelta,
                                                        _ttsId,
                                                        _upperLevelOfMinimumCalculation);
            }
        }
        

        InventQty       availPhysical;
        InventQty       availOrdered;
        PdsCWInventQty  cwAvailPhysical;
        PdsCWInventQty  cwAvailOrdered;

        Connection connection = new Connection();        
        try
        {
            Statement statement = connection.createStatement();
            ResultSet resultSet;
            if (isExecuteWithParamsEnabled)
            {
                resultSet = statement.executeQueryWithParameters(sqlWithParams.parmStatement(), sqlWithParams.parmParameters());
            }
            else
            {
                resultSet = statement.executeQuery(sqlStmt);
            }

            if (!resultSet.next())
            {
                throw error(Error::missingRecord(#WHSOnHandSPName));
            }        
        
            availPhysical  = resultSet.getReal(1);
            availOrdered   = resultSet.getReal(2);
            
            if (includeCW)
            {
                CWAvailPhysical  = resultSet.getReal(3);
                CWAvailOrdered  = resultSet.getReal(4);
            }
        }
        finally
        {
            connection.finalize();
        }

        return WHSInventReserveQuantities::newAvailQuantities(availPhysical, availOrdered, cwAvailPhysical, cwAvailOrdered);
    }

]]></Source>
			</Method>
			<Method>
				<Name>SQLOptions</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Returns a string with options that are used for the SQL statements.
    /// </summary>
    /// <returns>
    ///  A string of SQL with the options.
    /// </returns>
    [Hookable(true)]
    private str SQLOptions()    
    {
        return 'OPTION(FORCE ORDER, LOOP JOIN)';      
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCreateSPStmt</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal str buildCreateSPStmt(boolean _includeDelta, boolean _includeCW, boolean _joinInventDim)
    {
        str             ret = '';
        ListEnumerator  enabledStorageAndTrancingDimensionEnumerator;
        ListEnumerator  enabledProductDimensionEnumerator;
        FieldId         dimFieldId;
        str             dimFieldName;
        
        InventDimMetaDataCache::clearCache(); //in some cases the cache is not updated before sync making below SP

        enabledStorageAndTrancingDimensionEnumerator = this.enabledStorageAndTrackingDimensions().getEnumerator();
        enabledProductDimensionEnumerator = this.enabledProductDimensions().getEnumerator();
        
        /*

        --------------------- NO DELTA - NON CATCH WEIGHT VERSION---------------------

            SET ANSI_NULLS ON
            GO
            
            SET QUOTED_IDENTIFIER ON
            GO
            
            CREATE PROCEDURE [dbo].[sp_WHSOnHand]
                @PARTITION bigint,
                @LEVEL int,
                @UPPERLEVELOFMINIMUMCALCULATION int,
                @DATAAREAID nvarchar (4),
                @ITEMID nvarchar (20),
                @INVENTSITEID nvarchar (10) = NULL,
                @INVENTSITEIDLEVEL int = 1024,
                @INVENTLOCATIONID nvarchar (10) = NULL,
                @INVENTLOCATIONIDLEVEL int = 1024,
                @WMSLOCATIONID nvarchar (10) = NULL,
                @WMSLOCATIONIDLEVEL int = 1024,
                @INVENTSTATUSID nvarchar (10) = NULL,
                @INVENTSTATUSIDLEVEL int = 1024,
                @LICENSEPLATEID nvarchar (25) = NULL,
                @LICENSEPLATEIDLEVEL int = 1024,
                @INVENTBATCHID nvarchar (20) = NULL,
                @INVENTBATCHIDLEVEL int = 1024,
                @INVENTSERIALID nvarchar (20) = NULL,
                @INVENTSERIALIDLEVEL int = 1024,
                @INVENTPROFILEID_RU nvarchar (10) = NULL,
                @INVENTPROFILEID_RULEVEL int = 1024,
                @INVENTOWNERID_RU nvarchar (40) = NULL,
                @INVENTOWNERID_RULEVEL int = 1024,
                @INVENTGTDID_RU nvarchar (30) = NULL,
                @INVENTGTDID_RULEVEL int = 1024,
                @CONFIGID nvarchar (50) = NULL,
                @INVENTSIZEID nvarchar (10) = NULL,
                @INVENTCOLORID nvarchar (10) = NULL,
                @INVENTSTYLEID nvarchar (10) = NULL,
                @INVENTVERSIONID nvarchar (10) = NULL,
                -- Output parameters
                @AVAILPHYSICAL  numeric(32, 6) OUTPUT,
                @AVAILORDERED  numeric(32, 6) OUTPUT
            AS
            
            -- Without nocount on the procedure will return number of affected rows in the result set which is
            -- harmful to performance and requires us to adjust field retrieval when calling the stored procedure
            SET NOCOUNT ON;
            
            -- We need to suppress warnings when trying to aggregate NULL columns. This is a valid business scenario
            -- and happens e.g. for a non-LP controlled location with batch below item.
            SET ANSI_WARNINGS OFF;
            
            -- The @RESULT table variable is used to store intermediate quantities.
            DECLARE @RESULT TABLE(
                AVAILPHYSICALRESULT numeric(32, 6) NOT NULL, -- Aggregated minimum qtys from lower level in @RESULT
                AVAILORDEREDRESULT numeric(32, 6) NOT NULL, -- Aggregated minimum qtys from lower level in @RESULT
                AVAILPHYSICALFOUND numeric(32, 6), -- Aggregated qty for current level in WHSInventReserve
                AVAILORDEREDFOUND numeric(32, 6), -- Aggregated qty for current level in WHSInventReserve
                HIERARCHYLEVEL int NOT NULL,
                PARENTINVENTDIMID nvarchar (20) NOT NULL,
                INDEX RESULTCLUSTEREDIDX CLUSTERED (HIERARCHYLEVEL, PARENTINVENTDIMID));
            
            -- The algorithm of the stored procedure is as follows:
            -- 1. Initialize the @RESULT table with aggregated qtys in WHSInventReserve for the level requested by user
            -- 2. Traverse the hierarchy up and for each level:
            --     1) Aggregate qtys from previous level in @RESULT grouping by dimensions of parent hierarchy level
            --     2) Aggregate qtys from current level in WHSInventReserve grouping by dimensions of parent hierarchy level
            --     3) Select the minimum of the above qtys and insert into @RESULT
            -- 3. When hierarchy level @UPPERLEVELOFMINIMUMCALCULATION is reached, return the sum of aggregated qtys in @RESULT
            
            -- Initialize the @RESULT variable.
            -- Loads aggregated data for the lowest level requested by user.
            INSERT INTO @RESULT (AVAILPHYSICALRESULT, AVAILORDEREDRESULT, AVAILPHYSICALFOUND, AVAILORDEREDFOUND, HIERARCHYLEVEL, PARENTINVENTDIMID)
            SELECT SUM(WHSINVENTRESERVE.AVAILPHYSICAL),
                SUM(WHSINVENTRESERVE.AVAILORDERED),
                NULL,
                NULL,
                @LEVEL,
                WHSINVENTRESERVE.PARENTINVENTDIMID
                FROM WHSINVENTRESERVE WHSINVENTRESERVE
                JOIN INVENTDIM ON INVENTDIM.INVENTDIMID = WHSINVENTRESERVE.INVENTDIMID AND INVENTDIM.DATAAREAID = WHSINVENTRESERVE.DATAAREAID AND INVENTDIM.PARTITION = WHSINVENTRESERVE.PARTITION
                WHERE WHSINVENTRESERVE.ITEMID           = @ITEMID
                    AND WHSINVENTRESERVE.PARTITION      = @PARTITION
                    AND WHSINVENTRESERVE.DATAAREAID     = @DATAAREAID
                    AND WHSINVENTRESERVE.HIERARCHYLEVEL = @LEVEL
                    AND (@CONFIGID IS NULL OR INVENTDIM.CONFIGID = @CONFIGID)
                    AND (@INVENTSIZEID IS NULL OR INVENTDIM.INVENTSIZEID = @INVENTSIZEID)
                    AND (@INVENTCOLORID IS NULL OR INVENTDIM.INVENTCOLORID = @INVENTCOLORID)
                    AND (@INVENTSTYLEID IS NULL OR INVENTDIM.INVENTSTYLEID = @INVENTSTYLEID)
                    AND (@INVENTVERSIONID IS NULL OR INVENTDIM.INVENTVERSIONID = @INVENTVERSIONID)
                    AND (1 = CASE WHEN @LEVEL >= @INVENTSITEIDLEVEL AND @INVENTSITEID is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTSITEID = CASE WHEN @LEVEL >= @INVENTSITEIDLEVEL THEN @INVENTSITEID ELSE '' END)
                    AND (1 = CASE WHEN @LEVEL >= @INVENTLOCATIONIDLEVEL AND @INVENTLOCATIONID is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTLOCATIONID = CASE WHEN @LEVEL >= @INVENTLOCATIONIDLEVEL THEN @INVENTLOCATIONID ELSE '' END)
                    AND (1 = CASE WHEN @LEVEL >= @WMSLOCATIONIDLEVEL AND @WMSLOCATIONID is null THEN 1 ELSE 0 END OR INVENTDIM.WMSLOCATIONID = CASE WHEN @LEVEL >= @WMSLOCATIONIDLEVEL THEN @WMSLOCATIONID ELSE '' END)
                    AND (1 = CASE WHEN @LEVEL >= @INVENTSTATUSIDLEVEL AND @INVENTSTATUSID is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTSTATUSID = CASE WHEN @LEVEL >= @INVENTSTATUSIDLEVEL THEN @INVENTSTATUSID ELSE '' END)
                    AND (1 = CASE WHEN @LEVEL >= @LICENSEPLATEIDLEVEL AND @LICENSEPLATEID is null THEN 1 ELSE 0 END OR INVENTDIM.LICENSEPLATEID = CASE WHEN @LEVEL >= @LICENSEPLATEIDLEVEL THEN @LICENSEPLATEID ELSE '' END)
                    AND (1 = CASE WHEN @LEVEL >= @INVENTBATCHIDLEVEL AND @INVENTBATCHID is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTBATCHID = CASE WHEN @LEVEL >= @INVENTBATCHIDLEVEL THEN @INVENTBATCHID ELSE '' END)
                    AND (1 = CASE WHEN @LEVEL >= @INVENTSERIALIDLEVEL AND @INVENTSERIALID is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTSERIALID = CASE WHEN @LEVEL >= @INVENTSERIALIDLEVEL THEN @INVENTSERIALID ELSE '' END)
                    AND (1 = CASE WHEN @LEVEL >= @INVENTPROFILEID_RULEVEL AND @INVENTPROFILEID_RU is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTPROFILEID_RU = CASE WHEN @LEVEL >= @INVENTPROFILEID_RULEVEL THEN @INVENTPROFILEID_RU ELSE '' END)
                    AND (1 = CASE WHEN @LEVEL >= @INVENTOWNERID_RULEVEL AND @INVENTOWNERID_RU is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTOWNERID_RU = CASE WHEN @LEVEL >= @INVENTOWNERID_RULEVEL THEN @INVENTOWNERID_RU ELSE '' END)
                    AND (1 = CASE WHEN @LEVEL >= @INVENTGTDID_RULEVEL AND @INVENTGTDID_RU is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTGTDID_RU = CASE WHEN @LEVEL >= @INVENTGTDID_RULEVEL THEN @INVENTGTDID_RU ELSE '' END)
            GROUP BY
                WHSINVENTRESERVE.PARENTINVENTDIMID
                OPTION(FORCE ORDER, LOOP JOIN);
            
            WHILE (@LEVEL > @UPPERLEVELOFMINIMUMCALCULATION)
            BEGIN
                INSERT INTO @RESULT (AVAILPHYSICALRESULT, AVAILORDEREDRESULT, AVAILPHYSICALFOUND, AVAILORDEREDFOUND, HIERARCHYLEVEL, PARENTINVENTDIMID)
             SELECT SUM(RESULTAGGR.MINAVAILPHYSICAL),
                    SUM(RESULTAGGR.MINAVAILORDERED),
                    SUM(CASE WHEN FOUND.HIERARCHYLEVEL = @Level + -1 THEN FOUND.AVAILPHYSICAL ELSE NULL END),
                    SUM(CASE WHEN FOUND.HIERARCHYLEVEL = @Level + -1 THEN FOUND.AVAILORDERED ELSE NULL END),
                    @LEVEL + -1,
                    CASE WHEN FOUND.HIERARCHYLEVEL = @LEVEL + -1 THEN FOUND.PARENTINVENTDIMID ELSE FOUND.INVENTDIMID END
             FROM (SELECT SUM(CASE WHEN AVAILPHYSICALFOUND < AVAILPHYSICALRESULT THEN AVAILPHYSICALFOUND ELSE AVAILPHYSICALRESULT END) AS MINAVAILPHYSICAL,
                          SUM(CASE WHEN AVAILORDEREDFOUND < AVAILORDEREDRESULT THEN AVAILORDEREDFOUND ELSE AVAILORDEREDRESULT END) AS MINAVAILORDERED,
                  PARENTINVENTDIMID as PARENTINVENTDIMID
               FROM @RESULT
               WHERE HIERARCHYLEVEL = @LEVEL
               GROUP BY PARENTINVENTDIMID) RESULTAGGR
               JOIN WHSINVENTRESERVE FOUND
               ON  FOUND.INVENTDIMID = RESULTAGGR.PARENTINVENTDIMID
               AND FOUND.ITEMID = @ITEMID
               AND FOUND.PARTITION = @PARTITION and FOUND.DATAAREAID = @DATAAREAID
             GROUP BY FOUND.PARENTINVENTDIMID, FOUND.HIERARCHYLEVEL, FOUND.INVENTDIMID

                SET @LEVEL = @LEVEL - 1
            END; -- WHILE
            
            SELECT @AVAILPHYSICAL = SUM(CASE WHEN AVAILPHYSICALFOUND < AVAILPHYSICALRESULT THEN AVAILPHYSICALFOUND ELSE AVAILPHYSICALRESULT END),
                @AVAILORDERED = SUM(CASE WHEN AVAILORDEREDFOUND < AVAILORDEREDRESULT THEN AVAILORDEREDFOUND ELSE AVAILORDEREDRESULT END)
            FROM @RESULT
            WHERE HIERARCHYLEVEL = @UPPERLEVELOFMINIMUMCALCULATION;
            
            GO
        */
        
        /*
            
            --------------------- WITH DELTA - NON CATCH WEIGHT VERSION ---------------------

                SET ANSI_NULLS ON
                GO

                SET QUOTED_IDENTIFIER ON
                GO

                CREATE PROCEDURE [dbo].[sp_WHSOnHandWithDelta]
                    @PARTITION bigint,
                    @LEVEL int,
                    @UPPERLEVELOFMINIMUMCALCULATION int,
                    @DATAAREAID nvarchar (4),
                    @ITEMID nvarchar (20),
                    @TTSId bigint,
                    @INVENTSITEID nvarchar (10) = NULL,
                    @INVENTSITEIDLEVEL int = 1024,
                    @INVENTLOCATIONID nvarchar (10) = NULL,
                    @INVENTLOCATIONIDLEVEL int = 1024,
                    @WMSLOCATIONID nvarchar (10) = NULL,
                    @WMSLOCATIONIDLEVEL int = 1024,
                    @INVENTSTATUSID nvarchar (10) = NULL,
                    @INVENTSTATUSIDLEVEL int = 1024,
                    @LICENSEPLATEID nvarchar (25) = NULL,
                    @LICENSEPLATEIDLEVEL int = 1024,
                    @INVENTBATCHID nvarchar (20) = NULL,
                    @INVENTBATCHIDLEVEL int = 1024,
                    @INVENTSERIALID nvarchar (20) = NULL,
                    @INVENTSERIALIDLEVEL int = 1024,
                    @INVENTPROFILEID_RU nvarchar (10) = NULL,
                    @INVENTPROFILEID_RULEVEL int = 1024,
                    @INVENTOWNERID_RU nvarchar (40) = NULL,
                    @INVENTOWNERID_RULEVEL int = 1024,
                    @INVENTGTDID_RU nvarchar (30) = NULL,
                    @INVENTGTDID_RULEVEL int = 1024,
                    @CONFIGID nvarchar (50) = NULL,
                    @INVENTSIZEID nvarchar (10) = NULL,
                    @INVENTCOLORID nvarchar (10) = NULL,
                    @INVENTSTYLEID nvarchar (10) = NULL,
                    @INVENTVERSIONID nvarchar (10) = NULL,
                    -- Output parameters
                    @AVAILPHYSICAL  numeric(32, 6) OUTPUT,
                    @AVAILORDERED  numeric(32, 6) OUTPUT
                AS

                -- Without nocount on the procedure will return number of affected rows in the result set which is
                -- harmful to performance and requires us to adjust field retrieval when calling the stored procedure
                SET NOCOUNT ON;

                -- We need to suppress warnings when trying to aggregate NULL columns. This is a valid business scenario
                -- and happens e.g. for a non-LP controlled location with batch below item.
                SET ANSI_WARNINGS OFF;

                -- The @RESULT table variable is used to store intermediate quantities.
                DECLARE @RESULT TABLE(
                    AVAILPHYSICALRESULT numeric(32, 6) NOT NULL, -- Aggregated minimum qtys from lower level in @RESULT
                    AVAILORDEREDRESULT numeric(32, 6) NOT NULL, -- Aggregated minimum qtys from lower level in @RESULT
                    AVAILPHYSICALFOUND numeric(32, 6), -- Aggregated qty for current level in WHSInventReserve
                    AVAILORDEREDFOUND numeric(32, 6), -- Aggregated qty for current level in WHSInventReserve
                    HIERARCHYLEVEL int NOT NULL,
                    CONFIGID nvarchar (50) NULL,
                    INVENTSIZEID nvarchar (10) NULL,
                    INVENTCOLORID nvarchar (10) NULL,
                    INVENTSTYLEID nvarchar (10) NULL,
                    INVENTVERSIONID nvarchar (10) NULL,
                    INVENTSITEID nvarchar (10) NULL,
                    INVENTLOCATIONID nvarchar (10) NULL,
                    WMSLOCATIONID nvarchar (10) NULL,
                    INVENTSTATUSID nvarchar (10) NULL,
                    LICENSEPLATEID nvarchar (25) NULL,
                    INVENTBATCHID nvarchar (20) NULL,
                    INVENTSERIALID nvarchar (20) NULL,
                    INVENTPROFILEID_RU nvarchar (10) NULL,
                    INVENTOWNERID_RU nvarchar (40) NULL,
                    INVENTGTDID_RU nvarchar (30) NULL);

                -- The algorithm of the stored procedure is as follows:
                -- 1. Initialize the @RESULT table with aggregated qtys in WHSInventReserve for the level requested by user
                -- 2. Traverse the hierarchy up and for each level:
                --     1) Aggregate qtys from previous level in @RESULT grouping by dimensions of current hierarchy level
                --     2) Aggregate qtys from current level in WHSInventReserve grouping by dimensions of current hierarchy level
                --     3) Select the minimum of the above qtys and insert into @RESULT
                -- 3. When hierarchy level @UPPERLEVELOFMINIMUMCALCULATION is reached, return the sum of aggregated qtys in @RESULT

                -- Initialize the @RESULT variable.
                -- Loads aggregated data for the lowest level requested by user.
                INSERT INTO @RESULT (AVAILPHYSICALRESULT, AVAILORDEREDRESULT, AVAILPHYSICALFOUND, AVAILORDEREDFOUND, HIERARCHYLEVEL, CONFIGID, INVENTSIZEID, INVENTCOLORID, INVENTSTYLEID, INVENTVERSIONID, INVENTSITEID, INVENTLOCATIONID, WMSLOCATIONID, INVENTSTATUSID, LICENSEPLATEID, INVENTBATCHID, INVENTSERIALID, INVENTPROFILEID_RU, INVENTOWNERID_RU, INVENTGTDID_RU)
                SELECT SUM(WHSINVENTRESERVEWITHDELTA.AVAILPHYSICAL),
                    SUM(WHSINVENTRESERVEWITHDELTA.AVAILORDERED),
                    NULL,
                    NULL,
                    @LEVEL,
                    INVENTDIM.CONFIGID,
                    INVENTDIM.INVENTSIZEID,
                    INVENTDIM.INVENTCOLORID,
                    INVENTDIM.INVENTSTYLEID,
                    INVENTDIM.INVENTVERSIONID,
                    CASE WHEN @LEVEL + -1 >= @INVENTSITEIDLEVEL THEN INVENTDIM.INVENTSITEID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTLOCATIONIDLEVEL THEN INVENTDIM.INVENTLOCATIONID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @WMSLOCATIONIDLEVEL THEN INVENTDIM.WMSLOCATIONID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTSTATUSIDLEVEL THEN INVENTDIM.INVENTSTATUSID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @LICENSEPLATEIDLEVEL THEN INVENTDIM.LICENSEPLATEID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTBATCHIDLEVEL THEN INVENTDIM.INVENTBATCHID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTSERIALIDLEVEL THEN INVENTDIM.INVENTSERIALID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTPROFILEID_RULEVEL THEN INVENTDIM.INVENTPROFILEID_RU ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTOWNERID_RULEVEL THEN INVENTDIM.INVENTOWNERID_RU ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTGTDID_RULEVEL THEN INVENTDIM.INVENTGTDID_RU ELSE NULL END
                    FROM if_WHSInventReserveUnionDelta(@TTSId) WHSINVENTRESERVEWITHDELTA
                    JOIN INVENTDIM ON INVENTDIM.INVENTDIMID = WHSINVENTRESERVEWITHDELTA.INVENTDIMID AND INVENTDIM.DATAAREAID = WHSINVENTRESERVEWITHDELTA.DATAAREAID AND INVENTDIM.PARTITION = WHSINVENTRESERVEWITHDELTA.PARTITION
                    WHERE WHSINVENTRESERVEWITHDELTA.ITEMID           = @ITEMID
                        AND WHSINVENTRESERVEWITHDELTA.PARTITION      = @PARTITION
                        AND WHSINVENTRESERVEWITHDELTA.DATAAREAID     = @DATAAREAID
                        AND WHSINVENTRESERVEWITHDELTA.HIERARCHYLEVEL = @LEVEL
                        AND (@CONFIGID IS NULL OR INVENTDIM.CONFIGID = @CONFIGID)
                        AND (@INVENTSIZEID IS NULL OR INVENTDIM.INVENTSIZEID = @INVENTSIZEID)
                        AND (@INVENTCOLORID IS NULL OR INVENTDIM.INVENTCOLORID = @INVENTCOLORID)
                        AND (@INVENTSTYLEID IS NULL OR INVENTDIM.INVENTSTYLEID = @INVENTSTYLEID)
                        AND (@INVENTVERSIONID IS NULL OR INVENTDIM.INVENTVERSIONID = @INVENTVERSIONID)
                        AND (1 = CASE WHEN @LEVEL >= @INVENTSITEIDLEVEL AND @INVENTSITEID is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTSITEID = CASE WHEN @LEVEL >= @INVENTSITEIDLEVEL THEN @INVENTSITEID ELSE '' END)
                        AND (1 = CASE WHEN @LEVEL >= @INVENTLOCATIONIDLEVEL AND @INVENTLOCATIONID is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTLOCATIONID = CASE WHEN @LEVEL >= @INVENTLOCATIONIDLEVEL THEN @INVENTLOCATIONID ELSE '' END)
                        AND (1 = CASE WHEN @LEVEL >= @WMSLOCATIONIDLEVEL AND @WMSLOCATIONID is null THEN 1 ELSE 0 END OR INVENTDIM.WMSLOCATIONID = CASE WHEN @LEVEL >= @WMSLOCATIONIDLEVEL THEN @WMSLOCATIONID ELSE '' END)
                        AND (1 = CASE WHEN @LEVEL >= @INVENTSTATUSIDLEVEL AND @INVENTSTATUSID is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTSTATUSID = CASE WHEN @LEVEL >= @INVENTSTATUSIDLEVEL THEN @INVENTSTATUSID ELSE '' END)
                        AND (1 = CASE WHEN @LEVEL >= @LICENSEPLATEIDLEVEL AND @LICENSEPLATEID is null THEN 1 ELSE 0 END OR INVENTDIM.LICENSEPLATEID = CASE WHEN @LEVEL >= @LICENSEPLATEIDLEVEL THEN @LICENSEPLATEID ELSE '' END)
                        AND (1 = CASE WHEN @LEVEL >= @INVENTBATCHIDLEVEL AND @INVENTBATCHID is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTBATCHID = CASE WHEN @LEVEL >= @INVENTBATCHIDLEVEL THEN @INVENTBATCHID ELSE '' END)
                        AND (1 = CASE WHEN @LEVEL >= @INVENTSERIALIDLEVEL AND @INVENTSERIALID is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTSERIALID = CASE WHEN @LEVEL >= @INVENTSERIALIDLEVEL THEN @INVENTSERIALID ELSE '' END)
                        AND (1 = CASE WHEN @LEVEL >= @INVENTPROFILEID_RULEVEL AND @INVENTPROFILEID_RU is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTPROFILEID_RU = CASE WHEN @LEVEL >= @INVENTPROFILEID_RULEVEL THEN @INVENTPROFILEID_RU ELSE '' END)
                        AND (1 = CASE WHEN @LEVEL >= @INVENTOWNERID_RULEVEL AND @INVENTOWNERID_RU is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTOWNERID_RU = CASE WHEN @LEVEL >= @INVENTOWNERID_RULEVEL THEN @INVENTOWNERID_RU ELSE '' END)
                        AND (1 = CASE WHEN @LEVEL >= @INVENTGTDID_RULEVEL AND @INVENTGTDID_RU is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTGTDID_RU = CASE WHEN @LEVEL >= @INVENTGTDID_RULEVEL THEN @INVENTGTDID_RU ELSE '' END)
                GROUP BY
                    INVENTDIM.CONFIGID,
                    INVENTDIM.INVENTSIZEID,
                    INVENTDIM.INVENTCOLORID,
                    INVENTDIM.INVENTSTYLEID,
                    INVENTDIM.INVENTVERSIONID,
                    CASE WHEN @LEVEL + -1 >= @INVENTSITEIDLEVEL THEN INVENTDIM.INVENTSITEID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTLOCATIONIDLEVEL THEN INVENTDIM.INVENTLOCATIONID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @WMSLOCATIONIDLEVEL THEN INVENTDIM.WMSLOCATIONID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTSTATUSIDLEVEL THEN INVENTDIM.INVENTSTATUSID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @LICENSEPLATEIDLEVEL THEN INVENTDIM.LICENSEPLATEID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTBATCHIDLEVEL THEN INVENTDIM.INVENTBATCHID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTSERIALIDLEVEL THEN INVENTDIM.INVENTSERIALID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTPROFILEID_RULEVEL THEN INVENTDIM.INVENTPROFILEID_RU ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTOWNERID_RULEVEL THEN INVENTDIM.INVENTOWNERID_RU ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTGTDID_RULEVEL THEN INVENTDIM.INVENTGTDID_RU ELSE NULL END
                    OPTION(FORCE ORDER, LOOP JOIN);

                WHILE (@LEVEL > @UPPERLEVELOFMINIMUMCALCULATION)
                BEGIN
                    INSERT INTO @RESULT (AVAILPHYSICALRESULT, AVAILORDEREDRESULT, AVAILPHYSICALFOUND, AVAILORDEREDFOUND, HIERARCHYLEVEL, CONFIGID, INVENTSIZEID, INVENTCOLORID, INVENTSTYLEID, INVENTVERSIONID, INVENTSITEID, INVENTLOCATIONID, WMSLOCATIONID, INVENTSTATUSID, LICENSEPLATEID, INVENTBATCHID, INVENTSERIALID, INVENTPROFILEID_RU, INVENTOWNERID_RU, INVENTGTDID_RU)
                SELECT SUM(CASE WHEN RESULT.AVAILPHYSICALFOUND < RESULT.AVAILPHYSICALRESULT THEN RESULT.AVAILPHYSICALFOUND ELSE RESULT.AVAILPHYSICALRESULT END),
                    SUM(CASE WHEN RESULT.AVAILORDEREDFOUND < RESULT.AVAILORDEREDRESULT THEN RESULT.AVAILORDEREDFOUND ELSE RESULT.AVAILORDEREDRESULT END),
                    SUM(FOUND.AVAILPHYSICAL),
                    SUM(FOUND.AVAILORDERED),
                    @LEVEL + -1,
                    RESULT.CONFIGID AS CONFIGID,
                    RESULT.INVENTSIZEID AS INVENTSIZEID,
                    RESULT.INVENTCOLORID AS INVENTCOLORID,
                    RESULT.INVENTSTYLEID AS INVENTSTYLEID,
                    RESULT.INVENTVERSIONID AS INVENTVERSIONID,
                    CASE WHEN @LEVEL + -1 >= @INVENTSITEIDLEVEL THEN RESULT.INVENTSITEID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTLOCATIONIDLEVEL THEN RESULT.INVENTLOCATIONID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @WMSLOCATIONIDLEVEL THEN RESULT.WMSLOCATIONID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTSTATUSIDLEVEL THEN RESULT.INVENTSTATUSID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @LICENSEPLATEIDLEVEL THEN RESULT.LICENSEPLATEID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTBATCHIDLEVEL THEN RESULT.INVENTBATCHID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTSERIALIDLEVEL THEN RESULT.INVENTSERIALID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTPROFILEID_RULEVEL THEN RESULT.INVENTPROFILEID_RU ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTOWNERID_RULEVEL THEN RESULT.INVENTOWNERID_RU ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTGTDID_RULEVEL THEN RESULT.INVENTGTDID_RU ELSE NULL END
                FROM @RESULT RESULT
                LEFT OUTER JOIN (
                SELECT SUM(WHSINVENTRESERVEWITHDELTA.AVAILPHYSICAL) AS AVAILPHYSICAL,
                    SUM(WHSINVENTRESERVEWITHDELTA.AVAILORDERED) AS AVAILORDERED,
                    INVENTDIM.CONFIGID AS CONFIGID,
                    INVENTDIM.INVENTSIZEID AS INVENTSIZEID,
                    INVENTDIM.INVENTCOLORID AS INVENTCOLORID,
                    INVENTDIM.INVENTSTYLEID AS INVENTSTYLEID,
                    INVENTDIM.INVENTVERSIONID AS INVENTVERSIONID,
                    CASE WHEN @LEVEL + -1 >= @INVENTSITEIDLEVEL THEN INVENTDIM.INVENTSITEID ELSE NULL END AS INVENTSITEID,
                    CASE WHEN @LEVEL + -1 >= @INVENTLOCATIONIDLEVEL THEN INVENTDIM.INVENTLOCATIONID ELSE NULL END AS INVENTLOCATIONID,
                    CASE WHEN @LEVEL + -1 >= @WMSLOCATIONIDLEVEL THEN INVENTDIM.WMSLOCATIONID ELSE NULL END AS WMSLOCATIONID,
                    CASE WHEN @LEVEL + -1 >= @INVENTSTATUSIDLEVEL THEN INVENTDIM.INVENTSTATUSID ELSE NULL END AS INVENTSTATUSID,
                    CASE WHEN @LEVEL + -1 >= @LICENSEPLATEIDLEVEL THEN INVENTDIM.LICENSEPLATEID ELSE NULL END AS LICENSEPLATEID,
                    CASE WHEN @LEVEL + -1 >= @INVENTBATCHIDLEVEL THEN INVENTDIM.INVENTBATCHID ELSE NULL END AS INVENTBATCHID,
                    CASE WHEN @LEVEL + -1 >= @INVENTSERIALIDLEVEL THEN INVENTDIM.INVENTSERIALID ELSE NULL END AS INVENTSERIALID,
                    CASE WHEN @LEVEL + -1 >= @INVENTPROFILEID_RULEVEL THEN INVENTDIM.INVENTPROFILEID_RU ELSE NULL END AS INVENTPROFILEID_RU,
                    CASE WHEN @LEVEL + -1 >= @INVENTOWNERID_RULEVEL THEN INVENTDIM.INVENTOWNERID_RU ELSE NULL END AS INVENTOWNERID_RU,
                    CASE WHEN @LEVEL + -1 >= @INVENTGTDID_RULEVEL THEN INVENTDIM.INVENTGTDID_RU ELSE NULL END AS INVENTGTDID_RU
                FROM if_WHSInventReserveUnionDelta(@TTSId) WHSINVENTRESERVEWITHDELTA
                JOIN INVENTDIM ON INVENTDIM.PARTITION = WHSINVENTRESERVEWITHDELTA.PARTITION
                    AND INVENTDIM.DATAAREAID  = WHSINVENTRESERVEWITHDELTA.DATAAREAID
                    AND INVENTDIM.INVENTDIMID = WHSINVENTRESERVEWITHDELTA.INVENTDIMID
                WHERE WHSINVENTRESERVEWITHDELTA.HIERARCHYLEVEL = @LEVEL + -1
                    AND WHSINVENTRESERVEWITHDELTA.ITEMID       = @ITEMID
                    AND WHSINVENTRESERVEWITHDELTA.PARTITION    = @PARTITION
                    AND WHSINVENTRESERVEWITHDELTA.DATAAREAID   = @DATAAREAID
                        AND (@CONFIGID IS NULL OR INVENTDIM.CONFIGID = @CONFIGID)
                        AND (@INVENTSIZEID IS NULL OR INVENTDIM.INVENTSIZEID = @INVENTSIZEID)
                        AND (@INVENTCOLORID IS NULL OR INVENTDIM.INVENTCOLORID = @INVENTCOLORID)
                        AND (@INVENTSTYLEID IS NULL OR INVENTDIM.INVENTSTYLEID = @INVENTSTYLEID)
                        AND (@INVENTVERSIONID IS NULL OR INVENTDIM.INVENTVERSIONID = @INVENTVERSIONID)
                        AND (1 = CASE WHEN @LEVEL + -1 >= @INVENTSITEIDLEVEL AND @INVENTSITEID is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTSITEID = CASE WHEN @LEVEL + -1 >= @INVENTSITEIDLEVEL THEN @INVENTSITEID ELSE '' END)
                        AND (1 = CASE WHEN @LEVEL + -1 >= @INVENTLOCATIONIDLEVEL AND @INVENTLOCATIONID is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTLOCATIONID = CASE WHEN @LEVEL + -1 >= @INVENTLOCATIONIDLEVEL THEN @INVENTLOCATIONID ELSE '' END)
                        AND (1 = CASE WHEN @LEVEL + -1 >= @WMSLOCATIONIDLEVEL AND @WMSLOCATIONID is null THEN 1 ELSE 0 END OR INVENTDIM.WMSLOCATIONID = CASE WHEN @LEVEL + -1 >= @WMSLOCATIONIDLEVEL THEN @WMSLOCATIONID ELSE '' END)
                        AND (1 = CASE WHEN @LEVEL + -1 >= @INVENTSTATUSIDLEVEL AND @INVENTSTATUSID is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTSTATUSID = CASE WHEN @LEVEL + -1 >= @INVENTSTATUSIDLEVEL THEN @INVENTSTATUSID ELSE '' END)
                        AND (1 = CASE WHEN @LEVEL + -1 >= @LICENSEPLATEIDLEVEL AND @LICENSEPLATEID is null THEN 1 ELSE 0 END OR INVENTDIM.LICENSEPLATEID = CASE WHEN @LEVEL + -1 >= @LICENSEPLATEIDLEVEL THEN @LICENSEPLATEID ELSE '' END)
                        AND (1 = CASE WHEN @LEVEL + -1 >= @INVENTBATCHIDLEVEL AND @INVENTBATCHID is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTBATCHID = CASE WHEN @LEVEL + -1 >= @INVENTBATCHIDLEVEL THEN @INVENTBATCHID ELSE '' END)
                        AND (1 = CASE WHEN @LEVEL + -1 >= @INVENTSERIALIDLEVEL AND @INVENTSERIALID is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTSERIALID = CASE WHEN @LEVEL + -1 >= @INVENTSERIALIDLEVEL THEN @INVENTSERIALID ELSE '' END)
                        AND (1 = CASE WHEN @LEVEL + -1 >= @INVENTPROFILEID_RULEVEL AND @INVENTPROFILEID_RU is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTPROFILEID_RU = CASE WHEN @LEVEL + -1 >= @INVENTPROFILEID_RULEVEL THEN @INVENTPROFILEID_RU ELSE '' END)
                        AND (1 = CASE WHEN @LEVEL + -1 >= @INVENTOWNERID_RULEVEL AND @INVENTOWNERID_RU is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTOWNERID_RU = CASE WHEN @LEVEL + -1 >= @INVENTOWNERID_RULEVEL THEN @INVENTOWNERID_RU ELSE '' END)
                        AND (1 = CASE WHEN @LEVEL + -1 >= @INVENTGTDID_RULEVEL AND @INVENTGTDID_RU is null THEN 1 ELSE 0 END OR INVENTDIM.INVENTGTDID_RU = CASE WHEN @LEVEL + -1 >= @INVENTGTDID_RULEVEL THEN @INVENTGTDID_RU ELSE '' END)
                GROUP BY
                    INVENTDIM.CONFIGID,
                    INVENTDIM.INVENTSIZEID,
                    INVENTDIM.INVENTCOLORID,
                    INVENTDIM.INVENTSTYLEID,
                    INVENTDIM.INVENTVERSIONID,
                    CASE WHEN @LEVEL + -1 >= @INVENTSITEIDLEVEL THEN INVENTDIM.INVENTSITEID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTLOCATIONIDLEVEL THEN INVENTDIM.INVENTLOCATIONID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @WMSLOCATIONIDLEVEL THEN INVENTDIM.WMSLOCATIONID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTSTATUSIDLEVEL THEN INVENTDIM.INVENTSTATUSID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @LICENSEPLATEIDLEVEL THEN INVENTDIM.LICENSEPLATEID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTBATCHIDLEVEL THEN INVENTDIM.INVENTBATCHID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTSERIALIDLEVEL THEN INVENTDIM.INVENTSERIALID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTPROFILEID_RULEVEL THEN INVENTDIM.INVENTPROFILEID_RU ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTOWNERID_RULEVEL THEN INVENTDIM.INVENTOWNERID_RU ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTGTDID_RULEVEL THEN INVENTDIM.INVENTGTDID_RU ELSE NULL END
                    ) AS FOUND ON (RESULT.CONFIGID = FOUND.CONFIGID)
                        AND (RESULT.INVENTSIZEID = FOUND.INVENTSIZEID)
                        AND (RESULT.INVENTCOLORID = FOUND.INVENTCOLORID)
                        AND (RESULT.INVENTSTYLEID = FOUND.INVENTSTYLEID)
                        AND (RESULT.INVENTVERSIONID = FOUND.INVENTVERSIONID)
                        AND (@LEVEL + -1 < @INVENTSITEIDLEVEL OR RESULT.INVENTSITEID = FOUND.INVENTSITEID)
                        AND (@LEVEL + -1 < @INVENTLOCATIONIDLEVEL OR RESULT.INVENTLOCATIONID = FOUND.INVENTLOCATIONID)
                        AND (@LEVEL + -1 < @WMSLOCATIONIDLEVEL OR RESULT.WMSLOCATIONID = FOUND.WMSLOCATIONID)
                        AND (@LEVEL + -1 < @INVENTSTATUSIDLEVEL OR RESULT.INVENTSTATUSID = FOUND.INVENTSTATUSID)
                        AND (@LEVEL + -1 < @LICENSEPLATEIDLEVEL OR RESULT.LICENSEPLATEID = FOUND.LICENSEPLATEID)
                        AND (@LEVEL + -1 < @INVENTBATCHIDLEVEL OR RESULT.INVENTBATCHID = FOUND.INVENTBATCHID)
                        AND (@LEVEL + -1 < @INVENTSERIALIDLEVEL OR RESULT.INVENTSERIALID = FOUND.INVENTSERIALID)
                        AND (@LEVEL + -1 < @INVENTPROFILEID_RULEVEL OR RESULT.INVENTPROFILEID_RU = FOUND.INVENTPROFILEID_RU)
                        AND (@LEVEL + -1 < @INVENTOWNERID_RULEVEL OR RESULT.INVENTOWNERID_RU = FOUND.INVENTOWNERID_RU)
                        AND (@LEVEL + -1 < @INVENTGTDID_RULEVEL OR RESULT.INVENTGTDID_RU = FOUND.INVENTGTDID_RU)
                WHERE RESULT.HIERARCHYLEVEL = @LEVEL
                GROUP BY
                    RESULT.CONFIGID,
                    RESULT.INVENTSIZEID,
                    RESULT.INVENTCOLORID,
                    RESULT.INVENTSTYLEID,
                    RESULT.INVENTVERSIONID,
                    CASE WHEN @LEVEL + -1 >= @INVENTSITEIDLEVEL THEN RESULT.INVENTSITEID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTLOCATIONIDLEVEL THEN RESULT.INVENTLOCATIONID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @WMSLOCATIONIDLEVEL THEN RESULT.WMSLOCATIONID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTSTATUSIDLEVEL THEN RESULT.INVENTSTATUSID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @LICENSEPLATEIDLEVEL THEN RESULT.LICENSEPLATEID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTBATCHIDLEVEL THEN RESULT.INVENTBATCHID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTSERIALIDLEVEL THEN RESULT.INVENTSERIALID ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTPROFILEID_RULEVEL THEN RESULT.INVENTPROFILEID_RU ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTOWNERID_RULEVEL THEN RESULT.INVENTOWNERID_RU ELSE NULL END,
                    CASE WHEN @LEVEL + -1 >= @INVENTGTDID_RULEVEL THEN RESULT.INVENTGTDID_RU ELSE NULL END
                OPTION(FORCE ORDER, LOOP JOIN);

                    SET @LEVEL = @LEVEL - 1
                END; -- WHILE

                SELECT @AVAILPHYSICAL = SUM(CASE WHEN AVAILPHYSICALFOUND < AVAILPHYSICALRESULT THEN AVAILPHYSICALFOUND ELSE AVAILPHYSICALRESULT END),
                    @AVAILORDERED = SUM(CASE WHEN AVAILORDEREDFOUND < AVAILORDEREDRESULT THEN AVAILORDEREDFOUND ELSE AVAILORDEREDRESULT END)
                FROM @RESULT
                WHERE HIERARCHYLEVEL = @UPPERLEVELOFMINIMUMCALCULATION;

                GO
        */

        ret += strFmt('CREATE PROCEDURE [%1]\n', WhsOnHandSPHelper::storedProcedureName(_includeDelta, _includeCW, _joinInventDim));
        ret +=        '    @PARTITION bigint,\n';
        ret += strFmt('    %1 int,\n', this.levelExpression(0));
        ret += strFmt('    %1 int,\n', UpperLevelOfMinimumCalculationParamName);
        ret += strFmt('    @DATAAREAID %1,\n', this.sqlTypeNameForField(tableNum(InventTable), fieldNum(InventTable, DataAreaId)));
        ret += strFmt('    @ITEMID %1,\n', this.sqlTypeNameForField(tableNum(InventTable), fieldNum(InventTable, ItemId)));
        if (_includeDelta)
        {
            ret += strFmt('    %1 %2,\n', TTSIdParmName, this.sqlTypeNameForField(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, TTSId)));
        }

        // Generate parameters for supported dimensions
        enabledStorageAndTrancingDimensionEnumerator.reset();
        while (enabledStorageAndTrancingDimensionEnumerator.moveNext())
        {
            [dimFieldId, dimFieldName] = enabledStorageAndTrancingDimensionEnumerator.current();
            if (_joinInventDim)
            {
                ret += strFmt('    %1 %2 = NULL,\n', this.dimensionParm(dimFieldName), this.sqlTypeNameForField(tableNum(InventDim), dimFieldId));
            }
            else
            {
                ret += strFmt('    %1 %2 = NULL,\n', this.dimensionParm(dimFieldName), this.sqlTypeNameForField(tableNum(WHSInventReserve), InventDim::dim2WHSInventReserveDim(dimFieldId)));
            }
            ret += strFmt('    %1 int = %2,\n', this.dimensionLevelParm(dimFieldName), #INVALIDHIERARCHYLEVEL);
        }

        // Generate parameters for product dimensions
        enabledProductDimensionEnumerator.reset();
        while (enabledProductDimensionEnumerator.moveNext())
        {
            [dimFieldId, dimFieldName] = enabledProductDimensionEnumerator.current();
            if (_joinInventDim)
            {
                ret += strFmt('    %1 %2 = NULL,\n', this.dimensionParm(dimFieldName), this.sqlTypeNameForField(tableNum(InventDim), dimFieldId));
            }
            else
            {
                ret += strFmt('    %1 %2 = NULL,\n', this.dimensionParm(dimFieldName), this.sqlTypeNameForField(tableNum(WHSInventReserve), InventDim::dim2WHSInventReserveDim(dimFieldId)));
            }
        }

        ret +=        '    -- Output parameters\n';
        ret += strFmt('    %1  %2 OUTPUT,\n', AvailPhysicalParmName, this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, AvailPhysical)));
        ret += strFmt('    %1  %2 OUTPUT\n', AvailOrderedParmName, this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventreserve, AvailOrdered)));
        
        if (_includeCW)
        {
            ret += strFmt('   , %1  %2 OUTPUT,\n', CWAvailPhysicalParmName, this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, CWAvailPhysical)));
            ret += strFmt('    %1  %2 OUTPUT\n', CWAvailOrderedParmName, this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventreserve, CWAvailOrdered)));
        }
        ret +=        'AS\n\n';

        ret +=        '-- Without nocount on the procedure will return number of affected rows in the result set which is\n';
        ret +=        '-- harmful to performance and requires us to adjust field retrieval when calling the stored procedure\n';
        ret +=        'SET NOCOUNT ON;\n\n';

        ret +=        '-- We need to suppress warnings when trying to aggregate NULL columns. This is a valid business scenario\n';
        ret +=        '-- and happens e.g. for a non-LP controlled location with batch below item.\n';
        ret +=        'SET ANSI_WARNINGS OFF;\n\n';

        ret += this.declareResultTableVariable(_includeDelta, _includeCW, _joinInventDim) + '\n';

        ret +=        '-- The algorithm of the stored procedure is as follows:\n';
        ret +=        '-- 1. Initialize the @RESULT table with aggregated qtys in WHSInventReserve for the level requested by user\n';
        ret +=        '-- 2. Traverse the hierarchy up and for each level:\n';
        ret +=        '--     1) Aggregate qtys from previous level in @RESULT grouping by dimensions of current hierarchy level\n';
        ret +=        '--     2) Aggregate qtys from current level in WHSInventReserve grouping by dimensions of current hierarchy level\n';
        ret +=        '--     3) Select the minimum of the above qtys and insert into @RESULT\n';
        ret +=        '-- 3. When hierarchy level 0 is reached, return the sum of aggregated qtys in @RESULT\n\n';

        ret +=        '-- Initialize the @RESULT variable.\n';
        ret +=        '-- Loads aggregated data for the lowest level requested by user.\n';
        ret +=        'INSERT INTO @RESULT (' + this.resultTableVariableFields(_includeDelta, _includeCW, _joinInventDim) + ')\n';

        ret += this.selectFromWHSInventReserveStmt(_includeDelta, _includeCW, _joinInventDim) + '\n';

        ret += strFmt('WHILE (%1 > %2)\n', this.levelExpression(0), UpperLevelOfMinimumCalculationParamName);
        ret +=        'BEGIN\n';

        ret += strFmt('    INSERT INTO @RESULT (%1)\n', this.resultTableVariableFields(_includeDelta, _includeCW, _joinInventDim));

        ret += this.selectFromResultJoinWHSInventReserveStmt(_includeDelta, _includeCW, _joinInventDim) + '\n\n';

        ret += strFmt('    SET %1 = %1 - 1\n', this.levelExpression(0));
        ret +=        'END; -- WHILE\n\n';

        ret += strFmt('SELECT %1 = SUM(CASE WHEN %2 < %3 THEN %2 ELSE %3 END),\n',
                        AvailPhysicalParmName,
                        AvailPhysicalFoundFieldName,
                        AvailPhysicalResultFieldName);
        ret += strFmt('    %1 = SUM(CASE WHEN %2 < %3 THEN %2 ELSE %3 END)\n',
                        AvailOrderedParmName,
                        AvailOrderedFoundFieldName,
                        AvailOrderedResultFieldName);

        if (_includeCW)
        {
            ret += strFmt(', %1 = SUM(CASE WHEN %2 < %3 THEN %2 ELSE %3 END),\n',
                        CWAvailPhysicalParmName,
                        CWAvailPhysicalFoundFieldName,
                        CWAvailPhysicalResultFieldName);
            
            ret += strFmt(' %1 = SUM(CASE WHEN %2 < %3 THEN %2 ELSE %3 END)\n',
                        CWAvailOrderedParmName,
                        CWAvailOrderedFoundFieldName,
                        CWAvailOrderedResultFieldName);
        }

        ret +=        'FROM @RESULT\n';
        ret += strFmt('WHERE %1 = %2;\n', HierarchyLevelFieldName, UpperLevelOfMinimumCalculationParamName);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>WHSOnHandUnionAllDeltaTVFName</Name>
				<Source><![CDATA[
    private static str WHSOnHandUnionAllDeltaTVFName(boolean _includeCWFields, boolean _joinInventDim)
    {
        if (_joinInventDim)
        {
            return (_includeCWFields) ? WHSOnHandUnionAllDeltaTVFCatchWeight : #WHSOnHandUnionAllDeltaTVF;
        }

        return (_includeCWFields) ? WHSOnHandUnionAllDeltaWithInventDimTVFCatchWeight : WHSOnHandUnionAllDeltaWithInventDimTVF;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCreateTVFOnHandUnionAllDeltaSqlStmt</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal str buildCreateTVFOnHandUnionAllDeltaSqlStmt(boolean _includeCWFields, boolean _joinInventDim)
    {
        SysDictTable dictTableWHSInventReserve;
        SysDictTable dictTableWHSInventReserveDelta;

        str ret = '';

        /* NON CATCH WEIGHT VERSION
    CREATE FUNCTION [if_WHSInventReserveUnionAllDelta] (
            @TTSId bigint
    )
    RETURNS TABLE
    AS
    RETURN
        SELECT
            Partition,
            DataAreaId,
            ItemId,
            InventDimId,
            HierarchyLevel,
            AvailPhysical,
            AvailOrdered,
            ReservPhysical,
            ReservOrdered
        FROM WHSInventReserve
        UNION ALL
        SELECT
            Partition,
            DataAreaId,
            ItemId,
            InventDimId,
            HierarchyLevel,
            AvailPhysical,
            AvailOrdered,
            ReservPhysical,
            ReservOrdered
        FROM WHSINVENTRESERVEDELTA
            WHERE TTSId = @TTSId
        */

        dictTableWHSInventReserve = new SysDictTable(tableNum(WHSInventReserve));
        dictTableWHSInventReserveDelta = new SysDictTable(tableNum(WHSInventReserveDelta));

        boolean addDimensionFields = !_joinInventDim;

        ret += strFmt('CREATE FUNCTION [%1] (\n', WhsOnHandSPHelper::WHSOnHandUnionAllDeltaTVFName(_includeCWFields, _joinInventDim));
        ret += '    @TTSId bigint\n';
        ret += ')\n';
        ret += 'RETURNS TABLE\n';
        ret += 'AS\n';
        ret += 'RETURN\n';
        ret += '    SELECT\n';
        ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, Partition)));
        ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, DataAreaId)));
        ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, ItemId)));
        ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, InventDimId)));

        ListEnumerator  enabledDimensionEnumerator;
        FieldId         dimFieldId;
        str             dimFieldName;
        
        if (addDimensionFields)
        {
            InventDimMetaDataCache::clearCache(); //in some cases the cache is not updated before sync making below SP

            enabledDimensionEnumerator = this.allEnabledDimensions().getEnumerator();

            enabledDimensionEnumerator.reset();
            while (enabledDimensionEnumerator.moveNext())
            {
                [dimFieldId, dimFieldName] = enabledDimensionEnumerator.current();
                ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserve), InventDim::dim2WHSInventReserveDim(dimFieldId)));
            }
        }

        ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, HierarchyLevel)));
        ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, AvailPhysical)));
        ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, AvailOrdered)));
        ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, ReservPhysical)));
        ret += strFmt('        %1\n', this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, ReservOrdered)));

        if (_includeCWFields)
        {
            ret += strFmt('        ,%1,\n', this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, CWAvailPhysical)));
            ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, CWAvailOrdered)));
            ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, CWReservPhysical)));
            ret += strFmt('        %1\n', this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, CWReservOrdered)));
        }

        ret += strFmt('   FROM %1\n', this.sqlTableName(tableNum(WHSInventReserve)));
        ret += '    UNION ALL\n';
        ret += '    SELECT\n';
        ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, Partition)));
        ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, DataAreaId)));
        ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, ItemId)));
        ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, InventDimId)));

        if (addDimensionFields)
        {
            enabledDimensionEnumerator.reset();
            while (enabledDimensionEnumerator.moveNext())
            {
                [dimFieldId, dimFieldName] = enabledDimensionEnumerator.current();
                ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), InventDim::dim2WHSInventReserveDeltaDim(dimFieldId)));
            }
        }

        ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, HierarchyLevel)));
        ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, AvailPhysical)));
        ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, AvailOrdered)));
        ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, ReservPhysical)));
        ret += strFmt('        %1\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, ReservOrdered)));

        if (_includeCWFields)
        {
            ret += strFmt('        ,%1,\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, CWAvailPhysical)));
            ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, CWAvailOrdered)));
            ret += strFmt('        %1,\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, CWReservPhysical)));
            ret += strFmt('        %1\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, CWReservOrdered)));
        }

        ret += strFmt('   FROM %1\n', this.sqlTableName(tableNum(WHSInventReserveDelta)));
        ret += strFmt('   WHERE %1 = @TTSId\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, ttsId)));

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSPCallParameters</Name>
				<Source><![CDATA[
    private WHSQueryWithParametersValues buildSPCallParameters(
        InventTable                     _inventTable,
        InventDim                       _inventDimCriteria,
        InventDimParm                   _inventDimParm,
        WHSReservationHierarchyLevel    _level,
        str                             _statement = '',
        Map                             _paramMap = SqlParams::create())
    {
        ListEnumerator                      le;
        MapEnumerator                       mapEnumerator;
        WHSReservationHierarchyElementData  elementData;
        FieldId                             dimFieldId;
        WHSReservationHierarchyLevel        dimFieldLevel;
        Map                                 parametersMap = this.getEnabledDimsParametersMap();
        SysSqlSystem                        sqlSystem = new SysSqlSystem();
        str                                 sqlParm;
        str                                 sqlParmLevel;

        boolean isExecuteWithParamsFlightEnabled = WHSExecuteWithParametersV3Flight::instance().isEnabled();
        // Add parameters for reservation hierarchy dimensions
        le = WHSReservationHierarchyProvider::construct()
                .getDimListAllFromInventTable(_inventTable, WHSReservationHierarchySortOrder::TopDown)
                .getEnumerator();
        int i = 0;
        while (le.moveNext())
        {
            elementData = le.current();
            dimFieldId = elementData.parmDimensionFieldId();
            dimFieldLevel = elementData.parmLevel();
            [sqlParm, sqlParmLevel] = parametersMap.lookup(dimFieldId);

            if (isExecuteWithParamsFlightEnabled)
            {
                // Add invent dim criteria only for requested levels
                if (_inventDimCriteria.(dimFieldId)
                && _inventDimParm.(InventDim::dim2dimParm(dimFieldId)))
                {
                    str inventParm = InventParmValue + int2Str(i);
                    _statement += strFmt(sqlParm, '@' + inventParm);
                    _paramMap.add(inventParm, _inventDimCriteria.(dimFieldId));
                }

                // Add invent dim parm for all levels in hierarchy
                str inventLevelParm = InventLevelParmValue + int2Str(i);
                _statement += strFmt(sqlParmLevel, '@' + inventLevelParm);
                _paramMap.add(inventLevelParm, dimFieldLevel);
            }
            else
            {
                // Add invent dim criteria only for requested levels
                if (_inventDimCriteria.(dimFieldId)
                && _inventDimParm.(InventDim::dim2dimParm(dimFieldId)))
                {
                    _statement += strFmt(sqlParm, sqlSystem.sqlLiteral(_inventDimCriteria.(dimFieldId), true));
                }

                // Add invent dim parm for all levels in hierarchy
                _statement += strFmt(sqlParmLevel, sqlSystem.sqlLiteral(dimFieldLevel, true));
            }
            if (elementData.parmLevel() == _level)
            {
                break;
            }
            i++;
        }

        // Add parameters for product dimensions
        if (_inventDimCriteria.anyProductDimensionSpecified())
        {
            i = 0;
            mapEnumerator = this.getProductDimsParametersMap().getEnumerator();
            while (mapEnumerator.moveNext())
            {
                dimFieldId = mapEnumerator.currentKey();
                if (_inventDimCriteria.(dimFieldId)
                    && _inventDimParm.(InventDim::dim2dimParm(dimFieldId)))
                {
                    if (isExecuteWithParamsFlightEnabled)
                    {
                        str inventDimParm = InventDimParmValue + int2Str(i);
                        _statement += strFmt(mapEnumerator.currentValue(), '@' + inventDimParm);
                        _paramMap.add(inventDimParm, _inventDimCriteria.(dimFieldId));
                        i++;
                    }
                    else
                    {
                        _statement += strFmt(mapEnumerator.currentValue(), sqlSystem.sqlLiteral(_inventDimCriteria.(dimFieldId), true));
                    }
                }
            }
        }

        return WHSQueryWithParametersValues::construct(_statement, _paramMap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>declareCWResultTableVariableFields</Name>
				<Source><![CDATA[
    private str declareCWResultTableVariableFields(boolean _initializeResultFields)
    {
        if (_initializeResultFields && cwResultTableVariableFields == '')
        {
            cwResultTableVariableFields += ' ' + CWAVAILPHYSICALRESULTFieldName;
            cwResultTableVariableFields += ', ' + CWAVAILORDEREDRESULTFieldName;
            cwResultTableVariableFields += ', ' + CWAVAILPHYSICALFOUNDFieldName;
            cwResultTableVariableFields += ', ' + CWAVAILORDEREDFOUNDFieldName;
        }

        return cwResultTableVariableFields;
    }

]]></Source>
			</Method>
			<Method>
				<Name>declareResultTableVariable</Name>
				<Source><![CDATA[
    private str declareResultTableVariable(
        boolean _includeDelta,
        boolean _includeCWFields,
        boolean _joinInventDim)
    {
        ListEnumerator  enabledProductDimensionEnumerator = this.enabledProductDimensions().getEnumerator();
        ListEnumerator  enabledStorageAndTrackingDimensionEnumerator = this.enabledStorageAndTrackingDimensions().getEnumerator();
        boolean         hasDoneFirstIteration;
        boolean         initializeResultFields;
        FieldId         dimFieldId;
        FieldName       dimFieldName;
        str             ret = '';

        resultTableVariableFields = '';
        
        initializeResultFields = true;
        
        resultTableVariableFields = strFmt('%1, %2, %3, %4, %5',
                                            AvailPhysicalResultFieldName,
                                            AvailOrderedResultFieldName,
                                            AvailPhysicalFoundFieldName,
                                            AvailOrderedFoundFieldName,
                                            HierarchyLevelFieldName);
        if (!_includeDelta)
        {
            resultTableVariableFields += strFmt(', %1', ParentInventDimIdFieldName);

            if (_includeCWFields)
            {
                resultTableVariableFields += ',';
                resultTableVariableFields += this.declareCWResultTableVariableFields(initializeResultFields);
            }
        }        

        ret += '-- The @RESULT table variable is used to store intermediate quantities.\n';
        ret += 'DECLARE @RESULT TABLE(\n';
        ret += strFmt('    %1 %2 NOT NULL, -- Aggregated minimum qtys from lower level in @RESULT\n', AvailPhysicalResultFieldName, this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, AvailPhysical)));
        ret += strFmt('    %1 %2 NOT NULL, -- Aggregated minimum qtys from lower level in @RESULT\n', AvailOrderedResultFieldName, this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, AvailOrdered)));
        ret += strFmt('    %1 %2, -- Aggregated qty for current level in WHSInventReserve\n', AvailPhysicalFoundFieldName, this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, AvailPhysical)));
        ret += strFmt('    %1 %2, -- Aggregated qty for current level in WHSInventReserve\n', AvailOrderedFoundFieldName, this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, AvailOrdered)));
        ret += strFmt('    %1 int NOT NULL,\n', HierarchyLevelFieldName);

        if (_includeDelta)
        {
            // Add product dimensions fields
            enabledProductDimensionEnumerator.reset();
            while (enabledProductDimensionEnumerator.moveNext())
            {
                [dimFieldId, dimFieldName] = enabledProductDimensionEnumerator.current();

                if (_joinInventDim)
                {
                    ret += strFmt('    %1 %2 NULL,\n', dimFieldName, this.sqlTypeNameForField(tableNum(InventDim), dimFieldId));
                }
                else
                {
                    ret += strFmt('    %1 %2 NULL,\n', dimFieldName, this.sqlTypeNameForField(tableNum(WHSInventReserve), InventDim::dim2WHSInventReserveDim(dimFieldId)));
                }

                if (initializeResultFields)
                {
                    resultTableVariableFields += strFmt(', %1', dimFieldName);
                }
            }

            // Add enabled dimensions fields
            enabledStorageAndTrackingDimensionEnumerator.reset();
            hasDoneFirstIteration = false;
            while (enabledStorageAndTrackingDimensionEnumerator.moveNext())
            {
                if (hasDoneFirstIteration)
                {
                    ret += ',\n';
                }

                [dimFieldId, dimFieldName] = enabledStorageAndTrackingDimensionEnumerator.current();
                if (_joinInventDim)
                {
                    ret += strFmt('    %1 %2 NULL', dimFieldName, this.sqlTypeNameForField(tableNum(InventDim), dimFieldId));
                }
                else
                {
                    ret += strFmt('    %1 %2 NULL', dimFieldName, this.sqlTypeNameForField(tableNum(WHSInventReserve), InventDim::dim2WHSInventReserveDim(dimFieldId)));
                }

                if (initializeResultFields)
                {
                    resultTableVariableFields += strFmt(', %1', dimFieldName);
                }

                hasDoneFirstIteration = true;
            }

            if (_includeCWFields)
            {
                resultTableVariableFields += ',';
                resultTableVariableFields += this.declareCWResultTableVariableFields(initializeResultFields);
            
                ret += ',\n';
                ret += strFmt('    %1 numeric(32, 16) NOT NULL, -- Aggregated minimum CW qtys from lower level in @RESULT\n', CWAVAILPHYSICALRESULTFieldName);
                ret += strFmt('    %1 numeric(32, 16) NOT NULL, -- Aggregated minimum CW qtys from lower level in @RESULT\n', CWAVAILORDEREDRESULTFieldName);
                ret += strFmt('    %1 numeric(32, 16), -- Aggregated CW qty for current level in WHSInventReserve\n', CWAVAILPHYSICALFOUNDFieldName);
                ret += strFmt('    %1 numeric(32, 16) -- Aggregated CW qty for current level in WHSInventReserve\n', CWAVAILORDEREDFOUNDFieldName);
            }
        }
        else 
        {
            ret += strFmt('    %1 %2 NOT NULL,\n', ParentInventDimIdFieldName, this.sqlTypeNameForField(tableNum(InventDim), fieldNum(InventDim, inventDimId)));
            
            if (_includeCWFields)
            {
                ret += strFmt('    %1 numeric(32, 16) NOT NULL, -- Aggregated minimum CW qtys from lower level in @RESULT\n', CWAVAILPHYSICALRESULTFieldName);
                ret += strFmt('    %1 numeric(32, 16) NOT NULL, -- Aggregated minimum CW qtys from lower level in @RESULT\n', CWAVAILORDEREDRESULTFieldName);
                ret += strFmt('    %1 numeric(32, 16), -- Aggregated CW qty for current level in WHSInventReserve\n', CWAVAILPHYSICALFOUNDFieldName);
                ret += strFmt('    %1 numeric(32, 16) -- Aggregated CW qty for current level in WHSInventReserve\n', CWAVAILORDEREDFOUNDFieldName);
           
                ret += ',\n';
            }

            ret += strFmt('    INDEX RESULTCLUSTEREDIDX CLUSTERED (%1, %2)', HierarchyLevelFieldName, ParentInventDimIdFieldName);
        }

        ret += ');\n';

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dimensionLevelParm</Name>
				<Source><![CDATA[
    private str dimensionLevelParm(str _name)
    {
        return strFmt('@%1LEVEL', _name);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dimensionParm</Name>
				<Source><![CDATA[
    private str dimensionParm(str _name)
    {
        return strFmt('@%1', _name);
    }

]]></Source>
			</Method>
			<Method>
				<Name>enabledStorageAndTrackingDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets a list of enabled storage and tracking dimensions.
    /// </summary>
    /// <returns>
    ///     <c>List</c> with dimensions entries in following form:
    ///     [
    ///         Field ID,
    ///         SQL field name
    ///     ]
    /// </returns>
    private List enabledStorageAndTrackingDimensions()
    {
        List            ret = new List(Types::Container);
        List            enabledStorageAndTrackingDimensions = new List(Types::Integer);
        FieldId         fieldId;
        ListEnumerator  le;

        enabledStorageAndTrackingDimensions.appendList(InventDimMetaDataCache::dimStorageDimEnabledFieldList());
        enabledStorageAndTrackingDimensions.appendList(InventDimMetaDataCache::dimTrackingDimEnabledFieldList());

        le = enabledStorageAndTrackingDimensions.getEnumerator();
        while (le.moveNext())
        {
            fieldId = le.current();

            ret.addEnd([
                        fieldId,
                        SysDictTable::fieldnameSQL(tableNum(InventDim), fieldId, FieldNameGenerationMode::FieldList)
                       ]);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateEnabledDimsParametersMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Generates a map of enabled dimensions to be used as
    ///     parameters of the stored procedure.
    /// </summary>
    /// <returns>
    ///     <c>Map</c> of dimensions in a following form:
    ///
    ///         FieldId => [
    ///                     '@parameter_name = %1,\n',
    ///                     '@parameter_nameLEVEL = %1,\n'
    ///                    ]
    /// </returns>
    private Map generateEnabledDimsParametersMap()
    {
        Map             map = new Map(Types::Integer, Types::Container);
        ListEnumerator  le;
        FieldId         dimFieldId;
        str             dimFieldName;

        le = this.enabledStorageAndTrackingDimensions().getEnumerator();
        while (le.moveNext())
        {
            [dimFieldId, dimFieldName] = le.current();
            map.insert(
                    dimFieldId,
                    [
                        strFmt('%1 = %2,\n', this.dimensionParm(dimFieldName), '%1'),
                        strFmt('%1 = %2,\n', this.dimensionLevelParm(dimFieldName), '%1')
                    ]);
        }

        return map;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateProductDimsParametersMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Generates a map of product dimensions to be used as
    ///     parameters of the stored procedure.
    /// </summary>
    /// <returns>
    ///     <c>Map</c> of dimensions in a following form:
    ///
    ///         FieldId => '@parameter_name = %1,\n'
    /// </returns>
    private Map generateProductDimsParametersMap()
    {
        Map             ret = new Map(Types::Integer, Types::String);
        FieldId         dimFieldId;
        FieldName       sqlFieldName;
        ListEnumerator  le = this.enabledProductDimensions().getEnumerator();

        while (le.moveNext())
        {
            [dimFieldId, sqlFieldName] = le.current();
            ret.insert(dimFieldId, strFmt('%1 = %2,\n', this.dimensionParm(sqlFieldName), '%1'));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEnabledDimsParametersMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves a cached map of enabled dimensions to be used as
    ///     parameters of the stored procedure.
    /// </summary>
    /// <returns>
    ///     <c>Map</c> of dimensions as returned by <c>generateEnabledDimsParametersMap</c>.
    /// </returns>
    private Map getEnabledDimsParametersMap()
    {
        Map                     ret;
        container               packedMap;
        SysGlobalCache          globalCache = classfactory.globalCache();
        SysGlobalObjectCache    globalObjectCache = classfactory.globalObjectCache();

        if (globalCache.isSet(CacheScope, EnabledDimsParametersCacheKey))
        {
            ret = globalCache.get(CacheScope, EnabledDimsParametersCacheKey);
        }
        else
        {
            packedMap = globalObjectCache.find(CacheScope, [EnabledDimsParametersCacheKey]);
            if (packedMap != conNull())
            {
                ret = Map::create(packedMap);
            }
            else
            {
                ret = this.generateEnabledDimsParametersMap();
                globalObjectCache.insert(CacheScope, [EnabledDimsParametersCacheKey], ret.pack());
            }

            globalCache.set(CacheScope, EnabledDimsParametersCacheKey, ret);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductDimsParametersMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves a cached map of product dimensions to be used as
    ///     parameters of the stored procedure.
    /// </summary>
    /// <returns>
    ///     <c>Map</c> of dimensions as returned by <c>generateProductDimsParametersMap</c>.
    /// </returns>
    private Map getProductDimsParametersMap()
    {
        Map                     ret;
        container               packedMap;
        SysGlobalCache          globalCache = classfactory.globalCache();
        SysGlobalObjectCache    globalObjectCache = classfactory.globalObjectCache();

        if (globalCache.isSet(CacheScope, ProductDimsParametersCacheKey))
        {
            ret = globalCache.get(CacheScope, ProductDimsParametersCacheKey);
        }
        else
        {
            packedMap = globalObjectCache.find(CacheScope, [ProductDimsParametersCacheKey]);
            if (packedMap != conNull())
            {
                ret = Map::create(packedMap);
            }
            else
            {
                ret = this.generateProductDimsParametersMap();
                globalObjectCache.insert(CacheScope, [ProductDimsParametersCacheKey], ret.pack());
            }

            globalCache.set(CacheScope, ProductDimsParametersCacheKey, ret);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>levelExpression</Name>
				<Source><![CDATA[
    private str levelExpression(int _levelDelta)
    {
        str ret = '@LEVEL';

        if (_levelDelta != 0)
        {
            ret += ' + ' + int2str(_levelDelta);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        hierarchyLevelFieldName = this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, HierarchyLevel));
        parentInventDimIdFieldName = this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, ParentInventDimId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>enabledProductDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets a list of enabled product dimensions.
    /// </summary>
    /// <returns>
    ///     <c>List</c> with dimensions entries in following form:
    ///     [
    ///         Field ID,
    ///         SQL field name
    ///     ]
    /// </returns>
    private List enabledProductDimensions()
    {
        List            ret = new List(Types::Container);
        ListEnumerator  le = InventDimMetaDataCache::dimProductDimEnabledFieldList().getEnumerator();
        FieldId         fieldId;

        while (le.moveNext())
        {
            fieldId = le.current();

            ret.addEnd([
                        fieldId,
                        SysDictTable::fieldnameSQL(tableNum(InventDim), fieldId, FieldNameGenerationMode::FieldList)
                       ]);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allEnabledDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets a list of enabled product, storage and tracking dimensions.
    /// </summary>
    /// <returns>
    ///     <c>List</c> with dimensions entries in following form:
    ///     [
    ///         Field ID,
    ///         SQL field name
    ///     ]
    /// </returns>
    private List allEnabledDimensions()
    {
        List enabledDimensions = this.enabledProductDimensions();

        enabledDimensions.appendList(this.enabledStorageAndTrackingDimensions());

        return enabledDimensions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resultTableVariableFields</Name>
				<Source><![CDATA[
    private str resultTableVariableFields(boolean _includeDelta, boolean _includeCW, boolean _joinInventDim)
    {
        if (resultTableVariableFields == '')
        {
            this.declareResultTableVariable(_includeDelta, _includeCW, _joinInventDim);
        }

        return resultTableVariableFields;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectFromResultJoinWHSInventReserveStmt</Name>
				<Source><![CDATA[
    private str selectFromResultJoinWHSInventReserveStmt(boolean _includeDelta, boolean _includeCW, boolean _joinInventDim)
    {
        if (!_includeDelta)
        {
            return this.selectFromResultJoinWHSInventReserveStmtNoDelta(_includeCW, _joinInventDim);
        }
        else 
        {
            return this.selectFromResultJoinWHSInventReserveStmtDelta(_includeCW, _joinInventDim);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectFromResultJoinWHSInventReserveStmtNoDelta</Name>
				<Source><![CDATA[
    private str selectFromResultJoinWHSInventReserveStmtNoDelta(boolean _includeCW, boolean _joinInventDim)
    {
        const str AggregatedResultAlias = 'RESULTAGGR';
        const str MinAvailPhysicalAlias = 'MINAVAILPHYSICAL';
        const str MinAvailOrderedAlias = 'MINAVAILORDERED';
        const str CWMinAvailPhysicalAlias = 'CWMINAVAILPHYSICAL';
        const str CWMinAvailOrderedAlias = 'CWMINAVAILORDERED';

        const str WhsInventReserveFoundAlias = 'FOUND';
        str inventDimIdFieldName = this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, InventDimId));
        str itemIdFieldName = this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, ItemId));
        str partitionFieldName = this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, Partition));
        str dataAreaIdFieldName = this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, DataAreaId));
        
        str ret = strFmt(' SELECT SUM(%1.%2),\n', AggregatedResultAlias,  MinAvailPhysicalAlias);
        ret    += strFmt('        SUM(%1.%2),\n', AggregatedResultAlias, MinAvailOrderedAlias);
        ret    += strFmt('        SUM(CASE WHEN %1.%2 = @Level + -1 THEN %1.%3 ELSE NULL END),\n', WhsInventReserveFoundAlias, hierarchyLevelFieldName, 'AVAILPHYSICAL');
        ret    += strFmt('        SUM(CASE WHEN %1.%2 = @Level + -1 THEN %1.%3 ELSE NULL END),\n', WhsInventReserveFoundAlias, hierarchyLevelFieldName, 'AVAILORDERED');
        ret    +=        '        @LEVEL + -1,\n';
        ret    += strFmt('        CASE WHEN %1.%2 = @LEVEL + -1 THEN %1.%3 ELSE %1.%4 END\n', WhsInventReserveFoundAlias, hierarchyLevelFieldName, parentInventDimIdFieldName, inventDimIdFieldName);
        
        if (_includeCW)
        {
            ret += ',\n';
            ret += strFmt('        SUM(%1.%2),\n', AggregatedResultAlias, CWMinAvailPhysicalAlias);
            ret += strFmt('        SUM(%1.%2),\n', AggregatedResultAlias, CWMinAvailOrderedAlias);
            ret += strFmt('        SUM(CASE WHEN %1.%2 = @Level + -1 THEN %1.%3 ELSE NULL END),\n', WhsInventReserveFoundAlias, hierarchyLevelFieldName, 'CWAVAILPHYSICAL');
            ret += strFmt('        SUM(CASE WHEN %1.%2 = @Level + -1 THEN %1.%3 ELSE NULL END)', WhsInventReserveFoundAlias, hierarchyLevelFieldName, 'CWAVAILORDERED');
        }
        ret    += strFmt(' FROM (SELECT SUM(CASE WHEN %1 < %2 THEN %1 ELSE %2 END) AS %3,\n', AvailPhysicalFoundFieldName, AvailPhysicalResultFieldName, MinAvailPhysicalAlias);
        ret    += strFmt('              SUM(CASE WHEN %1 < %2 THEN %1 ELSE %2 END) AS %3,\n', AvailOrderedFoundFieldName, AvailOrderedResultFieldName, MinAvailOrderedAlias);

        if (_includeCW)
        {
            ret += strFmt('              SUM(CASE WHEN %1 < %2 THEN %1 ELSE %2 END) AS %3,\n', CWAvailPhysicalFoundFieldName, CWAvailPhysicalResultFieldName, CWMinAvailPhysicalAlias);
            ret += strFmt('              SUM(CASE WHEN %1 < %2 THEN %1 ELSE %2 END) AS %3,\n', CWAvailOrderedFoundFieldName, CWAvailOrderedResultFieldName, CWMinAvailOrderedAlias);
        }

        ret    += strFmt('      %1 as %1\n', parentInventDimIdFieldName);
        ret    +=        '   FROM @RESULT\n';
        ret    += strFmt('   WHERE %1 = @LEVEL\n', hierarchyLevelFieldName);
        ret    += strFmt('   GROUP BY %1) %2\n', parentInventDimIdFieldName, AggregatedResultAlias);
        ret    += strFmt('   JOIN %1 %2\n', this.whsInventReserveTableName(false, _includeCW, _joinInventDim), WhsInventReserveFoundAlias);
        ret    += strFmt('   ON  %1.%2 = %3.%4\n', WhsInventReserveFoundAlias, inventDimIdFieldName, AggregatedResultAlias, parentInventDimIdFieldName);
        ret    += strFmt('   AND %1.%2 = @ITEMID\n', WhsInventReserveFoundAlias, itemIdFieldName);
        ret    += strFmt('   AND %1.%2 = @PARTITION and %1.%3 = @DATAAREAID\n', WhsInventReserveFoundAlias, partitionFieldName, dataAreaIdFieldName);
        ret    += strFmt(' GROUP BY %1.%2, %1.%3, %1.%4\n', WhsInventReserveFoundAlias, parentInventDimIdFieldName, hierarchyLevelFieldName, inventDimIdFieldName);
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectFromResultJoinWHSInventReserveStmtDelta</Name>
				<Source><![CDATA[
    private str selectFromResultJoinWHSInventReserveStmtDelta(boolean _includeCW, boolean _joinInventDim)
    {
        str             ret = '';
        ListEnumerator  enabledStorageAndTrackingDimensionEnumerator = this.enabledStorageAndTrackingDimensions().getEnumerator();
        ListEnumerator  enabledProductDimensionEnumerator = this.enabledProductDimensions().getEnumerator();
        str             dimFieldName;
        str             levelExpr = this.levelExpression(-1);
        str             inventReserveAlias = this.whsInventReserveTableAlias(true);
        boolean         hasDoneFirstIteration;

        ret += strFmt('SELECT SUM(CASE WHEN RESULT.%1 < RESULT.%2 THEN RESULT.%1 ELSE RESULT.%2 END),\n',
                        AvailPhysicalFoundFieldName,
                        AvailPhysicalResultFieldName);
        ret += strFmt('    SUM(CASE WHEN RESULT.%1 < RESULT.%2 THEN RESULT.%1 ELSE RESULT.%2 END),\n',
                        AvailOrderedFoundFieldName,
                        AvailOrderedResultFieldName);
        ret +=        '    SUM(FOUND.AVAILPHYSICAL),\n';
        ret +=        '    SUM(FOUND.AVAILORDERED),\n';
        ret += strFmt('    %1,\n', levelExpr);

        // Select product dimensions
        enabledProductDimensionEnumerator.reset();
        while (enabledProductDimensionEnumerator.moveNext())
        {
            dimFieldName = conPeek(enabledProductDimensionEnumerator.current(), 2);
            ret += strFmt('    RESULT.%1 AS %1,\n', dimFieldName);
        }

        // Create select list
        enabledStorageAndTrackingDimensionEnumerator.reset();
        hasDoneFirstIteration = false;
        while (enabledStorageAndTrackingDimensionEnumerator.moveNext())
        {
            if (hasDoneFirstIteration)
            {
                ret += ',\n';
            }

            dimFieldName = conPeek(enabledStorageAndTrackingDimensionEnumerator.current(), 2);
            ret += strFmt('    CASE WHEN %1 >= %2 THEN RESULT.%3 ELSE NULL END',
                            levelExpr,
                            this.dimensionLevelParm(dimFieldName),
                            dimFieldName);

            hasDoneFirstIteration = true;
        }

        if (_includeCW)
        {
            ret += strFmt(',SUM(CASE WHEN RESULT.%1 < RESULT.%2 THEN RESULT.%1 ELSE RESULT.%2 END),\n',
                            CWAvailPhysicalFoundFieldName,
                            CWAvailPhysicalResultFieldName);
            ret += strFmt('    SUM(CASE WHEN RESULT.%1 < RESULT.%2 THEN RESULT.%1 ELSE RESULT.%2 END),\n',
                            CWAvailOrderedFoundFieldName,
                            CWAvailOrderedResultFieldName);
            ret +=        '    SUM(FOUND.CWAVAILPHYSICAL),\n';
            ret +=        '    SUM(FOUND.CWAVAILORDERED)\n';
        }
        ret += '\n';

        ret +=        'FROM @RESULT RESULT\n';
        ret +=        'LEFT OUTER JOIN (\n';
        ret += this.selectInnerFromWHSInventReserveStmt(true, _includeCW, _joinInventDim);
        ret +=        '    ) AS FOUND ON ';

        // Add product dimensions range
        enabledProductDimensionEnumerator.reset();
        hasDoneFirstIteration = false;
        while (enabledProductDimensionEnumerator.moveNext())
        {
            if (hasDoneFirstIteration)
            {
                ret += '        AND ';
            }

            dimFieldName = conPeek(enabledProductDimensionEnumerator.current(), 2);
            ret += strFmt('(RESULT.%1 = FOUND.%1)\n', dimFieldName);

            hasDoneFirstIteration = true;
        }

        // Add enabled dimensions range
        enabledStorageAndTrackingDimensionEnumerator.reset();
        while (enabledStorageAndTrackingDimensionEnumerator.moveNext())
        {
            dimFieldName = conPeek(enabledStorageAndTrackingDimensionEnumerator.current(), 2);

            if (hasDoneFirstIteration)
            {
                ret += strFmt('        AND (%1 < %2 OR RESULT.%3 = FOUND.%3)\n',
                            levelExpr,
                            this.dimensionLevelParm(dimFieldName),
                            dimFieldName);
            }
            else
            {
                ret += strFmt('        (%1 < %2 OR RESULT.%3 = FOUND.%3)\n',
                            levelExpr,
                            this.dimensionLevelParm(dimFieldName),
                            dimFieldName);
                hasDoneFirstIteration = true;
            }
        }

        ret += strFmt('WHERE RESULT.%1 = %2\n', HierarchyLevelFieldName, this.levelExpression(0));
        ret +=        'GROUP BY\n';

        // Add grouping by product dimensions
        enabledProductDimensionEnumerator.reset();
        while (enabledProductDimensionEnumerator.moveNext())
        {
            dimFieldName = conPeek(enabledProductDimensionEnumerator.current(), 2);
            ret += strFmt('    RESULT.%1,\n', dimFieldName);
        }

        // Add grouping by enabled dimensions
        enabledStorageAndTrackingDimensionEnumerator.reset();
        hasDoneFirstIteration = false;
        while (enabledStorageAndTrackingDimensionEnumerator.moveNext())
        {
            if (hasDoneFirstIteration)
            {
                ret += ',\n';
            }

            dimFieldName = conPeek(enabledStorageAndTrackingDimensionEnumerator.current(), 2);
            ret += strFmt('    CASE WHEN %1 >= %2 THEN RESULT.%3 ELSE NULL END',
                            levelExpr,
                            this.dimensionLevelParm(dimFieldName),
                            dimFieldName);

            hasDoneFirstIteration = true;
        }

        ret += '\n';
        ret += this.SQLOptions();        
        ret += ';\n';

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectFromWHSInventReserveStmt</Name>
				<Source><![CDATA[
    private str selectFromWHSInventReserveStmt(boolean _includeDelta, boolean _includeCW, boolean _joinInventDim)
    {
        str             ret = '';
        ListEnumerator  enabledStorageAndTrackingDimensionEnumerator = this.enabledStorageAndTrackingDimensions().getEnumerator();
        ListEnumerator  enabledproductDimensionEnumerator = this.enabledProductDimensions().getEnumerator();
        str             dimFieldName;
        str             inventReserveAlias = this.whsInventReserveTableAlias(_includeDelta);
        boolean         hasDoneFirstIteration;
        str             whereLevelExpression = this.levelExpression(0);
        str             grouppingLevelExpression = this.levelExpression(-1);
        str             dimensionTableName = this.inventoryDimensionTableAlias(_includeDelta, _joinInventDim);

        ret += strFmt('SELECT SUM(%1.AVAILPHYSICAL),\n', inventReserveAlias);
        ret += strFmt('    SUM(%1.AVAILORDERED),\n', inventReserveAlias);
        ret +=        '    NULL,\n';
        ret +=        '    NULL,\n';
        ret += strFmt('    %1,\n', this.levelExpression(0));

        if ( _includeDelta)
        {
            // Select product dimensions
            enabledProductDimensionEnumerator.reset();
            while (enabledProductDimensionEnumerator.moveNext())
            {
                dimFieldName = conPeek(enabledProductDimensionEnumerator.current(), 2);
                ret += strFmt('    %2.%1,\n', dimFieldName, dimensionTableName);
            }

            // Select enabled dimensions
            enabledStorageAndTrackingDimensionEnumerator.reset();
            hasDoneFirstIteration = false;
            while (enabledStorageAndTrackingDimensionEnumerator.moveNext())
            {
                if (hasDoneFirstIteration)
                {
                    ret += ',\n';
                }

                dimFieldName = conPeek(enabledStorageAndTrackingDimensionEnumerator.current(), 2);
                ret += strFmt('    CASE WHEN %1 >= %2 THEN %4.%3 ELSE NULL END',
                                this.levelExpression(-1),
                                this.dimensionLevelParm(dimFieldName),
                                dimFieldName,
                                dimensionTableName);

                hasDoneFirstIteration = true;
            }
        }
        else 
        {
            ret += strFmt('    %1.%2', inventReserveAlias, ParentInventDimIdFieldName);
        }

        if (_includeCW)
        {
            ret += strFmt(', SUM(%1.CWAVAILPHYSICAL),\n', inventReserveAlias);
            ret += strFmt('    SUM(%1.CWAVAILORDERED),\n', inventReserveAlias);
            ret +=        '    NULL,\n';
            ret +=        '    NULL\n';
        }

        ret += '\n';

        ret += strFmt('    FROM %1 %2\n', this.whsInventReserveTableName(_includeDelta, _includeCW, _joinInventDim), inventReserveAlias);
        if (_joinInventDim)
        {
            ret += strFmt('    JOIN INVENTDIM ON INVENTDIM.INVENTDIMID = %1.INVENTDIMID AND INVENTDIM.DATAAREAID = %1.DATAAREAID AND INVENTDIM.PARTITION = %1.PARTITION\n', inventReserveAlias);
        }
        ret += strFmt('    WHERE %1.ITEMID           = @ITEMID\n', inventReserveAlias);
        ret += strFmt('        AND %1.PARTITION      = @PARTITION\n', inventReserveAlias);
        ret += strFmt('        AND %1.DATAAREAID     = @DATAAREAID\n', inventReserveAlias);
        ret += strFmt('        AND %1.HIERARCHYLEVEL = %2\n', inventReserveAlias, this.levelExpression(0));

        // Add product dimensions range
        enabledProductDimensionEnumerator.reset();
        while (enabledProductDimensionEnumerator.moveNext())
        {
            dimFieldName = conPeek(enabledProductDimensionEnumerator.current(), 2);
            ret += strFmt('        AND (%2 IS NULL OR %3.%1 = %2)\n',
                            dimFieldName,
                            this.dimensionParm(dimFieldName),
                            dimensionTableName);
        }

        // Add enabled dimensions range
        enabledStorageAndTrackingDimensionEnumerator.reset();
        while (enabledStorageAndTrackingDimensionEnumerator.moveNext())
        {
            dimFieldName = conPeek(enabledStorageAndTrackingDimensionEnumerator.current(), 2);

            
            ret += strFmt('        AND (1 = CASE WHEN %1 >= %2 AND %3 is null THEN 1 ELSE 0 END OR %5.%4 = CASE WHEN %1 >= %2 THEN %3 ELSE %6 END)\n',
                            whereLevelExpression,
                            this.dimensionLevelParm(dimFieldName),
                            this.dimensionParm(dimFieldName),
                            dimFieldName,
                            dimensionTableName,
                            this.getDimensionEmptyValue(dimFieldName, _joinInventDim));
       
            
        }

        ret +=        'GROUP BY\n';

        if (_includeDelta)
        {
            // Add grouping by product dimensions
            enabledProductDimensionEnumerator.reset();
            while (enabledProductDimensionEnumerator.moveNext())
            {
                dimFieldName = conPeek(enabledProductDimensionEnumerator.current(), 2);
                ret += strFmt('    %2.%1,\n', dimFieldName, dimensionTableName);
            }

            // Add grouping by enabled dimensions
            enabledStorageAndTrackingDimensionEnumerator.reset();
            hasDoneFirstIteration = false;
            while (enabledStorageAndTrackingDimensionEnumerator.moveNext())
            {
                if (hasDoneFirstIteration)
                {
                    ret += ',\n';
                }

                dimFieldName = conPeek(enabledStorageAndTrackingDimensionEnumerator.current(), 2);
                ret += strFmt('    CASE WHEN %1 >= %2 THEN %4.%3 ELSE NULL END',
                                grouppingLevelExpression,
                                this.dimensionLevelParm(dimFieldName),
                                dimFieldName,
                                dimensionTableName);

                hasDoneFirstIteration = true;
            }
        } 
        else
        {
            ret += strFmt('    %1.%2', inventReserveAlias, ParentInventDimIdFieldName);
        }
        ret += '\n    ';
        ret += this.SQLOptions();
        
        ret += ';\n';

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectInnerFromWHSInventReserveStmt</Name>
				<Source><![CDATA[
    private str selectInnerFromWHSInventReserveStmt(boolean _includeDelta, boolean _includeCW, boolean _joinInventDim)
    {
        str             ret = '';
        ListEnumerator  enabledStorageAndTrackingDimensionEnumerator = this.enabledStorageAndTrackingDimensions().getEnumerator();
        ListEnumerator  enabledProductDimensionEnumerator = this.enabledProductDimensions().getEnumerator();
        str             dimFieldName;
        str             levelExpr = this.levelExpression(-1);
        str             inventReserveAlias = this.whsInventReserveTableAlias(_includeDelta);
        boolean         hasDoneFirstIteration;
        str             dimensionTableName = this.inventoryDimensionTableAlias(_includeDelta, _joinInventDim);

        ret += strFmt('SELECT SUM(%1.AVAILPHYSICAL) AS AVAILPHYSICAL,\n', inventReserveAlias);
        ret += strFmt('    SUM(%1.AVAILORDERED) AS AVAILORDERED,\n', inventReserveAlias);

        // Select product dimensions
        enabledProductDimensionEnumerator.reset();
        while (enabledProductDimensionEnumerator.moveNext())
        {
            dimFieldName = conPeek(enabledProductDimensionEnumerator.current(), 2);
            ret += strFmt('    %2.%1 AS %1,\n', dimFieldName, dimensionTableName);
        }

        // Select enabled dimensions
        enabledStorageAndTrackingDimensionEnumerator.reset();
        hasDoneFirstIteration = false;
        while (enabledStorageAndTrackingDimensionEnumerator.moveNext())
        {
            if (hasDoneFirstIteration)
            {
                ret += ',\n';
            }

            dimFieldName = conPeek(enabledStorageAndTrackingDimensionEnumerator.current(), 2);
            ret += strFmt('    CASE WHEN %1 >= %2 THEN %4.%3 ELSE NULL END AS %3',
                            levelExpr,
                            this.dimensionLevelParm(dimFieldName),
                            dimFieldName,
                            dimensionTableName);

            hasDoneFirstIteration = true;
        }

        if (_includeCW)
        {
            ret += strFmt(', SUM(%1.CWAVAILPHYSICAL) AS CWAVAILPHYSICAL,\n', inventReserveAlias);
            ret += strFmt('    SUM(%1.CWAVAILORDERED) AS CWAVAILORDERED\n', inventReserveAlias);
        }
        ret += '\n';

        ret += strFmt('FROM %1 %2\n', this.whsInventReserveTableName(_includeDelta, _includeCW, _joinInventDim), inventReserveAlias);
        if (_joinInventDim)
        {
            ret += strFmt('JOIN INVENTDIM ON INVENTDIM.PARTITION = %1.PARTITION\n', inventReserveAlias);
            ret += strFmt('    AND INVENTDIM.DATAAREAID  = %1.DATAAREAID\n', inventReserveAlias);
            ret += strFmt('    AND INVENTDIM.INVENTDIMID = %1.INVENTDIMID\n', inventReserveAlias);
        }
        ret += strFmt('WHERE %1.HIERARCHYLEVEL = %2\n', inventReserveAlias, levelExpr);
        ret += strFmt('    AND %1.ITEMID       = @ITEMID\n', inventReserveAlias);
        ret += strFmt('    AND %1.PARTITION    = @PARTITION\n', inventReserveAlias);
        ret += strFmt('    AND %1.DATAAREAID   = @DATAAREAID\n', inventReserveAlias);

        // Add product dimensions range to better facilitate indexes with product dimensions
        enabledProductDimensionEnumerator.reset();
        while (enabledProductDimensionEnumerator.moveNext())
        {
            dimFieldName = conPeek(enabledProductDimensionEnumerator.current(), 2);
            ret += strFmt('        AND (%2 IS NULL OR %3.%1 = %2)\n',
                            dimFieldName,
                            this.dimensionParm(dimFieldName),
                            dimensionTableName);
        }

        // Add enabled dimensions range
        enabledStorageAndTrackingDimensionEnumerator.reset();
        while (enabledStorageAndTrackingDimensionEnumerator.moveNext())
        {
            dimFieldName = conPeek(enabledStorageAndTrackingDimensionEnumerator.current(), 2);

            ret += strFmt('        AND (1 = CASE WHEN %1 >= %2 AND %3 is null THEN 1 ELSE 0 END OR %5.%4 = CASE WHEN %1 >= %2 THEN %3 ELSE %6 END)\n',
                            levelExpr,
                            this.dimensionLevelParm(dimFieldName),
                            this.dimensionParm(dimFieldName),
                            dimFieldName,
                            dimensionTableName,
                            this.getDimensionEmptyValue(dimFieldName, _joinInventDim));
 
        }

        // Add grouping by product dimensions
        ret +=          'GROUP BY\n';
        enabledProductDimensionEnumerator.reset();
        while (enabledProductDimensionEnumerator.moveNext())
        {
            dimFieldName = conPeek(enabledProductDimensionEnumerator.current(), 2);
            ret += strFmt('    %2.%1,\n', dimFieldName, dimensionTableName);
        }

        // Add grouping by enabled dimensions
        enabledStorageAndTrackingDimensionEnumerator.reset();
        hasDoneFirstIteration = false;
        while (enabledStorageAndTrackingDimensionEnumerator.moveNext())
        {
            if (hasDoneFirstIteration)
            {
                ret += ',\n';
            }

            dimFieldName = conPeek(enabledStorageAndTrackingDimensionEnumerator.current(), 2);
            ret += strFmt('    CASE WHEN %1 >= %2 THEN %4.%3 ELSE NULL END',
                            levelExpr,
                            this.dimensionLevelParm(dimFieldName),
                            dimFieldName,
                            dimensionTableName);

            hasDoneFirstIteration = true;
        }
        ret += '\n';

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimensionEmptyValue</Name>
				<Source><![CDATA[
    private str getDimensionEmptyValue(str _fieldName, boolean _joinInventDim)
    {
        str ret;

        TableId tableId = _joinInventDim ? tableNum(InventDim) : tableNum(WHSInventReserve);
        FieldId fieldId = fieldName2Id(tableId, _fieldName);

        SysDictField dictField = new SysDictField(tableId, fieldId);

        if (dictField)
        {
            switch (dictField.baseType())
            {
                case Types::String:
                    ret = '\'\'';
                    break;
                case Types::Real:
                case Types::Integer:
                case Types::Int64:
                case Types::Enum:
                    ret = '0';
                    break;
                case Types::Date:
                case Types::UtcDateTime:
                    ret = 'convert(date, \'1900-01-01\')';
                    break;
                case Types::Guid:
                    ret = guid2Str(emptyGuid());
                default:
                    throw error(Error::wrongUseOfFunction(funcName()));
            }
        }
        else
        {
            ret = '\'\'';
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sqlFieldName</Name>
				<Source><![CDATA[
    private str sqlFieldName(TableId _tableId, FieldId _fieldId)
    {
        return new SysDictField(_tableId, _fieldId).name(DbBackend::Sql);
    }

]]></Source>
			</Method>
			<Method>
				<Name>sqlTableName</Name>
				<Source><![CDATA[
    private str sqlTableName(TableId _tableId)
    {
        return new SysDictTable(_tableId).name(DbBackend::Sql);
    }

]]></Source>
			</Method>
			<Method>
				<Name>sqlTypeNameForField</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets a SQL type name that should be used for requested <c>InventDim</c> field in a stored procedure.
    /// </summary>
    /// <param name="_tableId">
    ///     <c>TableId</c> of the requested field.
    /// </param>
    /// <param name="_dimFieldId">
    ///     <c>FieldId</c> of the requested field.
    /// </param>
    /// <returns>
    ///     SQL type name.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///     Thrown when a field with unhandled type is requested.
    /// </exception>
    private str sqlTypeNameForField(TableId _tableId, FieldId _dimFieldId)
    {
        DictField   df;
        str         ret = '';

        df = new DictField(_tableId, _dimFieldId);
        switch (df.baseType())
        {
            case Types::String  :
                ret = strFmt('nvarchar (%1)', int2str(df.stringLen()));
                break;

            case Types::Integer :
                ret = 'int';
                break;

            case Types::Real    :
                ret =  'numeric(32, 6)';
                break;
            
            case Types::Date    :
            case Types::UtcDateTime:
                ret = 'datetime';
                break;

            case Types::Enum    :
                ret = 'int';
                break;

            case Types::Int64   :
                ret = 'bigint';
                break;
            
            case Types::Guid    :
                ret = 'uniqueidentifier';
                break;
            
            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsInventReserveTableAlias</Name>
				<Source><![CDATA[
    private str whsInventReserveTableAlias(boolean _includeDelta)
    {
        return _includeDelta ?  'WHSINVENTRESERVEWITHDELTA' : 'WHSINVENTRESERVE';
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventoryDimensionTableAlias</Name>
				<Source><![CDATA[
    private str inventoryDimensionTableAlias(boolean _includeDelta, boolean _joinInventDim)
    {
        return _joinInventDim ?  tableStr(InventDim) : this.whsInventReserveTableAlias(_includeDelta);
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsInventReserveTableName</Name>
				<Source><![CDATA[
    private str whsInventReserveTableName(
        boolean _includeDelta,
        boolean _includeCW,
        boolean _joinInventDim)
    {
        return _includeDelta ?  strFmt('%1(%2)', WhsOnHandSPHelper::WHSOnHandUnionAllDeltaTVFName(_includeCW, _joinInventDim), TTSIdParmName) : this.sqlTableName(tableNum(WHSInventReserve));
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSPCallStmt</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds the SQL statement to call the WHS on-hand query.
    /// </summary>
    /// <param name="_inventTable">
    ///     <c>InventTable</c> record to use.
    /// </param>
    /// <param name="_inventDimCriteria">
    ///     <c>InventDim</c> criteria for the calculations.
    /// </param>
    /// <param name="_inventDimParm">
    ///     <c>InventDimParm</c> criteria for the calculations.
    /// </param>
    /// <param name="_level">
    ///     <c>WHSReservationHierarchyLevel</c> level to start the search at.
    /// </param>
    /// <param name="_includeDelta">
    ///     A boolean indicating whether delta records should be considered in the on hand calculation; optional.
    /// </param>
    /// <param name="_ttsId">
    ///     The id of the transaction that the deltas were created in.
    /// </param>
    /// <param name="_upperLevelOfMinimumCalculation">
    ///     The maximum hierarchy level to be considered for calculating the onhand; optional.
    /// </param>
    /// <returns>
    ///     A string containing the SQL statement.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws an error if the <c>InventTable</c> record is not specified.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Throws an error if deltas need to be included but the transaction id was not specified.
    /// </exception>
    public str buildSPCallStmt(
        InventTable                     _inventTable,
        InventDim                       _inventDimCriteria,
        InventDimParm                   _inventDimParm,
        WHSReservationHierarchyLevel    _level,
        boolean                         _includeDelta = false,
        CreatedTransactionId            _ttsId = 0,
        WHSReservationHierarchyLevel    _upperLevelOfMinimumCalculation = #ITEMHIERARCHYLEVEL)
    {
        return this.buildSPCallStmtInternal(_inventTable, _inventDimCriteria, _inventDimParm, _level, _includeDelta, _ttsId, _upperLevelOfMinimumCalculation, false).parmStatement();
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSPCallStmtWithParameters</Name>
				<Source><![CDATA[
    public WHSQueryWithParametersValues buildSPCallStmtWithParameters(
        InventTable                     _inventTable,
        InventDim                       _inventDimCriteria,
        InventDimParm                   _inventDimParm,
        WHSReservationHierarchyLevel    _level,
        boolean                         _includeDelta = false,
        CreatedTransactionId            _ttsId = 0,
        WHSReservationHierarchyLevel    _upperLevelOfMinimumCalculation = #ITEMHIERARCHYLEVEL)
    {
        return this.buildSPCallStmtInternal(_inventTable, _inventDimCriteria, _inventDimParm, _level, _includeDelta, _ttsId, _upperLevelOfMinimumCalculation, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSPCallStmtCW</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal str buildSPCallStmtCW(
        InventTable                     _inventTable,
        InventDim                       _inventDimCriteria,
        InventDimParm                   _inventDimParm,
        WHSReservationHierarchyLevel    _level,
        boolean                         _includeDelta,
        CreatedTransactionId            _ttsId,
        WHSReservationHierarchyLevel    _upperLevelOfMinimumCalculation)
    {
        return this.buildSPCallStmtInternal(_inventTable, _inventDimCriteria, _inventDimParm, _level, _includeDelta, _ttsId, _upperLevelOfMinimumCalculation, true).parmStatement();
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSPCallStmtCWWithParameters</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal WHSQueryWithParametersValues buildSPCallStmtCWWithParameters(
        InventTable                     _inventTable,
        InventDim                       _inventDimCriteria,
        InventDimParm                   _inventDimParm,
        WHSReservationHierarchyLevel    _level,
        boolean                         _includeDelta,
        CreatedTransactionId            _ttsId,
        WHSReservationHierarchyLevel    _upperLevelOfMinimumCalculation)
    {
        return this.buildSPCallStmtInternal(_inventTable, _inventDimCriteria, _inventDimParm, _level, _includeDelta, _ttsId, _upperLevelOfMinimumCalculation, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSPCallStmtInternal</Name>
				<Source><![CDATA[
    private WHSQueryWithParametersValues buildSPCallStmtInternal(
        InventTable                     _inventTable,
        InventDim                       _inventDimCriteria,
        InventDimParm                   _inventDimParm,
        WHSReservationHierarchyLevel    _level,
        boolean                         _includeDelta,
        CreatedTransactionId            _ttsId,
        WHSReservationHierarchyLevel    _upperLevelOfMinimumCalculation,
        boolean                         _includeCW)
    {
        str                 ret = '';
        SysSqlSystem        sqlSystem = new SysSqlSystem();

        if (!_inventTable)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (_includeDelta && !_ttsId)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        ret += strFmt('DECLARE %1 %2\n', AvailPhysicalParmName, this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, AvailPhysical)));
        ret += strFmt('DECLARE %1 %2;\n\n', AvailOrderedParmName, this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, AvailOrdered)));
        
        if (_includeCW)
        {
            ret += strFmt('DECLARE %1 %2\n', CWAvailPhysicalParmName, this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, CWAvailPhysical)));
            ret += strFmt('DECLARE %1 %2;\n\n', CWAvailOrderedParmName, this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, CWAvailOrdered)));
        }
        
        Map paramMap;
        if (WHSExecuteWithParametersV3Flight::instance().isEnabled())
        {
            paramMap = SqlParams::create();
            ret += strFmt('EXECUTE %1\n', WHSOnHandSPHelper::storedProcedureName(_includeDelta, _includeCW, false));
            ret += strFmt('@DATAAREAID = @%1,\n', DataAreaIdParmValue);
            paramMap.add(DataAreaIdParmValue, _inventTable.DataAreaId);
            ret += strFmt('@PARTITION = @%1,\n', PartitionParmValue);
            paramMap.add(PartitionParmValue, _inventTable.Partition);
            ret += strFmt('@ITEMID = @%1,\n', ItemIdParmValue);
            paramMap.add(ItemIdParmValue, _inventTable.ItemId);
            ret += strFmt('@LEVEL = @%1,\n', LevelParmValue);
            paramMap.add(LevelParmValue, _level);
            ret += strFmt('%1 = @%2,\n', UpperLevelOfMinimumCalculationParamName, UpperLevelOfMinimumCalculationParmValue);
            paramMap.add(UpperLevelOfMinimumCalculationParmValue, _upperLevelOfMinimumCalculation);
            if (_includeDelta)
            {
                ret += strFmt('%1 = @%2,\n', TTSIdParmName, TTSIdParmValue);
                paramMap.add(TTSIdParmValue, _ttsId);
            }
        }

        else
        {
            ret += strFmt('EXECUTE %1\n', WHSOnHandSPHelper::storedProcedureName(_includeDelta, _includeCW, false));
            ret += strFmt('@DATAAREAID = %1,\n', sqlSystem.sqlLiteral(_inventTable.DataAreaId, false));
            ret += strFmt('@PARTITION = %1,\n', sqlSystem.sqlLiteral(_inventTable.Partition, false));
            ret += strFmt('@ITEMID = %1,\n', sqlSystem.sqlLiteral(_inventTable.ItemId, false));
            ret += strFmt('@LEVEL = %1,\n', sqlSystem.sqlLiteral(_level, false));
            ret += strFmt('%1 = %2,\n', UpperLevelOfMinimumCalculationParamName, sqlSystem.sqlLiteral(_upperLevelOfMinimumCalculation, false));
            if (_includeDelta)
            {
                ret += strFmt('%1 = %2,\n', TTSIdParmName, sqlSystem.sqlLiteral(_ttsId, false));
            }
        }

        WHSQueryWithParametersValues sqlWithParams = this.buildSPCallParameters(
            _inventTable,
            _inventDimCriteria,
            _inventDimParm,
            _level,
            ret,
            paramMap);
        ret = sqlWithParams.parmStatement();
        paramMap = sqlWithParams.parmParameters();

        ret += strFmt('%1 = %1 output,\n', AvailPhysicalParmName);
        ret += strFmt('%1 = %1 output\n', AvailOrderedParmName);

        if (_includeCW)
        {
            ret += strFmt(', %1 = %1 output,\n', CWAvailPhysicalParmName);
            ret += strFmt('%1 = %1 output\n', CWAvailOrderedParmName);
        }

        ret += ';\n';

        ret += strFmt('SELECT %1 as [AVAILPHYSICAL],\n', AvailPhysicalParmName);
        ret += strFmt('    %1 as [AVAILORDERED]', AvailOrderedParmName);

        if (_includeCW)
        {
            ret += strFmt(',%1 as [CWAVAILPHYSICAL],\n', CWAvailPhysicalParmName);
            ret += strFmt('    %1 as [CWAVAILORDERED]', CWAvailOrderedParmName);
        }

        ret += ';';

        return WHSQueryWithParametersValues::construct(ret, paramMap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCacheMaps</Name>
				<Source><![CDATA[
    private static void clearCacheMaps()
    {
        // Clear enabled dimensions parameters cache
        classfactory.globalCache().remove(CacheScope, EnabledDimsParametersCacheKey);
        classfactory.globalObjectCache().remove(CacheScope, [EnabledDimsParametersCacheKey]);

        // Clear product dimensions parameters cache
        classfactory.globalCache().remove(CacheScope, ProductDimsParametersCacheKey);
        classfactory.globalObjectCache().remove(CacheScope, [ProductDimsParametersCacheKey]);

        if (WHSReserveAvailQuantitiesStoredProceduresV2Flight::instance().isEnabled())
        {
            // Clear cashed sql queries
            classfactory.globalCache().clear(WHSInventReserveMinValuesForDimIdCacheScope);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
	/// Constructs a new instance.
	/// </summary>
	/// <returns>
	/// New <c>WHSOnHandSPHelper</c> instance.
	/// </returns>
    public static WHSOnHandSPHelper construct()
    {
        return new WHSOnHandSPHelper();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDBStoredProcedures</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the stored procedures that query WHS on hand.
    /// </summary>
    public static void createDBStoredProcedures()
    {
        WHSOnHandSPHelper::createDBProcedureAndTVF(false);
        WHSOnHandSPHelper::createCWDBProcedureAndTVF();

        if (WHSReserveAvailQuantitiesStoredProceduresV2Flight::instance().isEnabled())
        {
            WHSOnHandSPHelper::createInventReserveMinValuesForDimIdStoredProcedures();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDBProcedureAndTVF</Name>
				<Source><![CDATA[
    private static void createDBProcedureAndTVF(boolean _includeCW)
    {
        WHSOnHandSPHelper::createSqlOnHandUnionAllDeltaTVF(_includeCW, true);
        WHSOnHandSPHelper::createSqlOnHandUnionAllDeltaTVF(_includeCW, false);

        WHSOnHandSPHelper::createSqlStoredProcedure(false, _includeCW, true); // no delta - InventDim join
        WHSOnHandSPHelper::createSqlStoredProcedure(false, _includeCW, false); // no delta - No InventDim join

        WHSOnHandSPHelper::createSqlStoredProcedure(true, _includeCW, true); // with delta - InventDim join
        WHSOnHandSPHelper::createSqlStoredProcedure(true, _includeCW, false); // with delta - No InventDim join
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUseWHSCatchWeight</Name>
				<Source><![CDATA[
    private static boolean canUseWHSCatchWeight()
    {
        return isConfigurationkeyEnabled(configurationkeynum(WHSCatchWeight));
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUseWHSCatchWeightForItem</Name>
				<Source><![CDATA[
    private static boolean canUseWHSCatchWeightForItem(ItemId _itemId)
    {
        return WHSOnHandSPHelper::canUseWHSCatchWeight() && PdsGlobal::pdsIsCWItem(_itemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCWDBProcedureAndTVF</Name>
				<Source><![CDATA[
    private static void createCWDBProcedureAndTVF()
    {
        if (WHSOnHandSPHelper::canUseWHSCatchWeight())
        {
            WHSOnHandSPHelper::createDBProcedureAndTVF(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSqlOnHandUnionAllDeltaTVF</Name>
				<Source><![CDATA[
    private static void createSqlOnHandUnionAllDeltaTVF(boolean _includeCW, boolean _joinInventDim)
    {
        Statement                       statement;
        str                             sqlStmt;
        WHSOnHandSPHelper               helper = WHSOnHandSPHelper::construct();

        statement = new Connection().createStatement();

        sqlStmt = helper.buildCreateTVFOnHandUnionAllDeltaSqlStmt(_includeCW, _joinInventDim);

        new SqlStatementExecutePermission(sqlStmt).assert();

        if (WHSExecuteWithParametersV3Flight::instance().isEnabled())
        {
            statement.executeUpdateWithParameters(sqlStmt, null);
        }
        else
        {
            statement.executeUpdate(sqlStmt);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSqlStoredProcedure</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates the WHS on-hand stored procedure.
    /// </summary>
    /// <param name="_includeDelta">A boolean indicating whether the procedure should consider delta records or not.</param>
    /// <param name="_includeCW">A boolean indicating whether the procedure should include catch weight fields.</param>
    /// <param name="_joinInventDim">A boolean indicating whether the procedure should use inventory dimensions from <c>InventDim</c> table.</param>
    /// <remarks>
    ///     The method will fail if the procedure already exists.
    /// </remarks>
    private static void createSqlStoredProcedure(boolean _includeDelta, boolean _includeCW, boolean _joinInventDim)
    {
        Statement           statement;
        str                 sqlStmt;
        WHSOnHandSPHelper   helper = WHSOnHandSPHelper::construct();

        statement = new Connection().createStatement();

        sqlStmt = helper.buildCreateSPStmt(_includeDelta, _includeCW, _joinInventDim);

        new SqlStatementExecutePermission(sqlStmt).assert();

        if (WHSExecuteWithParametersV3Flight::instance().isEnabled())
        {
            statement.executeUpdateWithParameters(sqlStmt, null);
        }
        else
        {
            statement.executeUpdate(sqlStmt);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dropDBStoredProcedures</Name>
				<Source><![CDATA[
    /// <summary>
    /// Drops the stored procedures that query WHS on hand.
    /// </summary>
    public static void dropDBStoredProcedures()
    {
        WHSOnHandSPHelper::dropSqlStoredProcedure(false); // no delta
        WHSOnHandSPHelper::dropSqlStoredProcedure(true); // with delta
        WHSOnHandSPHelper::dropSqlOnHandUnionAllDeltaTVF();

        WHSOnHandSPHelper::dropCWDBStoredProcedures();

        if (WHSReserveAvailQuantitiesStoredProceduresV2Flight::instance().isEnabled())
        {
            WHSOnHandSPHelper::dropInventReserveMinValuesForDimIdStoredProcedures();
        }
        
        WHSOnHandSPHelper::clearCacheMaps();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dropCWDBStoredProcedures</Name>
				<Source><![CDATA[
    private static void dropCWDBStoredProcedures()
    {
        WHSOnHandSPHelper::dropCWSqlStoredProcedure(false, true); // no delta - InventDim join
        WHSOnHandSPHelper::dropCWSqlStoredProcedure(false, false); // no delta - No InventDim join
        WHSOnHandSPHelper::dropCWSqlStoredProcedure(true, true); // InventDim join
        WHSOnHandSPHelper::dropCWSqlStoredProcedure(true, false); // No InventDim join
        WHSOnHandSPHelper::dropCWSqlOnHandUnionAllDeltaTVF();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dropSqlOnHandUnionAllDeltaTVF</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Drops the WHS on-hand stored procedure from the database.
    /// </summary>
    protected static void dropSqlOnHandUnionAllDeltaTVF()
    {
        WhsOnHandSPHelper::dropSqlOnHandUnionAllDeltaTVFByName(WhsOnHandSPHelper::WHSOnHandUnionAllDeltaTVFName(false, true));
        WhsOnHandSPHelper::dropSqlOnHandUnionAllDeltaTVFByName(WhsOnHandSPHelper::WHSOnHandUnionAllDeltaTVFName(false, false));
    }

]]></Source>
			</Method>
			<Method>
				<Name>dropCWSqlOnHandUnionAllDeltaTVF</Name>
				<Source><![CDATA[
    private static void dropCWSqlOnHandUnionAllDeltaTVF()
    {
        WhsOnHandSPHelper::dropSqlOnHandUnionAllDeltaTVFByName(WhsOnHandSPHelper::WHSOnHandUnionAllDeltaTVFName(true, true));
        WhsOnHandSPHelper::dropSqlOnHandUnionAllDeltaTVFByName(WhsOnHandSPHelper::WHSOnHandUnionAllDeltaTVFName(true, false));
    }

]]></Source>
			</Method>
			<Method>
				<Name>dropSqlOnHandUnionAllDeltaTVFByName</Name>
				<Source><![CDATA[
    private static void dropSqlOnHandUnionAllDeltaTVFByName(str _functionName)
    {
        str sqlStmt = 'IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N\'[' + _functionName + ']\') AND type = N\'IF\')';
        sqlStmt += 'DROP FUNCTION ['+ _functionName + ']';

        Statement statement = new Connection().createStatement();

        new SqlStatementExecutePermission(sqlStmt).assert();

        if (WHSExecuteWithParametersV3Flight::instance().isEnabled())
        {
            statement.executeUpdateWithParameters(sqlStmt, null);
        }
        else
        {
            statement.executeUpdate(sqlStmt);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dropSqlStoredProcedure</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Drops the WHS on-hand stored procedure from the database.
    /// </summary>
    /// <param name="_includeDelta">A boolean indicating whether the procedure that considers delta records should be removed or the one that does not.</param>
    protected static void dropSqlStoredProcedure(boolean _includeDelta)
    {
        WHSOnHandSPHelper::dropOnHandSqlStoredProcedure(_includeDelta, true);
        WHSOnHandSPHelper::dropOnHandSqlStoredProcedure(_includeDelta, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dropOnHandSqlStoredProcedure</Name>
				<Source><![CDATA[
    private static void dropOnHandSqlStoredProcedure(boolean _includeDelta, boolean _joinInventDim)
    {
        str procedureName = WHSOnHandSPHelper::storedProcedureName(_includeDelta, false, _joinInventDim);

        WHSOnHandSPHelper::dropSqlStoredProcedureByName(procedureName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dropCWSqlStoredProcedure</Name>
				<Source><![CDATA[
    private static void dropCWSqlStoredProcedure(boolean _includeDelta, boolean _joinInventDim)
    {
        str procedureName = WHSOnHandSPHelper::storedProcedureName(_includeDelta, true, _joinInventDim);

        WHSOnHandSPHelper::dropSqlStoredProcedureByName(procedureName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dropSqlStoredProcedureByName</Name>
				<Source><![CDATA[
    private static void dropSqlStoredProcedureByName(str _procedureName)
    {
        str sqlStmt = 'IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N\'[' + _procedureName + ']\') AND type in (N\'P\', N\'PC\'))';
        sqlStmt += 'DROP PROCEDURE ['+ _procedureName + ']';

        Statement statement = new Connection().createStatement();

        new SqlStatementExecutePermission(sqlStmt).assert();

        if (WHSExecuteWithParametersV3Flight::instance().isEnabled())
        {
            statement.executeUpdateWithParameters(sqlStmt, null);
        }
        else
        {
            statement.executeUpdate(sqlStmt);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>storedProcedureName</Name>
				<Source><![CDATA[
    private static str storedProcedureName(boolean _includeDelta, boolean _includeCW, boolean _joinInventDim)
    {
        if (_joinInventDim)
        {
            if (_includeCW)
            {
                return _includeDelta ? CWWHSOnHandWithDeltaSPName : CWWHSOnHandSPName;
            }

            return _includeDelta ? #WHSOnHandWithDeltaSPName : #WHSOnHandSPName;
        }
        
        if (_includeCW)
        {
            return _includeDelta ? CWWHSOnHandWithDeltaWithInventDimSPName : CWWHSOnHandWithInventDimSPName;
        }

        return _includeDelta ? WHSOnHandWithDeltaWithInventDimSPName : WHSOnHandWithInventDimSPName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncDBStoredProcedures</Name>
				<Source><![CDATA[
    /// <summary>
    /// Drops and creates stored procedures that allow to query WHS on hand.
    /// </summary>
    public static void syncDBStoredProcedures()
    {
        #Define.WHSOnHandSPLockName('WHSOnHandSPLock')

        // Serialize access to manipulating of the stored procedure
        using (var reqReaderWriterLock = ReqReaderWriterLock::construct())
        {
            reqReaderWriterLock.enterUpdateLock(#WHSOnHandSPLockName);

            WHSOnHandSPHelper::dropDBStoredProcedures();
            WHSOnHandSPHelper::createDBStoredProcedures();

            reqReaderWriterLock.exit(#WHSOnHandSPLockName);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dbSynchronize</Name>
				<Source><![CDATA[
    [SysObsolete('Please use method WHSOnHandSPHelper.syncDBStoredProcedures() instead', true, 15\11\2021)]
    public static void dbSynchronize(
        TableId         tableId,   // 0 = all tables, non-zero is a valid table handle
        boolean         syncAsNeeded,  // true = objects touched in the AOT, false = unconditional synchronize
        boolean         continueOnError,
        boolean         showProgress,  // true = report all problems, but throw only after all tables are synchronized, false = stop synchronize after first error/problem
        container       checkSyncTables, // [0] all tables or [x, y, z, ...] for 1 or more tables
        boolean         createAllIndexes,
        boolean         useLockForSingleTable)
    {
        if (syncAsNeeded == false
            && isConfigurationkeyEnabled(configurationKeyNum(WHSandTMS))
            && (tableId == 0 || tableId == tableNum(WHSInventReserve) || tableId == tableNum(InventDim)))
        {
            if (InventDim::isPhysicallyExistingInDB()
                && WHSInventReserve::isPhysicallyExistingInDB())
            {
                WHSOnHandSPHelper::syncDBStoredProcedures();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateInventReserveMinValuesForDimId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal WHSInventReserveQuantities calculateInventReserveMinValuesForDimId(
        ItemId                          _itemId,
        WHSReservationHierarchyLevel    _upperHierarchyLevel,
        InventDimId                     _inventDimId,
        boolean                         _skipFirstRecordValidation,
        boolean                         _includeDelta,
        CreatedTransactionId            _ttsId)
    {
        if (!_itemId
            || (_includeDelta && !_ttsId)
            || !isConfigurationkeyEnabled(configurationKeyNum(WHSandTMS)))
        {
            return null;
        }

        boolean includeCW = WHSOnHandSPHelper::canUseWHSCatchWeightForItem(_itemId);

        WHSQueryWithParametersValues sqlWithParams = this.buildInventReserveMinValuesForDimIdSPCallStmt(
            _itemId,
            _upperHierarchyLevel,
            _inventDimId,
            _skipFirstRecordValidation,
            _includeDelta,
            _ttsId,
            includeCW);
        
        WHSInventReserveQuantities quantities;
        Connection connection;
        Statement statement;

        try
        {
            connection = new Connection();
            statement = connection.createStatement();
            
            ResultSet resultSet = statement.executeQueryWithParameters(sqlWithParams.parmStatement(), sqlWithParams.parmParameters());

            if (!resultSet.next())
            {
                quantities = WHSInventReserveQuantities::newDefault();
            }
            else if (resultSet.getBoolean(1))
            {
                quantities = WHSInventReserveQuantities::newDefault();

                quantities.availPhysical  = resultSet.getReal(2);
                quantities.availOrdered   = resultSet.getReal(3);
            
                if (includeCW)
                {
                    quantities.CWAvailPhysical  = resultSet.getReal(4);
                    quantities.CWAvailOrdered   = resultSet.getReal(5);
                }
            }
            // else quantities variable should be non-initialized
        }
        finally
        {
            if (statement)
            {
                statement.close();
            }

            if (connection)
            {
                connection.finalize();
            }
        }

        return quantities;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCreateInventReserveMinValuesForDimIdSPStmt</Name>
				<Source><![CDATA[
    private str buildCreateInventReserveMinValuesForDimIdSPStmt(boolean _includeDelta, boolean _includeCW)
    {
        /*

        --------------------- NO DELTA VERSION ---------------------

        CREATE PROCEDURE [CWWHSInventReserveMinValuesForDimId]
            @PARTITION bigint,
            @DATAAREAID nvarchar (4),
            @UPPERLEVELOFMINIMUMCALCULATION int,
            @ITEMID nvarchar (20),
            @INVENTDIMID nvarchar (20),
            @SkipFirstRecordValidation BIT,
            -- Output parameters
            @VALUESFOUND BIT OUTPUT,
            @AVAILPHYSICAL numeric(32, 6) OUTPUT,
            @AVAILORDERED numeric(32, 6) OUTPUT
            ,@CWAVAILPHYSICAL numeric(32, 6) OUTPUT,
            @CWAVAILORDERED numeric(32, 6) OUTPUT
        AS

        -- Without nocount on the procedure will return number of affected rows in the result set which is
        -- harmful to performance and requires us to adjust field retrieval when calling the stored procedure
        SET NOCOUNT ON;

        DECLARE @InventReserve_AvailPhysical numeric(32, 6);
        DECLARE @InventReserve_AvailOrdered numeric(32, 6);
        DECLARE @InventReserve_CWAvailPhysical numeric(32, 6);
        DECLARE @InventReserve_CWAvailOrdered numeric(32, 6);
        DECLARE @InventReserve_ParentInventDimId nvarchar (20);
        DECLARE @InventReserve_RecId bigint;
        DECLARE @InventReserve_HierarchyLevel int;
        DECLARE @LocalHierarchyCount int = 0;
        DECLARE @LocalParentInventDimId nvarchar (20) = @INVENTDIMID;

        SET @VALUESFOUND = 0;
        WHILE ISNULL(@LocalParentInventDimId, '') <> ''
        BEGIN
            SET @LocalHierarchyCount = @LocalHierarchyCount + 1;
            IF @LocalHierarchyCount >= 1024 THROW 51001, 'WHSInventReserveMinValuesForDimId', 1;

            SET @InventReserve_RecId = 0;

            SELECT TOP 1
                @InventReserve_RecId = RECID,
                @InventReserve_ParentInventDimId = PARENTINVENTDIMID,
                @InventReserve_HierarchyLevel = HIERARCHYLEVEL,
                @InventReserve_AvailPhysical = AVAILPHYSICAL,
                @InventReserve_AvailOrdered = AVAILORDERED
                ,@InventReserve_CWAvailPhysical = CWAVAILPHYSICAL,
                @InventReserve_CWAvailOrdered = CWAVAILORDERED
            FROM WHSINVENTRESERVE
            WHERE WHSINVENTRESERVE.ITEMID = @ITEMID
                AND WHSINVENTRESERVE.INVENTDIMID = @LocalParentInventDimId
                AND WHSINVENTRESERVE.PARTITION = @PARTITION
                AND WHSINVENTRESERVE.DATAAREAID = @DATAAREAID;

            IF ISNULL(@InventReserve_HierarchyLevel, 0) < @UPPERLEVELOFMINIMUMCALCULATION AND ISNULL(@InventReserve_RecId, 0) <> 0 AND (@LocalHierarchyCount > 1 OR @SkipFirstRecordValidation = 0) BREAK;

            IF ISNULL(@InventReserve_RecId, 0) <> 0
            BEGIN
                SET @AVAILPHYSICAL = IIF(@AVAILPHYSICAL > ISNULL(@InventReserve_AvailPhysical, 0) OR @VALUESFOUND = 0, ISNULL(@InventReserve_AvailPhysical, 0), @AVAILPHYSICAL);
                SET @AVAILORDERED = IIF(@AVAILORDERED > ISNULL(@InventReserve_AvailOrdered, 0) OR @VALUESFOUND = 0, ISNULL(@InventReserve_AvailOrdered, 0), @AVAILORDERED);
                SET @CWAVAILPHYSICAL = IIF(@CWAVAILPHYSICAL > ISNULL(@InventReserve_CWAvailPhysical, 0) OR @VALUESFOUND = 0, ISNULL(@InventReserve_CWAvailPhysical, 0), @CWAVAILPHYSICAL);
                SET @CWAVAILORDERED = IIF(@CWAVAILORDERED > ISNULL(@InventReserve_CWAvailOrdered, 0) OR @VALUESFOUND = 0, ISNULL(@InventReserve_CWAvailOrdered, 0), @CWAVAILORDERED);
                SET @VALUESFOUND = 1;
            END
            ELSE BREAK;

            IF ISNULL(@InventReserve_RecId, 0) <> 0 SET @LocalParentInventDimId = ISNULL(@InventReserve_ParentInventDimId, '')
            ELSE SET @LocalParentInventDimId = '';
        END; -- WHILE

        --------------------- WITH DELTA VERSION ---------------------

        CREATE PROCEDURE [CWWHSInventReserveMinValuesForDimIdWithDelta]
            @PARTITION bigint,
            @DATAAREAID nvarchar (4),
            @UPPERLEVELOFMINIMUMCALCULATION int,
            @ITEMID nvarchar (20),
            @INVENTDIMID nvarchar (20),
            @SkipFirstRecordValidation BIT,
            @TTSId bigint,
            -- Output parameters
            @VALUESFOUND BIT OUTPUT,
            @AVAILPHYSICAL numeric(32, 6) OUTPUT,
            @AVAILORDERED numeric(32, 6) OUTPUT
            ,@CWAVAILPHYSICAL numeric(32, 6) OUTPUT,
            @CWAVAILORDERED numeric(32, 6) OUTPUT
        AS

        -- Without nocount on the procedure will return number of affected rows in the result set which is
        -- harmful to performance and requires us to adjust field retrieval when calling the stored procedure
        SET NOCOUNT ON;

        DECLARE @InventReserve_AvailPhysical numeric(32, 6);
        DECLARE @InventReserve_AvailOrdered numeric(32, 6);
        DECLARE @InventReserve_CWAvailPhysical numeric(32, 6);
        DECLARE @InventReserve_CWAvailOrdered numeric(32, 6);
        DECLARE @InventReserve_ParentInventDimId nvarchar (20);
        DECLARE @InventReserve_RecId bigint;
        DECLARE @InventReserve_HierarchyLevel int;
        DECLARE @InventReserveDelta_AvailPhysical numeric(32, 6);
        DECLARE @InventReserveDelta_AvailOrdered numeric(32, 6);
        DECLARE @InventReserveDelta_CWAvailPhysical numeric(32, 6);
        DECLARE @InventReserveDelta_CWAvailOrdered numeric(32, 6);
        DECLARE @InventReserveDelta_ParentInventDimId nvarchar (20);
        DECLARE @InventReserveDelta_RecId bigint;
        DECLARE @InventReserveDelta_HierarchyLevel int;
        DECLARE @LocalHierarchyCount int = 0;
        DECLARE @LocalParentInventDimId nvarchar (20) = @INVENTDIMID;

        SET @VALUESFOUND = 0;
        WHILE ISNULL(@LocalParentInventDimId, '') <> ''
        BEGIN
            SET @LocalHierarchyCount = @LocalHierarchyCount + 1;
            IF @LocalHierarchyCount >= 1024 THROW 51001, 'WHSInventReserveMinValuesForDimId', 1;

            SET @InventReserve_RecId = 0;

            SELECT TOP 1
                @InventReserve_RecId = RECID,
                @InventReserve_ParentInventDimId = PARENTINVENTDIMID,
                @InventReserve_HierarchyLevel = HIERARCHYLEVEL,
                @InventReserve_AvailPhysical = AVAILPHYSICAL,
                @InventReserve_AvailOrdered = AVAILORDERED
                ,@InventReserve_CWAvailPhysical = CWAVAILPHYSICAL,
                @InventReserve_CWAvailOrdered = CWAVAILORDERED
            FROM WHSINVENTRESERVE
            WHERE WHSINVENTRESERVE.ITEMID = @ITEMID
                AND WHSINVENTRESERVE.INVENTDIMID = @LocalParentInventDimId
                AND WHSINVENTRESERVE.PARTITION = @PARTITION
                AND WHSINVENTRESERVE.DATAAREAID = @DATAAREAID;

            IF ISNULL(@InventReserve_HierarchyLevel, 0) < @UPPERLEVELOFMINIMUMCALCULATION AND ISNULL(@InventReserve_RecId, 0) <> 0 AND (@LocalHierarchyCount > 1 OR @SkipFirstRecordValidation = 0) BREAK;

            SET @InventReserveDelta_RecId = 0;

            SELECT TOP 1
                @InventReserveDelta_RecId = MAX(RECID),
                @InventReserveDelta_ParentInventDimId = MAX(PARENTINVENTDIMID),
                @InventReserveDelta_HierarchyLevel = MAX(HIERARCHYLEVEL),
                @InventReserveDelta_AvailPhysical = SUM(AVAILPHYSICAL),
                @InventReserveDelta_AvailOrdered = SUM(AVAILORDERED)
                ,@InventReserveDelta_CWAvailPhysical = SUM(CWAVAILPHYSICAL),
                @InventReserveDelta_CWAvailOrdered = SUM(CWAVAILORDERED)
            FROM WHSINVENTRESERVEDELTA
            WHERE WHSINVENTRESERVEDELTA.ITEMID = @ITEMID
                AND WHSINVENTRESERVEDELTA.INVENTDIMID = @LocalParentInventDimId
                AND WHSINVENTRESERVEDELTA.PARTITION = @PARTITION
                AND WHSINVENTRESERVEDELTA.DATAAREAID = @DATAAREAID
                AND WHSINVENTRESERVEDELTA.TTSID = @TTSId;

            IF ISNULL(@InventReserveDelta_HierarchyLevel, 0) < @UPPERLEVELOFMINIMUMCALCULATION AND ISNULL(@InventReserveDelta_RecId, 0) <> 0 AND (@LocalHierarchyCount > 1 OR @SkipFirstRecordValidation = 0) BREAK;

            IF ISNULL(@InventReserve_RecId, 0) <> 0
                OR ISNULL(@InventReserveDelta_RecId, 0) <> 0
            BEGIN
                SET @AVAILPHYSICAL = IIF((@AVAILPHYSICAL > ISNULL(@InventReserve_AvailPhysical, 0) + ISNULL(@InventReserveDelta_AvailPhysical, 0)) OR @VALUESFOUND = 0, ISNULL(@InventReserve_AvailPhysical, 0) + ISNULL(@InventReserveDelta_AvailPhysical, 0), @AVAILPHYSICAL);
                SET @AVAILORDERED = IIF((@AVAILORDERED > ISNULL(@InventReserve_AvailOrdered, 0) + ISNULL(@InventReserveDelta_AvailOrdered, 0)) OR @VALUESFOUND = 0, ISNULL(@InventReserve_AvailOrdered, 0) + ISNULL(@InventReserveDelta_AvailOrdered, 0), @AVAILORDERED);
                SET @CWAVAILPHYSICAL = IIF((@CWAVAILPHYSICAL > ISNULL(@InventReserve_CWAvailPhysical, 0) + ISNULL(@InventReserveDelta_CWAvailPhysical, 0)) OR @VALUESFOUND = 0, ISNULL(@InventReserve_CWAvailPhysical, 0) + ISNULL(@InventReserveDelta_CWAvailPhysical, 0), @CWAVAILPHYSICAL);
                SET @CWAVAILORDERED = IIF((@CWAVAILORDERED > ISNULL(@InventReserve_CWAvailOrdered, 0) + ISNULL(@InventReserveDelta_CWAvailOrdered, 0)) OR @VALUESFOUND = 0, ISNULL(@InventReserve_CWAvailOrdered, 0) + ISNULL(@InventReserveDelta_CWAvailOrdered, 0), @CWAVAILORDERED);
                SET @VALUESFOUND = 1;
            END
            ELSE BREAK;

            IF ISNULL(@InventReserve_RecId, 0) <> 0 SET @LocalParentInventDimId = ISNULL(@InventReserve_ParentInventDimId, '')
            ELSE IF ISNULL(@InventReserveDelta_RecId, 0) <> 0 SET @LocalParentInventDimId = ISNULL(@InventReserveDelta_ParentInventDimId, '')
            ELSE SET @LocalParentInventDimId = '';
        END; -- WHILE

        */

        str             ret = '';
        str             spName = WhsOnHandSPHelper::inventReserveMinValuesForDimIdStoredProcedureName(_includeDelta, _includeCW);

        ret += strFmt('CREATE PROCEDURE [%1]\n', spName);
        ret +=        '    @PARTITION bigint,\n';
        ret += strFmt('    @DATAAREAID %1,\n', this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, DataAreaId)));
        ret += strFmt('    %1 int,\n', UpperLevelOfMinimumCalculationParamName);
        ret += strFmt('    @ITEMID %1,\n', this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, ItemId)));
        ret += strFmt('    @INVENTDIMID %1,\n', this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, InventDimId)));
        ret +=        '    @SkipFirstRecordValidation BIT,\n';

        if (_includeDelta)
        {
            ret += strFmt('    %1 %2,\n', TTSIdParmName, this.sqlTypeNameForField(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, TTSId)));
        }

        ret +=        '    -- Output parameters\n';
        
        ret += strFmt('    %1 BIT OUTPUT,\n', ValuesFoundParmName);
        ret += strFmt('    %1 %2 OUTPUT,\n', AvailPhysicalParmName, this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, AvailPhysical)));
        ret += strFmt('    %1 %2 OUTPUT\n', AvailOrderedParmName, this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventreserve, AvailOrdered)));

        if (_includeCW)
        {
            ret += strFmt('    ,%1 %2 OUTPUT,\n', CWAvailPhysicalParmName, this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, CWAvailPhysical)));
            ret += strFmt('    %1 %2 OUTPUT\n', CWAvailOrderedParmName, this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventreserve, CWAvailOrdered)));
        }

        ret +=        'AS\n\n';

        ret +=        '-- Without nocount on the procedure will return number of affected rows in the result set which is\n';
        ret +=        '-- harmful to performance and requires us to adjust field retrieval when calling the stored procedure\n';
        ret +=        'SET NOCOUNT ON;\n\n';

        ret += strfmt('DECLARE @InventReserve_AvailPhysical %1;\n', this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, AvailPhysical)));
        ret += strfmt('DECLARE @InventReserve_AvailOrdered %1;\n', this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, AvailOrdered)));

        if (_includeCW)
        {
            ret += strfmt('DECLARE @InventReserve_CWAvailPhysical %1;\n', this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, CWAvailPhysical)));
            ret += strfmt('DECLARE @InventReserve_CWAvailOrdered %1;\n', this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, CWAvailOrdered)));
        }

        ret += strfmt('DECLARE @InventReserve_ParentInventDimId %1;\n', this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, InventDimId)));
        ret += strfmt('DECLARE @InventReserve_RecId %1;\n', this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, RecId)));
        ret +=        'DECLARE @InventReserve_HierarchyLevel int;\n';
        
        if (_includeDelta)
        {
            ret += strfmt('DECLARE @InventReserveDelta_AvailPhysical %1;\n', this.sqlTypeNameForField(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, AvailPhysical)));
            ret += strfmt('DECLARE @InventReserveDelta_AvailOrdered %1;\n', this.sqlTypeNameForField(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, AvailOrdered)));

            if (_includeCW)
            {
                ret += strfmt('DECLARE @InventReserveDelta_CWAvailPhysical %1;\n', this.sqlTypeNameForField(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, CWAvailPhysical)));
                ret += strfmt('DECLARE @InventReserveDelta_CWAvailOrdered %1;\n', this.sqlTypeNameForField(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, CWAvailOrdered)));
            }

            ret += strfmt('DECLARE @InventReserveDelta_ParentInventDimId %1;\n', this.sqlTypeNameForField(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, InventDimId)));
            ret += strfmt('DECLARE @InventReserveDelta_RecId %1;\n', this.sqlTypeNameForField(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, RecId)));
            ret +=        'DECLARE @InventReserveDelta_HierarchyLevel int;\n';
        }
        
        ret +=        'DECLARE @LocalHierarchyCount int = 0;\n';
        ret += strfmt('DECLARE @LocalParentInventDimId %1 = @INVENTDIMID;\n\n', this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, InventDimId)));
        ret += strFmt('SET %1 = 0;\n', ValuesFoundParmName);

        ret +=        'WHILE ISNULL(@LocalParentInventDimId, \'\') <> \'\'\n';
        ret +=        'BEGIN\n';
        ret +=        '    SET @LocalHierarchyCount = @LocalHierarchyCount + 1;\n';
        ret += strFmt('    IF @LocalHierarchyCount >= %1 THROW 51001, \'%2\', 1;\n\n', #INVALIDHIERARCHYLEVEL, WHSInventReserveMinValuesForDimIdSPName);

        ret +=        '    SET @InventReserve_RecId = 0;\n\n';

        ret +=        '    SELECT TOP 1\n';
        ret += strFmt('        @InventReserve_RecId = %1,\n', this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, RecId)));
        ret += strFmt('        @InventReserve_ParentInventDimId = %1,\n', this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, ParentInventDimId)));
        ret += strFmt('        @InventReserve_HierarchyLevel = %1,\n', this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, HierarchyLevel)));
        ret += strFmt('        @InventReserve_AvailPhysical = %1,\n', this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, AvailPhysical)));
        ret += strFmt('        @InventReserve_AvailOrdered = %1\n', this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, AvailOrdered)));

        if (_includeCW)
        {
            ret += strFmt('        ,@InventReserve_CWAvailPhysical = %1,\n', this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, CWAvailPhysical)));
            ret += strFmt('        @InventReserve_CWAvailOrdered = %1\n', this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, CWAvailOrdered)));
        }

        ret += strFmt('    FROM %1\n', this.sqlTableName(tableNum(WHSInventReserve)));

        ret += strFmt('    WHERE %1.%2 = @ITEMID\n', this.sqlTableName(tableNum(WHSInventReserve)), this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, ItemId)));
        ret += strFmt('        AND %1.%2 = @LocalParentInventDimId\n', this.sqlTableName(tableNum(WHSInventReserve)), this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, InventDimId)));
        ret += strFmt('        AND %1.%2 = @PARTITION\n', this.sqlTableName(tableNum(WHSInventReserve)), this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, Partition)));
        ret += strFmt('        AND %1.%2 = @DATAAREAID;\n\n', this.sqlTableName(tableNum(WHSInventReserve)), this.sqlFieldName(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, DataAreaId)));

        ret += strFmt('    IF ISNULL(@InventReserve_HierarchyLevel, 0) < %1 AND ISNULL(@InventReserve_RecId, 0) <> 0 AND (@LocalHierarchyCount > 1 OR @SkipFirstRecordValidation = 0) BREAK;\n\n', UpperLevelOfMinimumCalculationParamName);

        if (_includeDelta)
        {
            ret +=        '    SET @InventReserveDelta_RecId = 0;\n\n';

            ret +=        '    SELECT TOP 1\n';
            ret += strFmt('        @InventReserveDelta_RecId = MAX(%1),\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, RecId)));
            ret += strFmt('        @InventReserveDelta_ParentInventDimId = MAX(%1),\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, ParentInventDimId)));
            ret += strFmt('        @InventReserveDelta_HierarchyLevel = MAX(%1),\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, HierarchyLevel)));
            ret += strFmt('        @InventReserveDelta_AvailPhysical = SUM(%1),\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, AvailPhysical)));
            ret += strFmt('        @InventReserveDelta_AvailOrdered = SUM(%1)\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, AvailOrdered)));

            if (_includeCW)
            {
                ret += strFmt('        ,@InventReserveDelta_CWAvailPhysical = SUM(%1),\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, CWAvailPhysical)));
                ret += strFmt('        @InventReserveDelta_CWAvailOrdered = SUM(%1)\n', this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, CWAvailOrdered)));
            }

            ret += strFmt('    FROM %1\n', this.sqlTableName(tableNum(WHSInventReserveDelta)));

            ret += strFmt('    WHERE %1.%2 = @ITEMID\n', this.sqlTableName(tableNum(WHSInventReserveDelta)), this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, ItemId)));
            ret += strFmt('        AND %1.%2 = @LocalParentInventDimId\n', this.sqlTableName(tableNum(WHSInventReserveDelta)), this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, InventDimId)));
            ret += strFmt('        AND %1.%2 = @PARTITION\n', this.sqlTableName(tableNum(WHSInventReserveDelta)), this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, Partition)));
            ret += strFmt('        AND %1.%2 = @DATAAREAID\n', this.sqlTableName(tableNum(WHSInventReserveDelta)), this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, DataAreaId)));
            ret += strFmt('        AND %1.%2 = %3;\n\n', this.sqlTableName(tableNum(WHSInventReserveDelta)), this.sqlFieldName(tableNum(WHSInventReserveDelta), fieldNum(WHSInventReserveDelta, ttsId)), TTSIdParmName);

            ret += strFmt('    IF ISNULL(@InventReserveDelta_HierarchyLevel, 0) < %1 AND ISNULL(@InventReserveDelta_RecId, 0) <> 0 AND (@LocalHierarchyCount > 1 OR @SkipFirstRecordValidation = 0) BREAK;\n\n', UpperLevelOfMinimumCalculationParamName);
        }

        ret +=        '    IF ISNULL(@InventReserve_RecId, 0) <> 0\n';

        if (_includeDelta)
        {
            ret +=        '        OR ISNULL(@InventReserveDelta_RecId, 0) <> 0\n';
        }

        ret +=        '    BEGIN\n';

        if (_includeDelta)
        {
            ret += strFmt('        SET %1 = IIF((%1 > ISNULL(@InventReserve_AvailPhysical, 0) + ISNULL(@InventReserveDelta_AvailPhysical, 0)) OR %2 = 0, ISNULL(@InventReserve_AvailPhysical, 0) + ISNULL(@InventReserveDelta_AvailPhysical, 0), %1);\n', AvailPhysicalParmName, ValuesFoundParmName);
            ret += strFmt('        SET %1 = IIF((%1 > ISNULL(@InventReserve_AvailOrdered, 0) + ISNULL(@InventReserveDelta_AvailOrdered, 0)) OR %2 = 0, ISNULL(@InventReserve_AvailOrdered, 0) + ISNULL(@InventReserveDelta_AvailOrdered, 0), %1);\n', AvailOrderedParmName, ValuesFoundParmName);

            if (_includeCW)
            {
                ret += strFmt('        SET %1 = IIF((%1 > ISNULL(@InventReserve_CWAvailPhysical, 0) + ISNULL(@InventReserveDelta_CWAvailPhysical, 0)) OR %2 = 0, ISNULL(@InventReserve_CWAvailPhysical, 0) + ISNULL(@InventReserveDelta_CWAvailPhysical, 0), %1);\n', CWAvailPhysicalParmName, ValuesFoundParmName);
                ret += strFmt('        SET %1 = IIF((%1 > ISNULL(@InventReserve_CWAvailOrdered, 0) + ISNULL(@InventReserveDelta_CWAvailOrdered, 0)) OR %2 = 0, ISNULL(@InventReserve_CWAvailOrdered, 0) + ISNULL(@InventReserveDelta_CWAvailOrdered, 0), %1);\n', CWAvailOrderedParmName, ValuesFoundParmName);
            }
        }
        else
        {
            ret += strFmt('        SET %1 = IIF(%1 > ISNULL(@InventReserve_AvailPhysical, 0) OR %2 = 0, ISNULL(@InventReserve_AvailPhysical, 0), %1);\n', AvailPhysicalParmName, ValuesFoundParmName);
            ret += strFmt('        SET %1 = IIF(%1 > ISNULL(@InventReserve_AvailOrdered, 0) OR %2 = 0, ISNULL(@InventReserve_AvailOrdered, 0), %1);\n', AvailOrderedParmName, ValuesFoundParmName);

            if (_includeCW)
            {
                ret += strFmt('        SET %1 = IIF(%1 > ISNULL(@InventReserve_CWAvailPhysical, 0) OR %2 = 0, ISNULL(@InventReserve_CWAvailPhysical, 0), %1);\n', CWAvailPhysicalParmName, ValuesFoundParmName);
                ret += strFmt('        SET %1 = IIF(%1 > ISNULL(@InventReserve_CWAvailOrdered, 0) OR %2 = 0, ISNULL(@InventReserve_CWAvailOrdered, 0), %1);\n', CWAvailOrderedParmName, ValuesFoundParmName);
            }
        }

        ret += strFmt('        SET %1 = 1;\n', ValuesFoundParmName);
        ret +=        '    END\n';
        ret +=        '    ELSE BREAK;\n\n';

        ret +=        '    IF ISNULL(@InventReserve_RecId, 0) <> 0 SET @LocalParentInventDimId = ISNULL(@InventReserve_ParentInventDimId, \'\')\n';

        if (_includeDelta)
        {
            ret +=        '    ELSE IF ISNULL(@InventReserveDelta_RecId, 0) <> 0 SET @LocalParentInventDimId = ISNULL(@InventReserveDelta_ParentInventDimId, \'\')\n';
        }

        ret +=        '    ELSE SET @LocalParentInventDimId = \'\';\n';

        ret +=        'END; -- WHILE\n';

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventReserveMinValuesForDimIdSPCallStmtCacheKey</Name>
				<Source><![CDATA[
    private str getInventReserveMinValuesForDimIdSPCallStmtCacheKey(
        boolean                         _includeDelta,
        boolean                         _includeCW)
    {
        return strFmt('%1#%2#%3', WHSInventReserveMinValuesForDimIdSPCallStmtCacheKey, _includeDelta ? 1 : 0, _includeCW ? 1 : 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildInventReserveMinValuesForDimIdSPCallStmt</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal WHSQueryWithParametersValues buildInventReserveMinValuesForDimIdSPCallStmt(
        ItemId                          _itemId,
        WHSReservationHierarchyLevel    _upperHierarchyLevel,
        InventDimId                     _inventDimId,
        boolean                         _skipFirstRecordValidation,
        boolean                         _includeDelta,
        CreatedTransactionId            _ttsId,
        boolean                         _includeCW)
    {
        SysGlobalCache      globalCache = classfactory.globalCache();
        str                 cacheKey = this.getInventReserveMinValuesForDimIdSPCallStmtCacheKey(_includeDelta, _includeCW);
        str                 ret = globalCache.get(WHSInventReserveMinValuesForDimIdCacheScope, cacheKey, '');

        if (!ret)
        {
            str spName = WHSOnHandSPHelper::inventReserveMinValuesForDimIdStoredProcedureName(_includeDelta, _includeCW);

            ret += strFmt('DECLARE %1 BIT;\n', ValuesFoundParmName);
            ret += strFmt('DECLARE %1 %2;\n', AvailPhysicalParmName, this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, AvailPhysical)));
            ret += strFmt('DECLARE %1 %2;\n', AvailOrderedParmName, this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, AvailOrdered)));
        
            if (_includeCW)
            {
                ret += strFmt('DECLARE %1 %2;\n', CWAvailPhysicalParmName, this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, CWAvailPhysical)));
                ret += strFmt('DECLARE %1 %2;\n', CWAvailOrderedParmName, this.sqlTypeNameForField(tableNum(WHSInventReserve), fieldNum(WHSInventReserve, CWAvailOrdered)));
            }
        
            ret += strFmt('EXECUTE %1\n', spName);
            ret += strFmt('@DATAAREAID = @%1,\n', DataAreaIdParmValue);
            ret += strFmt('@PARTITION = @%1,\n', PartitionParmValue);
            ret += strFmt('@ITEMID = @%1,\n', ItemIdParmValue);
            ret += strFmt('%1 = @%2,\n', UpperLevelOfMinimumCalculationParamName, UpperLevelOfMinimumCalculationParmValue);
            ret += strFmt('@INVENTDIMID = @%1,\n', InventDimParmValue);
            ret += strFmt('@SkipFirstRecordValidation = @%1,\n', SkipFirstRecordValidationParmValue);

            if (_includeDelta)
            {
                ret += strFmt('%1 = @%2,\n', TTSIdParmName, TTSIdParmValue);
            }

            ret += strFmt('%1 = %1 output,\n', ValuesFoundParmName);
            ret += strFmt('%1 = %1 output,\n', AvailPhysicalParmName);
            ret += strFmt('%1 = %1 output\n', AvailOrderedParmName);

            if (_includeCW)
            {
                ret += strFmt(',%1 = %1 output,\n', CWAvailPhysicalParmName);
                ret += strFmt('%1 = %1 output\n', CWAvailOrderedParmName);
            }

            ret +=        ';\n';

            ret += strFmt('SELECT %1 as [VALUESFOUND],\n', ValuesFoundParmName);
            ret += strFmt('    %1 as [AVAILPHYSICAL],\n', AvailPhysicalParmName);
            ret += strFmt('    %1 as [AVAILORDERED]\n', AvailOrderedParmName);

            if (_includeCW)
            {
                ret += strFmt(',%1 as [CWAVAILPHYSICAL],\n', CWAvailPhysicalParmName);
                ret += strFmt('    %1 as [CWAVAILORDERED]', CWAvailOrderedParmName);
            }

            ret +=       ';\n';

            globalCache.set(WHSInventReserveMinValuesForDimIdCacheScope, cacheKey, ret);
        }

        Map paramMap = SqlParams::create();
        paramMap.add(DataAreaIdParmValue, curExt());
        paramMap.add(PartitionParmValue, getCurrentPartitionRecId());
        paramMap.add(ItemIdParmValue, _itemId);
        paramMap.add(UpperLevelOfMinimumCalculationParmValue, _upperHierarchyLevel);
        paramMap.add(InventDimParmValue, _inventDimId);
        paramMap.add(SkipFirstRecordValidationParmValue, _skipFirstRecordValidation ? 1 : 0);

        if (_includeDelta)
        {
            paramMap.add(TTSIdParmValue, _ttsId);
        }

        return WHSQueryWithParametersValues::construct(ret, paramMap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventReserveMinValuesForDimIdStoredProcedures</Name>
				<Source><![CDATA[
    private static void createInventReserveMinValuesForDimIdStoredProcedures()
    {
        WHSOnHandSPHelper::createInventReserveMinValuesForDimIdStoredProcedure(true, false);
        WHSOnHandSPHelper::createInventReserveMinValuesForDimIdStoredProcedure(false, false);

        if (WHSOnHandSPHelper::canUseWHSCatchWeight())
        {
            WHSOnHandSPHelper::createInventReserveMinValuesForDimIdStoredProcedure(true, true);
            WHSOnHandSPHelper::createInventReserveMinValuesForDimIdStoredProcedure(false, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventReserveMinValuesForDimIdStoredProcedure</Name>
				<Source><![CDATA[
    private static void createInventReserveMinValuesForDimIdStoredProcedure(boolean _includeDelta, boolean _includeCW)
    {
        WHSOnHandSPHelper   helper = WHSOnHandSPHelper::construct();
        Statement           statement = new Connection().createStatement();
        str                 sqlStmt = helper.buildCreateInventReserveMinValuesForDimIdSPStmt(_includeDelta, _includeCW);

        statement.executeUpdateWithParameters(sqlStmt, null);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dropInventReserveMinValuesForDimIdStoredProcedures</Name>
				<Source><![CDATA[
    private static void dropInventReserveMinValuesForDimIdStoredProcedures()
    {
        WHSOnHandSPHelper::dropInventReserveMinValuesForDimIdStoredProcedure(true, true);
        WHSOnHandSPHelper::dropInventReserveMinValuesForDimIdStoredProcedure(false, true);
        WHSOnHandSPHelper::dropInventReserveMinValuesForDimIdStoredProcedure(true, false);
        WHSOnHandSPHelper::dropInventReserveMinValuesForDimIdStoredProcedure(false, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dropInventReserveMinValuesForDimIdStoredProcedure</Name>
				<Source><![CDATA[
    private static void dropInventReserveMinValuesForDimIdStoredProcedure(boolean _includeDelta, boolean _includeCW)
    {
        str procedureName = WHSOnHandSPHelper::inventReserveMinValuesForDimIdStoredProcedureName(_includeDelta, _includeCW);

        WHSOnHandSPHelper::dropSqlOnHandUnionAllDeltaTVFByName(procedureName);
        WHSOnHandSPHelper::dropSqlStoredProcedureByName(procedureName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventReserveMinValuesForDimIdStoredProcedureName</Name>
				<Source><![CDATA[
    private static str inventReserveMinValuesForDimIdStoredProcedureName(boolean _includeDelta, boolean _includeCW)
    {
        if (_includeCW)
        {
            return _includeDelta ? CWWHSInventReserveMinValuesForDimIdWithDeltaSPName : CWWHSInventReserveMinValuesForDimIdSPName;
        }

        return _includeDelta ? WHSInventReserveMinValuesForDimIdWithDeltaSPName : WHSInventReserveMinValuesForDimIdSPName;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>