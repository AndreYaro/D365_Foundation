<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSPrintLabels</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WHSPrintLabels</c> class handles business logic for label printing wave step.
/// </summary>
public final class WHSPrintLabels
{
    private WHSWaveId                                   waveId;
    private WHSWaveStepCode                             waveStepCode;
    private WHSWorkBuildId                              workBuildId;
    private WHSWaveLabelTemplateRecId                   waveLabelTemplateRecId;
    private WHSWaveLabelBuildId                         waveLabelBuildId;
    private boolean                                     sendLabelsToPrinter;
    private boolean                                     sendBreakLabelsToPrinter;
    private WHSWaveMethodSubProgressStatusMethodHandler waveMethodSubProgressStatusHandler;
    private WHSInstrumentationLogger					instrumentationLogger;

    private Map workCacheForTemplateLine = new Map(Types::Int64, Types::Class);
    private Map workLineCacheForTemplateLine = new Map(Types::Int64, Types::Class);

    private boolean                                     searchForVoidedLabelsWhenCreatingLabels;
    private static boolean WHSPrintLabelPerfOptimizationsFlightEnabled = WHSPrintLabelPerfOptimizationsFlight::instance().isEnabled();

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    private void new()
    {
        sendLabelsToPrinter = true;
        sendBreakLabelsToPrinter = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    private static WHSPrintLabels construct()
    {
        return new WHSPrintLabels();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromWave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the class <c>WHSPrintLabels</c> setting the wave ID and the wave step code in the instance.
    /// </summary>
    /// <param name = "_waveId">The wave ID being used in the class.</param>
    /// <param name = "_waveStepCode">The wave step code used to filter which templates to look at.</param>
    /// <param name = "_waveMethodStatusHandler">The wave method status handler.</param>
    /// <returns>A new instance of the <c>WHSPrintLabels</c> class.</returns>
    [Hookable(false)]
    public static WHSPrintLabels newFromWave(
        WHSWaveId					_waveId,
        WHSWaveStepCode				_waveStepCode,
        WHSWaveMethodStatusHandler	_waveMethodStatusHandler)
    {
        WHSPrintLabels printLabels = WHSPrintLabels::construct();
        printLabels.waveId = _waveId;
        printLabels.waveStepCode = _waveStepCode;
        printLabels.waveMethodSubProgressStatusHandler = WHSWaveMethodSubProgressStatusMethodHandler::constructFromWaveMethodStatusHandler(_waveMethodStatusHandler);
        printLabels.instrumentationLogger = WHSInstrumentationLogger::createLogger(classId2Name(classIdGet(printLabels)));

        return printLabels;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromLabelHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the class <c>WHSPrintLabels</c> setting the wave ID and the wave step code in the instance.
    /// </summary>
    /// <param name = "_waveId">The wave ID being used in the class.</param>
    /// <param name = "_waveLabelTemplateRecId">The wave label template record ID.</param>
    /// <param name = "_labelBuildId">The label build ID.</param>
    /// <returns>A new instance of the <c>WHSPrintLabels</c> class.</returns>
    [Hookable(false)]
    internal static WHSPrintLabels newFromLabelHistory(
        WHSWaveId                   _waveId,
        WHSWaveLabelTemplateRecId   _waveLabelTemplateRecId,
        WHSWaveLabelBuildId         _labelBuildId = '')
    {
        WHSPrintLabels printLabels = WHSPrintLabels::construct();
        printLabels.waveId = _waveId;
        printLabels.waveLabelTemplateRecId = _waveLabelTemplateRecId;
        printLabels.waveLabelBuildId = _labelBuildId;
        printLabels.instrumentationLogger = WHSInstrumentationLogger::createLogger(classId2Name(classIdGet(printLabels)));

        return printLabels;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSendLabelsToPrinter</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean parmSendLabelsToPrinter(boolean _sendLabelsToPrinter = sendLabelsToPrinter)
    {
        sendLabelsToPrinter = _sendLabelsToPrinter;

        return sendLabelsToPrinter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSendBreakLabelsToPrinter</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean parmSendBreakLabelsToPrinter(boolean _sendBreakLabelsToPrinter = sendBreakLabelsToPrinter)
    {
        sendBreakLabelsToPrinter = _sendBreakLabelsToPrinter;

        return sendBreakLabelsToPrinter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForLabelBreak</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks to see if label break criteria is met.
    /// </summary>
    /// <param name="_labelTemplateRecId">
    /// The label template header information whose break fields are being evaluated.
    /// </param>
    /// <param name="_labelTemplateGroupList">
    /// A <c>List</c> object containing the label template group records.
    /// </param>
    /// <param name="_queryRun">
    /// A query run iteration whose results are being evaluated.
    /// </param>
    /// <param name="_groupByFields">
    /// Previously stored off query values used for comparison.
    /// </param>
    /// <returns>
    /// True if break criteria is met; otherwise False.
    /// </returns>
    private boolean checkForLabelBreak(
        WHSWaveLabelTemplateRecId   _labelTemplateRecId,
        List                        _labelTemplateGroupList,
        QueryRun                    _queryRun,
        container                   _groupByFields)
    {
        boolean     ret;
        boolean     first;
    
        if (_groupByFields == conNull())
        {
            first = true;
        }
    
        WHSWaveLabelTemplateGroup   labelTemplateGroup;
        int                         i = 1;

        while select labelTemplateGroup
            order by labelTemplateGroup.LineNumber
            where labelTemplateGroup.LabelTemplate == _labelTemplateRecId
            &&    labelTemplateGroup.LabelTemplateGroupBy == NoYes::Yes
        {
            Common  table = _queryRun.get(labelTemplateGroup.GroupTableId);
            AnyType field = table.(labelTemplateGroup.GroupFieldId);
    
            if (field != conPeek(_groupByFields, i) || first)
            {
                ret = true;
    
                _labelTemplateGroupList.addEnd(labelTemplateGroup);
            }
    
            ++i;
        }
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createGroupByFieldContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a container of field values based on label template grouping criteria.
    /// </summary>
    /// <param name="_labelTemplateRecId">
    /// Record ID of the label template table header record.
    /// </param>
    /// <param name="_queryRun">
    /// The query run object whose results will be used to populate the container.
    /// </param>
    /// <returns>
    /// A container filled with field data values.
    /// </returns>
    /// <remarks>
    /// Containers built in this method will be used to compare data across query run iterations.
    /// </remarks>
    private container createGroupByFieldContainer(
        WHSWaveLabelTemplateRecId   _labelTemplateRecId,
        QueryRun                    _queryRun)
    {
        WHSWaveLabelTemplateGroup   labelTemplateGroup;
        container               ret;
        int                     i = 1;
    
        while select GroupTableId, GroupFieldId from labelTemplateGroup
            order by labelTemplateGroup.LineNumber
            where labelTemplateGroup.LabelTemplate == _labelTemplateRecId
            &&    labelTemplateGroup.LabelTemplateGroupBy == NoYes::Yes
        {
            ret = conPoke(ret, i, _queryRun.get(labelTemplateGroup.GroupTableId).(labelTemplateGroup.GroupFieldId));
    
            ++i;
        }
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWorkAndLineQueryRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Build query run object for work and work line.
    /// </summary>
    /// <param name = "_labelTemplateLine">The wave label template line record.</param>
    /// <returns>An new instance of the <c>PackedQueryRun</c> object.</returns>
    protected QueryRun buildWorkAndLineQueryRun(WHSWaveLabelTemplateLine _labelTemplateLine)
    {
        if (_labelTemplateLine.RunQuery)
        {
            return new QueryRun(_labelTemplateLine.PackedQueryRun);
        }
        
        return new QueryRun(WHSWaveLabelLayout::find(_labelTemplateLine.LabelLayoutId).PackedQueryRun);
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeLabelTemplateLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Evaluates label template detail records and prints appropriate labels.
    /// </summary>
    /// <param name="_labelTemplateRecId">
    /// The label template header information whose template detail lines are being evaluated.
    /// </param>
    /// <param name="_workTableSet">
    /// A set of valid work units used for filtering based on header level break criteria. May be empty.
    /// </param>
    /// <param name="_workLineSet">
    /// A set of valid work lines used for filtering based on line level break criteria. May be empty.
    /// </param>
    private void executeLabelTemplateLines(
        WHSWaveLabelTemplateRecId   _labelTemplateRecId,
        Set                         _workTableSet,
        Set                         _workLineSet)
    {
        using (var activityContext = instrumentationLogger.waveLabelActivities().waveLabelCreate(_labelTemplateRecId))
        {
            WHSWaveLabelTemplateLine labelTemplateLine;

            using (var batchedLabelPrint = WhsBatchedDocumentRoutingContext::construct())
            {
                while select labelTemplateLine
                    order by LabelTemplateSequenceNumber
                    where labelTemplateLine.LabelTemplate == _labelTemplateRecId
                {
                    instrumentationLogger.logRecordInformation(labelTemplateLine);

                    List workList = this.filterListFromTemplateLine(labelTemplateLine, _workTableSet, workCacheForTemplateLine);

                    // Move on to next label template line if query is not successful
                    if (workList.elements() == 0)
                    {
                        continue;
                    }

                    List workLineList = this.filterListFromTemplateLine(labelTemplateLine, _workLineSet, workLineCacheForTemplateLine);

                    instrumentationLogger.waveLabelActivities().waveLabelWorkLineListCount(activityContext, workLineList.elements());
            
                    WHSWaveLabelGenerator labelGenerator = WHSWaveLabelGenerator::newWaveLabelGenerator(labelTemplateLine.LabelGeneratorType);
                    labelGenerator.parmWorkBuildId(workBuildId);
                    labelGenerator.printWorkListLabels(this, labelTemplateLine, workList, workLineList, waveLabelBuildId);
                }

            
                batchedLabelPrint.printBatchedLabels();
            
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkAndLineQueryRun</Name>
				<Source><![CDATA[
    private QueryRun createWorkAndLineQueryRun(WHSWaveLabelTemplateLine _labelTemplateLine)
    {
        QueryRun queryRun = this.buildWorkAndLineQueryRun(_labelTemplateLine);

        QueryBuildDataSource qbdsWorkTable = queryRun.query().dataSourceTable(tableNum(WHSWorkTable));
        qbdsWorkTable.addGroupByField(fieldNum(WHSWorkTable, WorkId));
        qbdsWorkTable.addRange(fieldNum(WHSWorkTable, WorkBuildId)).value(queryValue(workBuildId));
    
        QueryBuildDataSource qbdsWorkLine = queryRun.query().dataSourceTable(tableNum(WHSWorkLine));
        qbdsWorkLine.addGroupByField(fieldNum(WHSWorkLine, RecId));

        WHSPrintLabels::addBuildIdRange(queryRun, waveLabelBuildId);

        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateWorkAndWorkLineCaches</Name>
				<Source><![CDATA[
    private void populateWorkAndWorkLineCaches(WHSWaveLabelTemplateLine _labelTemplateLine)
    {
        QueryRun queryRun = this.createWorkAndLineQueryRun(_labelTemplateLine);

        List workCache = new List(Types::String);
        List workLineCache = new List(Types::Int64);

        while (queryRun.next())
        {
            if (queryRun.changed(tableNum(WHSWorkTable)))
            {
                workCache.addEnd(queryRun.get(tableNum(WHSWorkTable)).(fieldNum(WHSWorkTable, WorkId)));
            }
            if (queryRun.changed(tableNum(WHSWorkLine)))
            {
                workLineCache.addEnd(queryRun.get(tableNum(WHSWorkLine)).RecId);
            }
        }

        workCacheForTemplateLine.insert(_labelTemplateLine.RecId, workCache);
        workLineCacheForTemplateLine.insert(_labelTemplateLine.RecId, workLineCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>filterListFromTemplateLine</Name>
				<Source><![CDATA[
    private List filterListFromTemplateLine(WHSWaveLabelTemplateLine _labelTemplateLine, Set _unfilteredSet, Map _cache)
    {
        if (!_cache.exists(_labelTemplateLine.RecId))
        {
            this.populateWorkAndWorkLineCaches(_labelTemplateLine);
        }

        List filter = _cache.lookup(_labelTemplateLine.RecId);
        
        if (_unfilteredSet.empty())
        {
            // Return everything
            return filter;
        }

        List result = new List(_unfilteredSet.typeId());
        Enumerator enum = filter.getEnumerator();
        while (enum.moveNext())
        {
            if (_unfilteredSet.in(enum.current()))
            {
                result.addEnd(enum.current());

                if (result.elements() == _unfilteredSet.elements())
                {
                    // Found all we were looking for.
                    break;
                }
            }
        }
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSendLabelsToPrinter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the labels can be send to printer.
    /// </summary>
    /// <param name="_labelTemplateLine">
    /// The label template line record.
    /// </param>
    /// <returns>true if the labels should be send to printer; otherwise, false.</returns>
    protected boolean canSendLabelsToPrinter(WHSWaveLabelTemplateLine _labelTemplateLine)
    {
        return sendLabelsToPrinter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSendBreakLabelsToPrinter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the break labels can be send to printer.
    /// </summary>
    /// <param name="_labelTemplateGroup">
    /// The label template record .
    /// </param>
    /// <returns>true if the break labels should be send to printer; otherwise, false.</returns>
    protected boolean canSendBreakLabelsToPrinter(WHSWaveLabelTemplateGroup _labelTemplateGroup)
    {
        return sendBreakLabelsToPrinter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSingleWorkIdFromList</Name>
				<Source><![CDATA[
    private WHSWorkId getSingleWorkIdFromList(List _workList)
    {
        WHSWorkId workId;
  
        if (_workList.elements() == 1)
        {
            ListEnumerator  listEnumerator = _workList.getEnumerator();

            listEnumerator.moveNext();

            workId = listEnumerator.current();
        }

        return workId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePrintedFieldsForWaveLabelAndShipment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update printed fields for wave labels and shipment when wave label is printed.
    /// </summary>
    /// <param name = "_waveLabelIdCon">Wave label id container</param>
    [Hookable(false)]
    internal static void updatePrintedFieldsForWaveLabelAndShipment(container _waveLabelIdCon)
    {
        WHSPrintLabels::updatePrintedFieldsUsingTempTable(_waveLabelIdCon);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePrintedFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update printed fields when wave label is printed.
    /// </summary>
    /// <param name = "_waveLabelIdCon">Wave label id container</param>
    [Hookable(false)]
    internal static void updatePrintedFields(container _waveLabelIdCon)
    {
        str rangeValue = con2Str(_waveLabelIdCon);

        if(rangeValue)
        {
            utcdatetime printedDateTime = DateTimeUtil::utcNow();
            SysUserId   printedBy       = curUserId();
                         
            //update wave labels
            Query                   waveLabelQuery = new Query();
            QueryBuildDataSource    qbdsWaveLabel = waveLabelQuery.addDataSource(tableNum(WHSWaveLabel));

            qbdsWaveLabel.addRange(fieldNum(WHSWaveLabel, WaveLabelId)).value(rangeValue);

            Map fieldSetMap = new Map(Types::String, Types::String);

            fieldSetMap.insert(fieldStr(WHSWaveLabel, Printed), any2Str(NoYes::Yes));
            fieldSetMap.insert(fieldStr(WHSWaveLabel, PrintedDateTime), DateTimeUtil::toStr(printedDateTime));
            fieldSetMap.insert(fieldStr(WHSWaveLabel, PrintedBy), printedBy);

            Query::update_recordset(fieldSetMap, waveLabelQuery);

            //update shipments
            Query                   shipmentQuery = new Query();
            QueryBuildDataSource    qbdsShipment = shipmentQuery.addDataSource(tableNum(WHSShipmentTable));
            QueryBuildDataSource    qbdsWorkLine;

            qbdsWorkLine = qbdsShipment.addDataSource(tableNum(WHSWorkLine));

            qbdsWorkLine.relations(true);
            qbdsWorkLine.joinMode(JoinMode::ExistsJoin);
                    
            qbdsWaveLabel = qbdsWorkLine.addDataSource(tableNum(WHSWaveLabel));
            qbdsWaveLabel.relations(true);
            qbdsWaveLabel.joinMode(JoinMode::InnerJoin);

            qbdsWaveLabel.addRange(fieldNum(WHSWaveLabel, WaveLabelId)).value(rangeValue);
                    
            fieldSetMap = new Map(Types::String, Types::String);

            fieldSetMap.insert(fieldStr(WHSShipmentTable, WaveLabelsPrinted), any2Str(NoYes::Yes));
            fieldSetMap.insert(fieldStr(WHSShipmentTable, WaveLabelsPrintedDateTime), DateTimeUtil::toStr(printedDateTime));
            fieldSetMap.insert(fieldStr(WHSShipmentTable, WaveLabelsPrintedBy), printedBy);

            Query::update_recordset(fieldSetMap, shipmentQuery);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePrintedFieldsUsingTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update printed fields using temp table when wave label is printed.
    /// </summary>
    /// <param name = "_waveLabelIdCon">Wave label id container</param>
    private static void updatePrintedFieldsUsingTempTable(container _waveLabelIdCon)
    {
        if (conLen(_waveLabelIdCon) > 0)
        {
            WHSTmpWaveLabelId tmpWaveLabelIdTable = WHSPrintLabels::buildTempDataSourceForWaveLabelId(_waveLabelIdCon);
            WHSPrintLabels::updateFieldsForWaveLabelAndShipment(tmpWaveLabelIdTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFieldsForWaveLabelAndShipment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update printed fields for wave and shipment table using temp table.
    /// </summary>
    /// <param name = "_tmpWaveLabelIdTable">TempDb table for wave label Ids.</param>
    [Hookable(false)]
    internal static void updateFieldsForWaveLabelAndShipment(WHSTmpWaveLabelId _tmpWaveLabelIdTable)
    {
        utcdatetime printedDateTime = DateTimeUtil::utcNow();
        SysUserId   printedBy       = curUserId();

        WHSWaveLabel waveLabel;

        ttsbegin;

        update_recordset waveLabel
            setting Printed = NoYes::Yes,
                PrintedDateTime = printedDateTime,
                PrintedBy = printedBy
            exists join _tmpWaveLabelIdTable
                where _tmpWaveLabelIdTable.WaveLabelId == waveLabel.WaveLabelId;

        WHSPrintLabels::updateWaveLabelFieldsOfShipmentUsingTempTable(_tmpWaveLabelIdTable, printedDateTime, printedBy);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWaveLabelFieldsOfShipmentUsingTempTable</Name>
				<Source><![CDATA[
    private static void updateWaveLabelFieldsOfShipmentUsingTempTable(WHSTmpWaveLabelId _tmpWaveLabelIdTable, utcdatetime _printedDateTime, SysUserId _printedBy)
    {
        WHSShipmentTable shipmentTable;
        WHSWorkLine workLine;

        WHSWaveLabel waveLabelToUpdateShipment;

        while select ShipmentId from shipmentTable
            exists join workLine
                where workLine.ShipmentId == shipmentTable.ShipmentId
            exists join waveLabelToUpdateShipment
                where waveLabelToUpdateShipment.WorkId == workLine.WorkId
                && waveLabelToUpdateShipment.WorkLineNum == workLine.LineNum
            exists join _tmpWaveLabelIdTable
                where _tmpWaveLabelIdTable.WaveLabelId == waveLabelToUpdateShipment.WaveLabelId
        {
            WHSShipmentWaveLabelDetails shipmentWaveLabelDetails;

            shipmentWaveLabelDetails.ShipmentId = shipmentTable.ShipmentId;
            shipmentWaveLabelDetails.WaveLabelsPrinted = NoYes::Yes;
            shipmentWaveLabelDetails.WaveLabelsPrintedBy = _printedBy;
            shipmentWaveLabelDetails.WaveLabelsPrintedDateTime = _printedDateTime;

            WHSShipmentWaveLabelDetailsTracker::trackShipmentWaveLabelDetails(shipmentWaveLabelDetails);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateLabelTemplateGroupList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a label template group list to be used for break label printing.
    /// </summary>
    /// <param name="_labelTemplateRecId">
    /// The label template header information whose grouping criteria is being stored off.
    /// </param>
    /// <returns>
    /// The <c>List</c> object containing the label template group records.
    /// </returns>
    private List populateLabelTemplateGroupList(WHSWaveLabelTemplateRecId _labelTemplateRecId)
    {
        List labelTemplateGroupList = new List(Types::Record);

        WHSWaveLabelTemplateGroup labelTemplateGroup;
    
        while select labelTemplateGroup
            order by labelTemplateGroup.LineNumber
            where labelTemplateGroup.LabelTemplate == _labelTemplateRecId
            &&    labelTemplateGroup.LabelTemplateGroupBy == NoYes::Yes
        {
            labelTemplateGroupList.addEnd(labelTemplateGroup);
        }

        return labelTemplateGroupList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printBreakLabels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prints break labels if configured in label template group setup.
    /// </summary>
    /// <param name="_labelTemplateGroupList">
    /// The list of templates groups.
    /// </param>
    /// <param name="_labelTemplateRecId">
    /// Label template record id that is used to filter the <c>WHSWaveLabel</c> query data.
    /// </param>
    /// <param name="_workId">
    /// Work Id used to filter query data.
    /// </param>
    /// <param name="_workLineRecId">
    /// Work line record id used to filter query data.
    /// </param>
    /// <remarks>
    /// Utilizes global list of label template group records created when evaluating break criteria.
    /// </remarks>
    private void printBreakLabels(
        List        _labelTemplateGroupList,
        RefRecId    _labelTemplateRecId,
        WHSWorkId   _workId,
        RefRecId    _workLineRecId)
    {
        using (var activityContext = instrumentationLogger.waveLabelActivities().waveLabelPrintBreakLabels(_labelTemplateRecId))
        {
            Counter printBreakLabels;

            ListEnumerator le = _labelTemplateGroupList.getEnumerator();
    
            while (le.moveNext())
            {
                WHSWaveLabelTemplateGroup labelTemplateGroup = le.current() as WHSWaveLabelTemplateGroup;
    
                if (labelTemplateGroup.PrintBreakLabel)
                {
                    List    workList = new List(Types::String);
                    List    workLineList = new List(Types::String);

                    workList.addEnd(_workId);
                    workLineList.addEnd(int642Str(_workLineRecId));

                    var     labelTranslator = WHSWaveLabelTranslator::newFromWorksAndLines(_labelTemplateRecId, labelTemplateGroup.LabelLayoutId, workList, workLineList, waveLabelBuildId);

                    List    labelList = labelTranslator.translateLabel();
    
                    // Store packed list for reprinting
                    WHSWaveLabelHistory::insertBreakLabel(labelList, waveId, _labelTemplateRecId, fieldId2name(labelTemplateGroup.GroupTableId, labelTemplateGroup.GroupFieldId), _workId);
    
                    if (this.canSendBreakLabelsToPrinter(labelTemplateGroup))
                    {
                        ListEnumerator zplLe = labelList.getEnumerator();
    
                        while (zplLe.moveNext())
                        {
                            WHSZPL zpl = zplLe.current();
                    
                            WhsDocumentRouting::printZPLLabelToPrinter(labelTemplateGroup.PrinterName, zpl);

                            printBreakLabels++;
                        }
                    }
                }
            }

            instrumentationLogger.waveLabelActivities().parmWaveLabelPrintBreakLabelsCount(activityContext, printBreakLabels);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyRanges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies data source ranges for the source queryRun to target queryRun.
    /// </summary>
    /// <param name="_queryRunTarget">
    /// Target queryRun instance
    /// </param>
    /// <param name="_queryRunSource">
    /// Source queryRun instance
    /// </param>
    /// <param name="_tableId">
    /// TableId value of the data source that should be copied
    /// </param>
    private void copyRanges(QueryRun _queryRunTarget, QueryRun _queryRunSource, TableId _tableId)
    {
        QueryBuildDataSource    qbdsSource;
        QueryBuildDataSource    qbdsTarget;
        Query                   sourceQuery = _queryRunSource.query();
        Query                   targetQuery = _queryRunTarget.query();

        if (_tableId)
        {
            qbdsSource = sourceQuery.dataSourceTable(_tableId);
            qbdsTarget = targetQuery.dataSourceTable(_tableId);

            if (qbdsTarget && qbdsSource && sourceQuery.hasRangeOrFilter(qbdsSource))
            {
                int rangeCnt = qbdsSource.rangeCount();
                
                for (int i = 1; i <= rangeCnt; i++)
                {
                    QueryBuildRange queryBuildRange = qbdsSource.range(i);
                    
                    qbdsTarget.addRange(queryBuildRange.field()).value(queryBuildRange.value());
                }

                int filterCnt = sourceQuery.queryFilterCount();

                for (int i = 1; i <= filterCnt; i++)
                {
                    QueryFilter queryFilter = sourceQuery.queryFilter(i);

                    if (queryFilter.dataSource().table() == _tableId)
                    {
                        targetQuery.addQueryFilter(qbdsTarget, queryFilter.field()).value(queryFilter.value());
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLabelsQueryRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create QueryRun with all required records from the <c>WHSWorkLine</c> table that will be used for printing.
    /// </summary>
    /// <param name = "_labelTemplateTable">Label template</param>
    /// <returns>QueryRun instance</returns>
    private QueryRun buildLabelsQueryRun(WHSWaveLabelTemplate _labelTemplateTable)
    {
        QueryRun    buildLabelQueryRun;

        buildLabelQueryRun = new queryRun(_labelTemplateTable.PackedQueryRun);

        buildLabelQueryRun.query().dataSourceTable(tableNum(WHSWorkTable)).addRange(fieldNum(WHSWorkTable, WorkBuildId)).value(queryValue(workBuildId));

        //copy ranges from layout query to buildLabelQuery
        WHSWaveLabelLayout          labelLayout;
        WHSWaveLabelTemplateLine    labelTemplateLine;

        while select labelLayout
            exists join labelTemplateLine
                where  labelTemplateLine.LabelLayoutId == labelLayout.LabelLayoutId
                    && labelTemplateLine.LabelTemplate == _labelTemplateTable.RecId
        {
            QueryRun labelLayoutQueryRun = new QueryRun(labelLayout.PackedQueryRun);

            this.copyRanges(buildLabelQueryRun, labelLayoutQueryRun, tableNum(WHSWorkLine));
        }

        WHSPrintLabels::addBuildIdRange(buildLabelQueryRun, waveLabelBuildId);

        return buildLabelQueryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBuildIdRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add range for the label build id field.
    /// </summary>
    /// <param name = "_queryRun">Query run</param>
    /// <param name = "_waveLabelBuildId">Wave label build id</param>
    static internal void addBuildIdRange(QueryRun _queryRun, WHSWaveLabelBuildId _waveLabelBuildId)
    {
        WHSWaveLabel            waveLabel;
        QueryBuildDataSource    qbds;

        if (_queryRun && _waveLabelBuildId)
        {
            select firstonly waveLabel
                where waveLabel.LabelBuildId == _waveLabelBuildId;
            
            qbds = _queryRun.query().dataSourceTable(tableName2Id(waveLabel.RefTableName));
            
            if (qbds)
            {
                qbds.addRange(fieldName2Id(qbds.table(), waveLabel.RefFieldName)).value(queryValue(waveLabel.RefFieldValue));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLabels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates labels in the <c>WHSWaveLabel</c> table.
    /// </summary>
    /// <param name = "_buildLabelQueryRun">QueryRun with all required records from the <c>WHSWorkLine</c> table</param>
    /// <param name = "_labelTemplate">Label template record</param>
    protected void createLabels(QueryRun _buildLabelQueryRun, WHSWaveLabelTemplate _labelTemplate)
    {
        WHSWaveLabelBuildId         labelBuildId;
        TableName                   labelBuildTableName;
        FieldName                   labelBuildFieldName;

        AnyType                     labelBuildFieldValue;
        AnyType                     prevLabelBuildFieldValue;
        int                         seqNum;

        using (var activityContext = instrumentationLogger.waveLabelActivities().waveLabelCreate(_labelTemplate.RecId))
        {
            if (WHSParameters::find().WaveLabelBOLNumGen)
            {
                instrumentationLogger.logInformation('Bill of lading number generation is used');
            }

            WHSWaveLabelTemplateGroup   labelTemplateGroup;
        
            select firstonly GroupTableId, GroupFieldId from labelTemplateGroup
            where  labelTemplateGroup.LabelTemplate == _labelTemplate.RecId
                && labelTemplateGroup.IsLabelBuildIdField  == NoYes::Yes;

            if (labelTemplateGroup)
            {
                labelBuildTableName = tableId2Name(labelTemplateGroup.GroupTableId);
                labelBuildFieldName = fieldId2Name(labelTemplateGroup.GroupTableId, labelTemplateGroup.GroupFieldId);

                instrumentationLogger.logInformation('Wave label template with a label build id checkbox selected is used');
            }

            int numberOfRows = QueryRun::getQueryRowCount(_buildLabelQueryRun.query(), 9999999);
            int rowIndex = 0;

            boolean searchForVoidedLabels = searchForVoidedLabelsWhenCreatingLabels || !WHSPrintLabels::WHSPrintLabelPerfOptimizationsFlightEnabled;

            instrumentationLogger.waveLabelActivities().waveLabelCreateNumOfRows(activityContext, numberOfRows, searchForVoidedLabels);
            
            while (_buildLabelQueryRun.next())
            {
                rowIndex += 1;

                if (labelTemplateGroup)
                {
                    Common table = _buildLabelQueryRun.get(labelTemplateGroup.GroupTableId);
                    labelBuildFieldValue   = table.(labelTemplateGroup.GroupFieldId);
                }
                else
                {
                    labelBuildId = strFmt('%1_%2', int642Str(_labelTemplate.RecId), workBuildId);
                }

                if (labelBuildFieldValue != prevLabelBuildFieldValue)
                {
                    this.updateWaveLabelNumOfLabels(labelBuildId, seqNum);

                    prevLabelBuildFieldValue = labelBuildFieldValue;

                    seqNum = 0;
                
                    labelBuildId = strFmt('%1_%2_%3_%4_%5', int642Str(_labelTemplate.RecId), workBuildId, labelBuildTableName, labelBuildFieldName, labelBuildFieldValue);
                }

                if (_buildLabelQueryRun.changed(tableNum(WHSWorkLine)))
                {
                    WHSWorkLine        workLine   = _buildLabelQueryRun.get(tableNum(WHSWorkLine));
                    WHSUOMSeqGroupId   seqGroupId = WHSInventTable::find(workLine.ItemId).UOMSeqGroupId;
                    ItemName           workLineItemName = workLine.displayItemName();
                    InventUnitId       workLineInventUnitId = workLine.displayInventUnitId();

                    instrumentationLogger.waveLabelActivities().waveLabelCreateWorkLineRecId(activityContext, workLine.RecId);

                    WHSUOMSeqGroupLine uomSeqGroupLine;

                    select firstonly UnitId, LicensePlatePackType from uomSeqGroupLine
                    where  uomSeqGroupLine.UOMSeqGroupId    == seqGroupId
                        && uomSeqGroupLine.WaveLabelTypeId  == _labelTemplate.WaveLabelTypeId;

                    if (!this.validate(workLine, seqGroupId, uomSeqGroupLine.UnitId, _labelTemplate.WaveLabelTypeId))
                    {
                        continue;
                    }

                    int numOfLabels = this.calculateNumberOfLabels(workLine, uomSeqGroupLine.UnitId);

                    instrumentationLogger.waveLabelActivities().waveLabelCreateNumOfLabels(activityContext, numOfLabels);

                    Qty accumulatedWorkQty;
                    Qty workQty = this.convertLabelUnitToUnit(workLine, uomSeqGroupLine.UnitId, workLine.UnitId);
                
                    Qty accumulatedInventQty;
                    Qty inventQty = this.convertLabelUnitToUnit(workLine, uomSeqGroupLine.UnitId, workLineInventUnitId);

                    for (int i = 1; i <= numOfLabels; i++)
                    {
                        seqNum += 1;

                        ttsbegin;
                        WHSWaveLabel waveLabel;
                        if (searchForVoidedLabels)
                        {
                            waveLabel = this.findFirstVoidedLabel(_labelTemplate);
                        }

                        if (!waveLabel.WaveLabelId)
                        {
                            waveLabel.WaveLabelId = this.getWaveLabelId(uomSeqGroupLine);

                            if (WHSPrintLabels::WHSPrintLabelPerfOptimizationsFlightEnabled)
                            {
                                searchForVoidedLabels = false; //once we do not have voided labels there is no need to continue searching for them, since we will not create nor qualify more in this loop.
                            }
                        }

                        waveLabel.WorkId = workLine.WorkId;
                        waveLabel.WorkLineNum = workLine.LineNum;
                    
                        waveLabel.SeqNum = seqNum;
                        waveLabel.NumberOfLabels = 0;

                        waveLabel.WaveLabelType = _labelTemplate.WaveLabelTypeId;

                        waveLabel.LabelItemId = workLine.ItemId;
                        waveLabel.LabelItemName = workLineItemName;
                        waveLabel.HazmatDescription = '';
                    
                        waveLabel.LabelQty = 1;
                        waveLabel.LabelUnitId = uomSeqGroupLine.UnitId;

                        waveLabel.WorkUnitId = workLine.UnitId;
                        waveLabel.InventUnitId = workLineInventUnitId;

                        if (i == numOfLabels)
                        {
                            if (workLine.QtyWork > accumulatedWorkQty)
                            {
                                waveLabel.WorkQty = workLine.QtyWork - accumulatedWorkQty;
                            }

                            if(workLine.InventQtyWork > accumulatedInventQty)
                            {
                                waveLabel.InventQty = workLine.InventQtyWork - accumulatedInventQty;
                            }
                        }
                        else
                        {
                            if (workLine.QtyWork > accumulatedWorkQty)
                            {
                                waveLabel.WorkQty = workQty;
                                accumulatedWorkQty += workQty;
                            }

                            if(workLine.InventQtyWork > accumulatedInventQty)
                            {
                                waveLabel.InventQty = inventQty;
                                accumulatedInventQty += inventQty;
                            }
                        }

                        waveLabel.Printed = NoYes::No;
                        waveLabel.PrintedBy = '';
                        waveLabel.PrintedDateTime = dateNull();
                        waveLabel.Voided = NoYes::No;

                        waveLabel.LabelBuildId = labelBuildId;
                        waveLabel.RefTableName = labelBuildTableName;
                        waveLabel.RefFieldName = labelBuildFieldName;
                        waveLabel.RefFieldValue= labelBuildFieldValue;
                        
                        waveLabel.write();

                        ttscommit;
                    }
                }

                if (waveMethodSubProgressStatusHandler)
                {
                    waveMethodSubProgressStatusHandler.setProgress(100.0 * rowIndex / numberOfRows);
                }

            }

            this.updateWaveLabelNumOfLabels(labelBuildId, seqNum);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWaveLabelNumOfLabels</Name>
				<Source><![CDATA[
    private void updateWaveLabelNumOfLabels(WHSWaveLabelBuildId _labelBuildId, WHSWaveLabelSeqNumber _seqNum)
    {
        WHSWaveLabel waveLabel;

        if (_labelBuildId && _seqNum)
        {
            update_recordset waveLabel
                    setting NumberOfLabels = _seqNum
                where  waveLabel.LabelBuildId == _labelBuildId
                    && waveLabel.Voided       == NoYes::No;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWaveLabelId</Name>
				<Source><![CDATA[
    private WHSWaveLabelId getWaveLabelId(WHSUOMSeqGroupLine _uomSeqGroupLine)
    {
        return WHSNumberSeqExt::newGetNum(WHSParameters::numRefWHSWaveLabelId()).num(WHSNumberSeqExtParameters::newFromLicensePlatePackType(_uomSeqGroupLine.LicensePlatePackType));
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFirstVoidedLabel</Name>
				<Source><![CDATA[
    private WHSWaveLabel findFirstVoidedLabel(WHSWaveLabelTemplate _labelTemplate)
    {
        WHSWaveLabel        waveLabel;
        WHSWaveLabelHistory waveLabelHistory;

        select firstonly forupdate waveLabel
            order by waveLabel.WaveLabelId
            where  waveLabel.Voided == NoYes::Yes
        exists join waveLabelHistory
            where  waveLabelHistory.RecId  == waveLabel.WaveLabelHistoryRecId
                && waveLabelHistory.WaveId == waveId
                && waveLabelHistory.WaveLabelTemplateRecId == _labelTemplate.RecId;

        return waveLabel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertLabelUnitToUnit</Name>
				<Source><![CDATA[
    private Qty convertLabelUnitToUnit(WHSWorkLine _workLine, InventUnitId _labelUnit, InventUnitId _toUnit)
    {
        EcoResReleasedProductUnitConverter unitConverter = EcoResReleasedProductUnitConverter::construct();

        return unitConverter.convertGivenUnitSymbols(1,
                                                    _labelUnit,
                                                    _toUnit,
                                                    NoYes::Yes,
                                                    _workLine.ItemId,
                                                    _workLine.InventDimId,
                                                    NoYes::Yes);

    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateNumberOfLabels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the number of labels from work line quantity.
    /// </summary>
    /// <param name = "_workLine">The work line record.</param>
    /// <param name = "_labelUnitId">The label unit ID.</param>
    /// <returns>The calculated number of labels.</returns>
    protected int calculateNumberOfLabels(WHSWorkLine _workLine, InventUnitId _labelUnitId)
    {
        int numOfLabels;

        if (_workLine.UnitId != _labelUnitId)
        {

            EcoResReleasedProductUnitConverter unitConverter = EcoResReleasedProductUnitConverter::construct();

            Qty convertedQty = unitConverter.convertGivenUnitSymbols(_workLine.QtyWork,
                                                                    _workLine.UnitId,
                                                                    _labelUnitId,
                                                                    NoYes::Yes,
                                                                    _workLine.ItemId,
                                                                    _workLine.InventDimId,
                                                                    NoYes::No);

            numOfLabels = real2int(roundUp(convertedQty, 1));
        }
        else
        {
            numOfLabels = real2int(_workLine.QtyWork);
        }

        return numOfLabels;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    private boolean validate(WHSWorkLine _workLine, WHSUOMSeqGroupId _seqGroupId, InventUnitId _labelUnitId, WHSWaveLabelTypeId _waveLabelTypeId)
    {
        boolean ret = true;

        if (!_workLine.ItemId)
        {
            ret = checkFailed(strFmt("@WAX:WaveLabelCreateWarningNoItemId", _workLine.LineNum, _workLine.WorkId));
        }

        if (!_seqGroupId)
        {
            ret = checkFailed(strFmt("@WAX:WaveLabelCreateWarningNoSeqGroup", fieldPName(WHSInventTable, UOMSeqGroupId), tablePName(WHSInventTable), _workLine.ItemId));
        }

        if (!_labelUnitId)
        {
            ret = checkFailed(strFmt("@WAX:WaveLabelCreateWarningNoUnit", _waveLabelTypeId, _seqGroupId, _workLine.ItemId));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReprint</Name>
				<Source><![CDATA[
    private boolean isReprint()
    {
        return waveLabelTemplateRecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareLabels</Name>
				<Source><![CDATA[
    private void prepareLabels()
    {
        if (waveMethodSubProgressStatusHandler)
        {
            waveMethodSubProgressStatusHandler.setSubMaxProgress(10);
        }

        using (var waveLabelTemplateActivityContext = instrumentationLogger.waveLabelActivities().prepareWaveLabelTemplate())
        {
            WHSWaveLabelTemplate    labelTemplateTable;
            WHSWaveTable            waveTable;
            Counter                 labelTemplateCount;

            QueryRun                buildLabelQueryRun;
            while select labelTemplateTable
                where ((waveLabelTemplateRecId          == 0
                    && labelTemplateTable.WaveStepCode  == waveStepCode)
                    || labelTemplateTable.RecId         == waveLabelTemplateRecId)
                    && labelTemplateTable.WaveLabelTypeId
            exists join waveTable
                where waveTable.InventLocationId    == labelTemplateTable.InventLocationId
                &&    waveTable.WaveId              == waveId
            {
                labelTemplateCount++;

                instrumentationLogger.waveLabelActivities().waveLabelTemplateRecId(waveLabelTemplateActivityContext, labelTemplateTable.RecId);

                using (var activityContext = instrumentationLogger.waveLabelActivities().waveLabelVoidAndCreate())
                {
                    int numberOfVoidedLabelsForWave;
                    
                    if (this.isReprint())
                    {
                        instrumentationLogger.waveLabelActivities().reprintLabel(waveLabelTemplateActivityContext, labelTemplateTable.RecId);
                        numberOfVoidedLabelsForWave = this.numberOfVoidedLabelsForWave();
                    }

                    buildLabelQueryRun = this.buildLabelsQueryRun(labelTemplateTable);

                    var voidedLabelsUpdated = this.voidWaveLabels(labelTemplateTable.RecId);

                    searchForVoidedLabelsWhenCreatingLabels = (voidedLabelsUpdated != 0);

                    if (workBuildId)
                    {
                        this.createLabels(buildLabelQueryRun, labelTemplateTable);
                    }

                    if (this.isReprint())
                    {
                        int numberOfNewVoidedLabelsForWave = this.numberOfVoidedLabelsForWave() - numberOfVoidedLabelsForWave;

                        if (numberOfNewVoidedLabelsForWave > 0)
                        {
                            instrumentationLogger.logInformation(strFmt('%1 new wave labels were voided during this wave processing for wave label template %2', numberOfNewVoidedLabelsForWave, labelTemplateTable.RecId));
                        }
                    }
                }
            }

            instrumentationLogger.waveLabelActivities().parmWaveLabelTemplateCount(waveLabelTemplateActivityContext, labelTemplateCount);
        }

        if (waveMethodSubProgressStatusHandler)
        {
            waveMethodSubProgressStatusHandler.setProgress(100);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfVoidedLabelsForWave</Name>
				<Source><![CDATA[
    private int numberOfVoidedLabelsForWave()
    {
        WHSWaveLabel        waveLabel;
        WHSWaveLabelHistory waveLabelHistory;

        select count(RecId) from waveLabel
            where waveLabel.Voided == NoYes::Yes
        exists join waveLabelHistory
            where  waveLabelHistory.RecId  == waveLabel.WaveLabelHistoryRecId
                && waveLabelHistory.WaveId == waveId;

        return waveLabel.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>voidWaveLabels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Void wave labels
    /// </summary>
    /// <param name = "_waveLabelTemplateRecId">Wave label template record id</param>
    private int64 voidWaveLabels(WHSWaveLabelTemplateRecId _waveLabelTemplateRecId)
    {
        WHSWaveLabel        waveLabel;
        WHSWaveLabelHistory waveLabelHistory;

        update_recordset waveLabel
                    setting Voided = NoYes::Yes
                where (waveLabelBuildId         == ''
                    || waveLabel.LabelBuildId   == waveLabelBuildId)
                    && waveLabel.Voided         == NoYes::No
            exists join waveLabelHistory
                where  waveLabelHistory.RecId   == waveLabel.WaveLabelHistoryRecId
                    && waveLabelHistory.WaveId  == waveId
                    && waveLabelHistory.WaveLabelTemplateRecId == _waveLabelTemplateRecId;

        return waveLabel.RowCount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateShipmentBillOfLadingId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates Bill of lading IDs on shipments.
    /// </summary>
    private void generateShipmentBillOfLadingId()
    {
        WHSShipmentTable shipmentTable;

        ttsbegin;

        while select forupdate shipmentTable
            where shipmentTable.WaveId == waveId
            &&   !shipmentTable.BillOfLadingId
        {
            this.setBillOfLadingIdForShipment(shipmentTable);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBillOfLadingIdForShipment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the bill of lading id of the provided shipment table.
    /// </summary>
    /// <param name = "_shipmentTable">The <c>WHSShipmentTable</c> record to set the bill of landing id.</param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void setBillOfLadingIdForShipment(WHSShipmentTable _shipmentTable)
    {
        _shipmentTable.setBillOfLadingId();
        _shipmentTable.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>printLabels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prints labels during configured wave steps.
    /// </summary>
    [Hookable(false)]
    public final void printLabels()
    {
        workBuildId = this.getWorkBuildId();

        this.prepareLabels();

        // Do not run printing logic if work was not created.
        if (!workBuildId)
        {
            return;
        }
        
        ttsbegin;

        if (WHSParameters::find().WaveLabelBOLNumGen)
        {
            this.generateShipmentBillOfLadingId();
        }
        
        WHSWaveLabelTemplate    labelTemplateTable;
        WHSWaveTable            waveTable;

        if (waveId)
        {
            //Deactivate old labels. New labels will be created below.
            this.removeActiveFlag();
        }

        using (var activityContext = instrumentationLogger.waveLabelActivities().waveLabelPrint())
        {
            // Loop over label templates tied to the wave step code or record id
            while select labelTemplateTable
                where ((waveLabelTemplateRecId          == 0
                    && labelTemplateTable.WaveStepCode  == waveStepCode)
                    || labelTemplateTable.RecId         == waveLabelTemplateRecId)
                exists join waveTable
                    where waveTable.InventLocationId    == labelTemplateTable.InventLocationId
                    &&    waveTable.WaveId              == waveId
            {
                instrumentationLogger.waveLabelActivities().waveLabelTemplateRecId(activityContext, labelTemplateTable.RecId);

                Set     workTableSet = new Set(Types::String);
                Set     workLineSet = new Set(Types::Int64);
                boolean hasSorting = labelTemplateTable.hasSorting();
                boolean foundRecord;

                List labelTemplateGroupList = new List(Types::Record);
                QueryRun labelTemplateTableQueryRun = new queryRun(labelTemplateTable.PackedQueryRun);
                labelTemplateTableQueryRun.query().dataSourceTable(tableNum(WHSWorkTable)).addRange(fieldNum(WHSWorkTable, WorkBuildId)).value(queryValue(workBuildId));
            
                WHSPrintLabels::addBuildIdRange(labelTemplateTableQueryRun, waveLabelBuildId);

                container   groupByFields;
                WHSWorkId   workId;
                RefRecId    workLineRecId;

                // If sorting criteria specified iterate over query to evaluate break fields
                if (hasSorting)
                {
                    instrumentationLogger.waveLabelActivities().waveLabelTemplateHasSorting(activityContext, hasSorting);

                    int numberOfRows = QueryRun::getQueryRowCount(labelTemplateTableQueryRun.query(), 99999999);
                    int rowIndex = 0;
                    while (labelTemplateTableQueryRun.next())
                    {
                        rowIndex += 1;
                        if (waveMethodSubProgressStatusHandler)
                        {
                            waveMethodSubProgressStatusHandler.setSubMaxProgress(100 * rowIndex / numberOfRows);
                        }

                        foundRecord = true;
                        workId = labelTemplateTableQueryRun.get(tableNum(WHSWorkTable)).(fieldNum(WHSWorkTable, WorkId));
                        workLineRecId = labelTemplateTableQueryRun.get(tableNum(WHSWorkLine)).RecId;
                    
                        if (this.checkForLabelBreak(labelTemplateTable.RecId, labelTemplateGroupList, labelTemplateTableQueryRun, groupByFields))
                        {
                            // Print any accumulated template line labels and reset accumulators
                            if (workTableSet.elements() > 0 && workLineSet.elements() > 0)
                            {
                                this.executeLabelTemplateLines(labelTemplateTable.RecId, workTableSet, workLineSet);

                                workTableSet = new Set(Types::String);
                                workLineSet = new Set(Types::Int64);
                            }
                                                        
                            // Print break labels forward and reset changed group list
                            this.printBreakLabels(labelTemplateGroupList, labelTemplateTable.RecId, workId, workLineRecId);
    
                            labelTemplateGroupList = new List(Types::Record);
                        }

                        workTableSet.add(workId);
                        workLineSet.add(workLineRecId);

                        groupByFields = this.createGroupByFieldContainer(labelTemplateTable.RecId, labelTemplateTableQueryRun);

                        if (waveMethodSubProgressStatusHandler)
                        {
                            waveMethodSubProgressStatusHandler.setProgress(100);
                        }
                    }
                }
    
                if ((hasSorting && foundRecord) || labelTemplateTableQueryRun.next())
                {
                    if (waveMethodSubProgressStatusHandler)
                    {
                        waveMethodSubProgressStatusHandler.setSubMaxProgress(100);
                    }

                    this.executeLabelTemplateLines(labelTemplateTable.RecId, workTableSet, workLineSet);

                    if (waveMethodSubProgressStatusHandler)
                    {
                        waveMethodSubProgressStatusHandler.setProgress(100);
                    }
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkBuildId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find the latest work build ID for the wave for work filtering
    /// </summary>
    /// <returns>Work build id</returns>
    private WHSWorkBuildId getWorkBuildId()
    {
        WHSWorkTable    workTable;

        select maxOf(WorkBuildId) from workTable
            where workTable.WaveId      == waveId
            &&    workTable.WorkStatus  == WHSWorkStatus::Open;

        if (!workTable.WorkBuildId)
        {
            select firstonly WorkBuildId from workTable
                order by workTable.CreatedDateTime desc
            where workTable.WaveId == waveId;
        }

        return workTable.WorkBuildId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printLabelList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prints a list of labels on a printer.
    /// </summary>
    /// <param name = "_zplLabelList">
    /// A <c>List</c> object containing the labels.
    /// </param>
    /// <param name = "_warelabelTemplateLine">
    /// A wave label template details record.
    /// </param>
    /// <param name = "_wavelabelsIds">
    /// A container with wave label ids that are used in zpl label.
    /// </param>
    [Hookable(false)]
    internal void printLabelList(List _zplLabelList, WHSWaveLabelTemplateLine _warelabelTemplateLine, container _wavelabelsIds)
    {
        int numberOfLabels = _zplLabelList.elements();
                    
        if (this.canSendLabelsToPrinter(_warelabelTemplateLine) && numberOfLabels)
        {
            ListEnumerator labelLe = _zplLabelList.getEnumerator();
            int labelIndex = 0;
            while (labelLe.moveNext())
            {
                labelIndex += 1;
                WHSZPL zpl = labelLe.current();
                            
                WhsDocumentRouting::printZPLLabelToPrinter(_warelabelTemplateLine.PrinterName, zpl);
                if (waveMethodSubProgressStatusHandler)
                {
                    waveMethodSubProgressStatusHandler.setProgress(100 * labelIndex / numberOfLabels);
                }
            }

            WHSPrintLabels::updatePrintedFieldsForWaveLabelAndShipment(_wavelabelsIds);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>storeLabelList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Stores a list of labels for a given work ID into label history.
    /// </summary>
    /// <param name = "_zplLabelList">
    /// A <c>List</c> object containing the labels.
    /// </param>
    /// <param name = "_warelabelTemplateLine">
    /// A wave label template details record.
    /// </param>
    /// <param name = "_workList">
    /// A <c>List</c> of work IDs.
    /// </param>
    /// <returns>The history record.</returns>
    [Hookable(false)]
    internal WHSWaveLabelHistory storeLabelList(
        List                        _zplLabelList,
        WHSWaveLabelTemplateLine    _warelabelTemplateLine,
        List                        _workList)
    {
        return WHSWaveLabelHistory::insertLabel(_zplLabelList, waveId, _warelabelTemplateLine.LabelTemplate, this.getSingleWorkIdFromList(_workList));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWaveLabelHistoryForWaveLabels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the wave labels.
    /// </summary>
    /// <param name = "_wavelabelsIds">
    /// A container with wave label ids that are used in zpl label.
    /// </param>
    /// <param name = "_waveLabelHistory">
    /// A wave label history record.
    /// </param>
    [Hookable(false)]
    internal void updateWaveLabelHistoryForWaveLabels(container _wavelabelsIds, WHSWaveLabelHistory _waveLabelHistory)
    {
        this.updateWavelabelsUsingTempTable(_wavelabelsIds, _waveLabelHistory);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWavelabelsUsingTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the wave labels using temp table.
    /// </summary>
    /// <param name = "_wavelabelsIds">
    /// A container with wave label ids that are used in zpl label.
    /// </param>
    /// <param name = "_waveLabelHistory">
    /// A wave label history record.
    /// </param>
    private void updateWavelabelsUsingTempTable(container _wavelabelsIds, WHSWaveLabelHistory _waveLabelHistory)
    {
        if (conLen(_wavelabelsIds) > 0)
        {
            WHSTmpWaveLabelId tmpWaveLabelIdTable = WHSPrintLabels::buildTempDataSourceForWaveLabelId(_wavelabelsIds);

            WHSWaveLabel waveLabel;
            update_recordset waveLabel
                setting WaveLabelHistoryRecId = _waveLabelHistory.RecId
            exists join tmpWaveLabelIdTable
                where tmpWaveLabelIdTable.WaveLabelId == waveLabel.WaveLabelId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWavelabels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the wave labels.
    /// </summary>
    /// <param name = "_wavelabelsIds">
    /// A container with wave label ids that are used in zpl label.
    /// </param>
    /// <param name = "_waveLabelHistory">
    /// A wave label history record.
    /// </param>
    [Hookable(false)]
    internal void updateWavelabels(container _wavelabelsIds, WHSWaveLabelHistory _waveLabelHistory)
    {
        str rangeValue = con2Str(_wavelabelsIds);

        if (rangeValue)
        {
            // Update wave labels
            Query waveLabelQuery = new Query();
            QueryBuildDataSource qbdsWaveLabel = waveLabelQuery.addDataSource(tableNum(WHSWaveLabel));
            qbdsWaveLabel.addRange(fieldNum(WHSWaveLabel, WaveLabelId)).value(rangeValue);

            Map fieldSetMap = new Map(Types::String, Types::String);
            fieldSetMap.insert(fieldStr(WHSWaveLabel, WaveLabelHistoryRecId), any2Str(_waveLabelHistory.RecId));

            Query::update_recordset(fieldSetMap, waveLabelQuery);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildTempDataSourceForWaveLabelId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Build TempDb table for wave label IDs. 
    /// </summary>
    /// <param name = "_wavelabelsIds">Container for wave label IDs</param>
    /// <returns>The TempDb table.</returns>
    private static WHSTmpWaveLabelId buildTempDataSourceForWaveLabelId(container _wavelabelsIds)
    {
        WHSTmpWaveLabelId tmpWaveLabelIdTable;
        int conLength = conlen(_wavelabelsIds);

               
        Set valuesToInsertToTempDB = new Set(Types::String);       
        for (int i = 1; i <= conLength; i++)
        {
            var conCurrent =  conPeek(_wavelabelsIds, i);
            if (!valuesToInsertToTempDB.in(conCurrent))
            {
                valuesToInsertToTempDB.add(conCurrent);
                tmpWaveLabelIdTable.WaveLabelId = conCurrent;
                tmpWaveLabelIdTable.insert();
            }
        }

     
        return tmpWaveLabelIdTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeActiveFlag</Name>
				<Source><![CDATA[
    private void removeActiveFlag()
    {
        WHSWaveLabelHistory waveLabelHistory;

        if (waveLabelTemplateRecId)
        {
            update_recordset waveLabelHistory
                setting Active = NoYes::No
                where waveLabelHistory.WaveId == waveId
                   && waveLabelHistory.Active == NoYes::Yes
                   && waveLabelHistory.WaveLabelTemplateRecId == waveLabelTemplateRecId;
        }
        else
        {
            WHSWaveLabelTemplate labelTemplateTable;

            update_recordset waveLabelHistory
                setting Active = NoYes::No
                where waveLabelHistory.WaveId == waveId
                   && waveLabelHistory.Active == NoYes::Yes
                exists join labelTemplateTable
                    where labelTemplateTable.RecId         == waveLabelHistory.WaveLabelTemplateRecId
                       && labelTemplateTable.WaveStepCode  == waveStepCode;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>