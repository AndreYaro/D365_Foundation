<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxWithholdCalculation_IN</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Class is used to calculate withholding tax for India.
/// </summary>
class TaxWithholdCalculation_IN
{
    boolean                     overlookThreshold;
    boolean                     exceptionalThreshold, amountOrginCalculated;
    TmpTaxWithholdWorkTrans_IN  taxWithholdWorkTrans;
    AmountCur                   transAmountOrigin;
    AmountCur                   curTransWHTNotCalculatedBaseCur;
    boolean                     checkBankStatus;
    CompanyId                   companyId;
    CompanyId                   paymcompanyId;
    CompanyId                   journalLineCompany;
    CustVendAC                  paymentAccount;
    CustVendAC                  invoiceAccount;
    Voucher                     invoiceVoucher;
    RecId                       specRefRecId;
    real                        tmpRateOfDeduction;
    SpecTrans                   specTransForCP;
    AccountNum                  offsetAccountNum;
    container                   tmpTotalTDSAmount;
    container                   thresholdStatus;
    TransDate                   thresholdFromDate;
    TransDate                   thresholdToDate;
    RefRecId                    custInvoiceTransRecid;
    RefRecId                    taxWithholdTransRecId;
    container                   sourceDocumentRecIdList;
    Counter                     sourceDocumentTaxLine;
    boolean                     useTaxWithholdUncommitted;
    RefTableId                  headingTableId;
    RefRecId                    headingRecId;
    RefRecId                    invoiceRecId;
    boolean                     loadTaxWithholdUncommitted;
    boolean                     loadTaxWithholdTrans;
    boolean                     maintainExistingTaxWithholdUncommitted;
    TaxModuleType               taxModuleType;
    TaxableDocument             ledgerJournalTaxWithholdDocument;
    Voucher                     voucher;
    TaxableLine                 taxableLineCurrentlyBeingCalculated;
    CurrencyCode                sourceCurrencyCode;
    ExchRate                    exchRate;
    ExchrateSecondary           exchRateSecond;
    TransDate                   taxDate;
    EUROTriangulation           triangulation;
    AmountCur                   cashDiscAmount;
    Percent                     cashDiscPercent;

    TaxWithhold_IN              taxWithHoldIN;
    AmountCur                   totalAmountOriginCur;
    TmpTransLineWithholdGrossAmount_IN   tmpTransLineWithholdGrossAmount;
    DiscPct                     endDiscPercent;

    Map                         calcPostedUncalculatedTransMap;

    private boolean isThresholdBasedOnPaymentOnly = FeatureStateProvider::isFeatureEnabled(TaxWithholdCustomerThresholdBasedOnPaymentOnlyFeature::instance());
    private boolean isTaxTCSWithSEZGST_INFlightEnabled = TaxTCSWithSEZGST_INFlight::instance().isEnabled();

    #COSNumbers
    #define.7(7)
    #define.8(8)
    #define.13(13)
    #define.15(15)
    #define.19(19)
    #define.TDSExchRate(27)
    #define.TDSExchRateSecond(28)
    #define.TDSTriangulation(29)
    #define.TaxDate(30)

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>newForSourceTypeDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for creating a new instance of <c>TaxWithholdCalculation_IN</c> for <c>TaxSourceType</c>.
    /// </summary>
    /// <param name="_sourceType">
    ///    The type of the transaction to calculate taxes.
    /// </param>
    /// <param name="_initializationClass">
    ///    The initialization class for the given transaction.
    /// </param>
    /// <param name = "_result">An <c>EventHandlerResult</c> instance, where subscribers can provide the creation result.</param>
    static delegate void newForSourceTypeDelegate(TaxSourceType _taxSourceType, Object _initializationClass, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForSourceTypeWithTaxUncommittedDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for creating a new instance of <c>TaxWithholdCalculation_IN</c> for <c>TaxSourceType</c>. This constructor causes
    ///    tax to use the <c>TaxUncommitted</c> table to load and persist taxes.
    /// </summary>
    /// <param name="_sourceType">
    ///    The type of the transaction to calculate taxes.
    /// </param>
    /// <param name="_initializationClass">
    ///    The initialization class for the given transaction. This is a different class for each transaction.
    /// </param>
    /// <param name="_loadTaxUncommitted">
    ///    A Boolean value that specifies whether during the construction to load the <c>TaxUncommitted</c>
    ///    records into taxes <c>TmpTaxWorkTrans</c> buffer which enables most of the inquiry functions to
    ///    work.
    /// </param>
    /// <param name="_loadTaxTrans">
    ///    A Boolean value that specifies whether during the construction to load the <c>TaxTrans</c>
    ///    records into taxes <c>TmpTaxWorkTrans</c> buffer which enables most of the inquiry functions to
    ///    work.
    /// </param>
    /// <param name="_maintainExistingTaxUncommitted">
    ///    A Boolean value which indicates that Tax should merge the newly calculated taxes with
    ///    existing records in TaxUncommitted.
    /// </param>
    /// <param name = "_result">An <c>EventHandlerResult</c> instance, where subscribers can provide the creation result.</param>
    static delegate void newForSourceTypeWithTaxUncommittedDelegate(
        TaxSourceType _taxSourceType,
        Object _initializationClass,
        boolean _loadTaxUncommitted,
        boolean _loadTaxTrans,
        boolean _maintainExistingTaxUncommitted,
        EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountPerCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the settled amount per company.
    /// </summary>
    /// <param name="_recId">
    /// Given record Id of which is related with specification.
    /// </param>
    /// <param name="_companyId">
    /// Given company Id.
    /// </param>
    /// <returns>
    /// The settled amount per company.
    /// </returns>
    private AmountCur amountPerCompany(RecId _recId,CompanyId  _companyId)
    {
        SpecTrans   specTransLoc;

        select sum(Balance01) from specTransLoc
            where specTransLoc.SpecRecId        == _recId
               && specTransLoc.RefCompany       == _companyId;
        return specTransLoc.Balance01;
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountToSettle</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets amount to be settled.
    /// </summary>
    /// <param name="_tableId">
    /// Given table Id.
    /// </param>
    /// <param name="_recId">
    /// Given record Id.
    /// </param>
    /// <param name="_taxWithholdData">
    /// Withholding tax data.
    /// </param>
    /// <param name="_transDate">
    /// Transaction date.
    /// </param>
    /// <param name="_taxWithholdGroup">
    /// Withholding tax group.
    /// </param>
    /// <param name="_taxWithholdCode">
    /// Withholding tax code.
    /// </param>
    /// <returns>
    /// Amount to be settled.
    /// </returns>
    public real  amountToSettle(RefTableId          _tableId,
                                RefRecId            _recId,
                                container           _taxWithholdData,
                                TransDate           _transDate,
                                TaxWithholdGroup    _taxWithholdGroup,
                                TaxWithholdCode     _taxWithholdCode)
    {
        SpecTrans               specTrans;
        real                    taxCalculatedAmount;
        TaxWithholdTrans_IN     taxWithholdTrans;
        VendTransOpen           vendTransOpen;
        CustTransOpen           custTransOpen;
        VendTrans               vendTrans;
        CustTrans               custTrans;
        VendSettlement          vendSettlement;
        CustSettlement          custSettlement;
        TaxWithholdTrans_IN     taxWithholdTransLoc;

        while select RefTableId, RefRecId, Balance01 from specTrans
            where specTrans.SpecRecId   == _recId
               && specTrans.SpecTableId == _tableId
               && specTrans.RefCompany  == companyId
                join RefRecId, AccountNum, TransDate, TableId, RecId, AmountMST from vendTransOpen
                    order by AmountCur desc, CashDiscDate, DueDate, RecId
                    where vendTransOpen.TableId    == specTrans.RefTableId
                       && vendTransOpen.RecId      == specTrans.RefRecId
        {
            select firstonly AccountNum, TransDate, RecId, Voucher  from  vendTrans
                where vendTrans.RecId             == vendTransOpen.RefRecId
                   && vendTrans.AccountNum        == vendTransOpen.AccountNum
                   && vendTrans.TransDate         == vendTransOpen.TransDate;

            select sum(AmountOriginMST), Source from taxWithholdTrans
                group by Source
                where taxWithholdTrans.Voucher              == vendTrans.Voucher
                   && (taxWithholdTrans.VendAccount         == vendTrans.AccountNum
                   || taxWithholdTrans.CustAccount          == vendTrans.AccountNum)
                   && taxWithholdTrans.TaxWithholdGroup     == _taxWithholdGroup
                   && taxWithholdTrans.TaxWithholdCode      == _taxWithholdCode;

            select sum(TaxWithholdAmount) from taxWithholdTransLoc
                where taxWithholdTransLoc.Voucher == vendTrans.Voucher;

            if (!taxWithholdTrans)
            {
                if (CompanyInfoHelper::standardCurrency() != conPeek(_taxWithholdData, #4))
                {
                    taxCalculatedAmount += CurrencyExchangeHelper::mstAmount(specTrans.Balance01,
                                                                         conPeek(_taxWithholdData, #4),
                                                                         _transDate,
                                                                         conPeek(_taxWithholdData, #3),
                                                                         conPeek(_taxWithholdData, #1),
                                                                         conPeek(_taxWithholdData, #2));
                }
                else
                {
                    taxCalculatedAmount += specTrans.Balance01 + this.calcCashDisc(vendTransOpen.TableId,
                                                                                   vendTransOpen.RecId,
                                                                                   _transDate);
                }
            }

            if (taxWithholdTrans
                && (taxWithholdTrans.Source  == TaxModuleType::FreeTxtInvoice
                || taxWithholdTrans.Source   == TaxModuleType::PurchInvoice
                || taxWithholdTrans.Source   == TaxModuleType::SalesInvoice))
            {
                if (taxWithholdTrans.AmountOriginMST != vendTransOpen.AmountMST)
                {
                    taxCalculatedAmount += abs(vendTrans.AmountMST - vendTrans.SettleAmountMST) - taxWithholdTransLoc.TaxWithholdAmount - taxWithholdTrans.AmountOriginMST;
                }
            }

            while select OffsetTransVoucher from  vendSettlement
              where vendSettlement.TransRecId == vendTrans.RecId
              join Voucher, VendAccount, TaxWithholdGroup, TaxWithholdCode, AmountOriginMST from taxWithholdTransLoc
               where taxWithholdTransLoc.Voucher       == vendSettlement.OffsetTransVoucher
               && taxWithholdTransLoc.VendAccount      == vendSettlement.AccountNum
               && taxWithholdTransLoc.TaxWithholdGroup == _taxWithholdGroup
               && taxWithholdTransLoc.TaxWithholdCode  == _taxWithholdCode
            {
                taxCalculatedAmount -= taxWithholdTransLoc.AmountOriginMST;
            }

            select sum(SettleAmountMST) from vendSettlement
                where vendSettlement.OffsetTransVoucher ==  vendTrans.Voucher;
            taxCalculatedAmount += vendSettlement.SettleAmountMST;
        }

        while select  SpecRecId, SpecTableId, RefCompany, RefTableId, RefRecId, Balance01 from specTrans
            where specTrans.SpecRecId   == _recId
               && specTrans.SpecTableId == _tableId
               && specTrans.RefCompany  == companyId
                join AmountCur, CashDiscDate, DueDate, RecId, RefRecId, AccountNum, TransDate, TableId, AmountMST  from custTransOpen
                    order by AmountCur desc, CashDiscDate, DueDate, RecId
                    where custTransOpen.TableId    == specTrans.RefTableId
                       && custTransOpen.RecId      == specTrans.RefRecId

        {
            select firstonly Voucher, AccountNum, AmountMST, SettleAmountMST, RecId from custTrans
                where custTrans.RecId             == custTransOpen.RefRecId
                   && custTrans.AccountNum        == custTransOpen.AccountNum
                   && custTrans.TransDate         == custTransOpen.TransDate;

            select sum(AmountOriginMST), Source from taxWithholdTrans
                group by Source
                where taxWithholdTrans.Voucher              == custTrans.Voucher
                   && (taxWithholdTrans.VendAccount         == custTrans.AccountNum
                   || taxWithholdTrans.CustAccount          == custTrans.AccountNum)
                   && taxWithholdTrans.TaxWithholdGroup     == _taxWithholdGroup
                   && taxWithholdTrans.TaxWithholdCode      == _taxWithholdCode;

            select sum(TaxWithholdAmount) from taxWithholdTransLoc
                where taxWithholdTransLoc.Voucher == custTrans.Voucher;

            if (!taxWithholdTrans)
            {
                if (CompanyInfoHelper::standardCurrency() != conPeek(_taxWithholdData, #4))
                {
                    taxCalculatedAmount += CurrencyExchangeHelper::mstAmount(specTrans.Balance01, conPeek(_taxWithholdData, 4), _transDate, conPeek(_taxWithholdData, 3), conPeek(_taxWithholdData, 1), conPeek(_taxWithholdData, 2));
                }
                else
                {
                    taxCalculatedAmount += specTrans.Balance01 + this.calcCashDisc(custTransOpen.TableId,
                                                                                   custTransOpen.RecId,
                                                                                   _transDate);
                }
            }

            if (taxWithholdTrans
                && (taxWithholdTrans.Source  == TaxModuleType::FreeTxtInvoice
                || taxWithholdTrans.Source   == TaxModuleType::PurchInvoice
                || taxWithholdTrans.Source   == TaxModuleType::SalesInvoice))
            {
                if (taxWithholdTrans.AmountOriginMST != custTransOpen.AmountMST)
                {
                    taxCalculatedAmount += abs(custTrans.AmountMST - custTrans.SettleAmountMST) + taxWithholdTransLoc.TaxWithholdAmount - taxWithholdTrans.AmountOriginMST;
                }
            }

            while select OffsetTransVoucher from  custSettlement
              where custSettlement.TransRecId == custTrans.RecId
              join AmountOriginMST from taxWithholdTransLoc
               where taxWithholdTransLoc.Voucher           == custSettlement.OffsetTransVoucher
               && taxWithholdTransLoc.CustAccount         == custSettlement.AccountNum
               && taxWithholdTransLoc.TaxWithholdGroup     == _taxWithholdGroup
               && taxWithholdTransLoc.TaxWithholdCode      == _taxWithholdCode
            {
                taxCalculatedAmount -= taxWithholdTransLoc.AmountOriginMST;
            }

            select sum(SettleAmountMST) from custSettlement
                where custSettlement.OffsetTransVoucher ==  custTrans.Voucher;
            taxCalculatedAmount -= custSettlement.SettleAmountMST;
        }
        return  taxCalculatedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCashDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the cash discount.
    /// </summary>
    /// <param name="_tableId">
    /// Given table Id.
    /// </param>
    /// <param name="_recId">
    /// Given record Id.
    /// </param>
    /// <param name="_transDate">
    /// Transaction date.
    /// </param>
    /// <returns>
    /// Calculated cash discount.
    /// </returns>
    public real  calcCashDisc(RefTableId     _tableId,
                              RefRecId       _recId,
                              TransDate      _transDate)
    {
        AmountCur               discAmount;

        switch (_tableId)
        {
            case tableNum(CustTransOpen):
                discAmount += CustTransCashDisc::findCashDisc(_tableId, _recId, _transDate).CashDiscAmount;
                break;
            case tableNum(VendTransOpen):
                discAmount += VendTransCashDisc::findCashDisc(_tableId, _recId, _transDate).CashDiscAmount;
                break;
            default:
                break;
        }
        return discAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTaxAdvancePayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates tax advance payment information.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal transaction.
    /// </param>
    /// <param name="_grossAmount">
    /// The gross amount.
    /// </param>
    /// <param name="_specTrans">
    /// The spce transaction.
    /// </param>
    /// <param name="_isVendorTransaction">
    /// True if the transaction is vendor transaction.
    /// </param>
    /// <returns>
    /// The tax advance payment amount.
    /// </returns>
    public real calcTaxAdvancePayment(
        LedgerJournalTrans _ledgerJournalTrans,
        real               _grossAmount,
        SpecTrans          _specTrans = null,
        boolean            _isVendorTransaction = false)
    {
        container                   taxWithholdData;
        AmountCur                   taxAmount;
        CustVendAC                  accountNumber;
        TaxWithholdGroup            taxWithholdGroup;
        SpecTrans                   specTrans;
        boolean                     isAdvancePayment = true;
        CustTable                   custTableLoc;
        TaxInformationCustTable_IN  taxInformationCustTableLoc;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();

        select  specTrans
            where specTrans.SpecRecId    == _specTrans.SpecRecId
               && specTrans.RefRecId     == _specTrans.RefRecId;

        if (specTrans)
        {
            this.setInvoiceAndPaymentData(specTrans);
            isAdvancePayment = false;
        }
        if (!specTrans && _ledgerJournalTrans.Company != _ledgerJournalTrans.OffsetCompany)
        {
            this.setInvoiceAndPaymentData(null, _ledgerJournalTrans, _ledgerJournalTrans.OffsetCompany);
            isAdvancePayment = ledgerJournalTransTaxExt.tdsGroup ? false : true;
        }

        taxWithholdData  = TaxWithholdCalculation_IN::setLedgerData(_ledgerJournalTrans, _grossAmount);

        if (companyId != paymcompanyId || _ledgerJournalTrans.Company != paymcompanyId)
        {
            accountNumber = invoiceAccount;
        }
        else
        {
            accountNumber = TaxWithholdJournal_IN::setAccountNumber(_ledgerJournalTrans);
        }
        if (!accountNumber)
        {
            accountNumber = invoiceAccount;
        }

        if (!specTrans)
        {
            taxWithholdGroup = ledgerJournalTransTaxExt.tdsGroup ? ledgerJournalTransTaxExt.tdsGroup : ledgerJournalTransTaxExt.tcsGroup;
        }
        else
        {
            custTableLoc = CustTable::findByCompany(specTrans.RefCompany, accountNumber);
            taxInformationCustTableLoc = custTableLoc.getTaxInformationCustTable_IN();
            taxWithholdGroup = taxInformationCustTableLoc.tdsGroup ? taxInformationCustTableLoc.tdsGroup : taxInformationCustTableLoc.tcsGroup;
        }

        if (ledgerJournalTransTaxExt.tcsGroup && this.canCalculateWHTForCC(_ledgerJournalTrans, accountNumber, true, _isVendorTransaction))
        {
            taxAmount = this.totalTaxWithhold(accountNumber,
                                              taxWithholdGroup,
                                              _ledgerJournalTrans.TransDate,
                                              taxWithholdData,
                                              TaxWithholdCalculation_IN::checkRecoverableAccount(_ledgerJournalTrans),
                                              isAdvancePayment,
                                              '',
                                              '',
                                              _ledgerJournalTrans.JournalNum,
                                              _ledgerJournalTrans.AmountCurDebit,
                                              _ledgerJournalTrans.AmountCurCredit,
                                              _ledgerJournalTrans.AccountType,
                                              _ledgerJournalTrans.OffsetAccountType);
        }

        taxAmount = specTrans ? taxAmount * -1 : taxAmount;
        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the formula for the withholdtax calculation as string with amounts and delimiters replaced.
    /// </summary>
    /// <param name="_formula">
    /// String parameter for the formula for withhold tax calculation.
    /// </param>
    /// <param name="_amount">
    /// TaxWithhold Amount for given taxWithhold Code.
    /// </param>
    /// <param name="_chargeName">
    /// Specific taxWithhold Code.
    /// </param>
    /// <param name="_openingDelimiter">
    /// String parameter for opening delimiter in the formula.
    /// </param>
    /// <param name="_closingDelimiter">
    /// String parameter for closing delimiter in the formula.
    /// </param>
    /// <returns>
    /// the formula for the withholdtax calculation as string with amounts and delimiters replaced.
    /// </returns>
    public str calculateAmount(str     _formula,
                               real    _amount,
                               str     _chargeName,
                               str     _openingDelimiter = "",
                               str     _closingDelimiter = "")
    {
        int     postion, chargeLength;
        str     formula;
        #define.Percentile('%')
        #define.PercentileOne('1')

        formula         = _formula;
        postion         = strScan(formula, strFmt(_openingDelimiter + #Percentile + #PercentileOne + _closingDelimiter, _chargeName), 1, strLen(formula));
        chargeLength    = strLen(strFmt(_openingDelimiter + #Percentile + #PercentileOne + _closingDelimiter, _chargeName));

        while (postion)
        {
            formula   = subStr(formula, 1, postion - 1) + num2str(any2real(_amount), 1, #4, 1, 0)
                                     + subStr(formula, postion + chargeLength, strLen(formula));
            postion = strScan(formula, strFmt(_openingDelimiter + #Percentile + #PercentileOne + _closingDelimiter, _chargeName), 1, strLen(formula));
        }
        return formula;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate tax information.
    /// </summary>
    /// <returns>
    /// The instance of the <c>TaxAmountCur</c> class.
    /// </returns>
    public TaxAmountCur calculateTax()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTaxWithholdAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the container with the formula for taxWithholdAmount and TaxAmountOrigin.
    /// </summary>
    /// <param name="_formula">
    /// Str parameter for formula.
    /// </param>
    /// <param name="_taxcode">
    /// The Container with the TaxWithholdCodes.
    /// </param>
    /// <param name="_countI">
    /// Counter value to identify the TaxwithholdCode and corresponding taxWithholdAmount.
    /// </param>
    /// <param name="_threshold">
    /// BaseAmount for calculation of TaxWithholdAmount.
    /// </param>
    /// <param name="_totalTDSAmount">
    /// Container with the TaxWithholdAmounts for all taxCodes.
    /// </param>
    /// <param name="_accountNum">
    /// The AccountNum value.
    /// </param>
    /// <param name="_taxWithholdGroup">
    /// The TaxWithholdGroup attached on transaction.
    /// </param>
    /// <param name="_taxWithholdCode">
    /// The TaxWithholdCode for withholding tax.
    /// </param>
    /// <param name="_taxWithholdData">
    /// The Container TaxwithholdData.
    /// </param>
    /// <param name="_transDate">
    /// The TransDate.
    /// </param>
    /// <returns>
    /// Container with the formula for taxWithholdAmount and TaxAmountOrigin.
    /// </returns>
    public container calculateTaxWithholdAmount(str                        _formula,
                                                container                  _taxcode,
                                                Counter                    _countI,
                                                TaxWithholdThreshold_IN    _threshold,
                                                container                  _totalTDSAmount,
                                                AccountNum                 _accountNum,
                                                TaxWithholdGroup           _taxWithholdGroup,
                                                TaxWithholdCode            _taxWithholdCode,
                                                container                  _taxWithholdData,
                                                TransDate                  _transDate)
    {
        str                 chargeName;
        real                amount, totalAmountOrigin;
        container           taxWithhold;
        TaxWithholdCode     taxWithholdCode;
        TaxWithholdTrans_IN taxWithholdTrans, taxWithholdTransLocal;
        AmountCur           taxAmount;
        str                 formulaLoc;
        #Operator_IN

        formulaLoc      = _formula;
        chargeName      = conPeek(_taxcode, _countI);
        taxWithholdCode = chargeName;
        if (!_threshold
        || overlookThreshold
        || exceptionalThreshold)
        {
            amount      = conPeek(_totalTDSAmount, _countI);
        }
        else
        {
            amount = 0;
            while select TaxWithholdCode, VendAccount, CustAccount, TransDate, TaxWithholdGroup, Voucher, Invoice, TaxWithholdAmountCur
                from  taxWithholdTrans
                where taxWithholdTrans.TaxWithholdCode  == taxWithholdCode
                   && (taxWithholdTrans.VendAccount     == _accountNum
                   || taxWithholdTrans.CustAccount      == _accountNum)
                   && taxWithholdTrans.TransDate        >= thresholdFromDate
                   && taxWithholdTrans.TransDate        <= thresholdToDate
                   && taxWithholdTrans.TaxWithholdGroup == _taxWithholdGroup
            {
                select firstonly taxWithholdTransLocal
                    where taxWithholdTransLocal.TaxWithholdCode     == _taxWithholdCode
                       && taxWithholdTransLocal.Voucher             == taxWithholdTrans.Voucher
                       && taxWithholdTransLocal.Invoice             == taxWithholdTrans.Invoice
                       && (taxWithholdTransLocal.VendAccount        == taxWithholdTrans.VendAccount
                       || taxWithholdTransLocal.CustAccount         == taxWithholdTrans.CustAccount)
                       && taxWithholdTransLocal.TransDate           >= thresholdFromDate
                       && taxWithholdTransLocal.TransDate           <= thresholdToDate
                       && taxWithholdTransLocal.TaxWithholdGroup    == taxWithholdTrans.TaxWithholdGroup;

                if (taxWithholdTransLocal.OverlookThreshold == false)
                {
                    if (CompanyInfoHelper::standardCurrency() != conPeek(_taxWithholdData, #4))
                    {
                        taxAmount = CurrencyExchangeHelper::mstAmount(taxWithholdTrans.TaxWithholdAmountCur, conPeek(_taxWithholdData, 4), _transDate, conPeek(_taxWithholdData, 3), conPeek(_taxWithholdData, 1), conPeek(_taxWithholdData, 2));
                    }
                    else
                    {
                        taxAmount = taxWithholdTrans.TaxWithholdAmountCur;
                    }

                    amount += (taxAmount) * -1;
                }
            }
            amount += conPeek(_totalTDSAmount, _countI);
        }

        totalAmountOrigin   += amount;
        formulaLoc          = this.calculateAmount(formulaLoc, amount, chargeName, num2char(#nintyOne), num2char(#nintyThree));
        taxwithhold         = conPoke(taxwithhold, 1, formulaLoc);
        taxwithhold         = conPoke(taxwithhold, #2, totalAmountOrigin);

        return taxWithhold;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCalculateTCS</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if TCS taxes are applicable to the combination of journals.
    /// </summary>
    /// <param name="_accountType">
    /// The LedgerJournalACType value for AccountType.
    /// </param>
    /// <param name="_offsetAccountType">
    /// The LedgerJournalACType value for OffsetAccountType.
    /// </param>
    /// <param name="_amountCurDebit">
    /// The AmountCurDebit value.
    /// </param>
    /// <param name="_amountCurCredit">
    /// The AmountCurCredit value.
    /// </param>
    /// <param name="_account">
    /// The AccountNum value.
    /// </param>
    /// <param name="_offsetAccount">
    /// The OffsetAccountNum value.
    /// </param>
    /// <param name="_ledgerJournalType">
    /// The LedgerJournalType value.
    /// </param>
    /// <param name="_OffsetLedgerDimension">
    /// The OffsetLedgerDimension value.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The ledgerDimension value.
    /// </param>
    /// <returns>
    /// True, if TCS taxes are applicable to the combination of journals otherwise, false.
    /// </returns>
    public boolean canCalculateTCS(LedgerJournalACType     _accountType,
                                   LedgerJournalACType     _offsetAccountType,
                                   AmountCur               _amountCurDebit,
                                   AmountCur               _amountCurCredit,
                                   LedgerJournalAC         _account,
                                   LedgerJournalAC         _offsetAccount,
                                   LedgerJournalType       _ledgerJournalType,
                                   DimensionDynamicAccount _OffsetLedgerDimension = 0,
                                   DimensionDynamicAccount _ledgerDimension = 0)
    {
        boolean ret;
        NoYes   canCalculate;

        switch (_accountType)
        {
            case LedgerJournalACType::Cust:
                canCalculate = CustTable::find(_account).TaxWithholdCalculate_IN;
            break;

            case LedgerJournalACType::Vend:
                canCalculate = VendTable::find(_account).TaxWithholdCalculate;
            break;
        }

        switch (_offsetAccountType)
        {
            case LedgerJournalACType::Cust:
                canCalculate = CustTable::find(_offsetAccount).TaxWithholdCalculate_IN;
            break;

            case LedgerJournalACType::Vend:
                canCalculate = VendTable::find(_offsetAccount).TaxWithholdCalculate;
            break;
        }

        if ((_accountType    == LedgerJournalACType::Cust    &&  _offsetAccountType == LedgerJournalACType::Ledger    && _amountCurDebit   > 0 && canCalculate)
            || (_accountType == LedgerJournalACType::Ledger  &&  _offsetAccountType == LedgerJournalACType::Cust      && _amountCurCredit  > 0 && canCalculate)
            || (_accountType == LedgerJournalACType::Bank    &&  _offsetAccountType == LedgerJournalACType::Cust      && _amountCurDebit   > 0 && canCalculate)
            || (_accountType == LedgerJournalACType::Cust    &&  _offsetAccountType == LedgerJournalACType::Bank      && _amountCurCredit  > 0 && canCalculate)
            || (_accountType == LedgerJournalACType::Ledger  &&  _offsetAccountType == LedgerJournalACType::Vend      && _amountCurDebit   > 0 && canCalculate)
            || (_accountType == LedgerJournalACType::Vend    &&  _offsetAccountType == LedgerJournalACType::Ledger    && _amountCurCredit  > 0 && canCalculate)
            || (_accountType == LedgerJournalACType::Bank    &&  _offsetAccountType == LedgerJournalACType::Vend      && _amountCurCredit  > 0 && canCalculate)
            || (_accountType == LedgerJournalACType::Vend    &&  _offsetAccountType == LedgerJournalACType::Bank      && _amountCurDebit   > 0 && canCalculate)
            || (_accountType == LedgerJournalACType::Project &&  _offsetAccountType == LedgerJournalACType::Vend      && _amountCurDebit   > 0 && canCalculate)
            )
        {
             ret = true;
        }

        if (canCalculate
            && MainAccount::findByLedgerDimension(_OffsetLedgerDimension).PostingType == LedgerPostingType::SalesCash
            && ((_accountType          == LedgerJournalACType::Cust
                && _offsetAccountType  == LedgerJournalACType::Ledger
                && _amountCurCredit     >  0)
                ||
                (_accountType          == LedgerJournalACType::Ledger
                && _offsetAccountType  == LedgerJournalACType::Cust
                && _amountCurDebit     >  0)))
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCalculateTDS</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if TDS taxes are applicable to the combination of journals.
    /// </summary>
    /// <param name="_accountType">
    /// The LedgerJournalACType value for AccountType.
    /// </param>
    /// <param name="_offsetAccountType">
    /// The LedgerJournalACType value for OffsetAccountType.
    /// </param>
    /// <param name="_amountCurDebit">
    /// The AmountCurDebit value.
    /// </param>
    /// <param name="_amountCurCredit">
    /// The AmountCurCredit value.
    /// </param>
    /// <param name="_account">
    /// The AccountNum value.
    /// </param>
    /// <param name="_offsetAccount">
    /// The OffsetAccountNum value.
    /// </param>
    /// <param name="_ledgerJournalType">
    /// The LedgerJournalType value.
    /// </param>
    /// <param name="_OffsetLedgerDimension">
    /// The OffsetLedgerDimension value.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The LedgerDimension value
    /// </param>
    /// <returns>
    /// True, if TDS taxes are applicable to the combination of journals otherwise, false.
    /// </returns>
    public boolean canCalculateTDS(LedgerJournalACType     _accountType,
                                  LedgerJournalACType     _offsetAccountType,
                                  AmountCur               _amountCurDebit,
                                  AmountCur               _amountCurCredit,
                                  LedgerJournalAC         _account,
                                  LedgerJournalAC         _offsetAccount,
                                  LedgerJournalType       _ledgerJournalType,
                                  DimensionDynamicAccount _OffsetLedgerDimension = 0,
                                  DimensionDynamicAccount _ledgerDimension = 0)

    {
        boolean     ret;
        NoYes       canCalculate;
        TaxWithholdParameters_IN   taxWithholdParameters = TaxWithholdParameters_IN::find();

        switch (_accountType)
        {
            case LedgerJournalACType::Cust:
                canCalculate = CustTable::find(_account).TaxWithholdCalculate_IN;
            break;

            case LedgerJournalACType::Vend:
                canCalculate = VendTable::find(_account).TaxWithholdCalculate;
            break;
        }

        switch (_offsetAccountType)
        {
            case LedgerJournalACType::Cust:
                canCalculate = CustTable::find(_offsetAccount).TaxWithholdCalculate_IN;
            break;

            case LedgerJournalACType::Vend:
                canCalculate = VendTable::find(_offsetAccount).TaxWithholdCalculate;
            break;
        }

        if ((_accountType    == LedgerJournalACType::Cust         &&  _offsetAccountType == LedgerJournalACType::Bank        && _amountCurDebit  > 0 && canCalculate && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Vend         &&  _offsetAccountType == LedgerJournalACType::Bank        && _amountCurDebit  > 0 && canCalculate && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Bank         &&  _offsetAccountType == LedgerJournalACType::Cust        && _amountCurCredit > 0 && canCalculate && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Bank         &&  _offsetAccountType == LedgerJournalACType::Vend        && _amountCurCredit > 0 && canCalculate && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Cust         &&  _offsetAccountType == LedgerJournalACType::Bank        && _amountCurCredit > 0 && canCalculate && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::Bank         &&  _offsetAccountType == LedgerJournalACType::Cust        && _amountCurDebit  > 0 && canCalculate && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::Cust         &&  _offsetAccountType == LedgerJournalACType::Ledger      && _amountCurDebit  > 0 && canCalculate && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::Ledger       &&  _offsetAccountType == LedgerJournalACType::Cust        && _amountCurCredit > 0 && canCalculate && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::Ledger       &&  _offsetAccountType == LedgerJournalACType::Vend        && _amountCurDebit  > 0 && canCalculate && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::Vend         &&  _offsetAccountType == LedgerJournalACType::Ledger      && _amountCurCredit > 0 && canCalculate && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::Ledger       &&  _offsetAccountType == LedgerJournalACType::Cust        && _amountCurDebit  > 0 && canCalculate && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::Cust         &&  _offsetAccountType == LedgerJournalACType::Ledger      && _amountCurCredit > 0 && canCalculate && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::FixedAssets  &&  _offsetAccountType == LedgerJournalACType::Vend        && _amountCurDebit  > 0 && canCalculate && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::Vend         &&  _offsetAccountType == LedgerJournalACType::FixedAssets && _amountCurCredit > 0 && canCalculate && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::FixedAssets  &&  _offsetAccountType == LedgerJournalACType::Cust        && _amountCurDebit  > 0 && canCalculate && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::Cust         &&  _offsetAccountType == LedgerJournalACType::FixedAssets && _amountCurCredit > 0 && canCalculate && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::Bank         &&  _offsetAccountType == LedgerJournalACType::Ledger      && _amountCurCredit > 0 && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Ledger       &&  _offsetAccountType == LedgerJournalACType::Bank        && _amountCurDebit  > 0 && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Bank         &&  _offsetAccountType == LedgerJournalACType::Ledger      && _amountCurDebit  > 0 && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Ledger       &&  _offsetAccountType == LedgerJournalACType::Bank        && _amountCurCredit > 0 && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Project      &&  _offsetAccountType == LedgerJournalACType::Vend        && _amountCurDebit  > 0 && canCalculate && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::Vend         &&  _offsetAccountType == LedgerJournalACType::Project     && _amountCurCredit > 0 && canCalculate && taxWithholdParameters.tdsInvoice)
            )
        {
            ret = true;
        }

        if ( _accountType        == LedgerJournalACType::Vend        &&
            _offsetAccountType  == LedgerJournalACType::Ledger      &&
            _amountCurDebit     > 0                                 &&
            canCalculate                                            &&
            taxWithholdParameters.tdsInvoice                        &&
            (MainAccount::findByLedgerDimension(_OffsetLedgerDimension).PostingType == LedgerPostingType::PurchCash))
        {
            ret = true;
        }

        if ( _accountType        == LedgerJournalACType::Ledger      &&
            _offsetAccountType  == LedgerJournalACType::Vend        &&
            _amountCurCredit     > 0                                &&
            canCalculate                                            &&
            taxWithholdParameters.tdsInvoice                        &&
            (MainAccount::findByLedgerDimension(_ledgerDimension).PostingType == LedgerPostingType::PurchCash))
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCalculateWHTForCC</Name>
				<Source><![CDATA[
    /// <summary>
    /// returns true if withhold taxes are applicable; otherwise false.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The LedgerJournalTrans buffer.
    /// </param>
    /// <param name="_account">
    /// The CutVendAC value.
    /// </param>
    /// <param name="_isValidCombination">
    /// boolean value if valid Combination.
    /// </param>
    /// <param name="_isVendorTransaction">
    /// boolean value if valid Transaction.
    /// </param>
    /// <returns>
    /// returns true if withhold taxes are applicable; otherwise false.
    /// </returns>
    protected boolean canCalculateWHTForCC(LedgerJournalTrans _ledgerJournalTrans,
                                           CustVendAC         _account,
                                           boolean            _isValidCombination = false,
                                           boolean            _isVendorTransaction = false)
    {
        boolean                     canCalculateWHT               = true;
        boolean                     canCalculateWHTForInvoiceCust = false;
        boolean                     canCalculateWHTForInvoiceVend = false;
        VendTable                   vendTable;
        CustTable                   custTable;
        TaxWithholdParameters_IN    taxWithholdParameter;
        boolean                     isCrossCompany = true;
        TaxInformationCustTable_IN  taxInformationCustTableLoc;
        TaxInformationVendTable_IN  taxInformationVendTableLoc;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();

        if (_isVendorTransaction)
        {
            _isValidCombination = false;
        }

        if (_isValidCombination)
        {
            canCalculateWHT = ((_ledgerJournalTrans.AccountType    == LedgerJournalACType::Cust  && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank &&  _ledgerJournalTrans.AmountCurCredit  > 0 && ledgerJournalTransTaxExt.tcsGroup)
                                ||(_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank  && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust &&  _ledgerJournalTrans.AmountCurDebit   > 0 && ledgerJournalTransTaxExt.tcsGroup)
                                ||(_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend  && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank &&  _ledgerJournalTrans.AmountCurDebit   > 0 && ledgerJournalTransTaxExt.tdsGroup)
                                ||(_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank  && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend &&  _ledgerJournalTrans.AmountCurCredit  > 0 && ledgerJournalTransTaxExt.tdsGroup)
                                ||(_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust  && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank &&  _ledgerJournalTrans.AmountCurDebit   > 0 && ledgerJournalTransTaxExt.tdsGroup)
                                ||(_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank  && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust &&  _ledgerJournalTrans.AmountCurCredit  > 0 && ledgerJournalTransTaxExt.tdsGroup)
                                ||(_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend  && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank &&  _ledgerJournalTrans.AmountCurDebit   > 0 && ledgerJournalTransTaxExt.tdsGroup)
                                ||(_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank  && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend &&  _ledgerJournalTrans.AmountCurCredit  > 0 && ledgerJournalTransTaxExt.tdsGroup)
                                ||(_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust  && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank &&  _ledgerJournalTrans.AmountCurCredit  > 0 && ledgerJournalTransTaxExt.tdsGroup)
                                ||(_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank  && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust &&  _ledgerJournalTrans.AmountCurDebit   > 0 && ledgerJournalTransTaxExt.tdsGroup)

                                ||(_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank  && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend &&  _ledgerJournalTrans.AmountCurCredit  > 0 && ledgerJournalTransTaxExt.tcsGroup)
                                ||(_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend  && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank &&  _ledgerJournalTrans.AmountCurDebit   > 0 && ledgerJournalTransTaxExt.tcsGroup))

                                ? true : false;
        }

        if ( _ledgerJournalTrans.AccountType         == LedgerJournalACType::Vend        &&
            _ledgerJournalTrans.OffsetAccountType   == LedgerJournalACType::Ledger      &&
            _ledgerJournalTrans.AmountCurDebit      > 0                                 &&
            (ledgerJournalTransTaxExt.tcsGroup || ledgerJournalTransTaxExt.tdsGroup)        &&
            (MainAccount::findByLedgerDimension(_ledgerJournalTrans.OffsetLedgerDimension).PostingType == LedgerPostingType::PurchCash))
        {
            canCalculateWHT = true;
        }
        else if ( _ledgerJournalTrans.AccountType         == LedgerJournalACType::Ledger      &&
                 _ledgerJournalTrans.OffsetAccountType   == LedgerJournalACType::Vend        &&
                 _ledgerJournalTrans.AmountCurCredit     > 0                                 &&
                 (ledgerJournalTransTaxExt.tcsGroup || ledgerJournalTransTaxExt.tdsGroup)        &&
                 (MainAccount::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension).PostingType == LedgerPostingType::PurchCash))
        {
            canCalculateWHT = true;
        }

        changecompany(companyId)
        {
            taxWithholdParameter            = TaxWithholdParameters_IN::find();
            vendTable                       = VendTable::find(_account);
            taxInformationVendTableLoc      = vendTable.getTaxInformationVendTable_IN();
            canCalculateWHTForInvoiceVend   = (vendTable && ((taxInformationVendTableLoc.tdsGroup && taxWithholdParameter.tdsPayment) ||(taxInformationVendTableLoc.tcsGroup && taxWithholdParameter.tcsPayment))
                                               && vendTable.TaxWithholdCalculate) ? true : false;

            custTable                       = CustTable::find(_account);
            taxInformationCustTableLoc      = custTable.getTaxInformationCustTable_IN();
            canCalculateWHTForInvoiceCust   = (custTable && ((taxInformationCustTableLoc.tdsGroup && taxWithholdParameter.tdsPayment) ||(taxInformationCustTableLoc.tcsGroup && taxWithholdParameter.tcsPayment))

                                   && custTable.TaxWithholdCalculate_IN) ? true : false;
        }

        if (companyId != paymcompanyId)
        {
            isCrossCompany =  TaxWithholdParameters_IN::findByCompany(paymcompanyId).CrossCompanyPayment;
        }

        canCalculateWHT    = (isCrossCompany && canCalculateWHT && (canCalculateWHTForInvoiceVend || canCalculateWHTForInvoiceCust)) ? true : false;

        return canCalculateWHT;
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditNoteCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates withholding taxes for CreditNote.
    /// </summary>
    /// <param name="_taxWithholdData">
    /// The Container of TaxWithholdData.
    /// </param>
    /// <param name="_purchId">
    /// The PurchId value.
    /// </param>
    /// <param name="_salesId">
    /// The SalesId value.
    /// </param>
    /// <returns>
    /// Withholding taxAmount for CreditNote.
    /// </returns>
    [SysObsolete('Method creditNoteCalculation has been deprecated, please use method creditNoteCalculationV2.', false, 02\05\2023)]
    public TaxAmountCur creditNoteCalculation(
        container       _taxWithholdData,
        PurchIdBase     _purchId,
        SalesIdBase     _salesId)
    {
        return this.creditNoteCalculationV2(_taxWithholdData, _purchId, _salesId, '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditNoteCalculationV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates withholding taxes for CreditNote.
    /// </summary>
    /// <param name="_taxWithholdData">
    /// The Container of TaxWithholdData.
    /// </param>
    /// <param name="_purchId">
    /// The PurchId value.
    /// </param>
    /// <param name="_salesId">
    /// The SalesId value.
    /// </param>
    /// <param name="_projId">
    /// The project id value.
    /// </param>
    /// <returns>
    /// Withholding taxAmount for credit note.
    /// </returns>
    public TaxAmountCur creditNoteCalculationV2(
        container _taxWithholdData,
        PurchIdBase _purchId,
        SalesIdBase _salesId,
        ProjId _projId)
    {
        TaxWithholdTrans_IN taxwithholdTransLoc;
        TaxAmountCur totalTaxWithholdCalculated;
        Factor taxFactor;

        Voucher voucherLoc = conPeek(_taxWithholdData, 19);
        LineNum lineNum = conPeek(_taxWithholdData, 20);
        TransDate creditNoteDate = conPeek(_taxWithholdData, 17);

        boolean isTaxProjInteJourFeatureEnabled = FeatureStateProvider::isFeatureEnabled(TaxProjOpsIntegrationJournal_INFeature::instance());

        select firstOnly AmountOriginMST, CurrencyCode, Voucher, TransDate
            from taxwithholdTransLoc
                where ((isTaxProjInteJourFeatureEnabled
                        && _projId
                        && taxwithholdTransLoc.ProjId == _projId)
                    || taxwithholdTransLoc.SalesId == _salesId
                    || taxwithholdTransLoc.PurchId == _purchId)
                    && taxwithholdTransLoc.Voucher == voucherLoc
                    && taxwithholdTransLoc.LineNum == lineNum;

        //Check if the Taxwithhold settlement process is run. Do not reverse the taxes for transactions where settlement is run.
        if (TaxwithholdTransReverse_IN::isSettlementProcessRun(taxwithholdTransLoc.Voucher, taxwithholdTransLoc.TransDate))
        {
            return totalTaxWithholdCalculated;
        }

        if (taxwithholdTransLoc.AmountOriginMST)
        {
            taxFactor = CurrencyExchangeHelper::amountCur2MST(tmpTransLineWithholdGrossAmount.LineGrossAmountCur, taxwithholdTransLoc.CurrencyCode) / taxwithholdTransLoc.AmountOriginMST;
        }

        if (abs(taxFactor)> 1)
        {
            taxFactor = -1;
        }

        while select taxwithholdTransLoc
            order by RecId asc
                where ((isTaxProjInteJourFeatureEnabled
                        && _projId
                        && taxwithholdTransLoc.ProjId == _projId)
                    || taxwithholdTransLoc.SalesId == _salesId
                    || taxwithholdTransLoc.PurchId == _purchId)
                    && taxwithholdTransLoc.Voucher == voucherLoc
                    && taxwithholdTransLoc.LineNum == lineNum
        {
            taxWithholdWorkTrans.clear();
            taxWithholdWorkTrans.initFromTaxWithholdTrans(taxwithholdTransLoc, taxFactor);

            taxWithholdWorkTrans.SourceTableId = conPeek(_taxWithholdData, #8);
            taxWithholdWorkTrans.SourceRecId = conPeek(_taxWithholdData, #9);

            if (isTaxProjInteJourFeatureEnabled && _projId)
            {
                taxWithholdWorkTrans.Voucher = conPeek(_taxWithholdData, #10);
            }

            taxWithholdWorkTrans.HeadingTableId = conPeek(_taxWithholdData, 22);
            taxWithholdWorkTrans.HeadingRecId = conPeek(_taxWithholdData, 23);
            taxWithholdWorkTrans.ExchangeRate = conPeek(_taxWithholdData, #1);
            taxWithholdWorkTrans.ExchRateSecond = conPeek(_taxWithholdData, #2);
            taxWithholdWorkTrans.TaxBaseQty = conPeek(_taxWithholdData, 21);
            taxWithholdWorkTrans.TransactionStatus = TaxWithholdTransactionstatus_IN::Adjusted;

            taxWithholdWorkTrans.CalculationDate = conPeek(_taxWithholdData, #TaxDate);
            taxWithholdWorkTrans.SourceTransDate = taxwithholdTransLoc.TransDate;
            taxWithholdWorkTrans.SourceTransVoucher = taxwithholdTransLoc.Voucher;

            taxWithholdWorkTrans.insert();

            totalTaxWithholdCalculated += taxWithholdWorkTrans.SourceRegulateAmountCur;
        }

        return totalTaxWithholdCalculated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountType</Name>
				<Source><![CDATA[
    private AccountType_IN getAccountType(boolean _isVendTransaction)
    {
        return _isVendTransaction ? AccountType_IN::Vend : AccountType_IN::Cust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGrossAmountConsideringThreshold</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the GrossAmount for the WithholdTax calculation based on the threshold limit.
    /// </summary>
    /// <param name="_taxWithholdTable">
    /// The TaxWithholdTable buffer.
    /// </param>
    /// <param name="_transDate">
    /// The TransDate value.
    /// </param>
    /// <param name="_accountNum">
    /// The AccountNum value.
    /// </param>
    /// <param name="_taxWithholdGroup">
    /// The TaxWithholdGroup value.
    /// </param>
    /// <param name="_exchangeRateHelper">
    /// The CurrencyExchangeHelper class instance.
    /// </param>
    /// <param name="_sourceCurrency">
    /// The Source currency.
    /// </param>
    /// <param name="_taxModuleType">
    /// The TaxModuleType.
    /// </param>
    /// <param name="_sourceTableId">
    /// The SourceTableId.
    /// </param>
    /// <returns>
    /// Calculated grossAmount.
    /// </returns>
    private container getGrossAmountConsideringThreshold(
        TaxWithholdTable       _taxWithholdTable,
        TransDate              _transDate,
        AccountNum             _accountNum,
        TaxWithholdGroup       _taxWithholdGroup,
        CurrencyExchangeHelper _exchangeRateHelper,
        CurrencyCode           _sourceCurrency,
        TaxModuleType          _taxModuleType,
        RefTableId             _sourceTableId)
    {
        TaxWithholdThresholdLimit_IN    taxWithholdThresholdLimit;
        TaxWithholdTrans_IN             taxWithholdTransloc;
        TaxAmount                       totalInvoiceAmount, totalUnpostedAmount, taxWithholdThreshold;
        TmpTaxWithholdWorkTrans_IN      tmpTaxWithholdWorkTransLoc;
        TaxWithholdUncommitted_IN       taxWithHoldUncommittedLoc;
        TaxWithholdGroupData            taxWithholdGroupDataLoc;
        AmountMST                       postedUncalculatedTransAmountMST;

        select firstonly TaxWithholdComponent, FromDate, ToDate, ExceptionThreshold, Threshold, RecId
            from taxWithholdThresholdLimit
            where taxWithholdThresholdLimit.TaxWithholdComponent      == _taxWithholdTable.TaxWithholdComponent_IN
                && (!taxWithholdThresholdLimit.FromDate
                || (taxWithholdThresholdLimit.FromDate                 <= _transDate
                && taxWithholdThresholdLimit.ToDate                    >= _transDate));

        if (taxWithholdThresholdLimit.RecId)
        {
            select sum(AmountOriginMST) from taxWithholdTransLoc
                where (taxWithholdTransLoc.VendAccount      == _accountNum
                    || taxWithholdTransLoc.CustAccount       == _accountNum)
                    && taxWithholdTransLoc.TaxWithholdGroup  == _taxWithholdGroup
                    && taxWithholdTransLoc.TaxWithholdCode   == _taxWithholdTable.TaxWithholdCode
                    && taxWithholdTransLoc.TransDate         >= taxWithholdThresholdLimit.FromDate
                    && taxWithholdTransLoc.TransDate         <= taxWithholdThresholdLimit.ToDate;

            totalInvoiceAmount      = taxWithholdTransLoc.AmountOriginMST;

            // Get the unPosted amount for threshold check. This is for multiple lines order, with the threshold exceeds cumulative of amount of multiple lines.
            if (_taxModuleType != TaxModuleType::Voucher)
            {
                tmpTaxWithholdWorkTransLoc.setTmpData(taxWithholdWorkTrans);

                select sum(AmountOriginMST) from tmpTaxWithholdWorkTransLoc
                    where tmpTaxWithholdWorkTransLoc.AccountNumber    == _accountNum
                       && tmpTaxWithholdWorkTransLoc.TaxWithholdGroup == _taxWithholdGroup
                       && tmpTaxWithholdWorkTransLoc.TaxWithholdCode  == _taxWithholdTable.TaxWithholdCode
                       && tmpTaxWithholdWorkTransLoc.CalculationDate  >= taxWithholdThresholdLimit.FromDate
                       && tmpTaxWithholdWorkTransLoc.CalculationDate  <= taxWithholdThresholdLimit.ToDate
                       && tmpTaxWithholdWorkTransLoc.SourceTableId    == _sourceTableId
                       && tmpTaxWithholdWorkTransLoc.HeadingTableId   == headingTableId
                       && tmpTaxWithholdWorkTransLoc.HeadingRecId     == headingRecId;

                totalUnpostedAmount = tmpTaxWithholdWorkTransLoc.AmountOriginMST;
            }
            else if (_taxModuleType == TaxModuleType::Voucher)
            {
                select sum(amountOriginMST) from taxWithHoldUncommittedLoc
                    where taxWithHoldUncommittedLoc.AccountNumber == _accountNum
                        && taxWithHoldUncommittedLoc.TaxWithholdGroup == _taxWithholdGroup
                        && taxWithHoldUncommittedLoc.TaxWithholdCode  == _taxWithholdTable.TaxWithholdCode
                        && taxWithHoldUncommittedLoc.CalculationDate  >= taxWithholdThresholdLimit.FromDate
                        && taxWithHoldUncommittedLoc.CalculationDate  <= taxWithholdThresholdLimit.ToDate
                        && taxWithHoldUncommittedLoc.SourceTableId    == _sourceTableId
                        && taxWithHoldUncommittedLoc.HeadingTableId   == headingTableId
                        && taxWithHoldUncommittedLoc.HeadingRecId     == headingRecId;

                totalUnpostedAmount = taxWithHoldUncommittedLoc.AmountOriginMST;
            }

            taxWithholdThreshold = totalInvoiceAmount + totalUnpostedAmount + _exchangeRateHelper.calculateTransactionToAccounting(_sourceCurrency, curTransWHTNotCalculatedBaseCur, true);
            if (taxWithholdThresholdLimit.Threshold                 >= taxWithholdThreshold
                && taxWithholdThresholdLimit.ExceptionThreshold
                && taxWithholdThresholdLimit.ExceptionThreshold     < _exchangeRateHelper.calculateTransactionToAccounting(_sourceCurrency, curTransWHTNotCalculatedBaseCur, true))
            {
                exceptionalThreshold            = true;
            }

            select firstonly TaxWithholdCode, Exempt_IN from taxWithholdGroupDataLoc
                where taxWithholdGroupDataLoc.TaxWithholdCode   == _taxWithholdTable.TaxWithholdCode
                    && taxWithholdGroupDataLoc.TaxWithholdGroup  == _taxWithholdGroup;
            if (taxWithholdGroupDataLoc.OverlookTax_IN)
            {
                overLookThreshold               = true;
            }

            totalUnpostedAmount = 0; //reset the varaible, and set the value if the threshold exceeded based on taxCalculated below.

            if (taxWithholdThresholdLimit.Threshold < taxWithholdThreshold)
            {
                if (_taxModuleType != TaxModuleType::Voucher)
                {
                    select firstOnly RecId from tmpTaxWithholdWorkTransLoc
                        where tmpTaxWithholdWorkTransLoc.AccountNumber    == _accountNum
                           && tmpTaxWithholdWorkTransLoc.TaxWithholdGroup == _taxWithholdGroup
                           && tmpTaxWithholdWorkTransLoc.TaxWithholdCode  == _taxWithholdTable.TaxWithholdCode
                           && tmpTaxWithholdWorkTransLoc.CalculationDate  >= taxWithholdThresholdLimit.FromDate
                           && tmpTaxWithholdWorkTransLoc.CalculationDate  <= taxWithholdThresholdLimit.ToDate
                           && tmpTaxWithholdWorkTransLoc.sourceTableId    == _sourceTableId
                           && tmpTaxWithholdWorkTransLoc.HeadingTableId   == headingTableId
                           && tmpTaxWithholdWorkTransLoc.HeadingRecId     == headingRecId
                           && tmpTaxWithholdWorkTransLoc.IsTaxCalculated;

                    if (tmpTaxWithholdWorkTransLoc.RecId == 0 && !overLookThreshold)
                    {
                        select sum(AmountOriginMST) from tmpTaxWithholdWorkTransLoc
                            where tmpTaxWithholdWorkTransLoc.AccountNumber    == _accountNum
                               && tmpTaxWithholdWorkTransLoc.TaxWithholdGroup == _taxWithholdGroup
                               && tmpTaxWithholdWorkTransLoc.TaxWithholdCode  == _taxWithholdTable.TaxWithholdCode
                               && tmpTaxWithholdWorkTransLoc.CalculationDate  >= taxWithholdThresholdLimit.FromDate
                               && tmpTaxWithholdWorkTransLoc.CalculationDate  <= taxWithholdThresholdLimit.ToDate
                               && tmpTaxWithholdWorkTransLoc.SourceTableId    == _sourceTableId
                               && tmpTaxWithholdWorkTransLoc.HeadingTableId   == headingTableId
                               && tmpTaxWithholdWorkTransLoc.HeadingRecId     == headingRecId;

                        totalUnpostedAmount = tmpTaxWithholdWorkTransLoc.AmountOriginMST;
                    }
                }
                else if (_taxModuleType == TaxModuleType::Voucher)
                {
                    // For journals the calculation happens per voucher, so tmpTaxWithholdWorkTrans buffer is blank, use TaxWithholdUncommitted_IN table.
                    select firstOnly RecId from taxWithHoldUncommittedLoc
                        where taxWithHoldUncommittedLoc.AccountNumber    == _accountNum
                            && taxWithHoldUncommittedLoc.TaxWithholdGroup == _taxWithholdGroup
                            && taxWithHoldUncommittedLoc.TaxWithholdCode  == _taxWithholdTable.TaxWithholdCode
                            && taxWithHoldUncommittedLoc.CalculationDate  >= taxWithholdThresholdLimit.FromDate
                            && taxWithHoldUncommittedLoc.CalculationDate  <= taxWithholdThresholdLimit.ToDate
                            && taxWithHoldUncommittedLoc.SourceTableId    == _sourceTableId
                            && taxWithHoldUncommittedLoc.HeadingTableId   == headingTableId
                            && taxWithHoldUncommittedLoc.HeadingRecId     == headingRecId
                            && taxWithHoldUncommittedLoc.IsTaxCalculated;

                    if (taxWithHoldUncommittedLoc.RecId == 0 && !overLookThreshold)
                    {
                        select sum(amountOriginMST) from taxWithHoldUncommittedLoc
                            where taxWithHoldUncommittedLoc.AccountNumber == _accountNum
                                && taxWithHoldUncommittedLoc.TaxWithholdGroup == _taxWithholdGroup
                                && taxWithHoldUncommittedLoc.TaxWithholdCode  == _taxWithholdTable.TaxWithholdCode
                                && taxWithHoldUncommittedLoc.CalculationDate  >= taxWithholdThresholdLimit.FromDate
                                && taxWithHoldUncommittedLoc.CalculationDate  <= taxWithholdThresholdLimit.ToDate
                                && taxWithHoldUncommittedLoc.SourceTableId    == _sourceTableId
                                && taxWithHoldUncommittedLoc.HeadingTableId   == headingTableId
                                && taxWithHoldUncommittedLoc.HeadingRecId     == headingRecId
                                && taxWithHoldUncommittedLoc.AdvancePayment   == true;

                        totalUnpostedAmount = (taxWithHoldUncommittedLoc.AmountOriginMST * 100) / (100 + tmpRateOfDeduction);

                        select sum(amountOriginMST) from taxWithHoldUncommittedLoc
                            where taxWithHoldUncommittedLoc.AccountNumber == _accountNum
                                && taxWithHoldUncommittedLoc.TaxWithholdGroup == _taxWithholdGroup
                                && taxWithHoldUncommittedLoc.TaxWithholdCode  == _taxWithholdTable.TaxWithholdCode
                                && taxWithHoldUncommittedLoc.CalculationDate  >= taxWithholdThresholdLimit.FromDate
                                && taxWithHoldUncommittedLoc.CalculationDate  <= taxWithholdThresholdLimit.ToDate
                                && taxWithHoldUncommittedLoc.SourceTableId    == _sourceTableId
                                && taxWithHoldUncommittedLoc.HeadingTableId   == headingTableId
                                && taxWithHoldUncommittedLoc.HeadingRecId     == headingRecId
                                && taxWithHoldUncommittedLoc.AdvancePayment   == false
                                && taxWithHoldUncommittedLoc.AmountOriginMST <= taxWithholdThresholdLimit.ExceptionThreshold;

                        totalUnpostedAmount += taxWithHoldUncommittedLoc.AmountOriginMST;
                    }
                }
            }
            if (taxWithholdThresholdLimit.Threshold < taxWithholdThreshold && (!tmpTaxWithholdWorkTransLoc.RecId && !taxWithHoldUncommittedLoc.RecId))
            {
                select sum(AmountOriginMST) from taxWithholdTransLoc
                    where (taxWithholdTransLoc.VendAccount              == _accountNum
                        || taxWithholdTransLoc.CustAccount              == _accountNum)
                        && taxWithholdTransLoc.TaxWithholdGroup         == _taxWithholdGroup
                        && taxWithholdTransLoc.TaxWithholdCode          == _taxWithholdTable.TaxWithholdCode
                        && taxWithholdTransLoc.TaxWithholdCalculated    == false
                        && taxWithholdTransLoc.TransDate                >= taxWithholdThresholdLimit.FromDate
                        && taxWithholdTransLoc.TransDate                <= taxWithholdThresholdLimit.ToDate
                        && taxWithholdTransLoc.AdvancePayment           == true;
                postedUncalculatedTransAmountMST = (taxWithholdTransLoc.AmountOriginMST * 100) / (100 + tmpRateOfDeduction);

                select sum(AmountOriginMST) from taxWithholdTransLoc
                    where (taxWithholdTransLoc.VendAccount              == _accountNum
                        || taxWithholdTransLoc.CustAccount              == _accountNum)
                        && taxWithholdTransLoc.TaxWithholdGroup         == _taxWithholdGroup
                        && taxWithholdTransLoc.TaxWithholdCode          == _taxWithholdTable.TaxWithholdCode
                        && taxWithholdTransLoc.TaxWithholdCalculated    == false
                        && taxWithholdTransLoc.TransDate                >= taxWithholdThresholdLimit.FromDate
                        && taxWithholdTransLoc.TransDate                <= taxWithholdThresholdLimit.ToDate
                        && taxWithholdTransLoc.AdvancePayment           == false;
                postedUncalculatedTransAmountMST += taxWithholdTransLoc.AmountOriginMST;
            }
        }

        return [exceptionalThreshold, overLookThreshold, taxWithholdThreshold, (postedUncalculatedTransAmountMST + totalUnpostedAmount)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaintainExistingTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>maintainExistingTaxUncommitted</c> value that indicates whether new records will
    ///    be added to the <c>TaxWithholdUncommitted_IN</c> table.
    /// </summary>
    /// <returns>
    ///    true if newly calculated tax lines will be added to the <c>TaxWithholdUncommitted_IN</c> table; otherwise,
    ///    false.
    /// </returns>
    public boolean getMaintainExistingTaxUncommitted()
    {
        return maintainExistingTaxWithholdUncommitted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxWithholdThresholdHandler</Name>
				<Source><![CDATA[
    private TaxWithholdThresholdHandler_IN getTaxWithholdThresholdHandler(
        AccountType_IN      _accountType,
        AccountNum          _accountNum,
        TaxWithholdCode     _taxWithholdCode,
        TaxWithholdGroup    _taxWithholdGroup,
        Transdate           _transDate,
        AmountMST           _curTransLineAmountMST,
        NoYesId             _isOverLook,
        RefTableId          _sourceTableId = 0,
        RefRecId            _sourceRecId = 0)
    {
        TaxWithholdThresholdHandler_IN      taxWithholdThresholdHandler;
        TaxWHTThresholdSourceLineImpl_IN    taxWHTThresholdSourceLineImpl;

        taxWHTThresholdSourceLineImpl   = TaxWHTThresholdSourceLineImpl_IN::construct(this, _accountType, _accountNum, _taxWithholdCode, _transDate, _curTransLineAmountMST, _isOverLook);
        if (isThresholdBasedOnPaymentOnly)
        {
            taxWHTThresholdSourceLineImpl.parmTaxWithholdGroup(_taxWithholdGroup);
            if (_sourceTableId && _sourceRecId && TaxWithholdGroupHeading::find(_taxWithholdGroup).TaxLiabilityOnPayment_IN)
            {
                taxWHTThresholdSourceLineImpl.parmIsProgressiveApplicable(!this.isCustInvoiceTransaction(_sourceTableId, _sourceRecId));
                taxWHTThresholdSourceLineImpl.parmIsPriceInclusive(this.isPriceInclusive(_sourceTableId, _sourceRecId));
            }
        }

        taxWithholdThresholdHandler     = ThresholdHandlerFactory_IN::newThresholdHandler(taxWHTThresholdSourceLineImpl);

        return taxWithholdThresholdHandler;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPriceInclusive</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected boolean isPriceInclusive(RefTableId _transactionLineTableId, RefRecId _transactionLineRecId)
    {
        // Override in extended class
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getValueForPerTransThresholdCompare</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the ValueForOneShotThresholdCompare .
    /// </summary>
    /// <param name="_taxWithholdTable">
    /// The TaxWithholdTable buffer.
    /// </param>
    /// <param name="_transDate">
    /// The TransDate value.
    /// </param>
    /// <param name="_accountNum">
    /// The AccountNum value.
    /// </param>
    /// <param name="_taxWithholdGroup">
    /// The TaxWithholdGroup value.
    /// </param>
    /// <param name="_exchangeRateHelper">
    /// The CurrencyExchangeHelper class instance.
    /// </param>
    /// <param name="_sourceCurrency">
    /// The Source currency.
    /// </param>
    /// <param name="_taxModuleType">
    /// The TaxModuleType.
    /// </param>
    /// <param name="_sourceTableId">
    /// The SourceTableId.
    /// </param>
    /// <param name="_isByCash">
    /// whether it is by cash.
    /// </param>
    /// <returns>
    /// Calculated grossAmount.
    /// </returns>
    private container getValueForPerTransThresholdCompare(
        TaxWithholdTable       _taxWithholdTable,
        TransDate              _transDate,
        AccountNum             _accountNum,
        TaxWithholdGroup       _taxWithholdGroup,
        CurrencyExchangeHelper _exchangeRateHelper,
        CurrencyCode           _sourceCurrency,
        TaxModuleType          _taxModuleType,
        RefTableId             _sourceTableId,
        boolean                _isByCash = false
        )
    {
        TaxWithholdThresholdLimit_IN    taxWithholdThresholdLimit;
        TaxWithholdTrans_IN             taxWithholdTransloc;
        TaxAmount                       totalUnpostedAmount, valueForOneShotThresholdCompare, taxWithholdThreshold;
        TmpTaxWithholdWorkTrans_IN      tmpTaxWithholdWorkTransLoc;
        TaxWithholdUncommitted_IN       taxWithHoldUncommittedLoc;

        select firstonly TaxWithholdComponent, FromDate, ToDate, ExceptionThreshold, Threshold, RecId
            from taxWithholdThresholdLimit
            where taxWithholdThresholdLimit.TaxWithholdComponent      == _taxWithholdTable.TaxWithholdComponent_IN
                && (!taxWithholdThresholdLimit.FromDate
                || (taxWithholdThresholdLimit.FromDate                 <= _transDate
                && taxWithholdThresholdLimit.ToDate                    >= _transDate));

        if (taxWithholdThresholdLimit.RecId)
        {
            select sum(AmountOriginMST) from taxWithholdTransLoc
                where (taxWithholdTransLoc.VendAccount      == _accountNum
                    || taxWithholdTransLoc.CustAccount       == _accountNum)
                    && taxWithholdTransLoc.TaxWithholdGroup  == _taxWithholdGroup
                    && taxWithholdTransLoc.TaxWithholdCode   == _taxWithholdTable.TaxWithholdCode
                    && taxWithholdTransLoc.TransDate         >= taxWithholdThresholdLimit.FromDate
                    && taxWithholdTransLoc.TransDate         <= taxWithholdThresholdLimit.ToDate;

            // Get the unPosted amount for threshold check. This is for multiple lines order, with the threshold exceeds cumulative of amount of multiple lines.
            if (_taxModuleType != TaxModuleType::Voucher)
            {
                tmpTaxWithholdWorkTransLoc.setTmpData(taxWithholdWorkTrans);

                select sum(AmountOriginMST) from tmpTaxWithholdWorkTransLoc
                    where tmpTaxWithholdWorkTransLoc.AccountNumber    == _accountNum
                       && tmpTaxWithholdWorkTransLoc.TaxWithholdGroup == _taxWithholdGroup
                       && tmpTaxWithholdWorkTransLoc.TaxWithholdCode  == _taxWithholdTable.TaxWithholdCode
                       && tmpTaxWithholdWorkTransLoc.CalculationDate  >= taxWithholdThresholdLimit.FromDate
                       && tmpTaxWithholdWorkTransLoc.CalculationDate  <= taxWithholdThresholdLimit.ToDate
                       && tmpTaxWithholdWorkTransLoc.SourceTableId    == _sourceTableId
                       && tmpTaxWithholdWorkTransLoc.HeadingTableId   == headingTableId
                       && tmpTaxWithholdWorkTransLoc.HeadingRecId     == headingRecId;

                totalUnpostedAmount = tmpTaxWithholdWorkTransLoc.AmountOriginMST;
            }
            else
            {
                select sum(amountOriginMST) from taxWithHoldUncommittedLoc
                    where taxWithHoldUncommittedLoc.AccountNumber == _accountNum
                        && taxWithHoldUncommittedLoc.TaxWithholdGroup == _taxWithholdGroup
                        && taxWithHoldUncommittedLoc.TaxWithholdCode  == _taxWithholdTable.TaxWithholdCode
                        && taxWithHoldUncommittedLoc.CalculationDate  >= taxWithholdThresholdLimit.FromDate
                        && taxWithHoldUncommittedLoc.CalculationDate  <= taxWithholdThresholdLimit.ToDate
                        && taxWithHoldUncommittedLoc.SourceTableId    == _sourceTableId
                        && taxWithHoldUncommittedLoc.HeadingTableId   == headingTableId
                        && taxWithHoldUncommittedLoc.HeadingRecId     == headingRecId;

                totalUnpostedAmount = taxWithHoldUncommittedLoc.AmountOriginMST;
            }
            taxWithholdThreshold = totalUnpostedAmount + _exchangeRateHelper.calculateTransactionToAccounting(_sourceCurrency, curTransWHTNotCalculatedBaseCur, true);
        }

        valueForOneShotThresholdCompare = taxWithholdThreshold;

        totalUnpostedAmount = 0; //reset the varaible, and set the value if the threshold exceeded based on taxCalculated below.

        if (taxWithholdThresholdLimit.PerTransThreshhold < valueForOneShotThresholdCompare)
        {
            if (_taxModuleType != TaxModuleType::Voucher)
            {
                select firstOnly RecId from tmpTaxWithholdWorkTransLoc
                    where tmpTaxWithholdWorkTransLoc.AccountNumber    == _accountNum
                       && tmpTaxWithholdWorkTransLoc.TaxWithholdGroup == _taxWithholdGroup
                       && tmpTaxWithholdWorkTransLoc.TaxWithholdCode  == _taxWithholdTable.TaxWithholdCode
                       && tmpTaxWithholdWorkTransLoc.CalculationDate  >= taxWithholdThresholdLimit.FromDate
                       && tmpTaxWithholdWorkTransLoc.CalculationDate  <= taxWithholdThresholdLimit.ToDate
                       && tmpTaxWithholdWorkTransLoc.sourceTableId    == _sourceTableId
                       && tmpTaxWithholdWorkTransLoc.HeadingTableId   == headingTableId
                       && tmpTaxWithholdWorkTransLoc.HeadingRecId     == headingRecId
                       && tmpTaxWithholdWorkTransLoc.IsTaxCalculated;

                if (tmpTaxWithholdWorkTransLoc.RecId == 0)
                {
                    select sum(AmountOriginMST) from tmpTaxWithholdWorkTransLoc
                        where tmpTaxWithholdWorkTransLoc.AccountNumber    == _accountNum
                           && tmpTaxWithholdWorkTransLoc.TaxWithholdGroup == _taxWithholdGroup
                           && tmpTaxWithholdWorkTransLoc.TaxWithholdCode  == _taxWithholdTable.TaxWithholdCode
                           && tmpTaxWithholdWorkTransLoc.CalculationDate  >= taxWithholdThresholdLimit.FromDate
                           && tmpTaxWithholdWorkTransLoc.CalculationDate  <= taxWithholdThresholdLimit.ToDate
                           && tmpTaxWithholdWorkTransLoc.SourceTableId    == _sourceTableId
                           && tmpTaxWithholdWorkTransLoc.HeadingTableId   == headingTableId
                           && tmpTaxWithholdWorkTransLoc.HeadingRecId     == headingRecId;

                    totalUnpostedAmount = tmpTaxWithholdWorkTransLoc.AmountOriginMST;
                }
            }
            else if (_taxModuleType == TaxModuleType::Voucher)
            {
                // For journals the calculation happens per voucher, so tmpTaxWithholdWorkTrans buffer is blank, use TaxWithholdUncommitted_IN table.
                select firstOnly RecId from taxWithHoldUncommittedLoc
                    where taxWithHoldUncommittedLoc.AccountNumber    == _accountNum
                        && taxWithHoldUncommittedLoc.TaxWithholdGroup == _taxWithholdGroup
                        && taxWithHoldUncommittedLoc.TaxWithholdCode  == _taxWithholdTable.TaxWithholdCode
                        && taxWithHoldUncommittedLoc.CalculationDate  >= taxWithholdThresholdLimit.FromDate
                        && taxWithHoldUncommittedLoc.CalculationDate  <= taxWithholdThresholdLimit.ToDate
                        && taxWithHoldUncommittedLoc.SourceTableId    == _sourceTableId
                        && taxWithHoldUncommittedLoc.HeadingTableId   == headingTableId
                        && taxWithHoldUncommittedLoc.HeadingRecId     == headingRecId
                        && taxWithHoldUncommittedLoc.IsTaxCalculated;

                if (taxWithHoldUncommittedLoc.RecId == 0)
                {
                    select sum(amountOriginMST) from taxWithHoldUncommittedLoc
                        where taxWithHoldUncommittedLoc.AccountNumber == _accountNum
                            && taxWithHoldUncommittedLoc.TaxWithholdGroup == _taxWithholdGroup
                            && taxWithHoldUncommittedLoc.TaxWithholdCode  == _taxWithholdTable.TaxWithholdCode
                            && taxWithHoldUncommittedLoc.CalculationDate  >= taxWithholdThresholdLimit.FromDate
                            && taxWithHoldUncommittedLoc.CalculationDate  <= taxWithholdThresholdLimit.ToDate
                            && taxWithHoldUncommittedLoc.SourceTableId    == _sourceTableId
                            && taxWithHoldUncommittedLoc.HeadingTableId   == headingTableId
                            && taxWithHoldUncommittedLoc.HeadingRecId     == headingRecId
                            && taxWithHoldUncommittedLoc.AdvancePayment   == true;

                    totalUnpostedAmount = (taxWithHoldUncommittedLoc.AmountOriginMST * 100) / (100 + tmpRateOfDeduction);

                    select sum(amountOriginMST) from taxWithHoldUncommittedLoc
                        where taxWithHoldUncommittedLoc.AccountNumber == _accountNum
                            && taxWithHoldUncommittedLoc.TaxWithholdGroup == _taxWithholdGroup
                            && taxWithHoldUncommittedLoc.TaxWithholdCode  == _taxWithholdTable.TaxWithholdCode
                            && taxWithHoldUncommittedLoc.CalculationDate  >= taxWithholdThresholdLimit.FromDate
                            && taxWithHoldUncommittedLoc.CalculationDate  <= taxWithholdThresholdLimit.ToDate
                            && taxWithHoldUncommittedLoc.SourceTableId    == _sourceTableId
                            && taxWithHoldUncommittedLoc.HeadingTableId   == headingTableId
                            && taxWithHoldUncommittedLoc.HeadingRecId     == headingRecId
                            && taxWithHoldUncommittedLoc.AdvancePayment   == false;

                    totalUnpostedAmount += taxWithHoldUncommittedLoc.AmountOriginMST;
                }
            }
        }

        return [valueForOneShotThresholdCompare, totalUnpostedAmount];
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the <c>TaxWithholdUncommitted_IN</c> records into the <c>TmpTaxWithholdWorkTrans_IN</c> buffer.
    /// </summary>
    /// <param name="_initializationClass">
    ///    The initialization class. The initialization class is a different class for each transaction that
    ///    calculates withhold tax.
    /// </param>
    public void init(Object _initializationClass)
    {
        if ((!this.useTaxWithHoldUncommitted()) && (this.useSubLedgerJournalLines()))
        {
            throw error("@SYS95118");
        }

        // this.useTaxWithholdUncommitted() returns true if the transaction supports the
        // use of TaxUncommitted.  The variable useTaxWithholdUncommitted indicates that on
        // this particular call, does the transaction want withhold tax to use TaxWithholdUncommitted.
        useTaxWithholdUncommitted = useTaxWithholdUncommitted && this.useTaxWithHoldUncommitted();
        if (useTaxWithholdUncommitted && loadTaxWithholdUncommitted)
        {
            this.loadFromTaxWithholdUncommitted();
        }

        calcPostedUncalculatedTransMap = new Map(Types::Int64, Types::Enum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initGrossAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the gross amount.
    /// </summary>
    protected void initGrossAmount()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntoTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates record in <c>TaxWithholdTrans_IN</c> table.
    /// </summary>
    /// <param name = "_taxWithholdTable">
    ///     A <c>TaxWithholdTable</c> table buffer.
    /// </param>
    /// <param name = "_taxWithholdData">
    ///     Withholding tax data.
    /// </param>
    /// <param name = "_insertTaxWithold">
    ///     Inserted tax witholding data.
    /// </param>
    /// <param name = "_overLookThreshold">
    ///     A boolean value for overlook threshold.
    /// </param>
    /// <param name = "_exceptionalThreshold">
    ///     A boolean value for exceptional threshold.
    /// </param>
    /// <param name = "_accountType">
    ///     The account type.
    /// </param>
    /// <param name = "_offsetAccountType">
    ///     The offset account type.
    /// </param>
    /// <returns>
    ///     A <c>TaxWithholdTrans_IN</c> table buffer.
    /// </returns>
    protected TaxWithholdTrans_IN insertIntoTaxTrans(TaxWithholdTable        _taxWithholdTable,
                                                   container               _taxWithholdData,
                                                   container               _insertTaxWithold,
                                                   boolean                 _overLookThreshold,
                                                   boolean                 _exceptionalThreshold,
                                                   LedgerJournalACType     _accountType = LedgerJournalACType::Cust,
                                                   LedgerJournalACType     _offsetAccountType = LedgerJournalACType::Cust)

    {
        TaxWithholdTrans_IN     taxWithholdTrans;
        VendTable               vendTableLoc;
        CustTable               custTableLoc;
        TaxWithholdType_IN      taxWithholdType;
        SpecTrans               specTransLoc;
        container               custVendInfo;
        #define.13(13)
        #define.19(19)
        LedgerJournalTrans      ledgerJournalTransLoc;
        TaxInformationCustTable_IN      taxInformationCustTableLoc;
        TaxInformationVendTable_IN      taxInformationVendTableLoc;

        sourceDocumentTaxLine += 1;
        taxWithholdType = _taxWithholdTable.TaxType_IN == TaxWithholdCodeType_IN::TDS ? TaxWithholdType_IN::TDS : TaxWithholdType_IN::TCS;
        ttsbegin;
    // Overview
        taxWithholdTrans.Exempt                     = conPeek(_insertTaxWithold, #18);
        taxWithholdTrans.Voucher                    = conPeek(_taxWithholdData, #10);
        taxWithholdTrans.TransDate                  = conPeek(_insertTaxWithold, #1);
        taxWithholdTrans.Source                     = conPeek(_taxWithholdData, #6);
        if (taxWithholdTrans.Exempt)
        {
            taxWithholdTrans.TaxWithholdValue       = 0;
        }
        else
        {
            taxWithholdTrans.TaxWithholdValue       = conPeek(_insertTaxWithold, #2);
        }
        taxWithholdTrans.TaxWithholdCode            = _taxWithholdTable.TaxWithholdCode;
        taxWithholdTrans.CurrencyCode               = conPeek(_taxWithholdData, #4);
        taxWithholdTrans.TaxWithholdBaseAmountCur   = conPeek(_insertTaxWithold, #3);
        taxWithholdTrans.TaxWithholdAmountCur       = conPeek(_insertTaxWithold, #4);
        taxWithholdTrans.AdjustedBaseAmount         = conPeek(_insertTaxWithold, #13);
        taxWithholdTrans.AdjustedTaxWithholdAmount  = conPeek(_insertTaxWithold, #14);

    // Payment Company Information
        if ((conPeek(_taxWithholdData, #14) == SettlementType::SelectedTransact) && (companyId != paymcompanyId || paymcompanyId == curext()))
        {
            select firstonly specTransLoc
                where specTransLoc.RefRecId     == specRefRecId
                   && specTransLoc.RefCompany   == companyId;
            custVendInfo = TaxWithholdCalculation_IN::getVendorInformation(specTransLoc);
            taxWithholdTrans.PaymAccount            = paymentAccount;
            taxWithholdTrans.PaymCompany            = paymcompanyId;
            taxWithholdTrans.InvoiceVoucher         = invoiceVoucher;
            taxWithholdTrans.SettlementVoucher      = conPeek(_taxWithholdData, #10);
            taxWithholdTrans.CustVendTransInvoiceId = conPeek(custVendInfo, 8);
        }

        if ((conPeek(_taxWithholdData, #14) != SettlementType::SelectedTransact) && (companyId != paymcompanyId))
        {
            select  ForeignVoucher from ledgerJournalTransLoc
                where ledgerJournalTransLoc.Voucher == taxWithholdTrans.Voucher;
            taxWithholdTrans.SettlementVoucher      = ledgerJournalTransLoc.ForeignVoucher;
            taxWithholdTrans.PaymAccount            = paymentAccount;
            taxWithholdTrans.PaymCompany            = paymcompanyId;
        }

        if ((conPeek(_taxWithholdData, #14) != SettlementType::SelectedTransact))
        {
            taxWithholdTrans.Posted          = NoYes::Yes;
        }

    // Genaral
        taxWithholdTrans.PaymCompany                = paymcompanyId;

        taxWithholdTrans.TaxWithholdGroup           = conPeek(_insertTaxWithold, #5);

        taxWithholdTrans.LedgerDimension            = _taxWithholdTable.LedgerDimension;

    //Amount
    // Company's currency
        taxWithholdTrans.WithholdBaseAmount         = CurrencyExchangeHelper::mstAmount(taxWithholdTrans.TaxWithholdBaseAmountCur, taxWithholdTrans.CurrencyCode, taxWithholdTrans.TransDate, conPeek(_taxWithholdData, 3), conPeek(_taxWithholdData, 1), conPeek(_taxWithholdData, 2));
        if (!taxWithholdTrans.AdjustedTaxWithholdAmount)
        {
            taxWithholdTrans.TaxWithholdAmount          = CurrencyExchangeHelper::mstAmount(taxWithholdTrans.TaxWithholdAmountCur, taxWithholdTrans.CurrencyCode, taxWithholdTrans.TransDate, conPeek(_taxWithholdData, 3), conPeek(_taxWithholdData, 1), conPeek(_taxWithholdData, 2));
        }
        else
        {
            taxWithholdTrans.TaxWithholdAmount          = CurrencyExchangeHelper::mstAmount(taxWithholdTrans.AdjustedTaxWithholdAmount, taxWithholdTrans.CurrencyCode, taxWithholdTrans.TransDate, conPeek(_taxWithholdData, 3), conPeek(_taxWithholdData, 1), conPeek(_taxWithholdData, 2));
        }

    //TaxWithhold currency
        taxWithholdTrans.TaxWithholdCurrency        = _taxWithholdTable.CurrencyCode;
        taxWithholdTrans.TaxWithholdAmountOrigin    = CurrencyExchangeHelper::curAmount(taxWithholdTrans.WithholdBaseAmount, taxWithholdTrans.TaxWithholdCurrency, taxWithholdTrans.TransDate);
        taxWithholdTrans.TaxTaxWithholdAmount       = CurrencyExchangeHelper::curAmount(taxWithholdTrans.TaxWithholdAmount, taxWithholdTrans.TaxWithholdCurrency, taxWithholdTrans.TransDate);

    //others
        if (taxWithholdTrans.Source == TaxModuleType::PurchInvoice)
        {
            taxWithholdTrans.VendAccount = conPeek(_insertTaxWithold, #6);
            vendTableLoc                    = VendTable::find(taxWithholdTrans.VendAccount);
        }
        else if (taxWithholdTrans.Source == TaxModuleType::SalesInvoice || taxWithholdTrans.Source == TaxModuleType::FreeTxtInvoice)
        {
            taxWithholdTrans.CustAccount = conPeek(_insertTaxWithold, #6);
            custTableLoc                    = CustTable::find(taxWithholdTrans.CustAccount);
        }
        else
        {
            if ((_accountType   == LedgerJournalACType::Cust         && _offsetAccountType == LedgerJournalACType::Ledger)
                ||(_accountType == LedgerJournalACType::Ledger       && _offsetAccountType == LedgerJournalACType::Cust)
                ||(_accountType == LedgerJournalACType::Cust         && _offsetAccountType == LedgerJournalACType::Bank)
                ||(_accountType == LedgerJournalACType::Bank         && _offsetAccountType == LedgerJournalACType::Cust)
                ||(_accountType == LedgerJournalACType::FixedAssets  && _offsetAccountType == LedgerJournalACType::Cust)
                ||(_accountType == LedgerJournalACType::Cust         && _offsetAccountType == LedgerJournalACType::FixedAssets))
            {
                taxWithholdTrans.CustAccount    =  conPeek(_insertTaxWithold, #6);
                 custTableLoc                   = CustTable::find(taxWithholdTrans.CustAccount);
            }

            if ((_accountType   == LedgerJournalACType::Vend         && _offsetAccountType == LedgerJournalACType::Ledger)
                ||(_accountType == LedgerJournalACType::Ledger       && _offsetAccountType == LedgerJournalACType::Vend)
                ||(_accountType == LedgerJournalACType::Bank         && _offsetAccountType == LedgerJournalACType::Vend)
                ||(_accountType == LedgerJournalACType::Vend         && _offsetAccountType == LedgerJournalACType::Bank)
                ||(_accountType == LedgerJournalACType::FixedAssets  && _offsetAccountType == LedgerJournalACType::Vend)
                ||(_accountType == LedgerJournalACType::Vend         && _offsetAccountType == LedgerJournalACType::FixedAssets))
            {
                taxWithholdTrans.VendAccount = conPeek(_insertTaxWithold, #6);
                vendTableLoc                    = VendTable::find(taxWithholdTrans.VendAccount);
            }

            if ((_accountType   == LedgerJournalACType::Bank    &&  _offsetAccountType == LedgerJournalACType::Ledger && conPeek(_insertTaxWithold, #8) != 0)
                ||(_accountType == LedgerJournalACType::Ledger  &&  _offsetAccountType == LedgerJournalACType::Bank   && conPeek(_insertTaxWithold, #9) != 0)
                ||(_accountType == LedgerJournalACType::Bank    &&  _offsetAccountType == LedgerJournalACType::Ledger && conPeek(_insertTaxWithold, #9) != 0)
                ||(_accountType == LedgerJournalACType::Ledger  &&  _offsetAccountType == LedgerJournalACType::Bank   && conPeek(_insertTaxWithold, #8) != 0))
            {
                taxWithholdTrans.AccountId = conPeek(_insertTaxWithold, #6);
            }
        }
        taxWithholdTrans.Invoice                    = conPeek(_taxWithholdData, #11);
        taxWithholdTrans.TaxType                    = _taxWithholdTable.TaxType_IN;
        taxWithholdTrans.TaxWithholdComponent       = _taxWithholdTable.TaxWithholdComponent_IN;
        taxWithholdTrans.TaxWithholdComponentGroup  = TaxWithholdComponentTable_IN::find(_taxWithholdTable.TaxWithholdComponent_IN).TaxWithholdComponentGroup;

        if (conPeek(_taxWithholdData, #14) == SettlementType::SelectedTransact)
        {
            taxWithholdTrans.AmountOriginMST = conPeek(_insertTaxWithold, #7);
        }
        else
        {
            taxWithholdTrans.AmountOriginMST       = CurrencyExchangeHelper::mstAmount(conPeek(_insertTaxWithold, 7), taxWithholdTrans.CurrencyCode, taxWithholdTrans.TransDate, conPeek(_taxWithholdData, 3), conPeek(_taxWithholdData, 1), conPeek(_taxWithholdData, 2));
        }

        taxWithholdTrans.OverlookThreshold      = _overLookThreshold;

        if (_exceptionalThreshold)
        {
            taxWithholdTrans.OverlookThreshold  = _exceptionalThreshold;
        }

        if (conPeek(_insertTaxWithold, #4) != 0 || conPeek(_insertTaxWithold, #14))
        {
            taxWithholdTrans.TaxWithholdCalculated = NoYes::Yes;
        }

        if (conPeek(_insertTaxWithold, #17))
        {
            taxWithholdTrans.RateOfDeduction        = this.rateOfDeduction(taxWithholdTrans.TaxWithholdGroup,
                                                                           conPeek(_insertTaxWithold, #17),
                                                                           taxWithholdTrans.VendAccount,
                                                                           true);
        }
        else
        {
            taxWithholdTrans.RateOfDeduction        = this.rateOfDeduction(taxWithholdTrans.TaxWithholdGroup,
                                                                           conPeek(_insertTaxWithold, #1),
                                                                           taxWithholdTrans.VendAccount,
                                                                           true);
        }
        taxWithholdTrans.LineNum                        = conPeek(_taxWithholdData, #12);
        taxWithholdTrans.PurchId                        = conPeek(_insertTaxWithold, #10);
        taxWithholdTrans.SalesId                        = conPeek(_insertTaxWithold, #11);
        taxWithholdTrans.JournalNum                     = conPeek(_insertTaxWithold, #12);
        taxWithholdTrans.AdvancePayment                 = conPeek(_insertTaxWithold, #15);
        TransTaxInformation transTaxInformation;
        transTaxInformation                             = TransTaxInformationHelper::findOrCreateTransTaxInformation(conpeek(_taxWithholdData, #8), conpeek(_taxWithholdData, #9));
        taxWithholdTrans.TaxWithholdRegNumber           = transTaxInformation.TaxWithholdTAN;
        if (!taxWithholdTrans.TaxWithholdRegNumber && transTaxInformation.TaxInformation)
        {
            taxWithholdTrans.TaxWithholdRegNumber       = TaxInformation_IN::find(transTaxInformation.TaxInformation).TAN;
        }
        taxWithholdTrans.TaxWithholdSettlementPeriod    = _taxWithholdTable.TaxWithholdSettlementPeriod_IN;
        taxWithholdTrans.RecoverableAccount             = conPeek(_insertTaxWithold, #16);
        if (taxWithholdTrans.RecoverableAccount)
        {
            taxWithholdTrans.LedgerDimensionReceivableAccount = _taxWithholdTable.LedgerDimension_IN;
            taxWithholdTrans.LedgerDimension            = _taxWithholdTable.LedgerDimension_IN;
        }
        taxWithholdTrans.NatureOfAssessee                   = conPeek(_taxWithholdData, #16);
        taxWithholdTrans.InventRefId                        = conPeek(_taxWithholdData, #18);
        taxWithholdTrans.ReturnVoucher                      = conPeek(_taxWithholdData, #19);
        taxWithholdTrans.ReturnLineNum                      = conPeek(_taxWithholdData, #20);
        taxWithholdTrans.VendInvoiceInternalDefaultGroup    = conPeek(_taxWithholdData, #22);

        taxWithholdTrans.ComponentStatus        = TaxWithholdComponentGroupTable_IN::find(
                                                                        TaxWithholdComponentTable_IN::find(
                                                                                    _taxWithholdTable.TaxWithholdComponent_IN).TaxWithholdComponentGroup).Status;
        if (vendTableLoc)
        {
            taxInformationVendTableLoc          = vendTableLoc.getTaxInformationVendTable_IN();
            if (taxInformationVendTableLoc)
            {
                taxWithholdTrans.pan                = taxInformationVendTableLoc.panNumber;
                taxWithholdTrans.panReferenceNumber = taxInformationVendTableLoc.panReferenceNumber;
                taxWithholdTrans.panStatus          = taxInformationVendTableLoc.panStatus;
            }

            taxWithholdTrans.Nameofdeductee     = DirPartyTable::findRec(vendTableLoc.Party).Name;
        }
        else
        {
            taxInformationCustTableLoc          = custTableLoc.getTaxInformationCustTable_IN();
            if (taxInformationCustTableLoc)
            {
                taxWithholdTrans.pan                = taxInformationCustTableLoc.panNumber;
                taxWithholdTrans.panReferenceNumber = taxInformationCustTableLoc.panReferenceNumber;
                taxWithholdTrans.panStatus          = taxInformationCustTableLoc.PanStatus;
            }

            taxWithholdTrans.Nameofdeductee     = DirPartyTable::findRec(custTableLoc.Party).Name;
            if (conPeek(_taxWithholdData, #8) == tableNum(CustInvoiceTrans))
            {
                taxWithholdTrans.SourceDocumentLine = conPeek(sourceDocumentRecIdList, sourceDocumentTaxLine);
            }
        }
        taxWithholdTrans.CustInvoiceTrans = this.parmCustInvoiceTransRecId();
        taxWithholdTrans.insert();
        this.parmTaxWithholdTransRecId(taxWithholdTrans.RecId);
        ttscommit;
        return taxWithholdTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVendorTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether this journal is a vendor transaction.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The ledeger journal line record.</param>
    /// <returns>true if this journal is a vendor transaction; otherwise, false.</returns>
    /// <reamarks> It assume that TDS/TCS will be applied on party (customer/vendor) line only, so only check the processing line. </remarks>
    public static boolean isVendorTransaction(LedgerJournalTrans _ledgerJournalTrans)
    {
        return (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend && _ledgerJournalTrans.LedgerDimension != 0)
            || (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend && _ledgerJournalTrans.OffsetLedgerDimension != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntoTmpWorkTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts calculated withholding tax into <c>TmpTaxWithholdWorkTrans_IN</c>.
    /// </summary>
    /// <param name="_taxWithholdGroup">
    /// Given withholding tax group.
    /// </param>
    /// <param name="_taxWithholdCode">
    /// Given withholding tax code.
    /// </param>
    /// <param name="_taxWithholdValue">
    /// Withholding tax value.
    /// </param>
    /// <param name="_taxWithholdData">
    /// Withholding tax information.
    /// </param>
    /// <param name="_taxWithholdAmountOrigin">
    /// Base amount of calculating withholding tax in transaction currency.
    /// </param>
    /// <param name="_baseAmount">
    /// Base amount of calculating withholding tax in tax currency.
    /// </param>
    /// <param name="_taxWithholdAmountCur">
    /// Withholding tax amount in transaction currency.
    /// </param>
    /// <param name="_taxWithholdAmount">
    /// Withholding tax amount in tax currency.
    /// </param>
    /// <param name="_custVendInfo">
    /// Customer or vendor information.
    /// </param>
    /// <param name="_exempt">
    /// Indicates whether it is an exempt code.
    /// </param>
    /// <param name="_accountType">
    /// Given account type.
    /// </param>
    /// <param name="_offsetAccountType">
    /// Given offset account type.
    /// </param>
    /// <param name="_amountCurDebit">
    /// Debit amount of journal in transaction currency.
    /// </param>
    /// <param name="_amountCurCredit">
    /// Credit amount of journal in transaction currency.
    /// </param>
    /// <param name="_isTaxWithholdThresholdExceeded">
    /// Indicates whether accumulated transaction amount exceeds threshold (in accounting currency).
    /// </param>
    /// <param name="_transDate">
    /// Transaction date.
    /// </param>
    /// <param name="_advancePayment">
    /// Indicates whether it is vendor/customer payment with TCS.
    /// </param>
    /// <param name="_cpOrigRefRecId">
    /// The original reference record Id for centralized payment.
    /// </param>
    public void insertIntoTmpWorkTrans(
        TaxWithholdGroup    _taxWithholdGroup,
        TaxWithholdCode     _taxWithholdCode,
        TaxWithholdValue    _taxWithholdValue,
        container           _taxWithholdData,
        TaxBase             _taxWithholdAmountOrigin,
        TaxBase             _baseAmount,
        TaxAmountCur        _taxWithholdAmountCur,
        TaxAmount           _taxWithholdAmount,
        container           _custVendInfo = conNull(),
        NoYesId             _exempt = NoYes::No,
        LedgerJournalACType _accountType        = LedgerJournalACType::Cust,
        LedgerJournalACType _offsetAccountType  = LedgerJournalACType::Cust,
        AmountCur           _amountCurDebit     = 0,
        AmountCur           _amountCurCredit    = 0,
        NoYesId             _isTaxWithholdThresholdExceeded = NoYes::No,
        TransDate           _transDate                      = dateNull(),
        boolean             _advancePayment = false,
        RefRecId            _cpOrigRefRecId = 0)
    {
        Currency            currencySource;
        Currency            currencyMST;
        Currency            currencyTax;
        CurrencyCode        accountingCurrency, sourceCurrency, taxCurrency;
        TaxWithholdTable    taxWithholdTable;
        LedgerDimensionDefaultAccount   ledgerDimensionDefaultAccount;
        boolean             purchTypeCash = false;
        LedgerJournalTrans  ledgerJournalTrans;

        accountingCurrency = Ledger::accountingCurrency();
        sourceCurrency     = conPeek(_taxWithholdData, #4);
        taxWithholdTable   = TaxWithholdTable::find(_taxWithholdCode);
        taxCurrency        = taxWithholdTable.CurrencyCode;

        currencyMST    = Currency::find(accountingCurrency);

        currencySource = Currency::find(conPeek(_taxWithholdData, #4));

        currencyTax = Currency::find(taxCurrency);

        taxWithholdWorkTrans.clear();
        taxWithholdWorkTrans.TaxWithholdGroup       = _taxWithholdGroup;
        taxWithholdWorkTrans.TaxWithholdCode        = _taxWithholdCode;

        if ( conPeek(_taxWithholdData, #8) == tableNum(LedgerJournalTrans))
        {
            select firstonly RecId, OffsetLedgerDimension, LedgerDimension from ledgerJournalTrans
                where ledgerJournalTrans.RecId == conPeek(_taxWithholdData, #9);

            if (ledgerJournalTrans.RecId &&
                (MainAccount::findByLedgerDimension(ledgerJournalTrans.OffsetLedgerDimension).PostingType == LedgerPostingType::PurchCash
                    || MainAccount::findByLedgerDimension(ledgerJournalTrans.LedgerDimension).PostingType == LedgerPostingType::PurchCash))
            {
                purchTypeCash = true;
            }
        }

        if (_exempt)
        {
            taxWithholdWorkTrans.TaxWithholdValue   = 0;
        }
        else
        {
            taxWithholdWorkTrans.TaxWithholdValue   = _taxWithholdValue;
        }

        NoYesId isTaxLiabilityOnPayment = TaxWithholdGroupHeading::find(_taxWithholdGroup).TaxLiabilityOnPayment_IN;

        if (conPeek(_taxWithholdData, #6) == TaxModuleType::PurchInvoice)
        {
            if (taxWithholdTable.TaxType_IN == TaxWithholdCodeType_IN::TDS)
            {
                ledgerDimensionDefaultAccount   = taxWithholdTable.LedgerDimension;
            }
            else if (taxWithholdTable.TaxType_IN == TaxWithholdCodeType_IN::TCS)
            {
                ledgerDimensionDefaultAccount   = taxWithholdTable.LedgerDimension_IN;
            }
        }
        else if (conPeek(_taxWithholdData, #6) == TaxModuleType::SalesInvoice
            || conPeek(_taxWithholdData, #6) == TaxModuleType::FreeTxtInvoice
            || conPeek(_taxWithholdData, #6) == TaxModuleType::ProjectInvoice)
        {
            if (taxWithholdTable.TaxType_IN == TaxWithholdCodeType_IN::TCS)
            {
                if (isTaxLiabilityOnPayment)
                {
                    // Set ledger dimension of table TmpWorkTrans to interim account when Tax liability on payment is enabled
                    ledgerDimensionDefaultAccount = taxWithholdTable.InterimAccount_IN;
                }
                else
                {
                    ledgerDimensionDefaultAccount = taxWithholdTable.LedgerDimension;
                }
            }
            else if (taxWithholdTable.TaxType_IN == TaxWithholdCodeType_IN::TDS)
            {
                ledgerDimensionDefaultAccount   = taxWithholdTable.LedgerDimension_IN;
            }
        }
        else if (conPeek(_taxWithholdData, #6) == TaxModuleType::Voucher
            || conPeek(_taxWithholdData, #6) == TaxModuleType::Project)
        {
            if (taxWithholdTable.TaxType_IN == TaxWithholdCodeType_IN::TDS)
            {
                ledgerDimensionDefaultAccount       = TaxWithholdCalculation_IN::tdsAccount(_accountType,
                                                                                            _offsetAccountType,
                                                                                            _amountCurDebit,
                                                                                            _amountCurCredit,
                                                                                            taxWithholdTable,
                                                                                            false,
                                                                                            LedgerJournalType::Approval,
                                                                                            purchTypeCash);
            }
            else if (taxWithholdTable.TaxType_IN == TaxWithholdCodeType_IN::TCS)
            {
                ledgerDimensionDefaultAccount       = TaxWithholdCalculation_IN::tcsAccount(_accountType,
                                                                                            _offsetAccountType,
                                                                                            _amountCurDebit,
                                                                                            _amountCurCredit,
                                                                                            taxWithholdTable);

                // Set ledger dimension of table TmpWorkTrans to interim account for customer invoice when Tax liability on payment is enabled
                if (ledgerDimensionDefaultAccount
                    && isTaxLiabilityOnPayment
                    && !LedgerJournalTrans::isCustomerPaymentByAccounts(ledgerJournalTrans)
                    && !TaxWithholdCalculation_IN::isVendorTransaction(ledgerJournalTrans))
                {
                    ledgerDimensionDefaultAccount = taxWithholdTable.InterimAccount_IN;
                }
            }
        }

        taxWithholdWorkTrans.LedgerDimensionDefaultAccount  = ledgerDimensionDefaultAccount;
        taxWithholdWorkTrans.SourceTableId          = conPeek(_taxWithholdData, #8);
        taxWithholdWorkTrans.SourceRecId            = conPeek(_taxWithholdData, #9);
        taxWithholdWorkTrans.HeadingTableId         = conPeek(_taxWithholdData, 22);
        taxWithholdWorkTrans.HeadingRecId           = conPeek(_taxWithholdData, 23);
        taxWithholdWorkTrans.CPOrigInvoiceRefRecId  = _cpOrigRefRecId;

        SalesLine               salesLine;
        ReturnDispositionCode   returnDispositionCode;

        select firstonly DispositionAction from returnDispositionCode
            join RecId from salesLine
                where salesLine.RecId == conPeek(_taxWithholdData, #9)
                    && salesLine.ReturnDispositionCodeId == returnDispositionCode.DispositionCodeId;

        if (returnDispositionCode.DispositionAction != DispositionAction::ReturnToCust)
        {
            taxWithholdWorkTrans.RateOfDeduction        = tmpRateOfDeduction;
        }

        taxWithholdWorkTrans.AccountNumber              = conPeek(_custVendInfo, #7);
        taxWithholdWorkTrans.CompanyAccount             = conPeek(_custVendInfo, #6);
        taxWithholdWorkTrans.TaxWithholdType            = conPeek(_custVendInfo, #3);
        taxWithholdWorkTrans.ExemptTax                  = _exempt;
        taxWithholdWorkTrans.CalculationDate            = _transDate;
        taxWithholdWorkTrans.Source                     = conPeek(_taxWithholdData, #6);
        taxWithholdWorkTrans.TaxAmount                  = _taxWithholdAmount;
        taxWithholdWorkTrans.TaxAmountCur               = currencyTax.amount_Instance(taxWithholdWorkTrans.TaxAmount);
        taxWithholdWorkTrans.TaxBaseAmount              = currencyMST.amount_Instance(_baseAmount);
        taxWithholdWorkTrans.TaxBaseAmountRaw           = _baseAmount;
        taxWithholdWorkTrans.TaxBaseAmountCur           = currencyTax.amount_Instance(taxWithholdWorkTrans.TaxBaseAmount);
        taxWithholdWorkTrans.SourceBaseAmountCur        = currencyMST.amount_Instance(_taxWithholdAmountOrigin);
        taxWithholdWorkTrans.SourceBaseAmountCurCalculated = currencyMST.amount_Instance(_taxWithholdAmountOrigin);
        taxWithholdWorkTrans.SourceBaseAmountCurRaw     = _taxWithholdAmountOrigin;
        taxWithholdWorkTrans.SourceTaxAmountCur         = _taxWithholdAmountCur;
        taxWithholdWorkTrans.SourceRegulateAmountCur    = _taxWithholdAmountCur;
        taxWithholdWorkTrans.SourceTaxAmountCurReal     = _taxWithholdAmountCur;
        taxWithholdWorkTrans.SourceCurrencyCode         = conPeek(_taxWithholdData, #4);
        taxWithholdWorkTrans.TaxCurrencyCode            = TaxWithholdTable::find(_taxWithholdCode).CurrencyCode;
        taxWithholdWorkTrans.ExchangeRate               = conPeek(_taxWithholdData, #1);
        taxWithholdWorkTrans.ExchRateSecond             = conPeek(_taxWithholdData, #2);
        taxWithholdWorkTrans.TaxAutogenerated           = NoYes::Yes;
        taxWithholdWorkTrans.TaxBaseQty                 = conPeek(_taxWithholdData, 21);
        taxWithholdWorkTrans.Voucher                    = conPeek(_taxWithholdData, #10);
        taxWithholdWorkTrans.IsTaxCalculated            = _isTaxWithholdThresholdExceeded;
        taxWithholdWorkTrans.TaxWithholdType            = TaxWithhold_IN::TaxWithholdCodeType2TaxWithholdType(taxWithholdTable.TaxType_IN);
        taxWithholdWorkTrans.InvoiceId                  = conPeek(_taxWithholdData, 11);
        // This field is required for threshold validation, grossAmount is stored in this field
        taxWithholdWorkTrans.AmountOriginMST            = CurrencyExchangeHelper::amountCur2MST(curTransWHTNotCalculatedBaseCur, taxWithholdWorkTrans.SourceCurrencyCode, taxWithholdWorkTrans.ExchangeRate, _transDate);
        taxWithholdWorkTrans.AdvancePayment             = _advancePayment;
        taxWithholdWorkTrans.TaxApplicability           = TaxWithholdGroupHeading::find(taxWithholdWorkTrans.TaxWithholdGroup).TaxApplicability_IN;
        taxWithholdWorkTrans.AcknowledgermentNumber     = conPeek(_taxWithholdData, 24);
        taxWithholdWorkTrans.CountryRegionToRemittance  = conPeek(_taxWithholdData, 25);
        taxWithholdWorkTrans.NatureOfRemittance         = conPeek(_taxWithholdData, 26);
        if (isTaxLiabilityOnPayment)
        {
            taxWithholdWorkTrans.IsPartOfTurnOver = NoYes::Yes;
            if (isThresholdBasedOnPaymentOnly && this.isCustInvoiceTransaction(conPeek(_taxWithholdData, 8), conPeek(_taxWithholdData, 9)))
            {
                taxWithholdWorkTrans.IsTaxInterim = NoYes::Yes;
            }
        }

        taxWithholdWorkTrans.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreditNote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the calculation contains credit note.
    /// </summary>
    /// <param name="_line">
    /// The line information.
    /// </param>
    /// <returns>
    /// Returns true if the calculation contains credit note.
    /// </returns>
    protected boolean isCreditNote(Common _line)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSettled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether transaction has been settled.
    /// </summary>
    /// <param name="_specCompany">
    /// The spec company of the <c>SpecTrans</c> record to find.
    /// </param>
    /// <param name="_specTableId">
    /// The spec table ID of the <c>SpecTrans</c> record to find.
    /// </param>
    /// <param name="_specRecId">
    /// The spec record ID of the <c>SpecTrans</c> record to find.
    /// </param>
    /// <returns>
    /// Returns true if transaction has been settled; Otherwise, returns false.
    /// </returns>
    public boolean isSettled(CompanyId _specCompany, TableId _specTableId, RefRecId _specRecId)
    {
        if (SpecTrans::findBySpec(_specCompany, _specTableId, _specRecId))
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWHTParameterMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether corresponding withholding tax parameter is marked.
    /// </summary>
    /// <param name="_common">
    /// Transaction buffer.
    /// </param>
    /// <returns>
    /// Returns true if witholding tax parameter is marked; Otherwise, returns false.
    /// </returns>
    protected boolean isWHTParameterMarked(Common _common)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadFromTaxWithholdUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads tax records from the <c>TaxWithholdUncommitted_IN</c> table into the <c>TmpTaxWithholdWorkTrans_IN</c> table.
    /// </summary>
    protected void loadFromTaxWithholdUncommitted()
    {
        taxWithholdWorkTrans.loadFromTaxUncommitted(headingTableId, headingRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustInvoiceTransRecId</Name>
				<Source><![CDATA[
    public RefRecId parmCustInvoiceTransRecId(RefRecId _custInvoiceTransRecid = custInvoiceTransRecid)
    {
        custInvoiceTransRecid = _custInvoiceTransRecid;

        return custInvoiceTransRecid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHeadingRecID</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the RecID of the Header table.
    /// </summary>
    /// <param name="_headingRecId">
    /// The new value of the RecID of the Header table; optional.
    /// </param>
    /// <returns>
    ///  The current value of RecID of the Header table
    /// </returns>
    public RefRecId parmHeadingRecID(RefRecId _headingRecId = headingRecId)
    {
        headingRecId = _headingRecId;

        return headingRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHeadingTableID</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the Table ID of the Header table.
    /// </summary>
    /// <param name="_headingTableId">
    /// The new value of the Table ID of the Header table; optional.
    /// </param>
    /// <returns>
    ///  The current value of Table ID of the Header table
    /// </returns>
    public RefTableId parmHeadingTableID(RefTableId _headingTableId = headingTableId)
    {
        headingTableId = _headingTableId;

        return headingTableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvoiceLineRecID</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the RecID of the Invoice line table.
    /// </summary>
    /// <param name="_invoiceRecId">
    /// The new value of the RecID of the Invoice line table; optional.
    /// </param>
    /// <returns>
    ///  The current value of RecID of the Invoice line table
    /// </returns>
    public RefRecId parmInvoiceLineRecID(RefRecId _invoiceRecId = invoiceRecId)
    {
        invoiceRecId = _invoiceRecId;

        return invoiceRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRateOfDeduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the RateOfDeduction value.
    /// </summary>
    /// <param name="_tmpRateOfDeduction">
    /// The RateOfDeduction value.
    /// </param>
    /// <returns>
    /// the RateOfDeduction value.
    /// </returns>
    public real parmRateOfDeduction(real _tmpRateOfDeduction = tmpRateOfDeduction)
    {
        tmpRateOfDeduction = _tmpRateOfDeduction;

        return tmpRateOfDeduction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxModuleType</Name>
				<Source><![CDATA[
    public TaxModuleType parmTaxModuleType(TaxModuleType _taxModuleType = taxModuleType)
    {
        taxModuleType = _taxModuleType;
        return taxModuleType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxWithholdTransRecId</Name>
				<Source><![CDATA[
    public RefRecId parmTaxWithholdTransRecId(RefRecId _taxWithholdTransRecId = taxWithholdTransRecId)
    {
        taxWithholdTransRecId = _taxWithholdTransRecId;

        return taxWithholdTransRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTmpTaxWithholdWorkTrans</Name>
				<Source><![CDATA[
    public TmpTaxWithholdWorkTrans_IN parmTmpTaxWithholdWorkTrans(TmpTaxWithholdWorkTrans_IN _tmpTaxWithholdWorkTrans = taxWithholdWorkTrans)
    {
        taxWithholdWorkTrans = _tmpTaxWithholdWorkTrans;
        return taxWithholdWorkTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTmpTransLineWithholdGrossAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the RecID of the tmpTransLineWithholdGrossAmount.
    /// </summary>
    /// <param name="_tmpTransLineWithholdGrossAmount">
    /// The new value of the tmpTransLineWithholdGrossAmount ; optional.
    /// </param>
    /// <returns>
    /// Returns current value of tmpTransLineWithholdGrossAmount.
    /// </returns>
    public TmpTransLineWithholdGrossAmount_IN parmTmpTransLineWithholdGrossAmount(TmpTransLineWithholdGrossAmount_IN _tmpTransLineWithholdGrossAmount = tmpTransLineWithholdGrossAmount)
    {
        tmpTransLineWithholdGrossAmount = _tmpTransLineWithholdGrossAmount;
        return tmpTransLineWithholdGrossAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or Sets <c>Voucher</c>
    /// </summary>
    /// <param name="_voucher">
    /// <c>Voucher</c>
    /// </param>
    /// <returns>
    /// <c>Voucher</c>
    /// </returns>
    public Voucher parmVoucher(Voucher _voucher = voucher)
    {
        voucher = _voucher;
        return voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>rateOfDeduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the witholding tax rate for specified withholding tax group and transaction date.
    /// </summary>
    /// <param name="_taxWithholdGroup">
    /// Witholding tax group.
    /// </param>
    /// <param name="_invoiceDate">
    /// Transaction date.
    /// </param>
    /// <param name="_accountNum">
    /// Customer or vendor account number.
    /// </param>
    /// <param name="_isVendTransaction">
    /// Indicates whether transaction is for vendor.
    /// </param>
    /// <param name="_curTransLineAmountMST">
    /// Indicates amount of current transaction line
    /// </param>
    /// <returns>
    /// Returns the calculated withholding tax rate.
    /// </returns>
    public real rateOfDeduction(TaxWithholdGroup    _taxWithholdGroup,
                                TransDate           _invoiceDate,
                                AccountNum          _accountNum = '',
                                boolean             _isVendTransaction = false,
                                AmountMST           _curTransLineAmountMST = 0)
    {
        return this.rateOfDeductionForThresholdBasedOnPaym(_taxWithholdGroup, _invoiceDate, _accountNum, _isVendTransaction);
    }

]]></Source>
			</Method>
			<Method>
				<Name>rateOfDeductionForThresholdBasedOnPaym</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the witholding tax rate for specified withholding tax group and transaction date when threshold is based on payment only.
    /// </summary>
    /// <param name = "_taxWithholdGroup">Witholding tax group.</param>
    /// <param name = "_invoiceDate">Transaction date.</param>
    /// <param name = "_accountNum">Customer or vendor account number.</param>
    /// <param name = "_isVendTransaction">Indicates whether transaction is for vendor.</param>
    /// <param name = "_curTransLineAmountMST">Indicates amount of current transaction line</param>
    /// <param name = "_sourceTable">The current transaction line table id.</param>
    /// <param name = "_sourceRecId">The current transaction line record id.</param>
    /// <returns>The calculated withholding tax rate.</returns>
    internal real rateOfDeductionForThresholdBasedOnPaym(
        TaxWithholdGroup _taxWithholdGroup,
        TransDate _invoiceDate,
        AccountNum _accountNum = '',
        boolean _isVendTransaction = false,
        AmountMST _curTransLineAmountMST = 0,
        RefTableId _sourceTable = 0,
        RefRecId _sourceRecId = 0)
    {
        int                             checkTaxCode;
        str                             formula, chargeName;
        real                            totalTDS, taxWithholdValue, taxWithholdAmount, resultStr;
        container                       totalTDSAmount, taxcode;
        Counter                         countI, countJ = 1, countK = 1;
        TaxWithholdDesignerTable_IN     taxWithholdDesignerTable;
        ExecutePermission               permission;
        TaxWithholdGroupData            taxWithholdGroupDataLoc;
        real                            previousLineTaxWithHoldAmt;
        Map                             taxWithholdCodeTaxValudeMap;
        #Operator_IN
        #define.Zero('0')

        permission = new ExecutePermission();
        permission.assert();
        taxcode             = conNull();
        totalTDSAmount      = conNull();
        countI              = 0;

        taxWithholdCodeTaxValudeMap             = new Map(Types::String, Types::Real);
        this.setTaxValueDataMaps(_taxWithholdGroup, _invoiceDate, _accountNum, _isVendTransaction, _curTransLineAmountMST, taxWithholdCodeTaxValudeMap, _sourceTable, _sourceRecId);

        while select taxWithholdDesignerTable order by id
            where taxWithholdDesignerTable.TaxWithholdGroup == _taxWithholdGroup
        {
            countI++;
            taxWithholdAmount       = 0;
            taxWithholdValue        = 0;

            if (taxWithholdCodeTaxValudeMap.exists(taxWithholdDesignerTable.TaxWithholdCode))
            {
                taxWithholdValue = taxWithholdCodeTaxValudeMap.lookup(taxWithholdDesignerTable.TaxWithholdCode);
            }

            select TaxWithholdCode, TaxWithholdGroup, Exempt_IN from taxWithholdGroupDataLoc
                where taxWithholdGroupDataLoc.TaxWithholdCode   == taxWithholdDesignerTable.TaxWithholdCode
                   && taxWithholdGroupDataLoc.TaxWithholdGroup  == _taxWithholdGroup;

            switch (taxWithholdDesignerTable.Basis)
            {
                case TaxWithholdBasis_IN::GrossAmount:
                    if (taxWithholdGroupDataLoc.Exempt_IN)
                    {
                        formula = #Zero;
                    }
                    else
                    {
                        formula     = enum2str(taxWithholdDesignerTable.Basis) + taxWithholdDesignerTable.Expression;
                        chargeName  = "@SYS11818";

                        formula     = this.calculateAmount(formula, taxWithholdValue, chargeName);
                        for (countJ = 1; countJ <= conLen(taxcode); countJ++)
                        {
                            checkTaxCode = strScan(formula, strFmt("[%1]", conPeek(taxcode, countJ)), 1, strLen(formula));
                            if (checkTaxCode)
                            {
                                chargeName      = conPeek(taxcode, countJ);
                                previousLineTaxWithHoldAmt = conPeek(totalTDSAmount, countJ);
                                formula         = this.calculateAmount(formula, previousLineTaxWithHoldAmt, chargeName, num2char(#nintyOne), num2char(#nintyThree));
                            }
                        }
                    }
                    break;

                case TaxWithholdBasis_IN::ExclGrossAmount:
                    if (taxWithholdGroupDataLoc.Exempt_IN)
                    {
                        formula = #Zero;
                    }
                    else
                    {
                        formula     = strDel(taxWithholdDesignerTable.Expression,1,1);
                        for (countJ = 1; countJ <= conLen(taxcode); countJ++)
                        {
                            checkTaxCode = strScan(formula, strFmt("[%1]", conPeek(taxcode, countJ)), 1, strLen(formula));
                            if (checkTaxCode)
                            {
                                chargeName      = conPeek(taxcode, countJ);
                                previousLineTaxWithHoldAmt = conPeek(totalTDSAmount, countJ);
                                formula         = this.calculateAmount(formula, previousLineTaxWithHoldAmt, chargeName, num2char(#nintyOne), num2char(#nintyThree));
                            }
                        }
                    }
                    if (formula)
                    {
                        formula = strFmt("%1 %2 %3 %4 %5",num2char(#fourZero),formula,num2char(#fourOne), num2char(#fourTwo), num2str(taxWithholdValue, #8, #5, 1, 1));
                    }
                    break;

                default:
                    break;
            }

            if (formula)
            {
                // Input to evalbuf has been validated
                // Only limited safe elements are allowed
                resultStr = TaxWithholdCalculation_IN::evaluate(formula);
            }
            else
            {
                resultStr = 0;
            }

            taxWithholdAmount = taxWithholdDesignerTable.Basis == TaxWithholdBasis_IN::ExclGrossAmount ?
                                                                  resultStr/100 : resultStr;

            totalTDSAmount        = conPoke(totalTDSAmount, countI, taxWithholdAmount);
            taxcode               = conPoke(taxcode, countI, taxWithholdDesignerTable.TaxWithholdCode);
        }

        for (countK = 1; countK <= conLen(totalTDSAmount); countK++)
        {
            totalTDS += conPeek(totalTDSAmount, countK);
        }

        return totalTDS;
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundOffTaxWithholdAmount</Name>
				<Source><![CDATA[
    private AmountCur roundOffTaxWithholdAmount(AmountCur         _taxWithholdAmount,
                                                TaxWithholdTable  _taxWithholdTable)
    {
        AmountCur           taxWithholdAmount;
        TaxWithholdTable    taxWithholdTable    = _taxWithholdTable;

        if (_taxWithholdAmount)
        {
            switch (taxWithholdTable.TaxWithholdRoundOffType)
            {
                case RoundOffType::Ordinary :
                    if (taxWithholdTable.TaxWithholdRoundOff)
                    {
                        taxWithholdAmount = round(_taxWithholdAmount, taxWithholdTable.TaxWithholdRoundOff);
                    }
                    else
                    {
                        taxWithholdAmount = round(_taxWithholdAmount, 0.01);
                    }
                    break;
                case RoundOffType::RoundDown :
                    if (taxWithholdTable.TaxWithholdRoundOff)
                    {
                        if (_taxWithholdAmount >= 0)
                        {
                            taxWithholdAmount = round(_taxWithholdAmount -
                                                      taxWithholdTable.TaxWithholdRoundOff / 2,
                                                      taxWithholdTable.TaxWithholdRoundOff);
                        }
                        else
                        {
                            taxWithholdAmount = round(_taxWithholdAmount +
                                                      taxWithholdTable.TaxWithholdRoundOff / 2,
                                                      taxWithholdTable.TaxWithholdRoundOff);
                        }
                    }
                    else
                    {
                         taxWithholdAmount = trunc(_taxWithholdAmount);
                    }
                    break;
                case RoundOffType::RoundUp :
                    if (taxWithholdTable.TaxWithholdRoundOff)
                    {
                        if (_taxWithholdAmount >= 0)
                        {
                            taxWithholdAmount = round(_taxWithholdAmount +
                                                      taxWithholdTable.TaxWithholdRoundOff / 2.01,
                                                      taxWithholdTable.TaxWithholdRoundOff);
                        }
                        else
                        {
                            taxWithholdAmount = round(_taxWithholdAmount -
                                                      taxWithholdTable.TaxWithholdRoundOff / 2.01,
                                                      taxWithholdTable.TaxWithholdRoundOff);
                        }
                    }
                    else
                    {
                        if (_taxWithholdAmount >= 0)
                        {
                            taxWithholdAmount = round(_taxWithholdAmount + 0.5, 1.0);
                        }
                        else
                        {
                            taxWithholdAmount = round(_taxWithholdAmount - 0.5, 1.0);
                        }
                    }
                    break;
            }
        }
        return taxWithholdAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setExchRates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the exchange rates.
    /// </summary>
    /// <param name="_sourceCurrencyCode">
    /// The source currency code.
    /// </param>
    /// <param name="_exchRate">
    /// The exchange rate.
    /// </param>
    /// <param name="_exchRateSecond">
    /// The second exchange rate.
    /// </param>
    /// <param name="_exchRatesTriangulation">
    /// The triangulation exchange rates.
    /// </param>
    /// <param name="_exchRateDate">
    /// The exchange rate date.
    /// </param>
    void setExchRates(
        CurrencyCode            _sourceCurrencyCode     = sourceCurrencyCode,
        ExchRate                _exchRate               = exchRate,
        ExchrateSecondary       _exchRateSecond         = exchRateSecond,
        ExchRatesTriangulation  _exchRatesTriangulation = UnknownNoYes::Unknown,
        TransDate               _exchRateDate           = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        sourceCurrencyCode  = _sourceCurrencyCode;
        triangulation = Currency::unknownNoYes2Noyes(_exchRatesTriangulation, _sourceCurrencyCode, _exchRateDate);
        exchRate = _exchRate;
        exchRateSecond = _exchRateSecond;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInvoiceAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the AccountNum value.
    /// </summary>
    /// <param name="_accountNumber">
    /// The CustVendAC value.
    /// </param>
    public void setInvoiceAccount(CustVendAC   _accountNumber)
    {
        invoiceAccount = _accountNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInvoiceAndPaymentData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the invoice and payment details to class variables.
    /// </summary>
    /// <param name="_specTrans">
    /// The SpecTrans buffer.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The LedgerJournalTrans buffer.
    /// </param>
    /// <param name="_paymentCompany">
    /// The PaymentCompany Id.
    /// </param>
    public void setInvoiceAndPaymentData(SpecTrans _specTrans, LedgerJournalTrans _ledgerJournalTrans = null, CompanyId _paymentCompany = '')
    {
        container                   vendorInformation;

        vendorInformation = TaxWithholdCalculation_IN::getVendorInformation(_specTrans, _ledgerJournalTrans, _paymentCompany);
        this.setInvoiceCompany(conPeek(vendorInformation, 5));
        this.setPaymentCompany(conPeek(vendorInformation, 6));
        this.setPaymentAccount('');
        this.setInvoiceAccount(conPeek(vendorInformation, 1));
        this.setInvoiceVoucher(conPeek(vendorInformation, 7));
        this.setJournalLineCompany(_ledgerJournalTrans.Company);
        this.setSpecRefRecid(_specTrans.RefRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInvoiceCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the invoiceCompany value.
    /// </summary>
    /// <param name="_companyId">
    /// The InvoiceCompany Id.
    /// </param>
    public void setInvoiceCompany(CompanyId   _companyId = curext())
    {
         companyId = _companyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInvoiceVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the InvoiceVoucher to classVariable.
    /// </summary>
    /// <param name="_invoiceVoucher">
    /// The InvoiceVoucher value.
    /// </param>
    public void setInvoiceVoucher(Voucher   _invoiceVoucher)
    {
        invoiceVoucher = _invoiceVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setJournalLineCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the JournalLine Company.
    /// </summary>
    /// <param name="_companyId">
    /// The JournalLine CompanyId.
    /// </param>
    public void setJournalLineCompany(CompanyId   _companyId = curext())
    {
         journalLineCompany = _companyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymentAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets Payment AccountNum.
    /// </summary>
    /// <param name="_paymentAccount">
    /// The Payment Account.
    /// </param>
    public void setPaymentAccount(CustVendAC    _paymentAccount)
    {
        paymentAccount = _paymentAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymentCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the Payment CompanyId.
    /// </summary>
    /// <param name="_companyId">
    /// The Payment companyId.
    /// </param>
    public void setPaymentCompany(CompanyId   _companyId = curext())
    {
        paymcompanyId = _companyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSpecRefRecid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets SpecTrans RefRecId.
    /// </summary>
    /// <param name="_recId">
    /// The SpecTrans refRecId.
    /// </param>
    public void setSpecRefRecid(RecId   _recId)
    {
        specRefRecId = _recId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSpecTransBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets SpecTrans buffer.
    /// </summary>
    /// <param name="_specTrans">
    /// The SpecTrans buffer.
    /// </param>
    public void setSpecTransBuffer(SpecTrans   _specTrans)
    {
        specTransForCP.data(_specTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxValueDataMaps</Name>
				<Source><![CDATA[
    private void setTaxValueDataMaps(
        TaxWithholdGroup    _taxWithholdGroup,
        TransDate           _transDate,
        AccountNum          _accountNum,
        boolean             _isVendTransaction,
        AmountMST           _curTransLineAmountMST,
        Map                 _taxWithholdCodeTaxValudeMap,
        RefTableId          _sourceTableId,
        RefRecId            _sourceRecId)
    {
        TaxWithholdDesignerTable_IN     taxWithholdDesignerTable;
        TaxWithholdThresholdHandler_IN  taxWithholdThresholdHandler;
        TaxWithholdGroupData            taxWithholdGroupData;
        TaxWithholdTable                taxWithholdTable;
        TaxValueData_IN                 taxValueData;
        TaxWithholdData                 taxWithholdData;

        if (!_taxWithholdCodeTaxValudeMap.elements())
        {
            while select TaxWithholdCode from taxWithholdDesignerTable order by ID
                    where taxWithholdDesignerTable.TaxWithholdGroup == _taxWithholdGroup
            {
                select firstonly ApplyThreshold_IN from taxWithholdTable
                    where taxWithholdTable.TaxWithholdCode == taxWithholdDesignerTable.TaxWithholdCode;

                if (taxWithholdTable.ApplyThreshold_IN)
                {
                    select firstonly OverlookTax_IN from taxWithholdGroupData
                        where taxWithholdGroupData.TaxWithholdGroup == _taxWithholdGroup
                            && taxWithholdGroupData.TaxWithholdCode == taxWithholdDesignerTable.TaxWithholdCode;

                    taxWithholdThresholdHandler = this.getTaxWithholdThresholdHandler(
                        this.getAccountType(_isVendTransaction),
                        _accountNum,
                        taxWithholdDesignerTable.TaxWithholdCode,
                        taxWithholdDesignerTable.TaxWithholdGroup,
                        _transDate,
                        _curTransLineAmountMST,
                        taxWithholdGroupData.OverlookTax_IN,
                        _sourceTableId,
                        _sourceRecId);

                    taxValueData = taxWithholdThresholdHandler.getTaxValueData();
                    if (taxValueData)
                    {
                        _taxWithholdCodeTaxValudeMap.insert(taxWithholdDesignerTable.TaxWithholdCode, taxValueData.TaxValue);
                    }
                }
                else
                {
                    //taxWithholdData = TaxWithholdData::find(taxWithholdDesignerTable.TaxWithholdCode, _transDate, 0);
                    select TaxWithholdCode, TaxWithholdFromDate, TaxWithholdToDate, TaxWithholdValue from taxWithholdData
                        where taxWithholdData.TaxWithholdCode        == taxWithholdDesignerTable.TaxWithholdCode
                           && (!taxWithholdData.TaxWithholdFromDate
                           || (taxWithholdData.TaxWithholdFromDate   <= _transDate
                           && taxWithholdData.TaxWithholdToDate      >= _transDate));

                    if (taxWithholdData)
                    {
                       _taxWithholdCodeTaxValudeMap.insert(taxWithholdDesignerTable.TaxWithholdCode, taxWithholdData.getTaxWithHoldValue_IN(_accountNum, _isVendTransaction));
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxWithholdAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets total TaxWithholdAmount for a journal.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The LedgerJournalTrans buffer.
    /// </param>
    /// <param name="_account">
    /// The AccountNum.
    /// </param>
    /// <param name="_invoiceCompany">
    /// The InvoiceCompany.
    /// </param>
    /// <returns>
    /// Total TaxAmount for a journal.
    /// </returns>
    public real setTaxWithholdAmount(LedgerJournalTrans   _ledgerJournalTrans,
                                     AccountNum           _account = '',
                                     CompanyId            _invoiceCompany = curext())
    {
        TaxWithholdTrans_IN    taxWithHoldTrans;
        TaxWithholdTrans_IN    taxWithholdTransLoc;
        real                   chargeAmount;
        int                    sign = -1;

        if (!paymcompanyId)
        {
            paymcompanyId = curext();
        }

        if (_invoiceCompany != paymcompanyId)
        {
            changecompany(_invoiceCompany)
            {
                select CustAccount, VendAccount, TaxType from taxWithholdTransLoc
                    where taxWithholdTransLoc.SettlementVoucher == _ledgerJournalTrans.Voucher
                       && taxWithholdTransLoc.TransDate         == _ledgerJournalTrans.TransDate;

                if (taxWithholdTransLoc.VendAccount && taxWithholdTransLoc.TaxType == TaxWithholdCodeType_IN::TCS)
                {
                    sign = -1;
                }
                if (taxWithholdTransLoc.CustAccount)
                {
                    sign = -1;
                }

                while select TaxWithholdAmountCur, AdjustedTaxWithholdAmount from taxWithHoldTrans
                    where taxWithHoldTrans.SettlementVoucher == _ledgerJournalTrans.Voucher
                       && taxWithHoldTrans.TransDate         == _ledgerJournalTrans.TransDate
                {
                    if (taxWithHoldTrans.AdjustedTaxWithholdAmount)
                    {
                        chargeAmount += taxWithHoldTrans.AdjustedTaxWithholdAmount * sign ;
                    }
                    else
                    {
                        chargeAmount += taxWithHoldTrans.TaxWithholdAmountCur * sign;
                    }
                }
            }
        }
        else
        {
            while select TaxWithholdAmountCur, AdjustedTaxWithholdAmount from taxWithHoldTrans
                    where taxWithHoldTrans.Voucher       == _ledgerJournalTrans.Voucher
                       && taxWithHoldTrans.TransDate     == _ledgerJournalTrans.TransDate
                       && (taxWithHoldTrans.CustAccount  == _account
                       ||  taxWithHoldTrans.VendAccount  == _account)
            {
                if (taxWithHoldTrans.AdjustedTaxWithholdAmount)
                {
                    chargeAmount += taxWithHoldTrans.AdjustedTaxWithholdAmount * -1;
                }
                else
                {
                    chargeAmount += taxWithHoldTrans.TaxWithholdAmountCur * -1;
                }
            }
        }
        return chargeAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleSales</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the container with paymentAmount attached for the invoice and TaxWithholdType.
    /// </summary>
    /// <param name="_commonTable">
    /// The SalesTable buffer.
    /// </param>
    /// <returns>
    /// Container with paymentAmount and TaxWithholdType.
    /// </returns>
    public container  settleSales(Common _commonTable)
    {
        int                         countI;
        container                   paymentAmountCur, taxWithholdType;
        SpecTrans                   specTrans;
        CustTransOpen               custTransOpen;
        CustTrans                   custTrans;
        TaxWithholdTrans_IN         taxWithholdTrans;
        TaxWithholdDesignerTable_IN taxWithholdDesignerTable;

        while select SpecRecId, SpecTableId, RefRecId, RefTableId  from specTrans
            where specTrans.SpecRecId   == _commonTable.RecId
               && specTrans.SpecTableId == _commonTable.TableId
        {
            countI++;
            select  firstonly RecId, TableId, RefRecId, AccountNum, TransDate, AmountCur from custTransOpen
                where custTransOpen.RecId         == specTrans.RefRecId
                   && custTransOpen.TableId       == specTrans.RefTableId;

            select firstonly RecId, Invoice, AccountNum, TransDate, Voucher from custTrans
                where custTrans.RecId             == custTransOpen.RefRecId
                   && custTrans.AccountNum        == custTransOpen.AccountNum
                   && custTrans.TransDate         == custTransOpen.TransDate;

            if (TaxFullyReverseTCSOnDesignatedTransactionsReturnSalesFlight::instance().isEnabled())
            {
                if (_commonTable.TableId == tableNum(SalesTable))
                {
                    SalesTable salesTable = _commonTable as SalesTable;
                    if (salesTable.SettleVoucher == SettlementType::SelectedTransact)
                    {
                        CustInvoiceJour custInvoiceJour = CustInvoiceJour::findFromCustTrans(custTrans.Invoice,
                            custTrans.TransDate,
                            custTrans.AccountNum,
                            false,
                            custTrans.Voucher);

                        // Skip marked transactions from sales orders, in case TCS is not fully reversed during sales order return.
                        if (custInvoiceJour.SalesId)
                        {
                            continue;
                        }
                    }
                }
            }

            select firstonly Taxtype, AdjustedBaseAmount from taxWithholdTrans
                where taxWithholdTrans.Voucher      == custTrans.Voucher
                    && taxWithholdTrans.TransDate   == custTrans.transDate
                    && taxWithholdTrans.CustAccount == custTrans.AccountNum
                join RecId from taxWithholdDesignerTable
                    where taxWithholdDesignerTable.TaxWithholdGroup == taxWithholdTrans.TaxWithholdGroup
                        && taxWithholdDesignerTable.TaxWithholdCode == taxWithholdTrans.TaxWithholdCode
                        && taxWithholdDesignerTable.Basis           == TaxWithholdBasis_IN::GrossAmount;

            if (taxWithholdTrans)
            {
                AmountCur actualWithholdTaxBaseAmount;
                if (taxWithholdTrans.AdjustedBaseAmount != 0)
                {
                    actualWithholdTaxBaseAmount = sign(custTransOpen.AmountCur) * taxWithholdTrans.AdjustedBaseAmount;
                }
                else
                {
                    actualWithholdTaxBaseAmount = custTransOpen.AmountCur;
                }

                paymentAmountCur    = conPoke(paymentAmountCur, countI, actualWithholdTaxBaseAmount);
                taxWithholdType     = conPoke(taxWithholdType, countI, taxWithholdTrans.Taxtype);
            }

            if (!taxWithholdTrans)
            {
                paymentAmountCur    = conPoke(paymentAmountCur, countI, custTransOpen.AmountCur);
                taxWithholdType     = conPoke(taxWithholdType, countI, TaxWithholdCodeType_IN::None);
            }
        }

        return  [paymentAmountCur, taxWithholdType];
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWHTContainerData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the WHT container date.
    /// </summary>
    /// <param name="_line">
    /// The line information.
    /// </param>
    /// <param name="_grossAmount">
    /// The gross amount.
    /// </param>
    /// <returns>
    /// The WHT container data.
    /// </returns>
    public container setWHTContainerData(
        Common  _line,
        real    _grossAmount)
    {
        container                           taxWithholdData;
        LedgerJournalTrans                  ledgerJournalTransLoc;
        LedgerJournalTransTaxExtensionIN    ledgerJournalTransTaxExtensionLoc;
        PurchLine                           purchLineLoc;
        PurchLine_IN                        purchLineLoc_IN;
        PurchTable                          purchTableLoc;
        VendInvoiceInfoLine                 vendInvoiceInfoLineLoc;
        VendInvoiceInfoTable                vendInvoiceInfoTableLoc;
        CustInvoiceLine                     custInvoiceLineLoc;
        CustInvoiceTable                    custInvoiceTableLoc;
        SalesLine                           salesLineLoc;
        SalesLine_IN                        salesLineLoc_IN;
        SalesTable                          salesTableLoc;
        CurrencyCode                        currencyCodeLoc;
        TaxModuleType                       taxModuleTypeLoc;
        DimensionDefault                    dimensionDefaultLoc;
        RefTableId                          sourceTableIdLoc;
        RefRecId                            sourceRecIdLoc;
        Voucher                             voucherLoc;
        InvoiceId                           invoiceLoc;
        LineNum                             lineNumLoc;
        SettlementType                      settlementTypeLoc;
        LedgerJournalType                   ledgerJournalTypeLoc;
        LogisticsLocationRecId              companyLocationLoc;
        NatureOfAssessee_IN                 natureOfAssesseeLoc;
        TransDate                           creditNoteDate;
        PurchOrderedQty                     quantityLoc;
        Voucher                             taxWithholdVoucher;
        LineNum                             taxWithholdLineNum;
        ExchRate                            exchangeRate;
        ExchrateSecondary                   exchangeRateSecond;
        VendInvoiceInfoTableTaxExtension_IN vendInvoiceInfoTableTaxLoc;

        ProjProposalRevenue         projProposalRevenue;
        ProjProposalOnAcc           projProposalOnAcc;
        ProjProposalItem            projProposalItem;
        ProjOnAccTrans              projOnAccTrans;
        ProjRevenueTrans            projRevenueTrans;
        ProjItemTrans               projItemTrans;
        ProjItemTransTaxExtensionIN     projItemTransTaxExtensionIN;
        ProjOnAccTransTaxExtensionIN    projOnAccTransTaxExtensionIN;
        ProjRevenueTransTaxExtensionIN  projRevenueTransTaxExtensionIN;

        TaxWithholdAcknowledgementNumber_IN     acknowledgementNumber;
        TaxWithholdCountryToRemitRefRecId_IN    countryToRemittance;
        TaxWitholdNatureOfRemittanceRefRecId_IN natureOfRemittance;
        TransTaxInformation                     transTaxInformation;
        ExchRate                                tdsExchangeRate; // TT buying rate used only by TDS
        ExchrateSecondary                       tdsExchangeRateSecond; // TT buying rate used only by TDS
        EUROTriangulation                       tdsTriangulation; // TT buying rate used only by TDS

        #define.13(13)

        void setValues(CurrencyCode _currencyCode, TaxModuleType _taxModuleType, DimensionDefault _dimensionDefault,
                       RefTableId _sourceTableId, RefRecId _sourceRecId, Voucher _voucher, InvoiceId _invoiceNum, LineNum _lineNum,
                       LedgerJournalType _ledgerJournalType, SettlementType _journalType, RefRecId _companyLocation, NatureOfAssessee_IN _natureOfAssessee,
                       Voucher _taxWithholdVoucher, LineNum _taxWithholdLineNum, TransDate _creditNoteDate, Qty _quantity,
                       ExchRate _exchangeRate, ExchrateSecondary _exchRateSecond, TaxWithholdAcknowledgementNumber_IN _acknowledgementNumber = '',
                       TaxWithholdCountryToRemitRefRecId_IN _countryToRemittance = 0, TaxWitholdNatureOfRemittanceRefRecId_IN _natureOfRemittance = 0)
        {
            currencyCodeLoc         = _currencyCode;
            taxModuleTypeLoc        = _taxModuleType;
            dimensionDefaultLoc     = _dimensionDefault;
            sourceTableIdLoc        = _sourceTableId;
            sourceRecIdLoc          = _sourceRecId;
            voucherLoc              = _voucher;
            invoiceLoc              = _invoiceNum;
            lineNumLoc              = _lineNum;
            ledgerJournalTypeLoc    = _ledgerJournalType;
            settlementTypeLoc       = _journalType;
            companyLocationLoc      = _companyLocation;
            natureOfAssesseeLoc     = _natureOfAssessee;
            taxWithholdVoucher      = _taxWithholdVoucher;
            taxWithholdLineNum      = _taxWithholdLineNum;
            creditNoteDate          = _creditNoteDate;
            quantityLoc             = _quantity;
            exchangeRate            = _exchangeRate;
            exchangeRateSecond      = _exchRateSecond;
            acknowledgementNumber   = _acknowledgementNumber;
            countryToRemittance     = _countryToRemittance;
            natureOfRemittance      = _natureOfRemittance;

            tdsExchangeRate = TaxExchangeRateHelper::getTDSExchangeRate_IN(
                _currencyCode, _creditNoteDate ? _creditNoteDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

            tdsExchangeRateSecond = TaxExchangeRateHelper::getTDSExchangeRateSecond_IN(
                _currencyCode, _creditNoteDate ? _creditNoteDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

            tdsTriangulation = Currency::unknownNoYes2Noyes(
                UnknownNoYes::Unknown, _currencyCode, _creditNoteDate ? _creditNoteDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        }

        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(_line);

        switch (_line.TableId)
        {
            case tableNum(LedgerJournalTrans) :
                ledgerJournalTransLoc               = _line as LedgerJournalTrans;
                ledgerJournalTransTaxExtensionLoc   = LedgerJournalTransTaxExtensionIN::findByLedgerJournalTrans(ledgerJournalTransLoc.RecId);
                InvoiceId invoice;
                if (ledgerJournalTransLoc.AccountType == LedgerJournalACType::Cust && ledgerJournalTransLoc.OffsetAccountType == LedgerJournalACType::Bank)
                {
                    invoice = ledgerJournalTransLoc.MarkedInvoice;
                }
                else
                {
                    invoice = ledgerJournalTransLoc.Invoice;
                }

                setValues(ledgerJournalTransLoc.CurrencyCode,
                          TaxModuleType::Voucher,
                          ledgerJournalTransLoc.DefaultDimension,
                          ledgerJournalTransLoc.TableId,
                          ledgerJournalTransLoc.RecId,
                          ledgerJournalTransLoc.Voucher,
                          invoice,
                          ledgerJournalTransLoc.LineNum,
                          ledgerJournalTransLoc.ledgerJournalTable().JournalType,
                          ledgerJournalTransLoc.SettleVoucher,
                          transTaxInformation.CompanyLocation,
                          transTaxInformation.TaxWithholdNatureOfAssessee,
                          '',
                          0,
                          ledgerJournalTransLoc.TransDate,
                          0,
                          ledgerJournalTransLoc.ExchRate,
                          ledgerJournalTransLoc.ExchRateSecond,
                          transTaxInformation.TaxWithholdAcknowledgementNumber,
                          transTaxInformation.TaxWithholdCountryRegionToRemittance,
                          transTaxInformation.TaxWithholdNatureOfRemittance);
                break;

            case tableNum(PurchLine) :
                purchLineLoc        = _line as PurchLine;
                purchLineLoc_IN     = purchLineLoc.purchLine_IN();
                purchTableLoc       = purchLineLoc.purchTable();

                setValues(purchLineLoc.CurrencyCode,
                          TaxModuleType::PurchInvoice,
                          0,
                          purchLineLoc.TableId,
                          purchLineLoc.RecId,
                          '',
                          '',
                          any2real(purchLineLoc.LineNumber),
                          0,
                          0,
                          transTaxInformation.CompanyLocation,
                          purchTableLoc.purchTable_W().NatureOfAssessee_IN,
                          purchLineLoc_IN.TaxWithholdVoucher,
                          purchLineLoc_IN.TaxWithholdLineNum,
                          purchLineLoc_IN.CreditNoteDate,
                          purchLineLoc.PurchQty,
                          exchRate,
                          exchRateSecond,
                          transTaxInformation.TaxWithholdAcknowledgementNumber,
                          transTaxInformation.TaxWithholdCountryRegionToRemittance,
                          transTaxInformation.TaxWithholdNatureOfRemittance);
                break;

            case tableNum(VendInvoiceInfoLine) :
                vendInvoiceInfoLineLoc      = _line as VendInvoiceInfoLine;
                vendInvoiceInfoTableLoc     = vendInvoiceInfoLineLoc.vendInvoiceInfoTable();
                vendInvoiceInfoTableTaxLoc  = VendInvoiceInfoTableTaxExtension_IN::findByVendInvoiceInfoTableRecId(vendInvoiceInfoTableLoc.RecId);
                // Added to get the fields related to credit note. This is not applicable to non PO lines.
                purchLineLoc                = vendInvoiceInfoLineLoc.purchLine();
                purchLineLoc_IN             = purchLineLoc.purchLine_IN();

                setValues(vendInvoiceInfoLineLoc.CurrencyCode,
                          TaxModuleType::PurchInvoice,
                          0,
                          vendInvoiceInfoLineLoc.TableId,
                          vendInvoiceInfoLineLoc.RecId,
                          '',
                          '',
                          vendInvoiceInfoLineLoc.LineNum,
                          0,
                          0,
                          transTaxInformation.CompanyLocation,
                          vendInvoiceInfoTableTaxLoc.NatureOfAssessee,
                          purchLineLoc_IN.TaxWithholdVoucher,
                          purchLineLoc_IN.TaxWithholdLineNum,
                          purchLineLoc_IN.CreditNoteDate,
                          vendInvoiceInfoLineLoc.ReceiveNow,
                          exchRate,
                          exchRateSecond,
                          transTaxInformation.TaxWithholdAcknowledgementNumber,
                          transTaxInformation.TaxWithholdCountryRegionToRemittance,
                          transTaxInformation.TaxWithholdNatureOfRemittance);
                break;

            case tableNum(CustInvoiceLine) :
                custInvoiceLineLoc  = _line as CustInvoiceLine;
                custInvoiceTableLoc = custInvoiceLineLoc.custInvoiceTable();

                setValues(custInvoiceTableLoc.CurrencyCode,
                          TaxModuleType::FreeTxtInvoice,
                          0,
                          custInvoiceLineLoc.TableId,
                          custInvoiceLineLoc.RecId,
                          '',
                          '',
                          custInvoiceLineLoc.LineNum,
                          0,
                          0,
                          transTaxInformation.CompanyLocation,
                          custInvoiceTableLoc.NatureOfAssessee_IN,
                          '',
                          0,
                          dateNull(),
                          0,
                          exchRate,
                          exchRateSecond,
                          transTaxInformation.TaxWithholdAcknowledgementNumber,
                          transTaxInformation.TaxWithholdCountryRegionToRemittance,
                          transTaxInformation.TaxWithholdNatureOfRemittance);
                break;

            case tableNum(SalesLine) :
                salesLineLoc  = _line as SalesLine;
                salesLineLoc_IN = salesLineLoc.salesLine_IN();
                salesTableLoc = salesLineLoc.salesTable();

                setValues(salesTableLoc.CurrencyCode,
                          TaxModuleType::SalesInvoice,
                          0,
                          salesLineLoc.TableId,
                          salesLineLoc.RecId,
                          '',
                          '',
                          salesLineLoc.LineNum,
                          0,
                          0,
                          transTaxInformation.CompanyLocation,
                          salesTableLoc.NatureOfAssessee_IN,
                          salesLineLoc_IN.TaxWithholdVoucher,
                          salesLineLoc_IN.TaxWithholdLineNum,
                          salesLineLoc_IN.CreditNoteDate,
                          salesLineLoc.SalesQty,
                          exchRate,
                          exchRateSecond,
                          transTaxInformation.TaxWithholdAcknowledgementNumber,
                          transTaxInformation.TaxWithholdCountryRegionToRemittance,
                          transTaxInformation.TaxWithholdNatureOfRemittance);
                break;

                case tablenum(ProjProposalRevenue) :
                projProposalRevenue = _line;
                projRevenueTrans = projProposalRevenue.projRevenueTrans();
                projRevenueTransTaxExtensionIN = projRevenueTrans.projRevenueTransTaxExtensionIN();

                transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(projRevenueTrans);

                setValues(projRevenueTrans.CurrencyId,
                        TaxModuleType::ProjectInvoice,
                        0,
                        projProposalRevenue.TableId,
                        projProposalRevenue.RecId,
                        '',
                        '',
                        0,
                        0,
                        0,
                        transTaxInformation.CompanyLocation,
                        NatureOfAssessee_IN::Company,
                        projProposalRevenue.projProposalJour().LedgerVoucher,
                        0,
                        dateNull(),
                        projRevenueTrans.Qty,
                        projProposalRevenue.projProposalJour().exchRate,
                        projProposalRevenue.projProposalJour().ExchrateSecondary);

                break;

            case tablenum(projProposalItem) :
                projProposalItem = _line;
                CurrencyCode currencyCode;
                Qty qty;
                Voucher ledgerVoucher;
                LineNum taxLineNum;
                SalesLine salesLine = projProposalItem.salesLine();
                if (salesline && projProposalItem.ItemType == ProjItemType::SalesOrder)
                {
                    salesTable salesTable = salesLine.salesTable();
                    currencyCode = salesTable.CurrencyCode;
                    qty = projProposalItem.qty();
                    transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(salesLine);
                    SalesLine_IN salesLineIN = projProposalItem.salesLine().salesLine_IN();
                    ledgerVoucher = salesLineIN.TaxWithholdVoucher;
                    taxLineNum = salesLineIN.TaxWithholdLineNum;
                }
                else
                {
                    projItemTrans = projProposalItem.projItemTrans();
                    projItemTransTaxExtensionIN = projItemTrans.projItemTransTaxExtensionIN();
                    transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(projItemTrans);
                    currencyCode = projItemTrans.CurrencyId;
                    qty = projItemTrans.Qty;
                    ledgerVoucher = projProposalItem.projProposalJour().LedgerVoucher;
                }

                setValues(currencyCode,
                        TaxModuleType::ProjectInvoice,
                        0,
                        projProposalItem.TableId,
                        projProposalItem.RecId,
                        '',
                        '',
                        0,
                        0,
                        0,
                        transTaxInformation.CompanyLocation,
                        NatureOfAssessee_IN::Company,
                        ledgerVoucher,
                        taxLineNum,
                        dateNull(),
                        qty,
                        projProposalItem.projProposalJour().exchRate,
                        projProposalItem.projProposalJour().ExchrateSecondary);

                break;

            case tablenum(projProposalOnAcc) :
                projProposalOnAcc = _line;
                projOnAccTrans = projProposalOnAcc.projOnAccTrans();
                projOnAccTransTaxExtensionIN = projOnAccTrans.projOnAccTransTaxExtensionIN();

                transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(projOnAccTrans);

                setValues(projOnAccTrans.CurrencyId,
                    TaxModuleType::ProjectInvoice,
                    0,
                    projProposalOnAcc.TableId,
                    projProposalOnAcc.RecId,
                    '',
                    '',
                    0,
                    0,
                    0,
                    transTaxInformation.CompanyLocation,
                    NatureOfAssessee_IN::Company,
                    projProposalOnAcc.projProposalJour().LedgerVoucher,
                    0,
                    dateNull(),
                    projOnAccTrans.Qty,
                    projProposalOnAcc.projProposalJour().exchRate,
                    projProposalOnAcc.projProposalJour().ExchrateSecondary);

                break;

            case tableNum(ProjAdvancedJournalLine) :
                ProjAdvancedJournalLine projAdvancedJournalLine = _line;
                boolean isCreditNote = TaxProjOperationUtils::isCreditNote(projAdvancedJournalLine);
                ProjAdvancedJournalVoucher taxWithholdVoucherLoc;
                LineNum taxWithholdLineNumLoc;

                if (isCreditNote)
                {
                    ProjAdvancedJournalLine projAdvancedJournalLineOrig = TaxProjOperationUtils::getOrigProjAdvancedJournalLine(projAdvancedJournalLine);
                    taxWithholdVoucherLoc = projAdvancedJournalLineOrig.Voucher;
                    taxWithholdLineNumLoc = projAdvancedJournalLineOrig.LineNumber;
                }

                if (projAdvancedJournalLine.TransType == ProjTransType::Cost)
                {
                    transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(projAdvancedJournalLine);

                    setValues(projAdvancedJournalLine.CostCurrency,
                        TaxModuleType::Project,
                        projAdvancedJournalLine.OffsetLedgerDimension,
                        projAdvancedJournalLine.TableId,
                        projAdvancedJournalLine.RecId,
                        projAdvancedJournalLine.Voucher,
                        '',
                        projAdvancedJournalLine.LineNumber,
                        0,
                        0,
                        transTaxInformation.CompanyLocation,
                        transTaxInformation.TaxWithholdNatureOfAssessee,
                        taxWithholdVoucherLoc,
                        taxWithholdLineNumLoc,
                        projAdvancedJournalLine.AccountingDate,
                        projAdvancedJournalLine.Quantity,
                        exchRate,
                        exchRateSecond,
                        transTaxInformation.TaxWithholdAcknowledgementNumber,
                        transTaxInformation.TaxWithholdCountryRegionToRemittance,
                        transTaxInformation.TaxWithholdNatureOfRemittance);
                }
                break;
            default :
                break;
        }

        taxWithholdData = conNull();
        taxWithholdData = conPoke(taxWithholdData, #1, exchangeRate);
        taxWithholdData = conPoke(taxWithholdData, #2, exchangeRateSecond);
        taxWithholdData = conPoke(taxWithholdData, #3, triangulation);
        taxWithholdData = conPoke(taxWithholdData, #4, currencyCodeLoc);
        taxWithholdData = conPoke(taxWithholdData, #5, _grossAmount);
        taxWithholdData = conPoke(taxWithholdData, #6, taxModuleTypeLoc);
        taxWithholdData = conPoke(taxWithholdData, #7, dimensionDefaultLoc);
        taxWithholdData = conPoke(taxWithholdData, #8, sourceTableIdLoc);
        taxWithholdData = conPoke(taxWithholdData, #9, sourceRecIdLoc);
        taxWithholdData = conPoke(taxWithholdData, #10, voucherLoc);
        taxWithholdData = conPoke(taxWithholdData, #11, invoiceLoc);
        taxWithholdData = conPoke(taxWithholdData, #12, lineNumLoc);
        taxWithholdData = conPoke(taxWithholdData, #13, ledgerJournalTypeLoc);
        taxWithholdData = conPoke(taxWithholdData, #14, settlementTypeLoc);
        taxWithholdData = conPoke(taxWithholdData, #15, companyLocationLoc);
        taxWithholdData = conPoke(taxWithholdData, #16, natureOfAssesseeLoc);
        taxWithholdData = conPoke(taxWithholdData, #17, creditNoteDate);
        taxWithholdData = conPoke(taxWithholdData, #18, '');
        taxWithholdData = conPoke(taxWithholdData, 19,  taxWithholdVoucher);
        taxWithholdData = conPoke(taxWithholdData, #20, taxWithholdLineNum);
        taxWithholdData = conPoke(taxWithholdData, 21, quantityLoc);
        taxWithholdData = conPoke(taxWithholdData, 22, headingTableId);
        taxWithholdData = conPoke(taxWithholdData, 23, headingRecId);
        taxWithholdData = conPoke(taxWithholdData, 24, acknowledgementNumber);
        taxWithholdData = conPoke(taxWithholdData, 25, countryToRemittance);
        taxWithholdData = conPoke(taxWithholdData, 26, natureOfRemittance);
        taxWithholdData = conPoke(taxWithholdData, #TDSExchRate, tdsExchangeRate);
        taxWithholdData = conPoke(taxWithholdData, #TDSExchRateSecond, tdsExchangeRateSecond);
        taxWithholdData = conPoke(taxWithholdData, #TDSTriangulation,  tdsTriangulation);

        return taxWithholdData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCustInvoiceTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if current transation is a customer invoice.
    /// </summary>
    /// <param name = "_sourceTableId">The current transation line table id.</param>
    /// <param name = "_sourceRecId">The current transation line recod id.</param>
    /// <returns>ture if it is customer invoice, otherwise; false.</returns>
    internal boolean isCustInvoiceTransaction(RefTableId _sourceTableId, RefRecId _sourceRecId)
    {
        boolean isCustInvoice = false;

        if (_sourceTableId && _sourceRecId)
        {
            if (_sourceTableId == tableNum(SalesLine)
                || _sourceTableId == tableNum(CustInvoiceLine)
                || _sourceTableId == tableNum(ProjProposalRevenue)
                || _sourceTableId == tableNum(projProposalItem)
                || _sourceTableId == tableNum(projProposalOnAcc))
            {
                isCustInvoice = true;
            }
            else if (_sourceTableId == tableNum(LedgerJournalTrans))
            {
                LedgerJournalTrans ledgerJournalTrans = LedgerJournalTrans::findRecId(_sourceRecId, false);
                // The ledgerJournalTrans for tax calculation will be the customer line.
                if ((ledgerJournalTrans.AccountType == LedgerJournalACType::Cust && ledgerJournalTrans.parmAccount())
                    || (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust && ledgerJournalTrans.parmOffsetAccount()))
                {
                    isCustInvoice = true;
                    LedgerJournalACType accountType = ledgerJournalTrans.AccountType;
                    DimensionDynamicAccount ledgerDimension = ledgerJournalTrans.LedgerDimension;
                    LedgerJournalACType offsetAccountType = ledgerJournalTrans.OffsetAccountType;
                    DimensionDynamicAccount offsetLedgerDimension = ledgerJournalTrans.OffsetLedgerDimension;
                    if (!offsetLedgerDimension
                        && accountType == LedgerJournalACType::Cust
                        && ledgerJournalTrans.AmountCurCredit > 0)
                    {
                        // For single side multiple lines, WHT just support offset is empty.
                        LedgerJournalTrans tmpLedgerJournalTrans;
                        select firstonly AccountType, LedgerDimension from tmpLedgerJournalTrans
                            where tmpLedgerJournalTrans.LedgerDimension
                                && (tmpLedgerJournalTrans.AccountType == LedgerJournalACType::Bank
                                    || (tmpLedgerJournalTrans.AccountType == LedgerJournalACType::Ledger
                                        && MainAccount::findByLedgerDimension(tmpLedgerJournalTrans.LedgerDimension).PostingType == LedgerPostingType::SalesCash))
                                && tmpLedgerJournalTrans.AmountCurDebit > 0
                                && tmpLedgerJournalTrans.Voucher == ledgerJournalTrans.Voucher
                                && tmpLedgerJournalTrans.RecId != ledgerJournalTrans.RecId;

                        if (tmpLedgerJournalTrans.RecId)
                        {
                            offsetAccountType = tmpLedgerJournalTrans.AccountType;
                            offsetLedgerDimension = tmpLedgerJournalTrans.LedgerDimension;
                        }
                    }

                    if ((accountType == LedgerJournalACType::Cust
                            && ledgerJournalTrans.AmountCurCredit > 0
                            && (offsetAccountType == LedgerJournalACType::Bank
                                || (offsetAccountType == LedgerJournalACType::Ledger
                                    && MainAccount::findByLedgerDimension(offsetLedgerDimension).PostingType == LedgerPostingType::SalesCash)))
                        || (offsetAccountType == LedgerJournalACType::Cust
                            && ledgerJournalTrans.AmountCurDebit > 0
                            && (accountType == LedgerJournalACType::Bank
                                || (accountType == LedgerJournalACType::Ledger
                                    && MainAccount::findByLedgerDimension(ledgerDimension).PostingType == LedgerPostingType::SalesCash))))

                    {
                        isCustInvoice = false;
                    }
                }
            }
        }

        return isCustInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the tax exists.
    /// </summary>
    /// <returns>
    /// Returns true if the tax exist.
    /// </returns>
    public boolean taxExists()
    {
        select firstonly RecId from taxWithholdWorkTrans;

        if (taxWithholdWorkTrans.RecId)
            return true;

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithhold</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax withhold information.
    /// </summary>
    /// <param name="_taxWithhold">
    /// The tax withhold information.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxWithhold_IN</c> class.
    /// </returns>
    public TaxWithhold_IN taxWithhold(TaxWithhold_IN  _taxWithhold = taxWithHoldIN)
    {
        taxWithHoldIN = _taxWithhold;

        return taxWithHoldIN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdAdvancePayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates tax WithholdAmount for Advance payment.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The LedgerJournalTrans buffer.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The LedgerVoucher object.
    /// </param>
    /// <param name="_taxWithholdGroup">
    /// The TaxWithholdGroup value.
    /// </param>
    /// <param name="_grossAmount">
    /// The GrossAmount.
    /// </param>
    /// <returns>
    /// Tax WithholdAmount for Advance payment.
    /// </returns>
    public real  taxWithholdAdvancePayment(LedgerJournalTrans _ledgerJournalTrans,
                                           LedgerVoucher      _ledgerVoucher,
                                           TaxWithholdGroup   _taxWithholdGroup,
                                           real               _grossAmount)
    {
        container                   taxWithholdData;
        AmountCur                   taxAmount;
        CustVendAC                  accountNumber;

        taxWithholdData  = TaxWithholdCalculation_IN::setLedgerData(_ledgerJournalTrans, _grossAmount);

        if (companyId != paymcompanyId)
        {
            accountNumber = invoiceAccount;
        }
        else
        {
            accountNumber = TaxWithholdJournal_IN::setAccountNumber(_ledgerJournalTrans);
        }
        if (!accountNumber)
        {
            accountNumber = invoiceAccount;
        }

        taxAmount = this.totalTaxWithhold(accountNumber,
                                          _taxWithholdGroup,
                                          _ledgerJournalTrans.TransDate,
                                          taxWithholdData,
                                          TaxWithholdCalculation_IN::checkRecoverableAccount(_ledgerJournalTrans),
                                          true,
                                          '',
                                          '',
                                          _ledgerJournalTrans.JournalNum,
                                          _ledgerJournalTrans.AmountCurDebit,
                                          _ledgerJournalTrans.AmountCurCredit,
                                          _ledgerJournalTrans.AccountType,
                                          _ledgerJournalTrans.OffsetAccountType);

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdAdvancePaymentCalc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates tax WithholdAmount for Advance payment.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The LedgerJournalTrans buffer.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The LedgerVoucher object.
    /// </param>
    /// <param name="_grossAmount">
    /// The GrossAmount.
    /// </param>
    /// <param name="_isTmpTable">
    /// boolean value if IsTmpTable.
    /// </param>
    /// <param name="_specTrans">
    /// The SpecTrans buffer.
    /// </param>
    /// <param name="_isVendorTransaction">
    /// boolean value if isVendorTransaction.
    /// </param>
    /// <returns>
    /// Calculated tax WithholdAmount for Advance payment.
    /// </returns>
    public real taxWithholdAdvancePaymentCalc(LedgerJournalTrans _ledgerJournalTrans,
                                              LedgerVoucher      _ledgerVoucher,
                                              real               _grossAmount,
                                              boolean            _isTmpTable = true,
                                              SpecTrans          _specTrans = null,
                                              boolean            _isVendorTransaction = false)
    {
        container                   taxWithholdData;
        AmountCur                   taxAmount;
        CustVendAC                  accountNumber;
        TaxWithholdGroup            taxWithholdGroup;
        SpecTrans                   specTrans;
        boolean                     isAdvancePayment = true;
        CustTable                   custTableLoc;
        TaxInformationCustTable_IN  taxInformationCustTableLoc;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();

        select  specTrans
            where specTrans.SpecRecId    == _specTrans.SpecRecId
               && specTrans.RefRecId     == _specTrans.RefRecId;

        if (specTrans)
        {
            this.setInvoiceAndPaymentData(specTrans);
            isAdvancePayment = false;
        }
        if (!specTrans && _ledgerJournalTrans.Company != _ledgerJournalTrans.OffsetCompany)
        {
            this.setInvoiceAndPaymentData(null, _ledgerJournalTrans, _ledgerJournalTrans.OffsetCompany);
            isAdvancePayment = ledgerJournalTransTaxExt.tdsGroup ? false : true;
        }

        taxWithholdData  = TaxWithholdCalculation_IN::setLedgerData(_ledgerJournalTrans, _grossAmount);

        if (companyId != paymcompanyId || _ledgerJournalTrans.Company != paymcompanyId)
        {
            accountNumber = invoiceAccount;
        }
        else
        {
            accountNumber = TaxWithholdJournal_IN::setAccountNumber(_ledgerJournalTrans);
        }
        if (!accountNumber)
        {
            accountNumber = invoiceAccount;
        }

        if (!specTrans)
        {
            taxWithholdGroup = ledgerJournalTransTaxExt.tdsGroup ? ledgerJournalTransTaxExt.tdsGroup : ledgerJournalTransTaxExt.tcsGroup;
        }
        else
        {
            custTableLoc = CustTable::findByCompany(specTrans.RefCompany, accountNumber);
            taxInformationCustTableLoc = custTableLoc.getTaxInformationCustTable_IN();
            taxWithholdGroup = taxInformationCustTableLoc.tdsGroup ? taxInformationCustTableLoc.tdsGroup : taxInformationCustTableLoc.tcsGroup;
        }

        if (ledgerJournalTransTaxExt.tcsGroup && this.canCalculateWHTForCC(_ledgerJournalTrans, accountNumber, true, _isVendorTransaction))
        {
            taxAmount = this.totalTaxWithhold(accountNumber,
                                              taxWithholdGroup,
                                              _ledgerJournalTrans.TransDate,
                                              taxWithholdData,
                                              TaxWithholdCalculation_IN::checkRecoverableAccount(_ledgerJournalTrans),
                                              isAdvancePayment,
                                              '',
                                              '',
                                              _ledgerJournalTrans.JournalNum,
                                              _ledgerJournalTrans.AmountCurDebit,
                                              _ledgerJournalTrans.AmountCurCredit,
                                              _ledgerJournalTrans.AccountType,
                                              _ledgerJournalTrans.OffsetAccountType);
        }

        taxAmount = specTrans ? taxAmount * -1 : taxAmount;
        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdBank</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates withholding taxes for Bank transactions.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// The LedgerVoucher object.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The LedgerJournalTrans buffer.
    /// </param>
    /// <returns>
    /// Calculated withholding taxAmount.
    /// </returns>
    public real  taxWithholdBank(LedgerVoucher         _ledgerVoucher,
                                 LedgerJournalTrans    _ledgerJournalTrans)
    {
        real                        chargeAmount , grossAmount;
        TaxWithholdTable            taxWithHoldTableLoc;
        LedgerJournalTrans          ledgerJournalLoc;
        TaxWithholdGroup            taxWithholdGroup;
        TaxTrans                    taxTrans;
        TaxTable                    taxTable;
        AmountCur                   taxAmount;
        int                         i;
        container                   invoiceCmp;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();

        taxWithholdGroup = ledgerJournalTransTaxExt.tdsGroup ? ledgerJournalTransTaxExt.tdsGroup : ledgerJournalTransTaxExt.tcsGroup;

        select firstonly taxWithHoldTableLoc;
        select firstonly ledgerJournalLoc
            where ledgerJournalLoc.RecId == _ledgerJournalTrans.RecId;

        if (TaxWithholdGroupHeading::find(taxWithholdGroup).TaxType_IN == TaxWithholdCodeType_IN::TDS
            && TaxWithholdCalculation_IN::tdsAccount(ledgerJournalLoc.AccountType,
                                                     ledgerJournalLoc.OffsetAccountType,
                                                     ledgerJournalLoc.AmountCurDebit,
                                                     ledgerJournalLoc.AmountCurCredit,
                                                     taxWithHoldTableLoc,
                                                      true))
        {
            select sum(TaxAmount) from taxTrans
                where taxTrans.SourceTableId == _ledgerJournalTrans.TableId
                   && taxTrans.SourceRecId   == _ledgerJournalTrans.RecId
            join TaxCode,TaxType_IN from taxTable
                where taxTable.TaxCode      == taxTrans.TaxCode
                   && taxTable.TaxType_IN   != TaxType_IN::Customs;
            if (_ledgerJournalTrans.Prepayment && _ledgerJournalTrans.ledgerJournalTable().LedgerJournalInclTax)
            {
                taxAmount = 0;
            }
            else
            {
                taxAmount = abs(taxTrans.TaxAmount);
            }

            TaxWithholdJournal_IN::checkMultipleTaxType(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher);
            grossAmount = (ledgerJournalLoc.AmountCurCredit + ledgerJournalLoc.AmountCurDebit +
                           taxAmount);

            if ((ledgerJournalLoc.AccountType            == LedgerJournalACType::Cust   && ledgerJournalLoc.OffsetAccountType   == LedgerJournalACType::Bank
                && ledgerJournalLoc.AmountCurDebit      > 0)
                || (ledgerJournalLoc.AccountType        == LedgerJournalACType::Vend   &&  ledgerJournalLoc.OffsetAccountType   == LedgerJournalACType::Bank
                && ledgerJournalLoc.AmountCurDebit      > 0)
                || (ledgerJournalLoc.AccountType        == LedgerJournalACType::Cust   && ledgerJournalLoc.OffsetAccountType   == LedgerJournalACType::Bank
                && ledgerJournalLoc.AmountCurCredit     > 0)
                || (ledgerJournalLoc.AccountType        == LedgerJournalACType::Bank   && ledgerJournalLoc.OffsetAccountType   == LedgerJournalACType::Cust
                && ledgerJournalLoc.AmountCurDebit      > 0))

            {
                invoiceCmp = _ledgerVoucher.parmAllWHTInvoiceCompany_IN();
                this.setPaymentCompany(ledgerJournalLoc.company());
                for (i=1; i <= conLen(invoiceCmp); i++)
                {
                   chargeAmount += this.setTaxWithholdAmount(ledgerJournalLoc, '', conPeek(invoiceCmp, i));
                }
                _ledgerVoucher.flushAllWHTInvoiceCompany_IN();

                if (ledgerJournalLoc.AccountType     == LedgerJournalACType::Bank   && ledgerJournalLoc.OffsetAccountType   == LedgerJournalACType::Cust
                    && ledgerJournalLoc.AmountCurDebit   > 0)
                {
                    chargeAmount =  -this.taxWithholdLedger(ledgerJournalLoc, _ledgerVoucher, taxWithholdGroup, grossAmount);
                }
            }
            if (ledgerJournalTransTaxExt.tdsGroup
                && ledgerJournalLoc.AmountCurCredit > 0
                && ledgerJournalLoc.AccountType == LedgerJournalACType::Bank)
            {
                if (ledgerJournalLoc.OffsetAccountType  == LedgerJournalACType::Cust
                    && CustTable::find(TaxWithholdJournal_IN::setAccountNumber(ledgerJournalLoc), false).TaxWithholdCalculate_IN)
                {
                    chargeAmount =  this.taxWithholdLedger(ledgerJournalLoc, _ledgerVoucher, taxWithholdGroup, grossAmount);
                }

                if (ledgerJournalLoc.OffsetAccountType  == LedgerJournalACType::Vend
                    && VendTable::find(TaxWithholdJournal_IN::setAccountNumber(ledgerJournalLoc), false).TaxWithholdCalculate)
                {
                    chargeAmount =  this.taxWithholdLedger(ledgerJournalLoc, _ledgerVoucher, taxWithholdGroup, grossAmount);
                }
            }
            if ((ledgerJournalLoc.AccountType           == LedgerJournalACType::Bank
                && ledgerJournalLoc.OffsetAccountType   == LedgerJournalACType::Ledger  && ledgerJournalLoc.AmountCurDebit      > 0)
                || (ledgerJournalLoc.AccountType        == LedgerJournalACType::Ledger  &&  ledgerJournalLoc.OffsetAccountType  == LedgerJournalACType::Bank
                && ledgerJournalLoc.AmountCurCredit > 0))
            {
                chargeAmount =  -this.taxWithholdLedger(ledgerJournalLoc, _ledgerVoucher, taxWithholdGroup,grossAmount);
            }
            if ((ledgerJournalLoc.AccountType           == LedgerJournalACType::Bank
                && ledgerJournalLoc.OffsetAccountType   == LedgerJournalACType::Ledger && ledgerJournalLoc.AmountCurCredit > 0)
                || (ledgerJournalLoc.AccountType        == LedgerJournalACType::Ledger &&  ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Bank
                && ledgerJournalLoc.AmountCurDebit      > 0))
            {
                chargeAmount =  this.taxWithholdLedger(ledgerJournalLoc,_ledgerVoucher,taxWithholdGroup,grossAmount);
            }
        }
        if (TaxWithholdGroupHeading::find(taxWithholdGroup).TaxType_IN == TaxWithholdCodeType_IN::TCS)
        {
            if ((ledgerJournalLoc.AccountType            == LedgerJournalACType::Cust
                && ledgerJournalLoc.OffsetAccountType   == LedgerJournalACType::Bank
                && ledgerJournalLoc.AmountCurCredit > 0 && ledgerJournalLoc.SettleVoucher == SettlementType::SelectedTransact))
            {
                invoiceCmp = _ledgerVoucher.parmAllWHTInvoiceCompany_IN();
                this.setPaymentCompany(ledgerJournalLoc.company());
                for (i=1; i <= conLen(invoiceCmp); i++)
                {
                   chargeAmount += this.setTaxWithholdAmount(ledgerJournalLoc, '', conPeek(invoiceCmp, i));
                }
                _ledgerVoucher.flushAllWHTInvoiceCompany_IN();

                if (_ledgerVoucher.parmCheckBank_IN())
                {
                    chargeAmount = 0;
                    _ledgerVoucher.parmCheckBank_IN(false);
                }
            }

            if ((ledgerJournalLoc.AccountType            == LedgerJournalACType::Vend
                && ledgerJournalLoc.OffsetAccountType   == LedgerJournalACType::Bank
                && ledgerJournalLoc.AmountCurDebit      > 0 && ledgerJournalLoc.SettleVoucher == SettlementType::SelectedTransact))
            {
                invoiceCmp = _ledgerVoucher.parmAllWHTInvoiceCompany_IN();
                this.setPaymentCompany(ledgerJournalLoc.company());
                for (i=1; i <= conLen(invoiceCmp); i++)
                {
                   chargeAmount += this.setTaxWithholdAmount(ledgerJournalLoc, '', conPeek(invoiceCmp, i));
                }
                _ledgerVoucher.flushAllWHTInvoiceCompany_IN();

                if (_ledgerVoucher.parmCheckBank_IN())
                {
                    chargeAmount = 0;
                    _ledgerVoucher.parmCheckBank_IN(false);
                }
            }
        }
        return chargeAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates withholding TaxAmount for Customer transaction.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// The LedgerVoucher object.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The LedgerJournalTrans buffer.
    /// </param>
    /// <param name="_custVoucher">
    /// The CustVoucher object.
    /// </param>
    /// <param name="_amountCur">
    /// The AmountCur value.
    /// </param>
    public void  taxWithholdCustomer(LedgerVoucher        _ledgerVoucher,
                                     LedgerJournalTrans   _ledgerJournalTrans,
                                     CustVoucher          _custVoucher,
                                     AmountCur            _amountCur = 0)
    {
        real                        chargeAmount , grossAmount;
        TaxWithholdTable            taxWithHoldTableLoc;
        LedgerJournalTrans          ledgerJournalLoc, ledgerJournalTransLoc;
        TaxWithholdGroup            taxWithholdGroup;
        TaxWithholdParameters_IN    taxWithholdParameters = TaxWithholdParameters_IN::find();
        TaxTrans                    taxTrans;
        TaxTable                    taxTable;
        AmountCur                   taxAmount;
        SpecTrans                   specTransCount;
        int                         counter;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();

        this.setJournalLineCompany(curext());
        select firstonly ledgerJournalLoc
            where ledgerJournalLoc.RecId == _ledgerJournalTrans.RecId;

        select firstonly taxWithHoldTableLoc;
        while select RefCompany from specTransCount
                group by RefCompany
                where specTransCount.SpecRecId == _ledgerJournalTrans.RecId
        {
            counter += 1;
        }

        taxWithholdGroup = ledgerJournalTransTaxExt.tdsGroup ? ledgerJournalTransTaxExt.tdsGroup : ledgerJournalTransTaxExt.tcsGroup;

        if (TaxWithholdJournal_IN::validateBankAccount(ledgerJournalLoc))
        {
            while select JournalNum, Voucher, TableId, RecId   from ledgerJournalTransLoc
                    where ledgerJournalTransLoc.JournalNum == _ledgerJournalTrans.JournalNum    &&
                            ledgerJournalTransLoc.Voucher    == _ledgerJournalTrans.Voucher
            {
                select sum(TaxAmount) from taxTrans
                    where taxTrans.SourceTableId == ledgerJournalTransLoc.TableId
                            && taxTrans.SourceRecId   == ledgerJournalTransLoc.RecId
                join TaxCode,TaxType_IN from taxTable
                    where taxTable.TaxCode      == taxTrans.TaxCode
                        && taxTable.TaxType_IN   != TaxType_IN::Customs;

                taxAmount += taxTrans.TaxAmount;
            }

            if (_ledgerJournalTrans.ledgerJournalTable().LedgerJournalInclTax)
            {
                taxAmount = 0;
            }
            else
            {
                taxAmount = abs(taxAmount);
            }

            TaxWithholdJournal_IN::checkMultipleTaxType(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher);
            taxWithholdGroup = ledgerJournalTransTaxExt.tdsGroup ? ledgerJournalTransTaxExt.tdsGroup : ledgerJournalTransTaxExt.tcsGroup;
            grossAmount      = (ledgerJournalLoc.AmountCurCredit + ledgerJournalLoc.AmountCurDebit +
                                taxAmount);

            if (CustTable::find(_ledgerJournalTrans.parmAccount(), false).TaxWithholdCalculate_IN && ledgerJournalTransTaxExt.tcsGroup
                && taxWithholdParameters.tcsInvoice && TaxWithholdCalculation_IN::tcsAccount(ledgerJournalLoc.AccountType,
                                                                                                ledgerJournalLoc.OffsetAccountType,
                                                                                                ledgerJournalLoc.AmountCurDebit,
                                                                                                ledgerJournalLoc.AmountCurCredit,
                                                                                                taxWithHoldTableLoc,
                                                                                                true,
                                                                                                LedgerJournalType::Approval))
            {
                if (_ledgerJournalTrans.SettleVoucher == SettlementType::SelectedTransact)
                {
                    if (counter >= 2)
                    {
                        grossAmount = abs(this.amountPerCompany(_ledgerJournalTrans.RecId, companyId));
                    }
                    else
                    {
                        grossAmount = _ledgerJournalTrans.AmountCurDebit + _ledgerJournalTrans.AmountCurCredit + taxAmount;
                    }

                    if (grossAmount)
                    {
                        chargeAmount = this.taxWithholdLedger(ledgerJournalLoc,_ledgerVoucher,taxWithholdGroup,grossAmount);
                    }
                }
                else
                {
                    chargeAmount = this.taxWithholdLedger(ledgerJournalLoc,_ledgerVoucher,taxWithholdGroup,grossAmount);
                }

                if (chargeAmount)
                {
                    _custVoucher.parmTaxWithholdAmount_IN(chargeAmount);
                }
            }
            if (CustTable::find(_ledgerJournalTrans.parmAccount(), false).TaxWithholdCalculate_IN && ledgerJournalTransTaxExt.tdsGroup
            && TaxWithholdCalculation_IN::tdsAccount(ledgerJournalLoc.AccountType,
                                                            ledgerJournalLoc.OffsetAccountType,
                                                            ledgerJournalLoc.AmountCurDebit,
                                                            ledgerJournalLoc.AmountCurCredit,
                                                            taxWithHoldTableLoc, true))
            {
                if (_ledgerJournalTrans.SettleVoucher == SettlementType::SelectedTransact)
                {
                    if (counter >= 2)
                    {
                        grossAmount = abs(this.amountPerCompany(_ledgerJournalTrans.RecId, companyId));
                    }
                    else
                    {
                        grossAmount = _ledgerJournalTrans.AmountCurDebit + _ledgerJournalTrans.AmountCurCredit;
                    }

                    if (grossAmount)
                    {
                        chargeAmount = this.taxWithholdLedger(ledgerJournalLoc, _ledgerVoucher, taxWithholdGroup, grossAmount);
                    }
                }
                else
                {
                    if (ledgerJournalLoc.AccountType    == LedgerJournalACType::Bank &&  ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Cust && ledgerJournalLoc.AmountCurDebit  > 0 && taxWithholdParameters.tdsPayment)

                    {
                        chargeAmount      = this.setTaxWithholdAmount(ledgerJournalLoc, ledgerJournalLoc.parmOffsetAccount());
                        transAmountOrigin = ledgerJournalLoc.AmountCurDebit;
                    }
                    else
                    {
                        chargeAmount = this.taxWithholdLedger(ledgerJournalLoc, _ledgerVoucher, taxWithholdGroup, grossAmount);
                    }
                }
                if (abs(chargeAmount) > abs(grossAmount))
                {
                    throw error (strFmt("@GLS5855", "@SYS81689"));
                }
                if (chargeAmount && TaxWithholdJournal_IN::checkBankAccount(ledgerJournalLoc))
                {
                    _custVoucher.parmTaxWithholdAmount_IN(TaxWithholdJournal_IN::setDirection(chargeAmount, ledgerJournalLoc));
                }
                else
                {
                    _custVoucher.parmTaxWithholdBank_IN(chargeAmount);
                }
            }

            _custVoucher.parmTaxWithholdAmountOriginCur_IN(transAmountOrigin);
        }
        else
        {
            if (TaxWithholdGroupHeading::find(taxWithholdGroup).TaxType_IN == TaxWithholdCodeType_IN::TCS &&
                CustTable::find(_ledgerJournalTrans.parmAccount(), false).TaxWithholdCalculate_IN            &&
                taxWithholdParameters.tcsPayment)
            {
                select sum(TaxAmount) from taxTrans
                    where taxTrans.SourceTableId == _ledgerJournalTrans.TableId
                        && taxTrans.SourceRecId   == _ledgerJournalTrans.RecId
                join TaxCode,TaxType_IN from taxTable
                    where taxTable.TaxCode      == taxTrans.TaxCode
                        && taxTable.TaxType_IN   != TaxType_IN::Customs;

                if (_ledgerJournalTrans.ledgerJournalTable().LedgerJournalInclTax)
                {
                    taxAmount = 0;
                }
                else
                {
                    taxAmount = abs(taxTrans.TaxAmount);
                }

                TaxWithholdJournal_IN::checkMultipleTaxType(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher);
                grossAmount = (ledgerJournalLoc.AmountCurCredit + ledgerJournalLoc.AmountCurDebit +
                                taxAmount);

                if ((ledgerJournalLoc.AccountType           == LedgerJournalACType::Bank
                    &&  ledgerJournalLoc.OffsetAccountType  == LedgerJournalACType::Cust  && ledgerJournalLoc.AmountCurDebit > 0)
                    || (ledgerJournalLoc.AccountType        == LedgerJournalACType::Cust  &&  ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Bank
                    && ledgerJournalLoc.AmountCurCredit     > 0))
                {
                    if (counter >= 2)
                    {
                        grossAmount = abs(this.amountPerCompany(_ledgerJournalTrans.RecId, companyId));
                    }
                    else
                    {
                        grossAmount = _ledgerJournalTrans.AmountCurDebit + _ledgerJournalTrans.AmountCurCredit + taxAmount;
                    }

                    if (!grossAmount)
                    {
                        grossAmount = _ledgerJournalTrans.AmountCurDebit + _ledgerJournalTrans.AmountCurCredit;
                    }

                    chargeAmount =  this.taxWithholdAdvancePayment(ledgerJournalLoc,_ledgerVoucher,taxWithholdGroup,grossAmount);
                    if (abs(chargeAmount) > abs(grossAmount))
                    {
                        throw error (strFmt("@GLS5855", "@SYS81689"));
                    }
                    if (ledgerJournalLoc.SettleVoucher == SettlementType::SelectedTransact)
                    {
                        _custVoucher.parmTaxWithholdBank_IN(chargeAmount);
                        _custVoucher.parmCheckBank_IN(checkBankStatus);
                        _ledgerVoucher.parmCheckBank_IN(checkBankStatus);
                    }
                    else
                    {
                        _custVoucher.parmTaxWithholdAmount_IN(chargeAmount);
                    }
                }
            }
            _custVoucher.parmTaxWithholdAmountOriginCur_IN(transAmountOrigin);
        }
        _custVoucher.parmTaxWithholdTransRecId_IN(taxWithholdTransRecId);
        if ((ledgerJournalLoc.AccountType == LedgerJournalACType::Bank &&  ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Cust && ledgerJournalLoc.AmountCurCredit > 0 && taxWithholdParameters.tdsPayment && ledgerJournalLoc.ledgerJournalTransTaxExtensionIN().tdsGroup))
        {
            _custVoucher.parmTaxWithholdBank_IN(this.setTaxWithholdAmount(ledgerJournalLoc, ledgerJournalLoc.parmOffsetAccount()));
            _custVoucher.parmTaxWithholdAmountOriginCur_IN(ledgerJournalLoc.AmountCurCredit);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates withholding taxes for Ledger Transaction.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The LedgerJournalTrans buffer.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The LedgerVoucher object.
    /// </param>
    /// <param name="_taxWithholdGroup">
    /// The TaxWithholdGroup value.
    /// </param>
    /// <param name="_grossAmount">
    /// The GrossAmount.
    /// </param>
    /// <returns>
    /// Calculated withholding taxes for Ledger Transaction.
    /// </returns>
    public real  taxWithholdLedger(LedgerJournalTrans _ledgerJournalTrans,
                                   LedgerVoucher      _ledgerVoucher,
                                   TaxWithholdGroup   _taxWithholdGroup,
                                   real               _grossAmount)
    {
        container                   taxWithholdData;
        CustVendAC                  accountNumber;

        taxWithholdData  = TaxWithholdCalculation_IN::setLedgerData(_ledgerJournalTrans,_grossAmount);
        if ((companyId && paymcompanyId) && (companyId != paymcompanyId || _ledgerJournalTrans.Company != paymcompanyId))
        {
            accountNumber = invoiceAccount;
        }
        else
        {
            accountNumber = TaxWithholdJournal_IN::setAccountNumber(_ledgerJournalTrans);
        }
        if (!accountNumber)
        {
            accountNumber = invoiceAccount;
        }
        offsetAccountNum = _ledgerJournalTrans.parmAccount();

        return this.totalTaxWithhold(accountNumber,
                                     _taxWithholdGroup,
                                     _ledgerJournalTrans.TransDate,
                                     taxWithholdData,
                                     TaxWithholdCalculation_IN::checkRecoverableAccount(_ledgerJournalTrans),
                                     false,
                                     '',
                                     '',
                                     _ledgerJournalTrans.JournalNum,
                                     _ledgerJournalTrans.AmountCurDebit,
                                     _ledgerJournalTrans.AmountCurCredit,
                                     _ledgerJournalTrans.AccountType,
                                     _ledgerJournalTrans.OffsetAccountType,
                                     conNull());
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdVendor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates withholding taxes for vendor transactions.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// The LedgerVoucher object.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The LedgerJournalTrans buffer.
    /// </param>
    /// <param name="_vendVoucher">
    /// The VendVoucher object.
    /// </param>
    public void taxWithholdVendor(LedgerVoucher        _ledgerVoucher,
                                  LedgerJournalTrans   _ledgerJournalTrans,
                                  VendVoucher          _vendVoucher)
    {
        TaxWithholdTable            taxWithHoldTableLoc;
        LedgerJournalTrans          ledgerJournalLoc,ledgerJournalTransLoc;
        real                        chargeAmount , grossAmount;
        TaxWithholdGroup            taxWithholdGroup;
        TaxWithholdParameters_IN    taxWithholdParameters = TaxWithholdParameters_IN::find();
        TaxTrans                    taxTrans;
        TaxTable                    taxTable;
        AmountCur                   taxAmount;
        SpecTrans                   specTransCount;
        int                         counter;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();

        this.setJournalLineCompany(curext());
        select firstonly ledgerJournalLoc
            where ledgerJournalLoc.RecId == _ledgerJournalTrans.RecId;

        select firstonly taxWithHoldTableLoc;

        while select RefCompany from specTransCount
                group by RefCompany
                where specTransCount.SpecRecId == _ledgerJournalTrans.RecId
        {
            counter += 1;
        }

        taxWithholdGroup = ledgerJournalTransTaxExt.tdsGroup ? ledgerJournalTransTaxExt.tdsGroup : ledgerJournalTransTaxExt.tcsGroup;

        if (TaxWithholdJournal_IN::validateBankAccount(ledgerJournalLoc))
        {
            if (VendTable::findByLedgerDimension(ledgerJournalLoc.LedgerDimension).isGTA()
                || VendTable::findByLedgerDimension(ledgerJournalLoc.OffsetLedgerDimension).isGTA())
            {
                while select JournalNum,Voucher from ledgerJournalTransLoc
                    where ledgerJournalTransLoc.JournalNum == _ledgerJournalTrans.JournalNum    &&
                            ledgerJournalTransLoc.Voucher    == _ledgerJournalTrans.Voucher
                {
                    select sum(TaxAmount) from taxTrans
                        where taxTrans.SourceTableId == ledgerJournalTransLoc.TableId
                            && taxTrans.SourceRecId   == ledgerJournalTransLoc.RecId
                    join TaxCode,TaxType_IN from taxTable
                        where taxTable.TaxCode      == taxTrans.TaxCode
                            && taxTable.TaxType_IN   != TaxType_IN::Customs
                            && taxTable.TaxType_IN   != TaxType_IN::ServiceTax;

                    taxAmount += taxTrans.TaxAmount;
                }
            }
            else
            {
                while select JournalNum,Voucher from ledgerJournalTransLoc
                    where ledgerJournalTransLoc.JournalNum == _ledgerJournalTrans.JournalNum    &&
                            ledgerJournalTransLoc.Voucher    == _ledgerJournalTrans.Voucher
                {
                    select sum(TaxAmount) from taxTrans
                        where taxTrans.SourceTableId == ledgerJournalTransLoc.TableId
                            && taxTrans.SourceRecId   == ledgerJournalTransLoc.RecId
                    join taxTable
                        where taxTable.TaxCode      == taxTrans.TaxCode
                            && taxTable.TaxType_IN   != TaxType_IN::Customs;

                    taxAmount += taxTrans.TaxAmount;
                }
            }
            if (_ledgerJournalTrans.ledgerJournalTable().LedgerJournalInclTax)
            {
                taxAmount = 0;
            }
            else
            {
                taxAmount = abs(taxAmount);
            }

            TaxWithholdJournal_IN::checkMultipleTaxType(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher);
            taxWithholdGroup = ledgerJournalTransTaxExt.tdsGroup ? ledgerJournalTransTaxExt.tdsGroup : ledgerJournalTransTaxExt.tcsGroup;
            grossAmount      = (ledgerJournalLoc.AmountCurCredit + ledgerJournalLoc.AmountCurDebit +
                                taxAmount);

            if (VendTable::find(_ledgerJournalTrans.parmAccount(), false).TaxWithholdCalculate && ledgerJournalTransTaxExt.tcsGroup
                && taxWithholdParameters.tcsInvoice && TaxWithholdCalculation_IN::tcsAccount(ledgerJournalLoc.AccountType,
                                                                                                ledgerJournalLoc.OffsetAccountType,
                                                                                                ledgerJournalLoc.AmountCurDebit,
                                                                                                ledgerJournalLoc.AmountCurCredit,
                                                                                                taxWithHoldTableLoc,
                                                                                                true,
                                                                                                LedgerJournalType::Approval))
            {
                if (_ledgerJournalTrans.SettleVoucher == SettlementType::SelectedTransact)
                {
                    if (counter >= 2)
                    {
                        grossAmount = abs(this.amountPerCompany(_ledgerJournalTrans.RecId, companyId));
                    }
                    else
                    {
                        grossAmount = _ledgerJournalTrans.AmountCurDebit + _ledgerJournalTrans.AmountCurCredit + taxAmount;
                    }

                    if (grossAmount)
                    {
                        chargeAmount =  this.taxWithholdLedger(ledgerJournalLoc,_ledgerVoucher,taxWithholdGroup,grossAmount);
                    }
                }
                else
                {
                    chargeAmount =  this.taxWithholdLedger(ledgerJournalLoc,_ledgerVoucher,taxWithholdGroup,grossAmount);
                }

                if (chargeAmount)
                {
                    _vendVoucher.parmTaxWithholdAmount_IN(TaxWithholdJournal_IN::setDirection(chargeAmount,ledgerJournalLoc));
                }
            }
            if (VendTable::find(_ledgerJournalTrans.parmAccount(),false).TaxWithholdCalculate && ledgerJournalTransTaxExt.tdsGroup
                && TaxWithholdCalculation_IN::tdsAccount(ledgerJournalLoc.AccountType,
                                                            ledgerJournalLoc.OffsetAccountType,
                                                            ledgerJournalLoc.AmountCurDebit,
                                                            ledgerJournalLoc.AmountCurCredit,
                                                            taxWithHoldTableLoc,
                                                            true,
                                                            LedgerJournalType::Approval,
                                                            false))
            {
                if (_ledgerJournalTrans.SettleVoucher == SettlementType::SelectedTransact)
                {
                    if (counter >= 2)
                    {
                        grossAmount = abs(this.amountPerCompany(_ledgerJournalTrans.RecId, companyId));
                    }
                    else
                    {
                        grossAmount = _ledgerJournalTrans.AmountCurDebit + _ledgerJournalTrans.AmountCurCredit;
                    }

                    if (grossAmount)
                    {
                        chargeAmount =  this.taxWithholdLedger(ledgerJournalLoc,_ledgerVoucher,taxWithholdGroup,grossAmount);
                    }
                }
                else
                {
                    chargeAmount =  this.taxWithholdLedger(ledgerJournalLoc,_ledgerVoucher,taxWithholdGroup,grossAmount);
                }

                if (abs(chargeAmount) > abs(grossAmount))
                {
                    throw error (strFmt("@GLS5855", "@SYS81689"));
                }

                if (chargeAmount && TaxWithholdJournal_IN::checkBankAccount(ledgerJournalLoc))
                {
                        _vendVoucher.parmTaxWithholdAmount_IN(chargeAmount);
                }
                else
                {
                    _vendVoucher.parmTaxWithholdBank_IN(chargeAmount);
                }
            }

            _vendVoucher.parmTaxWithholdAmountOriginCur_IN(transAmountOrigin);
        }
        else
        {
            if (TaxWithholdGroupHeading::find(taxWithholdGroup).TaxType_IN == TaxWithholdCodeType_IN::TCS &&
                VendTable::find(_ledgerJournalTrans.parmAccount(),false).TaxWithholdCalculate &&
                taxWithholdParameters.tcsPayment)
            {
                select sum(TaxAmount) from taxTrans
                    where taxTrans.SourceTableId == _ledgerJournalTrans.TableId
                        && taxTrans.SourceRecId   == _ledgerJournalTrans.RecId
                join TaxCode,TaxType_IN from taxTable
                    where taxTable.TaxCode      == taxTrans.TaxCode
                        && taxTable.TaxType_IN   != TaxType_IN::Customs;

                if (_ledgerJournalTrans.ledgerJournalTable().LedgerJournalInclTax)
                {
                    taxAmount = 0;
                }
                else
                {
                    taxAmount = abs(taxTrans.TaxAmount);
                }

                TaxWithholdJournal_IN::checkMultipleTaxType(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher);
                grossAmount = (ledgerJournalLoc.AmountCurCredit + ledgerJournalLoc.AmountCurDebit +
                                taxAmount);
                if ((ledgerJournalLoc.AccountType           == LedgerJournalACType::Vend
                    && ledgerJournalLoc.OffsetAccountType   == LedgerJournalACType::Bank  && ledgerJournalLoc.AmountCurDebit > 0)
                    || (ledgerJournalLoc.AccountType        == LedgerJournalACType::Bank  && ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Vend
                    && ledgerJournalLoc.AmountCurCredit > 0))
                {
                    if (counter >= 2)
                    {
                        grossAmount = abs(this.amountPerCompany(_ledgerJournalTrans.RecId, companyId));
                    }
                    else
                    {
                        grossAmount = _ledgerJournalTrans.AmountCurDebit + _ledgerJournalTrans.AmountCurCredit + taxAmount;
                    }

                    if (!grossAmount)
                    {
                        grossAmount = _ledgerJournalTrans.AmountCurDebit + _ledgerJournalTrans.AmountCurCredit;
                    }

                    chargeAmount =  -(this.taxWithholdAdvancePayment(ledgerJournalLoc,_ledgerVoucher,taxWithholdGroup,grossAmount));
                    if (abs(chargeAmount) > abs(grossAmount))
                    {
                        throw error (strFmt("@GLS5855", "@SYS81689"));
                    }

                    if (ledgerJournalLoc.SettleVoucher == SettlementType::SelectedTransact)
                    {
                        if (checkBankStatus)
                        {
                            _vendVoucher.parmTaxWithholdBank_IN(chargeAmount);
                        }
                        else
                        {
                            _vendVoucher.parmTaxWithholdAmount_IN(0);
                        }
                        _vendVoucher.parmCheckBank_IN(checkBankStatus);
                        _ledgerVoucher.parmCheckBank_IN(checkBankStatus);
                    }
                    else
                    {
                        _vendVoucher.parmTaxWithholdAmount_IN(chargeAmount);
                    }
                }
            }
            _vendVoucher.parmTaxWithholdAmountOriginCur_IN(transAmountOrigin);
        }
        if ((ledgerJournalLoc.AccountType == LedgerJournalACType::Bank &&  ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Vend && ledgerJournalLoc.AmountCurCredit > 0 && taxWithholdParameters.tdsPayment && ledgerJournalLoc.ledgerJournalTransTaxExtensionIN().tdsGroup))
        {
            _vendVoucher.parmTaxWithholdBank_IN(this.setTaxWithholdAmount(ledgerJournalLoc, ledgerJournalLoc.parmOffsetAccount()));
            _vendVoucher.parmTaxWithholdAmountOriginCur_IN(ledgerJournalLoc.AmountCurCredit);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpTaxWithholdWorkTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets/Gets TmpTaxWithholdWorkTrans_IN buffer.
    /// </summary>
    /// <param name="_taxWithholdWorkTrans">
    /// The TmpTaxWithholdWorkTrans_IN buffer.
    /// </param>
    /// <returns>
    /// The TmpTaxWithholdWorkTrans_IN buffer.
    /// </returns>
    public TmpTaxWithholdWorkTrans_IN tmpTaxWithholdWorkTrans(TmpTaxWithholdWorkTrans_IN _taxWithholdWorkTrans = taxWithholdWorkTrans)
    {
        taxWithholdWorkTrans = _taxWithholdWorkTrans;

        return taxWithholdWorkTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpTransLineWithholdGrossAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the temporary trans line withhold gross amount.
    /// </summary>
    /// <param name="_tmpTransLineWithholdGrossAmount">
    /// The TmpTransLineWithholdGrossAmount_IN buffer.
    /// </param>
    /// <returns>
    /// The instance of the <c>TmpTransLineWithholdGrossAmount_IN</c> class.
    /// </returns>
    public TmpTransLineWithholdGrossAmount_IN tmpTransLineWithholdGrossAmount(TmpTransLineWithholdGrossAmount_IN _tmpTransLineWithholdGrossAmount = tmpTransLineWithholdGrossAmount)
    {
        tmpTransLineWithholdGrossAmount = _tmpTransLineWithholdGrossAmount;

        return tmpTransLineWithholdGrossAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountOriginCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total Amount Origin in transaction currency for all the lines.
    /// </summary>
    /// <returns>
    /// Returns the total Amount Origin in transaction currency for all the lines.
    /// </returns>
    public TaxAmountCur totalTaxAmountOriginCur()
    {
        TaxWithholdDesignerTable_IN taxWithholdDesigner;
        RefRecId                    sourceRecIdloc;

        while select taxWithholdWorkTrans
        {
            taxWithholdDesigner = TaxWithholdDesignerTable_IN::findByTaxWithholdGroup(taxWithholdWorkTrans.TaxWithholdGroup, taxWithholdWorkTrans.TaxWithholdCode);

            // Get the SourceBaseAmountCur for the taxLine with Basis as GrossAmount. Add all the GrossAmount for different Source records.
            if (taxWithholdDesigner.Basis == TaxWithholdBasis_IN::GrossAmount
                && sourceRecIdloc != taxWithholdWorkTrans.SourceRecId)
            {
                totalAmountOriginCur += taxWithholdWorkTrans.SourceBaseAmountCur;
                sourceRecIdloc = taxWithholdWorkTrans.SourceRecId;
            }
        }

        return totalAmountOriginCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxWithhold</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates withholding tax.
    /// </summary>
    /// <param name="_accountNum">
    /// Customer or vendor account number.
    /// </param>
    /// <param name="_taxWithholdGroup">
    /// Given withholding tax group.
    /// </param>
    /// <param name="_transDate">
    /// Transaction date.
    /// </param>
    /// <param name="_taxWithholdData">
    /// Withholding tax information.
    /// </param>
    /// <param name="_recoverable">
    /// Indicates whether it is withholding tax recoverable transaction.
    /// </param>
    /// <param name="_advancePayment">
    /// Indicates whether it is vendor/customer payment with TCS.
    /// </param>
    /// <param name="_purchId">
    /// Purchase order Id.
    /// </param>
    /// <param name="_salesId">
    /// Sales order Id.
    /// </param>
    /// <param name="_journalNum">
    /// Journal number.
    /// </param>
    /// <param name="_amountCurDebit">
    /// Debit amount of journal in transaction currency.
    /// </param>
    /// <param name="_amountCurCredit">
    /// Credit amount of journal in transaction currency.
    /// </param>
    /// <param name="_accountType">
    /// Given account type.
    /// </param>
    /// <param name="_offsetAccountType">
    /// Given offset account type.
    /// </param>
    /// <param name="_custVendInfo">
    /// Customer or vendor information.
    /// </param>
    /// <param name="_adjusted">
    /// Indicates whether it is adjusted.
    /// </param>
    /// <param name="_cpOrigRefRecId">
    /// The original reference record Id for centralized payment.
    /// </param>
    /// <param name="_isOnJewelry">
    /// Indicates whether it is transaction on jewelry. if it is on jewelry, it must be by cash.
    /// </param>
    /// <param name="_isByCash">
    /// Indicates whether it is by cash.
    /// </param>
    /// <returns>
    /// Calculated withholding tax amount.
    /// </returns>
    public AmountCur totalTaxWithhold(AccountNum                _accountNum,
                                      TaxWithholdGroup          _taxWithholdGroup,
                                      TransDate                 _transDate,
                                      container                 _taxWithholdData,
                                      boolean                   _recoverable        = false,
                                      boolean                   _advancePayment    = false,
                                      PurchIdBase               _purchId            = '',
                                      SalesIdBase               _salesId            = '',
                                      LedgerJournalId           _journalNum         = '',
                                      AmountCur                 _amountCurDebit     = 0,
                                      AmountCur                 _amountCurCredit    = 0,
                                      LedgerJournalACType       _accountType        = LedgerJournalACType::Cust,
                                      LedgerJournalACType       _offsetAccountType  = LedgerJournalACType::Cust,
                                      container                 _custVendInfo       = conNull(),
                                      boolean                   _adjusted           = false,
                                      RefRecId                  _cpOrigRefRecId     = 0,
                                      boolean                   _isOnJewelry        = false,
                                      boolean                   _isByCash           = false
                                      )
    {
        str                             formula, taxWithholdCode;
        str                             taxAmount;
        TaxAmountCur                    taxWithholdAmountOriginCur, taxWithholdAmountCur, totalTaxWithholdCalculatedCur;

        TaxAmount                       grossAmount, amountOriginMST, taxWithholdMST,
                                        taxWithholdThreshold, taxWithholdCalculationAmount, amount,
                                        totalAmountOrigin, convertedAmount, taxWithholdAmount;
        real                            taxWithholdValue;
        int                             checkTaxCode;
        container                       totalTDSAmount, taxcode;
        container                       taxWithhold;
        container                       insertTaxWithhold;
        Counter                         countI, countJ = 1;
        TaxWithholdType_IN              taxWithholdType;
        TaxWithholdDesignerTable_IN     taxWithholdDesignerTable;
        TaxWithholdTable                taxWithholdTableLoc;
        TaxWithholdData                 taxWithholdDataLoc;
        TaxWithholdThresholdLimit_IN    taxWithholdThresholdLimit;
        TaxWithholdGroupData            taxWithholdGroupDataLoc;
        ExecutePermission               permission;
        RefRecId                        refRecId    = conPeek(_taxWithholdData, #9);
        RefTableId                      refTableId  = conPeek(_taxWithholdData, #8);
        int                             sign = 1;
        CurrencyExchangeHelper          exchangeRateHelper;
        boolean                         isVendTransaction = false;
        TaxWithholdWorkRegulation_IN    taxWithholdWorkRegulation;
        AmountMST                       uncalculatedTransAmountMST;
        TaxWithholdTrans_IN             taxWithholdTransTaxCalculated;
        TaxAmount                       valueForOneShotThresholdCompare = 0;
        boolean                         isTaxCalculated = false;
        AmountMST                       curTransWHTNotCalculatedBaseMST;

        TaxWithholdThresholdHandler_IN  taxWithholdThresholdHanlder;
        TaxValueData_IN                 taxValueData;
        boolean                         isTaxAmountSet = false;

        #define.13(13)
        #Operator_IN
        #define.Zero('0')

        exchangeRateHelper = CurrencyExchangeHelper::newLedger(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));
        exchangeRateHelper.parmExchangeRate1(conPeek(_taxWithholdData, 1));
        exchangeRateHelper.parmExchangeRate2(conPeek(_taxWithholdData, #2));
        exchangeRateHelper.parmExchangeDate(_transDate);
        taxModuleType = conPeek(_taxWithholdData, #6);

        if ( _accountType == LedgerJournalACType::Vend ||
                _offsetAccountType            == LedgerJournalACType::Vend ||
                conPeek(_taxWithholdData, #8) == tableNum(PurchLine) ||
                conPeek(_taxWithholdData, #8) == tableNum(VendInvoiceTrans) ||
                conPeek(_taxWithholdData, #8) == tableNum(VendInvoiceInfoLine))
        {
            isVendTransaction = true;
        }

        if (!paymcompanyId)
        {
            paymcompanyId = curext();
        }
        if (!companyId)
        {
            companyId = curext();
        }

        changecompany (companyId)
        {
            permission = new ExecutePermission();
            permission.assert();
            taxcode             = conNull();
            totalTDSAmount      = conNull();
            countI              = 0;

            if (!_advancePayment)
            {
                curTransWHTNotCalculatedBaseCur = conPeek(_taxWithholdData, #5);
            }
            curTransWHTNotCalculatedBaseMST = exchangeRateHelper.calculateTransactionToAccounting(conPeek(_taxWithholdData, #4), curTransWHTNotCalculatedBaseCur, true);
            tmpRateOfDeduction  = this.rateOfDeductionForThresholdBasedOnPaym(
                _taxWithholdGroup,
                _transDate,
                _accountNum,
                isVendTransaction,
                curTransWHTNotCalculatedBaseMST,
                conPeek(_taxWithholdData, 8),
                conPeek(_taxWithholdData, 9));
            grossAmount = exchangeRateHelper.calculateTransactionToAccounting(conPeek(_taxWithholdData, #4), conPeek(_taxWithholdData, #5), true);

            while select taxWithholdDesignerTable order by id
                where taxWithholdDesignerTable.TaxWithholdGroup == _taxWithholdGroup
            {
                countI++;
                insertTaxWithhold                   = conNull();
                taxWithholdAmount                   = 0;
                taxWithholdCalculationAmount        = 0;
                totalAmountOrigin                   = 0;
                amount                              = 0;
                uncalculatedTransAmountMST          = 0;
                overLookThreshold                   = false;
                exceptionalThreshold                = false;
                thresholdFromDate                   = dateNull();
                thresholdToDate                     = dateNull();
                isTaxAmountSet                      = false;

                select firstonly taxWithholdTableLoc
                    where taxWithholdTableLoc.TaxWithholdCode == taxWithholdDesignerTable.TaxWithholdCode;

                taxWithholdType = taxWithholdTableLoc.TaxType_IN == TaxWithholdCodeType_IN::TDS ? TaxWithholdType_IN::TDS : TaxWithholdType_IN::TCS;

                select firstonly TaxWithholdCode, Exempt_IN, OverlookTax_IN, RecId from taxWithholdGroupDataLoc
                    where taxWithholdGroupDataLoc.TaxWithholdCode    == taxWithholdTableLoc.TaxWithholdCode
                       && taxWithholdGroupDataLoc.TaxWithholdGroup   == _taxWithholdGroup;

                if (taxWithholdTableLoc.ApplyThreshold_IN)
                {
                    taxWithholdThresholdHanlder = this.getTaxWithholdThresholdHandler(
                                            this.getAccountType(isVendTransaction),
                                            _accountNum,
                                            taxWithholdDesignerTable.TaxWithholdCode,
                                            taxWithholdDesignerTable.TaxWithholdGroup,
                                            _transDate,
                                            curTransWHTNotCalculatedBaseMST,
                                            taxWithholdGroupDataLoc.OverlookTax_IN,
                                            conPeek(_taxWithholdData, 8),
                                            conPeek(_taxWithholdData, 9));
                    taxWithholdThresholdHanlder.parmRateOfDeduction(tmpRateOfDeduction);
                    taxWithholdThresholdHanlder.parmCalcPostedUncalculatedTransMap(calcPostedUncalculatedTransMap);

                    // can not find coresponding tax value record
                    if (taxWithholdThresholdHanlder.getTaxValueData().RecId == 0)
                    {
                        taxcode         = conPoke(taxcode, countI, taxWithholdDesignerTable.TaxWithholdCode);
                        continue;
                    }
                }
                else
                {
                    taxWithholdDataLoc = TaxWithholdData::find(taxWithholdDesignerTable.TaxWithholdCode, _transDate, 0);
                }

                if (!taxWithholdTableLoc.ApplyThreshold_IN)
                {
                    if (!_recoverable)
                    {
                        select firstonly TaxWithholdComponent, FromDate, ToDate, ExceptionThreshold, Threshold, RecId, PerTransThreshhold
                            from taxWithholdThresholdLimit
                            where taxWithholdThresholdLimit.TaxWithholdComponent      == taxWithholdTableLoc.TaxWithholdComponent_IN
                                && (!taxWithholdThresholdLimit.FromDate
                                || (taxWithholdThresholdLimit.FromDate                 <= _transDate
                                && taxWithholdThresholdLimit.ToDate                    >= _transDate));

                        thresholdFromDate = taxWithholdThresholdLimit.FromDate;
                        thresholdToDate   = taxWithholdThresholdLimit.ToDate;

                        if (taxWithholdGroupDataLoc.RecId)
                        {
                            overLookThreshold = taxWithholdGroupDataLoc.OverlookTax_IN;
                        }

                        // Checks if the posted withhold transactions has already exceeded threshold.
                        select firstOnly TaxWithholdCalculated, RecId from taxWithholdTransTaxCalculated
                           where (taxWithholdTransTaxCalculated.VendAccount      == _accountNum
                              || taxWithholdTransTaxCalculated.CustAccount       == _accountNum)
                              && taxWithholdTransTaxCalculated.TaxWithholdGroup  == _taxWithholdGroup
                              && taxWithholdTransTaxCalculated.TaxWithholdCode   == taxWithholdTableLoc.TaxWithholdCode
                              && taxWithholdTransTaxCalculated.TransDate         >= thresholdFromDate
                              && taxWithholdTransTaxCalculated.TransDate         <= thresholdToDate
                              && taxWithholdTransTaxCalculated.TaxWithholdCalculated
                              && !taxWithholdTransTaxCalculated.OverlookThreshold;

                        if (_isOnJewelry)
                        {
                            [valueForOneShotThresholdCompare, uncalculatedTransAmountMST] = this.getValueForPerTransThresholdCompare(taxWithholdTableLoc,
                                                                                                                _transDate,
                                                                                                                _accountNum,
                                                                                                                _taxWithholdGroup,
                                                                                                                exchangeRateHelper,
                                                                                                                conPeek(_taxWithholdData, #4),
                                                                                                                conPeek(_taxWithholdData, #6),
                                                                                                                refTableId,
                                                                                                                _isByCash);
                        }
                        else
                        {
                            if (!taxWithholdTransTaxCalculated.TaxWithholdCalculated)
                            {
                                [exceptionalThreshold, overLookThreshold, taxWithholdThreshold, uncalculatedTransAmountMST] = this.getGrossAmountConsideringThreshold(taxWithholdTableLoc,
                                                                                                                    _transDate,
                                                                                                                    _accountNum,
                                                                                                                    _taxWithholdGroup,
                                                                                                                    exchangeRateHelper,
                                                                                                                    conPeek(_taxWithholdData, #4),
                                                                                                                    conPeek(_taxWithholdData, #6),
                                                                                                                    refTableId);
                            }
                        }
                    }

                    taxWithholdValue = taxWithholdDataLoc.getTaxWithHoldValue_IN(_accountNum, isVendTransaction);
                }
                else
                {
                    taxValueData                = taxWithholdThresholdHanlder.getTaxValueData();
                    if (taxValueData.IsCalculate)
                    {
                        taxWithholdValue            = taxValueData.TaxValue;
                    }
                    else
                    {
                        taxWithholdValue            = 0;
                    }
                }

                if (
                     (!_isOnJewelry && (!taxWithholdThresholdLimit.RecId || exceptionalThreshold || overLookThreshold|| taxWithholdThresholdLimit.Threshold < taxWithholdThreshold || (taxWithholdTransTaxCalculated.TaxWithholdCalculated)))
                   ||(_isOnJewelry && ValueForOneShotThresholdCompare > taxWithholdThresholdLimit.PerTransThreshhold)
                   || taxWithholdTableLoc.ApplyThreshold_IN
                   )
                {
                    switch (taxWithholdDesignerTable.Basis)
                    {
                        case TaxWithholdBasis_IN::GrossAmount:
                            formula         = enum2str(taxWithholdDesignerTable.Basis) + taxWithholdDesignerTable.Expression;
                            taxWithholdCode = "@SYS11818";
                            if (!taxWithholdTableLoc.ApplyThreshold_IN)
                            {
                                amount = uncalculatedTransAmountMST + grossAmount;
                            }
                            else
                            {
                                if (taxValueData.IsCalculate)
                                {
                                    amount = grossAmount + taxWithholdThresholdHanlder.getUncalculatedTransAmountMST();

                                    if (isThresholdBasedOnPaymentOnly
                                        && taxWithholdThresholdHanlder.parmWHTThresholdSourceLineImpl()
                                        && !taxWithholdThresholdHanlder.parmWHTThresholdSourceLineImpl().parmIsProgressiveApplicable())
                                    {
                                        [isTaxAmountSet, convertedAmount] = [false, amount];
                                    }
                                    else
                                    {
                                        // Apply the progressive values
                                        if (taxWithholdThresholdHanlder.isTaxInclusiveAndProgressive())
                                        {
                                            // Get current transaction origin amount which include tax.
                                            amount = abs(curTransWHTNotCalculatedBaseMST) + taxWithholdThresholdHanlder.getUncalculatedTransAmountMST() ;
                                            [isTaxAmountSet, convertedAmount, amount] = taxWithholdThresholdHanlder.getProgressiveTaxAmountAndAmountOrigin(amount, true);
                                        }
                                        else
                                        {
                                            [isTaxAmountSet, convertedAmount] = taxWithholdThresholdHanlder.getProgressiveTaxAmount(amount);
                                        }
                                    }
                                }
                                else
                                {
                                    amount = grossAmount;
                                }
                            }
                            totalAmountOrigin   += abs(amount);
                            formula             = this.calculateAmount(formula, amount, taxWithholdCode);

                            if (taxWithholdGroupDataLoc.Exempt_IN)
                            {
                                formula = #Zero;
                            }
                            else
                            {
                                for (countJ = 1; countJ <= conLen(taxcode); countJ++)
                                {
                                    checkTaxCode = strScan(formula, strFmt("[%1]", conPeek(taxcode, countJ)), 1, strLen(formula));
                                    if (checkTaxCode)
                                    {
                                        taxWithhold         = this.calculateTaxWithholdAmount(formula,
                                                                                                taxcode,
                                                                                                countJ,
                                                                                                taxWithholdThresholdLimit.Threshold,
                                                                                                totalTDSAmount,
                                                                                                _accountNum,
                                                                                                _taxWithholdGroup,
                                                                                                taxWithholdTableLoc.TaxWithholdCode,
                                                                                                _taxWithholdData,
                                                                                                _transDate);

                                        formula             = conPeek(taxWithhold, 1);
                                        totalAmountOrigin   += abs(conPeek(taxWithhold, #2));
                                    }
                                }
                            }
                            break;

                        case TaxWithholdBasis_IN::ExclGrossAmount:
                            if (taxWithholdGroupDataLoc.Exempt_IN)
                            {
                                formula = #Zero;
                            }
                            else
                            {
                                if (taxWithholdTableLoc.ApplyThreshold_IN)
                                {
                                    if (taxValueData.IsCalculate)
                                    {
                                        uncalculatedTransAmountMST = taxWithholdThresholdHanlder.getUncalculatedTransAmountMST();
                                    }
                                }

                                formula     = strDel(taxWithholdDesignerTable.Expression,1,1);

                                for (countJ = 1; countJ <= conLen(taxcode); countJ++)
                                {
                                    checkTaxCode = strScan(formula, strFmt("[%1]", conPeek(taxcode, countJ)), 1, strLen(formula));
                                    if (checkTaxCode)
                                    {
                                        taxWithhold         = this.calculateTaxWithholdAmount(formula,
                                                                                                taxcode,
                                                                                                countJ,
                                                                                                taxWithholdThresholdLimit.Threshold,
                                                                                                totalTDSAmount,
                                                                                                _accountNum,
                                                                                                _taxWithholdGroup,
                                                                                                taxWithholdTableLoc.TaxWithholdCode,
                                                                                                _taxWithholdData,
                                                                                                _transDate);
                                        formula             = conPeek(taxWithhold, 1);
                                        totalAmountOrigin   += abs(conPeek(taxWithhold, #2));
                                    }
                                }

                                if (taxWithholdTableLoc.ApplyThreshold_IN)
                                {
                                    //update totalAmountOrigin and formula when there is uncalculatedTransAmountMST(including posted and unposted)
                                    totalAmountOrigin += uncalculatedTransAmountMST;
                                    if (uncalculatedTransAmountMST)
                                    {
                                        formula = formula + "+" + num2str(any2real(uncalculatedTransAmountMST), 1, #4, 1, 0);
                                    }
                                }
                            }
                            break;

                        default:
                            break;
                    }//end of switch

                    if (isTaxAmountSet)
                    {
                        convertedAmount     = convertedAmount / 100;
                        taxWithholdAmount   = this.roundOffTaxWithholdAmount(abs(CurrencyExchangeHelper::amount(convertedAmount)), taxWithholdTableLoc);
                    }
                    else
                    {
                        taxAmount = formula ? strFmt("%1 %2 %3 %4 %5",num2char(#fourZero),formula,num2char(#fourOne), num2char(#fourTwo),
                                num2str(taxWithholdValue,#8, #5, 1, 1)) : num2char(#fourEight);

                        if (formula)
                        {
                            // Input to evalbuf has been validated
                            // Only limited safe elements are allowed
                            // BP deviation documented
                            convertedAmount     = TaxWithholdCalculation_IN::evaluate(taxAmount);
                            convertedAmount     = convertedAmount / 100;
                            taxWithholdAmount   = this.roundOffTaxWithholdAmount(abs(CurrencyExchangeHelper::amount(convertedAmount)),
                                                                            taxWithholdTableLoc);
                        }
                    }
                }
                totalTDSAmount  = conPoke(totalTDSAmount, countI, taxWithholdAmount);
                taxcode         = conPoke(taxcode, countI, taxWithholdDesignerTable.TaxWithholdCode);

                // for multiple currency
                taxWithholdAmountCur = exchangeRateHelper.calculateAccountingToTransaction(conPeek(_taxWithholdData, #4), taxWithholdAmount, true);
                this.roundOffTaxWithholdAmount(taxWithholdAmountCur, taxWithholdTableLoc);

                taxWithholdAmountOriginCur = exchangeRateHelper.calculateAccountingToTransaction(conPeek(_taxWithholdData, #4), totalAmountOrigin, true);

                if (!amountOrginCalculated  && taxWithholdAmount
                    && conPeek(_taxWithholdData, #6) != TaxModuleType::SalesInvoice
                    && conPeek(_taxWithholdData, #6) != TaxModuleType::FreeTxtInvoice
                    && conPeek(_taxWithholdData, #6) != TaxModuleType::PurchInvoice)
                {
                    transAmountOrigin       = taxWithholdAmountOriginCur;
                    amountOrginCalculated   = true;
                }

                if (!amountOrginCalculated  && taxWithholdAmount
                    && ((conPeek(_taxWithholdData, #6)  == TaxModuleType::SalesInvoice)
                    || (conPeek(_taxWithholdData, #6)   == TaxModuleType::FreeTxtInvoice)
                    || (conPeek(_taxWithholdData, #6)   == TaxModuleType::PurchInvoice)))
                {
                    transAmountOrigin       = taxWithholdAmountOriginCur;
                    amountOrginCalculated   = true;
                }

                boolean isForeign;

                if (isVendTransaction)
                {
                    isForeign = Ledger::accountingCurrency() != conPeek(_taxWithholdData, #4);
                }

                if (isVendTransaction && (VendTable::find(_accountNum).isForeign() || isForeign)
                    && TaxWithholdGroupHeading::find(_taxWithholdGroup).TaxType_IN == TaxWithholdCodeType_IN::TDS
                    && (!TaxTDSExchRateByDocumentDateFlight::instance().isEnabled()
                        || ledgerExtensionIN::findByLedger(Ledger::current()).TDSImportExchangeRateType))
                {
                    //When it is a foreign Vendor and TDS is applied, then use TT buying rate type for currency conversion
                    taxWithholdMST = TaxExchangeRateHelper::tdsMSTAmount_IN(taxWithholdAmountCur, conPeek(_taxWithholdData, #4), _transDate);
                    amountOriginMST = TaxExchangeRateHelper::tdsMSTAmount_IN(taxWithholdAmountOriginCur, conPeek(_taxWithholdData, #4), _transDate);
                }
                else
                {
                    taxWithholdMST = exchangeRateHelper.calculateTransactionToAccounting(conPeek(_taxWithholdData, #4), taxWithholdAmountCur, true);
                    amountOriginMST = exchangeRateHelper.calculateTransactionToAccounting(conPeek(_taxWithholdData, #4), taxWithholdAmountOriginCur, true);
                }
                _custVendInfo = conPoke(_custVendInfo, #1, taxWithholdTableLoc.TaxType_IN == TaxWithholdCodeType_IN::TDS ? NoYes::Yes : NoYes::No);
                _custVendInfo = conPoke(_custVendInfo, #2, taxWithholdTableLoc.TaxType_IN == TaxWithholdCodeType_IN::TCS ? NoYes::Yes : NoYes::No);
                _custVendInfo = conPoke(_custVendInfo, #3, taxWithholdType);
                _custVendInfo = conPoke(_custVendInfo, #4, taxWithholdTableLoc.TaxWithholdComponent_IN);
                _custVendInfo = conPoke(_custVendInfo, #5, TaxWithholdComponentTable_IN::find(taxWithholdTableLoc.TaxWithholdComponent_IN).TaxWithholdComponentGroup);
                _custVendInfo = conPoke(_custVendInfo, #6, taxWithholdTableLoc.DataAreaId);
                _custVendInfo = conPoke(_custVendInfo, #7, _accountNum);

                if (!_isOnJewelry)
                {
                    isTaxCalculated = !(taxWithholdThresholdLimit.RecId && taxWithholdThresholdLimit.Threshold >= taxWithholdThreshold) || taxWithholdTransTaxCalculated.TaxWithholdCalculated;
                }
                else
                {
                    isTaxCalculated = ValueForOneShotThresholdCompare > taxWithholdThresholdLimit.PerTransThreshhold;
                }

                this.insertIntoTmpWorkTrans(_taxWithholdGroup,
                                            taxWithholdDesignerTable.TaxWithholdCode,
                                            taxWithholdValue,
                                            _taxWithholdData,
                                            taxWithholdAmountOriginCur,
                                            amountOriginMST,
                                            taxWithholdAmountCur,
                                            taxWithholdMST,
                                            _custVendInfo,
                                            taxWithholdGroupDataLoc.Exempt_IN,
                                            _accountType,
                                            _offsetAccountType,
                                            _amountCurDebit,
                                            _amountCurCredit,
                                            isTaxCalculated,
                                            _transDate,
                                            _advancePayment,
                                            _cpOrigRefRecId);
                if (taxWithholdTableLoc.ApplyThreshold_IN)
                {
                    this.updateTmpWorkTransByTaxValueData(taxWithholdThresholdHanlder);
                }
                else
                {
                    taxWithholdWorkTrans.IsPartOfTurnOver = true;
                    taxWithholdWorkTrans.update();
                }

                select firstonly crossCompany AdjustedTaxWithholdAmount,RecId from taxWithholdWorkRegulation
                        where taxWithholdWorkRegulation.TaxWithholdCode == taxWithholdTableLoc.TaxWithholdCode
                           && taxWithholdWorkRegulation.SourceTableId   == refTableId
                           && taxWithholdWorkRegulation.SourceRecId     == refRecId
                           && taxWithholdWorkRegulation.dataAreaId      == paymcompanyId;

                if (taxWithholdWorkRegulation.RecId)
                {
                    taxWithholdAmountCur = CurrencyExchangeHelper::amount(taxWithholdWorkRegulation.AdjustedTaxWithholdAmount);
                    taxWithholdWorkTrans.TaxAutogenerated = NoYes::No;
                    taxWithholdWorkTrans.SourceRegulateAmountCur = taxWithholdAmountCur * sign(taxWithholdWorkTrans.SourceRegulateAmountCur);
                    taxWithholdWorkTrans.update();
                }

                totalTaxWithholdCalculatedCur += taxWithholdAmountCur;
            }// end of while loop

            sourceDocumentRecIdList = conNull();
            sourceDocumentTaxLine = 0;
            return abs(totalTaxWithholdCalculatedCur);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxWithholdAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax withhold amount.
    /// </summary>
    /// <returns>
    /// The total tax withhold amount.
    /// </returns>
    public TaxAmountCur totalTaxWithholdAmount()
    {
        select sum(SourceRegulateAmountCur)
            from taxWithholdWorkTrans;

        return taxWithholdWorkTrans.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxWithholdTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the TaxWithholdCalculated and OverlookThreshold fields of TaxWithholdTrans_IN table.
    /// </summary>
    /// <param name="_tableId">
    /// The sourceTableId.
    /// </param>
    /// <param name="_recId">
    /// The sourcetable recId.
    /// </param>
    /// <param name="_taxWithholdGroup">
    /// The TaxWithholdGroup value.
    /// </param>
    /// <param name="_taxWithholdCode">
    /// The TaxWithholdCode value.
    /// </param>
    public void  updateTaxWithholdTrans(RefTableId         _tableId,
                                        RefRecId           _recId,
                                        TaxWithholdGroup   _taxWithholdGroup,
                                        TaxWithholdCode    _taxWithholdCode)
    {
        SpecTrans               specTrans;
        VendTransOpen           vendTransOpen;
        VendTrans               vendTrans;
        TaxWithholdTrans_IN     taxWithholdTransLoc;
        CustTransOpen           custTransOpen;
        CustTrans               custTrans;
        Voucher                 voucherLoc;

        while select SpecRecId, SpecTableId, RefRecId, RefTableId from specTrans
            where specTrans.SpecRecId   == _recId
               && specTrans.SpecTableId == _tableId
        {
            select  firstonly RecId, TableId, RefRecId, AccountNum, TransDate from vendTransOpen
                where vendTransOpen.RecId         == specTrans.RefRecId
                   && vendTransOpen.TableId       == specTrans.RefTableId;

            select firstonly RecId, AccountNum, TransDate, Voucher from vendTrans
                where vendTrans.RecId             == vendTransOpen.RefRecId
                   && vendTrans.AccountNum        == vendTransOpen.AccountNum
                   && vendTrans.TransDate         == vendTransOpen.TransDate;

            select  firstonly RecId, TableId, RefRecId, AccountNum, TransDate from custTransOpen
                where custTransOpen.RecId         == specTrans.RefRecId
                   && custTransOpen.TableId       == specTrans.RefTableId;

            select firstonly RecId, AccountNum, TransDate, Voucher from custTrans
                where custTrans.RecId             == custTransOpen.RefRecId
                   && custTrans.AccountNum        == custTransOpen.AccountNum
                   && custTrans.TransDate         == custTransOpen.TransDate;

            voucherLoc    = custTrans.Voucher      ?  custTrans.Voucher   : vendTrans.Voucher;

            update_recordset taxWithholdTransLoc
                setting OverlookThreshold       = true,
                        TaxWithholdCalculated   = true
                where taxWithholdTransLoc.Voucher           == voucherLoc
                   && taxWithholdTransLoc.TaxWithholdGroup  == _taxWithholdGroup
                   && taxWithholdTransLoc.TaxWithholdCode   == _taxWithholdCode;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxWithholdUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Delete all tax withhold uncommitted records for the document and insert
    ///   the new TaxWithhold Uncommitted records.
    /// </summary>
    public void updateTaxWithholdUncommitted()
    {
        if (useTaxWithholdUncommitted)
        {
            TaxWithholdUncommitted_IN::updateTaxUncommittedWHT(this);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxWithholdWorkRegulation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates TaxWithholdWorkRegulation_IN table with the destination tableId and recId.
    /// </summary>
    /// <param name="_sourceTable">
    /// The SourceTable buffer.
    /// </param>
    /// <param name="_destinationTable">
    /// The Destination table buffer.
    /// </param>
    public void updateTaxWithholdWorkRegulation(Common _sourceTable, Common _destinationTable)
    {
        TaxWithholdWorkRegulation_IN    taxWithholdWorkRegulation;

        ttsbegin;
        update_recordset taxWithholdWorkRegulation
            setting SourceTableId   = _destinationTable.TableId,
                    SourceRecId     = _destinationTable.RecId
            where taxWithholdWorkRegulation.SourceTableId   == _sourceTable.TableId
               && taxWithholdWorkRegulation.SourceRecId     == _sourceTable.RecId;
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTmpWorkTransByTaxValueData</Name>
				<Source><![CDATA[
    private void updateTmpWorkTransByTaxValueData(TaxWithholdThresholdHandler_IN _taxWithholdThresholdHandler)
    {
        TaxValueData_IN taxValudData;
        ThresholdSections_IN            thresholdSectionParent;
        ConcessionCertificateDetails_IN ConcessionCertificateDetailsLoc;

        taxValudData = _taxWithholdThresholdHandler.getTaxValueData();
        taxWithholdWorkTrans.OverlookThreshold      = taxValudData.IsOverLook;
        taxWithholdWorkTrans.IsTaxCalculated        = taxValudData.IsCalculate;
        taxWithholdWorkTrans.Reason                 = taxValudData.ReasonCode;
        taxWithholdWorkTrans.IsPartOfTurnOver       = taxValudData.IsPartOfTurnOver;
        taxWithholdWorkTrans.CalcUncalcPostedTrans  = taxValudData.CalcUncalcPostedTrans;

        thresholdSectionParent = _taxWithholdThresholdHandler.getTargetSectionParent();
        taxWithholdWorkTrans.ThresholdValidFrom     = thresholdSectionParent.ValidFrom;
        taxWithholdWorkTrans.ThresholdValidTo       = thresholdSectionParent.ValidTo;

        ConcessionCertificateDetailsLoc                     = _taxWithholdThresholdHandler.getConcessionCertificateDetails();
        taxWithholdWorkTrans.TurnoverThreshold              = ConcessionCertificateDetailsLoc.TurnoverThreshold;
        taxWithholdWorkTrans.ConcessionCertificateNumber    = ConcessionCertificateDetailsLoc.CertificateNumber;

        taxWithholdWorkTrans.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSubLedgerJournalLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the current transaction to calculate supports the <c>SubLedgerDistributions</c>
    ///    or <c>SubLedgerJournalLines</c> records. By default, this base implementation is that they do not
    ///    support them. As the individual transaction support the sub-ledger, they must override this method
    ///    and return true.
    /// </summary>
    /// <returns>
    ///    true if the current transaction to calculate supports the <c>SubLedgerDistributions</c> or
    ///    <c>SubLedgerJournalLines</c> records; otherwise, false.
    /// </returns>
    public boolean useSubLedgerJournalLines()
    {
        boolean ret = true;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useTaxWithHoldUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the <c>Tax</c> class should use the <c>TaxWithholdUncommitted_IN</c> table.
    /// </summary>
    /// <returns>
    ///    true if the <c>taxableDocument</c> class should use the <c>TaxWithholdUncommitted_IN</c> table; otherwise, false.
    /// </returns>
    public boolean useTaxWithHoldUncommitted()
    {
        boolean ret = true;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkRecoverableAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the withhold taxes calculated on journal are recoverable.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The LedgerJournalTrans buffer.
    /// </param>
    /// <returns>
    /// True, if the withhold taxes calculated on journal are recoverable otherwise, false.
    /// </returns>
    public static boolean  checkRecoverableAccount(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();

        if (ledgerJournalTransTaxExt.tdsGroup)
        {
            if ((_ledgerJournalTrans.AccountType    == LedgerJournalACType::Cust   &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank   && _ledgerJournalTrans.AmountCurCredit  > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank   &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust   && _ledgerJournalTrans.AmountCurDebit   > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust   &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger && _ledgerJournalTrans.AmountCurDebit   > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust   && _ledgerJournalTrans.AmountCurCredit  > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank   &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger && _ledgerJournalTrans.AmountCurDebit   > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank   && _ledgerJournalTrans.AmountCurCredit  > 0))
            {
                return true;
            }
        }
        if (ledgerJournalTransTaxExt.tcsGroup)
        {
            if ((_ledgerJournalTrans.AccountType    == LedgerJournalACType::Ledger &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend   && _ledgerJournalTrans.AmountCurDebit   > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend   &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger && _ledgerJournalTrans.AmountCurCredit  > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank   &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend   && _ledgerJournalTrans.AmountCurCredit  > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend   &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank   && _ledgerJournalTrans.AmountCurDebit   > 0))
            {
                return true;
            }
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>evaluate</Name>
				<Source><![CDATA[
    /// <summary>
    /// The evaluate function.
    /// </summary>
    /// <param name="_expression">
    /// The expression information.
    /// </param>
    /// <returns>
    /// The result of the expression.
    /// </returns>
    public static real evaluate(str _expression)
    {
        return str2Num(tax::evaluate_IN(_expression));
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLedgerInterCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the LedgerInterCompany record.
    /// </summary>
    /// <param name="_companyToFindIn">
    /// The CompanyId of intercompany.
    /// </param>
    /// <param name="_companyRelated">
    /// The related companyId.
    /// </param>
    /// <returns>
    /// LedgerInterCompany record.
    /// </returns>
    public static LedgerInterCompany findLedgerInterCompany(CompanyId _companyToFindIn,
                                                            CompanyId _companyRelated)
    {
        LedgerInterCompany interCompany;

        interCompany = LedgerInterCompany::findCompanyPair(_companyToFindIn, _companyRelated);

        if (interCompany.RecId == 0)
        {
            throw error(strFmt("@SYS113857", _companyToFindIn, _companyRelated));
        }

        return interCompany;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVendorInformation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    sets the container with values from either open transactions or ledgerJournalTrans
    /// </summary>
    /// <param name="_specTrans">
    ///    The <c>_specTrans</c> open transactions buffer used to set container.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>_ledgerJournalTrans</c> journal lines buffer used to set container.
    /// </param>
    /// <param name="_paymentCompany">
    ///    The <c>_paymentCompany</c> payment company.
    /// </param>
    /// <returns>
    ///    Returns container with values set from specTrans buffer or ledgerJournalTrans buffer.
    /// </returns>
    public static container getVendorInformation(
        SpecTrans           _specTrans,
        LedgerJournalTrans _ledgerJournalTrans = null,
        CompanyId           _paymentCompany = '')
    {
        VendTable           vendTableLoc;
        VendTrans           vendTransLoc;
        VendTransOpen       vendTransOpenLoc;
        CustTable           custTableLoc;
        CustTrans           custTransLoc;
        CustTransOpen       custTransOpenLoc;
        container           custVendInformation = conNull();
        TaxWithholdGroup    taxWithholdGroup;
        CustVendAC          accountNumber;
        TaxInformationCustTable_IN      taxInformationCustTableLoc;
        TaxInformationVendTable_IN      taxInformationVendTableLoc;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();

        container setLocalData(AccountNum  _accountNum, TaxWithholdGroup _taxWithholdGroup, boolean     _isTaxWithholdCalculate,
                               AmountCur   _amount    , CompanyId        _invoiceCompany  , CompanyId   _paymentCompanyLoc,
                               Voucher     _voucher   , RecId            _recId)
        {
            container custVendInfo;

            custVendInfo += _accountNum;
            custVendInfo += _taxWithholdGroup;
            custVendInfo += _isTaxWithholdCalculate;
            custVendInfo += _amount;
            custVendInfo += _invoiceCompany;
            custVendInfo += _paymentCompanyLoc;
            custVendInfo += _voucher;
            custVendInfo += _recId;
            return custVendInfo;
        }

        if (_specTrans)
        {
            switch (_specTrans.RefTableId)
            {
                case tableNum(VendTransOpen):
                    changecompany(_specTrans.RefCompany)
                    {
                        select firstonly RefRecId from vendTransOpenLoc
                            where vendTransOpenLoc.RecId    == _specTrans.RefRecId;

                        select firstonly AccountNum from vendTransLoc
                            where vendTransLoc.RecId        == vendTransOpenLoc.RefRecId;

                        select firstonly RecId from vendTableLoc
                            where vendTableLoc.AccountNum   == vendTransLoc.AccountNum;

                        if (_specTrans.RefCompany == _specTrans.SpecCompany && _specTrans.SpecCompany == _ledgerJournalTrans.Company)
                        {
                            taxWithholdGroup = ledgerJournalTransTaxExt.tdsGroup ? ledgerJournalTransTaxExt.tdsGroup  : ledgerJournalTransTaxExt.tcsGroup;
                        }
                        else
                        {
                             taxInformationVendTableLoc = vendTableLoc.getTaxInformationVendTable_IN();
                             taxWithholdGroup = taxInformationVendTableLoc.tdsGroup ? taxInformationVendTableLoc.tdsGroup : taxInformationVendTableLoc.tcsGroup;
                        }

                        custVendInformation = setLocalData(vendTableLoc.AccountNum, taxWithholdGroup,vendTableLoc.TaxWithholdCalculate,
                                                           _specTrans.Balance01 * -1, _specTrans.RefCompany,
                                                           _ledgerJournalTrans.OffsetCompany ? _ledgerJournalTrans.OffsetCompany : _specTrans.SpecCompany,
                                                           vendTransLoc.Voucher, vendTransLoc.RecId);
                    }
                break;

                case tableNum(CustTransOpen):
                    changecompany(_specTrans.RefCompany)
                    {
                        select firstonly RefRecId from custTransOpenLoc
                            where custTransOpenLoc.RecId    == _specTrans.RefRecId;

                        select firstonly AccountNum from custTransLoc
                            where custTransLoc.RecId        == custTransOpenLoc.RefRecId;

                        select firstonly RecId from custTableLoc
                            where custTableLoc.AccountNum   == custTransLoc.AccountNum;

                        if (_specTrans.RefCompany == _specTrans.SpecCompany && _specTrans.SpecCompany == _ledgerJournalTrans.Company)
                        {
                            taxWithholdGroup = ledgerJournalTransTaxExt.tdsGroup ? ledgerJournalTransTaxExt.tdsGroup  : ledgerJournalTransTaxExt.tcsGroup;
                        }
                        else
                        {
                             taxInformationCustTableLoc = custTableLoc.getTaxInformationCustTable_IN();
                             taxWithholdGroup = taxInformationCustTableLoc.tdsGroup ? taxInformationCustTableLoc.tdsGroup : taxInformationCustTableLoc.tcsGroup;
                        }
                        custVendInformation = setLocalData(custTableLoc.AccountNum, taxWithholdGroup, custTableLoc.TaxWithholdCalculate_IN,
                                                           _specTrans.Balance01, _specTrans.RefCompany,
                                                           _ledgerJournalTrans.OffsetCompany ? _ledgerJournalTrans.OffsetCompany : _specTrans.SpecCompany,
                                                           custTransLoc.Voucher, custTransLoc.RecId);
                    }
                    break;

                default:
                break;
            }
        }
        else
        {
            taxWithholdGroup = ledgerJournalTransTaxExt.tdsGroup ? ledgerJournalTransTaxExt.tdsGroup  : ledgerJournalTransTaxExt.tcsGroup;
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend || _ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
            {
                accountNumber = _ledgerJournalTrans.parmAccount();
            }
            else
            {
                accountNumber = _ledgerJournalTrans.parmOffsetAccount();
            }

            custVendInformation = setLocalData(accountNumber, taxWithholdGroup, true,
                                              (_ledgerJournalTrans.AmountCurDebit + _ledgerJournalTrans.AmountCurCredit),
                                              _ledgerJournalTrans.Company ,
                                              _paymentCompany,
                                               _ledgerJournalTrans.Voucher, 0);
        }

        return custVendInformation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForSourceType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new instance of the <c>TaxWithholdCalculation_IN</c> class for source type.
    /// </summary>
    /// <param name="_sourceType">
    /// The source type.
    /// </param>
    /// <param name="_initializationClass">
    /// The initialization class.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxWithholdCalculation_IN</c> class.
    /// </returns>
    public static TaxWithholdCalculation_IN newForSourceType(
        TaxSourceType _sourceType,
        Object        _initializationClass)
    {
        TaxWithholdJournal_IN         taxWithholdJournal;
        TaxWithholdCalcPurch_IN       taxWithholdCalcPurch;
        TaxWithholdCalcFreeInvoice_IN taxWithholdCalcFreeInvoice;

        switch (_sourceType)
        {
            case TaxSourceType::PurchaseOrder :
                taxWithholdCalcPurch = new TaxWithholdCalcPurch_IN(_initializationClass, false, false, false);
                return taxWithholdCalcPurch;
            case TaxSourceType::FreeTextInvoice :
                taxWithholdCalcFreeInvoice = new TaxWithholdCalcFreeInvoice_IN(_initializationClass, false, false, false);
                return taxWithholdCalcFreeInvoice;
            case TaxSourceType::Journals :
                taxWithholdJournal = new TaxWithholdJournal_IN(_initializationClass, false, false, false);
                return taxWithholdJournal;
            default:
                var eventHandlerResult = new EventHandlerResult();
                TaxWithholdCalculation_IN::newForSourceTypeDelegate(_sourceType, _initializationClass, eventHandlerResult);

                if (eventHandlerResult.hasResult())
                {
                    return eventHandlerResult.result();
                }
                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForSourceTypeWithTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new instance of the <c>TaxWithholdCalculation_IN</c> class for source type with tax uncommitted.
    /// </summary>
    /// <param name="_sourceType">
    /// The source type.
    /// </param>
    /// <param name="_initializationClass">
    /// The initialization class.
    /// </param>
    /// <param name="_loadTaxUncommitted">
    /// True if the uncommitted will be loaded.
    /// </param>
    /// <param name="_loadTaxTrans">
    /// True if the tax transaction will be loaded.
    /// </param>
    /// <param name="_maintainExistingTaxUncommitted">
    /// True if the uncommitted existing tax should be maintained.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxWithholdCalculation_IN</c> class.
    /// </returns>
    public static TaxWithholdCalculation_IN newForSourceTypeWithTaxUncommitted(
        TaxSourceType _sourceType,
        Object        _initializationClass,
        boolean       _loadTaxUncommitted,
        boolean       _loadTaxTrans,
        boolean       _maintainExistingTaxUncommitted = false)
    {
        TaxWithholdJournal_IN         taxWithholdJournal;
        TaxWithholdCalcPurch_IN       taxWithholdCalcPurch;
        TaxWithholdCalcFreeInvoice_IN taxWithholdCalcFreeInvoice;
        TaxWithholdCalcProjectAdvancedJournal_IN taxWithholdCalcProjAdvancedJournal;

        switch (_sourceType)
        {
            case TaxSourceType::PurchaseOrder :
                taxWithholdCalcPurch = new TaxWithholdCalcPurch_IN(_initializationClass, true, _loadTaxUncommitted, _loadTaxTrans, false, _maintainExistingTaxUncommitted);
                return taxWithholdCalcPurch;
            case TaxSourceType::FreeTextInvoice :
                taxWithholdCalcFreeInvoice = new TaxWithholdCalcFreeInvoice_IN(_initializationClass, true, _loadTaxUncommitted, _loadTaxTrans, false, _maintainExistingTaxUncommitted);
                return taxWithholdCalcFreeInvoice;
            case TaxSourceType::Journals :
                taxWithholdJournal = new TaxWithholdJournal_IN(_initializationClass, true, _loadTaxUncommitted, _loadTaxTrans, false, _maintainExistingTaxUncommitted);
                return taxWithholdJournal;
            case TaxSourceType::ProjAdvancedJournal :
                taxWithholdCalcProjAdvancedJournal = new TaxWithholdCalcProjectAdvancedJournal_IN(_initializationClass, true, _loadTaxUncommitted, _loadTaxTrans, false, _maintainExistingTaxUncommitted);
                return taxWithholdCalcProjAdvancedJournal;
            default:
                var eventHandlerResult = new EventHandlerResult();
                TaxWithholdCalculation_IN::newForSourceTypeWithTaxUncommittedDelegate(
                    _sourceType,
                    _initializationClass,
                    _loadTaxUncommitted,
                    _loadTaxTrans,
                    _maintainExistingTaxUncommitted,
                    eventHandlerResult);

                if (eventHandlerResult.hasResult())
                {
                    return eventHandlerResult.result();
                }
                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDirection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the sign of the TaxAmount.
    /// </summary>
    /// <param name="_amount">
    /// The AmountCur.
    /// </param>
    /// <param name="_accountType">
    /// The AccountType.
    /// </param>
    /// <param name="_offsetAccountType">
    /// The offsetAccountType.
    /// </param>
    /// <param name="_amountCurDebit">
    /// The AmountCurDebit.
    /// </param>
    /// <param name="_amountCurCredit">
    /// The AmountCurCredit.
    /// </param>
    /// <param name="_taxType">
    /// The TaxWithholdType.
    /// </param>
    /// <param name="_ledgerJournalType">
    /// The LedgerJournalType.
    /// </param>
    /// <param name="_purchTypeCash">
    /// The PurchTypeCash transaction.
    /// </param>
    /// <param name="_settlementType">
    /// The SettlementType.
    /// </param>
    /// <param name="_prepayment">
    /// boolean, if prepayment is marked.
    /// </param>
    /// <returns>
    /// TaxAmount after setting sign.
    /// </returns>
    public static AmountMST setDirection(AmountCur                 _amount,
                                         LedgerJournalACType       _accountType,
                                         LedgerJournalACType       _offsetAccountType,
                                         AmountCur                 _amountCurDebit,
                                         AmountCur                 _amountCurCredit,
                                         TaxWithholdCodeType_IN    _taxType,
                                         LedgerJournalType         _ledgerJournalType = LedgerJournalType::Approval,
                                         boolean                   _purchTypeCash     = false,
                                         SettlementType            _settlementType = SettlementType::None,
                                         boolean                   _prepayment        = false)

    {
        if (_taxType == TaxWithholdCodeType_IN::TCS)
        {
            if ((_accountType    == LedgerJournalACType::Cust    &&  _offsetAccountType == LedgerJournalACType::Ledger    && _amountCurDebit   > 0)
                || (_accountType == LedgerJournalACType::Ledger  &&  _offsetAccountType == LedgerJournalACType::Cust      && _amountCurCredit  > 0)
                || (_accountType == LedgerJournalACType::Ledger  &&  _offsetAccountType == LedgerJournalACType::Cust      && _amountCurDebit   > 0)
                || (_accountType == LedgerJournalACType::Cust    &&  _offsetAccountType == LedgerJournalACType::Ledger    && _amountCurCredit  > 0)
                || (_accountType == LedgerJournalACType::Bank    &&  _offsetAccountType == LedgerJournalACType::Cust      && _amountCurDebit   > 0)
                || (_accountType == LedgerJournalACType::Cust    &&  _offsetAccountType == LedgerJournalACType::Bank      && _amountCurCredit  > 0))
            {
                return -_amount;
            }
        }

        if (_taxType == TaxWithholdCodeType_IN::TDS)
        {
            if ((_accountType    == LedgerJournalACType::Ledger      &&  _offsetAccountType == LedgerJournalACType::Vend        && _amountCurDebit  > 0)
                || (_accountType == LedgerJournalACType::Vend        &&  _offsetAccountType == LedgerJournalACType::Ledger      && _amountCurCredit > 0)
                || (_accountType == LedgerJournalACType::FixedAssets &&  _offsetAccountType == LedgerJournalACType::Vend        && _amountCurDebit  > 0)
                || (_accountType == LedgerJournalACType::Vend        &&  _offsetAccountType == LedgerJournalACType::FixedAssets && _amountCurCredit > 0)
                || (_accountType == LedgerJournalACType::Ledger      &&  _offsetAccountType == LedgerJournalACType::Cust        && _amountCurDebit  > 0)
                || (_accountType == LedgerJournalACType::Cust        &&  _offsetAccountType == LedgerJournalACType::Ledger      && _amountCurCredit > 0)
                || (_accountType == LedgerJournalACType::FixedAssets &&  _offsetAccountType == LedgerJournalACType::Cust        && _amountCurDebit  > 0)
                || (_accountType == LedgerJournalACType::Cust        &&  _offsetAccountType == LedgerJournalACType::FixedAssets && _amountCurCredit > 0)
                || (_accountType == LedgerJournalACType::Cust        &&  _offsetAccountType == LedgerJournalACType::Bank        && _amountCurDebit  > 0)
                || (_accountType == LedgerJournalACType::Vend        &&  _offsetAccountType == LedgerJournalACType::Bank        && _amountCurDebit  > 0)
                || (_accountType == LedgerJournalACType::Bank        &&  _offsetAccountType == LedgerJournalACType::Cust        && _amountCurCredit > 0)
                || (_accountType == LedgerJournalACType::Bank        &&  _offsetAccountType == LedgerJournalACType::Vend        && _amountCurCredit > 0)
                || (_accountType == LedgerJournalACType::Cust        &&  _offsetAccountType == LedgerJournalACType::Bank        && _amountCurDebit  > 0)
                || (_accountType == LedgerJournalACType::Vend        &&  _offsetAccountType == LedgerJournalACType::Bank        && _amountCurDebit  > 0)
                || (_accountType == LedgerJournalACType::Bank        &&  _offsetAccountType == LedgerJournalACType::Cust        && _amountCurCredit > 0)
                || (_accountType == LedgerJournalACType::Bank        &&  _offsetAccountType == LedgerJournalACType::Vend        && _amountCurCredit > 0)
                || (_accountType == LedgerJournalACType::Bank        &&  _offsetAccountType == LedgerJournalACType::Ledger      && _amountCurCredit > 0)
                || (_accountType == LedgerJournalACType::Ledger      &&  _offsetAccountType == LedgerJournalACType::Bank        && _amountCurDebit  > 0)
                || (_accountType == LedgerJournalACType::Vend        &&  _offsetAccountType == LedgerJournalACType::Ledger      && _amountCurDebit  > 0 && _settlementType == SettlementType::SelectedTransact)
                || (_accountType == LedgerJournalACType::Project     &&  _offsetAccountType == LedgerJournalACType::Vend        && _amountCurDebit  > 0)
                || (_accountType == LedgerJournalACType::Vend        &&  _offsetAccountType == LedgerJournalACType::Project     && _amountCurCredit > 0)
                )

            {
                return -_amount;
            }

            if (_accountType        == LedgerJournalACType::Ledger  &&
                _offsetAccountType  == LedgerJournalACType::Vend    &&
                _amountCurCredit    > 0                             &&
                _purchTypeCash)
            {
                return -_amount;
            }

            if (_accountType        == LedgerJournalACType::vend   &&
                _offsetAccountType  == LedgerJournalACType::Ledger &&
                _amountCurDebit     > 0                            &&
                _purchTypeCash)
            {
                return -_amount;
            }
        }

        return _amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLedgerData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets ledger data information.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal transaction.
    /// </param>
    /// <param name="_grossAmount">
    /// The gross amount.
    /// </param>
    /// <returns>
    /// The ledger data.
    /// </returns>
    public static container setLedgerData(LedgerJournalTrans _ledgerJournalTrans,
                                   real               _grossAmount)
    {
        container   taxWithholdData;
        TransTaxInformation transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(_ledgerJournalTrans);
        #define.13(13)

        taxWithholdData = conNull();
        taxWithholdData = conPoke(taxWithholdData, #1, _ledgerJournalTrans.ExchRate);
        taxWithholdData = conPoke(taxWithholdData, #2, _ledgerJournalTrans.ExchRateSecond);
        taxWithholdData = conPoke(taxWithholdData, #3, Currency::noYes2UnknownNoYes(_ledgerJournalTrans.Triangulation));
        taxWithholdData = conPoke(taxWithholdData, #4, _ledgerJournalTrans.CurrencyCode);
        taxWithholdData = conPoke(taxWithholdData, #5, _grossAmount);
        taxWithholdData = conPoke(taxWithholdData, #6, TaxModuleType::Voucher);
        taxWithholdData = conPoke(taxWithholdData, #7, _ledgerJournalTrans.DefaultDimension);
        taxWithholdData = conPoke(taxWithholdData, #8, _ledgerJournalTrans.TableId);
        taxWithholdData = conPoke(taxWithholdData, #9, _ledgerJournalTrans.RecId);
        taxWithholdData = conPoke(taxWithholdData, #10, _ledgerJournalTrans.Voucher);
        taxWithholdData = conPoke(taxWithholdData, #11, _ledgerJournalTrans.Invoice);
        taxWithholdData = conPoke(taxWithholdData, #12, _ledgerJournalTrans.LineNum);
        taxWithholdData = conPoke(taxWithholdData, #13, _ledgerJournalTrans.ledgerJournalTable().JournalType);
        taxWithholdData = conPoke(taxWithholdData, #14, _ledgerJournalTrans.SettleVoucher);
        taxWithholdData = conPoke(taxWithholdData, #15, transTaxInformation.CompanyLocation);
        taxWithholdData = conPoke(taxWithholdData, #16, transTaxInformation.TaxWithholdNatureOfAssessee);
        taxWithholdData = conPoke(taxWithholdData, #17, _ledgerJournalTrans.TransDate);
        taxWithholdData = conPoke(taxWithholdData, #18, '');

        return taxWithholdData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tcsAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tcs tax posting Account.
    /// </summary>
    /// <param name="_accountType">
    /// The AccountType.
    /// </param>
    /// <param name="_offsetAccountType">
    /// The offsetAccountType.
    /// </param>
    /// <param name="_amountCurDebit">
    /// The AmountCurDebit.
    /// </param>
    /// <param name="_amountCurCredit">
    /// The AmountCurCredit.
    /// </param>
    /// <param name="_taxWithholdTable">
    /// The TaxWithholdTable buffer.
    /// </param>
    /// <param name="_checkStatus">
    /// boolean checkStatus value.
    /// </param>
    /// <param name="_ledgerJournalType">
    /// The LedgerJournalType value.
    /// </param>
    /// <returns>
    /// TCS tax posting Account.
    /// </returns>
    public static LedgerDimensionDefaultAccount tcsAccount(LedgerJournalACType     _accountType,
                                                           LedgerJournalACType     _offsetAccountType,
                                                           AmountCur               _amountCurDebit,
                                                           AmountCur               _amountCurCredit,
                                                           TaxWithholdTable        _taxWithholdTable,
                                                           boolean                 _checkStatus = false,
                                                           LedgerJournalType       _ledgerJournalType = LedgerJournalType::Approval)
    {
        if ((_accountType    == LedgerJournalACType::Ledger  &&  _offsetAccountType == LedgerJournalACType::Cust      && _amountCurDebit  > 0)
            || (_accountType == LedgerJournalACType::Cust    &&  _offsetAccountType == LedgerJournalACType::Ledger    && _amountCurCredit > 0)
            || (_accountType == LedgerJournalACType::Bank    &&  _offsetAccountType == LedgerJournalACType::Cust      && _amountCurDebit  > 0)
            || (_accountType == LedgerJournalACType::Cust    &&  _offsetAccountType == LedgerJournalACType::Bank      && _amountCurCredit > 0)
            || (_accountType == LedgerJournalACType::Cust    &&  _offsetAccountType == LedgerJournalACType::Ledger    && _amountCurDebit  > 0)
            || (_accountType == LedgerJournalACType::Ledger  &&  _offsetAccountType == LedgerJournalACType::Cust      && _amountCurCredit > 0))
        {
            if (_checkStatus && !_taxWithholdTable.LedgerDimension)
            {
                return 1;
            }
            else
            {
                return _taxWithholdTable.LedgerDimension;
            }
        }
        if ((_accountType    == LedgerJournalACType::Ledger &&  _offsetAccountType == LedgerJournalACType::Vend       && _amountCurDebit  > 0)
            || (_accountType == LedgerJournalACType::Vend   &&  _offsetAccountType == LedgerJournalACType::Ledger     && _amountCurCredit > 0)
            || (_accountType == LedgerJournalACType::Bank   &&  _offsetAccountType == LedgerJournalACType::Vend       && _amountCurCredit > 0)
            || (_accountType == LedgerJournalACType::Vend   &&  _offsetAccountType == LedgerJournalACType::Bank       && _amountCurDebit  > 0)
            || (_accountType == LedgerJournalACType::Project   &&  _offsetAccountType == LedgerJournalACType::Vend    && _amountCurDebit > 0)
            || (_accountType == LedgerJournalACType::Vend   &&  _offsetAccountType == LedgerJournalACType::Project    && _amountCurCredit > 0))
        {
            if (_checkStatus && !_taxWithholdTable.LedgerDimension_IN)
            {
                return 1;
            }
            else
            {
                return _taxWithholdTable.LedgerDimension_IN;
            }
        }

        // handle PO/SO/FTI transaction. For these transactions _amountCurDebit and _amountCurCredit will be 0.
        if (_amountCurDebit == 0 &&  _amountCurCredit == 0)
        {
            if (_accountType == LedgerJournalACType::Vend)
            {
                return _taxWithholdTable.LedgerDimension_IN;
            }
            else
            {
                return _taxWithholdTable.LedgerDimension;
            }
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tdsAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tds tax posting Account.
    /// </summary>
    /// <param name="_accountType">
    /// The AccountType.
    /// </param>
    /// <param name="_offsetAccountType">
    /// The offsetAccountType.
    /// </param>
    /// <param name="_amountCurDebit">
    /// The AmountCurDebit.
    /// </param>
    /// <param name="_amountCurCredit">
    /// The AmountCurCredit.
    /// </param>
    /// <param name="_taxWithholdTable">
    /// The TaxWithholdTable buffer.
    /// </param>
    /// <param name="_checkStatus">
    /// boolean checkStatus value.
    /// </param>
    /// <param name="_ledgerJournalType">
    /// The LedgerJournalType value.
    /// </param>
    /// <param name="_purchTypeCash">
    /// Is purchTypecash transaction.
    /// </param>
    /// <returns>
    /// TCS tax posting Account.
    /// </returns>
    public static LedgerDimensionDefaultAccount tdsAccount(LedgerJournalACType     _accountType,
                                                           LedgerJournalACType     _offsetAccountType,
                                                           AmountCur               _amountCurDebit,
                                                           AmountCur               _amountCurCredit,
                                                           TaxWithholdTable        _taxWithholdTable,
                                                           boolean                 _checkStatus = false,
                                                           LedgerJournalType       _ledgerJournalType = LedgerJournalType::Approval,
                                                           boolean                 _purchTypeCash = false)
    {
        TaxWithholdParameters_IN   taxWithholdParameters = TaxWithholdParameters_IN::find();

        if ((_accountType    == LedgerJournalACType::Cust         &&  _offsetAccountType == LedgerJournalACType::Bank        && _amountCurDebit  > 0 && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Vend         &&  _offsetAccountType == LedgerJournalACType::Bank        && _amountCurDebit  > 0 && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Bank         &&  _offsetAccountType == LedgerJournalACType::Cust        && _amountCurCredit > 0 && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Bank         &&  _offsetAccountType == LedgerJournalACType::Vend        && _amountCurCredit > 0 && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Ledger       &&  _offsetAccountType == LedgerJournalACType::Vend        && _amountCurDebit  > 0 && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::Vend         &&  _offsetAccountType == LedgerJournalACType::Ledger      && _amountCurCredit > 0 && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::Ledger       &&  _offsetAccountType == LedgerJournalACType::Cust        && _amountCurDebit  > 0 && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::Cust         &&  _offsetAccountType == LedgerJournalACType::Ledger      && _amountCurCredit > 0 && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::FixedAssets  &&  _offsetAccountType == LedgerJournalACType::Vend        && _amountCurDebit  > 0 && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::Vend         &&  _offsetAccountType == LedgerJournalACType::FixedAssets && _amountCurCredit > 0 && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::FixedAssets  &&  _offsetAccountType == LedgerJournalACType::Cust        && _amountCurDebit  > 0 && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::Cust         &&  _offsetAccountType == LedgerJournalACType::FixedAssets && _amountCurCredit > 0 && taxWithholdParameters.tdsInvoice)
            || (_accountType == LedgerJournalACType::Bank         &&  _offsetAccountType == LedgerJournalACType::Ledger      && _amountCurCredit > 0 && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Ledger       &&  _offsetAccountType == LedgerJournalACType::Bank        && _amountCurDebit  > 0 && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Project      &&  _offsetAccountType == LedgerJournalACType::Vend        && _amountCurDebit  > 0 && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Vend         &&  _offsetAccountType == LedgerJournalACType::Project     && _amountCurCredit > 0 && taxWithholdParameters.tdsPayment))
        {
            if (_checkStatus && !_taxWithholdTable.LedgerDimension)
            {
                return 1;
            }
            else
            {
                return _taxWithholdTable.LedgerDimension;
            }
        }

        if (_accountType        == LedgerJournalACType::Ledger  &&
            _offsetAccountType  == LedgerJournalACType::Vend    &&
            _amountCurCredit    > 0                             &&
            _purchTypeCash)
        {
            return _taxWithholdTable.LedgerDimension;
        }

        if ((_accountType    == LedgerJournalACType::Bank         &&  _offsetAccountType == LedgerJournalACType::Ledger      && _amountCurDebit  > 0 && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Ledger       &&  _offsetAccountType == LedgerJournalACType::Bank        && _amountCurCredit > 0 && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Cust         &&  _offsetAccountType == LedgerJournalACType::Bank        && _amountCurCredit > 0 && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Bank         &&  _offsetAccountType == LedgerJournalACType::Cust        && _amountCurDebit  > 0 && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Cust         &&  _offsetAccountType == LedgerJournalACType::Ledger      && _amountCurDebit  > 0 && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Ledger       &&  _offsetAccountType == LedgerJournalACType::Cust        && _amountCurCredit > 0 && taxWithholdParameters.TDSInvoice)
            || (_accountType == LedgerJournalACType::Project      &&  _offsetAccountType == LedgerJournalACType::Vend        && _amountCurDebit > 0 && taxWithholdParameters.tdsPayment)
            || (_accountType == LedgerJournalACType::Vend         &&  _offsetAccountType == LedgerJournalACType::Project     && _amountCurCredit > 0 && taxWithholdParameters.tdsPayment))
        {
            if (_checkStatus && !_taxWithholdTable.LedgerDimension_IN)
            {
                return 1;
            }
            else
            {
                return _taxWithholdTable.LedgerDimension_IN;
            }
        }

        // handle PO/SO/FTI transaction. For these transactions _amountCurDebit and _amountCurCredit will be 0.
        if (_amountCurDebit == 0 &&  _amountCurCredit == 0)
        {
            if (_accountType == LedgerJournalACType::Vend)
            {
                return _taxWithholdTable.LedgerDimension;
            }
            else
            {
                return _taxWithholdTable.LedgerDimension_IN;
            }
        }

        if (_accountType        == LedgerJournalACType::vend   &&
            _offsetAccountType  == LedgerJournalACType::Ledger &&
            _amountCurDebit     > 0                            &&
            _purchTypeCash)
        {
            return _taxWithholdTable.LedgerDimension;
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTDSZeroRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate if the selected tds group is zero rate, and the code rate here is specific for field TaxWithholdValue
    /// </summary>
    /// <param name="_taxWithholdGroup">
    /// Withholding tax Group
    /// </param>
    /// <param name="_invoiceDate">
    /// Invoice Date
    /// </param>
    /// <returns>
    /// boolean
    /// </returns>
    public static boolean validateTDSZeroRate(TaxWithholdGroup _taxWithholdGroup,
                                            TransDate        _invoiceDate)
    {
        boolean ret = true;
        #define.RateZero(0)

        TaxWithholdDesignerTable_IN     taxWithholdDesignerTable;
        TaxWithholdData                 taxWithholdDataLoc;
        TaxWithholdGroupData            taxWithholdGroupDataLoc;
        ;

        if (!_taxWithholdGroup)
        {
            ret = checkfailed(strfmt("@SYS4002159"));
        }
        else
        {
            select firstonly taxWithholdDesignerTable
                where taxWithholdDesignerTable.TaxWithholdGroup == _taxWithholdGroup
                    && taxWithholdDesignerTable.Basis           == TaxWithholdBasis_IN::GrossAmount
                    join Exempt_IN from taxWithholdGroupDataLoc
                        where taxWithholdGroupDataLoc.TaxWithholdCode   == taxWithholdDesignerTable.TaxWithholdCode
                            && taxWithholdGroupDataLoc.TaxWithholdGroup == _taxWithholdGroup
                                && !(taxWithholdGroupDataLoc.Exempt_IN)
                    join TaxWithholdValue from taxWithholdDataLoc
                        where taxWithholdDataLoc.TaxWithholdCode        == taxWithholdDesignerTable.TaxWithholdCode
                            && (!taxWithholdDataLoc.TaxWithholdFromDate
                                || (taxWithholdDataLoc.TaxWithholdFromDate   <= _invoiceDate
                                    && taxWithholdDataLoc.TaxWithholdToDate      >= _invoiceDate))
                                        && taxWithholdDataLoc.TaxWithholdValue       >  #RateZero;

            if (taxWithholdDesignerTable)
            {
                ret = checkfailed(strfmt("@SYS4002159"));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIndirectTaxAmountByLine</Name>
				<Source><![CDATA[
    internal AmountCur getIndirectTaxAmountByLine(TaxDocumentProxy _taxDocument, TaxDocumentLineProxy _line, TaxWithholdGroupHeading _taxWithholdGroupHeading)
    {
        AmountCur taxAmountCur;

        Map includeTaxComponentsMap = new Map(Types::String, Types::Container);
        includeTaxComponentsMap = TaxWithholdIncIndirectTaxComponentsUtil::getIncTaxComponentsForWithholdGroup(_taxWithholdGroupHeading.RecId);

        taxAmountCur = _line.getTaxAmountByComponentsAndProvider(includeTaxComponentsMap, TaxAccountingProvider::Party);
        if (isTaxTCSWithSEZGST_INFlightEnabled
            && _taxWithholdGroupHeading.TaxType_IN == TaxWithholdCodeType_IN::TCS
            && !taxAmountCur
            && _line.getLineTax().value())
        {
            TaxDocumentLineProxy headerLine = _taxDocument.findLineBySource(_taxDocument.getSourceTableId(), _taxDocument.getSourceRecId());
            if (headerLine
                && TaxEngineEREnumToEnumUtil::noYes(headerLine.getFieldValue(TaxEngineModelFields::WouldYouClaimRefund)) == NoYes::Yes)
            {
                taxAmountCur = -_line.getTaxAmountByComponentsAndProvider(includeTaxComponentsMap, TaxAccountingProvider::Tax);
            }
        }
        return taxAmountCur;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>