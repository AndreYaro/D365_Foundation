<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalTaxDocument</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>LedgerJournalTaxDocument</c> class is the implementation of the <c>TaxableDocument</c>
/// interface for Journals that is used to feed data to Tax to support Tax calculations and Tax posting.
/// </summary>
public class LedgerJournalTaxDocument implements TaxableDocument
{
    LedgerJournalTrans ledgerJournalTrans;
    LedgerJournalTrans ledgerJournalTransSource;
    LedgerJournalTable ledgerJournalTable;
    JournalId journalId;
    Voucher referenceNumber;
    InvoiceId invoiceId;

    LedgerJournalTrans unsavedLedgerJournalTrans;
    boolean currentIsUnsaved;
    boolean noMoreRecords;
    boolean intercompanyJournal;

    Map intercompanyRecIdMap;
    Map mainAccountTypeByVoucher;

    boolean forPostingUseOnly;

    #ISOCountryRegionCodes

    // <GEERU>
    boolean forceTaxable_RU;
    boolean skipUseTaxUncommitted_RU;
    // </GEERU>

    // <GIN>
    boolean isServTaxCentralizedPayment;
    boolean currentIsUnsaved_IN;
    boolean countryRegionIN;
    // </GIN>

    boolean taxOnCustPrepayment;
    boolean taxOnVendPrepayment;

    boolean intercompanyEnabled;

    TransDate taxRateDateOverride;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>doTaxGroupExistsForDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if tax group are set on any line of the document.
    /// </summary>
    /// <returns>
    /// true if tax groups exist on any line; otherwise, false.
    /// </returns>
    public boolean doTaxGroupExistsForDocument()
    {
        LedgerJournalTable journalTable = this.getSourceHeader();

        // If the unsaved transaction has taxes, just return
        // without caching since the insert/update/delete of
        // the record will flush the cache anyway
        if ((unsavedLedgerJournalTrans.TaxGroup &&
             unsavedLedgerJournalTrans.TaxItemGroup) ||
             unsavedLedgerJournalTrans.TaxCode)
        {
            return true;
        }

        // Always push to the server tier to check if tax groups exist
        return LedgerJournalTaxDocument::doTaxGroupExistsForDocument_Server(journalTable.JournalNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompanyForJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the company for the journal.
    /// </summary>
    /// <returns>
    ///    The <c>CompanyId</c> type for the journal.
    /// </returns>
    public CompanyId getCompanyForJournal()
    {
        return ledgerJournalTable.DataAreaId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets an object which implements <c>TaxableLine</c> interface that represents the current
    ///    transaction line.
    /// </summary>
    /// <returns>
    ///    An object that represents the current transaction line.
    /// </returns>
    /// <remarks>
    ///    If there is no current line null may be returned.
    /// </remarks>
    public TaxableLine getCurrentLine()
    {
        if (forPostingUseOnly)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        boolean taxOnPrepayment = this.getTaxOnPrepayment();

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            taxOnPrepayment = taxOnPrepayment || ledgerJournalTrans.isVatTaxAgentPrepayment_RU();
        }
        // </GEERU>

        if (!noMoreRecords)
        {
            return LedgerJournalTaxLine::construct(this, ledgerJournalTrans, taxOnPrepayment);
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentMiscellaneousCharge</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets an object which implements the <c>TaxableLine</c> interface that represents the current
    ///    miscellaneous charge line.
    /// </summary>
    /// <returns>
    ///    An object that represents the current miscellaneous charge line.
    /// </returns>
    /// <remarks>
    ///    If there is no current miscellaneous charge line or if miscellaneous charges are not supported,
    ///    null may be returned.
    /// </remarks>
    public TaxableLine getCurrentMiscellaneousCharge()
    {
        if (forPostingUseOnly)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reads the first transaction line.
    /// </summary>
    /// <returns>
    ///    true if the first transaction line was found; otherwise, false.
    /// </returns>
    public boolean getFirstLine()
    {
        boolean taxOnPrepayment;
        boolean countryRegionRU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        currentIsUnsaved_IN = false;

        if (forPostingUseOnly)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        noMoreRecords = false;
       
        this.initLedgerJournalTrans();
        taxOnPrepayment = this.getPrepaymentByPrimaryAccountType();
        this.clearLedgerJournalTrans();

        // If this is a payment ie, bank is involved along with Vendor/Customer, then standard does not calculate taxes.
        // Also among India taxes only ServiceTax and WHT allows tax.
        select * from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == journalId &&
                  ledgerJournalTrans.Voucher == referenceNumber &&
                  ledgerJournalTrans.Invoice == invoiceId &&

                  // Calculate if primary or offset type is Ledger, Project, or Fixed Assets.
                  ((ledgerJournalTrans.LedgerDimension != 0 &&
                  (ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger ||
                  ledgerJournalTrans.AccountType == LedgerJournalACType::Project ||
                  ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets)
                  // <GEERU>
                  || (ledgerJournalTrans.vatTaxAgentVendAccount_RU &&
                      ledgerJournalTrans.TaxCode &&
                      ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
                  || (countryRegionRU && ledgerJournalTrans.AccountType == LedgerJournalACType::Vend && ledgerJournalTrans.Prepayment)
                  // </GEERU>
                  || (taxOnPrepayment && ledgerJournalTrans.Prepayment)) ||
                  ((ledgerJournalTrans.OffsetLedgerDimension != 0 &&
                  ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger ||
                  ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project ||
                  ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets))) &&

                  // Don't Calculate the line passed in as unsaved.  It is probably
                  // newer than what we will find in the database.
                  ledgerJournalTrans.RecId != unsavedLedgerJournalTrans.RecId;

        // <GIN>
        if (countryRegionIN)
        {
            // Once standard validates the taxable combination, and in case finds cant calculate tax. Then double confirm
            // by calling India additional requirement to see if still tax can be calculated for India.
            if (LedgerJournalTrans_IN_Extension::canServiceTaxCalculate_IN(referenceNumber, journalId, unsavedLedgerJournalTrans))
            {
                select * from ledgerJournalTrans
                    where ledgerJournalTrans.JournalNum == journalId
                       && ledgerJournalTrans.Voucher == referenceNumber
                       && ledgerJournalTrans.RecId != unsavedLedgerJournalTrans.RecId;
            }
        }
        // </GIN>

        // <GEERU>
        if (countryRegionRU)
        {
            this.getNextLineVatTaxAgentPrepayment(taxOnPrepayment);
        }
        // </GEERU>

        currentIsUnsaved = false;

        // If the query result produces no results, evaluate the (optional)
        // unsaved LedgerJournalTrans record as taxable.
        if (ledgerJournalTrans.RecId == 0)
        {
            // Update the current line buffer to reference the unsaved journal line.
            ledgerJournalTrans = unsavedLedgerJournalTrans;
            taxOnPrepayment = this.getTaxOnPrepayment(unsavedLedgerJournalTrans);

            if (this.isJournalLineTaxable(unsavedLedgerJournalTrans, taxOnPrepayment))
            {
                currentIsUnsaved = true;

                return true;
            }
        }
        else if (ledgerJournalTrans.RecId != 0)
        {
            if (ledgerJournalTrans.TaxCode)
            {
                LedgerJournalTaxLine::checkVatTransaction(ledgerJournalTrans);
            }

            return true;
        }

        noMoreRecords = true;
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstMiscellaneousCharge</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Reads the first miscellaneous charge line.
    /// </summary>
    /// <returns>
    ///   true if the first miscellaneous charge line was found; otherwise, false.
    /// </returns>
    /// <remarks>
    ///   Transactions which do not support Miscellaneous Charges may return false.
    /// </remarks>
    public boolean getFirstMiscellaneousCharge()
    {
        if (forPostingUseOnly)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceId</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the Invoice ID.
    /// </summary>
    /// <returns>
    ///   The invoice ID if an invoice ID exists; otherwise, blank.
    /// </returns>
    public InvoiceId getInvoiceId()
    {
        return invoiceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalizedDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the table buffer that represents the journalized document header for the transaction.
    /// </summary>
    /// <returns>
    /// A table buffer for the journalized document header.
    /// </returns>
    /// <remarks>
    /// The table buffer would generally be from the <c>VendInvoiceJour</c> table if the transaction is a
    /// Purchase Order Invoice.This method is used to set the grandparent parent of the <c>TaxTrans</c>
    /// record.The table buffer must have a Record ID assigned to it.
    /// </remarks>
    public Common getJournalizedDocument()
    {
        return ledgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLineByLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets an object that implements the <c>TaxableLine</c> interface that represents the transaction
    ///    line that is specified by the specified parameter.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The transaction line.
    /// </param>
    /// <param name="_taxOnPrepayment">
    ///    true if the document is a payment and if the parameter tax on prepayments is enabled; otherwise,
    ///    false.
    /// </param>
    /// <returns>
    ///    An object that represents the transaction line.
    /// </returns>
    public TaxableLine getLineByLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans, boolean _taxOnPrepayment = this.getTaxOnPrepayment())
    {
        LedgerJournalTaxLine ledgerJournalTaxLine;

        ledgerJournalTaxLine = LedgerJournalTaxLine::construct(this, _ledgerJournalTrans, _taxOnPrepayment);

        return ledgerJournalTaxLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLineByRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets an object which implements the <c>TaxableLine</c> interface that represents the transaction
    ///    line that is specified by the specified parameter.
    /// </summary>
    /// <param name="_recId">
    ///    The ID of the transaction line.
    /// </param>
    /// <returns>
    ///    An object that represents the transaction line.
    /// </returns>
    public TaxableLine getLineByRecId(RefRecId _recId)
    {
        LedgerJournalTrans ledgerJournalTransLocal;

        ledgerJournalTransLocal = LedgerJournalTrans::findRecId(_recId, false);

        return this.getLineByLedgerJournalTrans(ledgerJournalTransLocal, this.getTaxOnPrepayment());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMainAccountType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the main account type for the specified voucher.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher for which to get the main account type.
    /// </param>
    /// <returns>
    /// The main account type.
    /// </returns>
    /// <remarks>
    /// This method is exposed on the tax document to allow for caching of this information so that it does
    /// not have to be recalculated for every line in the voucher. This caching can be done here because a
    /// new tax document instance is created every time that taxes are calculated. The same caching cannot
    /// be done on the <c>LedgerJournalTable</c> or <c>LedgerJournalTrans</c> tables because in these
    /// locations managing flushing of cache data on changes would become prohibitively expensive.
    /// </remarks>
    public LedgerJournalACType getMainAccountType(Voucher _voucher)
    {
        LedgerJournalACType type;

        if (mainAccountTypeByVoucher.exists(_voucher))
        {
            type = mainAccountTypeByVoucher.lookup(_voucher);
        }
        else
        {
            type = ledgerJournalTable.mainAccountType(_voucher);
            mainAccountTypeByVoucher.insert(_voucher, type);
        }

        return type;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getModuleType</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the module type.
    /// </summary>
    /// <returns>
    ///   The module type.
    /// </returns>
    public TaxModuleType getModuleType()
    {
        return TaxModuleType::Voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Reads the next transaction line.
    /// </summary>
    /// <returns>
    ///   true if a transaction line was found; otherwise, false.
    /// </returns>
    public boolean getNextLine()
    {
        RefRecId startingLedgerJournalTrans = ledgerJournalTrans.RecId;

        if (forPostingUseOnly)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        boolean taxOnPrepayment = this.getTaxOnPrepayment();

        if (!currentIsUnsaved && !noMoreRecords)
        {
            next ledgerJournalTrans;

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                this.getNextLineVatTaxAgentPrepayment(taxOnPrepayment);
            }

            if (ledgerJournalTrans.RecId)
            {
                if (ledgerJournalTrans.TaxCode)
                {
                    LedgerJournalTaxLine::checkVatTransaction(ledgerJournalTrans);
                }

                return true;
            }
            // If the query result set has no more records to evaluate, evaluate the (optional)
            // unsaved LedgerJournalTrans record as taxable.
            else if (ledgerJournalTrans.RecId == 0)
            {
                // Update the current line buffer to reference the unsaved journal line.
                ledgerJournalTrans = unsavedLedgerJournalTrans;
                taxOnPrepayment = this.getTaxOnPrepayment(unsavedLedgerJournalTrans);

                if (this.isJournalLineTaxable(unsavedLedgerJournalTrans, taxOnPrepayment))
                {
                    currentIsUnsaved = true;

                    if (ledgerJournalTrans.TaxCode)
                    {
                        LedgerJournalTaxLine::checkVatTransaction(ledgerJournalTrans);
                    }

                    if (countryRegionIN
                        && isServTaxCentralizedPayment
                        && unsavedLedgerJournalTrans.RecId != 0
                        && startingLedgerJournalTrans != 0)
                    {
                        return false;
                    }

                    return true;
                }
            }
        }

        noMoreRecords = true;
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isJournalLineTaxable</Name>
				<Source><![CDATA[
    private boolean isJournalLineTaxable(LedgerJournalTrans _ledgerJournalTrans, boolean _taxOnPrepayment)
    {
        return (
            ((_ledgerJournalTrans.TaxGroup != '' && _ledgerJournalTrans.TaxItemGroup != '')
                || _ledgerJournalTrans.TaxCode != '') &&
            _ledgerJournalTrans.amount() != 0 &&
            (
                LedgerJournalTaxLine::canLineBeCalculated(_ledgerJournalTrans, _taxOnPrepayment) ||
                forceTaxable_RU ||
                _ledgerJournalTrans.TaxCode != ''
            )
        );
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextLineVatTaxAgentPrepayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves to the next line of the ledger journal transaction if country RU, line is prepayment and tax
    /// calculation on prepayments has been turned off in parameters.
    /// </summary>
    /// <param name="_taxOnPrepayment">
    /// The value to calculate tax on prepayments from parameters.
    /// </param>
    private void getNextLineVatTaxAgentPrepayment(boolean _taxOnPrepayment)
    {
        //tax agent prepayments should be processed even if tax calculation on prepayments has been turned off in parameters
        while (!_taxOnPrepayment && ledgerJournalTrans.Prepayment && !ledgerJournalTrans.isVatTaxAgentPrepayment_RU())
        {
            next ledgerJournalTrans;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextMiscellaneousCharge</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Reads the next miscellaneous charge line.
    /// </summary>
    /// <returns>
    ///   true if a miscellaneous charge line was found; otherwise, false.
    /// </returns>
    public boolean getNextMiscellaneousCharge()
    {
        if (forPostingUseOnly)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginalCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the <c>OriginalCompany</c> field from the <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <returns>
    ///   The <c>OriginalCompany</c> field from the <c>LedgerJournalTrans</c> record.
    /// </returns>
    public LedgerJournalId getOriginalCompany()
    {
        return ledgerJournalTable.OriginalCompany;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginalJournalNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the <c>OriginalJournalNum</c> field from the <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <returns>
    ///   The <c>OriginalJournalNum</c> field from the <c>LedgerJournalTrans</c> record.
    /// </returns>
    public LedgerJournalId getOriginalJournalNum()
    {
        return ledgerJournalTable.OriginalJournalNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPrepaymentByPrimaryAccountType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that indicates whether prepayments are supported, depending on the main account type
    /// for the voucher.
    /// </summary>
    /// <returns>
    /// true if prepayments are supported for the main account type for the voucher; otherwise, false.
    /// </returns>
    internal boolean getPrepaymentByPrimaryAccountType()
    {
        return this.getPrepaymentByPrimaryAccountTypeByLedgerJournalTrans(ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPrepaymentByPrimaryAccountTypeByLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that indicates whether prepayments are supported, depending on the main account type
    /// for the voucher.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record to evalulate; optional.  The
    ///    default value is current buffer value.
    /// </param>
    /// <returns>
    /// true if prepayments are supported for the main account type for the voucher; otherwise, false.
    /// </returns>
    internal boolean getPrepaymentByPrimaryAccountTypeByLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans = ledgerJournalTrans)
    {
        LedgerJournalACType primaryAccountType;
        boolean returnValue;

        // Short-circuit if possible to avoid expensive ledger account type lookup
        if (!taxOnCustPrepayment && !taxOnVendPrepayment)
        {
            return false;
        }

        if (mainAccountTypeByVoucher.exists(_ledgerJournalTrans.Voucher))
        {
            primaryAccountType = mainAccountTypeByVoucher.lookup(_ledgerJournalTrans.Voucher);
        }
        else
        {
            primaryAccountType = _ledgerJournalTrans.displayMainAccountType();
            mainAccountTypeByVoucher.insert(_ledgerJournalTrans.Voucher, primaryAccountType);
        }

        if (primaryAccountType == LedgerJournalACType::Cust)
        {
            returnValue = taxOnCustPrepayment;
        }
        else if (primaryAccountType == LedgerJournalACType::Vend)
        {
            returnValue = taxOnVendPrepayment;
        }
        // <GEERU><GEEU>
        else
        {
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ, #isoHU, #isoPL]) && unsavedLedgerJournalTrans.isTmp())
            {
                returnValue = taxOnCustPrepayment || taxOnVendPrepayment;
            }
        }
        // </GEEU></GEERU>

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReferenceNumber</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the reference number.
    /// </summary>
    /// <returns>
    ///   The reference number for the current document.
    /// </returns>
    public Voucher getReferenceNumber()
    {
        return referenceNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSourceCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines the source company in an intercompany document.
    /// </summary>
    /// <returns>
    ///   The source company.
    /// </returns>
    /// <remarks>
    ///   The source company is the company where the payable to the vendor or receivable to the customer is recorded.
    /// </remarks>
    public SelectableDataArea getSourceCompany()
    {
        SelectableDataArea company;
        LedgerJournalTrans ledgerJournalTransTaxSource;
        boolean useUnsavedLedgerJournalTrans;
        boolean isUnsavedLedgerJournalTransUseable;

        if (ledgerJournalTable.JournalType == LedgerJournalType::Approval)
        {
            return curext();
        }

        if (ledgerJournalTransSource == null)
        {
            ledgerJournalTransSource = LedgerJournalTrans::findTaxSource(LedgerJournalTable.JournalNum, this.getReferenceNumber(), false, '', false);
            ledgerJournalTransTaxSource = ledgerJournalTransSource;
        }

        // The record could not be found in the table. Check to see if we can use the unsavedLedgerJournalTrans
        // record to get the source company.
        if (ledgerJournalTransSource == null)
        {
            isUnsavedLedgerJournalTransUseable = (unsavedLedgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum &&
                                                    unsavedLedgerJournalTrans.Voucher == this.getReferenceNumber());

            if (isUnsavedLedgerJournalTransUseable &&
                (
                    (unsavedLedgerJournalTrans.Company != curext() && unsavedLedgerJournalTrans.Company != '') ||
                    (unsavedLedgerJournalTrans.OffsetCompany != curext() && unsavedLedgerJournalTrans.OffsetCompany != '')
                ))
            {
                ledgerJournalTransTaxSource = unsavedLedgerJournalTrans;
                useUnsavedLedgerJournalTrans = true;
            }
        }

        if (ledgerJournalTransTaxSource || useUnsavedLedgerJournalTrans)
        {
            if (ledgerJournalTransTaxSource.AccountType == LedgerJournalACType::Vend)
            {
                company = ledgerJournalTransTaxSource.Company;
            }

            if (ledgerJournalTransTaxSource.OffsetAccountType == LedgerJournalACType::Vend)
            {
                company = ledgerJournalTransTaxSource.OffsetCompany;
            }

            if (ledgerJournalTransTaxSource.AccountType == LedgerJournalACType::Cust)
            {
                company = ledgerJournalTransTaxSource.Company;
            }

            if (ledgerJournalTransTaxSource.OffsetAccountType == LedgerJournalACType::Cust)
            {
                company = ledgerJournalTransTaxSource.OffsetCompany;
            }

            if (ledgerJournalTransTaxSource.AccountType == LedgerJournalACType::Bank)
            {
                company = ledgerJournalTransTaxSource.Company;
            }

            if (ledgerJournalTransTaxSource.OffsetAccountType == LedgerJournalACType::Bank)
            {
                company = ledgerJournalTransTaxSource.OffsetCompany;
            }
        }

        // if no source found. Can't default to curext() because that may not be the proper company to use.
        // it is safest to return an empty company and make caller decide what to do.
        return company;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSourceHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the table buffer that represents the source document header for the transaction.
    /// </summary>
    /// <returns>
    ///    The table buffer for the source document header.
    /// </returns>
    /// <remarks>
    ///    For example, for a purchase order, the source document header is a <c>PurchTable</c> record.This is
    ///    used before the document being journalized to determine the grandparent of the
    ///    <c>TaxUncommitted</c> record.The table buffer must have a record ID assigned to it.
    /// </remarks>
    public Common getSourceHeader()
    {
        return ledgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxIncluded</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets a flag that indicates whether line amounts include taxes.
    /// </summary>
    /// <returns>
    ///    true if the line amounts include taxes; otherwise, false.
    /// </returns>
    public boolean getTaxIncluded()
    {
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) &&
           (ledgerJournalTrans.isVatTaxAgentPrepayment_RU() ||
            ledgerJournalTrans.isVatTaxAgentAuthorityPayment_RU()))
        {
            return false;
        }
        else
        {
            // </GEERU>
            return ledgerJournalTable.LedgerJournalInclTax;
            // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxObligationCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the company for which we have a tax obligation.
    /// </summary>
    /// <returns>
    ///   The <c>TaxObligationCompany</c> setting for the document.
    /// </returns>
    public TaxObligationCompany getTaxObligationCompany()
    {
        if (intercompanyEnabled)
        {
            return ledgerJournalTable.TaxObligationCompany;
        }
        else
        {
            return TaxObligationCompany::Destination;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldDeleteTaxForPrepayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether tax should be deleted for prepayment journal.
    /// If the user enabled the TaxOnPrepayment option and calculated tax for a prepayment journal,
    /// but then disabled the TaxOnPrepayment option, the <c>TaxUncommitted</c> should not exist.
    /// </summary>
    /// <param name="_ledgerJournalTable">
    ///    The <c>LedgerJournalTable</c> that is being calculated.
    /// </param>
    /// <returns>
    /// true if tax should be deleted; otherwise, false.
    /// </returns>
    internal boolean shouldDeleteTaxForPrepayment(LedgerJournalTable _ledgerJournalTable = null)
    {
        if (!_ledgerJournalTable)
        {
            _ledgerJournalTable = LedgerJournalTable::find(journalId);
        }
        // If this is a prepayment and the tax parameter enabling tax on prepayments was on, we calculated tax.
        // Then, if we turned off the parameter, we need to ensure that taxes gets cleared out.
        if (_ledgerJournalTable
            && _ledgerJournalTable.isTaxIntegrationEnabled()
            && TaxIntegrationJournalDoNotRecalcWithoutChangeFlight::instance().isEnabled())
        {
            boolean vendTaxOnPrepaymentEnabled = VendParameters::find().TaxOnPrepayment;
            boolean custTaxOnPrepaymentEnabled = CustParameters::find().TaxOnPrepayment;
            if ((!vendTaxOnPrepaymentEnabled
                    && LedgerJournalTrans::hasVendorPrepayment(journalId, referenceNumber))
                || (!custTaxOnPrepaymentEnabled
                    && LedgerJournalTrans::hasCustomerPrepayment(journalId, referenceNumber)))
            {
                return true;
            }
            // Refered to LedgerJournalTaxDocument.getPrepaymentByPrimaryAccountTypeByLedgerJournalTrans
            else if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ, #isoHU, #isoPL])
                && unsavedLedgerJournalTrans.isTmp()
                && !vendTaxOnPrepaymentEnabled
                && !custTaxOnPrepaymentEnabled)
            {
                return LedgerJournalTrans::hasPrepaymentJournalLine(journalId, referenceNumber);
            }
            else
            {
                return false;
            }
        }
        else
        {
            // below code always return true, if ledgerJournalTrans in LedgerJournalTaxDocuemnt is not initialized.
            return ((this.isCustomerPayment()
                    && !this.getTaxOnPrepayment())
                || (this.isVendorPayment()
                    && !this.getTaxOnPrepayment()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxOnPrepayment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether this is a prepayment and if taxes apply.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record to evalulate; optional.  The
    ///    default value is current buffer value.
    /// </param>
    /// <returns>
    ///    true if this is a prepayment and taxes apply; otherwise, false.
    /// </returns>
    public boolean getTaxOnPrepayment(LedgerJournalTrans _ledgerJournalTrans = ledgerJournalTrans)
    {
        return _ledgerJournalTrans.Prepayment && this.getPrepaymentByPrimaryAccountType();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalType</Name>
				<Source><![CDATA[
    public LedgerJournalType getJournalType()
    {
        return ledgerJournalTable.JournalType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalNum</Name>
				<Source><![CDATA[
    internal LedgerJournalId getJournalNum()
    {
        return ledgerJournalTable.JournalNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCustomerPayment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the current journal is a customer payment.
    /// </summary>
    /// <returns>
    ///   true if the current journal is a customer payment; otherwise, false.
    /// </returns>
    public boolean isCustomerPayment()
    {
        // <GEERU><GEEU>
        if (ledgerJournalTable.JournalType == LedgerJournalType::RCash && RCashParameters::isCashModuleEnabled())
        {
            return true;
        }
        // </GEERU></GEEU>

        return ledgerJournalTable.JournalType == LedgerJournalType::CustPayment ||
              (ledgerJournalTable.JournalType == LedgerJournalType::Daily && (!ledgerJournalTrans || ledgerJournalTrans.Prepayment));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPayment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the document is being taxed is a payment.
    /// </summary>
    /// <returns>
    ///    true if the current document is a payment; otherwise, false.
    /// </returns>
    public boolean isPayment()
    {
        return this.isCustomerPayment() || this.isVendorPayment();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVendorPayment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the current journal is a vendor payment.
    /// </summary>
    /// <returns>
    ///   true if the current journal is a vendor payment; otherwise, false.
    /// </returns>
    public boolean isVendorPayment()
    {
        // <GEERU><GEEU>
        if (ledgerJournalTable.JournalType == LedgerJournalType::RCash && RCashParameters::isCashModuleEnabled())
        {
            return true;
        }
        // </GEERU></GEEU>

        return ledgerJournalTable.JournalType == LedgerJournalType::Payment ||
              (ledgerJournalTable.JournalType == LedgerJournalType::Daily && (((SysCountryRegionCode::isLegalEntityInCountryRegion([#isoGB]) && invoiceId)? false : !ledgerJournalTrans) || ledgerJournalTrans.Prepayment));
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructForNew</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new <c>LedgerJournalTaxDocument</c> object.
    /// </summary>
    /// <param name = "_unsavedLedgerJournalTrans">The unsaved journal.</param>
    /// <param name = "_journalId">The journal id.</param>
    /// <param name = "_referenceNumber">The reference number.</param>
    /// <param name = "_invoiceId">The invoice id.</param>
    /// <param name = "_forPostingUseOnly">Indicates if this is for posting.</param>
    /// <returns>A new instance of the <c>LedgerJournalTaxDocument</c> object</returns>
    public static LedgerJournalTaxDocument constructForNew(LedgerJournalTrans _unsavedLedgerJournalTrans,
                                         JournalId _journalId,
                                         Voucher _referenceNumber,
                                         InvoiceId _invoiceId,
                                         boolean _forPostingUseOnly)
    {
        return new LedgerJournalTaxDocument( _unsavedLedgerJournalTrans,
                                         _journalId,
                                         _referenceNumber,
                                         _invoiceId,
                                         _forPostingUseOnly);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(LedgerJournalTrans _unsavedLedgerJournalTrans,
                                         JournalId _journalId,
                                         Voucher _referenceNumber,
                                         InvoiceId _invoiceId,
                                         boolean _forPostingUseOnly)
    {
        unsavedLedgerJournalTrans = _unsavedLedgerJournalTrans;
        forPostingUseOnly = _forPostingUseOnly;
        referenceNumber = _referenceNumber;
        invoiceId = _invoiceId;
        journalId = _journalId;

        ledgerJournalTable = LedgerJournalTable::find(_journalId, false);

        mainAccountTypeByVoucher = new Map(Types::String, Types::Enum);

        taxOnCustPrepayment = this.isCustomerPayment() && CustParameters::find().TaxOnPrepayment;

        taxOnVendPrepayment = this.isVendorPayment() && VendParameters::find().TaxOnPrepayment;

        intercompanyEnabled = isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting));

        countryRegionIN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmForceTaxable_RU</Name>
				<Source><![CDATA[
    public boolean parmForceTaxable_RU(boolean _value = forceTaxable_RU)
    {
        forceTaxable_RU = _value;
        return forceTaxable_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIntercompanyJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or gets the <c>intercompanyJournal</c> variable in this class.
    /// </summary>
    /// <param name="_intercompanyJournal">
    ///    The <c>intercompanyJournal</c> value to set.
    /// </param>
    /// <returns>
    ///    The value of <c>intercompanyJournal</c>.
    /// </returns>
    public boolean parmIntercompanyJournal(boolean _intercompanyJournal = intercompanyJournal)
    {
        intercompanyJournal = _intercompanyJournal;
        return intercompanyJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIntercompanyMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or gets the <c>intercompanyRecIdMap</c> variable in this class.
    /// </summary>
    /// <param name="_intercompanyRecIdMap">
    ///    The <c>intercompanyJournal</c> value to set.
    /// </param>
    /// <returns>
    ///    The value of <c>intercompanyRecIdMap</c>.
    /// </returns>
    public Map parmIntercompanyMap(Map _intercompanyRecIdMap = intercompanyRecIdMap)
    {
        intercompanyRecIdMap = _intercompanyRecIdMap;
        return intercompanyRecIdMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmServTaxCentralizedPayment_IN</Name>
				<Source><![CDATA[
    public boolean parmServTaxCentralizedPayment_IN(boolean _isServTaxCentralizedPayment = isServTaxCentralizedPayment)
    {
        isServTaxCentralizedPayment = _isServTaxCentralizedPayment;
        return isServTaxCentralizedPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipUseTaxUncommitted_RU</Name>
				<Source><![CDATA[
    public boolean parmSkipUseTaxUncommitted_RU(boolean _value = skipUseTaxUncommitted_RU)
    {
        skipUseTaxUncommitted_RU = _value;
        return skipUseTaxUncommitted_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxRateDateOverride</Name>
				<Source><![CDATA[
    public TransDate parmTaxRateDateOverride(TransDate _taxRateDateOverride = taxRateDateOverride)
    {
        taxRateDateOverride = _taxRateDateOverride;
        return taxRateDateOverride;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalTransCurrentlyBeingCalculated</Name>
				<Source><![CDATA[
    /// <remarks>
    /// This method is specifically for Tax Service Integration.
    /// Do not use it unless you are working on Tax Service Intergation.
    /// </remarks>
    internal LedgerJournalTrans parmLedgerJournalTransCurrentlyBeingCalculated(LedgerJournalTrans _ledgerJournalTrans = ledgerJournalTrans)
    {
        ledgerJournalTrans = _ledgerJournalTrans;
        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerJournalTableForInterWHT_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets new <c>ledgerJournalTable</c> due to interCompany journal number
    /// </summary>
    /// <param name="_intercompanyJournalNum">
    /// InterCompany journal number
    /// </param>
    /// <remarks>
    /// ledgerJournalTable is the member variable of class <c>LedgerJournalTaxDocument</c>
    /// Here update it to match centralized payment withhold tax crossCompany settlement case
    /// </remarks>
    public void updateLedgerJournalTableForInterWHT_IN(JournalId _intercompanyJournalNum)
    {
        select firstOnly crossCompany ledgerJournalTable
            where ledgerJournalTable.JournalNum == _intercompanyJournalNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSourceDocumentFramework</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method returns a Boolean value that indicates whether the current transaction supports the
    ///    source document framework.
    /// </summary>
    /// <returns>
    ///    true if the current transaction supports the source document framework; otherwise, false.
    /// </returns>
    public boolean useSourceDocumentFramework()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether taxes should allow customers to use the <c>TaxUncommitted</c> table to store
    /// taxes which have not yet been journalized.
    /// </summary>
    /// <returns>
    /// true if taxes allow customers to use the <c>TaxUncommitted</c> table; otherwise, false .
    /// </returns>
    public boolean useTaxUncommitted()
    {
        // <GEERU>
        if (skipUseTaxUncommitted_RU)
        {
            return false;
        }
        // </GEERU>
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCachedTaxExistenceCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears any cached tax existence information about the specified journal.
    /// </summary>
    /// <param name="_journalNum">
    /// The journal number.
    /// </param>
    /// <remarks>
    /// This check must always occur on the server since the classFactory.globalCache()
    /// is a different instance on the client and the server. If the value was cached
    /// on the client side, subsequent clears of the cache on the server tier during data
    /// updates would not properly flush the client side cache.
    /// </remarks>
    public static void clearCachedTaxExistenceCheck(JournalId _journalNum)
    {
        SysGlobalCache cache = classFactory.globalCache();

        if (cache.isSet(classStr(LedgerJournalTaxDocument), _journalNum))
        {
            cache.remove(classStr(LedgerJournalTaxDocument), _journalNum);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Constructs an instance of the <c>LedgerJournalTaxDocument</c> class.
    /// </summary>
    /// <param name="_journalId">
    ///    The journal ID.
    /// </param>
    /// <param name="_referenceNumber">
    ///    The reference number.
    /// </param>
    /// <param name="_invoiceId">
    ///    The invoice ID.
    /// </param>
    /// <param name="_unsavedLedgerJournalTrans">
    ///    An instance of the <c>LedgerJournalTrans</c> table buffer that represents a record that has not
    ///    been saved to SQL.
    /// </param>
    /// <returns>
    ///    An instance of the <c>LedgerJournalTaxDocument</c> class.
    /// </returns>
    /// <remarks>
    ///    null may be passed for the <paramref name="_unsavedLedgerJournalTrans" /> parameter if all
    ///    <c>LedgerJournalTrans</c> records in SQL are up to date.
    /// </remarks>
    public static LedgerJournalTaxDocument construct(JournalId _journalId,
                                                     Voucher _referenceNumber,
                                                     InvoiceId _invoiceId,
                                                     LedgerJournalTrans _unsavedLedgerJournalTrans = null)
    {
        return new LedgerJournalTaxDocument(_unsavedLedgerJournalTrans, _journalId, _referenceNumber, _invoiceId, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructForPosting</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>LedgerJournalTaxDocument</c> class.
    /// </summary>
    /// <param name="_journalId">
    ///    The journal ID.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher.
    /// </param>
    /// <returns>
    ///    An instance of the <c>LedgerJournalTaxDocument</c> class.
    /// </returns>
    public static LedgerJournalTaxDocument constructForPosting(JournalId _journalId, Voucher _voucher)
    {
        LedgerJournalTaxDocument ledgerJournalTaxDocument;

        ledgerJournalTaxDocument = new LedgerJournalTaxDocument(null, _journalId, _voucher, '', true);

        return ledgerJournalTaxDocument;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doTaxGroupExistsForDocument_Server</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that indicates whether taxes exist on any line of the document.
    /// </summary>
    /// <param name="_journalNum">
    /// The journal number.
    /// </param>
    /// <returns>
    /// true if tax groups exist on any line; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This check must always occur on the server since the classFactory.globalCache()
    /// is a different instance on the client and the server. If the value was cached
    /// on the client side, subsequent clears of the cache on the server tier during data
    /// updates would not properly flush the client side cache.
    /// </remarks>
    private static boolean doTaxGroupExistsForDocument_Server(JournalId _journalNum)
    {
        LedgerJournalTrans ledgerJournalTrans;
        SysGlobalCache cache;

        cache = classfactory.globalCache();

        if (cache.isSet(classStr(LedgerJournalTaxDocument), _journalNum))
        {
            ledgerJournalTrans.RecId = cache.get(classStr(LedgerJournalTaxDocument), _journalNum);
        }
        else
        {
            select firstOnly RecId from ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == _journalNum &&
                      ((ledgerJournalTrans.TaxGroup != '' &&
                      ledgerJournalTrans.TaxItemGroup != '') ||
                      ledgerJournalTrans.TaxCode != '');

            cache.set(classStr(LedgerJournalTaxDocument), _journalNum, ledgerJournalTrans.RecId);
        }

        return ledgerJournalTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUnsavedLedgerJournalTrans</Name>
				<Source><![CDATA[
    internal LedgerJournalTrans getUnsavedLedgerJournalTrans()
    {
        return unsavedLedgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerJournalTrans</Name>
				<Source><![CDATA[
    private void initLedgerJournalTrans()
    {
        // <GIN>
        DataAreaId dataAreaId = LedgerJournalTrans_IN_Extension::getInterCompanyForCentralizedPay_IN(unsavedLedgerJournalTrans, curext());
        if (dataAreaId != curext())
        {
            // prime the buffer with the key values since the first
            // LedgerJournalTrans record hasn't been read yet.
            changeCompany(dataAreaId)
            {
                // This is required without which select statement wont fetch record, same for sstandard also. See below.
                ledgerJournalTrans.Voucher = referenceNumber;
                ledgerJournalTrans.JournalNum = journalId;
            }
        }
        else
        {
            // </GIN>
            // prime the buffer with the key values since the first
            // LedgerJournalTrans record hasn't been read yet.
            ledgerJournalTrans.Voucher = referenceNumber;
            ledgerJournalTrans.JournalNum = journalId;
            // <GIN>
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <remarks>
    /// ledgerJournalTrans buffer need to be cleared as this method getting called twice for same unsaved record.
    /// But when the ledgerJournalTrans is temporary (for example, when calling from CustVendPrepaymentHandling_W)
    /// calling ledgerJournalTrans.clear() will clear the unsavedLedgerJournalTrans too. So null instead of .clear()
    /// </remarks>
    private void clearLedgerJournalTrans()
    {
        if (this.shouldClearLedgerJournalTrans())
        {
            ledgerJournalTrans = null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldClearLedgerJournalTrans</Name>
				<Source><![CDATA[
    private boolean shouldClearLedgerJournalTrans()
    {
        boolean shouldClear = false;

        TaxIntegrationBusinessProcess businessProcess = TaxIntegrationUtils::getBusinessProcessByTable(ledgerJournalTrans.TableId, ledgerJournalTrans.RecId);

        if ((TaxSpecificExchangeRateHelper::isTaxSpecificExchRateEnabledByBusinessProcess(businessProcess)
                || TaxParameters::isBankExchRateEnabled_W())
            && ledgerJournalTrans.RecId == unsavedLedgerJournalTrans.RecId)
        {
            if (currentIsUnsaved
                || Tax::isTaxIntegrationEnabledForBusinessProcess(businessProcess))
            {
                shouldClear = true;
            }
        }
        return shouldClear;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>