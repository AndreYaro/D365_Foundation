<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>JmgPostStandardSystem</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>JmgPostStandardSystem</c> class is used to post time and quantities collected in
///    manufacturing execution and time and attendance modules to other modules.
/// </summary>
/// <remarks>
///    The <c>JmgPostStandardSystem</c> class is the main interface from time and attendance and
///    manufacturing execution modules to other parts of . Registered time and quantities are posted to
///    other modules using journals.
/// </remarks>
public class JmgPostStandardSystem
{
    static private readonly Decimals hourDecimals = new DictType(new SysDictField(tableNum(ProdJournalRoute), fieldNum(ProdJournalRoute, Hours)).typeId()).effectivePrecision();

    static private readonly Decimals qtyDecimals = new DictType(new SysDictField(tableNum(ProjJournalTrans), fieldNum(ProjJournalTrans, Qty)).typeId()).effectivePrecision();

    private static boolean isJmgPostStandardSystemCreateProductionStartUpJournalRefactoringFlightEnabled = JmgPostStandardSystemCreateProductionStartUpJournalRefactoringFlight::instance().isEnabled();
    private static boolean isJmgPostStandardSystemCreateUpdateBOMJournalRefactoringFlightEnabled = JmgPostStandardSystemCreateUpdateBOMJournalRefactoringFlight::instance().isEnabled();
    private static boolean isJmgProductionStartWithJobSetupFlightEnabled = JmgProductionStartWithJobSetupFlight::instance().isEnabled();
            
    boolean                     invertTime;

    JmgProdMultiReportFinished  prodMultiReportFinished;

    Array               jobs;
    Array               jobParameters;
    Array               jobTime;
    JmgWorkerRecId      worker;
    JmgWrkCtrIdPilot    wrkCtrIdPilot;
    JmgProfileDate      profileDate;
    InventDimId         inventDimId;
    private FormRun     callerForm;
    private boolean     createEmptyQtyBomJournalLine;

    private JmgInstrumentationLogger jmgInstrumentationLogger;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmCallerForm</Name>
				<Source><![CDATA[
    internal FormRun parmCallerForm(FormRun _callerForm = callerForm)
    {
        callerForm = _callerForm;
        return callerForm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addJob</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a job to the <c>JmgPostStandardSystem</c> instance, which will be considered when journals are
    ///    created.
    /// </summary>
    /// <param name="_job">
    ///    The job for which to create journals.
    /// </param>
    /// <param name="_params">
    ///    An instance of the <c>JmgRegistrationParameters</c> class, which is considered when journals are
    ///    created for the added job.
    /// </param>
    /// <param name="_jmgStampTransMap">
    ///    A registration that is made on the specified job; optional.
    /// </param>
    /// <remarks>
    ///    The <c>_jmgStampTransMap</c> parameter must be specified to post time for the added job.
    /// </remarks>
    public void addJob(
    JmgTermJob                  _job,
    JmgRegistrationParameters   _params = new JmgRegistrationParameters(),
    JmgStampTransMap            _jmgStampTransMap = null)
    {
        if (!_job.isValidJobId())
            return;

        int idx = jobs.lastIndex() + 1;
        jobs.value(idx, _job);
        jobParameters.value(idx, _params);
        jobTime.value(idx, _jmgStampTransMap);

        if (_job.module() == JmgModuleEnum::PROD)
        {
            JmgTermJob_Prod prodJob = _job;
            inventDimId = prodJob.siteInventDimId();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProdStatusQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a <c>List</c> of instances of the <c>ProdJournalCheckPost</c> class, which refers to a production journal
    ///    to post that contains registered information about the added jobs.
    /// </summary>
    /// <returns>
    ///    The <c>List</c> of the <c>ProdJournalCheckPost</c> classes.
    /// </returns>
    /// <remarks>
    ///    The <c>createProdStatusQty</c> method returns <c>null</c> if there is nothing to post to production
    ///    based on the jobs that are added to the instance of the <c>JmgPostStandardSystem</c> class.
    /// </remarks>
    public List createProdStatusQty()
    {
        ProdJournalRoute    prodJournalRoute;
        ProdJobType         prodJobType;
        RouteJobType        routeJobType;

        ProdJournalTransDataRoute   journalTransDataRoute;
        ProdJournalTable            prodJournalTable_JobCard;
        ProdJournalTableData        journalTableData_JobCard;
        ProdJournalCheckPost        prodJournalCheckPost;
        List                        prodJournalCheckPostList = new List(Types::Class);

        int                         i;
        JmgTermJob                  job;
        JmgTermJob_Prod             prodJob;
        JmgRegistrationParameters   feedback;
        ProdId                      prodId;

        Map                         prodJournalTableMap;
        Map                         journalTableDataMap;
        Map                         journalTransDataMap;
        MapEnumerator               enumerator;

        prodJournalTableMap = new Map(Types::String, Types::Record);
        journalTableDataMap = new Map(Types::String, Types::Class);
        journalTransDataMap = new Map(Types::String, Types::Class);

        ttsbegin;

        for (i = 1; i <= jobs.lastIndex(); i++)
        {
            job = jobs.value(i);
            if (job.module() == JmgModuleEnum::PROD)
            {
                prodJob = job;
                routeJobType = prodJob.prodJobType();
                feedback = jobParameters.value(i);
                prodId = prodJob.jobRef();
                prodJournalRoute.clear();

                if (feedback.goodQuantity() != 0
                || JmgErrorSpecificationForm::getTotalErrorQuantity(feedback.errorSpecification())
                || feedback.reportAsFinished() == JmgFeedbackStatus::Completed)
                {
                    if (!prodJournalTableMap.exists(prodId))
                    {
                        prodJournalTable_JobCard.clear();
                        journalTableData_JobCard    = JournalTableData::newTable(prodJournalTable_JobCard);
                        prodJournalTable_JobCard.ProdId = prodJob.jobRef();
                        this.newJournal_JobCard(journalTableData_JobCard, prodJournalTable_JobCard, false);

                        journalTransDataRoute = journalTableData_JobCard.journalStatic().newJournalTransData(prodJournalRoute, journalTableData_JobCard);
                        journalTransDataRoute.initFromJournalTable();

                        prodJournalTableMap.insert(prodId, prodJournalTable_JobCard);
                        journalTableDataMap.insert(prodId, journalTableData_JobCard);
                        journalTransDataMap.insert(prodId, journalTransDataRoute);
                    }
                    else
                    {
                        journalTableData_JobCard = journalTableDataMap.lookup(prodId);
                        prodJournalTable_JobCard = prodJournalTableMap.lookup(prodId);
                        journalTransDataRoute       = journalTransDataMap.lookup(prodId);
                    }

                    ProdRouteJob    prodRouteJob = ProdRouteJob::findJobId(prodJob.jobId());
                    ProdRoute       prodRoute = prodJob.prodRoute();

                    prodJobType = ProdJobType::construct(routeJobType);
                    prodJobType.initProdJournalRoute(prodRoute, prodJournalRoute, prodRouteJob);

                    if (JmgProdJourRouteDefaultParmDefaultDimensionFlight::instance().isEnabled())
                    {
                        this.initProdJournalRouteDefaultDimension(prodJournalRoute, prodRoute, prodRouteJob);
                    }

                    if (! prodJournalRoute.ProdId)
                    prodJournalRoute.ProdId     = prodJob.jobRef();

                    prodJournalRoute.JournalId      = prodJournalTable_JobCard.JournalId;
                    prodJournalRoute.TransDate      = JmgProfileSeconds::getSysDate();
                    prodJournalRoute.QtyError       = 0;
                    prodJournalRoute.QtyGood        = feedback.goodQuantity();
                    prodJournalRoute.PdsCWQtyGood   = feedback.pdsCWGoodQuantity();
                    prodJournalRoute.JobFinished    = feedback.reportAsFinished() == JmgFeedbackStatus::Completed;
                    prodJournalRoute.Worker         = worker;
                    prodJournalRoute.ProdPickList   = NoYes::No;
                    if (wrkCtrIdPilot)
                    {
                        prodJournalRoute.WrkCtrId   = wrkCtrIdPilot;
                    }
                    else
                    {
                        prodJournalRoute.WrkCtrId   = feedback.wrkCtrId();
                        if (!prodJournalRoute.WrkCtrId)
                        {
                            prodJournalRoute.WrkCtrId = prodJob.jmgJobTable().WrkCtrId;
                        }
                    }

                    switch (JmgProdParameters::find().StampLevel)
                    {
                        case JmgStampLevel::Job :
                            prodJournalRoute.JobId = prodJob.jobId();
                            break;

                        case JmgStampLevel::Route :
                            prodJournalRoute.OprId   = prodJob.prodRoute().OprId;
                            prodJournalRoute.OprNum  = prodJob.prodRoute().OprNum;
                            prodJournalRoute.JobType = prodJob.prodJobType();
                            break;
                    }

                    if (prodJournalRoute.JobFinished &&
                    JmgProdParametersDim::find(inventDimId).ReportFinishStatus != JmgProdStatusUpdateReportFinished::QtyOnly &&
                    this.isLastOpenJobOnOpr(prodJob))
                    {
                        prodJournalRoute.OprFinished = NoYes::Yes;
                    }

                    if (prodJournalRoute.QtyGood || prodJournalRoute.OprFinished || prodJournalRoute.JobFinished)
                    {
                        journalTransDataRoute.create();
                        if (prodJournalRoute.isProjMethodConsumed())
                        {
                            JmgPostStandardSystem::createProjTransFromProdJournalRoute(prodJournalRoute , prodJobType);
                        }
                        prodJournalTable_JobCard.update();
                        prodJournalTableMap.insert(prodId, prodJournalTable_JobCard);
                    }

                    this.prodQtyErrorSpec(feedback.errorSpecification(), journalTransDataRoute, prodJournalRoute);
                }
            }
        }

        enumerator = prodJournalTableMap.getEnumerator();
        while (enumerator.moveNext())
        {
            prodJournalTable_JobCard = enumerator.currentValue();
            // Update journal after creation of lines
            ttsbegin;
            prodJournalTable_JobCard.update();
            ttscommit;

            if (JmgProdParameters::find().StampLevel == JmgStampLevel::Route)
            {
                prodJournalCheckPost = ProdJournalCheckPostRoute::newJournalCheckPost(true, false, JournalCheckPostType::Post, prodJournalTable_JobCard.TableId, prodJournalTable_JobCard.JournalId);
            }
            else
            {
                prodJournalCheckPost = ProdJournalCheckPostRouteJob::newJournalCheckPost(true, false, JournalCheckPostType::Post, prodJournalTable_JobCard.TableId, prodJournalTable_JobCard.JournalId);
            }

            // Generate picking list.
            if (JmgProdParametersDim::find(inventDimId).StatusQtyAutoConsump != BOMAutoConsump::Never)
            {
                this.createUpdateBOMJournal(false);
            }

            prodJournalCheckPostList.addEnd(prodJournalCheckPost);
        }

        ttscommit;

        if (!prodJournalCheckPostList.empty()
            && JmgPostStandardSystem::mustShowBOMJournalsOnOperationComplete(inventDimId))
        {
            this.showBOMJournals();
        }

        return prodJournalCheckPostList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProdJournalRouteDefaultDimension</Name>
				<Source><![CDATA[
    private void initProdJournalRouteDefaultDimension(ProdJournalRoute _prodJournalRoute, ProdRoute _prodRoute, ProdRouteJob _prodRouteJob)
    {
        DimensionCopy   dimensionCopy = DimensionCopy::newFromTable(null, _prodJournalRoute.companyInfo().RecId);
        InventDim       inventDimSite;

        inventDimSite.InventSiteId = _prodRoute.prodTable().inventDim().InventSiteId;
        inventDimSite = InventDim::findOrCreate(inventDimSite);

        switch (JmgProdParametersDim::find(inventDimSite.InventDimId).ProdDimensionFrom)
        {
            case JmgDimensionFrom::Employee:
                _prodJournalRoute.DefaultDimension = _prodJournalRoute.copyDimension(JmgEmployee::find(worker).workerDimension(_prodJournalRoute.TransDate), dimensionCopy);
                break;
            case JmgDimensionFrom::Job:
                _prodJournalRoute.DefaultDimension = _prodJournalRoute.copyDimension(_prodRoute.DefaultDimension, dimensionCopy);
                break;
            case JmgDimensionFrom::EmployeeJob:
                _prodJournalRoute.DefaultDimension = _prodJournalRoute.mergeDimension(JmgEmployee::find(worker).workerDimension(_prodJournalRoute.TransDate),
                                                        _prodRoute.DefaultDimension);
                break;
            case JmgDimensionFrom::JobEmployee:
                _prodJournalRoute.DefaultDimension = _prodJournalRoute.mergeDimension(_prodRoute.DefaultDimension,
                                                        JmgEmployee::find(worker).workerDimension(_prodJournalRoute.TransDate));
                break;
        }

        // After initializing a financial dimensions combination according to the setup from Production order defaults - Dimension, 
        // this combination is merged with a combination from a resource.
        // When we have the property set to any value except Worker, we have dimensions copied or merged from ProdRoute
        // but when we have Resource load qty > 1, then on ProdRoute we will have dimensions from a resource group
        // and we will need to merge dimensions from resources.
        WrkCtrTable wrkCtrTable;

        if (!_prodRouteJob)
        {
            date searchDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

            if (_prodRoute)
            {
                if (_prodRoute.FromDate)
                {
                    searchDate = _prodRoute.FromDate;
                }
                else if (_prodJournalRoute.TransDate)
                {
                    searchDate = _prodJournalRoute.TransDate;
                }

                wrkCtrTable = _prodRoute.getResource(true, true, searchDate, searchDate, inventDimSite.InventSiteId, false, true);
            }
        }
        else
        {
            wrkCtrTable = WrkCtrTable::find(_prodRouteJob.WrkCtrId);
        }
        _prodJournalRoute.DefaultDimension = _prodJournalRoute.mergeDimension(_prodJournalRoute.DefaultDimension, wrkCtrTable.DefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProductionStartUpJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a production startup journal by using the added jobs.
    /// </summary>
    /// <returns>
    ///    An instance of the <c>JmgProdMultiStartUp</c> class, which starts productions that are referred to
    ///    by the added jobs.
    /// </returns>
    /// <remarks>
    ///    If there are no productions to start based on the added jobs, the
    ///    <c>createProductionStartUpJournal</c> returns null.
    /// </remarks>
    public JmgProdMultiStartUp createProductionStartUpJournal()
    {
        boolean postJournal;
        JmgProdMultiStartUp  jmgProdMultiStartUp  = new JmgProdMultiStartUp();
        JmgProdParametersDim jmgProdParametersDim = JmgProdParametersDim::find(inventDimId);

        if (jmgProdParametersDim.StartUpStatus != JmgProdStatusUpdate::No)
        {
            jmgProdMultiStartUp.initSFCParmId(inventDimId);
            postJournal = false;

            ttsbegin;
            for (int i = 1; i <= jobParameters.lastIndex(); i++)
            {
                JmgTermJob_Prod prodJob = jobs.value(i);
                JmgRegistrationParameters registrationParameters = jobParameters.value(i);

                Qty startQuantity;
                PdsCWInventQty pdsCWStartQuantity;
                if (jmgProdParametersDim.StartUpStatus == JmgProdStatusUpdate::Qty)
                {
                    startQuantity = registrationParameters.startQuantity();
                    pdsCWStartQuantity = registrationParameters.pdsCWStartQuantity();
                }

                JmgJobStatusTransaction jobStatus = new JmgJobStatusTransaction();
                if (startQuantity || !jobStatus.reportedStarted(prodJob.prodRoute(), prodJob.jobId()))
                {
                    if (isJmgPostStandardSystemCreateProductionStartUpJournalRefactoringFlightEnabled)
                    {
                        this.addJobToProductionStartUpJournal(prodJob, jmgProdMultiStartUp, startQuantity, pdsCWStartQuantity, registrationParameters);
                    }
                    else
                    {
                        ProdParmStartUp prodParmStartUp;
                        prodParmStartUp.clear();
                        ProdRoute prodRoute = prodJob.prodRoute();
                        ProdTable prodTable = prodRoute.prodTable();
                        prodParmStartUp.FromOprNum  = prodRoute.OprNum;
                        prodParmStartUp.ToOprNum    = prodRoute.OprNum;
                        prodParmStartUp.ProdId      = prodJob.jobRef();

                        jmgProdMultiStartUp.insert(prodTable, prodParmStartUp);
                        if (prodParmStartUp)
                        {
                            prodParmStartUp.StartUpQty  = startQuantity;
                            prodParmStartUp.PdsCWStartupQty = pdsCWStartQuantity;

                            if (this.mustNotStartProduction(prodParmStartUp))
                            {
                                prodParmStartUp.StartUpProduction = NoYes::No;
                            }

                            if (prodParmStartUp.StartUpProduction == NoYes::Yes)
                            {
                                Qty allStartedQty = startQuantity + prodJob.jmgJobTable().startedQuantity();
                                prodParmStartUp.StartUpQty = max(0, allStartedQty - prodTable.QtyStUp);

                                Qty allPdsCWStartedQty = pdsCWStartQuantity + prodJob.jmgJobTable().pdsCWStartedQuantity();
                                prodParmStartUp.PdsCWStartupQty = max(0, allPdsCWStartedQty - prodTable.PdsCWBatchStup);
                            }

                            prodParmStartUp.update();
                        }
                    }

                    postJournal = true; //Job added
                }
            }
            ttscommit;
        }

        if (!postJournal && jmgProdMultiStartUp)
        {
            ProdParmStartUp::deleteParameters(jmgProdMultiStartUp.parmId());
        }

        if (jmgProdMultiStartUp)
        {
            jmgProdMultiStartUp.parmUserCanceled(false); //User Cancelled always false
        }
        return jmgProdMultiStartUp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addJobToProductionStartUpJournal</Name>
				<Source><![CDATA[
    protected void addJobToProductionStartUpJournal(
        JmgTermJob_Prod _prodJob,
        JmgProdMultiStartUp _jmgProdMultiStartUp,
        Qty _startQuantity,
        PdsCWInventQty _pdsCWStartQuantity,
        JmgRegistrationParameters _registrationParameters)
    {
        ProdParmStartUp prodParmStartUp;
        prodParmStartUp.clear();
        ProdRoute prodRoute = _prodJob.prodRoute();
        ProdTable prodTable = prodRoute.prodTable();
        prodParmStartUp.FromOprNum  = prodRoute.OprNum;
        prodParmStartUp.ToOprNum    = prodRoute.OprNum;
        prodParmStartUp.ProdId      = _prodJob.jobRef();

        _jmgProdMultiStartUp.insert(prodTable, prodParmStartUp);
        if (prodParmStartUp)
        {
            prodParmStartUp.StartUpQty  = _startQuantity;
            prodParmStartUp.PdsCWStartupQty = _pdsCWStartQuantity;

            if (this.mustNotStartProduction(prodParmStartUp))
            {
                prodParmStartUp.StartUpProduction = NoYes::No;
            }

            if (prodParmStartUp.StartUpProduction == NoYes::Yes)
            {
                boolean parallelJobComponentNotConsumedFlight = ParallelJobComponentNotConsumedFlight::instance().isEnabled();
                Qty prevStartedQty = _prodJob.jmgJobTable().startedQuantity();
                Qty allStartedQty = _startQuantity + prevStartedQty;
                prodParmStartUp.StartUpQty = max(0, allStartedQty - prodTable.QtyStUp);

                // In case of parallel jobs, in order to start the second job, we need to send some start up quantity without starting production for that job.
                // We have to check for the current job if there is some qty for start up and there have not been any qty started yet and update starting qty if it has been changed to 0.
                if (parallelJobComponentNotConsumedFlight && _startQuantity && prevStartedQty == 0 && prodParmStartUp.StartUpQty == 0)
                {
                    prodParmStartUp.StartUpQty  = _startQuantity;
                    prodParmStartUp.StartUpProduction = NoYes::No;
                }

                Qty prevPdsCWStartedQty = _prodJob.jmgJobTable().pdsCWStartedQuantity();
                Qty allPdsCWStartedQty = _pdsCWStartQuantity + prevPdsCWStartedQty;
                prodParmStartUp.PdsCWStartupQty = max(0, allPdsCWStartedQty - prodTable.PdsCWBatchStup);

                if (parallelJobComponentNotConsumedFlight && _pdsCWStartQuantity && prevPdsCWStartedQty == 0 && prodParmStartUp.PdsCWStartupQty == 0)
                {
                    prodParmStartUp.PdsCWStartupQty  = _pdsCWStartQuantity;
                    prodParmStartUp.StartUpProduction = NoYes::No;
                }

                if (isJmgProductionStartWithJobSetupFlightEnabled && _prodJob.prodJobType() != RouteJobType::Process)
                {
                    prodParmStartUp.BOMAutoConsump = BOMAutoConsump::Never;
                    prodParmStartUp.PostNowBOM = NoYes::No;
                    prodParmStartUp.CompletePickListJournal = NoYes::No;
                    prodParmStartUp.EndPicklist = NoYes::No;
                }
            }

            prodParmStartUp.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustNotStartProduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if production must be started.
    /// </summary>
    /// <param name = "_prodParmStartUp">Parameters defining if the production order must be started.</param>
    /// <returns>true if production must be started; otherwise, false.</returns>
    protected boolean mustNotStartProduction(ProdParmStartUp _prodParmStartUp)
    {
        return ((_prodParmStartUp.StartUpProduction == NoYes::Yes) &&
            !(((select firstonly RecId from prodRoute
                    where prodRoute.ProdId          == _prodParmStartUp.ProdId
                        && prodRoute.OprNumNext     == _prodParmStartUp.FromOprNum).RecId == 0)
                &&   (select RecId from prodTable
                        where prodTable.ProdId          == _prodParmStartUp.ProdId
                            && (prodTable.ProdStatus == ProdStatus::Created
                                || prodTable.ProdStatus == ProdStatus::Scheduled
                                || prodTable.ProdStatus == ProdStatus::Released
                                || prodTable.ProdStatus == ProdStatus::StartedUp)).RecId != 0));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjTransFromProdJournalRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create the project journal transactions.
    /// </summary>
    /// <param name="_prodJournalRoute">
    /// The production journal route which will be used to create the project journal transactions.
    /// </param>
    /// <param name="_prodJobType">
    /// The production job type.
    /// </param>
    public static void createProjTransFromProdJournalRoute(
    ProdJournalRoute        _prodJournalRoute,
    ProdJobType             _prodJobType)
    {
        ProdJournalRouteProj    prodJournalRouteProjQuantity;
        ProdJournalRouteProj    prodJournalRouteProjHour;

        // Create project journal transactions.
        prodJournalRouteProjQuantity.clear();
        prodJournalRouteProjQuantity = _prodJobType.initProdJournalRouteProj(ProdRouteTransType::Qty, _prodJournalRoute, prodJournalRouteProjQuantity);
        if (ProjJournalTransMapForm::construct(prodJournalRouteProjQuantity, _prodJournalRoute).validateWritePost())
        {
            prodJournalRouteProjQuantity.insert();
        }
        else
        {
            throw error("@SYS21628");
        }
        prodJournalRouteProjHour.clear();
        prodJournalRouteProjHour = _prodJobType.initProdJournalRouteProj(ProdRouteTransType::Time, _prodJournalRoute, prodJournalRouteProjHour);
        if (ProjJournalTransMapForm::construct(prodJournalRouteProjHour, _prodJournalRoute).validateWritePost())
        {
            prodJournalRouteProjHour.insert();
        }
        else
        {
            throw error("@SYS21628");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReportFinishedJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an instance of the <c>JmgProdMultiReportFinished</c> class, which
    /// reports productions referred to by added jobs as finished
    /// </summary>
    /// <returns>
    /// Returns an instance of the <c>JmgProdMultiReportFinished</c> class.
    /// </returns>
    /// <remarks>
    /// If no productions are to be reported finished based on the added jobs, then the <c>createReportFinishedJournal</c>
    /// method returns null.
    /// </remarks>
    public JmgProdMultiReportFinished createReportFinishedJournal()
    {
        JmgProdParametersDim        jmgProdParametersDim    = JmgProdParametersDim::find(inventDimId);
        ProdParmReportFinished      prodParmReportFinished;
        boolean                     postJournal = false;

        if (jmgProdParametersDim.ReportFinishStatus != JmgProdStatusUpdateReportFinished::No)
        {
            JmgTermJob_Prod             prodJob;
            JmgRegistrationParameters   feedback;
            int                         i;
            prodParmReportFinished.LineNum = 1;

            prodMultiReportFinished     = new JmgProdMultiReportFinished();
            prodMultiReportFinished.initParmSFC(inventDimId);
            prodMultiReportFinished.parmCallerForm(this.parmCallerForm());

            ttsbegin;
            for (i = 1; i <= jobs.lastIndex(); i++)
            {
                prodJob = jobs.value(i);
                feedback = jobParameters.value(i);


                boolean prodMultiLineReportFinishSerialNumEnabled = FeatureStateProvider::isFeatureEnabled(ProdMultiLineReportAsFinishSerialNumFeature::instance()) || (!feedback.parmSerialNumberRequired() || !feedback.parmWHSLicensePlateId());
                if (prodMultiLineReportFinishSerialNumEnabled && (this.mustCreateReportFinishedJournalForJob(prodJob, feedback) || feedback.isCoByProductFeedback(prodJob.jobId())))
                {
                    prodParmReportFinished.ProdId   = prodJob.jobRef();
                    prodMultiReportFinished.insert(ProdTable::find(prodJob.jobRef()), prodParmReportFinished);
                    prodMultiReportFinished.parmRegistrationParametersFeedback(feedback);

                    prodParmReportFinished.EndJob  = this.shouldReportAsFinished(jmgProdParametersDim, feedback, prodJob, worker);

                    if (prodParmReportFinished)
                    {
                        this.initializeProdParmReportFinished(prodParmReportFinished, jmgProdParametersDim, feedback, prodJob);
                        this.updateProductionReportFinishedParameters(prodParmReportFinished);

                        if (feedback.parmSerialNumberRequired())
                        {
                            if (FeatureStateProvider::isFeatureEnabled(ProdMultiLineReportAsFinishSerialNumFeature::instance()))
                            {
                                prodMultiReportFinished.initializeJmgSerialNumberSpecification(prodParmReportFinished, prodJob.jobId(), prodParmReportFinished.EndJob);
                            }
                            else
                            {
                                prodMultiReportFinished.initializeProdParmReportFinishedWithSerialNumber(prodParmReportFinished, prodJob.jobId(), prodParmReportFinished.EndJob);
                            }
                        }
                    }

                    if (#pmfEnabled)
                    {
                        prodMultiReportFinished.pmfInsertPost(ProdTable::find(prodParmReportFinished.ProdId), prodParmReportFinished, true);
                    }

                    postJournal = true;
                }
            }
            ttscommit;
        }

        if (!postJournal)
        {
            ProdParmReportFinished::deleteParameters(prodParmReportFinished.ParmId);
        }

        if (prodMultiReportFinished)
        {
            prodMultiReportFinished.parmUserCanceled(false); //User Cancelled always false
        }
        return prodMultiReportFinished;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateReportFinishedJournalForJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether finished journal must be created for job.
    /// </summary>
    /// <param name = "_prodJob">Represents production type jobs.</param>
    /// <param name = "_feedback">Registration parameters in shop floor control.</param>
    /// <returns>true if finished journal must be created for job; otherwise, false.</returns>
    protected boolean mustCreateReportFinishedJournalForJob(JmgTermJob_Prod _prodJob, JmgRegistrationParameters _feedback)
    {
        if(_feedback.reportAsFinished() == JmgFeedbackStatus::Completed
                    || _feedback.goodQuantity()
                    || _feedback.errorSpecification()
                    || _feedback.pdsCWGoodQuantity())
        {
            return _prodJob.prodJobType() == RouteJobType::Process && _prodJob.prodRoute().OprNum == ProdRoute::lastOprNum(_prodJob.jobRef());
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProdParmReportFinished</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize production order parameters for the reporting.
    /// </summary>
    /// <param name = "_prodParmReportFinished">The buffer for parameters to report a production order as finished.</param>
    /// <param name = "_jmgProdParametersDim">The buffer of parameters for manufacturing execution</param>
    /// <param name = "_feedback">Registration parameters in shop floor control.</param>
    /// <param name = "_prodJob">Represents production type jobs.</param>
    /// <returns>Instance of <c>ProdParmReportFinished</c>.</returns>
    protected ProdParmReportFinished initializeProdParmReportFinished(
        ProdParmReportFinished _prodParmReportFinished, 
        JmgProdParametersDim _jmgProdParametersDim, 
        JmgRegistrationParameters _feedback, 
        JmgTermJob_Prod _prodJob)
    {
        
        if (this.isOperationsReportedAsFinished(_jmgProdParametersDim))
        {
            _prodParmReportFinished.QtyGood = _feedback.goodQuantity();
            _prodParmReportFinished.PdsCWBatchGood = _feedback.pdsCWGoodQuantity();

            boolean shouldReportScrap = this.shouldReportScrap(_feedback, _prodJob);

            _prodParmReportFinished.QtyError      = this.totalProdQtyError(shouldReportScrap, _prodJob, _feedback.errorSpecification());
            _prodParmReportFinished.PdsCWBatchErr = this.pdsCWTotalProdQtyError(shouldReportScrap, _prodJob, _feedback.errorSpecification());

            _prodParmReportFinished.setLicensePlateId(_feedback.parmWHSLicensePlateId());
            _prodParmReportFinished.setInventBatchId(_feedback.parmInventBatchId());
        }
        else
        {
            _prodParmReportFinished.QtyGood = 0;
            _prodParmReportFinished.QtyError = 0;
            _prodParmReportFinished.PdsCWBatchGood = 0;
            _prodParmReportFinished.PdsCWBatchErr = 0;
        }

        return _prodParmReportFinished;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOperationsReportedAsFinished</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if given operations has reported as finished status.
    /// </summary>
    /// <param name = "_jmgProdParametersDim">The parameters manufacturing execution module.</param>
    /// <returns>true if operations be reported as finished at quantity or status level; otherwise, false.</returns>
    protected boolean isOperationsReportedAsFinished(JmgProdParametersDim _jmgProdParametersDim)
    {
        return _jmgProdParametersDim.ReportFinishStatus == JmgProdStatusUpdateReportFinished::Qty ||
            _jmgProdParametersDim.ReportFinishStatus == JmgProdStatusUpdateReportFinished::QtyOnly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProductionReportFinishedParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates production order parameters for the reporting.
    /// </summary>
    /// <param name = "_prodParmReportFinished">The buffer for parameters to report a production order as finished.</param>
    protected void updateProductionReportFinishedParameters(ProdParmReportFinished _prodParmReportFinished)
    {
        _prodParmReportFinished.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createUpdateBOMJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Generates a BOM Journal based on the added jobs
    /// </summary>
    /// <param name="_update">
    ///    A Boolean value that indicates whether to override previously generated BOM journals.
    /// </param>
    /// <param name="_allowEmpty">
    ///    A Boolean value that specifies whether to keep the BOM Journal header even though no BOM journal
    ///    lines are calculated.
    /// </param>
    /// <remarks>
    ///    The journal ID of each generated BOM journal is saved in the <c>JmgRegistrationParameters</c>
    ///    object that is associated to each added job.
    /// </remarks>
    public void createUpdateBOMJournal(boolean _update = true, boolean _allowEmpty = false)
    {
        int                         i;
        JmgTermJob_Prod             prodJob;
        JmgRegistrationParameters   feedback;

        ProdJournalTable            prodJournalTable;
        ProdJournalBOM              prodJournalBOM;
        ProdJournalTableData        prodJournalTableData;
        ProdJournalTransData        prodJournalTransData;
        boolean                     noBOM;

        #OCCRetryCount

        for (i = 1; i <= jobs.lastIndex(); i++)
        {
            noBOM = false;
            prodJob = jobs.value(i);
            prodJournalTable.clear();

            feedback = jobParameters.value(i);
            if (feedback.prodJournalIdBOM())
            {
                prodJournalTable = ProdJournalTable::find(feedback.prodJournalIdBOM(), true);
            }

            if (prodJournalTable && _update)
            {
                // Clear existing prod journal id
                delete_from prodJournalBOM
                where prodJournalBOM.JournalId == feedback.prodJournalIdBOM();

                prodJournalTable.delete();
                prodJournalTable.clear();
                feedback.prodJournalIdBOM('');
            }

            // Initialise after possible deletion of prodJournalTable to maintain referential integrity:
            prodJournalTableData = JournalTableData::newTable(prodJournalTable);

            if (!prodJournalTable)
            {
                // Init new prod journal table
                prodJournalTable.initValue();
                prodJournalTable.JournalId      = prodJournalTableData.nextJournalId();
                prodJournalTable.JournalType    = ProdJournalType::Picklist;
                prodJournalTable.JournalNameId  = JmgProdParametersDim::find(inventDimId).bomJournalName;
                prodJournalTable.ProdId         = prodJob.jobRef();

                prodJournalTableData.initFromJournalName(prodJournalTableData.journalStatic().findJournalName(prodJournalTable.JournalNameId));
                prodJournalTable.insert();

                feedback.prodJournalIdBOM(prodJournalTable.JournalId);
                noBOM = true;
            }

            // Calculate new BOM:
            if (_update || noBOM)
            {
                try
                {
                    ttsbegin;
                    ProdTable prodTable = ProdTable::find(prodJob.jobRef());
                    Qty quantity = feedback.goodQuantity() + JmgErrorSpecificationForm::getTotalErrorQuantity(feedback.errorSpecification());
                    OprNum oprNum = prodJob.prodRoute().OprNum;

                    prodJournalTransData = prodJournalTableData.journalStatic().newJournalTransData(prodJournalBOM,prodJournalTableData);
                    if (prodJournalTable.NumOfLines)
                    {
                        prodJournalTransData.parmLastLineNum(ProdJournalBOM::lastLineNum(prodJournalTable.JournalId));
                    }

                    BOMCalcData bomCalcData = BOMCalcData::newProdTable(quantity, prodTable);

                    if (isJmgPostStandardSystemCreateUpdateBOMJournalRefactoringFlightEnabled)
                    {
                        ProdBOM prodBOM;

                        SysDaQueryObject prodBOMQueryObject = this.buildQueryObjectForProdBOM(prodBOM, prodTable, oprNum);

                        SysDaSearchObject searchObject = new SysDaSearchObject(prodBOMQueryObject);
                        SysDaSearchStatement searchStmt = new SysDaSearchStatement();

                        while (searchStmt.nextRecord(searchObject))
                        {
                            ProdBOMCalc prodBOMCalc = this.initializeProdBOMCalc(prodBOM, bomCalcData);
                            this.updateBOMQuantities(
                                prodBOM,
                                prodBOMCalc,
                                prodJournalBOM,
                                prodJournalTransData,
                                prodJournalTableData);
                        }
                    }
                    else
                    {
                        ProdBOM prodBOM;

                        while select forupdate prodBOM
                            index hint NumIdx
                            where prodBOM.ProdId == prodTable.ProdId
                               && prodBOM.OprNum == oprNum
                        {
                            ProdBOMCalc prodBOMCalc = this.initializeProdBOMCalc(prodBOM, bomCalcData);
                            this.updateBOMQuantities(
                                prodBOM,
                                prodBOMCalc,
                                prodJournalBOM,
                                prodJournalTransData,
                                prodJournalTableData);
                        }
                    }

                    if (prodJournalTable.WaitCreateLine)
                    {
                        prodJournalTable.WaitCreateLine = NoYes::No;
                        prodJournalTable.SystemBlocked  = NoYes::No;
                    }

                    if (prodJournalTableData.journalTable().JournalId)
                    {
                        prodJournalTableData.journalTable().write();
                    }

                    prodJournalTable.reread();
                    if (!_allowEmpty && prodJournalTable.NumOfLines == 0)
                    {
                        feedback.prodJournalIdBOM('');
                        prodJournalTable.delete();
                    }
                    ttscommit;
                }
                catch (Exception::Deadlock)
                {
                    retry;
                }
                catch (Exception::UpdateConflict)
                {
                    if (appl.ttsLevel() == 0)
                    {
                        if (xSession::currentRetryCount() >= #RetryNum)
                        {
                            throw Exception::UpdateConflictNotRecovered;
                        }
                        else
                        {
                            retry;
                        }
                    }
                    else
                    {
                        throw Exception::UpdateConflict;
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProdBOMCalc</Name>
				<Source><![CDATA[
    protected ProdBOMCalc initializeProdBOMCalc(ProdBOM _prodBOM, BOMCalcData _bomCalcData)
    {
        return ProdBOMCalc::newBOMCalcData(
            _bomCalcData,
            _prodBOM,
            ProdBOMConsumpProposal::Qty,
            JmgProdParametersDim::find(inventDimId).StatusQtyAutoConsump,
            !_prodBOM.ConstantReleased,
            NoYes::Yes,
            false,
            true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryObjectForProdBOM</Name>
				<Source><![CDATA[
    protected SysDaQueryObject buildQueryObjectForProdBOM(ProdBOM _prodBOM, ProdTable _prodTable, OprNum _oprNum)
    {
        SysDaQueryObject prodBOMQueryObject = new SysDaQueryObject(_prodBOM);
        prodBOMQueryObject.forUpdateHint = true;
        prodBOMQueryObject.whereClause(this.buildWhereClauseForProdBOM(_prodBOM, _prodTable, _oprNum));

        // We cannot set index hint using SysDa, so we have to set it using SysDaOrderBys to mimic index hint NumIdx.
        prodBOMQueryObject.orderByClause(new SysDaOrderBys()
            .add(fieldStr(ProdBOM, Partition))
            .add(fieldStr(ProdBOM, DataAreaId))
            .add(fieldStr(ProdBOM, ProdId))
            .add(fieldStr(ProdBOM, LineNum))
            .add(fieldStr(ProdBOM, RecId)));

        return prodBOMQueryObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWhereClauseForProdBOM</Name>
				<Source><![CDATA[
    protected SysDaQueryExpression buildWhereClauseForProdBOM(ProdBOM _prodBOM, ProdTable _prodTable, OprNum _oprNum)
    {
        return new SysDaEqualsExpression(
                    new SysDaFieldExpression(_prodBOM, fieldStr(ProdBOM, ProdId)),
                    new SysDaValueExpression(_prodTable.ProdId))
          .and(new SysDaEqualsExpression(
                    new SysDaFieldExpression(_prodBOM, fieldStr(ProdBOM, OprNum)),
                    new SysDaValueExpression(_oprNum)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBOMQuantities</Name>
				<Source><![CDATA[
    protected void updateBOMQuantities(
        ProdBOM _prodBOM,
        ProdBOMCalc _prodBOMCalc,
        ProdJournalBOM _prodJournalBOM,
        ProdJournalTransData _prodJournalTransData,
        ProdJournalTableData _prodJournalTableData)
    {
        if (_prodBOMCalc.hasQty() || createEmptyQtyBomJournalLine)
        {
            _prodJournalTableData.initJournalId();

            _prodJournalBOM.clear();
            _prodJournalBOM.initValue();

            _prodJournalTransData.initFromJournalTable();

            _prodJournalBOM.initFromProdBOM(_prodBOM);

            _prodJournalBOM.TransDate      = profileDate;
            _prodJournalBOM.EndConsump     = NoYes::No;

            _prodBOMCalc.setProdJournalBOM(_prodJournalBOM);

            _prodJournalBOM.bomProposal      = _prodJournalBOM.bomConsump;
            _prodJournalBOM.InventProposal   = _prodJournalBOM.InventConsump;

            _prodBOM.ConstantReleased = NoYes::Yes;

            if (JmgCreateProdJournalBOMPickMaterialFromWhsFlight::instance().isEnabled() && !WHSInventEnabled::exist(_prodBOM.prodTable().ItemId))
            {
                _prodJournalBOM.pickMaterialFromWarehouse(_prodBOM, ProdFlushingPrincipBOM::Finish);
            }

            if (_prodJournalBOM.bomProposal || _prodJournalBOM.InventProposal || createEmptyQtyBomJournalLine)
            {
                _prodJournalBOM.insertJournalCreate(_prodJournalTransData,_prodBOM);
                if (_prodBOM.ConstantReleased != _prodBOM.orig().ConstantReleased)
                {
                    _prodBOM.doUpdate();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getHourPriceFromStampTrans</Name>
				<Source><![CDATA[
    private Price getHourPriceFromStampTrans(JmgStampTransMap jmgStampTransMap)
    {
        JmgStampTrans jmgStampTrans;

        select HourPrice from jmgStampTrans
        where jmgStampTrans.Worker == worker &&
        jmgStampTrans.ProfileDate  == profileDate &&
        jmgStampTrans.Module       == jmgStampTransMap.Module &&
        jmgStampTrans.StartDate    == jmgStampTransMap.StartDate &&
        jmgStampTrans.StartTime    == jmgStampTransMap.StartTime &&
        jmgStampTrans.JobId        == jmgStampTransMap.JobId;

        return jmgStampTrans.HourPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJobs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an array of the added jobs.
    /// </summary>
    /// <returns>
    /// an array of the added jobs
    /// </returns>
    public Array getJobs()
    {
        return jobs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReversedHourPrice</Name>
				<Source><![CDATA[
    private Price getReversedHourPrice(JmgStampTransMap jmgStampTransMap)
    {
        ResourceRecId resource;
        ProdRouteTrans prodRouteTrans;
        ProjJournalTrans projJournalTrans;

        if (jmgStampTransMap.Module != JmgModuleEnum::PROD && jmgStampTransMap.Module != JmgModuleEnum::PROJ)
        {
            throw error(Error::wrongUseOfFunction(funcName())); // this method can only be used for production journal transaction and project journal transaction.
        }

        if (jmgStampTransMap.Module == JmgModuleEnum::PROJ)
        {
            resource = ResourceFacade::findOrCreateByWorker(worker);

            // Find the price on projJournalTrans which will be reversed, that can keep the price consistent.
            select firstonly CostPrice from projJournalTrans order by RecId desc
            where projJournalTrans.Resource       == resource                      &&
                projJournalTrans.ProjId           == jmgStampTransMap.JobRef       &&
                projJournalTrans.CategoryId       == jmgStampTransMap.ProjCategory &&
                projJournalTrans.TransDate        == profileDate                   &&
                projJournalTrans.FromTime         == jmgStampTransMap.StartTime    &&
                projJournalTrans.ToTime           == jmgStampTransMap.StopTime     &&
                projJournalTrans.DefaultDimension == jmgStampTransMap.DefaultDimension;

            return projJournalTrans.CostPrice;
        }

        // Find the price on prodRouteTrans which will be reversed, that can keep the price consistent.
        JmgStampLevel stampLevel = JmgProdParameters::find().StampLevel;
        switch (stampLevel)
        {
            case JmgStampLevel::Job:
                select firstonly HourPrice from prodRouteTrans order by RecId desc
                    where prodRouteTrans.TransRefId     == jmgStampTransMap.JobRef          &&
                          prodRouteTrans.TransRefType   == ProdTransRefType::Production     &&
                          prodRouteTrans.DateWIP        == jmgStampTransMap.ProfileDate     &&
                          prodRouteTrans.Worker         == worker                           &&
                          prodRouteTrans.FromTime       == jmgStampTransMap.StartTime       &&
                          prodRouteTrans.ToTime         == jmgStampTransMap.StopTime        &&
                          prodRouteTrans.JobId          == jmgStampTransMap.JobId           &&
                          prodRouteTrans.Hours          >  0;
                break;

            case JmgStampLevel::Route:
                select firstonly HourPrice from prodRouteTrans order by RecId desc
                    where prodRouteTrans.TransRefId     == jmgStampTransMap.JobRef          &&
                          prodRouteTrans.TransRefType   == ProdTransRefType::Production     &&
                          prodRouteTrans.Worker         == worker                           &&
                          prodRouteTrans.DateWIP        == jmgStampTransMap.ProfileDate     &&
                          prodRouteTrans.FromTime       == jmgStampTransMap.StartTime       &&
                          prodRouteTrans.ToTime         == jmgStampTransMap.StopTime        &&
                          prodRouteTrans.OprId          == jmgStampTransMap.ActOprID        &&
                          prodRouteTrans.OprNum         == jmgStampTransMap.OprNum          &&
                          prodRouteTrans.JobType        == jmgStampTransMap.RouteJobType    &&
                          prodRouteTrans.OprPriority    == JmgJobTable::find(jmgStampTransMap.JobId).Priority  &&
                          prodRouteTrans.Hours          >  0;
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName())); // unexpected enum value.
        }

        return prodRouteTrans.HourPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invertTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether time should be inverted, that is negative time is posted in journals.
    /// </summary>
    /// <param name="value">
    ///    true if time should be inverted; otherwise, false.
    /// </param>
    /// <remarks>
    ///    This method is used right after the <c>JmgPostStandardSystem</c> object has been initialized. To
    ///    roll back the posting of some journal registrations, the <paramref name="invertTime" /> parameter
    ///    must be set to true. If journal registrations are to be posted, the <paramref name="invertTime" />
    ///    parameter must be set to false.
    /// </remarks>
    protected void invertTime(boolean value)
    {
        invertTime = value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLastOpenJobOnOpr</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the specified job is the last open job on an operation.
    /// </summary>
    /// <param name="_prodJob">
    ///    The job to check whether it is the last open job on the operation.
    /// </param>
    /// <returns>
    ///    true if the specified job is the last job on the operation; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method checks whether a job is the last open job on a production operation. It checks both the
    ///    status of the productions jobs and checks whether there are unposted journal lines in the shop
    ///    floor control module. This method also considers whether you have chosen the job or route level in
    ///    the job level parameter in the shop floor control module.
    /// </remarks>
    protected boolean isLastOpenJobOnOpr(JmgTermJob_Prod _prodJob)
    {
        ProdRouteJob    prodRouteJob;
        ProdRoute       prodRoute;
        RouteJobType    otherJobType;
        JmgJobId        otherJobId;
        boolean         ret = true;

        boolean         hasPlannedTime;
        boolean         isJobManaged;
        boolean         isJobFinishedInJournal;
        boolean         isJobFinishedInBundle;
        int             i;
        JmgRegistrationParameters   jmgRegistrationParameters;
        JmgTermJob                  jmgTermJob;

        prodRoute   = _prodJob.prodRoute();

        if (JmgProdParameters::find().StampLevel == JmgStampLevel::Route)
        {
            if (_prodJob.prodJobType() == RouteJobType::Setup)
            {
                otherJobType    = RouteJobType::Process;
                otherJobId      = prodRoute.JobIdProcess;
                hasPlannedTime  = prodRoute.ProcessTime > 0;
            }
            else if (_prodJob.prodJobType() == RouteJobType::Process)
            {
                otherJobType    = RouteJobType::Setup;
                otherJobId      = prodRoute.JobIdSetup;
                hasPlannedTime  = prodRoute.SetupTime   > 0;
            }

            isJobManaged = RouteJobSetup::find(prodRoute.RouteGroupId, otherJobType).JobCtrlTime;

            isJobFinishedInJournal =((select firstonly jmgTermReg
                                            where jmgTermReg.JobId        == otherJobId           &&
                                                  jmgTermReg.FinishedCode == 2).RecId != 0);

            isJobFinishedInBundle = false;
            for (i = 1; i <= jobs.lastIndex(); i++)
            {
                jmgTermJob  = jobs.value(i);
                if (otherJobId == jmgTermJob.jobId())
                {
                    jmgRegistrationParameters = jobParameters.value(i);
                    if (jmgRegistrationParameters.reportAsFinished() == JmgFeedbackStatus::Completed)
                    {
                        isJobFinishedInBundle = true;
                        break;
                    }
                }
            }
            if (isJobManaged && !(isJobFinishedInJournal || isJobFinishedInBundle) && hasPlannedTime)
            {
                return false;
            }
            return true;
        }

        while select ProdId, OprNum, OprPriority, JobType, JobId
        from prodRouteJob
        where prodRouteJob.ProdId     == prodRoute.ProdId
            && prodRouteJob.OprNum    == prodRoute.OprNum
            && prodRouteJob.RecId     != _prodJob.sourceData().RecId
            && prodRouteJob.JobStatus <  ProdJobStatus::Completed
        {
            isJobManaged = RouteJobSetup::find(ProdRoute::find(prodRouteJob.ProdId,prodRouteJob.OprNum,prodRouteJob.OprPriority).RouteGroupId,prodRouteJob.JobType).JobCtrlTime;

            isJobFinishedInJournal =((select firstonly jmgTermReg
                                        where jmgTermReg.JobId  == prodRouteJob.JobId
                                            && jmgTermReg.FinishedCode == 2).RecId);

            isJobFinishedInBundle = false;
            for (i = 1; i <= jobs.lastIndex(); i++)
            {
                jmgTermJob  = jobs.value(i);
                if (prodRouteJob.JobId == jmgTermJob.jobId())
                {
                    jmgRegistrationParameters = jobParameters.value(i);
                    if (jmgRegistrationParameters.reportAsFinished() == JmgFeedbackStatus::Completed)
                    {
                        isJobFinishedInBundle = true;
                        break;
                    }
                }
            }

            if (isJobManaged && !isJobFinishedInJournal && !isJobFinishedInBundle)
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOtherWorkEnded</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether any work is being performed on the specified job by other workers than the one
    ///    specified.
    /// </summary>
    /// <param name="_worker">
    ///    The ID of the worker that is currently working on the job.
    /// </param>
    /// <param name="_jobId">
    ///    The job to check for other workers.
    /// </param>
    /// <returns>
    ///    true if no other workers are currently working on the specified job; otherwise, false.
    /// </returns>
    [SysObsolete('The method is obsoleted because all works that are being performed on the specified job will be stopped.', false, 26\10\2021)]
    protected boolean isOtherWorkEnded(JmgWorkerRecId _worker, JmgJobId _jobId)
    {
        JmgTermReg jmgTermReg;

        if (_worker)
        {
            select firstonly jmgTermReg
            where jmgTermReg.JobId      == _jobId
                && jmgTermReg.Worker    != _worker
                && jmgTermReg.JobActive == NoYes::Yes;
        }
        else if (wrkCtrIdPilot)
        {
            select firstonly jmgTermReg
            where jmgTermReg.JobId          == _jobId
                && jmgTermReg.WrkCtrIdPilot != wrkCtrIdPilot
                && jmgTermReg.JobActive     == NoYes::Yes;
        }
        if (jmgTermReg)
        return false;

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>JmgPostStandardSystem</c> class.
    /// </summary>
    protected void new()
    {
        worker          = 0;
        jobs            = new Array(Types::Class);
        jobParameters   = new Array(Types::Class);
        jobTime         = new Array(Types::Record);
        profileDate     = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        inventDimId     = InventDim::inventDimIdBlank();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newJournal_JobCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new <c>ProdJournalTable</c> record for posting route or job card journals.
    /// </summary>
    /// <param name="_prodJournalTableData">
    /// A reference to a <c>ProdJournalTableData</c> to which the initialized <c>ProdJournalTable</c> record
    /// is associated.
    /// </param>
    /// <param name="_prodJournalTable">
    /// The <c>ProdJournalTable</c> record to initialize.
    /// </param>
    /// <param name="_timeJournal">
    /// true, if the <c>ProdJournalTable</c> journal is used for posting time; otherwise, false.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Throws an error if the <c>ProdJournalTable</c> record cannot be initialized correctly.
    /// </exception>
    private void newJournal_JobCard(ProdJournalTableData _prodJournalTableData, ProdJournalTable _prodJournalTable, boolean _timeJournal)
    {
        ttsbegin;

        _prodJournalTable.initValue();
        if (_timeJournal)
        {
            _prodJournalTableData.initFromJournalName(_prodJournalTableData.journalStatic().findJournalName(JmgProdParametersDim::find(inventDimId).TimeProdJournalNameId));
            _prodJournalTable.JournalNameId   = JmgProdParametersDim::find(inventDimId).TimeProdJournalNameId;
        }
        else
        {
            _prodJournalTableData.initFromJournalName(_prodJournalTableData.journalStatic().findJournalName(JmgProdParametersDim::find(inventDimId).StatusQtyJournalNameId));
            _prodJournalTable.JournalNameId   = JmgProdParametersDim::find(inventDimId).StatusQtyJournalNameId;
        }
        _prodJournalTable.Description     = "@SYS38526";
        _prodJournalTable.JournalType     = JmgProdParameters::find().StampLevel == JmgStampLevel::Job ? ProdJournalType::JobCard : ProdJournalType::RouteCard;
        _prodJournalTable.AcceptError     = NoYes::Yes;

        _prodJournalTable.insert();
        ttscommit;

        if (!_prodJournalTable.JournalId)
        throw error(strFmt("@SYS22828",funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>newJournal_Proj</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new <c>ProjJournalTable</c> record which can be used to post time to project module.
    /// </summary>
    /// <param name="_projJournalTable">
    /// The <c>ProjJournalTable</c> record to initialize.
    /// </param>
    /// <param name="_projJournalTableData">
    /// An instance of the <c>ProjJournalTableData</c> class, which the initialized
    /// <c>ProjJournalTable</c> record is associated.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Throws an error, if the <c>ProjJournalTable</c> record cannot be initialized correctly.
    /// </exception>
    private void newJournal_Proj(ProjJournalTable _projJournalTable, ProjJournalTableData _projJournalTableData)
    {
        ProjJournalNameId projJournalNameId;

        if (_projJournalTable.JournalId)
        return;

        ttsbegin;
        projJournalNameId = JmgParameters::find().ProjJournalNameId;

        if (!projJournalNameId)
        {
            throw error("@SYS329335");
        }

        _projJournalTableData.initFromJournalName(ProjJournalName::find(projJournalNameId));
        _projJournalTable.Description    = "@SYS38526";
        _projJournalTable.JournalType    = ProjJournalType::Hour;
        _projJournalTable.insert();
        ttscommit;

        if (!_projJournalTable.JournalId)
        throw error(strFmt("@SYS22828",funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProfileDate</Name>
				<Source><![CDATA[
    public JmgProfileDate parmProfileDate(JmgProfileDate _profileDate = profileDate)
    {
        profileDate = _profileDate;
        return profileDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWorker</Name>
				<Source><![CDATA[
    public JmgWorkerRecId parmWorker(JmgWorkerRecId _worker = worker)
    {
        worker = _worker;
        return worker;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWrkCtrPilot</Name>
				<Source><![CDATA[
    public JmgWrkCtrIdPilot parmWrkCtrPilot(JmgWrkCtrIdPilot _wrkCtrIdPilot = wrkCtrIdPilot)
    {
        wrkCtrIdPilot = _wrkCtrIdPilot;
        return wrkCtrIdPilot;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreateEmptyQtyBomJournalLine</Name>
				<Source><![CDATA[
    internal boolean parmCreateEmptyQtyBomJournalLine(boolean _createEmptyQtyBomJournalLine = createEmptyQtyBomJournalLine)
    {
        createEmptyQtyBomJournalLine = _createEmptyQtyBomJournalLine;

        return createEmptyQtyBomJournalLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWProdQtyError</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is returning the Error Quantity reported on the Production Order in catch weight unit.
    /// </summary>
    /// <param name="_endJob">
    /// Production Job - is it the last report as finished - production status changes to reported as finished - yes or no.
    /// </param>
    /// <param name="_prodJob">
    /// Production Job Type.
    /// </param>
    /// <param name="_worker">
    /// Worker from the production job.
    /// </param>
    /// <param name="_jmgErrorSpecification">
    /// Error Specfication Descritption.
    /// </param>
    /// <returns>
    /// Error Quantity Reported on the Production Order in catch weight unit.
    /// </returns>
    /// <remarks>
    /// Only post error quantities on the last report as finished journal.
    /// </remarks>
    [SysObsolete('This method is deprecated because it is not used anymore. Please, use pdsCWTotalProdQtyError method instead.', true, 21\04\2020)]
    protected PdsCWBatchErr pdsCWProdQtyError(ProdEndJob _endJob, JmgTermJob_Prod _prodJob, JmgWorkerRecId _worker, JmgErrorSpecification _jmgErrorSpecification)
    {
        JmgStampJournalTrans    jmgStampJournalTransSum;
        JmgStampTrans           jmgStampTransSum;
        PdsCWBatchErr           cwBatchError;

        if (_endJob && _prodJob.prodJobType() == RouteJobType::Process)
        {
            select sum(PdsCWQtyError) from jmgStampJournalTransSum
            where jmgStampJournalTransSum.Module    == JmgModuleEnum::PROD
                && jmgStampJournalTransSum.JobRef   == _prodJob.jobRef()
                && (jmgStampJournalTransSum.Worker  != _worker
                ||  (jmgStampJournalTransSum.Worker == _worker
                &&   jmgStampJournalTransSum.Active == NoYes::No));

            select sum(PdsCWQtyError) from jmgStampTransSum
            where jmgStampTransSum.Module == JmgModuleEnum::PROD
                && jmgStampTransSum.JobRef == _prodJob.jobRef();

            cwBatchError = jmgStampJournalTransSum.PdsCWQtyError + jmgStampTransSum.PdsCWQtyError + JmgErrorSpecificationForm::getTotalPdsCWErrorQuantity(_jmgErrorSpecification);
        }
        else
        {
            cwBatchError = 0;
        }

        return cwBatchError;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWTotalProdQtyError</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is returning the Error Quantity reported on the Production Order in catch weight unit.
    /// </summary>
    /// <param name="_endJob">
    /// Production Job - is it the last report as finished - production status changes to reported as finished - yes or no.
    /// </param>
    /// <param name="_prodJob">
    /// Production Job Type.
    /// </param>
    /// <param name="_jmgErrorSpecification">
    /// Error specification description.
    /// </param>
    /// <returns>
    /// Error Quantity Reported on the Production Order in catch weight unit.
    /// </returns>
    /// <remarks>
    /// Only post error quantities on the last report as finished journal.
    /// </remarks>
    protected PdsCWBatchErr pdsCWTotalProdQtyError(ProdEndJob _endJob, JmgTermJob_Prod _prodJob, JmgErrorSpecification _jmgErrorSpecification)
    {
        PdsCWBatchErr           cwBatchError = 0;

        if (_endJob && _prodJob.prodJobType() == RouteJobType::Process)
        {
            JmgStampJournalTrans    jmgStampJournalTransSum;
            JmgStampTrans           jmgStampTransSum;

            select sum(PdsCWQtyError) from jmgStampJournalTransSum
            where jmgStampJournalTransSum.Module    == JmgModuleEnum::PROD
                && jmgStampJournalTransSum.JobRef   == _prodJob.jobRef();

            select sum(PdsCWQtyError) from jmgStampTransSum
            where jmgStampTransSum.Module == JmgModuleEnum::PROD
                && jmgStampTransSum.JobRef == _prodJob.jobRef();

            cwBatchError = jmgStampJournalTransSum.PdsCWQtyError + jmgStampTransSum.PdsCWQtyError + JmgErrorSpecificationForm::getTotalPdsCWErrorQuantity(_jmgErrorSpecification);
        }

        return cwBatchError;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postIPCTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts time based on the added jobs that refer to time collected on indirect activities.
    /// </summary>
    protected void postIPCTime()
    {
        JmgIpcJournalTable  jmgIpcJournalTable;
        LineNum             lineNum;

        for (int i = 1; i <= jobs.lastIndex(); i++)
        {
            JmgTermJob job = jobs.value(i);
            if (job.module() == JmgModuleEnum::IPC)
            {
                JmgTermJob_IPC ipcJob  = job;
                JmgStampTransMap jmgStampTransMap = jobTime.value(i);

                if ((ipcJob.signType() == JmgSignInOut::Job
                    || ipcJob.signType() == JmgSignInOut::SysIndirect)
                    && jmgStampTransMap)
                {
                    lineNum++;
                    if (!jmgIpcJournalTable)
                    {
                        jmgIpcJournalTable.initValue();
                        jmgIpcJournalTable.Description  = "@SYS38526";
                        jmgIpcJournalTable.insert();
                    }
                    
                    JmgIpcJournalTrans jmgIpcJournalTrans = this.initializeIpcJournalTransaction(jmgIpcJournalTable, ipcJob, jmgStampTransMap, lineNum);
                    jmgIpcJournalTrans.insert();
                }
            }
        }

        if (jmgIpcJournalTable)
        {
            JmgIPCCheckPost jmgIPCCheckPost = JmgIPCCheckPost::construct(jmgIpcJournalTable.ipcJournalId);
            jmgIPCCheckPost.run();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeIpcJournalTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes IPC journal transaction table buffer.
    /// </summary>
    /// <param name = "_jmgIpcJournalTable">The IPC journal table buffer.</param>
    /// <param name = "_ipcJob">The IPC job to use when creating IPC journal transaction.</param>
    /// <param name = "_jmgStampTransMap">A registration that is made on the specified job.</param>
    /// <param name = "_lineNum">The line number for which to create journal transaction.</param>
    /// <returns>
    /// The IPC journal transaction table buffer.
    /// </returns>
    protected JmgIpcJournalTrans initializeIpcJournalTransaction(JmgIpcJournalTable  _jmgIpcJournalTable, JmgTermJob_IPC _ipcJob, JmgStampTransMap _jmgStampTransMap, LineNum _lineNum)
    {
        JmgIpcJournalTrans  jmgIpcJournalTrans;

        jmgIpcJournalTrans.ipcJournalId     = _jmgIpcJournalTable.ipcJournalId;
        jmgIpcJournalTrans.Description      = _ipcJob.jobDescription();
        jmgIpcJournalTrans.Worker           = worker;
        jmgIpcJournalTrans.FromDateTime     = DateTimeUtil::newDateTime(_jmgStampTransMap.StartDate, _jmgStampTransMap.StartTime, DateTimeUtil::getUserPreferredTimeZone());
        jmgIpcJournalTrans.ToDateTime       = DateTimeUtil::newDateTime(_jmgStampTransMap.StopDate, _jmgStampTransMap.StopTime, DateTimeUtil::getUserPreferredTimeZone());
        jmgIpcJournalTrans.initFromJmgIpcActivity(_ipcJob.sourceData());
        jmgIpcJournalTrans.LineNum          = _lineNum;
        jmgIpcJournalTrans.Hours            = _jmgStampTransMap.Seconds / 3600;

        return jmgIpcJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjTransCostPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the cost price based on the project journal, transfer journal registrations, and logbook. 
    /// </summary>
    /// <param name = "_projJournalTrans">
    /// The <c>ProjJournalTrans</c> record to calculate the cost price from.
    /// </param>
    /// <param name = "_jmgStampTrans">
    /// Journal registrations related to the <c>ProjJournalTrans</c> record.
    /// </param>
    /// <param name = "_jmgStampTransMap">
    /// A logbook registration on the specified record.
    /// </param>
    /// <returns>
    /// A container contains the calculated sales price.
    /// </returns>
    protected CostPrice getProjTransCostPrice(ProjJournalTrans _projJournalTrans, JmgStampTrans _jmgStampTrans, JmgStampTransMap _jmgStampTransMap)
    {
        CostPrice costPrice;

        if (_projJournalTrans.Qty < 0)
        {
            costPrice = this.getReversedHourPrice(_jmgStampTransMap);
        }
        else
        {
            _jmgStampTrans = _jmgStampTransMap.JmgStampTransMap::getStampTrans();
            if (_jmgStampTrans && JmgParameters::find().CostUseStandardCostProj == NoYes::No)
            {
                costPrice = _jmgStampTrans.HourPrice;
            }
            else
            {
                ProjPriceParameters priceParams = this.instantiateProjectPriceParametersForHourCostPriceLookup(_projJournalTrans);
                costPrice = ProjHourCostPrice::findCostPriceByPriceParameters(priceParams, false);
            }
        }

        return costPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateProjectPriceParametersForHourCostPriceLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates a <c>ProjPriceParameters</c> parameter class instance.
    /// </summary>
    /// <param name = "_projJournalTrans">A project journal record.</param>
    /// <returns>The <c>ProjPriceParameters</c> class instance.</returns>
    protected ProjPriceParameters instantiateProjectPriceParametersForHourCostPriceLookup(ProjJournalTrans _projJournalTrans)
    {
        ProjPriceParameters priceParams = ProjHourCostPrice::constructPriceParametersForFindCostPrice(
                    _projJournalTrans.ProjId,
                    _projJournalTrans.Resource,
                    _projJournalTrans.CategoryId,
                    _projJournalTrans.LinePropertyId,
                    _projJournalTrans.TransDate,
                    '',
                    '',
                    '',
                    _projJournalTrans.ResourceCategory);

        return priceParams;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postProjTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts time based on the added jobs that refer to time collected on projects and project activities.
    /// </summary>
    protected void postProjTime()
    {
        boolean                     projTimeAdjusted;
        int                         i;
        JmgTermJob                  job;
        JmgTermJob_Proj             projJob;
        JmgRegistrationParameters   feedback;
        JmgStampTransMap            jmgStampTransMap;
        JmgStampTrans               jmgStampTrans;
        ProjJournalTrans            projJournalTrans;
        ProjJournalTable            projJournalTable;
        ProjJournalTableData        projJournalTableData;
        ProjJournalTransData        projJournalTransData;
        ProjTable                   projTable;
        ProjActivity                projActivity;
        ProjJournalCheckPost        projJournalCheckPost;

        ProjAdjustmentSelect        projAdjustmentSelect;
        ProjAdjustmentSplit         projAdjustmentSplit;
        TmpProjAdjustment           tmpProjAdjustment;
        TmpProjAdjustmentCost       tmpProjAdjustmentCost;
        TmpProjAdjustmentSale       tmpProjAdjustmentSale;
        TmpProjAdjustmentCreate     tmpProjAdjustmentCreate;
        TmpProjAdjustmentCreateCost tmpProjAdjustmentCreateCost;
        TmpProjAdjustmentCreateSale tmpProjAdjustmentCreateSale;
        ProjEmplTrans               projEmplTrans;
        ProjJournalTable            deleteProjJournalTable;
        ProjJournalTrans            deleteProjJournalTrans;
        ProjJournalId               deleteProjJournalId;
        Args                        args;

        for (i = 1; i <= jobs.lastIndex(); i++)
        {
            job = jobs.value(i);
            feedback = jobParameters.value(i);
            jmgStampTransMap = jobTime.value(i);

            if (job.module() == JmgModuleEnum::PROJ)
            {
                projJob = job;
                projTimeAdjusted = false;
                // Try to adjust posted proj time
                if (invertTime  && jmgStampTransMap.ProjEmplTransId)
                {
                    projEmplTrans = ProjEmplTrans::find(jmgStampTransMap.ProjEmplTransId);
                    if (projEmplTrans && ProjTrans::construct(projEmplTrans).adjustable())
                    {
                        projAdjustmentSelect = this.initializeProjAdjustmentSelect(projEmplTrans);
                        projAdjustmentSelect.runOperation();

                        tmpProjAdjustment.linkPhysicalTableInstance(projAdjustmentSelect.tmpProjAdjustment());
                        tmpProjAdjustmentCost.linkPhysicalTableInstance(projAdjustmentSelect.tmpProjAdjustmentCost());
                        tmpProjAdjustmentSale.linkPhysicalTableInstance(projAdjustmentSelect.tmpProjAdjustmentSale());
                        projAdjustmentSplit = new ProjAdjustmentSplit(
                            tmpProjAdjustmentCreate,
                            tmpProjAdjustmentCreateCost,
                            tmpProjAdjustmentCreateSale,
                            tmpProjAdjustment,
                            tmpProjAdjustmentCost,
                            tmpProjAdjustmentSale);
                        projAdjustmentSplit.parmProjQty(1);
                        projAdjustmentSplit.runOperation();
          
                        this.resetQuantityOnTmpProjAdjustmentCreate(tmpProjAdjustmentCreate, tmpProjAdjustment, projEmplTrans);

                        select firstonly tmpProjAdjustment;
                        args = new Args();
                        args.record(tmpProjAdjustment);
                        ProjAdjustmentUpdate::newPostAdjustment(
                            tmpProjAdjustmentCreate,
                            tmpProjAdjustmentCreateCost,
                            tmpProjAdjustmentCreateSale,
                            tmpProjAdjustment,
                            tmpProjAdjustmentCost,
                            tmpProjAdjustmentSale,
                            args);

                        jmgStampTransMap.ProjEmplTransId = '';
                        this.updateJmgStampJournal(jmgStampTransMap);
                        projTimeAdjusted = true;
                    }
                    else if (!projJournalTrans)
                    {
                        // Delete transaction from unposted journal
                        select firstonly forupdate deleteProjJournalTrans
                            where deleteProjJournalTrans.TransId    == jmgStampTransMap.ProjEmplTransId
                            exists join deleteProjJournalTable
                            where deleteProjJournalTable.JournalId  == deleteProjJournalTrans.JournalId    &&
                                  deleteProjJournalTable.Posted     == NoYes::No;
                        if (deleteProjJournalTrans)
                        {
                            deleteProjJournalId = deleteProjJournalTrans.JournalId;
                            deleteProjJournalTrans.delete();
                            projTimeAdjusted = true;

                            // Delete the journal if it is empty.
                            delete_from deleteProjJournalTable
                                where deleteProjJournalTable.JournalId  == deleteProjJournalId
                                notexists join deleteProjJournalTrans
                                where deleteProjJournalTrans.JournalId  == deleteProjJournalTable.JournalId;
                        }
                    }
                }

                if (!this.mustCreateProjectJournalTrans(projTimeAdjusted, jmgStampTransMap))
                {
                    projJournalTrans.TransId = '';

                    if (!projJournalTable.JournalId)
                    {
                        projJournalTableData    = new ProjJournalTableData(projJournalTable);
                        this.newJournal_Proj(projJournalTable, projJournalTableData);
                    }

                    if (!projJournalTransData)
                    {
                        projJournalTransData    = new ProjJournalTransData(projJournalTrans, projJournalTableData);
                        projJournalTransData.initFromJournalTable();
                    }

                    projTable   = projJob.projTable();
                    if (projJob.actOprId())
                    {
                        projActivity = ProjActivity::find(projJob.actOprId());
                        projJournalTrans.initFromProjActivity(projActivity);
                    }

                    JmgPostStandardSystemParameters jmgPostStandardSystemParameters = this.instantiateJmgPostStandardSystemParameters(projJournalTrans, jmgStampTransMap, feedback, projJob, projTable, projJournalTransData);
                    projJournalTrans = this.initializeProjJournalTrans(jmgPostStandardSystemParameters);

                    projJournalTrans.CostPrice = this.getProjTransCostPrice(projJournalTrans, jmgStampTrans, jmgStampTransMap);
                    [projJournalTrans.SalesPrice] = this.calculateProjJournalTransSalesPrice(projJournalTrans, jmgStampTrans);

                    if (invertTime)
                    {
                        projJournalTrans.Qty    = -projJournalTrans.Qty;
                        jmgStampTransMap.ProjEmplTransId    = '';
                        this.updateJmgStampJournal(jmgStampTransMap);
                    }

                    this.createProjJournalTransData(projJournalTransData);

                    this.updateTotalsForProjJournalTable(projJournalTableData);
                }
            }
        }
        if (projJournalTable.JournalId && JmgParameters::find().PostAutomaticallyProj == NoYes::Yes)
        {
            projJournalCheckPost = ProjJournalCheckPost::newJournalCheckPost(true,false,JournalCheckPostType::Post,projJournalTable.TableId,projJournalTable.JournalId);
            projJournalCheckPost.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateProjectJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether project journal transaction must be created
    /// </summary>
    /// <param name = "_projTimeAdjusted">Indicates whether project time is adjusted.</param>
    /// <param name = "_jmgStampTransMap">The current <c>JmgStampTransMap</c> record.</param>
    /// <returns>true if project journal transaction must be created; otherwise, false</returns>
    protected boolean mustCreateProjectJournalTrans(boolean _projTimeAdjusted, JmgStampTransMap _jmgStampTransMap)
    {
        return _projTimeAdjusted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the project journal.
    /// </summary>
    /// <param name = "_jmgPostStandardSystemParameters">An instance of the <c>JmgPostStandardSystemParameters</c> class.</param>
    /// <returns>A project journal table buffer.</returns>
    protected ProjJournalTrans initializeProjJournalTrans(JmgPostStandardSystemParameters _jmgPostStandardSystemParameters)
    {
        JmgProfileDate              profileDateLocal;
        ProjJournalTrans            projJournalTrans = _jmgPostStandardSystemParameters.parmProjJournalTrans();
        jmgStampTransMap            jmgStampTransMap = _jmgPostStandardSystemParameters.parmJmgStampTransMap();
        JmgTermJob_Proj             projJob = _jmgPostStandardSystemParameters.parmProjJob();

        projJournalTrans.CategoryId = _jmgPostStandardSystemParameters.parmFeedback().costCategory();
        projJournalTrans.TaxItemGroupId =   ProjCategory::find(projJournalTrans.CategoryId).TaxItemGroupId;

        if (jmgStampTransMap.ProfileDate)
        {
            profileDateLocal = jmgStampTransMap.ProfileDate;
        }
        else
        {
            profileDateLocal = this.parmProfileDate();
        }

        projJournalTrans.TransDate      = profileDateLocal;
        projJournalTrans.ProjTransDate  = profileDateLocal;

        projJournalTrans.Resource   = ResourceFacade::findOrCreateByWorker(worker);
        projJournalTrans.setResourceCategory();
        projJournalTrans.ProjId     = projJob.jobRef();
        projJournalTrans.ActivityNumber = projJob.actOprId();
        projJournalTrans.initFromProjTable(_jmgPostStandardSystemParameters.parmProjTable());

        projJournalTrans.Qty = decRound((jmgStampTransMap.Seconds) / 3600, JmgPostStandardSystem::qtyDecimals);

        _jmgPostStandardSystemParameters.parmProjJournalTransData().initVoucher('',false);

        projJournalTrans.DefaultDimension   = jmgStampTransMap.DefaultDimension;
        projJournalTrans.FromTime           = jmgStampTransMap.StartTime;
        projJournalTrans.ToTime             = jmgStampTransMap.StopTime;

        return projJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJmgStampJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates logbook.
    /// </summary>
    /// <param name = "_jmgStampTransMap">The current <c>JmgStampTransMap</c> record.</param>
    protected void updateJmgStampJournal(JmgStampTransMap _jmgStampTransMap)
    {
        _jmgStampTransMap.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjAdjustmentSelect</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>ProjAdjustmentSelect</c> class.
    /// </summary>
    /// <param name = "_projEmplTrans">The current <c>ProjEmplTrans</c> record.</param>
    /// <returns>
    /// An instance of <c>ProjAdjustmentSelect</c> class.
    /// </returns>
    protected ProjAdjustmentSelect initializeProjAdjustmentSelect(ProjEmplTrans _projEmplTrans)
    {
        ProjAdjustmentSelect        projAdjustmentSelect;
        List                        recordList;

        recordList  = new List(Types::Record);
        recordList.addEnd(_projEmplTrans);

        projAdjustmentSelect = ProjAdjustmentSelect::construct('', '', '');
        projAdjustmentSelect.parmQueryEmpl(NoYes::Yes);
        projAdjustmentSelect.parmTransIdList(recordList.pack());

        return projAdjustmentSelect;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetQuantityOnTmpProjAdjustmentCreate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reset the quantity on <c>TmpProjAdjustmentCreate</c> table buffer.
    /// </summary>
    /// <param name = "_tmpProjAdjustmentCreate">The current <c>TmpProjAdjustmentCreate</c> table buffer.</param>
    /// <param name = "_tmpProjAdjustment">The current <c>TmpProjAdjustment</c> table buffer.</param>
    /// <param name = "_projEmplTrans">The current <c>ProjEmplTrans</c> record.</param>
    protected void resetQuantityOnTmpProjAdjustmentCreate(TmpProjAdjustmentCreate _tmpProjAdjustmentCreate, TmpProjAdjustment _tmpProjAdjustment, ProjEmplTrans _projEmplTrans)
    {
        update_recordset _tmpProjAdjustmentCreate
            setting Qty = 0
            where   _tmpProjAdjustmentCreate.AdjustOrig == NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjJournalTransData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates journal lines.
    /// </summary>
    /// <param name = "_projJournalTransData">The instance of the <c>ProjJournalTransData</c> class.</param>
    protected void createProjJournalTransData(ProjJournalTransData _projJournalTransData)
    {
        _projJournalTransData.create();
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateJmgPostStandardSystemParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a <c>JmgPostStandardSystemParameters</c> parameter class instance.
    /// </summary>
    /// <param name = "_projJournalTrans">The project journal record.</param>
    /// <param name = "_jmgStampTransMap">The current <c>JmgStampTransMap</c> record.</param>
    /// <param name = "_feedback">Job Registration Helper Class object providing the production job feedback status</param>
    /// <param name = "_projJob">The instance of <c>JmgTermJob_Proj</c> class.</param>
    /// <param name = "_projTable">The current <c>ProjTable</c> record.</param>
    /// <param name = "_projJournalTransData">The instance of the <c>ProjJournalTransData</c> class.</param>
    /// <returns>The instance of the <c>JmgPostStandardSystemParameters</c> class.</returns>
    protected JmgPostStandardSystemParameters instantiateJmgPostStandardSystemParameters(
        ProjJournalTrans            _projJournalTrans,
        JmgStampTransMap            _jmgStampTransMap,
        JmgRegistrationParameters   _feedback,
        JmgTermJob_Proj             _projJob,
        ProjTable                   _projTable,
        ProjJournalTransData        _projJournalTransData)
    {
        JmgPostStandardSystemParameters jmgPostStandardSystemParameters = JmgPostStandardSystemParameters::construct();

        jmgPostStandardSystemParameters.parmProjJournalTrans(_projJournalTrans);
        jmgPostStandardSystemParameters.parmJmgStampTransMap(_jmgStampTransMap);
        jmgPostStandardSystemParameters.parmFeedback(_feedback);
        jmgPostStandardSystemParameters.parmProjJob(_projJob);
        jmgPostStandardSystemParameters.parmProjTable(_projTable);
        jmgPostStandardSystemParameters.parmProjJournalTransData(_projJournalTransData);

        return jmgPostStandardSystemParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateProjJournalTransSalesPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the sales price for the passed <c>ProjJournalTrans</c> record.
    /// </summary>
    /// <param name = "_projJournalTrans">
    /// The <c>ProjJournalTrans</c> record to calculate the sales price for.
    /// </param>
    /// <param name = "_jmgStampTrans">
    /// The <c>JmgStampTrans</c> record used to create the <c>ProjJournalTrans</c>
    /// </param>
    /// <returns>
    /// A container contains the calculated sales price.
    /// </returns>
    [Replaceable]
    protected container calculateProjJournalTransSalesPrice(ProjJournalTrans _projJournalTrans, JmgStampTrans _jmgStampTrans)
    {
        ProjPriceParameters priceParams = ProjHourSalesPrice::constructPriceParametersForFindHourSalesPrice(
			_projJournalTrans.ProjId,
            _projJournalTrans.Resource,
            _projJournalTrans.CategoryId,
            _projJournalTrans.LinePropertyId,
            _projJournalTrans.CostPrice,
            _projJournalTrans.CurrencyId,
            _projJournalTrans.TransDate,
            '',
            '',
            '',
            _projJournalTrans.ResourceCategory);
        return ProjHourSalesPrice::findHourSalesPriceByPriceParameters(priceParams, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts qty based on the added jobs that refer to time collected on productions.
    /// </summary>
    /// <param name="_jmgStampJournalTrans">
    ///    A registration that is made on the specified job.
    /// </param>
    public void postQty(JmgStampJournalTrans _jmgStampJournalTrans)
    {
        List prodJournalCheckPostList;

        prodJournalCheckPostList = this.createProdStatusQty();
        JmgPostStandardSystem::postQtyJournalsList(
            prodJournalCheckPostList,
            _jmgStampJournalTrans.StartDate,
            _jmgStampJournalTrans.StartTime,
            _jmgStampJournalTrans.StartTime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts time based on the added jobs that refer to time collected on productions.
    /// </summary>
    public void postTime()
    {
        ProdJournalRoute    prodJournalRoute;
        ProdJobType         prodJobType;
        RouteJobType        routeJobType;

        ProdJournalTransDataRoute   journalTransDataRoute;
        ProdJournalTable            prodJournalTable_JobCard;
        ProdJournalTableData        journalTableData_JobCard;
        ProdJournalCheckPostRoute   prodJournalCheckPost;

        JmgTermJob                  job;
        JmgTermJob_Prod             prodJob;
        JmgRegistrationParameters   feedback;
        int                         i;
        JmgStampTransMap            jmgStampTransMap;
        ProdId                      prodId;
        InventDimId                 siteInventDim;

        // Post production time
        Map journalTableDataMap = new Map(Types::String, Types::Class);
        Map journalTransDataMap = new Map(Types::String, Types::Class);
        Map prodJournalTableMap = new Map(Types::String, Types::Record);
        Map prodSitesMap        = new Map(Types::String, Types::String);
        for (i = 1; i <= jobs.lastIndex(); i++)
        {
            job = jobs.value(i);
            feedback = jobParameters.value(i);
            jmgStampTransMap = jobTime.value(i);

            this.updatedOriginalTransactionOnJournal(jmgStampTransMap);

            if (job.module() == JmgModuleEnum::PROD)
            {
                prodJob = job;

                prodId = prodJob.jobRef();
                routeJobType = prodJob.prodJobType();
                feedback = jobParameters.value(i);

                if (FeatureStateProvider::isFeatureEnabled(JmgDecoupleMesAndTAAFeature::instance()))
                {
                    RouteGroup jobRouteGroup = prodJob.prodRoute().routeGroup();
                    ProdTable prodTable = ProdTable::find(prodId);
                    // do not post real time if Only use estimated time checked
                    if (jobRouteGroup.AutoProcessTime || 
                        (prodTable.ProdStatus == ProdStatus::Completed && JmgProdParametersDim::find(prodJob.siteInventDimId()).SkipTimeAdjustments == NoYes::Yes))
                    {
                        continue;
                    }
                }

                if (jmgStampTransMap)
                {
                    if (!prodJournalTableMap.exists(prodId))
                    {
                        prodJournalTable_JobCard = null;
                        journalTableData_JobCard = JournalTableData::newTable(prodJournalTable_JobCard);
                        prodJournalTable_JobCard.ProdId = prodJob.jobRef();
                        this.newJournal_JobCard(journalTableData_JobCard, prodJournalTable_JobCard, true);

                        prodJournalRoute = null;
                        journalTransDataRoute = journalTableData_JobCard.journalStatic().newJournalTransData(prodJournalRoute, journalTableData_JobCard);
                        journalTransDataRoute.initFromJournalTable();

                        prodJournalTableMap.insert(prodId, prodJournalTable_JobCard);
                        journalTableDataMap.insert(prodId, journalTableData_JobCard);
                        journalTransDataMap.insert(prodId, journalTransDataRoute);
                        prodSitesMap.insert(prodId, prodJob.siteInventDimId());
                    }
                    else
                    {
                        prodJournalTable_JobCard    = prodJournalTableMap.lookup(prodId);
                        journalTableData_JobCard    = journalTableDataMap.lookup(prodId);
                        journalTransDataRoute       = journalTransDataMap.lookup(prodId);
                        prodJournalRoute            = journalTransDataRoute.journalTrans();
                    }

                    prodJobType = ProdJobType::construct(routeJobType);
                    prodJobType.initProdJournalRoute(prodJob.prodRoute(), prodJournalRoute, ProdRouteJob::findJobId(prodJob.jobId()), true);
                    this.setupProdJournalRoute(prodJournalRoute, feedback, prodJob, prodJournalTable_JobCard, jmgStampTransMap);


                    if (prodJournalRoute.Hours || prodJournalRoute.FromTime != prodJournalRoute.ToTime)
                    {
                        journalTransDataRoute.create();
                        if (prodJournalRoute.isProjMethodConsumed())
                        {
                            JmgPostStandardSystem::createProjTransFromProdJournalRoute(prodJournalRoute , prodJobType);
                        }
                        // prodJournalTable_JobCard has changed during creation of journal line.
                        prodJournalTable_JobCard = journalTransDataRoute.journalTableData().journalTable();
                        prodJournalTable_JobCard.update();
                        prodJournalTableMap.insert(prodId, prodJournalTable_JobCard);
                    }
                }
            }
        }

        MapEnumerator enumerator = prodJournalTableMap.getEnumerator();
        while (enumerator.moveNext())
        {
            prodId             = enumerator.currentKey();
            prodJournalTable_JobCard    = prodJournalTableMap.lookup(prodId);
            journalTableData_JobCard    = journalTableDataMap.lookup(prodId);
            siteInventDim = prodSitesMap.lookup(prodId);

            // Update journal after creation of lines
            ttsbegin;
            prodJournalTable_JobCard.update();
            ttscommit;

            if (prodJournalTable_JobCard.JournalId && JmgProdParametersDim::find(siteInventDim).PostTimeAutomatically == NoYes::Yes)
            {
                if (JmgProdParameters::find().StampLevel == JmgStampLevel::Route)
                {
                    prodJournalCheckPost = ProdJournalCheckPostRoute::newJournalCheckPost(true, false, JournalCheckPostType::Post, prodJournalTable_JobCard.TableId, prodJournalTable_JobCard.JournalId);
                }
                else
                {
                    prodJournalCheckPost = ProdJournalCheckPostRouteJob::newJournalCheckPost(true, false, JournalCheckPostType::Post, prodJournalTable_JobCard.TableId, prodJournalTable_JobCard.JournalId);
                }

                // Ended production route job won't be rescheduled when posting route card job
                prodJournalCheckPost.parmIsRouteCardPosting(true);
                prodJournalCheckPost.runOperation();
            }
        }

        // Post project time
        this.postProjTime();

        // Post IPC time
        this.postIPCTime();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupProdJournalRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the prodJournalRoute record
    /// </summary>
    /// <param name = "_prodJournalRoute"> The prodJournalRoute record to be initialized. </param>
    /// <param name = "_feedback"> The feedback of the current job. </param>
    /// <param name = "_prodJob"> The current job. </param>
    /// <param name = "_prodJournalTable_JobCard"> The <c>ProdJournalTable</c> record. </param>
    /// <param name = "_jmgStampTransMap"> A registration that is made on the specified job. </param>
    protected void setupProdJournalRoute(ProdJournalRoute           _prodJournalRoute, 
                                         JmgRegistrationParameters  _feedback, 
                                         JmgTermJob_Prod            _prodJob, 
                                         ProdJournalTable           _prodJournalTable_JobCard,
                                         JmgStampTransMap           _jmgStampTransMap)
    {

        if (! _prodJournalRoute.ProdId)
        {
            _prodJournalRoute.ProdId     = _prodJob.jobRef();
        }

        _prodJournalRoute.JournalId      = _prodJournalTable_JobCard.JournalId;
        _prodJournalRoute.TransDate      = _jmgStampTransMap.ProfileDate;
        _prodJournalRoute.Hours          = decRound((_jmgStampTransMap.Seconds) / 3600, JmgPostStandardSystem::hourDecimals);
        if (invertTime)
        {
            _prodJournalRoute.Hours      = -1 * _prodJournalRoute.Hours;
        }

        if (_prodJournalRoute.Hours  < 0.01 && _jmgStampTransMap.Seconds >= 0.00)
        {
            _prodJournalRoute.Hours  = 0.01;
        }
        else if (_prodJournalRoute.Hours  > -0.01 && _jmgStampTransMap.Seconds < 0.00)
        {
            _prodJournalRoute.Hours  = -0.01;
        }

        _prodJournalRoute.FromTime       = _jmgStampTransMap.StartTime;
        _prodJournalRoute.ToTime         = _jmgStampTransMap.StopTime;
        _prodJournalRoute.JobFinished    = _feedback.reportAsFinished() == JmgFeedbackStatus::Completed;
        _prodJournalRoute.Worker         = worker;
        if (wrkCtrIdPilot)
        {
            _prodJournalRoute.WrkCtrId   = wrkCtrIdPilot;
        }
        else
        {
            _prodJournalRoute.WrkCtrId   = _feedback.wrkCtrId();
            if (!_prodJournalRoute.WrkCtrId)
            {
                _prodJournalRoute.WrkCtrId = _prodJob.jmgJobTable().WrkCtrId;
            }
        }
        _prodJournalRoute.ProdPickList   = NoYes::No;

        switch (JmgProdParameters::find().StampLevel)
        {
            case JmgStampLevel::Job :
                _prodJournalRoute.JobId          = _prodJob.jobId();
                _prodJournalRoute.ExecutedPct    = _prodJournalRoute.proposalJobExecutedPct();
                break;

            case JmgStampLevel::Route :
                _prodJournalRoute.OprId          = _prodJob.prodRoute().OprId;
                _prodJournalRoute.OprNum         = _prodJob.prodRoute().OprNum;
                _prodJournalRoute.JobType        = _prodJob.prodJobType();
                _prodJournalRoute.ExecutedPct    = _prodJournalRoute.proposalRouteExecutedPct(_prodJob.prodRoute());
                break;
        }

        if (JmgProdJourRouteDefaultParmDefaultDimensionFlight::instance().isEnabled())
        {
            _prodJournalRoute.DefaultDimension = _prodJournalRoute.copyDimension(_jmgStampTransMap.DefaultDimension);
        }
        else
        {
            _prodJournalRoute.DefaultDimension = _prodJournalRoute.mergeDimension(_prodJournalRoute.DefaultDimension, _jmgStampTransMap.DefaultDimension);
        }

        ProdHourPrice fallBackHourPrice = _prodJournalRoute.HourPrice;
        _prodJournalRoute.HourPrice = this.getHourPrice(_prodJournalRoute, _jmgStampTransMap);

        if (_prodJournalRoute.HourPrice == 0
            && fallBackHourPrice != 0 
            && JmgProdJournalRouteReversedHourPriceFallBackFlight::instance().isEnabled())
        {
            _prodJournalRoute.HourPrice = fallBackHourPrice;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getHourPrice</Name>
				<Source><![CDATA[
    private final ProdHourPrice getHourPrice(ProdJournalRoute _prodJournalRoute, JmgStampTransMap _jmgStampTransMap)
    {
        ProdHourPrice hourPrice = _prodJournalRoute.HourPrice;
        ProdReportedHours reportedHours = _prodJournalRoute.Hours;
       
        if (reportedHours < 0)
        {
            hourPrice = this.getReversedHourPrice(_jmgStampTransMap);
        }
        else
        {
            JmgStampTrans jmgStampTrans = _jmgStampTransMap.JmgStampTransMap::getStampTrans();
            if (jmgStampTrans)
            {
                hourPrice  = jmgStampTrans.HourPrice;
            }
        }        

        return hourPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodQtyError</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is returning the Error Quantity reported on the Production Order.
    /// </summary>
    /// <param name="_endJob">
    /// Production Job - is it the last report as finished - production status changes to reported as finished - yes or no.
    /// </param>
    /// <param name="_prodJob">
    /// Production Job Type.
    /// </param>
    /// <param name="_worker">
    /// Worker from the production job.
    /// </param>
    /// <param name="_jmgErrorSpecification">
    /// Error specification description.
    /// </param>
    /// <returns>
    /// Error Quantity Reported on the Production Order.
    /// </returns>
    /// <remarks>
    /// Only post error quantities on the last report as finished journal.
    /// </remarks>
    [SysObsolete('This method is deprecated because it is not used anymore. Please, use totalProdQtyError method instead.', true, 21\04\2020)]
    protected ProdReportedError  prodQtyError(ProdEndJob _endJob, JmgTermJob_Prod _prodJob, JmgWorkerRecId _worker, JmgErrorSpecification _jmgErrorSpecification)
    {
        ProdReportedError           prodReportedError;

        if (_endJob && _prodJob.prodJobType() == RouteJobType::Process)
        {
            prodReportedError = (JmgJobStatusFactory::buildJmgJobStatusInstance()).calculateErrorQtyToReportAsFinished(_prodJob, _jmgErrorSpecification);
        }
        else
        {
            prodReportedError = 0;
        }
        return prodReportedError;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalProdQtyError</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is returning the Error Quantity reported on the Production Order.
    /// </summary>
    /// <param name="_endJob">
    /// Production Job - is it the last report as finished - production status changes to reported as finished - yes or no.
    /// </param>
    /// <param name="_prodJob">
    /// Production Job Type.
    /// </param>
    /// <param name="_jmgErrorSpecification">
    /// Error specification description.
    /// </param>
    /// <returns>
    /// Error Quantity Reported on the Production Order.
    /// </returns>
    /// <remarks>
    /// Only post error quantities on the last report as finished journal.
    /// </remarks>
    protected ProdReportedError  totalProdQtyError(ProdEndJob _endJob, JmgTermJob_Prod _prodJob, JmgErrorSpecification _jmgErrorSpecification)
    {
        ProdReportedError           prodReportedError = 0;

        if (_endJob && _prodJob.prodJobType() == RouteJobType::Process)
        {
            prodReportedError = (JmgJobStatusFactory::buildJmgJobStatusInstance()).calculateErrorQtyToReportAsFinished(_prodJob, _jmgErrorSpecification);
        }

        return prodReportedError;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodQtyErrorSpec</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds journal lines for the specified error quantities.
    /// </summary>
    /// <param name="_errors">
    /// A list of error quantities and error causes to add journal lines to.
    /// </param>
    /// <param name="journalTransDataRoute">
    /// An instance of the <c>ProdJournalTransDataRoute</c> class, which is used to generated the
    /// journal lines.
    /// </param>
    /// <param name="prodJournalRoute">
    /// An already initialized <c>ProdJournalRoute</c> record which is used to create journal lines for error quantities
    /// </param>
    private void prodQtyErrorSpec(JmgErrorSpecification _errors, ProdJournalTransDataRoute journalTransDataRoute, ProdJournalRoute prodJournalRoute)
    {
        Map nowErrors;
        MapIterator nowErrorsIterator;
        container   errorQty;

        Map toMap(JmgTmpErrorSpecification errorSpecification)
        {
            Map result;

            result = new Map(Types::Enum, Types::Container);

            while select ErrorCause, sum(QtyError)
            , sum(PdsCWQtyError)
            from errorSpecification
            group by ErrorCause
            {
                result.insert(errorSpecification.ErrorCause, [errorSpecification.QtyError, errorSpecification.PdsCWQtyError]);
            }
            return result;
        }

        nowErrors = toMap(JmgErrorSpecificationForm::decodeErrorSpecification(_errors));

        prodJournalRoute.QtyGood = 0;
        prodJournalRoute.PdsCWQtyGood = 0;

        nowErrorsIterator = new MapIterator(nowErrors);

        while (nowErrorsIterator.more())
        {
            // Change in postings.
            errorQty = nowErrorsIterator.value();
            prodJournalRoute.QtyError = conPeek(errorQty, 1);
            prodJournalRoute.PdsCWQtyError = conPeek(errorQty, 2);

            if (prodJournalRoute.QtyError)
            {
                prodJournalRoute.ErrorCause = nowErrorsIterator.key();
                journalTransDataRoute.create();
            }
            nowErrorsIterator.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>feedbackFinishedOnSameOpr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if endjob field on report as finished journal line should be marked.
    /// </summary>
    /// <param name="_prodJob">
    /// The current production job to feedback.
    /// </param>
    /// <returns>
    /// true if no other fedback with completed option on the same operation after this; otherwise, false.
    /// </returns>
    protected boolean feedbackFinishedOnSameOpr(JmgTermJob_Prod _prodJob)
    {
        boolean                     hitCurrentJob;
        JmgRegistrationParameters   jmgRegistrationParameters;
        JmgTermJob                  jmgTermJob;
        JmgTermJob_Prod             prodJob;
        boolean                     ret = true;
    
        for (int i = 1; i <= jobs.lastIndex(); i++)
        {
            jmgTermJob = jobs.value(i);
    
            if (hitCurrentJob)
            {
                if (jmgTermJob.module() == JmgModuleEnum::PROD)
                {
                    prodJob = jmgTermJob;
                    jmgRegistrationParameters = jobParameters.value(i);
                    if (jmgRegistrationParameters.reportAsFinished() == JmgFeedbackStatus::Completed
                        && prodJob.prodRoute().RecId == _prodJob.prodRoute().RecId)
                    {
                        ret = false;
                        break;
                    }
                }
            }
            else if (jmgTermJob.jobId() == _prodJob.jobId())
            {
                hitCurrentJob = true;
            }
        }
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldReportAsFinished</Name>
				<Source><![CDATA[
    /// <summary>
    /// Should this production job be reported as finished
    /// </summary>
    /// <param name="jmgProdParametersDim">
    /// JMG Production Parameter - Is it the last report as finished (production status changes to reported as finished)?
    /// </param>
    /// <param name="_feedback">
    /// Job Registration Helper Class object providing the production job feedback status
    /// </param>
    /// <param name="_prodJob">
    /// Production Job Type.
    /// </param>
    /// <param name="_worker">
    /// Worker from the prodution job.
    /// </param>
    /// <returns>
    /// Returns a boolean - true if the production job shold be reported as finished and false if it shouldn't.
    /// </returns>
    protected boolean shouldReportAsFinished(JmgProdParametersDim jmgProdParametersDim, JmgRegistrationParameters   _feedback, JmgTermJob_Prod _prodJob, JmgWorkerRecId _worker)
    {
        boolean  ret;
    
        ret = jmgProdParametersDim.ReportFinishEndJob;
        ret = ret && (jmgProdParametersDim.ReportFinishStatus!= JmgProdStatusUpdateReportFinished::QtyOnly);
        ret = ret && _feedback.reportAsFinished()            == JmgFeedbackStatus::Completed;
        ret = ret && this.isLastOpenJobOnOpr(_prodJob);
        ret = ret && this.feedbackFinishedOnSameOpr(_prodJob);
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldReportScrap</Name>
				<Source><![CDATA[
    private boolean shouldReportScrap(JmgRegistrationParameters _feedback, JmgTermJob_Prod _prodJob)
    {
        boolean ret = _feedback.reportAsFinished() == JmgFeedbackStatus::Completed;

        ret = ret && this.isLastOpenJobOnOpr(_prodJob);
        ret = ret && this.feedbackFinishedOnSameOpr(_prodJob);
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustShowBOMJournals</Name>
				<Source><![CDATA[
    protected boolean mustShowBOMJournals()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showBOMJournals</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows generated BOM journals to the user, with the BOM journals generated based on the added jobs.
    /// </summary>
    public void showBOMJournals()
    {
        if (!this.mustShowBOMJournals())
        {
            return;
        }

        for (int i = 1; i <= jobs.lastIndex(); i++)
        {
            ProdJournalIdBOM prodJournalIdBOM = jobParameters.value(i).prodJournalIdBOM();
            if (prodJournalIdBOM)
            {
                #DEFINE.PostJournalButton('PostJournal')
                FormControl                 postJournalButton;

                Args prodJournalTableArgs    = new Args();
                prodJournalTableArgs.name(formStr(ProdJournalTable));
                FormRun prodJournalTableFormRun = classfactory.formRunClass(prodJournalTableArgs);
                prodJournalTableFormRun.init();

                FormDataSource formDataSource  = prodJournalTableFormRun.dataSource();
                QueryBuildDataSource qbds = formDataSource.query().dataSourceTable(tableNum(ProdJournalTable));
                qbds.addRange(fieldNum(ProdJournalTable, JournalType)).value(queryValue(ProdJournalType::Picklist));
                qbds.addRange(fieldNum(ProdJournalTable, Posted)).value(queryValue(NoYes::No));
                qbds.addRange(fieldNum(ProdJournalTable, JournalId)).value(prodJournalIdBOM);

                prodJournalTableFormRun.run();

                Args prodJournalTransArgs    = new Args();
                prodJournalTransArgs.name(formStr(ProdJournalTransBOM));
                prodJournalTransArgs.caller(prodJournalTableFormRun);
                prodJournalTransArgs.record(prodJournalTableFormRun.dataSource().cursor());
                FormRun prodJournalTransFormRun = classfactory.formRunClass(prodJournalTransArgs);
                prodJournalTransFormRun.init();
                formDataSource = prodJournalTransFormRun.dataSource();
                formDataSource.insertIfEmpty(false);
                prodJournalTransFormRun.run();
                // Disable post button:
                postJournalButton = prodJournalTransFormRun.design().controlName(#PostJournalButton);
                postJournalButton.visible(false);
                // Don't create new lines if picking list is empty.
                prodJournalTransFormRun.wait();
                prodJournalTableFormRun.close();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showOnlyOneBOMJournal</Name>
				<Source><![CDATA[
    private void showOnlyOneBOMJournal()
    {
        boolean                     journalAdded;
        #DEFINE.PostJournalButton('PostJournal')
        FormControl                 postJournalButton;
        Args prodJournalTableArgs    = new Args();
        prodJournalTableArgs.name(formStr(ProdJournalTable));
        FormRun prodJournalTableFormRun = classfactory.formRunClass(prodJournalTableArgs);
        prodJournalTableFormRun.init();
        FormDataSource formDataSource  = prodJournalTableFormRun.dataSource();
        QueryBuildDataSource qbds = formDataSource.query().dataSourceTable(tableNum(ProdJournalTable));
        qbds.addRange(fieldNum(ProdJournalTable, JournalType)).value(queryValue(ProdJournalType::Picklist));
        qbds.addRange(fieldNum(ProdJournalTable, Posted)).value(queryValue(NoYes::No));
        for (int i = 1; i <= jobs.lastIndex(); i++)
        {
            JmgRegistrationParameters feedback = jobParameters.value(i);
            if (feedback.prodJournalIdBOM())
            {
                qbds.addRange(fieldNum(ProdJournalTable, JournalId)).value(feedback.prodJournalIdBOM());
                journalAdded = true;
            }
        }
        if (journalAdded)
        {
            prodJournalTableFormRun.run();
            Args prodJournalTransArgs    = new Args();
            prodJournalTransArgs.name(formStr(ProdJournalTransBOM));
            prodJournalTransArgs.caller(prodJournalTableFormRun);
            prodJournalTransArgs.record(prodJournalTableFormRun.dataSource().cursor());
            FormRun prodJournalTransFormRun = classfactory.formRunClass(prodJournalTransArgs);
            prodJournalTransFormRun.init();
            formDataSource = prodJournalTransFormRun.dataSource();
            formDataSource.insertIfEmpty(false);
            prodJournalTransFormRun.run();
            // Disable post button:
            postJournalButton = prodJournalTransFormRun.design().controlName(#PostJournalButton);
            postJournalButton.visible(false);
            // Don't create new lines if picking list is empty.
            prodJournalTransFormRun.wait();
            prodJournalTableFormRun.close();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showProfitLossInventJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows an empty profit and loss journal to the user.
    /// </summary>
    public void showProfitLossInventJournal()
    {
        Args                    inventJournalTableArgs;
        FormRun                 inventJournalTableFormRun;

        Args                    inventJournalTransArgs;
        FormRun                 inventJournalTransFormRun;

        InventJournalTable      journalTable;
        InventJournalTrans      journalTrans;

        InventJournalTableData  journalTableData;
        InventJournalTransData  journalTransData;

        if (!JmgParameters::find().InventJournalNameLossProfit)
        {
            throw error("@SYS108642");
        }

        select firstonly journalTable
        where journalTable.JournalType  == InventJournalType::LossProfit    &&
              journalTable.Posted       == NoYes::No                        &&
              journalTable.Worker       == worker;

        if (!journalTable)
        {
            journalTableData = JournalTableData::newTable(journalTable);
            journalTransData = journalTableData.journalStatic().newJournalTransData(journalTrans,journalTableData);
            journalTable.JournalType    = InventJournalType::LossProfit;
            journalTableData.initFromJournalName(InventJournalName::find(JmgParameters::find().InventJournalNameLossProfit));
            journalTable.Worker         = worker;
            journalTable.insert();
        }

        inventJournalTableArgs    = new Args();
        inventJournalTableArgs.name(formStr(InventJournalTable));
        inventJournalTableFormRun = classfactory.formRunClass(inventJournalTableArgs);
        inventJournalTableArgs.record(journalTable);
        inventJournalTableFormRun.init();
        inventJournalTableFormRun.run();

        inventJournalTransArgs    = new Args();
        inventJournalTransArgs.name(formStr(InventJournalLossProfit));
        inventJournalTransArgs.record(journalTable);
        inventJournalTransArgs.caller(inventJournalTableFormRun);
        inventJournalTransFormRun = classfactory.formRunClass(inventJournalTransArgs);
        inventJournalTransFormRun.init();
        inventJournalTransFormRun.run();
        inventJournalTransFormRun.wait();
    }

]]></Source>
			</Method>
			<Method>
				<Name>showProjectFeeJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows a project fee journal to the user.
    /// </summary>
    /// <remarks>
    ///    If the user is active on a project job, the journal is initialized based on the active job.
    /// </remarks>
    public void showProjectFeeJournal()
    {
        ProjJournalTable        journalTable;
        ProjJournalTrans        journalTrans;
        ProjJournalTrans        existingJournalTrans;

        ProjJournalTableData    journalTableData;
        ProjJournalTransData    journalTransData;

        int                     i;
        JmgTermJob              job;
        JmgTermJob_Proj         projJob;
        ResourceRecId           resource;

        if (!JmgParameters::find().ProjInventJournalNameId)
        {
            throw error("@SYS108641");
        }

        resource = ResourceFacade::findOrCreateByWorker(worker);

        select firstonly journalTable
        where journalTable.JournalType  == ProjJournalType::Revenue &&
              journalTable.Posted       == NoYes::No                &&
              journalTable.Resource     == resource;

        if (!journalTable)
        {
            journalTableData    = JournalTableData::newTable(journalTable);
            journalTransData    = journalTableData.journalStatic().newJournalTransData(journalTrans,journalTableData);
            journalTable.JournalType    = ProjJournalType::Revenue;
            journalTable.Resource       = resource;
            journalTableData.initFromJournalName(ProjJournalName::find(JmgParameters::find().ProjFeeJournalNameId));
            journalTable.insert();
        }

        for (i = 1; i <= jobs.lastIndex(); i++)
        {
            job = jobs.value(i);
            if (job.module() == JmgModuleEnum::PROJ)
            {
                projJob = job;

                select firstonly existingJournalTrans
                where existingJournalTrans.JournalId        == journalTable.JournalId   &&
                      existingJournalTrans.ProjId           == projJob.jobRef()         &&
                      existingJournalTrans.Resource         == resource                 &&
                      existingJournalTrans.ActivityNumber   == projJob.actOprId()       &&
                      existingJournalTrans.ProjTransDate    == profileDate;
                if (!existingJournalTrans)
                {
                    if (!journalTableData)
                    {
                        journalTableData    = JournalTableData::newTable(journalTable);
                        journalTableData.initFromJournalName(ProjJournalName::find(JmgParameters::find().ProjFeeJournalNameId));
                    }

                    if (!journalTransData)
                    {
                        journalTransData    = journalTableData.journalStatic().newJournalTransData(journalTrans,journalTableData);
                    }
                    journalTransData.initFromJournalTable();
                    journalTrans.ProjId = projJob.jobRef();
                    journalTrans.ProjTransDate  = profileDate;
                    journalTrans.Resource = resource;
                    journalTrans.setResourceCategory();
                    journalTrans.initFromProjTable(projJob.projTable());
                    journalTrans.ActivityNumber = projJob.actOprId();

                    journalTransData.create();
                }
            }
        }
        JmgPostStandardSystem::showProjectFeeJournalOnClient(journalTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>showProjectItemJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows a project item journal to the user.
    /// </summary>
    /// <remarks>
    ///    If the user is active on a project job, the journal is initialized based on the active job.
    /// </remarks>
    public void showProjectItemJournal()
    {
        Args                        inventJournalTableArgs;
        FormRun                     inventJournalTableFormRun;

        Args                        inventJournalProjectArgs;
        FormRun                     inventJournalProjectFormRun;

        InventJournalTable          journalTable;

        InventJournalTableData      journalTableData;

        if (!JmgParameters::find().ProjInventJournalNameId)
        {
            throw error("@SYS108640");
        }

        select firstonly journalTable
        where journalTable.JournalType  == InventJournalType::project   &&
              journalTable.Posted       == NoYes::No                    &&
              journalTable.Worker       == worker;

        if (!journalTable)
        {
            journalTableData    = JournalTableData::newTable(journalTable);
            journalTable.JournalType    = InventJournalType::project;
            journalTableData.initFromJournalName(InventJournalName::find(JmgParameters::find().ProjInventJournalNameId));
            journalTable.Worker         = worker;
            journalTable.insert();
        }

        inventJournalTableArgs    = new Args();
        inventJournalTableArgs.name(formStr(InventJournalTable));
        inventJournalTableFormRun = classfactory.formRunClass(inventJournalTableArgs);
        inventJournalTableArgs.record(journalTable);
        inventJournalTableFormRun.init();
        inventJournalTableFormRun.run();

        inventJournalProjectArgs    = new Args();
        inventJournalProjectArgs.name(formStr(InventJournalProject));
        inventJournalProjectArgs.record(journalTable);
        inventJournalProjectArgs.caller(inventJournalTableFormRun);
        inventJournalProjectFormRun = classfactory.formRunClass(inventJournalProjectArgs);
        inventJournalProjectFormRun.init();
        inventJournalProjectFormRun.run();
        inventJournalProjectFormRun.wait();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatedOriginalTransactionOnJournal</Name>
				<Source><![CDATA[
    private void updatedOriginalTransactionOnJournal(JmgStampTransMap jmgStampTransMap)
    {
        JmgStampJournalTrans jmgStampJournalTrans;
        if (jmgStampTransMap.TableId == tableNum(JmgStampJournalTrans))
        {
            ttsbegin;
            select firstonly forupdate jmgStampJournalTrans
            where jmgStampJournalTrans.Worker == jmgStampTransMap.Worker
            && jmgStampJournalTrans.ProfileDate == jmgStampTransMap.ProfileDate
            && jmgStampJournalTrans.JobId == jmgStampTransMap.JobId
            && jmgStampJournalTrans.RouteJobType == jmgStampTransMap.RouteJobType
            && jmgStampJournalTrans.StartTime == jmgStampTransMap.StartTime
            && jmgStampJournalTrans.StartDate == jmgStampTransMap.StartDate;
            if (jmgStampJournalTrans && jmgStampTransMap.Seconds > 0)
            {
                jmgStampJournalTrans.Seconds = jmgStampTransMap.Seconds;
                jmgStampJournalTrans.updateOriginalTransaction();
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTotalsForProjJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates totals like total number of lines and total project quantity for the specified project journal.
    /// </summary>
    /// <param name="_projJournalTableData">
    /// The instance of <c>ProjJournalTableData</c> class.
    /// </param>
    protected void updateTotalsForProjJournalTable(ProjJournalTableData  _projJournalTableData)
    {
        if (_projJournalTableData.hasLines())
        {
            _projJournalTableData.initTotal();
            _projJournalTableData.journalTable().update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static JmgPostStandardSystem construct()
    {
        return new JmgPostStandardSystem();
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructJmgStampJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an instance of the <c>JmgPostStandardSystem</c> class, which is initialized based
    /// on a <c>JmgStampJournalTable</c> record.
    /// </summary>
    /// <param name="_jmgStampJournalTable">
    /// A <c>JmgStampJournalTable</c> record. A job is added for each <c>JmgStampJournalTrans</c> record
    /// associated to the <c>JmgStampJournalTable</c> record.
    /// </param>
    /// <returns>
    /// An instance of the <c>JmgPostStandardSystem</c> class
    /// </returns>
    public static JmgPostStandardSystem constructJmgStampJournalTable(JmgStampJournalTable _jmgStampJournalTable)
    {
        JmgPostStandardSystem       ret;

        ret = JmgPostStandardSystem::construct();
        ret.initializeJmgPostStandardSystem(_jmgStampJournalTable);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeJmgPostStandardSystem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>JmgPostStandardSystem</c> class based on a <c>JmgStampJournalTable</c> record.
    /// </summary>
    /// <param name = "_jmgStampJournalTable">The current record of the <c>JmgStampJournalTable</c> table buffer.</param>
    protected void initializeJmgPostStandardSystem(JmgStampJournalTable _jmgStampJournalTable)
    {
        JmgStampJournalTrans        jmgStampJournalTrans;
        JmgRegistrationParameters   jmgRegistrationParameters;

        if (!this.hasTransferred(_jmgStampJournalTable))
        {
            while select jmgStampJournalTrans
            where jmgStampJournalTrans.Worker       == _jmgStampJournalTable.Worker &&
                  jmgStampJournalTrans.ProfileDate  == _jmgStampJournalTable.ProfileDate
            {
                jmgRegistrationParameters = JmgRegistrationParameters::constructJmgStampTransMap(jmgStampJournalTrans);
                if (jmgStampJournalTrans.JourRegType    == JmgJourRegTypeEnum::Absence && jmgStampJournalTrans.JobIDAbs)
                {
                    this.addJob(JmgTermJob::construct(jmgStampJournalTrans.JobIDAbs), jmgRegistrationParameters, jmgStampJournalTrans);
                }
                else
                {
                    this.addJob(JmgTermJob::construct(jmgStampJournalTrans.JobId), jmgRegistrationParameters, jmgStampJournalTrans);
                }
            }
        }
        else
        {
            QueryRun queryRun = new QueryRun(this.createJmgPostStandardSystemQuery(_jmgStampJournalTable));

            while (queryRun.next())
            {
                JmgStampTrans jmgStampTrans = queryRun.get(tableNum(JmgStampTrans));
                jmgRegistrationParameters = JmgRegistrationParameters::constructJmgStampTransMap(jmgStampTrans);
                if (jmgStampTrans.JourRegType    == JmgJourRegTypeEnum::Absence && jmgStampTrans.JobIDAbs)
                {
                    this.addJob(JmgTermJob::construct(jmgStampTrans.JobIDAbs), jmgRegistrationParameters, jmgStampTrans);
                }
                else
                {
                    this.addJob(JmgTermJob::construct(jmgStampTrans.JobId), jmgRegistrationParameters, jmgStampTrans);
                }
            }
        }
        this.parmWorker(_jmgStampJournalTable.Worker);
        this.parmProfileDate(_jmgStampJournalTable.ProfileDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasTransferred</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether stamp journal table record is transferred.
    /// </summary>
    /// <param name = "_jmgStampJournalTable">The <c>JmgStampJournalTable</c> table buffer.</param>
    /// <returns>true if stamp journal table record is transferred; otherwise, false</returns>
    protected boolean hasTransferred(JmgStampJournalTable _jmgStampJournalTable)
    {
        return _jmgStampJournalTable.Transferred;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJmgPostStandardSystemQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for transferred journal registration that is related to the given worker and profile date.
    /// </summary>
    /// <param name = "_jmgStampJournalTable">The current record of <c>JmgStampJournalTable</c> table buffer.</param>
    /// <returns>A query object.</returns>
    protected Query createJmgPostStandardSystemQuery(JmgStampJournalTable _jmgStampJournalTable)
    {
        Query					query = new Query();
        QueryBuildDataSource	queryBuildDataSource;

        queryBuildDataSource = query.addDataSource(tablenum(JmgStampTrans));
        SysQuery::findOrCreateRange(queryBuildDataSource, fieldNum(JmgStampTrans, Worker)).value(queryValue(_jmgStampJournalTable.Worker));
        SysQuery::findOrCreateRange(queryBuildDataSource, fieldNum(JmgStampTrans, ProfileDate)).value(queryValue(_jmgStampJournalTable.ProfileDate));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructJmgStampJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an instance of the <c>JmgPostStandardSystem</c> class, which is initialized based
    /// on a <c>JmgStampTable</c> record.
    /// </summary>
    /// <param name="_jmgStampJournalTrans">
    /// A <c>JmgStampJournalTrans</c> record, based on which a job is
    /// added to the returned <c>JmgPostStandardSystem</c> instance.
    /// </param>
    /// <param name="_licensePlateId">
    /// License plate id reported on the feedback for advanced warehouse
    /// enabled items.
    /// </param>
    /// <returns>
    /// An instance of the <c>JmgPostStandardSystem</c> class
    /// </returns>
    public static JmgPostStandardSystem constructJmgStampJournalTrans(JmgStampJournalTrans _jmgStampJournalTrans, WHSLicensePlateId _licensePlateId = '')
    {
        JmgPostStandardSystem jmgPostStandardSystem   = JmgPostStandardSystem::construct();
        jmgPostStandardSystem.parmWorker(_jmgStampJournalTrans.Worker);
        jmgPostStandardSystem.parmProfileDate(_jmgStampJournalTrans.ProfileDate);

        JmgTermJob job = JmgPostStandardSystem::createTermJobFromStampJournalTrans(_jmgStampJournalTrans);
        JmgRegistrationParameters jobParameters 
            = JmgPostStandardSystem::createRegistrationParamsFromStampJournalTrans(_jmgStampJournalTrans, _licensePlateId);

        jmgPostStandardSystem.addJob(job, jobParameters, _jmgStampJournalTrans);

        return jmgPostStandardSystem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTermJobFromStampJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>JmgTermJob</c> class based on a <c>JmgStampJournalTrans</c> record.
    /// </summary>
    /// <param name = "_jmgStampJournalTrans">
    /// The <c>JmgStampJournalTrans</c> record base on which the <c>JmgTermJob</c> instance should be created.
    /// </param>
    /// <returns>
    /// The created <c>JmgTermJob</c> instance.
    /// </returns>
    protected internal static JmgTermJob createTermJobFromStampJournalTrans(JmgStampJournalTrans _jmgStampJournalTrans)
    {
        if (_jmgStampJournalTrans.JourRegType == JmgJourRegTypeEnum::Absence    && _jmgStampJournalTrans.JobIDAbs)
        {
            return JmgTermJob::construct(_jmgStampJournalTrans.JobIDAbs);
        }
        else
        {
            return JmgTermJob::construct(_jmgStampJournalTrans.JobId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRegistrationParamsFromStampJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>JmgRegistrationParameters</c> class based on a <c>JmgStampJournalTrans</c> record.
    /// </summary>
    /// <param name = "_jmgStampJournalTrans">
    /// The <c>JmgStampJournalTrans</c> record base on which the <c>JmgRegistrationParameters</c> instance should be created.
    /// </param>
    /// <param name = "_licenseplateId">
    /// The license plate id in which the finished item should be received.
    /// </param>
    /// <returns>
    /// The created <c>JmgRegistrationParameters</c> instance.
    /// </returns>
    protected static JmgRegistrationParameters createRegistrationParamsFromStampJournalTrans(JmgStampJournalTrans _jmgStampJournalTrans, WHSLicensePlateId _licenseplateId)
    {
        JmgRegistrationParameters jobParameters = new JmgRegistrationParameters();
        jobParameters.reportAsFinished(_jmgStampJournalTrans.JobFinished == NoYes::Yes ? JmgFeedbackStatus::Completed : JmgFeedbackStatus::Stopped);
        jobParameters.startQuantity(_jmgStampJournalTrans.QtyStartup - _jmgStampJournalTrans.SysQtyStartup);
        jobParameters.goodQuantity(_jmgStampJournalTrans.QtyGood - _jmgStampJournalTrans.SysQtyGood);
        jobParameters.pdsCWStartQuantity(_jmgStampJournalTrans.PdsCWQtyStartup - _jmgStampJournalTrans.PdsCWSysQtyStartup);
        jobParameters.pdsCWGoodQuantity(_jmgStampJournalTrans.PdsCWQtyGood - _jmgStampJournalTrans.PdsCWSysQtyGood);
        jobParameters.errorSpecification(JmgErrorSpecificationForm::getDifference(_jmgStampJournalTrans.ErrorSpecification, _jmgStampJournalTrans.SysErrorSpecification));
        jobParameters.parmWHSLicensePlateId(_licensePlateId);

        return jobParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructJmgTimecardTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an instance of the <c>JmgPostStandardSystem</c> class, which is initialized based
    /// on a <c>JmgTimecardTable</c> record.
    /// </summary>
    /// <param name="_jmgTimecardTable">
    /// A <c>JmgTimecardTable</c> record. A job is added for each <c>JmgTimecardTrans</c> record
    /// associated to the <c>JmgTimecardTable</c> record.
    /// </param>
    /// <returns>
    /// An instance of the <c>JmgPostStandardSystem</c> class
    /// </returns>
    public static JmgPostStandardSystem constructJmgTimecardTable(JmgTimecardTable _jmgTimecardTable)
    {
        JmgPostStandardSystem       ret;
        JmgTimecardTrans            jmgTimecardTrans;
        JmgRegistrationParameters   jmgRegistrationParameters;

        ret = JmgPostStandardSystem::construct();

        while select jmgTimecardTrans
        where jmgTimecardTrans.Worker       == _jmgTimecardTable.Worker &&
              jmgTimecardTrans.ProfileDate  == _jmgTimecardTable.ProfileDate
        {
            jmgRegistrationParameters = new JmgRegistrationParameters();
            jmgRegistrationParameters.costCategory(jmgTimecardTrans.ProjCategory);

            if (jmgTimecardTrans.JourRegType == JmgJourRegTypeEnum::Absence && jmgTimecardTrans.JobIDAbs)
            {
                ret.addJob(JmgTermJob::construct(jmgTimecardTrans.JobIDAbs), jmgRegistrationParameters);
            }
            else
            {
                ret.addJob(JmgTermJob::construct(jmgTimecardTrans.JobId), jmgRegistrationParameters);
            }
        }
        ret.parmWorker(_jmgTimecardTable.Worker);
        ret.parmProfileDate(_jmgTimecardTable.ProfileDate);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructJmgTimecardTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an instance of the <c>JmgPostStandardSystem</c> class, which is initialized based
    /// on a <c>JmgTimecardTrans</c> record.
    /// </summary>
    /// <param name="_jmgTimecardTrans">
    /// A <c>JmgTimecardTrans</c> record, based on which a job is
    /// added to the returned <c>JmgPostStandardSystem</c> instance.
    /// </param>
    /// <returns>
    /// An instance of the <c>JmgPostStandardSystem</c> class
    /// </returns>
    public static JmgPostStandardSystem constructJmgTimecardTrans(JmgTimecardTrans _jmgTimecardTrans)
    {
        JmgPostStandardSystem       ret;
        JmgRegistrationParameters   jmgRegistrationParameters;

        ret = JmgPostStandardSystem::construct();

        jmgRegistrationParameters = new JmgRegistrationParameters();
        jmgRegistrationParameters.costCategory(_jmgTimecardTrans.ProjCategory);

        if (_jmgTimecardTrans.JobId)
        {
            ret.addJob(JmgTermJob::construct(_jmgTimecardTrans.JobId), jmgRegistrationParameters);
        }
        ret.parmWorker(_jmgTimecardTrans.Worker);
        ret.parmProfileDate(_jmgTimecardTrans.ProfileDate);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructJobBundle</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an instance of the <c>JmgPostStandardSystem</c> class, which is initialized based
    /// on a <c>JmgJobBundle</c> object.
    /// </summary>
    /// <param name="_jmgJobBundle">
    /// A reference to a <c>JmgJobBundle</c> object. A job is added to the <c>JmgPostStandardSystem</c>
    /// for each job included in the <c>JmgJobBundle</c> object.
    /// </param>
    /// <param name="_useStartJobs">
    /// If true, then start jobs from the <c>JmgJobBundle</c> is used; otherwise active jobs is used.
    /// </param>
    /// <param name="_useJobStartedParameters">
    /// If true, then start job parameters from the <c>JmgJobBundle</c> is used; otherwise active job parameters is used.
    /// </param>
    /// <returns>
    /// An instance of the <c>JmgPostStandardSystem</c> class.
    /// </returns>
    public static JmgPostStandardSystem constructJobBundle(JmgJobBundle _jmgJobBundle, boolean _useStartJobs, boolean _useJobStartedParameters = false)
    {
        JmgPostStandardSystem   ret;
        MapIterator             mapIterator;
        Map                     jobsMap = _useStartJobs ? _jmgJobBundle.getNewJobsMap() : _jmgJobBundle.getActiveJobsMap();
        
        ret = JmgPostStandardSystem::construct();
        ret.parmCallerForm(_jmgJobBundle.parmCallerForm());

        if (_useStartJobs)
        {
            mapIterator = _jmgJobBundle.getNewJobsIterator();
        }
        else
        {
            mapIterator = _jmgJobBundle.getActiveJobsIterator();
        }
            
        if (JmgJobBundleOrderByOprPriorityV2Flight::instance().isEnabled()
            && jobsMap && jobsMap.elements() > 1)
        {
            // (sorting string -> jobId)
            MapIterator jobsOrderIterator = _jmgJobBundle.getJobsOrderIterator(mapIterator);

            while (jobsOrderIterator.more())
            {
                if (_useStartJobs)
                {
                    ret.addJob(jobsMap.lookup(jobsOrderIterator.value()), _jmgJobBundle.getStartupParameters(jobsOrderIterator.value()));
                }
                else
                {
                    ret.addJob(jobsMap.lookup(jobsOrderIterator.value()), _useJobStartedParameters ? _jmgJobBundle.getJobStartedParameters(jobsOrderIterator.value()) :
                                                                                               _jmgJobBundle.getFeedbackParameters(jobsOrderIterator.value()));
                }
                jobsOrderIterator.next();
            }
        }
        else
        {
            while (mapIterator.more())
            {
                if (_useStartJobs)
                {
                    ret.addJob(mapIterator.value(), _jmgJobBundle.getStartupParameters(mapIterator.key()));
                }
                else
                {
                    ret.addJob(
                    mapIterator.value(),
                    _useJobStartedParameters ? _jmgJobBundle.getJobStartedParameters(mapIterator.key()) :
                                               _jmgJobBundle.getFeedbackParameters(mapIterator.key()));
                }
                mapIterator.next();
            }
        }

        if (_jmgJobBundle.parmResourceRegistration())
        {
            ret.parmWrkCtrPilot(_jmgJobBundle.wrkCtrIdPilot());
        }
        else
        {
            ret.parmWorker(_jmgJobBundle.worker());
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>emptyInfolog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Removes noncritical information messages from the Infolog.
    /// </summary>
    private static void emptyInfolog()
    {
        InfologData             log;
        SysInfologEnumerator    enum;
        boolean                 found = false;

        log = infolog.copy(1,infolog.num());
        enum = SysInfologEnumerator::newData(log);
        while (enum.moveNext())
        {
            if (enum.currentException() != Exception::Info)
            {
                found = true;
                break;
            }
        }

        if (!found)
        infolog.clear(0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postQtyJournalsList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts quantity based on the added jobs that refer to time collected on productions.
    /// </summary>
    /// <param name="journalList">
    /// The <c>List</c> of the <c>ProdJournalCheckPost</c> classes.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <param name="_fromTime">
    /// The from time.
    /// </param>
    /// <param name="_toTime">
    /// The to time.
    /// </param>
    public static void postQtyJournalsList(List journalList, JmgDate _transDate, JmgTime _fromTime, JmgTime _toTime)
    {
        ProdJournalCheckPost prodJournalCheckPost;
        ListEnumerator enumerator;
        ProdJournalRoute prodJournalRoute;

        enumerator = journalList.getEnumerator();
        while (enumerator.moveNext())
        {
            prodJournalCheckPost = enumerator.current();
            update_recordset prodJournalRoute
            setting TransDate = _transDate,
                    FromTime  = _fromTime,
                    ToTime    = _toTime
            where prodJournalRoute.JournalId    == prodJournalCheckPost.parmJournalId();

            prodJournalCheckPost.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showBOMJournalOnStartUp</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows generated BOM journals to the user on the startup of jobs.
    /// </summary>
    /// <param name="_prodParmId">
    ///    The ID of the journal to show.
    /// </param>
    /// <param name="_inventDimId">
    ///    The inventory dimension ID of the site for which to show journals.
    /// </param>
    public static void showBOMJournalOnStartUp(ProdParmId _prodParmId, InventDimId _inventDimId)
    {
        ProdParmStartUp             prodParmStartUp;
        Args                        prodJournalTableArgs;
        FormRun                     prodJournalTableFormRun;
        FormDataSource              formDataSource;
        QueryBuildDataSource        qbds;
        QueryBuildDataSource        prodJournalBOMQbds;
        boolean                     parmIdsAdded;

        if (JmgPostStandardSystem::mustShowBOMJournalsOnStartUp(_inventDimId))
        {
            prodJournalTableArgs    = new Args();
            prodJournalTableArgs.name(formStr(ProdJournalTable));
            prodJournalTableFormRun = classfactory.formRunClass(prodJournalTableArgs);
            prodJournalTableFormRun.init();

            formDataSource  = prodJournalTableFormRun.dataSource();
            qbds = formDataSource.query().dataSourceTable(tableNum(ProdJournalTable));
            prodJournalBOMQbds = qbds.addDataSource(tableNum(ProdJournalBOM));
            prodJournalBOMQbds.joinMode(JoinMode::ExistsJoin);
            prodJournalBOMQbds.addLink(fieldNum(ProdJournalTable, JournalId), fieldNum(ProdJournalBOM, JournalId));

            qbds.addRange(fieldNum(ProdJournalTable, JournalType)).value(queryValue(ProdJournalType::Picklist));
            qbds.addRange(fieldNum(ProdJournalTable, Posted)).value(queryValue(NoYes::No));

            parmIdsAdded    = false;
            while select prodParmStartUp
            where prodParmStartUp.ParmId        == _prodParmId  &&
                  prodParmStartUp.PostNowBOM    == NoYes::No
            {
                qbds.addRange(fieldNum(ProdJournalTable, ProdId)).value(prodParmStartUp.ProdId);
                if (prodParmStartUp.FromOprNum)
                {
                    prodJournalBOMQbds.addRange(fieldNum(ProdJournalBOM, OprNum)).value(queryValue(prodParmStartUp.FromOprNum));
                }
                parmIdsAdded = true;
            }

            if (parmIdsAdded && SysQuery::countLoops(new QueryRun(formDataSource.query())))
            {
                prodJournalTableFormRun.run();
                prodJournalTableFormRun.wait();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showProjectFeeJournalOnClient</Name>
				<Source><![CDATA[
    /// <summary>
    /// Shows a project fee journal to the user.
    /// </summary>
    /// <param name="_projJournalTable">
    /// The journal to show to the user.
    /// </param>
    public static void showProjectFeeJournalOnClient(ProjJournalTable _projJournalTable)
    {
        Args                    projJournalTableArgs;
        FormRun                 projJournalTableFormRun;

        Args                    projJournalTransRevenueArgs;
        FormRun                 projJournalTransRevenueFormRun;

        Object                  o;
        ProjJournalFormTable    projJournalFormTable;
        FormDataSource          fds;
        Query                   q;
        Query                   qOrig;
        QueryBuildDataSource    qbds;

        projJournalTableArgs    = new Args();
        projJournalTableArgs.menuItemName(menuitemDisplayStr(ProjJournalTableRevenue));
        projJournalTableArgs.name(formStr(ProjJournalTable));
        projJournalTableFormRun = classfactory.formRunClass(projJournalTableArgs);
        projJournalTableArgs.record(_projJournalTable);
        projJournalTableFormRun.init();

        o = projJournalTableFormRun;
        projJournalFormTable = o.journalForm();
        fds = projJournalFormTable.journalTable_DS();
        fds.insertIfEmpty(false);

        q = new Query();
        qbds = q.addDataSource(tableNum(ProjJournalTable));
        qbds.addRange(fieldNum(ProjJournalTable, RecId)).value(queryValue(_projJournalTable.RecId));
        qbds.addRange(fieldNum(ProjJournalTable, JournalType)).value(queryValue(ProjJournalType::Revenue));
        // Keep a reference to the original query to avoid error:
        qOrig   = fds.query();
        fds.query(q);
        projJournalFormTable.queryAddRange();
        projJournalTableFormRun.run();

        projJournalTransRevenueArgs    = new Args();
        projJournalTransRevenueArgs.name(formStr(ProjJournalTransRevenue));
        projJournalTransRevenueArgs.record(_projJournalTable);
        projJournalTransRevenueArgs.caller(projJournalTableFormRun);
        projJournalTransRevenueFormRun = classfactory.formRunClass(projJournalTransRevenueArgs);
        projJournalTransRevenueFormRun.init();
        projJournalTransRevenueFormRun.run();
        projJournalTransRevenueFormRun.wait();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustShowBOMJournalsOnStartUp</Name>
				<Source><![CDATA[
    internal static boolean mustShowBOMJournalsOnStartUp(InventDimId _inventDimId)
    {
        if (JmgPFEOpenPickingListOnStartUpFlight::instance().isEnabled())
        {
            JmgProdParametersDim prodParametersDim = JmgProdParametersDim::find(_inventDimId);

            return prodParametersDim.StartUpBOMAutoConsump != BOMAutoConsump::Never
            && prodParametersDim.StartUpShowOpenBOM == NoYes::Yes
            && !JmgManufacturingExecutionWorkloadConfigurationProvider::isInventDimDeployedOnSpoke(InventDim::find(_inventDimId));
        }
        
        return JmgProdParametersDim::find(_inventDimId).StartUpShowOpenBOM == NoYes::Yes
            && !JmgManufacturingExecutionWorkloadConfigurationProvider::isInventDimDeployedOnSpoke(InventDim::find(_inventDimId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustShowBOMJournalsOnOperationComplete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defines if BOM journal (picking list) must be shown before posting when report progress from shop floor.
    /// </summary>
    /// <param name="_inventDimId">
    /// The inventory dimension ID to search for.
    /// </param>
    /// <returns>
    /// true if the Picking list must be shown; otherwise, false.
    /// </returns>
    [Hookable(false)]
    internal static boolean mustShowBOMJournalsOnOperationComplete(InventDimId _inventDimId)
    {
        JmgProdParametersDim prodParametersDim = JmgProdParametersDim::find(_inventDimId);

        return prodParametersDim.StatusQtyAutoConsump != BOMAutoConsump::Never
            && prodParametersDim.bomEditJournal == NoYes::Yes
            && !JmgManufacturingExecutionWorkloadConfigurationProvider::isInventDimDeployedOnSpoke(InventDim::find(_inventDimId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMultiLineReportAsFinished</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates multi-line report finished journal for posting all serial numbers in one journal.
    /// </summary>
    /// <returns>
    /// List of report finished journals.
    /// </returns>
    [Hookable(false), SysObsolete('Multi-line report as finish journal is taken care of by ProdMultiLineReportAsFinishSerialNumFeature', false, 03\07\2022)]
    internal List createMultiLineReportAsFinished()
    {
        List prodJournalCheckPostList = new List(Types::Class);

        using(var activityContext = JmgInstrumentationLogger::createLogger(classStr(JmgPostStandardSystem)).registration().createMultiLineRAF())
        {
            JmgProdParametersDim jmgProdParametersDim = JmgProdParametersDim::find(inventDimId);

            if (jmgProdParametersDim.ReportFinishStatus != JmgProdStatusUpdateReportFinished::No)
            {
                ProdJournalTransDataProd    journalTransDataProd;
                ProdJournalTable            prodJournalTable_Raf;
                ProdJournalTableData        journalTableData_Raf;
                ProdJournalProd             prodJournalReportAsFinished;

                Map prodJournalTableMap = new Map(Types::String, Types::Record);
                Map journalTableDataMap = new Map(Types::String, Types::Class);
                Map journalTransDataMap = new Map(Types::String, Types::Class);

                JmgTermJob_Prod             prodJob;
                JmgRegistrationParameters   feedback;
                int                         i;
                ProdId                      prodId;

                boolean isOperationsReportedAsFinishedQuantity = this.isOperationsReportedAsFinished(jmgProdParametersDim);

                ttsbegin;
                for (i = 1; i <= jobs.lastIndex(); i++)
                {
                    prodJob = jobs.value(i);
                    feedback = jobParameters.value(i);

                    if (feedback.parmSerialNumberRequired() && feedback.parmWHSLicensePlateId() && this.mustCreateReportFinishedJournalForJob(prodJob, feedback))
                    {
                        prodId = prodJob.jobRef();
                        prodJournalReportAsFinished.clear();

                        if (!prodJournalTableMap.exists(prodId))
                        {
                            prodJournalTable_Raf.clear();
                            journalTableData_Raf    = JournalTableData::newTable(prodJournalTable_Raf);
                            prodJournalTable_Raf.ProdId = prodId;
                            this.newJournal_ReportAsFinished(journalTableData_Raf, prodJournalTable_Raf);

                            journalTransDataProd = journalTableData_Raf.journalStatic().newJournalTransData(prodJournalReportAsFinished, journalTableData_Raf);
                            journalTransDataProd.initFromJournalTable();

                            prodJournalTableMap.insert(prodId, prodJournalTable_Raf);
                            journalTableDataMap.insert(prodId, journalTableData_Raf);
                            journalTransDataMap.insert(prodId, journalTransDataProd);
                        }
                        else
                        {
                            journalTableData_Raf = journalTableDataMap.lookup(prodId);
                            prodJournalTable_Raf = prodJournalTableMap.lookup(prodId);
                            journalTransDataProd = journalTransDataMap.lookup(prodId);
                        }

                        this.initProdJournalReportAsFinished(prodJournalReportAsFinished, prodId, prodJournalTable_Raf.JournalId);
                        InventDim journalInventDim = JmgProdMultiReportFinished::initProdParmReportFinishedInventDim(prodJournalReportAsFinished.ItemId, prodJournalReportAsFinished.InventDimId, feedback.parmWHSLicensePlateId(), feedback.parmInventBatchId());
                        boolean prodFinished = this.shouldReportAsFinished(jmgProdParametersDim, feedback, prodJob, worker);

                        this.createReportAsFinishedJournalLines(journalTransDataProd, prodJournalReportAsFinished, journalInventDim, prodJob.jobId(), feedback.parmSerialNumberSpecification(), isOperationsReportedAsFinishedQuantity, prodFinished);
                    }
                }

                prodJournalCheckPostList = this.newJournal_ProdJournalCheckPostProd(prodJournalTableMap.getEnumerator());

                ttscommit;
            }
        }

        return prodJournalCheckPostList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newJournal_ReportAsFinished</Name>
				<Source><![CDATA[
    [SysObsolete('Multi-line report as finish journal is taken care of by ProdMultiLineReportAsFinishSerialNumFeature', false, 03\07\2022)]
    private void newJournal_ReportAsFinished(ProdJournalTableData _prodJournalTableData, ProdJournalTable _prodJournalTable)
    {
        ttsbegin;

        _prodJournalTable.initValue();

        _prodJournalTableData.initFromJournalName(_prodJournalTableData.journalStatic().findJournalName(JmgProdParametersDim::find(inventDimId).ReportFinishProdJournalNameId));
        _prodJournalTable.AcceptError = NoYes::Yes;
        _prodJournalTable.insert();

        ttscommit;

        if (!_prodJournalTable.JournalId)
        {
            throw error(strFmt("@SYS22828",funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newJournal_ProdJournalCheckPostProd</Name>
				<Source><![CDATA[
    [SysObsolete('Multi-line report as finish journal is taken care of by ProdMultiLineReportAsFinishSerialNumFeature', false, 03\07\2022)]
    private List newJournal_ProdJournalCheckPostProd(MapEnumerator _prodJournalTableMapEnumerator)
    {
        ProdJournalTable            prodJournalTable_Raf;
        List                        prodJournalCheckPostList = new List(Types::Class);

        while (_prodJournalTableMapEnumerator.moveNext())
        {
            prodJournalTable_Raf = _prodJournalTableMapEnumerator.currentValue();
            // Update journal after creation of lines
            ttsbegin;
            ProdJournalTable::initTotal(prodJournalTable_Raf);
            prodJournalTable_Raf.update();
            ttscommit;

            ProdJournalCheckPostProd prodJournalCheckPostProd = ProdJournalCheckPostProd::newPostJournal(prodJournalTable_Raf.JournalId, true);
            prodJournalCheckPostProd.parmCreatePutawayWork(true);
            prodJournalCheckPostList.addEnd(prodJournalCheckPostProd);
        }

        return prodJournalCheckPostList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProdJournalReportAsFinished</Name>
				<Source><![CDATA[
    [SysObsolete('Multi-line report as finish journal is taken care of by ProdMultiLineReportAsFinishSerialNumFeature', false, 03\07\2022)]
    private void initProdJournalReportAsFinished(ProdJournalProd _prodJournalReportAsFinished, ProdId _prodId, ProdJournalIdProd _journalId)
    {
        ProdTable prodTable = ProdTable::find(_prodId);
        _prodJournalReportAsFinished.TransDate      = JmgProfileSeconds::getSysDate();
        _prodJournalReportAsFinished.initFromProdTable(prodTable);
        _prodJournalReportAsFinished.JournalId      = _journalId;
        _prodJournalReportAsFinished.ProdPickList   = NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReportAsFinishedJournalLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds journal lines for the specified error quantities.
    /// </summary>
    /// <param name = "_journalTransDataRaf">
    /// An instance of the <c>ProdJournalTransDataProd</c> class, which is used to generated the
    /// journal lines.
    /// </param>
    /// <param name = "_prodJournalProd">
    ///  An already initialized <c>ProdJournalProd</c> record which is used to create journal lines for quantities.
    /// </param>
    /// <param name = "_journalInventDim">
    /// The <c>InventDim</c> of journal.
    /// </param>
    /// <param name = "_jobId">
    /// The <c>JmgJobId</c> value for which needs to be added a journal line.
    /// </param>
    /// <param name = "_serialNumberSpecification">
    ///  A list of serial numbers with quantities and error causes to add journal lines to.
    /// </param>
    /// <param name = "_isOperationsReportedAsFinishedQuantity">
    /// true if operations be reported as finished at quantity level; otherwise, false.
    /// </param>
    /// <param name = "_prodFinished">
    /// true if the report should be marked as report finished.
    /// </param>
    [SysObsolete('Multi-line report as finish journal is taken care of by ProdMultiLineReportAsFinishSerialNumFeature', false, 03\07\2022)]
    private void createReportAsFinishedJournalLines( 
        ProdJournalTransDataProd        _journalTransDataRaf, 
        ProdJournalProd                 _prodJournalProd,
        InventDim                       _journalInventDim,
        JmgJobId                        _jobId,
        JmgTmpSerialNumberSpecification _serialNumberSpecification,
        boolean                         _isOperationsReportedAsFinishedQuantity,
        boolean                         _prodFinished)
    {
        int i = 0;
        JmgTmpSerialNumberSpecification localSerialNumberSpecification;
        localSerialNumberSpecification.setTmpData(_serialNumberSpecification);
        select count(RecId) 
            from localSerialNumberSpecification
            where localSerialNumberSpecification.JobId == _jobId;

        // Report errors from previous operations
        if (_prodFinished)
        {
            this.createLine_PrevOperations_QtyError(_journalTransDataRaf, _prodJournalProd, _journalInventDim.inventDimId,
                _isOperationsReportedAsFinishedQuantity, !localSerialNumberSpecification.RecId);
        }

        while select _serialNumberSpecification
            where    _serialNumberSpecification.JobId == _jobId
        {
            _prodJournalProd.ProdFinished = false;

            if (_isOperationsReportedAsFinishedQuantity)
            {
                _prodJournalProd.QtyGood        = _serialNumberSpecification.QtyGood;
                _prodJournalProd.QtyError       = _serialNumberSpecification.QtyError;
                _prodJournalProd.PdsCWBatchGood = _serialNumberSpecification.PdsCWQtyGood;
                _prodJournalProd.PdsCWBatchErr  = _serialNumberSpecification.PdsCWQtyError;
                _prodJournalProd.ErrorCause     = _serialNumberSpecification.ErrorCause;
            }
            else
            {
                _prodJournalProd.QtyGood        = 0;
                _prodJournalProd.QtyError       = 0;
                _prodJournalProd.PdsCWBatchGood = 0;
                _prodJournalProd.PdsCWBatchErr  = 0;
                _prodJournalProd.ErrorCause = ProdErrorCause::None;
            }

            InventSerial jobInventSerial = InventSerial::findOrCreate(_serialNumberSpecification.SerialNumber, _prodJournalProd.ItemId);
            _journalInventDim.inventSerialId = jobInventSerial.inventSerialId;
            _prodJournalProd.InventDimId  = InventDim::findOrCreate(_journalInventDim).inventDimId;

            i++;
            if (i == localSerialNumberSpecification.RecId)
            {
                _prodJournalProd.ProdFinished = _prodFinished;
            }

            _journalTransDataRaf.create();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLine_PrevOperations_QtyError</Name>
				<Source><![CDATA[
    [SysObsolete('Multi-line report as finish journal is taken care of by ProdMultiLineReportAsFinishSerialNumFeature', false, 03\07\2022)]
    private void createLine_PrevOperations_QtyError(
        ProdJournalTransDataProd _journalTransDataRaf, 
        ProdJournalProd          _prodJournalProd, 
        InventDimId              _journalInventDimId,  
        boolean                  _isOperationsReportedAsFinishedQuantity,
        boolean                  _isNoSerialNumberReporting)
    {
        ProdReportedError prevReported = this.calculatePrevOperations_QtyError(_journalTransDataRaf.prodId());

        if (_isOperationsReportedAsFinishedQuantity && prevReported)
        {
            _prodJournalProd.QtyError      = prevReported;
            _prodJournalProd.PdsCWBatchErr = this.calculatePrevOperations_PdsCWQtyError(_journalTransDataRaf.prodId());
            _prodJournalProd.InventDimId   = _journalInventDimId;

            // Mark Report as Finished if no serial number reporting
            if (_isNoSerialNumberReporting)
            {
                _prodJournalProd.ProdFinished = true;
            }

            _journalTransDataRaf.create();
        }
        else if (_isNoSerialNumberReporting)
        {
            // Create line with no reported quanitity in order to complete job  
            _prodJournalProd.ProdFinished = true;
            _journalTransDataRaf.create();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatePrevOperations_QtyError</Name>
				<Source><![CDATA[
    [SysObsolete('Multi-line report as finish journal is taken care of by ProdMultiLineReportAsFinishSerialNumFeature', false, 03\07\2022)]
    private ProdReportedError calculatePrevOperations_QtyError(ProdId _prodId)
    {
        JmgStampJournalTrans        jmgStampJournalTransSum;
        JmgStampTrans               jmgStampTransSum;

        select sum(QtyError) from jmgStampJournalTransSum
            where jmgStampJournalTransSum.Module   == JmgModuleEnum::PROD
               && jmgStampJournalTransSum.JobRef   == _prodId
               && (jmgStampJournalTransSum.Worker  != worker
                ||  (jmgStampJournalTransSum.Worker == worker
                &&   jmgStampJournalTransSum.Active == NoYes::No));

        select sum(QtyError) from jmgStampTransSum
            where jmgStampTransSum.Module  == JmgModuleEnum::PROD
                && jmgStampTransSum.JobRef == _prodId;

        return jmgStampJournalTransSum.QtyError + jmgStampTransSum.QtyError;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatePrevOperations_PdsCWQtyError</Name>
				<Source><![CDATA[
    [SysObsolete('Multi-line report as finish journal is taken care of by ProdMultiLineReportAsFinishSerialNumFeature', false, 03\07\2022)]
    private PdsCWBatchErr calculatePrevOperations_PdsCWQtyError(ProdId _prodId)
    {
        JmgStampJournalTrans        jmgStampJournalTransSum;
        JmgStampTrans               jmgStampTransSum;

        select sum(PdsCWQtyError) from jmgStampJournalTransSum
            where jmgStampJournalTransSum.Module   == JmgModuleEnum::PROD
               && jmgStampJournalTransSum.JobRef   == _prodId
               && (jmgStampJournalTransSum.Worker  != worker
                ||  (jmgStampJournalTransSum.Worker == worker
                &&   jmgStampJournalTransSum.Active == NoYes::No));

        select sum(PdsCWQtyError) from jmgStampTransSum
            where jmgStampTransSum.Module  == JmgModuleEnum::PROD
                && jmgStampTransSum.JobRef == _prodId;

        return jmgStampJournalTransSum.PdsCWQtyError + jmgStampTransSum.PdsCWQtyError;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLogger</Name>
				<Source><![CDATA[
    private JmgInstrumentationLogger createLogger()
    {
        jmgInstrumentationLogger = JmgInstrumentationLogger::createLogger(classStr(JmgPostStandardSystem));
        return jmgInstrumentationLogger;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>