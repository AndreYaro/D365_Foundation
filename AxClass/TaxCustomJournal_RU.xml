<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxCustomJournal_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
class TaxCustomJournal_RU extends Tax
{
    CustomJournalTable_RU   customJournalTable;

    tableId                 sourceTableId;
    RecId                   sourceRecId;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcAndInsertTaxes</Name>
				<Source><![CDATA[
    protected TaxAmount calcAndInsertTaxes()
    {
        CustomJournalTrans_RU           customJournalTrans;
        TaxAmount                       vatAmount;
        TaxAmount                       exciseAmount;
        TaxAmount                       baseAmount;
        TaxAmount                       taxAmount;
        LedgerDimensionDefaultAccount   ledgerDefaultAccount;

        ttsbegin;

        while select * from customJournalTrans
        where customJournalTrans.CustomJournalId == customJournalTable.CustomJournalId
        {
            baseAmount   = 0;
            vatAmount    = 0;
            exciseAmount = 0;

            switch (customJournalTrans.CalculationMethod)
            {
                case CustomCalculationMethod_RU::Invoice:
                    baseAmount   = customJournalTrans.InvoiceCostInclMarkup;
                    vatAmount    = customJournalTrans.InvoiceVAT;
                    exciseAmount = customJournalTrans.InvoiceExcise;
                    break;

                case CustomCalculationMethod_RU::Indicative:
                    baseAmount   = customJournalTrans.IndicativeCost;
                    vatAmount    = customJournalTrans.IndicativeVAT;
                    exciseAmount = customJournalTrans.IndicativeExcise;
                    break;
            }

            if (! vatAmount && ! exciseAmount)
            {
                continue;
            }

            taxWorkTrans.clear();
            taxWorkTrans.HeadingTableId         = sourceTableId;
            taxWorkTrans.HeadingRecId           = sourceRecId;
            taxWorkTrans.SourceTableId          = this.sourceTableId();
            taxWorkTrans.SourceRecId            = this.sourceRecId();
            taxWorkTrans.InvoiceRecId           = sourceRecId;

            taxWorkTrans.Source                 = taxModuleType;
            taxWorkTrans.Voucher                = voucher;
            taxWorkTrans.TransDate              = taxDate;
            taxWorkTrans.CalculationDate        = taxDate;
            taxWorkTrans.TaxDirection           = TaxDirection::IncomingTax;
            taxWorkTrans.CurrencyCode           = sourceCurrencyCode;
            taxWorkTrans.SourceCurrencyCode     = sourceCurrencyCode;
            taxWorkTrans.TaxAutogenerated       = true;
            taxWorkTrans.TaxBaseAmount          = baseAmount;
            taxWorkTrans.TaxBaseAmountCur       = baseAmount;
            taxWorkTrans.SourceBaseAmountCur    = baseAmount;
            taxWorkTrans.TaxBaseQty             = customJournalTrans.Qty;

            if (vatAmount)
            {
                taxWorkTrans.TaxCode                = FEACCCustomRateTable_RU::findOnDate(customJournalTrans.feaccId,
                                                                                          TaxType_W::VAT,
                                                                                          CustomJournalCalc_RU::customAllImportExport(customJournalTable.CustomJournalType),
                                                                                          customJournalTrans.CountryRegionId,
                                                                                          customJournalTable.PlanArrivalDate);

                if (! taxWorkTrans.TaxCode)
                {
                    checkFailed(strfmt("@GLS116078", customJournalTable.CustomJournalId, customJournalTrans.feaccId, enum2str(TaxType_W::VAT)));
                }

                ledgerDefaultAccount                = TaxLedgerAccountGroup::accountLedgerDimension(taxWorkTrans.TaxCode, TaxDirection::IncomingTax);
                taxWorkTrans.LedgerDimension        = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDefaultAccount, customJournalTrans.DefaultDimension);

                taxWorkTrans.SourceTaxAmountCur     = vatAmount;
                taxWorkTrans.TaxAmount              = vatAmount;
                taxWorkTrans.TaxAmountCur           = vatAmount;
                taxWorkTrans.insert();

                taxAmount += vatAmount;
            }

            if (exciseAmount)
            {
                taxWorkTrans.TaxCode                = FEACCCustomRateTable_RU::findOnDate(customJournalTrans.feaccId,
                                                                                          TaxType_W::Excise,
                                                                                          CustomJournalCalc_RU::customAllImportExport(customJournalTable.CustomJournalType),
                                                                                          customJournalTrans.CountryRegionId,
                                                                                          customJournalTable.PlanArrivalDate);
                if (! taxWorkTrans.TaxCode)
                {
                    checkFailed(strfmt("@GLS116078", customJournalTable.CustomJournalId, customJournalTrans.feaccId, enum2str(TaxType_W::Excise)));
                }

                ledgerDefaultAccount                = TaxLedgerAccountGroup::accountLedgerDimension(taxWorkTrans.TaxCode, TaxDirection::IncomingTax);
                taxWorkTrans.LedgerDimension        = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDefaultAccount, customJournalTrans.DefaultDimension);

                taxWorkTrans.SourceTaxAmountCur     = exciseAmount;
                taxWorkTrans.TaxAmount              = exciseAmount;
                taxWorkTrans.TaxAmountCur           = exciseAmount;
                taxWorkTrans.insert();

                taxAmount += exciseAmount;
            }
        }

        ttscommit;

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAndPost</Name>
				<Source><![CDATA[
    public TaxAmount calcAndPost(LedgerPostingController _ledgerPostingController)
    {
        TaxAmount   taxAmount;

        if (_ledgerPostingController.getJournal() == null)
        {
            throw error(Error::missingParameter(this));
        }

        if (sourceRecId && sourceTableId)
        {
            taxAmount = this.calcAndInsertTaxes();

            this.saveAndPost(_ledgerPostingController);
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new(Voucher        _voucher,
             TransDate      _taxDate,
             tableId        _sourceTableId,
             RecId          _sourceRecId,
             CurrencyCode   _currencyCode,
             ExchRate       _exchRate)
    {
        super();

        voucher            = _voucher;
        taxDate            = _taxDate;
        sourceTableId      = _sourceTableId;
        sourceRecId        = _sourceRecId;

        taxModuleType      = TaxModuleType::Voucher;

        this.setExchRates(_currencyCode, _exchRate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalTable</Name>
				<Source><![CDATA[
    void parmJournalTable(Common _journalTable)
    {
        customJournalTable = _journalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPost</Name>
				<Source><![CDATA[
    public void saveAndPost(LedgerPostingController _ledgerPostingController)
    {
        TaxTrans    taxTrans;
        ExchRate    exchRateOnTax;
        CurrencyExchangeHelper  exchangeRateHelper;

        this.validateForPost();

        ttsbegin;

        while select *
        from taxWorkTrans
        where taxWorkTrans.SourceRecId     == sourceRecId &&
              (taxWorkTrans.TaxOrigin     != TaxOrigin::TaxReversed ||
              this.allowPostingOfReversals()) &&
              taxWorkTrans.IsDeleted      == NoYes::No
        {
            if (taxWorkTrans.TaxCode)
            {
                this.validateWarningsForPost(taxWorkTrans.Warning, taxWorkTrans.TaxCode, false);

                taxTrans.clear();
                this.initFromTaxWorkTrans(taxTrans, taxWorkTrans,  this.taxOrigin(taxWorkTrans.TaxOrigin));
                this.taxInCostPriceReporting(taxTrans, taxWorkTrans.TaxInCostPrice);

                taxTrans.SourceTableId    = sourceTableId;
                taxTrans.SourceRecId      = sourceRecId;
                this.initTaxTrans(taxTrans, _ledgerPostingController.getJournal().parmVoucherSeriesCode());
                taxTrans.insert();

                if (taxTrans.SourceTaxAmountCur != 0 && !triangulation && this.exchRate() != taxTrans.TaxAmount / taxTrans.SourceTaxAmountCur * 100)
                {
                    exchRateOnTax = taxTrans.TaxAmount / taxTrans.SourceTaxAmountCur * 100;
                }
                else
                {
                    exchRateOnTax = this.exchRate();
                }
                exchangeRateHelper = CurrencyExchangeHelper::newLedger(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));
                exchangeRateHelper.parmExchangeDate(taxTrans.TransDate);
                exchangeRateHelper.parmExchangeRate1(exchRateOnTax);
                exchangeRateHelper.parmExchangeRate2(exchRateSecond);

                this.post(_ledgerPostingController, taxTrans, taxTrans.SourceTaxAmountCur, taxTrans.TaxInCostPrice, exchangeRateHelper, taxWorkTrans.LedgerDimension, taxWorkTrans.OperationLedgerDimension, taxWorkTrans.TaxOffsetUseTaxLedgerDimension, LedgerDetailLevel::Summary);
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceRecId</Name>
				<Source><![CDATA[
    public RecId sourceRecId()
    {
        return sourceRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTableId</Name>
				<Source><![CDATA[
    public tableId sourceTableId()
    {
        return sourceTableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static TaxCustomJournal_RU construct(CustomDocument_RU   _customDocument,
                                                Voucher             _voucher,
                                                TransDate           _taxDate,
                                                tableId             _sourceTableId,
                                                RecId               _sourceRecId,
                                                CurrencyCode        _currencyCode,
                                                ExchRate            _exchRate,
                                                Common              _journalTable)
    {
        TaxCustomJournal_RU taxCustomJournal;

        switch (_customDocument)
        {
            case CustomDocument_RU::GTD:
                taxCustomJournal = new TaxCustomJournal_RU(_voucher, _taxDate, _sourceTableId, _sourceRecId, _currencyCode, _exchRate);
                break;

            case CustomDocument_RU::Correction:
                taxCustomJournal = new TaxCustomCorrectionJournal_RU(_voucher, _taxDate, _sourceTableId, _sourceRecId, _currencyCode, _exchRate);
                break;
        }

        taxCustomJournal.parmJournalTable(_journalTable);

        return taxCustomJournal;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>