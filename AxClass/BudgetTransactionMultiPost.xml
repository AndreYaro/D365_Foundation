<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BudgetTransactionMultiPost</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    Contains the logic to process one or more budget transaction headers to post.
/// </summary>
class BudgetTransactionMultiPost extends RunBaseBatch implements BatchRetryable
{
    Set budgetTransactionHeaderList;

    boolean                     sumPreliminaryBudget;
    boolean                     displayReversalControls;
    boolean                     isPostiveAmountForTransactionTypeIncreaseToBudget;
    boolean                     isReversal;
    boolean                     posted;
    boolean                     userHasTransactionInUse;
    BudgetCode                  reversalTransactionCode;
    BudgetProvisionalReverseHelper budgetProvisionalReverseHelper;
    BudgetTransactionHeader     budgetTransactionHeader;
    BudgetTransactionId         budgetTransactionId;
    Counter                     numOfLinesProcessed;
    Counter                     progressCounter;
    NoYes                       isReversePreliminary;
    RecId                       primaryLedgerRecId;
    ReversalTransactionCodes    specifyTransactionCode;
    BudgetControlConfiguration  budgetControlConfiguration;
    container                   summaryTrackingDate;
    date                        startDate;
    date                        endDate;
    FormRun                     dialogFormRun;
    boolean useTodayDateToReversePreliminaryBudget;

    // This list defines which fields will be persisted and
    // restored via the system's SysLastValue functionality.
    #LOCALMACRO.SysLastValuesList
        // Currently no values are persisted via SysLastValues.
        // If values are added here, uncomment the code in saveLast and getLast methods
        //    and implement packSysLastValues and unpackSysLastValues methods.
    #ENDMACRO

                                              // SysLastValuesList forked from.

    #DEFINE.CurrentVersion(1)

    #LOCALMACRO.CurrentList
        // budgetTransactionHeaderList is packed and unpacked separately.
        // If values are added to this list, update the pack and unpack methods to include #CurrentList.
        budgetTransactionId,
        isReversePreliminary,
        reversalTransactionCode,
        specifyTransactionCode,
        displayReversalControls
    #ENDMACRO
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addBudgetTransactionHeaderSetToPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the budget transaction headers from the packed set to the list of items to post.
    /// </summary>
    /// <param name="_packedBudgetTransactionHeaderIds">
    ///    The packed set of budget transaction header identifiers for the budget transactions to post.
    /// </param>
    private void addBudgetTransactionHeaderSetToPost(container _packedBudgetTransactionHeaderIds)
    {
        Set                         budgetTransactionHeaderSet;
        SetEnumerator               setEnumerator;

        budgetTransactionHeaderSet = Set::create(_packedBudgetTransactionHeaderIds);
        setEnumerator = budgetTransactionHeaderSet.getEnumerator();

        while (setEnumerator.moveNext())
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
            {
                budgetTransactionId = setEnumerator.current();
                this.addBudgetTransactionHeaderToPost(budgetTransactionId);
            }
            else
            {
                this.addBudgetTransactionHeaderToPost(setEnumerator.current());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBudgetTransactionHeaderToPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a budget transaction header to the list of items to post.
    /// </summary>
    /// <param name="_budgetTransactionId">
    ///    The <c>BudgetTransactionId</c> value of the budget transaction header to post.
    /// </param>
    public void addBudgetTransactionHeaderToPost(BudgetTransactionId _budgetTransactionId)
    {
        budgetTransactionHeaderList.add(_budgetTransactionId);

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            if (sumPreliminaryBudget && !this.parmDisplayReversalControls())
            {
                this.parmDisplayReversalControls(BudgetTransactionMultiPost::getBudgetTransactionLineForReversal(_budgetTransactionId, primaryLedgerRecId).RecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatch</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the posting operation can be batched.
    /// </summary>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    public boolean canGoBatch()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAllSetForReversal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks several validations that are required for reversal of preliminary budget transaction.
    /// </summary>
    /// <returns>
    /// true if all parameters are set for reversal; otherwise, false.
    /// </returns>
    public boolean checkAllSetForReversal()
    {
        boolean allParmSet = false;

        allParmSet = true;

        // Performing reset for displayReversalControls variable.
        displayReversalControls = false;

        if (allParmSet && !isReversePreliminary)
        {
            allParmSet = false;
            throw error(strFmt("@SPS564", "@SPS377"));
        }

        return allParmSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExistingBudgetTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for existing inquired budget transaction in <c>BudgetTransactionLine</c> table on posting of budget transaction.
    /// </summary>
    /// <param name="_budgetTransactionType">
    /// The <c>_budgetTransactionType</c> of the budget transaction to post.
    /// </param>
    /// <returns>
    /// true if inquired budget transactions exists; otherwise, false.
    /// </returns>
    public boolean checkExistingBudgetTransaction(BudgetTransactionType _budgetTransactionType)
    {
        BudgetTransactionHeader budgetTransactionHeaderProvisional;
        BudgetTransactionLine   budgetTransactionLineOriginal;
        BudgetTransactionLine   budgetTransactionLineProvisional;
        boolean                 budgetTypeExist = false;

        select firstonly LedgerDimension from budgetTransactionLineOriginal
        where  budgetTransactionLineOriginal.BudgetTransactionHeader == budgetTransactionHeader.RecId
        exists join  budgetTransactionHeaderProvisional
            where budgetTransactionHeaderProvisional.BudgetModelId == budgetTransactionHeader.BudgetModelId
               &&  budgetTransactionHeaderProvisional.BudgetTransactionType == _budgetTransactionType
               &&  budgetTransactionHeaderProvisional.TransactionStatus == BudgetTransactionStatus::Completed
               &&  budgetTransactionHeaderProvisional.PrimaryLedger == primaryLedgerRecId
               &&  budgetTransactionHeaderProvisional.Date >= startDate
               &&  budgetTransactionHeaderProvisional.Date <= endDate
        exists join budgetTransactionLineProvisional
            where  budgetTransactionLineProvisional.BudgetTransactionHeader == budgetTransactionHeaderProvisional.RecId
                &&  budgetTransactionLineProvisional.LedgerDimension == budgetTransactionLineOriginal.LedgerDimension;

        if (budgetTransactionLineOriginal.LedgerDimension)
        {
            budgetTypeExist = true;
        }

        return budgetTypeExist;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPreliminaryTransactionInDraft</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for existing unposted preliminary transaction in <c>BudgetTransactionTable</c> table.
    /// </summary>
    public void checkPreliminaryTransactionInDraft()
    {
        BudgetTransactionHeader budgetTransactionHeaderProvisional;
        BudgetTransactionLine   budgetTransactionLineOrig;
        BudgetTransactionLine   budgetTransactionLineProv;

        select firstonly RecId from budgetTransactionLineOrig
         where budgetTransactionLineOrig.BudgetTransactionHeader == budgetTransactionHeader.RecId
         exists join RecId from budgetTransactionHeaderProvisional
             where budgetTransactionHeaderProvisional.BudgetModelId == budgetTransactionHeader.BudgetModelId
                 &&    budgetTransactionHeaderProvisional.BudgetTransactionType == BudgetTransactionType::PreliminaryBudget
                 &&    budgetTransactionHeaderProvisional.PrimaryLedger == budgetTransactionHeader.PrimaryLedger
                 &&    budgetTransactionHeaderProvisional.TransactionStatus == BudgetTransactionStatus::Draft
                 &&    budgetTransactionHeaderProvisional.Date >= startDate
                 &&    budgetTransactionHeaderProvisional.Date <= endDate
         exists join budgetTransactionLineProv
            where budgetTransactionLineProv.BudgetTransactionHeader == budgetTransactionHeaderProvisional.RecId
                &&  budgetTransactionLineProv.LedgerDimension == budgetTransactionLineOrig.LedgerDimension;

        if (budgetTransactionLineOrig)
        {
            warning("@SPS527");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates budget transaction posting dialog.
    /// </summary>
    /// <returns>
    /// A dialog object.
    /// </returns>
    public Object dialog()
    {
        return Dialog::newFormnameRunbase(formstr(BudgetTransactionMultiPost), this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPostRun</Name>
				<Source><![CDATA[
    public void dialogPostRun(DialogRunbase _dialog)
    {
        super(_dialog);

        dialogFormRun = _dialog.formRun();

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            BudgetTransactionIMultiPost budgetTransactionIMultiPost = dialogFormRun as BudgetTransactionIMultiPost;

            if (budgetTransactionIMultiPost)
            {
                budgetTransactionIMultiPost.setBudgetTabPageVisible(true);
                budgetTransactionIMultiPost.setIsReversalPreliminaryEnabled(displayReversalControls);
            }

            _dialog.dialogForm().formRun().controlMethodOverload(true);
            _dialog.dialogForm().formRun().controlMethodOverloadObject(this);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets values from controls on the dialog.
    /// </summary>
    /// <returns>
    /// true if call to the super() method returns true; otherwise, false.
    /// </returns>
    public boolean getFromDialog()
    {
        boolean ret;

        ret = super();

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            BudgetTransactionIMultiPost budgetTransactionIMultiPost = dialogFormRun as BudgetTransactionIMultiPost;

            if (budgetTransactionIMultiPost)
            {
                if (budgetTransactionIMultiPost.getIsReversePreliminarySelected())
                {
                    reversalTransactionCode = budgetTransactionIMultiPost.getReversalTransactionCodeName();
                }

                isReversePreliminary = budgetTransactionIMultiPost.getIsReversePreliminarySelected();
                specifyTransactionCode = budgetTransactionIMultiPost.getSpecifyTransactionCodeValue();
            }

            if (PreliminaryBudgetReversalDateFeature::isEnabled())
            {
                BudgetTransactionIMultiPostReversal budgetTransactionIMultiPostReversal = dialogFormRun as BudgetTransactionIMultiPostReversal;

                if (budgetTransactionIMultiPostReversal)
                {
                    useTodayDateToReversePreliminaryBudget = budgetTransactionIMultiPostReversal.getUseTodayDateToReversePreliminaryBudget();
                }
            }
           
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>SysLastValue</c> record for this user and object.
    /// </summary>
    /// <remarks>
    ///    This is a customization of the standard <c>SysLastValues</c> functionality and is required to
    ///    support the split implementation of serializing, with pack and unpack, and persisting user input.
    /// </remarks>
    public void getLast()
    {
        //container packedValues;

        // Don't make the call to super as the #CurrentList and #SysLastValues
        // lists are different, requiring that we have specialized logic for the
        // SysLastValues implementation.

        // The following fields must be maintained to mimic the functionality of the overridden method.
        getLastCalled   = true;
        inGetSaveLast   = true;

        // Don't call getValue or unpackSysLastValues because no values are currently persisted via SysLastValue.

        // Restore the pertinent values from the SysLastValue table.
        //packedValues = xSysLastValue::getValue(this.lastValueDataAreaId(),
        //                                       this.lastValueUserId(),
        //                                       this.lastValueType(),
        //                                       this.lastValueElementName(),
        //                                       this.lastValueDesignName());
        //this.unpackSysLastValues(packedValues);

        // This is a RunBaseBatch derivative class. Manually restore the user's settings on the batch tab since super() is not being called.
        xSysLastValue::getLast(this.batchInfo());

        // The following fields must be maintained to mimic the functionality of the overridden method.
        inGetSaveLast = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPerformReversal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks parameters for reversal.
    /// </summary>
    /// <param name="_budgetTransactionId">
    /// The <c>BudgetTransactionId</c> of the budget transaction header to post.
    /// </param>
    /// <returns>
    /// true if all parameter for reversal are enabled; otherwise, false.
    /// </returns>
    public boolean isPerformReversal(BudgetTransactionId _budgetTransactionId)
    {
        budgetTransactionHeader = BudgetTransactionHeader::findByTransactionNumber(_budgetTransactionId, primaryLedgerRecId);

        return (sumPreliminaryBudget && budgetTransactionHeader.BudgetTransactionType == BudgetTransactionType::OriginalBudget);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();

        budgetTransactionHeaderList = new Set(Types::String);
        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            primaryLedgerRecId = Ledger::current();
            budgetControlConfiguration  = BudgetControlConfiguration::findActiveByPrimaryLedger(primaryLedgerRecId);
            sumPreliminaryBudget = budgetControlConfiguration.SumPreliminaryBudget && !budgetControlConfiguration.UseApportionedAmount ;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container packed;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            packed = [#CurrentVersion, [budgetTransactionHeaderList ? budgetTransactionHeaderList.pack() : conNull()], #CurrentList];
        }
        else
        {
            packed = [#CurrentVersion, [budgetTransactionHeaderList ? budgetTransactionHeaderList.pack() : connull()]];
        }

        packed = SysPackExtensions::appendVariableToPack(packed, classStr(BudgetTransactionMultiPost), varStr(useTodayDateToReversePreliminaryBudget), useTodayDateToReversePreliminaryBudget);
        return packed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBudgetTransactionId</Name>
				<Source><![CDATA[
    public BudgetTransactionId parmBudgetTransactionId(BudgetTransactionId _budgetTransactionId = budgetTransactionId)
    {
        budgetTransactionId = _budgetTransactionId;
        return budgetTransactionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDisplayReversalControls</Name>
				<Source><![CDATA[
    public boolean parmDisplayReversalControls(boolean _displayReversalControls = displayReversalControls)
    {
        displayReversalControls = _displayReversalControls;

        return displayReversalControls;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the logic for posting a set of budget transactions.
    /// </summary>
    public void run()
    {
        int                     numPostSuccess;
        boolean                 errorsExist = false;
        container               errorsLogged;
        BudgetTransactionPost   budgetTransactionPost; // Batch task that will post the individual budget transactions
        SetEnumerator           setEnumerator;
        BatchHeader             batchHeader;
        BudgetTransactionCode   budgetTransactionCode;

        #OCCRetryCount
        setPrefix(BudgetTransactionMultiPost::description());

        if (this.isInBatch() == true)
        {
            // Create the BatchHeader if the user chose to use batch processing.
            batchHeader = BatchHeader::construct(this.parmCurrentBatch().BatchJobId);
        }

        setEnumerator = budgetTransactionHeaderList.getEnumerator();

        // Post the budget transactions specified in the list.
        while (setEnumerator.moveNext())
        {
            try
            {
                budgetTransactionId = setEnumerator.current();
                budgetTransactionPost = BudgetTransactionPost::construct(budgetTransactionId);

                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    budgetTransactionHeader = BudgetTransactionHeader::findByTransactionNumber(budgetTransactionId, primaryLedgerRecId);
                    summaryTrackingDate = BudgetTransactionMultiPost::calculateTimeInterval(budgetTransactionHeader.Date);
                    startDate = conPeek(summaryTrackingDate,1);
                    endDate = conPeek(summaryTrackingDate,2);
                    switch (budgetTransactionHeader.BudgetTransactionType)
                    {
                        case BudgetTransactionType::PreliminaryBudget:

                            if (sumPreliminaryBudget && this.checkExistingBudgetTransaction(BudgetTransactionType::OriginalBudget))
                            {
                                warning("@SPS566");
                            }
                            break;

                        case BudgetTransactionType::OriginalBudget:

                            if (!sumPreliminaryBudget && this.checkExistingBudgetTransaction(BudgetTransactionType::PreliminaryBudget))
                            {
                                info("@SPS2284");
                            }
                            else
                            {
                                if (displayReversalControls && this.checkAllSetForReversal())
                                {
                                    if (batchHeader)
                                    {
                                        budgetTransactionPost.parmIsBudgetReversal(true);
                                        budgetTransactionPost.parmIsReversePreliminary(isReversePreliminary);
                                        budgetTransactionPost.parmReversalTransactionCode(reversalTransactionCode);
                                        budgetTransactionPost.parmSpecifyTransactionCode(specifyTransactionCode);
                                        budgetTransactionPost.parmUseTodayDateToReversePreliminaryBudget(useTodayDateToReversePreliminaryBudget);
                                    }
                                    else
                                    {
                                        budgetProvisionalReverseHelper = BudgetProvisionalReverseHelper::construct();

                                        if (specifyTransactionCode == ReversalTransactionCodes::SpecifyTransactionCode)
                                        {
                                            budgetProvisionalReverseHelper.parmIsSpecificBudgetCode(true);
                                            budgetProvisionalReverseHelper.parmBudgetTransactionCode(reversalTransactionCode);
                                        }
                                        else
                                        {
                                            budgetProvisionalReverseHelper.parmIsSpecificBudgetCode(false);
                                        }

                                        budgetProvisionalReverseHelper.parmIsReversalRequired(isReversePreliminary);
                                        budgetProvisionalReverseHelper.parmUseTodayDateToReversePreliminaryBudget(useTodayDateToReversePreliminaryBudget);
                                        budgetTransactionPost.parmBudgetProvisionalReverseHelper(budgetProvisionalReverseHelper);
                                    }
                                }

                                this.checkPreliminaryTransactionInDraft();
                            }
                            break;
                    }
                }

                if (batchHeader)
                {
                    // Using batch processing; add a task to post the budget transaction.
                    budgetTransactionPost.batchInfo().parmCaption(strFmt("@SYS319308", "@SYS129613", budgetTransactionId));
                    batchHeader.addRuntimeTask(budgetTransactionPost, this.parmCurrentBatch().RecId);
                }
                else
                {
                    // Not using batch processing; post the budget transaction immediately.
                    budgetTransactionPost.runOperation();
                    numPostSuccess++;
                }
            }
            catch (Exception::Deadlock)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::Deadlock;
                }
                else
                {
                    retry;
                }
            }
            catch (Exception::UpdateConflict)
            {
                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        throw Exception::UpdateConflictNotRecovered;
                    }
                    else
                    {
                        retry;
                    }
                }
                else
                {
                    throw Exception::UpdateConflict;
                }
            }
            catch (Exception::Error)
            {
                // Continue to post any additional budget transactions.
            }
        }

        if (batchHeader)
        {
            batchHeader.save();
        }
        else
        {
            int numPostCanceled = budgetTransactionHeaderList.elements() - numPostSuccess;
            info(strFmt("@Budget:RegisterEntryMultiPostResults", numPostSuccess, numPostCanceled));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the posting operation runs as impersonated.
    /// </summary>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveLast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves the <c>SysLastValue</c> record for this user and object.
    /// </summary>
    /// <remarks>
    ///    This is a customization of the standard <c>SysLastValues</c> functionality and is required to
    ///    support the split implementation of serializing, with pack and unpack, and persisting user input.
    /// </remarks>
    public void saveLast()
    {
        // Don't make the call to super as the #CurrentList and #SysLastValues
        // lists are different, requiring that we have specialized logic for the
        // SysLastValues implementation.

        // The following fields must be maintained to mimic the functionality of the overridden method.
        inGetSaveLast   = true;

        // Don't call putValue because no values are currently persisted via SysLastValue.

        // Persist the pertinent values to the SysLastValue table.
        //xSysLastValue::putValue(this.packSysLastValues(),
        //                        this.lastValueDataAreaId(),
        //                        this.lastValueUserId(),
        //                        this.lastValueType(),
        //                        this.lastValueElementName(),
        //                        this.lastValueDesignName());

        // This is a RunBaseBatch derivative class. Manually save the user's
        // settings on the batch tab since super() is not being called.
        xSysLastValue::saveLast(this.batchInfo());

        // The following fields must be maintained to mimic the functionality of the overridden method.
        inGetSaveLast = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);
        container packedValues, packedBudgetTransactionsList;

        switch (version)
        {
            case #CurrentVersion :
                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    [version, packedValues, #CurrentList] = _packedClass;
                }
                else
                {
                    [version, packedValues] = _packedClass;
                }
                [packedBudgetTransactionsList] = packedValues;

                useTodayDateToReversePreliminaryBudget = SysPackExtensions::extractPackedVariable(_packedClass, classStr(BudgetTransactionMultiPost), varStr(useTodayDateToReversePreliminaryBudget));

                break;

            default :
                return false;
        }

        if (packedBudgetTransactionsList != conNull())
        {
            // Unpack the packed set
            budgetTransactionHeaderList = Set::create(packedBudgetTransactionsList);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for valid preliminary budget transaction code.
    /// </summary>
    /// <param name="calledFrom">
    /// An object from base class implementation of the method.
    /// </param>
    /// <returns>
    /// true if preliminary budget transaction code is valid; otherwise, false.
    /// </returns>
    public boolean validate(Object calledFrom = null)
    {
        boolean ret;
        BudgetTransactionCode   budgetTransactionCode;
        boolean validPreliminaryBudgetCode = false;
        str errorText;

        ret = super();

        if (specifyTransactionCode == ReversalTransactionCodes::SpecifyTransactionCode && sumPreliminaryBudget)
        {
            budgetTransactionCode = BudgetTransactionCode::findByBudgetTransactionCode(reversalTransactionCode);

            if (!budgetTransactionCode)
            {
                errorText = "@SPS2269";
                checkFailed(errorText);
                ret = false;
            }
            else
            {
                validPreliminaryBudgetCode = budgetTransactionCode.BudgetTransactionType == BudgetTransactionType::PreliminaryBudget
                                        && BudgetTransactionMultiPost::checkExistingTransactionCodeForReversal(budgetTransactionId, primaryLedgerRecId, reversalTransactionCode);

                if (!validPreliminaryBudgetCode)
                {
                    errorText = strFmt("@SPS556",reversalTransactionCode);
                    checkFailed(errorText);
                    ret = false;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTimeInterval</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the start date and end date of the defined interval for the specified date.
    /// </summary>
    /// <param name="trackingDate">
    ///    The date for which the start date and end date of the defined interval in which the date falls are to be found.
    /// </param>
    /// <returns>
    ///    A container that contains the start date and end date of the fiscal year; otherwise, an empty container.
    /// </returns>
    public static container calculateTimeInterval(date trackingDate)
    {
        date                        dateBegin;
        date                        dateEnd;
        container                   summaryTrackingDate;
        FiscalCalendarRecId         fiscalCalendarRecId;
        FiscalCalendarPeriod        fiscalCalendarPeriod;
        BudgetInterval              budgetInterval;
        RecId                       cycleTimeSpan;

        fiscalCalendarRecId = CompanyInfoHelper::fiscalCalendarRecId();
        fiscalCalendarPeriod = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(fiscalCalendarRecId , trackingDate);
        budgetInterval  = BudgetControlConfiguration::findActiveByPrimaryLedger(Ledger::current()).DefaultInterval;

        switch (budgetInterval)
        {
            case BudgetInterval::FiscalYear:
                dateBegin = FiscalCalendars::findFirstDayofYear(fiscalCalendarRecId , trackingDate);
                dateEnd   = FiscalCalendars::findLastDayofYear(fiscalCalendarRecId , trackingDate);
                break;

            case BudgetInterval::FiscalYearToDate:
                dateBegin = FiscalCalendars::findFirstDayofYear(fiscalCalendarRecId , trackingDate);
                dateEnd   = fiscalCalendarPeriod.EndDate;
                break;

            case BudgetInterval::FiscalPeriod:
                dateBegin = fiscalCalendarPeriod.StartDate;
                dateEnd   = fiscalCalendarPeriod.EndDate;
                break;

            case BudgetInterval::TotalBudget:
                cycleTimeSpan = BudgetControlConfiguration::findActiveByPrimaryLedger(Ledger::current()).DefaultBudgetCycleTimeSpan;
                dateBegin = BudgetCycle::findBudgetCycleStartDate(cycleTimeSpan,trackingDate);
                dateEnd   = BudgetCycle::findBudgetCycleEndDate(cycleTimeSpan,trackingDate);
                break;

            case BudgetInterval::BudgetToDate:
                cycleTimeSpan = BudgetControlConfiguration::findActiveByPrimaryLedger(Ledger::current()).DefaultBudgetCycleTimeSpan;
                dateBegin = BudgetCycle::findBudgetCycleStartDate(cycleTimeSpan,trackingDate);
                dateEnd   = fiscalCalendarPeriod.EndDate;
                break;

            case BudgetInterval::Month:
                dateBegin = FiscalCalendars::findFirstDayOfMonth(fiscalCalendarRecId , trackingDate);
                dateEnd   = FiscalCalendars::findLastDayOfMonth(fiscalCalendarRecId , trackingDate);
                break;

            case BudgetInterval::Quarter:
                dateBegin = FiscalCalendars::findFirstDayOfQuarter(fiscalCalendarRecId , trackingDate);
                dateEnd   = FiscalCalendars::findLastDayOfQuarter(fiscalCalendarRecId , trackingDate);
                break;

            case BudgetInterval::MonthsToDate:
                dateBegin = FiscalCalendars::findFirstDayOfMonth(fiscalCalendarRecId , trackingDate);
                dateEnd   = fiscalCalendarPeriod.EndDate;
                break;

            case BudgetInterval::QuartersToDate:
                dateBegin = FiscalCalendars::findFirstDayOfQuarter(fiscalCalendarRecId , trackingDate);
                dateEnd   = fiscalCalendarPeriod.EndDate;
                break;

            default:
                break;
        }

        summaryTrackingDate = [dateBegin, dateEnd];

        return summaryTrackingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExistingTransactionCodeForReversal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the budget transaction line for process of reversal.
    /// </summary>
    /// <param name="_budgetTransactionId">
    /// <c>BudgetTransactionId</c> to find the respective budget transaction.
    /// </param>
    /// <param name="_primaryLedgerId">
    /// <c>BudgetTransactionId</c> to find the respective budget transaction.
    /// </param>
    /// <param name="_reversalTransactionCode">
    /// <c>BudgetTransactionId</c> to find the respective budget transaction.
    /// </param>
    /// <returns>
    /// Returns the <c>BudgetTransactionLine</c> found by the provided <c>BudgetTransactionId</c>
    /// </returns>
    public static boolean checkExistingTransactionCodeForReversal(BudgetTransactionId _budgetTransactionId, RecId _primaryLedgerId, BudgetCode _reversalTransactionCode)
    {
        BudgetTransactionHeader         budgetTransactionHeaderOrig;
        BudgetTransactionHeader         budgetTransactionHeaderProv;
        BudgetTransactionLine           budgetTransactionLineOrig;
        BudgetTransactionLine           budgetTransactionLineProv;
        BudgetTransactionLineReverse    budgetTransactionLineReversed;
        BudgetTransactionLineReverse    budgetTransactionLineReversing;
        boolean                         provisionalBudgetExist = false;
        container                       summaryTrackingDate;
        date                            startDate;
        date                            endDate;

        budgetTransactionHeaderOrig = BudgetTransactionHeader::findByTransactionNumber(_budgetTransactionId, _primaryLedgerId);

        if (budgetTransactionHeaderOrig.BudgetTransactionType == BudgetTransactionType::OriginalBudget)
        {
            summaryTrackingDate = BudgetTransactionMultiPost::calculateTimeInterval(budgetTransactionHeaderOrig.Date);
            startDate = conPeek(summaryTrackingDate,1);
            endDate = conPeek(summaryTrackingDate,2);

            while select BudgetTransactionHeader, LedgerDimension from budgetTransactionLineOrig
                where budgetTransactionLineOrig.BudgetTransactionHeader == budgetTransactionHeaderOrig.RecId
            {
                select firstonly budgetTransactionLineProv
                    where budgetTransactionLineProv.LedgerDimension == budgetTransactionLineOrig.LedgerDimension
                    exists join budgetTransactionHeaderProv
                        where budgetTransactionHeaderProv.RecId == budgetTransactionLineProv.BudgetTransactionHeader
                            && budgetTransactionHeaderProv.BudgetModelId == budgetTransactionHeaderOrig.BudgetModelId
                            && budgetTransactionHeaderProv.BudgetTransactionType == BudgetTransactionType::PreliminaryBudget
                            && budgetTransactionHeaderProv.TransactionStatus == BudgetTransactionStatus::Completed
                            && budgetTransactionHeaderProv.PrimaryLedger == budgetTransactionHeaderOrig.PrimaryLedger
                            && budgetTransactionHeaderProv.BudgetTransactionCode == BudgetTransactionCode::findByBudgetTransactionCode(_reversalTransactionCode).RecId
                            && budgetTransactionHeaderProv.Date >= startDate
                            && budgetTransactionHeaderProv.Date <= endDate
                    notexists join budgetTransactionLineReversed
                        where budgetTransactionLineReversed.ReversedBudgetTransactionLine == budgetTransactionLineProv.RecId
                    notexists join budgetTransactionLineReversing
                        where budgetTransactionLineReversing.ReversingBudgetTransactionLine == budgetTransactionLineProv.RecId;

                if (budgetTransactionLineProv)
                {
                    provisionalBudgetExist = true;
                    break;
                }
            }
        }

        return provisionalBudgetExist;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates new instance of the <c>BudgetTransactionMultiPost</c> class.
    /// </summary>
    /// <returns>
    ///    A new instance of the <c>BudgetTransactionMultiPost</c> class.
    /// </returns>
    public static BudgetTransactionMultiPost construct()
    {
        BudgetTransactionMultiPost  budgetTransactionMultiPost;

        budgetTransactionMultiPost = new BudgetTransactionMultiPost();

        return budgetTransactionMultiPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@Budget:RegisterEntryMultiPostDescription";
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetTransactionIds</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the set of budget transaction headers to post.
    /// </summary>
    /// <param name="args">
    ///    The arguments for the <c>BudgetTransactionMultiPost</c> class.
    /// </param>
    /// <returns>
    ///    A container that is a packed set that contains the budget transaction headers to be posted.
    /// </returns>
    private static container getBudgetTransactionIds(Args args)
    {
        Common                      common;
        FormDataSource              formDataSource;
        BudgetTransactionHeader     budgetTransactionHeader;
        Set                         budgetTransactionHeaderList = new Set(Types::String);

        if (args && args.dataset() && FormDataUtil::getFormDataSource(args.record()))
        {
            formDataSource = FormDataUtil::getFormDataSource(args.record());

            // If the getFirst method on the datasource returns a valid record, use it to begin the loop.
            // Otherwise use args.record().  Keep getting records as long as the getNext method
            // on the datasource returns a valid recod.
            for (common=formDataSource.getFirst(true)
                    ? formDataSource.getFirst(true)
                    : args.record(); common; common=formDataSource.getNext())
            {
                budgetTransactionHeader = common;
                budgetTransactionHeaderList.add(budgetTransactionHeader.TransactionNumber);
            }
        }

        return budgetTransactionHeaderList.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetTransactionLineForReversal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the budget transaction line for process of reversal.
    /// </summary>
    /// <param name="_budgetTransactionId">
    /// <c>BudgetTransactionId</c> to find the respective budget transaction.
    /// </param>
    /// <param name="_primaryLedgerId">
    /// <c>PrimaryLedgerId</c> to find the respective budget transaction.
    /// </param>
    /// <returns>
    /// Returns the <c>BudgetTransactionLine</c> found by the provided <c>BudgetTransactionId</c>
    /// </returns>
    public static BudgetTransactionLine getBudgetTransactionLineForReversal(
        BudgetTransactionId _budgetTransactionId,
        RecId               _primaryLedgerId)
    {
        BudgetTransactionHeader         budgetTransactionHeaderOrig;
        BudgetTransactionHeader         budgetTransactionHeaderProv;
        BudgetTransactionLine           budgetTransactionLineOrig;
        BudgetTransactionLine           budgetTransactionLineProv;
        BudgetTransactionLineReverse    budgetTransactionLineReversed;
        BudgetTransactionLineReverse    budgetTransactionLineReversing;
        container                       summaryTrackingDate;
        date                            startDate;
        date                            endDate;

        budgetTransactionHeaderOrig = BudgetTransactionHeader::findByTransactionNumber(_budgetTransactionId, _primaryLedgerId);

        if (budgetTransactionHeaderOrig.BudgetTransactionType == BudgetTransactionType::OriginalBudget)
        {
            summaryTrackingDate = BudgetTransactionMultiPost::calculateTimeInterval(budgetTransactionHeaderOrig.Date);
            startDate = conPeek(summaryTrackingDate,1);
            endDate = conPeek(summaryTrackingDate,2);

            select firstOnly RecId from budgetTransactionLineOrig
                where budgetTransactionLineOrig.BudgetTransactionHeader == budgetTransactionHeaderOrig.RecId
                exists join RecId from budgetTransactionHeaderProv
                    where budgetTransactionHeaderProv.BudgetModelId == budgetTransactionHeaderOrig.BudgetModelId
                        && budgetTransactionHeaderProv.BudgetTransactionType == BudgetTransactionType::PreliminaryBudget
                        && budgetTransactionHeaderProv.TransactionStatus == BudgetTransactionStatus::Completed
                        && budgetTransactionHeaderProv.PrimaryLedger == budgetTransactionHeaderOrig.PrimaryLedger
                        && budgetTransactionHeaderProv.Date >= startDate
                        && budgetTransactionHeaderProv.Date <= endDate
                exists join budgetTransactionLineProv
                    where budgetTransactionLineProv.BudgetTransactionHeader == budgetTransactionHeaderProv.RecId
                        && budgetTransactionLineProv.LedgerDimension == budgetTransactionLineOrig.LedgerDimension
                    notexists join budgetTransactionLineReversed
                        where budgetTransactionLineProv.RecId == budgetTransactionLineReversed.ReversedBudgetTransactionLine
                    notexists join budgetTransactionLineReversing
                        where budgetTransactionLineProv.RecId == budgetTransactionLineReversing.ReversingBudgetTransactionLine;
        }

        return BudgetTransactionLine::find(budgetTransactionLineOrig.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static public void main(Args args)
    {
        container                   packedBudgetTransactionHeaderSet;
        BudgetTransactionMultiPost  budgetTransactionMultiPost;
        RecId                       primaryLedgerRecId;

        primaryLedgerRecId = Ledger::current();

        switch (args.dataset())
        {
            case tableNum(BudgetTransactionHeader):
                budgetTransactionMultiPost = BudgetTransactionMultiPost::construct();

                // Get the set of budget transaction headers to post.
                packedBudgetTransactionHeaderSet = BudgetTransactionMultiPost::getBudgetTransactionIds(args);
                budgetTransactionMultiPost.addBudgetTransactionHeaderSetToPost(packedBudgetTransactionHeaderSet);

                break;

            default:
                throw error(strFmt("@SYS23396", funcName()));
        }

        if (budgetTransactionMultiPost.prompt())
        {
            budgetTransactionMultiPost.runOperation();
        }
        else
        {
            // User clicked cancel or selected to use batch processing.

            if (budgetTransactionMultiPost.batchInfo() && budgetTransactionMultiPost.batchInfo().parmBatchExecute())
            {
                // User chose to use batch processing; set the enum value on the arguments.
                args.parmEnum(UnknownNoYes::Yes);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>