<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjForecastPost</Name>
	<SourceCode>
		<Declaration><![CDATA[
class ProjForecastPost
{
    ProjTrans           projTrans;

    LedgerDimensionDefaultAccount
                        accountNum;

    LedgerPostingType   postingType;
    AmountMST           amountMST;
    ProjCostSales       costSales;
    TransDate           ledgerTransDate;

    ProjLedgerStatus    ledgerStatusCostValue;
    LedgerVoucher       ledgerVoucher;
    ProjTransIdBase     transId;

    ProjTable projTable;
    ProjGroup projGroup;
    ProjRevenueProfile projRevProfile;
    ProjParameters projParameters;

    ProjForecastUpdateType
                        forecastUpdateType;

    ForecastModelId     modelId;
    ProjQty             qty;

    Map                 costDistributions;
    Map                 saleDistributions;
    List                fundingSourceList;
    boolean             allocationError;
    
    boolean isMultipleContractLineFeatureEnabled = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();
    protected boolean isProjectOperationsIntegrationEnabled = ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled();
    private PSAContractLineItems contractLineItems;
 
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmContractLineItems</Name>
				<Source><![CDATA[
    public PSAContractLineItems parmContractLineItems(PSAContractLineItems _contractLineItems = contractLineItems)
    {
        contractLineItems = _contractLineItems;
        return contractLineItems;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountNum</Name>
				<Source><![CDATA[
    protected LedgerDimensionDefaultAccount accountNum(LedgerDimensionDefaultAccount _accountNum  = accountNum)
    {
        accountNum   = _accountNum;

        return accountNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountMST</Name>
				<Source><![CDATA[
    protected AmountMST amountMST(AmountMST _amountMST  = amountMST)
    {
        amountMST   = _amountMST;

        return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateTransBudget</Name>
				<Source><![CDATA[
    protected boolean canCreateTransBudget()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDeleteTransBudget</Name>
				<Source><![CDATA[
    protected boolean canDeleteTransBudget()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCost</Name>
				<Source><![CDATA[
    protected boolean checkCost()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCreditAccrued</Name>
				<Source><![CDATA[
    boolean checkCreditAccrued()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCreditCost</Name>
				<Source><![CDATA[
    protected boolean checkCreditCost()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCreditOnAcc</Name>
				<Source><![CDATA[
    boolean checkCreditOnAcc()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDebitAccrued</Name>
				<Source><![CDATA[
    boolean checkDebitAccrued()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDebitCost</Name>
				<Source><![CDATA[
    protected boolean checkDebitCost()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDebitOnAcc</Name>
				<Source><![CDATA[
    boolean checkDebitOnAcc()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEnterAccruedOnAcc</Name>
				<Source><![CDATA[
    protected boolean checkEnterAccruedOnAcc()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEnterCost</Name>
				<Source><![CDATA[
    protected boolean checkEnterCost()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEnterNeverLedger</Name>
				<Source><![CDATA[
    protected boolean checkEnterNeverLedger()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEnterNoneLedger</Name>
				<Source><![CDATA[
    boolean checkEnterNoneLedger()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEnterSalesAccrued</Name>
				<Source><![CDATA[
    protected boolean checkEnterSalesAccrued()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEnterTurnover</Name>
				<Source><![CDATA[
    protected boolean checkEnterTurnover()
    {
        return projTrans.canBeInvoiced() && projTrans.transTurnover();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEnterWIP</Name>
				<Source><![CDATA[
    boolean checkEnterWIP()
    {
        boolean enterWIP;

        switch (projTable.Type)
        {
            case ProjType::TimeMaterial:
                enterWIP   = ForecastModel::find(HeadingSub::Heading,this.modelId()).ProjForecastWIPTimeMaterial;
                break;

            case ProjType::FixedPrice:
                enterWIP   = ForecastModel::find(HeadingSub::Heading,this.modelId()).ProjForecastWIPFixedPrice;
                break;

            case ProjType::Investment:
                enterWIP   = ForecastModel::find(HeadingSub::Heading,this.modelId()).ProjForecastWIPInvestment;
                break;

            default:
                enterWIP    = false;
        }

        return enterWIP;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLedger</Name>
				<Source><![CDATA[
    protected boolean checkLedger()
    {
        if (this.checkEnterCost()       ||
        this.checkEnterSalesAccrued()   ||
        this.checkEnterTurnover()       ||
        this.checkEnterNeverLedger()    ||
        this.checkEnterNoneLedger()     ||
        this.checkEnterAccruedOnAcc()     )
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNeverLedger</Name>
				<Source><![CDATA[
    boolean checkNeverLedger()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNoneLedger</Name>
				<Source><![CDATA[
    boolean checkNoneLedger()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkOnAccAccrued</Name>
				<Source><![CDATA[
    protected boolean checkOnAccAccrued()
    {
        boolean ret = true;

        if (this.checkDebitOnAcc())
        {
            if (! ForecastModel::find(HeadingSub::Heading,this.modelId()).UseProjectDate)
            {
                if (! projTrans.forecastInvoiceDate())
                {
                    ret = checkFailed("@SYS89884");
                }
            }
        }

        if (this.checkCreditOnAcc())
        {
            if (!ForecastModel::find(HeadingSub::Heading,this.modelId()).UseProjectDate)
            {
                if (! projTrans.forecastInvoiceDate())
                {
                    ret = checkFailed("@SYS89884");
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTurnover</Name>
				<Source><![CDATA[
    protected boolean checkTurnover()
    {
        boolean ret = true;

        if (! ForecastModel::find(HeadingSub::Heading,this.modelId()).UseProjectDate)
        {
            if (! projTrans.forecastInvoiceDate())
            {
                ret = checkFailed("@SYS89884");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTurnoverAccrued</Name>
				<Source><![CDATA[
    protected boolean checkTurnoverAccrued()
    {
        boolean ret = true;

        if (this.checkDebitAccrued())
        {
            if (! ForecastModel::find(HeadingSub::Heading,this.modelId()).UseProjectDate)
            {
                if (! projTrans.forecastInvoiceDate())
                {
                    ret = checkFailed("@SYS89884");
                }
            }
        }

        if (this.checkCreditAccrued())
        {
            if (! ForecastModel::find(HeadingSub::Heading,this.modelId()).UseProjectDate)
            {
                if (! projTrans.forecastInvoiceDate())
                {
                    ret = checkFailed("@SYS89884");
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costPostingType</Name>
				<Source><![CDATA[
    LedgerPostingType costPostingType()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>costPostingTypeOffset</Name>
				<Source><![CDATA[
    LedgerPostingType costPostingTypeOffset()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>costSales</Name>
				<Source><![CDATA[
    protected ProjCostSales costSales(ProjCostSales _projCostSales  = costSales)
    {
        costSales   = _projCostSales;

        return costSales;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCostSalesDistributions</Name>
				<Source><![CDATA[
    public void createCostSalesDistributions( )
    {
        ProjFundingEngine       projFundingEngine;
        ProjLineProperty        projLineProperty;
        boolean                 createZeroSalesDistributions;

        costDistributions = new Map(Types::Int64, Types::Real);
        saleDistributions = new Map(Types::Int64, Types::Real);
        fundingSourceList = new List( Types::Class );

        if (projTrans.fundingSource() == 0)
        {
            // Ignore limits if negativeAllocation
            boolean negativeCostAllocation = projTrans.transCost() < 0;
            boolean negativeSaleAllocation = projTrans.transTurnover() < 0;
            boolean useFundingLimits = !(negativeCostAllocation || negativeSaleAllocation);

            if (useFundingLimits)
            {
                switch (projTrans.buffer().TableId)
                {
                    case tableNum(ForecastSales):
                        ForecastSales forecastSales = projTrans.buffer();
                        if (forecastSales.ProjForecastBudgetType != ProjForecastBudgetType::None)
                        {
                            useFundingLimits = false;
                        }
                        break;
                    case tableNum(ProjForecastRevenue):
                        ProjForecastRevenue projForecastRevenue = projTrans.buffer();
                        if (projForecastRevenue.ProjForecastBudgetType != ProjForecastBudgetType::None)
                        {
                            useFundingLimits = false;
                        }
                        break;
                    case tableNum(ProjForecastCost):
                        ProjForecastCost projForecastCost = projTrans.buffer();
                        if (projForecastCost.ProjForecastBudgetType != ProjForecastBudgetType::None)
                        {
                            useFundingLimits = false;
                        }
                        break;
                    case tableNum(ProjForecastEmpl):
                        ProjForecastEmpl projForecastEmpl = projTrans.buffer();
                        if (projForecastEmpl.ProjForecastBudgetType != ProjForecastBudgetType::None)
                        {
                            useFundingLimits = false;
                        }
                        break;
                }
            }

            // No funding source specified use rules
            projFundingEngine = ProjFundingEngine::construct(projTrans,
                                                             abs(projTrans.transCost() + projTrans.indirectCostAmount()),
                                                             abs(projTrans.transTurnover() + projTrans.indirectSalesAmount()),
                                                             false,
                                                             useFundingLimits)  ;
            if (projFundingEngine.allocate())
            {
                costDistributions = projFundingEngine.parmCostDistributions();
                saleDistributions = projFundingEngine.parmSaleDistributions();
                fundingSourceList = projFundingEngine.parmfundingSourceAllocation();

                if (negativeCostAllocation)
                {
                    costDistributions = this.negateDistributions(costDistributions);
                }

                if (negativeSaleAllocation)
                {
                    saleDistributions = this.negateDistributions(saleDistributions);
                }
            }
            else
            {
                throw Global::error("@SYS136009");
            }
        }
        else
        {
            if (ProjFundingEngine::isAmountWithinFundingLimits(projTrans, projTrans.fundingSource(), projTrans.transTurnover() + projTrans.indirectSalesAmount()))
            {
                projLineProperty = ProjLineProperty::find(projTrans.linePropertyId());
                if (projLineProperty)
                {
                    // Print Zeron Sales Price on Invoice
                    if (projLineProperty.OnInvoice)
                    {
                        createZeroSalesDistributions = true;
                    }
                }

                if (projTrans.transCost() != 0.00)
                {
                    costDistributions.insert(projTrans.fundingSource(), projTrans.transCost() + projTrans.indirectCostAmount());
                }
                if ((projTrans.transTurnover() != 0.00) || (createZeroSalesDistributions == true))
                {
                    saleDistributions.insert(projTrans.fundingSource(), projTrans.transTurnover() + projTrans.indirectSalesAmount());
                }

                fundingSourceList.addEnd( ProjSplitAllocation::construct( projTrans.fundingSource(),100, 0, NoYes::Yes) );
            }
            else
            {
                throw Global::error("@SYS136009");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>negateDistributions</Name>
				<Source><![CDATA[
    private Map negateDistributions(Map _distribution)
    {
        Map mapNegative = new Map(Types::Int64, Types::Real);
        MapEnumerator distributionEnumerator = _distribution.getEnumerator();

        while (distributionEnumerator.moveNext())
        {
            mapNegative.insert(distributionEnumerator.currentKey(), distributionEnumerator.currentValue() * -1);
        }

        return mapNegative;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createForecastPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a record for forecast posting.
    /// </summary>
    /// <param name = "_fundingSourceId">
    /// The project funding source id.
    /// </param>
    public void createForecastPosting(ProjFundingSourceRefId _fundingSourceId)
    {
        ProjTransBudget projTransBudget = this.initProjTransBudget(_fundingSourceId);
        projTransBudget.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProjTransBudget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializing the values to <c>ProjTransBudget</c> table.
    /// </summary>
    /// <param name = "_fundingSourceId">
    /// The project funding source id.
    /// </param>
    /// <returns>
    /// Returns the <c>ProjTransBudget</c> buffer.
    /// </returns>
    protected ProjTransBudget initProjTransBudget(ProjFundingSourceRefId _fundingSourceId)
    {
        ProjTransBudget projTransBudget;
        DimensionDefault    defaultDimension;
        Map                 attributeValues;
        MapEnumerator       mi;

        projTransBudget = this.initTrans();
        ProjFundingSource projFundingSource = ProjFundingSource::find(_fundingSourceId);
        projTransBudget.ProjFundingSource = _fundingSourceId;

        defaultDimension = this.ledgerDimension();

        if (projTransBudget.LedgerDimension)
        {
            MainAccountLegalEntity mainAccountLegalEntity = MainAccountLegalEntity::findByMainAccountLegalEntity(MainAccount::findByLedgerDimension(projTransBudget.LedgerDimension).RecId, CompanyInfo::current());
            if (mainAccountLegalEntity)
            {
                attributeValues = LedgerDimensionFacade::getFixedDimensionsForMainAccount(mainAccountLegalEntity.MainAccount, mainAccountLegalEntity.LegalEntity);
                if (attributeValues.elements())
                {
                    mi = attributeValues.getEnumerator();
                    while (mi.moveNext())
                    {
                        defaultDimension = LedgerDimensionDefaultFacade::serviceReplaceAttributeValue(defaultDimension, mainAccountLegalEntity.DefaultDimension, mi.currentKey());

                        defaultDimension = LedgerDimensionFacade::serviceApplyDerivedDimensionsForAttribute(defaultDimension, mi.currentKey(), Ledger::current());
                    }
                }
            }
        }

        projTransBudget.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(defaultDimension, projFundingSource.DefaultDimension);

        if (projTransBudget.AmountMst < 0)
        {
            if (projTransBudget.Qty > 0)
            {
                projTransBudget.Qty    = -projTransBudget.Qty;
            }
        }
        else if (projTransBudget.AmountMst > 0)
        {
            if (projTransBudget.Qty < 0)
            {
                projTransBudget.Qty    = -projTransBudget.Qty;
            }
        }

        // Set to default
        projTransBudget.PaymentDate    = dateNull();
        projTransBudget.PaymentStatus  = ProjPaymentStatus::NoPayment;

        // Set the payment date and status over here
        if (projTransBudget.Elimination == NoYes::Yes)
        {
            // Set to default
            projTransBudget.PaymentDate    = dateNull();
            projTransBudget.PaymentStatus  = ProjPaymentStatus::NoPayment;
        }
        else
        {
            projTransBudget.PaymentDate = this.getPaymentDate(this.postingType());
            projTransBudget.PaymentStatus = this.getPaymentStatus(this.postingType());
        }

        return projTransBudget;
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditAccountCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ledger account for posting the credit side of transactions for costs.
    /// </summary>
    /// <param name="_fundingSourceId">
    ///    The funding source that is associated with the project contract that is used by this transaction.
    /// </param>
    /// <returns>
    ///    The ledger account for posting credit amounts for costs.
    /// </returns>
    /// <remarks>
    ///    This method must be overridden by the class that extends this class to provide the necessary
    ///    functionality for the transaction that is being posted; otherwise, it will throw an exception.
    /// </remarks>
    LedgerDimensionDefaultAccount creditAccountCost(ProjFundingSourceRefId _fundingSourceId)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditAccountOnAcc</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the account for posting the credit side of transactions for on-account accounts.
    /// </summary>
    /// <param name="_fundingSourceId">
    ///    The funding source that is associated with the project contract that is used by this transaction.
    /// </param>
    /// <returns>
    ///    The ledger account for posting credit amounts.
    /// </returns>
    /// <remarks>
    ///    This method must be overridden by the class that extends this class to provide the necessary
    ///    functionality for the transaction that is being posted; otherwise, it will throw an exception.
    /// </remarks>
    LedgerDimensionDefaultAccount creditAccountOnAcc(ProjFundingSourceRefId _fundingSourceId)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditAccountSalesAccrued</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ledger account that is used for posting accrued sales amounts.
    /// </summary>
    /// <param name="_fundingSourceID">
    ///    The funding source that is associated with the project contract that is used by this transaction.
    /// </param>
    /// <returns>
    ///    The ledger account for posting accrued sales amounts.
    /// </returns>
    /// <remarks>
    ///    This method must be overridden by the class that extends this class to provide the necessary
    ///    functionality for the transaction that is being posted; otherwise, it will throw an exception.
    /// </remarks>
    LedgerDimensionDefaultAccount creditAccountSalesAccrued( ProjFundingSourceRefId _fundingSourceID )
    {
        return projTrans.salesOffsetAccountLedgerDimension(_fundingSourceID );
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditAccountTurnover</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ledger account that is used for posting revenue amounts.
    /// </summary>
    /// <param name="_fundingSourceID">
    ///    The funding source that is associated with the project contract that is used by this transaction.
    /// </param>
    /// <returns>
    ///    The ledger account that is used for posting revenue amounts.
    /// </returns>
    /// <remarks>
    ///    This method must be overridden by the class that extends this class to provide the necessary
    ///    functionality for the transaction that is being posted; otherwise, it will throw an exception.
    /// </remarks>
    protected LedgerDimensionDefaultAccount creditAccountTurnover(ProjFundingSourceRefId _fundingSourceID)
    {
        return projTrans.revenueAccountLedgerDimension(_fundingSourceID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>debitAccountCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger account that is used for the debit side of a posting transaction for costs.
    /// </summary>
    /// <param name="_fundingSourceId">
    /// The funding source that is associated with the project contract to be used by this transaction.
    /// </param>
    /// <param name="_categoryID">
    /// The project category id value.
    /// </param>
    /// <returns>
    /// The ledger account that is used for posting debit amounts of cost transactions.
    /// </returns>
    /// <remarks>
    /// This method must be overridden by the class that extends this class to provide the necessary
    /// functionality for the transaction that is being posted; otherwise, it will throw an exception.
    /// </remarks>
    LedgerDimensionDefaultAccount debitAccountCost(ProjFundingSourceRefId _fundingSourceId, ProjCategoryId _categoryID = '' )
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>debitAccountOnAcc</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ledger account that is used for the debit side of posting an on-account transaction.
    /// </summary>
    /// <param name="_fundingSourceId">
    ///    The funding source that is associated with the project contract that is by this transaction.
    /// </param>
    /// <returns>
    ///    The posting account for debit amounts of on-account transactions.
    /// </returns>
    /// <remarks>
    ///    This method must be overridden by the class that extends this class to provide the necessary
    ///    functionality for the transaction that is being posted; otherwise, it will throw an exception.
    /// </remarks>
    LedgerDimensionDefaultAccount debitAccountOnAcc(ProjFundingSourceRefId _fundingSourceId)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>debitAccountSalesAccrued</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ledger account that is used for the debit side of a posting transaction for
    ///    sales-accrued revenue.
    /// </summary>
    /// <param name="_fundingSourceID">
    ///    The funding source that is associated with the project contract that is used by this transaction.
    /// </param>
    /// <returns>
    ///    The posting account for the debit amount of sales-accrued revenue transactions.
    /// </returns>
    /// <remarks>
    ///    This method must be overridden by the class that extends this class to provide the necessary
    ///    functionality for the transaction that is being posted; otherwise, it will throw an exception.
    /// </remarks>
    LedgerDimensionDefaultAccount debitAccountSalesAccrued(ProjFundingSourceRefId _fundingSourceID)
    {
        return projTrans.salesValueAccountLedgerDimension(_fundingSourceID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTransBudget</Name>
				<Source><![CDATA[
    void deleteTransBudget()
    {
        ProjTransBudget projTransBudget;

        delete_from projTransBudget
        where projTransBudget.TransId   == projTrans.transId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>forecastUpdateType</Name>
				<Source><![CDATA[
    ProjForecastUpdateType  forecastUpdateType(ProjForecastUpdateType   _forecastUpdateType = forecastUpdateType)
    {
        forecastUpdateType  = _forecastUpdateType;

        return forecastUpdateType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieve the payment date for the posting type.
    /// </summary>
    /// <param name = "_postingType">The ledger posting type.</param>
    /// <returns>Returns the payment date for the posting type.</returns>
    public TransDate getPaymentDate(LedgerPostingType _postingType)
    {
        return dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieve the payment status for the posting type.
    /// </summary>
    /// <param name = "_postingType">The ledger posting type.</param>
    /// <returns>Returns the payment status for the posting type.</returns>
    public ProjPaymentStatus getPaymentStatus(LedgerPostingType _postingType)
    {
        return ProjPaymentStatus::NoPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTrans</Name>
				<Source><![CDATA[
    public ProjTransBudget initTrans()
    {
        ProjTransBudget projTransBudget;

        projTransBudget.TransId         = projTrans.transId();
        projTransBudget.ProjId          = projTrans.projId();
        projTransBudget.ProjType        = projTrans.projTable().Type;
        projTransBudget.CategoryId      = projTrans.categoryId();
        projTransBudget.EmplItemId      = this.setEmplItemId();
        projTransBudget.Resource        = this.setResource();
        projTransBudget.ResourceCategory = this.setResourceCategory();
        projTransBudget.SubscriptionId  = this.setSubscriptionId();
        projTransBudget.ProjTransDate   = projTrans.transDate();
        projTransBudget.ProjTransType   = projTrans.transType();

        projTransBudget.Qty             = this.qty();

        if (this.forecastUpdateType() == ProjForecastUpdateType::Elimination)
        {
            projTransBudget.Elimination = NoYes::Yes;
        }

        projTransBudget.Voucher         = "";  // should only be set in auto create mode

        projTransBudget.PostingType     = this.postingType();

        projTransBudget.LedgerDimension = this.accountNum();

        projTransBudget.AmountMst       = this.amountMST();
        projTransBudget.LedgerTransDate = this.ledgerTransDate();
        projTransBudget.CostSales       = this.costSales();
        projTransBudget.ModelId         = projTrans.forecastModelId();
        projTransBudget.ActivityNumber  = projTrans.activityNumber();

        return projTransBudget;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDimension</Name>
				<Source><![CDATA[
    DimensionDefault ledgerDimension()
    {
        return projTrans.defaultDimension();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerStatusCost</Name>
				<Source><![CDATA[
    ProjLedgerStatus    ledgerStatusCost()
    {
        return ProjLedgerStatus::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerTransDate</Name>
				<Source><![CDATA[
    protected TransDate ledgerTransDate(TransDate _ledgerTransDate  = ledgerTransDate)
    {
        ledgerTransDate   = _ledgerTransDate;

        return ledgerTransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modelId</Name>
				<Source><![CDATA[
    ForecastModelId modelId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new(Common _buffer)
    {
        projTable = projTrans.projTable();
        projParameters = ProjParameters::find();

        if (!isMultipleContractLineFeatureEnabled)
        {
            projGroup = projTable.projGroup();
        }
        else
        {
            this.initializeRevenueProfileForMultipleContractLines();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeRevenueProfileForMultipleContractLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes project revenue profile when multiple contract lines feature is enabled.
    /// </summary>
    protected internal void initializeRevenueProfileForMultipleContractLines()
    {
        if (projTable.ProjInvoiceProjId && projTrans.transType() != ProjTransType::OnAccount)
        {
            if (isProjectOperationsIntegrationEnabled && this.parmContractLineItems())
            {
                projRevProfile = ProjRevRecHelper::getRevProfileV2(projTable, this.parmContractLineItems());
            }
            else
            {
                projRevProfile = ProjRevRecHelper::getRevProfileForTransactionType(projTable, projTrans.transType());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isIncludedInProjectContractForMultipleContractLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if project and transaction type are included in the project contract when multiple contract lines feature is enabled.
    /// </summary>
    /// <param name = "_projTable">The project to check.</param>
    /// <param name = "_projTransType">The transaction type to check.</param>
    /// <returns>True if project and transaction type are included in the project contract; otherwise false.</returns>
    protected internal boolean isIncludedInProjectContractForMultipleContractLines(ProjTable _projTable, ProjTransType _projTransType)
    {
        return this.parmContractLineItems() || (_projTable.ProjInvoiceProjId && ProjMultipleContractLinesForProjectFeatureHelper::getProjContractLineByContractIdTransType(_projTable.ProjId, _projTable.ProjInvoiceProjId, _projTransType));
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCost</Name>
				<Source><![CDATA[
    protected void postCost()
    {
        MapEnumerator   fundingAllocationEnumerator;
        Map             splitTransQty;

        if (this.checkDebitCost())
        {
            this.postingType(this.costPostingType());
            this.ledgerTransDate(projTrans.transDate());
            this.costSales(ProjCostSales::Cost);

            fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions(fundingSourceList, projTrans.transCost(), projTrans.currencyIdCost()).getEnumerator();
            splitTransQty = ProjFundingEngine::distributeQty(fundingSourceList, projTrans.qty());
            while (fundingAllocationEnumerator.moveNext())
            {
                this.qty(splitTransQty.exists(fundingAllocationEnumerator.currentKey()) ? splitTransQty.lookup(fundingAllocationEnumerator.currentKey()) * 1 : 0.0);
                this.accountNum(this.debitAccountCost(fundingAllocationEnumerator.currentKey(), projTrans.categoryId()));
                this.amountMST(fundingAllocationEnumerator.currentValue());
                this.createForecastPosting(fundingAllocationEnumerator.currentKey());
            }
            if (projTrans.indirectCostAmount())
            {
                fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions(fundingSourceList, projTrans.indirectCostAmount(), projTrans.currencyIdCost()).getEnumerator();
                while (fundingAllocationEnumerator.moveNext())
                {
                    this.qty(splitTransQty.exists(fundingAllocationEnumerator.currentKey()) ? splitTransQty.lookup(fundingAllocationEnumerator.currentKey()) * 1 : 0.0);
                    this.postIndirectCostAmounts(fundingAllocationEnumerator.currentKey());
                }
            }
        }

        if (this.checkCreditCost())
        {
            this.postingType(this.costPostingTypeOffset());
            this.costSales(ProjCostSales::Cost);
            this.ledgerTransDate(projTrans.transDate());

            fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions( fundingSourceList,-projTrans.transCost(),projTrans.currencyIdCost()).getEnumerator();
            splitTransQty = ProjFundingEngine::distributeQty(fundingSourceList, -projTrans.qty());

            while (fundingAllocationEnumerator.moveNext())
            {
                this.qty(splitTransQty.exists(fundingAllocationEnumerator.currentKey()) ? splitTransQty.lookup(fundingAllocationEnumerator.currentKey()) * 1 : 0.0);
                this.accountNum(this.creditAccountCost(fundingAllocationEnumerator.currentKey()));
                this.amountMST(fundingAllocationEnumerator.currentValue());
                this.createForecastPosting(fundingAllocationEnumerator.currentKey());
            }
            if (projTrans.indirectCostAmount())
            {
                fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions( fundingSourceList,-projTrans.indirectCostAmount(),projTrans.currencyIdCost()).getEnumerator();
                while (fundingAllocationEnumerator.moveNext())
                {
                    this.qty(splitTransQty.exists(fundingAllocationEnumerator.currentKey()) ? splitTransQty.lookup(fundingAllocationEnumerator.currentKey()) * 1 : 0.0);
                    this.postIndirectCostAmounts(fundingAllocationEnumerator.currentKey());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postIndirectCostAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method calculates the indirect cost amount based on the indirect cost components.
    /// </summary>
    /// <param name="_fundingSourceId">
    /// The funding source that is associated with the project contract to be used by this transaction.
    /// </param>
    protected void postIndirectCostAmounts(ProjFundingSourceRefId _fundingSourceId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingType</Name>
				<Source><![CDATA[
    protected LedgerPostingType postingType(LedgerPostingType _postingType = postingType)
    {
        postingType   = _postingType;

        return postingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeOffsetOnAcc</Name>
				<Source><![CDATA[
    LedgerPostingType postingTypeOffsetOnAcc()
    {
        return LedgerPostingType::ProjWIPInvoicedOnAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeOffsetTurnoverAccrued</Name>
				<Source><![CDATA[
    LedgerPostingType postingTypeOffsetTurnoverAccrued()
    {
        return LedgerPostingType::ProjSalesvalueOffset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeOnAcc</Name>
				<Source><![CDATA[
    LedgerPostingType postingTypeOnAcc()
    {
        return LedgerPostingType::ProjAccruedRevenueOnAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeTurnover</Name>
				<Source><![CDATA[
    protected LedgerPostingType postingTypeTurnover()
    {
        return LedgerPostingType::ProjTurnover;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeTurnoverAccrued</Name>
				<Source><![CDATA[
    LedgerPostingType postingTypeTurnoverAccrued()
    {
        return LedgerPostingType::ProjSalesvalue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postNeverLedger</Name>
				<Source><![CDATA[
    void postNeverLedger()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postNoneLedger</Name>
				<Source><![CDATA[
    void postNoneLedger()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postOnAccAccrued</Name>
				<Source><![CDATA[
    protected void postOnAccAccrued()
    {
        MapEnumerator fundingAllocationEnumerator;

        if (this.checkDebitOnAcc())
        {
            this.postingType(this.postingTypeOnAcc());
            this.costSales(ProjCostSales::Sales);
            if (ForecastModel::find(HeadingSub::Heading,this.modelId()).UseProjectDate)
            {
                this.ledgerTransDate(projTrans.transDate());
            }
            else
            {
                this.ledgerTransDate(projTrans.forecastInvoiceDate());
            }
            fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions( fundingSourceList,projTrans.transTurnoverMST(),projTrans.currencyIdSales()).getEnumerator();

            while (fundingAllocationEnumerator.moveNext())
            {
                if (ProjFundingSource::isExternalFunding(fundingAllocationEnumerator.currentKey()))
                {
                    this.accountNum(this.debitAccountOnAcc(fundingAllocationEnumerator.currentKey()));
                    this.amountMST(fundingAllocationEnumerator.currentValue());
                    this.createForecastPosting(fundingAllocationEnumerator.currentKey());
                }
            }
        }

        if (this.checkCreditOnAcc())
        {
            this.postingType(this.postingTypeOffsetOnAcc());
            this.costSales(ProjCostSales::Sales);
            if (ForecastModel::find(HeadingSub::Heading,this.modelId()).UseProjectDate)
            {
                this.ledgerTransDate(projTrans.transDate());
            }
            else
            {
                this.ledgerTransDate(projTrans.forecastInvoiceDate());
            }
            fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions( fundingSourceList, -projTrans.transTurnoverMST(),projTrans.currencyIdSales()).getEnumerator();

            while (fundingAllocationEnumerator.moveNext())
            {
                if (ProjFundingSource::isExternalFunding(fundingAllocationEnumerator.currentKey()))
                {
                    this.accountNum(this.creditAccountOnAcc(fundingAllocationEnumerator.currentKey()));
                    this.amountMST(fundingAllocationEnumerator.currentValue());
                    this.createForecastPosting(fundingAllocationEnumerator.currentKey());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postOnhandFinancial</Name>
				<Source><![CDATA[
    boolean postOnhandFinancial()
    {
        return InventTable::find(projTrans.itemId()).modelGroup().PostOnhandFinancial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTurnover</Name>
				<Source><![CDATA[
    protected void postTurnover()
    {
        MapEnumerator           fundingAllocationEnumerator;
        Map                     splitTransQty;

        if (ForecastModel::find(HeadingSub::Heading,this.modelId()).UseProjectDate)
        {
            this.ledgerTransDate(projTrans.transDate());
        }
        else
        {
            this.ledgerTransDate(projTrans.forecastInvoiceDate());
        }
        this.postingType(this.postingTypeTurnover());
        this.costSales(ProjCostSales::Sales);

        fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions( fundingSourceList,-projTrans.transTurnoverMST(),projTrans.currencyIdSales()).getEnumerator();
        splitTransQty = ProjFundingEngine::distributeQty(fundingSourceList, projTrans.qty());
        while (fundingAllocationEnumerator.moveNext())
        {
            if (ProjFundingSource::isExternalFunding(fundingAllocationEnumerator.currentKey()))
            {
                this.qty(splitTransQty.exists(fundingAllocationEnumerator.currentKey()) ? splitTransQty.lookup(fundingAllocationEnumerator.currentKey()) * 1 : 0.0);
                this.accountNum(this.creditAccountTurnover(fundingAllocationEnumerator.currentKey()));
                this.amountMST(fundingAllocationEnumerator.currentValue());
                this.createForecastPosting(fundingAllocationEnumerator.currentKey());
            }
        }

        if (projTrans.indirectSalesAmount())
        {
            fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions( fundingSourceList,-projTrans.indirectSalesAmountMST(),projTrans.currencyIdSales()).getEnumerator();
            while (fundingAllocationEnumerator.moveNext())
            {
                if (ProjFundingSource::isExternalFunding(fundingAllocationEnumerator.currentKey()))
                {
                    this.qty(0.0);
                    this.accountNum(this.creditAccountTurnover(fundingAllocationEnumerator.currentKey()));
                    this.amountMST(fundingAllocationEnumerator.currentValue());
                    this.createForecastPosting(fundingAllocationEnumerator.currentKey());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTurnoverAccrued</Name>
				<Source><![CDATA[
    protected void postTurnoverAccrued()
    {
        MapEnumerator           fundingAllocationEnumerator;
        AmountCur               amountCur;
        Map                     splitTransQty;

        if (this.checkDebitAccrued())
        {
            this.postingType(this.postingTypeTurnoverAccrued());

            if (this.forecastUpdateType() == ProjForecastUpdateType::Journals)
            {
                this.ledgerTransDate(projTrans.transDate());
                amountCur = -projTrans.transTurnoverMST();
            }
            else
            {
                amountCur = projTrans.transTurnoverMST();
                if (ForecastModel::find(HeadingSub::Heading,this.modelId()).UseProjectDate)
                {
                    this.ledgerTransDate(projTrans.transDate());
                }
                else
                {
                    this.ledgerTransDate(projTrans.forecastInvoiceDate());
                }
            }
            this.costSales(ProjCostSales::Sales);

            fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions(fundingSourceList, amountCur, projTrans.currencyIdSales()).getEnumerator();
            splitTransQty = ProjFundingEngine::distributeQty(fundingSourceList, -projTrans.qty());

            while (fundingAllocationEnumerator.moveNext())
            {
                if (ProjFundingSource::isExternalFunding(fundingAllocationEnumerator.currentKey()))
                {
                    this.qty((splitTransQty.exists(fundingAllocationEnumerator.currentKey()) ? splitTransQty.lookup(fundingAllocationEnumerator.currentKey()) * 1 : 0.0));
                    this.accountNum(this.debitAccountSalesAccrued(fundingAllocationEnumerator.currentKey()));
                    this.amountMST(fundingAllocationEnumerator.currentValue());
                    this.createForecastPosting(fundingAllocationEnumerator.currentKey());
                }
            }

            if (this.forecastUpdateType() == ProjForecastUpdateType::Journals)
            {
                amountCur = -projTrans.indirectSalesAmount();
            }
            else
            {
                amountCur = projTrans.indirectSalesAmount();
            }
            fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions(fundingSourceList, amountCur, projTrans.currencyIdSales()).getEnumerator();
            while (fundingAllocationEnumerator.moveNext())
            {
                if (ProjFundingSource::isExternalFunding(fundingAllocationEnumerator.currentKey()))
                {
                    this.qty(0.0);
                    this.accountNum(this.debitAccountSalesAccrued(fundingAllocationEnumerator.currentKey()));
                    this.amountMST(fundingAllocationEnumerator.currentValue());
                    this.createForecastPosting(fundingAllocationEnumerator.currentKey());
                }
            }
        }

        if (this.checkCreditAccrued())
        {
            this.postingType(this.postingTypeOffsetTurnoverAccrued());

            if (this.forecastUpdateType() == ProjForecastUpdateType::Journals)
            {
                amountCur = projTrans.transTurnoverMST();
                this.ledgerTransDate(projTrans.transDate());
            }
            else
            {
                amountCur = -projTrans.transTurnoverMST();
                if (ForecastModel::find(HeadingSub::Heading,this.modelId()).UseProjectDate)
                {
                    this.ledgerTransDate(projTrans.transDate());
                }
                else
                {
                    this.ledgerTransDate(projTrans.forecastInvoiceDate());
                }
            }

            this.costSales(ProjCostSales::Sales);

            fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions(fundingSourceList, amountCur, projTrans.currencyIdSales()).getEnumerator();
            splitTransQty = ProjFundingEngine::distributeQty(fundingSourceList, projTrans.qty());
            while (fundingAllocationEnumerator.moveNext())
            {
                if (ProjFundingSource::isExternalFunding(fundingAllocationEnumerator.currentKey()))
                {
                    this.qty((splitTransQty.exists(fundingAllocationEnumerator.currentKey()) ? splitTransQty.lookup(fundingAllocationEnumerator.currentKey()) * 1 : 0.0));
                    this.accountNum(this.creditAccountSalesAccrued(fundingAllocationEnumerator.currentKey()));
                    this.amountMST(fundingAllocationEnumerator.currentValue());
                    this.createForecastPosting(fundingAllocationEnumerator.currentKey());
                }
            }

            if (this.forecastUpdateType() == ProjForecastUpdateType::Journals)
            {
                amountCur = projTrans.indirectSalesAmount();
            }
            else
            {
                amountCur = -projTrans.indirectSalesAmount();
            }
            fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions(fundingSourceList, amountCur, projTrans.currencyIdSales()).getEnumerator();
            while (fundingAllocationEnumerator.moveNext())
            {
                if (ProjFundingSource::isExternalFunding(fundingAllocationEnumerator.currentKey()))
                {
                    this.qty(0.0);
                    this.accountNum(this.creditAccountSalesAccrued(fundingAllocationEnumerator.currentKey()));
                    this.amountMST(fundingAllocationEnumerator.currentValue());
                    this.createForecastPosting(fundingAllocationEnumerator.currentKey());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>qty</Name>
				<Source><![CDATA[
    ProjQty qty(ProjQty  _qty    = qty)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        Counter i;

        //  this method must be run for
//  Journal Post
//  Invoice
//  Estimate Period
//  Elimination

        if (! projTrans)
        {
            throw error("@SYS3458");
        }

        if (this.canDeleteTransBudget())
        {
            this.deleteTransBudget();
        }

        // Only create distribution when cost or sale amount exist; But for hour transactions it is exceptional.
        if (this.canCreateTransBudget() &&
            (projTrans.transType() == ProjTransType::Hour ||
            ((projTrans.transCost() != 0) || (projTrans.transTurnover() != 0))))
        {
            this.createCostSalesDistributions();

            for (i=1;i<=4;i++)
            {
                this.forecastUpdateType(i-1);

                if (this.checkLedger())
                {
                    if (this.checkEnterCost())
                    {
                        this.postCost();
                    }

                    if (this.checkEnterSalesAccrued())
                    {
                        this.postTurnoverAccrued();
                    }

                    if (this.checkEnterTurnover())
                    {
                        this.postTurnover();
                    }

                    if (this.checkEnterNeverLedger())
                    {
                        this.postNeverLedger();
                    }

                    if (this.checkEnterNoneLedger())
                    {
                        this.postNoneLedger();
                    }

                    if (this.checkEnterAccruedOnAcc())
                    {
                        this.postOnAccAccrued();
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runCheck</Name>
				<Source><![CDATA[
    public boolean runCheck()
    {
        boolean ret = true;
        Counter i;

        //  this method must be run for
//  Journal Post
//  Invoice
//  Estimate Period
//  Elimination

        if (! projTrans)
        {
            ret = checkFailed("@SYS3458");
        }

        for (i=1;ret && i<=4;i++)
        {
            this.forecastUpdateType(i-1);

            if (this.checkLedger())
            {
                if (this.checkEnterCost())
                {
                    ret = this.checkCost();
                }

                if (this.checkEnterSalesAccrued())
                {
                    ret = this.checkTurnoverAccrued();
                }

                if (this.checkEnterTurnover())
                {
                    ret = this.checkTurnover();
                }

                if (this.checkEnterNeverLedger())
                {
                    ret = this.checkNeverLedger();
                }

                if (this.checkEnterNoneLedger())
                {
                    ret = this.checkNoneLedger();
                }

                if (this.checkEnterAccruedOnAcc())
                {
                    ret = this.checkOnAccAccrued();
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setEmplItemId</Name>
				<Source><![CDATA[
    ProjEmplItemId setEmplItemId()
    {
        return projTrans.itemId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setResource</Name>
				<Source><![CDATA[
    ResourceRecId setResource()
    {
        return projTrans.resource();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setResourceCategory</Name>
				<Source><![CDATA[
    ResourceCategoryRecId setResourceCategory()
    {
        return projTrans.resourceCategory();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSubscriptionId</Name>
				<Source><![CDATA[
    SMASubscriptionId setSubscriptionId()
    {
        return projTrans.subscriptionId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPostForecastCost</Name>
				<Source><![CDATA[
    public static ProjForecastPost newPostForecastCost(
    ProjForecastCost           projForecastCost)
    {
        ProjForecastPost        projForecastPost;
        ProjTable projTableLocal = projForecastCost.projTable();

        switch (projTableLocal.Type)
        {
            case ProjType::TimeMaterial:
                projForecastPost = new ProjForecastPostCostTM(projForecastCost);
                break;

            case ProjType::FixedPrice:
            case ProjType::Investment:
                projForecastPost = new ProjForecastPostCostFixedInvest(projForecastCost);
                break;

            case ProjType::Cost:
            case ProjType::Internal:
                projForecastPost = new ProjForecastPostCostCostInternal(projForecastCost);
                break;

            case ProjType::Time:
                projForecastPost = new ProjForecastPostCostTime(projForecastCost);
                break;
                
            case ProjType::None:
                projForecastPost = ProjForecastPost::newPostForecastCostForNoneProjType(projTableLocal, projForecastCost);
                break;
        }

        return projForecastPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPostForecastCostForNoneProjType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>ProjForecastPost</c> instance based on the given project and project forecast.
    /// </summary>
    /// <param name = "_projTable">The <c>ProjTable</c> record.</param>
    /// <param name = "_projForecastCost">The <c>ProjForecastCost</c> record.</param>
    /// <returns>
    /// The <c>ProjForecastPost</c> instance.
    /// </returns>
    protected static ProjForecastPost newPostForecastCostForNoneProjType(ProjTable _projTable, ProjForecastCost _projForecastCost)
    {
        ProjForecastPost projForecastPost;
        if (ProjMultipleContractLinesForProjectFeatureHelper::isTimeMaterialBillingMethodForContractLine(_projTable, _projForecastCost.ContractLineId, ProjTransType::Cost))
        {
            projForecastPost = new ProjForecastPostCostTM(_projForecastCost);
        }
        else if (ProjMultipleContractLinesForProjectFeatureHelper::isFixedPriceBillingMethodForContractLine(_projTable, _projForecastCost.ContractLineId, ProjTransType::Cost))
        {
            projForecastPost = new ProjForecastPostCostFixedInvest(_projForecastCost);
        }
        else
        {
            projForecastPost = new ProjForecastPostCostCostInternal(_projForecastCost);
        }

        return projForecastPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransTypeIncludedByBillingMethod</Name>
				<Source><![CDATA[
    public boolean isTransTypeIncludedByBillingMethod(ProjTable _projTable, ProjTransType _projTransType, ProjContractBillingMethod _billingMethod)
    {
        boolean ret = false;
        // Fall back on contract line setup if contract line is not present on the forecast.
        if (this.parmContractLineItems())
        {
            ret = this.parmContractLineItems().BillingMethod == _billingMethod;
        }
		else
        {
            ret = ProjMultipleContractLinesForProjectFeatureHelper::isTransTypeIncludedByBillingMethod(_projTable.ProjId, _projTable.ProjInvoiceProjId, _projTransType, _billingMethod);
		}
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPostForecastEmpl</Name>
				<Source><![CDATA[
    public static ProjForecastPost newPostForecastEmpl(
    ProjForecastEmpl           projForecastEmpl)
    {
        ProjForecastPost projForecastPost;
        ProjTable projTableLocal = projForecastEmpl.projTable();

        switch (projTableLocal.Type)
        {
            case ProjType::TimeMaterial:
                projForecastPost = new ProjForecastPostEmplTM(projForecastEmpl);
                break;

            case ProjType::FixedPrice:
            case ProjType::Investment:
                projForecastPost = new ProjForecastPostEmplFixedInvest(projForecastEmpl);
                break;

            case ProjType::Cost:
            case ProjType::Internal:
                projForecastPost = new ProjForecastPostEmplCostInternal(projForecastEmpl);
                break;

            case ProjType::Time:
                projForecastPost = new ProjForecastPostEmplTime(projForecastEmpl);
                break;

            case ProjType::None:
                projForecastPost = ProjForecastPost::newPostForecastEmplForNoneProjType(projTableLocal, projForecastEmpl);

                break;
        }

        return projForecastPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPostForecastEmplForNoneProjType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>ProjForecastPost</c> instance based on the given project and project forecast.
    /// </summary>
    /// <param name = "_projTable">The <c>ProjTable</c> record.</param>
    /// <param name = "_projForecastEmpl">The <c>ProjForecastEmpl</c> record.</param>
    /// <returns>
    /// The <c>ProjForecastPost</c> instance.
    /// </returns>
    protected static ProjForecastPost newPostForecastEmplForNoneProjType(ProjTable _projTable, ProjForecastEmpl _projForecastEmpl)
    {
        ProjForecastPost projForecastPost;
        if (ProjMultipleContractLinesForProjectFeatureHelper::isTimeMaterialBillingMethodForContractLine(_projTable, _projForecastEmpl.ContractLineId, ProjTransType::Hour))
        {
            projForecastPost = new ProjForecastPostEmplTM(_projForecastEmpl);
        }
        else if (ProjMultipleContractLinesForProjectFeatureHelper::isFixedPriceBillingMethodForContractLine(_projTable, _projForecastEmpl.ContractLineId, ProjTransType::Hour))
        {
            projForecastPost = new ProjForecastPostEmplFixedInvest(_projForecastEmpl);
        }
        else
        {
            projForecastPost = new ProjForecastPostEmplCostInternal(_projForecastEmpl);
        }

        return projForecastPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPostForecastItem</Name>
				<Source><![CDATA[
    public static ProjForecastPost newPostForecastItem(
    ForecastSales           forecastSales)
    {
        ProjForecastPost projForecastPost;
        ProjTable projTableLocal = forecastSales.projTable();

        switch (projTableLocal.Type)
        {
            case ProjType::TimeMaterial:
                projForecastPost = new ProjForecastPostItemTM(forecastSales);
                break;

            case ProjType::FixedPrice:
            case ProjType::Investment:
                projForecastPost = new ProjForecastPostItemFixedInvest(forecastSales);
                break;

            case ProjType::Cost:
            case ProjType::Internal:
                projForecastPost = new ProjForecastPostItemCostInternal(forecastSales);
                break;

            case ProjType::Time:
                projForecastPost = new ProjForecastPostItemTime(forecastSales);
                break;

            case ProjType::None:
                projForecastPost = ProjForecastPost::newPostForecastItemForNoneProjType(projTableLocal, forecastSales);
                break;
        }

        return projForecastPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPostForecastItemForNoneProjType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>ProjForecastPost</c> instance based on the given project and project forecast.
    /// </summary>
    /// <param name = "_projTable">The <c>ProjTable</c> record.</param>
    /// <param name = "_forecastSales">The <c>ForecastSales</c> record.</param>
    /// <returns>
    /// The <c>ProjForecastPost</c> instance.
    /// </returns>
    protected static ProjForecastPost newPostForecastItemForNoneProjType(ProjTable _projTable, ForecastSales _forecastSales)
    {
        ProjForecastPost projForecastPost;

        if (ProjMultipleContractLinesForProjectFeatureHelper::isTimeMaterialBillingMethodForContractLine(_projTable, _forecastSales.ContractLineId, ProjTransType::Item))
        {
            projForecastPost = new ProjForecastPostItemTM(_forecastSales);
        }
        else if (ProjMultipleContractLinesForProjectFeatureHelper::isFixedPriceBillingMethodForContractLine(_projTable, _forecastSales.ContractLineId, ProjTransType::Item))
        {
            projForecastPost = new ProjForecastPostItemFixedInvest(_forecastSales);
        }
        else
        {
            projForecastPost = new ProjForecastPostItemCostInternal(_forecastSales);
        }
		      
        return projForecastPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPostForecastOnAcc</Name>
				<Source><![CDATA[
    public static ProjForecastPost newPostForecastOnAcc(
    ProjForecastOnAcc           projForecastOnAcc)
    {
        ProjForecastPost        projForecastPost;

        switch (projForecastOnAcc.projTable().Type)
        {
            case ProjType::FixedPrice:
                projForecastPost    = new ProjForecastPostOnAccFixedInvest(projForecastOnAcc);
                break;

            default:
                projForecastPost    = new ProjForecastPostOnAcc(projForecastOnAcc);
        }

        return projForecastPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPostForecastRevenue</Name>
				<Source><![CDATA[
    public static ProjForecastPost newPostForecastRevenue(
    ProjForecastRevenue           projForecastRevenue)
    {
        ProjForecastPost projForecastPost;
        ProjTable projTableLocal = projForecastRevenue.projTable();

        switch (projTableLocal.Type)
        {
            case ProjType::TimeMaterial:
                projForecastPost = new ProjForecastPostRevenueTM(projForecastRevenue);
                break;

            case ProjType::FixedPrice:
                projForecastPost = new ProjForecastPostRevenueFixed(projForecastRevenue);
                break;

            case ProjType::None:
                projForecastPost = ProjForecastPost::newPostForecastRevenueForNoneProjType(projTableLocal, projForecastRevenue);
                break;

            default:
                throw error("@SYS50155");
        }

        return projForecastPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPostForecastRevenueForNoneProjType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>ProjForecastPost</c> instance based on the given project and project forecast.
    /// </summary>
    /// <param name = "_projTable">The <c>ProjTable</c> record.</param>
    /// <param name = "_projForecastRevenue">The <c>ProjForecastRevenue</c> record.</param>
    /// <returns>
    /// The <c>ProjForecastPost</c> instance.
    /// </returns>
    protected static ProjForecastPost newPostForecastRevenueForNoneProjType(ProjTable _projTable, ProjForecastRevenue _projForecastRevenue)
    {
        ProjForecastPost projForecastPost;

        if (ProjMultipleContractLinesForProjectFeatureHelper::isTransTypeIncludedByBillingMethod(_projTable.ProjId, _projTable.ProjInvoiceProjId, ProjTransType::Revenue, ProjContractBillingMethod::TimeMaterial))
        {
            projForecastPost = new ProjForecastPostRevenueTM(_projForecastRevenue);
        }
        else if (ProjMultipleContractLinesForProjectFeatureHelper::isTransTypeIncludedByBillingMethod(_projTable.ProjId, _projTable.ProjInvoiceProjId, ProjTransType::Revenue, ProjContractBillingMethod::FixedPrice))
        {
            projForecastPost = new ProjForecastPostRevenueFixed(_projForecastRevenue);
        }
        else
        {
            projForecastPost = new ProjForecastPostRevenue(_projForecastRevenue);
        }

        return projForecastPost;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>