<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TrvPolicyEvalEngine</Name>
	<SourceCode>
		<Declaration><![CDATA[
class TrvPolicyEvalEngine
{

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>anyPolicyErrors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether there are any policy errors in the expense or travel requisition document.
    /// </summary>
    /// <param name="header">
    /// The record ID of the transaction header.
    /// </param>
    /// <param name="policyType">
    /// The policy type.
    /// </param>
    /// <returns>
    /// true if there are policy errors; otherwise, false.
    /// </returns>
    static boolean anyPolicyErrors(RefRecId header, SysPolicyTypeEnum policyType)
    {
        TrvPolicyViolationsCache        cache;
        TrvPolicyViolationsLog          log;
        TrvPolicyViolationJustification justification;
        TrvPolicyRule                   policy;

        TrvPolicyViolationJustificationTypeEnum lineJustificationType;
        TrvPolicyViolationJustificationTypeEnum headerJustificationType;

        if (policyType == SysPolicyTypeEnum::TrvExpensePolicy)
        {
            lineJustificationType = TrvPolicyViolationJustificationTypeEnum::TrvExpLine;
            headerJustificationType = TrvPolicyViolationJustificationTypeEnum::TrvExpHeader;
        }
        else if (policyType == SysPolicyTypeEnum::TrvRequisitionPolicy)
        {
            lineJustificationType = TrvPolicyViolationJustificationTypeEnum::TrvReqLine;
            headerJustificationType = TrvPolicyViolationJustificationTypeEnum::TrvReqHeader;
        }

        TrvExpTable trvExpTable;

        //Based on below record, check for submitter justification will be performed as this check is specific for 'Submit' action.
        select firstonly RecId, ApprovalStatus from trvExpTable
            where trvExpTable.RecId == header;

        if (trvExpTable.RecId && (trvExpTable.ApprovalStatus == TrvAppStatus::None || trvExpTable.ApprovalStatus == TrvAppStatus::Create))
        {
            // check for submitter justification needed errors.
            select firstonly * from cache join policy
                order by policy.Action desc
                where cache.Rule == policy.RecId
                    && (policy.Action == TrvPolicyViolationLevel::SubmitJustification || policy.Action == TrvPolicyViolationLevel::SubmitApproveJustification)
                    && cache.PolicyType == policyType && cache.Header == header
                    notexists join Action, ViolatingRecord, ViolationJustificationType, JustifyingWorker from  justification
                    where justification.Action == TrvWorkflowAction::Submit
                        && ((justification.ViolatingRecord == cache.Line && justification.ViolationJustificationType == lineJustificationType)
                            || (justification.ViolatingRecord == cache.Header && justification.ViolationJustificationType == headerJustificationType && cache.Line == 0))
                        && justification.JustifyingWorker == cache.Worker;
        }

        if (cache.RecId != 0)
        {
            return true;
        }
        else
        {
            //check for error violations
            select firstonly * from cache join policy
                    order by policy.Action desc
                    where cache.Rule == policy.RecId && policy.Action == TrvPolicyViolationLevel::Error
                       && cache.PolicyType == policyType && cache.Header == header;

            if (cache.RecId != 0)
            {
                return true;
            }
        }

        // check log for approval time
        // check for approverjustificationneeded errors.
        select firstonly * from log join policy
                    order by policy.Action desc
                    where log.Rule == policy.RecId
                       && ((policy.Action == TrvPolicyViolationLevel::ApproveJustification) || (policy.Action == TrvPolicyViolationLevel::SubmitApproveJustification))
                       && log.PolicyType == policyType
                       && log.Header == header
                       && log.Action != TrvWorkflowAction::Return
                       notexists join Action, ViolatingRecord, ViolationJustificationType from  justification
                        where justification.Action == TrvWorkflowAction::Approve
                           && (    (justification.ViolatingRecord == log.Line && justification.ViolationJustificationType == lineJustificationType)
                                || (justification.ViolatingRecord == log.Header && justification.ViolationJustificationType == headerJustificationType && log.Line == 0))
                           && justification.JustifyingWorker == HcmWorkerLookup::currentWorker();

        if (log.RecId != 0)
        {
            return true;
        }
        //no need for check on error violations since if there are error violations the document would not reach the approver

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>anyPolicyErrorsForLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether there are any policy errors in the expense or requisition line.
    /// </summary>
    /// <param name="_lineRecId">
    /// The record ID of the transaction line.
    /// </param>
    /// <param name="_policyType">
    /// The policy type.
    /// </param>
    /// <returns>
    /// true if there are policy errors; otherwise, false.
    /// </returns>
    static boolean anyPolicyErrorsForLine(RefRecId _lineRecId, SysPolicyTypeEnum _policyType)
    {
        TrvPolicyViolationsCache        cache;
        TrvPolicyViolationsLog          log;
        TrvPolicyViolationJustification justification;
        TrvPolicyRule                   policy;

        TrvPolicyViolationJustificationTypeEnum lineJustificationType;

        if (_policyType == SysPolicyTypeEnum::TrvExpensePolicy)
        {
            lineJustificationType = TrvPolicyViolationJustificationTypeEnum::TrvExpLine;
        }
        else if (_policyType == SysPolicyTypeEnum::TrvRequisitionPolicy)
        {
            lineJustificationType = TrvPolicyViolationJustificationTypeEnum::TrvReqLine;
        }

        // check for submitter justification needed errors.
        select firstonly * from cache join policy
                    order by policy.Action desc
                    where cache.Rule == policy.RecId
                      && (policy.Action == TrvPolicyViolationLevel::SubmitJustification || policy.Action == TrvPolicyViolationLevel::SubmitApproveJustification)
                      && cache.PolicyType == _policyType && cache.Line == _lineRecId
                      notexists join Action, ViolatingRecord, ViolationJustificationType, JustifyingWorker from  justification
                        where justification.Action == TrvWorkflowAction::Submit
                           && justification.ViolatingRecord == cache.Line
                           && justification.ViolationJustificationType == lineJustificationType
                           && justification.JustifyingWorker == cache.Worker;

        if (cache.RecId != 0)
        {
            return true;
        }
        else
        {
            //check for error violations
            select firstonly * from cache join policy
                    order by policy.Action desc
                    where cache.Rule == policy.RecId && policy.Action == TrvPolicyViolationLevel::Error
                       && cache.PolicyType == _policyType && cache.Line == _lineRecId;

            if (cache.RecId != 0)
            {
                return true;
            }
        }

        // check log during approval
        // check for approverjustificationneeded errors.
        select firstonly * from log join policy
                    order by policy.Action desc
                    where log.Rule == policy.RecId
                       && (policy.Action == TrvPolicyViolationLevel::ApproveJustification || policy.Action == TrvPolicyViolationLevel::SubmitApproveJustification)
                       && log.PolicyType == _policyType
                       && log.Line == _lineRecId
                       && log.Action != TrvWorkflowAction::Return
                       notexists join Action, ViolatingRecord, ViolationJustificationType from  justification
                        where justification.Action == TrvWorkflowAction::Approve
                           && justification.ViolatingRecord == log.Line
                           && justification.ViolationJustificationType == lineJustificationType
                           && justification.JustifyingWorker == HcmWorkerLookup::currentWorker();

        if (log.RecId != 0)
        {
            return true;
        }
        //no need for check on error violations since if there are error violations the document would not reach the approver

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPoliciesForHdr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a container that contains every policy violation for the specified expense or travel
    /// requisition transaction header. Reads from the log table, so this doesn't work on documents in draft.
    /// </summary>
    /// <param name="header">
    /// The record ID of the transaction header.
    /// </param>
    /// <param name="policyType">
    /// The policy type.
    /// </param>
    /// <param name="c">
    /// The container to add the policy violations to.
    /// </param>
    /// <param name="_stopOnError">
    /// A Boolean value that indicates whether to add additional violations after the first policy
    /// violation has been added.
    /// </param>
    /// <param name="_includeAllLines">
    /// True if policies need to be checked for all the lines too; otherwise false.
    /// </param>
    /// <returns>
    /// A container that contains every policy violation for the specified transaction header.
    /// </returns>
    public static container checkPoliciesForHdr(RefRecId header, SysPolicyTypeEnum policyType, container c, boolean _stopOnError = false, boolean _includeAllLines = false)
    {
        TrvPolicyViolationsLog     log;
        TrvPolicyRule              policy;

        TrvPolicyViolationJustification         justification;
        TrvPolicyViolationJustificationTypeEnum justificationType;

        TrvPolicyViolationLevel     violationLevelIsError = TrvPolicyViolationLevel::Warning;
        TrvHcmWorkerRecId           currentWorker;

        if (policyType == SysPolicyTypeEnum::TrvExpensePolicy)
        {
            justificationType = TrvPolicyViolationJustificationTypeEnum::TrvExpHeader;
        }
        else if (policyType == SysPolicyTypeEnum::TrvRequisitionPolicy)
        {
            justificationType = TrvPolicyViolationJustificationTypeEnum::TrvReqHeader;
        }

        currentWorker = HcmWorkerLookup::currentWorker();

        // directly read from log table
        while select * from log join policy
                    order by policy.Action desc
                    where log.Rule == policy.RecId
                        && (_includeAllLines || log.Line == 0) // this means it is for transaction header alone if _includeAllLines is false.
                        && log.Header == header
                        && log.PolicyType == policyType
                        && log.Action != TrvWorkflowAction::Return
                            outer join justification
                                where justification.ViolatingRecord == log.Header
                                    && justification.JustifyingWorker == currentWorker
                                    && justification.ViolationJustificationType == justificationType
                                    && justification.Action == TrvWorkflowAction::Approve
        {
            switch (policy.Action)
            {
                case TrvPolicyViolationLevel::Error :
                    violationLevelIsError = TrvPolicyViolationLevel::Error;
                    break;

                case TrvPolicyViolationLevel::Warning :
                case TrvPolicyViolationLevel::SubmitJustification :
                    violationLevelIsError = TrvPolicyViolationLevel::Warning;
                    break;

                case TrvPolicyViolationLevel::ApproveJustification :
                case TrvPolicyViolationLevel::SubmitApproveJustification :
                    if (justification.RecId == 0 || strLRTrim(justification.Justification) == '')
                    {
                        violationLevelIsError = TrvPolicyViolationLevel::Error;
                    }
                    else
                    {
                        // justification is provided, move to the next
                        continue;
                    }
                    break;
            }
            c += [policy.RecId, [1], [policy.Action, policy.userMessage()], [violationLevelIsError]];
            if (_stopOnError)
            {
                return c;
            }
        }

        return c;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPoliciesForLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a container that contains every policy violation for the specified expense or travel
    /// requisition transaction line. Reads from the log table, so this doesn't work on documents in draft.
    /// </summary>
    /// <param name="line">
    /// The record ID of the transaction line.
    /// </param>
    /// <param name="policyType">
    /// The policy type.
    /// </param>
    /// <param name="c">
    /// The container to add the policy violations to.
    /// </param>
    /// <param name="_stopOnError">
    /// A Boolean value that indicates whether to add additional violations after the first policy
    /// violation has been added.
    /// </param>
    /// <param name="_throwInfologs">
    /// A Boolean value that indicates whether violations will be thrown/
    /// </param>
    /// <returns>
    /// A container that contains every policy violation for the specified transaction line.
    /// </returns>
    public static container checkPoliciesForLine(RefRecId line, SysPolicyTypeEnum policyType, container c, boolean _stopOnError = false, boolean _throwInfologs = false)
    {
        TrvPolicyViolationsLog      log;
        TrvPolicyRule               policy;
        TrvPolicyViolationLevel     violationLevelIsError;
        TrvHcmWorkerRecId           currentWorker;
        TrvPolicyViolationJustification         justification;
        TrvPolicyViolationJustificationTypeEnum justificationType;

        switch (policyType)
        {
            case SysPolicyTypeEnum::TrvExpensePolicy :
                justificationType = TrvPolicyViolationJustificationTypeEnum::TrvExpLine;
                break;

            case SysPolicyTypeEnum::TrvRequisitionPolicy :
                justificationType = TrvPolicyViolationJustificationTypeEnum::TrvReqLine;
                break;

            default:
                break;
        }

        currentWorker = HcmWorkerLookup::currentWorker();

        // directly read from log table
        while select * from log join policy
                    order by policy.Action desc
                    where log.Rule == policy.RecId
                        && log.Line == line
                        && log.PolicyType == policyType
                        && log.Action != TrvWorkflowAction::Return
                            outer join justification
                                where justification.Action == TrvWorkflowAction::Approve
                                    && justification.ViolatingRecord == log.Line
                                    && justification.JustifyingWorker == currentWorker
                                    && justification.ViolationJustificationType == justificationType
        {
            switch (policy.Action)
            {
                case TrvPolicyViolationLevel::Error :
                    violationLevelIsError = TrvPolicyViolationLevel::Error;
                    break;

                case TrvPolicyViolationLevel::Warning :
                // above we check for justifications for current worker
                // submit justifications have justifications entered by the creating worker
                // submit justifications are treated as warnings, when user is approving
                case TrvPolicyViolationLevel::SubmitJustification:
                    violationLevelIsError = TrvPolicyViolationLevel::Warning;
                    break;

                case TrvPolicyViolationLevel::ApproveJustification :
                case TrvPolicyViolationLevel::SubmitApproveJustification :
                    if (justification.RecId == 0 || strLRTrim(justification.Justification) == '')
                    {
                        violationLevelIsError = TrvPolicyViolationLevel::Error;
                    }
                    else
                    {
                        // justification is provided, move to the next
                        continue;
                    }
                    break;
            }

            c += [policy.RecId, [1], [policy.Action, policy.userMessage()], [violationLevelIsError]];
            if (_stopOnError)
            {
                return c;
            }
        }

        if (_throwInfologs)
        {
            TrvPolicyEvalEngine::throwInfologs(c);
        }

        return c;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteNotNeededJustifications</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes justifications that are no longer valid.
    /// </summary>
    /// <param name="_recId">
    /// RecId of the expense report.
    /// </param>
    /// <param name="_policyType">
    /// Type of policy.
    /// </param>
    /// <param name="_forHeader">
    /// If the method was called for the header document.
    /// </param>
    public static void deleteNotNeededJustifications(RecId _recId,
                                                      SysPolicyTypeEnum _policyType,
                                                      boolean _forHeader = false)
    {
        TrvPolicyViolationJustification         justification;
        TrvPolicyViolationJustificationTypeEnum justificationType;
        TrvPolicyViolationsCache                cache;

        if (_forHeader)
        {
            justificationType = (_policyType == SysPolicyTypeEnum::TrvExpensePolicy) ?
                                    TrvPolicyViolationJustificationTypeEnum::TrvExpHeader :
                                    TrvPolicyViolationJustificationTypeEnum::TrvReqHeader;
        }
        else
        {
            justificationType = (_policyType == SysPolicyTypeEnum::TrvExpensePolicy) ?
                                    TrvPolicyViolationJustificationTypeEnum::TrvExpLine :
                                    TrvPolicyViolationJustificationTypeEnum::TrvReqLine;
        }

        // If the policy is not violated anymore, there will not be an entry in the cache

        if (_forHeader)
        {
            while select forupdate justification
                where justification.ViolatingRecord == _recId
                    && justification.ViolationJustificationType == justificationType
                    notexists join cache
                        where cache.Header == _recId
                            && cache.PolicyType == _policyType
                            && (cache.PolicyViolationLevel == TrvPolicyViolationLevel::SubmitApproveJustification ||
                                cache.PolicyViolationLevel == TrvPolicyViolationLevel::SubmitJustification ||
                                cache.PolicyViolationLevel == TrvPolicyViolationLevel::ApproveJustification)
            {
                ttsbegin;
                justification.delete();
                ttscommit;
            }
        }
        else
        {
            while select forupdate justification
                where justification.ViolatingRecord == _recId
                    && justification.ViolationJustificationType == justificationType
                    notexists join cache
                        where cache.Line == _recId
                            && cache.PolicyType == _policyType
                            && (cache.PolicyViolationLevel == TrvPolicyViolationLevel::SubmitApproveJustification ||
                                cache.PolicyViolationLevel == TrvPolicyViolationLevel::SubmitJustification ||
                                cache.PolicyViolationLevel == TrvPolicyViolationLevel::ApproveJustification)
            {
                ttsbegin;
                justification.delete();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayPolicyViolationLevelMsg</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of <c>TrvPolicyViolation</c> objects for the specified line.
    /// </summary>
    /// <param name="line">
    /// The record ID of the transaction.
    /// </param>
    /// <param name="policyType">
    /// The policy type.
    /// </param>
    /// <returns>
    /// A list of <c>TrvPolicyViolation</c> objects for the specified line.
    /// </returns>
    public static List displayPolicyViolationLevelMsg(RefRecId line, SysPolicyTypeEnum policyType)
    {
        container   c = conNull();
        Array       arrayViolations;
        int         len;
        List        policyViolations = new List(Types::Class);

        if (line)
        {
            c = TrvPolicyEvalEngine::checkPoliciesForLine(line, policyType, c, false);
            len = conLen(c);

            // Policy violation for a document will be either in log table or in cache table, not both.
            // If nothing from log table, search the cache table.
            if (len < 4)
            {
                arrayViolations = TrvPolicyEvalEngine::showViolationsForExpLines(0, line, policyType, false, false, false, false);
                TrvPolicyEvalEngine::addViolationsFromArrayToList(policyViolations, arrayViolations);

                //policy violation for child lines.
                TrvExpTrans itemizedExpenseLine;

                select firstonly itemizedExpenseLine
                    where itemizedExpenseLine.ParentRecId == line;

                if (itemizedExpenseLine)
                {
                    arrayViolations = TrvPolicyEvalEngine::showViolationsForChildLines(line, itemizedExpenseLine.recid);
                    TrvPolicyEvalEngine::addViolationsFromArrayToList(policyViolations, arrayViolations);
                }
            }
            else // Found violations from log table.
            {
                TrvPolicyEvalEngine::addViolationsFromContainerToList(policyViolations, c);
            }
        }

        return policyViolations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayPolicyViolationLevelMsgHdr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of <c>TrvPolicyViolation</c> objects for the specified transaction header.
    /// </summary>
    /// <param name="header">
    /// The record ID of the transaction header.
    /// </param>
    /// <param name="policyType">
    /// The policy type.
    /// </param>
    /// <param name="_includeAllLines">
    /// True if policy messages need to be fetched for all the lines as well; otherwise false.
    /// </param>
    /// <returns>
    /// A list of <c>TrvPolicyViolation</c> objects for the specified transaction header.
    /// </returns>
    public static List displayPolicyViolationLevelMsgHdr(RefRecId header, SysPolicyTypeEnum policyType, boolean _includeAllLines = false)
    {
        container   c = conNull();
        Array       arrayViolations;
        int         len;
        List        policyViolations = new List(Types::Class);

        if (header)
        {
            c = TrvPolicyEvalEngine::checkPoliciesForHdr(header, policyType, c, false, _includeAllLines);
            len = conLen(c);

            // Policy violation for a document will be either in log table or in cache table, not both.
            // If nothing from log table, search the cache table.
            if (len < 4)
            {
                if (_includeAllLines)
                {
                    arrayViolations = TrvPolicyEvalEngine::showViolationsForExpLines(header, 0, policyType, false, false, false, false);
                }
                else
                {
                    arrayViolations = TrvPolicyEvalEngine::showViolationsForExpHdr(header, policyType, false);
                }

                TrvPolicyEvalEngine::addViolationsFromArrayToList(policyViolations, arrayViolations);
            }
            else // Found violations from log table.
            {
                TrvPolicyEvalEngine::addViolationsFromContainerToList(policyViolations, c);
            }
        }

        return policyViolations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>evaluateViolationsForHdr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Evaluates policy violations for the specified transaction header.
    /// Evaluates on documents in draft and inserts violations in cache table.
    /// </summary>
    /// <param name="header">
    /// The record ID of the transaction header.
    /// </param>
    /// <param name="policyType">
    /// The policy type.
    /// </param>
    public static void evaluateViolationsForHdr(RefRecId header, SysPolicyTypeEnum policyType)
    {
        TrvPolicyViolationsCache    cache;
        utcdatetime                 applyDate;
        SysDictTable                dictTable;
        FieldId                     createdDateTimeFieldId;
        FieldId                     workerFieldId;
        SysPolicyRuleType           policyRuleType;
        TableId                     headerTableId;
        Common                      common;
        Array                       applicablePolicyRules;
        int64                       orgIds[];
        FieldId                     legalEntityFieldId;
        int                         i;
        TrvPolicyRule               currentTrvRule;
        boolean                     forHeader = true;
        container                   workerDepts = conNull();
        int                         numWorkerDepts;
        int                         numberOfErrors = 0;
        int                         numberOfWarnings = 0;
        int                         numberOfRulesEvaluated = 0;
        boolean                     success = false;
        utcDateTime                 minValue = DateTimeUtil::minValue();
        utcDateTime                 maxValue = DateTimeUtil::maxValue();

        try
        {
            Microsoft.Dynamics.Application.Instrumentation.ApplicationEventSource::EventWriteTrvPolicyHeaderEvaluationStart(numberOfWarnings, numberOfErrors, numberOfRulesEvaluated, true);

			switch (policyType)
			{
				case SysPolicyTypeEnum::TrvExpensePolicy :
					headerTableId = tableNum(TrvExpTable);
					policyRuleType = SysPolicyRuleType::findByRuleTypePolicyType(SysPolicyRuleTypeEnum::TrvHeaderPolicyRule, policyType);
					break;
		
				case SysPolicyTypeEnum::TrvRequisitionPolicy :
					headerTableId = tableNum(TrvRequisitionTable);
					policyRuleType = SysPolicyRuleType::findByRuleTypePolicyType(SysPolicyRuleTypeEnum::TrvRequisitionHeaderPolicyRule, policyType);
					break;
		
				default:
					break;
			}
		
			dictTable = new SysDictTable(headerTableId);
			if(dictTable)
			{
				common = dictTable.makeRecord();
			}
		
			select common where common.RecId == header;
			if (!common)
			{
				return;
			}
		
			createdDateTimeFieldId = fieldName2id(headerTableId, 'CreatedDateTime');
            legalEntityFieldId = fieldName2id(headerTableId, 'LegalEntity');
			workerFieldId =  fieldName2id(headerTableId, 'CreatingWorker');
		
			ttsBegin;
		
			while select forUpdate cache
				where   cache.Line == 0 &&
						cache.Header == header &&
						cache.PolicyType == policyType &&
						cache.Worker == common.(workerFieldId)
			{
				cache.delete();
			}
		
			ttsCommit;
		
			applyDate = DateTimeUtil::newDateTime(common.(createdDateTimeFieldId), 0);
			applyDate = DateTimeUtil::addHours(applyDate, 23);
			applyDate = DateTimeUtil::addMinutes(applyDate, 59);
			applyDate = DateTimeUtil::addSeconds(applyDate, 59);
			// we remove the time zone offset to get the utc since the policy time is in utc
			applyDate = DateTimeUtil::removeTimeZoneOffset(applyDate, DateTimeUtil::getUserPreferredTimeZone());
		
			applyDate = applyDate ? applyDate : DateTimeUtil::utcNow();
		
			cache.clear();
			cache.Line                  = 0;
			cache.Header                = header;
			cache.SaveDateTime          = applyDate;
			cache.Rule                  = 0;
			cache.PolicyViolationLevel  = TrvPolicyViolationLevel::None;
            cache.ViolationDate         = TrvExpenseHelper::getUserPreferredTimeZoneDate(common.(createdDateTimeFieldId));
			cache.Worker                = common.(workerFieldId);
			cache.PolicyType            = policyType;
		
			// Policy rules will be fetched for the following orgs:
			// 1) The LE associated with the expense/req header
            FieldId interCompanyLegalEntityFieldId = fieldName2id(headerTableId, 'InterCompanyLE');
            orgIds[1] = TrvPolicyEvalEngine::getLegalEntityRecId(common, legalEntityFieldId, interCompanyLegalEntityFieldId);
		
			// 2) The Department OU(s) for the worker (based on position) as of the expense date
			workerDepts = HcmWorkerHelper::getDepartmentRecIds(cache.Worker, applyDate);
			numWorkerDepts = conLen(workerDepts);
			for (i = 1; i <= numWorkerDepts; i++)
			{
				orgIds[i+1] = conPeek(workerDepts, i);
			}

            // Consider organizations that are currently associated with the policies. The last parameter (true) enables
            // evaluating policy rules in the past that may be effective before organizations were associated with the policy.
            applicablePolicyRules = SysPolicies::getPolicyRuleIDs(orgIds, policyRuleType.RecId, policyType, applyDate,
                                                                    false, false, true);
			numberOfRulesEvaluated = applicablePolicyRules.lastIndex();
			for (i = 1; i <= numberOfRulesEvaluated; i++)
			{
                select validTimeState(minValue, maxValue) * from currentTrvRule where currentTrvRule.RecId == applicablePolicyRules.value(i);
		
				if (TrvPolicyEvalEngine::isPolicyViolatedHdr(currentTrvRule, policyType, header))
				{
					cache.Rule = currentTrvRule.RecId;
					cache.PolicyViolationLevel = currentTrvRule.Action;
					if(cache.PolicyViolationLevel == TrvPolicyViolationLevel::Error)
					{
						numberOfErrors++;
					}
					else
					{
						numberOfWarnings++;
					}
					cache.insert();
				}
			}

            success = true;
        }
        finally
        {
            Microsoft.Dynamics.Application.Instrumentation.ApplicationEventSource::EventWriteTrvPolicyHeaderEvaluationStop(numberOfWarnings, numberOfErrors, numberOfRulesEvaluated, success);
        }

        TrvPolicyEvalEngine::deleteNotNeededJustifications(common.RecId, policyType, forHeader);
    }

]]></Source>
			</Method>
			<Method>
				<Name>evaluateViolationsForLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Evaluates policy violations for the specified transaction.
    /// Evaluates on documents in draft and inserts violations in cache table.
    /// </summary>
    /// <param name="line">
    /// The record ID of the transaction.
    /// </param>
    /// <param name="policyType">
    /// The policy type.
    /// </param>
    public static void evaluateViolationsForLine(RefRecId line, SysPolicyTypeEnum policyType)
    {
        TrvPolicyViolationsCache    cache;
        utcdatetime                 applyDate;

        SysDictTable                dictTable;
        SysDictTable                headerDictTable;
        str                         transactionDateFieldName;
        str                         headerRecordFieldName;
        str                         headerEmployeeRecordFieldName;

        FieldId                     lineDateFiedId;
        FieldId                     legalEntityFieldId;
        FieldId                     expTypeFieldId;
        FieldId                     workerFieldId;
        FieldId                     headerRecordId;
        FieldId                     parentRecordId;
        FieldId						splitLineTypeId;

        TableId                     lineTableId;
        Common                      common;
        SysPolicyRuleTypeEnum       specificApplicablePolicyRuleTypeEnum;
        SysPolicyRuleType           policyRuleType;
        TableId                     headerTableId;
        Common                      commonHeaderRecord;
        int64                       orgIds[];
        Array                       applicablePolicyRules;
        Array                       applicablePolicyRuleTypes;
        TrvExpType                  expType;
        int                         i;
        int                         j;
        TrvPolicyRule               currentTrvRule;
        boolean                     forHeader = false;
        container                   workerDepts = conNull();
        int                         numWorkerDepts;
        int                         numberOfErrors = 0;
        int                         numberOfWarnings = 0;
        int                         numberOfRulesEvaluated = 0;
        boolean                     success = false;
        utcDateTime                 minValue = DateTimeUtil::minValue();
        utcDateTime                 maxValue = DateTimeUtil::maxValue();

        applicablePolicyRuleTypes = new Array(Types::Int64);
        try
        {
            Microsoft.Dynamics.Application.Instrumentation.ApplicationEventSource::EventWriteTrvPolicyLineEvaluationStart(numberOfWarnings, numberOfErrors, numberOfRulesEvaluated, true);
			
			switch (policyType)
			{
				case SysPolicyTypeEnum::TrvExpensePolicy :
					lineTableId = tableNum(TrvExpTrans);
					headerTableId = tableNum(TrvExpTable);
					transactionDateFieldName = 'TransDate';
					headerRecordFieldName = 'TrvExpTable';
					headerEmployeeRecordFieldName = 'CreatingWorker';
					parentRecordId = fieldName2id(lineTableId, 'ParentRecId');
					break;
				case SysPolicyTypeEnum::TrvRequisitionPolicy :
					lineTableId = tableNum(TrvRequisitionLine);
					headerTableId = tableNum(TrvRequisitionTable);
					transactionDateFieldName = 'EstimatedDate';
					headerRecordFieldName = 'TrvRequisitionTable';
					headerEmployeeRecordFieldName = 'CreatingWorker';
					break;
		
				default:
					break;
			}
		
			lineDateFiedId = fieldName2id(lineTableId, transactionDateFieldName);
			legalEntityFieldId = fieldName2id(lineTableId, 'LegalEntity');
			expTypeFieldId = fieldName2id(lineTableId, 'ExpType');
            splitLineTypeId = fieldName2Id(lineTableId, 'SplitLineType');
			headerRecordId = fieldName2id(lineTableId, headerRecordFieldName);
			workerFieldId =  fieldName2id(headerTableId, headerEmployeeRecordFieldName);
		
			dictTable = new SysDictTable(lineTableId);
			if (dictTable)
			{
				common = dictTable.makeRecord();
			}
		
			select common where common.RecId == line;
            
            if (!common || (lineTableId == tableNum(TrvExpTrans) && common.(splitLineTypeId) == TrvExpSplitLineType::SplitHeader))
            {
                return;
            }
            
			headerDictTable = new SysDictTable(headerTableId);
			if (headerDictTable)
			{
				commonHeaderRecord = headerDictTable.makeRecord();
			}
		
			select commonHeaderRecord where commonHeaderRecord.RecId == common.(headerRecordId);
		
			ttsBegin;
            delete_from cache
                where   cache.Line == line &&
                        cache.PolicyType == policyType &&
                        ((cache.Header == commonHeaderRecord.RecId &&
                             cache.Worker == commonHeaderRecord.(workerFieldId)) || cache.Header == 0);
			ttsCommit;
		
			applyDate = TrvPolicyEvalEngine::getPolicyCheckDateTime(common.(lineDateFiedId));
		
			applyDate = applyDate ? applyDate : DateTimeUtil::utcNow();
		
			cache.clear();
			cache.Line                  = line;
		
			// only expense lines have parent lines(itemization, cost split)
			if (policyType == SysPolicyTypeEnum::TrvExpensePolicy)
			{
				cache.ParentRecId       = common.(parentRecordId);
			}
		
			cache.Header                = commonHeaderRecord.RecId;
			cache.SaveDateTime          = applyDate;
			cache.Rule                  = 0;
			cache.PolicyViolationLevel  = TrvPolicyViolationLevel::None;
			cache.ViolationDate         = common.(lineDateFiedId);
			cache.PolicyType            = policyType;
            cache.Worker                = commonHeaderRecord.(workerFieldId);
		
			expType = common.(expTypeFieldId);
		
			//expense policies
			if(policyType == SysPolicyTypeEnum::TrvExpensePolicy)
			{
				switch (expType)
				{
					case TrvExpType::Airline :
						specificApplicablePolicyRuleTypeEnum = SysPolicyRuleTypeEnum::TrvAirlinePolicyRule;
						break;
					case TrvExpType::Hotel :
						specificApplicablePolicyRuleTypeEnum = SysPolicyRuleTypeEnum::TrvHotelPolicyRule;
						break;
					case TrvExpType::Meals :
						specificApplicablePolicyRuleTypeEnum = SysPolicyRuleTypeEnum::TrvMealsPolicyRule;
						break;
					case TrvExpType::CarRental :
						specificApplicablePolicyRuleTypeEnum = SysPolicyRuleTypeEnum::TrvCarRentalPolicyRule;
						break;
					case TrvExpType::Transport :
						specificApplicablePolicyRuleTypeEnum = SysPolicyRuleTypeEnum::TrvMileagePolicyRule;
						break;
					case TrvExpType::Entertainment :
						specificApplicablePolicyRuleTypeEnum = SysPolicyRuleTypeEnum::TrvEntertainmentPolicyRule;
						break;
					case TrvExpType::Conference :
						specificApplicablePolicyRuleTypeEnum = SysPolicyRuleTypeEnum::TrvConferencePolicyRule;
						break;
					case TrvExpType::Personal :
						specificApplicablePolicyRuleTypeEnum = SysPolicyRuleTypeEnum::TrvPersonalPolicyRule;
						break;
					case TrvExpType::Expense :
						specificApplicablePolicyRuleTypeEnum = SysPolicyRuleTypeEnum::TrvMiscellaneousPolicyRule;
						break;
					case TrvExpType::Gift :
						specificApplicablePolicyRuleTypeEnum = SysPolicyRuleTypeEnum::TrvGiftPolicyRule;
						break;
				}

                cache.Worker = cache.Worker ? cache.Worker : common.(fieldName2Id(lineTableId, 'CreatingWorker'));
			}
			//travel policies
			else
			{
				switch (expType)
				{
					case TrvExpType::Airline :
						specificApplicablePolicyRuleTypeEnum = SysPolicyRuleTypeEnum::TrvRequisitionAirlinePolicyRule;
						break;
					case TrvExpType::Hotel :
						specificApplicablePolicyRuleTypeEnum = SysPolicyRuleTypeEnum::TrvRequisitionHotelPolicyRule;
						break;
					case TrvExpType::Meals :
						specificApplicablePolicyRuleTypeEnum = SysPolicyRuleTypeEnum::TrvRequisitionMeals;
						break;
					case TrvExpType::CarRental :
						specificApplicablePolicyRuleTypeEnum = SysPolicyRuleTypeEnum::TrvRequisitionCarRentallPolicyRule;
						break;
					case TrvExpType::Transport :
						specificApplicablePolicyRuleTypeEnum = SysPolicyRuleTypeEnum::TrvRequisitionMileagePolicyRule;
						break;
					case TrvExpType::Entertainment :
						specificApplicablePolicyRuleTypeEnum = SysPolicyRuleTypeEnum::TrvRequisitionEntertainementPolicyRule;
						break;
					case TrvExpType::Conference :
						specificApplicablePolicyRuleTypeEnum = SysPolicyRuleTypeEnum::TrvRequisitionConferencePolicyRule;
						break;
					case TrvExpType::Expense :
						specificApplicablePolicyRuleTypeEnum = SysPolicyRuleTypeEnum::TrvRequisitionMiscellaneousPolicyRule;
						break;
				}
			}
		
			if (specificApplicablePolicyRuleTypeEnum)
			{
				policyRuleType = SysPolicyRuleType::findByRuleTypePolicyType(specificApplicablePolicyRuleTypeEnum, policyType);
			}
		
			// Policy rules will be fetched for the following orgs:
			// 1) The LE associated with the expense/req header
            FieldId interCompanyLegalEntityFieldId = fieldName2id(lineTableId, 'InterCompanyLE');
            orgIds[1] = TrvPolicyEvalEngine::getLegalEntityRecId(common, legalEntityFieldId, interCompanyLegalEntityFieldId);
            
			// 2) The Department OU(s) for the worker (based on position) as of the expense date
			workerDepts = HcmWorkerHelper::getDepartmentRecIds(cache.Worker, applyDate);
			numWorkerDepts = conLen(workerDepts);
			for (i = 1; i <= numWorkerDepts; i++)
			{
				orgIds[i+1] = conPeek(workerDepts, i);
			}

            // Consider organizations that are currently associated with the policies. The last parameter (true) enables
            // evaluating policy rules in the past that may be effective before organizations were associated with the policy.
			applicablePolicyRules = SysPolicies::getPolicyRuleIDs(orgIds, policyRuleType.RecId, policyType, applyDate,
                                                                    false, false, true);
			numberOfRulesEvaluated = applicablePolicyRules.lastIndex();
		
			for (i = 1; i <= applicablePolicyRules.lastIndex(); i++)
			{
                select validTimeState(minValue, maxValue) * from currentTrvRule where currentTrvRule.RecId == applicablePolicyRules.value(i);
				if (TrvPolicyEvalEngine::isPolicyViolated(currentTrvRule, line, policyType))
				{
					cache.Rule = currentTrvRule.RecId;
					cache.PolicyViolationLevel = currentTrvRule.Action;
					cache.insert();
					if(cache.PolicyViolationLevel == TrvPolicyViolationLevel::Error)
					{
						numberOfErrors++;
					}
					else
					{
						numberOfWarnings++;
					}
				}
			}
		
			// run policies that apply to lines of all expense types
			if (policyType == SysPolicyTypeEnum::TrvExpensePolicy)
			{
				policyRuleType = SysPolicyRuleType::findByRuleTypePolicyType(SysPolicyRuleTypeEnum::TrvOther, policyType);
				applicablePolicyRuleTypes.value(1, policyRuleType.RecId);
		
				policyRuleType = SysPolicyRuleType::findByRuleTypePolicyType(SysPolicyRuleTypeEnum::TrvPreferredMerchant, policyType);
				applicablePolicyRuleTypes.value(2, policyRuleType.RecId);
		
				policyRuleType = SysPolicyRuleType::findByRuleTypePolicyType(SysPolicyRuleTypeEnum::TrvReceiptsRequired, policyType);
				applicablePolicyRuleTypes.value(3, policyRuleType.RecId);
			}
			else
			{
				policyRuleType = SysPolicyRuleType::findByRuleTypePolicyType(SysPolicyRuleTypeEnum::TrvRequisitionOther, policyType);
				applicablePolicyRuleTypes.value(1, policyRuleType.RecId);
		
				policyRuleType = SysPolicyRuleType::findByRuleTypePolicyType(SysPolicyRuleTypeEnum::TrvRequisitionPreferredMerchant, policyType);
				applicablePolicyRuleTypes.value(2, policyRuleType.RecId);
			}
		
			for (i = 1; i <= applicablePolicyRuleTypes.lastIndex(); i++)
            {
                // Consider organizations that are currently associated with the policies. The last parameter (true) enables
                // evaluating policy rules in the past that may be effective before organizations were associated with the policy.
				applicablePolicyRules = SysPolicies::getPolicyRuleIDs(orgIds, applicablePolicyRuleTypes.value(i), policyType,
                                                                        applyDate, false, false, true);
				numberOfRulesEvaluated += applicablePolicyRules.lastIndex();
				
				for (j = 1; j <= applicablePolicyRules.lastIndex(); j++)
				{
                    select validTimeState(minValue, maxValue) * from currentTrvRule where currentTrvRule.RecId == applicablePolicyRules.value(j) && currentTrvRule.ValidTo > DateTimeUtil::utcNow(); ;
		
					if (TrvPolicyEvalEngine::isPolicyViolated(currentTrvRule, line, policyType))
					{
						cache.Rule = currentTrvRule.RecId;
						cache.PolicyViolationLevel = currentTrvRule.Action;
						cache.insert();
						if(cache.PolicyViolationLevel == TrvPolicyViolationLevel::Error)
						{
							numberOfErrors++;
						}
						else
						{
							numberOfWarnings++;
						}
					}
				}
			}

            success = true;
        }
        finally
        {
            Microsoft.Dynamics.Application.Instrumentation.ApplicationEventSource::EventWriteTrvPolicyLineEvaluationStop(numberOfWarnings, numberOfErrors, numberOfRulesEvaluated, success);
        }
		
        TrvPolicyEvalEngine::deleteNotNeededJustifications(common.RecId, policyType, forHeader);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPolicyViolations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether there are any policy errors in the expense/travel requisition header or line.
    /// </summary>
    /// <param name="_refTableId">
    /// The table ID of the transaction header or line table.
    /// </param>
    /// <param name="_refRecId">
    /// The record ID of the transaction header or line.
    /// </param>
    /// <returns>
    /// true if there are policy errors; otherwise, false.
    /// </returns>
    public static boolean hasPolicyViolations(RefTableId _refTableId, RefRecId _refRecId)
    {
        TrvExpTrans         expenseTrans;
        TrvRequisitionLine  trvRequisitionLine;
        boolean             ret = false;

        switch (_refTableId)
        {
            case tableNum(TrvExpTable):
                ret = TrvPolicyEvalEngine::anyPolicyErrors(_refRecId, SysPolicyTypeEnum::TrvExpensePolicy);

                if (!ret)
                {
                    while select RecId from expenseTrans
                        where expenseTrans.TrvExpTable == _refRecId
                    {
                        if (ret)
                        {
                            break;
                        }
                        ret = TrvPolicyEvalEngine::anyPolicyErrorsForLine(expenseTrans.RecId, SysPolicyTypeEnum::TrvExpensePolicy);
                    }
                }
                break;

            case tableNum(TrvExpTrans):
                ret = TrvPolicyEvalEngine::anyPolicyErrorsForLine(_refRecId, SysPolicyTypeEnum::TrvExpensePolicy);
                break;

            case tableNum(TrvRequisitionTable):
                ret = TrvPolicyEvalEngine::anyPolicyErrors(_refRecId, SysPolicyTypeEnum::TrvRequisitionPolicy);

                if (!ret)
                {
                    while select RecId from trvRequisitionLine
                        where trvRequisitionLine.TrvRequisitionTable == _refRecId
                    {
                        if (ret)
                        {
                            break;
                        }
                        ret = TrvPolicyEvalEngine::anyPolicyErrorsForLine(trvRequisitionLine.RecId, SysPolicyTypeEnum::TrvRequisitionPolicy);
                    }
                }
                break;

            case tableNum(TrvRequisitionLine):
                ret = TrvPolicyEvalEngine::anyPolicyErrorsForLine(_refRecId, SysPolicyTypeEnum::TrvRequisitionPolicy);
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPolicyWarnings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether there are any policy warnings in the expense/travel requisition header or line.
    /// Reads from the log table, so this doesn't work on documents in draft.
    /// </summary>
    /// <param name="_refTableId">
    /// The table ID of the transaction header or line table.
    /// </param>
    /// <param name="_refRecId">
    /// The record ID of the transaction header or line.
    /// </param>
    /// <returns>
    /// true if there are policy warnings; otherwise, false.
    /// </returns>
    public static boolean hasPolicyWarnings(RefTableId _refTableId, RefRecId _refRecId)
    {
        TrvExpTrans expenseTrans;
        TrvRequisitionLine trvRequisitionLine;
        boolean     ret = false;
        container   cont = conNull();
        TrvPolicyViolationLevel isErrorMessage;

        if (_refTableId == tableNum(TrvExpTable))
        {
            cont = TrvPolicyEvalEngine::checkPoliciesForHdr(_refRecId, SysPolicyTypeEnum::TrvExpensePolicy, cont);
            [isErrorMessage] = conPeek(cont, 4);
            if (enum2str(isErrorMessage) != '')
            {
                ret = true;
            }
            while select RecId from expenseTrans
                where expenseTrans.TrvExpTable == _refRecId
            {
                cont = TrvPolicyEvalEngine::checkPoliciesForLine(expenseTrans.RecId, SysPolicyTypeEnum::TrvExpensePolicy, cont);
                [isErrorMessage] = conPeek(cont, 4);
                if (enum2str(isErrorMessage) != '')
                {
                    ret = true;
                }
            }
        }
        else if (_refTableId == tableNum(TrvExpTrans))
        {
            cont = TrvPolicyEvalEngine::checkPoliciesForLine(_refRecId, SysPolicyTypeEnum::TrvExpensePolicy, cont);
            [isErrorMessage] = conPeek(cont, 4);
            if (enum2str(isErrorMessage) != '')
            {
                ret = true;
            }
        }
        else if (_refTableId == tableNum(TrvRequisitionTable))
        {
            cont = TrvPolicyEvalEngine::checkPoliciesForHdr(_refRecId, SysPolicyTypeEnum::TrvRequisitionPolicy, cont);
            [isErrorMessage] = conPeek(cont, 4);
            if (enum2str(isErrorMessage) != '')
            {
                ret = true;
            }
            while select RecId from trvRequisitionLine
                where trvRequisitionLine.TrvRequisitionTable == _refRecId
            {
                cont = TrvPolicyEvalEngine::checkPoliciesForLine(trvRequisitionLine.RecId, SysPolicyTypeEnum::TrvRequisitionPolicy, cont);
                [isErrorMessage] = conPeek(cont, 4);
                if (enum2str(isErrorMessage) != '')
                {
                    ret = true;
                }
            }
        }
        else if (_refTableId == tableNum(TrvRequisitionLine))
        {
            cont = TrvPolicyEvalEngine::checkPoliciesForLine(_refRecId, SysPolicyTypeEnum::TrvRequisitionPolicy, cont);
            [isErrorMessage] = conPeek(cont, 4);
            if (enum2str(isErrorMessage) != '')
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>headerJustificationType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Used to know header justification type
    /// </summary>
    /// <param name="_policyType">
    /// The policy type, either Expense or Travel requisition.
    /// </param>
    /// <returns>
    /// Header justification type
    /// </returns>
    private static TrvPolicyViolationJustificationTypeEnum headerJustificationType(SysPolicyTypeEnum _policyType)
    {
        TrvPolicyViolationJustificationTypeEnum     headerJustificationType;

        if (_policyType == SysPolicyTypeEnum::TrvExpensePolicy)
        {
            headerJustificationType = TrvPolicyViolationJustificationTypeEnum::TrvExpHeader;
        }
        else if (_policyType == SysPolicyTypeEnum::TrvRequisitionPolicy)
        {
            headerJustificationType = TrvPolicyViolationJustificationTypeEnum::TrvReqHeader;
        }

        return headerJustificationType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>IsGuestsApplicableToPolicy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the policy rule is applicable to expense types which are allowed have guests.
    /// </summary>
    /// <param name="_policy">
    ///     The policy rule record.
    /// </param>
    /// <param name="policyType">
    ///     The policy type.
    /// </param>
    /// <returns>
    /// True if policy is applicable to have guests, otherwise false.
    /// </returns>
    private static boolean IsGuestsApplicableToPolicy(TrvPolicyRule _policy, SysPolicyTypeEnum _policyType, ExpressionTable _expressionTable)
    {
        // The expense types meals, entertainment and gifts are allowed to have guest.
        // Check if policy rule belongs to one of these categories.
        if ((_policy.PolicyRuleType == SysPolicyRuleType::findByRuleTypePolicyType(SysPolicyRuleTypeEnum::TrvMealsPolicyRule, _policyType).RecId ||
            _policy.PolicyRuleType == SysPolicyRuleType::findByRuleTypePolicyType(SysPolicyRuleTypeEnum::TrvEntertainmentPolicyRule, _policyType).RecId ||
            _policy.PolicyRuleType == SysPolicyRuleType::findByRuleTypePolicyType(SysPolicyRuleTypeEnum::TrvGiftPolicyRule, _policyType).RecId) &&
            match("Guest", _expressionTable.XPathQuery))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPolicyViolated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a given policy rule is violated for the specified line.
    /// </summary>
    /// <param name="policy">
    /// The policy rule record.
    /// </param>
    /// <param name="line">
    /// The record ID of the transaction.
    /// </param>
    /// <param name="policyType">
    /// The policy type.
    /// </param>
    /// <param name="checkReceiptAttached">
    /// Receipt required policy validation should pass when the policy rule applies and a receipt has been attached.
    /// True is default.  False should be used when you only want to verify that a policy rule applies to the expense.
    /// </param>
    /// <returns>
    /// true if the policy is violated; otherwise, false.
    /// </returns>
    static boolean isPolicyViolated(TrvPolicyRule policy, RefRecId line, SysPolicyTypeEnum policyType, boolean checkReceiptAttached = true)
    {
        ExpressionResultType result = ExpressionResultType::False;
        TableId              lineTableId;
        ExpressionTable      expressionTable = ExpressionTable::findRecId(policy.ExpressionTableRecId);

        // if the expression is empty, there is no policy as such
        if (!expressionTable.xPathQuery)
        {
            return false;
        }

         switch (policyType)
        {
            case SysPolicyTypeEnum::TrvExpensePolicy :
                lineTableId = tableNum(TrvExpTrans);
                break;

            case SysPolicyTypeEnum::TrvRequisitionPolicy :
                lineTableId = tableNum(TrvRequisitionLine);
                break;

            default:
                break;
        }

        TrvExpTrans trvExpTrans = null;
        
        if (lineTableId == tableNum(TrvExpTrans))
        {
            trvExpTrans = TrvExpTrans::find(line);
        }

        boolean isProjectValidationRule = match('ProjId', expressionTable.XPathQuery) ? true : false;

        // Skip project policy rule for the itemized headers as header lines are not part of TrvExprBuilderAccDistributionProjTableView
        // Related lines will have the distribution, should appear in view
        if (isProjectValidationRule
            && trvExpTrans.LineType == TrvExpLineType::ItemizedHeader
            && trvExpTrans.ProjId)
        {
            return false;
        }

        result = Expression::evaluate(curext(), lineTableId, line, expressionTable.ExpressionId, ExpressionDataSources::newExpressionDataSources(), true);

        //
        // The receipt required policies will always fail evaluation when that rule applies to a line even if a receipt is attached.
        // 1. If checkReceiptAttached is true and a receipt is attached OR
        // 2. If lineType is ItemizedLine and a receipt is not attached
        // we reset the result to false so the expense doesn't show an error and the user can submit the expense.
        if (result == ExpressionResultType::True && checkReceiptAttached)
        {
            result = TrvPolicyEvalEngine::receiptRequiredPolicyEvaluation(trvExpTrans, expressionTable, policy, policyType);
        }

        // If LineType is itemized line, guests will not get attached to the lines.
        // Let's not fail the policy validation in this scenario.
        if (result == ExpressionResultType::True
            && trvExpTrans.LineType == TrvExpLineType::ItemizedLine
            && TrvPolicyEvalEngine::IsGuestsApplicableToPolicy(policy, policyType, expressionTable)
            && TrvExpTrans::find(trvExpTrans.ParentRecId).isGuestType())
        {
            result = ExpressionResultType::False;
        }
        
        return result == ExpressionResultType::True ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPolicyViolatedHdr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a given policy rule is violated for the specified transaction header.
    /// </summary>
    /// <param name="policy">
    /// The policy rule record.
    /// </param>
    /// <param name="policyType">
    /// The policy type.
    /// </param>
    /// <param name="header">
    /// The record ID of the transaction header.
    /// </param>
    /// <returns>
    /// true if the policy is violated; otherwise, false.
    /// </returns>
    static boolean isPolicyViolatedHdr(TrvPolicyRule policy, SysPolicyTypeEnum policyType, RefRecId header)
    {
        ExpressionResultType    ret = ExpressionResultType::False;
        Common                  headerRecord;
        TableId                 headerTableId;
        DictTable               headerDictTable;
        ExpressionTable         expressionTable = ExpressionTable::findRecId(policy.ExpressionTableRecId);

        switch (policyType)
        {
            case SysPolicyTypeEnum::TrvExpensePolicy :
                headerTableId = tableNum(TrvExpTable);
                break;

            case SysPolicyTypeEnum::TrvRequisitionPolicy :
                headerTableId = tableNum(TrvRequisitionTable);
                break;

            default:
                break;
        }

        headerDictTable = new SysDictTable(headerTableId);
        if (headerDictTable)
        {
            headerRecord = headerDictTable.makeRecord();
        }

        // if the expression is empty, there is no policy as such
        if (!expressionTable.xPathQuery)
        {
            return false;
        }

        select headerRecord where headerRecord.RecId == header;
        if (headerRecord.RecId != 0)
        {
            ret = Expression::evaluate(curext(), headerTableId, header, expressionTable.ExpressionId, ExpressionDataSources::newExpressionDataSources(), true);
        }

        return ret == ExpressionResultType::True ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>receiptRequiredPolicyEvaluation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether receipt required policy is violated when the rule applies to a line.
    /// </summary>
    /// <param name="_trvExpTrans">
    /// The expense line record.
    /// </param>
    /// <param name="_expressionTable">
    /// The expression record.
    /// </param>
    /// <param name="_policy">
    /// The policy rule record.
    /// </param>
    /// <param name="_policyType">
    /// The policy type.
    /// </param>
    /// <returns>
    /// true if the policy is violated; otherwise, false.
    /// </returns>
    private static boolean receiptRequiredPolicyEvaluation(TrvExpTrans _trvExpTrans, ExpressionTable _expressionTable, TrvPolicyRule _policy, SysPolicyTypeEnum _policyType)
    {
        boolean evaluationResult = true;

        boolean isFeatureEnabled = FeatureStateProvider::isFeatureEnabled(TrvExpReceiptForItemizedLinesFeature::instance());

        if ((_trvExpTrans.ReceiptsAttached || (!isFeatureEnabled && _trvExpTrans.LineType == TrvExpLineType::ItemizedLine))
            && (match('Receipts', _expressionTable.XPathQuery) || 
            (TrvReceiptRequiredPolicyFeature::isEnabled() && _policy.PolicyRuleType == SysPolicyRuleType::findByRuleTypePolicyType(SysPolicyRuleTypeEnum::TrvReceiptsRequired, _policyType).RecId)))
        {
            evaluationResult = false;
        }

        return evaluationResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineJustificationType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Used to know line justification type
    /// </summary>
    /// <param name="_policyType">
    /// The policy type, either Expense or Travel requisition.
    /// </param>
    /// <returns>
    /// Line justification type
    /// </returns>
    private static TrvPolicyViolationJustificationTypeEnum lineJustificationType(SysPolicyTypeEnum _policyType)
    {
        TrvPolicyViolationJustificationTypeEnum     lineJustificationType;

        if (_policyType == SysPolicyTypeEnum::TrvExpensePolicy)
        {
            lineJustificationType = TrvPolicyViolationJustificationTypeEnum::TrvExpLine;
        }
        else if (_policyType == SysPolicyTypeEnum::TrvRequisitionPolicy)
        {
            lineJustificationType = TrvPolicyViolationJustificationTypeEnum::TrvReqLine;
        }

        return lineJustificationType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showViolationsForChildLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the policy violations for the child expense lines, and also writes the policy violations messages to the infolog.
    /// </summary>
    /// <param name="_parentLineId">
    ///     The <c>RecId</c> of the parent expense line.
    /// </param>
    /// <param name="_currLineId">
    ///     The <c>RecId</c> of the child expense line.
    /// </param>
    /// <param name="_writeToInfolog">
    ///     Boolean value that indicates whether policy messages are written to the infolog.
    /// </param>
    /// <returns>
    ///     An array of the policy violations.
    /// </returns>
    static Array showViolationsForChildLines(RefRecId _parentLineId, RefRecId _currLineId, boolean _writeToInfolog = false)
    {
        container c = conNull();      // container stores violations by policies
        Array arrayViolationsByLine = new Array(Types::String);
        TrvPolicyViolationsCache cache;
        TrvPolicyRule policy;
        int pos, num;
        int i=1;
        str msg;
        TrvPolicyViolationLevel isErrorViolation;
        boolean hasJustificationBeenEntered;

        TrvPolicyViolationJustification justification;

        // directly read from cache table
        while select Line from cache join policy
                    order by policy.Action desc
                        where cache.Rule == policy.RecId
                           && cache.ParentRecId == _parentLineId
                           && policy.Action != TrvPolicyViolationLevel::ApproveJustification // approver justifications should not be shown to expense creator
                        outer join Action, ViolatingRecord, JustifyingWorker, ViolationJustificationType from justification where
                           (justification.Action == TrvWorkflowAction::Submit) &&
                           (justification.ViolatingRecord == cache.Line) &&
                           justification.JustifyingWorker == cache.Worker &&
                           ((justification.ViolationJustificationType == TrvPolicyViolationJustificationTypeEnum::TrvExpLine))
        {
            msg = policy.userMessage();
            hasJustificationBeenEntered = false;

            switch (policy.Action)
            {
                case TrvPolicyViolationLevel::Error :
                    isErrorViolation = TrvPolicyViolationLevel::Error;
                    break;

                case TrvPolicyViolationLevel::Warning :
                    isErrorViolation = TrvPolicyViolationLevel::Warning;
                    break;

                default :
                    if (justification.RecId == 0)
                    {
                        isErrorViolation = TrvPolicyViolationLevel::Error;
                    }
                    else
                    {
                        hasJustificationBeenEntered = true;
                    }
                    break;
            }

            if (!hasJustificationBeenEntered)
            {
                arrayViolationsByLine.value(i, int642str(cache.Line));
                arrayViolationsByLine.value(i+1, int2str(enum2int(policy.Action)));
                arrayViolationsByLine.value(i+2, int2str(enum2int(isErrorViolation)));
                arrayViolationsByLine.value(i+3, msg);
                i = i+4;

                // push policies in container (to see by policy)
                pos = conFind(c, policy.RecId);
                if (pos)
                {
                    [num]  = conPeek(c, pos+1);
                    c      = conPoke(c, pos+1, [num+1]); // update the count by 1
                }
                else
                {
                    c += [policy.RecId, [1], [policy.Action, msg], [isErrorViolation]];
                }
            }
        }

        if (_writeToInfolog)
        {
            TrvPolicyEvalEngine::throwInfologs(c);
        }

        return arrayViolationsByLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showViolationsForExpHdr</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the policy violations for the specified transaction header, and also writes the policy violations messages to the infolog.
    ///     Reads from the cache table, so this doesn't work on documents NOT in draft.
    /// </summary>
    /// <param name="header">
    ///     The <c>RecId</c> of the transaction header.
    /// </param>
    /// <param name="policyType">
    ///     The policy type, either Expense or Travel requisition.
    /// </param>
    /// <param name="_writeToInfolog">
    ///     Boolean value that indicates whether policy messages are written to the infolog.
    /// </param>
    /// <returns>
    ///     An array of the policy violations.
    /// </returns>
    static Array showViolationsForExpHdr(RefRecId header, SysPolicyTypeEnum policyType, boolean _writeToInfolog = false)
    {
        container                   c = conNull();
        Array                       arrayViolationsByLine  = new Array(Types::String);
        TrvPolicyViolationsCache    cache;
        TrvPolicyRule               policy;
        int                         i=1;
        str                         msg;
        boolean                     hasJustificationBeenEntered;

        TrvPolicyViolationLevel                 isErrorViolation;
        TrvPolicyViolationJustification         justification;
        TrvPolicyViolationJustificationTypeEnum justificationType;

        if (policyType == SysPolicyTypeEnum::TrvExpensePolicy)
        {
            justificationType = TrvPolicyViolationJustificationTypeEnum::TrvExpHeader;
        }
        else if (policyType == SysPolicyTypeEnum::TrvRequisitionPolicy)
        {
            justificationType = TrvPolicyViolationJustificationTypeEnum::TrvReqHeader;
        }

        // directly read from cache table
        while select Line from cache join policy
                    order by policy.Action desc
                    where cache.Rule == policy.RecId
                       && cache.Header == header
                       && cache.Line == 0
                       && cache.PolicyType == policyType
                       && policy.Action != TrvPolicyViolationLevel::ApproveJustification  // approver justifications should not be shown to expense creator
                       outer join JustifyingWorker, ViolatingRecord, ViolationJustificationType from justification
                            where justification.JustifyingWorker == cache.Worker
                                    && justification.ViolatingRecord == cache.Header && justification.ViolationJustificationType == justificationType
        {
            msg = policy.userMessage();
            hasJustificationBeenEntered = false;

            switch (policy.Action)
            {
                case TrvPolicyViolationLevel::Error :
                    isErrorViolation = TrvPolicyViolationLevel::Error;
                    break;
                case TrvPolicyViolationLevel::Warning :
                    isErrorViolation = TrvPolicyViolationLevel::Warning;
                    break;
                default :
                    if (justification.RecId == 0)
                    {
                        isErrorViolation = TrvPolicyViolationLevel::Error;
                    }
                    else
                    {
                        hasJustificationBeenEntered = true;
                    }
                    break;
            }

            if (!hasJustificationBeenEntered)
            {
                // push into array (to see by line)
                arrayViolationsByLine.value(i,      int642str(cache.Line));
                arrayViolationsByLine.value(i+1,    int2str(enum2int(policy.Action)));
                arrayViolationsByLine.value(i+2,    int2str(enum2int(isErrorViolation)));
                arrayViolationsByLine.value(i+3,    msg);
                i = i+4;

                // push policies in container (to see by policy)
                // same policy cannot break, so just push without checking
                c += [policy.RecId, [1], [policy.Action, msg], [isErrorViolation]];
            }
        }

        if (_writeToInfolog)
        {
            TrvPolicyEvalEngine::throwInfologs(c);
        }

        return arrayViolationsByLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showViolationsForExpLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the policy violations for the specified document or line, and also writes the policy violations messages to the infolog.
    ///     Reads from the cache table, so this doesn't work on documents NOT in draft.
    /// </summary>
    /// <param name="header">
    ///     The <c>RecId</c> of the transaction header.
    /// </param>
    /// <param name="line">
    ///     The <c>RecId</c> of the transaction line. If this value is 0, search all lines for the given header.
    /// </param>
    /// <param name="policyType">
    ///     The policy type, either Expense or Travel requisition.
    /// </param>
    /// <param name="reEvaluatePolicies">
    ///     Boolean value which denotes if policies are to be re-evaluated or to be read from the cache table.
    /// </param>
    /// <param name="_throwOnlyErrors">
    ///     Boolean value that indicates whether non-error violation messages are to be thrown.
    /// </param>
    /// <param name="_writeToInfolog">
    ///     Boolean value that indicates whether policy messages are written to the infolog.
    /// </param>
    /// <param name="_showOnlyHeaderViolations">
    ///     Boolean value that indicates whether only header policy violation messages are written to the infolog.
    /// </param>
    /// <returns>
    ///     An array of the policy violations.
    /// </returns>
    static Array showViolationsForExpLines(RefRecId header, RefRecId line, SysPolicyTypeEnum policyType, boolean reEvaluatePolicies = false, boolean _throwOnlyErrors = false, boolean _writeToInfolog = false, boolean _showOnlyHeaderViolations = false)
    {
        container                   c = conNull();
        Array                       arrayViolationsByLine  = new Array(Types::String);
        TrvPolicyViolationsCache    cache;
        TrvPolicyRule               policy;
        int                         pos, num;
        int                         i=1;
        str                         msg;
        TrvPolicyViolationLevel     isErrorViolation;
        TrvParameters               trvParameters = TrvParameters::find();
        boolean                     hasJustificationBeenEntered;
        utcDateTime                 minValue = DateTimeUtil::minValue();
        utcDateTime                 maxValue = DateTimeUtil::maxValue();

        TrvPolicyViolationJustification         justification;
        TrvPolicyViolationJustificationTypeEnum lineJustificationType;
        TrvPolicyViolationJustificationTypeEnum headerJustificationType;

        if (policyType == SysPolicyTypeEnum::TrvExpensePolicy)
        {
            lineJustificationType = TrvPolicyViolationJustificationTypeEnum::TrvExpLine;
            headerJustificationType = TrvPolicyViolationJustificationTypeEnum::TrvExpHeader;
        }
        else if (policyType == SysPolicyTypeEnum::TrvRequisitionPolicy)
        {
            lineJustificationType = TrvPolicyViolationJustificationTypeEnum::TrvReqLine;
            headerJustificationType = TrvPolicyViolationJustificationTypeEnum::TrvReqHeader;
        }

        // reevaluate policies if needed
        if (reEvaluatePolicies == true && trvParameters.WhenToEvaluatePolicy == TrvEvaluateExpensePolicies::OnLineSave)
        {
            TrvPolicyEvalEngine::evaluateViolationsForHdr(header, policyType);

            if (line == 0)
            {
                TrvPolicyEvalEngine::evaluatePoliciesForAllLines(header, policyType);
            }
            else
            {
                TrvPolicyEvalEngine::evaluateViolationsForLine(Line, policyType);
            }
        }

        // Directly read from cache table for all time states, since its the cache table.
        // If the caller specified line != 0, they're querying for violations on a specific line and NOT the header.
        // In this case, we don't look at header rows.
        // If the caller specified line == 0, they want violations on all lines for a given header, INCLUDING the header.
        // In this case, we need to join the header rows also.
        while select validTimeState(minValue, maxValue) Line from cache
            join policy order by policy.Action desc
                where cache.Rule == policy.RecId
                   && cache.PolicyType == policyType
                   // (line ==/!= 0) nicely short-circuits this expression here so we only get ONE cache.X = x expression in the generated SQL
                   && ((line == 0 && cache.Header == header) || (line != 0 && cache.Line == line))
                   && policy.Action != TrvPolicyViolationLevel::ApproveJustification // approver justifications should not be shown to expense creator
                   && !(policy.Action == TrvPolicyViolationLevel::SubmitJustification && cache.ParentRecId != 0)
            outer join Action, ViolatingRecord, ViolationJustificationType, JustifyingWorker from justification
                where justification.Action == TrvWorkflowAction::Submit
                   && justification.JustifyingWorker == cache.Worker
                   && (((justification.ViolatingRecord == cache.Line || justification.ViolatingRecord == cache.ParentRecId)
                            && justification.ViolationJustificationType == lineJustificationType)
                        // Same trick as above...if (line != 0), we already know we don't need any of the following
                        // expression in the generated SQL, because this expression only helps select the header justification.
                        // Conversely, if (line == 0), we ALSO want to check the header justification
                        // (which has cache.Line == 0) in addition to all the specific lines.
                        || (line == 0
                            && justification.ViolatingRecord == cache.Header
                            && justification.ViolationJustificationType == headerJustificationType
                            && cache.Line == 0)
                      )
        {
            msg = policy.userMessage();
            hasJustificationBeenEntered = false;

            switch (policy.Action)
            {
                case TrvPolicyViolationLevel::Error :
                    isErrorViolation = TrvPolicyViolationLevel::Error;
                    break;

                case TrvPolicyViolationLevel::Warning :
                case TrvPolicyViolationLevel::ApproveJustification :
                    isErrorViolation = TrvPolicyViolationLevel::Warning;
                    break;

                default :
                    if (justification.RecId == 0)
                    {
                        isErrorViolation = TrvPolicyViolationLevel::Error;
                    }
                    else
                    {
                        hasJustificationBeenEntered = true;
                    }
                    break;
            }

            if (!hasJustificationBeenEntered)
            {
                // push into array (to see by line)
                arrayViolationsByLine.value(i,      int642str(cache.Line));
                arrayViolationsByLine.value(i+1,    int2str(enum2int(policy.Action)));
                arrayViolationsByLine.value(i+2,    int2str(enum2int(isErrorViolation)));
                arrayViolationsByLine.value(i+3,    msg);
                i = i+4;

                // push policies in container (to see by policy)
                pos = conFind(c, policy.RecId);
                if (pos)
                {
                    [num]  = conPeek(c, pos+1);
                    c      = conPoke(c, pos+1, [num+1]); // update the count by 1
                }
                else
                {
                    c += [policy.RecId, [1], [policy.Action, msg], [isErrorViolation]];
                }
            }
        }

        if (_writeToInfolog)
        {
            TrvPolicyEvalEngine::throwInfologs(c, _throwOnlyErrors, _showOnlyHeaderViolations);
        }

        return arrayViolationsByLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>throwInfologs</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Writes the policy violation messages to the infolog.
    /// </summary>
    /// <param name="c">
    ///     Container of the policy violations.
    /// </param>
    /// <param name="_throwOnlyErrors">
    ///     Boolean value that indicates whether non-error violation messages are to be thrown.
    /// </param>
    /// <param name="_showOnlyHeaderViolations">
    ///     Boolean value that indicates whether only header policy violation messages are to be thrown.
    /// </param>
    /// <returns>
    ///     True if any error violation was written to the infolog, false otherwise.
    /// </returns>
    public static boolean throwInfologs(container c, boolean _throwOnlyErrors = false, boolean _showOnlyHeaderViolations = false)
    {
        TrvPolicyViolationLevel level;
        int                     i, counts;
        RefRecId                policyRecId;
        str                     msg;
        TrvPolicyViolationLevel   violationLevelIsError;
        boolean                 ret = false;
        TrvPolicyViolationsCache    cache;

        boolean showMessage(TrvPolicyViolationLevel _violationLevelIsError, str _msg)
        {
            boolean returnval = false;

            if (_violationLevelIsError == TrvPolicyViolationLevel::Warning && !_throwOnlyErrors)
            {
                warning(_msg);
            }
            else if (_violationLevelIsError == TrvPolicyViolationLevel::Error)
            {
                error(_msg);
                returnval = true;
            }

            return returnval;
        }

        // the container is of the format:
        // policyId1, [count1], [level1, msg1], [violationLevelIsError1], policyId2, [count2], [level2, msg2], , [isErrorMessage2] ...
        for (i=2; i+1 <= conLen(c); i=i+4)
        {
            // read the policyid, count, level, message
            [policyRecId]  = conPeek(c, i-1);
            [counts]       = conPeek(c, i);
            [level, msg]   = conPeek(c, i+1);
            [violationLevelIsError] = conPeek(c, i+2);

            if (counts > 1)
            {
                msg = msg + " " + strFmt("@SYS111640", counts);
            }

            if (_showOnlyHeaderViolations)
            {
                // to check whether policy violation is exists for expense header
                select Line from cache
                    where cache.rule == policyRecId &&
                          cache.Line == 0;

                if (cache.RecId)
                {
                    ret = showMessage(violationLevelIsError, msg);
                }
            }
            else
            {
                ret = showMessage(violationLevelIsError, msg);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferLineToLog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves the policies violations from the cache table to the log table on the resubmit of the expense
    /// line.
    /// </summary>
    /// <param name="_line">
    /// The record ID of the expense line.
    /// </param>
    /// <param name="policyType">
    /// The policy type.
    /// </param>
    /// <param name="_action">
    /// The workflow action.
    /// </param>
    static void transferLineToLog(RecId _line, SysPolicyTypeEnum policyType, TrvWorkflowAction _action)
    {
        TrvPolicyViolationsLog      violationsLog;
        RecordInsertList            rilViolationsLog;
        TrvPolicyViolationsCache    violationsCache;

        rilViolationsLog = new RecordInsertList(tableNum(TrvPolicyViolationsLog), true);

        while select * from violationsCache
                where violationsCache.Line == _line
                   && violationsCache.PolicyViolationLevel != TrvPolicyViolationLevel::None
        {
            violationsLog.Action = _action;
            violationsLog.Worker = violationsCache.Worker;
            violationsLog.Rule = violationsCache.Rule;
            violationsLog.ViolationDate = violationsCache.ViolationDate;
            violationsLog.Line = violationsCache.Line;
            violationsLog.Header = violationsCache.Header;
            violationsLog.PolicyType = violationsCache.PolicyType;
            rilViolationsLog.add(violationsLog);
        }

        ttsbegin;
        rilViolationsLog.insertDatabase();
        while select forUpdate violationsCache where violationsCache.Line == _line
        {
            violationsCache.delete();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferToLog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves the policies violations from the cache table to the log table on the submission of the
    /// expense report.
    /// </summary>
    /// <param name="header">
    /// The record ID of the transaction header.
    /// </param>
    /// <param name="policyType">
    /// The policy type.
    /// </param>
    /// <param name="_action">
    /// The workflow action.
    /// </param>
    static void transferToLog(RefRecId header, SysPolicyTypeEnum policyType, TrvWorkflowAction _action)
    {
        TrvPolicyViolationsLog      violationsLog;
        RecordInsertList            rilViolationsLog;
        TrvPolicyViolationsCache    violationsCache;
        Common                      commonHeaderRecord;
        TableId                     headerTableId;
        SysDictTable                headerDictTable;
        FieldId                     workerFieldId;
        str                         headerEmployeeRecordFieldName;

        switch (policyType)
        {
            case SysPolicyTypeEnum::TrvExpensePolicy :
                headerTableId = tableNum(TrvExpTable);
                headerEmployeeRecordFieldName = 'CreatingWorker';
                break;

            case SysPolicyTypeEnum::TrvRequisitionPolicy :
                headerTableId = tableNum(TrvRequisitionTable);
                headerEmployeeRecordFieldName = 'CreatingWorker';
                break;

            default:
                break;
        }

        headerDictTable = new SysDictTable(headerTableId);
        if (headerDictTable)
        {
            commonHeaderRecord = headerDictTable.makeRecord();
        }

        workerFieldId =  fieldName2id(headerTableId, headerEmployeeRecordFieldName);

        select commonHeaderRecord where commonHeaderRecord.RecId == header;
        
        rilViolationsLog = new RecordInsertList(tableNum(TrvPolicyViolationsLog));

        ttsbegin;
        while select * from violationsCache
                where violationsCache.Header == header
                   && violationsCache.PolicyViolationLevel != TrvPolicyViolationLevel::None
        {
            violationsLog.Action = _action;
            violationsLog.Worker = commonHeaderRecord.(workerFieldId);
            violationsLog.Rule = violationsCache.Rule;
            violationsLog.ViolationDate = violationsCache.ViolationDate;
            violationsLog.Line = violationsCache.Line;
            violationsLog.Header = violationsCache.Header;
            violationsLog.PolicyType = violationsCache.PolicyType;
            rilViolationsLog.add(violationsLog);
        }

        rilViolationsLog.insertDatabase();
        while select forUpdate violationsCache where violationsCache.Header == header
        {
            violationsCache.delete();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addViolationsFromArrayToList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the violations from source array to target list.
    /// </summary>
    /// <param name="_target">
    /// The target list to which <c>TrvPolicyViolation</c> objects will be added.
    /// </param>
    /// <param name="_source">
    /// The source array containing violations.
    /// </param>
    private static void addViolationsFromArrayToList(List _target, Array _source)
    {
        TrvPolicyViolation trvPolicyViolation;
        int len;

        if (_target && _source)
        {
            len = _source.lastIndex();

            if (len >= 4)
            {
                // Array violations contains lineRecId, actualViolation, adjustedViolation, Message, lineRecId... in that order. Everything is a string.
                for (int i=1; i<=len; i=i+4)
                {
                    trvPolicyViolation = new TrvPolicyViolation();
                    trvPolicyViolation.parmViolationLevel(str2int(_source.value(i+1)));
                    trvPolicyViolation.parmAdjustedViolationLevel(str2int(_source.value(i+2)));
                    trvPolicyViolation.parmViolationMessage(_source.value(i+3));

                    _target.addEnd(trvPolicyViolation);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addViolationsFromContainerToList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the violations from source container to target list.
    /// </summary>
    /// <param name="_target">
    /// The target list to which <c>TrvPolicyViolation</c> objects will be added.
    /// </param>
    /// <param name="_c">
    /// The source container containing violations.
    /// </param>
    private static void addViolationsFromContainerToList(List _target, container _c)
    {
        str                     msg;
        int                     len = conLen(_c);
        TrvPolicyViolationLevel lvl;
        TrvPolicyViolationLevel violationLevelIsError;
        TrvPolicyViolation      trvPolicyViolation;

        if (_target && len >= 4)
        {
            // The container would be like this: [policy.RecId, [1], [policy.Action, policy.userMessage()], [violationLevelIsError]].
            for (int i=1; i<=len; i=i+4)
            {
                [lvl, msg] = conPeek(_c, i+2);
                [violationLevelIsError] = conPeek(_c, i+3);

                trvPolicyViolation = new TrvPolicyViolation();
                trvPolicyViolation.parmViolationLevel(lvl);
                trvPolicyViolation.parmAdjustedViolationLevel(violationLevelIsError);
                trvPolicyViolation.parmViolationMessage(msg);

                _target.addEnd(trvPolicyViolation);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>evaluateViolationsForLineAsync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Will evaluate expense policies for a given expense or travel requisition line.
    /// Evaluates on documents in draft and inserts violations in cache table.
    /// </summary>
    /// <param name = "params">A container that has two values: First, the recId of the line. Second, the type of policy to evaluate..</param>
    /// <param name = "cancellationToken">A cancellation token used to stop this async method call.</param>
    public static void evaluateViolationsForLineAsync(container params, System.Threading.CancellationToken cancellationToken)
    {
        if (conlen(params) != 2)
        {
            error(strFmt("@SYS22828", funcName()));
        }

        RefRecId line = conpeek(params, 1);
        SysPolicyTypeEnum policyType = conpeek(params, 2);

        TrvPolicyEvalEngine::evaluateViolationsForLine(line, policyType);

        if (cancellationToken.IsCancellationRequested)
        {
            cancellationToken.ThrowIfCancellationRequested();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTableIdForPolicyType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the table Id for the main table based on the policy type.
    /// </summary>
    /// <param name = "policyType">The policy type for which to get the table Id</param>
    /// <returns>The table Id for the entity for the policy type.</returns>
    private static TableId getTableIdForPolicyType(SysPolicyTypeEnum policyType)
    {
        if (policyType == SysPolicyTypeEnum::TrvExpensePolicy)
        {
            return tableNum(TrvExpTrans);
        }
        else if (policyType == SysPolicyTypeEnum::TrvRequisitionPolicy)
        {
            return tableNum(TrvRequisitionLine);
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFieldNameForHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the name of the field that holds the foreign key to the main table.
    /// </summary>
    /// <param name = "policyType">The policy type for which to get the name of the field.</param>
    /// <returns>The field name that holds the foreign key to the main table.</returns>
    private static str getFieldNameForHeader(SysPolicyTypeEnum policyType)
    {
        if (policyType == SysPolicyTypeEnum::TrvExpensePolicy)
        {
            return "TrvExpTable";
        }
        else if (policyType == SysPolicyTypeEnum::TrvRequisitionPolicy)
        {
            return "TrvRequisitionTable";
        }

        return "";
    }

]]></Source>
			</Method>
			<Method>
				<Name>evaluatePoliciesForAllLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Will evaluate expense policies on all the lines for the given header record.
    /// </summary>
    /// <param name = "header">The RecId of the document on which to evaluate all lines.</param>
    /// <param name = "policyType">The type of policy to evaluate.</param>
    /// <remarks>This method will take care of multi-threading in case it is beneficial. To the caller it will be a blocking call.
    /// The method will wait until all lines are evaluated before returning.</remarks>
    public static void evaluatePoliciesForAllLines(RefRecId header, SysPolicyTypeEnum policyType)
    {
        Common common;
        boolean runAsync = true;
        System.Threading.Tasks.Task[] tasks;
        System.Collections.Generic.List<System.Threading.Tasks.Task> taskList = new System.Collections.Generic.List<System.Threading.Tasks.Task>();
        System.Threading.Tasks.Task task;
        AsyncTaskResult taskResult;
        SysDictTable    dictTable;
        TableId         lineTableId = TrvPolicyEvalEngine::getTableIdForPolicyType(policyType);
        FieldId         headerRecordFieldId = fieldName2id(lineTableId, TrvPolicyEvalEngine::getFieldNameForHeader(policyType));

        if (policyType == SysPolicyTypeEnum::TrvExpensePolicy)
        {
            if (TrvExpTable::getNumberOfExpenseLines(header) <= 10)
            {
                // If the expense report has less than 10 lines, don't incur the overhead of multi-threading.
                runAsync = false;
            }
        }
        else if (policyType == SysPolicyTypeEnum::TrvRequisitionPolicy)
        {
            if (TrvRequisitionTable::getNumberOfRequisitionLines(header) <= 10)
            {
                runAsync = false;
            }
        }

        dictTable = new SysDictTable(lineTableId);
        if (dictTable)
        {
            common = dictTable.makeRecord();
        }

        while select common
                where common.(headerRecordFieldId) == header
        {
            if (runAsync)
            {
                // Make call to evaluate the policies for the current line async.
                taskList.Add(runAsync(classnum(TrvPolicyEvalEngine), "evaluateViolationsForLineAsync", [common.RecId, policyType], System.Threading.CancellationToken::None));
            }
            else
            {
                TrvPolicyEvalEngine::evaluateViolationsForLine(common.RecId, policyType);
            }
        }

        if ( runAsync && taskList.get_Count() != 0)
        {
            tasks = taskList.ToArray();
            // Wait until all tasks are completed before returning to the caller.
            System.Threading.Tasks.Task::WaitAll(tasks);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>evaluateExpenseLineOnSave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Execute line policy evaluations on line save based on company parameter setting.
    /// </summary>
    /// <param name = "_expTransRecId">The RecId of the expense line to validate.</param>
    public static void evaluateExpenseLineOnSave(RefRecId _expTransRecId)
    {
        TrvParameters   trvParameters = TrvParameters::find();

        if (trvParameters.WhenToEvaluatePolicy == TrvEvaluateExpensePolicies::OnLineSave)
        {
            TrvPolicyEvalEngine::evaluateViolationsForLine(_expTransRecId, SysPolicyTypeEnum::TrvExpensePolicy);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPolicyCheckDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the transaction date to a date time to use for policy evaluation.
    /// </summary>
    /// <param name = "_transactionDate">The date of the transaction.</param>
    /// <returns>The date and time to use in policy evaluation.</returns>
    public static utcdatetime getPolicyCheckDateTime(date _transactionDate)
    {
        // transaction date is a date only field while policies have time as well.
        // we decided to apply all policies created in a day to a line created in that day
        // therefore we set the time of the transaction to the end of the day by adding the corresponding minute, hours.
        utcdatetime applyDate = DateTimeUtil::newDateTime(_transactionDate, 0);
        applyDate = DateTimeUtil::addHours(applyDate, 23);
        applyDate = DateTimeUtil::addMinutes(applyDate, 59);
        applyDate = DateTimeUtil::addSeconds(applyDate, 59);
        // we remove the time zone offset to get the utc since the policy time is in utc
        return DateTimeUtil::removeTimeZoneOffset(applyDate, DateTimeUtil::getUserPreferredTimeZone());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLegalEntityRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Evaluates which legal entity should be used for policy evaluation.
    /// </summary>
    /// <param name="_common">
    /// The record of the current transaction line.
    /// </param>
    /// <param name="_legalEntityFieldId">
    /// The legal entity field Id.
    /// </param>
    /// <param name="_interCompanyLEFieldId">
    /// The inter company legal entity field Id.
    /// </param>
    /// <returns>
    /// Legal entity record identifier.
    /// </returns>
    private static RecId getLegalEntityRecId(Common _common, FieldId _legalEntityFieldId, FieldId _interCompanyLEFieldId)
    {
        RecId   retCompanyLE =  _common.(_legalEntityFieldId);

        boolean isFeatureEnabled = FeatureStateProvider::isFeatureEnabled(TrvPolicyEvalInterCompanyFeature::instance());

        if (isFeatureEnabled && _interCompanyLEFieldId)
        {
            retCompanyLE = CompanyInfo::findDataArea(_common.(_interCompanyLEFieldId)).RecId;

            //If there is no valid data for intercompany field, return value for the legal entity field.
            retCompanyLE = retCompanyLE ? retCompanyLE : _common.(_legalEntityFieldId);
        } 

        return retCompanyLE;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>