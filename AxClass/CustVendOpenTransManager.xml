<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendOpenTransManager</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.CashManagement.Instrumentation;

/// <summary>
/// The <c>CustVendOpenTransManager</c> class is used to manage the business logic that supports the
/// <c>CustOpenTrans</c> and <c>VendOpenTrans</c> forms.
/// </summary>
/// <remarks>
/// This class uses the <c>SpecTransManager</c>, <c>CustVendOpenTransBalances</c>, and
/// <c>CurrencyExchHelper</c> classes.
/// </remarks>
class CustVendOpenTransManager
{
    SpecTransManager specTransManager;
    CustVendOpenTransBalances balances;
    SettleDatePrinc settlePostingType;
    TransDate settlePostingDate;

    CashDiscUsedToCalcDisc dateTypeUsedToCalcDisc;
    TransDate dateUsedToCalcDisc;

    Common originator;
    TableId refTableId;

    CurrencyCode displayCurrency;
    CompanyId displayCompany;
    CurrencyCode displayMstCurrency;
    CurrencyExchangeHelper displayExchRateHelper;

    boolean paymentMarked;
    boolean paymentFromJournal;
    CurrencyCode paymentCurrency;
    CurrencyCode paymentMstCurrency;
    CompanyId paymentCompany;
    TransDate paymentTransDate;
    ExchRate paymentExchRate;

    DirPartyRecId custVendParty;
    AccountNum custVendAccountNum;
    CurrencyCode custVendCurrency;
    CompanyId custVendCompany;

    TransDate discountDate;
    DiscGraceDays graceDays;
    container sharedServiceCompanies;

    CurrencyExchangeHelper transExchRateHelper;

    SysModule module;

    // Maps used for caching companies missing currencies & exchange rates for payment currency
    // Key: CompanyId
    // Value: NoYes value - No = currency/exchange rate not missing, Yes = currency/exchange rate missing
    Map paymentMstCurrencyMissing;
    Map paymentMstExchRateMissing;

    // Map used for caching transaction currencies
    // Key: CompanyId
    // Value: Inner Map used for cache
    // Key: RecId
    // Value: CurrencyCode
    Map custVendTransOpenCurrenciesCache;

    // Map used for caching current cash discount amounts
    // Key: CompanyId
    // Value: Inner Map used for cache
    // Key: RecId
    // Value: CashDiscAmount
    Map custVendTransOpenCashDiscAmountsCache;

    // Map used for caching current cash discount taken amounts
    // Key: CompanyId
    // Value: Inner Map used for cache
    // Key: RecId
    // Value: CashDiscTakenAmount
    Map custVendTransOpenCashDiscTakenCache;

    // Map used for caching largest cash discount amount
    // Key: CompanyId
    // Value: Inner Map used for cache
    // Key: RecId
    // Value: Largest cash discount amount
    Map custVendTransOpenLargestCashDiscCache;

    // Map used for caching CustVendTransCashDisc records
    // Key: [CustVendTransOpen.RecId,
    // Value: Inner map used for cache
    // Key:CustVendTransOpen.UseCashDisc, discountDate, graceDays]
    // Value: CustVendTransCashDisc record
    Map custVendTransCashDiscCache;

    // Map used for caching current cash discount dates
    // Key: CompanyId
    // Value: Inner Map used for cache
    // Key: RecId
    // Value: CashDiscDate
    Map custVendTransOpenCashDiscDateCache;

    Map bankLCCustVendTransCache;

    CashDiscAmount fullSettlementCashDiscount;
    PurchId purchId;
    VendOpenTransForm vendOpenTransForm;

    // <GEERU>
    #isoCountryRegionCodes
    boolean countryRegion_RU;
    // </GEERU>

    // Map used for caching current fine amounts
    // Key: CompanyId
    // Value: Inner Map used for cache
    // Key: RecId
    // Value: FineAmount
    Map custVendTransOpenFineAmountsCache;

    // Map used for caching current interest amounts
    // Key: CompanyId
    // Value: Inner Map used for cache
    // Key: RecId
    // Value: FinInterestAmount
    Map custVendTransOpenInterestAmountsCache;

    boolean skipPrePaymentSettlementWarning;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addCustVendTransOpenCashDiscAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the cash discount amount for the open transaction to the cache.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to track the cash discount amount.
    /// </param>
    /// <param name="_cashDiscAmount">
    /// The cash discount amount to track for the open transaction.
    /// </param>
    private void addCustVendTransOpenCashDiscAmount(
        CustVendTransOpen _custVendTransOpen,
        CashDiscAmount _cashDiscAmount)
    {
        Map innerMap;

        if (custVendTransOpenCashDiscAmountsCache.exists(_custVendTransOpen.company()))
        {
            // Company map exists, get inner map with currencies
            innerMap = custVendTransOpenCashDiscAmountsCache.lookup(_custVendTransOpen.company());

            // Add cash discount amount to cache
            innerMap.insert(_custVendTransOpen.RecId, _cashDiscAmount);

            // Add cash discount map to Company map
            custVendTransOpenCashDiscAmountsCache.insert(_custVendTransOpen.company(), innerMap);
        }
        else
        {
            // Company map doesn't exist, initialize inner map
            innerMap = new Map(Types::Int64, Types::Real);

            // Add cash discount amount to cache
            innerMap.insert(_custVendTransOpen.RecId, _cashDiscAmount);

            // Add cash discount map to Company map
            custVendTransOpenCashDiscAmountsCache.insert(_custVendTransOpen.company(), innerMap);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCustVendTransOpenCashDiscDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the cash discount date for the open transaction to the cache.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to track the cash discount date.
    /// </param>
    /// <param name="_cashDiscDate">
    /// The cash discount date to track for the open transaction.
    /// </param>
    private void addCustVendTransOpenCashDiscDate(
        CustVendTransOpen _custVendTransOpen,
        CashDiscdate _cashDiscDate)
    {
        Map innerMap;

        if (custVendTransOpenCashDiscDateCache.exists(_custVendTransOpen.company()))
        {
            // Company map exists, get inner map with currencies
            innerMap = custVendTransOpenCashDiscDateCache.lookup(_custVendTransOpen.company());

            // Add cash discount amount to cache
            innerMap.insert(_custVendTransOpen.RecId, _cashDiscDate);

            // Add cash discount map to Company map
            custVendTransOpenCashDiscDateCache.insert(_custVendTransOpen.company(), innerMap);
        }
        else
        {
            // Company map doesn't exist, initialize inner map
            innerMap = new Map(Types::Int64, Types::Date);

            // Add cash discount amount to cache
            innerMap.insert(_custVendTransOpen.RecId, _cashDiscDate);

            // Add cash discount map to Company map
            custVendTransOpenCashDiscDateCache.insert(_custVendTransOpen.company(), innerMap);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCustVendTransOpenCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the currency for the open transaction to the cache.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to track the currency.
    /// </param>
    /// <param name="_currency">
    /// The currency to track for the open transaction.
    /// </param>
    private void addCustVendTransOpenCurrency(
        CustVendTransOpen _custVendTransOpen,
        CurrencyCode _currency)
    {
        Map innerMap;

        if (custVendTransOpenCurrenciesCache.exists(_custVendTransOpen.company()))
        {
            // Company map exists, get inner map with currencies
            innerMap = custVendTransOpenCurrenciesCache.lookup(_custVendTransOpen.company());

            // Add currency to cache
            innerMap.insert(_custVendTransOpen.RecId, _currency);

            // Add currency map to Company map
            custVendTransOpenCurrenciesCache.insert(_custVendTransOpen.company(), innerMap);
        }
        else
        {
            // Company map doesn't exist, initialize inner map
            innerMap = new Map(Types::Int64, Types::String);

            // Add currency to cache
            innerMap.insert(_custVendTransOpen.RecId, _currency);

            // Add currency map to Company map
            custVendTransOpenCurrenciesCache.insert(_custVendTransOpen.company(), innerMap);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCustVendTransOpenFineAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the fine amount for the open transaction to the cache.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to track the fine amount.
    /// </param>
    /// <param name="_fineAmount">
    /// The fine amount to track for the open transaction.
    /// </param>
    private void addCustVendTransOpenFineAmount_BR(
                CustVendTransOpen _custVendTransOpen,
                FineAmount_BR _fineAmount)
    {
        Map innerMap;

        if (custVendTransOpenFineAmountsCache.exists(_custVendTransOpen.company()))
        {
            // Company map exists, get inner map with fine amounts
            innerMap = custVendTransOpenFineAmountsCache.lookup(_custVendTransOpen.company());

            // Add fine amount to cache
            innerMap.insert(_custVendTransOpen.RecId, _fineAmount);

            // Add fine amount map to Company map
            custVendTransOpenFineAmountsCache.insert(_custVendTransOpen.company(), innerMap);
        }
        else
        {
            // Company map doesn't exist, initialize inner map
            innerMap = new Map(Types::Int64, Types::Real);

            // Add fine amount to cache
            innerMap.insert(_custVendTransOpen.RecId, _fineAmount);

            // Add fine amount map to Company map
            custVendTransOpenFineAmountsCache.insert(_custVendTransOpen.company(), innerMap);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCustVendTransOpenInterestAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the interest amount for the open transaction to the cache.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to track the interest amount.
    /// </param>
    /// <param name="_interestAmount">
    /// The interest amount to track for the open transaction.
    /// </param>
    private void addCustVendTransOpenInterestAmount_BR(
                CustVendTransOpen _custVendTransOpen,
                FinInterestAmount_BR _interestAmount)
    {
        Map innerMap;

        if (custVendTransOpenInterestAmountsCache.exists(_custVendTransOpen.company()))
        {
            // Company map exists, get inner map with interest amounts
            innerMap = custVendTransOpenInterestAmountsCache.lookup(_custVendTransOpen.company());

            // Add interest amount to cache
            innerMap.insert(_custVendTransOpen.RecId, _interestAmount);

            // Add interest amount map to Company map
            custVendTransOpenInterestAmountsCache.insert(_custVendTransOpen.company(), innerMap);
        }
        else
        {
            // Company map doesn't exist, initialize inner map
            innerMap = new Map(Types::Int64, Types::Real);

            // Add interest amount to cache
            innerMap.insert(_custVendTransOpen.RecId, _interestAmount);

            // Add interest amount map to Company map
            custVendTransOpenInterestAmountsCache.insert(_custVendTransOpen.company(), innerMap);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAndUpdateFine_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Fine amount and Fine Amount Currency
    /// </summary>
    /// <param name="_refCompany">
    /// The company related to the CustOpentransaction that should be updated
    /// </param>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to calculate the fine amount and Fine amount Currency
    /// </param>
    /// <param name="_paymentDate">
    /// The date used to calculate the Fine amount
    /// </param>
    /// <remarks>
    /// if param "_transdate" is null, Fine amount is set to zero
    /// </remarks>
    public void calcAndUpdateFine_BR(CompanyId _refCompany,
                       CustVendTransOpen _custVendTransOpen,
                       TransDate _paymentDate)

    {
        CustVendFine_BR custVendFine;
        FineCalculator_BR fineCalculator;
        CustVendTransOpenData custVendTransOpenData;

        custVendTransOpenData = CustVendTransOpenData::construct(_custVendTransOpen);
        custVendFine = _custVendTransOpen.CustVendTransOpen::custVendFine_BR();

        changecompany(_refCompany)
        {
            fineCalculator = new FineCalculator_BR(custVendFine,
                                                    _paymentDate,
                                                    _custVendTransOpen.DueDate,
                                                    _custVendTransOpen.AmountCur,
                                                    custVendTransOpenData.custVendTrans().CurrencyCode,
                                                    _custVendTransOpen.getCalendarDerivation_BR(),
                                                    _custVendTransOpen.FineAmount_BR);

            // Calculating and updating fine amount
            _custVendTransOpen.FineAmount_BR = fineCalculator.calculate();

            // updating FinInterest Amount Payment Currency
            _custVendTransOpen.FineAmountPaymCur_BR = this.convertAmountTransCurToAmountPaymCur(_custVendTransOpen, _custVendTransOpen.FineAmount_BR);

            //Update settlement amounts including specTrans
            this.updateSettleAmount(_custVendTransOpen, 0);

            // Add amount to cache as most recently calculated value
            this.addCustVendTransOpenFineAmount_BR(_custVendTransOpen, _custVendTransOpen.FineAmount_BR);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAndUpdateInterest_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Interest amount and Interest Amount Currency
    /// </summary>
    /// <param name="_refCompany">
    /// The company related to the CustOpentransaction that should be updated
    /// </param>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to calculate the Interest amount and Interest amount Currency
    /// </param>
    /// <param name="_paymentDate">
    /// The date used to calculate the interest amount
    /// </param>
    /// <remarks>
    /// If param "_paymentDate" is null, Interest amount is set to zero
    /// </remarks>
    public void calcAndUpdateInterest_BR(
                                CompanyId _refCompany,
                                CustVendTransOpen _custVendTransOpen,
                                TransDate _paymentDate)

    {
        CustVendInterest_BR custVendFinInterest;
        InterestCalculator_BR finInterestCalculator;
        CustVendTransOpenData custVendTransOpenData;

        custVendTransOpenData = CustVendTransOpenData::construct(_custVendTransOpen);
        custVendFinInterest = _custVendTransOpen.CustVendTransOpen::custVendInterest_BR();

        changecompany(_refCompany)
        {
            finInterestCalculator = new InterestCalculator_BR(custVendFinInterest,
                                                               _paymentDate,
                                                               _custVendTransOpen.DueDate,
                                                               _custVendTransOpen.AmountCur,
                                                               custVendTransOpenData.custVendTrans().CurrencyCode,
                                                               _custVendTransOpen.getCalendarDerivation_BR(),
                                                               _custVendTransOpen.FineAmount_BR);

            // Calculating and updating interest amount
            _custVendTransOpen.InterestAmount_BR = finInterestCalculator.calculate();

            // updating FinInterest Amount Cur
            _custVendTransOpen.InterestAmountPaymCur_BR = this.convertAmountTransCurToAmountPaymCur(_custVendTransOpen, _custVendTransOpen.InterestAmount_BR);

            //Update settlement amounts including specTrans
            this.updateSettleAmount(_custVendTransOpen, 0);

            // Add amount to cache as most recently calculated value
            this.addCustVendTransOpenInterestAmount_BR(_custVendTransOpen, _custVendTransOpen.InterestAmount_BR);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAndUpdateInterestAndFine_BR</Name>
				<Source><![CDATA[
    internal void calcAndUpdateInterestAndFine_BR(
        CompanyId _refCompany,
        CustVendTransOpen _custVendTransOpen,
        TransDate _paymentDate,
        AmountCur _oldDiscountAmount)
    {
        this.calcAndUpdateFine_BR(_refCompany, _custVendTransOpen, _paymentDate);
        this.calcAndUpdateInterest_BR(_refCompany, _custVendTransOpen, _paymentDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReorganizeTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the specified transaction can be reorganized.
    /// </summary>
    /// <param name="_reorgCustVendTrans">
    /// The transaction to reorganize.
    /// </param>
    /// <returns>
    /// true if the transaction can be reorganized; otherwise, false.
    /// </returns>
    public boolean canReorganizeTrans(CustVendTrans _reorgCustVendTrans)
    {
        boolean canReorganizeTrans = false;

        if (specTransManager.getSpecTransCount() > 0
            && (!#PdsRebateEnabled
                || specTransManager.getSpecTransCount() == 1)
            )
        {
            // If there are marked open transactions, determine whether posted transaction can be reorganized
            changecompany(_reorgCustVendTrans.company())
            {
                switch (_reorgCustVendTrans.TableId)
                {
                    case tableNum(CustTrans):
                        canReorganizeTrans = CustTrans::chkCustTransReorg(originator.TableId, originator.RecId, _reorgCustVendTrans.AccountNum);
                        break;

                    case tableNum(VendTrans):
                        canReorganizeTrans = VendTrans::chkVendTransReorg(originator.TableId, originator.RecId, _reorgCustVendTrans.AccountNum);
                        break;

                    default:
                        Debug::assert(false);
                        break;
                }
            }
        }
        else
        {
            canReorganizeTrans = false;
        }

        return canReorganizeTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDisplayMstCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the monetary standard (MST) currency of the display company exists in the open
    /// transaction company.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to check the MST currency.
    /// </param>
    /// <remarks>
    /// For the <c>LedgerJournalTrans</c> records, the company of the customer or vendor account is used to
    /// determine whether the MST currency exists. For all other records, the company of the record is used.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    /// The MST currency of the display company does not exist in the open transaction company.
    /// </exception>
    protected void checkDisplayMstCurrency(CustVendTransOpen _custVendTransOpen)
    {
        if (!Currency::exist(displayMstCurrency))
        {
            throw error(strFmt("@SYS115657", displayMstCurrency));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForFilteredRecordsWithPaymentGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Compares the passed in container of records to the number of records in the <c>VendTrans</c> table
    /// to verify that they are the same.
    /// </summary>
    /// <param name="_vendPaymentGroup">
    /// The payment group that the records in the container belong to.
    /// </param>
    /// <param name="_containerRecords">
    /// A container of records to be marked that make up all of the visible records on the form.
    /// </param>
    /// <param name="_refCompany">
    /// The company that will be used for cross company selection.
    /// </param>
    /// <param name="_agreementHeaderExtRecId">
    /// The agreement RecId that the records in the _containerRecords container belong to.
    /// </param>
    /// <param name="_debitCreditAll">
    /// debit/Credit sign. Not equal "Unknown" (All) in case this method is called from VendOpenTrans_RU form with two vendOpenTrans data sources? one debit and one credit
    /// </param>
    /// <returns>
    /// true if there are no filtered records; otherwise, false.
    /// </returns>
    protected boolean checkForFilteredRecordsWithPaymentGroup(
        VendPaymentGrouping _vendPaymentGroup,
        List _containerRecords,
        container _refCompany,
        AgreementHeaderExtRecId_RU _agreementHeaderExtRecId = 0,
        DebCredUnknown_RU _debitCreditAll = DebCredUnknown_RU::Unknown)
    {
        VendTrans vendTrans;
        // <GEERU>
        Query query;
        QueryBuildDataSource qbds;
        QueryRun qr;
        int idx;
        RecId dimAttrRecId;
        // </GEERU>

        //unapproved invoices would be filtered, check for this and present a different error first
        select crosscompany:_refCompany count(RecId) from vendTrans
            where vendTrans.VendPaymentGroup == _vendPaymentGroup &&
            vendTrans.Approved == NoYes::No;

        if (vendTrans.RecId > 0)
        {
            error(strFmt("@SYS134713", _vendPaymentGroup));
            return false;
        }

        //otherwise, check for filtered records.
        // <GEERU>
        if (countryRegion_RU)
        {
            query = new Query();
            query.allowCrossCompany(true);
            for (idx = 1; idx <= conLen(_refCompany); idx++)
            {
                query.addCompanyRange(conPeek(_refCompany, idx));
            }

            qbds = query.addDataSource(tableNum(VendTrans));
            qbds.addSelectionField(fieldNum(VendTrans, RecId), SelectionField::Count);
            qbds.addRange(fieldNum(VendTrans, VendPaymentGroup)).value(_vendPaymentGroup);
            qbds.addRange(fieldNum(VendTrans, Closed)).value(queryValue(dateNull()));
            qbds.addRange(fieldNum(VendTrans, Closed)).value(queryValue(dateNull()));
            if (_debitCreditAll == DebCredUnknown_RU::Debit)
            {
                qbds.addRange(fieldNum(VendTrans, RecId)).value('((AmountCur >= 0) || (AmountMST >= 0))');
            }
            else
            if (_debitCreditAll == DebCredUnknown_RU::Credit)
            {
                qbds.addRange(fieldNum(VendTrans, RecId)).value('((AmountCur <= 0) || (AmountMST <= 0))');
            }

            dimAttrRecId = AgreementHeaderExt_RU::getAgreementDimensionAttribute();
            if (dimAttrRecId)
            {
                SysQuery::addDimensionAttributeRange(query,
                    qbds.name(),
                    fieldStr(VendTrans, DefaultDimension),
                    DimensionComponent::DimensionAttribute,
                    _agreementHeaderExtRecId ? AgreementHeaderExt_RU::find(_agreementHeaderExtRecId).AgreementId : SysQuery::valueEmptyString(),
                    DimensionAttribute::find(dimAttrRecId).Name);
            }

            qr = new QueryRun(query);
            if (qr.next())
            {
                vendTrans = qr.get(tableNum(VendTrans));
            }
        }
        else
        {
            // </GEERU>
            select crosscompany:_refCompany count(RecId) from vendTrans
                where vendTrans.VendPaymentGroup == _vendPaymentGroup &&
                vendTrans.Closed == dateNull();
            // <GEERU>
        }
        // </GEERU>

        if (vendTrans.RecId > _containerRecords.elements())
        {
            error(strFmt("@SYS134715", _vendPaymentGroup));
            this.resetMarkedTrans();
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForUnpostInvoicesForPaymentGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the <c>VendInvoiceInfoTable</c> table for unposted invoices with the specified payment group.
    /// </summary>
    /// <param name="_vendPaymentGroup">
    /// The payment group to check for unposted invoices.
    /// </param>
    /// <param name="_refCompany">
    /// The reference company for cross-company queries.
    /// </param>
    /// <returns>
    /// true if there are unposted invoices; otherwise, false.
    /// </returns>
    protected boolean checkForUnpostInvoicesForPaymentGroup(VendPaymentGrouping _vendPaymentGroup, container _refCompany)
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;

        // Check for unposted invoices for this PaymentGroup
        select firstonly crosscompany:_refCompany RecId from vendInvoiceInfoTable
            where vendInvoiceInfoTable.VendPaymentGroup == _vendPaymentGroup &&
                (vendInvoiceInfoTable.ParmJobStatus == ParmJobStatus::ContainErrors || vendInvoiceInfoTable.ParmJobStatus == ParmJobStatus::Waiting);

        if (vendInvoiceInfoTable.RecId > 0)
        {
            error(strFmt("@SYS134713", _vendPaymentGroup));
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPaymentGroupCanBeMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies that the given <c>VendTransOpen</c> record can be marked.
    /// </summary>
    /// <param name="_vendTransOpen">
    /// The <c>VendTransOpen</c> record to verify.
    /// </param>
    /// <returns>
    /// true if the record may be marked; otherwise, false.
    /// </returns>
    protected boolean checkPaymentGroupCanBeMarked(VendTransOpen _vendTransOpen)
    {
        VendTrans vendTrans;
        container refCompany = [_vendTransOpen.company()];

        select firstonly crosscompany:refCompany InvoiceReleaseDate, VendPaymentGroup from vendTrans
                where vendTrans.RecId == _vendTransOpen.RefRecId &&
                    vendTrans.AccountNum == _vendTransOpen.AccountNum;

        if (vendTrans.InvoiceReleaseDate > DateTimeUtil::utcNow())
        {
            error(strFmt("@SYS134714", vendTrans.VendPaymentGroup));
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPaymentGroupIndividualRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs verifications on all records in the container.
    /// </summary>
    /// <param name="_containerRecords">
    /// The list of records that require verification logic.
    /// </param>
    /// <param name="_vendPaymentGroup">
    /// The payment group that is being marked.
    /// </param>
    /// <param name="refCompany">
    /// The reference company for cross company queries.
    /// </param>
    /// <param name="_isPaymentGroupModifyEvent">
    /// true if the method was called due to a payment group value being modified; otherwise, false.
    /// </param>
    /// <returns>
    /// true if the verification passes; otherwise, false.
    /// </returns>
    protected boolean checkPaymentGroupIndividualRecords(List _containerRecords, VendPaymentGrouping _vendPaymentGroup, container refCompany, boolean _isPaymentGroupModifyEvent)
    {
        Enumerator listEnumerator;
        VendTransOpen vendTransOpen;
        int recordCounter = 0;

        listEnumerator = _containerRecords.getEnumerator();

        while (listEnumerator.moveNext())
        {
            //a warning is produced if there is goign to be more than one record marked. A counter needs to be used since the List object doesn't seem to have a length() method.
            recordCounter++;
            //grab the current record
            vendTransOpen = listEnumerator.current();

            //if that record is in use, display an error and return false
            if (specTransManager.existForOtherSpec(vendTransOpen.company(), vendTransOpen.TableId, vendTransOpen.RecId))
            {
                error("@CashManagement:VendPaymentGroupAlreadyMarked");
                return false;
            }

            //Check conditions on the associated vendTrans record.
            if (!this.checkPaymentGroupCanBeMarked(vendTransOpen))
            {
                return false;
            }
        }

        //if there is more than one record in the list, and that group is not already marked, then issue a warning.
        if (recordCounter > 1 && SpecTrans::findNumberOfMarkedVendPaymentGroups(_vendPaymentGroup, originator.company()) == 0 ||
            (recordCounter > 1 && SpecTrans::findNumberOfMarkedVendPaymentGroups(_vendPaymentGroup, originator.company()) == 1 && _isPaymentGroupModifyEvent))
        {
            warning(strFmt("@SYS134747", _vendPaymentGroup));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkRemittanceTransCanBeMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies that the transaction can be marked for settlement.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The <c>CustVendTransOpen</c> record to be marked.
    /// </param>
    /// <returns>
    /// true if the payment group may be marked; otherwise, false.
    /// </returns>
    public boolean checkRemittanceTransCanBeMarked(CustVendTransOpen _custVendTransOpen)
    {
        boolean remittanceTransCanBeMarked = true;
        LedgerJournalTrans ledgerJournalTrans;
        VendParameters vendParameters = VendParameters::find();

        switch (originator.TableId)
        {
            case tableNum(LedgerJournalTrans):
                ledgerJournalTrans = originator;

                if (!vendParameters.EnableSettlementAllRemittanceAddress
                    && ledgerJournalTrans.RemittanceLocation
                    && ledgerJournalTrans.RemittanceLocation != VendTrans::findByCompany(_custVendTransOpen.company(), _custVendTransOpen.RefRecId).RemittanceLocation)
                {
                    remittanceTransCanBeMarked = false;
                }

                break;

            case tableNum(VendTable), tableNum(VendTrans):
                if (!vendParameters.EnableSettlementAllRemittanceAddress
                    && !this.isRemittanceLocationValidForSettlement(VendTrans::findByCompany(_custVendTransOpen.company(), _custVendTransOpen.RefRecId).RemittanceLocation))
                {
                    remittanceTransCanBeMarked = false;
                }

                break;
        }

        if (!remittanceTransCanBeMarked)
        {
            //Location on marked transaction and the passed-in transaction do not match; cannot mark the transaction
            checkFailed("@SYS152832");
        }

        return remittanceTransCanBeMarked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUnmarkingVendPaymentGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Iterates the passed in container and displays warning messages if multiple records will be changed by the marking operation.
    /// </summary>
    /// <param name="_recordsToBeUnMarked">
    /// A container of VendTransOpen records that are going to be un-marked.
    /// </param>
    /// <param name="_vendPaymentGroup">
    /// The payment group that is having its marked status changed.
    /// </param>
    /// <param name="_markTrans">
    /// Yes if a mark operation is being performed; otherwise, No.
    /// </param>
    /// <param name="_numInvoicesMarked">
    /// The number of invoices that are currently marked.
    /// </param>
    /// <returns>
    /// true if a warning was presented; otherwise, false.
    /// </returns>
    protected boolean checkUnmarkingVendPaymentGroup(container _recordsToBeUnMarked, VendPaymentGrouping _vendPaymentGroup, NoYes _markTrans, int _numInvoicesMarked)
    {
        List recordsToBeUnMarkedList;
        Enumerator recordsToBeUnMarkedEnum;
        VendTransOpen tmpVendTransOpen;
        VendTrans vendTrans;
        int numPaymentGroups = 0;
        int numNonPaymentGroups = 0;
        boolean ret = false;

        recordsToBeUnMarkedList = con2List(_recordsToBeUnMarked);
        recordsToBeUnMarkedEnum = recordsToBeUnMarkedList.getEnumerator();

        while (recordsToBeUnMarkedEnum.moveNext() && numPaymentGroups < 2)
        {
            tmpVendTransOpen = recordsToBeUnMarkedEnum.current();

            select firstonly crossCompany VendPaymentGroup from vendTrans
                where vendTrans.RecId == tmpVendTransOpen.RefRecId;

            //this keeps track of the number of records that have more than one payment group that are encountered.
            if (vendTrans.VendPaymentGroup != '')
            {
                numPaymentGroups++;
            }
            else
            {
                numNonPaymentGroups++;
            }

            //if markTrans is Yes then we are marking the record and need to check for that resulting in a payment group being unmarked.
            if (_markTrans == NoYes::Yes)
            {
                //if we have at least one payment group that is being unmarked due to marking a settlement that does not have a payment group, we want to display a warning.
                if (_vendPaymentGroup == '' && numPaymentGroups == 1)
                {
                    warning(strFmt("@SYS135277", vendTrans.VendPaymentGroup));
                    ret = true;
                }
            }
            else
            {
                //if we are unmarking a payment group and other records with that payment group will be unmarked as a result, we want to display a warning.
                if (_vendPaymentGroup != '' && numPaymentGroups == 2)
                {
                    warning(strFmt("@SYS135316", _vendPaymentGroup));
                    ret = true;
                }
            }
        }

        //
        //Generally we get an error message if a group is marked that has more than one Payment Group assigned. We need to catch the situation where the payment group
        //only has one invoice in it, and there is a marked invoice without a payment group.
        //
        if (numNonPaymentGroups > 0 && _markTrans == NoYes::Yes && _vendPaymentGroup != '' && _numInvoicesMarked == 1)
        {
            warning(strFmt("@SYS134747", _vendPaymentGroup));
            ret = true;
        }

        //
        //We need to catch the situation where a payment group is being unmarked because another payment group is selected.
        //This message is already thrown if the payment group being marked has more than one invoice. As a result we want to throw this message
        //if and only if there is only one invoice in the payment group being marked.
        //
        select count(RecId) from vendTrans
            where vendTrans.VendPaymentGroup == _vendPaymentGroup;

        if (_vendPaymentGroup != '' && numPaymentGroups > 0 && _markTrans == NoYes::Yes && vendTrans.RecId == 1)
        {
            warning(strFmt("@SYS134747", _vendPaymentGroup));
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearAllCashDiscountCaches</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears all the cash discount internal caches.
    /// </summary>
    public void clearAllCashDiscountCaches()
    {
        custVendTransOpenCashDiscAmountsCache = new Map(Types::String, Types::Class);
        custVendTransOpenCashDiscDateCache = new Map(Types::String, Types::Class);
        custVendTransOpenCashDiscTakenCache = new Map(Types::String, Types::Class);
        custVendTransOpenLargestCashDiscCache = new Map(Types::String, Types::Class);
        custVendTransCashDiscCache = new Map(Types::Container, Types::Class);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCashDiscountCaches</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the cash discount internal caches that are associated with the open transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to find the cash discount transaction.
    /// </param>
    public void clearCashDiscountCaches(CustVendTransOpen _custVendTransOpen)
    {
        Map innerMap;
        container key = [_custVendTransOpen.RecId, _custVendTransOpen.company()];

        // Discounts have been changed need to clear the discount caches

        // Clear largest cash discount cache
        if (custVendTransOpenLargestCashDiscCache.exists(_custVendTransOpen.company()))
        {
            // Get Company map
            innerMap = custVendTransOpenLargestCashDiscCache.lookup(_custVendTransOpen.company());

            if (innerMap.exists(_custVendTransOpen.RecId))
            {
                // Remove from inner map
                innerMap.remove(_custVendTransOpen.RecId);

                // Update Company map
                custVendTransOpenLargestCashDiscCache.insert(_custVendTransOpen.company(), innerMap);
            }
        }

        // Clear the discount amount cache
        if (custVendTransOpenCashDiscAmountsCache.exists(_custVendTransOpen.company()))
        {
            // Get Company map
            innerMap = custVendTransOpenCashDiscAmountsCache.lookup(_custVendTransOpen.company());

            if (innerMap.exists(_custVendTransOpen.RecId))
            {
                // Remove from inner map
                innerMap.remove(_custVendTransOpen.RecId);

                // Update Company map
                custVendTransOpenCashDiscAmountsCache.insert(_custVendTransOpen.company(), innerMap);
            }
        }

        // Clear the CustTransCashDisc record cache
        if (custVendTransCashDiscCache.exists(key))
        {
            // remove from map, which will remove the inner map
            custVendTransCashDiscCache.remove(key);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearPrimaryPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the class variables that are used to track a primary payment when it is unmarked.
    /// </summary>
    /// <remarks>
    /// When a primary payment is unmarked, the display currency is set to the currency of the customer or
    /// vendor.
    /// </remarks>
    protected void clearPrimaryPayment()
    {
        // Clear primary tracking variables
        if (!paymentFromJournal)
        {
            paymentMarked = false;
            paymentExchRate = 0;
            paymentTransDate = dateNull();
            graceDays = 0;

            this.setPaymentCurrency('', '', '');

            displayCompany = custVendCompany;
            displayCurrency = custVendCurrency;
            discountDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

            dateTypeUsedToCalcDisc = CashDiscUsedToCalcDisc::TransactionDate;
            dateUsedToCalcDisc = dateNull();

            // Reset exchange rate helper to customer/vendor
            displayExchRateHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(displayCompany).RecId));
            displayExchRateHelper.parmExchangeDate(dateNull());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertAmountPaymCurToAmountTransCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the specified amount from the payment currency to the currency of the open transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction from which to obtain the currency.
    /// </param>
    /// <param name="_amountPaymCur">
    /// The amount to convert to the currency of the open transaction.
    /// </param>
    /// <returns>
    /// The specified amount converted to the currency of the open transaction.
    /// </returns>
    public AmountCur convertAmountPaymCurToAmountTransCur(CustVendTransOpen _custVendTransOpen, AmountCur _amountPaymCur)
    {
        CurrencyCode transCurrency;
        SpecTrans specTrans;
        AmountCur amountTransCur;
        AmountCur interimAmount;
        CurrencyCode transMstCurrency;

        // Get the currency for the open transaction
        transCurrency = this.getCustVendTransOpenCurrency(_custVendTransOpen);

        // Get the SpecTrans related to the open transaction
        specTrans = specTransManager.findByRef(_custVendTransOpen.company(), _custVendTransOpen.TableId, _custVendTransOpen.RecId);

        if (transCurrency == paymentCurrency)
        {
            // Currencies are the same between the marked transaction & the payment
            amountTransCur = _amountPaymCur;
        }
        else if (specTrans.RecId != 0 && specTrans.CrossRate != 0)
        {
            // Cross rate is specified, convert directly from payment to marked transaction currency
            amountTransCur = CurrencyExchange::round(
                CurrencyExchange::calculateAmount(
                    _amountPaymCur,
                    ExchangeRateCalculation::calculateReciprocalExchangeRate(specTrans.CrossRate)),
                transCurrency);
        }
        else
        {
            // Convert from payment currency to payment company currency
            if (paymentExchRate != 0)
            {
                // If an exchange rate was specified for the payment use to convert from payment to payment company currency
                displayExchRateHelper.parmExchangeRate1(paymentExchRate);
            }

            interimAmount = displayExchRateHelper.calculateTransactionToAccounting(paymentCurrency, _amountPaymCur, false);

            transExchRateHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(_custVendTransOpen.company()).RecId));
            transExchRateHelper.parmExchangeDate(paymentTransDate);

            if (paymentCompany != _custVendTransOpen.company())
            {
                // Convert from payment company currency to trans company currency
                changecompany(_custVendTransOpen.company())
                {
                    // Get trans company currency
                    transMstCurrency = CompanyInfoHelper::standardCurrency();
                }

                if (paymentMstCurrency != transMstCurrency)
                {
                    if (this.existPaymMstCurrencyExchRate(_custVendTransOpen.company()))
                    {
                        interimAmount = transExchRateHelper.calculateTransactionToAccounting(paymentMstCurrency, interimAmount, false);
                    }
                }
            }

            // Convert from trans company currency to trans currency

            amountTransCur = transExchRateHelper.calculateAccountingToTransaction(transCurrency, interimAmount, true);
        }

        return amountTransCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertAmountTransCurToAmountPaymCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the specified amount from the currency of the open transaction to the currency of the
    /// payment.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction from which to retrieve the currency.
    /// </param>
    /// <param name="_amountTransCur">
    /// The amount to convert to the payment currency.
    /// </param>
    /// <returns>
    /// The specified amount converted to the currency of the open transaction.
    /// </returns>
    public AmountCur convertAmountTransCurToAmountPaymCur(CustVendTransOpen _custVendTransOpen, AmountCur _amountTransCur)
    {
        CurrencyCode transCurrency;
        SpecTrans specTrans;
        AmountCur amountPaymCur;
        AmountCur interimAmount;
        CurrencyCode transMstCurrency;

        // Get the currency for the open transaction
        transCurrency = this.getCustVendTransOpenCurrency(_custVendTransOpen);

        // Get the SpecTrans related to the open transaction
        specTrans = specTransManager.findByRef(_custVendTransOpen.company(), _custVendTransOpen.TableId, _custVendTransOpen.RecId);

        if (transCurrency == paymentCurrency)
        {
            // Currencies are the same between the marked transaction & the payment
            amountPaymCur = _amountTransCur;
        }
        else if (specTrans.RecId != 0 && specTrans.CrossRate != 0)
        {
            // Cross rate is specified, convert directly from payment to marked transaction currency
            amountPaymCur = CurrencyExchange::round(CurrencyExchange::calculateAmount(_amountTransCur, specTrans.CrossRate), paymentCurrency);
        }
        else
        {
            // Convert from transaction currency to transaction company currency
            transExchRateHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(_custVendTransOpen.company()).RecId));
            transExchRateHelper.parmExchangeDate(paymentTransDate);
            interimAmount = transExchRateHelper.calculateTransactionToAccounting(transCurrency, _amountTransCur, false);

            if (paymentCompany != _custVendTransOpen.company())
            {
                // Convert from transaction company currency to payment company currency
                changecompany(_custVendTransOpen.company())
                {
                    // Get trans company currency
                    transMstCurrency = CompanyInfoHelper::standardCurrency();
                }

                if (transMstCurrency != paymentMstCurrency)
                {
                    if (this.existPaymMstCurrencyExchRate(_custVendTransOpen.company()))
                    {
                        interimAmount = transExchRateHelper.calculateAccountingToTransaction(paymentMstCurrency, interimAmount, false);
                    }
                }
            }

            // Convert from payment company currency to payment currency

            if (paymentExchRate != 0)
            {
                displayExchRateHelper.parmExchangeRate1(paymentExchRate);
            }

            amountPaymCur = displayExchRateHelper.calculateAccountingToTransaction(paymentCurrency, interimAmount, true);
        }

        return amountPaymCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLookupForAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the agreements lookup.
    /// </summary>
    /// <param name="_ctrl">
    /// The control for which lookup will be created.
    /// </param>
    /// <param name="_tableId">
    /// The cursor type identifier.
    /// </param>
    public void createLookupForAgreement(
        FormStringControl _ctrl,
        TableId _tableId)
    {
        PurchTable purchTable;
        SalesTable salesTable;

        if (_tableId == tableNum(CustTrans))
        {
            salesTable.CustAccount = custVendAccountNum;
            SalesAgreementHeader::salesAgreementLookup(_ctrl, salesTable, '', true);
        }
        else if (_tableId == tableNum(VendTrans))
        {
            purchTable.OrderAccount = custVendAccountNum;
            PurchAgreementHeader::purchAgreementLookup(_ctrl, purchTable, '', true);
        }
        else
        {
            throw error("@SYS104799");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxWithholding</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a tax withholding record for the specified <c>VendTransOpen</c> record.
    /// </summary>
    /// <param name="_vendTransOpen">
    /// The record whose values should be used to create the tax withholding record.
    /// </param>
    /// <param name="_taxWithhold">
    /// The <c>TaxWithhold</c> object to use to create the tax withhold record.
    /// </param>
    /// <remarks>
    /// This is called from the <c>VendPaymentGroupUpdateTransMarked</c> method and is used to perform form
    /// level code that is not done when the Payment Group marking process is used.
    /// </remarks>
    [Wrappable(true)]
    protected final void createTaxWithholding(CustVendTransOpen _vendTransOpen, TaxWithhold _taxWithhold)
    {
        VendTrans vendTrans;

        changecompany(_vendTransOpen.company())
        {
            //get the associated vendTrans record.
            select firstonly vendTrans
                where vendTrans.RecId == _vendTransOpen.RefRecId;

            //If the _taxWithhold object is not null then create the taxWithholding record using the _taxWithhold object.
            if (_taxWithhold != null)
            {
                _taxWithhold.createTaxWithholdTrans(
                    vendTrans,
                    this.getSpecTrans(_vendTransOpen),
                    this.getSettleAmount(_vendTransOpen) + this.getCashDiscAmountToTake(_vendTransOpen),
                    this.getSpecTrans(_vendTransOpen).CrossRate);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineCashDiscAmountToTake</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the cash discount amount to take that corresponds to the open transaction in the
    /// transaction currency.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to get the cash discount amount.
    /// </param>
    /// <param name="_validateDiscOnCreditNote">
    /// A Boolean value that indicates whether to validate if discounts are enabled on credit notes.
    /// </param>
    /// <returns>
    /// The cash discount amount to take for the open transaction.
    /// </returns>
    /// <remarks>
    /// The cash discount to take is calculated as the discount amount minus the discount taken. The cash
    /// discount to take will be zero when the use cash discount is never, or the open transaction is a
    /// credit note and discount is not enabled on credit notes.
    /// </remarks>
    protected CashDiscAmount determineCashDiscAmountToTake(CustVendTransOpen _custVendTransOpen, boolean _validateDiscOnCreditNote)
    {
        CashDiscAmount cashDiscAmountToTake;
        CashDiscAmount fullCashDiscAmount;
        CustVendCashDiscountHelper cashDiscountHelper;

        // Get the full discount amount and discount already taken
        fullCashDiscAmount = this.getCustVendTransOpenCashDiscAmount(_custVendTransOpen);

        cashDiscountHelper = CustVendCashDiscountHelper::construct(_custVendTransOpen);
        cashDiscountHelper.parmFullCashDiscountForTier(fullCashDiscAmount);
        cashDiscountHelper.parmDiscountDate(discountDate);
        cashDiscountHelper.parmGraceDays(graceDays);
        cashDiscountHelper.parmCashDiscountTaken(this.getCashDiscAmountTaken(_custVendTransOpen));
        cashDiscountHelper.parmLargestCashDiscount(this.getCashDiscLargestAmount(_custVendTransOpen));
        cashDiscAmountToTake = cashDiscountHelper.determineCashDiscForOpenAmount();

        if (this.getFullSettlement(_custVendTransOpen))
        {
            fullSettlementCashDiscount = this.convertAmountPaymCurToAmountTransCur(_custVendTransOpen, balances.getMarkedTotalDisplayCur());
            cashDiscAmountToTake = fullSettlementCashDiscount + cashDiscAmountToTake;
        }

        return cashDiscAmountToTake;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existPaymMstCurrencyExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the MST currency of the payment company and an exchange rate for this currency
    /// exist in the given company.
    /// </summary>
    /// <param name="_company">
    /// The company to check.
    /// </param>
    /// <returns>
    /// true if the currency and an exchange rate exist in the given company; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method will cause exceptions for a missing currency or exchange rate one time per company per
    /// instance.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    /// The MST currency of the payment company does not exist in the given company.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// An exchange rate for the MST currency of the payment company does not exist in the given company.
    /// </exception>
    private boolean existPaymMstCurrencyExchRate(CompanyId _company)
    {
        boolean doExist = true;
        ExchRate exchRate;

        if (!paymentMstCurrencyMissing.exists(_company))
        {
            // The company hasn't been checked for existence of the payment MST currency
            if (!Currency::exist(paymentMstCurrency))
            {
                // Add to cache as missing
                paymentMstCurrencyMissing.insert(_company, NoYes::Yes);

                // Only throw currency missing error once per company
                throw error(strFmt("@SYS125521",
                    paymentMstCurrency,
                    tableStr(Currency),
                    _company));
            }
            else
            {
                // Add to cache as not missing
                paymentMstCurrencyMissing.insert(_company, NoYes::No);
            }
        }

        if (paymentMstCurrencyMissing.exists(_company) &&
            paymentMstCurrencyMissing.lookup(_company) == NoYes::No)
        {
            // Currency exists in the transaction company
            if (!paymentMstExchRateMissing.exists(_company))
            {
                // The company hasn't been checked for existence of payment MST exch rate
                changecompany(_company)
                {
                    exchRate = ExchangeRateHelper::getCrossRate_Static(
                        Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                        paymentMstCurrency,
                        DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

                    if (exchRate == 0)
                    {
                        // Add to cache as missing
                        paymentMstExchRateMissing.insert(_company, NoYes::Yes);

                        // Only throw exchange rate missing error once per company
                        throw error(strFmt("@SYS125524",
                            paymentMstCurrency,
                            tableStr(ExchangeRate),
                            _company));
                    }
                    else
                    {
                        // Add to cache as not missing
                        paymentMstExchRateMissing.insert(_company, NoYes::No);
                    }
                }
            }
        }

        if ((paymentMstCurrencyMissing.exists(_company) && paymentMstCurrencyMissing.lookup(_company) == NoYes::Yes) ||
            (paymentMstExchRateMissing.exists(_company) && paymentMstExchRateMissing.lookup(_company) == NoYes::Yes))
        {
            // Error has been thrown, for subsequent calls, just return false.
            doExist = false;
        }

        return doExist;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existTransWithDifferentVendBank</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the marked records contain different vendor bank accounts.
    /// </summary>
    /// <returns>
    /// true if marked record contains different vendor bank accounts; otherwise, false.
    /// </returns>
    public boolean existTransWithDifferentVendBank()
    {
        return vendOpenTransForm.existTransWithDiffVendBankOnMark();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAllowCashDiscOnCreditNote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>CashDiscForCreditNote</c> parameter.
    /// </summary>
    /// <param name="_company">
    /// The company ID of the parameter.
    /// </param>
    /// <returns>
    /// The <c>CashDiscForCreditNote</c> parameter.
    /// </returns>
    protected boolean findAllowCashDiscOnCreditNote(CompanyId _company)
    {
        CustParameters custParameters;
        VendParameters vendParameters;
        boolean allowCashDiscountForCreditNote;

        changecompany(_company)
        {
            // Get the specific/unspecific setting for the transaction company
            switch (module)
            {
                case SysModule::Cust:
                    custParameters = CustParameters::find();
                    allowCashDiscountForCreditNote = custParameters.CashDiscForCreditNote;
                    break;

                case SysModule::Vend:
                    vendParameters = VendParameters::find();
                    allowCashDiscountForCreditNote = vendParameters.CashDiscForCreditNote;
                    break;
            }
        }
        return allowCashDiscountForCreditNote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAnyPrimaryPayments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds if there are any payments marked as primary
    /// </summary>
    /// <returns>
    /// True if any primary payments are found, else false
    /// </returns>
    public boolean findAnyPrimaryPayments()
    {
        SpecTrans primaryPaymentFound;
        boolean result;

        primaryPaymentFound = specTransManager.findByMarkedPayment();
        if (primaryPaymentFound)
        {
            result = true;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankLCCustVendEmptyBuffer</Name>
				<Source><![CDATA[
    private container getBankLCCustVendEmptyBuffer()
    {
        BankLCCustVendTrans bankLCCustVendTrans;
        CustVendTrans custVendTrans;
        LedgerJournalTrans ledgerJournalTrans;

        if(originator.TableId == tableNum(LedgerJournalTrans))
        {
            ledgerJournalTrans = originator;

            switch (ledgerJournalTrans.AccountType)
            {
                case LedgerJournalACType::Cust:
                    bankLCCustVendTrans = new DictTable(tableNum(BankLCCustTrans)).makeRecord();
                    custVendTrans = new DictTable(tableNum(CustTrans)).makeRecord();
                    break;

                case LedgerJournalACType::Vend:
                    bankLCCustVendTrans = new DictTable(tableNum(BankLCVendTrans)).makeRecord();
                    custVendTrans = new DictTable(tableNum(VendTrans)).makeRecord();
                    break;
            }
        }

        return [bankLCCustVendTrans, custVendTrans];
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAnyBankLCNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds if there are any bank LC numbers to show on the form.
    /// </summary>
    /// <returns>
    /// True if any bank LC numbers are found; otherwise false.
    /// </returns>
    public boolean findAnyBankLCNumber()
    {
        BankLCCustVendTrans bankLCCustVendTrans;
        CustVendTrans custVendTrans;

        [bankLCCustVendTrans, custVendTrans] = this.getBankLCCustVendEmptyBuffer();

        select firstonly RecId from custVendTrans
            exists join bankLCCustVendTrans
                where bankLCCustVendTrans.BankLCLine == custVendTrans.BankLCLine
                    && bankLCCustVendTrans.BankLCNumber
                    && custVendTrans.AccountNum == custVendAccountNum;

        return custVendTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAnyBankLCShipmentLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds if there are any bank LC shipments to show on the form.
    /// </summary>
    /// <returns>
    /// True if any bank LC shipments are found; otherwise false.
    /// </returns>
    public boolean findAnyBankLCShipmentLineNum()
    {
        CustVendTrans custVendTrans;
        BankLCCustVendTrans bankLCCustVendTrans;

        [bankLCCustVendTrans, custVendTrans] = this.getBankLCCustVendEmptyBuffer();

        select firstonly RecId from custVendTrans
            exists join bankLCCustVendTrans
                where bankLCCustVendTrans.BankLCLine == custVendTrans.BankLCLine
                    && bankLCCustVendTrans.LineNum
                    && custVendTrans.AccountNum == custVendAccountNum;

        return custVendTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findApplicableCustVendTransCashDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the applicable cash discount transaction based on the <c>UseCashDisc</c> field of the open
    /// transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to find the cash discount transaction.
    /// </param>
    /// <returns>
    /// The <c>CustVendTransCashDisc</c> record found.
    /// </returns>
    /// <remarks>
    /// If the <c>UseCashDisc</c> field is set to <c>Never</c>, this method returns the cash discount
    /// transaction that corresponds to the due date.
    /// </remarks>
    public CustVendTransCashDisc findApplicableCustVendTransCashDisc(CustVendTransOpen _custVendTransOpen)
    {
        CustVendTransCashDisc custVendTransCashDisc;
        Map innerMap;
        container key = [_custVendTransOpen.RecId, _custVendTransOpen.company()];
        container innerMapKey = [_custVendTransOpen.UseCashDisc, discountDate, graceDays];

        if (custVendTransCashDiscCache.exists(key))
        {
            // Company map exists, get inner map with largest cash discount
            innerMap = custVendTransCashDiscCache.lookup(key);

            if (innerMap.exists(innerMapKey))
            {
                // CustVendTransCashDisc exists in cache
                custVendTransCashDisc = innerMap.lookup(innerMapKey);
            }
            else
            {
                // find in database
                custVendTransCashDisc = CustVendOpenTransManager::findApplicableCashDisc_Server(_custVendTransOpen, discountDate, graceDays);

                // add to cache
                innerMap.insert(innerMapKey, custVendTransCashDisc);

                // Add to record, company map
                custVendTransCashDiscCache.insert(key, innerMap);
            }
        }
        else
        {
            // not in cache, find in database
            custVendTransCashDisc = CustVendOpenTransManager::findApplicableCashDisc_Server(_custVendTransOpen, discountDate, graceDays);

            // Company map doesn't exist, initialize inner map
            innerMap = new Map(Types::Container, Types::Record);

            // Track cash discount for open transaction
            innerMap.insert(innerMapKey, custVendTransCashDisc);

            // Add to record, company map
            custVendTransCashDiscCache.insert(key, innerMap);
        }

        return custVendTransCashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustDiscountGraceDays</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the discount grace days for the specified method of payment.
    /// </summary>
    /// <param name="_companyId">
    /// The company that is associated with the method of payment.
    /// </param>
    /// <param name="_paymMode">
    /// The method of payment for which to find the discount grace days.
    /// </param>
    /// <returns>
    /// The discount grace days for the method of payment.
    /// </returns>
    protected DiscGraceDays findCustDiscountGraceDays(CompanyId _companyId, PaymMode _paymMode)
    {
        DiscGraceDays foundGraceDays = 0;

        changecompany(_companyId)
        {
            foundGraceDays = CustPaymModeTable::discGraceDays(_paymMode);
        }

        return foundGraceDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findVendDiscountGraceDays</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the discount grace days for the specified method of payment.
    /// </summary>
    /// <param name="_companyId">
    /// The company that is associated with the method of payment.
    /// </param>
    /// <param name="_paymMode">
    /// The method of payment for which to find discount grace days.
    /// </param>
    /// <returns>
    /// The discount grace days for the method of payment.
    /// </returns>
    protected DiscGraceDays findVendDiscountGraceDays(CompanyId _companyId, PaymMode _paymMode)
    {
        DiscGraceDays foundGraceDays = 0;

        changecompany(_companyId)
        {
            foundGraceDays = VendPaymModeTable::discGraceDays(_paymMode);
        }

        return foundGraceDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDisplayFactorForCustVendTransOpen</Name>
				<Source><![CDATA[
    private ExchangeRateDisplayFactor findDisplayFactorForCustVendTransOpen(CustVendTransOpen _custVendTransOpen)
    {
        CustVendTrans custVendTrans = CustVendTrans::getEmptyTableBuffer(_custVendTransOpen.CustVendTransOpen::getModule());

        select firstonly CurrencyCode from custVendTrans
            where custVendTrans.RecId == _custVendTransOpen.RefRecId;

        ExchangeRateDisplayFactor displayFactor = ExchangeRateCurrencyPair::getExchangeRateDisplayFactor(
            custVendTrans.CurrencyCode,
            paymentCurrency,
            Ledger::find(Ledger::primaryLedger(CompanyInfo::findDataArea(displayCompany).RecId)).DefaultExchangeRateType,
            true);

        return displayFactor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the currently effective cash discount amount that corresponds to the open transaction.
    /// </summary>
    /// <param name = "_custVendTransOpen">
    /// Currently selected cash discount amount
    /// </param>
    /// <returns>
    /// The cash discount amount
    /// </returns>
    public CashDiscAmount getCashDiscAmount(CustVendTransOpen _custVendTransOpen)
    {
        CashDiscAmount cashDiscAmount;

        cashDiscAmount = this.getCustVendTransOpenCashDiscAmount(_custVendTransOpen);

        return cashDiscAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the currently effective cash discount date that corresponds to the open transaction.
    /// </summary>
    /// <param name = "_custVendTransOpen">
    /// Currently selected cash discount amount
    /// </param>
    /// <returns>
    /// The cash discount amount
    /// </returns>
    public CashDiscdate getCashDiscDate(CustVendTransOpen _custVendTransOpen)
    {
        CashDiscdate cashDiscDate;

        cashDiscDate = this.getCustVendTransOpenCashDiscDate(_custVendTransOpen);

        return cashDiscDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankLCCustVendTrans</Name>
				<Source><![CDATA[
    private BankLCCustVendTrans getBankLCCustVendTrans(CustVendTrans _custVendTrans)
    {
        BankLCCustVendTrans bankLCCustVendTrans;

        if (bankLCCustVendTransCache.exists([_custVendTrans.TableId, _custVendTrans.RecId]))
        {
            bankLCCustVendTrans = bankLCCustVendTransCache.lookup([_custVendTrans.TableId, _custVendTrans.RecId]);
        }
        else
        {
            bankLCCustVendTrans = _custVendTrans.CustVendTrans::getBankLCCustVendTrans();
            bankLCCustVendTransCache.insert([_custVendTrans.TableId, _custVendTrans.RecId], bankLCCustVendTrans);
        }

        return bankLCCustVendTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankLCNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the bank document number that corresponds to the current transaction.
    /// </summary>
    /// <param name = "_custVendTrans">
    /// Currently selected transaction.
    /// </param>
    /// <returns>
    /// The bank document number.
    /// </returns>
    public BankLCNumber getBankLCNumber(CustVendTrans _custVendTrans)
    {
        return this.getBankLCCustVendTrans(_custVendTrans).BankLCNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankLCShipmentLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the bank shipment line number that corresponds to the current transaction.
    /// </summary>
    /// <param name = "_custVendTrans">
    /// Currently selected transaction.
    /// </param>
    /// <returns>
    /// Shipment line number.
    /// </returns>
    public BankLCShipmentLineNum getBankLCShipmentLineNum(CustVendTrans _custVendTrans)
    {
        return this.getBankLCCustVendTrans(_custVendTrans).LineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscAmountPaymCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the cash discount amount converted to the payment currency that corresponds to the open
    /// transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to retrieve the cash discount amount.
    /// </param>
    /// <returns>
    /// The cash discount amount converted to the payment currency.
    /// </returns>
    public CashDiscAmount getCashDiscAmountPaymCur(CustVendTransOpen _custVendTransOpen)
    {
        CashDiscAmount cashDiscAmount;
        CashDiscAmount cashDiscAmountPaymCur;

        // Get cash discount amount
        cashDiscAmount = this.getCustVendTransOpenCashDiscAmount(_custVendTransOpen);

        // Convert cash disc amount from marked transaction currency to payment currency
        cashDiscAmountPaymCur = this.convertAmountTransCurToAmountPaymCur(_custVendTransOpen, cashDiscAmount);

        return cashDiscAmountPaymCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscAmountTaken</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>cashDiscAmountTaken</c> value that corresponds to the open transaction in the
    /// transaction currency.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to get the cash discount amount.
    /// </param>
    /// <returns>
    /// The <c>cashDiscAmountTaken</c> value in the transaction currency.
    /// </returns>
    public CashDiscAmount getCashDiscAmountTaken(CustVendTransOpen _custVendTransOpen)
    {
        Map innerMap;
        CashDiscAmount cashDiscAmountTaken;

        if (custVendTransOpenCashDiscTakenCache.exists(_custVendTransOpen.company())
            && !specTransManager.existForOtherSpec(_custVendTransOpen.company(), _custVendTransOpen.TableId, _custVendTransOpen.RecId))
        {
            // Company map exists, get inner map with cash discount taken
            innerMap = custVendTransOpenCashDiscTakenCache.lookup(_custVendTransOpen.company());

            if (innerMap.exists(_custVendTransOpen.RecId))
            {
                // Discount taken is tracked for open transaction, get from cache
                cashDiscAmountTaken = innerMap.lookup(_custVendTransOpen.RecId);
            }
            else
            {
                // discount taken is not tracked for open transaction, find in database
                changecompany(_custVendTransOpen.company())
                {
                    cashDiscAmountTaken = _custVendTransOpen.getCashDiscAlreadyTaken();
                }
                // add to cache
                innerMap.insert(_custVendTransOpen.RecId, cashDiscAmountTaken);

                // Add to company map
                custVendTransOpenCashDiscTakenCache.insert(_custVendTransOpen.company(), innerMap);
            }
        }
        else
        {
            // discount taken is not in cache, find in database
            changecompany(_custVendTransOpen.company())
            {
                cashDiscAmountTaken = _custVendTransOpen.getCashDiscAlreadyTaken();
                cashDiscAmountTaken += specTransManager.findCashDiscountMarkedToBeTaken(
                    _custVendTransOpen.company(),
                    _custVendTransOpen.TableId,
                    _custVendTransOpen.RecId);
            }

            // Company map doesn't exist, initialize inner map
            innerMap = new Map(Types::Int64, Types::Real);

            // Track cash discount for open transaction
            innerMap.insert(_custVendTransOpen.RecId, cashDiscAmountTaken);

            // Add to company map
            custVendTransOpenCashDiscTakenCache.insert(_custVendTransOpen.company(), innerMap);
        }

        return cashDiscAmountTaken;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscAmountTakenPaymCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the cash discount amount taken that corresponds to the open transaction converted to payment
    /// currency.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to get the cash discount amount taken.
    /// </param>
    /// <returns>
    /// The cash discount amount taken converted to payment currency.
    /// </returns>
    public CashDiscAmount getCashDiscAmountTakenPaymCur(CustVendTransOpen _custVendTransOpen)
    {
        CashDiscAmount cashDiscAmountTaken;
        CashDiscAmount cashDiscAmountTakenPaymCur;

        // Get cash discount amount
        cashDiscAmountTaken = this.getCashDiscAmountTaken(_custVendTransOpen);

        // Convert cash disc amount from marked transaction currency to payment currency
        cashDiscAmountTakenPaymCur = this.convertAmountTransCurToAmountPaymCur(_custVendTransOpen, cashDiscAmountTaken);

        return cashDiscAmountTakenPaymCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscAmountToTake</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the cash discount amount to take for the specified open transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to get the cash discount amount to take.
    /// </param>
    /// <returns>
    /// The cash discount amount to take for the open transaction.
    /// </returns>
    /// <remarks>
    /// If the open transaction is marked for settlement, the current cash discount amount is
    /// returned.Otherwise, the open transaction cash discount amount minus the cash discount already taken
    /// is returned.
    /// </remarks>
    public CashDiscAmount getCashDiscAmountToTake(CustVendTransOpen _custVendTransOpen)
    {
        CashDiscAmount returnCashDiscToTake;
        SpecTrans specTrans;

        specTrans = specTransManager.findByRef(_custVendTransOpen.company(), _custVendTransOpen.TableId, _custVendTransOpen.RecId);

        if (specTrans.RecId != 0)
        {
            // Get cash discount amount stored on associated SpecTrans record
            returnCashDiscToTake = specTrans.CashDiscToTake;
        }
        else
        {
            returnCashDiscToTake = this.determineCashDiscAmountToTake(_custVendTransOpen, true);
        }

        return returnCashDiscToTake;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscAmountToTakePaymCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the cash discount amount to take that corresponds to the open transaction converted to the
    /// payment currency.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to get the cash discount amount to take.
    /// </param>
    /// <returns>
    /// The cash discount amount to take converted to the payment currency.
    /// </returns>
    public CashDiscAmount getCashDiscAmountToTakePaymCur(CustVendTransOpen _custVendTransOpen)
    {
        CashDiscAmount cashDiscAmountToTake;
        CashDiscAmount cashDiscAmountToTakePaymCur;

        // Get cash discount amount
        cashDiscAmountToTake = this.getCashDiscAmountToTake(_custVendTransOpen);

        // Convert cash disc amount from marked transaction currency to payment currency
        cashDiscAmountToTakePaymCur = this.convertAmountTransCurToAmountPaymCur(_custVendTransOpen, cashDiscAmountToTake);

        return cashDiscAmountToTakePaymCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscLargestAmount</Name>
				<Source><![CDATA[
    private CashDiscAmount getCashDiscLargestAmount(CustVendTransOpen _custVendTransOpen)
    {
        Map innerMap;
        CashDiscAmount largestCashDiscAmount;

        if (custVendTransOpenLargestCashDiscCache.exists(_custVendTransOpen.company()))
        {
            // Company map exists, get inner map with largest cash discount
            innerMap = custVendTransOpenLargestCashDiscCache.lookup(_custVendTransOpen.company());

            if (innerMap.exists(_custVendTransOpen.RecId))
            {
                // Largest Discount is tracked for open transaction, get from cache
                largestCashDiscAmount = innerMap.lookup(_custVendTransOpen.RecId);
            }
            else
            {
                // Largest discount is not tracked for open transaction, find in database
                changecompany(_custVendTransOpen.company())
                {
                    if (module == SysModule::Cust)
                    {
                        largestCashDiscAmount = CustTransCashDisc::findLargestCashDisc(_custVendTransOpen.TableId, _custVendTransOpen.RecId).CashDiscAmount;
                    }
                    else
                    {
                        largestCashDiscAmount = VendTransCashDisc::findLargestCashDisc(_custVendTransOpen.TableId, _custVendTransOpen.RecId).CashDiscAmount;
                    }
                }

                // add to cache
                innerMap.insert(_custVendTransOpen.RecId, largestCashDiscAmount);

                // Add to company map
                custVendTransOpenLargestCashDiscCache.insert(_custVendTransOpen.company(), innerMap);
            }
        }
        else
        {
            // largest discount is not in cache, find in database
            changecompany(_custVendTransOpen.company())
            {
                if (module == SysModule::Cust)
                {
                    largestCashDiscAmount = CustTransCashDisc::findLargestCashDisc(_custVendTransOpen.TableId, _custVendTransOpen.RecId).CashDiscAmount;
                }
                else
                {
                    largestCashDiscAmount = VendTransCashDisc::findLargestCashDisc(_custVendTransOpen.TableId, _custVendTransOpen.RecId).CashDiscAmount;
                }
            }

            // Company map doesn't exist, initialize inner map
            innerMap = new Map(Types::Int64, Types::Real);

            // Track cash discount for open transaction
            innerMap.insert(_custVendTransOpen.RecId, largestCashDiscAmount);

            // Add to company map
            custVendTransOpenLargestCashDiscCache.insert(_custVendTransOpen.company(), innerMap);
        }

        return largestCashDiscAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscTotalDisplayCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the total discount amount of the marked transactions in the display currency.
    /// </summary>
    /// <returns>
    /// The total discount amount of the marked transactions.
    /// </returns>
    public AmountCur getCashDiscTotalDisplayCur()
    {
        return balances.getEstimatedCashDiscTotalDisplayCur();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscTotalMst</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the total discount amount of the marked transactions in the monetary standard (MST)
    /// currency.
    /// </summary>
    /// <returns>
    /// The total estimated discount amount of the marked transactions.
    /// </returns>
    public AmountMST getCashDiscTotalMst()
    {
        return balances.getEstimatedCashDiscTotalMst();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCrossRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the cross rate that corresponds to the specified open transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to obtain the cross rate.
    /// </param>
    /// <returns>
    /// The cross rate that corresponds to the specified open transaction.
    /// </returns>
    /// <remarks>
    /// The cross rate converts directly from the currency of the marked transaction to the payment
    /// currency.
    /// </remarks>
    public CrossExchRate getCrossRate(CustVendTransOpen _custVendTransOpen)
    {
        ExchangeRateDisplayFactor displayFactor = this.findDisplayFactorForCustVendTransOpen(_custVendTransOpen);

        // Get cross rate stored on associated SpecTrans record
        return CurrencyEuroDenomination::displayStoredExchangeRate_Static(
            specTransManager.findByRef(
                _custVendTransOpen.company(),
                _custVendTransOpen.TableId,
                _custVendTransOpen.RecId).CrossRate,
            displayFactor);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendAccountNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the AccountNum of current vendor or customer.
    /// currency.
    /// </summary>
    /// <returns>
    /// The vendor or customer AccountNum.
    /// </returns>
    public AccountNum getCustVendAccountNum()
    {
        return custVendAccountNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendBalanceMst</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the total posted balance of the customer or vendor in the monetary standard (MST)
    /// currency.
    /// </summary>
    /// <returns>
    /// The total posted balance of the customer or vendor.
    /// </returns>
    public AmountMST getCustVendBalanceMst()
    {
        return balances.custVendBalanceMst();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendTransOpenCashDiscAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates the cash discount amount for the specified open transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction that is used to determine the cash discount amount.
    /// </param>
    /// <returns>
    /// The cash discount amount for the open transaction.
    /// </returns>
    public CashDiscAmount getCustVendTransOpenCashDiscAmount(CustVendTransOpen _custVendTransOpen)
    {
        Map innerMap;
        CashDiscAmount cashDiscAmount;

        // Check cache for cash discount
        if (custVendTransOpenCashDiscAmountsCache.exists(_custVendTransOpen.company()))
        {
            // Company map exists, get inner map with cash discounts
            innerMap = custVendTransOpenCashDiscAmountsCache.lookup(_custVendTransOpen.company());

            if (innerMap.exists(_custVendTransOpen.RecId))
            {
                // Currency is tracked for open transaction, get from cache
                cashDiscAmount = innerMap.lookup(_custVendTransOpen.RecId);
            }
            else
            {
                // Currency is not tracked for open transaction, find in database
                cashDiscAmount = this.findApplicableCustVendTransCashDisc(_custVendTransOpen).CashDiscAmount;

                // Add currency to cache
                innerMap.insert(_custVendTransOpen.RecId, cashDiscAmount);

                // Add to company map
                custVendTransOpenCashDiscAmountsCache.insert(_custVendTransOpen.company(), innerMap);
            }
        }
        else
        {
            // Cash discount for open transaction is not in cache - find in database
            cashDiscAmount = this.findApplicableCustVendTransCashDisc(_custVendTransOpen).CashDiscAmount;

            // Company map doesn't exist, initialize inner map
            innerMap = new Map(Types::Int64, Types::Real);

            // Track cash discount for open transaction
            innerMap.insert(_custVendTransOpen.RecId, cashDiscAmount);

            // Add to company map
            custVendTransOpenCashDiscAmountsCache.insert(_custVendTransOpen.company(), innerMap);
        }

        return cashDiscAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendTransOpenCashDiscDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates the cash discount date for the specified open transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction that is used to determine the cash discount date.
    /// </param>
    /// <returns>
    /// The cash discount date for the open transaction.
    /// </returns>
    public CashDiscdate getCustVendTransOpenCashDiscDate(CustVendTransOpen _custVendTransOpen)
    {
        Map innerMap;
        CashDiscdate cashDiscDate;

        // Check cache for cash discount
        if (custVendTransOpenCashDiscDateCache.exists(_custVendTransOpen.company()))
        {
            // Company map exists, get inner map with cash discounts
            innerMap = custVendTransOpenCashDiscDateCache.lookup(_custVendTransOpen.company());

            if (innerMap.exists(_custVendTransOpen.RecId))
            {
                // Cash discount date is tracked for open transaction, get from cache
                cashDiscDate = innerMap.lookup(_custVendTransOpen.RecId);
            }
            else
            {
                // Cash discount date is not tracked for open transaction, find in database
                cashDiscDate = this.findApplicableCustVendTransCashDisc(_custVendTransOpen).CashDiscDate;

                // Add date to cache
                innerMap.insert(_custVendTransOpen.RecId, cashDiscDate);

                // Add to company map
                custVendTransOpenCashDiscDateCache.insert(_custVendTransOpen.company(), innerMap);
            }
        }
        else
        {
            // Cash discount for open transaction is not in cache - find in database
            cashDiscDate = this.findApplicableCustVendTransCashDisc(_custVendTransOpen).CashDiscDate;

            // Company map doesn't exist, initialize inner map
            innerMap = new Map(Types::Int64, Types::Date);

            // Track cash discount for open transaction
            innerMap.insert(_custVendTransOpen.RecId, cashDiscDate);

            // Add to company map
            custVendTransOpenCashDiscDateCache.insert(_custVendTransOpen.company(), innerMap);
        }

        return cashDiscDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendTransOpenCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the currency for the open transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to retrieve the currency.
    /// </param>
    /// <returns>
    /// The currency of the open transaction.
    /// </returns>
    public CurrencyCode getCustVendTransOpenCurrency(CustVendTransOpen _custVendTransOpen)
    {
        Map innerMap;
        CurrencyCode transCurrency = '';

        // Check cache for currency
        if (custVendTransOpenCurrenciesCache.exists(_custVendTransOpen.company()))
        {
            // Company map exists, get inner map with currencies
            innerMap = custVendTransOpenCurrenciesCache.lookup(_custVendTransOpen.company());

            if (innerMap.exists(_custVendTransOpen.RecId))
            {
                // Currency is tracked for open transaction, get from cache
                transCurrency = innerMap.lookup(_custVendTransOpen.RecId);
            }
            else
            {
                // Currency is not tracked for open transaction, find in database
                transCurrency = CustVendTransOpenData::construct(_custVendTransOpen).custVendTrans().CurrencyCode;

                // Add currency to cache
                innerMap.insert(_custVendTransOpen.RecId, transCurrency);
            }
        }
        else
        {
            // Currency for open transaction is not in cache - find in database
            transCurrency = CustVendTransOpenData::construct(_custVendTransOpen).custVendTrans().CurrencyCode;

            // Company map doesn't exist, initialize inner map
            innerMap = new Map(Types::Int64, Types::String);

            // Track currency for open transaction
            innerMap.insert(_custVendTransOpen.RecId, transCurrency);

            // Add to company map
            custVendTransOpenCurrenciesCache.insert(_custVendTransOpen.company(), innerMap);
        }

        return transCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendTransOpenPrevSettledAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the amount settled that corresponds to the open transaction in the transaction currency.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to get the cash discount amount.
    /// </param>
    /// <returns>
    /// The amount settled in the transaction currency.
    /// </returns>
    public AmountCur getCustVendTransOpenPrevSettledAmount(CustVendTransOpen _custVendTransOpen)
    {
        AmountCur prevSettledAmount;

        changecompany(_custVendTransOpen.company())
        {
            prevSettledAmount = _custVendTransOpen.getPrevSettledAmount();
        }

        return prevSettledAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDisplayCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the display currency.
    /// </summary>
    /// <returns>
    /// The display currency.
    /// </returns>
    public CurrencyCode getDisplayCurrency()
    {
        return displayCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFullSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>FullSettlement</c> field of the record in the <c>SpecTrans</c> table associated
    /// with the open transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to retrieve the associated <c>SpecTrans</c> record.
    /// </param>
    /// <returns>
    /// The <c>FullSettlement</c> field of the associated record in the <c>SpecTrans</c> table.
    /// </returns>
    public NoYes getFullSettlement(CustVendTransOpen _custVendTransOpen)
    {
        // Get full settlement flag stored on associated SpecTrans record
        return specTransManager.findByRef(
            _custVendTransOpen.company(),
            _custVendTransOpen.TableId,
            _custVendTransOpen.RecId).FullSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFullSettlementCashDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the full settlement cash discount amount that corresponds to the open transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to retrieve the full settlement cash discount amount.
    /// </param>
    /// <returns>
    /// The full settlement cash discount amount.
    /// </returns>
    public CashDiscAmount getFullSettlementCashDisc(CustVendTransOpen _custVendTransOpen)
    {
        CashDiscAmount fullSettlementCashDisc;
        if (this.getFullSettlement(_custVendTransOpen))
        {
            fullSettlementCashDisc = fullSettlementCashDiscount;
        }
        else
        {
            fullSettlementCashDisc = 0;
        }
        return fullSettlementCashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFullSettlementCashDiscPaymCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the full settlement cash discount amount that corresponds to the open transaction converted to
    /// payment currency.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to retrieve the cash discount amount.
    /// </param>
    /// <returns>
    /// The full settlement cash discount amount that is converted to payment currency.
    /// </returns>
    public CashDiscAmount getFullSettlementCashDiscPaymCur(CustVendTransOpen _custVendTransOpen)
    {
        CashDiscAmount fullSettlementCashDiscPaymCur;
        if (this.getFullSettlement(_custVendTransOpen))
        {
        // Convert cash disc amount from marked transaction currency to payment currency
            fullSettlementCashDiscPaymCur = this.convertAmountTransCurToAmountPaymCur(_custVendTransOpen, fullSettlementCashDiscount);
        }
        else
        {
            fullSettlementCashDiscPaymCur = 0;
        }

        return fullSettlementCashDiscPaymCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalTransAmountDisplayCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the amount of the transaction transferred from the journal in the currency displayed.
    /// </summary>
    /// <returns>
    /// The amount of the journal transaction.
    /// </returns>
    public AmountCur getJournalTransAmountDisplayCur()
    {
        return balances.getFromLedgerJournalTransDisplayCur();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalTransAmountMst</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the amount of the transaction transferred from the journal in the monetary standard (MST)
    /// currency.
    /// </summary>
    /// <returns>
    /// The amount of the journal transaction.
    /// </returns>
    public AmountMST getJournalTransAmountMst()
    {
        return balances.getFromLedgerJournalTransMst();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastFineAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the most currently calculated fine amount from the cache
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction used to determine the fine amount.
    /// </param>
    /// <returns>
    /// The fine amount for the open transaction. If an amount does not exist
    /// in the cache, zero is returned.
    /// </returns>
    private FineAmount_BR getLastFineAmount_BR(CustVendTransOpen _custVendTransOpen)
    {
        Map innerMap;
        FineAmount_BR fineAmount;

        // Check cache for fine
        if (custVendTransOpenFineAmountsCache.exists(_custVendTransOpen.company()))
        {
            // Company map exists, get inner map with fines
            innerMap = custVendTransOpenFineAmountsCache.lookup(_custVendTransOpen.company());

            if (innerMap.exists(_custVendTransOpen.RecId))
            {
                // Fine is tracked for open transaction, get from cache
                fineAmount = innerMap.lookup(_custVendTransOpen.RecId);
            }
            else
            {
                // Fine is not tracked for open transaction, set to zero
                fineAmount = 0;
            }
        }
        else
        {
            // Fine is not tracked for open transaction, set to zero
            fineAmount = 0;
        }

        return fineAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastInterestAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the most currently calculated interest amount from the cache
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction used to determine the interest amount.
    /// </param>
    /// <returns>
    /// The interest amount for the open transaction. If an amount does not exist
    /// in the cache, zero is returned.
    /// </returns>
    private FinInterestAmount_BR getLastInterestAmount_BR(CustVendTransOpen _custVendTransOpen)
    {
        Map innerMap;
        FinInterestAmount_BR interestAmount;

        // Check cache for interest
        if (custVendTransOpenInterestAmountsCache.exists(_custVendTransOpen.company()))
        {
            // Company map exists, get inner map with interest
            innerMap = custVendTransOpenInterestAmountsCache.lookup(_custVendTransOpen.company());

            if (innerMap.exists(_custVendTransOpen.RecId))
            {
                // Fine is tracked for open transaction, get from cache
                interestAmount = innerMap.lookup(_custVendTransOpen.RecId);
            }
            else
            {
                // Fine is not tracked for open transaction, set to zero
                interestAmount = 0;
            }
        }
        else
        {
            // Fine is not tracked for open transaction, set to zero
            interestAmount = 0;
        }

        return interestAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkedPrimaryPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>Payment</c> field of the record in the <c>SpecTrans</c> table that is associated
    /// with the open transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to retrieve the associated record in the <c>SpecTrans</c> table.
    /// </param>
    /// <returns>
    /// The <c>Payment</c> field of the associated record in the <c>SpecTrans</c> table.
    /// </returns>
    /// <remarks>
    /// The <c>Payment</c> field of the record in the <c>SpecTrans</c> table designates the marked
    /// transaction as a primary payment.
    /// </remarks>
    public NoYes getMarkedPrimaryPayment(CustVendTransOpen _custVendTransOpen)
    {
        return specTransManager.isMarkedPayment(
            _custVendTransOpen.company(),
            _custVendTransOpen.TableId,
            _custVendTransOpen.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkedTotalDisplayCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the total amount of the marked transactions in the currency displayed.
    /// </summary>
    /// <returns>
    /// The total amount of the marked transactions.
    /// </returns>
    /// <remarks>
    /// The total includes the transaction amount transferred from the journal transaction if it has a
    /// value.
    /// </remarks>
    public AmountCur getMarkedTotalDisplayCur()
    {
        return balances.getMarkedTotalDisplayCur();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkedTotalMst</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the total amount of the marked transactions in the monetary standard (MST) currency.
    /// </summary>
    /// <returns>
    /// The total amount of the marked transactions.
    /// </returns>
    /// <remarks>
    /// The total includes the transaction amount transferred from the journal transaction if it has a
    /// value.
    /// </remarks>
    public AmountMST getMarkedTotalMst()
    {
        return balances.getMarkedTotalMst();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getParty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>Party</c> object of the customer or vendor.
    /// </summary>
    /// <returns>
    /// The <c>Party</c> object of the customer or vendor.
    /// </returns>
    public DirPartyRecId getParty()
    {
        return custVendParty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSettleAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the amount to settle for the specified open transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to retrieve the settlement amount.
    /// </param>
    /// <param name="_includeFineAndInterest">
    /// Indicates whether or not to include the interest and fine amounts.
    /// </param>
    /// <returns>
    /// The amount to settle for the open transaction.
    /// </returns>
    /// <remarks>
    /// If the open transaction is marked for settlement, the current amount to settle is returned.If the
    /// open transaction is not marked for settlement the open transaction amount less the applicable cash
    /// discount is returned.
    /// </remarks>
    public AmountCur getSettleAmount(CustVendTransOpen _custVendTransOpen,
        boolean _includeFineAndInterest = true)
    {
        AmountCur settleAmount;
        AmountCur cashDiscAmountToTake;
        SpecTrans specTrans;
        // <GBR>
        AmountCur fineAmount;
        AmountCur interestAmount;
        // </GBR>

        specTrans = specTransManager.findByRef(_custVendTransOpen.company(), _custVendTransOpen.TableId, _custVendTransOpen.RecId);

        if (specTrans.RecId != 0)
        {
            // Get settle amount (Balance01) stored on associated SpecTrans record
            settleAmount = specTrans.Balance01;

            // <GBR>
            if (BrazilParameters::isEnabled() && _includeFineAndInterest == false)
            {
                // Retrieve last calculated fine and interest amounts
                fineAmount = this.getLastFineAmount_BR(_custVendTransOpen);
                interestAmount = this.getLastInterestAmount_BR(_custVendTransOpen);

                // Remove interest and fine
                settleAmount -= (fineAmount + interestAmount);
            }
            // </GBR>
        }
        else
        {
            // This amount includes the available discount
            cashDiscAmountToTake = this.determineCashDiscAmountToTake(_custVendTransOpen, true);

            settleAmount = this.determineSettleAmountIncludingCashDiscount(_custVendTransOpen, cashDiscAmountToTake, _includeFineAndInterest);
        }

        return settleAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSettleAmountForCashDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the amount to settle including the cash discount amount of the specified cash discount
    /// transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to retrieve the amount to settle.
    /// </param>
    /// <param name="_custVendTransCashDisc">
    /// The cash discount transaction to include in the amount to settle.
    /// </param>
    /// <returns>
    /// The amount to settle including cash discount.
    /// </returns>
    public AmountCur getSettleAmountForCashDisc(CustVendTransOpen _custVendTransOpen, CustVendTransCashDisc _custVendTransCashDisc)
    {
        CustVendTransOpenData custVendTransOpenData;
        AmountCur settleAmountForCashDisc;

        if (_custVendTransCashDisc.CashDiscDue == CashDiscDue::CashDisc)
        {
            // This is a discount record, calculate the settle amount for this discount amount
            changecompany(_custVendTransOpen.company())
            {
                custVendTransOpenData = CustVendTransOpenData::construct(_custVendTransOpen);

                SpecTrans specTrans = specTransManager.findByRef(
                    _custVendTransOpen.company(),
                    _custVendTransOpen.TableId,
                    _custVendTransOpen.RecId);

                if (BrazilParameters::isEnabled())
                {
                    // Need to exclude interest and fines in the cash discount calculation
                    settleAmountForCashDisc = custVendTransOpenData.remainAmountCashDisc(
                        _custVendTransCashDisc.CashDiscDate,
                        graceDays,
                        false,
                        specTrans.Balance01,
                        specTrans.CashDiscToTake);
                }
                else
                {
                    settleAmountForCashDisc = custVendTransOpenData.remainAmountCashDisc(
                        _custVendTransCashDisc.CashDiscDate,
                        graceDays,
                        true,
                        specTrans.Balance01,
                        specTrans.CashDiscToTake);
                }
            }
        }
        else
        {
            // This is a due record, the settle amount is the open amount
            settleAmountForCashDisc = specTransManager.findUnmarkedAmountForRef(
                _custVendTransOpen.AmountCur,
                _custVendTransOpen.company(),
                _custVendTransOpen.TableId,
                _custVendTransOpen.RecId);
        }

        return settleAmountForCashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSettleAmountPaymCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the amount to settle in the payment currency.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to retrieve the settlement amount.
    /// </param>
    /// <returns>
    /// The amount to settle converted to the payment currency.
    /// </returns>
    public AmountCur getSettleAmountPaymCur(CustVendTransOpen _custVendTransOpen)
    {
        AmountCur settleAmount;
        AmountCur settleAmountPaymCur;

        // Get settle amount stored on associated SpecTrans record
        settleAmount = this.getSettleAmount(_custVendTransOpen);

        // Convert from marked transaction currency to payment currency
        settleAmountPaymCur = this.convertAmountTransCurToAmountPaymCur(_custVendTransOpen, settleAmount);

        return settleAmountPaymCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSpecTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the record in the <c>SpecTrans</c> table that is associated with the specified open
    /// transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to retrieve the associated record in the <c>SpecTrans</c> table.
    /// </param>
    /// <returns>
    /// The record in the <c>SpecTrans</c> table that is associated with the specified open transaction.
    /// </returns>
    public SpecTrans getSpecTrans(CustVendTransOpen _custVendTransOpen)
    {
        return specTransManager.findByRef(_custVendTransOpen.company(), _custVendTransOpen.TableId, _custVendTransOpen.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSpecTransCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the count of records in the <c>SpecTrans</c> table that are associated with this instance
    /// of the <c>CustVendOpenTransManager</c> class.
    /// </summary>
    /// <returns>
    /// The count of records in the <c>SpecTrans</c> table.
    /// </returns>
    public int getSpecTransCount()
    {
        int specTransCount;

        specTransCount = specTransManager.getSpecTransCount();

        return specTransCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the marked status of the specified open transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to retrieve the marked status.
    /// </param>
    /// <returns>
    /// The marked status of the open transaction.
    /// </returns>
    public NoYes getTransMarked(CustVendTransOpen _custVendTransOpen)
    {
        return specTransManager.exist(
            _custVendTransOpen.company(),
            _custVendTransOpen.TableId,
            _custVendTransOpen.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransMarkedByOtherSpec</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the marked status of the specified open transaction if it is marked by another
    /// transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to retrieve the marked status.
    /// </param>
    /// <returns>
    /// true if the open transaction is marked for settlement by another transaction; otherwise, false.
    /// </returns>
    public boolean getTransMarkedByOtherSpec(CustVendTransOpen _custVendTransOpen)
    {
        return specTransManager.existForOtherSpec(
            _custVendTransOpen.company(),
            _custVendTransOpen.TableId,
            _custVendTransOpen.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearMarkedByOtherSpec</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the cache for whether a <c>SpecTrans</c> record is already marked by another <c>SpecTrans</c> record.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to clear the marked status.
    /// </param>
    internal void clearMarkedByOtherSpec(CustVendTransOpen _custVendTransOpen)
    {
        specTransManager.clearMarkedByOtherSpec(
            _custVendTransOpen.company(),
            _custVendTransOpen.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransFullyMarkedByOtherSpec</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if an open transaction is fully marked for settlement by other transactions.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to retrieve the marked status.
    /// </param>
    /// <returns>
    /// true if the open transaction is fully marked for settlement by other transactions; otherwise, false.
    /// </returns>
    public boolean checkTransFullyMarkedByOtherSpec(CustVendTransOpen _custVendTransOpen)
    {
        return specTransManager.checkTransFullyMarkedByOtherSpec(_custVendTransOpen);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the customer information for this instance of the <c>CustVendOpenTransManager</c> class.
    /// </summary>
    /// <param name="_custVendAccountNum">
    /// The customer account number for which to initialize the class.
    /// </param>
    /// <param name="_custVendCompany">
    /// The company of the customer account.
    /// </param>
    protected void initCustInfo(
        CustVendAC _custVendAccountNum,
        CompanyId _custVendCompany)
    {
        CustTable custTable;
        container company = [_custVendCompany];

        // Get customer currency - could be cross company
        select firstonly crossCompany:company Currency, Party from custTable
            where custTable.AccountNum == _custVendAccountNum;

        custVendCurrency = custTable.Currency;
        custVendParty = custTable.Party;

        module = SysModule::Cust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCaller</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the customer or vendor account number and currency and sets the display currency from the
    /// specified table buffer and related tables.
    /// </summary>
    /// <param name="_originator">
    /// The table buffer used to initialize the class.
    /// </param>
    /// <remarks>
    /// The table buffer should be from the <c>CustTable</c>, <c>VendTable</c>, <c>CustInvoiceTable</c>,
    /// <c>SalesTable</c>, <c>PurchTable</c>, or <c>LedgerJournalTrans</c> table with an account type of
    /// customer or vendor.If the specified table buffer is from the <c>LedgerJournalTrans</c> table, the
    /// display currency is set to the <c>CurrencyCode</c> field from this table. Otherwise, the display
    /// currency is set to the currency from the customer or vendor.
    /// </remarks>
    protected void initFromCaller(Common _originator)
    {
        LedgerJournalTrans ledgerJournalTrans;
        CustTable custTable;
        CustTrans custTrans;
        CustInvoiceTable custInvoiceTable;
        SalesTable salesTable;
        VendTable vendTable;
        VendTrans vendTrans;
        PurchTable purchTable;
        // <GEEU>
        CustInvoiceJour custInvoiceJour;
        // </GEEU>

        switch (_originator.TableId)
        {
            case tableNum(LedgerJournalTrans):
                ledgerJournalTrans = _originator;
                this.initFromLedgerJournalTrans(ledgerJournalTrans);

                break;

            case tableNum(CustTable):
                module = SysModule::Cust;
                custTable = _originator;
                custVendAccountNum = custTable.AccountNum;
                custVendCompany = custTable.company();
                custVendParty = custTable.Party;
                custVendCurrency = custTable.Currency;
                refTableId = tableNum(CustTransOpen);

                // Initialize companies of the shared service boundary based on the caller's company
                sharedServiceCompanies = CustVendOpenTransManager::findSharedServiceCompanies(custTable.company());

                break;

            case tableNum(CustInvoiceTable):
                custInvoiceTable = _originator;
                custVendAccountNum = custInvoiceTable.InvoiceAccount;
                custVendCompany = custInvoiceTable.company();
                this.initCustInfo(custVendAccountNum, custVendCompany);

                // Initialize companies of the shared service boundary based on the caller's company
                sharedServiceCompanies = CustVendOpenTransManager::findSharedServiceCompanies(custInvoiceTable.company());

                break;

            case tableNum(CustTrans):
                custTrans = _originator;
                custVendAccountNum = custTrans.AccountNum;
                custVendCompany = custTrans.company();
                this.initCustInfo(custVendAccountNum, custVendCompany);

                sharedServiceCompanies = CustVendOpenTransManager::findSharedServiceCompanies(custTrans.company());
                break;

            // <GEEU>
            case tableNum(CustInvoiceJour):
                custInvoiceJour = _originator;
                custVendAccountNum = custInvoiceJour.InvoiceAccount;
                custVendCompany = custInvoiceJour.company();
                this.initCustInfo(custVendAccountNum, custVendCompany);

                // Initialize companies of the shared service boundary based on the caller's company
                sharedServiceCompanies = CustVendOpenTransManager::findSharedServiceCompanies(custInvoiceJour.company());

                break;
            // </GEEU>

            case tableNum(SalesTable):
                salesTable = _originator;
                custVendAccountNum = salesTable.InvoiceAccount;
                custVendCompany = salesTable.company();
                this.initCustInfo(custVendAccountNum, custVendCompany);

                // Initialize companies of the shared service boundary based on the caller's company
                sharedServiceCompanies = CustVendOpenTransManager::findSharedServiceCompanies(salesTable.company());

                break;

            case tableNum(VendTable):
                module = SysModule::Vend;
                vendTable = _originator;
                custVendAccountNum = vendTable.AccountNum;
                custVendCompany = vendTable.company();
                custVendParty = vendTable.Party;
                custVendCurrency = vendTable.Currency;
                refTableId = tableNum(VendTransOpen);

                // Initialize companies of the shared service boundary based on the caller's company
                sharedServiceCompanies = CustVendOpenTransManager::findSharedServiceCompanies(vendTable.company());

                break;

            case tableNum(VendTrans):
                module = SysModule::Vend;
                vendTrans = _originator;
                custVendAccountNum = vendTrans.AccountNum;
                custVendCompany = vendTrans.company();
                this.initVendInfo(custVendAccountNum, custVendCompany);
                refTableId = tableNum(VendTransOpen);

                // Initialize companies of the shared service boundary based on the caller's company
                sharedServiceCompanies = CustVendOpenTransManager::findSharedServiceCompanies(vendTrans.company());

                break;

            case tableNum(PurchTable):
                purchTable = _originator;
                custVendAccountNum = purchTable.InvoiceAccount;
                custVendCompany = purchTable.company();
                this.initVendInfo(custVendAccountNum, custVendCompany);

                // Initialize companies of the shared service boundary based on the caller's company
                sharedServiceCompanies = CustVendOpenTransManager::findSharedServiceCompanies(purchTable.company());

                break;

        }

        this.initDisplayCompanyAndCurrencies(custVendCompany, custVendCurrency);

    }

]]></Source>
			</Method>
			<Method>
				<Name>initDisplayCompanyAndCurrencies</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the class variables used to display company and currencies.
    /// </summary>
    /// <param name = "_company">
    /// The company used to find the accounting currency.
    /// </param>
    /// <param name = "_currencyCode">
    /// The transaction currency code.
    /// </param>
    protected void initDisplayCompanyAndCurrencies(CompanyId _company, CurrencyCode _currencyCode)
    {
        if (displayCurrency == '')
        {
            displayCurrency = _currencyCode;
            displayCompany = _company;

            changecompany(displayCompany)
            {
                displayMstCurrency = CompanyInfoHelper::standardCurrency();
            }

            //<GBR>
            if (BrazilParameters::isEnabled())
            {
                this.setPaymentCurrency(displayCompany, displayCurrency, displayMstCurrency);
            }
            //</GBR>
        }

        displayExchRateHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(displayCompany).RecId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initForSettlementWriteOff</Name>
				<Source><![CDATA[
    private void initForSettlementWriteOff(Common _originator, CurrencyCode _currencyCode)
    {
        this.setPaymentCurrency(_originator.DataAreaId, _currencyCode, CompanyInfoHelper::standardCurrency());

        paymentTransDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromLedgerJournalTrans</Name>
				<Source><![CDATA[
    protected void initFromLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalType ledgerJournalType;
        DiscGraceDays foundGraceDays;
        ExchangeRateHelper exchangeRateHelper =
        ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(_ledgerJournalTrans.Company).RecId), _ledgerJournalTrans.CurrencyCode);

        custVendAccountNum = _ledgerJournalTrans.parmAccount();
        displayCurrency = _ledgerJournalTrans.CurrencyCode;
        displayCompany = _ledgerJournalTrans.Company;

        changecompany(displayCompany)
        {
            displayMstCurrency = CompanyInfoHelper::standardCurrency();
        }

        // Initialize companies of the shared service boundary based on the journal transaction's account company
        sharedServiceCompanies = CustVendOpenTransManager::findSharedServiceCompanies(_ledgerJournalTrans.Company);

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
        {
            this.initCustInfo(custVendAccountNum, _ledgerJournalTrans.Company);
        }
        else if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
        {
            this.initVendInfo(custVendAccountNum, _ledgerJournalTrans.Company);
        }

        ledgerJournalType = _ledgerJournalTrans.ledgerJournalTable().JournalType;

        if (ledgerJournalType == LedgerJournalType::Daily ||
            ledgerJournalType == LedgerJournalType::CustPayment ||
            ledgerJournalType == LedgerJournalType::Payment ||
            ledgerJournalType == LedgerJournalType::Netting ||
            ledgerJournalType == LedgerJournalType::CustBillOfExchangeDraw ||
            ledgerJournalType == LedgerJournalType::VendPromissoryNoteDraw ||
            ledgerJournalType == LedgerJournalType::VendPaymRemittance)
        {
            // Customer payments & bill of exchange draws, vendor payments, vendor promissory note draws & remittances are primary payment transactions.
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
            {
                foundGraceDays = this.findCustDiscountGraceDays(_ledgerJournalTrans.company(), _ledgerJournalTrans.PaymMode);
            }
            else if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
            {
                foundGraceDays = this.findVendDiscountGraceDays(_ledgerJournalTrans.company(), _ledgerJournalTrans.PaymMode);
            }

            // Track primary payment
            this.setPrimaryPayment(
                _ledgerJournalTrans.Company,
                _ledgerJournalTrans.CurrencyCode,
                exchangeRateHelper.prepareExchangeRateForStorage(_ledgerJournalTrans.crossrate()),
                _ledgerJournalTrans.TransDate,
                foundGraceDays);

            paymentFromJournal = true;
        }
        else
        {
            // Set payment values to display values for all other journals
            this.setPaymentCurrency(displayCompany, displayCurrency, displayMstCurrency);

            // Set payment date to system date - used for exchange rates
            paymentTransDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymentCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the payment currency.
    /// </summary>
    /// <param name = "_paymentCompany">The payment company.</param>
    /// <param name = "_paymentCurrency">The payment currency.</param>
    /// <param name = "_paymentMSTCurrency">The payment master currency.</param>
    private void setPaymentCurrency(
        DataAreaId _paymentCompany,
        CurrencyCode _paymentCurrency,
        CurrencyCode _paymentMSTCurrency)
    {
        paymentCompany = _paymentCompany;
        paymentCurrency = _paymentCurrency;
        paymentMstCurrency = _paymentMSTCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMarkedPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the class for a primary payment being marked.
    /// </summary>
    protected void initMarkedPayment()
    {
        SpecTrans paymentSpecTrans;
        CustVendTransOpen paymentCustVendTransOpen;

        paymentSpecTrans = specTransManager.findByMarkedPayment();

        if (paymentSpecTrans.RecId != 0)
        {
            switch (paymentSpecTrans.RefTableId)
            {
                case tableNum(CustTransOpen):
                    paymentCustVendTransOpen = paymentSpecTrans.custTransOpen();
                    break;

                case tableNum(VendTransOpen):
                    paymentCustVendTransOpen = paymentSpecTrans.vendTransOpen();
                    break;
            }

            // Another process may have settled the transaction
            if (paymentCustVendTransOpen)
            {
                this.updateMarkedPrimaryPayment(paymentCustVendTransOpen, NoYes::Yes);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMarkedTransBalances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the balances for existing marked transactions.
    /// </summary>
    protected void initMarkedTransBalances()
    {
        Map markedTransactions;
        MapEnumerator currentTransaction;
        SpecTrans currentSpecTrans;
        CustVendTransOpenData currentCustVendTransOpenData;
        CustVendTransOpen currentCustVendTransOpen;
        CustVendTrans currentCustVendTrans;
        CashDiscAmount cashDiscAmountToTake;

        if (specTransManager.getSpecTransCount() > 0)
        {
            markedTransactions = specTransManager.getAllSpecTransMap();

            currentTransaction = new MapEnumerator(markedTransactions);

            while (currentTransaction.moveNext())
            {
                currentSpecTrans = currentTransaction.currentValue();

                // Set date to use to calculate cash discount
                if (currentSpecTrans.SelectedDateUsedToCalcCashDisc != dateNull())
                {
                    dateTypeUsedToCalcDisc = CashDiscUsedToCalcDisc::SelectedDate;
                    dateUsedToCalcDisc = currentSpecTrans.SelectedDateUsedToCalcCashDisc;
                }

                // Get the current open transaction
                switch (currentSpecTrans.RefTableId)
                {
                    case tableNum(CustTransOpen):
                        currentCustVendTransOpen = currentSpecTrans.custTransOpen();
                        break;

                    case tableNum(VendTransOpen):
                        currentCustVendTransOpen = currentSpecTrans.vendTransOpen();
                        break;

                    default:
                        break;
                }

                // Another process may have settled the transaction
                if (!currentCustVendTransOpen)
                {
                    continue;
                }

                if (currentCustVendTransOpenData == null)
                {
                    // Construct the CustVendTransOpenData class with the current open transaction of the loop, if it hasn't been created yet.
                    currentCustVendTransOpenData = CustVendTransOpenData::construct(currentCustVendTransOpen);
                }
                else
                {
                    // Set the current open transaction of the loop.
                    currentCustVendTransOpenData.parmCustVendTransOpen(currentCustVendTransOpen);
                }

                // Get posted transaction & applicable cash discount amount
                currentCustVendTrans = currentCustVendTransOpenData.custVendTrans();
                this.addCustVendTransOpenCurrency(currentCustVendTransOpen, currentCustVendTrans.CurrencyCode);

                if (currentSpecTrans.SelectedDateUsedToCalcCashDisc != dateNull())
                {
                    // use the cash discount amount from the spec trans
                    cashDiscAmountToTake = this.getCashDiscAmountToTake(currentCustVendTransOpen);
                }
                else
                {
                    cashDiscAmountToTake = this.determineCashDiscAmountToTake(currentCustVendTransOpen, true);
                }

                // Mark transaction with default amounts
                balances.markTrans(
                    currentCustVendTransOpen,
                    currentCustVendTrans,
                    specTransManager.findUnmarkedAmountForRef(
                        currentCustVendTransOpen.AmountCur,
                        currentCustVendTransOpen.company(),
                        currentCustVendTransOpen.TableId,
                        currentCustVendTransOpen.RecId),
                    cashDiscAmountToTake,
                    currentSpecTrans.CrossRate);

                if (currentSpecTrans.CashDiscToTake != cashDiscAmountToTake)
                {
                    this.updateSettleDiscountAmountsWhenDiscountChanged(
                        currentCustVendTransOpen,
                        this.getSettleAmount(currentCustVendTransOpen),
                        currentSpecTrans.CashDiscToTake,
                        cashDiscAmountToTake,
                        false);
                }
                else
                {
                    // Update balances only based on settle amount & actual discount
                    this.updateSettleDiscountAmounts(
                        currentCustVendTransOpen,
                        this.getSettleAmount(currentCustVendTransOpen),
                        cashDiscAmountToTake,
                        true);
                }
            }
            this.updateFullSettlementCashDiscount();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initVendInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the vendor information for this instance of the <c>CustVendOpenTransManager</c> class.
    /// </summary>
    /// <param name="_custVendAccountNum">
    /// The vendor account number for which to initialize the class.
    /// </param>
    /// <param name="_custVendCompany">
    /// The company of the vendor account.
    /// </param>
    protected void initVendInfo(
        CustVendAC _custVendAccountNum,
        CompanyId _custVendCompany)
    {
        VendTable vendTable;
        container company = [_custVendCompany];

        // Get vendor currency - could be cross company
        select firstonly crossCompany:company Currency, Party from vendTable
            where vendTable.AccountNum == _custVendAccountNum;

        custVendCurrency = vendTable.Currency;
        custVendParty = vendTable.Party;

        module = SysModule::Vend;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSharedServiceCompaniesByParty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the shared service companies for a the customer or vendor party.
    /// </summary>
    /// <returns>A container of shared service companies.</returns>
    /// <remarks>
    /// This method optimizes centralized payment shared service companies.  It finds the intersection
    /// between the total possible shared service companies and the companies that are related to the customer or vendor party.
    /// </remarks>
    internal container getSharedServiceCompaniesByParty()
    {
        container companies;
        boolean isFound;

        if ((module == SysModule::Cust || module == SysModule::Vend)
            && custVendParty > 0
            && conLen(sharedServiceCompanies) > 0)
        {
            switch (module)
            {
                case SysModule::Cust:

                    CustTable custTable;

                    while select crosscompany:sharedServiceCompanies DataAreaId 
                        from custTable
                        where custTable.Party == custVendParty
                    {
                        companies += custTable.DataAreaId;
                        isFound = true;
                    }
                    break;

                case SysModule::Vend:

                    VendTable vendTable;

                    while select crosscompany:sharedServiceCompanies DataAreaId
                        from vendTable
                        where vendTable.Party == custVendParty
                    {
                        companies += vendTable.DataAreaId;
                        isFound = true;
                    }
                    break;         
            }
        }

        if (!isFound)
        {
            companies = sharedServiceCompanies;
        }

        return companies;

    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreditNote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the open transaction is a credit note.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction.
    /// </param>
    /// <returns>
    /// true if the open transaction is a credit note; otherwise, false.
    /// </returns>
    protected boolean isCreditNote(CustVendTransOpen _custVendTransOpen)
    {
        CustTrans custTrans;
        VendTrans vendTrans;
        boolean isCreditNote = false;

        changecompany(_custVendTransOpen.company())
        {
            if (module == SysModule::Cust)
            {
                custTrans = _custVendTransOpen.custTrans();
                if (custTrans.RecId != 0)
                {
                    isCreditNote = custTrans.isCreditNote();
                }
            }
            else
            {
                vendTrans = _custVendTransOpen.vendTrans();
                if (vendTrans.RecId != 0)
                {
                    isCreditNote = vendTrans.isCreditNote();
                }
            }
        }

        return isCreditNote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPartialAdvanceInvoiceRemaining</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether there exist any partial advance invoice to implement priority settlement.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// A <c>CustVendTransOpen</c> record.
    /// </param>
    /// <param name="_vendTrans">
    /// A <c>VendTrans</c> record.
    /// </param>
    /// <returns>
    /// true if partial advance invoice exists; otherwise, false.
    /// </returns>
    [SysObsoleteAttribute('This method is no longer supported.', true, 30\5\2022)]
    private boolean isPartialAdvanceInvoiceRemaining(CustVendTransOpen _custVendTransOpen, VendTrans _vendTrans)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRemittanceLocationValidForSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the remittance location is valid for the settlement.
    /// </summary>
    /// <param name="_remittanceLocation">
    /// The remittance location to validate.
    /// </param>
    /// <returns>
    /// True if the remittance location is valid for the settlement; otherwise, false.
    /// </returns>
    public boolean isRemittanceLocationValidForSettlement(RecId _remittanceLocation)
    {
        VendTrans vendTrans;
        VendTransOpen vendTransOpen;
        SpecTrans specTrans;

        Debug::assert(originator.TableId == tableNum(VendTable));

        select firstonly RecId from vendTrans
            where vendTrans.RemittanceLocation != _remittanceLocation
                && vendTrans.RemittanceLocation != 0
            exists join vendTransOpen
                where vendTrans.RecId == vendTransOpen.RefRecId
            exists join specTrans
                where vendTransOpen.DataAreaId == specTrans.RefCompany
                   && vendTransOpen.TableId == specTrans.RefTableId
                   && vendTransOpen.RecId == specTrans.RefRecId
                   && specTrans.SpecCompany == originator.DataAreaId
                   && specTrans.SpecTableId == originator.TableId
                   && specTrans.SpecRecId == originator.RecId;

        return vendTrans.RecId == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markVendPaymentGroups</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks and unmarks the records in the lists associated with the <c>invoicesToBeMarkedEnum</c> and
    /// <c>invoicesToBeUnMarkedEnum</c> enumerators, respectively.
    /// </summary>
    /// <param name="_invoicesToBeMarkedEnum">
    /// An enumerator that points to a list of invoices that should be marked.
    /// </param>
    /// <param name="_invoicesToBeUnMarkedEnum">
    /// An enumerator that points to a list of invoices that should be unmarked.
    /// </param>
    private void markVendPaymentGroups(Enumerator _invoicesToBeMarkedEnum, Enumerator _invoicesToBeUnMarkedEnum)
    {
        VendTransOpen vendTransOpen;

        if (_invoicesToBeMarkedEnum != null)
        {
            //Do all the marking
            while (_invoicesToBeMarkedEnum.moveNext())
            {
                vendTransOpen = _invoicesToBeMarkedEnum.current();

                //make sure the record is not already marked, otherwise the balances will get messed up.
                if (!specTransManager.exist(vendTransOpen.company(), vendTransOpen.TableId, vendTransOpen.RecId))
                {
                    //mark the record
                    this.updateTransMarked(vendTransOpen, NoYes::Yes);
                }
            }
        }
        if (_invoicesToBeUnMarkedEnum != null)
        {
            //Do all the unMarking
            while (_invoicesToBeUnMarkedEnum.moveNext())
            {
                vendTransOpen = _invoicesToBeUnMarkedEnum.current();

                this.updateTransMarked(vendTransOpen, NoYes::No);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>CustVendOpenTransManager</c> class.
    /// </summary>
    /// <param name="_originator">
    /// The table buffer that is used to initialize the class.
    /// </param>
    /// <remarks>
    /// This method sets class variables. These include how other classes used for managing data relate to
    /// the open transactions and the <c>CustOpenTrans</c> and <c>VendOpenTrans</c> forms.
    /// </remarks>
    protected void new(Common _originator)
    {
        originator = _originator;

        // Set variables to defaults
        settlePostingType = SettleDatePrinc::DateOfPayment;
        settlePostingDate = dateNull();

        dateTypeUsedToCalcDisc = CashDiscUsedToCalcDisc::TransactionDate;
        dateUsedToCalcDisc = dateNull();

        paymentTransDate = dateNull();
        paymentExchRate = 0;

        discountDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        graceDays = 0;

        refTableId = 0;

        // Initialize data caches - currencies, discount amounts & missing company currencies
        paymentMstCurrencyMissing = new Map(Types::String, Types::Enum);
        paymentMstExchRateMissing = new Map(Types::String, Types::Enum);
        custVendTransOpenCurrenciesCache = new Map(Types::String, Types::Class);
        custVendTransOpenCashDiscAmountsCache = new Map(Types::String, Types::Class);
        custVendTransOpenCashDiscDateCache = new Map(Types::String, Types::Class);
        custVendTransOpenCashDiscTakenCache = new Map(Types::String, Types::Class);
        custVendTransOpenLargestCashDiscCache = new Map(Types::String, Types::Class);
        custVendTransCashDiscCache = new Map(Types::Container, Types::Class);
        bankLCCustVendTransCache = new Map(Types::Container, Types::Record);

        // Inititalize currency exchange rate helpers
        displayExchRateHelper = CurrencyExchangeHelper::construct();
        transExchRateHelper = CurrencyExchangeHelper::construct();

        // Initialize state based on calling record
        this.initFromCaller(originator);

        // Initialize SpecTrans manager & marked transactions
        specTransManager = SpecTransManager::newRefTableId(_originator, refTableId, true);

        // Initialize balances
        balances = CustVendOpenTransBalances::construct(_originator);
        this.initMarkedTransBalances();

        // Inititialize for marked payment in marked transactions
        this.initMarkedPayment();

        // <GEERU>
        countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            vendOpenTransForm = new VendOpenTransForm(originator);
            this.parmVendOpenTransForm(vendOpenTransForm);
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            custVendTransOpenFineAmountsCache = new Map(Types::String, Types::Class);
            custVendTransOpenInterestAmountsCache = new Map(Types::String, Types::Class);
        }
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDateTypeUsedToCalcDisc</Name>
				<Source><![CDATA[
    public CashDiscUsedToCalcDisc parmDateTypeUsedToCalcDisc(CashDiscUsedToCalcDisc _dateTypeUsedToCalcDisc = dateTypeUsedToCalcDisc)
    {
        if (dateTypeUsedToCalcDisc != _dateTypeUsedToCalcDisc)
        {
            dateTypeUsedToCalcDisc = _dateTypeUsedToCalcDisc;
        }

        return dateTypeUsedToCalcDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDateUsedToCalcDisc</Name>
				<Source><![CDATA[
    public TransDate parmDateUsedToCalcDisc(TransDate _dateUsedToCalcDisc = dateUsedToCalcDisc)
    {
        if (dateUsedToCalcDisc != _dateUsedToCalcDisc)
        {
            dateUsedToCalcDisc = _dateUsedToCalcDisc;
        }

        return dateUsedToCalcDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSettlePostingDate</Name>
				<Source><![CDATA[
    public TransDate parmSettlePostingDate(TransDate _settlePostingDate = settlePostingDate)
    {
        if (settlePostingDate != _settlePostingDate)
        {
            settlePostingDate = _settlePostingDate;
        }

        return settlePostingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSettlePostingType</Name>
				<Source><![CDATA[
    public SettleDatePrinc parmSettlePostingType(SettleDatePrinc _settlePostingType = settlePostingType)
    {
        if (settlePostingType != _settlePostingType)
        {
            settlePostingType = _settlePostingType;

            if (settlePostingType == SettleDatePrinc::DateOfPayment)
            {
                this.parmSettlePostingDate(dateNull());
            }
            else if (settlePostingType == SettleDatePrinc::DaysDate ||
                settlePostingType == SettleDatePrinc::SelectDate)
            {
                this.parmSettlePostingDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
            }
        }

        return settlePostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSharedServiceCompanies</Name>
				<Source><![CDATA[
    public container parmSharedServiceCompanies()
    {
        return sharedServiceCompanies;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSpecTransManager</Name>
				<Source><![CDATA[
    public SpecTransManager parmSpecTransManager(SpecTransManager _specTransManager = specTransManager)
    {
        specTransManager = _specTransManager;

        return specTransManager;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVendOpenTransForm</Name>
				<Source><![CDATA[
    public VendOpenTransForm parmVendOpenTransForm(VendOpenTransForm _vendOpenTransForm = vendOpenTransForm)
    {
        vendOpenTransForm = _vendOpenTransForm;
        return vendOpenTransForm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>preResetMarkedTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prepares to reset marked transactions
    /// </summary>
    /// <remarks>
    /// Only for ledger journal transactions
    /// </remarks>
    public void preResetMarkedTrans()
    {
        if (originator.TableId == tableNum(LedgerJournalTrans))
        {
            // Uncheck selected withholding tax transactions
            TaxWithhold::uncheckWithholdTrans_BR(originator);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshCustVendBalances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refreshes the total posted balance of the customer or vendor in the monetary standard (MST)
    /// currency.
    /// </summary>
    public void refreshCustVendBalances()
    {
        switch (module)
        {
            case SysModule::Cust:
                balances.refreshCustVendBalanceMst(true);
                break;

            case SysModule::Vend:
                balances.refreshCustVendBalanceMst(false);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reorganizeMarkedTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reorganizes marked transactions.
    /// </summary>
    /// <returns>
    /// true if the transaction was reorganized; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The transaction reorganization process is run by the <c>CustVendTransReorg</c> class.
    /// </remarks>
    public boolean reorganizeMarkedTrans()
    {
        SpecTrans markedSpecTrans;
        CustTrans markedCustTrans;
        CustTransOpen markedCustTransOpen;
        VendTrans markedVendTrans;
        VendTransOpen markedVendTransOpen;
        AmountCur reorganizeAmount;
        CustVendTrans reorganizeCustVendTrans;
        CustVendTransReorg reorganizeMarkedTrans;
        LedgerJournalTrans ledgerJournalTrans;
        boolean transReorganized;

        // Get total open amount of marked transactions
        switch (originator.TableId)
        {
            case tableNum(CustTable), tableNum(CustTrans):
                while select crosscompany RecId from markedSpecTrans
                    where markedSpecTrans.SpecCompany == originator.company() &&
                        markedSpecTrans.SpecTableId == originator.TableId &&
                        markedSpecTrans.SpecRecId == originator.RecId
                    join AmountCur from markedCustTransOpen
                        where markedSpecTrans.RefCompany == markedCustTransOpen.DataAreaId &&
                            markedSpecTrans.RefTableId == markedCustTransOpen.TableId &&
                            markedSpecTrans.RefRecId == markedCustTransOpen.RecId
                        join markedCustTrans
                            where markedCustTransOpen.RefRecId == markedCustTrans.RecId
                {
                    reorganizeAmount += specTransManager.findUnmarkedAmountForRef(
                        markedCustTransOpen.AmountCur,
                        markedCustTransOpen.company(),
                        markedCustTransOpen.TableId,
                        markedCustTransOpen.RecId);
                    reorganizeCustVendTrans = markedCustTrans.data();
                }

                break;

            case tableNum(VendTable), tableNum(VendTrans):
                while select crosscompany RecId from markedSpecTrans
                    where markedSpecTrans.SpecCompany == originator.company() &&
                        markedSpecTrans.SpecTableId == originator.TableId &&
                        markedSpecTrans.SpecRecId == originator.RecId
                    join AmountCur from markedVendTransOpen
                        where markedSpecTrans.RefCompany == markedVendTransOpen.DataAreaId &&
                            markedSpecTrans.RefTableId == markedVendTransOpen.TableId &&
                            markedSpecTrans.RefRecId == markedVendTransOpen.RecId
                        join markedVendTrans
                            where markedVendTransOpen.RefRecId == markedVendTrans.RecId
                {
                    reorganizeAmount += specTransManager.findUnmarkedAmountForRef(
                        markedVendTransOpen.AmountCur,
                        markedVendTransOpen.company(),
                        markedVendTransOpen.TableId,
                        markedVendTransOpen.RecId);
                    reorganizeCustVendTrans = markedVendTrans.data();
                }

                break;

            case tableNum(LedgerJournalTrans):
                ledgerJournalTrans = originator;

                if (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
                {
                    while select crosscompany RecId from markedSpecTrans
                        where markedSpecTrans.SpecCompany == originator.company() &&
                            markedSpecTrans.SpecTableId == originator.TableId &&
                            markedSpecTrans.SpecRecId == originator.RecId
                        join AmountCur from markedCustTransOpen
                            where markedSpecTrans.RefCompany == markedCustTransOpen.DataAreaId &&
                                markedSpecTrans.RefTableId == markedCustTransOpen.TableId &&
                                markedSpecTrans.RefRecId == markedCustTransOpen.RecId
                            join markedCustTrans
                                where markedCustTransOpen.RefRecId == markedCustTrans.RecId
                    {
                        reorganizeAmount += specTransManager.findUnmarkedAmountForRef(
                            markedCustTransOpen.AmountCur,
                            markedCustTransOpen.company(),
                            markedCustTransOpen.TableId,
                            markedCustTransOpen.RecId);
                        reorganizeCustVendTrans = markedCustTrans.data();
                    }
                }
                else if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
                {
                    while select crosscompany RecId from markedSpecTrans
                        where markedSpecTrans.SpecCompany == originator.company() &&
                            markedSpecTrans.SpecTableId == originator.TableId &&
                            markedSpecTrans.SpecRecId == originator.RecId
                        join AmountCur from markedVendTransOpen
                            where markedSpecTrans.RefCompany == markedVendTransOpen.DataAreaId &&
                                markedSpecTrans.RefTableId == markedVendTransOpen.TableId &&
                                markedSpecTrans.RefRecId == markedVendTransOpen.RecId
                            join markedVendTrans
                                where markedVendTransOpen.RefRecId == markedVendTrans.RecId
                    {
                        reorganizeAmount += specTransManager.findUnmarkedAmountForRef(
                            markedVendTransOpen.AmountCur,
                            markedVendTransOpen.company(),
                            markedVendTransOpen.TableId,
                            markedVendTransOpen.RecId);
                        reorganizeCustVendTrans = markedVendTrans.data();
                    }
                }

                break;

            default:
                Debug::assert(false);
                break;
        }

        changecompany(reorganizeCustVendTrans.company())
        {
            reorganizeMarkedTrans = new CustVendTransReorg(reorganizeCustVendTrans,
                                            abs(reorganizeAmount),
                                            originator.TableId,
                                            originator.RecId,
                                            originator.company());

            transReorganized = reorganizeMarkedTrans.run();
        }

        if (transReorganized)
        {
            this.resetMarkedTrans();
        }

        return transReorganized;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetInterestAndFine_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Setting to zero Interest and Fine amounts of VendOpenTrans, related to these SpecTrans
    /// </summary>
    public void resetInterestAndFine_BR()
    {
        SpecTrans markedSpecTrans;
        CustTransOpen markedCustTransOpen;
        VendTransOpen markedVendTransOpen;
        LedgerJournalTrans ledgerJournalTrans;

        ttsbegin;

        switch (originator.TableId)
        {
            case tableNum(LedgerJournalTrans):
                ledgerJournalTrans = originator;

                while select crosscompany RefCompany, RefTableId, RefRecId from markedSpecTrans
                      where markedSpecTrans.SpecCompany == originator.company() &&
                            markedSpecTrans.SpecTableId == originator.TableId &&
                            markedSpecTrans.SpecRecId == originator.RecId
                {
                    if (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
                    {
                        changecompany (markedSpecTrans.RefCompany)
                        {
                            while select forupdate markedCustTransOpen
                                  where markedCustTransOpen.DataAreaId == markedSpecTrans.RefCompany &&
                                        markedCustTransOpen.TableId == markedSpecTrans.RefTableId &&
                                        markedCustTransOpen.RecId == markedSpecTrans.RefRecId
                            {
                                this.calcAndUpdateInterest_BR(
                                    markedCustTransOpen.company(),
                                    markedCustTransOpen,
                                    dateNull());

                                this.calcAndUpdateFine_BR(
                                    markedCustTransOpen.company(),
                                    markedCustTransOpen,
                                    dateNull());

                                markedCustTransOpen.update();
                            }
                        }
                    }
                    else if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
                    {
                        changecompany (markedSpecTrans.RefCompany)
                        {
                            while select forupdate markedVendTransOpen
                                  where markedVendTransOpen.DataAreaId == markedSpecTrans.RefCompany &&
                                        markedVendTransOpen.TableId == markedSpecTrans.RefTableId &&
                                        markedVendTransOpen.RecId == markedSpecTrans.RefRecId
                            {
                                this.calcAndUpdateInterest_BR(
                                    markedVendTransOpen.company(),
                                    markedVendTransOpen,
                                    dateNull());

                                this.calcAndUpdateFine_BR(
                                    markedVendTransOpen.company(),
                                    markedVendTransOpen,
                                    dateNull());

                                markedVendTransOpen.update();
                            }
                        }
                    }
                }
                break;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetMarkedTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes all marked transactions that are managed by this instance of the
    /// <c>CustVendOpenTransManager</c> class.
    /// </summary>
    /// <remarks>
    /// Deletes all records in the <c>SpecTrans</c> table and removes all marked transactions from balance
    /// tracking.
    /// </remarks>
    public void resetMarkedTrans()
    {
        // <GBR>
        if (BrazilParameters::isEnabled()
            && originator.TableId == tableNum(LedgerJournalTrans))
        {
            // Reset Interest and Fine
            this.resetInterestAndFine_BR();
        }
        // </GBR>

        // Reset specTransManager
        specTransManager.deleteAll();

        // Reset balances
        balances.unmarkAllTrans();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFilterValueForAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets filter value for agreements.
    /// </summary>
    /// <param name="_formDS">
    /// Datasource where filter will be applied to.
    /// </param>
    /// <param name="_tableId">
    /// The table ID passed.
    /// </param>
    /// <param name="_agreementId">
    /// The filter value.
    /// </param>
    /// <exception cref="Exception::Error">
    /// A Error::wrongUseOfFunction is thrown if _tableId is not tableNum of CustTrans or VendTrans tables
    /// </exception>
    /// <exception cref="Exception::Error">
    /// An error is throw the table is not assigned to datasource.
    /// </exception>
    public void setFilterValueForAgreement(FormDataSource _formDS, TableId _tableId, Range _agreementId)
    {
        QueryBuildDataSource ds;
        QueryBuildRange range;
        Query q = _formDS.queryRun().query();
        RecId dimAttrRecId = AgreementHeaderExt_RU::getAgreementDimensionAttribute();
        FieldName dimensionFieldName;

        if (_tableId == tableNum(CustTrans))
        {
            dimensionFieldName = fieldStr(CustTrans, DefaultDimension);
        }
        else if (_tableId == tableNum(VendTrans))
        {
            dimensionFieldName = fieldStr(VendTrans, DefaultDimension);
        }
        else
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        SysQuery::clearDimensionRangesFromQuery(q);

        if (_agreementId && dimAttrRecId)
        {
            ds = q.dataSourceTable(_tableId);

            if (!ds)
            {
                throw error(strFmt("@SYS329470", _tableId));
            }

            range = SysQuery::addDimensionAttributeRange(
                q,
                ds.name(),
                dimensionFieldName,
                DimensionComponent::DimensionAttribute,
                _agreementId,
                DimensionAttribute::find(dimAttrRecId).Name);

            if (range)
            {
                range.status(RangeStatus::Locked);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPrimaryPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the class variables that are used to track a marked primary payment.
    /// </summary>
    /// <param name="_company">
    /// The company of the primary payment.
    /// </param>
    /// <param name="_currency">
    /// The currency of the primary payment.
    /// </param>
    /// <param name="_exchRate">
    /// The exchange rate of the primary payment that is used to translate from the currency of the payment
    /// to the monetary standard (MST) currency.
    /// </param>
    /// <param name="_transDate">
    /// The posting date of the primary payment.
    /// </param>
    /// <param name="_discGraceDays">
    /// The number of grace days for the discount that is associated with the primary payment.
    /// </param>
    /// <remarks>
    /// When a primary payment is marked, the display currency is set to the currency of the primary
    /// payment and the date used to determine cash discounts is set to the posting date of the primary
    /// payment.
    /// </remarks>
    protected void setPrimaryPayment(
        CompanyId _company,
        CurrencyCode _currency,
        ExchRate _exchRate,
        TransDate _transDate,
        DiscGraceDays _discGraceDays)
    {
        // Update primary tracking variables
        if (!paymentFromJournal)
        {
            paymentMarked = true;
            paymentExchRate = _exchRate;
            paymentTransDate = _transDate;
            graceDays = _discGraceDays;

            CurrencyCode companyStandardCompany;
            changecompany(_company)
            {
                companyStandardCompany = CompanyInfoHelper::standardCurrency();
            }

            this.setPaymentCurrency(_company, _currency, companyStandardCompany);

            displayCompany = paymentCompany;
            displayCurrency = paymentCurrency;
            discountDate = paymentTransDate;

            dateTypeUsedToCalcDisc = CashDiscUsedToCalcDisc::SelectedDate;
            dateUsedToCalcDisc = discountDate;

            displayExchRateHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(displayCompany).RecId));
            displayExchRateHelper.parmExchangeDate(paymentTransDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleMarkedTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Settles marked transactions.
    /// </summary>
    /// <returns>
    /// true if marked transactions were settled; otherwise, false.
    /// </returns>
    public boolean settleMarkedTrans()
    {
        boolean settleMarkedTrans = true;
        boolean markedTransSettled = false;

        // Validate settlement posting date
        if (this.validateSettlePostingDate(settlePostingType, settlePostingDate) == true)
        {
            if (settleMarkedTrans)
            {
                switch (originator.TableId)
                {
                    case tableNum(CustTable):

                        markedTransSettled = this.settleMarkTransCustTable();

                        break;

                    case tableNum(VendTable):
                        // <GEERU>
                        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                        {
                            markedTransSettled = VendTrans::settleTransact(originator, null, true, settlePostingType, settlePostingDate, DimSettlementType_RU::Manual);
                        }
                        else
                        {
                        // </GEERU>
                            markedTransSettled = VendTrans::settleTransact(originator, null, true, settlePostingType, settlePostingDate);
                        // <GEERU>
                        }
                        // </GEERU>
                        break;

                    default:
                        Debug::assert(false);
                        break;
                }

                if (markedTransSettled)
                {
                    this.resetMarkedTrans();
                }
            }
        }

        return markedTransSettled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleMarkTransCustTable</Name>
				<Source><![CDATA[
    private boolean settleMarkTransCustTable()
    {
        boolean markedTransSettled = false;
    
        CashManagementEventSource eventSource = CashManagementEventSource::Log;
        eventSource.EventWriteCustVendOpenTransManagerSettleMarkTransCustTableCalled();

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            markedTransSettled = CustTrans::settleTransact(originator, null, true, settlePostingType, settlePostingDate, DimSettlementType_RU::Manual);
        }
        else
        {
            markedTransSettled = CustTrans::settleTransact(originator, null, true, settlePostingType, settlePostingDate);
        }

        return markedTransSettled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAllCashDiscAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates all cash discount amounts that are associated with marked transactions.
    /// </summary>
    protected void updateAllCashDiscAmounts()
    {
        Map markedTransactions;
        MapEnumerator currentTransaction;
        SpecTrans currentSpecTrans;
        CustVendTransOpen currentCustVendTransOpen;

        // Reinitialize cash discount cache so that it will be refreshed on subsequent accesses
        // as overall discount factors have changed
        custVendTransOpenCashDiscAmountsCache = new Map(Types::String, Types::Class);
        custVendTransOpenCashDiscDateCache = new Map(Types::String, Types::Class);

        // Get map containing SpecTrans records from specTransManager
        markedTransactions = specTransManager.getAllSpecTransMap();

        currentTransaction = new MapEnumerator(markedTransactions);

        while (currentTransaction.moveNext())
        {
            currentSpecTrans = currentTransaction.currentValue();

            if (currentSpecTrans.Payment == NoYes::No)
            {
                // Get related open transaction from SpecTrans
                switch (currentSpecTrans.RefTableId)
                {
                    case tableNum(CustTransOpen):
                        currentCustVendTransOpen = currentSpecTrans.custTransOpen();
                        break;

                    case tableNum(VendTransOpen):
                        currentCustVendTransOpen = currentSpecTrans.vendTransOpen();
                        break;
                }

                this.updateCashDiscAmount(currentCustVendTransOpen);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the settlement and cash discount amounts on the record in the <c>SpecTrans</c> table and
    /// the balances associated with the specified open transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to update associated amounts.
    /// </param>
    /// <param name="_specTransAmount">
    /// The amount with which to update the associated record in the <c>SpecTrans</c> table.
    /// </param>
    /// <param name="_balancesTransAmount">
    /// The settlement amount with which to update the balances.
    /// </param>
    /// <param name="_balancesDiscAmount">
    /// The cash discount amount with which to update the balances.
    /// </param>
    /// <param name="_updateBalancesOnly">
    /// A Boolean value that indicates whether to only update the associated balances.
    /// </param>

    public void updateAmounts(
        CustVendTransOpen _custVendTransOpen,
        AmountCur _specTransAmount,
        AmountCur _balancesTransAmount,
        AmountCur _balancesDiscAmount,
        boolean _updateBalancesOnly)
    {
        // Update related records
        if (_updateBalancesOnly == false)
        {
            specTransManager.updateSettleBalanceAndDisc(
                _custVendTransOpen.company(),
                _custVendTransOpen.TableId,
                _custVendTransOpen.RecId,
                _specTransAmount,
                _balancesDiscAmount);
        }

        balances.updateSettleAmountCur(_custVendTransOpen, _balancesTransAmount);
        balances.updateDiscAmount(_custVendTransOpen, _balancesDiscAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBankLCLineToLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>BankLCLine</c> record ID from the selected <c>CustVendTransOpen</c> record to the
    /// <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The target <c>LedgerJournalTrans</c> record.
    /// </param>
    private void updateBankLCLineToLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        Map specTransMap;
        SpecTrans specTrans;
        MapEnumerator mapEnumerator;
        BankLCLineRefRecId bankLCLineRefRecId;

        if (BankLCImportFeatureChecker::checkBankLCImportEnabled()
            || BankLCExportFeatureChecker::checkBankLCExportEnabled())
        {
            specTransMap = specTransManager.getAllSpecTransMap();
            if (specTransMap.elements() == 1)
            {
                mapEnumerator = specTransMap.getEnumerator();
                if (mapEnumerator.moveNext())
                {
                    specTrans = mapEnumerator.currentValue();
                    switch (specTrans.RefTableId)
                    {
                        case tableNum(VendTransOpen) :
                            bankLCLineRefRecId = specTrans.vendTransOpen().BankLCImportLine;
                            break;
                        case tableNum(CustTransOpen) :
                            bankLCLineRefRecId = specTrans.custTransOpen().BankLCExportLine;
                            break;
                    }
                    LedgerJournalTransBankLC::syncSettlement(_ledgerJournalTrans, bankLCLineRefRecId);
                    if (bankLCLineRefRecId)
                    {
                        _ledgerJournalTrans.PaymMode = '';
                        _ledgerJournalTrans.PaymSpec = '';
                        _ledgerJournalTrans.Prepayment = NoYes::No;
                    }
                }
            }
            else
            {
                LedgerJournalTransBankLC::syncSettlement(_ledgerJournalTrans, 0);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCashDiscAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the related records and balances for the specified open transaction for a change in the
    /// discount amount.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to make the related updates.
    /// </param>
    /// <param name="_custVendTransCashDisc">
    /// The cash discount transaction that captures the cash discount amount change; optional.
    /// </param>
    /// <param name="_updateDiscAmount">
    /// The changed cash discount amount; optional.
    /// </param>
    /// <remarks>
    /// If a cash discount transaction and updated cash discount amount are specified, the cash discount
    /// transaction is updated with the specified cash discount amount. If the associated open transaction
    /// is marked for settlement and the cash discount transaction that is updated is the applicable cash
    /// discount for the open transaction, the related records and balances are updated.
    /// </remarks>
    public void updateCashDiscAmount(
        CustVendTransOpen _custVendTransOpen,
        CustVendTransCashDisc _custVendTransCashDisc = null,
        CashDiscAmount _updateDiscAmount = 0.0)
    {
        CustVendTransCashDisc cashDiscTrans;
        CashDiscAmount cashDiscAmountToTake;
        CashDiscAmount updateDiscAmount = _updateDiscAmount;

        // Round amount as it may be entered by user
        if (updateDiscAmount != 0.0)
        {
            updateDiscAmount = CurrencyExchange::round(updateDiscAmount, this.getCustVendTransOpenCurrency(_custVendTransOpen));
        }

        if (updateDiscAmount != 0.0)
        {
            if (_custVendTransCashDisc == null)
            {
                changecompany(_custVendTransOpen.company())
                {
                    ttsbegin;

                    if (module == SysModule::Cust)
                    {
                        cashDiscTrans = CustVendTransCashDisc::findLastCashDisc(ModuleCustVend::Cust, _custVendTransOpen.TableId, _custVendTransOpen.RecId);
                    }
                    else
                    {
                        cashDiscTrans = CustVendTransCashDisc::findLastCashDisc(ModuleCustVend::Vend, _custVendTransOpen.TableId, _custVendTransOpen.RecId);
                    }

                    cashDiscTrans.RefTableId = _custVendTransOpen.TableId;
                    cashDiscTrans.RefRecId = _custVendTransOpen.RecId;
                    cashDiscTrans.CashDiscAmount = updateDiscAmount;
                    cashDiscTrans.write();

                    discountDate = dateNull();

                    ttscommit;
                }
            }
            else
            {
                changecompany(_custVendTransCashDisc.company())
                {
                    // The cash discount transaction passed in needs to be updated as it wasn't directly updated from the form.
                    ttsbegin;
                    _custVendTransCashDisc.selectForUpdate(true);
                    _custVendTransCashDisc.CashDiscAmount = updateDiscAmount;
                    _custVendTransCashDisc.update();
                    ttscommit;
                }
            }
        }

        // clear the caches
        this.clearCashDiscountCaches(_custVendTransOpen);

        // Find the applicable discount trans
        cashDiscTrans = this.findApplicableCustVendTransCashDisc(_custVendTransOpen);

        // Update the cash discount cache
        this.addCustVendTransOpenCashDiscAmount(_custVendTransOpen, cashDiscTrans.CashDiscAmount);
        this.addCustVendTransOpenCashDiscDate(_custVendTransOpen, cashDiscTrans.CashDiscDate);

        // get the discount to take
        cashDiscAmountToTake = this.determineCashDiscAmountToTake(_custVendTransOpen, true);

        if (this.getTransMarked(_custVendTransOpen) == NoYes::Yes)
        {
            if ((_custVendTransCashDisc != null && cashDiscTrans.RecId != 0 && cashDiscTrans.RecId == _custVendTransCashDisc.RecId) ||
                (_custVendTransCashDisc == null))
            {
                // If a cash discount transaction was passed in to change, an applicable cash discount transaction
                // was found, and the two records are the same, the settle and discount amounts need to be updated.
                // If no cash discount transaction was passed in, the applicable cash discount transaction was updated
                // by the form and the settle and discount amounts need to be updated.
                this.updateSettleDiscountAmounts(
                    _custVendTransOpen,
                    specTransManager.findUnmarkedAmountForRef(
                        _custVendTransOpen.AmountCur,
                        _custVendTransOpen.company(),
                        _custVendTransOpen.TableId,
                        _custVendTransOpen.RecId),
                    cashDiscAmountToTake);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCashDiscAmountPaymCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the specified cash discount amount from the payment currency to the transaction currency
    /// and calls the <c>updateCashDiscAmount</c> method to update the related data.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to make related updates.
    /// </param>
    /// <param name="_custVendTransCashDisc">
    /// The cash discount transaction to update.
    /// </param>
    /// <param name="_updateCashDiscAmountPaymCur">
    /// The cash discount amount in payment currency.
    /// </param>
    public void updateCashDiscAmountPaymCur(
        CustVendTransOpen _custVendTransOpen,
        CustVendTransCashDisc _custVendTransCashDisc,
        AmountCur _updateCashDiscAmountPaymCur)
    {
        AmountCur cashDiscAmount;
        AmountCur updateCashDiscAmountPaymCur = _updateCashDiscAmountPaymCur;

        // Round amount as it may be entered by user
        if (updateCashDiscAmountPaymCur != 0)
        {
            updateCashDiscAmountPaymCur = CurrencyExchange::round(updateCashDiscAmountPaymCur, displayCurrency);
        }

       // Convert amount from payment currency to marked transaction currency
        cashDiscAmount = this.convertAmountPaymCurToAmountTransCur(_custVendTransOpen, updateCashDiscAmountPaymCur);

        // Update cash discount amount
        this.updateCashDiscAmount(_custVendTransOpen, _custVendTransCashDisc, cashDiscAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCashDiscAmountToTakePaymCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the specified cash discount amount to take from the payment currency to the transaction
    /// currency and calls the <c>updateCashDiscAmountToTake</c> method to update the related data.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to make related updates.
    /// </param>
    /// <param name="_updateCashDiscAmountToTakePaymCur">
    /// The cash discount amount in payment currency to take.
    /// </param>
    public void updateCashDiscAmountToTakePaymCur(
        CustVendTransOpen _custVendTransOpen,
        AmountCur _updateCashDiscAmountToTakePaymCur)
    {
        AmountCur cashDiscAmountToTake;
        AmountCur updateCashDiscAmountToTakePaymCur = _updateCashDiscAmountToTakePaymCur;

        // Round amount as it may be entered by user
        if (updateCashDiscAmountToTakePaymCur != 0)
        {
            updateCashDiscAmountToTakePaymCur = CurrencyExchange::round(updateCashDiscAmountToTakePaymCur, displayCurrency);
        }

       // Convert amount from payment currency to marked transaction currency
        cashDiscAmountToTake = this.convertAmountPaymCurToAmountTransCur(_custVendTransOpen, updateCashDiscAmountToTakePaymCur);

        // Update cash discount amount
        this.updateCashDiscAmountToTake(_custVendTransOpen, cashDiscAmountToTake);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCashDiscDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the related records and balances for the specified open transaction for a change in the discount date.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to make related updates.
    /// </param>
    /// <param name="_updatedCustVendTransCashDisc">
    /// The cash discount transaction with the updated discount date.
    /// </param>
    public void updateCashDiscDate(CustVendTransOpen _custVendTransOpen, CustVendTransCashDisc _updatedCustVendTransCashDisc)
    {
        CustVendTransCashDisc cashDiscTrans;
        CashDiscAmount cashDiscAmountToTake;

        // clear the caches
        this.clearCashDiscountCaches(_custVendTransOpen);

        // Find the applicable discount trans
        cashDiscTrans = this.findApplicableCustVendTransCashDisc(_custVendTransOpen);

        // Update the cash discount cache
        this.addCustVendTransOpenCashDiscAmount(_custVendTransOpen, cashDiscTrans.CashDiscAmount);
        this.addCustVendTransOpenCashDiscDate(_custVendTransOpen, cashDiscTrans.CashDiscDate);

        //get the discount to take
        cashDiscAmountToTake = this.determineCashDiscAmountToTake(_custVendTransOpen, true);

        if (this.getTransMarked(_custVendTransOpen) == NoYes::Yes)
        {
            if (cashDiscTrans.RecId != 0)
            {
                // Different discount applies, update amounts
                this.updateSettleDiscountAmounts(
                    _custVendTransOpen,
                    specTransManager.findUnmarkedAmountForRef(
                        _custVendTransOpen.AmountCur,
                        _custVendTransOpen.company(),
                        _custVendTransOpen.TableId,
                        _custVendTransOpen.RecId),
                    cashDiscAmountToTake);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCashDiscAmountToTake</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the cash discount amount to take that is associated with the specified open transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to update the amount to settle.
    /// </param>
    /// <param name="_updateCashDiscToTake">
    /// The changed cash discount amount to take.
    /// </param>
    /// <remarks>
    /// If the open transaction is marked for settlement, the associated record in the <c>SpecTrans</c>
    /// table and the balances are updated.
    /// </remarks>
    public void updateCashDiscAmountToTake(CustVendTransOpen _custVendTransOpen, AmountCur _updateCashDiscToTake)
    {
        AmountCur cashDiscToTake;
        AmountCur settleAmount;
        CustVendCashDiscountHelper cashDiscountHelper;

        if (this.getTransMarked(_custVendTransOpen) == NoYes::Yes)
        {
            // If full settlement is marked, unmark the full settlement flag
            if (this.getFullSettlement(_custVendTransOpen))
            {
                this.updateFullSettlement(_custVendTransOpen, NoYes::No);
            }

            // Round the entered amount
            cashDiscToTake = CurrencyExchange::round(_updateCashDiscToTake, this.getCustVendTransOpenCurrency(_custVendTransOpen));

            cashDiscountHelper = CustVendCashDiscountHelper::construct(_custVendTransOpen);
            cashDiscountHelper.parmCashDiscountTaken(this.getCashDiscAmountTaken(_custVendTransOpen));
            cashDiscountHelper.parmLargestCashDiscount(this.getCashDiscLargestAmount(_custVendTransOpen));
            cashDiscToTake = cashDiscountHelper.validateCashDiscToTake(cashDiscToTake);

            settleAmount = this.getSettleAmount(_custVendTransOpen);

            // The applicable discount was changed, update amounts
            this.updateSettleDiscountAmounts(
                _custVendTransOpen,
                settleAmount,
                cashDiscToTake,
                false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCrossRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the related records and balances for the specified open transaction for a change in the
    /// cross rate.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction that is associated with the updated cross rate.
    /// </param>
    /// <param name="_updateCrossRate">
    /// The exchange rate that is used to translate from the currency of the transaction to the payment
    /// currency.
    /// </param>
    public void updateCrossRate(CustVendTransOpen _custVendTransOpen, CrossExchRate _updateCrossRate)
    {
        ExchangeRateDisplayFactor displayFactor = this.findDisplayFactorForCustVendTransOpen(_custVendTransOpen);
        CrossExchRate updateCrossRate = CurrencyEuroDenomination::prepareExchangeRateForStorage_Static(_updateCrossRate, displayFactor);

        // Update cross rate stored on associated SpecTrans record
        specTransManager.updateCrossRate(_custVendTransOpen.company(),
            _custVendTransOpen.TableId,
            _custVendTransOpen.RecId,
            updateCrossRate);

        // Update balances
        balances.updateCrossRate(_custVendTransOpen, updateCrossRate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDateTypeUsedToCalcDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the date to use to calculate discount type.
    /// </summary>
    /// <param name="_dateTypeUsedToCalcDisc">
    /// The changed date to use to calculate discount type.
    /// </param>
    public void updateDateTypeUsedToCalcDisc(CashDiscUsedToCalcDisc _dateTypeUsedToCalcDisc)
    {
        if (dateTypeUsedToCalcDisc != _dateTypeUsedToCalcDisc)
        {
            dateTypeUsedToCalcDisc = _dateTypeUsedToCalcDisc;

            // If the type is change the default value for the date is updated
            if (dateTypeUsedToCalcDisc == CashDiscUsedToCalcDisc::TransactionDate)
            {
                this.updateDateUsedToCalcDisc(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
                dateUsedToCalcDisc = dateNull();
            }
            else if (dateTypeUsedToCalcDisc == CashDiscUsedToCalcDisc::SelectedDate)
            {
                this.updateDateUsedToCalcDisc(discountDate);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDateUsedToCalcDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the date to use to calculate discount.
    /// </summary>
    /// <param name="_dateUsedToCalcDisc">
    /// The changed date to use to calculate discount.
    /// </param>
    public void updateDateUsedToCalcDisc(TransDate _dateUsedToCalcDisc)
    {
        discountDate = _dateUsedToCalcDisc;
        dateUsedToCalcDisc = _dateUsedToCalcDisc;

        this.updateAllCashDiscAmounts();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFineAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Fine Amount Currency
    /// </summary>
    /// <param name="_refCompany">
    /// The company of the Open transaction
    /// </param>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to calculate the Fine amount Currency
    /// </param>
    /// <param name="_fineAmount">
    /// Amount used to updated the field Fine Amount Currency
    /// </param>
    public void updateFineAmount_BR(CompanyId _refCompany,
                                        CustVendTransOpen _custVendTransOpen,
                                        FineAmount_BR _fineAmount)
    {
        changecompany(_refCompany)
        {
            _custVendTransOpen.FineAmount_BR = _fineAmount;
            _custVendTransOpen.FineAmountPaymCur_BR = this.convertAmountTransCurToAmountPaymCur(_custVendTransOpen, _fineAmount);

            // update Settle Amount (considering Fine Amount)
            this.updateSettleAmount(_custVendTransOpen, 0);

            // Add amount to cache as most recently calculated value
            this.addCustVendTransOpenFineAmount_BR(_custVendTransOpen, _custVendTransOpen.FineAmount_BR);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFullSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>FullSettlement</c> field of the record in the <c>SpecTrans</c> table that is
    /// associated with the open transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to update the associated record in the <c>SpecTrans</c> table.
    /// </param>
    /// <param name="_updateFullSettlement">
    /// A <c>NoYes</c> enumeration value that indicates whether the record in the <c>SpecTrans</c> table is
    /// marked for full settlement.
    /// </param>
    public void updateFullSettlement(CustVendTransOpen _custVendTransOpen, NoYes _updateFullSettlement)
    {
        // If full settlement is not marked, reset the cash discounts and settle amounts to original values
        if (!this.getFullSettlement(_custVendTransOpen))
        {
            this.updateCashDiscAmount(_custVendTransOpen);
        }

        // Update full settlement stored on associated SpecTrans record
        specTransManager.updateFullSettlement(_custVendTransOpen.company(),
            _custVendTransOpen.TableId,
            _custVendTransOpen.RecId,
            _updateFullSettlement);

        this.updateCashDiscAmount(_custVendTransOpen);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFullSettlementCashDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the cash discount amount that is associated with the full settlement record.
    /// </summary>
    protected void updateFullSettlementCashDiscount()
    {
        SpecTrans currentSpecTrans;
        CustVendTransOpen currentCustVendTransOpen;

        currentSpecTrans = specTransManager.findByFullSettlement();

        switch (currentSpecTrans.RefTableId)
        {
            case tableNum(CustTransOpen):
                currentCustVendTransOpen = currentSpecTrans.custTransOpen();
                break;

            case tableNum(VendTransOpen):
                currentCustVendTransOpen = currentSpecTrans.vendTransOpen();
                break;
        }

        if (currentCustVendTransOpen)
        {
            // Re-calculate full settlement values
            this.updateFullSettlement(currentCustVendTransOpen, NoYes::No);
            this.updateFullSettlement(currentCustVendTransOpen, NoYes::Yes);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInterestAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Interest Amount Currency
    /// </summary>
    /// <param name="_refCompany">
    /// The company ID related to the transaction
    /// </param>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to calculate the Interest amount Currency
    /// </param>
    /// <param name="_finInterestAmount">
    /// Amount used to updated the field Interest Amount Currency
    /// </param>
    public void updateInterestAmount_BR(CompanyId _refCompany,
                                        CustVendTransOpen _custVendTransOpen,
                                        FinInterestAmount_BR _finInterestAmount)
    {
        changecompany(_refCompany)
        {
            _custVendTransOpen.InterestAmount_BR = _finInterestAmount;
            _custVendTransOpen.InterestAmountPaymCur_BR = this.convertAmountTransCurToAmountPaymCur(_custVendTransOpen,_finInterestAmount);

            // update Settle Amount (considering Interest Amount)
            this.updateSettleAmount(_custVendTransOpen, 0);

            // Add amount to cache as most recently calculated value
            this.addCustVendTransOpenInterestAmount_BR(_custVendTransOpen, _custVendTransOpen.InterestAmount_BR);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMarkedPrimaryPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>Payment</c> field of the record in the <c>SpecTrans</c> table that is associated
    /// with the open transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to update the associated record in the <c>SpecTrans</c> table.
    /// </param>
    /// <param name="_updateMarkedPrimaryPayment">
    /// A Boolean value that indicates whether the record in the <c>SpecTrans</c> table is marked as the
    /// primary payment.
    /// </param>
    public void updateMarkedPrimaryPayment(CustVendTransOpen _custVendTransOpen, NoYes _updateMarkedPrimaryPayment)
    {
        CustVendTransOpenData custVendTransOpenData;
        CustVendTrans custVendTrans;
        DiscGraceDays newGraceDays;
        TransDate oldDiscountDate = discountDate;
        DiscGraceDays oldGraceDays = graceDays;

        custVendTransOpenData = CustVendTransOpenData::construct(_custVendTransOpen);
        custVendTrans = custVendTransOpenData.custVendTrans();

        if (_updateMarkedPrimaryPayment == NoYes::Yes)
        {
            newGraceDays = custVendTransOpenData.findPaymModeTable(false).DiscGraceDays;

            // Track new primary payment
            this.setPrimaryPayment(
                _custVendTransOpen.company(),
                custVendTrans.CurrencyCode,
                custVendTrans.exchRateCurToMst(),
                custVendTrans.TransDate,
                newGraceDays);
        }
        else
        {
            // Discontinue tracking the primary payment
            this.clearPrimaryPayment();
        }

        // Update SpecTrans tracking primary payment - marked or unmarked
        specTransManager.updateMarkedPayment(
            _custVendTransOpen.company(),
            _custVendTransOpen.TableId,
            _custVendTransOpen.RecId,
            _updateMarkedPrimaryPayment);

        // Update all discount amounts if discount date or grace days has changed
        if (oldDiscountDate != discountDate || oldGraceDays != graceDays)
        {
            this.updateAllCashDiscAmounts();
        }

        // Update Balances - will update tracking for exchange rates
        balances.setPrimaryPayment(_custVendTransOpen, custVendTrans, _updateMarkedPrimaryPayment);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOriginatorForMarkedTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the originating transaction for marked transactions.
    /// </summary>
    /// <remarks>
    /// Updates the value of the <c>SettleVoucher</c> field of the <c>SalesTable</c> , <c>PurchTable</c> ,
    /// or <c>LedgerJournalTrans</c> table based on the status of the marked transactions.
    /// </remarks>
    public void updateOriginatorForMarkedTrans()
    {

        if (specTransManager.getSpecTransCount() > 0)
        {
            // If transactions were marked, write data back to the originating record.
            switch (originator.TableId)
            {
                case tableNum(LedgerJournalTrans):
                    this.updateOriginatorLedgerJournalTrans();
                    break;

                case tableNum(CustInvoiceJour):
                    this.updateOriginatorCustInvoiceJour();
                    break;

                case tableNum(SalesTable):
                    this.updateOriginatorSalesTable();
                    break;

                case tableNum(PurchTable):
                    this.updateOriginalPurchTable();
                    break;

                case tableNum(CustTable), tableNum(CustInvoiceTable), tableNum(VendTable), tableNum(CustTrans), tableNum(VendTrans):
                    // NOTE: These tables do not have data to be written back to them based on transactions being marked.
                    break;

                default:
                    break;
            }
        }
        else
        {
            // If no transactions were marked, write data back to the originating record.
            switch (originator.TableId)
            {
                case tableNum(LedgerJournalTrans):
                    this.updateOriginatorLedgerJournalTransNotMarked();
                    break;

                // <GEEU>
                case tableNum(CustInvoiceJour):
                // </GEEU>
                case tableNum(SalesTable), tableNum(PurchTable), tableNum(CustTable),
                    tableNum(VendTable), tableNum(CustInvoiceTable), tableNum(CustTrans), tableNum(VendTrans):
                    // NOTE: These tables do not have data to be written back to them based on no transactions being marked.
                    break;

                default:
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOriginatorLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update originator <c>LedgerJournalTrans</c>.
    /// </summary>
    protected void updateOriginatorLedgerJournalTrans()
    {
        LedgerJournalTrans ledgerJournalTrans = originator;
    
        changecompany(ledgerJournalTrans.company())
        {
            this.populateLedgerJournalTransForTransactionsMarked(ledgerJournalTrans);
            ledgerJournalTrans.write();

            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
            {
                BankThirdPartyAccountId firstVendBank = vendOpenTransForm.getVendBankAccount();
                if (firstVendBank)
                {
                    ledgerJournalTrans.CustVendBankAccountId = firstVendBank;
                }
            }
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOriginatorLedgerJournalTransNotMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update originator <c>LedgerJournalTrans</c> when transacations are not marked.
    /// </summary>
    protected void updateOriginatorLedgerJournalTransNotMarked()
    {
        LedgerJournalTrans ledgerJournalTrans = originator;
    
        changecompany(ledgerJournalTrans.company())
        {
            this.populateLedgerJournalTransForTransactionsNotMarked(ledgerJournalTrans);
            ledgerJournalTrans.write();
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOriginatorCustInvoiceJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update originator <c>CustInvoiceJour</c>.
    /// </summary>
    protected void updateOriginatorCustInvoiceJour()
    {
        CustInvoiceJour custInvoiceJour = originator;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            CustInvoiceJour_RU custInvoiceJourRU = custInvoiceJour.custInvoiceJour_RU();
            if (custInvoiceJourRU.SettleVoucher_RU == SettlementType::None)
            {
                custInvoiceJourRU.SettleVoucher_RU = SettlementType::SelectedTransact;
                custInvoiceJour.packCustInvoiceJour_RU(custInvoiceJourRU);
                custInvoiceJour.write();
            }
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOriginatorSalesTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update originator <c>SalesTable</c>.
    /// </summary>
    protected void updateOriginatorSalesTable()
    {
        SalesTable salesTable = originator;

        changecompany(salesTable.company())
        {
            if (salesTable.SettleVoucher == SettlementType::None)
            {
                ttsbegin;
                salesTable.SettleVoucher = SettlementType::SelectedTransact;
                salesTable.write();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOriginalPurchTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update originator <c>PurchTable</c>.
    /// </summary>
    protected void updateOriginalPurchTable()
    {
        PurchTable purchTable = originator;

        if (purchTable.SettleVoucher == SettlementType::None)
        {
            purchTable.SettleVoucher = SettlementType::SelectedTransact;
            purchTable.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateLedgerJournalTransForTransactionsMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populate <c>LedgerJournalTrans</c> as the originator for transactions that are marked.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The originator.</param>
    protected void populateLedgerJournalTransForTransactionsMarked(LedgerJournalTrans _ledgerJournalTrans)
    {
        TaxWithholdAuthorities_IN taxWithholdAuthorities;
        LedgerJournalType ledgerJournalType;

        _ledgerJournalTrans.SettleVoucher = this.getSettlementType();

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
        {
            _ledgerJournalTrans.fillPaymentNotes();

            if (TaxWithholdParameters_IN::checkTaxParameters())
            {
                ledgerJournalType = _ledgerJournalTrans.ledgerJournalTable().JournalType;

                if (ledgerJournalType == LedgerJournalType::Daily
                    || ledgerJournalType == LedgerJournalType::Payment)
                {
                    select firstonly RecId from taxWithholdAuthorities
                        where taxWithholdAuthorities.VendAccount == _ledgerJournalTrans.parmAccount();

                    if (taxWithholdAuthorities)
                    {
                        _ledgerJournalTrans.splitPaymentTAN_IN(_ledgerJournalTrans.TransDate);
                    }
                }
            }
        }

        this.updateBankLCLineToLedgerJournalTrans(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSettlementType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the settlement type.
    /// </summary>
    /// <returns>
    ///     The settlement type.
    /// </returns>
    public SettlementType getSettlementType()
    {
        return SettlementType::SelectedTransact;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateLedgerJournalTransForTransactionsNotMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populate <c>LedgerJournalTrans</c> as the originator for transactions that are not marked.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The originator.</param>
    protected void populateLedgerJournalTransForTransactionsNotMarked(LedgerJournalTrans _ledgerJournalTrans)
    {
        NoYes autoSettlement;

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
        {
            autoSettlement = CustParameters::find().AutoSettle;
        }
        else if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
        {
            autoSettlement = VendParameters::find().AutoSettle;

            _ledgerJournalTrans.fillPaymentNotes();
        }

        this.populateSettleVoucher(_ledgerJournalTrans, autoSettlement);

        this.updateBankLCLineToLedgerJournalTrans(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateSettleVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Populate the settlement voucher for journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    ///     A <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    /// <param name = "_autoSettlement">
    ///     The auto settlement value.
    /// </param>
    protected void populateSettleVoucher(LedgerJournalTrans _ledgerJournalTrans, NoYes _autoSettlement)
    {
        if (_autoSettlement == NoYes::Yes)
        {
            _ledgerJournalTrans.SettleVoucher = SettlementType::OpenTransact;
        }
        else
        {
            _ledgerJournalTrans.SettleVoucher = SettlementType::None;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSettleAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the amount to settle that is associated with the specified open transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to update the settlement amount.
    /// </param>
    /// <param name="_updateSettleAmount">
    /// The changed amount to settle.
    /// </param>
    /// <remarks>
    /// If the open transaction is marked for settlement, the associated record in the <c>SpecTrans</c>
    /// table and balances are updated.
    /// </remarks>
    public void updateSettleAmount(CustVendTransOpen _custVendTransOpen, AmountCur _updateSettleAmount)
    {
        // If full settlement is mark, unmark the full settlement flag
        if (this.getFullSettlement(_custVendTransOpen))
        {
            this.updateFullSettlement(_custVendTransOpen, NoYes::No);
        }

        if (this.getTransMarked(_custVendTransOpen) == NoYes::Yes)
        {
            AmountCur settleAmount = this.calculateUpdatedAmountForSettlement(_custVendTransOpen, _updateSettleAmount);

            CashDiscAmount cashDiscAmountToTake = this.calculateCashDiscountForSettleAmount(_custVendTransOpen, settleAmount);

            // The applicable discount was changed, update amounts
            this.updateSettleDiscountAmounts(
                _custVendTransOpen,
                settleAmount,
                cashDiscAmountToTake,
                false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateUpdatedAmountForSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the settlement amount for an open transaction given an updated settle amount.
    /// </summary>
    /// <param name = "_custVendTransOpen">The open transaction.</param>
    /// <param name = "_newAmountForSettlement">The updated settle amount.</param>
    /// <returns>The new settlement amount.</returns>
    internal AmountCur calculateUpdatedAmountForSettlement(CustVendTransOpen _custVendTransOpen, AmountCur _newAmountForSettlement)
    {
        AmountCur settleAmount;

        if (_newAmountForSettlement == 0)
        {
            // Get the amount from the SpecTrans
            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                // Exclude interest and fine since the use of this amount in
                // updateSettleDiscountAmounts (which determines if discounts
                // should be applied) will be incorrect if fines and interest
                // are included.
                settleAmount = this.getSettleAmount(_custVendTransOpen, false);
            }
            else
            {
                // </GBR>
                settleAmount = this.getSettleAmount(_custVendTransOpen);
                // <GBR>
            }
            // </GBR>
        }
        else
        {
            CustVendTransOpenData custVendTransOpenData = CustVendTransOpenData::construct(_custVendTransOpen);

            // Round the entered amount
            settleAmount = CurrencyExchange::round(_newAmountForSettlement, custVendTransOpenData.custVendTrans().CurrencyCode);

            changecompany(_custVendTransOpen.company())
            {
                SpecTrans specTrans = specTransManager.findByRef(_custVendTransOpen.company(), _custVendTransOpen.TableId, _custVendTransOpen.RecId);

                // This will calculate the amount based on past partial settlements, and also adjust the
                // amount to take into account cash discounts
                if (BrazilParameters::isEnabled())
                {
                    // Exclude interest and fine since the use of this amount in
                    // updateSettleDiscountAmounts (which determines if discounts
                    // should be applied) will be incorrect if fines and interest
                    // are included.
                    settleAmount = custVendTransOpenData.findSettlementAmount(
                        _newAmountForSettlement,
                        this.findCashDiscountUnspecificSpecific(_custVendTransOpen),
                        discountDate,
                        false,
                        specTrans.Balance01,
                        specTrans.CashDiscToTake);
                }
                else
                {
                    settleAmount = custVendTransOpenData.findSettlementAmount(
                        _newAmountForSettlement,
                        this.findCashDiscountUnspecificSpecific(_custVendTransOpen),
                        discountDate,
                        true,
                        specTrans.Balance01,
                        specTrans.CashDiscToTake);
                }
            }
        }

        return settleAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCashDiscountUnspecificSpecific</Name>
				<Source><![CDATA[
    private UnspecificSpecific findCashDiscountUnspecificSpecific(CustVendTransOpen _custVendTransOpen)
    {
        UnspecificSpecific cashDiscUnspecificSpecific;

        // Get the specific/unspecific setting for the transaction company
        switch (_custVendTransOpen.TableId)
        {
            case tableNum(CustTransOpen):
                cashDiscUnspecificSpecific = CustParameters::find().CashDisc;
                break;

            case tableNum(VendTransOpen):
                cashDiscUnspecificSpecific = VendParameters::find().CashDisc;
                break;
        }

        return cashDiscUnspecificSpecific;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdjustedSettleAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates setlement amount when discount was deleted.
    /// </summary>
    /// <param name = "_amount">
    /// Settlement amount.
    /// </param>
    /// <param name = "_discount">
    /// Cash discount amount which should be applied.
    /// </param>
    /// <returns>
    /// Settlement amount.
    /// </returns>
    internal AmountCur getAdjustedSettleAmount(AmountCur _amount, AmountCur _discount)
    {
        return _amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateCashDiscountForSettleAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the cash discount to take for an open transaction with a specified settlement amount.
    /// </summary>
    /// <param name = "_custVendTransOpen">The open transaction.</param>
    /// <param name = "_settleAmount">The settlement amount for the open transaction.</param>
    /// <returns>The cash discount to take.</returns>
    internal CashDiscAmount calculateCashDiscountForSettleAmount(CustVendTransOpen _custVendTransOpen, AmountCur _settleAmount)
    {
        CashDiscAmount fullCashDiscAmount = this.getCustVendTransOpenCashDiscAmount(_custVendTransOpen);

        CustVendCashDiscountHelper cashDiscountHelper = CustVendCashDiscountHelper::construct(_custVendTransOpen);
        cashDiscountHelper.parmFullCashDiscountForTier(fullCashDiscAmount);
        cashDiscountHelper.parmCashDiscountTaken(this.getCashDiscAmountTaken(_custVendTransOpen));
        cashDiscountHelper.parmLargestCashDiscount(this.getCashDiscLargestAmount(_custVendTransOpen));
        cashDiscountHelper.parmRemainingOpenBalance(specTransManager.findUnmarkedAmountForRef(
            _custVendTransOpen.AmountCur,
            _custVendTransOpen.company(),
            _custVendTransOpen.TableId,
            _custVendTransOpen.RecId));

        return cashDiscountHelper.determineCashDiscForPartialSettlement(_settleAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSettleAmountPaymCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the specified amount to settle from the payment currency to the transaction currency and
    /// calls the <c>updateSettleAmount</c> method to update the related data.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to make related updates.
    /// </param>
    /// <param name="_updateSettleAmountPaymCur">
    /// The amount to settle in payment currency.
    /// </param>
    public void updateSettleAmountPaymCur(
        CustVendTransOpen _custVendTransOpen,
        AmountCur _updateSettleAmountPaymCur)
    {
        AmountCur settleAmount;
        AmountCur updateSettleAmountPaymCur = _updateSettleAmountPaymCur;

        // Round amount as it may be entered by user
        if (updateSettleAmountPaymCur != 0)
        {
            updateSettleAmountPaymCur = CurrencyExchange::round(updateSettleAmountPaymCur, displayCurrency);
        }

        // Convert amount from payment currency to marked transaction currency - may be cross company
        settleAmount = this.convertAmountPaymCurToAmountTransCur(_custVendTransOpen, updateSettleAmountPaymCur);

        // Update settle amount
        this.updateSettleAmount(_custVendTransOpen, settleAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSettleDiscountAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines what amount to settle and what discount amount should be used to update the associated
    /// record in the <c>SpecTrans</c> table and balances.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to update the associated amounts.
    /// </param>
    /// <param name="_settleAmount">
    /// The amount to settle.
    /// </param>
    /// <param name="_discountAmount">
    /// The possible cash discount amount.
    /// </param>
    /// <param name="_updateBalancesOnly">
    /// A Boolean value that indicates whether to only update the associated balances; optional.
    /// </param>
    /// <remarks>
    /// If the amount to settle is less than the open transaction amount less the specified discount
    /// amount, the amount to settle is used and no discount is taken. If the amount to settle is equal to
    /// the open transaction amount less the specified discount amount or the settle amount is more than
    /// the open transaction amount, the open transaction amount is used and the full discount is taken. If
    /// the amount to settle is between the open transaction amount less the specified discount and the
    /// open transaction amount, the amount to settle is used and the discount amount is adjusted to the
    /// difference between the open transaction amount and the amount to settle.
    /// </remarks>
    protected void updateSettleDiscountAmounts(
        CustVendTransOpen _custVendTransOpen,
        AmountCur _settleAmount,
        AmountCur _discountAmount,
        boolean _updateBalancesOnly = false)
    {
        AmountCur adjustedDiscount;
        // <GBR>
        AmountCur interestAndFineAmount_BR;
        // </GBR>
        AmountCur settleAmount = _settleAmount;

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            interestAndFineAmount_BR = _custVendTransOpen.FineAmount_BR + _custVendTransOpen.InterestAmount_BR;
        }
        // </GBR>

        AmountCur remainingUnmarkedAmount = specTransManager.findUnmarkedAmountForRef(
            _custVendTransOpen.AmountCur,
            _custVendTransOpen.company(),
            _custVendTransOpen.TableId,
            _custVendTransOpen.RecId);

        if (!this.getFullSettlement(_custVendTransOpen))
        {
            if (abs(settleAmount) < abs(remainingUnmarkedAmount - _discountAmount))
            {
                settleAmount = this.getAdjustedSettleAmount(settleAmount, _discountAmount);
                // assume partial payment and discount allowed on partial, so take discount
                this.updateAmounts(
                    _custVendTransOpen,
                    // <GBR>
                    interestAndFineAmount_BR +
                    // </GBR>
                    settleAmount, // specTrans balance amount
                    // <GBR>
                    interestAndFineAmount_BR +
                    // </GBR>
                    settleAmount + _discountAmount, // amount to update balances
                    _discountAmount, // amount of cash discount
                    _updateBalancesOnly);
            }
            else if (abs(settleAmount) == abs(remainingUnmarkedAmount - _discountAmount))
            {
                // Settle amount is equal to the open trans amount less the discount - full discount is taken
                this.updateAmounts(
                    _custVendTransOpen,
                    // <GBR>
                    interestAndFineAmount_BR +
                    // </GBR>
                    remainingUnmarkedAmount - _discountAmount,
                    // <GBR>
                    interestAndFineAmount_BR +
                    // </GBR>
                    remainingUnmarkedAmount,
                    _discountAmount,
                    _updateBalancesOnly);
            }
            else if (abs(settleAmount) > abs(remainingUnmarkedAmount - _discountAmount) && abs(settleAmount) < abs(remainingUnmarkedAmount))
            {
                // Settle amount is greater than the open trans amount less the discount - adjust the discount taken
                adjustedDiscount = remainingUnmarkedAmount - settleAmount;

                this.updateAmounts(
                    _custVendTransOpen,
                    // <GBR>
                    interestAndFineAmount_BR +
                    // </GBR>
                    settleAmount,
                    // <GBR>
                    interestAndFineAmount_BR +
                    // </GBR>
                    remainingUnmarkedAmount,
                    adjustedDiscount,
                    _updateBalancesOnly);
            }
            else
            {
                // Full open trans amount and discount amount are used
                this.updateAmounts(
                    _custVendTransOpen,
                    // <GBR>
                    interestAndFineAmount_BR +
                    // </GBR>
                    remainingUnmarkedAmount - _discountAmount,
                    // <GBR>
                    interestAndFineAmount_BR +
                    // </GBR>
                    remainingUnmarkedAmount,
                    _discountAmount,
                    _updateBalancesOnly);
            }
        }
        else
        {
            this.updateAmounts(
                _custVendTransOpen,
                // <GBR>
                interestAndFineAmount_BR +
                // </GBR>
                remainingUnmarkedAmount - _discountAmount,
                // <GBR>
                interestAndFineAmount_BR +
                // </GBR>
                remainingUnmarkedAmount,
                _discountAmount,
                _updateBalancesOnly);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSettleDiscountAmountsWhenDiscountChanged</Name>
				<Source><![CDATA[
    internal void updateSettleDiscountAmountsWhenDiscountChanged(
        CustVendTransOpen _custVendTransOpen,
        AmountCur _settleAmount,
        AmountCur _oldDiscountAmount,
        AmountCur _discountAmount,
        boolean _updateBalancesOnly)
    {
        this.updateSettleDiscountAmounts(_custVendTransOpen, _settleAmount, _discountAmount, _updateBalancesOnly);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSpecTransWithSelectedDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>SpecTrans</c> records with the date to use to calculate the discount.
    /// </summary>
    /// <remarks>
    /// All <c>SpecTrans</c> records associated with the originator company, table ID, and record ID are
    /// updated.
    /// </remarks>
    public void updateSpecTransWithSelectedDate()
    {
        SpecTrans specTrans;

        update_recordset specTrans
        setting
            SelectedDateUsedToCalcCashDisc = dateUsedToCalcDisc
        where specTrans.SpecCompany == originator.company()
           && specTrans.SpecTableId == originator.TableId
           && specTrans.SpecRecId == originator.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the marked status of the specified open transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to update the marked status.
    /// </param>
    /// <param name="_updateTransMarked">
    /// The marked status with which to update the associated open transaction.
    /// </param>
    public void updateTransMarked(CustVendTransOpen _custVendTransOpen, NoYes _updateTransMarked)
    {
        CashDiscAmount cashDiscAmountToTake;
        CustVendTransOpenData custVendTransOpenData;
        CustVendTrans custVendTrans;
        // <GIN>
        boolean taxWithholdParameters = TaxWithholdParameters_IN::checkTaxParameters();
        CustTransOpen custTransOpenLoc;
        boolean settledAmountFromLine = false;
        CustTransOpen custTransOpen;
        // </GIN>
        VendTrans vendTrans;
        AmountCur settleAmount;
        AmountCur settleAmountAfterCashDisc;
        boolean isPwp;

        // <GBR>
        TaxWithholdTrans taxWithholdTrans;
        // </GBR>

        if (_custVendTransOpen.TableId == tableNum(VendTransOpen))
        {
            vendTrans = _custVendTransOpen.vendTrans();
        }

        if (_updateTransMarked == NoYes::No)
        {
            // If unmarked transaction was primary payment
            if (this.getMarkedPrimaryPayment(_custVendTransOpen) == NoYes::Yes)
            {
                this.updateMarkedPrimaryPayment(_custVendTransOpen, _updateTransMarked);
            }

            // Update balances
            balances.unmarkTrans(_custVendTransOpen, specTransManager.isMarkedPayment(_custVendTransOpen.company(), _custVendTransOpen.TableId, _custVendTransOpen.RecId));

            if (BrazilParameters::isEnabled())
            {
                // Clear interest and fines
                _custVendTransOpen.InterestAmount_BR = 0;
                _custVendTransOpen.InterestAmountPaymCur_BR = 0;
                _custVendTransOpen.FineAmount_BR = 0;
                _custVendTransOpen.FineAmountPaymCur_BR = 0;

                if (originator.TableId == tableNum(LedgerJournalTrans))
                {
                    select firstonly RecId from taxWithholdTrans
                        where taxWithholdTrans.CustVendTransOpenRecId_BR == _custVendTransOpen.RecId;

                    if (taxWithholdTrans)
                    {
                        TaxWithhold::uncheckWithholdTrans_BR(originator);
                    }
                }
            }

            // Delete SpecTrans
            specTransManager.delete(_custVendTransOpen.company(), _custVendTransOpen.TableId, _custVendTransOpen.RecId);

            if (taxWithholdParameters)
            {
                this.updateWHTMarkedTrans_IN(custVendTrans, _custVendTransOpen);
            }
        }
        else
        {
            if (specTransManager.findUnmarkedAmountForRef(
                _custVendTransOpen.AmountCur,
                _custVendTransOpen.company(),
                _custVendTransOpen.TableId,
                _custVendTransOpen.RecId) == 0.0)
            {
                str messageForMarkedTransaction = SpecTransManager::getTransactionMarkedMessageByRef(
                    _custVendTransOpen.company(),
                    _custVendTransOpen.TableId,
                    _custVendTransOpen.RecId);

                throw error(messageForMarkedTransaction);
            }

            // Verify that the MST currency of the transaction exists in the correct company
            this.checkDisplayMstCurrency(_custVendTransOpen);

            // Set up CustVendTransOpenData
            custVendTransOpenData = CustVendTransOpenData::construct(_custVendTransOpen);

            // Get posted transaction record
            custVendTrans = custVendTransOpenData.custVendTrans();

            if (CustVendTransData::construct(custVendTrans).isAdvanceInvoice_W())
            {
                throw error("@GLS114162");
            }

            // Check if a prepayment - warn & confirm with message
            if (skipPrePaymentSettlementWarning || !custVendTrans.Prepayment || Box::yesNo("@SYS68879", DialogButton::No) == DialogButton::Yes)
            {
                // Get applicable cash discount amount
                cashDiscAmountToTake = this.determineCashDiscAmountToTake(_custVendTransOpen, true);

                if (isConfigurationkeyEnabled(configurationKeyNum(Project)) && (_custVendTransOpen.TableId == tableNum(VendTransOpen)))
                {
                    if (_custVendTransOpen.checkPwpEnabled(_custVendTransOpen))
                    {
                        settleAmount = _custVendTransOpen.calcSettlementAmount(_custVendTransOpen);

                        if (settleAmount != 0)
                        {
                            settleAmountAfterCashDisc = settleAmount - cashDiscAmountToTake;
                        }

                        isPwp = true;
                    }
                }

                AmountCur remainingUnmarkedAmount = specTransManager.findUnmarkedAmountForRef(
                    _custVendTransOpen.AmountCur,
                    _custVendTransOpen.company(),
                    _custVendTransOpen.TableId,
                    _custVendTransOpen.RecId);

                if (BrazilParameters::isEnabled()
                    && (_custVendTransOpen.InterestAmount_BR || _custVendTransOpen.FineAmount_BR))
                {
                    // Insert SpecTrans
                    specTransManager.insert(
                        _custVendTransOpen.company(),
                        _custVendTransOpen.TableId,
                        _custVendTransOpen.RecId,
                        isPwp ? settleAmountAfterCashDisc :
                        remainingUnmarkedAmount - cashDiscAmountToTake + _custVendTransOpen.InterestAmount_BR + _custVendTransOpen.FineAmount_BR,
                        custVendTrans.CurrencyCode,
                        NoYes::No, // primary payment
                        cashDiscAmountToTake);

                    // Update balances
                    balances.markTrans(
                        _custVendTransOpen,
                        custVendTrans,
                        isPwp ? settleAmount :
                        remainingUnmarkedAmount + _custVendTransOpen.InterestAmount_BR + _custVendTransOpen.FineAmount_BR,
                        cashDiscAmountToTake,
                        specTransManager.findByRef(
                            _custVendTransOpen.company(),
                            _custVendTransOpen.TableId,
                            _custVendTransOpen.RecId).CrossRate);
                }
                else
                {
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
                    {
                        if (_custVendTransOpen.TableId == tableNum(CustTransOpen))
                        {
                            select firstonly RecId,SettledTotalAmount_IN from custTransOpenLoc
                            where custTransOpenLoc.RecId == _custVendTransOpen.RecId;
                            if (custTransOpenLoc.SettledTotalAmount_IN > 0)
                            {
                                settledAmountFromLine = true;
                            }
                        }
                    }

                    //if select lines to settle
                    if (settledAmountFromLine)
                    {
                        // Insert SpecTrans
                        specTransManager.insert(
                            _custVendTransOpen.company(),
                            _custVendTransOpen.TableId,
                            _custVendTransOpen.RecId,
                            isPwp ? settleAmountAfterCashDisc :
                            custTransOpenLoc.SettledTotalAmount_IN - cashDiscAmountToTake*custTransOpenLoc.SettledLinePercent_IN,
                            custVendTrans.CurrencyCode,
                            NoYes::No, // primary payment
                            cashDiscAmountToTake * custTransOpenLoc.SettledLinePercent_IN);

                        // Update balances
                        balances.markTrans(
                            _custVendTransOpen,
                            custVendTrans,
                            isPwp ? settleAmount :
                            custTransOpenLoc.SettledTotalAmount_IN,
                            cashDiscAmountToTake,
                            specTransManager.findByRef(
                                _custVendTransOpen.company(),
                                _custVendTransOpen.TableId,
                                _custVendTransOpen.RecId).CrossRate);

                        // update line settled amount
                        ttsbegin;

                        custTransOpen.skipDataMethods(true);

                        update_recordset custTransOpen
                            setting SettledTotalAmount_IN = -1,
                                    SettledLinePercent_IN = 0
                            where custTransOpen.RecId == custTransOpenLoc.RecId;

                        ttscommit;
                    }
                    else
                    {
                        // Insert SpecTrans
                        specTransManager.insert(
                            _custVendTransOpen.company(),
                            _custVendTransOpen.TableId,
                            _custVendTransOpen.RecId,
                            isPwp ? settleAmountAfterCashDisc :
                            // <GEERU>
                            remainingUnmarkedAmount - cashDiscAmountToTake - this.vatTaxAgentAmount_RU(_custVendTransOpen),
                            // </GEERU>
                            custVendTrans.CurrencyCode,
                            NoYes::No, // primary payment
                            cashDiscAmountToTake);

                        // Update balances
                        balances.markTrans(
                            _custVendTransOpen,
                            custVendTrans,
                            isPwp ? settleAmount :
                            // <GEERU>
                            remainingUnmarkedAmount - this.vatTaxAgentAmount_RU(_custVendTransOpen),
                            // </GEERU>
                            cashDiscAmountToTake,
                            specTransManager.findByRef(
                                _custVendTransOpen.company(),
                                _custVendTransOpen.TableId,
                                _custVendTransOpen.RecId).CrossRate);
                    }
                }

                if (taxWithholdParameters)
                {
                    this.updateWHTMarkedTrans_IN(custVendTrans, _custVendTransOpen, true);
                }
            }
        }
        this.updateFullSettlementCashDiscount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransMarkedAdjustJournals_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the marked status of the open transactions related to adjustment journal linked to specified original transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to update the marked status.
    /// </param>
    /// <param name="_updateTransMarked">
    /// The marked status with which to update the associated open transaction.
    /// </param>
    public void updateTransMarkedAdjustJournals_IN(CustVendTransOpen _custVendTransOpen, NoYes _updateTransMarked)
    {
        CustTrans_IN custTransIN;
        CustTransOpen custTransOpenloc;
        VendTransOpen vendTransOpenloc;
        VendTrans_IN vendTransIN;

        if (_custVendTransOpen.TableId == tableNum(CustTransOpen))
        {
            while select CustTrans, CustTransRefRecId from custTransIN
                where custTransIN.CustTransRefRecId == _custVendTransOpen.RefRecId
            {
                custTransOpenloc = CustTransOpen::findRefId(custTransIN.CustTrans);

                if ((_updateTransMarked == NoYes::Yes
                    && !specTransManager.exist(custTransOpenloc.company(), custTransOpenloc.TableId, custTransOpenloc.RecId))
                    || _updateTransMarked == NoYes::No)
                {
                    this.updateTransMarked(custTransOpenloc, _updateTransMarked);
                }
            }
        }
        else
        {
            while select VendTrans, VendTransRefRecId from vendTransIN
                where vendTransIN.VendTransRefRecId == _custVendTransOpen.RefRecId
            {
                vendTransOpenloc = VendTransOpen::findRefId(vendTransIN.VendTrans);

                if ((_updateTransMarked == NoYes::Yes
                    && !specTransManager.exist(vendTransOpenloc.company(), vendTransOpenloc.TableId, vendTransOpenloc.RecId))
                    || _updateTransMarked == NoYes::No)
                {
                    this.updateTransMarked(vendTransOpenloc, _updateTransMarked);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateUseCashDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the related records and balances for the specified open transaction for a change in the
    /// <c>UseCashDisc</c> field.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction associated with the updated <c>UseCashDisc</c> field.
    /// </param>
    public void updateUseCashDisc(CustVendTransOpen _custVendTransOpen)
    {
        CustVendTransCashDisc cashDiscTrans;
        CashDiscAmount cashDiscToTake;

        // Find the applicable discount trans as it could have changed when the discount usage changed
        cashDiscTrans = this.findApplicableCustVendTransCashDisc(_custVendTransOpen);

        // Update the cash discount cache
        this.addCustVendTransOpenCashDiscAmount(_custVendTransOpen, cashDiscTrans.CashDiscAmount);
        this.addCustVendTransOpenCashDiscDate(_custVendTransOpen, cashDiscTrans.CashDiscDate);

        // get the the discount to take
        cashDiscToTake = this.determineCashDiscAmountToTake(_custVendTransOpen, true);

        if (this.getTransMarked(_custVendTransOpen) == NoYes::Yes)
        {
            // The applicable discount was changed, update amounts for marked transaction
            this.updateSettleDiscountAmounts(
                _custVendTransOpen,
                specTransManager.findUnmarkedAmountForRef(
                    _custVendTransOpen.AmountCur,
                    _custVendTransOpen.company(),
                    _custVendTransOpen.TableId,
                    _custVendTransOpen.RecId),
                cashDiscToTake,
                false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWHTMarkedTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update marked withholding tax transactions.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The <c>CustVendTrans</c> map.
    /// </param>
    /// <param name="_custVendTransOpen">
    /// The <c>CustVendTransOpen</c> map.
    /// </param>
    /// <param name="_mark">
    /// Boolean value whether to mark the transaction or not.
    /// </param>
    private void updateWHTMarkedTrans_IN(CustVendTrans _custVendTrans,
                                         CustVendTransOpen _custVendTransOpen,
                                         boolean _mark = false)
    {
        TaxWithholdSettleTrans_IN taxWithholdSettleTrans;
        LedgerJournalType ledgerJournalType;
        LedgerJournalTrans ledgerJournalTrans;

        // Execute when there is Vendor Transaction...
        if (_custVendTransOpen.TableId == tableNum(VendTransOpen))
        {
            if (originator.TableId == tableNum(LedgerJournalTrans))
            {
                ledgerJournalTrans = originator;
                ledgerJournalType = ledgerJournalTrans.ledgerJournalTable().JournalType;
            }
            // To mark all Transaction in TaxWithholdsettleTrans_IN
            if (_mark &&
                _custVendTransOpen.TaxWithholdStatus_IN == NoYes::Yes &&
               (ledgerJournalType == LedgerJournalType::Daily
               || ledgerJournalType == LedgerJournalType::Payment))
            {
                taxWithholdSettleTrans.markTrans(_custVendTrans.RecId, _custVendTrans.Voucher, _custVendTransOpen.company());
                select sum(TaxAmount) from taxWithholdSettleTrans
                    where taxWithholdSettleTrans.Voucher == _custVendTrans.Voucher
                       && taxWithholdSettleTrans.Mark == NoYes::Yes
                       && taxWithholdSettleTrans.Closed == NoYes::No;
                if (taxWithholdSettleTrans.TaxAmount)
                {
                    taxWithholdSettleTrans.updateLedgerVoucher(ledgerJournalTrans.Voucher, _custVendTrans.Voucher);
                }
            }
            else
            {
                // To Unmark all Transaction in TaxWithholdsettleTrans_IN
                if (ledgerJournalType == LedgerJournalType::Daily
                   || ledgerJournalType == LedgerJournalType::Payment)
                {
                    taxWithholdSettleTrans.markTrans(_custVendTrans.RecId, _custVendTrans.Voucher, _custVendTransOpen.company());
                    taxWithholdSettleTrans.updateLedgerVoucher('', _custVendTrans.Voucher);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBankLCSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the settlement for the Letter of Credit.
    /// </summary>
    /// <returns>
    /// true if the validation is successful; otherwise, false.
    /// </returns>
    public boolean validateBankLCSettlement()
    {
        boolean ret = true;
        Map specTransMap;
        SpecTrans specTrans;
        MapEnumerator mapEnumerator;

        if (BankLCImportFeatureChecker::checkBankLCImportEnabled()
            || BankLCExportFeatureChecker::checkBankLCExportEnabled())
        {
            if (originator.TableId == tableNum(LedgerJournalTrans))
            {
                if (specTransManager.getSpecTransCount() > 1)
                {
                    specTransMap = specTransManager.getAllSpecTransMap();
                    mapEnumerator = specTransMap.getEnumerator();
                    while (mapEnumerator.moveNext())
                    {
                        specTrans = mapEnumerator.currentValue();
                        switch (specTrans.RefTableId)
                        {
                            case tableNum(VendTransOpen) :
                                if (specTrans.vendTransOpen().BankLCImportLine != 0)
                                {
                                    ret = false;
                                }
                                break;
                            case tableNum(CustTransOpen) :
                                if (specTrans.custTransOpen().BankLCExportLine != 0)
                                {
                                    ret = false;
                                }
                                break;
                        }

                        if (!ret)
                        {
                            // Only one Letter of Credit transaction can be selected for payment at a time.
                            checkFailed("@SYS321186");
                            break;
                        }
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCashDiscAmountToTake</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the cash discount amount to take.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The open transaction for which to validate.
    /// </param>
    /// <param name="_cashDiscAmountToTake">
    /// The cash discount amount to take to validate.
    /// </param>
    /// <param name="_validateDiscOnCreditNote">
    /// A Boolean value that indicates whether to validate when discounts are enabled on credit notes.
    /// </param>
    /// <returns>
    /// The valid cash discount amount to take.
    /// </returns>
    public CashDiscAmount validateCashDiscAmountToTake(
        CustVendTransOpen _custVendTransOpen,
        AmountCur _cashDiscAmountToTake,
        boolean _validateDiscOnCreditNote)
    {
        CashDiscAmount returnCashDiscAmountToTake = _cashDiscAmountToTake;
        CashDiscAmount maxCashDiscToTake;

        maxCashDiscToTake = this.determineCashDiscAmountToTake(_custVendTransOpen, _validateDiscOnCreditNote);

        // validate that discount to take is less than or equal to full discount less discount taken
        if ((abs(_cashDiscAmountToTake)) > (abs(maxCashDiscToTake)))
        {
            returnCashDiscAmountToTake = maxCashDiscToTake;
        }

        // validate that discount is same sign as transaction
        if ( (_cashDiscAmountToTake > 0 && _custVendTransOpen.AmountCur < 0)
            || (_cashDiscAmountToTake < 0 && _custVendTransOpen.AmountCur > 0) )
        {
            returnCashDiscAmountToTake = maxCashDiscToTake;
        }

        return returnCashDiscAmountToTake;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCashDiscAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the cash discount amount that is entered to override the calculated amount.
    /// </summary>
    /// <param name = "_custVendTransOpen">The open transaction for which to validate.</param>
    /// <param name = "_cashDiscAmount">The cash discount amount to validate.</param>
    /// <returns>true if the value is valid; otherwise false.</returns>
    public boolean validateCashDiscAmount(
        CustVendTransOpen _custVendTransOpen,
        CashDiscAmount _cashDiscAmount)
    {
        boolean isValid = true;

        if ((_cashDiscAmount > 0 && _custVendTransOpen.AmountCur < 0)
             || (_cashDiscAmount < 0 && _custVendTransOpen.AmountCur > 0))
        {
            // The signs of the discount & open transaction amount are not the same
            isValid = checkFailed("@SYS68141");
        }

        // Cash discount can't be more than the transaction amount
        if (abs(_cashDiscAmount) > abs(_custVendTransOpen.AmountCur))
        {
            isValid = false;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateMarkedTotalWithinOverUnder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether an OK or Cancel message box is displayed and retrieves the selection from the
    /// message box.
    /// </summary>
    /// <returns>
    /// true if processing should continue; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The message box will display when partial payments are enabled, but the marked amount is not zero
    /// and is not in the overpayment or underpayment amount for the current company. The message box will
    /// not be displayed when the date used for calculating discounts is set to the transaction date.
    /// </remarks>
    public boolean validateMarkedTotalWithinOverUnder()
    {
        boolean canContinue = true;
        boolean skipMessage = false;
        boolean discountExists;
        DialogButton continueOkSelection;
        AmountCur overUnderAmount;
        boolean allowCashDiscOnPartialPaym;
        CustParameters custParameters;
        VendParameters vendParameters;
        LedgerJournalTrans ledgerJournalTrans;
        Map markedTransactions;
        MapEnumerator currentTransaction;
        SpecTrans currentSpecTrans;

        // Skip check when originator is LedgerJournalTrans and the amount of the LedgerJournalTrans is zero
        if (originator.TableId == tableNum(LedgerJournalTrans))
        {
            ledgerJournalTrans = originator;
            if (ledgerJournalTrans.amount() == 0)
            {
                skipMessage = true;
            }
        }

        // Only display message box when date used for calculation discount is selected date and there are transactions
        // marked and source is LedgerJournalTrans, CustTable or VendTable.
        if (skipMessage == false
            && dateTypeUsedToCalcDisc == CashDiscUsedToCalcDisc::SelectedDate
            && specTransManager.getSpecTransCount() != 0
            && (originator.TableId == tableNum(LedgerJournalTrans) || originator.TableId == tableNum(CustTable)
                || originator.TableId == tableNum(VendTable)))
        {
            // check if any marked transaction has a discount and marked transations are in current company mst currency
            markedTransactions = specTransManager.getAllSpecTransMap();

            currentTransaction = new MapEnumerator(markedTransactions);

            while (currentTransaction.moveNext())
            {
                currentSpecTrans = currentTransaction.currentValue();
                if (currentSpecTrans.CashDiscToTake != 0)
                {
                    discountExists = true;
                }
                if (currentSpecTrans.RefCompany != curext() || currentSpecTrans.Code != CompanyInfoHelper::standardCurrency())
                {
                    skipMessage = true;
                    break;
                }
            }

            if (skipMessage == false && discountExists == true)
            {
                changecompany(curext())
                {
                    // Find parameter record for the current company
                    if (module == SysModule::Cust)
                    {
                        custParameters = CustParameters::find();
                        overUnderAmount = custParameters.MaxMSTOverUnder;
                        allowCashDiscOnPartialPaym = custParameters.CashDiscForPartialPaym;
                    }
                    else
                    {
                        vendParameters = VendParameters::find();
                        overUnderAmount = vendParameters.MaxMSTOverUnder;
                        allowCashDiscOnPartialPaym = vendParameters.CashDiscForPartialPaym;
                    }
                }

                // Additional check that allow partial payment is true and marked total is greater than the over/under
                // for current company.
                if (allowCashDiscOnPartialPaym == true
                    && abs(this.getMarkedTotalMst()) > overUnderAmount)
                {
                    continueOkSelection = Box::okCancel("@SYS128703", DialogButton::Cancel);

                    canContinue = (continueOkSelection == DialogButton::Ok) ? true : false;
                }
            }
        }

        return canContinue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateMarkedWithCrossRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the cross rate.
    /// </summary>
    /// <returns>
    /// true if processing should continue; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The cross rate can be used when the invoice and payment currencies are different.
    /// </remarks>
    public boolean validateMarkedWithCrossRate()
    {
        SpecTrans currentSpecTrans;
        CurrencyCode currency;
        Map markedTransactions;
        MapEnumerator currentTransaction;
        Set invoiceCurrencySet;
        Set paymentCurrencySet;
        Set intersectionSet;
        boolean wasCrossRateEntered;
        boolean isValid = true;

        if (originator.TableId == tableNum(LedgerJournalTrans))
        {
            return true;
        }

        if ((originator.TableId == tableNum(VendTable)
            || originator.TableId == tableNum(CustTable))
            && specTransManager.getSpecTransCount() != 0)
        {
            invoiceCurrencySet = new Set(Types::String);
            paymentCurrencySet = new Set(Types::String);

            markedTransactions = specTransManager.getAllSpecTransMap();
            currentTransaction = new MapEnumerator(markedTransactions);

            while (currentTransaction.moveNext())
            {
                currentSpecTrans = currentTransaction.currentValue();
                if (currentSpecTrans.CrossRate)
                {
                    wasCrossRateEntered = true;
                }

                currency = currentSpecTrans.Code;
                if (currency)
                {
                    if (currentSpecTrans.Payment)
                    {
                        paymentCurrencySet.add(currency);
                    }
                    else
                    {
                        invoiceCurrencySet.add(currency);
                    }
                }
            }

            if (wasCrossRateEntered)
            {
                intersectionSet = Set::intersection(invoiceCurrencySet, paymentCurrencySet);

                if (intersectionSet.elements() > 0 )
                {
                    isValid = checkFailed("@SYS4010038");
                }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSettlePostingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the settlement posting type and date.
    /// </summary>
    /// <param name="_settlePostingType">
    /// The settlement posting type to validate.
    /// </param>
    /// <param name="_settlePostingDate">
    /// The settlement posting date to validate.
    /// </param>
    /// <returns>
    /// true if the settlement posting type and date are valid; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method validates that the settlement posting date is after the latest marked transaction date,
    /// and that the settlement posting date is not blank if the settlement posting type is the
    /// <c>SelectDate</c> enumeration value.
    /// </remarks>
    public boolean validateSettlePostingDate(SettleDatePrinc _settlePostingType, TransDate _settlePostingDate)
    {
        TransDate maxMarkedTransDate = maxDate();
        SpecTrans latestSpecTrans;
        CustTransOpen latestCustTransOpen;
        VendTransOpen latestVendTransOpen;
        DocumentDate documentDate;
        #ISOCountryRegionCodes

        if (_settlePostingDate != dateNull())
        {
            // Find the latest transaction to be settled
            switch (originator.TableId)
            {
                // <GEEU>
                case tableNum(CustInvoiceJour):
                // </GEEU>
                case tableNum(CustTable), tableNum(SalesTable), tableNum(CustInvoiceTable), tableNum(CustTrans):
                    select firstonly crosscompany:sharedServiceCompanies TransDate from latestCustTransOpen
                        order by latestCustTransOpen.TransDate desc
                        join latestSpecTrans
                            where latestSpecTrans.SpecCompany == originator.DataAreaId &&
                            latestSpecTrans.SpecTableId == originator.TableId &&
                            latestSpecTrans.SpecRecId == originator.RecId &&
                            latestCustTransOpen.TableId == latestSpecTrans.RefTableId &&
                            latestCustTransOpen.RecId == latestSpecTrans.RefRecId;

                    maxMarkedTransDate = latestCustTransOpen.TransDate;

                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT]))
                    {
                        documentDate = latestSpecTrans.custTrans().DocumentDate;

                        if (documentDate && (documentDate < maxMarkedTransDate))
                        {
                            maxMarkedTransDate = documentDate;
                        }
                    }

                    break;

                case tableNum(VendTable), tableNum(PurchTable), tableNum(VendTrans):
                    select firstonly crosscompany:sharedServiceCompanies TransDate from latestVendTransOpen
                        order by latestVendTransOpen.TransDate desc
                        join latestSpecTrans
                            where latestSpecTrans.SpecCompany == originator.DataAreaId &&
                            latestSpecTrans.SpecTableId == originator.TableId &&
                            latestSpecTrans.SpecRecId == originator.RecId &&
                            latestVendTransOpen.TableId == latestSpecTrans.RefTableId &&
                            latestVendTransOpen.RecId == latestSpecTrans.RefRecId;

                    maxMarkedTransDate = latestVendTransOpen.TransDate;

                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT]))
                    {
                        documentDate = latestSpecTrans.vendTrans().DocumentDate;

                        if (documentDate && (documentDate < maxMarkedTransDate))
                        {
                            maxMarkedTransDate = documentDate;
                        }
                    }

                    break;

                // <GEERU>
                case tableNum(LedgerJournalTrans):
                    LedgerJournalTrans ledgerjournalTrans = originator;

                    if (countryRegion_RU)
                    {
                        if (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
                        {
                            select firstonly crosscompany:sharedServiceCompanies TransDate from latestCustTransOpen
                                order by latestCustTransOpen.TransDate desc
                            exists join latestSpecTrans
                                where latestSpecTrans.SpecCompany == originator.DataAreaId &&
                                latestSpecTrans.SpecTableId == originator.TableId &&
                                latestSpecTrans.SpecRecId == originator.RecId &&
                                latestCustTransOpen.TableId == latestSpecTrans.RefTableId &&
                                latestCustTransOpen.RecId == latestSpecTrans.RefRecId;

                            maxMarkedTransDate = latestCustTransOpen.TransDate;
                        }
                        else if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
                        {
                            select firstonly crosscompany:sharedServiceCompanies TransDate from latestVendTransOpen
                                order by latestVendTransOpen.TransDate desc
                            exists join latestSpecTrans
                                where latestSpecTrans.SpecCompany == originator.DataAreaId &&
                                latestSpecTrans.SpecTableId == originator.TableId &&
                                latestSpecTrans.SpecRecId == originator.RecId &&
                                latestVendTransOpen.TableId == latestSpecTrans.RefTableId &&
                                latestVendTransOpen.RecId == latestSpecTrans.RefRecId;

                            maxMarkedTransDate = latestVendTransOpen.TransDate;
                        }

                        if (maxMarkedTransDate && ledgerJournalTrans.TransDate > maxMarkedTransDate)
                        {
                            maxMarkedTransDate = ledgerJournalTrans.TransDate;
                        }
                    }

                    break;
                // </GEERU>

                default:
                    Debug::assert(false);
                    break;
            }

            // The settlement posting date cannot be before the latest transaction to be settled
            if (maxMarkedTransDate > _settlePostingDate)
            {
                error(strFmt("@SYS86343", date2StrUsr(_settlePostingDate, DateFlags::FormatAll), date2StrUsr(maxMarkedTransDate, DateFlags::FormatAll)));
                return false;
            }
        }
        else
        {
            // The settlement posting date cannot be blank if the type is selected date
            if (_settlePostingType == SettleDatePrinc::SelectDate)
            {
                error("@SYS101212");
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateVendPaymentGroupTransMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs validation to make sure that the supplied payment group may be marked.
    /// </summary>
    /// <param name="_vendPaymentGroup">
    /// The payment group to be marked.
    /// </param>
    /// <param name="_invoicesToBeMarked">
    /// A container of records that are to be marked.
    /// </param>
    /// <param name="_isPaymentGroupModifyEvent">
    /// true if the method was called due to a payment group value being modified; otherwise, false.
    /// </param>
    /// <param name="_agreementHeaderExtRecId">
    /// The agreement RecIa that the records in the _invoicesToBeMarked container belong to.
    /// </param>
    /// <param name="_debitCreditAll">
    /// debit/Credit/All(Unknown) sign. != Unknown in case this method is called from VendOpenTrans_RU form with two vendOpenTrans data sources? one debit and one credit
    /// </param>///
    /// <returns>
    /// true if the payment group may be marked; otherwise, false.
    /// </returns>
    protected boolean validateVendPaymentGroupTransMarked(
        VendPaymentGrouping _vendPaymentGroup,
        container _invoicesToBeMarked,
        boolean _isPaymentGroupModifyEvent,
        AgreementHeaderExtRecId_RU _agreementHeaderExtRecId = 0,
        DebCredUnknown_RU _debitCreditAll = DebCredUnknown_RU::Unknown)
    {
        List containerRecords;
        Enumerator listEnumerator;

        //make a list from the container so that I can iterate it.
        containerRecords = con2List(_invoicesToBeMarked);

        //validate if there are any unposted invoices with the group
        if (this.checkForUnpostInvoicesForPaymentGroup(_vendPaymentGroup, sharedServiceCompanies))
        {
            return false;
        }

        listEnumerator = containerRecords.getEnumerator();

        //make sure that there are no settlements being filtered off the form by checking the container (which contains records on the form only) against what is in VendTrans.
        // <GEERU>
        if (! this.checkForFilteredRecordsWithPaymentGroup(_vendPaymentGroup,
            containerRecords,
            sharedServiceCompanies,
            _agreementHeaderExtRecId,
            _debitCreditAll))
        // </GEERU>
        {
            return false;
        }

        //iterate through all the of the records to be marked and perform other validations.
        if (!this.checkPaymentGroupIndividualRecords(containerRecords, _vendPaymentGroup, sharedServiceCompanies, _isPaymentGroupModifyEvent))
        {
            return false;
        }

        //everything passed
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatTaxAgentAmount_RU</Name>
				<Source><![CDATA[
    public AmountCur vatTaxAgentAmount_RU(CustVendTransOpen _custVendTransOpen)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendPaymentGroupsUpdateTransMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs validation on the record to be marked or unmarked and then makes sure that any records
    /// with a different payment group are unmarked and any with the same payment group are marked.
    /// </summary>
    /// <param name="_custVendTransOpen">
    /// The record that will be marked or unmarked.
    /// </param>
    /// <param name="_markTrans">
    /// Yes if the record is to be marked; otherwise, No.
    /// </param>
    /// <param name="_vendTransOpen">
    /// The form data source that contains all records that can be viewed on the calling form.
    /// </param>
    /// <param name="_vendPaymentGroup">
    /// The payment group of the record to be marked.
    /// </param>
    /// <param name="_taxWithhold">
    /// The tax withholding object that must be updated when a record is updated.
    /// </param>
    /// <param name="_originator">
    /// The calling table that contains company information that will be used for cross company queries.
    /// </param>
    /// <param name="_isPaymentGroupModifyEvent">
    /// true if the method was called due to a payment group value being modified; otherwise, false.
    /// </param>
    /// <param name="_debitCreditAll">
    /// debit/Credit/All(Unknown) sign. != Unknown in case this method is called from VendOpenTrans_RU form with two vendOpenTrans data sources? one debit and one credit
    /// </param>
    public void vendPaymentGroupsUpdateTransMarked(
        CustVendTransOpen _custVendTransOpen,
        NoYes _markTrans,
        FormDataSource _vendTransOpen,
        VendPaymentGrouping _vendPaymentGroup,
        TaxWithhold _taxWithhold,
        Common _originator,
        boolean _isPaymentGroupModifyEvent,
        DebCredUnknown_RU _debitCreditAll = DebCredUnknown_RU::Unknown)
    {
        container invoicesToBeMarked;
        container invoicesToBeUnMarked;
        List invoicesToBeMarkedList;
        List invoicesToBeUnMarkedList;
        Enumerator invoicesToBeMarkedEnum;
        Enumerator invoicesToBeUnMarkedEnum;
        int vendTransOpenDSPosition = _vendTransOpen.getPosition();
        // <GEERU>
        CustVendTrans custVendTrans = CustVendTransOpenData::construct(_custVendTransOpen).custVendTrans();
        AgreementHeaderExt_RU agreementHeaderExt;
        // </GEERU>

        VendTransOpen vendTransOpen;
        // <GEERU>
        if (countryRegion_RU && custVendTrans.DefaultDimension)
        {
            agreementHeaderExt = AgreementHeaderExt_RU::findByDefaultDimension(custVendTrans.DefaultDimension);
        }
        // </GEERU>

        //we are marking the record
        if (_markTrans == NoYes::Yes)
        {
            //if the payment group is not blank then we need to run payment group specific validation and get a whole bunch of other records (potentially).
            if (_vendPaymentGroup != '')
            {
                // <GEERU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                {
                    invoicesToBeMarked = CustVendOpenTransManager::getPaymentGroupInvoicesToMark(_vendPaymentGroup,
                                                                                                 _vendTransOpen,
                                                                                                 agreementHeaderExt.RecId);
                }
                else
                {
                // </GEERU>
                    invoicesToBeMarked = CustVendOpenTransManager::getPaymentGroupInvoicesToMark(_vendPaymentGroup, _vendTransOpen);
                // <GEERU>
                }
                // </GEERU>

                //if the validation does not pass then bail out now.
                // <GEERU>
                if (!this.validateVendPaymentGroupTransMarked(_vendPaymentGroup,
                    invoicesToBeMarked,
                    _isPaymentGroupModifyEvent,
                    agreementHeaderExt.RecId,
                    _debitCreditAll))
                // </GEERU>
                {
                    return;
                }
            }
            else
            {
            //
            //the payment group is empty, we want to check this in the "normal" way, this means fill the container with the record passed in and call the mark method.
            //We only have this coming into this method so we can unmark payment groups later.
            //
                invoicesToBeMarked = [_custVendTransOpen];
            }

            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                invoicesToBeUnMarked = CustVendOpenTransManager::getPaymentGroupInvoicesToUnMark(_vendPaymentGroup,
                                                                                                 _markTrans,
                                                                                                 specTransManager,
                                                                                                 originator,
                                                                                                 agreementHeaderExt.RecId);
            }
            else
            {
            // </GEERU>
                invoicesToBeUnMarked = CustVendOpenTransManager::getPaymentGroupInvoicesToUnMark(_vendPaymentGroup, _markTrans, specTransManager, originator);
            // <GEERU>
            }
            // </GEERU>
        }
        else
        {
        //we are unmarking the record
            //if the paymentGroup is not empty unmark other records in that group
            if (_vendPaymentGroup != '')
            {
                // <GEERU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                {
                    invoicesToBeUnMarked = CustVendOpenTransManager::getPaymentGroupInvoicesToUnMark(_vendPaymentGroup,
                                                                                                     _markTrans,
                                                                                                     specTransManager,
                                                                                                     originator,
                                                                                                     agreementHeaderExt.RecId);
                }
                else
                {
                // </GEERU>
                    invoicesToBeUnMarked = CustVendOpenTransManager::getPaymentGroupInvoicesToUnMark(_vendPaymentGroup, _markTrans, specTransManager, originator);
                // <GEERU>
                }
                // </GEERU>
            }
            else
            {
            //if the paymentGroup is empty only unmark that record
                invoicesToBeUnMarked = [_custVendTransOpen];
            }
        }

        //get the marking list and Enumerator
        invoicesToBeMarkedList = con2List(invoicesToBeMarked);
        invoicesToBeMarkedEnum = invoicesToBeMarkedList.getEnumerator();

        //display warning messages about multiple records being unmarked.
        this.checkUnmarkingVendPaymentGroup(invoicesToBeUnMarked, _vendPaymentGroup, _markTrans, invoicesToBeMarkedList.elements());

        //Now that we know what groups to mark or unmark, and that they are all valid, lets perform the marking and unmarking.

        //get the UnMarking list and Enumerator
        invoicesToBeUnMarkedList = con2List(invoicesToBeUnMarked);
        invoicesToBeUnMarkedEnum = invoicesToBeUnMarkedList.getEnumerator();

        //mark and unmark records.
        this.markVendPaymentGroups(invoicesToBeMarkedEnum, invoicesToBeUnMarkedEnum);

        //now that all the records have been marked we need to create the taxWithholding form marked records that would have been done at the form level.

        //reset the enumerator
        invoicesToBeMarkedEnum.reset();

        //Create a taxwithholding object for each record.
        while (invoicesToBeMarkedEnum.moveNext())
        {
            vendTransOpen = invoicesToBeMarkedEnum.current();

            if (_originator.TableId == tableNum(LedgerJournalTrans))
            {
                this.createTaxWithholding(vendTransOpen, _taxWithhold);
            }
        }

        //reset the position of the datasource
        _vendTransOpen.setPosition(vendTransOpenDSPosition);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVendOpenTransFormPost_SLN</Name>
				<Source><![CDATA[
    [PostHandlerFor(classStr(CustVendOpenTransManager), methodstr(CustVendOpenTransManager, updateTransMarked))]
    /// <summary>
    /// Validates the <c>VendOpenTrans</c> form.
    /// </summary>
    /// <param name="_xppPrePostArgs">
    /// The <c>XPPPrePostArgs</c> class instance to pass arguments.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Throws exception when payment hold.
    /// </exception>
    public static void checkVendOpenTransFormPost_SLN(XppPrePostArgs _xppPrePostArgs)
    {
        CustVendOpenTransManager custVendOpenTransManager = _xppPrePostArgs.getThis();
        CustVendTransOpen custVendTransOpenLocal = _xppPrePostArgs.getArg('_custVendTransOpen');
        NoYes updateMarkedTrans = _xppPrePostArgs.getArg('_updateTransMarked');
        VendOpenTransForm vendOpenTransFormLocal = custVendOpenTransManager.parmVendOpenTransForm();
        #ISOCountryRegionCodes

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            if (updateMarkedTrans == NoYes::No)
            {
                if (custVendTransOpenLocal.TableId == tableNum(VendTransOpen))
                {
                    vendOpenTransFormLocal.existTransWithDiffVendBankOnUnMark();
                }
            }
            else
            {
                if (custVendOpenTransManager.shouldPromptUserToMarkRecordsWithDifferentBank(custVendTransOpenLocal))
                {
                    if (!vendOpenTransFormLocal.promptToMarkRecordsWithDiffBank(custVendTransOpenLocal))
                    {
                        return;
                    }
                }

                if (PublicSectorUtils::isFrenchRegulatoryEnabled() &&
                    VendInvoiceHoldHistory::isPlaceInHold(VendTrans::find(custVendTransOpenLocal.RefRecId).RecId, tableNum(VendTrans)) &&
                    custVendTransOpenLocal.TableId == tableNum(VendTransOpen))
                {
                    throw error("@SPS1894");
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldPromptUserToMarkRecordsWithDifferentBank</Name>
				<Source><![CDATA[
    private boolean shouldPromptUserToMarkRecordsWithDifferentBank(CustVendTransOpen _custVendTransOpen)
    {
        return this.paymentFromJournal
            && _custVendTransOpen.TableId == tableNum(VendTransOpen)
            && !VendTrans::find(_custVendTransOpen.RefRecId).VendPaymentGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearInterestAndFineAmounts_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Setting to zero Interest/Fine amounts of the linked OpenTrans
    /// </summary>
    /// <param name="_specCompany">
    /// The spec company of the <c>SpecTrans</c> records.
    /// </param>
    /// <param name="_specTableId">
    /// The spec table ID of the <c>SpecTrans</c> .
    /// </param>
    /// <param name="_specRecId">
    /// The spec record ID of the <c>SpecTrans</c> record .
    /// </param>
    public static void clearInterestAndFineAmounts_BR(
        CompanyId _specCompany,
        TableId _specTableId,
        RefRecId _specRecId)
    {
        CustTransOpen custTransOpen;
        VendTransOpen vendTransOpen;
        SpecTrans specTrans;
        SpecTrans specTrans2;

        ttsbegin;

        changecompany(_specCompany)
        {
            custTransOpen.skipDataMethods(true);

            update_recordset custTransOpen
                setting InterestAmount_BR = 0,
                        InterestAmountPaymCur_BR = 0,
                        FineAmount_BR = 0,
                        FineAmountPaymCur_BR = 0
                join specTrans
                where specTrans.SpecCompany == _specCompany &&
                      specTrans.SpecTableId == _specTableId &&
                      specTrans.SpecRecId == _specRecId &&
                      custTransOpen.TableId == specTrans.RefTableId &&
                      custTransOpen.RecId == specTrans.RefRecId
                // In certain scenarios when editing a payment proposal, it is possible for the same
                // CustVendTransOpen record to be link to more than one specTrans record. Only clear
                // the fine and interest amounts if CustVendTransOpen record is only linked to the current
                // specTrans
                notexists join specTrans2
                    where specTrans2.RefCompany == specTrans.RefCompany &&
                          specTrans2.RefTableId == specTrans.RefTableId &&
                          specTrans2.RefRecId == specTrans.RefRecId &&
                          specTrans2.RecId != specTrans.RecId;

            vendTransOpen.skipDataMethods(true);

            update_recordset vendTransOpen
                setting InterestAmount_BR = 0,
                        InterestAmountPaymCur_BR = 0,
                        FineAmount_BR = 0,
                        FineAmountPaymCur_BR = 0
                join specTrans
                where specTrans.SpecCompany == _specCompany &&
                      specTrans.SpecTableId == _specTableId &&
                      specTrans.SpecRecId == _specRecId &&
                      vendTransOpen.TableId == specTrans.RefTableId &&
                      vendTransOpen.RecId == specTrans.RefRecId
                notexists join specTrans2
                    where specTrans2.RefCompany == specTrans.RefCompany &&
                          specTrans2.RefTableId == specTrans.RefTableId &&
                          specTrans2.RefRecId == specTrans.RefRecId &&
                          specTrans2.RecId != specTrans.RecId;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static CustVendOpenTransManager construct(Common _originator)
    {
        return new CustVendOpenTransManager(_originator);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findApplicableCashDisc_Server</Name>
				<Source><![CDATA[
    private static CustVendTransCashDisc findApplicableCashDisc_Server(
        CustVendTransOpen _custVendTransOpen,
        TransDate _discountDate,
        DiscGraceDays _graceDays)
    {
        CustVendTransCashDisc cashDiscTrans;
        CustTrans custTrans;
        VendTrans vendTrans;
        boolean isCreditNote;

        // Find applicable cash discount trans record - may be cross company
        changecompany(_custVendTransOpen.company())
        {
            switch (_custVendTransOpen.TableId)
            {
                case tableNum(CustTransOpen):
                    if (_custVendTransOpen.UseCashDisc == UseCashDisc::Normal ||
                        _custVendTransOpen.UseCashDisc == UseCashDisc::Always)
                    {
                        cashDiscTrans = CustTransCashDisc::findByUseCashDisc(tableNum(CustTransOpen),
                                            _custVendTransOpen.RecId,
                                            _custVendTransOpen.UseCashDisc,
                                            _discountDate,
                                            _graceDays);
                    }

                    custTrans = _custVendTransOpen.custTrans();
                    if (custTrans.RecId != 0)
                    {
                        isCreditNote = custTrans.isCreditNote();
                    }

                    if (_custVendTransOpen.UseCashDisc == UseCashDisc::Never
                        || cashDiscTrans.RecId == 0
                        || (isCreditNote == true && CustParameters::find().CashDiscForCreditNote == false))
                    {
                        // Get the Due record if UseCashDisc == Never or no cash discount record was found
                        cashDiscTrans = CustTransCashDisc::findDue(tableNum(CustTransOpen), _custVendTransOpen.RecId, false);
                    }
                    break;

                case tableNum(VendTransOpen):
                    if (_custVendTransOpen.UseCashDisc == UseCashDisc::Normal ||
                        _custVendTransOpen.UseCashDisc == UseCashDisc::Always)
                    {
                        cashDiscTrans = VendTransCashDisc::findByUseCashDisc(tableNum(VendTransOpen),
                                            _custVendTransOpen.RecId,
                                            _custVendTransOpen.UseCashDisc,
                                            _discountDate,
                                            _graceDays);
                    }

                    vendTrans = _custVendTransOpen.vendTrans();
                    if (vendTrans.RecId != 0)
                    {
                        isCreditNote = vendTrans.isCreditNote();
                    }

                    if (_custVendTransOpen.UseCashDisc == UseCashDisc::Never
                        || cashDiscTrans.RecId == 0
                        || (isCreditNote == true && VendParameters::find().CashDiscForCreditNote == false))
                    {
                        // Get the Due record if UseCashDisc == Never or no cash discount record was found
                        cashDiscTrans = VendTransCashDisc::findDue(tableNum(VendTransOpen), _custVendTransOpen.RecId, false);
                    }
                    break;
            }
        }

        return cashDiscTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSharedServiceCompanies</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the company accounts in the <c>OMHierarchyType</c> table that are associated with the
    /// Centralized Payments <c>HierarchyPurpose</c> enumeration value for the specified company account.
    /// </summary>
    /// <param name="_companyId">
    /// The company for which to find the associated company accounts.
    /// </param>
    /// <returns>
    /// A container of company accounts.
    /// </returns>
    /// <remarks>
    /// If the specified company is not part of a hierarchy that is assigned to the
    /// <c>CentralizedPayments</c> purpose, the returned container will contain the specified company.
    /// </remarks>
    public static container findSharedServiceCompanies(CompanyId _companyId)
    {
        OMExplodedOrganizationSecurityGraph explodedOrg;
        OMHierarchyType omHierarchyType;
        CompanyInfo companyInfo;
        RecId omHierarchyTypeRecId;
        container companies;
        Array organizationHierarchyRecIds;
        int arrayLength;
        utcdatetime currentClientSessionDateTime = DateTimeUtil::applyTimeZoneOffset(DateTimeUtil::getSystemDateTime(), DateTimeUtil::getUserPreferredTimeZone());
        date currentClientSessionDate = DateTimeUtil::date(currentClientSessionDateTime);

        companies = CustVendCache::getValue(CustVendCacheScope::CentralizedPaymentLegalEntity, [_companyId, currentClientSessionDate]);

        if (companies == conNull())
        {
            // Get the first OMHiearchyType where the purpose is CentralizedPayments and that
            // also contains this companyId legal entity.
            organizationHierarchyRecIds = OMMultipleHierarchy::FindOrganizationHierarchies(
                CompanyInfo::findDataArea(_companyId).RecId,
                HierarchyPurpose::CentralizedPayments,
                DateTimeUtil::getSystemDateTime(),
                DateTimeUtil::maxValue());

            // There should be at most one hierarchy assigned to a Centralized Payment purpose that contains any
            // particular legal entity
            arrayLength = organizationHierarchyRecIds.lastIndex();
            Debug::assert(arrayLength == 0 || arrayLength == 1);

            // If the array is populated, meaning there is a CentralizedPayments org model hierarchy,
            // then cache the RecId locally for this method.
            if (arrayLength)
            {
                omHierarchyTypeRecId = organizationHierarchyRecIds.value(1);
            }

            if (omHierarchyTypeRecId)
            {
                // Then grab all of the Legal Entities that are part of this hierarchy.
                while select validtimestate(currentClientSessionDateTime) RecId from explodedOrg
                        where explodedOrg.Distance == 0
                    join Name from omHierarchyType
                        where explodedOrg.omHierarchyType == omHierarchyType.RecId
                            && omHierarchyType.RecId == omHierarchyTypeRecId
                    join DataArea from companyInfo
                        where companyInfo.RecId == explodedOrg.Organization
                {
                    companies += companyInfo.DataArea;
                }
            }

            if (!companies)
            {
                companies = [_companyId];
            }

            CustVendCache::insertValue(CustVendCacheScope::CentralizedPaymentLegalEntity, [_companyId, currentClientSessionDate], companies);
        }

        return companies;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentGroupInvoicesToMark</Name>
				<Source><![CDATA[
    /// <summary>
    /// Iterates the <c>vendOpenTrans</c> data source supplied and fills a container of
    /// <c>vendTransOpen</c> records that are associated with the passed in payment group.
    /// </summary>
    /// <param name="_vendPaymentGroup">
    /// The payment group for which associated records should be selected.
    /// </param>
    /// <param name="_vendOpenTransDS">
    /// The <c>vendOpenTrans</c> data source that contains the records to be selected from.
    /// </param>
    /// <param name="_agreementHeaderExtRecId">
    /// The agreement RecId for which associated records should be selected.
    /// </param>///
    /// <returns>
    /// A container of <c>VendTransOpen</c> records.
    /// </returns>
    private static container getPaymentGroupInvoicesToMark(
        VendPaymentGrouping _vendPaymentGroup,
        FormDataSource _vendOpenTransDS,
        AgreementHeaderExtRecId_RU _agreementHeaderExtRecId = 0)
    {
        container vendTransOpenContainer;
        VendTransOpen vendTransOpen;
        VendTrans vendTrans;
        container refCompany;

        //iterate the datasource and grab all vendTrans records that have the passed in group, stick the corresponding vendTransOpen records in the container.
        for (vendTransOpen = _vendOpenTransDS.getFirst() ? _vendOpenTransDS.getFirst() : _vendOpenTransDS.cursor(); vendTransOpen; vendTransOpen = _vendOpenTransDS.getNext())
        {
            refCompany = [vendTransOpen.company()];

            select firstonly crosscompany:refCompany VendPaymentGroup, DefaultDimension from vendTrans
                where vendTrans.RecId == vendTransOpen.RefRecId
                    && vendTrans.AccountNum == vendTransOpen.AccountNum;

            if (vendTrans.VendPaymentGroup == _vendPaymentGroup
                && (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) || (AgreementHeaderExt_RU::findByDefaultDimension(vendTrans.DefaultDimension).RecId == _agreementHeaderExtRecId)))
            {
                vendTransOpenContainer += [vendTransOpen];
            }
        }

        return vendTransOpenContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentGroupInvoicesToUnMark</Name>
				<Source><![CDATA[
    /// <summary>
    /// Queries the <c>SpecTrans</c> table for marked records associated with the passed in payment group
    /// and adds the associated <c>VendTransOpen</c> record to a container.
    /// </summary>
    /// <param name="_vendPaymentGroup">
    /// The payment group that the record selection should be based on.
    /// </param>
    /// <param name="_markTrans">
    /// A value that indicates whether the records are being marked or unmarked.
    /// </param>
    /// <param name="_specManager">
    /// The <c>SpecTransManager</c> object to use to verify whether a record exists in another spec.
    /// </param>
    /// <param name="_originator">
    /// The class originator record that will be used to determine the <c>SpecTableId</c>,
    /// <c>SpecRecId</c>, and <c>SpecCompany</c> fields for queries on the <c>SpecTrans</c> table.
    /// </param>
    /// <param name="_agreementHeaderExtRecId">
    /// The agreement RecId that the record selection should be based on.
    /// </param>
    /// <returns>
    /// A container of <c>VendTransOpen</c> records.
    /// </returns>
    protected static container getPaymentGroupInvoicesToUnMark(
        VendPaymentGrouping _vendPaymentGroup,
        NoYes _markTrans,
        SpecTransManager _specManager,
        Common _originator,
        AgreementHeaderExtRecId_RU _agreementHeaderExtRecId = 0)
    {
        SpecTrans specTrans;
        VendTrans vendTrans;
        VendTransOpen vendTransOpen;
        container invoicesToBeUnMarked;

        while select RecId, RefRecId, RefTableId, RefCompany from specTrans
            where specTrans.SpecCompany == _originator.company()
                && specTrans.SpecTableId == _originator.TableId
                && specTrans.SpecRecId == _originator.RecId
        {
            vendTrans = specTrans.vendTrans();
            vendTransOpen = specTrans.vendTransOpen();

            //we are in a marking operation. If we are marking then we want to unmark records that are not of the payment group being marked
            if (_markTrans == NoYes::Yes)
            {
                if (!_specManager.existForOtherSpec(vendTransOpen.company(), vendTransOpen.TableId, vendTransOpen.RecId)
                    && (vendTrans.VendPaymentGroup != _vendPaymentGroup
                        || AgreementHeaderExt_RU::findByDefaultDimension(vendTrans.DefaultDimension).RecId != _agreementHeaderExtRecId)
                    && !(vendTrans.TransType == LedgerTransType::Payment || vendTrans.TransType == LedgerTransType::None))
                {
                    invoicesToBeUnMarked += [specTrans.vendTransOpen()];
                }
            }
            //we are in an unmarking operation. If we are unmarking a payment group then we just want to unmark that group.
            else
            {
                if (vendTrans.VendPaymentGroup == _vendPaymentGroup
                    && (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) || (AgreementHeaderExt_RU::findByDefaultDimension(vendTrans.DefaultDimension).RecId == _agreementHeaderExtRecId))
                   )
                {
                    invoicesToBeUnMarked += [specTrans.vendTransOpen()];
                }
            }
        }

        return invoicesToBeUnMarked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>preResetMarkedTransHandler</Name>
				<Source><![CDATA[
    [PostHandlerFor(classStr(CustVendOpenTransManager), methodstr(CustVendOpenTransManager, resetMarkedTrans))]
    /// <summary>
    /// Handles the event triggered in method resetMarkedTrans
    /// </summary>
    /// <param name="_args">
    /// Event payload
    /// </param>
    public static void preResetMarkedTransHandler(XppPrePostArgs _args)
    {
        CustVendOpenTransManager custVendOpenTransManager = _args.getThis();

        if (!BrazilParameters::isEnabled())
        {
            return;
        }

        custVendOpenTransManager.preResetMarkedTrans();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCentralizedPaymentHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether the legal entity already exists in another organization hierarchy that is
    /// assigned to the Centralized Payment purpose.
    /// </summary>
    /// <param name="_hierarchy">
    /// The organization hierarchy to which the organization node is being added and should be validated.
    /// </param>
    /// <param name="_publishDateTime">
    /// The date and time at which the hierarchy is being published.
    /// </param>
    /// <returns>
    /// true if the hierarchy can be published successfully; otherwise, false.
    /// </returns>
    private static boolean validateCentralizedPaymentHierarchy(OMOrganizationHierarchy _hierarchy, utcdatetime _publishDateTime)
    {
        Query query = new Query();
        QueryBuildDataSource explodedOrgQBDS;
        QueryBuildDataSource omHierarchyTypeQBDS;
        QueryBuildDataSource omHierarchyPurposeQBDS;
        QueryBuildDataSource companyInfoQBDS;
        QueryRun queryRun;

        OMHierarchyType omHierarchyType;
        CompanyInfo companyInfo;

        OMOrganizationNode omOrganizationNode;
        OMOrgHierarchyIterator hierarchyIterator = _hierarchy.getIterator();
        container allNodesInHierarchy;
        boolean ok = true;

        // Gather all the Legal Entity RecIds for the CP Hierarchy into a container
        omOrganizationNode = hierarchyIterator.getNext();

        while (omOrganizationNode)
        {
            allNodesInHierarchy += omOrganizationNode.parmID();
            omOrganizationNode = hierarchyIterator.getNext();
        }

        // Build up the query to figure out if any Centralized Payment hierarchy is already published with this legal entity.
        // If so, it will not be allowed to be inserted. If legal entities exist in other Centralized Payment hierarchies
        // and are published, they would have records populated out in the OMExplodedOrganizationSecurityGraph table. We
        // need to use a query in this case as opposed to standard select logic as the CompanyInfo.RecId values need to restricted
        // based on a container for which the number of values is dynamic. Using a query allows us to build the string of RecId
        // values more easily in this case.
        query.validTimeStateDateTimeRange(_publishDateTime, DateTimeUtil::maxValue());

        explodedOrgQBDS = query.addDataSource(tableNum(OMExplodedOrganizationSecurityGraph));
        explodedOrgQBDS.fields().dynamic(NoYes::No);
        explodedOrgQBDS.fields().clearFieldList();
        explodedOrgQBDS.fields().addField(fieldNum(OMExplodedOrganizationSecurityGraph, RecId));
        explodedOrgQBDS.fields().addField(fieldNum(OMExplodedOrganizationSecurityGraph, Organization));
        explodedOrgQBDS.addRange(fieldNum(OMExplodedOrganizationSecurityGraph, Distance)).value('0');

        omHierarchyTypeQBDS = explodedOrgQBDS.addDataSource(tableNum(OMHierarchyType));
        omHierarchyTypeQBDS.fetchMode(QueryFetchMode::One2One);
        omHierarchyTypeQBDS.relations(true);
        omHierarchyTypeQBDS.fields().dynamic(NoYes::No);
        omHierarchyTypeQBDS.fields().clearFieldList();
        omHierarchyTypeQBDS.fields().addField(fieldNum(OMHierarchyType, Name));
        omHierarchyTypeQBDS.addRange(fieldNum(OMHierarchyType, RecId)).value('!'+int642str(_hierarchy.parmHierarchyRecID()));

        omHierarchyPurposeQBDS = omHierarchyTypeQBDS.addDataSource(tableNum(OMHierarchyPurpose));
        omHierarchyPurposeQBDS.fetchMode(QueryFetchMode::One2One);
        omHierarchyPurposeQBDS.relations(true);
        omHierarchyPurposeQBDS.fields().dynamic(NoYes::No);
        omHierarchyPurposeQBDS.fields().clearFieldList();
        omHierarchyPurposeQBDS.fields().addField(fieldNum(OMHierarchyPurpose, HierarchyType));
        omHierarchyPurposeQBDS.addRange(fieldNum(OMHierarchyPurpose, HierarchyPurpose)).value(int2str(enum2int(HierarchyPurpose::CentralizedPayments)));

        companyInfoQBDS = explodedOrgQBDS.addDataSource(tableNum(CompanyInfo));
        companyInfoQBDS.fetchMode(QueryFetchMode::One2One);
        companyInfoQBDS.addLink(fieldNum(OMExplodedOrganizationSecurityGraph, Organization), fieldNum(CompanyInfo, RecId));
        companyInfoQBDS.joinMode(JoinMode::InnerJoin);
        companyInfoQBDS.fields().dynamic(NoYes::No);
        companyInfoQBDS.fields().clearFieldList();
        companyInfoQBDS.fields().addField(fieldNum(CompanyInfo, DataArea));
        companyInfoQBDS.fields().addField(fieldNum(CompanyInfo, Name));
        companyInfoQBDS.addRange(fieldNum(CompanyInfo, RecId)).value(con2Str(allNodesInHierarchy, ','));

        queryRun = new QueryRun(query);

        while (queryRun.next())
        {
            if (ok)
            {
                ok = false;
            }

            companyInfo = queryRun.get(tableNum(CompanyInfo));
            omHierarchyType = queryRun.get(tableNum(OMHierarchyType));

            error(strFmt("@SYS331817", companyInfo.name(), omHierarchyType.Name));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCentralizedPaymentHierPublish</Name>
				<Source><![CDATA[
    [SubscribesTo(classStr(OMOrganizationHierarchy), delegatestr(OMOrganizationHierarchy, PublishCallback))]
    /// <summary>
    /// Validates whether a legal entity already exists in another organization hierarchy that is assigned
    /// to the Centralized Payment purpose.
    /// </summary>
    /// <param name="_hierarchy">
    /// The organization hierarchy to which the organization node is being added and should be validated.
    /// </param>
    /// <param name="_publishDateTime">
    /// The date and time at which the hierarchy is being published.
    /// </param>
    /// <remarks>
    /// This method serves as the event subscription entry point when organization hierarchies are
    /// published.Note that a legal entity can only be a member of one organization hierarchy that is
    /// assigned to the Centralized Payment purpose.
    /// </remarks>
    public static void validateCentralizedPaymentHierPublish(OMOrganizationHierarchy _hierarchy, utcdatetime _publishDateTime)
    {
        // First make sure that the hierarchy is assigned to CentralizePayment purpose. If not, bypass.
        if (OMMultipleHierarchy::isPurposeAssignedToHierarchy(_hierarchy.parmHierarchyRecID(), HierarchyPurpose::CentralizedPayments))
        {
            if (!CustVendOpenTransManager::validateCentralizedPaymentHierarchy(_hierarchy, _publishDateTime))
            {
                throw error("@SYS331818");
            }
            else
            {
                // Clear the cache for legal entities that will be returned by the CustVendOpenTrans::findSharedServiceCompanies method
                CustVendCache::clearScope(CustVendCacheScope::CentralizedPaymentLegalEntity);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAmountToSettleForMarkedTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the settlement amount in <c>SpecTrans</c> for marked transactions..
    /// </summary>
    /// <param name="_custVendTransOpen">Cust/VendOpenTrans record.</param>
    public void updateAmountToSettleForMarkedTransaction(CustVendTransOpen _custVendTransOpen)
    {
        CashDiscAmount cashDiscAmountToTake;
        AmountCur settleAmount;

        if (this.getTransMarked(_custVendTransOpen) == NoYes::Yes)
        {
            cashDiscAmountToTake = this.determineCashDiscAmountToTake(_custVendTransOpen, true);

            settleAmount = this.determineSettleAmountIncludingCashDiscount(_custVendTransOpen, cashDiscAmountToTake);

            this.updateSettleDiscountAmounts(_custVendTransOpen, settleAmount, cashDiscAmountToTake, false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determinePossibleSettleAmountWithoutCashDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total settle amount open if no cash discount is taken.
    /// </summary>
    /// <param name = "_custVendTransOpen">The open transaction.</param>
    /// <returns>The total settle amount.</returns>
    public AmountCur determinePossibleSettleAmountWithoutCashDiscount(CustVendTransOpen _custVendTransOpen)
    {
        return this.determineSettleAmountIncludingCashDiscount(_custVendTransOpen, 0.0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineSettleAmountIncludingCashDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the settlement amount.
    /// </summary>
    /// <param name = "_custVendTransOpen">
    /// The open transaction.
    /// </param>
    /// <param name = "_cashDiscAmount">
    /// The available cash discount.
    /// </param>
    /// <param name = "_includeFineAndInterest">
    /// Indicates whether or not to include the interest and fine amounts.
    /// </param>
    /// <returns>
    /// The settlement amount.
    /// </returns>
    protected AmountCur determineSettleAmountIncludingCashDiscount(
        CustVendTransOpen _custVendTransOpen,
        CashDiscAmount _cashDiscAmount,
        boolean _includeFineAndInterest = true)
    {
        AmountCur settleAmount;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)) && _custVendTransOpen.TableId == tableNum(VendTransOpen))
        {
            if (_custVendTransOpen.checkPwpEnabled(_custVendTransOpen))
            {
                settleAmount = _custVendTransOpen.calcSettlementAmount(_custVendTransOpen);

                if (settleAmount != 0)
                {
                    settleAmount -= _cashDiscAmount;
                }
            }
            else
            {
                settleAmount = specTransManager.findUnmarkedAmountForRef(
                    _custVendTransOpen.AmountCur,
                    _custVendTransOpen.company(),
                    _custVendTransOpen.TableId,
                    _custVendTransOpen.RecId) - _cashDiscAmount;
            }
        }
        else
        {
            if (_custVendTransOpen.TableId == tableNum(CustTransOpen) && this.isTransactionSettledByLine(_custVendTransOpen))
            {
                SpecTrans specTrans = specTransManager.findByRef(_custVendTransOpen.company(), _custVendTransOpen.TableId, _custVendTransOpen.RecId);

                settleAmount = CustOpenTransLineManager::determineTotalSettledLineAmount(specTrans.RecId) - _cashDiscAmount;
            }
            else
            {
                settleAmount = specTransManager.findUnmarkedAmountForRef(
                    _custVendTransOpen.AmountCur,
                    _custVendTransOpen.company(),
                    _custVendTransOpen.TableId,
                    _custVendTransOpen.RecId) - _cashDiscAmount;
            }

            // <GEERU>
            settleAmount -= this.vatTaxAgentAmount_RU(_custVendTransOpen);
            // </GEERU>

            // <GBR>
            if (BrazilParameters::isEnabled() && _includeFineAndInterest)
            {
                settleAmount += (_custVendTransOpen.FineAmount_BR + _custVendTransOpen.InterestAmount_BR);
            }
            // </GBR>
        }

        return settleAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransactionSettledByLine</Name>
				<Source><![CDATA[
    private boolean isTransactionSettledByLine(CustTransOpen _custTransOpen)
    {
        if (CustParameters::find().MarkOpenInvoiceLine)
        {
            CustTransOpenLine custTransOpenLine;
            CustTransMarkedOpenLine custTransMarkedOpenLine;

            SpecTrans specTrans = specTransManager.findByRef(_custTransOpen.company(), tableNum(CustTransOpen), _custTransOpen.RecId);

            select firstonly RecId from custTransMarkedOpenLine
                where custTransMarkedOpenLine.SpecTrans == specTrans.RecId
                exists join custTransOpenLine
                    where custTransOpenLine.CustTransOpen == _custTransOpen.RecId
                        && custTransOpenLine.RecId == custTransMarkedOpenLine.CustTransOpenLine;

            return custTransMarkedOpenLine.RecId != 0;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipPrePaymentSettlementWarning</Name>
				<Source><![CDATA[
    public boolean parmSkipPrePaymentSettlementWarning(boolean _skipPrePaymentSettlementWarning = skipPrePaymentSettlementWarning)
    {
        if(skipPrePaymentSettlementWarning != _skipPrePaymentSettlementWarning)
        {
            skipPrePaymentSettlementWarning = _skipPrePaymentSettlementWarning;
        }

        return skipPrePaymentSettlementWarning;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateForeignVendor_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if it is a foreign vendor.
    /// </summary>
    /// <returns>
    /// Whether it is a foreign vendor or not.
    /// </returns>
    public boolean validateForeignVendor_IN()
    {
        boolean         isValid = true;

        if (originator.TableId == tableNum(LedgerJournalTrans))
        {
            return true;
        }

        // Check TDS for foreign vendor
        isValid = this.validateForeignVendWithTDS_IN();

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateForeignVendWithTDS_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates foreign vendor with TDS.
    /// When trying to settle a posted invoice with a posted payment, an error should be given and the settlement is not done, if:
    /// 1. The vendor is a foreign vendor
    /// 2. The multiple transactions to be settled have TDS.
    /// </summary>
    /// <returns>
    /// Whether the foreign vendor with TDS meets the above conditions or not.
    /// </returns>
    public boolean validateForeignVendWithTDS_IN()
    {
        SpecTrans               currentSpecTrans;
        Map                     markedTransactions;
        MapEnumerator           currentTransaction;
        boolean                 isValid = true;
        int                     numOfVendTransWithTDS = 0;
        TaxWithholdTrans_IN     taxWithholdTransLoc;
        VendTrans               vendTransLoc;

        if (originator.TableId == tableNum(LedgerJournalTrans))
        {
            return true;
        }

        if ((originator.TableId == tableNum(VendTable))
            && specTransManager.getSpecTransCount() != 0
            && TaxWithholdParameters_IN::isTDSActivate())
        {
            markedTransactions = specTransManager.getAllSpecTransMap();
            currentTransaction = new MapEnumerator(markedTransactions);
            while (currentTransaction.moveNext())
            {
                currentSpecTrans = currentTransaction.currentValue();
                vendTransLoc = currentSpecTrans.vendTrans();

                select firstOnly RecId from taxWithholdTransLoc
                    where taxWithholdTransLoc.Voucher == vendTransLoc.Voucher
                        && taxWithholdTransLoc.TransDate == vendTransLoc.TransDate
                        && taxWithholdTransLoc.TaxType  == TaxWithholdCodeType_IN::TDS;

                if (taxWithholdTransLoc.RecId)
                {
                    numOfVendTransWithTDS++;
                }

                if (numOfVendTransWithTDS >= 2)
                {

                    isValid = false;
                    break;
                }
            }
        }

        if (!isValid)
        {
            checkFailed(strFmt("@TaxLocalization:SYP4882637")); //Multiple transactions of the foreign vendor have TDS, you cannot settle them.
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForSettlementWriteOff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs an instance of the <c>CustVendOpenTransManager</c> class for settlement write off.
    /// </summary>
    /// <param name = "_originator">The originating table.</param>
    /// <param name = "_currencyCode">The currency code for write off.</param>
    /// <returns>The new instance of the class.</returns>
    public static CustVendOpenTransManager newForSettlementWriteOff(Common _originator, CurrencyCode _currencyCode)
    {
        CustVendOpenTransManager manager = new CustVendOpenTransManager(_originator);
        manager.initForSettlementWriteOff(_originator, _currencyCode);

        return manager;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>