<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendPDCManager</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>CustVendPDCManager</c> class manages the actions that are performed on the post-dated
///    checks.
/// </summary>
class CustVendPDCManager
{
    #ISOCountryRegionCodes

    public const str CalculateCanceledPDCPayments = 'CalculateCanceledPDCPayments';

    boolean checkCancelStatus;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmCheckCancelStatus</Name>
				<Source><![CDATA[
    public boolean parmCheckCancelStatus(boolean _checkCancelStatus = checkCancelStatus)
    {
        checkCancelStatus = _checkCancelStatus;

        return checkCancelStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowPostDatedChecks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the post dated checks must be entered for a journal.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>ledgerJournalTrans</c> record for which a post dated check must be enabled.
    /// </param>
    /// <returns>
    /// true if the post dated check is valid for the current <c>ledgerJournalTrans</c> record; otherwise,
    /// false.
    /// </returns>
    public static boolean allowPostDatedChecks(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean allowPost = false;
        BankParameters bankParameters = BankParameters::find();

        if (bankParameters.EnablePDC)
        {
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
            {
                allowPost = CustPaymModeTable::find(_ledgerJournalTrans.PaymMode).pdcClearingPosting;
            }
            else if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
            {
                allowPost = VendPaymModeTable::find(_ledgerJournalTrans.PaymMode).pdcClearingPosting;
            }

            if (!allowPost)
            {
                CustVendPDCRegister custVendPDCRegister;
                ttsbegin;
                delete_from custVendPDCRegister
                    where custVendPDCRegister.LedgerJournalTrans == _ledgerJournalTrans.RecId;
                ttscommit;
            }
        }
        return allowPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelPostDatedCheck</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Cancels a postdated check.
    /// </summary>
    /// <param name="_custVendPDCRegister">
    ///    The postdated check register that is associated with the check to be canceled.
    /// </param>
    /// <returns>
    ///    true if the post dated check is canceled; otherwise, false.
    /// </returns>
    public static boolean cancelPostDatedCheck(CustVendPDCRegister _custVendPDCRegister)
    {
        boolean checkCancelled = false;
        CustVendPDCManager custVendPDCManager = new CustVendPDCManager();

        if (_custVendPDCRegister.PDCStatus != PostDatedCheckStatus::Posted)
        {
            return checkFailed("@SYS322467");
        }

        LedgerJournalTrans ledgerJournalTrans = LedgerJournalTrans::findByRefAndDataArea(_custVendPDCRegister.DataAreaId, _custVendPDCRegister.LedgerJournalTrans);

        if (!ledgerJournalTrans.RecId)
        {
            return checkfailed(strFmt("@SYS:EventNotification_CannotFindRecord", TablePName(LedgerJournalTrans)));
        }

        Args args = new Args();
        if (_custVendPDCRegister.AccountType == CustVendACType::Cust)
        {
            CustTrans custTrans = CustTrans::findVoucherDateType(ledgerJournalTrans.Voucher, ledgerJournalTrans.TransDate, ledgerJournalTrans.TransactionType);
            if (custTrans)
            {
                args.parmObject(custVendPDCManager);
                args.record(custTrans);
                BankPaymCancel::main(args);
                if (custVendPDCManager.parmCheckCancelStatus())
                {
                    checkCancelled = true;
                }
            }
        }
        else
        {
            BankChequeTable bankChequeTable;
            VendPaymModeTable vendPaymModeTable = VendPaymModeTable::find(ledgerJournalTrans.PaymMode);
            // If the method of payment account type is bank
            if (vendPaymModeTable.AccountType == LedgerJournalACType::Bank)
            {
                bankChequeTable = BankChequeTable::find(
                LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(vendPaymModeTable.PaymentLedgerDimension), ledgerJournalTrans.BankChequeNum);
                if (bankChequeTable)
                {
                    args.parmObject(custVendPDCManager);
                    args.record(bankChequeTable);
                    BankChequeCancel::main(args);
                    if (custVendPDCManager.parmCheckCancelStatus())
                    {
                        checkCancelled = true;
                    }
                }
            }

            // If PDC number is filled in by user
            if (!bankChequeTable && _custVendPDCRegister.CheckNumber)
            {
                checkCancelled = true;
            }
        }

        // Update the check status
        if (checkCancelled)
        {
            ttsbegin;
            _custVendPDCRegister.selectForUpdate(true);
            _custVendPDCRegister.PDCStatus = PostDatedCheckStatus::Cancelled;
            _custVendPDCRegister.update();
            ttscommit;
        }
        return checkCancelled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>enablePostDatedCheckPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the post button must be enabled for the payment.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>ledgerJournalTrans</c> record for which a post dated check posting must be enabled.
    /// </param>
    /// <returns>
    /// true if the post dated check posting is valid for the current <c>ledgerJournalTrans</c> record;
    /// otherwise, false.
    /// </returns>
    public static boolean enablePostDatedCheckPosting(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean enablePost = true;

        BankParameters bankParameters = BankParameters::find();

        if (bankParameters.EnablePDC)
        {
            CustVendPDCRegister custVendPDCRegister = CustVendPDCRegister::findByReference(_ledgerJournalTrans.RecId);
            boolean pdcClearingPosting;

            if (custVendPDCRegister.AccountType == CustVendACType::Cust)
            {
                pdcClearingPosting = CustPaymModeTable::find(_ledgerJournalTrans.PaymMode).pdcClearingPosting;
            }
            else
            {
                pdcClearingPosting = VendPaymModeTable::find(_ledgerJournalTrans.PaymMode).pdcClearingPosting;
            }

            if (pdcClearingPosting)
            {
                if (custVendPDCRegister.PDCStatus == PostDatedCheckStatus::Open)
                {
                    enablePost = bankParameters.PostTransPDC || custVendPDCRegister.MaturityDate > DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                }
                else if (custVendPDCRegister.PDCStatus == PostDatedCheckStatus::OnHold)
                {
                    enablePost = false;
                }
            }
        }
        return enablePost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postDatedCheckPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts dated check posting.
    /// </summary>
    /// <param name="_ledgerJournalId">
    /// The payment journal for which post dated checks must be posted.
    /// </param>
    /// <remarks>
    /// This method is part of payment journal posting if there are PDCs to be posted.
    /// </remarks>

    public static void postDatedCheckPost(LedgerJournalId _ledgerJournalId)
    {
        LedgerJournalTrans ledgerJournalTrans;
        CustVendPDCRegister custVendPDCRegister;
        CustVendPDCRegister custVendPDCRegisterOriginal;

        ttsbegin;
        while select forupdate custVendPDCRegister
            join ledgerJournalTrans
            where ledgerJournalTrans.RecId == custVendPDCRegister.LedgerJournalTrans
                && ledgerJournalTrans.JournalNum == _ledgerJournalId
        {
            custVendPDCRegister.PDCStatus = PostDatedCheckStatus::Posted;
            custVendPDCRegister.update();
            if (custVendPDCRegister.IsReplacementCheck)
            {
                custVendPDCRegisterOriginal = CustVendPDCRegister::findByCheck(custVendPDCRegister.OriginalCheck, true);
                custVendPDCRegisterOriginal.PDCStatus = PostDatedCheckStatus::Replaced;
                custVendPDCRegisterOriginal.update();
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleClearingTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Settles clearing transactions and sets the PDC to Paid.
    /// </summary>
    /// <param name="_custVendPDCRegister">
    /// Post dated check to be settled.
    /// </param>
    /// <remarks>
    /// This method uses the standard bridging and clearing accounts posting logic.
    /// </remarks>
    [SysObsolete('This method is obsoleted, please use settleClearingTransactionsV2 instead.', false, 15\09\2023)]
    public static void settleClearingTransactions(CustVendPDCRegister _custVendPDCRegister)
    {
        CustVendPDCManager::settleClearingTransactionsV2(_custVendPDCRegister);
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleClearingTransactionsV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Settles clearing transactions and sets the PDC to Paid.
    /// </summary>
    /// <param name="_custVendPDCRegister">
    /// Post dated check to be settled.
    /// </param>
    /// <param name="_bridgedAutoClearingDate">
    /// The clearing date for bridged transactions auto clearing during bank reconciliation.
    /// </param>
    /// <remarks>
    /// This method uses the standard bridging and clearing accounts posting logic.
    /// </remarks>
    public static void settleClearingTransactionsV2(CustVendPDCRegister _custVendPDCRegister, TransDate _bridgedAutoClearingDate = dateNull())
    {
        if (_custVendPDCRegister.PDCStatus != PostDatedCheckStatus::Posted
            || _custVendPDCRegister.MaturityDate > DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
        {
            checkFailed("@SYS322445");
            return;
        }

        LedgerJournalNameId journalName;

        if (_bridgedAutoClearingDate)
        {
            journalName = BankParameters::find().BridgedTransClearingJournalName;
        }
        else
        {
            journalName = BankParameters::find().GeneralJournalNamePDC;

            if (!journalName)
            {
                checkFailed("@SYS322456");
                return;
            }
        }

        TransDate settleDate;
        if (_bridgedAutoClearingDate)
        {
            settleDate = _bridgedAutoClearingDate;
        }
        else
        {
            settleDate = CustVendPDCManager::getSettleDate(_custVendPDCRegister.MaturityDate);

            if (!settleDate)
            {
                return;
            }
        }

        LedgerJournalTrans ledgerJournalTrans = LedgerJournalTrans::findRecId(_custVendPDCRegister.LedgerJournalTrans, false);

        LedgerJournalTable ledgerJournalTable;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry, localGeneralJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry, localGeneralJournalEntry;
        LedgerEntry ledgerEntry, localLedgerEntry;
        LedgerEntryJournal ledgerEntryJournal, localLedgerEntryJournal;
        LedgerTransFurtherPosting ledgerTransFurtherPosting;

        if (SettleClearingEntriesWarningMessageFlight::instance().isEnabled())
        {
            GeneralJournalAccountEntry generalJournalAccountEntryBridging;
            select count(RecId) from generalJournalAccountEntryBridging
                exists join subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalAccountEntryBridging.GeneralJournalEntry
                    && subledgerVoucherGeneralJournalEntry.Voucher == ledgerJournalTrans.Voucher
                    && subledgerVoucherGeneralJournalEntry.AccountingDate == ledgerJournalTrans.TransDate
                    && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == ledgerJournalTrans.DataAreaId
                    && generalJournalAccountEntryBridging.PostingType != LedgerPostingType::InterunitCredit
                    && generalJournalAccountEntryBridging.PostingType != LedgerPostingType::InterunitDebit
                exists join generalJournalEntry
                where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                    && generalJournalEntry.Ledger == Ledger::current()
                outer join ledgerEntryJournal
                where ledgerEntryJournal.JournalNumber == ledgerJournalTrans.JournalNum
                    && ledgerEntryJournal.RecId == generalJournalEntry.LedgerEntryJournal
                outer join ledgerEntry
                where ledgerEntry.GeneralJournalAccountEntry == generalJournalAccountEntryBridging.RecId
                    && ledgerEntry.IsBridgingPosting == NoYes::Yes
                exists join ledgerTransFurtherPosting
                where ledgerTransFurtherPosting.RefRecId == ledgerEntry.RecId
                    && ledgerTransFurtherPosting.AccountNum == ledgerJournalTrans.accountDisplay();

            if (!generalJournalAccountEntryBridging.RecId)
            {
                throw error("@CashManagement:NoMatchedBridgingTrans");
            }
        }

        ttsbegin;

        while select generalJournalAccountEntry
            join RecId from subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalAccountEntry.GeneralJournalEntry
                && subledgerVoucherGeneralJournalEntry.Voucher == ledgerJournalTrans.Voucher
                && subledgerVoucherGeneralJournalEntry.AccountingDate == ledgerJournalTrans.TransDate
                && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == ledgerJournalTrans.DataAreaId
                && generalJournalAccountEntry.PostingType != LedgerPostingType::InterunitCredit
                && generalJournalAccountEntry.PostingType != LedgerPostingType::InterunitDebit
            join RecId from generalJournalEntry
            where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                && generalJournalEntry.Ledger == Ledger::current()
            outer join ledgerEntryJournal
            where ledgerEntryJournal.JournalNumber == ledgerJournalTrans.JournalNum
                && ledgerEntryJournal.RecId == generalJournalEntry.LedgerEntryJournal
            outer join ledgerEntry
            where ledgerEntry.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId
                && ledgerEntry.IsBridgingPosting == NoYes::Yes
            exists join ledgerTransFurtherPosting
            where ledgerTransFurtherPosting.RefRecId == ledgerEntry.RecId
                && ledgerTransFurtherPosting.AccountNum == ledgerJournalTrans.accountDisplay()
        {
            [localGeneralJournalAccountEntry, localLedgerEntryJournal, localGeneralJournalEntry, localLedgerEntry] =
                GeneralLedgerExtension::findRelated(generalJournalAccountEntry.RecId);

            boolean isClearingTransExist;
            if (FeatureStateProvider::isFeatureEnabled(BankBridgedTransAutoClearingFeature::instance()) && _bridgedAutoClearingDate)
            {
                isClearingTransExist = BankReconBridgedAutoClearing::isClearingTransExist(localLedgerEntry);
            }

            if (!isClearingTransExist)
            {
                if (!ledgerJournalTable)
                {
                    ledgerJournalTable.initFromLedgerJournalName(journalName);
                    ledgerJournalTable.insert();
                }

                LedgerJournalTrans ledgerJournalTransClearing = LedgerTransFurtherPosting::createAndGetLedgerJournalTransFromGenJour(
                    localGeneralJournalAccountEntry,
                    localLedgerEntryJournal,
                    localGeneralJournalEntry,
                    localLedgerEntry,
                    ledgerJournalTable,
                    settleDate,
                    ledgerJournalTrans);

                if (_bridgedAutoClearingDate)
                {
                    ttsbegin;
                    ledgerJournalTransClearing.selectForUpdate(true);
                    ledgerJournalTransClearing.Txt = BankReconBridgedAutoClearing::getClearingTransTxt(ledgerJournalTrans);
                    ledgerJournalTransClearing.doUpdate();
                    ttscommit;
                }

            }
        }

        if (ledgerJournalTable)
        {
            LedgerJournalCheckPost ledgerJournalCheckPost = LedgerJournalCheckPost::newLedgerJournalTable(ledgerJournalTable, NoYes::Yes, false);
            LedgerJournalCheckPost::processOperation(ledgerJournalCheckPost);

            // Reverse and repost withholding tax for vendor account
            if (_custVendPDCRegister.AccountType == CustVendACType::Vend
                && ledgerJournalTrans.TaxWithholdGroup
                && BankParameters::find().WHTClearingPDC)
            {
                LedgerVoucher ledgerVoucher;
                LedgerVoucherObject ledgerVoucherObject;
                VendTrans vendTrans;
                TaxWithholdTrans taxWithholdTrans;
                NumberSeq numberSeq;

                while select taxWithholdTrans
                    where taxWithholdTrans.DataAreaId == ledgerJournalTrans.DataAreaId
                        && taxWithholdTrans.Voucher == ledgerJournalTrans.Voucher
                        && taxWithholdTrans.TransDate == ledgerJournalTrans.TransDate
                {
                    // We are reversing the witholding tax entries posted to the settling account and
                    // posting it to the WHT account. Since we are creating a brand new WHT transaction, we need a new voucher.
                    numberSeq = NumberSeq::newGetVoucher(LedgerParameters::numRefJournalNum(), false);
                    ledgerVoucher = LedgerVoucher::newLedgerPost(
                        DetailSummary::Detail,
                        SysModule::Ledger,
                        numberSeq.parmVoucherSequenceCode());

                    ledgerVoucherObject = LedgerVoucherObject::newVoucher(
                        numberSeq.voucher(),
                        settleDate,
                        SysModule::Ledger,
                        LedgerTransType::Vend,
                        ledgerJournalTrans.correct(),
                        ledgerJournalTable.CurrentOperationsTax,
                        ledgerJournalTrans.DocumentNum,
                        ledgerJournalTrans.DocumentDate,
                        ledgerJournalTrans.AcknowledgementDate);
                    ledgerVoucher.addVoucher(ledgerVoucherObject);

                    vendTrans = VendTrans::find(taxWithholdTrans.VendTransPaymId);
                    // reverse the existing taxwithold trans posted in WHT clearing account
                    CustVendPDCManager::settleTaxWithhold(ledgerVoucher, vendTrans, taxWithholdTrans, -1);
                    // Re-initialize the ledger dimension
                    taxWithholdTrans.initFromTaxWithholdTable();
                    // Post withholdingTax for the original dimension
                    CustVendPDCManager::settleTaxWithhold(ledgerVoucher, vendTrans, taxWithholdTrans);
                    ledgerVoucher.end();
                }
            }

            LedgerJournalTrans ledgerJournalTransLocal;
            CustVendPDCRegister custVendPDCRegister;

            while select forupdate custVendPDCRegister
                exists join ledgerJournalTransLocal
                where custVendPDCRegister.LedgerJournalTrans == ledgerJournalTransLocal.RecId
                    && ledgerJournalTransLocal.Voucher == ledgerJournalTrans.Voucher
                    && ledgerJournalTransLocal.TransDate == ledgerJournalTrans.TransDate
            {
                // If the posting is successful, change the PDC status to paid.
                if (ledgerJournalCheckPost && !ledgerJournalCheckPost.parmPostingResults().errorInJournal())
                {
                    custVendPDCRegister.PDCStatus = PostDatedCheckStatus::Paid;
                    custVendPDCRegister.update();
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSettleDate</Name>
				<Source><![CDATA[
    private static TransDate getSettleDate(TransDate _maturityDate)
    {
        if (_maturityDate == DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())
            || !FeatureStateProvider::isFeatureEnabled(CustVendPDCSettleDateFeature::instance()))
        {
            return _maturityDate;
        }

        return CustVendPDCSettleDateDialog::getSettleDate(_maturityDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleConditionalTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Process conditional tax for PDC post.
    /// </summary>
    /// <param name = "_custVendACType">The account type.</param>
    /// <param name = "_ledgerJournalTablePDCPost">The record of <c>LedgerJournalTable</c> for PDC post.</param>
    /// <param name = "_ledgerJournalTransPayment">The record of <c>LedgerjournalTrans</c> for payment journal.</param>
    /// <param name = "_ledgerJournalTransPDCPost">The record of <c>LedgerJournalTrans</c> for post PDC.</param>
    public static void settleConditionalTax(
        CustVendACType _custVendACType,
        LedgerJournalTable _ledgerJournalTablePDCPost,
        LedgerJournalTrans _ledgerJournalTransPayment,
        LedgerJournalTrans _ledgerJournalTransPDCPost)
    {
        CustVendTrans paymentTrans;
        SysMoDule module;
        Map custVendSettlementMap = new Map(Types::Record, Types::Container);
        CustVendPDCManager custVendPDCManager = new CustVendPDCManager();
        LedgerTransType ledgerTransType;

        if (_custVendACType == CustVendACType::Vend)
        {
            paymentTrans = CustVendTrans::findByModule(ModuleCustVend::Vend, _ledgerJournalTransPayment.VendTransId);
            ledgerTransType = LedgerTransType::Vend;
            VendSettlement vendSettlement;
            while select SettleAmountCur, SettlementVoucher, TransRecId
                from vendSettlement
                where vendSettlement.OffsetRecid == _ledgerJournalTransPayment.VendTransId
            {
                Amount withholdTaxAmount;
                VendTrans vendTransLoc = VendTrans::find(vendSettlement.TransRecId);
                vendTransLoc.TransDate = CustVendPDCManager.determineTransDate(vendTransLoc);

                // Calculate existed withhold tax amount for current payment.
                TaxWithholdTrans taxWithholdTrans;
                while select taxWithholdTrans
                    where taxWithholdTrans.Voucher == _ledgerJournalTransPayment.Voucher
                        && taxWithholdTrans.VoucherInvoice == vendTransLoc.Voucher
                        && taxWithholdTrans.TransDate == _ledgerJournalTransPayment.TransDate
                {
                    withholdTaxAmount += taxWithholdTrans.TaxWithholdAmount;
                }
                SettlementUtility::reverseTransAmounts(vendTransLoc);
                custVendSettlementMap.insert(vendTransLoc, [vendSettlement.SettleAmountCur, vendSettlement.SettlementVoucher, withholdTaxAmount]);
            }

            module = SysModule::Vend;
            SettlementUtility::reverseTransAmounts(paymentTrans);
        }
        else if (_custVendACType == CustVendACType::Cust)
        {
            CustTrans CustTransPayment = CustVendTrans::findByModule(ModuleCustVend::Cust, _ledgerJournalTransPayment.CustTransId);
            ledgerTransType = LedgerTransType::Cust;

            paymentTrans = CustTransPayment;
            CustSettlement custSettlement;
            while select SettleAmountCur, SettlementVoucher, TransRecId
                from custSettlement
                where custSettlement.OffsetRecid == _ledgerJournalTransPayment.CustTransId
            {
                CustTrans custTransLoc = CustTrans::find(custSettlement.TransRecId);
                custVendSettlementMap.insert(custTransLoc, [custSettlement.SettleAmountCur, custSettlement.SettlementVoucher]);
            }

            module = SysModule::Cust;
        }

        if (!paymentTrans)
        {
            return;
        }

        Amount cashDiscountAmount;
        MapEnumerator mapEnumerator = custVendSettlementMap.getEnumerator();
        CustVendTrans invoiceTrans;
        LedgerVoucher conditionalTaxLedgerVoucher;
        LedgerVoucherObject conditionalTaxLedgerVoucherObject;
        boolean cashDiscVAT;
        NumberSequenceReference numberSequenceRefrence;
        boolean isAverageVATEnabled = TaxThaiGovCertificationFeatureChecker::isAverageVATEnabled();

        while (mapEnumerator.moveNext())
        {
            invoiceTrans = mapEnumerator.currentKey();
            Voucher relatedVoucher;
            Amount settlementAmount;
            Amount withholdTaxAmount;
            [settlementAmount, relatedVoucher, withholdTaxAmount] = mapEnumerator.currentValue();

            changecompany(invoiceTrans.company())
            {
                if (isAverageVATEnabled
                    && (!TaxAverageVATAdjust::canProcessConditionalSalesTax(
                        invoiceTrans.Voucher,
                        invoiceTrans.TransDate,
                        paymentTrans.TransDate)))
                {
                    continue;
                }

                if (!TaxParameters::find().ConditionalTax)
                {
                    continue;
                }

                if (module == SysMoDule::Vend)
                {
                    numberSequenceRefrence = VendParameters::numRefVendPaymentVoucher();
                    cashDiscVAT = VendParameters::find().CashDiscVAT;
                }
                else if (module == SysModule::Cust)
                {
                    numberSequenceRefrence = CustParameters::numRefCustPaymVoucher();
                    cashDiscVAT = CustParameters::find().CashDiscVAT;
                }

                RecId voucherGroupId = LedgerTransVoucherLink::findVoucherGroupId(_ledgerJournalTransPayment.Voucher, _ledgerJournalTransPayment.TransDate);
                LedgerTransVoucherLink currentLink, ledgerTransVoucherLink;
                select firstonly RecId from currentLink
                    where currentLink.VoucherGroupId == voucherGroupId
                        && currentLink.Voucher == _ledgerJournalTransPayment.Voucher
                        && currentLink.TransDate == _ledgerJournalTransPayment.TransDate;

                // Check if there was realized conditional tax for payment journal.
                boolean settledConditionalTaxExisted = custVendPDCManager.checkSettledConditionalTaxExisted(
                    voucherGroupId,
                    currentLink.RecId,
                    relatedVoucher,
                    _ledgerJournalTransPayment,
                    module);

                if (settledConditionalTaxExisted)
                {
                    continue;
                }

                // Calculate existed cash discount amount for currenct payment journal.
                if (cashDiscVAT)
                {
                    cashDiscountAmount = custVendPDCManager.getCashDiscountAmount(voucherGroupId, currentLink.RecId, relatedVoucher);
                }

                LedgerVoucherGroup ledgerVoucherGroup = LedgerVoucherGroup::construct();
                NumberSequenceCode numberSeqCode = numberSequenceRefrence.numberSequenceTable().NumberSequence;
                conditionalTaxLedgerVoucher = LedgerVoucher::newLedgerPost(
                    DetailSummary::Detail,
                    module,
                    numberSeqCode);

                conditionalTaxLedgerVoucher.parmCompanyId(invoiceTrans.company());
                ledgerVoucherGroup.addLedgerVoucher(conditionalTaxLedgerVoucher);

                NumberSeq numberSeqLoc = NumberSeq::newGetVoucher(numberSequenceRefrence);

                conditionalTaxLedgerVoucherObject = LedgerVoucherObject::newVoucher(
                    numberSeqLoc.voucher(),
                    _ledgerJournalTransPDCPost.TransDate,
                    module,
                    ledgerTransType,
                    _ledgerJournalTransPayment.correct(),
                    _ledgerJournalTablePDCPost.CurrentOperationsTax,
                    _ledgerJournalTransPayment.DocumentNum,
                    _ledgerJournalTransPayment.DocumentDate,
                    _ledgerJournalTransPayment.AcknowledgementDate);
                conditionalTaxLedgerVoucher.addVoucher(conditionalTaxLedgerVoucherObject);

                Amount actualCashDiscountAmount = SettlementUtility::adjustAmountSign(cashDiscountAmount, module);

                Percent currentPercent = invoiceTrans.AmountCur ? (SettlementUtility::adjustAmountSign(settlementAmount, module) + withholdTaxAmount) / invoiceTrans.AmountCur : 0;

                ExchRate creditExchRateCurToMst = paymentTrans.exchRateCurToMst();
                CurrencyCode invoiceCompanyCurrency, paymentCompanyCurrency;

                changecompany(invoiceTrans.company())
                {
                    invoiceCompanyCurrency = CompanyInfoHelper::standardCurrency();
                }

                changecompany(paymentTrans.company())
                {
                    paymentCompanyCurrency = CompanyInfoHelper::standardCurrency();
                }

                SettlementExchRate exchRate = SettlementExchRate::constructV2(
                    invoiceTrans.company(),
                    invoiceCompanyCurrency,
                    invoiceTrans.CurrencyCode,
                    0,
                    paymentTrans.company(),
                    paymentCompanyCurrency,
                    paymentTrans.CurrencyCode,
                    paymentTrans.TransDate,
                    creditExchRateCurToMst,
                    paymentTrans.getReportingCombinedExchangeRate());

                custVendPDCManager.processConditionalTax(
                    conditionalTaxLedgerVoucherObject,
                    conditionalTaxLedgerVoucher,
                    _ledgerJournalTransPDCPost,
                    invoiceTrans,
                    paymentTrans,
                    actualCashDiscountAmount,
                    currentPercent * 100,
                    exchRate.getDebitCurToDebitMstCombined(),
                    exchRate.getDebitCurToReporting(),
                    cashDiscVAT,
                    module);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSettledConditionalTaxExisted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if there is realized conditional tax (related voucher) for payment journal
    /// </summary>
    /// <param name = "_voucherGroupId">The voucher group id for payment voucher.</param>
    /// <param name = "_ledgerTransVoucherLinkRecId">The recid of <c>LedgerTransVoucherLink</c>.</param>
    /// <param name = "_relatedVoucher">The related voucher for payment.</param>
    /// <param name = "_ledgerJournalTrans">The ledger journal trans for payment.</param>
    /// <param name = "_module">The module the <c>CustVendTrans</c> record is in.</param>
    /// <returns>True if there was realized conditional tax for payment journal, otherwise false.</returns>
    private boolean checkSettledConditionalTaxExisted(
        RecId _voucherGroupId,
        RecId _ledgerTransVoucherLinkRecId,
        Voucher _relatedVoucher,
        LedgerJournalTrans _ledgerJournalTrans,
        SysModule _module)
    {
        LedgerTransVoucherLink ledgerTransVoucherLink;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntryLoc;
        GeneralJournalEntry generalJournalEntryLoc;
        TaxTrans taxTransloc;

        select firstonly RecId from ledgerTransVoucherLink
            where ledgerTransVoucherLink.VoucherGroupId == _voucherGroupId
                && ledgerTransVoucherLink.RecId != _ledgerTransVoucherLinkRecId
            exists join taxTransloc
                where taxTransloc.Voucher == ledgerTransVoucherLink.Voucher
                    && taxTransloc.TransDate == ledgerTransVoucherLink.TransDate
                    && ((_module == SysModule::Vend && taxTransloc.SourceRecId == _ledgerJournalTrans.VendTransId)
                        || (_module == SysModule::Cust && taxTransloc.SourceRecId == _ledgerJournalTrans.CustTransId))
                    && taxTransloc.TaxOrigin == TaxOrigin::Payment
            exists join subledgerVoucherGeneralJournalEntryLoc
                where ledgerTransVoucherLink.Voucher == subledgerVoucherGeneralJournalEntryLoc.Voucher
                    && ledgerTransVoucherLink.TransDate == subledgerVoucherGeneralJournalEntryLoc.AccountingDate
                    && ledgerTransVoucherLink.DataAreaId == subledgerVoucherGeneralJournalEntryLoc.VoucherDataAreaId
            exists join generalJournalEntryLoc
                where subledgerVoucherGeneralJournalEntryLoc.GeneralJournalEntry == generalJournalEntryLoc.RecId
                    && subledgerVoucherGeneralJournalEntryLoc.Voucher == _relatedVoucher;

        return ledgerTransVoucherLink.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscountAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate existed cash discount amount for payment journal.
    /// </summary>
    /// <param name = "_voucherGroupId">The voucher group id for payment voucher.</param>
    /// <param name = "_ledgerTransVoucherLinkRecId">The recid of <c>LedgerTransVoucherLink</c>.</param>
    /// <param name = "_relatedVoucher">The related voucher for payment.</param>
    /// <returns>Existed cash discount amount for payment journal.</returns>
    private Amount getCashDiscountAmount(
        RecId _voucherGroupId,
        RecId _ledgerTransVoucherLinkRecId,
        Voucher _relatedVoucher)
    {
        LedgerTransVoucherLink ledgerTransVoucherLink;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntryLoc;
        GeneralJournalEntry generalJournalEntryLoc;
        GeneralJournalAccountEntry generalJournalAccountEntryDiscount;

        select Voucher, TransDate from ledgerTransVoucherLink
            where ledgerTransVoucherLink.VoucherGroupId == _voucherGroupId
                && ledgerTransVoucherLink.RecId != _ledgerTransVoucherLinkRecId
            join sum(TransactionCurrencyAmount) from generalJournalAccountEntryDiscount
                where generalJournalAccountEntryDiscount.PostingType == LedgerPostingType::VendCashDisc
                    || generalJournalAccountEntryDiscount.PostingType == LedgerPostingType::CustCashDisc
            exists join subledgerVoucherGeneralJournalEntryLoc
                where generalJournalAccountEntryDiscount.GeneralJournalEntry == subledgerVoucherGeneralJournalEntryLoc.GeneralJournalEntry
                    && ledgerTransVoucherLink.Voucher == subledgerVoucherGeneralJournalEntryLoc.Voucher
                    && ledgerTransVoucherLink.TransDate == subledgerVoucherGeneralJournalEntryLoc.AccountingDate
                    && ledgerTransVoucherLink.DataAreaId == subledgerVoucherGeneralJournalEntryLoc.VoucherDataAreaId
                    && subledgerVoucherGeneralJournalEntryLoc.Voucher == _relatedVoucher
            exists join generalJournalEntryLoc
                where generalJournalAccountEntryDiscount.GeneralJournalEntry == generalJournalEntryLoc.RecId
                    && generalJournalEntryLoc.SubledgerVoucher == ledgerTransVoucherLink.Voucher;

        Amount cashDiscountAmount = generalJournalAccountEntryDiscount.TransactionCurrencyAmount;

        TaxTrans cashDiscountTaxTrans;
        select Voucher, TransDate from ledgerTransVoucherLink
            where ledgerTransVoucherLink.VoucherGroupId == _voucherGroupId
                && ledgerTransVoucherLink.RecId != _ledgerTransVoucherLinkRecId
            join sum(TaxAmount) from cashDiscountTaxTrans
                where cashDiscountTaxTrans.Voucher == ledgerTransVoucherLink.Voucher
                    && cashDiscountTaxTrans.TransDate == ledgerTransVoucherLink.TransDate
                    && cashDiscountTaxTrans.TaxOrigin == TaxOrigin::CashDisc
            exists join subledgerVoucherGeneralJournalEntryLoc
                where ledgerTransVoucherLink.Voucher == subledgerVoucherGeneralJournalEntryLoc.Voucher
                    && ledgerTransVoucherLink.TransDate == subledgerVoucherGeneralJournalEntryLoc.AccountingDate
                    && ledgerTransVoucherLink.DataAreaId == subledgerVoucherGeneralJournalEntryLoc.VoucherDataAreaId
            exists join generalJournalEntryLoc
                where subledgerVoucherGeneralJournalEntryLoc.GeneralJournalEntry == generalJournalEntryLoc.RecId
                    && subledgerVoucherGeneralJournalEntryLoc.Voucher == _relatedVoucher;
        cashDiscountAmount += cashDiscountTaxTrans.TaxAmount;

        return cashDiscountAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processConditionalTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs posting of conditional tax.
    /// </summary>
    /// <param name = "_ledgerVoucherObject">The instance of <c>LedgerVoucherObject</c>.</param>
    /// <param name = "_ledgerVoucher">The instance of <c>LedgerVoucher</c></param>
    /// <param name = "_ledgerJournaltrans">The record of <c>LedgerJournalTrans</c> for post PDC.</param>
    /// <param name = "_invoiceTrans">The record of <c>CustVendTrans</c> for invoice.</param>
    /// <param name = "_paymentTrans">The record of <c>CustVendTrans</c> for payment.</param>
    /// <param name = "_cashDiscAmountCur">The cash discount amount in the transaction currency.</param>
    /// <param name = "_percent">The percent of the transaction that is settled including the current settlement.</param>
    /// <param name = "_exchRate">The exchange rate between transaction and accounting currency.</param>
    /// <param name = "_exchRateReporting">The exchange rate between accounting and transaction currency.</param>
    /// <param name = "_cashDiscVAT">Cash discount is calculated on amount including sales tax.</param>
    /// <param name = "_module">The module the <c>CustVendTrans</c> record is in.</param>
    private void processConditionalTax(
        LedgerVoucherObject _ledgerVoucherObject,
        LedgerVoucher _ledgerVoucher,
        LedgerJournalTrans _ledgerJournaltrans,
        CustVendTrans _invoiceTrans,
        CustVendTrans _paymentTrans,
        DiscAmount _cashDiscAmountCur,
        Percent _percent,
        ExchRate _exchRate,
        ExchRate _exchRateReporting,
        boolean _cashDiscVAT,
        SysModule _module)
    {
        Debug::assert(curext() == _invoiceTrans.company());

        if (!TaxParameters::find().ConditionalTax)
        {
            return;
        }

        CustVendInvoiceJour custVendInvoiceJour;
        if (_module == SysModule::Vend)
        {
            custVendInvoiceJour = VendInvoiceJour::findFromVendTransVoucher(
                _invoiceTrans.Invoice,
                _invoiceTrans.Voucher,
                _invoiceTrans.TransDate,
                _invoiceTrans.AccountNum);
        }
        else if (_module == SysMoDule::Cust)
        {
            custVendInvoiceJour = CustInvoiceJour::findFromCustTransVoucher(
                _invoiceTrans.Invoice,
                _invoiceTrans.Voucher,
                _invoiceTrans.TransDate,
                _invoiceTrans.AccountNum);
        }

        Percent percent = _percent;
        //Conditional tax should be realized excluding the cash discount amount.
        if (_cashDiscVAT
            && _cashDiscAmountCur
            && _invoiceTrans.AmountCur)
        {
            percent -= (_cashDiscAmountCur / _invoiceTrans.AmountCur * 100);
        }

        LedgerJournalVoucherChanged ledgerJournalVoucherChanged;
        if (_invoiceTrans.TableId == tableNum(VendTrans))
        {
            ledgerJournalVoucherChanged = LedgerJournalVoucherChanged::findFromVendTrans(_invoiceTrans);
        }

        TableId taxTableId;
        RecId taxRecId;
        if (custVendInvoiceJour.RecId)
        {
            taxTableId = custVendInvoiceJour.TableId;
            taxRecId = custVendInvoiceJour.RecId;
        }
        else
        {
            taxTableId = _invoiceTrans.TableId;
            taxRecId = _invoiceTrans.RecId;
        }

        Voucher invoiceVoucher = ledgerJournalVoucherChanged.RecId ? ledgerJournalVoucherChanged.ToVoucher : _invoiceTrans.Voucher;
        TransDate invoiceDate = ledgerJournalVoucherChanged.RecId ? ledgerJournalVoucherChanged.ToDate : _invoiceTrans.TransDate;

        TaxTrans taxTrans;
        TaxTable taxTable;
        // check for conditional tax records
        select firstonly RecId from taxTrans
            where taxTrans.Voucher == invoiceVoucher
                && taxTrans.TransDate == invoiceDate
                && (taxTrans.TaxOrigin == TaxOrigin::Tax
                    || taxTrans.TaxOrigin == TaxOrigin::Transfer)
                && (taxTrans.TaxDirection == TaxDirection::IncomingTax
                    || taxTrans.TaxDirection == TaxDirection::OutgoingTax
                    || taxTrans.TaxDirection == TaxDirection::TaxExemptSales
                    || taxTrans.TaxDirection == TaxDirection::TaxExemptPurchase
                    || taxTrans.TaxDirection == TaxDirection::UseTax)
            join PaymentTaxCode from taxTable
                where taxTable.TaxCode == taxTrans.TaxCode
                    && taxTable.PaymentTaxCode != '';

        if (taxTrans.RecId == 0)
        {
            return;
        }

        LedgerPostingController ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(_ledgerVoucher);

        // <GEEU>
        if (CustVendTransPostingLog_RU::usePostingLog())
        {
            this.createLedgerVoucherObject_RU(ledgerPostingController.getJournal(), _invoiceTrans, _paymentTrans);
        }
        // </GEEU>

        _ledgerVoucher.findLedgerVoucherObject().lastTransTxt(_paymentTrans.Txt);

        TaxSettlement taxSettlement = new TaxSettlement(
            ledgerJournalVoucherChanged.RecId ? ledgerJournalVoucherChanged.ToVoucher : _invoiceTrans.Voucher,
            ledgerJournalVoucherChanged.RecId ? ledgerJournalVoucherChanged.ToDate : _invoiceTrans.TransDate,
            taxTableId,
            taxRecId,
            _invoiceTrans.CurrencyCode,
            _paymentTrans.TableId,
            _paymentTrans.RecId,
            percent,
            _exchRate,
            0,
            UnknownNoYes::No);
        taxSettlement.parmSettlementReportingCrossRate(_exchRateReporting);
        taxSettlement.parmEnableExchangeRatesGainLoss(true);
        taxSettlement.parmPercentIncludingCashDiscount(_percent);

        taxSettlement.parmInvoiceReportingCrossRate(_invoiceTrans.getReportingCombinedExchangeRate());
        taxSettlement.parmRelatedLedgerVoucher(_ledgerVoucher);

        taxSettlement.calcAndPost(ledgerPostingController);
        taxSettlement.reverseLinks(TaxTransRelationshipType::TransactionLineAccount);
        // <GEEU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU ]))
        {
            container taxTransRecIDsAndAmounts = taxSettlement.getContainers_W();
            CustVendSettlePostingLog_RU postingLog = CustVendSettlePostingLog_RU::newCustVendSettle(
                CustVendTransPostingLogType_RU::ConditionalTax,
                _invoiceTrans,
                _invoiceTrans,
                _paymentTrans);
            postingLog.parmVoucher(ledgerPostingController.getJournal().lastVoucher());
            postingLog.parmTransDate(ledgerPostingController.getJournal().lastTransDate());
            CustVendSettle custVendSettle = CustVendSettle::construct(_module);
            postingLog.parmCustVendSettle(custVendSettle);

            Set localTaxTransRecIDs;
            RecId localTaxTransRecID;
            TaxAmount taxAmount;
            for (int i = 1; i <= conLen(taxTransRecIDsAndAmounts); i++)
            {
                [localTaxTransRecID, taxAmount] = conPeek(taxTransRecIDsAndAmounts, i);
                localTaxTransRecIDs = new Set(typeName2Type(extendedTypeStr(RecId)));
                localTaxTransRecIDs.add(localTaxTransRecID);

                postingLog.parmTaxTransRecIDs(localTaxTransRecIDs);
                postingLog.createTrans(
                    LedgerPostingType::Tax,
                    0,
                    0,
                    _invoiceTrans.CurrencyCode,
                    taxAmount,
                    0,
                    0,
                    _invoiceTrans.exchRateCurToMst());
            }
        }
        // </GEEU>

        AmountMST taxExchAdjMst = taxSettlement.getTotalGainLossInAccountingAmount();
        AmountMSTSecondary taxExchAdjReporting = taxSettlement.getTotalGainLossInReportingCurrency();

        if (taxExchAdjMst || taxExchAdjReporting)
        {
            LedgerDimensionAccount mergedLedgerDimension;
            LedgerVoucherTransObject ledgerVoucherTransObject;

            if (taxExchAdjMst)
            {
                mergedLedgerDimension = this.accountLossProfitTax(taxExchAdjMst, _invoiceTrans.CurrencyCode);
                mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(mergedLedgerDimension, _invoiceTrans.DefaultDimension);

                ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
                    _ledgerVoucherObject,
                    this.getLedgerPostingType_ExchRateTax(taxExchAdjMst),
                    mergedLedgerDimension,
                    _invoiceTrans.CurrencyCode,
                    -taxExchAdjMst,
                    0.0);
                ledgerPostingController.addTrans(ledgerVoucherTransObject);
            }

            if (taxExchAdjReporting)
            {
                mergedLedgerDimension = this.accountLossProfitTax(taxExchAdjReporting, _invoiceTrans.CurrencyCode);
                mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(mergedLedgerDimension, _invoiceTrans.DefaultDimension);

                ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
                    _ledgerVoucherObject,
                    this.getLedgerPostingType_ExchRateTax(taxExchAdjReporting),
                    mergedLedgerDimension,
                    _invoiceTrans.CurrencyCode,
                    0.0,
                    -taxExchAdjReporting);
                ledgerPostingController.addTrans(ledgerVoucherTransObject);
            }
        }

        _ledgerVoucher.end();

        _ledgerVoucher.createVoucherLinks(_ledgerJournaltrans.Voucher, _ledgerJournaltrans.TransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingType_ExchRateTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger posting type for exchange rate difference for tax settlement.
    /// </summary>
    /// <param name="_exchRateDiff">
    /// Amount of the exchange rate adjustment.
    /// </param>
    /// <returns>
    /// <c>LedgerPostingType</c> for the tax settlement exchange adjustment posting.
    /// </returns>
    /// <remarks>
    /// The logic for retrieving the posting type is identical for both the AP and AR side.
    /// This is because on the AR side the tax posting is money that is owed by the company.
    /// If the company owes more tax (overall transaction gain) it is a tax loss. On the AP side,
    /// the tax posting is an asset that can be netted out against owed tax to reduce what
    /// is owed. If the tax that can be netted out is now less (overall transaction gain),
    /// it's a tax loss as well.
    /// </remarks>
    private LedgerPostingType getLedgerPostingType_ExchRateTax(Amount _exchRateDiff)
    {
        return _exchRateDiff > 0 ? LedgerPostingType::ExchRateGain : LedgerPostingType::ExchRateLoss;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountLossProfitTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger posting account for the tax settlement exchange adjustment
    /// posting.
    /// </summary>
    /// <param name="_exchRateDiff">
    /// Amount of the exchange rate adjustment.
    /// </param>
    /// <param name="_currencyCode">
    /// Currency code of the exchange adjustment posting.
    /// </param>
    /// <returns>
    /// <c>LedgerDimensionDefaultAccount</c> for the tax settlement exchange adjustment
    /// posting.
    /// </returns>
    /// <remarks>
    /// The logic for retrieving the account is identical for both the AP and AR side.
    /// This is because on the AR side the tax posting is money that is owed by the company.
    /// If the company owes more tax (overall transaction gain) it is a tax loss. On the AP side,
    /// the tax posting is an asset that can be netted out against owed tax to reduce what
    /// is owed. If the tax that can be netted out is now less (overall transaction gain),
    /// it's a tax loss as well.
    /// </remarks>
    private LedgerDimensionDefaultAccount accountLossProfitTax(
        Amount _exchRateDiff,
        CurrencyCode _currencyCode)
    {
        CurrencyGainLossAccountType accountType;

        if (_exchRateDiff > 0)
        {
            accountType = CurrencyGainLossAccountType::RealizedGain;
        }
        else
        {
            accountType = CurrencyGainLossAccountType::RealizedLoss;
        }

        LedgerDimensionDefaultAccount defaultAccount = CurrencyLedgerGainLossAccount::ledgerDimension(
            Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
            _currencyCode,
            accountType);

        return defaultAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleTaxWithhold</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Settles the withholding tax transactions that are posted for a vendor PDC.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher for the transactions.
    /// </param>
    /// <param name="_vendTrans">
    ///    The withholding tax that is posted to vendor transactions.
    /// </param>
    /// <param name="_taxWithholdTrans">
    ///    The withholding tax record.
    /// </param>
    /// <param name="_sign">
    ///    A value that is used to reverse a withholding tax transaction
    /// </param>
    public static void settleTaxWithhold(
        LedgerVoucher _ledgerVoucher,
        VendTrans _vendTrans,
        TaxWithholdTrans _taxWithholdTrans,
        Integer _sign = 1)
    {
        if (!_taxWithholdTrans.RecId)
        {
            return;
        }

        ttsbegin;

        // Creation of the TaxWithholdTrans record
        TaxWithholdTrans taxWithholdTransReverse;
        taxWithholdTransReverse.copyTaxWithholdTrans(
            _taxWithholdTrans,
            _ledgerVoucher.lastVoucher(),
            _ledgerVoucher.lastTransDate(),
            _sign);
        taxWithholdTransReverse.insert();

        ExchRate exchRate;
        ExchrateSecondary exchRateSecond;
        UnknownNoYes triangulation;
        if (_vendTrans.euroTriangulation)
        {
            triangulation = UnknownNoYes::Yes;
            exchRate = ExchangeRateHelper::exchRate(taxWithholdTransReverse.InvoiceCurrency, taxWithholdTransReverse.TransDate, triangulation);
            exchRateSecond = ExchangeRateHelper::exchRateSecond(taxWithholdTransReverse.InvoiceCurrency, taxWithholdTransReverse.TransDate, triangulation);
        }
        else
        {
            triangulation = UnknownNoYes::No;
            exchRate = taxWithholdTransReverse.InvoiceTaxWithholdAmount ?
                taxWithholdTransReverse.TaxWithholdAmount / taxWithholdTransReverse.InvoiceTaxWithholdAmount * 100 :
                0;
            exchRateSecond = 0;
        }

        // Posting of the withholding tax on the withholding tax account
        LedgerVoucherObject ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
        CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
        currencyExchangeHelper.parmExchangeRate1(exchRate);
        currencyExchangeHelper.parmExchangeRate2(exchRateSecond);

        LedgerDimensionDefaultAccount ledgerDimensionDefaultAccount = taxWithholdTransReverse.LedgerDimension;
        LedgerDimensionAccount ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionDefaultAccount, _vendTrans.DefaultDimension);

        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
            ledgerVoucherObject,
            LedgerPostingType::TaxWithhold,
            ledgerDimensionMerged,
            taxWithholdTransReverse.InvoiceCurrency,
            -taxWithholdTransReverse.InvoiceTaxWithholdAmount,
            currencyExchangeHelper);
        ledgerVoucherTransObject.parmSourceTableId(taxWithholdTransReverse.TableId);
        ledgerVoucherTransObject.parmSourceRecId(taxWithholdTransReverse.RecId);
        TransTxt transTxt = _ledgerVoucher.findLedgerVoucherObject().lastTransTxt();
        ledgerVoucherTransObject.parmTransTxt(transTxt);
        _ledgerVoucher.addTrans(ledgerVoucherTransObject);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferToAccountsPayable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transfer the current customer post dated check to vendor payment journal.
    /// </summary>
    /// <param name="_custVendPDCRegister">
    /// Post dated check to be transferred
    /// </param>
    /// <param name="_vendAccount">
    /// vendor account to which check needs to be transferred
    /// </param>
    /// <param name="_vendPaymMode">
    /// Vendor method of payment that needs to be set on the destination journal. This should have PDC clearing posting set.
    /// </param>
    public static void transferToAccountsPayable(CustVendPDCRegister _custVendPDCRegister, VendAccount _vendAccount, VendPaymMode _vendPaymMode)
    {
        if (_custVendPDCRegister.PDCStatus != PostDatedCheckStatus::Posted
            && _custVendPDCRegister.PDCStatus != PostDatedCheckStatus::Open)
        {
            checkFailed("@SYS330795");
            return;
        }

        JournalNameId journalName = BankParameters::find().VendPaymentJournalPDC;

        if (!journalName)
        {
            checkFailed("@SYS330295");
            return;
        }

        if (!_vendAccount || !_vendPaymMode)
        {
            checkFailed("@SYS330986");
            return;
        }

        ttsbegin;

        VendPaymModeTable vendPaymModeTable = VendPaymModeTable::find(_vendPaymMode);

        LedgerJournalTrans ledgerJournalTransCust = LedgerJournalTrans::findRecId(_custVendPDCRegister.LedgerJournalTrans, false);

        LedgerJournalTable ledgerJournalTable;
        ledgerJournalTable.initFromLedgerJournalName(journalName);
        ledgerJournalTable.insert();

        // Initialize ledgerJournalTrans
        LedgerJournalTrans ledgerJournalTrans;
        ledgerJournalTrans.data(ledgerJournalTransCust);
        ledgerJournalTrans.AccountType = LedgerJournalACType::Vend;

        // Get new voucher number
        NumberSequenceTable numberSequenceTable = NumberSequenceTable::find(ledgerJournalTable.NumberSequenceTable);
        SysLastValue nextNumSeq;
        nextNumSeq.Value = connull();
        NumberSeq numberSeq = NumberSeq::newGetNumFromId(numberSequenceTable.RecId, true, true, nextNumSeq, true);

        if (numberSeq)
        {
            Num nextNumber;
            [nextNumber] = nextNumSeq.Value;
            ledgerJournalTrans.Voucher = nextNumber;
        }

        ledgerJournalTrans.parmAccount(_vendAccount);
        ledgerJournalTrans.JournalNum = ledgerJournalTable.JournalNum;
        ledgerJournalTrans.AmountCurCredit = ledgerJournalTransCust.AmountCurDebit;
        ledgerJournalTrans.AmountCurDebit = ledgerJournalTransCust.AmountCurCredit;
        ledgerJournalTrans.PaymMode = _vendPaymMode;
        ledgerJournalTrans.modifiedField(fieldNum(LedgerJournalTrans, PaymMode));
        ledgerJournalTrans.OffsetLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimForDefaultDim(VendTable::find(_vendAccount).DefaultDimension, ledgerJournalTrans.OffsetLedgerDimension);
        ledgerJournalTrans.insert();

        CustVendPDCRegister custVendPDCRegister;
        custVendPDCRegister.data(_custVendPDCRegister);
        custVendPDCRegister.LedgerJournalTrans = ledgerJournalTrans.RecId;
        custVendPDCRegister.PDCStatus = PostDatedCheckStatus::Open;
        custVendPDCRegister.AccountType = CustVendACType::Vend;
        custVendPDCRegister.insert();

        _custVendPDCRegister.selectForUpdate(true);
        _custVendPDCRegister.PDCStatus = PostDatedCheckStatus::TransferredToAP;
        _custVendPDCRegister.update();

        ttscommit;

        info(strfmt("@SYS330987", _vendAccount, ledgerJournalTable.JournalNum));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostDatedCheckNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Copies check numbers that are generated to postdated check records.
    /// </summary>
    /// <param name="_journalId">
    ///    The payment journal for which postdated checks are generated.
    /// </param>
    /// <remarks>
    ///    This method is part of payment creation using checks.
    /// </remarks>
    ///
    public static void updatePostDatedCheckNum(LedgerJournalId _journalId)
    {
        CustVendPDCRegister custVendPDCRegister;
        LedgerJournalTrans ledgerJournalTrans;

        ttsbegin;
        while select forupdate custVendPDCRegister
            join ledgerJournalTrans
            where ledgerJournalTrans.RecId == custVendPDCRegister.LedgerJournalTrans
                && ledgerJournalTrans.JournalNum == _journalId
                && ledgerJournalTrans.BankChequeNum != ''
        {
            custVendPDCRegister.CheckNumber = ledgerJournalTrans.BankChequeNum;
            custVendPDCRegister.update();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPostDatedChecksEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if Postdated Checks functionality is enabled.
    /// </summary>
    /// <returns>
    /// Returns true if the functionality is enabled; otherwise false.
    /// </returns>
    public static boolean isPostDatedChecksEnabled()
    {
        return isConfigurationkeyEnabled(configurationKeyNum(LedgerPostDatedChecks)) && BankParameters::find().EnablePDC;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerVoucherObject_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create ledger voucher object.
    /// </summary>
    /// <param name = "_ledgerVoucher">The instance of <c>LedgerVoucher</c>.</param>
    /// <param name = "_invoiceTrans">The record of <c>CustVendTrans</c> for invoice.</param>
    /// <param name = "_paymentTrans">The record of <c>CustVendTrans</c> for payment.</param>
    /// <returns>The instance of <C>LedgerVoucherObject</C>.</returns>
    private LedgerVoucherObject createLedgerVoucherObject_RU(LedgerVoucher _ledgerVoucher, CustVendTrans _invoiceTrans, CustVendTrans _paymentTrans)
    {
        LedgerVoucherObject ledgerVoucherObject;
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU ]))
        {
            ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
            TransDate transactionDate = max(_invoiceTrans.TransDate, _paymentTrans.TransDate);

            if (ledgerVoucherObject && ledgerVoucherObject.transElements())
            {
                NumberSeq numberSeq = NumberSeq::newGetVoucherFromCode(_ledgerVoucher.parmVoucherSeriesCode());
                ledgerVoucherObject = LedgerVoucherObject::newVoucher(
                    numberSeq.voucher(),
                    transactionDate,
                    _ledgerVoucher.parmSysModuleDefault(),
                    ledgerVoucherObject.parmLedgerTransType());
                _ledgerVoucher.addVoucher(ledgerVoucherObject);
            }

            if (ledgerVoucherObject && !ledgerVoucherObject.transElements())
            {
                ledgerVoucherObject.parmTransDate(transactionDate);
            }
        }

        return ledgerVoucherObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine trans date for cust vend invoice trans.
    /// </summary>
    /// <param name = "custVendTrans">The record of <c>CustVendTrans</c> for invoice.</param>
    /// <returns>The trans date.</returns>
    private TransDate determineTransDate(CustVendTrans custVendTrans)
    {
        LedgerJournalTrans ledgerJournalTrans;
        TaxTable taxTable;
        TaxTrans taxTrans;
        TaxTrans reversedTaxTrans;
        TaxTransGeneralJournalAccountEntry taxTransGeneralJournalAccountEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        DimensionAttributeValueCombination dimensionAttributeValueCombination, reversedDimensionAttributeValueCombination;

        TransDate transDate = custVendTrans.TransDate;

        // Taxes are not always added as of the CustVendTrans.TransDate.  It is possible to add taxes on an invoice register
        // or approval journals and each journal can have a different date.  Therefore, we need to find the 'correct' tax transaction
        // date so these transactiosn can be reversed durring settlements.  This query looks up related tax transactions, ensures
        // those transactions have not already been reversed and uses that tax transaction date.
        while select TableId, RecId from ledgerJournalTrans
            where ledgerJournalTrans.VendTransId == custVendTrans.RecId
        {
            select firstonly TaxCode, Voucher, TaxAmount, TransDate
                from taxTrans
                where taxTrans.SourceTableId == ledgerJournalTrans.TableId
                    && taxTrans.SourceRecId == ledgerJournalTrans.RecId
                    && taxTrans.ExemptTax == NoYes::No
                    && (taxTrans.TaxDirection == TaxDirection::IncomingTax
                    || taxTrans.TaxDirection == TaxDirection::OutgoingTax
                    || taxTrans.TaxDirection == TaxDirection::UseTax)
                join RecId from taxTable
                    where taxTable.TaxCode == taxTrans.TaxCode
                        && taxTable.PaymentTaxCode != ''
                        && taxTable.TaxBase != TaxBaseType::AmountByUnit
                join firstonly RecId from taxTransGeneralJournalAccountEntry
                    where taxTrans.RecId == taxTransGeneralJournalAccountEntry.TaxTrans
                        && taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::Tax
                outer join RecId from generalJournalAccountEntry
                    where generalJournalAccountEntry.RecId == taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry
                join Hash, RecId from dimensionAttributeValueCombination
                    where ((dimensionAttributeValueCombination.RecId == generalJournalAccountEntry.LedgerDimension
                            && taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry)
                        || (dimensionAttributeValueCombination.RecId == taxTransGeneralJournalAccountEntry.LedgerDimension
                            && !taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry));

            if (dimensionAttributeValueCombination.RecId)
            {
                select firstonly RecId from reversedTaxTrans
                    where reversedTaxTrans.Voucher == taxTrans.Voucher
                        && reversedTaxTrans.TaxOrigin == TaxOrigin::TaxReversed
                        && reversedTaxTrans.TaxAmount == -taxTrans.TaxAmount
                    join firstonly RecId from taxTransGeneralJournalAccountEntry
                        where taxTrans.RecId == taxTransGeneralJournalAccountEntry.TaxTrans
                            && taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::Tax
                    outer join RecId from generalJournalAccountEntry
                        where generalJournalAccountEntry.RecId == taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry
                    join RecId from reversedDimensionAttributeValueCombination
                        where (((reversedDimensionAttributeValueCombination.RecId == generalJournalAccountEntry.LedgerDimension
                                    && taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry)
                                || (reversedDimensionAttributeValueCombination.RecId == taxTransGeneralJournalAccountEntry.LedgerDimension
                                    && !taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry))
                            && reversedDimensionAttributeValueCombination.Hash == dimensionAttributeValueCombination.Hash);

                if (reversedDimensionAttributeValueCombination.RecId == 0)
                {
                    transDate = taxTrans.TransDate;
                    break;
                }
            }
        }

        return transDate;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>