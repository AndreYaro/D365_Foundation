<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSAutoReleaseToWarehouse</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WhsAutoReleaseToWarehouse</c> is used to run batch job for auto releasing to warehouse.
/// </summary>
class WhsAutoReleaseToWarehouse extends RunBaseBatch implements BatchRetryable, SysErrorMessageHelpScopeIBatchProvider
{
    QueryRun            queryRun;

    DialogField                     fldReleaseQuantitySpecification;
    DialogField                     fldAllowPartiallyReleased;
    DialogField                     fldKeepReservations;
    DialogField                     fldOrderType;
    DialogField                     fldCreditMaxCheck;

    private DialogField             fldGroupIntoMultipleReleases;
    private DialogField             fldLockedOrderHandling;

    WHSReleaseQuantitySpecification releaseQuantitySpecification;
    boolean                         allowPartiallyReleased;
    boolean                         keepReservations;
    WHSAutoReleaseOrderType         validOrderTypes;
    private boolean                 groupIntoMultipleReleases;
    private WHSLockedOrderHandling  lockedOrderHandling;

    WHSReleaseToWarehouseRetrieveRTWId  retrieveRTWId;
    CustCreditMaxCheck                  creditMaxCheck;
    WHSReleaseToWarehouseId             releaseToWarehouseIdGlobal;
    private boolean                     errorsFound;

    private Set                     releaseIdsWithRTWLinesSet;

    private WHSInstrumentationLogger logger;

    #define.Version8(8)

    #define.Version9(9)
        #localmacro.Version9List
        releaseQuantitySpecification,
        allowPartiallyReleased,
        keepReservations
    #endmacro

    #define.Version10(10)
    #localmacro.Version10List
		releaseQuantitySpecification,
		allowPartiallyReleased,
		keepReservations,
		validOrderTypes
	#endmacro

    #define.Version11(11)
    #localmacro.Version11List
        releaseQuantitySpecification,
        allowPartiallyReleased,
        keepReservations,
        validOrderTypes,
        creditMaxCheck
    #endmacro

    #define.Version12(12)
    #localmacro.Version12List
        releaseQuantitySpecification,
        allowPartiallyReleased,
        keepReservations,
        validOrderTypes,
        creditMaxCheck,
        groupIntoMultipleReleases
    #endmacro

    #define.CurrentVersion(13)
    #localmacro.CurrentList
		releaseQuantitySpecification,
		allowPartiallyReleased,
		keepReservations,
		validOrderTypes,
		creditMaxCheck,
        groupIntoMultipleReleases,
        lockedOrderHandling
	#endmacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmGroupIntoMultipleReleases</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean parmGroupIntoMultipleReleases(boolean _groupIntoMultipleReleases = groupIntoMultipleReleases)
    {
        groupIntoMultipleReleases = _groupIntoMultipleReleases;
        return groupIntoMultipleReleases;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLockedOrderHandling</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal WHSLockedOrderHandling parmLockedOrderHandling(WHSLockedOrderHandling _lockedOrderHandling = lockedOrderHandling)
    {
        lockedOrderHandling = _lockedOrderHandling;
        return lockedOrderHandling;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultGroupIntoMultipleReleases</Name>
				<Source><![CDATA[
    [Replaceable(true)]
    public void defaultGroupIntoMultipleReleases()
    {
        if (this.mustUseShipmentConsolidation())
        {
            groupIntoMultipleReleases = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoReserveItemToWarehouse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Automatically reserves an item to the warehouse.
    /// </summary>
    /// <param name="_salesLine">
    /// A <c>SalesLine</c> record for which to reserve the item to the warehouse.
    /// </param>
    /// <param name="_processingResult">
    /// The processing result object which will be updated if there are any errors or warnings
    /// that can prevent the entire sales order from being released to warehouse.
    /// </param>
    protected void autoReserveItemToWarehouse(
        SalesLine _salesLine,
        WHSWarehouseReleaseProcessingResult _processingResult)
    {
        InventUpd_Reservation   reservation;
        InventMovement          movement;
        InventQty               reserveQuantity;
        PdsCWQty                reserveCWQuantity;
        boolean                 needsQuantityReserved;

        if (PdsGlobal::pdsIsCWItem(_salesLine.ItemId))
        {
            // Because of potential for automatic weight adjustments, sales line must be selected for update for catch weight items.
            SalesLine cwSalesLine = SalesLine::findRecId(_salesLine.RecId, true);
            movement = InventMovement::construct(cwSalesLine);

            reserveCWQuantity = cwSalesLine.PdsCWRemainInventPhysical - abs(movement.transIdSum().pdsCWReserved());
            needsQuantityReserved   = reserveCWQuantity > 0;
            reserveQuantity         = WhsInvent::defaultCatchWeightReserveQuantity(_salesLine.ItemId, reserveCWQuantity);
        }
        else
        {
            movement = InventMovement::construct(_salesLine);
            reserveQuantity = _salesLine.RemainInventPhysical - abs(movement.transIdSum().reserved());

            if (this.useKitting())
            {
                reserveQuantity     = KittingDelegateHelper::getQtyToReserve(_salesLine, reserveQuantity);
            }

            needsQuantityReserved   = reserveQuantity > 0;
        }

        if (needsQuantityReserved)
        {
            reservation = InventUpd_Reservation::newMovement(
                                        movement,
                                        -reserveQuantity,
                                        true, /*mayBeReduced */
                                        false,
                                        false,
                                        -reserveCWQuantity);

            reservation.updateNow();

            _processingResult.parmIsReservationDone(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQuery</Name>
				<Source><![CDATA[
    /// <summary>
	/// Builds query for auto release to warehouse.
	/// </summary>
	/// <returns>
	/// The query built.
	/// </returns>
    Query buildQuery()
    {
        Query           query;
        QueryBuildDataSource dsSalesTable, dsSalesLine, dsCustTable, dsMCRSalesTable, dsInventTable;

        if (WHSReleaseToWarehouseSalesQueryNoDynamicFldsV2Flight::instance().isEnabled())
        {
            query = new Query(queryStr(WHSReleaseToWarehouseSalesNonDynamicFields));
        }
        else 
        {
            query = new Query(queryStr(WHSReleaseToWarehouseSales));
        }

        dsSalesTable = query.dataSourceTable(tableNum(SalesTable));
        this.addLockedRange(dsSalesTable, fieldNum(SalesTable, ReleaseStatus), SysQuery::valueNot(WHSReleaseStatus::Released));
        this.addLockedRange(dsSalesTable, fieldNum(SalesTable, mcrOrderStopped), queryValue(NoYes::No));

        dsSalesLine =  query.dataSourceTable(tableNum(SalesLine));
        this.addLockedRange(dsSalesLine, fieldNum(SalesLine, SalesStatus), queryRangeConcat(queryValue(SalesStatus::None), queryValue(SalesStatus::Backorder)));
        this.setOrderTypeRange(dsSalesLine);
        dsSalesLine.addRange(fieldNum(SalesLine, ConfirmedDlv));

        if (FeatureStateProvider::IsFeatureEnabled(KittingFeature::instance()))
        {
            dsSalesLine.addSortField(fieldNum(SalesLine, ConfirmedDlv));
            dsSalesLine.addSortField(fieldNum(SalesLine, LineNum));
        }

        dsCustTable = query.dataSourceTable(tableNum(CustTable));
        dsCustTable.addRange(fieldNum(CustTable, CustClassificationId)); // override default range with one that makes more sense in this scenario

        dsInventTable = query.dataSourceTable(tableNum(InventTable));
        dsInventTable.addRange(fieldNum(InventTable, ItemId)).status(RangeStatus::Hidden); // Hide the default range for the table.

        dsMCRSalesTable = query.dataSourceTable(tableNum(MCRSalesTable));
        dsMCRSalesTable.fetchMode(QueryFetchMode::One2One);
        dsMCRSalesTable.joinMode(JoinMode::OuterJoin);
        dsMCRSalesTable.addRange(fieldNum(MCRSalesTable, SalesTable)).status(RangeStatus::Hidden); // Hide the default ranges for the table. It is joined in the query for the sorting purposes

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatchJournal</Name>
				<Source><![CDATA[
    public boolean canGoBatchJournal()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustReserveOnReleaseToWarehouse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if reservation should be done during release to warehouse for the specified sales line.
    /// </summary>
    /// <param name="_salesLine">
    /// The sales line.
    /// </param>
    /// <returns>
    /// true if reservation should be done during release to warehouse; otherwise, false.
    /// </returns>
    private boolean mustReserveOnReleaseToWarehouse(SalesLine _salesLine)
    {
        return _salesLine.inventDim().inventLocation().WarehouseAutoReleaseReservation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new()
    {
        super();

        queryRun = new QueryRun(this.buildQuery());
        this.defaultCheckCreditMax();
        this.defaultGroupIntoMultipleReleases();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList, queryRun.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    public QueryRun queryRun()
    {
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldReduceLoadLineWhenCrossDockFailed</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static boolean shouldReduceLoadLineWhenCrossDockFailed(WHSReleaseQuantitySpecification _releaseQuantitySpecification)
    {
        return _releaseQuantitySpecification == WHSReleaseQuantitySpecification::ReservedPhysically
            || _releaseQuantitySpecification == WHSReleaseQuantitySpecification::ReservedPhysicallyAndCrossDock;
    }

]]></Source>
			</Method>
			<Method>
				<Name>releaseLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Release the lines with the release Id specified.
    /// </summary>
    /// <param name="_releaseToWarehouse">
    /// The release to warehouse lines.
    /// </param>
    /// <param name="_releaseToWarehouseId">
    /// The release to warehouse Id to release.
    /// </param>
    protected void releaseLines(WHSTmpReleaseToWarehouse _releaseToWarehouse, WHSReleaseToWarehouseId _releaseToWarehouseId)
    {
        #OCCRetryCount
        WHSTmpReleaseToWarehouse releaseToWarehouseOrderRec;
        boolean                  isConsolidatedId;
        WHSOrderNum              firstOrderNum;

        void setErrorsFound()
        {
            if (isConsolidatedId)
            {
                error("@WAX1895");
            }
            else
            {
                error(strFmt("@WAX2951", firstOrderNum));
            }

            errorsFound = true;
        }
        
        releaseToWarehouseOrderRec.linkPhysicalTableInstance(_releaseToWarehouse);

        try
        {
            select count(RecId) from releaseToWarehouseOrderRec
                where releaseToWarehouseOrderRec.ReleaseToWarehouseId == _releaseToWarehouseId
                    && releaseToWarehouseOrderRec.OrderNum            == _releaseToWarehouse.OrderNum;

            isConsolidatedId = releaseToWarehouseOrderRec.RecId > 1 ? true : false;
            firstOrderNum = _releaseToWarehouse.OrderNum;

            using (WHSShouldReduceLoadLineWhenCrossDockFailedContext context = WHSShouldReduceLoadLineWhenCrossDockFailedContext::newFromParms(WhsAutoReleaseToWarehouse::shouldReduceLoadLineWhenCrossDockFailed(releaseQuantitySpecification)))
            {
                ttsBegin;
                WHSWarehouseRelease::releaseToWarehouse(_releaseToWarehouse, _releaseToWarehouseId, false, false, true);
                ttsCommit;
            }
        }
        catch (Exception::UpdateConflict)
        {
            var context = WHSLockedOrderHandlingContext::instance();

            if (context &&
                context.skipOccurred)
            {
                context.reset();
                exceptionTextFallThrough();
            }
            else
            {
                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() < #RetryNum)
                    {
                        retry;
                    }
                    throw Exception::UpdateConflictNotRecovered;
                }
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::TransientSqlConnectionError)
        {
            //When SQL errors are encountered the tmp table cannot be access, so we need to return to the outermost catch to get is recreated
            if (WHSReleaseToWarehouseSQLErrorThrowFlight::instance().isEnabled())
            {
                throw error("@WAX:ReleaseToWHDBError");
            }
            else
            {
                setErrorsFound();
            }
        }
        catch (Exception::PersistentSqlConnectionError)
        {
            //When SQL errors are encountered the tmp table cannot be access, so we need to return to the outermost catch to get is recreated
            if (WHSReleaseToWarehouseSQLErrorThrowFlight::instance().isEnabled())
            {
                throw error("@WAX:ReleaseToWHDBError");
            }
            else
            {
                setErrorsFound();
            }
        }
        catch
        {
            // Display the order number that failed if possible.
            setErrorsFound();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContextBatchServer(this))
        {
            using (WHSInstrumentationReleaseToWarehousePerformanceTask perfTask = WHSInstrumentationReleaseToWarehousePerformanceTask::newFromAction('autoReleaseSalesOrders'))
            {
                perfTask.setGroupIntoMultipleWaves(groupIntoMultipleReleases);
                perfTask.setLockedOrderHandling(lockedOrderHandling);

                WHSTmpReleaseToWarehouse    releaseToWarehouse;                

                setPrefix("@WAX2927");

                if (!groupIntoMultipleReleases &&
                    this.mustUseShipmentConsolidation())
                {
                    releaseToWarehouseIdGlobal = WHSTmpReleaseToWarehouse::getNextReleaseToWarehouseId();
                }
                else
                {
                    retrieveRTWId = WHSReleasetoWarehouseRetrieveRTWId::construct();
                    retrieveRTWId.parmUseConsolidationPolicies(this.mustUseShipmentConsolidation());
                    releaseIdsWithRTWLinesSet = new Set(Types::String);
                }

                select firstonly releaseToWarehouse; // ensure that the temp table is created

                int processedSalesOrders = 0;
                WHSAutoRTWReleaseEnumerator enumerator = WHSAutoRTWReleaseEnumerator::newFromQuery(this.getFinalQuery());
                while (enumerator.nextSalesOrder())
                {
                    this.processSalesOrder(enumerator, releaseToWarehouse);
                    processedSalesOrders++;
                }

                perfTask.setReleasedSalesOrders(processedSalesOrders);

                using (WHSLockedOrderHandlingContext context = WHSLockedOrderHandlingContext::instance())
                {
                    context.initialize(lockedOrderHandling);

                    if (releaseToWarehouseIdGlobal)
                    {
                        this.releaseLines(releaseToWarehouse, releaseToWarehouseIdGlobal);
                    }
                    else
                    {
                        var rtwEnumerator = retrieveRTWId.getValidReleaseToWarehouseIds().getEnumerator();                        
                        while (rtwEnumerator.moveNext())
                        {
                            if (releaseIdsWithRTWLinesSet && releaseIdsWithRTWLinesSet.in(rtwEnumerator.current()))
                            {
                                this.releaseLines(releaseToWarehouse, rtwEnumerator.current());
                            }
                        }
                    }

                    perfTask.setSkippedOrders(context.numberOfSkippedOrders);
                }

                if (errorsFound
                    && this.isInBatch()
                    && WHSParameters::find().EnableReleaseToWarehouseErrorOnBatchFailure)
                {
                    throw error("@WAX:AutoReleaseToWarehouseFailed");
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUseShipmentConsolidation</Name>
				<Source><![CDATA[
    protected boolean mustUseShipmentConsolidation()
    {
        return WHSShipConsolidationPolicy::anyPolicyExists();
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesTypeQueryRangeValueDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for specifying the query range for <c>SalesLine.SalesType</c>.
    /// </summary>
    /// <param name = "_whsAutoReleaseOrderType">The provided order types.</param>
    /// <param name = "_result">An <c>EventHandlerResult</c> class where subscribers can provide the range when applicable.</param>
    delegate void salesTypeQueryRangeValueDelegate(WHSAutoReleaseOrderType _whsAutoReleaseOrderType, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setOrderTypeRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the sales order type query range based on the dialog field.
    /// </summary>
    /// <param name="_dataSource">
    /// The datasource that should contain the order type range.
    /// </param>
    private void setOrderTypeRange(QueryBuildDataSource _dataSource)
    {
        QueryBuildRange orderTypeRange;

        orderTypeRange = SysQuery::findOrCreateRange(_dataSource, fieldNum(SalesLine, SalesType));
        orderTypeRange.status(RangeStatus::Locked);
        
        str queryRangeValue;

        switch (validOrderTypes)
        {
            case WHSAutoReleaseOrderType::SalesItemReq:
                queryRangeValue = queryRangeConcat(queryValue(SalesType::Sales), queryValue(SalesType::ItemReq));
                break;

            case WHSAutoReleaseOrderType::Sales:
                queryRangeValue = queryValue(SalesType::Sales);
                break;

            case WHSAutoReleaseOrderType::ItemReq:
                queryRangeValue = queryValue(SalesType::ItemReq);
                break;

            default:
                EventHandlerResult result = EventHandlerResult::newSingleResponse();
                this.salesTypeQueryRangeValueDelegate(validOrderTypes, result);

                if (result.hasResult())
                {
                    queryRangeValue = result.result();
                }
                else
                {
                    throw error(Error::wrongUseOfFunction(funcName()));
                }
                break;
        }
        
        orderTypeRange.value(queryRangeValue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQuerySelectButton</Name>
				<Source><![CDATA[
    /// <summary>
	/// Checks if to show query select button.
	/// </summary>
	/// <returns>
	/// True if to show query select button.
	/// </returns>
    boolean showQuerySelectButton()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    public boolean showQueryValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version     version = RunBase::getVersion(_packedClass);
        boolean     ret = true;
        container   packedQuery;

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList, packedQuery] = _packedClass;
                queryRun = packedQuery ? new QueryRun(packedQuery) : null;
                ret  = queryRun != null;
                break;

            case #Version8:
                [version, packedQuery] = _packedClass;
                queryRun = packedQuery ? new QueryRun(this.upgradeVersion8Query(packedQuery)) : null;
                ret  = queryRun != null;
                break;

            case #Version9:
                [version, #Version9List, packedQuery] = _packedClass;
                queryRun = packedQuery ? new QueryRun(packedQuery) : null;
                ret = queryRun != null;
                break;

			case #Version10:
				[version, #Version10List, packedQuery] = _packedClass;
				queryRun = packedQuery ? new QueryRun(packedQuery) : null;
				ret = queryRun != null;
                break;

            case #Version11:
                [version, #Version11List, packedQuery] = _packedClass;
                queryRun = packedQuery ? new QueryRun(packedQuery) : null;
                ret = queryRun != null;
                break;

            case #Version12:
                [version, #Version12List, packedQuery] = _packedClass;
                queryRun = packedQuery ? new QueryRun(packedQuery) : null;
                ret = queryRun != null;
                break;

            default:
                ret = false;
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static WHSAutoReleaseToWarehouse construct()
    {
        return new WHSAutoReleaseToWarehouse();
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    static ClassDescription description()
    {
        return "@SYP4860550";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args _args)
    {
        WHSAutoReleaseToWarehouse    autoRTWSales;

        autoRTWSales = WHSAutoReleaseToWarehouse::construct();

        using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContextBatchController(autoRTWSales))
        {
            if (autoRTWSales.prompt())
            {
                autoRTWSales.runOperation();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLockedRange</Name>
				<Source><![CDATA[
    private void addLockedRange(QueryBuildDataSource _dataSource, FieldId _fieldId, str _value)
    {
        QueryBuildRange range = _dataSource.addRange(_fieldId);
        range.status(RangeStatus::Locked);
        range.value(_value);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCanReleaseSalesOrderPreProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Pre-check if the sales order can be released
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order which will be checked.
    /// </param>
    /// <returns>
    /// true if sales order can be released to warehouse; otherwise, false.
    /// </returns>
    public boolean checkCanReleaseSalesOrderPreProcess(SalesTable _salesTable)
    {
        boolean result = true;

        if (!allowPartiallyReleased
            && (this.isSalesOrderPartiallyReleased(_salesTable) || this.isSalesOrderReleasedUsingNonWHSProcess(_salesTable))
            && !keepReservations)
        {
            result = checkFailed("@SYP4881421");
        }

        using (var context = WHSAutoReleaseToWarehouseSkipSOPreProcessMCRCallCenterFullReservCheckContext::construct())
        {
            result = result && _salesTable.canReleaseToWarehouse();
        }

        if (!result)
        {
            error(strFmt("@WAX2951", _salesTable.SalesId));
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCanReleaseSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the specified sales line can be released to warehouse.
    /// </summary>
    /// <param name="_salesLine">
    /// The sales line.
    /// </param>
    /// <param name="_processingResult">
    /// The processing result object which will be updated if there are any errors or warnings
    /// that can prevent the entire sales order from being released to warehouse.
    /// </param>
    /// <returns>
    /// true if the sales line can be released to warehouse; otherwise, false.
    /// </returns>
    protected boolean checkCanReleaseSalesLine(
        SalesLine                           _salesLine,
        WHSWarehouseReleaseProcessingResult _processingResult)
    {
        boolean result = true;

        if (this.pendingPickingListExists(_salesLine))
        {
            _processingResult.addOrderLevelWarning("@WAX5826");
            result = false;
        }

        if (WhsWarehouseRelease::useSalesLineDeliveryAddress())           
        {
            if (!_salesLine.DeliveryPostalAddress
                || (this.mustUseShipmentConsolidation()
                    && (   !_salesLine.deliveryAddress().whsAddressFormatValidation()
                        || !_salesLine.deliveryAddress().isEffective())))
            {
                _processingResult.addOrderLevelError(strFmt("@WAX4810", _salesLine.SalesId));
                result = false;
            }
        }
        else
        {
            SalesTable salesTable = _salesLine.salesTable();

            if (!salesTable.DeliveryPostalAddress
                || (this.mustUseShipmentConsolidation()
                    && (   !salesTable.deliveryAddress().whsAddressFormatValidation()
                        || !salesTable.deliveryAddress().isEffective())))
            {
                _processingResult.addOrderLevelError(strFmt("@WAX:ReleaseToWarehouseError_SalesOrderMissingDeliveryAddress", _salesLine.SalesId));
                result = false;
            }
        }

        if (result
            && !_salesLine.DeliveryName)
        {
            _processingResult.addOrderLevelWarning(strFmt("@WAX:ReleaseToWarehouseError_SalesOrderMissingDeliveryName", _salesLine.SalesId));
            result = false;
        }

        if (result
            && !_salesLine.SalesUnit)
        {
            _processingResult.addOrderLevelError(strFmt("@WAX:ReleaseToWarehouseError_SalesOrderMissingSalesUnit", _salesLine.SalesId));
            result = false;
        }

        if (result
            && !WhsWarehouseRelease::checkItemNotStoppedForInventOrSales(_salesLine))
        {
            _processingResult.addOrderLevelError(strFmt("@WAX:ReleaseToWarehouseError_SalesOrderItemStopped", _salesLine.ItemId, _salesLine.SalesId));
            result = false;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCanReleaseSalesOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the specified sales order can be released to warehouse.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order.
    /// </param>
    /// <param name="_processingResult">
    /// The processing result object which will be updated if there are any errors or warnings
    /// that can prevent the entire sales order from being released to warehouse.
    /// </param>
    /// <returns>
    /// true if the sales order can be released to warehouse; otherwise, false.
    /// </returns>
    protected boolean checkCanReleaseSalesOrder(
        SalesTable                          _salesTable,
        WHSWarehouseReleaseProcessingResult _processingResult)
    {
        boolean result;

        using (var activityContext = this.activities().checkCanReleaseSalesOrder(_salesTable.RecId))
        {
            result = !_processingResult.hasOrderLevelErrors();

            _processingResult.displayOrderLevelMessages();

            result = WHSFulfillmentRateValidator::checkFulfillmentRate(_salesTable, ErrorTolerance::Warning) && result;

            result = WHSWarehouseRelease::creditLimitCheck(_salesTable, true, creditMaxCheck) && result;

            if (WHSWarehouseRelease::isOrderOnLoadAndNotOnShipment(_salesTable.SalesId, InventTransType::Sales))
            {
                result = checkFailed("@WAX4240");
            }

            if (_salesTable.mcrIsCallCenter())
            {
                // Check for ship complete
                // Do not make a pick list if the order is not complete (if ship complete is on)
                if (! _salesTable.mcrCheckShipComplete())
                {
                    result = checkFailed(strFmt("@MCR12672", _salesTable.SalesId));
                }
            }

            if (!allowPartiallyReleased
            && (this.isSalesOrderPartiallyReleased(_salesTable) || this.isSalesOrderReleasedUsingNonWHSProcess(_salesTable)))
            {
                result = checkFailed("@SYP4881421");
            }

            if (!result)
            {
                error(strFmt("@WAX2951", _salesTable.SalesId));

                errorsFound = true;
            }

            this.activities().parmIsCheckCanReleaseSalesOrderPassed(activityContext, result);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    public Object dialog()
    {
        DialogRunbase dialog;

        dialog = super();

        dialog.addGroup("@SYS12687");

        fldReleaseQuantitySpecification = dialog.addFieldValue(enumStr(WHSReleaseQuantitySpecification), releaseQuantitySpecification);
        fldAllowPartiallyReleased = dialog.addFieldValue(enumStr(NoYes), allowPartiallyReleased, "@SYP4881422", "@SYP4881423");
        fldKeepReservations = dialog.addFieldValue(enumStr(NoYes), keepReservations, "@SYP4881424", "@SYP4881425");

        if (this.mustUseShipmentConsolidation())
        {
            fldGroupIntoMultipleReleases = dialog.addFieldValue(enumStr(NoYes), groupIntoMultipleReleases, "@WAX:WHSAutoReleaseToWarehouseGroupIntoMultipleReleasesLabel", "@FieldDescriptions_WHS:WHSAutoReleaseToWarehouse_GroupIntoMultipleReleases");
        }

        fldLockedOrderHandling = dialog.addFieldValue(enumStr(WHSLockedOrderHandling), lockedOrderHandling, "@WAX:WHSLockedOrderHandlingLabel", "@FieldDescriptions_WHS:WHSLockedOrderHandling");
        fldOrderType = dialog.addFieldValue(enumStr(WHSAutoReleaseOrderType), validOrderTypes);
        fldCreditMaxCheck = dialog.addFieldValue(extendedTypeStr(CustCreditMaxCheck), creditMaxCheck);

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayReservationKeptMessage</Name>
				<Source><![CDATA[
    private void displayReservationKeptMessage(WHSWarehouseReleaseProcessingResult _processingResult)
    {
        if (_processingResult.parmIsReservationDone())
        {
            info("@SYP4881545");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFinalQuery</Name>
				<Source><![CDATA[
    Query getFinalQuery()
    {
        Query query;
        QueryBuildDataSource dsInventTable, dsWHSInventEnabled;

        query = queryRun.query();

        dsInventTable = query.dataSourceTable(tableNum(InventTable));

        dsWHSInventEnabled = dsInventTable.addDataSource(tableNum(WHSInventEnabled));
        dsWHSInventEnabled.joinMode(JoinMode::ExistsJoin);
        dsWHSInventEnabled.relations(true);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        boolean ret;

        ret = super();

        releaseQuantitySpecification = fldReleaseQuantitySpecification.value();
        allowPartiallyReleased = fldAllowPartiallyReleased.value();
        keepReservations = fldKeepReservations.value();
        validOrderTypes = fldOrderType.value();

        this.setOrderTypeRange(queryRun.query().dataSourceTable(tableNum(SalesLine)));
        creditMaxCheck = fldCreditMaxCheck.value();

        if (fldGroupIntoMultipleReleases)
        {
            groupIntoMultipleReleases = fldGroupIntoMultipleReleases.value();
        }
        else
        {
            groupIntoMultipleReleases = false;
        }

        if (fldLockedOrderHandling)
        {
            lockedOrderHandling = fldLockedOrderHandling.value();
        }
        else
        {
            lockedOrderHandling = WHSLockedOrderHandling::WaitForLockedOrders;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSalesOrderPartiallyReleased</Name>
				<Source><![CDATA[
    private boolean isSalesOrderPartiallyReleased(SalesTable _salesOrder)
    {
        return _salesOrder.ReleaseStatus == WHSReleaseStatus::PartialReleased;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSalesOrderReleasedUsingNonWHSProcess</Name>
				<Source><![CDATA[
    private boolean isSalesOrderReleasedUsingNonWHSProcess(SalesTable _salesTable)
    {
        SalesLine           salesLine;
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;

        select firstonly RecId from salesLine
            where salesLine.SalesId == _salesTable.SalesId
            exists join inventTransOrigin
                where inventTransOrigin.InventTransId == salesLine.InventTransId
            exists join inventTrans
                where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                    && inventTrans.StatusReceipt == StatusReceipt::None
                    && (inventTrans.StatusIssue == StatusIssue::Picked
                        || inventTrans.StatusIssue == StatusIssue::Deducted
                        || inventTrans.StatusIssue == StatusIssue::Sold);

        return salesLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowPartiallyReleased</Name>
				<Source><![CDATA[
    public boolean parmAllowPartiallyReleased(boolean _allowPartiallyReleased = allowPartiallyReleased)
    {
        allowPartiallyReleased = _allowPartiallyReleased;

        return allowPartiallyReleased;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmKeepReservations</Name>
				<Source><![CDATA[
    public boolean parmKeepReservations(boolean _keepReservations = keepReservations)
    {
        keepReservations = _keepReservations;

        return keepReservations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReleaseQuantitySpecification</Name>
				<Source><![CDATA[
    public WHSReleaseQuantitySpecification parmReleaseQuantitySpecification(
        WHSReleaseQuantitySpecification _releaseQuantitySpecification = releaseQuantitySpecification)
    {
        releaseQuantitySpecification = _releaseQuantitySpecification;

        return releaseQuantitySpecification;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pendingPickingListExists</Name>
				<Source><![CDATA[
    private boolean pendingPickingListExists(SalesLine _salesLine)
    {
        WMSOrder wmsOrder;

        select firstonly RecId from wmsOrder
            where wmsOrder.InventTransId == _salesLine.InventTransId
                && (wmsOrder.Status == WMSOrderStatus::New || wmsOrder.Status == WMSOrderStatus::InExpedition);

        return wmsOrder.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProcessingResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the processing result class.
    /// </summary>
    /// <returns>A processing result instance.</returns>
    protected WHSWarehouseReleaseProcessingResult initializeProcessingResult()
    {
        return new WHSWarehouseReleaseProcessingResult();
    }

]]></Source>
			</Method>
			<Method>
				<Name>onlyAutoReserveSalesLineWhenReleasing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls if auto reservation only happens when the sales order line can be released to the warehouse.
    /// </summary>
    /// <param name="_salesLine">
    /// A sales order line record.
    /// </param>
    /// <returns>true if auto reservation only happens when the sales order line can be released; false, if reservation and releasing are separate steps.</returns>
    [Replaceable]
    protected boolean onlyAutoReserveSalesLineWhenReleasing(SalesLine _salesLine)
    {
        return this.onlyAutoReserveWhenReleasing();
    }

]]></Source>
			</Method>
			<Method>
				<Name>onlyAutoReserveWhenReleasing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls if auto reservation only happens when the sales order line can be released to the warehouse.
    /// </summary>
    /// <returns>true if auto reservation only happens when the sales order line can be released; false, if reservation and releasing are separate steps.</returns>
    [Replaceable]
    protected boolean onlyAutoReserveWhenReleasing()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSalesOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the sales order.
    /// </summary>
    /// <param name="_releaseEnumerator">
    /// The enumerator that can be used to enumerate over the selected lines of the sales order.
    /// </param>
    /// <param name="_releaseToWarehouse">
    /// The release lines.
    /// </param>
    /// <remarks>
    /// Iterates over the selected lines of the order, reserves and marks them for release if required/possible.
    /// </remarks>
    protected void processSalesOrder(WHSAutoRTWReleaseEnumerator _releaseEnumerator, WHSTmpReleaseToWarehouse _releaseToWarehouse)
    {
        #OCCRetryCount
        SalesTable salesTable = _releaseEnumerator.currentSalesTable();
        setPrefix(strFmt("@SYS76767", salesTable.SalesId));

        try
        {
            using (var activityContext = this.activities().processSalesOrder(salesTable.RecId))
            {
                ttsbegin;

                WHSWarehouseReleaseProcessingResult processingResult = this.initializeProcessingResult();

                WHSTmpReleaseToWarehouse releaseToWarehouse;
                releaseToWarehouse.linkPhysicalTableInstance(_releaseToWarehouse);

            
                NoYes usingShipmentConsolidation = this.mustUseShipmentConsolidation();
                NoYes usingGlobalRTWId = (usingShipmentConsolidation && !retrieveRTWId);

                if (!usingGlobalRTWId)
                {
                    retrieveRTWId.clearOrderReleaseToWarehouseId();
                }

                boolean preCheckResult = this.checkCanReleaseSalesOrderPreProcess(salesTable);

                if (preCheckResult)
                {
                    while (_releaseEnumerator.nextSalesLineInOrder())
                    {
                        SalesLine salesLine = _releaseEnumerator.currentSalesLine();
                        boolean onlyAutoReserveWhenReleasing = this.onlyAutoReserveSalesLineWhenReleasing(salesLine);
                        boolean mustReserveOnReleaseToWarehouse = this.mustReserveOnReleaseToWarehouse(salesLine);

                        if (!onlyAutoReserveWhenReleasing &&
                        mustReserveOnReleaseToWarehouse)
                        {
                            this.autoReserveItemToWarehouse(salesLine, processingResult);
                        }

                        if (this.checkCanReleaseSalesLine(salesLine, processingResult))
                        {
                            if (onlyAutoReserveWhenReleasing &&
                            mustReserveOnReleaseToWarehouse)
                            {
                                this.autoReserveItemToWarehouse(salesLine, processingResult);
                            }

                            using (var context = new WHSAutoReleaseToWarehouseProcessingResultContext())
                            {
                                context.processingResult = processingResult;
                            
                                if (releaseIdsWithRTWLinesSet)
                                {
                                    context.releaseIdsWithRTWLinesSet = releaseIdsWithRTWLinesSet;
                                }

                                if (usingGlobalRTWId)
                                {
                                    WHSTmpReleaseToWarehouse::createFromSalesLine(releaseToWarehouse, releaseToWarehouseIdGlobal, salesLine, releaseQuantitySpecification);
                                    WHSTmpReleaseToWarehouse releaseToWarehouseCreated;
                                    TMSInventEnabled tmsInventEnabled;

                                    releaseToWarehouseCreated.linkPhysicalTableInstance(_releaseToWarehouse);

                                    while select releaseToWarehouseCreated
                                    where  releaseToWarehouseCreated.ReleaseToWarehouseId == releaseToWarehouseIdGlobal
                                        && releaseToWarehouseCreated.InventTransId == salesLine.InventTransId
                                        && releaseToWarehouseCreated.ReleasedQty >  0
                                exists join tmsInventEnabled
                                    where tmsInventEnabled.ItemId == salesLine.ItemId
                                    {
                                        if (!WHSWarehouseReleaseValidator::canOrderQuantityBeReleased(salesLine.maxReleaseHandlingQuantity(), releaseToWarehouseCreated))
                                        {
                                            processingResult.addOrderLevelError(strFmt("@SCM:CannotReleaseMoreThanOrderLineQuantity_Error", salesLine.LineNum, salesLine.SalesId));

                                            errorsFound = true;

                                            break;
                                        }
                                    }
                                
                                }
                                else
                                {
                                    WHSReleaseToWarehouseId releaseToWarehouseId = retrieveRTWId.getReleaseToWarehouseId(salesLine);
                                    WHSTmpReleaseToWarehouse::createFromSalesLine(releaseToWarehouse, releaseToWarehouseId, salesLine, releaseQuantitySpecification);
                                }

                                if (processingResult.parmInventTransLocationOrBelowValidationFailed())
                                {
                                    errorsFound = true;
                                }
                            }
                        }
                        else
                        {
                            errorsFound = true;
                        }
                    }
                }
                else
                {
                    errorsFound = true;
                }

                if (preCheckResult && this.checkCanReleaseSalesOrder(salesTable, processingResult))
                {
                    ttscommit;
                }
                else if (keepReservations)
                {
                    this.displayReservationKeptMessage(processingResult);
                    // Remove all lines for this order so they aren't processed.
                    delete_from releaseToWarehouse
                    where releaseToWarehouse.OrderNum == salesTable.SalesId;
                    ttscommit;
                }
                else
                {
                    // Remove all lines for this order so they aren't processed.
                    delete_from releaseToWarehouse
                    where releaseToWarehouse.OrderNum == salesTable.SalesId;
                    ttsabort;
                }

                this.activities().parmIsProcessSalesOrderFailed(activityContext, errorsFound);
            }
        }
        catch (Exception::Error)
        {
            error(strFmt("@WAX2951", salesTable.SalesId));

            errorsFound = true;
        }
        catch (Exception::Deadlock)
        {
            //In case of retry we need to start iterating from the first line of the current order again.
            _releaseEnumerator.restartFromFirstSalesOrderLine();
            retry;
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError())
            {
                //In case of retry we need to start iterating from the first line of the current order again.
                _releaseEnumerator.restartFromFirstSalesOrderLine();
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::UpdateConflictNotRecovered;
            }

            //In case of retry we need to start iterating from the first line of the current order again.
            _releaseEnumerator.restartFromFirstSalesOrderLine();
            retry;
        }
        catch
        {
            exceptionTextFallThrough();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>upgradeVersion8Query</Name>
				<Source><![CDATA[
    private Query upgradeVersion8Query(container _packedQuery)
    {
        Query query = new Query(_packedQuery);
        QueryBuildDataSource dsWHSLoadLine = query.dataSourceTable(tableNum(WHSLoadLine));

        if (dsWHSLoadLine.joinMode() == JoinMode::NoExistsJoin
            && dsWHSLoadLine.parentDataSource().table() == tableNum(SalesLine))
        {
            dsWHSLoadLine.enabled(false);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultCheckCreditMax</Name>
				<Source><![CDATA[
    private void defaultCheckCreditMax()
    {
        creditMaxCheck = CustParameters::find().CreditMaxCheck;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useKitting</Name>
				<Source><![CDATA[
    private boolean useKitting()
    {
        return FeatureStateProvider::IsFeatureEnabled(KittingFeature::instance());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>errorMessageHelpScopeFormName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the form name used for the error context using a <c>SysErrorMessageHelpScope</c> class.
    /// </summary>
    /// <returns>The form name used for the error context.</returns>
    [Hookable(false)]
    public FormName errorMessageHelpScopeFormName()
    {
        return strFmt('%1_%2', formStr(Dialog), classStr(WhsAutoReleaseToWarehouse));
    }

]]></Source>
			</Method>
			<Method>
				<Name>errorMessageHelpScopeActionName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the action name used for the error context using a <c>SysErrorMessageHelpScope</c> class.
    /// </summary>
    /// <returns>The action name used for the error context.</returns>
    [Hookable(false)]
    public str errorMessageHelpScopeActionName()
    {
        return menuItemActionStr(WHSAutoReleaseToWarehouse);
    }

]]></Source>
			</Method>
			<Method>
				<Name>activities</Name>
				<Source><![CDATA[
    private WhsAutoReleaseToWarehouseInstrumentationActivities activities()
    {
        if (!logger)
        {
            logger = WHSInstrumentationLogger::createLogger(classStr(WhsAutoReleaseToWarehouse));
        }

        return logger.autoReleaseToWarehouse();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>