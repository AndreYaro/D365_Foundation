<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>JmgProfiles</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>JmgProfiles</c> class is used as part of the calculation process when calculating a set of
/// registrations against a profile setup.
/// </summary>
public class JmgProfiles
{
    JmgProfileId            getProfileProfile_Head[];
    JmgDayId                getProfileWeekDay_Head[];
    Integer                 getProfileStartPos_Head[];
    Integer                 getProfileEndPos_Head[];
    JmgRelDayNo             getProfileNStartDay_Head[];
    JmgSeconds              getProfileNStartTime_Head[];
    JmgRelDayNo             getProfileNEndDay_Head[];
    JmgSeconds              getProfileNEndTime_Head[];
    JmgSeconds              getProfileNSeconds_Head[];
    boolean                 getProfileHaveFlex_Head[];

    JmgProfileId            getProfileProfile_Line[];
    JmgDayId                getProfileWeekDay_Line[];
    JmgProfileSpecType      getProfileTimeType_Line[];
    JmgSeconds              getProfileStartTime_Line[];
    JmgRelDayNo             getProfileStartDay_Line[];
    JmgSeconds              getProfileEndTime_Line[];
    JmgRelDayNo             getProfileEndDay_Line[];
    JmgToleranceBeforeStart getProfileTolBeforeStart_Line[];
    JmgToleranceAfterStart  getProfileTolAfterStart_Line[];
    JmgToleranceBeforeEnd   getProfileTolBeforeEnd_Line[];
    JmgToleranceAfterEnd    getProfileTolAfterEnd_Line[];
    JmgSeconds              getProfileEventSec_Line[];
    Integer                 getProfileEventReal_Line[];
    JmgProfileSpecType      getProfileSecondaryType_Line[];
    JmgEventCode            getProfileEventCode_Line[];
    JmgProfileTypeRecId     getProfileProfileType_Line[];
    JmgProfileTypeRecId     getProfileSecondaryProfileType_Line[];

    Integer                 getProfileEventTab_Cnt;
    JmgTransId              getProfileEventTab_TransId;
    JmgProfileSpecType      getProfileEventTab_Type[];
    JmgProfileTypeRecId     getProfileEventTab_ProfileType[];
    JmgSeconds              getProfileEventTab_LowLim[];
    JmgSeconds              getProfileEventTab_UppLim[];
    JmgSeconds              getProfileEventTab_Sec[];
    JmgStampTypeSpec        getProfileEventTab_StampSpec[];
    JmgTransId              getProfileEventTab_Trid[];
    JmgJobPayTypeEnum       getProfileEventTab_JobPayType[];
    JmgProfileSpecType      getProfileEventTab_SecondaryType[];

    DimensionDefault        getProfileEventTab_DefaultDimension[];

    date                    timeEventDate;
    Integer                 timeEventLowLimit_P;
    Integer                 timeEventUppLimit_P;
    Integer                 timeEventLowLimit_S;
    Integer                 timeEventUppLimit_S;
    Integer                 timeEventLowLimit_B;
    Integer                 timeEventUppLimit_B;
    Integer                 timeEventLowLimit_Save;
    JmgSeconds              timeEventSec;
    JmgProfileSpecType      timeEventSpec;
    JmgSeconds              timeEventNetTime;
    JmgSeconds              timeEventBrkTime;
    JmgSeconds              timeEventBrkTimePay;

    Integer                 getProfileFrom;
    Integer                 getProfileTo;

    Integer                 getProfileCurProfile;

    Integer                 timeGapCnt;
    Integer                 timeGapMax;
    Integer                 timeGapLL;
    Integer                 timeGapUL;
    JmgSeconds              timeGapStartTime;
    JmgSeconds              timeGapEndTime;

    Integer                 timeGapLowLim[];
    Integer                 timeGapUppLim[];
    recId                   timeGapRecId[];
    JmgJobIDAbs             timeGapJobIdAbs[];
    boolean                 timeGapClockedInOut[];

    Integer                 timeGapFrom;
    Integer                 timeGapTo;
    date                    timeGapDate;
    JmgSeconds              timeGapSeconds;
    JmgSeconds              timeGapSecondsFlex;
    JmgSeconds              timeGapFlex_LowLim;
    JmgSeconds              timeGapFlex_UppLim;

    Integer                 getProfileCnt;
    Integer                 getProfileMax;
    boolean                 getProfileNStartOk;
    boolean                 getProfileNEndOk;

    JmgTransId              chkTransId;
    JmgSeconds              chkTime;
    JmgJobType              chkType;
    boolean                 chkSignedInOk;
    boolean                 chkAbsenceErr;
    boolean                 chkTransIdErr;
    boolean                 chkChronologyErr;
    boolean                 chkAbsenceOrFlexConfigErr;

    boolean                 approveMode;

    boolean                 simulationMode;
    JmgSeconds              simulationEndTime;
    StartDate               simulationEndDate;

    Integer                 bundlePointer;
    JmgTransId              bundle[];
    JmgStampTypeSpecEnum    bundleTypeSpec[];
    JmgJobType              bundleType[];
    DimensionDefault        bundle_DefaultDimension[];
    JmgSeconds              bundleStart[];
    JmgSeconds              bundleEnd[];
    JmgSeconds              bundleStartEndTime[];
    JmgSeconds              bundleStartDateTimeCorr[];
    JmgSeconds              bundleEndDateTimeCorr[];
    JmgSeconds              bundleTotJobsTime[];
    JmgSeconds              bundleTotJobsTimeEst[];

    JmgJobPayType           bundleJobPayType[];
    container               bundleAllocationkeyCount[];

    Integer                 bundleQty[];

    JmgBreaks               jmgBreaks;

    int                     chkTimeChron;
    int                     chkClockInOutStatus;
    boolean                 chkClockInOutErr;

    Set                     eventCodeSet;

    JmgJobIDAbs             tmpJobidAbs;
    JmgJobIDAbs             tmpJobidAbsNorm;
    JmgSeconds              tmpSaveStopDateTime;
    recId                   tmpLastRecId;
    JmgModule               tmpSaveModule;
    JmgTransId              tmpSaveTransId;
    JmgSeconds              tmpStart;
    StartDate               tmpStartDate;
    JmgSeconds              tmpEnd;
    StartDate               tmpEndDate;
    JmgTransId              newTransId;

    boolean                 clockInOutStatus;
    boolean                 payBonusCalcOk;

    JmgSeconds              calcSumOvtRounded;
    JmgSeconds              calcSumOvtRoundedDiff;
    JmgSeconds              calcSumOvtFlexCorrect;

    JmgSeconds              calcSumWorkTime;
    JmgSeconds              calcSumPayTime;
    JmgSeconds              calcSumPayOverTime;
    JmgSeconds              calcSumAbsLegal;
    JmgSeconds              calcSumAbsIllegal;
    JmgSeconds              calcSumFlexAdd;
    JmgSeconds              calcSumFlexSub;
    JmgSeconds              calcSumNonPaidBreaks;
    JmgSeconds              calcSumPaidBreaks;

    boolean                 isSignIn;
    Integer                 signInCount;
    Integer                 signOutCount;
    JmgTime                 fromDatetimeSignin;
    StartDate               correctSignInDate[];
    JmgSeconds              correctSignInTime[];
    EndDate                 correctSignOutDate[];
    JmgSeconds              correctSignOutTime[];
    Integer                 signInBundlePointer[];
    Integer                 signOutBundlePointer[];

    private boolean jmgBreakRegistrationsFlightEnabled;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>bundleAddStack</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a registration to the internal bundles.
    /// </summary>
    /// <param name="jmgStampJournalTrans">
    ///    The registration to add to the internal bundles.
    /// </param>
    /// <param name="transEndDate">
    ///    The end date to use as the registration stop date when a simulated calculation is run; optional.
    /// </param>
    /// <param name="transEndTime">
    ///    The end time to use as the registration stop time when a simulated calculation is run; optional.
    /// </param>
    void bundleAddStack(JmgStampJournalTrans jmgStampJournalTrans, StartDate transEndDate = dateNull(), JmgSeconds transEndTime = 0)
    {
        JmgProfileSeconds   profSec = new JmgProfileSeconds();
        boolean             isBreakParallel;

        if (prmisdefault(transEndDate))
        {
            transEndDate    = jmgStampJournalTrans.StopDate;
            transEndTime    = jmgStampJournalTrans.StopTime;
        }

        bundlePointer = 1;
        while (bundle[bundlePointer])
        {
            if (bundle[bundlePointer] == jmgStampJournalTrans.TransId)
            {
                isBreakParallel = jmgBreakRegistrationsFlightEnabled && jmgStampJournalTrans.JourRegType == JmgJourRegTypeEnum::BreakReg;
                break;
            }
            bundlePointer++;
        }

        bundle[bundlePointer]         = jmgStampJournalTrans.TransId;
        bundleTypeSpec[bundlePointer] = isBreakParallel ? bundleTypeSpec[bundlePointer] : jmgStampJournalTrans.StampTypeSpec;        

        if (jmgStampJournalTrans.JourRegType == JmgJourRegTypeEnum::SignIn)
        {
            signInBundlePointer[signInCount] = bundlePointer;
        }

        if (jmgStampJournalTrans.JourRegType == JmgJourRegTypeEnum::SignOut)
        {
            signOutBundlePointer[signOutCount] = bundlePointer;
        }

        this.setAllocationKey(jmgStampJournalTrans);

        bundle_DefaultDimension[bundlePointer]      = jmgStampJournalTrans.DefaultDimension;
        if ((bundleStart[bundlePointer] == 0) || (profSec.profileSeconds(jmgStampJournalTrans.StartDate,jmgStampJournalTrans.StartTime) < bundleStart[bundlePointer]))
            bundleStart[bundlePointer]              = profSec.profileSeconds(jmgStampJournalTrans.StartDate,jmgStampJournalTrans.StartTime);

        if (profSec.profileSeconds(transEndDate,transEndTime) > bundleEnd[bundlePointer])
            bundleEnd[bundlePointer]                = profSec.profileSeconds();

        bundleStartEndTime      [bundlePointer]     = 0;
        bundleStartDateTimeCorr [bundlePointer]     = 0;
        bundleEndDateTimeCorr   [bundlePointer]     = 0;

        if (!jmgBreakRegistrationsFlightEnabled || jmgStampJournalTrans.JourRegType != JmgJourRegTypeEnum::BreakReg)
        {
            bundleQty[bundlePointer]++;
        }

        real tmpReal1 = jmgStampJournalTrans.Module == JmgModuleEnum::PROD ? jmgStampJournalTrans.calcEstimJobTime() : 0;

        this.countProfileTimeEvent(jmgStampJournalTrans.ProfileDate,
                                       jmgStampJournalTrans.StartDate,
                                       transEndDate,
                                       jmgStampJournalTrans.StartTime,
                                       transEndTime,
                                       JmgStampTypeSpecEnum::Work,
                                       JmgProfiles::noTransID(),JmgJobPayTypeEnum::Hours,false);

        bundleTotJobsTime       [bundlePointer]    += timeEventNetTime;
        bundleTotJobsTimeEst    [bundlePointer]    += real2int(tmpReal1);
        bundleJobPayType        [bundlePointer]     = jmgStampJournalTrans.JobPayType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustRunInSimulationMode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to use simulated calculation during registration update.
    /// </summary>
    /// <param name = "_transEndDate">
    /// Transaction end date value.
    /// </param>
    /// <returns>
    /// true if simulation run; otherwise, false.
    /// </returns>
    protected boolean mustRunInSimulationMode(StartDate _transEndDate)
    {
        return _transEndDate != dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildUpdateRegistrationsQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>Query</c> object for selecting <c>JmgStampJournalTrans</c> records.
    /// </summary>
    /// <param name = "_jmgStampJournalTable">
    /// A <c>JmgStampJournalTable</c> record buffer.
    /// </param>
    /// <returns>
    /// An <c>Query</c> object.
    /// </returns>
    protected Query buildUpdateRegistrationsQuery(JmgStampJournalTable _jmgStampJournalTable)
    {
        Query query = new Query();
        QueryBuildDataSource queryBuildDataSourceStampJournalTrans = query.addDataSource(tableNum(JmgStampJournalTrans));

        queryBuildDataSourceStampJournalTrans.update(true);
        queryBuildDataSourceStampJournalTrans.addOrderByField(fieldNum(JmgStampJournalTrans, ProfileDate));
        queryBuildDataSourceStampJournalTrans.addOrderByField(fieldNum(JmgStampJournalTrans, StartDate));
        queryBuildDataSourceStampJournalTrans.addOrderByField(fieldNum(JmgStampJournalTrans, StartTime));
        queryBuildDataSourceStampJournalTrans.addOrderByField(fieldNum(JmgStampJournalTrans, StopDate));
        queryBuildDataSourceStampJournalTrans.addOrderByField(fieldNum(JmgStampJournalTrans, StopTime));
        queryBuildDataSourceStampJournalTrans.addOrderByField(fieldNum(JmgStampJournalTrans, JourRegType));

        queryBuildDataSourceStampJournalTrans.addRange(fieldNum(JmgStampJournalTrans, Worker)).value(queryValue(_jmgStampJournalTable.Worker));
        queryBuildDataSourceStampJournalTrans.addRange(fieldNum(JmgStampJournalTrans, ProfileDate)).value(queryValue(_jmgStampJournalTable.ProfileDate));
        
        if (!jmgBreakRegistrationsFlightEnabled)
        {
            queryBuildDataSourceStampJournalTrans.addRange(fieldNum(JmgStampJournalTrans, JourRegType)).value(SysQuery::valueNot(JmgJourRegTypeEnum::BreakReg));
        }
        
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeSeconds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the seconds on the <c>JmgStampJournalTrans</c> record buffer.
    /// </summary>
    /// <param name = "_jmgStampJournalTable">
    /// A <c>JmgStampJournalTable</c> record buffer.
    /// </param>
    /// <param name = "_jmgStampJournalTrans">
    /// A <c>JmgStampJournalTrans</c> record buffer.
    /// </param>
    /// <param name = "_profSec">
    /// A <c>JmgProfileSeconds</c> object.
    /// </param>
    protected void initializeSeconds(JmgStampJournalTable _jmgStampJournalTable, JmgStampJournalTrans _jmgStampJournalTrans, JmgProfileSeconds _profSec)
    {
        _jmgStampJournalTrans.SecondsOnReg   = timeEventNetTime;
        _jmgStampJournalTrans.SecondsOnTrans = bundleStartEndTime[bundlePointer];
        _jmgStampJournalTrans.Seconds        = 0;
        
        if (bundleQty[bundlePointer] > 1)
        {
            _jmgStampJournalTrans.JobType    = bundleType[bundlePointer];

            switch (bundleType[bundlePointer])
            {
                case JmgJobTypeEnum::Normal :
                    break;
                case JmgJobTypeEnum::Bundle1 :
                    if (bundleTotJobsTimeEst[bundlePointer] > 0)
                    {
                        _jmgStampJournalTrans.Seconds = real2int(bundleStartEndTime[bundlePointer] * (_jmgStampJournalTrans.calcEstimJobTime() / bundleTotJobsTimeEst[bundlePointer]));
                    }
                    else
                    {
                        // If there was no estimated time on any of the jobs in the bundle, we need to fall back to net time.
                        this.bundleSlizeTime_NetTime(_jmgStampJournalTable, _jmgStampJournalTrans);
                    }
                    break;
                case JmgJobTypeEnum::Bundle2 :
                    _jmgStampJournalTrans.Seconds = real2int(bundleStartEndTime[bundlePointer] * (1 / bundleQty[bundlePointer]));
                    break;
                case JmgJobTypeEnum::Bundle3 :
                    this.bundleSlizeTime_NetTime(_jmgStampJournalTable, _jmgStampJournalTrans);
                    break;
                case JmgJobTypeEnum::Bundle4 :
                    _jmgStampJournalTrans.Seconds    = timeEventNetTime;
                    break;
            }
        }
        else
        {
            _jmgStampJournalTrans.JobType    = JmgJobTypeEnum::Normal;
            _jmgStampJournalTrans.Seconds    = bundleStartEndTime[bundlePointer];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bundleSlizeTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates registrations with the time calculated in the internal bundles.
    /// </summary>
    /// <param name="jmgStampJournalTable">
    ///    The <c>JmgStampJournalTable</c> record, which is the header for the calculation.
    /// </param>
    /// <param name="transEndDate">
    ///    The end date to use the stop date on active registrations, when a simulated calculation is run;
    ///    optional.
    /// </param>
    /// <param name="transEndTime">
    ///    The end time to use as the stop time on active registrations, when a simulated calculation is run;
    ///    optional.
    /// </param>
    void bundleSlizeTime(JmgStampJournalTable jmgStampJournalTable, StartDate transEndDate = dateNull(), JmgSeconds transEndTime = 0)
    {
        StartDate               bundletransEndDate;
        JmgSeconds              bundletransEndTime;
        boolean                 simulationRun       = this.mustRunInSimulationMode(transEndDate);
        JmgTransId              tmpTransID;
        JmgStampJournalTrans    jmgStampJournalTrans;
        JmgSeconds              tmpProfileSeconds;
        JmgSeconds              tmpProfileSecondsDiff;
        int                     signInOutIndex;

        JmgProfileSeconds       profSec             = new JmgProfileSeconds();
        bundlePointer                               = 1;

        ttsbegin;

        while (bundle[bundlePointer])
        {
            bundleStartDateTimeCorr[bundlePointer]  = bundleStart[bundlePointer];
            bundleEndDateTimeCorr[bundlePointer]    = bundleEnd[bundlePointer];

            bundlePointer++;
        }
        if (!jmgStampJournalTable.DropClockInCorrection)
        {
            for (signInOutIndex = 1; signInOutIndex <= signInCount; signInOutIndex++)
            {
                tmpProfileSeconds = profSec.profileSeconds(correctSignInDate[signInOutIndex], correctSignInTime[signInOutIndex]);
                tmpProfileSecondsDiff = bundleStart[signInBundlePointer[signInOutIndex]] - tmpProfileSeconds;

                if (tmpProfileSecondsDiff != 0)
                {
                    this.shiftSignInOutBundle(signInBundlePointer[signInOutIndex], bundleStart[signInBundlePointer[signInOutIndex]], tmpProfileSeconds, tmpProfileSecondsDiff < 0);
                }
            }
        }

        if (!jmgStampJournalTable.DropClockOutCorrection)
        {
            for (signInOutIndex = 1; signInOutIndex <= signOutCount; signInOutIndex++)
            {
                tmpProfileSeconds = profSec.profileSeconds(correctSignOutDate[signInOutIndex], correctSignOutTime[signInOutIndex]);
                tmpProfileSecondsDiff = bundleStart[signOutBundlePointer[signInOutIndex]] - tmpProfileSeconds;

                if (tmpProfileSeconds != 0)
                {
                    this.shiftSignInOutBundle(signOutBundlePointer[signInOutIndex], bundleStart[signOutBundlePointer[signInOutIndex]], tmpProfileSeconds, tmpProfileSecondsDiff < 0);
                }
            }
        }

        bundlePointer = 1;
        while (bundle[bundlePointer])
        {
            [tmpStartDate,tmpStart]                 = profSec.dateSeconds(bundleStartDateTimeCorr[bundlePointer]);
            [tmpEndDate,tmpEnd]                     = profSec.dateSeconds(bundleEndDateTimeCorr[bundlePointer]);

            this.countProfileTimeEvent(jmgStampJournalTable.ProfileDate,tmpStartDate,tmpEndDate,tmpStart,tmpEnd,
                bundleTypeSpec[bundlePointer],JmgProfiles::noTransID(),JmgJobPayTypeEnum::Hours,false);

            bundleStartEndTime[bundlePointer]       = timeEventNetTime;

            bundlePointer++;
        }

        QueryRun queryRun = new QueryRun(this.buildUpdateRegistrationsQuery(jmgStampJournalTable));
        while (queryRun.next())
        {
            jmgStampJournalTrans = queryRun.get(tableNum(JmgStampJournalTrans));

            bundletransEndDate  = jmgStampJournalTrans.StopDate;
            bundletransEndTime  = jmgStampJournalTrans.StopTime;
            if ((! prmisdefault(transEndDate))    &&
                (jmgStampJournalTrans.Active == NoYes::Yes))
            {
                bundletransEndDate  = transEndDate;
                bundletransEndTime  = transEndTime;
            }

            bundlePointer = 1;
            while (bundle[bundlePointer])
            {
                if (bundle[bundlePointer] == jmgStampJournalTrans.TransId)
                {
                    break;
                }
                bundlePointer++;
            }

            this.countProfileTimeEvent(jmgStampJournalTrans.ProfileDate,jmgStampJournalTrans.StartDate,bundletransEndDate,jmgStampJournalTrans.StartTime,bundletransEndTime,
                jmgStampJournalTrans.StampTypeSpec,JmgProfiles::noTransID(),JmgJobPayTypeEnum::Hours,false);


            [jmgStampJournalTrans.CorrStartDate, jmgStampJournalTrans.CorrStartTime] = profSec.dateSeconds(bundleStartDateTimeCorr[bundlePointer]);
            [jmgStampJournalTrans.CorrStopDate, jmgStampJournalTrans.CorrStopTime]   = profSec.dateSeconds(bundleEndDateTimeCorr[bundlePointer]);
        
            if (!jmgBreakRegistrationsFlightEnabled || (jmgStampJournalTrans.JourRegType != JmgJourRegTypeEnum::BreakReg))
            {
                this.initializeSeconds(jmgStampJournalTable, jmgStampJournalTrans, profSec);
            }

            jmgStampJournalTrans.update();
            JmgCalcApproveForm::construct().transactionUpdated(jmgStampJournalTrans);

            if (jmgStampJournalTrans.TransId != tmpTransID)
            {
                this.countProfileTimeEvent(jmgStampJournalTrans.ProfileDate,jmgStampJournalTrans.CorrStartDate,jmgStampJournalTrans.CorrStopDate,
                jmgStampJournalTrans.CorrStartTime,jmgStampJournalTrans.CorrStopTime,
                jmgStampJournalTrans.StampTypeSpec,jmgStampJournalTrans.TransId,jmgStampJournalTrans.JobPayType,true,jmgStampJournalTrans.DefaultDimension);
            }
            tmpTransID = jmgStampJournalTrans.TransId;

            if (! simulationRun)
            {
                if ((jmgStampJournalTrans.JourRegType == JmgJourRegTypeEnum::SignIn) ||
                    (jmgStampJournalTrans.JourRegType == JmgJourRegTypeEnum::SignOut))
                {
                    if (jmgStampJournalTrans.JourRegType == JmgJourRegTypeEnum::SignIn)
                    {
                        if (! jmgStampJournalTable.WorkStartDate)
                        {
                            jmgStampJournalTable.WorkStart      = jmgStampJournalTrans.StartTime;
                            jmgStampJournalTable.WorkStartDate  = jmgStampJournalTrans.StartDate;
                        }
                        if (! jmgStampJournalTable.PayStartDate)
                        {
                            jmgStampJournalTable.PayStart       = jmgStampJournalTrans.CorrStartTime;
                            jmgStampJournalTable.PayStartDate   = jmgStampJournalTrans.CorrStartDate;
                        }
                    }
                    else
                    {
                        jmgStampJournalTable.WorkEnd            = jmgStampJournalTrans.StopTime;
                        jmgStampJournalTable.WorkEndDate        = jmgStampJournalTrans.StopDate;
                        jmgStampJournalTable.PayEnd             = jmgStampJournalTrans.CorrStopTime;
                        jmgStampJournalTable.PayEndDate         = jmgStampJournalTrans.CorrStopDate;
                    }
                }
                else
                {
                    if ((jmgStampJournalTrans.JourRegType != JmgJourRegTypeEnum::Absence)    &&
                        (jmgStampJournalTrans.JourRegType != JmgJourRegTypeEnum::BreakReg)   &&
                        (jmgStampJournalTrans.JourRegType != JmgJourRegTypeEnum::Empty)      &&
                        (jmgStampJournalTrans.JourRegType != JmgJourRegTypeEnum::StartTeam)  &&
                        (jmgStampJournalTrans.JourRegType != JmgJourRegTypeEnum::StopTeam))
                    {
                        jmgStampJournalTable.WorkSecondsNotAllocated += jmgStampJournalTrans.SecondsOnReg;
                    }
                }
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bundleSlizeTime_NetTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates registrations with the time calculated in internal bundles by using the net time allocation
    ///    key.
    /// </summary>
    /// <param name="jmgStampJournalTable">
    ///    The <c>JmgStampJournalTable</c> record, which is the header for the calculation.
    /// </param>
    /// <param name="jmgStampJournalTrans">
    ///    The registration on which to update the calculated time.
    /// </param>
    void bundleSlizeTime_NetTime(JmgStampJournalTable jmgStampJournalTable,JmgStampJournalTrans jmgStampJournalTrans)
    {
        JmgStampJournalTrans    jmgStampJournalTransScan;
        container               scanStartCon;
        container               scanStopCon;
        int                     scanStart;
        int                     scanStop;
        container               periods;
        container               periodQty;
        int                     i;
        container               newPeriods;
        container               newPeriodQty;
        JmgProfileSeconds       profSec             = new JmgProfileSeconds();

        periods   = [profSec.profileSeconds(jmgStampJournalTrans.StartDate,jmgStampJournalTrans.StartTime), profSec.profileSeconds(jmgStampJournalTrans.StopDate,jmgStampJournalTrans.StopTime)];
        periodQty = [1];

        while select StartDate, StartTime, StopDate, StopTime
            from  jmgStampJournalTransScan
            where jmgStampJournalTransScan.Worker        == jmgStampJournalTable.Worker      &&
                  jmgStampJournalTransScan.TransId       == bundle[bundlePointer]            &&
                  jmgStampJournalTransScan.ProfileDate   == jmgStampJournalTable.ProfileDate &&
                  jmgStampJournalTransScan.Module        == JmgModuleEnum::PROD              &&
                  jmgStampJournalTransScan.RecId         != jmgStampJournalTrans.RecId
        {
            scanStart = profSec.profileSeconds(jmgStampJournalTransScan.StartDate,jmgStampJournalTransScan.StartTime);
            scanStop  = profSec.profileSeconds(jmgStampJournalTransScan.StopDate,jmgStampJournalTransScan.StopTime);

            if (scanStart <  conpeek(periods,conlen(periods)) &&
                scanStop  >  conpeek(periods,1))
            {
                i = 1;
                while (i <= conlen(periodQty))
                {
                    if (scanStart > conpeek(periods,i+1) ||
                        scanStop  < conpeek(periods,i))
                    {
                        newPeriods   += [conpeek(periods,i)];
                        newPeriodQty += [(conpeek(periodQty,i))];
                    }
                    else if (scanStart <= conpeek(periods,i) &&
                        scanStop  >= conpeek(periods,i+1))
                    {
                        newPeriods   += [conpeek(periods,i)];
                        newPeriodQty += [(conpeek(periodQty,i)+1)];
                    }
                    else if (scanStart > conpeek(periods,i) &&
                             scanStop  >= conpeek(periods,i+1))
                    {
                        newPeriods   += [conpeek(periods,i)];
                        newPeriodQty += [conpeek(periodQty,i)];
                        newPeriods   += [scanStart];
                        newPeriodQty += [(conpeek(periodQty,i)+1)];
                    }
                    else if (scanStart <= conpeek(periods,i) &&
                             scanStop  < conpeek(periods,i+1))
                    {
                        newPeriods   += [conpeek(periods,i)];
                        newPeriodQty += [(conpeek(periodQty,i)+1)];
                        newPeriods   += [scanStop];
                        newPeriodQty += [conpeek(periodQty,i)];
                    }
                    else if (scanStart > conpeek(periods,i) &&
                             scanStop  < conpeek(periods,i+1))
                    {
                        newPeriods   += [conpeek(periods,i)];
                        newPeriodQty += [conpeek(periodQty,i)];
                        newPeriods   += [scanStart];
                        newPeriodQty += [(conpeek(periodQty,i)+1)];
                        newPeriods   += [scanStop];
                        newPeriodQty += [conpeek(periodQty,i)];
                    }
                    i++;
                }
                newPeriods  += [conpeek(periods,i)];
                periods      = newPeriods;
                periodQty    = newPeriodQty;
                newPeriods   = connull();
                newPeriodQty = connull();
            }
        }

        jmgStampJournalTrans.Seconds = 0;
        i = 1;
        while (i <= conlen(periodQty))
        {
            scanStartCon = profSec.dateSeconds(conpeek(periods,i));
            scanStopCon  = profSec.dateSeconds(conpeek(periods,i+1));

            this.countProfileTimeEvent(jmgStampJournalTrans.ProfileDate,conpeek(scanStartCon,1),conpeek(scanStopCon,1),conpeek(scanStartCon,2),conpeek(scanStopCon,2),JmgStampTypeSpecEnum::Work,JmgProfiles::noTransID(),JmgJobPayTypeEnum::Hours,false);

            if (conpeek(periodQty,i))
            {
                jmgStampJournalTrans.Seconds += real2int(timeEventNetTime / conpeek(periodQty,i));
            }
            i++;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDelimitations</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks delimitations on the pay agreement line.
    /// </summary>
    /// <param name="_jmgTransferEvents">
    ///    The <c>JmgTransferEvents</c> object, which is calculating pay.
    /// </param>
    /// <param name="_jmgPayAgreementLineMap">
    ///    The <c>JmgPayAgreementLineMap</c> record, which contains pay delimitations.
    /// </param>
    /// <param name="_jmgStampJournalTable">
    ///    The <c>JmgStampJournalTable</c> record for which pay is currently being calculated.
    /// </param>
    /// <returns>
    ///    true if the delimitations set on the <c>JmgPayAgreementLineMap</c> is fulfilled by the worker
    ///    specified at the <c>JmgStampJournalTable</c> record.
    /// </returns>
    protected boolean checkDelimitations(JmgTransferEvents _jmgTransferEvents, JmgPayAgreementLineMap _jmgPayAgreementLineMap, JmgStampJournalTable _jmgStampJournalTable)
    {
        JmgPayLineDelimitation  jmgPayLineDelimitation;
        boolean                 ret;
        JmgPayRule              jmgPayRule;
        JmgStampJournalTrans    jmgStampJournalTrans;
        ExpressionTable         expressionTable;

        ret = this.checkWorkerSkillAndCertificate(
            _jmgStampJournalTable.Worker,
            _jmgPayAgreementLineMap.SkillId,
            HcmRatingLevel::find(_jmgPayAgreementLineMap.RatingLevel).RatingLevelId,
            _jmgPayAgreementLineMap.CertificateId,
            _jmgStampJournalTable.ProfileDate);

        if (ret)
        {
            ret =  (_jmgPayAgreementLineMap.RouteOprId          == _jmgTransferEvents.curTrOpr()                 || !_jmgPayAgreementLineMap.RouteOprId)
                && (_jmgPayAgreementLineMap.ProjId              == _jmgTransferEvents.curProjId()                  || ! _jmgPayAgreementLineMap.ProjId)
                && (_jmgPayAgreementLineMap.ActivityNumber      == _jmgTransferEvents.curProjActivityId()           || ! _jmgPayAgreementLineMap.ActivityNumber)
                && (_jmgPayAgreementLineMap.AbsenceActivityId   == _jmgTransferEvents.curAbsAct()                   || ! _jmgPayAgreementLineMap.AbsenceActivityId)
                && (_jmgPayAgreementLineMap.hrmAbsenceCodeId    == _jmgTransferEvents.currentAbsenceCode()          || ! _jmgPayAgreementLineMap.hrmAbsenceCodeId)
                && (_jmgPayAgreementLineMap.OnCallActivity      == _jmgTransferEvents.curOnCallActivity()           || ! _jmgPayAgreementLineMap.OnCallActivity)
                && (_jmgPayAgreementLineMap.SpecialDayId        == _jmgTransferEvents.curSpecialDayId()             || ! _jmgPayAgreementLineMap.SpecialDayId);
        }

        if (ret)
        {
            jmgStampJournalTrans.Worker         = _jmgStampJournalTable.Worker;
            jmgStampJournalTrans.ProfileDate    = _jmgStampJournalTable.ProfileDate;
            jmgStampJournalTrans.JobRef         = _jmgTransferEvents.curJobRef();
            jmgStampJournalTrans.ActOprID       =
                _jmgTransferEvents.curAbsAct()          ? _jmgTransferEvents.curAbsAct()            :
                _jmgTransferEvents.curOnCallActivity()  ? _jmgTransferEvents.curOnCallActivity()    :
                _jmgTransferEvents.curProjActivityId()  ? _jmgTransferEvents.curProjActivityId()    :
                _jmgTransferEvents.currentAbsenceCode() ? _jmgTransferEvents.currentAbsenceCode()   :
                _jmgTransferEvents.curTrOpr()           ? _jmgTransferEvents.curTrOpr()             :
                '';
            while select PayRuleClassId
                from  jmgPayLineDelimitation
                where jmgPayLineDelimitation.PayAgreementLineRecId == _jmgPayAgreementLineMap.RecId
                join  expressionTable
                where expressionTable.ExpressionId  == jmgPayLineDelimitation.ExpressionId
            {
                jmgPayRule = new SysDictClass(className2Id(jmgPayLineDelimitation.PayRuleClassId)).makeObject();
                ret = ret && jmgPayRule.evaluate(expressionTable, jmgStampJournalTrans);
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEventCodesIsSet</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the worker has created a registration on the specified switch code.
    /// </summary>
    /// <param name="eventCode">
    ///    The ID of the switch code to check.
    /// </param>
    /// <returns>
    ///    true if the worker has created a registration on the switch code; otherwise, false.
    /// </returns>
    boolean checkEventCodesIsSet(JmgEventCode eventCode)
    {
        return eventCodeSet.in(eventCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPayDeduction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether pay must be deducted.
    /// </summary>
    /// <param name="jmgStampJournalTable">
    ///    The <c>JmgStampJournalTable</c> record, which is the header for the calculation.
    /// </param>
    /// <remarks>
    ///    The internal event table is updated, if any pay must be deducted.
    /// </remarks>
    void checkPayDeduction(JmgStampJournalTable jmgStampJournalTable)
    {
        Integer                 getProfileFromIdx;
        JmgProfileSeconds       profileSec = new JmgProfileSeconds();
        JmgSeconds              payDrawMin;
        JmgSeconds              payDrawLimit;
        JmgStampJournalTrans    clockStamp;

        if (!(jmgStampJournalTable.ProfileStart && jmgStampJournalTable.ProfileStartDate && (jmgStampJournalTable.FlexProfile==NoYes::No)))
        {
            return;
        }

        select firstonly clockStamp
            order by StartDate,StartTime
            where clockStamp.Worker         == jmgStampJournalTable.Worker &&
                  clockStamp.ProfileDate    == jmgStampJournalTable.ProfileDate &&
                  clockStamp.JourRegType    == JmgJourRegTypeEnum::SignIn;

        if (! clockStamp)
        {
            return;
        }

        if (profileSec.profileSeconds(clockStamp.CorrStartDate,clockStamp.CorrStartTime) <=
            profileSec.profileSeconds(jmgStampJournalTable.ProfileStartDate,jmgStampJournalTable.ProfileStart) )
        {
            return;
        }

        if (JmgPayAgreementOverride::find(jmgStampJournalTable.Worker,jmgStampJournalTable.ProfileDate).RecId)
        {
            payDrawMin = JmgPayAgreementOverride::find(jmgStampJournalTable.Worker,jmgStampJournalTable.ProfileDate).PayDeductToLateSeconds;
        }
        else
        {
            payDrawMin =  JmgPayAgreementTable::find(jmgStampJournalTable.PayAgreement).PayDeductToLateSeconds;
        }
        if (! payDrawMin)
        {
            return;
        }

        payDrawLimit = profileSec.profileSeconds(jmgStampJournalTable.ProfileStartDate,jmgStampJournalTable.ProfileStart) + payDrawMin;

        for (getProfileFromIdx = 1; getProfileFromIdx <= getProfileEventTab_Cnt; getProfileFromIdx++)
        {
            if (getProfileEventTab_UppLim[getProfileFromIdx] < payDrawLimit)
            {
                if ((getProfileEventTab_StampSpec[getProfileFromIdx] != JmgStampTypeSpecEnum::AbsIllegal)     &&
                    (getProfileEventTab_StampSpec[getProfileFromIdx] != JmgStampTypeSpecEnum::AbsIllegalFlex) &&
                    (getProfileEventTab_StampSpec[getProfileFromIdx] != JmgStampTypeSpecEnum::AbsLegal)       &&
                    (getProfileEventTab_StampSpec[getProfileFromIdx] != JmgStampTypeSpecEnum::AbsLegalFlex)   )
                {
                    getProfileEventTab_LowLim[getProfileFromIdx] = getProfileEventTab_UppLim[getProfileFromIdx];
                    getProfileEventTab_Sec[getProfileFromIdx] = 0;
                }
            }
            else if (getProfileEventTab_LowLim[getProfileFromIdx] < payDrawLimit)
            {
                if ((getProfileEventTab_StampSpec[getProfileFromIdx] != JmgStampTypeSpecEnum::AbsIllegal)     &&
                    (getProfileEventTab_StampSpec[getProfileFromIdx] != JmgStampTypeSpecEnum::AbsIllegalFlex) &&
                    (getProfileEventTab_StampSpec[getProfileFromIdx] != JmgStampTypeSpecEnum::AbsLegal)       &&
                    (getProfileEventTab_StampSpec[getProfileFromIdx] != JmgStampTypeSpecEnum::AbsLegalFlex)   )
                {
                    getProfileEventTab_Sec[getProfileFromIdx]    -= (payDrawLimit - getProfileEventTab_LowLim[getProfileFromIdx]);
                    getProfileEventTab_LowLim[getProfileFromIdx] =  payDrawLimit;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWorkerSkillAndCertificate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the worker has the specified skill and certificate.
    /// </summary>
    /// <param name="_workerId">
    ///    The ID of the worker to check.
    /// </param>
    /// <param name="_skillId">
    ///    The ID of the skill the worker must have.
    /// </param>
    /// <param name="_requiredLevelId">
    ///    The required level that the worker must have the skill.
    /// </param>
    /// <param name="_certificateId">
    ///    The ID of the certificate the worker must have.
    /// </param>
    /// <param name="_date">
    ///    The date at which the worker must have the skill and certificate.
    /// </param>
    /// <returns>
    ///    true if the worker has the skill and certificate at the specified date; otherwise, false.
    /// </returns>
    private boolean checkWorkerSkillAndCertificate(
        JmgWorkerRecId          _workerId,
        HcmSkillId              _skillId,
        HcmRatingLevelId        _requiredLevelId,
        HcmCertificateTypeId    _certificateId,
        JmgDate                 _date)
    {
        HcmPersonSkill          hcmPersonSkill;
        HcmSkill                hcmSkill;
        HRMRatingNormFactor     expectedFactor;
        HRMRatingNormFactor     workerFactor;
        HcmPersonCertificate    hcmPersonCertificate;
        boolean                 ok;

        ok = true;

        if (_skillId)
        {
            hcmSkill = HcmSkill::findBySkill(_skillId);
            hcmPersonSkill = HcmPersonSkill::findByPersonSkillRatingDetails(
                HcmWorker::find(_workerId).Person,
                hcmSkill.RecId,
                HRMSkillLevelType::Actual,
                _date);

            if (hcmPersonSkill)
            {
                expectedFactor = HcmRatingLevel::findRatingFactor(hcmSkill.RatingModel, _requiredLevelId);
                workerFactor = HcmRatingLevel::findRatingFactor(hcmSkill.RatingModel, HcmRatingLevel::find(hcmPersonSkill.RatingLevel).RatingLevelId);
                if (workerFactor < expectedFactor)
                {
                    ok = false;
                }
            }
            else
            {
                ok = false;
            }
        }

        if (ok && _certificateId)
        {
            hcmPersonCertificate = HcmPersonCertificate::findByPersonCertificateTypeIssueDate(
                HcmWorker::find(_workerId).Person,
                HcmCertificateType::findByCertificateType(_certificateId).RecId,
                _date);
            if (!hcmPersonCertificate)
            {
                ok = false;
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>chkAbsenceErr</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a calculation error caused by missing absence has been detected.
    /// </summary>
    /// <returns>
    ///    true if an error has been detected because of absence; otherwise, false.
    /// </returns>
    boolean chkAbsenceErr()
    {
        return chkAbsenceErr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>chkChronologyErr</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a calculation error caused by chronology has been detected.
    /// </summary>
    /// <returns>
    ///    true if an error caused by chronology has been detected; otherwise, false.
    /// </returns>
    boolean chkChronologyErr()
    {
        return chkChronologyErr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>chkClockInOutErr</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a calculation error because of missing clock in or clock out registrations has
    ///    been detected.
    /// </summary>
    /// <returns>
    ///    true if an error has been detected caused by missing clock in or clock out registrations;
    ///    otherwise, false.
    /// </returns>
    boolean chkClockInOutErr()
    {
        return chkClockInOutErr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>chkAbsenceOrFlexConfigErr</Name>
				<Source><![CDATA[
    public boolean chkAbsenceOrFlexConfigErr()
    {
        return chkAbsenceOrFlexConfigErr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>chkCreateAbsRec</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an absence registration for the specified time.
    /// </summary>
    /// <param name="_jmgStampJournalTable">
    ///    The <c>JmgStampJournalTable</c> record, which is the header for the calculation.
    /// </param>
    /// <param name="_intimeGapLowLim">
    ///    The start time of the absence period.
    /// </param>
    /// <param name="_intimeGapUppLim">
    ///    The end time of the absence period.
    /// </param>
    /// <param name="_intimeGapRecId">
    ///    The record ID of an existing absence record to reuse.
    /// </param>
    /// <param name="_intimeGapClockedIn">
    ///    A Boolean value that specifies whether the worker was clocked in during the specified time interval.
    /// </param>
    /// <param name="_intimeGapJobIdAbs">
    ///    The job ID of the absence code to apply to the created absence record.
    /// </param>
    void chkCreateAbsRec(JmgStampJournalTable   _jmgStampJournalTable,
                         Integer                _intimeGapLowLim,
                         Integer                _intimeGapUppLim,
                         recId                  _intimeGapRecId,
                         boolean                _intimeGapClockedIn,
                         JmgJobIDAbs            _intimeGapJobIdAbs)
    {
        JmgProfileSeconds       profSec = new JmgProfileSeconds();
        HRMAbsenceCode          hrmAbsenceCode;
        HRMAbsenceCodeGroup     hrmAbsenceCodeGroup;
        JmgIpcActivity          jmgIpcActivity;
        boolean                 transUpdated;
        JmgStampJournalTrans    jmgStampJournalTrans;
        ttsbegin;

        this.setNewTransId();

        Integer timeGapLowLimLoc = _intimeGapLowLim;

        if (_intimeGapRecId != 0)
        {
            select firstonly forupdate jmgStampJournalTrans
                where jmgStampJournalTrans.RecId == _intimeGapRecId;

            // Won't touch existing absence records that have job ID and where the start time is the same as the end time
            if (jmgStampJournalTrans.JourRegType == JmgJourRegTypeEnum::Absence
                && (jmgStampJournalTrans.JobId || jmgStampJournalTrans.JobIDAbs)
                && (jmgStampJournalTrans.StartDate != jmgStampJournalTrans.StopDate
                    || jmgStampJournalTrans.StartTime != jmgStampJournalTrans.StopTime))
            {
                this.bundleAddStack(jmgStampJournalTrans);
                Seconds absEndSeconds = new JmgProfileSeconds(jmgStampJournalTrans.StopDate, jmgStampJournalTrans.StopTime).profileSeconds();
                timeGapLowLimLoc = absEndSeconds;
                if (timeGapLowLimLoc == _intimeGapUppLim)
                {
                    ttsCommit;
                    return;
                }
                jmgStampJournalTrans.clear();
            }
        }
        else
        {
            jmgStampJournalTrans.IsGeneratedByCalculation = NoYes::Yes;
        }

        if (_intimeGapClockedIn)
        {
            jmgStampJournalTrans.JourRegType    = JmgJourRegTypeEnum::IndActivity;
            jmgStampJournalTrans.StampType      = JmgStampTypeEnum::Work;
            jmgStampJournalTrans.StampTypeSpec  = JmgStampTypeSpecEnum::Work;
            jmgStampJournalTrans.JobId          = JmgIpcActivity::findSignTypeJobId(JmgSignInOut::SysIndirect);
            jmgStampJournalTrans.JobIDAbs       = '';
            jmgIpcActivity              = JmgIpcActivity::findJobId(jmgStampJournalTrans.JobId);
        }
        else
        {
            jmgStampJournalTrans.JourRegType    = JmgJourRegTypeEnum::Absence;
            jmgStampJournalTrans.StampType      = JmgStampTypeEnum::Absence;
            jmgStampJournalTrans.StampTypeSpec  = JmgStampTypeSpecEnum::AbsNotSpec;
            if (jmgStampJournalTrans.JobIDAbs)
                jmgStampJournalTrans.JobId      = jmgStampJournalTrans.JobIDAbs;
            else if (! jmgStampJournalTrans.JobId)
                jmgStampJournalTrans.JobId      = _intimeGapJobIdAbs;
            jmgStampJournalTrans.JobIDAbs       = '';
        }

        if (jmgStampJournalTrans.JobId)
        {
            hrmAbsenceCode                      = HRMAbsenceCode::findByJobId(jmgStampJournalTrans.JobId);
            if (hrmAbsenceCode)
            {
                hrmAbsenceCodeGroup             = HRMAbsenceCodeGroup::find(hrmAbsenceCode.HrmAbsenceCodeGroupId);
            }
            else
            {
                hrmAbsenceCodeGroup             = HRMAbsenceCodeGroup_Extension::findJobId(jmgStampJournalTrans.JobId);
            }
        }
        else if (jmgStampJournalTrans.JobRef)
        {
            hrmAbsenceCodeGroup                 = HRMAbsenceCodeGroup::find(jmgStampJournalTrans.JobRef);
        }

        jmgStampJournalTrans.initFromJournalTable(_jmgStampJournalTable,newTransId);
        jmgStampJournalTrans.StartTime                  = profSec.seconds(timeGapLowLimLoc);
        jmgStampJournalTrans.StartDate                  = profSec.date(timeGapLowLimLoc);
        jmgStampJournalTrans.StopTime                   = profSec.seconds(_intimeGapUppLim);
        jmgStampJournalTrans.StopDate                   = profSec.date(_intimeGapUppLim);

        if (hrmAbsenceCode)
        {
            jmgStampJournalTrans.setJournalTransTypes(hrmAbsenceCode);
        }
        else if (hrmAbsenceCodeGroup)
        {
            jmgStampJournalTrans.setJournalTransTypes(hrmAbsenceCodeGroup);
        }
        else if (jmgIpcActivity)
        {
            jmgStampJournalTrans.setJournalTransTypes(jmgIpcActivity);
        }

        if (jmgStampJournalTrans.JourRegType    == JmgJourRegTypeEnum::Absence  &&
            !jmgStampJournalTrans.JobId                                         &&
            !jmgStampJournalTrans.JobIDAbs)
        {
            jmgStampJournalTrans.Log            = "@SYS38459";
            chkAbsenceErr               = true;
        }

        transUpdated = jmgStampJournalTrans.TransTableId != 0;
        if (!transUpdated)
        {
            jmgStampJournalTrans.IsGeneratedByCalculation = NoYes::Yes;
        }

        jmgStampJournalTrans.Worker        = _jmgStampJournalTable.Worker;
        jmgStampJournalTrans.ProfileDate   = _jmgStampJournalTable.ProfileDate;
        jmgStampJournalTrans.write();

        if (transUpdated)
        {
            JmgCalcApproveForm::construct().transactionUpdated(jmgStampJournalTrans);
        }
        else
        {
            JmgCalcApproveForm::construct().transactionInserted(jmgStampJournalTrans);
        }

        this.bundleAddStack(jmgStampJournalTrans);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>chkError</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a calculation error has been detected.
    /// </summary>
    /// <param name="inErr1">
    ///    A Boolean value that specifies whether an error has occurred.
    /// </param>
    /// <param name="inErr2">
    ///    A Boolean value that specifies whether an error has occurred.
    /// </param>
    /// <param name="inErr3">
    ///    A Boolean value that specifies whether an error has occurred.
    /// </param>
    /// <returns>
    ///    true if an error has been detected; otherwise, false.
    /// </returns>
    boolean chkError(boolean inErr1 = false, boolean inErr2 = false, boolean inErr3 = false)
    {
        if (inErr1 || inErr2 || inErr3 || chkChronologyErr || chkAbsenceErr || chkTransIdErr || chkClockInOutErr || chkAbsenceOrFlexConfigErr)
            return true;

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>chkTimeGaps</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates time gaps in the internal event table.
    /// </summary>
    /// <param name="jmgStampJournalTable">
    /// The <c>JmgStampJournalTable</c> record, which is the header for the calculation.
    /// </param>
    /// <param name="jmgStampJournalTrans">
    /// The registration, which is the next to add to the internal event table.
    /// </param>
    void chkTimeGaps(JmgStampJournalTable jmgStampJournalTable,JmgStampJournalTrans jmgStampJournalTrans)
    {
        JmgProfileSeconds   jmgProfileSeconds   = new JmgProfileSeconds(jmgStampJournalTrans.StartDate,jmgStampJournalTrans.StartTime);

        if (jmgProfileSeconds.profileSeconds() > tmpSaveStopDateTime)
            this.insertTimeGaps(jmgStampJournalTable,tmpSaveStopDateTime,jmgProfileSeconds.profileSeconds(),tmpLastRecId,tmpJobidAbs);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreateAbsenceRegisterationForTimeGabType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether an absence registrations should be created for the specified time gap type.
    /// </summary>
    /// <param name="_timeGabType">
    /// The type of the time gap to check.
    /// </param>
    /// <returns>
    /// true if an absence registrations should be created for the specified time gap type; otherwise, false.
    /// </returns>
    [Hookable]
    protected boolean shouldCreateAbsenceRegisterationForTimeGabType(JmgProfileSpecType _timeGabType)
    {
        return _timeGabType == JmgProfileSpecTypeEnum::WorkTime     ||
                _timeGabType == JmgProfileSpecTypeEnum::OverTime    ||
                _timeGabType == JmgProfileSpecTypeEnum::FlexAdd     ||
                _timeGabType == JmgProfileSpecTypeEnum::FlexSub     ||
                _timeGabType == JmgProfileSpecTypeEnum::BreakPay;
    }

]]></Source>
			</Method>
			<Method>
				<Name>chkTimeGapsAbsence</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates absence registrations for all detected time gaps.
    /// </summary>
    /// <param name="jmgStampJournalTable">
    /// The <c>JmgStampJournalTable</c> record, which is the header for the calculation.
    /// </param>
    void chkTimeGapsAbsence(JmgStampJournalTable jmgStampJournalTable)
    {
        JmgProfileSeconds   profSec = new JmgProfileSeconds();
        Integer             timeEventFrom;

        for (timeGapCnt = 1; timeGapCnt <= timeGapMax; timeGapCnt++)
        {
            if (! timeGapClockedInOut[timeGapCnt])
            {
                // Determine whether to disregard absence because it is covered by tolerances.
                timeGapLL               = 0;
                timeGapUL               = 0;
                [tmpStartDate,tmpStart] = profSec.dateSeconds(timeGapLowLim[timeGapCnt]);
                [tmpEndDate,tmpEnd]     = profSec.dateSeconds(timeGapUppLim[timeGapCnt]);

                [tmpStartDate,tmpStart] = this.getToleranceAdjustedTime(jmgStampJournalTable.ProfileDate, tmpStartDate, tmpStart, true);
                [tmpEndDate,tmpEnd]     = this.getToleranceAdjustedTime(jmgStampJournalTable.ProfileDate, tmpEndDate, tmpEnd, false);

                // If the absence is covered by the same tolerance zone, then start and end time will be equal.
                if (tmpStartDate    == tmpEndDate
                    && tmpStart     == tmpEnd)
                {
                    timeGapLowLim[timeGapCnt]   = 0;
                    timeGapUppLim[timeGapCnt]   = 0;
                    timeGapRecId[timeGapCnt]    = 0;
                }
            }
        }

        for (timeGapCnt = 1; timeGapCnt <= timeGapMax; timeGapCnt++)
        {
            if (! timeGapClockedInOut[timeGapCnt])
            {
                if ((getProfileFrom && getProfileTo))
                {
                    for (timeEventFrom = getProfileFrom ; timeEventFrom <= getProfileTo ; timeEventFrom++)
                    {
                        if (this.shouldCreateAbsenceRegisterationForTimeGabType(getProfileTimeType_Line[timeEventFrom]))
                        {
                            timeEventDate       = (jmgStampJournalTable.ProfileDate + getProfileStartDay_Line[timeEventFrom]);
                            timeEventLowLimit_P = profSec.profileSeconds(timeEventDate,getProfileStartTime_Line[timeEventFrom]);
                            timeEventDate       = (jmgStampJournalTable.ProfileDate + getProfileEndDay_Line[timeEventFrom]);
                            timeEventUppLimit_P = profSec.profileSeconds(timeEventDate,getProfileEndTime_Line[timeEventFrom]);
                            timeEventSpec       = getProfileTimeType_Line[timeEventFrom];
                            timeEventLowLimit_P = max(timeEventLowLimit_P,timeGapLowLim[timeGapCnt]);
                            timeEventUppLimit_P = min(timeEventUppLimit_P,timeGapUppLim[timeGapCnt]);

                            if (timeEventLowLimit_P < timeEventUppLimit_P)
                            {
                                this.chkCreateAbsRec(jmgStampJournalTable,
                                                     timeGapLowLim[timeGapCnt],
                                                     timeGapUppLim[timeGapCnt],
                                                     timeGapRecId[timeGapCnt],
                                                     timeGapClockedInOut[timeGapCnt],
                                                     timeGapJobIdAbs[timeGapCnt]);
                                break;
                            }
                        }
                    }
                }
            }
            else
            {
                this.chkCreateAbsRec(jmgStampJournalTable,
                                    timeGapLowLim[timeGapCnt],
                                    timeGapUppLim[timeGapCnt],
                                    timeGapRecId[timeGapCnt],
                                    timeGapClockedInOut[timeGapCnt],
                                    timeGapJobIdAbs[timeGapCnt]);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>chkTransIdErr</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves whether a calculation error because of a missing transaction ID has been detected.
    /// </summary>
    /// <returns>
    ///    true if an error because of a missing transaction ID has been detected; otherwise, false.
    /// </returns>
    boolean chkTransIdErr()
    {
        return chkTransIdErr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearTimeEvents</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the internal event table.
    /// </summary>
    void clearTimeEvents()
    {
        getProfileEventTab_TransId = JmgProfiles::noTransID();
        while (getProfileEventTab_Cnt > 0)
        {
            getProfileEventTab_Type             [getProfileEventTab_Cnt] = JmgProfileSpecTypeEnum::Blank;
            getProfileEventTab_ProfileType      [getProfileEventTab_Cnt] = 0;
            getProfileEventTab_LowLim           [getProfileEventTab_Cnt] = 0;
            getProfileEventTab_UppLim           [getProfileEventTab_Cnt] = 0;
            getProfileEventTab_Sec              [getProfileEventTab_Cnt] = 0;
            getProfileEventTab_StampSpec        [getProfileEventTab_Cnt] = JmgStampTypeSpecEnum::Work;
            getProfileEventTab_Trid             [getProfileEventTab_Cnt] = '';
            getProfileEventTab_JobPayType       [getProfileEventTab_Cnt] = JmgJobPayTypeEnum::Hours;
            getProfileEventTab_DefaultDimension [getProfileEventTab_Cnt] = 0;
            getProfileEventTab_Cnt--;
        }
        getProfileEventTab_Cnt = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>countProfileTimeEvent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates profile time, break time, and absence time in the specified time interval.
    /// </summary>
    /// <param name="profiledateIn">
    ///    The profile date to calculate time for.
    /// </param>
    /// <param name="startdateIn">
    ///    The date to start calculation from.
    /// </param>
    /// <param name="endDateIn">
    ///    The date where calculation is stopped.
    /// </param>
    /// <param name="startSecIn">
    ///    The time to start calculation from
    /// </param>
    /// <param name="endSecIn">
    ///    The time where calculation is stopped.
    /// </param>
    /// <param name="stampTypeSpecIn">
    ///    The type of registration to include in the calculation.
    /// </param>
    /// <param name="transIdIn">
    ///    The transaction ID to include in the calculation.
    /// </param>
    /// <param name="jobPayType">
    ///    The job pay type to include in the calculation.
    /// </param>
    /// <param name="eventInsert">
    ///    A Boolean value that specifies whether an entry is inserted into the internal event table.
    /// </param>
    /// <param name="defaultDimension">
    ///    The default dimensions to assign to the event created in the internal event table.
    /// </param>
    /// <remarks>
    ///    The result of the calculation is assigned to internal instance variables.
    /// </remarks>
    void countProfileTimeEvent( date                profiledateIn,
                                date                startdateIn,
                                date                endDateIn,
                                JmgSeconds          startSecIn,
                                JmgSeconds          endSecIn,
                                JmgStampTypeSpec    stampTypeSpecIn,
                                JmgTransId          transIdIn,
                                JmgJobPayTypeEnum   jobPayType,
                                boolean             eventInsert,
                                DimensionDefault    defaultDimension = 0)
    {
        JmgProfileSeconds   profSec = new JmgProfileSeconds();
        JmgProfileSpecType  timeEventSpecSecondary;
        JmgProfileTypeRecId timeEventProfileType;

        Integer             timeEventFrom  = getProfileFrom;
        Integer             timeEventTo;

        timeEventSec            = 0;
        timeEventBrkTime        = 0;
        timeEventBrkTimePay     = 0;

        timeEventLowLimit_S     = profSec.profileSeconds(startdateIn,startSecIn);
        timeEventUppLimit_S     = profSec.profileSeconds(endDateIn,endSecIn);
        timeEventNetTime        = max(0,(timeEventUppLimit_S - timeEventLowLimit_S));
        timeEventSpec           = JmgProfileSpecTypeEnum::Blank;
        timeEventSpecSecondary  = JmgProfileSpecTypeEnum::Blank;

        if ((stampTypeSpecIn != JmgStampTypeSpecEnum::BreakNoPayFlow) &&
            (stampTypeSpecIn != JmgStampTypeSpecEnum::BreakPayFlow)   &&
            (stampTypeSpecIn != JmgStampTypeSpecEnum::BreakDropOne)   &&
            (stampTypeSpecIn != JmgStampTypeSpecEnum::BreakDropAll)   &&
            timeEventNetTime)
        {
            timeEventTo   = getProfileTo;

            while ((timeEventFrom && timeEventTo) && (timeEventFrom <= timeEventTo))
            {
                timeEventDate               = (profileDateIn + getProfileStartDay_Line[timeEventFrom]);
                timeEventLowLimit_P         = profSec.profileSeconds(timeEventDate,getProfileStartTime_Line[timeEventFrom]);
                timeEventDate               = (profileDateIn + getProfileEndDay_Line[timeEventFrom]);
                timeEventUppLimit_P         = profSec.profileSeconds(timeEventDate,getProfileEndTime_Line[timeEventFrom]);
                timeEventSpec               = getProfileTimeType_Line[timeEventFrom];
                timeEventSpecSecondary      = getProfileTimeType_Line[timeEventFrom];
                timeEventProfileType        = getProfileProfileType_Line[timeEventFrom];

                if ((timeEventSpec == JmgProfileSpecTypeEnum::Break) || (timeEventSpec == JmgProfileSpecTypeEnum::BreakPay))
                {
                    jmgBreaks.breakCheckDropped(timeEventLowLimit_P,timeEventUppLimit_P);
                    if (jmgBreaks.breakIsDropped())
                    {
                        timeEventSpec           = getProfileSecondaryType_Line[timeEventFrom];
                        timeEventSpecSecondary  = getProfileSecondaryType_Line[timeEventFrom];
                    }
                }

                if (timeEventLowLimit_P > timeEventUppLimit_S)
                {
                    break;
                }
                else
                {
                    timeEventLowLimit_P = max(timeEventLowLimit_P,timeEventLowLimit_S);
                    timeEventUppLimit_P = min(timeEventUppLimit_P,timeEventUppLimit_S);
                    timeEventSec        = max(0,(timeEventUppLimit_P - timeEventLowLimit_P));

                    if (timeEventSec)
                    {
                        timeEventLowLimit_Save  = 0;
                        [timeEventLowLimit_Save,timeEventLowLimit_B,timeEventUppLimit_B,timeEventSec] =
                            jmgBreaks.insertbreakEvents(this,timeEventLowLimit_Save,timeEventLowLimit_B,timeEventUppLimit_B,timeEventSec,
                                    timeEventLowLimit_P,timeEventUppLimit_P,timeEventSpec,stampTypeSpecIn,transIdIn,jobPayType,defaultDimension,eventInsert, timeEventSpecSecondary, timeEventProfileType);
                    }
                }
                timeEventFrom++;
            }
        }
        else
        {
            if ((eventInsert) &&
                ((stampTypeSpecIn != JmgStampTypeSpecEnum::BreakDropOne)   &&
                (stampTypeSpecIn != JmgStampTypeSpecEnum::BreakDropAll)   &&
                (getProfileEventTab_TransId != transIdIn) && (transIdIn != JmgProfiles::noTransID())&& (timeEventNetTime)))
            {
                getProfileEventTab_Cnt++;

                getProfileEventTab_Type     [getProfileEventTab_Cnt] = stampTypeSpecIn==JmgStampTypeSpecEnum::BreakNoPayFlow ? JmgProfileSpecTypeEnum::Break : JmgProfileSpecTypeEnum::BreakPay ;
                getProfileEventTab_LowLim   [getProfileEventTab_Cnt] = timeEventLowLimit_S;
                getProfileEventTab_UppLim   [getProfileEventTab_Cnt] = timeEventUppLimit_S;
                getProfileEventTab_Sec      [getProfileEventTab_Cnt] = timeEventNetTime;
                getProfileEventTab_StampSpec[getProfileEventTab_Cnt] = jmgBreakRegistrationsFlightEnabled && (stampTypeSpecIn==JmgStampTypeSpecEnum::BreakNoPayFlow || stampTypeSpecIn==JmgStampTypeSpecEnum::BreakPayFlow) ? JmgStampTypeSpecEnum::Work : stampTypeSpecIn;
                getProfileEventTab_Trid     [getProfileEventTab_Cnt] = transIdIn;
                getProfileEventTab_DefaultDimension[getProfileEventTab_Cnt] = defaultDimension;
                getProfileEventTab_JobPayType[getProfileEventTab_Cnt]= jobPayType;
                if (timeEventFrom)
                {
                    getProfileEventTab_SecondaryType[getProfileEventTab_Cnt]=getProfileSecondaryType_Line[timeEventFrom];
                    getProfileEventTab_ProfileType[getProfileEventTab_Cnt]=getProfileProfileType_Line[timeEventFrom];
                }
            }
        }

        if (transIdIn != JmgProfiles::noTransID())
        {
            getProfileEventTab_TransId = transIdIn;
        }

        timeEventNetTime = max(0,(timeEventNetTime - timeEventBrkTime));
    }

]]></Source>
			</Method>
			<Method>
				<Name>enterTimeGapsAbsence</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds time gaps in the internal event table.
    /// </summary>
    /// <param name="jmgStampJournalTable">
    /// The <c>JmgStampJournalTable</c> record, which is the header for the calculation.
    /// </param>
    void enterTimeGapsAbsence(JmgStampJournalTable jmgStampJournalTable)
    {
        JmgProfileSeconds   profSec = new JmgProfileSeconds();

        if (tmpSaveStopDateTime <= profSec.profileSeconds(jmgStampJournalTable.ProfileStartDate,jmgStampJournalTable.ProfileStart))
        {
            this.insertTimeGaps(jmgStampJournalTable,
                profSec.profileSeconds(jmgStampJournalTable.ProfileStartDate,jmgStampJournalTable.ProfileStart),
                profSec.profileSeconds(jmgStampJournalTable.ProfileEndDate,jmgStampJournalTable.ProfileEnd),
                tmpLastRecId,tmpJobidAbs);
        }
        else
        {
            if (tmpSaveStopDateTime < profSec.profileSeconds(jmgStampJournalTable.ProfileEndDate,jmgStampJournalTable.ProfileEnd))
            {
                this.insertTimeGaps(jmgStampJournalTable,
                    tmpSaveStopDateTime,
                    profSec.profileSeconds(jmgStampJournalTable.ProfileEndDate,jmgStampJournalTable.ProfileEnd),
                    tmpLastRecId,tmpJobidAbs);
            }
        }

        this.chkTimeGapsAbsence(jmgStampJournalTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBreaks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>JmgBreaks</c> object, which handles calculation of break time.
    /// </summary>
    /// <param name="_worker">
    /// The ID of the worker, for which break time is calculated.
    /// </param>
    /// <param name="_startDate">
    /// The profile date for which break time is calculated.
    /// </param>
    /// <returns>
    /// the <c>JmgBreaks</c> object, which handles calculation of break time.
    /// </returns>
    JmgBreaks getBreaks(JmgWorkerRecId _worker, StartDate _startDate)
    {
        jmgBreaks.breakloaddrop(_worker, _startDate);

        return jmgBreaks;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadBreaks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads the <c>JmgBreaks</c> object, which handles calculation of break time.
    /// </summary>
    /// <param name="_worker">
    /// The ID of the worker, for which break time is calculated.
    /// </param>
    /// <param name="_startDate">
    /// The profile date for which break time is calculated.
    /// </param>
    public void loadBreaks(JmgWorkerRecId _worker, StartDate _startDate)
    {
        this.getBreaks(_worker, _startDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProfile</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the profile setup into internal variables.
    /// </summary>
    /// <param name="inProfile">
    ///    The profile ID to load.
    /// </param>
    /// <param name="inDay">
    ///    The ID of the day to load.
    /// </param>
    /// <param name="jmgStampJournalTable">
    ///    The <c>JmgStampJournalTable</c> record, which is the header for the calculation.
    /// </param>
    void getProfile(JmgProfileId inProfile, JmgDayId inDay, JmgStampJournalTable jmgStampJournalTable = null)
    {
        JmgProfileSpec          jmgProfileSpec;
        JmgProfileOverrideSpec  jmgProfileOverrideSpec;

        getProfileCnt          = 1;
        getProfileNStartOk     = 0;
        getProfileNEndOk       = 0;
        getProfileCurProfile   = 0;

        while (getProfileProfile_Head[getProfileCnt])
        {
            if ((getProfileProfile_Head[getProfileCnt] == inProfile) && (getProfileWeekDay_Head[getProfileCnt] == inDay))
            {
                getProfileFrom         = getProfileStartPos_Head[getProfileCnt];
                getProfileTo           = getProfileEndPos_Head[getProfileCnt];
                getProfileCurProfile   = getProfileCnt;
                getProfileCnt          = 0;
                break;
            }
            getProfileCnt++;
        }

        if (getProfileCnt)
        {
            getProfileProfile_Head[getProfileCnt]     = inProfile;
            getProfileWeekDay_Head[getProfileCnt]     = inDay;
            getProfileHaveFlex_Head[getProfileCnt]    = false;
            getProfileFrom                     = getProfileMax + 1;
            getProfileTo                       = getProfileMax;

            if (jmgStampJournalTable && (JmgProfileOverride::find(jmgStampJournalTable.Worker,jmgStampJournalTable.ProfileDate).RecId))
            {
                getProfileProfile_Head[getProfileCnt] = inProfile + int642str(jmgStampJournalTable.Worker);
                while select jmgProfileOverrideSpec
                    order by LineNum
                    where jmgProfileOverrideSpec.Worker         == jmgStampJournalTable.Worker &&
                          jmgProfileOverrideSpec.ProfileDate    == jmgStampJournalTable.ProfileDate
                {
                    this.getProfileLoadArray(jmgProfileOverrideSpec);
                    getProfileProfile_Line[getProfileTo] = inProfile + int642str(jmgStampJournalTable.Worker);
                    getProfileWeekDay_Line[getProfileTo] = inDay;
                }
            }
            else
            {
                getProfileProfile_Head[getProfileCnt] = inProfile;
                while select jmgProfileSpec
                    order by LineNum
                    where jmgProfileSpec.Profile   == inProfile &&
                          jmgProfileSpec.DayId     == inDay
                {
                    this.getProfileLoadArray(jmgProfileSpec);
                    getProfileProfile_Line[getProfileTo] = jmgProfileSpec.Profile;
                    getProfileWeekDay_Line[getProfileTo] = jmgProfileSpec.DayId;
                }
            }

            if (getProfileTo >= getProfileFrom)
            {
                getProfileCurProfile                    = getProfileCnt;
                getProfileStartPos_Head[getProfileCnt]  = getProfileFrom;
                getProfileEndPos_Head[getProfileCnt]    = getProfileTo;
                if ((! getProfileNStartOk) || (! getProfileNEndOk))
                {
                    getProfileNStartTime_Head[getProfileCnt] = -1;
                    getProfileNEndTime_Head[getProfileCnt]   = -1;
                }
            }
            else
            {
                getProfileFrom         = 0;
                getProfileTo           = 0;
                getProfileCurProfile   = 0;
            }
            if ((getProfileNStartOk) && (getProfileNEndOk))
            {
                this.countProfileTimeEvent( JmgProfileSeconds::proftestdate() + 1,
                                            (JmgProfileSeconds::proftestdate()+ 1 + getProfileNStartDay_Head[getProfileCnt]),
                                            (JmgProfileSeconds::proftestdate()+ 1 + getProfileNEndDay_Head[getProfileCnt]),
                                            getProfileNStartTime_Head[getProfileCnt],
                                            getProfileNEndTime_Head[getProfileCnt],
                                            JmgStampTypeSpecEnum::Work,
                                            JmgProfiles::noTransID(),JmgJobPayTypeEnum::Hours,false);

                getProfileNSeconds_Head[getProfileCnt] = this.timeEventStampTime()+ this.timeEventBreakTimePay();
            }
        }

        getProfileEventTab_Cnt          = 0;
        getProfileEventTab_TransId      = JmgProfiles::noTransID();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultAbsenceCode</Name>
				<Source><![CDATA[
    private JmgJobId getDefaultAbsenceCode(JmgWorkerRecId _worker)
    {
        JmgJobId    retAbsJobId;
        JmgJobId    tempAbsJobId = JmgParameters::find().getAbsenceJobId(_worker);
    
        if (this.validateAbsJobId(_worker, tempAbsJobId))
        {
            retAbsJobId = tempAbsJobId;
        }
    
        return retAbsJobId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProfileLoadArray</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads a single profile specification line into the internal variables.
    /// </summary>
    /// <param name="jmgProfileSpecMap">
    /// The <c>JmgProfileSpecMap</c> record to load.
    /// </param>
    void getProfileLoadArray(JmgProfileSpecMap jmgProfileSpecMap)
    {
        getProfileTo++;
        getProfileMax++;
        getProfileTimeType_Line         [getProfileTo] = JmgProfileTypeTable::find(jmgProfileSpecMap.ProfileType).ProfileSpecType;
        getProfileStartTime_Line        [getProfileTo] = JmgProfileSeconds::time2sec(jmgProfileSpecMap.StartTime);
        getProfileStartDay_Line         [getProfileTo] = jmgProfileSpecMap.StartDay;
        getProfileEndTime_Line          [getProfileTo] = JmgProfileSeconds::time2sec(jmgProfileSpecMap.EndTime);
        getProfileEndDay_Line           [getProfileTo] = jmgProfileSpecMap.EndDay;
        getProfileTolBeforeStart_Line   [getProfileTo] = JmgProfileSeconds::minutes2seconds(jmgProfileSpecMap.ToleranceBefore);
        getProfileTolAfterStart_Line    [getProfileTo] = JmgProfileSeconds::minutes2seconds(jmgProfileSpecMap.ToleranceAfterStart);
        getProfileTolBeforeEnd_Line     [getProfileTo] = JmgProfileSeconds::minutes2seconds(jmgProfileSpecMap.ToleranceBeforeEnd);
        getProfileTolAfterEnd_Line      [getProfileTo] = JmgProfileSeconds::minutes2seconds(jmgProfileSpecMap.ToleranceAfter);
        getProfileSecondaryType_Line    [getProfileTo] = JmgProfileTypeTable::find(jmgProfileSpecMap.SecondaryProfileType).ProfileSpecType;
        getProfileEventCode_Line        [getProfileTo] = jmgProfileSpecMap.EventCode;
        getProfileProfileType_Line      [getProfileTo] = jmgProfileSpecMap.ProfileType;
        getProfileSecondaryProfileType_Line[getProfileTo] = jmgProfileSpecMap.SecondaryProfileType;

        if ((getProfileTimeType_Line[getProfileTo] == JmgProfileSpecTypeEnum::FlexAdd)
            || (getProfileTimeType_Line[getProfileTo] == JmgProfileSpecTypeEnum::FlexSub))
            getProfileHaveFlex_Head[getProfileCnt] = true;

        if (getProfileTimeType_Line[getProfileTo] == JmgProfileSpecTypeEnum::SignIn)
        {
            getProfileNStartDay_Head[getProfileCnt]   = jmgProfileSpecMap.StartDay;
            getProfileNStartTime_Head[getProfileCnt]  = JmgProfileSeconds::time2sec(jmgProfileSpecMap.StartTime);
            getProfileNStartOk                 = 1;
            isSignIn                           = true;
        }
        if ((getProfileTimeType_Line[getProfileTo] == JmgProfileSpecTypeEnum::SignOut) && (getProfileNEndOk == 0))
        {
            getProfileNEndDay_Head [getProfileCnt]    = jmgProfileSpecMap.EndDay;
            getProfileNEndTime_Head[getProfileCnt]    = JmgProfileSeconds::time2sec(jmgProfileSpecMap.EndTime);
            getProfileNEndOk                   = 1;
        }

        if (eventCodeSet.in(getProfileEventCode_Line[getProfileTo]))
        {
            getProfileTimeType_Line[getProfileTo] = getProfileSecondaryType_Line[getProfileTo];
            getProfileProfileType_Line[getProfileTo] = getProfileSecondaryProfileType_Line[getProfileTo];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getToleranceAdjustedTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a container of the specified date and time, which has been adjusted according to the
    ///    profile setup.
    /// </summary>
    /// <param name="_profileDate">
    ///    The profile date for which to calculate adjustment.
    /// </param>
    /// <param name="_date">
    ///    The date for which to calculate adjustment.
    /// </param>
    /// <param name="_time">
    ///    The time for which to calculate adjustment.
    /// </param>
    /// <param name="_start">
    ///    A Boolean value that specifies whether the specified date and time must be adjusted according to
    ///    start tolerances;
    /// </param>
    /// <param name="_jmgProfileSpecType">
    ///    The type of registration to adjust the time with tolerance, default value is blank.
    /// </param>
    /// <returns>
    ///    A container that has the adjusted date and time.
    /// </returns>
    private container getToleranceAdjustedTime(JmgProfileDate _profileDate, JmgDate _date, JmgTime _time, boolean _start, JmgProfileSpecType _jmgProfileSpecType = JmgProfileSpecTypeEnum::Blank)
    {
        JmgProfileSeconds   startTolerance = new JmgProfileSeconds();
        JmgProfileSeconds   endTolerance = new JmgProfileSeconds();
        JmgProfileSeconds   registrationTime = new JmgProfileSeconds(_date, _time);
        JmgProfileSeconds   correctedTime = new JmgProfileSeconds(_date, _time);
        int     i;

        if (getProfileFrom > 0)
        {
            for (i = getProfileFrom; i <= getProfileTo; i++)
            {
                if (_start)
                {
                    startTolerance.setDateSeconds(_profileDate + getProfileStartDay_Line[i], getProfileStartTime_Line[i] - getProfileTolBeforeStart_Line[i]);
                    endTolerance.setDateSeconds(_profileDate + getProfileStartDay_Line[i], getProfileStartTime_Line[i] + getProfileTolAfterStart_Line[i]);
                    correctedTime.setDateSeconds(_profileDate + getProfileStartDay_Line[i], getProfileStartTime_Line[i]);
                }
                else
                {
                    startTolerance.setDateSeconds(_profileDate + getProfileEndDay_Line[i], getProfileEndTime_Line[i] - getProfileTolBeforeEnd_Line[i]);
                    endTolerance.setDateSeconds(_profileDate + getProfileStartDay_Line[i], getProfileEndTime_Line[i] + getProfileTolAfterEnd_Line[i]);
                    correctedTime.setDateSeconds(_profileDate + getProfileEndDay_Line[i], getProfileEndTime_Line[i]);
                }
                if (startTolerance.profileSeconds() <= registrationTime.profileSeconds()
                    && endTolerance.profileSeconds()>= registrationTime.profileSeconds()
                    && (prmisDefault(_jmgProfileSpecType) || getProfileTimeType_Line[i] == _jmgProfileSpecType))
                {
                    registrationTime.setProfileSeconds(correctedTime.profileSeconds());
                    break;
                }
            }
        }
        return registrationTime.dateSeconds();
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleNormTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles calculation of norm-time profiles.
    /// </summary>
    /// <param name="jmgStampJournalTable">
    ///    The <c>JmgStampJournalTable</c> record, which is the header for the calculation.
    /// </param>
    void handleNormTime(JmgStampJournalTable jmgStampJournalTable)
    {
        JmgProfileSeconds       profSec = new JmgProfileSeconds();
        JmgAbsenceCalendar      absenceCalendar;
        JmgSeconds              previousBreakTime;
        utcdatetime             plannedAbsenceFromTime;

        if ((jmgStampJournalTable.ProfileStartDate) || (!jmgStampJournalTable.NormSec))
            return;

        this.chkTimeGapsAbsence(jmgStampJournalTable);

        bundlePointer = 1;
        while (bundle[bundlePointer])
        {
            [tmpStartDate,tmpStart] = profSec.dateSeconds(bundleStart[bundlePointer]);
            [tmpEndDate,tmpEnd]     = profSec.dateSeconds(bundleEnd[bundlePointer]);

            [tmpStartDate, tmpStart]    = this.getToleranceAdjustedTime(jmgStampJournalTable.ProfileDate, tmpStartDate, tmpStart, true);
            [tmpEndDate, tmpEnd]        = this.getToleranceAdjustedTime(jmgStampJournalTable.ProfileDate, tmpEndDate, tmpEnd, false);

            bundleStartDateTimeCorr[bundlePointer]  = profSec.profileSeconds(tmpStartDate,tmpStart);
            bundleEndDateTimeCorr[bundlePointer]    = profSec.profileSeconds(tmpEndDate,tmpEnd);
            [tmpStartDate,tmpStart]                 = profSec.dateSeconds(bundleStartDateTimeCorr[bundlePointer]);
            [tmpEndDate,tmpEnd]                     = profSec.dateSeconds(bundleEndDateTimeCorr[bundlePointer]);
            this.countProfileTimeEvent(jmgStampJournalTable.ProfileDate,tmpStartDate,tmpEndDate,tmpStart,tmpEnd,
            bundleTypeSpec[bundlePointer],bundle[bundlePointer],bundleJobPayType[bundlePointer],true,bundle_DefaultDimension[bundlePointer]);

            bundlePointer++;
        }
        this.sumerizeCalc(jmgStampJournalTable);

        if (JmgProfilesCalcAbsenceTimeFlight::instance().isEnabled())
        {
            calcSumOvtFlexCorrect = max(0,(jmgStampJournalTable.NormSec - jmgStampJournalTable.PaySeconds));
        }
        else
        {
            calcSumOvtFlexCorrect = max(0,(jmgStampJournalTable.NormSec - (jmgStampJournalTable.PaySeconds + jmgStampJournalTable.PaidBreakSeconds)));
        }

        this.clearTimeEvents();
        this.timeGapsResetArray();

        jmgStampJournalTable.PaySeconds                 = 0;
        jmgStampJournalTable.PayOverTimeSeconds         = 0;
        jmgStampJournalTable.PayFlexAddSeconds          = 0;
        jmgStampJournalTable.PayFlexSubSeconds          = 0;
        jmgStampJournalTable.PayAbsenceSeconds          = 0;
        jmgStampJournalTable.PayFlexBalanceSeconds      = 0;
        jmgStampJournalTable.PayFlexCorrectionSeconds   = 0;

        if (calcSumOvtFlexCorrect)
        {
            if (! tmpSaveStopDateTime)
            {
                JmgProfileDay jmgProfileDay = JmgProfileDay::find(jmgStampJournalTable.Profile, JmgProfiles::date2DayId(jmgStampJournalTable.ProfileDate));
                tmpSaveStopDateTime = profSec.profileSeconds(
                                        jmgProfileDay.ProfileStartCodeBlankPrev == JmgProfileStartCodeBlankPrev::Blank ? jmgStampJournalTable.ProfileDate : jmgStampJournalTable.ProfileDate - 1,
                                        jmgProfileDay.StartTime);
            }

            if (! tmpJobidAbsNorm)
            {
                select firstOnly forUpdate absenceCalendar order by FromDateTime desc
                    where absenceCalendar.FromDateTime <= DateTimeUtil::newDateTime(jmgStampJournalTable.ProfileDate,timeMax(),DateTimeUtil::getUserPreferredTimeZone())  &&
                          absenceCalendar.ToDateTime   >= DateTimeUtil::newDateTime(jmgStampJournalTable.ProfileDate,0,DateTimeUtil::getUserPreferredTimeZone())  &&
                          absenceCalendar.Worker       == jmgStampJournalTable.Worker       &&
                          absenceCalendar.CalculationTrans  == NoYes::No                    &&
                          ((absenceCalendar.Disabled == NoYes::No) ||
                          (absenceCalendar.ToDateTime   >=  DateTimeUtil::newDateTime(jmgStampJournalTable.ProfileDate,0,DateTimeUtil::getUserPreferredTimeZone())));

                if (absenceCalendar)
                {
                    if ((absenceCalendar.Disabled == NoYes::No) && (absenceCalendar.DisableAtSigning == NoYes::Yes) && chkSignedInOk)
                    {
                        absenceCalendar.Disabled    = NoYes::Yes;
                        absenceCalendar.ToDateTime  = DateTimeUtil::newDateTime(jmgStampJournalTable.ProfileDate,24*60*60,DateTimeUtil::getUserPreferredTimeZone());
                        absenceCalendar.update();
                    }
                    tmpJobidAbsNorm                 = absenceCalendar.JobId;

                    // convert planned absence's from time to user time zone value to make correct comparison with signIn time
                    plannedAbsenceFromTime = DateTimeUtil::applyTimeZoneOffset(absenceCalendar.FromDateTime, DateTimeUtil::getUserPreferredTimeZone());

                    // check if planned absence begins before signIn time
                    // in this case use planned absence's from time as lower limit for the time gap
                    if (!isSignIn && DateTimeUtil::time(plannedAbsenceFromTime) < fromDatetimeSignin)
                    {
                        tmpSaveStopDateTime = profSec.profileSeconds(DateTimeUtil::date(plannedAbsenceFromTime),dateTimeutil::time(plannedAbsenceFromTime));
                    }
                }
            }

            if (!tmpJobidAbsNorm)
            {
                // If no planned absence, find the special day.
                tmpJobidAbsNorm = JmgProfileCalendar::getSpecialDayAbsence(JmgEmployee::find(jmgStampJournalTable.Worker), jmgStampJournalTable.ProfileDate);

                if (!tmpJobidAbsNorm)
                {
                    tmpJobidAbsNorm = this.getDefaultAbsenceCode(jmgStampJournalTable.Worker);
                }
            }

            timeGapMax++;
            timeGapLowLim[timeGapMax]       = tmpSaveStopDateTime;
            timeGapUppLim[timeGapMax]       = tmpSaveStopDateTime + calcSumOvtFlexCorrect;
            timeGapRecId[timeGapMax]        = tmpLastRecId;
            timeGapJobIdAbs[timeGapMax]     = tmpJobidAbsNorm;
            timeGapClockedInOut[timeGapMax] = this.signInStatus();

            [tmpStartDate,tmpStart]         = profSec.dateSeconds(timeGapLowLim[timeGapMax]);
            [tmpEndDate,tmpEnd]             = profSec.dateSeconds(timeGapUppLim[timeGapMax]);

            this.countProfileTimeEvent(jmgStampJournalTable.ProfileDate,tmpStartDate,tmpEndDate,tmpStart,tmpEnd,
                JmgStampTypeSpecEnum::Work,JmgProfiles::noTransID(),JmgJobPayTypeEnum::Hours,false);

            while (timeEventBrkTime > previousBreakTime)
            {
                previousBreakTime   = timeEventBrkTime;
                [tmpEndDate,tmpEnd] = profSec.dateSeconds(timeGapUppLim[timeGapMax] + timeEventBrkTime);
                this.countProfileTimeEvent(jmgStampJournalTable.ProfileDate,tmpStartDate,tmpEndDate,tmpStart,tmpEnd,
                    JmgStampTypeSpecEnum::Work,JmgProfiles::noTransID(),JmgJobPayTypeEnum::Hours,false);
            }
            timeGapUppLim[timeGapMax]       = tmpSaveStopDateTime + calcSumOvtFlexCorrect + timeEventBrkTime;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleNormTimeProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles calculation of norm time profiles.
    /// </summary>
    /// <param name="_jmgStampJournalTable">
    /// The <c>JmgStampJournalTable</c> record, which is the header for the calculation.
    /// </param>
    private void handleNormTimeProfile(JmgStampJournalTable _jmgStampJournalTable)
    {
        JmgSeconds              t;
        JmgSeconds              standardTime;
        JmgTimeCalcParmeters    overtimeParams;
        JmgTimeCalcParmeters    flextimeParams;
        select firstonly CalcPayTime
            from  overtimeParams
            where overtimeParams.ProfileSpecType    == JmgProfileSpecTypeEnum::OverTime &&
                  overtimeParams.StampTypeSpec      == JmgStampTypeSpecEnum::Work;

        select firstonly CalcPayTime, CalcPayOverTime
            from  flextimeParams
            where flextimeParams.ProfileSpecType    == JmgProfileSpecTypeEnum::FlexAdd &&
                  flextimeParams.StampTypeSpec      == JmgStampTypeSpecEnum::Work;

        standardTime = _jmgStampJournalTable.PaySeconds;

        if (overtimeParams.CalcPayTime)
        {
            standardTime -= _jmgStampJournalTable.PayOverTimeSeconds;
        }

        if (flextimeParams.CalcPayTime)
        {
            standardTime -= _jmgStampJournalTable.PayFlexAddSeconds;
        }

        // Convert overtime to standard time.
        if (standardTime < _jmgStampJournalTable.NormSec)
        {
            t = min(_jmgStampJournalTable.PayOverTimeSeconds, _jmgStampJournalTable.NormSec - standardTime);
            this.manipulateTimeEvents(t, JmgProfileSpecTypeEnum::OverTime, JmgProfileSpecTypeEnum::WorkTime, true);
            if (!overtimeParams.CalcPayTime)
            {
                _jmgStampJournalTable.PaySeconds += t;
            }
            _jmgStampJournalTable.PayOverTimeSeconds -= t;
            standardTime += t;
        }

        // Convert flex time to standard time.
        if (standardTime < _jmgStampJournalTable.NormSec)
        {
            t = min(_jmgStampJournalTable.PayFlexAddSeconds, _jmgStampJournalTable.NormSec - standardTime);
            this.manipulateTimeEvents(t, JmgProfileSpecTypeEnum::FlexAdd, JmgProfileSpecTypeEnum::WorkTime, true);
            if (!flextimeParams.CalcPayTime)
            {
                _jmgStampJournalTable.PaySeconds += t;
            }
            _jmgStampJournalTable.PayFlexAddSeconds -= t;
            standardTime += t;
        }

        // Convert overtime to flex+ time
        if (_jmgStampJournalTable.PayFlexAddSeconds < _jmgStampJournalTable.NormFlexSec)
        {
            t = min(_jmgStampJournalTable.NormFlexSec - _jmgStampJournalTable.PayFlexAddSeconds, _jmgStampJournalTable.PayOverTimeSeconds);
            this.manipulateTimeEvents(t, JmgProfileSpecTypeEnum::OverTime, JmgProfileSpecTypeEnum::FlexAdd, true);
            if (!flextimeParams.CalcPayOverTime)
            {
                _jmgStampJournalTable.PayOverTimeSeconds -= t;
            }
            if (overtimeParams.CalcPayTime && !flextimeParams.CalcPayTime)
            {
                _jmgStampJournalTable.PaySeconds    -= t;
            }
            else if (!overtimeParams.CalcPayTime && flextimeParams.CalcPayTime)
            {
                _jmgStampJournalTable.PaySeconds    += t;
            }
            _jmgStampJournalTable.PayFlexAddSeconds += t;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initStampJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a <c>JmgStampJournalTable</c> record with calculation results.
    /// </summary>
    /// <param name="jmgStampJournalTable">
    ///    The <c>JmgStampJournalTable</c> record to initialize.
    /// </param>
    void initStampJournalTable(JmgStampJournalTable jmgStampJournalTable)
    {
        if (getProfileCurProfile)
        {
            if (getProfileNStartTime_Head[getProfileCurProfile] != -1)
            {
                jmgStampJournalTable.ProfileStart       = getProfileNStartTime_Head[getProfileCurProfile];
                jmgStampJournalTable.ProfileStartDate   = jmgStampJournalTable.ProfileDate + getProfileNStartDay_Head[getProfileCurProfile];
                jmgStampJournalTable.ProfileEnd         = getProfileNEndTime_Head[getProfileCurProfile];
                jmgStampJournalTable.ProfileEndDate     = jmgStampJournalTable.ProfileDate + getProfileNEndDay_Head[getProfileCurProfile];
                jmgStampJournalTable.ProfileSeconds     = getProfileNSeconds_Head[getProfileCurProfile];
            }
            jmgStampJournalTable.ProfileSeconds         = max(jmgStampJournalTable.ProfileSeconds,jmgStampJournalTable.NormSec);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertProfileTimeEvent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts a profile time event into the internal event table.
    /// </summary>
    /// <param name="profileSpecType">
    ///    The profile specification type of the event.
    /// </param>
    /// <param name="eventLowLim">
    ///    The start time of the event.
    /// </param>
    /// <param name="eventUppLim">
    ///    The end time of the event.
    /// </param>
    /// <param name="eventSec">
    ///    The time of the event.
    /// </param>
    /// <param name="stampSpec">
    ///    The stamp specification type of the event.
    /// </param>
    /// <param name="transIdIn">
    ///    The transaction ID of the event.
    /// </param>
    /// <param name="jobPayType">
    ///    The job pay type of the event.
    /// </param>
    /// <param name="defaultDimension">
    ///    The dimension values of the event.
    /// </param>
    /// <param name="eventInsert">
    ///    A Boolean value that specifies whether the event is inserted.
    /// </param>
    /// <param name="_secondaryProfileSpecType">
    ///    The secondary profile specification type of the event.
    /// </param>
    /// <param name="_profileType">
    ///    The profile type of the event.
    /// </param>
    void insertProfileTimeEvent(JmgProfileSpecType  profileSpecType,
                                JmgSeconds          eventLowLim,
                                JmgSeconds          eventUppLim,
                                JmgSeconds          eventSec,
                                JmgStampTypeSpec    stampSpec,
                                JmgTransId          transIdIn,
                                JmgJobPayTypeEnum   jobPayType,
                                DimensionDefault    defaultDimension,
                                boolean             eventInsert,
                                JmgProfileSpecType  _secondaryProfileSpecType,
                                JmgProfileTypeRecId _profileType)
    {
        if (eventSec)
        {
            if ((eventInsert) &&
                ((getProfileEventTab_TransId != transIdIn) && (transIdIn != JmgProfiles::noTransID())))
            {
                // Insert events in event array for calculation of pay
                getProfileEventTab_Cnt++;
                getProfileEventTab_Type     [getProfileEventTab_Cnt] = profileSpecType;
                getProfileEventTab_LowLim   [getProfileEventTab_Cnt] = eventLowLim;
                getProfileEventTab_UppLim   [getProfileEventTab_Cnt] = eventUppLim;
                getProfileEventTab_Sec      [getProfileEventTab_Cnt] = eventSec;
                getProfileEventTab_StampSpec[getProfileEventTab_Cnt] = stampSpec;
                getProfileEventTab_Trid     [getProfileEventTab_Cnt] = transIdIn;
                getProfileEventTab_DefaultDimension[getProfileEventTab_Cnt] = defaultDimension;
                getProfileEventTab_JobPayType[getProfileEventTab_Cnt]= jobPayType;
                getProfileEventTab_SecondaryType[getProfileEventTab_Cnt]= _secondaryProfileSpecType;
                getProfileEventTab_ProfileType[getProfileEventTab_Cnt]= _profileType;
            }
            if ((profileSpecType == JmgProfileSpecTypeEnum::Break) || (profileSpecType == JmgProfileSpecTypeEnum::BreakPay))
            {
                timeEventBrkTime += eventSec;
                if (profileSpecType == JmgProfileSpecTypeEnum::BreakPay)
                    timeEventBrkTimePay += eventSec;
            }
            if (((stampSpec == JmgStampTypeSpecEnum::AbsLegal)        ||
                 (stampSpec == JmgStampTypeSpecEnum::AbsIllegal)      ||
                 (stampSpec == JmgStampTypeSpecEnum::AbsLegalFlex)    ||
                 (stampSpec == JmgStampTypeSpecEnum::AbsIllegalFlex)) && (profileSpecType == JmgProfileSpecTypeEnum::BreakPay))
            {
                timeEventBrkTime -= timeEventSec;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTimeGaps</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts a time gap into the internal event table for the specified time interval.
    /// </summary>
    /// <param name="jmgStampJournalTable">
    ///    The <c>JmgStampJournalTable</c> record, which is the header for the calculation.
    /// </param>
    /// <param name="lowlimSec">
    ///    The start time of the time gap.
    /// </param>
    /// <param name="upLimSec">
    ///    The end time of the time gap.
    /// </param>
    /// <param name="gabRecId">
    ///    The record ID of the registration to reuse when the time gap is created.
    /// </param>
    /// <param name="absJobid">
    ///    The job ID of the absence code to assign to the time gap.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    The <c>JmgStampJournalTable</c> record is not correctly specified.
    /// </exception>
    void insertTimeGaps(JmgStampJournalTable    jmgStampJournalTable,
                        JmgSeconds              lowlimSec,
                        JmgSeconds              upLimSec,
                        recId                   gabRecId,
                        JmgJobIDAbs             absJobid)
    {
        JmgProfileSeconds  profSec = new JmgProfileSeconds();

        if (! jmgStampJournalTable)
        {
            throw error(strfmt("@SYS27147",classstr(JmgProfiles)));
        }

        timeGapLL               = 0;
        timeGapUL               = 0;
        timeGapFrom             = 0;
        timeGapTo               = 0;
        timeGapSeconds          = 0;
        timeGapSecondsFlex      = 0;

        if (this.signInStatus())
        {
            timeGapLL           = lowlimSec;
            timeGapUL           = upLimSec;
            timeGapFrom         = 0;
            timeGapTo           = 0;
            timeGapSeconds      = max(0,(timeGapUL - timeGapLL));
            timeGapSecondsFlex  = 0;
        }

        // If the absence job id is known, or the employee is clocked in, then insert one absence period, set timeGapLL and timeGapUL
        if (this.signInStatus() || gabRecId || absJobid)
        {
            timeGapLL           = lowlimSec;
            timeGapUL           = upLimSec;

            // if absence is manually added we don't create absence for the whole gap because the flex seconds are unknown at this time.
            JmgStampJournalTrans jmgStampJournalTransAbsInGap = JmgStampJournalTrans::findRecId(gabRecId);
            if (jmgStampJournalTransAbsInGap && jmgStampJournalTransAbsInGap.IsGeneratedByCalculation == NoYes::No)
            {
                timeGapLL           = profSec.profileSeconds(jmgStampJournalTransAbsInGap.StartDate, jmgStampJournalTransAbsInGap.StartTime);
                timeGapUL           = profSec.profileSeconds(jmgStampJournalTransAbsInGap.StopDate, jmgStampJournalTransAbsInGap.StopTime);
            }

            timeGapFrom         = 0;
            timeGapTo           = 0;
            timeGapSeconds      = max(0,(timeGapUL - timeGapLL));
            timeGapSecondsFlex  = 0;
        }

        if ((this.signOutStatus()) && (jmgStampJournalTable.ProfileStartDate) && (jmgStampJournalTable.ProfileEndDate))
        {
            timeGapLL           = max(profSec.profileSeconds(jmgStampJournalTable.ProfileStartDate,jmgStampJournalTable.ProfileStart),lowlimSec);
            timeGapUL           = min(profSec.profileSeconds(jmgStampJournalTable.ProfileEndDate  ,jmgStampJournalTable.ProfileEnd)  ,upLimSec);
            timeGapFrom         = getProfileFrom;
            timeGapTo           = getProfileTo;
            timeGapSeconds      = max(0,(timeGapUL - timeGapLL));
            timeGapSecondsFlex  = 0;

            if ((timeGapSeconds != 0) && (timeGapLL < timeGapUL))
            {
                while ((timeGapFrom > 0) && (timeGapTo > 0) && (timeGapFrom <= timeGapTo))
                {
                    if ((getProfileTimeType_Line[timeGapFrom] == JmgProfileSpecTypeEnum::FlexAdd) ||
                        (getProfileTimeType_Line[timeGapFrom] == JmgProfileSpecTypeEnum::FlexSub) ||
                        (getProfileTimeType_Line[timeGapFrom] == JmgProfileSpecTypeEnum::Break))
                    {
                        timeGapDate         = jmgStampJournalTable.ProfileDate + getProfileStartDay_Line[timeGapFrom];
                        timeGapFlex_LowLim  = profSec.profileSeconds(timeGapDate,getProfileStartTime_Line[timeGapFrom]);
                        timeGapDate         = jmgStampJournalTable.ProfileDate + getProfileEndDay_Line[timeGapFrom];
                        timeGapFlex_UppLim  = profSec.profileSeconds(timeGapDate,getProfileEndTime_Line[timeGapFrom]);
                        if (timeGapFlex_LowLim > timeGapUL)
                        {
                            break;
                        }
                        else
                        {
                            timeGapFlex_LowLim = max(timeGapFlex_LowLim,timeGapLL);
                            timeGapFlex_UppLim = min(timeGapFlex_UppLim,timeGapUL);
                            timeGapSecondsFlex = timeGapSecondsFlex + max(0,(timeGapFlex_UppLim - timeGapFlex_LowLim));
                        }
                    }
                    timeGapFrom++;
                }
            }
        }

        if ((timeGapSeconds > timeGapSecondsFlex) || (gabRecId || absJobid) || JmgAbsenceCalendar::isPlannedAbsence(jmgStampJournalTable.Worker, jmgStampJournalTable.ProfileDate))
        {
            // Don't touch the existing registration
            if (gabRecId)
            {
                timeGapMax++;
                timeGapLowLim[timeGapMax]       = timeGapLL;
                timeGapUppLim[timeGapMax]       = timeGapUL;
                timeGapRecId[timeGapMax]        = gabRecId;
                timeGapJobIdAbs[timeGapMax]     = absJobid;
                timeGapClockedInOut[timeGapMax] = this.signInStatus();
            }
            else
            {
                this.insertTimeGapsPlannedAbs(jmgStampJournalTable, timeGapLL, timeGapUL, gabRecId, timeGapSeconds > timeGapSecondsFlex, absJobid);
            }
        }
        tmpJobidAbs             = '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>addUnidentifiedAbsenceBeforePlanned</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts unidentified absence before the planned absence.
    /// </summary>
    /// <param name = "_absenceGapStartTime">
    /// The start time of the absence time gap.
    /// </param>
    /// <param name = "_plannedAbsenceStartTime">
    /// The start time of the worker planned absence.
    /// </param>
    /// <param name = "_absenceJobId">
    /// The job ID of the absence code to apply to the created absence record.
    ///</param>
    protected void addUnidentifiedAbsenceBeforePlanned(
        JmgSeconds _absenceGapStartTime,
        JmgSeconds _plannedAbsenceStartTime,
        JmgJobIDAbs _absenceJobId
        )
    {
        timeGapMax++;
        timeGapLowLim[timeGapMax]       = _absenceGapStartTime;
        timeGapUppLim[timeGapMax]       = _plannedAbsenceStartTime;
        timeGapRecId[timeGapMax]        = 0;
        timeGapJobIdAbs[timeGapMax]     = _absenceJobId;
        timeGapClockedInOut[timeGapMax] = this.signInStatus();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addIdentifiedPlannedAbsence</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts identified planned absence.
    /// </summary>
    /// <param name = "_lowerLimit">
    /// The start time of the absence time gap.
    /// </param>
    /// <param name = "_upperLimit">
    /// The end time of the absence time gap.
    /// </param>
    /// <param name = "_plannedAbsenceStartTime">
    /// The start time of the worker planned absence.
    /// </param>
    /// <param name = "_plannedAbsenceEndTime">
    /// The end time of the worker planned absence.
    /// </param>
    /// <param name = "_absenceJobId">
    /// The job ID of the absence code to apply to the created absence record.
    /// </param>
    protected void addIdentifiedPlannedAbsence(
        JmgSeconds _lowerLimit,
        JmgSeconds _upperLimit,
        JmgSeconds _plannedAbsenceStartTime,
        JmgSeconds _plannedAbsenceEndTime,
        JmgJobIDAbs _absenceJobId
        )
    {
        timeGapMax++;
        timeGapLowLim[timeGapMax]       = max(_lowerLimit, _plannedAbsenceStartTime);
        timeGapUppLim[timeGapMax]       = min(_upperLimit, _plannedAbsenceEndTime);
        timeGapRecId[timeGapMax]        = 0;
        timeGapJobIdAbs[timeGapMax]     = _absenceJobId;
        timeGapClockedInOut[timeGapMax] = this.signInStatus();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addUnidentifiedAbsenceAfterPlanned</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts unidentified absence after the last planned absence.    
    /// </summary>
    /// <param name = "_lowerLimit">
    /// The start time of the absence time gap.
    /// </param>
    /// <param name = "_upperLimit">
    /// The end time of the absence time gap.
    /// </param>
    /// <param name = "_gapRecId">
    /// The record ID of the registration to reuse when the absence time gap is created.
    /// </param>
    /// <param name = "_absenceJobId">
    /// The job ID of the absence code to apply to the created absence record.
    /// </param>    
    protected void addUnidentifiedAbsenceAfterPlanned(
        JmgSeconds _lowerLimit,
        JmgSeconds _upperLimit,
        RecId _gapRecId,
        JmgJobIDAbs _absenceJobId
        )
    {
        timeGapMax++;
        timeGapLowLim[timeGapMax]       = _lowerLimit;
        timeGapUppLim[timeGapMax]       = _upperLimit;
        timeGapRecId[timeGapMax]        = _gapRecId;
        timeGapJobIdAbs[timeGapMax]     = _absenceJobId;
        timeGapClockedInOut[timeGapMax] = this.signInStatus();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTimeGapsPlannedAbs</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts a time gap based on planned absence into the internal event table for the specified time
    ///    interval.
    /// </summary>
    /// <param name="jmgStampJournalTable">
    ///    The <c>JmgStampJournalTable</c> record, which is the header for the calculation.
    /// </param>
    /// <param name="lowlimSec">
    ///    The start time of the absence time gap.
    /// </param>
    /// <param name="upLimSec">
    ///    The end time of the absence time gap.
    /// </param>
    /// <param name="gabRecId">
    ///    The record ID of the registration to reuse when the absence time gap is created.
    /// </param>
    /// <param name="absenceZone">
    ///    A Boolean value that specifies whether the specified time gap is identified as absence.
    /// </param>
    /// <param name="selectedAbs">
    ///    The absence Job which is specified during clockin. Default value is empty.
    /// </param>
    /// <remarks>
    ///    The priority for absence: planned absence, special day absence, selected absence.
    /// </remarks>
    private void insertTimeGapsPlannedAbs(JmgStampJournalTable  jmgStampJournalTable,
                                          JmgSeconds            lowlimSec,
                                          JmgSeconds            upLimSec,
                                          RecId                 gabRecId,
                                          boolean               absenceZone,
                                          JmgJobIDAbs           selectedAbs = '')
    {
        JmgAbsenceCalendar  absenceCalendar;
        JmgJobIDAbs         jobIdAbs;
        JmgProfileSeconds   profSec = new JmgProfileSeconds();

        // Find default absence from special day table to insert, if not planned absence.
        jobIdAbs = JmgProfileCalendar::getSpecialDayAbsence(JmgEmployee::find(jmgStampJournalTable.Worker), jmgStampJournalTable.ProfileDate);

        if (!jobIdAbs)
        {
            jobIdAbs = selectedAbs;
        }

        JmgPlannedAbsenceParameters jmgPlannedAbsenceParameters = this.instantiateJmgPlannedAbsenceParameters(profSec, lowlimSec, upLimSec, absenceZone, jobIdAbs);

        while select FromDateTime, ToDateTime, JobId
            from  absenceCalendar
            order by FromDateTime
            where absenceCalendar.FromDateTime <= DateTimeUtil::newDateTime(jmgStampJournalTable.ProfileDate,timeMax(),DateTimeUtil::getUserPreferredTimeZone())   &&
                  absenceCalendar.ToDateTime   >= DateTimeUtil::newDateTime(jmgStampJournalTable.ProfileDate,0,DateTimeUtil::getUserPreferredTimeZone())            &&
                  absenceCalendar.Worker       == jmgStampJournalTable.Worker                                                                                       &&
                  absenceCalendar.CalculationTrans  == NoYes::No
        {
            if (!this.createPlannedAbsence(absenceCalendar, jmgPlannedAbsenceParameters))
            {
                break;
            }
        }
        // Enter unidentified absence after the last planned absence.
        if (jmgPlannedAbsenceParameters.parmLowerLimitSeconds() < jmgPlannedAbsenceParameters.parmUpperLimitSeconds() && jmgPlannedAbsenceParameters.parmAbsenceZone())
        {
            this.addUnidentifiedAbsenceAfterPlanned(
                jmgPlannedAbsenceParameters.parmLowerLimitSeconds(),
                jmgPlannedAbsenceParameters.parmUpperLimitSeconds(),
                gabRecId, 
                jmgPlannedAbsenceParameters.parmJobIdAbsence() ? jmgPlannedAbsenceParameters.parmJobIdAbsence() : this.getDefaultAbsenceCode(jmgStampJournalTable.Worker));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPlannedAbsence</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates planned absence.
    /// </summary>
    /// <param name = "_absenceCalendar">The current <c>JmgAbsenceCalendar</c> record.</param>
    /// <param name = "_JmgPlannedAbsenceParameters">A <c>JmgPlannedAbsenceParameters</c> class instance.</param>
    /// <returns>true if the planned absence is created; otherwise, false.</returns>
     protected boolean createPlannedAbsence(
        JmgAbsenceCalendar          _absenceCalendar,
        JmgPlannedAbsenceParameters _JmgPlannedAbsenceParameters)
    {
        JmgSeconds profileSecondsFrom = _JmgPlannedAbsenceParameters.parmProfileSeconds().profileSeconds(
                    DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(_absenceCalendar.FromDateTime,DateTimeUtil::getUserPreferredTimeZone())),
                    DateTimeUtil::time(DateTimeUtil::applyTimeZoneOffset(_absenceCalendar.FromDateTime,DateTimeUtil::getUserPreferredTimeZone())));

        JmgSeconds profileSecondsTo = _JmgPlannedAbsenceParameters.parmProfileSeconds().profileSeconds(
                    DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(_absenceCalendar.ToDateTime,DateTimeUtil::getUserPreferredTimeZone())),
                    DateTimeUtil::time(DateTimeUtil::applyTimeZoneOffset(_absenceCalendar.ToDateTime,DateTimeUtil::getUserPreferredTimeZone())));

        // Planned absence after time gap. No reason to continue.
        if (profileSecondsFrom >= _JmgPlannedAbsenceParameters.parmUpperLimitSeconds())
        {
            return false;
        }

        // Insert unidentified absence before the planned absence.
        if (_JmgPlannedAbsenceParameters.parmLowerLimitSeconds() < profileSecondsFrom && _JmgPlannedAbsenceParameters.parmAbsenceZone())
        {
            this.addUnidentifiedAbsenceBeforePlanned(
                    _JmgPlannedAbsenceParameters.parmLowerLimitSeconds(),
                    profileSecondsFrom,
                    _JmgPlannedAbsenceParameters.parmJobIdAbsence());

            _JmgPlannedAbsenceParameters.parmLowerLimitSeconds(profileSecondsFrom);
        }

        // Insert identified planned absence.
        if (max(_JmgPlannedAbsenceParameters.parmLowerLimitSeconds(), profileSecondsFrom) < min(_JmgPlannedAbsenceParameters.parmUpperLimitSeconds(),profileSecondsTo))
        {
            this.addIdentifiedPlannedAbsence(_JmgPlannedAbsenceParameters.parmLowerLimitSeconds(), _JmgPlannedAbsenceParameters.parmUpperLimitSeconds(), profileSecondsFrom, profileSecondsTo, _absenceCalendar.JobId);

            _JmgPlannedAbsenceParameters.parmLowerLimitSeconds(profileSecondsTo);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFlexProfile</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the loaded profile is a flex profile.
    /// </summary>
    /// <param name="profileNo">
    ///    The number of the profile to check.
    /// </param>
    /// <returns>
    ///    true if the loaded profile is a flex profile; otherwise, false.
    /// </returns>
    boolean isFlexProfile(Integer profileNo = 0)
    {
        if (profileNo == 0)
            profileNo = getProfileCurProfile;

        return (profileNo ? getProfileHaveFlex_Head[profileNo] : false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadEventCodes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads switch codes, which have been registered by the worker at the profile date.
    /// </summary>
    /// <param name="jmgStampJournalTable">
    /// The <c>JmgStampJournalTable</c> record, which is the header for the calculation.
    /// </param>
    void loadEventCodes(JmgStampJournalTable jmgStampJournalTable)
    {
        eventCodeSet = JmgEventCtrl::getEventCodeSet(jmgStampJournalTable.Worker, jmgStampJournalTable.ProfileDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>manipulateTimeEvents</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts events in the internal event table from one profile specification type to another.
    /// </summary>
    /// <param name="inSecs">
    ///    The period of time for which to convert events.
    /// </param>
    /// <param name="oldProfType">
    ///    The profile specification type from which to convert.
    /// </param>
    /// <param name="newProfType">
    ///    The profile specification type to which to convert.
    /// </param>
    /// <param name="_ascending">
    ///    A Boolean value that specifies whether events must be converted in ascending order.
    /// </param>
    void manipulateTimeEvents(JmgSeconds inSecs,JmgProfileSpecTypeEnum oldProfType,JmgProfileSpecTypeEnum newProfType, boolean _ascending = false)
    {
        Integer wrkEventTab;
        Integer i;

        if (_ascending)
        {
            for (wrkEventTab = 1;wrkEventTab <= getProfileEventTab_Cnt; wrkEventTab++)
            {
                if (((getProfileEventTab_StampSpec[wrkEventTab] == JmgStampTypeSpecEnum::Work)          ||
                     (getProfileEventTab_StampSpec[wrkEventTab] == JmgStampTypeSpecEnum::BreakPayFlow)  )   &&
                    (getProfileEventTab_Type[wrkEventTab]       == oldProfType))
                {
                    timeEventSec = max(0,(getProfileEventTab_UppLim[wrkEventTab] - getProfileEventTab_LowLim[wrkEventTab]));
                    if (timeEventSec > inSecs)
                    {
                        getProfileEventTab_Cnt++;
                        for (i = getProfileEventTab_Cnt - 1; i >= wrkEventTab; i--)
                        {
                            getProfileEventTab_Type[i + 1]         = getProfileEventTab_Type[i];
                            getProfileEventTab_LowLim[i + 1]       = getProfileEventTab_LowLim[i] + 1;
                            getProfileEventTab_UppLim[i + 1]       = getProfileEventTab_UppLim[i] + 1;
                            getProfileEventTab_Sec[i + 1]          = getProfileEventTab_Sec[i];
                            getProfileEventTab_StampSpec[i + 1]    = getProfileEventTab_StampSpec[i];
                            getProfileEventTab_Trid[i + 1]         = getProfileEventTab_Trid[i];
                            getProfileEventTab_JobPayType[i + 1]   = getProfileEventTab_JobPayType[i];
                            getProfileEventTab_DefaultDimension[i + 1]    = getProfileEventTab_DefaultDimension[i];
                            getProfileEventTab_ProfileType[i + 1]    = getProfileEventTab_ProfileType[i];
                        }

                        getProfileEventTab_LowLim   [wrkEventTab + 1] += inSecs;
                        getProfileEventTab_Sec      [wrkEventTab + 1] -= inSecs;

                        getProfileEventTab_Type[wrkEventTab]         = newProfType;
                        //getProfileEventTab_LowLim[wrkEventTab] already has the correct value.
                        getProfileEventTab_UppLim[wrkEventTab]       = getProfileEventTab_LowLim[wrkEventTab + 1] - 1;
                        getProfileEventTab_Sec[wrkEventTab]          = inSecs;
                        getProfileEventTab_StampSpec[wrkEventTab]    = getProfileEventTab_StampSpec[wrkEventTab + 1];
                        getProfileEventTab_Trid[wrkEventTab]         = getProfileEventTab_Trid[wrkEventTab + 1];
                        getProfileEventTab_JobPayType[wrkEventTab]   = getProfileEventTab_JobPayType[wrkEventTab + 1];
                        getProfileEventTab_DefaultDimension[wrkEventTab]    = getProfileEventTab_DefaultDimension[wrkEventTab + 1];
                        getProfileEventTab_ProfileType[wrkEventTab]  = getProfileEventTab_ProfileType[wrkEventTab + 1];
                        inSecs                                       = 0;
                        break;
                    }
                    else
                    {
                        getProfileEventTab_Type[wrkEventTab]                    = newProfType;
                        inSecs                                                 -= timeEventSec;
                    }
                }
            }
        }
        else
        {
            for (wrkEventTab = getProfileEventTab_Cnt;wrkEventTab > 0; wrkEventTab--)
            {
                if (((getProfileEventTab_StampSpec[wrkEventTab] == JmgStampTypeSpecEnum::Work)          ||
                     (getProfileEventTab_StampSpec[wrkEventTab] == JmgStampTypeSpecEnum::BreakPayFlow)  )   &&
                    (getProfileEventTab_Type[wrkEventTab]       == oldProfType))
                {
                    timeEventSec = max(0,(getProfileEventTab_UppLim[wrkEventTab] - getProfileEventTab_LowLim[wrkEventTab]));
                    if (timeEventSec > inSecs)
                    {
                        getProfileEventTab_UppLim   [wrkEventTab]              -= inSecs;
                        getProfileEventTab_Sec      [wrkEventTab]              -= inSecs;
                        getProfileEventTab_Cnt++;
                        getProfileEventTab_Type[getProfileEventTab_Cnt]         = newProfType;
                        getProfileEventTab_LowLim[getProfileEventTab_Cnt]       = getProfileEventTab_UppLim[wrkEventTab] + 1;
                        getProfileEventTab_UppLim[getProfileEventTab_Cnt]       = getProfileEventTab_UppLim[wrkEventTab] + inSecs + 1;
                        getProfileEventTab_Sec[getProfileEventTab_Cnt]          = inSecs;
                        getProfileEventTab_StampSpec[getProfileEventTab_Cnt]    = getProfileEventTab_StampSpec[wrkEventTab];
                        getProfileEventTab_Trid[getProfileEventTab_Cnt]         = getProfileEventTab_Trid[wrkEventTab];
                        getProfileEventTab_JobPayType[getProfileEventTab_Cnt]   = getProfileEventTab_JobPayType[wrkEventTab];
                        getProfileEventTab_DefaultDimension[getProfileEventTab_Cnt]    = getProfileEventTab_DefaultDimension[wrkEventTab];
                        getProfileEventTab_ProfileType[getProfileEventTab_Cnt]  = getProfileEventTab_ProfileType[wrkEventTab];
                        inSecs                                                  = 0;
                    }
                    else
                    {
                        getProfileEventTab_Type[wrkEventTab]                    = newProfType;
                        inSecs                                                 -= timeEventSec;
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>JmgProfiles</c> class.
    /// </summary>
    /// <param name="isApproveMode">
    ///    A Boolean value that indicates whether the calculation is run in approve mode.
    /// </param>
    /// <param name="isSimulation">
    ///    A Boolean value that indicates whether the calculation is run in simulated mode.
    /// </param>
    /// <param name="simEndDate">
    ///    The end date for the simulated calculation.
    /// </param>
    /// <param name="simEndTime">
    ///    The end time for the simulated calculation.
    /// </param>
    void new(boolean        isApproveMode   = false,
             boolean        isSimulation    = false,
             StartDate      simEndDate      = dateNull(),
             JmgSeconds     simEndTime      = 0)
    {
        chkTransId          = JmgProfiles::noTransID();
        jmgBreaks           = new JmgBreaks();
        chkTime             = 0;
        chkType             = -1;
        chkSignedInOk       = false;
        chkChronologyErr    = false;
        chkTransIdErr       = false;
        chkAbsenceOrFlexConfigErr = false;

        approveMode         = isApproveMode;

        simulationMode      = isSimulation;
        simulationEndDate   = simEndDate;
        simulationEndTime   = simEndTime;

        signInCount         = 0;
        signOutCount        = 0;

        chkClockInOutStatus = 2;
        eventCodeSet        = new Set(Types::String);
        jmgBreakRegistrationsFlightEnabled = JmgBreakRegistrationsFlight::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundOvertime</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Modifies the internal event table to account for rounding of overtime.
    /// </summary>
    /// <param name="jmgStampJournalTable">
    ///    The <c>JmgStampJournalTable</c> record, which is the header for the calculation.
    /// </param>
    void roundOvertime(JmgStampJournalTable jmgStampJournalTable)
    {
        Integer                 getProfileToTmp;
        JmgPayAgreementTable    jmgPayAgreementTable;
        JmgSeconds              overTimeSeconds;
        JmgSeconds              overTimeSecondsDiff;
        select firstonly PayAgreement, OverTimeRound, RecId, OverTimeRoundType from jmgPayAgreementTable where jmgPayAgreementTable.PayAgreement == jmgStampJournalTable.PayAgreement;
        if ( !( (jmgPayAgreementTable) && (jmgPayAgreementTable.OverTimeRound)))
            return;

        overTimeSeconds     = jmgStampJournalTable.PayOverTimeSeconds;
        overTimeSecondsDiff = 0;
        switch (jmgPayAgreementTable.OverTimeRoundType)
        {
            case JmgRoundTypeEnum::RoundUp :
                overTimeSeconds = any2int(round(overTimeSeconds + (jmgPayAgreementTable.OverTimeRound/2.00001), jmgPayAgreementTable.OverTimeRound));
                break;
            case JmgRoundTypeEnum::RoundDown :
                overTimeSeconds = any2int(round(overTimeSeconds - (jmgPayAgreementTable.OverTimeRound/2.00001), jmgPayAgreementTable.OverTimeRound));
                break;
            case JmgRoundTypeEnum::Minimum :
                if (overTimeSeconds < jmgPayAgreementTable.OverTimeRound)
                {
                    overTimeSeconds = any2int(round(overTimeSeconds + (jmgPayAgreementTable.OverTimeRound/2.00001), jmgPayAgreementTable.OverTimeRound));
                }
                break;
            case JmgRoundTypeEnum::Normal :
                overTimeSeconds = any2int(round(overTimeSeconds, jmgPayAgreementTable.OverTimeRound));
                break;
        }

        if (overTimeSeconds == jmgStampJournalTable.PayOverTimeSeconds)
            return;

        overTimeSecondsDiff = any2int(abs(overTimeSeconds - jmgStampJournalTable.PayOverTimeSeconds));
        getProfileToTmp = getProfileEventTab_Cnt;
        while (getProfileToTmp > 0)
        {
            if ((getProfileEventTab_StampSpec[getProfileToTmp]    == JmgStampTypeSpecEnum::Work       ) &&
                (getProfileEventTab_Type[getProfileToTmp]         == JmgProfileSpecTypeEnum::OverTime ))
            {
                timeEventSec = max(0,(getProfileEventTab_UppLim[getProfileToTmp]-getProfileEventTab_LowLim[getProfileToTmp]));
                if ((overTimeSeconds - jmgStampJournalTable.PayOverTimeSeconds) < 0)
                {
                    if (timeEventSec > overTimeSecondsDiff)
                    {
                        getProfileEventTab_UppLim[getProfileToTmp] -= overTimeSecondsDiff;
                        getProfileEventTab_Sec[getProfileToTmp]    -= overTimeSecondsDiff;
                        overTimeSecondsDiff                         =  0;
                    }
                    else
                    {
                        getProfileEventTab_UppLim[getProfileToTmp]  =  0;
                        getProfileEventTab_LowLim[getProfileToTmp]  =  0;
                        getProfileEventTab_Sec[getProfileToTmp]     =  0;
                        overTimeSecondsDiff                         -= timeEventSec;
                    }
                }
                else
                {
                    getProfileEventTab_UppLim[getProfileToTmp]    += overTimeSecondsDiff;
                    getProfileEventTab_Sec[getProfileToTmp]       += overTimeSecondsDiff;
                    overTimeSecondsDiff                         =  0;
                }
            }
            getProfileToTmp--;
        }
        jmgStampJournalTable.PaySeconds         += (overTimeSeconds - jmgStampJournalTable.PayOverTimeSeconds);
        jmgStampJournalTable.PayOverTimeSeconds += (overTimeSeconds - jmgStampJournalTable.PayOverTimeSeconds);
        jmgStampJournalTable.PaySeconds         =  max(jmgStampJournalTable.PaySeconds,0);
        jmgStampJournalTable.PayOverTimeSeconds =  max(jmgStampJournalTable.PayOverTimeSeconds,0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAllocationKey</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the allocation key to use, when allocating time to registrations in a bundle.
    /// </summary>
    /// <param name="_jmgStampJournalTrans">
    ///    The <c>JmgStampJournalTrans</c> record for which to set the allocation key.
    /// </param>
    /// <remarks>
    ///    The allocation key is saved in the internal bundle variables.
    /// </remarks>
    private void setAllocationKey(JmgStampJournalTrans _jmgStampJournalTrans)
    {
        JmgJobTypeEnum  allocationKey;
        int             i;
        int             maxCount;
        int             currentCount;

        container       newAllocationKeyCount;

        // Find the next allocation key
        if ((_jmgStampJournalTrans.JourRegType != JmgJourRegTypeEnum::MrpSetup) &&
           (_jmgStampJournalTrans.JourRegType != JmgJourRegTypeEnum::MrpProcess))
        {
            allocationKey = JmgJobTypeEnum::Bundle3;
        }
        else
        {
            allocationKey   = JmgBundleSlize::findAllocationKey(_jmgStampJournalTrans.WrkCtrId, _jmgStampJournalTrans.ProfileDate);
        }

        // Add to allocation key sum. Check and initialize container for counters.
        if (!bundleAllocationkeyCount[bundlePointer])
        {
            newAllocationKeyCount = connull();
            for (i = 1; i <= enumcnt(JmgJobTypeEnum); i++)
            {
                newAllocationKeyCount = conins(newAllocationKeyCount, conlen(newAllocationKeyCount) + 1, 0);
            }
            bundleAllocationKeyCount[bundlePointer] = newAllocationKeyCount;
        }
        // Add to the correct allocation.
        bundleAllocationKeyCount[bundlePointer] =
            conpoke(bundleAllocationkeyCount[bundlePointer],
                    allocationKey + 1,
                    conpeek(bundleAllocationkeyCount[bundlePointer], allocationKey + 1) + 1);

        // Assign the allocation key to use for this bundle
        maxCount = 0;
        for (i = 1; i <= enumcnt(JmgJobTypeEnum); i++)
        {
            currentCount = conpeek(bundleAllocationkeyCount[bundlePointer], i);
            if (maxCount < currentCount)
            {
                maxCount = currentCount;
                allocationKey = i - 1; // Enumeration elements starts from 0.
            }
        }
        bundleType[bundlePointer] = allocationKey;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setClockInOutErr</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates whether an error is caused by missing clock in or clock out registrations has occurred.
    /// </summary>
    /// <param name="_chkClockInOutErr">
    ///    A Boolean value that specifies whether a missing clock-in or clock-out registration has been
    ///    detected.
    /// </param>
    void setClockInOutErr(boolean _chkClockInOutErr)
    {
        chkClockInOutErr = _chkClockInOutErr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNewTransId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new transaction id for a bundle.
    /// </summary>
    void setNewTransId()
    {
        newTransId  = int2str(str2int(newTransId)+1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSignInOutTransId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks the registration for chronology errors
    /// </summary>
    /// <param name="jmgStampJournalTrans">
    ///    The <c>JmgStampJournalTrans</c> record to check for chronology errors.
    /// </param>
    /// <remarks>
    ///    Any errors that are detected are set in the internal variables.
    /// </remarks>
    void setSignInOutTransId(JmgStampJournalTrans jmgStampJournalTrans)
    {
        JmgProfileSeconds   profSec = new JmgProfileSeconds();

        switch (jmgStampJournalTrans.StampType)
        {
            case JmgStampTypeEnum::Error :
                jmgStampJournalTrans.Log    = "@SYS39311";
                tmpSaveModule               = 0;
                break;

            case JmgStampTypeEnum::Work :
                switch (jmgStampJournalTrans.JourRegType)
                {
                    case JmgJourRegTypeEnum::SignIn         :
                        if (this.signInStatus())
                        {
                            jmgStampJournalTrans.Log    = strfmt("@SYS39312",JmgStampTypeSpecEnum::SignIn);
                        }
                        this.setNewTransId();
                        this.signInStatus(true);

                        signInCount++;
                        [correctSignInDate[signInCount], correctSignInTime[signInCount]] = this.getToleranceAdjustedTime(jmgStampJournalTrans.ProfileDate, jmgStampJournalTrans.StartDate, jmgStampJournalTrans.StartTime, true, JmgProfileSpecTypeEnum::SignIn);
                        if (correctSignInDate[signInCount] == jmgStampJournalTrans.StartDate && correctSignInTime[signInCount] == jmgStampJournalTrans.StartTime)
                        {
                            [correctSignInDate[signInCount], correctSignInTime[signInCount]] = this.getToleranceAdjustedTime(jmgStampJournalTrans.ProfileDate, jmgStampJournalTrans.StartDate, jmgStampJournalTrans.StartTime, false, JmgProfileSpecTypeEnum::SignIn);
                        }
                        tmpSaveModule           = 0;
                        break;

                    case JmgJourRegTypeEnum::SignOut        :
                        if (! this.signInStatus())
                        {
                            jmgStampJournalTrans.Log    = strfmt("@SYS39312",JmgStampTypeSpecEnum::SignOut);
                        }

                        this.setNewTransId();
                        this.signInStatus(false);
                        signOutCount++;
                        [correctSignOutDate[signOutCount], correctSignOutTime[signOutCount]] = this.getToleranceAdjustedTime(jmgStampJournalTrans.ProfileDate, jmgStampJournalTrans.StartDate, jmgStampJournalTrans.StartTime, true, JmgProfileSpecTypeEnum::SignOut);
                        if (correctSignOutDate[signOutCount] == jmgStampJournalTrans.StartDate && correctSignOutTime[signOutCount] == jmgStampJournalTrans.StartTime)
                        {
                            [correctSignOutDate[signOutCount], correctSignOutTime[signOutCount]] = this.getToleranceAdjustedTime(jmgStampJournalTrans.ProfileDate, jmgStampJournalTrans.StartDate, jmgStampJournalTrans.StartTime, false, JmgProfileSpecTypeEnum::SignOut);
                        }
                        tmpSaveModule           = 0;
                        break;

                    case JmgJourRegTypeEnum::IndActivity    :
                    case JmgJourRegTypeEnum::MrpQueueBefore :
                    case JmgJourRegTypeEnum::MrpSetup       :
                    case JmgJourRegTypeEnum::MrpProcess     :
                    case JmgJourRegTypeEnum::MrpOverlap     :
                    case JmgJourRegTypeEnum::MrpTransport   :
                    case JmgJourRegTypeEnum::MrpQueueAfter  :
                    case JmgJourRegTypeEnum::PrjProject     :
                    case JmgJourRegTypeEnum::PrjActivity    :
                    case JmgJourRegTypeEnum::StartTeam      :
                    case JmgJourRegTypeEnum::StopTeam       :
                        if (! this.signInStatus())
                        {
                            jmgStampJournalTrans.Log    = "@SYS39313";
                        }
                        if ((jmgStampJournalTrans.Module        != tmpSaveModule)                   ||
                            (jmgStampJournalTrans.JourRegType   == JmgJourRegTypeEnum::StartTeam)   ||
                            (jmgStampJournalTrans.JourRegType   == JmgJourRegTypeEnum::StopTeam)    ||
                            (jmgStampJournalTrans.Module        == JmgModuleEnum::IPC)              ||
                            (jmgStampJournalTrans.Module        == JmgModuleEnum::PROJ))
                        {
                            this.setNewTransId();
                        }
                        else
                        {
                            if (profSec.profileSeconds(jmgStampJournalTrans.StartDate,jmgStampJournalTrans.StartTime) >= tmpSaveStopDateTime)
                            {
                                this.setNewTransId();
                            }
                        }
                        tmpSaveModule   = jmgStampJournalTrans.Module;
                        break;
                }
                break;

            case JmgStampTypeEnum::Absence :
                if (this.signInStatus())
                {
                    jmgStampJournalTrans.Log    = "@SYS39314";
                }
                this.setNewTransId();
                tmpSaveModule   = jmgStampJournalTrans.Module;
                break;

            case JmgStampTypeEnum::Break :
                if (! this.signInStatus())
                {
                    jmgStampJournalTrans.Log    = "@SYS39315";
                }

                if (profSec.profileSeconds(jmgStampJournalTrans.StartDate, jmgStampJournalTrans.StartTime) >= tmpSaveStopDateTime)
                {
                    this.setNewTransId();
                    tmpSaveModule = jmgStampJournalTrans.Module;
                }
                break;
        }
        jmgStampJournalTrans.TransId            = newTransId;
        if ((jmgStampJournalTrans.TransId != tmpSaveTransId)
                && (tmpSaveTransId)
                && (jmgStampJournalTrans.JourRegType != JmgJourRegTypeEnum::BreakReg)
                && (profSec.profileSeconds(jmgStampJournalTrans.StartDate,jmgStampJournalTrans.StartTime) < tmpSaveStopDateTime))
        {
            jmgStampJournalTrans.Log            = "@SYS38452";
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTmpJobIdAbs</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the absence job ID used to create absence registrations in time gaps.
    /// </summary>
    /// <param name="_jobidAbs">
    ///    The ID of the absence code to use when an absence registration is created.
    /// </param>
    /// <param name="_stampJournal">
    ///    The <c>JmgStampJournalTrans</c> record which is used to determine whether the internal absence job
    ///    ID variable is updated.
    /// </param>
    void setTmpJobIdAbs(JmgJobIDAbs _jobidAbs, JmgStampJournalTrans _stampJournal)
    {
        if (_stampJournal.JourRegType == JmgJourRegTypeEnum::SignIn)
        {
            tmpJobidAbs     = _jobidAbs ? _jobidAbs : tmpJobidAbs;
            tmpJobidAbsNorm = _jobidAbs ? _jobidAbs : tmpJobidAbsNorm;
            fromDatetimeSignin = _stampJournal.StartTime;
        }

        if (_stampJournal.JourRegType == JmgJourRegTypeEnum::SignOut)
        {
            tmpJobidAbs     = _jobidAbs;
            tmpJobidAbsNorm = _jobidAbs ? _jobidAbs : tmpJobidAbsNorm;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTmpvariables</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the last added transaction ID, record ID, and registration time.
    /// </summary>
    /// <param name="jmgStampJournalTrans">
    /// The last added registration.
    /// </param>
    void setTmpvariables(JmgStampJournalTrans jmgStampJournalTrans)
    {
        JmgProfileSeconds   profSec = new JmgProfileSeconds();

        tmpSaveTransId          = jmgStampJournalTrans.TransId;

        if (jmgStampJournalTrans.JourRegType == JmgJourRegTypeEnum::Absence)
        {
            if (profSec.profileSeconds(jmgStampJournalTrans.StartDate,jmgStampJournalTrans.StartTime) >  tmpSaveStopDateTime)
               tmpSaveStopDateTime     = profSec.profileSeconds();
        }
        else
        {
            if (profSec.profileSeconds(jmgStampJournalTrans.StopDate,jmgStampJournalTrans.StopTime) >  tmpSaveStopDateTime)
               tmpSaveStopDateTime     = profSec.profileSeconds();
        }

        if ((jmgStampJournalTrans.JourRegType   == JmgJourRegTypeEnum::Absence) ||
            ((jmgStampJournalTrans.JourRegType  == JmgJourRegTypeEnum::IndActivity) &&
             (jmgStampJournalTrans.JobId        == JmgIpcActivity::findSignTypeJobId(JmgSignInOut::SysIndirect)))) // ThySol/Upg3
        {
            tmpLastRecId = jmgStampJournalTrans.RecId;
        }
        else
        {
            tmpLastRecId = 0;
        }

        if (jmgStampJournalTrans.JobPayType == JmgJobPayTypeEnum::PieceRate)
            payBonusCalcOk = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shiftSignInOutBundle</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Adjust all the bundles based on adjusted specified start date and time of clock-in or clock-out which has been adjusted according to the
    /// profile setup.
    /// </summary>
    /// <param name="shiftBundlePointer">
    ///   The bundle pointer of clockin or clockout.
    /// </param>
    /// <param name="fromSeconds">
    ///   The specified start date and time of clockin or clockout.
    /// </param>
    /// <param name="toSeconds">
    ///   Corrected seconds of sign in or sign out which has been adjusted according to the
    /// profile setup.
    /// </param>
    /// <param name="shiftToRight">
    ///   Default to shift to right.
    /// </param>
    private void shiftSignInOutBundle(Integer shiftBundlePointer, JmgSeconds fromSeconds, JmgSeconds toSeconds, boolean shiftToRight = true)
    {
        Integer localBundlePointer = 1;

        bundleStartDateTimeCorr[shiftBundlePointer] = toSeconds;
        bundleEndDateTimeCorr[shiftBundlePointer]   = toSeconds;

        while (bundle[localBundlePointer])
        {
            if (localBundlePointer == shiftBundlePointer)
            {
                localBundlePointer++;
                continue;
            }

            if (shiftToRight)
            {
                if (bundleStartDateTimeCorr[localBundlePointer] >= fromSeconds && bundleStartDateTimeCorr[localBundlePointer] <= toSeconds)
                {
                    bundleStartDateTimeCorr[localBundlePointer] = toSeconds;
                }
                if (bundleEndDateTimeCorr[localBundlePointer] >= fromSeconds && bundleEndDateTimeCorr[localBundlePointer] <= toSeconds)
                {
                    bundleEndDateTimeCorr[localBundlePointer] = toSeconds;
                }
            }
            else
            {
                if (bundleStartDateTimeCorr[localBundlePointer] <= fromSeconds && bundleStartDateTimeCorr[localBundlePointer] >= toSeconds)
                {
                    bundleStartDateTimeCorr[localBundlePointer] = toSeconds;
                }
                if (bundleEndDateTimeCorr[localBundlePointer] <= fromSeconds && bundleEndDateTimeCorr[localBundlePointer] >= toSeconds)
                {
                    bundleEndDateTimeCorr[localBundlePointer] = toSeconds;
                }
            }

            localBundlePointer++;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>signInStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the clocked in status of the last added registration.
    /// </summary>
    /// <param name="setvalue">
    ///    A Boolean value that specifies whether the last added registration was in clocked in status.
    /// </param>
    /// <returns>
    ///    true if the last added registration was in clocked in status; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The must only be specified, when the clocked in status is to be changed.To read the current clocked
    ///    in status, the must not be specified.
    /// </remarks>
    boolean signInStatus(boolean setvalue = false)
    {
        if (! prmisdefault(setvalue))
            clockInOutStatus = setvalue;

        return clockInOutStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>signOutStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the clocked out status of the last added registration.
    /// </summary>
    /// <returns>
    ///    true if the last added registration was in clocked out status; otherwise, false.
    /// </returns>
    boolean signOutStatus()
    {
        return !this.signInStatus();
    }

]]></Source>
			</Method>
			<Method>
				<Name>simulateSetSignInOutTransId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks the registration for chronology errors when a simulated calculation run.
    /// </summary>
    /// <param name="jmgStampJournalTrans">
    ///    The <c>JmgStampJournalTrans</c> record to check for chronology errors.
    /// </param>
    /// <param name="simTransEndDate">
    ///    The end date to use in the simulated calculation
    /// </param>
    /// <param name="simTransEndTime">
    ///    The end time to use in the simulated calculation.
    /// </param>
    /// <remarks>
    ///    Any errors that are detected are set in the internal variables.
    /// </remarks>
    void simulateSetSignInOutTransId(JmgStampJournalTrans jmgStampJournalTrans, StartDate simTransEndDate, JmgSeconds simTransEndTime)
    {
        JmgProfileSeconds   profSec = new JmgProfileSeconds();

        if ((jmgStampJournalTrans.StampType == JmgStampTypeEnum::Work)                      &&
            ((jmgStampJournalTrans.JourRegType == JmgJourRegTypeEnum::MrpQueueBefore)   ||
             (jmgStampJournalTrans.JourRegType == JmgJourRegTypeEnum::MrpSetup)         ||
             (jmgStampJournalTrans.JourRegType == JmgJourRegTypeEnum::MrpProcess)       ||
             (jmgStampJournalTrans.JourRegType == JmgJourRegTypeEnum::MrpTransport)     ||
             (jmgStampJournalTrans.JourRegType == JmgJourRegTypeEnum::MrpQueueAfter)    ||
             (jmgStampJournalTrans.JourRegType == JmgJourRegTypeEnum::MrpOverlap)       ||
             (jmgStampJournalTrans.JourRegType == JmgJourRegTypeEnum::PrjProject)       ||
             (jmgStampJournalTrans.JourRegType == JmgJourRegTypeEnum::PrjActivity)      ||
             (jmgStampJournalTrans.JourRegType == JmgJourRegTypeEnum::IndActivity))   )
        {
            if ((jmgStampJournalTrans.Module        != tmpSaveModule) ||
                (jmgStampJournalTrans.JourRegType   == JmgJourRegTypeEnum::StartTeam)||
                (jmgStampJournalTrans.JourRegType   == JmgJourRegTypeEnum::StopTeam))
            {
                this.setNewTransId();
            }
            else
            {
                if (profSec.profileSeconds(jmgStampJournalTrans.StartDate,jmgStampJournalTrans.StartTime) >= tmpSaveStopDateTime)
                {
                    this.setNewTransId();
                }
            }
            tmpSaveModule   = jmgStampJournalTrans.Module;

            //SET ESTIMATED TIMe
        }
        jmgStampJournalTrans.TransId            = newTransId;
        if ((jmgStampJournalTrans.TransId != tmpSaveTransId) && (tmpSaveTransId) &&
            (profSec.profileSeconds(jmgStampJournalTrans.StartDate,jmgStampJournalTrans.StartTime) < tmpSaveStopDateTime))
        {
            jmgStampJournalTrans.Log            = "@SYS38452";
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>simulatesetTmpvariables</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the last added transaction ID, record ID, and registration time when a simulated
    ///    calculation is run.
    /// </summary>
    /// <param name="jmgStampJournalTrans">
    ///    The last added registration.
    /// </param>
    /// <param name="simTransEndDate">
    ///    The end date of the simulated calculation.
    /// </param>
    /// <param name="simTransEndTime">
    ///    The end time of the simulated calculation.
    /// </param>
    void simulatesetTmpvariables(JmgStampJournalTrans jmgStampJournalTrans,StartDate simTransEndDate, JmgSeconds simTransEndTime)
    {
        JmgProfileSeconds   profSec = new JmgProfileSeconds();

        tmpSaveTransId              = jmgStampJournalTrans.TransId;
        if (profSec.profileSeconds(simTransEndDate,simTransEndTime) >  tmpSaveStopDateTime)
            tmpSaveStopDateTime     = profSec.profileSeconds();

        if ((jmgStampJournalTrans.JourRegType   == JmgJourRegTypeEnum::Absence) ||
            ((jmgStampJournalTrans.JourRegType  == JmgJourRegTypeEnum::IndActivity) &&
             (JmgIpcActivity::findSignTypeJobId(JmgSignInOut::SysIndirect))))
        {
            tmpLastRecId            = jmgStampJournalTrans.RecId;
        }
        else
        {
            tmpLastRecId            = 0;
        }

        if (jmgStampJournalTrans.JobPayType == JmgJobPayTypeEnum::PieceRate)
            payBonusCalcOk          = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>simulationMode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the class is run in simulation mode.
    /// </summary>
    /// <returns>
    ///    true if the calculation is performed in simulated mode; otherwise, false.
    /// </returns>
    boolean simulationMode()
    {
        return simulationMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>slizeProfileFlexMinus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts flex-events into the internal event table.
    /// </summary>
    /// <param name="jmgStampJournalTable">
    ///    The <c>JmgStampJournalTable</c> record, which is the header for the calculation.
    /// </param>
    void slizeProfileFlexMinus(JmgStampJournalTable jmgStampJournalTable)
    {
        JmgProfileSeconds   profSec         = new JmgProfileSeconds();
        Integer             timeEventFrom;
        Integer             timeEventTo   = getProfileEventTab_Cnt;
        Integer             getProfileLowLimit;
        Integer             getProfileFromIdx   = getProfileFrom;
        Integer             getProfileToIdx     = getProfileTo;
        JmgProfileDate      profiledate         = jmgStampJournalTable.ProfileDate;

        while ((getProfileFromIdx && getProfileToIdx) && (getProfileFromIdx <= getProfileToIdx))
        {
            if (getProfileTimeType_Line[getProfileFromIdx] == JmgProfileSpecTypeEnum::FlexSub)
            {
                timeEventDate       = (profiledate + getProfileStartDay_Line[getProfileFromIdx]);
                timeEventLowLimit_P = profSec.profileSeconds(timeEventDate,getProfileStartTime_Line[getProfileFromIdx]);
                timeEventDate       = (profiledate + getProfileEndDay_Line[getProfileFromIdx]);
                timeEventUppLimit_P = profSec.profileSeconds(timeEventDate,getProfileEndTime_Line[getProfileFromIdx]);

                timeEventFrom     = 1;
                getProfileLowLimit = timeEventLowLimit_P;

                while (timeEventFrom <= timeEventTo)
                {
                    timeEventLowLimit_S = getProfileEventTab_LowLim[timeEventFrom];
                    timeEventUppLimit_S = getProfileEventTab_UppLim[timeEventFrom];

                    if (timeEventLowLimit_S >= timeEventUppLimit_P)
                    {
                        break;
                    }
                    else
                    {
                        if (((timeEventLowLimit_S >= getProfileLowLimit) && (timeEventLowLimit_S <= timeEventUppLimit_P)) ||
                            ((timeEventUppLimit_S >= getProfileLowLimit) && (timeEventUppLimit_S <= timeEventUppLimit_P)))
                        {
                            if ((timeEventLowLimit_S > getProfileLowLimit) && (timeEventLowLimit_S < timeEventUppLimit_P))
                            {
                                getProfileEventTab_Cnt++;
                                getProfileEventTab_Type     [getProfileEventTab_Cnt]  = JmgProfileSpecTypeEnum::FlexSub;
                                getProfileEventTab_LowLim   [getProfileEventTab_Cnt]  = getProfileLowLimit;
                                getProfileEventTab_UppLim   [getProfileEventTab_Cnt]  = timeEventLowLimit_S;
                                getProfileEventTab_Sec      [getProfileEventTab_Cnt]  = max(0,(getProfileEventTab_UppLim[getProfileEventTab_Cnt]-getProfileEventTab_LowLim[getProfileEventTab_Cnt]));
                                getProfileEventTab_StampSpec[getProfileEventTab_Cnt]  = JmgStampTypeSpecEnum::FlexNoWork;
                                getProfileEventTab_Trid     [getProfileEventTab_Cnt]  = JmgProfiles::noTransID();
                                getProfileEventTab_DefaultDimension[getProfileEventTab_Cnt]  = 0;
                            }
                            getProfileLowLimit = timeEventUppLimit_S;
                        }
                    }
                    timeEventFrom++;
                }
                if (getProfileLowLimit < timeEventUppLimit_P)
                {
                    getProfileEventTab_Cnt++;
                    getProfileEventTab_Type     [getProfileEventTab_Cnt] = JmgProfileSpecTypeEnum::FlexSub;
                    getProfileEventTab_LowLim   [getProfileEventTab_Cnt] = getProfileLowLimit;
                    getProfileEventTab_UppLim   [getProfileEventTab_Cnt] = timeEventUppLimit_P;
                    getProfileEventTab_Sec      [getProfileEventTab_Cnt] = max(0,(getProfileEventTab_UppLim[getProfileEventTab_Cnt]-getProfileEventTab_LowLim[getProfileEventTab_Cnt]));
                    getProfileEventTab_StampSpec[getProfileEventTab_Cnt] = JmgStampTypeSpecEnum::FlexNoWork;
                    getProfileEventTab_Trid     [getProfileEventTab_Cnt] = JmgProfiles::noTransID();
                    getProfileEventTab_DefaultDimension[getProfileEventTab_Cnt] = 0;
                }
            }
            getProfileFromIdx++;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumerizeCalc</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Summarizes the events in the internal event table and writes the calculation result to the
    ///    <c>JmgStampJournalTable</c> record.
    /// </summary>
    /// <param name="jmgStampJournalTable">
    ///    The <c>JmgStampJournalTable</c> record to which to write the calculation result.
    /// </param>
    void sumerizeCalc(JmgStampJournalTable jmgStampJournalTable)
    {
        JmgSeconds  s;
        calcSumOvtRounded                       = 0;
        calcSumOvtRoundedDiff                   = 0;
        calcSumOvtFlexCorrect                   = 0;
        calcSumWorkTime                         = 0;
        calcSumPayTime                          = 0;
        calcSumPayOverTime                      = 0;
        calcSumAbsLegal                         = 0;
        calcSumAbsIllegal                       = 0;
        calcSumFlexAdd                          = 0;
        calcSumFlexSub                          = 0;
        calcSumNonPaidBreaks                    = 0;
        calcSumPaidBreaks                       = 0;

        this.sumerizeCalcTimeCodes();

        jmgStampJournalTable.WorkSeconds                = calcSumWorkTime;
        jmgStampJournalTable.PaySeconds                 = calcSumPayTime;
        jmgStampJournalTable.PayOverTimeSeconds         = calcSumPayOverTime;
        jmgStampJournalTable.PayFlexAddSeconds          = calcSumFlexAdd;
        jmgStampJournalTable.PayFlexSubSeconds          = calcSumFlexSub;
        jmgStampJournalTable.PayLegalAbsenceSeconds     = calcSumAbsLegal;
        jmgStampJournalTable.PayIllegalAbsenceSeconds   = calcSumAbsIllegal;
        jmgStampJournalTable.PayAbsenceSeconds          = calcSumAbsLegal + calcSumAbsIllegal;
        if (jmgStampJournalTable.Approved == NoYes::No)
        {
            jmgStampJournalTable.NonPaidBreakSeconds    = calcSumNonPaidBreaks;
        }
        jmgStampJournalTable.PaidBreakSeconds           = calcSumPaidBreaks;

        // Handle norm time profile:
        if (jmgStampJournalTable.NormSec)
        {
            this.handleNormTimeProfile(jmgStampJournalTable);
        }

        // Deduct illegal absence from overtime
        s = jmgStampJournalTable.PayOverTimeSeconds;
        jmgStampJournalTable.PayOverTimeSeconds = max(0, jmgStampJournalTable.PayOverTimeSeconds - calcSumAbsIllegal);
        this.manipulateTimeEvents(s - jmgStampJournalTable.PayOverTimeSeconds, JmgProfileSpecTypeEnum::OverTime, JmgProfileSpecTypeEnum::WorkTime);

        if (jmgStampJournalTable.PayOverTimeSeconds)
        {
            this.roundOvertime(jmgStampJournalTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumerizeCalcTimeCodes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Summarizes the events in the internal event table
    /// </summary>
    void sumerizeCalcTimeCodes()
    {
        Integer                 wrkEventTab;
        JmgTimeCalcParmeters    jmgTimeCalcParmeters;
        JmgTimeCalcParmeters    secondaryTimeCalcParmeters;

        for (wrkEventTab = 1;wrkEventTab <= getProfileEventTab_Cnt; wrkEventTab++)
        {         
            select firstonly jmgTimeCalcParmeters
                where jmgTimeCalcParmeters.StampTypeSpec        == getProfileEventTab_StampSpec[wrkEventTab] &&
                      jmgTimeCalcParmeters.ProfileSpecType      == getProfileEventTab_Type[wrkEventTab];

            if (getProfileEventTab_Type[wrkEventTab]            == JmgProfileSpecTypeEnum::BreakPay &&
                getProfileEventTab_SecondaryType[wrkEventTab]   != JmgProfileSpecTypeEnum::Blank)
            {
                select firstonly secondaryTimeCalcParmeters
                    where secondaryTimeCalcParmeters.StampTypeSpec    == getProfileEventTab_StampSpec[wrkEventTab] &&
                          secondaryTimeCalcParmeters.ProfileSpecType  == getProfileEventTab_SecondaryType[wrkEventTab];
            }
            else
            {
                secondaryTimeCalcParmeters = null;
            }

            if (jmgTimeCalcParmeters)
            {
                if (jmgTimeCalcParmeters.CalcWorkTime)
                    calcSumWorkTime += getProfileEventTab_Sec[wrkEventTab];

                if (secondaryTimeCalcParmeters)
                    jmgTimeCalcParmeters.data(secondaryTimeCalcParmeters);

                if (jmgTimeCalcParmeters.CalcPayTime)
                {
                    calcSumPayTime += getProfileEventTab_Sec[wrkEventTab];
                }
                if (jmgTimeCalcParmeters.CalcPayOverTime)
                    calcSumPayOverTime += getProfileEventTab_Sec[wrkEventTab];
                if (jmgTimeCalcParmeters.CalcAbsLegalTime)
                    calcSumAbsLegal += getProfileEventTab_Sec[wrkEventTab];
                if (jmgTimeCalcParmeters.CalcAbsIllegalTime)
                    calcSumAbsIllegal += getProfileEventTab_Sec[wrkEventTab];
                if (jmgTimeCalcParmeters.CalcFlexAddTime)
                    calcSumFlexAdd += getProfileEventTab_Sec[wrkEventTab];
                if (jmgTimeCalcParmeters.CalcFlexSubTime)
                    calcSumFlexSub += getProfileEventTab_Sec[wrkEventTab];
            }

            if (getProfileEventTab_Type[wrkEventTab]        == JmgProfileSpecTypeEnum::Break        &&
                getProfileEventTab_StampSpec[wrkEventTab]   != JmgStampTypeSpecEnum::AbsIllegal     &&
                getProfileEventTab_StampSpec[wrkEventTab]   != JmgStampTypeSpecEnum::AbsIllegalFlex &&
                getProfileEventTab_StampSpec[wrkEventTab]   != JmgStampTypeSpecEnum::AbsLegal       &&
                getProfileEventTab_StampSpec[wrkEventTab]   != JmgStampTypeSpecEnum::AbsLegalFlex)
            {
                calcSumNonPaidBreaks += getProfileEventTab_Sec[wrkEventTab];
            }

            if (getProfileEventTab_Type[wrkEventTab]        == JmgProfileSpecTypeEnum::BreakPay     &&
                getProfileEventTab_StampSpec[wrkEventTab]   != JmgStampTypeSpecEnum::AbsIllegal     &&
                getProfileEventTab_StampSpec[wrkEventTab]   != JmgStampTypeSpecEnum::AbsIllegalFlex &&
                getProfileEventTab_StampSpec[wrkEventTab]   != JmgStampTypeSpecEnum::AbsLegal       &&
                getProfileEventTab_StampSpec[wrkEventTab]   != JmgStampTypeSpecEnum::AbsLegalFlex)
            {
                calcSumPaidBreaks += getProfileEventTab_Sec[wrkEventTab];
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePayAgreementLineMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the <c>JmgPayAgreementLineMap</c> buffer.
    /// </summary>
    /// <param name = "_jmgTransferEvents">
    /// A <c>JmgTransferEvents</c> record buffer.
    /// </param>
    /// <param name = "_jmgPayAgreementLineMap">
    /// A <c>_jmgPayAgreementLineMap</c> record buffer.
    /// </param>
    /// <param name = "_jmgStampJournalTable">
    /// A <c>JmgStampJournalTable</c> record buffer.
    /// </param>
    /// <param name = "_getProfileFromIdx">
    /// An integer value.
    /// </param>
    /// <returns>
    /// true if the <c>JmgPayAgreementLineMap</c> is valid; otherwise, false.
    /// </returns>
    protected boolean validatePayAgreementLineMap(JmgTransferEvents _jmgTransferEvents, JmgPayAgreementLineMap _jmgPayAgreementLineMap, JmgStampJournalTable _jmgStampJournalTable, Integer _getProfileFromIdx)
    {
        return ((_jmgPayAgreementLineMap.ProfileType    == 0 || _jmgPayAgreementLineMap.ProfileType   == getProfileEventTab_ProfileType[_getProfileFromIdx])
                        &&(_jmgPayAgreementLineMap.JobPayType   == getProfileEventTab_JobPayType[_getProfileFromIdx]  || _jmgPayAgreementLineMap.JobPayType == JmgJobPayTypeEnum::Empty)
                        && this.checkDelimitations(_jmgTransferEvents, _jmgPayAgreementLineMap, _jmgStampJournalTable)
                        && JmgTimeCalcParmeters::checkMustPay(getProfileEventTab_StampSpec[_getProfileFromIdx],getProfileEventTab_Type[_getProfileFromIdx], _jmgPayAgreementLineMap.PaySpecType, getProfileEventTab_SecondaryType[_getProfileFromIdx]));
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumPayEventsSec</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the amount of seconds, for which pay should be generated for the specified pay agreement
    ///    line.
    /// </summary>
    /// <param name="jmgTransferEvents">
    ///    A reference to the <c>JmgTransferEvents</c> object, which calculates the pay.
    /// </param>
    /// <param name="jmgPayAgreementLineMap">
    ///    The pay agreement line for which to calculate time.
    /// </param>
    /// <param name="jmgStampJournalTable">
    ///    The <c>JmgStampJournalTable</c> record for which to calculate time.
    /// </param>
    /// <returns>
    ///    The amount of seconds for which pay should be generated for the specified pay agreement line.
    /// </returns>
    JmgSeconds sumPayEventsSec(JmgTransferEvents        jmgTransferEvents,
                               JmgPayAgreementLineMap   jmgPayAgreementLineMap,
                               JmgStampJournalTable     jmgStampJournalTable)
    {
        Integer             payDayCode;
        JmgSeconds          payEventSec;
        JmgProfileSeconds   jmgProfileSeconds = new JmgProfileSeconds();
        Integer             getProfileFromIdx;
        Integer             getProfileToIdx;
        HcmWorker           hcmWorker;
        JmgEmployee         jmgEmployee;
        CompanyInfo         companyInfo;

        payDayCode          = (jmgPayAgreementLineMap.ProfileStartCode == JmgProfileStartCode::Next) ?  1 :
                              (jmgPayAgreementLineMap.ProfileStartCode == JmgProfileStartCode::Prev) ? -1 : 0;

        if ((!jmgPayAgreementLineMap.TimeFrom) && (!jmgPayAgreementLineMap.TimeTo))
        {
            timeEventDate       = (jmgStampJournalTable.ProfileDate - 7);
            timeEventLowLimit_P = jmgProfileSeconds.profileSeconds(timeEventDate,jmgPayAgreementLineMap.TimeFrom);
            timeEventDate       = (jmgStampJournalTable.ProfileDate + 7);
            timeEventUppLimit_P = jmgProfileSeconds.profileSeconds(timeEventDate,jmgPayAgreementLineMap.TimeTo);
        }
        else
        {
            timeEventDate       = (jmgStampJournalTable.ProfileDate + payDayCode);
            timeEventLowLimit_P = jmgProfileSeconds.profileSeconds(timeEventDate,jmgPayAgreementLineMap.TimeFrom);
            timeEventDate       = (jmgPayAgreementLineMap.TimeFrom >= jmgPayAgreementLineMap.TimeTo) ? (jmgStampJournalTable.ProfileDate + payDayCode + 1) : (jmgStampJournalTable.ProfileDate + payDayCode);
            timeEventUppLimit_P = jmgProfileSeconds.profileSeconds(timeEventDate,jmgPayAgreementLineMap.TimeTo);
        }

        payEventSec         = 0;
        getProfileFromIdx   = 1;
        getProfileToIdx     = getProfileEventTab_Cnt;

        hcmWorker = HcmWorker::find(jmgStampJournalTable.Worker);
        // Get the LegalEntity for the jmgEmployee associated to the hcmWorker
        select firstonly jmgEmployee
            where jmgEmployee.Worker == hcmWorker.RecId
        join RecId, DataArea from companyInfo
            where companyInfo.DataArea == jmgEmployee.DataAreaId;

        jmgTransferEvents.clearTimePrDim();

        if (!jmgPayAgreementLineMap.ForcePay)
        {
            while (getProfileFromIdx <= getProfileToIdx)
            {
                timeEventLowLimit_S = max(timeEventLowLimit_P,getProfileEventTab_LowLim[getProfileFromIdx]);
                timeEventUppLimit_S = min(timeEventUppLimit_P,getProfileEventTab_UppLim[getProfileFromIdx]);
                timeEventSec        = max(0,(timeEventUppLimit_S - timeEventLowLimit_S));
                if (timeEventSec > 0)
                {
                    jmgTransferEvents.getTRiDTimeOpr(getProfileEventTab_Trid[getProfileFromIdx]);

                    if (this.validatePayAgreementLineMap(jmgTransferEvents, jmgPayAgreementLineMap, jmgStampJournalTable,  getProfileFromIdx))
                    {
                        payEventSec += timeEventSec;
                        if (getProfileEventTab_StampSpec[getProfileFromIdx] == JmgStampTypeSpecEnum::FlexNoWork)
                        {
                            jmgTransferEvents.addTimePrDim(hcmWorker.getDefaultDimension(companyInfo.RecId), timeEventSec);
                        }
                        else
                        {
                            jmgTransferEvents.addTimePrDim(getProfileEventTab_DefaultDimension[getProfileFromIdx], timeEventSec);
                        }
                        jmgTransferEvents.addTRiDCost(getProfileEventTab_Trid[getProfileFromIdx],jmgPayAgreementLineMap.PaySpecType,getProfileEventTab_StampSpec[getProfileFromIdx],0,timeEventSec,(jmgPayAgreementLineMap.RouteOprId==''));
                    }
                }
                getProfileFromIdx++;
            }
        }
        else if (!jmgPayAgreementLineMap.SpecialDayId   ||
            jmgPayAgreementLineMap.SpecialDayId       ==
            JmgProfileCalendar::find(
                JmgEmployee::find(jmgStampJournalTable.Worker),
                jmgStampJournalTable.ProfileDate).SpecialDayId)
        {
            payEventSec += real2int(JmgPayAgreementLineMap::getFixedQty(jmgPayAgreementLineMap, this));
            jmgTransferEvents.addTimePrDim(hcmWorker.getDefaultDimension(companyInfo.RecId), payEventSec);
        }

        return payEventSec;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeEventBreakTimePay</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the amount of the calculated paid break time.
    /// </summary>
    /// <returns>
    ///    The amount of the calculated paid break time in seconds.
    /// </returns>
    JmgSeconds timeEventBreakTimePay()
    {
        return timeEventBrkTimePay;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeEventStampTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the amount of the calculated job time.
    /// </summary>
    /// <returns>
    ///    The amount of calculated job time in seconds.
    /// </returns>
    JmgSeconds timeEventStampTime()
    {
        return timeEventNetTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeGapsResetArray</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the internal time gap table.
    /// </summary>
    void timeGapsResetArray()
    {
        for (timeGapCnt = 1;timeGapCnt <= timeGapMax;timeGapCnt++)
        {
            timeGapLowLim[timeGapCnt]       = 0;
            timeGapUppLim[timeGapCnt]       = 0;
            timeGapRecId[timeGapCnt]        = 0;
            timeGapJobIdAbs[timeGapCnt]     = '';
            timeGapClockedInOut[timeGapCnt] = false;
        }

        timeGapCnt                          = 0;
        timeGapMax                          = 0;
        timeGapLL                           = 0;
        timeGapUL                           = 0;
        timeGapStartTime                    = 0;
        timeGapEndTime                      = 0;

        timeGapFrom                         = 0;
        timeGapTo                           = 0;
        timeGapDate                         = dateNull();
        timeGapSeconds                      = 0;
        timeGapSecondsFlex                  = 0;
        timeGapFlex_LowLim                  = 0;
        timeGapFlex_UppLim                  = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>date2DayId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the day ID of the specified date.
    /// </summary>
    /// <param name="inDate">
    ///    The date for which to retrieve the day ID.
    /// </param>
    /// <returns>
    ///    The day ID of the specified date.
    /// </returns>
    static JmgDayIdEnum date2DayId(date inDate)
    {
        JmgDayIdEnum dayIdEnum =  dayofwk(inDate)-1;

        return dayIdEnum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>noTransID</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID that is used in the event tables, when no transaction ID has been assigned to the
    ///    event.
    /// </summary>
    /// <returns>
    ///    The ID that is used in the event tables, when no transaction ID has been assigned to the event.
    /// </returns>
    static JmgTransId  noTransID()
    {
        return '-';
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAbsJobId</Name>
				<Source><![CDATA[
    private boolean validateAbsJobId(JmgWorkerRecId _worker, JmgJobId _absenceJobId)
    {
        boolean ret = false;
    
        if (_worker && _absenceJobId)
        {
            boolean isWorkerAllowedFlex = JmgEmployee::find(_worker).isFlexProfile();
            HRMAbsenceCode absenceCode = HRMAbsenceCode::findByJobId(_absenceJobId);
            boolean isAbsenceFlex  = absenceCode.isFlexEnabled();
        
            chkAbsenceOrFlexConfigErr = !isWorkerAllowedFlex && isWorkerAllowedFlex != isAbsenceFlex;
            ret = !chkAbsenceOrFlexConfigErr;
        }
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateJmgPlannedAbsenceParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a <c>JmgPlannedAbsenceParameters</c> class instance.
    /// </summary>
    /// <param name = "_profSec">A <c>JmgProfileSeconds</c> class instance.</param>
    /// <param name = "_lowlimSec">The start time of the absence time gap.</param>
    /// <param name = "_upLimSec">The end time of the absence time gap.</param>
    /// <param name = "_absenceZone">A Boolean value that specifies whether the specified time gap is identified as absence.</param>
    /// <param name = "_jobIdAbs">The absence job id.</param>
    /// <returns>The instance of the <c>JmgPlannedAbsenceParameters</c> class.</returns>
    private JmgPlannedAbsenceParameters instantiateJmgPlannedAbsenceParameters(
        JmgProfileSeconds   _profSec,
        JmgSeconds          _lowlimSec,
        JmgSeconds          _upLimSec,
        boolean             _absenceZone,
        JmgJobIDAbs         _jobIdAbs)
    {
        JmgPlannedAbsenceParameters jmgPlannedAbsenceParameters = JmgPlannedAbsenceParameters::construct();

        jmgPlannedAbsenceParameters.parmProfileSeconds(_profSec);
        jmgPlannedAbsenceParameters.parmLowerLimitSeconds(_lowlimSec);
        jmgPlannedAbsenceParameters.parmUpperLimitSeconds(_upLimSec);
        jmgPlannedAbsenceParameters.parmAbsenceZone(_absenceZone);
        jmgPlannedAbsenceParameters.parmJobIdAbsence(_jobIdAbs);

        return jmgPlannedAbsenceParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJmgBreaksObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the JmgBreaks object.
    /// </summary>
    /// <returns> The JmgBreaks object. </returns>
    [Hookable(false)]
    internal JmgBreaks getJmgBreaksObject()
    {
        return jmgBreaks;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>