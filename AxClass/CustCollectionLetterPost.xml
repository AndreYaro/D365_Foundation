<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustCollectionLetterPost</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class CustCollectionLetterPost extends RunBaseBatch implements BatchRetryable
{
    static boolean nonInteractiveFilterSet = false;
    NoYes isBillingClassificationEnabled;
    CustCollectionLetterJour parmCustCollectionLetterJour;
    SysQueryRun queryRun;

    DialogField dialogPostingDate;

    TransDate postingDate;
    Counter progressCounter;

    NumberSeq numberSeq;

    int dialogBillingClassificationNamesId;
    FormStringControl dialogBillingClassificationIds;
    DialogField dialogInclTransWithNoBillingClassifications;

    str billingClassificationIds;
    NoYes inclTransWithNoBillingClassifications;
    SysLookupMultiSelectCtrl custBillingClassificationLookup;

    boolean isSubsetJob;
    container subsetRecIdContainer;

    private DialogField dialogUseRunDateAsPostingDate;
    private NoYes useRunDateAsPostingDate;

    #DEFINE.CurrentVersion(10)
    #LOCALMACRO.CurrentList
        postingDate,
        billingClassificationIds,
        inclTransWithNoBillingClassifications,
        isSubsetJob,
        subsetRecIdContainer,
        useRunDateAsPostingDate
    #ENDMACRO

    #LOCALMACRO.CurrentList_v9
        postingDate,
        billingClassificationIds,
        inclTransWithNoBillingClassifications,
        isSubsetJob,
        subsetRecIdContainer
    #ENDMACRO

    #LOCALMACRO.CurrentList_v8
        postingDate,
        billingClassificationIds,
        inclTransWithNoBillingClassifications
    #ENDMACRO

    #LOCALMACRO.CurrentList_v7
        postingDate
    #ENDMACRO


}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canGoBatchJournal</Name>
				<Source><![CDATA[
    public boolean canGoBatchJournal()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    public Object dialog()
    {
        FormBuildGroupControl currGroup;
        FormBuildStringControl dialogBillingClassificationNames;
        DialogRunbase dialogRunbase = super();

        isBillingClassificationEnabled = CustParameters::isBillingClassificationEnabled();

        if (isBillingClassificationEnabled)
        {
            dialogRunbase.addGroup().frameType(FormFrameType::None);
            currGroup = dialogRunbase.form().design().control(dialogRunbase.curFormGroup().name());
            dialogBillingClassificationNames = currGroup.addControl(FormControlType::String, 'CustBillingClassificationLookup');
            dialogBillingClassificationNames.label("@SPS371");
            dialogBillingClassificationNames.helpText("@SPS677");
            dialogBillingClassificationNamesId = dialogBillingClassificationNames.id();

            inclTransWithNoBillingClassifications = NoYes::Yes;
            dialogInclTransWithNoBillingClassifications = dialogRunbase.addFieldValue(enumStr(NoYes), inclTransWithNoBillingClassifications, "@SPS691", "@SPS1009" );
        }

        dialogPostingDate = dialogRunbase.addFieldValue(extendedTypeStr(TransDate), DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), "@SYS14475");
        useRunDateAsPostingDate = NoYes::No;
        dialogUseRunDateAsPostingDate = dialogRunbase.addFieldValue(extendedTypeStr(NoYesId), useRunDateAsPostingDate, "@AccountsReceivable:CustCollectionLetterPostUseRunDateAsPostingDate");

        return dialogRunbase;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetPostingDate</Name>
				<Source><![CDATA[
    private boolean resetPostingDate(FormCheckBoxControl _control)
    {
        boolean ret = true;

        dialogPostingDate.allowEdit(_control.value() ? false : true);
        dialogPostingDate.value(_control.value() ? dateNull() : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPostRun</Name>
				<Source><![CDATA[
    public void dialogPostRun(DialogRunbase dialog)
    {
        CustBillingClassification custBillingClassificationLocal;
        FormStringControl dialogBillingClassificationNames;

        super(dialog);

        dialogUseRunDateAsPostingDate.registerOverrideMethod(methodStr(FormCheckBoxControl, modified), methodStr(CustCollectionLetterPost, resetPostingDate), this);

        if (isBillingClassificationEnabled)
        {
            dialogBillingClassificationNames = dialog.formRun().design().control(dialogBillingClassificationNamesId);
            dialogBillingClassificationNames.label("@SPS371");

            custBillingClassificationLookup = SysLookupMultiSelectCtrl::construct(dialog.formRun(),
                dialogBillingClassificationNames, queryStr(CustBillingClassificationLookup));

            custBillingClassificationLocal = CustBillingClassification::find(str2int64(billingClassificationIds));

            custBillingClassificationLookup.set(custBillingClassificationLocal.custBillingClass(custBillingClassificationLocal.BillingClassification));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        postingDate = dialogPostingDate.value() != dateNull() ? dialogPostingDate.value() : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        useRunDateAsPostingDate = dialogUseRunDateAsPostingDate.value();

        if (isBillingClassificationEnabled)
        {
            inclTransWithNoBillingClassifications = dialogInclTransWithNoBillingClassifications.value();
            billingClassificationIds = con2Str(custBillingClassificationLookup.get());
        }
        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    public void initParmDefault()
    {
        super();

        isBillingClassificationEnabled = CustParameters::isBillingClassificationEnabled();

        if (isBillingClassificationEnabled)
        {
            billingClassificationIds = int642str(CustBillingClassification::find(this.parmCustCollectionLetterJour().CustBillingClassification).RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        super();

        queryRun = new SysQueryRun(queryStr(CustCollectionLetterJob));
        isBillingClassificationEnabled = CustParameters::isBillingClassificationEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList, queryRun.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustCollectionLetterJour</Name>
				<Source><![CDATA[
    private CustCollectionLetterJour parmCustCollectionLetterJour(CustCollectionLetterJour _custCollectionLetterJour = parmCustCollectionLetterJour)
    {
        nonInteractiveFilterSet = true;
        parmCustCollectionLetterJour = _custCollectionLetterJour;
        return parmCustCollectionLetterJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingDate</Name>
				<Source><![CDATA[
    public TransDate parmPostingDate(TransDate _postingDate = postingDate)
    {
        postingDate = _postingDate;
        return postingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseRunDateAsPostingDate</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public NoYes parmUseRunDateAsPostingDate(NoYes _useRunDateAsPostingDate = useRunDateAsPostingDate)
    {
        useRunDateAsPostingDate = _useRunDateAsPostingDate;
        return useRunDateAsPostingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsSubsetJob</Name>
				<Source><![CDATA[
    public boolean parmIsSubsetJob(boolean _isSubsetJob = isSubsetJob)
    {
        isSubsetJob = _isSubsetJob;
        return isSubsetJob;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSubsetRecIdContainer</Name>
				<Source><![CDATA[
    public container parmSubsetRecIdContainer(container _subsetRecIdContainer = subsetRecIdContainer)
    {
        subsetRecIdContainer = _subsetRecIdContainer;
        return subsetRecIdContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>progressUpdate</Name>
				<Source><![CDATA[
    private void progressUpdate(str _text)
    {
        progressCounter++;
        progress.setCount(progressCounter);
        progress.setText(_text);
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBuildUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the query with the parameter values.
    /// </summary>
    protected void queryBuildUpdate()
    {
        #define.BillingCalssificationselected(',0')
        #define.NoBillingclassificationselected('0')

        QueryBuildDataSource ds = queryRun.query().dataSourceTable(tableNum(CustCollectionLetterJour));

        if (!nonInteractiveFilterSet && this.parmCustCollectionLetterJour())
        {
            SysQuery::findOrCreateRange(ds, fieldNum(CustCollectionLetterJour, AccountNum)).value(this.parmCustCollectionLetterJour().AccountNum);
            SysQuery::findOrCreateRange(ds, fieldNum(CustCollectionLetterJour, CollectionLetterNum)).value(this.parmCustCollectionLetterJour().CollectionLetterNum);
            SysQuery::findOrCreateRange(ds, fieldNum(CustCollectionLetterJour, Status)).value(queryValue(this.parmCustCollectionLetterJour().Status));
        }

        if (isBillingClassificationEnabled)
        {
            //appending 0 to the Billing classfication value if include transaction without billing class checkedbox is marked
            if (inclTransWithNoBillingClassifications == NoYes::Yes)
            {
                if (billingClassificationIds != '')
                {
                    billingClassificationIds = billingClassificationIds + #BillingCalssificationselected;
                }
                else
                {
                    billingClassificationIds = billingClassificationIds + #NoBillingclassificationselected;
                }
            }

            SysQuery::findOrCreateRange(ds, fieldNum(CustCollectionLetterJour, CustBillingClassification)).value(billingClassificationIds);
        }

        if (isSubsetJob)
        {
            this.addSubsetRanges();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    public QueryRun queryRun()
    {
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains the code that performs the actual job of the class.
    /// </summary>
    public void run()
    {
        #macrolib.AviFiles
        #OCCRetryCount

        Counter progressTotal;

        if (isSubsetJob)
        {
            this.addSubsetRanges();
        }
        
        progressTotal = QueryRun::getQueryRowCount(queryRun.query(), intMax());

        this.progressInit("@SYS5212", progressTotal, #AviFindFile);
        progress = this.parmProgress();

        if (useRunDateAsPostingDate)
        {
            postingDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }

        try
        {
            ttsbegin;

            if (this.isInBatch())
            {
                this.processMultithreaded(progressTotal);
            }
            else
            {
                this.process();
            }

            ttscommit;
        }

        catch (Exception::Deadlock)
        {
            queryRun.reset();
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    queryRun.reset();
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::Error)
        {
            throw error("@SYS21533");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processMultithreaded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the collection letter posting multithreaded.
    /// </summary>
    /// <param name = "_totalNumberOfRecords">total number of record to handle</param>
    protected void processMultithreaded(Counter _totalNumberOfRecords)
    {
        if (!isSubsetJob)
        {
            // we are not a subset job, but initial job, so create subset jobs
            this.createSubSets(_totalNumberOfRecords);
        }
        else
        {
            // we are a subset, handle the subset, extra ranges are set with queryBuildUpdate
            this.process();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>process</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the collection letter posting.
    /// </summary>
    protected void process()
    {
        CustCollectionLetterJour custCollectionLetterJour;

        this.queryBuildUpdate();

        setPrefix("@AccountsReceivable:CollectionLetterPostingProcessComplete");

        while (queryRun.next())
        {
            custCollectionLetterJour = queryRun.get(tableNum(CustCollectionLetterJour));

            if (this.isInBatch())
            {
                custCollectionLetterJour = CustCollectionLetterJour::findRecIdConcurrent(custCollectionLetterJour.RecId, true, ConcurrencyModel::Pessimistic);
            }
            else
            {
                custCollectionLetterJour = CustCollectionLetterJour::findRecId(custCollectionLetterJour.RecId, true);
            }
            
            if (custCollectionLetterJour.RecId)
            {
                this.processRow(custCollectionLetterJour);
                this.sendBusinessEvent(custCollectionLetterJour);
            }
        }

        TransactionLog::create(TransactionLogType::CustCollectionLetter, "@SYS5212");
    }

]]></Source>
			</Method>
			<Method>
				<Name>processRow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process a <c>CustCollectionLetterJour</c> row.
    /// </summary>
    /// <param name = "_custCollectionLetterJour">
    /// The customer collection letter journal row.
    /// </param>
    protected void processRow(CustCollectionLetterJour _custCollectionLetterJour)
    {
        this.progressUpdate(strFmt("@SYS27235",
            _custCollectionLetterJour.AccountNum,
            _custCollectionLetterJour.CollectionLetterNum));

        setPrefix(#PreFixField(_custCollectionLetterJour, CollectionLetterNum));

        if (!this.validateCollectionLetter(_custCollectionLetterJour))
        {
            info(strFmt("@SYS66283", _custCollectionLetterJour.CollectionLetterNum,
                _custCollectionLetterJour.CollectionLetterCode,
                _custCollectionLetterJour.AccountNum));
        }
        else
        {
            LedgerDimensionDefaultAccount feeLedgerDimension = _custCollectionLetterJour.feeLedgerDimension();

            if (this.canUpdateCollectionLetterJourFee(_custCollectionLetterJour))
            {
                this.updateFee(_custCollectionLetterJour, feeLedgerDimension);
            }

            _custCollectionLetterJour.setPosted(postingDate);
            _custCollectionLetterJour.blockCustomer();

            this.writeCustCollectionLetterJour(_custCollectionLetterJour);

            if (this.shouldUpdateCollectionLetterCodeCustTrans(_custCollectionLetterJour))
            {
                _custCollectionLetterJour.updateCollectionLetterCodeCustTrans();
            }

            info(strFmt("@SYS66284", _custCollectionLetterJour.CollectionLetterNum,
                _custCollectionLetterJour.CollectionLetterCode,
                _custCollectionLetterJour.AccountNum));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeCustCollectionLetterJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Write the customer collection letter journal.
    /// </summary>
    /// <param name = "_custCollectionLetterJour">
    /// The customer collection letter journal.
    /// </param>
    protected void writeCustCollectionLetterJour(CustCollectionLetterJour _custCollectionLetterJour)
    {
        _custCollectionLetterJour.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateCollectionLetterCodeCustTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Should the customer collection letter journal be updated for the collection letter code.
    /// </summary>
    /// <param name = "_custCollectionLetterJour">
    /// The customer collection letter journal.
    /// </param>
    /// <returns>
    /// True if the collection letter code should be updated; otherwise false.
    /// </returns>
    protected boolean shouldUpdateCollectionLetterCodeCustTrans(CustCollectionLetterJour _custCollectionLetterJour)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    public boolean showQueryValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);
        container packedQuery;

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList, packedQuery] = _packedClass;
                if (packedQuery)
                {
                    queryRun = new SysQueryRun(packedQuery);
                }
                break;
            case 9:
                [version, #CurrentList_v9, packedQuery] = _packedClass;
                if (packedQuery)
                {
                    queryRun = new SysQueryRun(packedQuery);
                }
                break;
            case 8:
                [version, #CurrentList_v8, packedQuery] = _packedClass;
                if (packedQuery)
                {
                    queryRun = new SysQueryRun(packedQuery);
                }
                break;
            case 7:
                [version, #CurrentList_v7, packedQuery] = _packedClass;
                if (packedQuery)
                {
                    queryRun = new SysQueryRun(packedQuery);
                }
                break;

            default:
                return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFee</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update a collection letter journal fee.
    /// </summary>
    /// <param name = "_custCollectionLetterJour">The collection letter journal.</param>
    /// <param name = "_feeLedgerDimension">The default fee account.</param>
    protected void updateFee(CustCollectionLetterJour _custCollectionLetterJour, LedgerDimensionDefaultAccount _feeLedgerDimension)
    {
        #ISOCountryRegionCodes

        CustCollectionLetter custCollectionLetter = new CustCollectionLetter(_custCollectionLetterJour); 

        numberSeq = this.allocateVoucher(_custCollectionLetterJour);

        Voucher voucher = numberSeq.voucher();
        if (!voucher)
        {
            throw error("@SYS26396");
        }

        TransactionTxt transactionTxt = TransactionTxt::construct(
            LedgerTransTxt::CustCollectionLetterLedger,
            CompanyInfo::languageId(),
            this.parmPostingDate(),
            _custCollectionLetterJour.CollectionLetterNum,
            voucher);
        transactionTxt.setKey1(_custCollectionLetterJour.AccountNum);

        LedgerVoucher ledgerVoucher = this.constructLedgerVoucher();
        this.initLedgerVoucher(ledgerVoucher);

        LedgerVoucherObject ledgerVoucherObject = this.constructLedgerVoucherObject(voucher);
        ledgerVoucherObject.lastTransTxt(transactionTxt.txt());
        ledgerVoucher.addVoucher(ledgerVoucherObject);

        _custCollectionLetterJour.LedgerVoucher = voucher;

        TaxCustCollectionLetter taxCustCollectionLetter = this.constructTaxCustCollectionLetter(custCollectionLetter, voucher);
        _custCollectionLetterJour.TaxAmount = this.calcAndPostTaxCustCollectionLetter(taxCustCollectionLetter, ledgerVoucher);

        LedgerDimensionAccount ledgerDimensionMerged = this.determineFeeLedgerDimensionAccount(_feeLedgerDimension, _custCollectionLetterJour);

        CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
            ledgerVoucherObject.parmAccountingDate());

        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
            ledgerVoucherObject,
            LedgerPostingType::CustCollectionLetterFee,
            ledgerDimensionMerged,
            _custCollectionLetterJour.CurrencyCode,
            -_custCollectionLetterJour.Fee,
            currencyExchangeHelper);

        this.initLedgerVoucherTransObject(ledgerVoucherTransObject, _custCollectionLetterJour);
        ledgerVoucher.addTrans(ledgerVoucherTransObject);

        CustVoucher custVoucher = this.constructCustVoucher(_custCollectionLetterJour);
        this.initCustVoucher(custVoucher, _custCollectionLetterJour);

        CustTrans custTrans;
        custVoucher.post(
            ledgerVoucher,
            custTrans,
            NoYes::No,
            UnknownNoYes::Unknown);

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            LedgerBondClient_RU ledgerBondClient_RU = ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
            if (ledgerBondClient_RU)
            {
                ledgerBondClient_RU.bondLog2Log();
            }
        }
        // </GEERU>

        CustCollectionLetterTrans custCollectionLetterTrans;
        custCollectionLetterTrans.clear();
        CustTransOpen custTransOpen = CustTransOpen::findRefId(custTrans.RecId);

        this.populateCustCollectionLetterTrans(custCollectionLetterTrans, _custCollectionLetterJour, custTransOpen);
        custCollectionLetterTrans.insert();

        if (ledgerVoucher)
        {
            ledgerVoucher.end();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Construct a ledger voucher.
    /// </summary>
    /// <returns>A ledger voucher.</returns>
    protected LedgerVoucher constructLedgerVoucher()
    {
        LedgerVoucher ledgerVoucher = LedgerVoucher::newLedgerPost(
            DetailSummary::Detail,
            SysModule::Cust,
            numberSeq.parmVoucherSequenceCode());

        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize a ledger voucher.
    /// </summary>
    /// <param name = "_ledgerVoucher">The ledger voucher.</param>
    protected void initLedgerVoucher(LedgerVoucher _ledgerVoucher)
    {
        _ledgerVoucher.parmCheckBlockedDimensions(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructLedgerVoucherObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Construct a ledger voucher object.
    /// </summary>
    /// <param name = "_voucher">The voucher.</param>
    /// <returns>A ledger voucher object.</returns>
    protected LedgerVoucherObject constructLedgerVoucherObject(Voucher _voucher)
    {
        LedgerVoucherObject ledgerVoucherObject = LedgerVoucherObject::newVoucher(
            _voucher,
            this.parmPostingDate(),
            SysModule::Cust,
            LedgerTransType::CollectionLetter);

        return ledgerVoucherObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructTaxCustCollectionLetter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Construct a tax customer collection letter.
    /// </summary>
    /// <param name = "_custCollectionLetter">The customer collection letter.</param>
    /// <param name = "_voucher">The voucher.</param>
    /// <returns>The tax customer collection letter.</returns>
    protected TaxCustCollectionLetter constructTaxCustCollectionLetter(CustCollectionLetter _custCollectionLetter, Voucher _voucher)
    {
        TaxCustCollectionLetter taxCustCollectionLetter = new TaxCustCollectionLetter(NoYes::Yes, _custCollectionLetter, _voucher, this.parmPostingDate());

        return taxCustCollectionLetter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAndPostTaxCustCollectionLetter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate and post tax customer collection letter.
    /// </summary>
    /// <param name = "_taxCustCollectionLetter">The tax customer collection letter.</param>
    /// <param name = "_ledgerVoucher">The ledger voucher.</param>
    /// <returns>The tax amount.</returns>
    protected TaxAmount calcAndPostTaxCustCollectionLetter(TaxCustCollectionLetter _taxCustCollectionLetter, LedgerVoucher _ledgerVoucher)
    {
        TaxAmount taxAmount = _taxCustCollectionLetter.calcAndPost(LedgerPostingController::newForLedgerPostingJournal(_ledgerVoucher));

        return -taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineFeeLedgerDimensionAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine the fee ledger dimension.
    /// </summary>
    /// <param name = "_feeLedgerDimension">The default fee account.</param>
    /// <param name = "_custCollectionLetterJour">The customer collection letter journal.</param>
    /// <returns>The defaulted fee ledger dimension.</returns>
    protected LedgerDimensionAccount determineFeeLedgerDimensionAccount(LedgerDimensionDefaultAccount _feeLedgerDimension, CustCollectionLetterJour _custCollectionLetterJour)
    {
        LedgerDimensionAccount ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(_feeLedgerDimension, _custCollectionLetterJour.DefaultDimension); 
    
        return ledgerDimensionMerged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucherTransObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initalize the ledger voucher transaction object.
    /// </summary>
    /// <param name = "_ledgerVoucherTransObject">The ledger voucher transaction object.</param>
    /// <param name = "_custCollectionLetterJour">The customer collection letter journal.</param>
    protected void initLedgerVoucherTransObject(ledgerVoucherTransObject _ledgerVoucherTransObject, CustCollectionLetterJour _custCollectionLetterJour)
    {
        _ledgerVoucherTransObject.parmTaxParentReferenceTableId(_custCollectionLetterJour.TableId);
        _ledgerVoucherTransObject.parmTaxParentReferenceRecId(_custCollectionLetterJour.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructCustVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Construct customer voucher.
    /// </summary>
    /// <param name = "_custCollectionLetterJour">The customer collection letter journal.</param>
    /// <returns>The customer voucher.</returns>
    protected CustVoucher constructCustVoucher(CustCollectionLetterJour _custCollectionLetterJour)
    {
        CustVoucher custVoucher = CustVoucher::newCustVoucherCollectionLetter(_custCollectionLetterJour);

        return custVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize customer voucher.
    /// </summary>
    /// <param name = "_custVoucher">The customer voucher.</param>
    /// <param name = "_custCollectionLetterJour">The customer collection letter journal.</param>
    protected void initCustVoucher(CustVoucher _custVoucher, CustCollectionLetterJour _custCollectionLetterJour)
    {
        CustTable custTable = CustTable::find(_custCollectionLetterJour.AccountNum);

        _custVoucher.parmExchRate(
            ExchangeRateHelper::getExchangeRate1_Static(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), _custCollectionLetterJour.CurrencyCode, this.parmPostingDate()));

        _custVoucher.parmExchRateSecondary(
            ExchangeRateHelper::getExchangeRate2_Static(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), _custCollectionLetterJour.CurrencyCode, this.parmPostingDate()));

        _custVoucher.parmTransRefType(CustTransRefType::CollectionLetter);
        _custVoucher.parmTransRefId(_custCollectionLetterJour.CollectionLetterNum);
        _custVoucher.parmThirdPartyBankAccountId(custTable.BankAccount);

        if (isBillingClassificationEnabled)
        {
            _custVoucher.parmBillingClassification(_custCollectionLetterJour.CustBillingClassification);
        }

        _custVoucher.parmPaymId(_custCollectionLetterJour.PaymId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateCustCollectionLetterTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populate customer collection letter transaction.
    /// </summary>
    /// <param name = "_custCollectionLetterTrans">The customer collection letter transaction.</param>
    /// <param name = "_custCollectionLetterJour">The customer collection letter journal.</param>
    /// <param name = "_custTransOpen">The open customer transaction.</param>
    protected void populateCustCollectionLetterTrans(CustCollectionLetterTrans _custCollectionLetterTrans, CustCollectionLetterJour _custCollectionLetterJour, CustTransOpen _custTransOpen)
    {
        _custCollectionLetterTrans.initFromCustCollectionLetterJour(_custCollectionLetterJour);
        _custCollectionLetterTrans.initFromCustTransOpen(_custTransOpen);
        _custCollectionLetterTrans.CollectionLetterIssued = NoYes::Yes;
        _custCollectionLetterTrans.Fee = NoYes::Yes;
        _custCollectionLetterTrans.CollectionLetterCode = _custCollectionLetterJour.CollectionLetterCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///     To update the <c>CustCollectionLetterJour</c> datasource query with new range values.
    /// </summary>
    [Wrappable(true)]
    protected final void updateQuery()
    {
        QueryBuildDataSource ds = queryRun.query().dataSourceTable(tableNum(CustCollectionLetterJour));

        boolean hasRecId = this.parmCustCollectionLetterJour().RecId != 0;
        SysQuery::findOrCreateRange(ds, fieldNum(CustCollectionLetterJour, AccountNum)).value(this.parmCustCollectionLetterJour().AccountNum);
        SysQuery::findOrCreateRange(ds, fieldNum(CustCollectionLetterJour, CollectionLetterNum)).value(this.parmCustCollectionLetterJour().CollectionLetterNum);
        SysQuery::findOrCreateRange(ds, fieldNum(CustCollectionLetterJour, Status)).value(queryValue(this.parmCustCollectionLetterJour().Status));
        SysQuery::findOrCreateRange(ds, fieldNum(CustCollectionLetterJour, JournalPrinted)).status(hasRecId ? RangeStatus::Hidden : RangeStatus::Open);

        ds.findRange(fieldNum(CustCollectionLetterJour, Status)).status(hasRecId ? RangeStatus::Hidden : RangeStatus::Open);
        ds.findRange(fieldNum(CustCollectionLetterJour, JournalPrinted)).value(queryValue(this.parmCustCollectionLetterJour().JournalPrinted));
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate(Object _calledFrom = null)
    {
        boolean ok = true;

        ok = ok && this.validatePostingDate();
        ok = ok && this.validateBillingClassification();

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBillingClassification</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate billing classification.
    /// </summary>
    /// <returns>
    /// True fi the billing classification is valid; otherwise false.
    /// </returns>
    protected boolean validateBillingClassification()
    {
        boolean ok = true;

        if (isBillingClassificationEnabled && inclTransWithNoBillingClassifications == NoYes::No && billingClassificationIds == '')
        {
            ok = ok && checkFailed("@SPS673");
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePostingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate the posting date.
    /// </summary>
    /// <returns>
    /// True if the posting date is valid; otherwise false.
    /// </returns>
    protected boolean validatePostingDate()
    {
        boolean ok = true;

        if (!postingDate)
        {
            ok = checkFailed("@SYS16668");
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCollectionLetter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate the collection letter.
    /// </summary>
    /// <param name = "_custCollectionLetterJour">
    /// The collection letter journal.
    /// </param>
    /// <returns>
    /// True if valid; otherwise false;
    /// </returns>
    protected boolean validateCollectionLetter(CustCollectionLetterJour _custCollectionLetterJour)
    {
        boolean ok = true;

        if (_custCollectionLetterJour.Updated)
        {
            ok = checkFailed(strFmt("@SYS26132", _custCollectionLetterJour.CollectionLetterNum));
        }

        if (_custCollectionLetterJour.Canceled)
        {
            ok = checkFailed(strFmt("@SYS86766", _custCollectionLetterJour.CollectionLetterNum));
        }

        if (! _custCollectionLetterJour.mayBeReminded())
        {
            ok = checkFailed(strFmt("@SYS25470", _custCollectionLetterJour.AccountNum));
        }

        if (this.canUpdateCollectionLetterJourFee(_custCollectionLetterJour))
        {
            ok = MainAccount::checkAllowPosting(LedgerDimensionFacade::getMainAccountFromLedgerDimension(_custCollectionLetterJour.feeLedgerDimension()).MainAccountId) && ok;
        }

        if (PaymTerm::isCashAccount(_custCollectionLetterJour.PaymTermId))
        {
            ok = checkFailed(strfmt("@AccountsReceivable:CollectionLetterCanNotBePostedWIthTermsOfPaymentUsingCashAccount", _custCollectionLetterJour.CollectionLetterNum));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUpdateCollectionLetterJourFee</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates fee for the collection letter.
    /// </summary>
    /// <param name = "_custCollectionLetterJour">
    ///     The collection letter journal.
    /// </param>
    /// <returns>
    ///     true if collection letter journal has fee; otherwise, false.
    /// </returns>
    protected boolean canUpdateCollectionLetterJourFee(CustCollectionLetterJour _custCollectionLetterJour)
    {
        return _custCollectionLetterJour.Fee != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    static public ClassDescription description()
    {
        return "@SYS5212";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args args)
    {
        CustCollectionLetterJour custCollectionLetterJour;
        CustCollectionLetterPost custCollectionLetterPost;

        if (args.record().TableId == tableNum(CustCollectionLetterJour))
        {
            custCollectionLetterJour = args.record();
        }

        if (custCollectionLetterJour)
        {
            custCollectionLetterPost = CustCollectionLetterPost::constructWithJournalFilter(custCollectionLetterJour);
        }
        else
        {
            custCollectionLetterPost = CustCollectionLetterPost::construct();
        }
        nonInteractiveFilterSet = false;
        custCollectionLetterPost.getLast();
        custCollectionLetterPost.updateQuery();

        if (custCollectionLetterPost.prompt())
        {
            using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContext(args))
            {
                custCollectionLetterPost.runOperation();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static CustCollectionLetterPost construct()
    {
        return new CustCollectionLetterPost();
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructWithJournalFilter</Name>
				<Source><![CDATA[
    public static CustCollectionLetterPost constructWithJournalFilter(CustCollectionLetterJour _custCollectionLetterJour)
    {
        Debug::assert(_custCollectionLetterJour != null);

        CustCollectionLetterPost collectionLetterPost = CustCollectionLetterPost::construct();
        collectionLetterPost.parmCustCollectionLetterJour(_custCollectionLetterJour);
        return collectionLetterPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendBusinessEvent</Name>
				<Source><![CDATA[
    private void sendBusinessEvent(CustCollectionLetterJour _custCollectionLetterJour)
    {
        var businessEvent = CollectionLetterSentBusinessEvent::newFromCustCollectionLetterJour(_custCollectionLetterJour);
        businessEvent.send();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSubsetRanges</Name>
				<Source><![CDATA[
    private void addSubsetRanges()
    {
        var recIdRange = SysQuery::findOrCreateRange(queryRun.query().dataSourceTable(tableNum(CustCollectionLetterJour)), fieldNum(CustCollectionLetterJour, RecId));
            
        int recIdContainerLength = conLen(subsetRecIdContainer);

        if (recIdContainerLength == 1)
        {
            recIdRange.value(con2Str(subsetRecIdContainer));
        }
        else if (recIdContainerLength > 1)
        {
            // Create a range based on the first and last RecId in the container. The container is pre-sorted. The rest of the criteria on the query
            recIdRange.value(strFmt('%1..%2', conPeek(subsetRecIdContainer, 1), conPeek(subsetRecIdContainer, recIdContainerLength)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSubsetJob</Name>
				<Source><![CDATA[
    private void createSubsetJob(BatchHeader _batchHeader, container _container)
    {
        var subsetJob = CustCollectionLetterPost::construct();

        subsetJob.unpack(this.pack());

        subsetJob.parmSubsetRecIdContainer(_container);
        subsetJob.parmIsSubsetJob(true);

        subsetJob.batchInfo().parmGroupId(this.parmCurrentBatch().GroupId);
        subsetJob.batchInfo().parmCaption(CustCollectionLetterPost::description());
        _batchHeader.addRuntimeTask(subsetJob, this.parmCurrentBatch().RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSubSets</Name>
				<Source><![CDATA[
    private void createSubSets(Counter _totalNumberOfRecords)
    {
        int subsetSizePercentage = CustParameters::find().CollectionLetterPostBatchTaskPercentage;

        //set a default value when nothing configured
        if (subsetSizePercentage <= 0)
        {
            subsetSizePercentage = 20;
        }

        //determine subset size based on percentage of total number of record to process
        int subsetSize = real2int(roundUp( _totalNumberOfRecords * subsetSizePercentage / 100,0));

        var batchHeader = BatchHeader::getCurrentBatchHeader();

        this.queryBuildUpdate();
   
        //add sort on recid, so that we can use ranges in handling subset
        queryRun.query().clearOrderBy();
        queryRun.query().dataSourceTable(tableNum(CustCollectionLetterJour)).addSortField(fieldNum(CustCollectionLetterJour, RecId));

        int i = 0;
        container subsetRecIds;

        while (queryRun.next())
        {
            subsetRecIds += queryRun.get(tableNum(CustCollectionLetterJour)).RecId;
            i++;

            if (i == subsetSize)
            {
                this.createSubsetJob(batchHeader, subsetRecIds);
                subsetRecIds = conNull();
                i = 0;
            }
        }

        // handle the remainder
        if (i > 0)
        {
            this.createSubsetJob(batchHeader, subsetRecIds);
        }

        batchHeader.save();
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allocates voucher number sequence.
    /// </summary>
    /// <param name = "_custCollectionLetterJour">The buffer of the <c>CustCollectionLetterJour</c> table.</param>
    /// <returns>An instance of the <c>NumberSeq</c> class.</returns>
    protected NumberSeq allocateVoucher(CustCollectionLetterJour _custCollectionLetterJour)
    {
        return NumberSeq::newGetVoucher(CustParameters::numRefCollectionLetterVoucher());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>