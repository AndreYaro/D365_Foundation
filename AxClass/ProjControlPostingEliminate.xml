<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjControlPostingEliminate</Name>
	<SourceCode>
		<Declaration><![CDATA[
class   ProjControlPostingEliminate extends ProjControlPosting implements BatchRetryable
{
    private boolean enableMultipleContractLinesForProject = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkCreateRevenueTrans</Name>
				<Source><![CDATA[
    public boolean checkCreateRevenueTrans()
    {
        ProjTable projTableLocal = ProjTable::find(this.parmProjId());

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            PSAContractLineItems contractLine;
            ProjWIPTable wipProject = ProjWIPTable::find(this.parmProjId());
            ProjRevRecContractLine revRecContractLine;

            select firstonly contractLine
               join revRecContractLine
                where revRecContractLine.ContractLineNum == contractLine.ContractLineNum
                  && revRecContractLine.RevenueRecognitionId == this.parmProjId()
                  && contractLine.IncludeFeeTrans == NoYes::Yes;
             if(contractLine.RecId)
             {
                if (ProjRevRecHelper::getCompletePrincipleContractLine(wipProject) == ProjCompletePrincip::CompletedPercentage)
                {
                    return false;
                }
                return true;
             }
        }
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFixedPriceBillingMethod(projTableLocal, ProjTransType::Revenue))
        {
            if (ProjRevRecHelper::getCompletePrincipleForProjTable(projTableLocal) == ProjCompletePrincip::CompletedPercentage)
            {
                return false;
            }

            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPostOnAccByMatchingPrincip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements checking of matching principle for <c>ProjControlPostingEliminate::checkPostOnAcc</c>.
    /// </summary>
    /// <param name = "_matchingPrincip">Value of matching principle.</param>
    /// <returns>true if the check succeeds; otherwise, false.</returns>
	[Replaceable]
	protected boolean checkPostOnAccByMatchingPrincip(ProjMatchingPrincip _matchingPrincip)
    {
        return _matchingPrincip == ProjMatchingPrincip::SalesValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPostOnAccByCompletePrincip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements checking of complete principle for <c>ProjControlPostingEliminate::checkPostOnAcc</c>.
    /// </summary>
    /// <param name = "_completePrincip">Value of complete principle.</param>
    /// <returns>true if the check succeeds; otherwise, false.</returns>
	[Replaceable]
	protected boolean checkPostOnAccByCompletePrincip(ProjCompletePrincip _completePrincip)
    {
        return _completePrincip == ProjCompletePrincip::CompletedPercentage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPostOnAcc</Name>
				<Source><![CDATA[
    public boolean checkPostOnAcc()
    {
        ProjTable projTableLocal = ProjTable::find(this.parmProjId());
        ProjCompletePrincip completePrinciple;
        ProjMatchingPrincip matchingPrinciple;
        ProjLedgerStatusOnAcc onAccLedgerStatus;

        if ((isContractLineUsed && contractLineBasedRevRecFeature) || projGroup.ProjType == ProjType::FixedPrice || (enableMultipleContractLinesForProject && ProjMultipleContractLinesForProjectFeatureHelper::existContractLineForBillingMethod(projTableLocal.ProjId, projTableLocal.ProjInvoiceProjId, ProjContractBillingMethod::FixedPrice)))
        {
            if (enableMultipleContractLinesForProject || (isContractLineUsed && contractLineBasedRevRecFeature))
            {
                if (!projRevProfile)
                {
                    if(isContractLineUsed && contractLineBasedRevRecFeature)
                    {
                        projRevProfile = ProjRevRecHelper::getProfileForRevRecProjectContractLine(ProjWIPTable::find(this.parmProjId()));
                    }
                    else
                    {
                        projRevProfile = ProjRevRecHelper::getRevProfile(projTableLocal, ProjContractBillingMethod::FixedPrice);
                    }
                }
                completePrinciple = projRevProfile.CompletePrinciple;
                matchingPrinciple = projRevProfile.MatchingPrinciple;
                onAccLedgerStatus = projRevProfile.OnAccLedgerStatus;
            }
            else
            {
                completePrinciple = projGroup.CompletePrincip;
                matchingPrinciple = projGroup.MatchingPrincip;
                onAccLedgerStatus = projGroup.InvoicePosting;
            }

            if (onAccLedgerStatus == ProjLedgerStatusOnAcc::Operations &&
            this.checkPostOnAccByMatchingPrincip(matchingPrinciple) &&
            this.checkPostOnAccByCompletePrincip(completePrinciple))
            {
                return false;
            }
            
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPostRevenueReverse</Name>
				<Source><![CDATA[
    public boolean checkPostRevenueReverse()
    {
        if (isContractLineUsed && contractLineBasedRevRecFeature)
        {
            ProjRevRecContractLine projRevRecContractLine;
            PSAContractLineItems contractLine;
            select firstonly projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == this.parmProjId()
                exists join contractLine
                where contractLine.ContractLineNum == projRevRecContractLine.ContractLineNum
                  && contractLine.IncludeFeeTrans == NoYes::Yes
                  && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice;
            if(projRevRecContractLine)
            {
                if (ProjRevRecHelper::getCompletePrincipleContractLine(ProjWIPTable::find(this.parmProjId())) == ProjCompletePrincip::CompletedContract)
                {
                    return false;
                }
                return true;
            }
        }
        else
        {
            ProjTable projTableLocal = ProjTable::find(this.parmProjId());

            if (ProjMultipleContractLinesForProjectFeatureHelper::isFixedPriceBillingMethod(projTableLocal, ProjTransType::Revenue))
            {
                if (ProjRevRecHelper::getCompletePrincipleForProjTable(projTableLocal) == ProjCompletePrincip::CompletedContract)
                {
                    return false;
                }

                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    /// interface.
    /// </summary>
    /// <returns>
    /// A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    /// A dialog can be either built by using the <c>Dialog</c> class or by using a class that is created
    /// in the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        DialogRunbase   dialogRunbase;

        this.parmTransDate(this.parmTransDate() ? this.parmTransDate() : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

        dialogRunbase = super();

        dialogRunbase.caption("@SYS6098");

        dialogRunbase.addGroup("@SYS14475");
        fieldTransDate = dialogRunbase.addFieldValue(extendedTypeStr(TransDate), this.parmTransDate(), "@SYS14475", "@SYS53214");

        return dialogRunbase;
    }

]]></Source>
			</Method>
			<Method>
				<Name>elimination</Name>
				<Source><![CDATA[
    public boolean elimination()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>investmentEliminationAmount</Name>
				<Source><![CDATA[
    public AmountMST investmentEliminationAmount(ProjControlPeriodTable  _projControlPeriod)
    {
        ProjControlPeriodTableColumn    projControlPeriodTableColumnEstimate    =
                                        ProjControlPeriodTableColumn::find(_projControlPeriod.ProjId,
                                                                           _projControlPeriod.ControlId,
                                                                           _projControlPeriod.PeriodFrom,
                                                                           _projControlPeriod.Version,
                                                                           ProjEstimateColumn::Estimate);

        ProjControlPeriodTable  projControlPeriodTableLast = ProjControlPeriodTable::findLastPosted(
            _projControlPeriod.ProjId,_projControlPeriod.ControlId);

        return -(projControlPeriodTableColumnEstimate.wipCostpriceTotal+projControlPeriodTableLast.totalTotalEstimateAccCost());
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerStatusCostTo</Name>
				<Source><![CDATA[
    protected ProjLedgerStatus ledgerStatusCostTo(ProjTrans _projTrans)
    {
        ProjLedgerStatus    ret;

        ret = ProjLedgerStatus::Operations;

        if (_projTrans.transType() == ProjTransType::Cost &&
            _projTrans.ledgerStatusCost() == ProjLedgerStatus::None)
        {
            ret = _projTrans.ledgerStatusCost();
        }
        else if (_projTrans.ledgerStatusCost() ==  ProjLedgerStatus::Never) // Handle Never Ledger (Hour or Item)
        {
            ret = ProjLedgerStatus::Never;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projControlPeriodStatusNew</Name>
				<Source><![CDATA[
    protected ProjControlPeriodStatus projControlPeriodStatusNew()
    {
        return ProjControlPeriodStatus::Eliminate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogTxt</Name>
				<Source><![CDATA[
    public TransTxt transactionLogTxt()
    {
        return "@SYS92315";
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogType</Name>
				<Source><![CDATA[
    public TransactionLogType transactionLogType()
    {
        return TransactionLogType::ProjEstimate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAccruedCost</Name>
				<Source><![CDATA[
    public void updateAccruedCost(
        ProjControlPeriodTable  _projControlPeriod,
        LedgerVoucher           _ledgerVoucher)
    {
        ProjCostTrans       projCostTrans;
        ProjCostTransCost   projCostTransCost;
        ProjTable projTable;
        ProjRevRecContractLine projRevRecContractLine;

        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select forupdate projCostTrans
            where projCostTrans.TransactionOrigin == ProjOrigin::EstimateAccruedLoss
            join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == _projControlPeriod.ProjId &&
                      projRevRecContractLine.ContractLineNum == projCostTrans.PSAContractLineNum
            join forupdate projCostTransCost
                where projCostTransCost.TransId == projCostTrans.TransId &&
                      projCostTransCost.TransStatus == ProjTransStatus::Estimated
            {
                this.postAccruedCost(projCostTrans,projCostTransCost,_ledgerVoucher);
            }
        }
        else
        {
        while select forupdate projCostTrans
            where projCostTrans.TransactionOrigin == ProjOrigin::EstimateAccruedLoss
            join projTable
                where projTable.WIPProject == _projControlPeriod.ProjId && 
                      projCostTrans.ProjId == projTable.ProjId
            join forupdate projCostTransCost
                where projCostTransCost.TransId == projCostTrans.TransId &&
                      projCostTransCost.TransStatus == ProjTransStatus::Estimated
        {
            this.postAccruedCost(projCostTrans,projCostTransCost,_ledgerVoucher);
        }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAccruedOnAcc</Name>
				<Source><![CDATA[
    public void updateAccruedOnAcc(
        ProjId        _projId,
        LedgerVoucher _ledgerVoucher)
    {
        ProjOnAccTrans      projOnAccTrans;
        ProjOnAccTrans      projOnAccTransUpdate;
        ProjOnAccTransSale  projOnAccTransSale;
        ProjOnAccTransSale  projOnAccTransSaleUpdate;
        ProjTable           projTable;
        ProjRevRecContractLine projRevRecContractLine;

        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select RecId from projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == _projId
            join TransId, TransactionOrigin, ProjId from projOnAccTrans
                where projOnAccTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum
            join projOnAccTransSale
                where projOnAccTransSale.TransId == projOnAccTrans.TransId &&
                    projOnAccTransSale.TransStatus == ProjTransStatus::Estimated &&
                    projOnAccTransSale.wipPeriod

            {
                boolean shouldEnterCalculation = ProjCalcOnAccAmountInAccCurFlight::instance().isEnabled()
                    || !ProjControlDeductionCalculationFlight::instance().isEnabled() || ProjRevRecHelper::isNonDeductionOrNotAdjustedDeductionInvoicedWithMilestone(projOnAccTransSale);

                if (shouldEnterCalculation)
                {
                    projOnAccTransUpdate = ProjOnAccTrans::find(projOnAccTrans.TransId,true);
                    projOnAccTransSaleUpdate = ProjOnAccTransSale::find(projOnAccTransSale.RecId,true);
                    ProjPost::newEnterOnAccEstimate(projOnAccTransUpdate,
                                            projOnAccTransSaleUpdate,
                                            _ledgerVoucher,
                                            this.parmPeriodTo(),
                                            this.checkPostOnAcc(),
                                            this.isReversal(),
                                            NoYes::Yes).postTrans();

                    projOnAccTransSaleUpdate.TransStatus   = ProjTransStatus::Eliminated;
                    projOnAccTransSaleUpdate.update();
                }
            }
        }
        else
        {
        while select RecId from projTable
            where projTable.wipProject == _projId
            join TransId, TransactionOrigin, ProjId from projOnAccTrans 
              where projOnAccTrans.ProjID == projTable.ProjId
            join projOnAccTransSale
              where projOnAccTransSale.TransId == projOnAccTrans.TransId &&
                projOnAccTransSale.TransStatus == ProjTransStatus::Estimated &&
                projOnAccTransSale.wipPeriod      
            {
                boolean shouldEnterCalculation = ProjCalcOnAccAmountInAccCurFlight::instance().isEnabled()
                    || !ProjControlDeductionCalculationFlight::instance().isEnabled() || ProjRevRecHelper::isNonDeductionOrNotAdjustedDeductionInvoicedWithMilestone(projOnAccTransSale);

                if (shouldEnterCalculation)
                {
                    projOnAccTransUpdate = ProjOnAccTrans::find(projOnAccTrans.TransId,true);
                    projOnAccTransSaleUpdate = ProjOnAccTransSale::find(projOnAccTransSale.RecId,true);
                    ProjPost::newEnterOnAccEstimate(projOnAccTransUpdate,
                                                    projOnAccTransSaleUpdate,
                                                    _ledgerVoucher,
                                                    this.parmPeriodTo(),
                                                    this.checkPostOnAcc(),
                                                    this.isReversal(),
                                                    NoYes::Yes).postTrans();

                    projOnAccTransSaleUpdate.TransStatus   = ProjTransStatus::Eliminated;
                    projOnAccTransSaleUpdate.update();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjTable</Name>
				<Source><![CDATA[
    protected void updateProjTable()
    {
        ProjWIPTable       projWIPTable  = ProjWIPTable::find(this.parmProjId(), true);

        projWIPTable.wipEliminated = NoYes::Yes;
        projWIPTable.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjTrans</Name>
				<Source><![CDATA[
    protected void updateProjTrans()
    {
        ProjTable           projTable;
        ProjEmplTrans       projEmplTrans;
        ProjEmplTransCost   projEmplTransCost;
        ProjCostTrans       projCostTrans;
        ProjCostTransCost   projCostTransCost;
        ProjItemTrans       projItemTrans;
        ProjItemTransCost   projItemTransCost;
        ProjRevRecContractLine projRevRecContractLine;

        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
             update_recordset projEmplTransCost
                setting TransStatus = ProjTransStatus::Eliminated
                where projEmplTransCost.TransStatus == ProjTransStatus::Estimated
                join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == this.parmProjId()
                join projEmplTrans
                where projEmplTrans.TransId == projEmplTransCost.TransId &&
                    projEmplTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum;

            update_recordset projCostTransCost
                setting TransStatus = ProjTransStatus::Eliminated
                where projCostTransCost.TransStatus == ProjTransStatus::Estimated
                join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == this.parmProjId()
                join projCostTrans
                where projCostTrans.TransId == projCostTransCost.TransId &&
                    projCostTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum;

            update_recordset projItemTransCost
                setting TransStatus = ProjTransStatus::Eliminated
                where projItemTransCost.TransStatus == ProjTransStatus::Estimated
                join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == this.parmProjId()
                    join projItemTrans
                        where projItemTrans.InventTransId == projItemTransCost.InventTransId &&
                            projItemTrans.ProjAdjustRefId == projItemTransCost.ProjAdjustRefId &&
                            projItemTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum;
        }
        else
        {

            while select ProjId from projTable where projTable.wipProject == this.parmProjId()
            {
                update_recordset projEmplTransCost
                    setting TransStatus = ProjTransStatus::Eliminated
                    where projEmplTransCost.TransStatus == ProjTransStatus::Estimated
                    join projEmplTrans
                    where projEmplTrans.TransId == projEmplTransCost.TransId &&
                        projEmplTrans.ProjId == projTable.ProjId;

                update_recordset projCostTransCost
                    setting TransStatus = ProjTransStatus::Eliminated
                    where projCostTransCost.TransStatus == ProjTransStatus::Estimated
                    join projCostTrans
                    where projCostTrans.TransId == projCostTransCost.TransId &&
                        projCostTrans.ProjId == projTable.ProjId;

                update_recordset projItemTransCost
                    setting TransStatus = ProjTransStatus::Eliminated
                    where projItemTransCost.TransStatus == ProjTransStatus::Estimated
                        join projItemTrans
                            where projItemTrans.InventTransId == projItemTransCost.InventTransId &&
                                projItemTrans.ProjAdjustRefId == projItemTransCost.ProjAdjustRefId &&
                                projItemTrans.ProjId == projTable.ProjId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRevenueForEstimateCategoryOnly</Name>
				<Source><![CDATA[
    public void updateRevenueForEstimateCategoryOnly(ProjControlPeriodTable  _projControlPeriod,
        LedgerVoucher _ledgerVoucher)
    {
        ProjRevenueTrans projRevenueTrans;
        ProjRevenueTransSale projRevenueTransSale;
        ProjTable projTable;
        ProjCategory projCategory;
        ProjRevRecContractLine projRevRecContractLine;

        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select forupdate projRevenueTrans
            join forupdate projRevenueTransSale
                where projRevenueTransSale.TransId == projRevenueTrans.TransId
                    && projRevenueTransSale.TransStatus == ProjTransStatus::Estimated
                && projRevenueTransSale.WIPProjId == _projControlPeriod.ProjId
            exists join projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == _projControlPeriod.ProjId
            exists join projCategory
                where projCategory.CategoryId == projRevenueTrans.CategoryId
                    && projCategory.SetupEstimate == NoYes::Yes
            
            {
                if (projRevenueTransSale.LedgerSalesPosted == NoYes::Yes
                    && projRevenueTransSale.WIPPeriod > dateNull())
                {
                    ProjPost::newEnterRevenueEstimate(projRevenueTrans,
                                                  projRevenueTransSale,
                                                  _ledgerVoucher,
                                                  this.isReversal(),
                                                  true,
                                                  true).postTrans();
                }
            }
        }
        else
        {

        while select forupdate projRevenueTrans
            join forupdate projRevenueTransSale
                where projRevenueTransSale.TransId == projRevenueTrans.TransId
                    && projRevenueTransSale.TransStatus == ProjTransStatus::Estimated
            exists join projTable
                where projTable.ProjId == projRevenueTrans.ProjId
                    && projTable.WIPProject == _projControlPeriod.ProjId
            exists join projCategory
                where projCategory.CategoryId == projRevenueTrans.CategoryId
                    && projCategory.SetupEstimate == NoYes::Yes
            
        {
            if (projRevenueTransSale.LedgerSalesPosted == NoYes::Yes
                    && projRevenueTransSale.WIPPeriod > dateNull())
            {
                ProjPost::newEnterRevenueEstimate(projRevenueTrans,
                                                  projRevenueTransSale,
                                                  _ledgerVoucher,
                                                  this.isReversal(),
                                                  true,
                                                  true).postTrans();
            }
        }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRevenue</Name>
				<Source><![CDATA[
    public void updateRevenue(
        ProjControlPeriodTable  _projControlPeriod,
        LedgerVoucher           _ledgerVoucher)
    {
        ProjRevenueTrans        projRevenueTrans;
        ProjRevenueTransSale    projRevenueTransSale;
        ProjEmplTrans           projEmplTrans;
        ProjEmplTransSale       projEmplTransSale;
        ProjCostTrans           projCostTrans;
        ProjCostTransSale       projCostTransSale;
        ProjItemTrans           projItemTrans;
        ProjItemTransSale       projItemTransSale;
        ProjTable projTable;
        ProjRevRecContractLine projRevRecContractLine;

    #localMacro.process
        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            if(%1.tableId == tableNum(ProjRevenueTrans))
            {
                while select pessimisticlock %1
                join pessimisticlock %2
                    where %2.%3 == %1.%3 &&
                        %2.TransStatus == ProjTransStatus::Estimated &&
                        %2.LedgerSalesPosted &&
                        %2.wipPeriod &&
                        %2.%4 == _projControlPeriod.ProjId
                {
                    ProjPost::newEnterRevenueEstimate(%1,
                                                  %2,
                                                  _ledgerVoucher,
                                                  this.isReversal(),
                                                  true,
                                                  true).postTrans();
                }
            }
            else
            {
                while select pessimisticlock %1
                join pessimisticlock %2
                    where %2.%3 == %1.%3 &&
                        %2.TransStatus == ProjTransStatus::Estimated &&
                        %2.LedgerSalesPosted &&
                        %2.wipPeriod
                exists join projRevRecContractLine
                    where projRevRecContractLine.RevenueRecognitionId == _projControlPeriod.ProjId &&
                       projRevRecContractLine.ContractLineNum == %1.PSAContractLineNum
                {
                    ProjPost::newEnterRevenueEstimate(%1,
                                                  %2,
                                                  _ledgerVoucher,
                                                  this.isReversal(),
                                                  true,
                                                  true).postTrans();
                }
            
            }

        }
        else
        {
            while select forupdate %1
                join projTable
                where projTable.WIPProject == _projControlPeriod.ProjId
                    && %1.ProjId == projTable.ProjId
                join forupdate %2
                    where %2.%3 == %1.%3 &&
                        %2.TransStatus == ProjTransStatus::Estimated &&
                        %2.LedgerSalesPosted &&
                        %2.wipPeriod
            {
                ProjPost::newEnterRevenueEstimate(%1,
                                                  %2,
                                                  _ledgerVoucher,
                                                  this.isReversal(),
                                                  true,
                                                  true).postTrans();
            }
        }
    #endMacro

        if (this.getSalesPriceMatchingPrinciple() == ProjSalesPriceMatchingPrincip::None)
        {
            #process(projRevenueTrans, projRevenueTransSale, TransId, WIPProjId)
        }
        else
        {
            #process(projEmplTrans, projEmplTransSale, TransId, TransId)
            #process(projCostTrans, projCostTransSale, TransId, TransId)
            #process(projItemTrans, projItemTransSale, ProjTransId, ProjTransId)
            #process(projRevenueTrans, projRevenueTransSale, TransId, WIPProjId)
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipPostCost</Name>
				<Source><![CDATA[
    protected void wipPostCost(
        ProjControlPeriodTable  _projControlPeriod,
        LedgerVoucher           _ledgerVoucher,
        ProjId                  _projId)
    {
        ProjCostTrans           projCostTrans;
        ProjCostTransCost       projCostTransCost;
        ProjTrans               projTrans;
        LedgerVoucher           ledgerVoucherSpecialTrx;
        LedgerVoucherObject     ledgerVoucherObjectSpecial;
        TransactionTxt          transSpecialTxt;
        Voucher                 voucherSpecial;
        ProjLedgerStatus        projLedgerStatusTo;
        NumberSeq               numberSeqSpecial;
        TransDate               voucherDate;
        DetailSummary           detailSummary = ProjParameters::find().LineTotalEstimate == ProjLineTotal::Line ? DetailSummary::Detail : DetailSummary::Summary;
        ProjRevRecContractLine projRevRecContractLine;

        // Handle post of normal transactions
        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == _projControlPeriod.ProjId
           join forupdate projCostTrans
            where projCostTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum
                && projCostTrans.TransactionOrigin != ProjOrigin::EstimateAccruedLoss
                join forupdate projCostTransCost
                    where projCostTransCost.TransId == projCostTrans.TransId
                    && projCostTransCost.TransStatus == ProjTransStatus::Estimated
                    && projCostTransCost.wipPeriod
        {
            projTrans   = ProjTrans::newProjCostTransCost(projCostTrans, projCostTransCost);
            projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);

            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                ProjPost::newEnterCost_TrxDetail(projCostTrans, projCostTransCost, _ledgerVoucher, projLedgerStatusTo, ProjOrigin::EliminateEstimate, true).postTrans();
            }

            projCostTransCost.TransStatus   = ProjTransStatus::Eliminated;
            
        }
        }
        else
        {
        while select forupdate projCostTrans
            where projCostTrans.ProjId == _projId
                && projCostTrans.TransactionOrigin != ProjOrigin::EstimateAccruedLoss
                join forupdate projCostTransCost
                    where projCostTransCost.TransId == projCostTrans.TransId
                    && projCostTransCost.TransStatus == ProjTransStatus::Estimated
                    && projCostTransCost.wipPeriod
        {
            projTrans   = ProjTrans::newProjCostTransCost(projCostTrans, projCostTransCost);
            projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);

            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                ProjPost::newEnterCost_TrxDetail(projCostTrans, projCostTransCost, _ledgerVoucher, projLedgerStatusTo, ProjOrigin::EliminateEstimate, true).postTrans();
            }

            projCostTransCost.TransStatus   = ProjTransStatus::Eliminated;
            projCostTransCost.update();
        }
        }

        // Handle posting of transactions that were not estimated.
        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == _projControlPeriod.ProjId
           join forupdate projCostTrans
            where   projCostTrans.PSAContractLineNum      == projRevRecContractLine.ContractLineNum
            &&      projCostTrans.TransactionOrigin != ProjOrigin::EstimateAccruedLoss
                join forupdate projCostTransCost
                    where projCostTransCost.TransId == projCostTrans.TransId
                    && projCostTransCost.TransStatus == ProjTransStatus::Posted
                    && projCostTransCost.wipPeriod   == dateNull()
        {
            projTrans   = ProjTrans::newProjCostTransCost(projCostTrans, projCostTransCost);
            projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);

            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                numberSeqSpecial =  NumberSeq::newGetVoucher(ProjParameters::numRefProjPeriodVoucher());
                voucherSpecial = numberSeqSpecial.voucher();

                transSpecialTxt  = TransactionTxt::construct(LedgerTransTxt::ProjectPostingLedger);
                transSpecialTxt.setDate(this.parmTransDate());
                transSpecialTxt.setVoucher(voucherSpecial);

                ledgerVoucherSpecialTrx     = LedgerVoucher::newLedgerPost(detailSummary, SysModule::Project, numberSeqSpecial.parmVoucherSequenceCode(), this.transactionLogType(), this.transactionLogTxt());
                // Use larger of two dates (trx posted or Acknowledgment)
                if (projTrans.transDate() >= this.parmTransDate())
                {
                    voucherDate = projTrans.transDate();
                }
                else
                {
                    voucherDate = this.parmTransDate();
                }

                ledgerVoucherObjectSpecial = LedgerVoucherObject::newVoucher(
                    voucherSpecial,
                    voucherDate,
                    SysModule::Project,
                    LedgerTransType::Project);

                ledgerVoucherObjectSpecial.parmAcknowledgementDate(this.parmTransDate());
                ledgerVoucherObjectSpecial.lastTransTxt(transSpecialTxt.txt());

                ledgerVoucherSpecialTrx.addVoucher(ledgerVoucherObjectSpecial);

                ProjPost::newEnterCost_TrxDetail(projCostTrans, projCostTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo, ProjOrigin::EliminateEstimate, true).postTrans();

                if (projGroup.isInvestmentProjGroup(enableMultipleContractLinesForProject))
                {
                    this.eliminateInvestment(_projControlPeriod, ledgerVoucherSpecialTrx, NoYes::Yes, projCostTransCost.LineAmount);
                }
                ledgerVoucherSpecialTrx.end();
            }

            projCostTransCost.TransStatus   = ProjTransStatus::Eliminated;
            projCostTransCost.update();
        }
        }
        else
        {
        while select forupdate projCostTrans
            where   projCostTrans.ProjId      == _projId
            &&      projCostTrans.TransactionOrigin != ProjOrigin::EstimateAccruedLoss
                join forupdate projCostTransCost
                    where projCostTransCost.TransId == projCostTrans.TransId
                    && projCostTransCost.TransStatus == ProjTransStatus::Posted
                    && projCostTransCost.wipPeriod   == dateNull()
        {
            projTrans   = ProjTrans::newProjCostTransCost(projCostTrans, projCostTransCost);
            projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);

            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                numberSeqSpecial =  NumberSeq::newGetVoucher(ProjParameters::numRefProjPeriodVoucher());
                voucherSpecial = numberSeqSpecial.voucher();

                transSpecialTxt  = TransactionTxt::construct(LedgerTransTxt::ProjectPostingLedger);
                transSpecialTxt.setDate(this.parmTransDate());
                transSpecialTxt.setVoucher(voucherSpecial);

                ledgerVoucherSpecialTrx     = LedgerVoucher::newLedgerPost(detailSummary, SysModule::Project, numberSeqSpecial.parmVoucherSequenceCode(), this.transactionLogType(), this.transactionLogTxt());
                // Use larger of two dates (trx posted or Acknowledgment)
                if (projTrans.transDate() >= this.parmTransDate())
                {
                    voucherDate = projTrans.transDate();
                }
                else
                {
                    voucherDate = this.parmTransDate();
                }

                ledgerVoucherObjectSpecial = LedgerVoucherObject::newVoucher(
                    voucherSpecial,
                    voucherDate,
                    SysModule::Project,
                    LedgerTransType::Project);

                ledgerVoucherObjectSpecial.parmAcknowledgementDate(this.parmTransDate());
                ledgerVoucherObjectSpecial.lastTransTxt(transSpecialTxt.txt());

                ledgerVoucherSpecialTrx.addVoucher(ledgerVoucherObjectSpecial);

                ProjPost::newEnterCost_TrxDetail(projCostTrans, projCostTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo, ProjOrigin::EliminateEstimate, true).postTrans();

                if (projGroup.isInvestmentProjGroup(enableMultipleContractLinesForProject))
                {
                    this.eliminateInvestment(_projControlPeriod, ledgerVoucherSpecialTrx, NoYes::Yes, projCostTransCost.LineAmount);
                }
                ledgerVoucherSpecialTrx.end();
            }

            projCostTransCost.TransStatus   = ProjTransStatus::Eliminated;
            projCostTransCost.update();
        }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipPostEmpl</Name>
				<Source><![CDATA[
    protected void wipPostEmpl(
        ProjControlPeriodTable  _projControlPeriodTable,
        LedgerVoucher           _ledgerVoucher,
        ProjId                  _projId)
    {
        ProjEmplTrans           projEmplTrans;
        ProjEmplTransCost       projEmplTransCost;
        ProjTrans               projTrans;
        LedgerVoucher           ledgerVoucherSpecialTrx;
        LedgerVoucherObject     ledgerVoucherObjectSpecial;
        TransactionTxt          transSpecialTxt;
        Voucher                 voucherSpecial;
        ProjLedgerStatus        projLedgerStatusTo;
        NumberSeq               numberSeqSpecial;
        TransDate               voucherDate;
        DetailSummary           detailSummary = ProjParameters::find().LineTotalEstimate == ProjLineTotal::Line ? DetailSummary::Detail : DetailSummary::Summary ;
        PSAIndirectComponentTrans   psaIndirectComponentTrans;
        ProjRevRecContractLine projRevRecContractLine;

        // Handle posting for normal transactions
        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == _projControlPeriodTable.ProjId
            join forupdate projEmplTrans
            where   projEmplTrans.PSAContractLineNum        ==  projRevRecContractLine.ContractLineNum
                join forupdate projEmplTransCost
                    where projEmplTransCost.TransId == projEmplTrans.TransId
                    && projEmplTransCost.TransStatus   == ProjTransStatus::Estimated
                    && projEmplTransCost.wipPeriod
        {
            projTrans   = ProjTrans::newProjEmplTransCost(projEmplTrans, projEmplTransCost);
            projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);

            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                while select psaIndirectComponentTrans
                    where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                        psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                        psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                {
                    ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, _ledgerVoucher, projLedgerStatusTo, ProjOrigin::EliminateEstimate,true, false, psaIndirectComponentTrans).postTrans();
                }

                ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, _ledgerVoucher, projLedgerStatusTo, ProjOrigin::EliminateEstimate,true).postTrans();
            }

            projEmplTransCost.TransStatus   = ProjTransStatus::Eliminated;
            projEmplTransCost.update();
        }
        }
        else
        {
        while select forupdate projEmplTrans
            where   projEmplTrans.ProjId        == _projId
                join forupdate projEmplTransCost
                    where projEmplTransCost.TransId == projEmplTrans.TransId
                    && projEmplTransCost.TransStatus   == ProjTransStatus::Estimated
                    && projEmplTransCost.wipPeriod
        {
            projTrans   = ProjTrans::newProjEmplTransCost(projEmplTrans, projEmplTransCost);
            projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);

            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                while select psaIndirectComponentTrans
                    where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                        psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                        psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                {
                    ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, _ledgerVoucher, projLedgerStatusTo, ProjOrigin::EliminateEstimate,true, false, psaIndirectComponentTrans).postTrans();
                }

                ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, _ledgerVoucher, projLedgerStatusTo, ProjOrigin::EliminateEstimate,true).postTrans();
            }

            projEmplTransCost.TransStatus   = ProjTransStatus::Eliminated;
            projEmplTransCost.update();
        }
        }

        // Handle posting of transactions that were not estimated.
        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == _projControlPeriodTable.ProjId
           join forupdate projEmplTrans
            where   projEmplTrans.PSAContractLineNum      == projRevRecContractLine.ContractLineNum
                join forupdate projEmplTransCost
                    where projEmplTransCost.TransId == projEmplTrans.TransId
                    &&      projEmplTransCost.TransStatus == ProjTransStatus::Posted
                    &&      projEmplTransCost.wipPeriod   == dateNull()
        {
            projTrans   = ProjTrans::newProjEmplTransCost(projEmplTrans, projEmplTransCost);
            projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);

            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                numberSeqSpecial =  NumberSeq::newGetVoucher(ProjParameters::numRefProjPeriodVoucher());
                voucherSpecial = numberSeqSpecial.voucher();

                transSpecialTxt  = TransactionTxt::construct(LedgerTransTxt::ProjectPostingLedger);
                transSpecialTxt.setDate(this.parmTransDate());
                transSpecialTxt.setVoucher(voucherSpecial);

                ledgerVoucherSpecialTrx     = LedgerVoucher::newLedgerPost(detailSummary, SysModule::Project, numberSeqSpecial.parmVoucherSequenceCode(), this.transactionLogType(), this.transactionLogTxt());
                // Use larger of two dates (trx posted or Acknowledgment)
                if (projTrans.transDate() >= this.parmTransDate())
                {
                    voucherDate = projTrans.transDate();
                }
                else
                {
                    voucherDate = this.parmTransDate();
                }

                ledgerVoucherObjectSpecial = LedgerVoucherObject::newVoucher(
                    voucherSpecial,
                    voucherDate,
                    SysModule::Project,
                    LedgerTransType::Project);

                ledgerVoucherObjectSpecial.parmAcknowledgementDate(this.parmTransDate());
                ledgerVoucherObjectSpecial.lastTransTxt(transSpecialTxt.txt());

                ledgerVoucherSpecialTrx.addVoucher(ledgerVoucherObjectSpecial);

                while select psaIndirectComponentTrans
                    where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                        psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                        psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                {
                    ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo,ProjOrigin::EliminateEstimate, true, false, psaIndirectComponentTrans).postTrans();

                    if (projGroup.isInvestmentProjGroup(enableMultipleContractLinesForProject))
                    {
                        this.eliminateInvestment(_projControlPeriodTable, ledgerVoucherSpecialTrx, NoYes::Yes, psaIndirectComponentTrans.Amount);
                    }
                }

                ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo,ProjOrigin::EliminateEstimate, true).postTrans();

                if (projGroup.isInvestmentProjGroup(enableMultipleContractLinesForProject))
                {
                    this.eliminateInvestment(_projControlPeriodTable, ledgerVoucherSpecialTrx, NoYes::Yes, projEmplTransCost.LineAmount);
                }

                ledgerVoucherSpecialTrx.end();
            }

            projEmplTransCost.TransStatus   = ProjTransStatus::Eliminated;
            projEmplTransCost.update();
        }
        }
        else
        {
        while select forupdate projEmplTrans
            where   projEmplTrans.ProjId      == _projId
                join forupdate projEmplTransCost
                    where projEmplTransCost.TransId == projEmplTrans.TransId
                    &&      projEmplTransCost.TransStatus == ProjTransStatus::Posted
                    &&      projEmplTransCost.wipPeriod   == dateNull()
        {
            projTrans   = ProjTrans::newProjEmplTransCost(projEmplTrans, projEmplTransCost);
            projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);

            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                numberSeqSpecial =  NumberSeq::newGetVoucher(ProjParameters::numRefProjPeriodVoucher());
                voucherSpecial = numberSeqSpecial.voucher();

                transSpecialTxt  = TransactionTxt::construct(LedgerTransTxt::ProjectPostingLedger);
                transSpecialTxt.setDate(this.parmTransDate());
                transSpecialTxt.setVoucher(voucherSpecial);

                ledgerVoucherSpecialTrx     = LedgerVoucher::newLedgerPost(detailSummary, SysModule::Project, numberSeqSpecial.parmVoucherSequenceCode(), this.transactionLogType(), this.transactionLogTxt());
                // Use larger of two dates (trx posted or Acknowledgment)
                if (projTrans.transDate() >= this.parmTransDate())
                {
                    voucherDate = projTrans.transDate();
                }
                else
                {
                    voucherDate = this.parmTransDate();
                }

                ledgerVoucherObjectSpecial = LedgerVoucherObject::newVoucher(
                    voucherSpecial,
                    voucherDate,
                    SysModule::Project,
                    LedgerTransType::Project);

                ledgerVoucherObjectSpecial.parmAcknowledgementDate(this.parmTransDate());
                ledgerVoucherObjectSpecial.lastTransTxt(transSpecialTxt.txt());

                ledgerVoucherSpecialTrx.addVoucher(ledgerVoucherObjectSpecial);

                while select psaIndirectComponentTrans
                    where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                        psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                        psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                {
                    ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo,ProjOrigin::EliminateEstimate, true, false, psaIndirectComponentTrans).postTrans();

                    if (projGroup.isInvestmentProjGroup(enableMultipleContractLinesForProject))
                    {
                        this.eliminateInvestment(_projControlPeriodTable, ledgerVoucherSpecialTrx, NoYes::Yes, psaIndirectComponentTrans.Amount);
                    }
                }

                ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo,ProjOrigin::EliminateEstimate, true).postTrans();

                if (projGroup.isInvestmentProjGroup(enableMultipleContractLinesForProject))
                {
                    this.eliminateInvestment(_projControlPeriodTable, ledgerVoucherSpecialTrx, NoYes::Yes, projEmplTransCost.LineAmount);
                }

                ledgerVoucherSpecialTrx.end();
            }

            projEmplTransCost.TransStatus   = ProjTransStatus::Eliminated;
            projEmplTransCost.update();
        }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipPostItem</Name>
				<Source><![CDATA[
    protected void wipPostItem(
        ProjControlPeriodTable  _projControlPeriodTable,
        LedgerVoucher           _ledgerVoucher,
        ProjId                  _projId)
    {
        ProjItemTransCost       projItemTransCost;
        ProjItemTrans           projItemTrans;
        ProjTrans               projTrans;
        LedgerVoucher           ledgerVoucherSpecialTrx;
        LedgerVoucherObject     ledgerVoucherObjectSpecial;
        TransactionTxt          transSpecialTxt;
        Voucher                 voucherSpecial;
        ProjLedgerStatus        projLedgerStatusTo;
        NumberSeq               numberSeqSpecial;
        TransDate               voucherDate;
        DetailSummary           detailSummary = ProjParameters::find().LineTotalEstimate == ProjLineTotal::Line ? DetailSummary::Detail : DetailSummary::Summary ;
        ProjRevRecContractLine projRevRecContractLine;

        // Handle posting of normal transactions

        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == _projControlPeriodTable.ProjId
                    while select forupdate projItemTrans
            where   projItemTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum
            join forupdate projItemTransCost
                where projItemTransCost.InventTransId == projItemTrans.InventTransId
                && projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId
                && projItemTransCost.TransStatus == ProjTransStatus::Estimated
                && projItemTransCost.wipPeriod
        {
            projTrans   = ProjTrans::newProjItemTransCost(projItemTransCost);
            projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);

            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                ProjPost::newEnterCost_TrxDetail(projItemTrans, projItemTransCost, _ledgerVoucher, projLedgerStatusTo,ProjOrigin::EliminateEstimate, true).postTrans();
            }

            projItemTransCost.TransStatus = ProjTransStatus::Eliminated;
            projItemTransCost.update();
        }
        }
        else
        {
        while select forupdate projItemTrans
            where   projItemTrans.ProjId == _projId
            join forupdate projItemTransCost
                where projItemTransCost.InventTransId == projItemTrans.InventTransId
                && projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId
                && projItemTransCost.TransStatus == ProjTransStatus::Estimated
                && projItemTransCost.wipPeriod
        {
            projTrans   = ProjTrans::newProjItemTransCost(projItemTransCost);
            projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);

            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                ProjPost::newEnterCost_TrxDetail(projItemTrans, projItemTransCost, _ledgerVoucher, projLedgerStatusTo,ProjOrigin::EliminateEstimate, true).postTrans();
            }

            projItemTransCost.TransStatus = ProjTransStatus::Eliminated;
            projItemTransCost.update();
        }
        }

        // Handle posting of transactions that were not estimated.
        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == _projControlPeriodTable.ProjId
            join forupdate projItemTrans
            where   projItemTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum
            join forupdate projItemTransCost
                where projItemTransCost.InventTransId == projItemTrans.InventTransId
                && projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId
                && projItemTransCost.TransStatus == ProjTransStatus::Posted
                && projItemTransCost.wipPeriod   == dateNull()
        {
            projTrans   = ProjTrans::newProjItemTransCost(projItemTransCost);
            projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);

            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                    numberSeqSpecial =  NumberSeq::newGetVoucher(ProjParameters::numRefProjPeriodVoucher());
                    voucherSpecial = numberSeqSpecial.voucher();

                    transSpecialTxt  = TransactionTxt::construct(LedgerTransTxt::ProjectPostingLedger);
                    transSpecialTxt.setDate(this.parmTransDate());
                    transSpecialTxt.setVoucher(voucherSpecial);

                    ledgerVoucherSpecialTrx     = LedgerVoucher::newLedgerPost(detailSummary, SysModule::Project, numberSeqSpecial.parmVoucherSequenceCode(), this.transactionLogType(), this.transactionLogTxt());
                    // Use larger of two dates (trx posted or Acknowledgment)
                    if (projTrans.transDate() >= this.parmTransDate())
                    {
                        voucherDate = projTrans.transDate();
                    }
                    else
                    {
                        voucherDate = this.parmTransDate();
                    }

                    ledgerVoucherObjectSpecial = LedgerVoucherObject::newVoucher(
                        voucherSpecial,
                        voucherDate,
                        SysModule::Project,
                        LedgerTransType::Project);

                    ledgerVoucherObjectSpecial.parmAcknowledgementDate(this.parmTransDate());
                    ledgerVoucherObjectSpecial.lastTransTxt(transSpecialTxt.txt());

                    ledgerVoucherSpecialTrx.addVoucher(ledgerVoucherObjectSpecial);

                    ProjPost::newEnterCost_TrxDetail(projItemTrans, projItemTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo,ProjOrigin::EliminateEstimate,true).postTrans();

                    if (projGroup.isInvestmentProjGroup(enableMultipleContractLinesForProject))
                    {
                        this.eliminateInvestment(_projControlPeriodTable, ledgerVoucherSpecialTrx, NoYes::Yes, projItemTransCost.AmountMST);
                    }

                    ledgerVoucherSpecialTrx.end();
            }

                projItemTransCost.TransStatus = ProjTransStatus::Eliminated;
                projItemTransCost.update();
            }
        }

        else
         {
        while select forupdate projItemTrans
            where   projItemTrans.ProjId == _projId
            join forupdate projItemTransCost
                where projItemTransCost.InventTransId == projItemTrans.InventTransId
                && projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId
                && projItemTransCost.TransStatus == ProjTransStatus::Posted
                && projItemTransCost.wipPeriod   == dateNull()
        {
            projTrans   = ProjTrans::newProjItemTransCost(projItemTransCost);
            projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);

            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                numberSeqSpecial =  NumberSeq::newGetVoucher(ProjParameters::numRefProjPeriodVoucher());
                voucherSpecial = numberSeqSpecial.voucher();

                transSpecialTxt  = TransactionTxt::construct(LedgerTransTxt::ProjectPostingLedger);
                transSpecialTxt.setDate(this.parmTransDate());
                transSpecialTxt.setVoucher(voucherSpecial);

                ledgerVoucherSpecialTrx     = LedgerVoucher::newLedgerPost(detailSummary, SysModule::Project, numberSeqSpecial.parmVoucherSequenceCode(), this.transactionLogType(), this.transactionLogTxt());
                // Use larger of two dates (trx posted or Acknowledgment)
                if (projTrans.transDate() >= this.parmTransDate())
                {
                    voucherDate = projTrans.transDate();
                }
                else
                {
                    voucherDate = this.parmTransDate();
                }

                ledgerVoucherObjectSpecial = LedgerVoucherObject::newVoucher(
                    voucherSpecial,
                    voucherDate,
                    SysModule::Project,
                    LedgerTransType::Project);

                ledgerVoucherObjectSpecial.parmAcknowledgementDate(this.parmTransDate());
                ledgerVoucherObjectSpecial.lastTransTxt(transSpecialTxt.txt());

                ledgerVoucherSpecialTrx.addVoucher(ledgerVoucherObjectSpecial);

                ProjPost::newEnterCost_TrxDetail(projItemTrans, projItemTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo,ProjOrigin::EliminateEstimate,true).postTrans();

                if (projGroup.isInvestmentProjGroup(enableMultipleContractLinesForProject))
                {
                    this.eliminateInvestment(_projControlPeriodTable, ledgerVoucherSpecialTrx, NoYes::Yes, projItemTransCost.AmountMST);
                }

                ledgerVoucherSpecialTrx.end();
            }

            projItemTransCost.TransStatus = ProjTransStatus::Eliminated;
            projItemTransCost.update();
        }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    protected static ClassDescription description()
    {
        return "@SYS55483";
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>