<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSWaveProcessingDataCleanup</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Ax.Xpp.PlatformExtensions;

/// <summary>
/// The <c>WHSWaveProcessingDataCleanup</c> class is responsible for cleanup data related to the processing of a wave.
/// </summary>
/// <remarks>
/// This class is utilized for both successful and failed waves.
/// </remarks>
public class WHSWaveProcessingDataCleanup extends RunBaseBatch implements BatchRetryable, SysErrorMessageHelpScopeIBatchProvider
{
    #OCCRetryCount        
    WHSWaveId                   waveId;
    WHSWaveExecutionID          waveExecutionId;
    private str                 waveCleanupType;
    private boolean             isInitialWaveCleanUp;

    private WHSInstrumentationLogger    instrumentationLogger;

    #define.CurrentVersion(1)
    #localmacro.CurrentList
        waveId,
        waveExecutionId
    #endmacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>adjustLoadLineDeltaQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates load line quantity values based on tracked delta quantities during the wave run.
    /// </summary>
    /// <param name="_waveId">The wave Id.</param>
    [Hookable(false)]
    internal static NumberOfRecords adjustLoadLineDeltaQuantity(WHSWaveId _waveId)
    {
        WHSLoadLine             loadLine;
        WHSWaveUpdatedLoadLine  waveUpdatedLoadLine;

        ttsbegin;

        update_recordset loadLine
            setting
                WorkCreatedQty  = loadLine.WorkCreatedQty - waveUpdatedLoadLine.WorkCreatedQtyDelta,
                PickedQty       = loadLine.PickedQty - waveUpdatedLoadLine.PickedQtyDelta
            join waveUpdatedLoadLine
                where waveUpdatedLoadLine.LoadLineRefRecid                      == loadLine.RecId
                &&    waveUpdatedLoadLine.WaveId                                == _waveId
                &&    waveUpdatedLoadLine.SkipDeltaLoadLineQuantitiesAdjustment == NoYes::No;

        ttscommit;

        return loadLine.RowCount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowSaveLast</Name>
				<Source><![CDATA[
    public boolean allowSaveLast()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWaveCleanupType</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void parmWaveCleanupType(str _waveCleanupType)
    {
        waveCleanupType = _waveCleanupType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsInitialWaveCleanUp</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean parmIsInitialWaveCleanUp(boolean _isInitialWaveCleanUp = isInitialWaveCleanUp)
    {
        isInitialWaveCleanUp = _isInitialWaveCleanUp;
        return isInitialWaveCleanUp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpCreatedLoads</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleans up commited changes made during the create load wave method.
    /// </summary>
    /// <param name="_waveId">The wave Id.</param>
    [Hookable(false)]
    internal static NumberOfRecords cleanUpCreatedLoads(WHSWaveId _waveId)
    {
        WHSLoadTable        loadTable;
        WHSWaveCreatedLoad  waveCreatedLoad;

        WHSLoadLine         loadLine;
        WHSShipmentTable    shipmentTable;

        // Prevent calling into additional logic.
        loadLine.skipDataMethods(true);
        shipmentTable.skipDataMethods(true);

        loadLine.skipEvents(true);
        shipmentTable.skipEvents(true);

        NumberOfRecords numberOfRecords;

        ttsbegin;

        while select forUpdate loadTable
            exists join waveCreatedLoad
            where waveCreatedLoad.LoadId == loadTable.LoadId
            &&    waveCreatedLoad.WaveId == _waveId
        {
            update_recordSet loadLine
                setting LoadId = ''
                where loadLine.LoadId == loadTable.LoadId;

            update_recordSet shipmentTable
                setting LoadId = ''
                where shipmentTable.LoadId == loadTable.LoadId;

            loadTable.delete();

            numberOfRecords++;
        }

        ttscommit;

        return numberOfRecords;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tryCleanupErroredWave</Name>
				<Source><![CDATA[
    private boolean tryCleanupErroredWave()
    {
        boolean result = true;

        try
        {
            using (var waveLockManagerScope = WHSWaveLockManagerSharedScope::newFromContextOrDefault())
            {
                if (!waveLockManagerScope.current().tryLockForWaveId(this.waveId, 0, false))
                {
                    return false;
                }
            
                using (var perfTask = this.createPerformanceTask('cleanupErroredWave'))
                {
                    using (var cleanupActivitiesContext = this.instrumentationLogger().waveProcessingDataCleanupActivities().tryCleanupErroredWave())
                    {
                        using (var waveProcessingDataCleanupContext = WHSWaveProcessingDataCleanupContext::construct())
                        {
                            waveProcessingDataCleanupContext.skipThrowError = true;
                            waveProcessingDataCleanupContext.waveProcessingDataCleanupInstrumentationLogger = this.instrumentationLogger();
                            waveProcessingDataCleanupContext.waveExecutionId = waveExecutionId;

                            WHSWaveTable wave = WHSWaveTable::find(waveId);

                            if (wave.waveTemplate().WaveTemplateType == WHSWaveTemplateType::Shipping)
                            {
                                this.cleanUpErroredRun(perfTask);
                            }
                            else
                            {
                                try
                                {
                                    ttsbegin;

                                    perfTask.setDeleteTmpWorkLines(WHSWaveProcessingDataCleanup::deleteTmpWorkLines(waveId));
                                    WHSWaveProcessingDataCleanup::cleanUpReplenishment(waveId, perfTask);
                                    perfTask.setDeleteQualityOrders(WHSWaveProcessingDataCleanup::deleteQualityOrders(waveId));
                                    perfTask.setDeleteWaveFailedShipments(WHSWaveProcessingDataCleanup::deleteWaveFailedShipments(waveId));
                                    perfTask.setCleanUpCreatedLoads(WHSWaveProcessingDataCleanup::cleanUpCreatedLoads(waveId));
                                    perfTask.setadjustLoadLineDeltaQuantity(WHSWaveProcessingDataCleanup::adjustLoadLineDeltaQuantity(waveId));
                                    perfTask.setResetWaveTable(WHSWaveProcessingDataCleanup::resetWaveTable(waveId));
                                    this.deleteWaveTrackingData(perfTask);

                                    ttscommit;
                                }
                                catch (Exception::UpdateConflict) //can occur if two waves have updated the same loadline and both fails and need to adjust workcreatedqty
                                {
                                    if (appl.ttsLevel() != 0)
                                    {
                                        throw Exception::UpdateConflict;
                                    }
                                    if (xSession::currentRetryCount() >= #RetryNum)
                                    {
                                        throw Exception::UpdateConflictNotRecovered;
                                    }
                                    retry;
                                }
                            }
                        }
                    }
                }
            }
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw;
            }
            retry;
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError(#RetryNum))
            {
                retry;
            }
            else
            {
                throw;
            }
        }
        catch //this is to deal with scenarios where the main connection was broken. In this case any DB operation on the main connection will cause an exception
        {
            //we are relying on the transaction rollback to cleanup the wave so if we are not ttslevel = 0 we are not rolled back and we just throw to let normal clean up do its work
            if (appl.ttsLevel() == 0)
            {
                result = false;
            }
            else
            {
                throw;
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTmpWorkLinesUsingUserConnection</Name>
				<Source><![CDATA[
    private boolean deleteTmpWorkLinesUsingUserConnection()
    {
        UserConnection  userConnection;
        boolean         deleteSuccessful;
        
        try
        {
            userConnection = new UserConnection();            

            userConnection.ttsbegin();

            WHSTmpWorkLine tmpWorkLineByWave;
            WHSTmpWorkLine tmpWorkLineByDemand;

            tmpWorkLineByWave.setConnection(userConnection);
            tmpWorkLineByDemand.setConnection(userConnection);

            CommonExtensions::SetSqlDeleteIndexHint(tmpWorkLineByWave, indexStr(WHSTmpWorkLine, WaveIdx));                

            delete_from tmpWorkLineByWave
                where tmpWorkLineByWave.WaveId == this.waveId;

            //delete any records that came from replenishment
            delete_from tmpWorkLineByDemand
                where tmpWorkLineByDemand.DemandWaveId == this.waveId;
                
            userConnection.ttscommit();

            deleteSuccessful = true;
        }
        finally
        {
            if (userConnection)
            {
                userConnection.finalize();
            }
        }

        return deleteSuccessful;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupErroredWave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleans up all commited data of a wave process if the wave has errored.
    /// </summary>
    public void cleanupErroredWave()
    {        
        if (!this.tryCleanupErroredWave())
        {
            throw error("@WAX:WaveDataCleanup_WaveLockCannotBeAcquired_ErroMessage");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpReplenishment</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static void cleanUpReplenishment(WHSWaveId _waveId, WHSInstrumentationWaveProcessingDataCleanupPerformanceTask _perfTask) 
    {
        NumberOfRecords replenTmpWorkLinesDeleted = WHSWaveProcessingDataCleanup::deleteReplenishmentTmpWorkLines(_waveId);
        NumberOfRecords tmpReplenWorkLinksDeleted = WHSWaveProcessingDataCleanup::deleteTempReplenWorkLinks(_waveId);
        WHSWaveProcessingDataCleanup::cleanupImmediateReplenishmentWork(_waveId);

        _perfTask.setReplenTmpWorkLinesDeleted(replenTmpWorkLinesDeleted)
            .setTmpReplenWorkLinksDeleted(tmpReplenWorkLinksDeleted);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupBeforeWaveExecution</Name>
				<Source><![CDATA[
    /// <summary>
    /// cleans up wave tracking data from previous runs for the provided wave table and identifies and cleans up
    /// other failed waves.
    /// </summary>
    /// <param name = "_waveTable">The <c>WHSWaveTable</c> record to cleanup tracking data from previous runs.</param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute, Wrappable(true)]
    internal static void cleanupBeforeWaveExecution(WHSWaveTable _waveTable)
    {
        var waveProcessingDataCleanupInitial = WHSWaveProcessingDataCleanup::newInitialCleanUp(_waveTable.WaveId);

        waveProcessingDataCleanupInitial.cleanupExecutedWave();
        WHSWaveProcessingDataCleanup::identifyAndCleanupErroredWavesForWarehouseWithCleanupType(_waveTable.InventLocationId, 'CleanupOtherFailedWavesDuringInitialCleanup');
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTempReplenWorkLinks</Name>
				<Source><![CDATA[
    private static NumberOfRecords deleteTempReplenWorkLinks(WHSWaveId _waveId)
    {
        WHSReplenWorkLink replenWorkLink;
        WHSWaveProcessingStatus waveProcessingStatus;
            
        delete_from replenWorkLink
            exists join waveProcessingStatus
                where waveProcessingStatus.WorkBuildId == replenWorkLink.WorkBuildId
                    && waveProcessingStatus.WaveId == _waveId;

        return replenWorkLink.RowCount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupImmediateReplenishmentWork</Name>
				<Source><![CDATA[
    private static void cleanupImmediateReplenishmentWork(WHSWaveId _waveId)
    {
        WHSWaveTable immedWave;
        WHSWaveProcessingStatus waveProcessingStatus;

        while select forupdate immedWave
            where immedWave.DemandWaveId == _waveId
            exists join waveProcessingStatus
                where waveProcessingStatus.ExecutingUTCDateTime < immedWave.ExecutingUTCDateTime
                    && waveProcessingStatus.WaveId == _waveId
        {
            WHSWorkTable immedWork;

            while select forupdate immedWork
                where immedWork.WaveId        == immedWave.WaveId
                &&    immedWork.WorkTransType == WHSWorkTransType::Replenishment
                &&    immedWork.WorkStatus    != WHSWorkStatus::Cancelled
            {
                if (immedWork.WorkStatus == WHSWorkStatus::Open
                &&  !WHSReplenWorkLink::existsActiveForReplenWorkId(immedWork.WorkId))
                {
                    WHSWorkId immedWorkId = immedWork.WorkId;
                    immedWork.delete();
                    WHSWaveProcessingDataCleanup::log(strFmt("@WAX:ImmedReplenWorkDeletedOnWaveFailure", immedWorkId, _waveId));
                }
                else
                {
                    WHSWaveProcessingDataCleanup::log(strFmt("@WAX:ReplenWorkCannotBeDeletedOtherWorkUsesIt", immedWork.WorkId));
                }
            }
                
            immedWave.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>log</Name>
				<Source><![CDATA[
    private static void log(str _message)
    {
        info(_message);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupExecutedWave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleans up data after a successfully processed wave that is no longer needed.
    /// </summary>
    public void cleanupExecutedWave()
    {

        using (var perfTask = this.createPerformanceTask('cleanupExecutedWave'))
        {
            try
            {
                WHSWaveTable wave = WHSWaveTable::find(waveId);

                if (wave.waveTemplate().WaveTemplateType == WHSWaveTemplateType::Shipping)
                {
                    this.cleanUpSuccessfulRun(perfTask);
                }
                else
                {
                    ttsbegin;

                    this.deleteWaveTrackingData(perfTask);
        
                    //this is a hardening fix - for a successful wave we should never have any left behind
                    var numberOfWHSTmpWorkLinesDeleted = WHSWaveProcessingDataCleanup::deleteTmpWorkLines(waveId);
        
                    perfTask.setDeleteTmpWorkLines(numberOfWHSTmpWorkLinesDeleted);

                    if (numberOfWHSTmpWorkLinesDeleted)
                    {
                        //we surface this as a warning to allow us to do trouble shooting later
                        warning(strfmt("@WAX:WaveUnexpectedTmpWorkLinesDeletedForWave", numberOfWHSTmpWorkLinesDeleted, tableStr(WHSTmpWorkLine), waveId, waveExecutionId));
                        WHSPostEngine::createWaveExecutionHistoryLine(waveId, waveExecutionId, strFmt("@WAX:WaveUnexpectedTmpWorkLinesDeletedForWave", numberOfWHSTmpWorkLinesDeleted, tableStr(WHSTmpWorkLine), waveId, waveExecutionId), false);
                    }

                    ttscommit;
                }
            }
            catch (Exception::UpdateConflict) //can occur if two waves have updated the same loadline and both fails and need to adjust workcreatedqty
            {
                if (appl.ttsLevel() != 0)
                {
                    throw Exception::UpdateConflict;
                }
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            catch (Exception::Deadlock)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw;
                }
                else
                {
                    retry;
                }
            }
            catch (Exception::TransientSqlConnectionError)
            {
                if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError(#RetryNum))
                {
                    retry;
                }
                else
                {
                    throw;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupNonBatchErroredWave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleans up all committed data of a wave process that is not running in batch if the wave has errored.
    /// </summary>
    [SysObsolete('This method is no longer used.', false, 26\05\2020)]
    public void cleanupNonBatchErroredWave()
    {
        using (var perfTask = this.createPerformanceTask('cleanupNonBatchErroredWave'))
        {
			try
			{
                ttsbegin;

                perfTask.setDeleteTmpWorkLines(WHSWaveProcessingDataCleanup::deleteTmpWorkLines(waveId));
                perfTask.setResetWaveTable(WHSWaveProcessingDataCleanup::resetWaveTable(waveId));
                perfTask.setDeleteWaveStepControllerRecords(WHSWaveProcessingDataCleanup::deleteWaveStepControllerRecords(waveId, ''));

                ttscommit;
			}
			catch (Exception::UpdateConflict) //can occur if two waves have updated the same loadline and both fails and need to adjust workcreatedqty
			{
				if (appl.ttsLevel() != 0)
				{
					throw Exception::UpdateConflict;
				}
				if (xSession::currentRetryCount() >= #RetryNum)
				{
					throw Exception::UpdateConflictNotRecovered;
				}
				retry;
			}
			catch (Exception::Deadlock)
			{
				if (xSession::currentRetryCount() >= #RetryNum)
				{
					throw;
				}
				retry;
			}
            catch (Exception::TransientSqlConnectionError)
            {
                if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError(#RetryNum))
                {
                    retry;
                }
                else
                {
                    throw;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpErroredRun</Name>
				<Source><![CDATA[
    private void cleanUpErroredRun(WHSInstrumentationWaveProcessingDataCleanupPerformanceTask _perfTask)
    {
        this.cleanUpWave(true, _perfTask);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpSuccessfulRun</Name>
				<Source><![CDATA[
    private void cleanUpSuccessfulRun(WHSInstrumentationWaveProcessingDataCleanupPerformanceTask _perfTask)
    {
        this.cleanUpWave(false, _perfTask);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpWave</Name>
				<Source><![CDATA[
    private void cleanUpWave(boolean _erroredWave, WHSInstrumentationWaveProcessingDataCleanupPerformanceTask _perfTask)
    {
        try
        {
            ttsbegin;

            WHSWaveTable waveTable = WHSWaveTable::find(waveId);
            
            WHSWaveTemplateLine templateLine;

            while select templateLine
                order by templateLine.WaveStep desc
                where templateLine.WaveTemplateName == waveTable.WaveTemplateName
            {
                using (var methodPerfTask = this.createMethodPerformanceTask(_perfTask.waveCleanupType(), templateLine.PostMethodName, _erroredWave))
                {
                    this.cleanUpWaveStep(templateLine.PostMethodName, _erroredWave, methodPerfTask);
                }
            }

            this.finalizeWaveCleanup(_erroredWave, _perfTask);

            ttscommit;
        }
        catch (Exception::UpdateConflict) //can occur if two waves have updated the same loadline and both fails and need to adjust workcreatedqty
        {
            if (appl.ttsLevel() != 0)
            {
                throw Exception::UpdateConflict;
            }

            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::UpdateConflictNotRecovered;
            }

            retry;
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (appl.ttsLevel() != 0)
            {
                throw Exception::TransientSqlConnectionError;
            }

            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::TransientSqlConnectionError;
            }

            retry;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpWaveStep</Name>
				<Source><![CDATA[
    private void cleanUpWaveStep(WHSPostMethodName _postMethodName, boolean _erroredWave, WHSInstrumentationWaveProcessingDataCleanupPerformanceTask _perfTask)
    {
        WHSWaveStepMethodDataCleanup waveStepMethodDataCleanup = WHSWaveStepMethodDataCleanupFactory::createInstanceFromParameters(waveId, waveExecutionId, _postMethodName, _perfTask);
        
        if (waveStepMethodDataCleanup)
        {
            if (_erroredWave)
            {
                waveStepMethodDataCleanup.cleanupErroredRun();
            }
            else
            {
                waveStepMethodDataCleanup.parmIsInitialWaveCleanUp(this.parmIsInitialWaveCleanUp());
                waveStepMethodDataCleanup.cleanupSuccessfulRun();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeWaveCleanup</Name>
				<Source><![CDATA[
    private void finalizeWaveCleanup(boolean _erroredWave, WHSInstrumentationPerformanceTask _perfTask)
    {
        WHSPostWaveStepMethodDataCleanup postWaveStepMethodDataCleanup = WHSPostWaveStepMethodDataCleanup::construct(waveId, waveExecutionId, _perfTask);
        
        if (_erroredWave)
        {
            postWaveStepMethodDataCleanup.finalizeCleanupForErroredRun();
        }
        else
        {
            postWaveStepMethodDataCleanup.finalizeCleanupForSuccessfulRun();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteQualityOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes quality orders created during the allocation wave step.
    /// </summary>
    /// <param name="_waveId">The wave Id.</param>
    [Hookable(false)]
    internal static NumberOfRecords deleteQualityOrders(WHSWaveId _waveId)
    {
        InventQualityOrderTable     qualityOrder;
        WHSWaveCreatedQualityOrder  waveCreatedQualityOrder;

        // Delete any new quality orders that were created during the wave.
        delete_from qualityOrder
            exists join waveCreatedQualityOrder
            where waveCreatedQualityOrder.InventQualityOrderId  == qualityOrder.QualityOrderId
            &&    waveCreatedQualityOrder.WaveId                == _waveId;

        return qualityOrder.RowCount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteReplenishmentTmpWorkLines</Name>
				<Source><![CDATA[
    private static NumberOfRecords deleteReplenishmentTmpWorkLines(WHSWaveId _waveId)
    {
        using (var waveLockManager = WHSWaveLockManager::newStandard())
        {
            NumberOfRecords       numberOfRecordsDeleted;
            WHSTmpWorkLine        tmpWorkLine;
            WHSWaveStepController waveStepController;

            // Find replenishment tmpWorkLines that have a waveId but no wave table exists for that waveId.
            while select WaveId, DemandWaveId from tmpWorkLine
                group by DemandWaveId, WaveId
                where tmpWorkLine.WaveId != ''
                    && tmpWorkLine.WorkTransType == WHSWorkTransType::Replenishment
            {
                // Verify that this tmpWorkline is not for a currently running wave.
                // If we get a lock then we can assume that the demand replenishment wave replenish() step is not running and tmpWorkLines might need to be deleted.
                boolean acquiredLock = waveLockManager.tryLockForWaveId(tmpWorkLine.WaveId, 0, false);

                // However, in case of failure during replenish() step itself, we also need to clean up temporary work transactions
                // In this case, we use the DemandWaveId to force clean up of replenishment waves associated with the current (errored) wave
                boolean isReplenishmentWaveForCurrentWave = (tmpWorkLine.DemandWaveId == _waveId && tmpWorkLine.WaveId != _waveId);

                if (acquiredLock || isReplenishmentWaveForCurrentWave)
                {
                    if (!waveStepController || waveStepController.WaveId != tmpWorkLine.DemandWaveId)
                    {
                        // For a replenishment wave created in the scope on the current failed wave we should ignore the time delay validation
                        // since it seems clear that if the main wave fails then we should try and clean up the replenishent wave
                        // since it was a direct conseqeunce of the main wave running.                        
                        waveStepController = tmpWorkLine.DemandWaveId == _waveId ?
                                             WHSWaveStepController::findUnlockedRecordByWaveIdWithNoDelay(tmpWorkLine.DemandWaveId) :
                                             WHSWaveStepController::findUnlockedRecordByWaveId(tmpWorkLine.DemandWaveId);

                    }
                    
                    // If we do not have DemandWaveId specified (might be some older tmpWorkLines where it's not popualted) - we want to clean them up
                    // If waveStepController record is found and is not locked, that means at least one step failed, meaning the demand wave failed, so we need to clean up
                    // But need to first check if someone else is not already doing this cleanup (and we passed the wave lock) - should not happen, but to play it safe
                    if (!tmpWorkLine.DemandWaveId 
                        || (waveStepController.RecId != 0 && !WHSWaveStepController::doesWaveHaveLockedControlRecords(waveStepController.WaveId)))
                    {
                        numberOfRecordsDeleted += WHSWaveProcessingDataCleanup::deleteTmpWorkLines(tmpWorkLine.WaveId);
                    }

                    if (acquiredLock)
                    {
                        waveLockManager.releaseForWaveId(tmpWorkLine.WaveId);
                    }
                }
            }

            return numberOfRecordsDeleted;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTmpWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes tmpWorkLine records created during the allocation wave step.
    /// </summary>
    /// <param name="_waveId">The wave Id.</param>
    /// <returns>The number of records that were deleted.</returns>
    [Hookable(false)]
    internal static NumberOfRecords deleteTmpWorkLines(WHSWaveId _waveId)
    {
        WHSTmpWorkLine tmpWorkLine;

        CommonExtensions::SetSqlDeleteIndexHint(tmpWorkLine, indexStr(WHSTmpWorkLine, WaveIdx));

        delete_from tmpWorkLine
            where tmpWorkLine.WaveId == _waveId;

        return tmpWorkLine.RowCount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWaveFailedShipments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes <c>WHSWaveFailedShipment</c> records created during the allocation wave step.
    /// </summary>
    /// <param name="_waveId">The wave Id.</param>
    [Hookable(false)]
    internal static NumberOfRecords deleteWaveFailedShipments(WHSWaveId _waveId)
    {
        WHSWaveFailedShipment waveFailedShipments;
                
        CommonExtensions::SetSqlDeleteIndexHint(waveFailedShipments, indexStr(WHSWaveFailedShipment, WaveIdShipmentIdIdx));

        delete_from waveFailedShipments
            where waveFailedShipments.WaveId == _waveId;

        return waveFailedShipments.RowCount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    /// <summary>
    /// Description for the wave process.
    /// </summary>
    /// <returns>
    /// The description of the class.
    /// </returns>
    public static ClassDescription description()
    {
        return "@WAX:MenuItem_WHSWaveProcessingDataCleanup_Label";
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWaveTrackingData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes temporary tracking data created during the wave process.
    /// </summary>
    private void deleteWaveTrackingData(WHSInstrumentationWaveProcessingDataCleanupPerformanceTask _perfTask)
    {
        _perfTask.setDeleteWaveCreatedLoadRecords(WHSWaveProcessingDataCleanup::deleteWaveCreatedLoadRecords(waveId));
        _perfTask.setDeleteWaveCreatedQualityOrderRecords(WHSWaveProcessingDataCleanup::deleteWaveCreatedQualityOrderRecords(waveId));
        _perfTask.setDeleteWaveUpdatedLoadLineRecords(WHSWaveProcessingDataCleanup::deleteWaveUpdatedLoadLineRecords(waveId));
        _perfTask.setDeleteWaveProcessingStatusRecords(WHSWaveProcessingDataCleanup::deleteWaveProcessingStatusRecords(waveId, isInitialWaveCleanUp));
        _perfTask.setDeleteWaveStepControllerRecords(WHSWaveProcessingDataCleanup::deleteWaveStepControllerRecords(waveId, waveExecutionId));
        _perfTask.setDeleteWavePendingAllocationRecords(WHSWaveProcessingDataCleanup::deleteWavePendingAllocationRecords(waveId, waveExecutionId));
        _perfTask.setDeleteWaveDemandReplenishmentWorkRecords(WHSWaveProcessingDataCleanup::deleteWaveDemandReplenishmentWorkRecords(waveId, waveExecutionId));
        _perfTask.setDeleteWaveErroredIndicatorRecords(WHSWaveProcessingDataCleanup::deleteWaveErroredIndicatorRecords(waveId, waveExecutionId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWaveDemandReplenishmentWorkRecords</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static NumberOfRecords deleteWaveDemandReplenishmentWorkRecords(WHSWaveId _waveId, WHSWaveExecutionID _waveExecutionId)
    {
        WHSWaveDemandReplenishmentWork waveDemandReplenWork;

        CommonExtensions::SetSqlDeleteIndexHint(waveDemandReplenWork, indexStr(WHSWaveDemandReplenishmentWork, WaveExecutionWorkCreateIdx));

        delete_from waveDemandReplenWork
            where waveDemandReplenWork.WaveId == _waveId
                && (!_waveExecutionId || waveDemandReplenWork.WaveExecutionId == _waveExecutionId);

        return waveDemandReplenWork.RowCount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWaveUpdatedLoadLineRecords</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static NumberOfRecords deleteWaveUpdatedLoadLineRecords(WHSWaveId _waveId)
    {
        return WHSWaveUpdatedLoadLine::deleteWaveUpdatedLoadLineRecordsForWaveId(_waveId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWaveCreatedQualityOrderRecords</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static NumberOfRecords deleteWaveCreatedQualityOrderRecords(WHSWaveId _waveId)
    {
        WHSWaveCreatedQualityOrder waveCreatedQualityOrder;

        CommonExtensions::SetSqlDeleteIndexHint(waveCreatedQualityOrder, indexStr(WHSWaveCreatedQualityOrder, WaveIdQualityOrderIdIdx));

        delete_from waveCreatedQualityOrder
            where waveCreatedQualityOrder.WaveId == _waveId;

        return waveCreatedQualityOrder.RowCount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWaveProcessingStatusRecords</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static NumberOfRecords deleteWaveProcessingStatusRecords(WHSWaveId _waveId, boolean _isInitialWaveCleanUp)
    {
        WHSWaveProcessingStatus waveProcessingStatus;
        int                     waveProcessingStatusCount;

        if (_isInitialWaveCleanUp
            && appl.ttsLevel() > 1)
        {
            UserConnection userConnection;

            try
            {
                //We might hit the lock during the wave processing status record insert in user transaction
                //if the deletion of the same record is performed in the same outer transaction.
                //To avoid this situation we are performing deletion in the user transaction if we have outer transactions.
                userConnection = new UserConnection();
                userConnection.ttsbegin();

                waveProcessingStatus.setConnection(userConnection);

                // Delete records in user connection only if they are not already deleted in another transaction.
                waveProcessingStatus.readPast(true);

                while select pessimisticlock waveProcessingStatus
                    where waveProcessingStatus.WaveId == _waveId
                {
                    waveProcessingStatus.delete();
                    waveProcessingStatusCount++;
                }

                userConnection.ttscommit();
            }
            finally
            {
                if (userConnection)
                {
                    userConnection.finalize();
                }
            }
        }
        else
        {
            CommonExtensions::SetSqlDeleteIndexHint(waveProcessingStatus, indexStr(WHSWaveProcessingStatus, WaveWorkBuildIdx));

            delete_from waveProcessingStatus
                    where waveProcessingStatus.WaveId == _waveId;

            waveProcessingStatusCount = waveProcessingStatus.RowCount();
        }

        return waveProcessingStatusCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWavePendingAllocationRecords</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static NumberOfRecords deleteWavePendingAllocationRecords(WHSWaveId _waveId, WHSWaveExecutionID _waveExecutionId)
    {
        WHSWavePendingAllocation pendingAllocation;
        
        CommonExtensions::SetSqlDeleteIndexHint(pendingAllocation, indexStr(WHSWavePendingAllocation, WHSWaveIdItemIdDimIdIdx));

        delete_from pendingAllocation
            where pendingAllocation.WaveId          == _waveId
            &&    (!_waveExecutionId
            ||    pendingAllocation.WaveExecutionID == _waveExecutionId);
        
        return pendingAllocation.RowCount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWaveCreatedLoadRecords</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static NumberOfRecords deleteWaveCreatedLoadRecords(WHSWaveId _waveId)
    {
        WHSWaveCreatedLoad waveCreatedLoad;

        CommonExtensions::SetSqlDeleteIndexHint(waveCreatedLoad, indexStr(WHSWaveCreatedLoad, WaveIdLoadIdIdx));

        delete_from waveCreatedLoad
            where waveCreatedLoad.WaveId == _waveId;

        return waveCreatedLoad.RowCount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWaveStepControllerRecords</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static NumberOfRecords deleteWaveStepControllerRecords(WHSWaveId _waveId, WHSWaveExecutionID _waveExecutionId)
    {
        WHSWaveStepController waveStepController;

        CommonExtensions::SetSqlDeleteIndexHint(waveStepController, indexStr(WHSWaveStepController, WaveIdWaveExecutionIdRecIdIdx));

        // If waveExecutionId was provided we only delete for that execution
        delete_from waveStepController
            where waveStepController.WaveId             == _waveId
            &&    (!_waveExecutionId
            ||    waveStepController.WaveExecutionId    == _waveExecutionId);

        return waveStepController.RowCount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWaveErroredIndicatorRecords</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static NumberOfRecords deleteWaveErroredIndicatorRecords(WHSWaveId _waveId, WHSWaveExecutionID _waveExecutionId)
    {
        WHSWaveErroredIndicator waveErrorIndicator;

        CommonExtensions::SetSqlDeleteIndexHint(waveErrorIndicator, indexStr(WHSWaveErroredIndicator, WaveIdWaveExecutionIdIdx));

        delete_from waveErrorIndicator
            where waveErrorIndicator.WaveId             == _waveId
            &&    (!_waveExecutionId
            ||    waveErrorIndicator.WaveExecutionID    == _waveExecutionId);

        return waveErrorIndicator.RowCount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWaveExecutionId</Name>
				<Source><![CDATA[
    public WHSWaveExecutionID parmWaveExecutionId(WHSWaveExecutionID _waveExecutionId = waveExecutionId)
    {
        waveExecutionId = _waveExecutionId;

        return waveExecutionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWaveId</Name>
				<Source><![CDATA[
    protected WHSWaveId parmWaveId(WHSWaveId _waveId = waveId)
    {
        waveId = _waveId;

        return waveId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetWaveTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the wave table data to represent an unprocess waved.
    /// </summary>
    /// <param name="_waveId">The wave Id.</param>
    [Hookable(false)]
    internal static NumberOfRecords resetWaveTable(WHSWaveId _waveId)
    {
        NumberOfRecords numberOfRecords;

        ttsBegin;

        WHSWaveTable waveTable = WHSWaveTable::find(_waveId, true);

        if (waveTable)
        {
            waveTable.resetToStatusCreated();

            numberOfRecords++;
        }

        ttscommit;

        return numberOfRecords;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// With process the cleanup for a single wave.
    /// </summary>
    public void run()
    {
        using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContextBatchServer(this))
        {
            // Validate that wave should be cleaned up
            if (this.validateWaveEligibleForManualCleanup())
            {
                // Run cleanup
                this.cleanupErroredWave();
            }
            else
            {
                warning(strFmt("@WAX:WaveNotEligibleForCleanup", waveId));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWaveEligibleForManualCleanup</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute, Wrappable(true)]
    internal boolean validateWaveEligibleForManualCleanup()
    {
        boolean isEligible = this.validateWaveEligibleForCleanup();
        return isEligible || this.isWaveStuckInExecutingStatus(WHSWaveTable::find(this.parmWaveId()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWaveStuckInExecutingStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the wave is stuck in executing status.
    /// </summary>
    /// <param name = "_wave">The <c>WHSWaveTable</c> record of the wave to check if it's stuck.</param>
    /// <returns>true if the wave is stuck in executing status; false otherwise.</returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute, Wrappable(true)]
    internal boolean isWaveStuckInExecutingStatus(WHSWaveTable _wave)
    {
        return !_wave.inBatch() && _wave.waveStatus == WHSWaveStatus::Executing;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWaveEligibleForCleanup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the wave is eligible for cleanup.
    /// </summary>
    /// <returns>
    /// true if the wave is eligible for cleanup; otherwise, false.
    /// </returns>
    public boolean validateWaveEligibleForCleanup()
    {
        var waveStepController = WHSWaveStepController::findUnlockedRecordByWaveId(this.parmWaveId());
        boolean ret = waveStepController.RecId != 0;

        if (ret)
        {
            // Make sure the wave isn't still partially running by checking for locked control records.
            if (WHSWaveStepController::doesWaveHaveLockedControlRecords(waveStepController.WaveId))
            {
                // Create an error indicator in case one was not created.
                WHSWaveErroredIndicator::createRecordIfUnique(waveStepController.WaveId, waveStepController.WaveExecutionID);
                ret = false;
            }
        } 

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static WHSWaveProcessingDataCleanup construct()
    {
        return new WHSWaveProcessingDataCleanup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        if (_args.record()
        &&  _args.dataset() == tableNum(WHSWaveTable))
        {
            WHSWaveTable waveTable = _args.record() as WHSWaveTable;
            var waveProcessingDataCleanup = WHSWaveProcessingDataCleanup::newFromWaveId(waveTable.WaveId);

            using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContextBatchController(waveProcessingDataCleanup))
            {
                if (waveProcessingDataCleanup.prompt()) 
                {                
                    waveProcessingDataCleanup.parmWaveCleanupType('ManualWaveCleanup');

                    waveProcessingDataCleanup.runOperation();
                }            
            }
        }
        else
        {
            throw error(Error::missingRecord(tableStr(WHSWaveTable)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>prompt</Name>
				<Source><![CDATA[
    public boolean prompt()
    {
        DialogButton success = true;

        // Additional confirmation is required if wave is in executing mode because cleaning data of a wave while it is being executed can be dangerous.
        if (WHSWaveTable::find(this.waveId).WaveStatus == WHSWaveStatus::Executing)
        {
            success = Box::yesNo("@WAX:ConfirmWaveDataCleanupForWaveInExecution_Message", DialogButton::No);

            if (!success)
            {
                info("@SYS93835");
            }
            else
            {
                info("@WAX:ProgressingWaveDataCleanup_InfoMessage");
            }
        }

        return success;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList] = _packedClass;
                break;

            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForWaveExecution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of <c>WHSWaveProcessingDataCleanup</c> for a specific wave execution process.
    /// </summary>
    /// <param name="_waveId">
    /// The wave Id.
    /// </param>
    /// <param name="_waveExecutionId">
    /// The wave execution Id that identifies the specific wave execution process.
    /// </param>
    /// <returns>
    /// An instance of <c>WHSWaveProcessingDataCleanup</c>.
    /// </returns>
    /// <remarks>
    /// This constructor should be used if you know the specific wave execution process that needs to be cleaned up.
    /// </remarks>
    public static WHSWaveProcessingDataCleanup newForWaveExecution(
        WHSWaveId           _waveId,
        WHSWaveExecutionId  _waveExecutionId)
    {
        var waveProcessingDataCleanup = WHSWaveProcessingDataCleanup::construct();
        waveProcessingDataCleanup.parmWaveId(_waveId);
        waveProcessingDataCleanup.parmWaveExecutionId(_waveExecutionId);

        return waveProcessingDataCleanup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromWaveId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of <c>WHSWaveProcessingDataCleanup</c> for a wave Id.
    /// </summary>
    /// <param name="_waveId">
    /// The wave Id.
    /// </param>
    /// <returns>
    /// An instance of <c>WHSWaveProcessingDataCleanup</c>.
    /// </returns>
    /// <remarks>
    /// This constructor should be used if you don't know the wave Execution Id and the wave isn't being process currently.
    /// </remarks>
    public static WHSWaveProcessingDataCleanup newFromWaveId(WHSWaveId _waveId)
    {
        var waveProcessingDataCleanup = WHSWaveProcessingDataCleanup::construct();
        waveProcessingDataCleanup.parmWaveId(_waveId);

        return waveProcessingDataCleanup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInitialCleanUp</Name>
				<Source><![CDATA[
    private static WHSWaveProcessingDataCleanup newInitialCleanUp(WHSWaveId _waveId)
    {
        var waveProcessingDataCleanupInitial = WHSWaveProcessingDataCleanup::newFromWaveId(_waveId);
        waveProcessingDataCleanupInitial.parmWaveCleanupType('InitialWaveCleanup');
        waveProcessingDataCleanupInitial.parmIsInitialWaveCleanUp(true);

        return waveProcessingDataCleanupInitial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>identifyAndCleanupErroredWavesForWarehouse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Attempts to find unlocked wave control records and process cleanup for those waves.
    /// </summary>
    /// <param name="_inventLocationId">
    /// The warehouse criteria for waves which we must check for and clean up.
    /// </param>
    /// <param name="_callerWaveId">
    /// The caller wave Id for finalize.
    /// </param>
    /// <param name="_callerWaveExecutionId">
    /// The caller wave execution Id for finalize.
    /// </param>
    /// <remarks>
    /// The <c>WhSWaveStepController</c> records should only exists and be unlocked when an error has occured that was not handled by wave cleanup.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// An error is thrown if the unlocked control record is for the same wave execution as the caller is running, meaning that a parallel allocation task failed but wasn't handled.
    /// </exception>
    public static void identifyAndCleanupErroredWavesForWarehouse(
        InventLocationId    _inventLocationId,
        WHSWaveId           _callerWaveId = '',
        WHSWaveExecutionID  _callerWaveExecutionId = '')
    {
        WHSWaveProcessingDataCleanup::identifyAndCleanupErroredWavesForWarehouseWithCleanupType(_inventLocationId, 'OtherFailedWaveCleanup', _callerWaveId, _callerWaveExecutionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>identifyAndCleanupErroredWavesForWarehouseWithCleanupType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Attempts to find unlocked wave control records and process cleanup for those waves.
    /// </summary>
    /// <param name="_inventLocationId">
    /// The warehouse criteria for waves which we must check for and clean up.
    /// </param>
    /// <param name="_callerWaveId">
    /// The caller wave Id for finalize.
    /// </param>
    /// <param name="_callerWaveExecutionId">
    /// The caller wave execution Id for finalize.
    /// </param>
    /// <param name="_waveCleanUpType">
    /// String representing type of wave cleanup.
    /// </param>
    /// <remarks>
    /// The <c>WhSWaveStepController</c> records should only exists and be unlocked when an error has occured that was not handled by wave cleanup.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// An error is thrown if the unlocked control record is for the same wave execution as the caller is running, meaning that a parallel allocation task failed but wasn't handled.
    /// </exception>
    internal static void identifyAndCleanupErroredWavesForWarehouseWithCleanupType(
        InventLocationId    _inventLocationId,
        Str                 _waveCleanUpType,
        WHSWaveId           _callerWaveId = '',
        WHSWaveExecutionID  _callerWaveExecutionId = '')
    {
        WHSWaveStepController   waveStepController;
        
        do
        {
            ttsbegin;

            waveStepController = WHSWaveStepController::findUnlockedRecordByWarehouse(_inventLocationId);

            // If we find a control record then an error has occured and we should clean up
            if (waveStepController.RecId != 0)
            {
                // If the control record is for the same wave run as the caller then we can just throw an error and let normal catch cleanup happen.
                if (waveStepController.WaveId           == _callerWaveId
                &&  waveStepController.WaveExecutionID  == _callerWaveExecutionId)
                {
                    throw error("@WAX:WaveProcessingUnidentifiedError");
                }
                
                var waveProcessingDataCleanup = WHSWaveProcessingDataCleanup::newForWaveExecution(waveStepController.WaveId, waveStepController.WaveExecutionId);
                waveProcessingDataCleanup.parmWaveCleanupType(_waveCleanUpType);

                boolean successfulCleanup;
                if (waveProcessingDataCleanup.validateWaveEligibleForCleanup())
                {
                    successfulCleanup = waveProcessingDataCleanup.tryCleanupErroredWave();                    
                }
                
                if (!successfulCleanup)
                {
                    warning(strFmt("@WAX:WaveCleanupNotRunWarning", waveStepController.WaveId));
                    WHSWaveProcessingDataCleanup::notifyOnWaveExecutionFailure(waveStepController, infolog.text());
                    // We clear the controller record so we exit the loop.
                    // We want to exit the loop because we cannot easily determine what waves we have already checked in this loop and risk hitting the same control record indefinitely.
                    // There should be limited impact to not cleaning up the wave prior to allocation, such as suboptimal allocation. This is expected to be a low occurrence scenario, so we are ok with this risk.
                    waveStepController.clear();
                }
                else
                {
                    WHSWaveProcessingDataCleanup::notifyOnWaveExecutionFailure(waveStepController, "@WAX:WaveProcessingUnidentifiedError");
                }
            }

            ttscommit;
        }
        while (waveStepController.RecId); // Keep looping until no control records are found
    }

]]></Source>
			</Method>
			<Method>
				<Name>notifyOnWaveExecutionFailure</Name>
				<Source><![CDATA[
    private static void notifyOnWaveExecutionFailure(WHSWaveStepController _cleanedWaveStepController, str _errorMessage)
    {
        WHSWaveTable erroredWaveTable = WHSWaveTable::find(_cleanedWaveStepController.WaveId);        
        WhsWaveNotificationManager::instance().handleNotificationsOnWaveExecuted(erroredWaveTable, _cleanedWaveStepController.WaveExecutionId, 0, _errorMessage);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPerformanceTask</Name>
				<Source><![CDATA[
    private WHSInstrumentationWaveProcessingDataCleanupPerformanceTask createPerformanceTask(str _action)
    {
        return new WHSInstrumentationWaveProcessingDataCleanupPerformanceTask(WHSWaveTable::find(waveId).RecId, waveExecutionId, _action, waveCleanupType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMethodPerformanceTask</Name>
				<Source><![CDATA[
    private WHSInstrumentationWaveProcessingDataCleanupPerformanceTask createMethodPerformanceTask(str _action, WHSPostMethodName _postMethodName, boolean _erroredWave)
    {
        return WHSInstrumentationWaveProcessingDataCleanupPerformanceTask::newPostMethod(WHSWaveTable::find(waveId).RecId, waveExecutionId, _action, waveCleanupType, _postMethodName, _erroredWave);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPerformanceTaskForCleanupFailure</Name>
				<Source><![CDATA[
    private WHSInstrumentationPerformanceTask createPerformanceTaskForCleanupFailure()
    {
        //we need to avoid any DB interaction here so we have to pass 0 as wave recId
        return new WHSInstrumentationWaveProcessingDataCleanupPerformanceTask(0, waveExecutionId, 'cleanUpErroredWaveExceptionCaseCleanupTmpWorkLinesOnly', waveCleanupType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>errorMessageHelpScopeFormName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the form name used for the error context using a <c>SysErrorMessageHelpScope</c> class.
    /// </summary>
    /// <returns>The form name used for the error context.</returns>
    [Hookable(false)]
    public FormName errorMessageHelpScopeFormName()
    {
        return strFmt('%1_%2', formStr(Dialog), classStr(WHSWaveProcessingDataCleanup));
    }

]]></Source>
			</Method>
			<Method>
				<Name>errorMessageHelpScopeActionName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the action name used for the error context using a <c>SysErrorMessageHelpScope</c> class.
    /// </summary>
    /// <returns>The action name used for the error context.</returns>
    [Hookable(false)]
    public str errorMessageHelpScopeActionName()
    {
        return menuItemActionStr(WHSWaveProcessingDataCleanup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    private WHSInstrumentationLogger instrumentationLogger()
    {
        if (!instrumentationLogger)
        {
            instrumentationLogger = WHSInstrumentationLogger::createLogger(classId2Name(classIdGet(this)));
        }

        return instrumentationLogger;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>