<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjPostEmplJournal</Name>
	<SourceCode>
		<Declaration><![CDATA[
class ProjPostEmplJournal extends ProjPost
{
    Common buffer;
    ProdJournalRoute prodJournalRoute;
    ProdRouteTrans prodRouteTrans;
    ProjTransIdBase projTransId;
    ProjEmplTrans projEmplTrans;
    RefRecId intercompanyDueToCompany;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>budgetUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the budget amount.
    /// </summary>
    public void budgetUpdate()
    {
        ProjBudgetTransaction projBudgetTransaction;
        ProjBudgetTransactionLine projBudgetTransactionLine;
        ProjBudgetReductionHistory projBudgetReductionHistory;

        if (projEmplTrans.TransactionOrigin == ProjOrigin::ProductionConsumed)
        {
            if (projTrans.qty() < 0)
            {
                if (!this.parmTransIdOrig())
                {
                    this.parmTransIdOrig(this.parmTransIdCost());
                }

                if (ProjBudgetReductionHistory::existProjTransId(this.parmTransIdOrig()))
                {
                    super();
                }
                else
                {
                    //try to using route.projTransId to return
                    projBudgetTransactionLine = ProjBudgetTransactionLine::construct(projTrans.buffer());
                    projBudgetTransactionLine.parmTransIdRef(ProjEmplTrans::find(this.parmTransIdOrig()).TransIdRef);

                    projBudgetTransaction = new ProjBudgetTransaction();
                    projBudgetTransaction.addBudgetTransactionLine(projBudgetTransactionLine);

                    ProjBudgetTransactionManager::newProjBudgetTransactionManager(projBudgetTransaction).adjustBudget(ProjBudgetAdjustmentType::Increment);
                }
            }
            else
            {
                select projBudgetReductionHistory
                    where projBudgetReductionHistory.ProjTransId == this.parmTransIdCost();

                if (projBudgetReductionHistory)
                {
                    projBudgetTransactionLine = ProjBudgetTransactionLine::construct(projTrans.buffer());
                    projBudgetTransactionLine.parmTransIdRef(this.parmTransIdCost());

                    projBudgetTransaction = new ProjBudgetTransaction();
                    projBudgetTransaction.addBudgetTransactionLine(projBudgetTransactionLine);

                    ProjBudgetTransactionManager::newProjBudgetTransactionManager(projBudgetTransaction).adjustBudget(ProjBudgetAdjustmentType::Increment);

                    super();
                }
                else
                {
                    super();
                }
            }
        }
        else
        {
            super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEnterNeverLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the project ledger status field for costs to determine whether costs are posted to general
    /// ledgers.
    /// </summary>
    /// <returns>
    /// true if the project ledger status for costs is equal to the <c>ProjLedgerStatus::Never</c>
    /// enumeration value; otherwise, false.
    /// </returns>
    public boolean checkEnterNeverLedger()
    {
        if (!this.parmNotEnterNeverLedger()
            && (this.parmLedgerStatusCost() == ProjLedgerStatus::Never
                || (projTrans.transCost() == 0 && projTrans.qty())))
        {
            // if LedgerStatusCost is set to Never
            // if costPrice is set to zero a never ledger transactions must be created in projTransPosting
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLedgerStatusOrig</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the ledger posting status is set not to post.
    /// </summary>
    /// <returns>
    /// false
    /// </returns>
    public boolean checkLedgerStatusOrig()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLedgerTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the transaction has a valid date, a posting period has been set up for the date, and
    /// the period is open for posting.
    /// </summary>
    /// <returns>
    /// true if the system can create a ledger entry for the date; otherwise, false.
    /// </returns>
    protected boolean checkLedgerTransDate()
    {
        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkQtyNegative</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the transaction should check for negative quantity values.
    /// </summary>
    /// <returns>
    /// Gets false.
    /// </returns>
    public boolean checkQtyNegative()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkReverseCommittedCost</Name>
				<Source><![CDATA[
    public boolean checkReverseCommittedCost()
    {
        ProjTransRouteJournal projTransRouteJournal;
        ProdRoute prodRoute_tmp;
        ProdRouteProj prodRouteProj_tmp;

        if (!projTrans)
        {
            return false;
        }

        if (SysDictClass::isEqualOrSuperclass(classIdGet(projTrans),classNum(ProjTransRouteJournal)))
        {
            projTransRouteJournal = projTrans;
            prodRoute_tmp = projTransRouteJournal.prodRoute();
            prodRouteProj_tmp = projTransRouteJournal.prodRouteProj();

            if (this.parmCommittedCostReverse()
                && projTrans.mustHandleCommittedCost()
                && CostControlTransCommittedCost::findOpenedByProjTransID(prodRouteProj_tmp.ProjTransId))
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        else
        {
            return super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTrans</Name>
				<Source><![CDATA[
    public boolean checkTrans(boolean _throwerror = false)
    {
        ListEnumerator enumerator;
        ProjFundingSourceRefId fundingSourceId;
        LedgerDimensionAccount mergedLedgerDimension;
        LedgerDimensionDefaultAccount defaultLedgerDimension;

        boolean ok = super();

        ok = (ok && projTrans.validateWrite());

        if (!projTrans.linePropertyId())
        {
            // Line property is missing.
            ok = checkFailed("@SYS50154") && ok;
        }

        ProjLedgerStatus emplLedgerStatus;
        NoYes postWIPEmpl;
        ProjTable projTable = ProjTable::find(projTrans.projId());

        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            if (!projTable.ProjInvoiceProjId)
            {
                // Internal project, post cost to P/L accounts.
                emplLedgerStatus = ProjLedgerStatus::Operations;
                postWIPEmpl = NoYes::No;
            }
            else
            {
                ProjRevenueProfile revProfile = ProjRevRecHelper::getRevProfileForTransactionType(projTable, ProjTransType::Hour);
                emplLedgerStatus = revProfile.EmplLedgerStatus;
                postWIPEmpl = revProfile.PostWIPEmpl;
            }
        }
        else
        {
            ProjGroup projGroup = ProjGroup::find(projTable.ProjGroupId);
            emplLedgerStatus = projGroup.EmplTransCost;
            postWIPEmpl = projGroup.EmplTransTurnover;
        }
        
        if (projTrans.transCost() && (emplLedgerStatus == ProjLedgerStatus::BalanceSheet || emplLedgerStatus == ProjLedgerStatus::Operations))
        {
            if (this.costEnterDebit())
            {
                enumerator = ProjFundingSource::getFundingSources(projTrans).getEnumerator();
                while (enumerator.moveNext())
                {
                    fundingSourceId = enumerator.current();
                    this.postingType(emplLedgerStatus == ProjLedgerStatus::BalanceSheet ?
                                 (projTrans.projLineProperty().ToBeCapitalize ?
                                 LedgerPostingType::ProjCost : LedgerPostingType::ProjWIPCostvalue) :
                                 LedgerPostingType::ProjCost);

                    defaultLedgerDimension = this.parmLedgerDimension(emplLedgerStatus == ProjLedgerStatus::BalanceSheet ?
                                projTrans.statusAccountLedgerDimension(fundingSourceId) :
                                projTrans.costAccountLedgerDimension(fundingSourceId));


                    RefRecId accountNum = LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(defaultLedgerDimension);

                    if (ProjPostEmplJourFixedDimensionsValidateFlight::instance().isEnabled())
                    {
                        mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultLedgerDimension, this.defaultDimension(), ProjFundingSource::find(fundingSourceId).DefaultDimension);   
                        mergedLedgerDimension = LedgerDimensionFacade::serviceApplyFixedDimensions(mergedLedgerDimension);

                        // Re-create new LD as applying fixed may have changed which advanced rules are added to the combination
                        mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(mergedLedgerDimension);
                    }
                    else
                    {
                        MainAccountLegalEntity mainAccountLegalEntity;

                        select firstOnly DefaultDimension, FixedDimensions from mainAccountLegalEntity
                            where mainAccountLegalEntity.MainAccount == accountNum
                                && mainAccountLegalEntity.LegalEntity == CompanyInfo::current();

                        if (mainAccountLegalEntity.FixedDimensions && mainAccountLegalEntity.DefaultDimension)
                        {
                            DefaultDimensionView defaultDimensionView;
                            DimensionAttributeSetItem dimAttributeSetitem;
                            DimensionDefault dimensionDefault;

                            while select defaultDimensionView
                                where defaultDimensionView.DefaultDimension == mainAccountLegalEntity.DefaultDimension
                                join dimAttributeSetitem
                                    where dimAttributeSetitem.DimensionAttributeSet == mainAccountLegalEntity.FixedDimensions
                                        && dimAttributeSetitem.EnumerationValue == 1
                                        && dimAttributeSetitem.DimensionAttribute == defaultDimensionView.DimensionAttributeId
                            {
                                DimensionAttributeValue dimensionAttributeValue = 
                                    DimensionAttributeValue::findByDimensionAttributeAndValue(
                                        DimensionAttribute::find(defaultDimensionView.DimensionAttributeId),
                                        defaultDimensionView.DisplayValue, false, true);

                                DimensionAttributeValueSetStorage dimensionAttributeValueSetStorage = new DimensionAttributeValueSetStorage();
                                dimensionAttributeValueSetStorage.addItem(dimensionAttributeValue);

                                dimensionDefault = dimensionAttributeValueSetStorage.save();

                                LedgerDimensionAccount createdLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultLedgerDimension, this.defaultDimension(), dimensionDefault, ProjFundingSource::find(fundingSourceId).DefaultDimension);
                                
                                mergedLedgerDimension = LedgerDimensionFacade::serviceMergeLedgerDimensions(mergedLedgerDimension, createdLedgerDimension);
                            }
                        }
                    }

                    if (!mergedLedgerDimension)
                    {
                        if (this.parmAdjustment() && this.parmTransStatus() == ProjTransStatus::Adjusted && FeatureStateProvider::isFeatureEnabled(ProjAdjustmentKeepOrigFinDimOnReversingTransFeature::instance()))
                        {
                            // For adjusted reverting transaction, directly take default dimension from original transaction
                            mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultLedgerDimension, this.defaultDimension());
                        }
                        else
                        {
                            // need to merge the default account with the default dimensions and do the check on the fully instantiated account
                            mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultLedgerDimension, this.defaultDimension(), ProjFundingSource::find(fundingSourceId).DefaultDimension);
                        }
                    }

                    ok = MainAccount::checkAllowPosting(LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(mergedLedgerDimension)) && ok;

                    if (ok && TaxParameters::find().ValidateTaxCode)
                    {
                        MainAccount mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(mergedLedgerDimension);
                        ok = Tax::checkNoTax(mainAccount, projTrans.taxGroup(), projTrans.TaxItemGroup());
                    }

                    DimensionValidationRequest dimensionValidationRequest = DimensionValidationRequest::newForLedgerDimension(mergedLedgerDimension);

                    DimensionValidationStatusContract dimensionValidationStatusContract = DimensionValidation::getStatus(dimensionValidationRequest);

                    if (!dimensionValidationStatusContract.isValid())
                    {
                        ok = false;
                       
                        List validationMessages = dimensionValidationStatusContract.parmValidationMessages();
                        
                        ListEnumerator messagesEnumerator = validationMessages.getEnumerator();
                        
                        while (messagesEnumerator.moveNext())
                        {
                            info(messagesEnumerator.current());
                        }
                    }
                }
            }

            if (ok && this.costEnterCredit())
            {
                if (!enumerator)
                {
                    enumerator = ProjFundingSource::getFundingSources(projTrans).getEnumerator();
                }
                else
                {
                    enumerator.reset();
                }

                while (enumerator.moveNext())
                {
                    fundingSourceId = enumerator.current();
                    this.postingType(LedgerPostingType::ProjPayrollAllocation);

                    defaultLedgerDimension = this.parmLedgerDimension(projTrans.payrollAllocationLedgerDimension(fundingSourceId));
                    // need to merge the default account with the default dimensions and do the check on the fully instantiated account
                    mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultLedgerDimension, this.defaultDimension());
                   
                    ok = MainAccount::checkAllowPosting(LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(mergedLedgerDimension)) && ok;
                }
            }
        }

        if (projTrans.canBeInvoiced() && projTrans.transTurnover() && postWIPEmpl)
        {
            if (!enumerator)
            {
                enumerator = ProjFundingSource::getFundingSources( projTrans ).getEnumerator();
            }
            else
            {
                enumerator.reset();
            }

            while (enumerator.moveNext())
            {
                fundingSourceId = enumerator.current();
                defaultLedgerDimension = projTrans.salesOffsetAccountLedgerDimension(fundingSourceId);

                // need to merge the default account with the default dimensions and do the check on the fully instantiated account
                mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultLedgerDimension, this.defaultDimension());
                ok = MainAccount::checkAllowPosting(LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(mergedLedgerDimension)) && ok;

                defaultLedgerDimension = projTrans.salesValueAccountLedgerDimension(fundingSourceId);

                // need to merge the default account with the default dimensions and do the check on the fully instantiated account
                mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultLedgerDimension, this.defaultDimension());
                ok = MainAccount::checkAllowPosting(LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(mergedLedgerDimension)) && ok;
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateBudget</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a budget update is required.
    /// </summary>
    /// <returns>
    ///    true if a budget update is required; otherwise, false.
    /// </returns>
    public boolean checkUpdateBudget()
    {
        boolean ret;

        ret = super();

        if (ret)
        {
            if (this.parmTransIdOrig() && projTrans.qty() > 0)
            {
                ret = true;
            }
            if (!this.parmTransIdOrig() && projTrans.qty() < 0)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateForecast</Name>
				<Source><![CDATA[
    public boolean checkUpdateForecast()
    {
        boolean ret = super();

        if (ret && this.parmTransIdOrig() && projTrans.qty() > 0)
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>committedCostReverse</Name>
				<Source><![CDATA[
    public void committedCostReverse()
    {
        CostControlPostingHour costControlPostingHour;
        ProjTransRouteJournal projTransRouteJournal;
        ProdRoute prodRoute_tmp;
        ProdRouteProj prodRouteProj_tmp;
        ProdJournalRoute prodJournalRoute_tmp;
        ProdJournalRouteProj prodJournalRouteProj_tmp;

        ProjTransEmplJournal projTransEmplJournal;
        ProjJournalTrans projJournalTrans_tmp;

        if (SysDictClass::isEqualOrSuperclass(classIdGet(projTrans),classNum(ProjTransRouteJournal)))
        {
            projTransRouteJournal = projTrans;
            prodRoute_tmp = projTransRouteJournal.prodRoute();
            prodRouteProj_tmp = projTransRouteJournal.prodRouteProj();
            prodJournalRoute_tmp = projTransRouteJournal.childBuffer();
            prodJournalRouteProj_tmp = projTransRouteJournal.buffer();

            costControlPostingHour = CostControlPosting::newCostControlPostingHour(prodRoute_tmp, prodRouteProj_tmp);
            costControlPostingHour.parmLedgerVoucher(this.parmLedgerVoucher());
            costControlPostingHour.parmLedgerDimensionDefaultAccount(this.debitAccountCostValueLedgerDimension(projTrans.fundingSource()));
            costControlPostingHour.parmFinancial(prodJournalRouteProj_tmp.TransType == ProdRouteTransType::Time ? prodJournalRoute_tmp.Hours : prodJournalRoute_tmp.QtyGood + prodJournalRoute_tmp.QtyError);

            costControlPostingHour.run(ProjCommittedCostUpdateAction::Post);
        }
        else if (SysDictClass::isEqualOrSuperclass(classIdGet(projTrans),classNum(ProjTransEmplJournal)))
        {
            projTransEmplJournal = projTrans;
            projJournalTrans_tmp = projTransEmplJournal.projJournalTrans();

            costControlPostingHour = CostControlPosting::newCostControlPostingHour(projJournalTrans_tmp, null);
            costControlPostingHour.parmLedgerVoucher(this.parmLedgerVoucher());
            costControlPostingHour.parmLedgerDimensionDefaultAccount(this.debitAccountCostValueLedgerDimension(projTrans.fundingSource()));
            costControlPostingHour.parmFinancial(projJournalTrans_tmp.Qty);

            costControlPostingHour.run(ProjCommittedCostUpdateAction::Post);
        }
        else
        {
            super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>costEnterCredit</Name>
				<Source><![CDATA[
    protected boolean costEnterCredit()
    {
        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditAccountCostValueLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ledger dimension for posting the credit side of transactions for costs.
    /// </summary>
    /// <param name="_fundingSourceID">
    ///    The funding source that is associated with the project contract that will be used by this
    ///    transaction.
    /// </param>
    /// <returns>
    ///    The ledger dimension for posting the credit amounts for costs.
    /// </returns>
    public LedgerDimensionDefaultAccount creditAccountCostValueLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        if (this.parmIntercompanyDueToCompany())
        {
            return projTrans.intercompanyVendAccountLedgerDimension(this.parmIntercompanyDueToCompany());
        }

        return projTrans.payrollAllocationLedgerDimension(_fundingSourceID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>debitAccountCostValueLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ledger dimension that is used for the debit side of a posting transaction for costs.
    /// </summary>
    /// <param name="_fundingSourceId">
    ///    The funding source that is associated with the project contract that will be used by this
    ///    transaction.
    /// </param>
    /// <returns>
    ///    The ledger dimension that is used for posting the debit amounts of cost transactions.
    /// </returns>
    public LedgerDimensionDefaultAccount debitAccountCostValueLedgerDimension(ProjFundingSourceRefId _fundingSourceId)
    {
        LedgerDimensionDefaultAccount ledgerDimension;

        switch (this.parmLedgerStatusCost())
        {
            case ProjLedgerStatus::BalanceSheet:
                if (projTrans.projLineProperty().ToBeCapitalize)
                {
                    ledgerDimension = projTrans.statusAccountLedgerDimension(_fundingSourceId);
                }
                else
                {
                    ledgerDimension = projTrans.costAccountLedgerDimension(_fundingSourceId);
                }
                break;

            case ProjLedgerStatus::Operations:
                ledgerDimension = projTrans.costAccountLedgerDimension(_fundingSourceId);
                break;
        }
        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the default dimension value from the <c>projTrans</c> class object variable.
    /// </summary>
    /// <returns>
    /// The default dimension value from the <c>projTrans</c> class object variable.
    /// </returns>
    public DimensionDefault defaultDimension()
    {
        DimensionDefault defaultDimension = super();

        if (this.postingType() == LedgerPostingType::ProjPayrollAllocation)
        {
            ProjWorkerRecId workerRecId = ResourceFacade::getWorker(projTrans.resource());

            if (workerRecId && HcmWorker::workerStatusServer(workerRecId) == HcmWorkerStatus::Terminated)
            {
                ProjTransPosting projTransPosting;

                select firstOnly DefaultDimension from projTransPosting
                    where projTransPosting.TransId == this.parmAdjRefTransId()
                        && projTransPosting.PostingType == LedgerPostingType::ProjPayrollAllocation;

                defaultDimension = projTransPosting.DefaultDimension ? projTransPosting.DefaultDimension : defaultDimension;
            }
            else
            {
                DimensionDefault workerDefaultDimension = HcmEmployment::findByWorkerLegalEntity(workerRecId, CompanyInfo::current(), projTrans.transDate()).DefaultDimension;
                
                if (FeatureStateProvider::isFeatureEnabled(ProjPayrollAllocationAllowsOnlyWorkerDimensionsFeature::instance()))
                {
                    defaultDimension = workerDefaultDimension;
                }
                else
                {
                    defaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(workerDefaultDimension, defaultDimension, ProjTable::find(projTrans.projId()).DefaultDimension);
                }

            }
        }
        else if (this.postingType() == LedgerPostingType::ProjCost)
        {
            if (this.parmAdjustment() && this.parmTransStatus() == ProjTransStatus::Adjusted && FeatureStateProvider::isFeatureEnabled(ProjAdjustmentKeepOrigFinDimOnReversingTransFeature::instance()))
            {
                // For adjusted reverting transaction, directly take default dimension from original transaction
                defaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(defaultDimension, projEmplTrans.DefaultDimension);
            }
            else
            {
                defaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(defaultDimension, projEmplTrans.DefaultDimension, ProjTable::find(projTrans.projId()).DefaultDimension);
            }
        }

        return defaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>forecastUpdate</Name>
				<Source><![CDATA[
    public void forecastUpdate()
    {
        ProjForecastReduce projForecastReduce;
        ProjForecastReductionHistory projForecastReductionHistory;

        if (projEmplTrans.TransactionOrigin == ProjOrigin::ProductionConsumed)
        {
            if (projTrans.qty() < 0)
            {
                if ( !this.parmTransIdOrig())
                {
                    this.parmTransIdOrig(this.parmTransIdCost());
                }

                // Two step return: try to using routeJournal.projTransId to return
                if (ProjForecastReductionHistory::existProjTransId(this.parmTransIdOrig()))
                {
                    projForecastReduce = ProjForecastReduce::newProjPost(projTrans, projTrans.qty(), projTrans.transCost());
                    projForecastReduce.parmProjTransIdOrig(this.parmTransIdOrig());
                    projForecastReduce.parmProjTransId(this.parmTransIdCost());

                    projForecastReduce.run();
                }
                else //try to using route.projTransId to return
                {
                    projForecastReduce=ProjForecastReduce::newProjPost(projTrans, projTrans.qty(), projTrans.transCost());
                    projForecastReduce.parmProjTransIdOrig(ProjEmplTrans::find(this.parmTransIdOrig()).TransIdRef);
                    projForecastReduce.parmProjTransId(this.parmTransIdCost());

                    projForecastReduce.run();
                }
            }
            else
            {
                select projForecastReductionHistory
                    where projForecastReductionHistory.ProjTransId == this.parmTransIdCost()
                        && projForecastReductionHistory.QtyReduced == -projTrans.qty();

                if (projForecastReductionHistory)
                {
                    projForecastReduce=ProjForecastReduce::newVirtual(this.parmTransIdCost(), projTrans.transType());
                    projForecastReduce.parmProjTransId(this.parmTransIdCost());

                    projForecastReduce.reduceForecast(projTrans.qty(), projTrans.transCost());
                }
                else
                {
                    super();
                }
            }
        }
        else
        {
            super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveTransStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the transaction status.
    /// </summary>
    /// <returns>
    /// The transaction status.
    /// </returns>
    protected ProjTransStatus retrieveTransStatus()
    {
        ProjTransStatus ret = this.parmTransStatus();

        if (!ret)
        {
            ret = ProjTransStatus::Posted;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initUpdate</Name>
				<Source><![CDATA[
    public void initUpdate()
    {
        if (buffer.TableId == tableNum(ProdJournalRouteProj))
        {
            projTrans = ProjTrans::newProdJournalRouteProj(prodRouteTrans, prodJournalRoute, buffer);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjEmplTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the hour transaction record member of the class instance.
    /// </summary>
    protected void initializeProjEmplTrans()
    {
        switch (buffer.TableId)
        {
            case tableNum(ProjJournalTrans):
                projEmplTrans  = ProjEmplTrans::initTransFromJournal(buffer);
                if (ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled()
                    && this.parmTransIdRef()
                    && this.parmTransactionOriginOrig() == ProjOrigin::ProjAdvancedJournal
                    && (this.parmLedgerStatusCost() == ProjLedgerStatus::Never || this.parmLedgerStatusCost() == ProjLedgerStatus::None))
                {
                    projEmplTrans.TransIdRef = this.parmTransIdRef();
                }
                break;

            case tableNum(ProdJournalRouteProj):
                ProdJournalRouteProj prodJournalRouteProj = buffer;
                projEmplTrans = ProjEmplTrans::initTransFromRouteJournal(
                    prodRouteTrans,
                    prodJournalRoute,
                    prodJournalRouteProj,
                    projTransId);
                break;
        }

        if (ledgerVoucher)
        {
            projEmplTrans.VoucherJournal = ledgerVoucher.lastVoucher();
        }

        if (!projEmplTrans.TransId)
        {
            projEmplTrans.TransId = ProjParameters::newTransId();
        }

        if (this.parmTransactionOriginOrig())
        {
            projEmplTrans.TransactionOrigin = this.parmTransactionOriginOrig();
        }

        if (this.parmAdjustment())
        {
            projEmplTrans.TransIdRef = this.parmTransIdRef();
            projEmplTrans.AdjRefTransId = this.parmAdjRefTransId();

            ProjEmplTrans origProjEmplTrans = ProjEmplTrans::find(this.parmAdjRefTransId());

            if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
            {
                projEmplTrans.VendInvoiceTrans = origProjEmplTrans.VendInvoiceTrans;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>ProjPostEmplJournal</c> class.
    /// </summary>
    /// <param name="_buffer">
    /// The table for the transaction type.
    /// </param>
    public void new(Common _buffer)
    {
        switch (_buffer.TableId)
        {
            case tableNum(ProjJournalTrans):
                buffer = _buffer;
                projTrans = ProjTrans::newProjJournalTrans(buffer);
                break;

            case tableNum(ProdJournalRouteProj):
                buffer = _buffer;
                break;

            default:
                throw error("@SYS50155");
        }

        super(_buffer);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIntercompanyDueToCompany</Name>
				<Source><![CDATA[
    public RefRecId parmIntercompanyDueToCompany(RefRecId _dueToCompany = intercompanyDueToCompany)
    {
        intercompanyDueToCompany = _dueToCompany;

        return intercompanyDueToCompany;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProdJournalRoute</Name>
				<Source><![CDATA[
    public ProdJournalRoute parmProdJournalRoute(ProdJournalRoute _prodJournalRoute = prodJournalRoute)
    {
        prodJournalRoute = _prodJournalRoute;

        return prodJournalRoute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProdRouteTrans</Name>
				<Source><![CDATA[
    public ProdRouteTrans parmProdRouteTrans(ProdRouteTrans _prodRouteTrans = prodRouteTrans)
    {
        prodRouteTrans = _prodRouteTrans;

        return prodRouteTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjTransId</Name>
				<Source><![CDATA[
    public ProjTransIdBase parmProjTransId(ProjTransIdBase _projTransId = projTransId)
    {
        projTransId = _projTransId;

        return projTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ledger posting type that is associated with posting project costs based on the current
    /// project ledger status.
    /// </summary>
    /// <returns>
    /// The ledger posting type for project costs.
    /// </returns>
    public LedgerPostingType postingTypeCost()
    {
        LedgerPostingType ledgerPostingType;

        switch (this.parmLedgerStatusCost())
        {
            case ProjLedgerStatus::BalanceSheet:
                if (projTrans.projLineProperty().ToBeCapitalize)
                {
                    ledgerPostingType = LedgerPostingType::ProjWIPCostvalue;
                }
                else
                {
                    if (this.parmIntercompanyDueToCompany())
                    {
                        ledgerPostingType = LedgerPostingType::IntercompanyCost;
                    }
                    else
                    {
                        ledgerPostingType = LedgerPostingType::ProjCost;
                    }
                }
                break;

            case ProjLedgerStatus::Operations:
                if (this.parmIntercompanyDueToCompany())
                {
                    ledgerPostingType = LedgerPostingType::IntercompanyCost;
                }
                else
                {
                    ledgerPostingType = LedgerPostingType::ProjCost;
                }
                break;
        }
        return ledgerPostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeOffsetCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ledger posting type for project offset cost posting based on the current ledger status of
    /// the project.
    /// </summary>
    /// <returns>
    /// The ledger posting type for project offset costs.
    /// </returns>
    public LedgerPostingType postingTypeOffsetCost()
    {
        if (this.parmIntercompanyDueToCompany())
        {
            return LedgerPostingType::VendBalance;
        }

        return LedgerPostingType::ProjPayrollAllocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjEmplTransSale</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the field of the <c>ProjEmplTransSale</c> record.
    /// </summary>
    /// <param name = "_projEmplTrans">
    /// The <c>ProjEmplTrans</c> record.
    /// </param>
    /// <param name = "_projTrans">
    /// The <c>ProjTrans</c> object.
    /// </param>
    /// <param name = "_fundingSourceRecId">
    /// The funding source reference ID.
    /// </param>
    /// <param name = "_lineAmount">
    /// The line amount value.
    /// </param>
    /// <returns>
    /// </param>
    /// <param name = "_fundingSourceCount">
    /// The number of funding source distribution for this transaction.
    /// </param>
    /// </param>
    /// <param name = "_unitSalesPrice">
    /// The transaction unit sales price.
    /// </param>
    /// The <c>ProjEmplTransSale</c> record.>
    /// </returns> 
	protected ProjEmplTransSale initializeProjEmplTransSale(ProjEmplTrans _projEmplTrans, ProjTrans _projTrans, ProjFundingSourceRefId _fundingSourceRecId, AmountCur _lineAmount, int _fundingSourceCount, SalesPrice _unitSalesPrice)
    {
        ProjEmplTransSale projEmplTransSale;
        projEmplTransSale.FundingSource = _fundingSourceRecId;
        projEmplTransSale.LineAmount = _lineAmount;

        if (_fundingSourceCount == 1)
        {
            projEmplTransSale.SalesPrice = _unitSalesPrice;
        }
        else if (_projTrans.qty() != 0)
        {
            //Multiple funding sources scenario
            projEmplTransSale.SalesPrice = projEmplTransSale.LineAmount/_projTrans.qty();
        }
        else
        {
            // Use Qty value of 1
            projEmplTransSale.SalesPrice = projEmplTransSale.LineAmount;
        }

        ProjTable projTable = ProjTable::find(projEmplTrans.ProjId);
        if (projTable.wipProject && ProjMultipleContractLinesForProjectFeatureHelper::isFixedPriceBillingMethod(projTable, ProjTransType::Hour))
        {
            if (ProjRevRecHelper::getSalesPriceMatchingPrincipleForProject(projTable.wipProject) != ProjSalesPriceMatchingPrincip::None)
            {
                projEmplTransSale.LineAmount = 0;
                projEmplTransSale.SalesPrice = 0;
            }
        }

        projEmplTransSale.TransId = _projEmplTrans.TransId;
        switch (buffer.TableId)
        {
            case tableNum(ProjJournalTrans):
                projEmplTransSale.LedgerTransdate = this.getLedgerJournalTransDate();
                break;

            case tableNum(ProdJournalRouteProj):
                projEmplTransSale.LedgerTransdate = this.getLedgerJournalTransDate();
                break;
        }

        if (this.checkEnterSalesAccrued() && ProjFundingSource::isExternalFunding(_fundingSourceRecId))
        {
            projEmplTransSale.LedgerSalesPosted = true;
            projEmplTransSale.LedgerSalesAmount = 
                CurrencyExchangeHelper::mstAmount(
                    projEmplTransSale.SalesPrice * _projTrans.qty(), 
                    _projTrans.currencyIdSales(), 
                    _projTrans.transDate(), 
                    Currency::noYes2UnknownNoYes(_projTrans.triangulationSales()), _projTrans.exchRateSales(), projTrans.exchRateSecondarySales());
        }
        projEmplTransSale.TransStatus = this.retrieveTransStatus();

		ProjFundingSource projFundingSource = ProjFundingSource::find(_fundingSourceRecId);
        projEmplTransSale.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(_projEmplTrans.DefaultDimension, projFundingSource.DefaultDimension);
    
        return projEmplTransSale;
	}

]]></Source>
			</Method>
			<Method>
				<Name>projTransCreate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows for extensibility in creating a transaction posting. The method contains no code.
    /// </summary>
    /// <remarks>
    /// This method is called by the <c>postTrans</c> method before the <c>ledgerTransActionsCreate</c>
    /// method when the <c>parmCreateTrans</c> method is true.
    /// </remarks>
    public void projTransCreate()
    {
        ProdJournalRouteProj prodJournalRouteProj;
        ProjEmplTransCost projEmplTransCost;
        ProjEmplTransSale projEmplTransSale;
        MapEnumerator enumerateMap;
        PSAIndirectComponentTrans tProjindirectTrans;
        AmountCur indirectRevenueAmount;
        ProjFundingSource projFundingSource;
        SalesPrice projSalesPrice;
        int fundingSourcesCount;

        projEmplTrans.clear();

        this.initializeProjEmplTrans();

        if (!projEmplTrans.validateWrite())
        {
            throw error("@SYS21628");
        }

        // <GEEU>
        if (LedgerParameters::isStornoEnabledEE())
        {
            projEmplTrans.IsCorrection = this.isTransCorrection();
        }
        // </GEEU>

        projEmplTrans.insert();

        if (TaxIntegrationUtils::isTaxInformationEnabled())
        {
            TransTaxInformationHelper::copyTransTaxInformation(buffer, projEmplTrans);
        }

        // <GEEPL>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            TaxServiceTariff::insertTaxServiceTariffForNewParent(buffer.TableId, buffer.RecId, projEmplTrans.TableId, projEmplTrans.RecId);
        }
        // </GEEPL>

        if (this.parmLedgerOrigin() != ProjOrigin::Adjustment)
        {
            // intialize the sales price.
            switch (buffer.TableId)
            {
                case tableNum(ProjJournalTrans):
                    projEmplTransSale = ProjEmplTransSale::initTransFromJournal(buffer);
                    projEmplTransSale.LedgerTransdate = this.getLedgerJournalTransDate();
                    break;

                case tableNum(ProdJournalRouteProj):
                    prodJournalRouteProj = buffer;
                    projEmplTransSale = ProjEmplTransSale::initTransFromRouteJournal(prodJournalRoute, prodJournalRouteProj);
                    projEmplTransSale.LedgerTransdate = this.getLedgerJournalTransDate();
                    break;
            }
                       
            AmountCur amountCur;
            TransDate transDate = projTrans.Transdate();

            PSAComponentGroupAssignment psaComponentGroupAssignment = PSAComponentGroupAssignment::findAssignment(projTrans.ProjId(),
                                                                                                                    projTrans.Resource(),
                                                                                                                    projTrans.CategoryId(),
                                                                                                                    transDate);

            if (psaComponentGroupAssignment)
            {
                PSAComponentGroupAssignment psaComponentGroupAssignmentLocal;
                PSAIndirectComponentGroup psaIndirectComponentGroup;
                PSAIndirectCompoundingSetup psaIndirectCompoundingSetup;
                PSAIndirectCostCalculation psaIndirectCostCalculation = new PSAIndirectCostCalculation();

                select firstonly RevenueRate, ComponentId from psaIndirectCompoundingSetup
                    where psaIndirectCompoundingSetup.DateFrom <= transDate
                    join ComponentGroupId from psaIndirectComponentGroup
                        where psaIndirectCompoundingSetup.ProjComponentGroupId == psaIndirectComponentGroup.ComponentGroupId
                            && psaIndirectComponentGroup.ComponentGroupId == psaComponentGroupAssignment.IndirectComponentGroup
                    join psaComponentGroupAssignmentLocal
                        order by psaComponentGroupAssignmentLocal.TransDate desc, psaIndirectCompoundingSetup.DateFrom desc
                        where psaComponentGroupAssignmentLocal.RecId == psaComponentGroupAssignment.RecId
                            && psaComponentGroupAssignmentLocal.TransDate <= transDate;
                    
                amountCur += psaIndirectCostCalculation.calculate(projEmplTransSale.SalesPrice,
                                                                        psaIndirectComponentGroup.ComponentGroupId,
                                                                        PSAIndirectComponentType::Revenue,
                                                                        psaIndirectCompoundingSetup.ComponentId,
                                                                        transDate, //  Add trans date as a parameter to the search
                                                                        0,
                                                                        projTrans.Qty());
            }

            //we need to consider the indirect revenue for funding limit
            this.createCostSalesDistributions(projTrans.transCost(), projTrans.transTurnover() + amountCur);

            if (allocationError == NoYes::No)
            {
                //Create ProjEmplTransCost record
                enumerateMap = new MapEnumerator(costDistributions);
                while (enumerateMap.moveNext())
                {
                    projEmplTransCost.clear();

                    switch (buffer.TableId)
                    {
                        case tableNum(ProjJournalTrans):
                            projEmplTransCost = ProjEmplTransCost::initTransFromJournal(buffer);
                            projEmplTransCost.LedgerTransdate = this.getLedgerJournalTransDate();
                            break;

                        case tableNum(ProdJournalRouteProj):
                            prodJournalRouteProj = buffer;
                            projEmplTransCost = ProjEmplTransCost::initTransFromRouteJournal(prodJournalRoute, prodJournalRouteProj);
                            projEmplTransCost.LedgerTransdate = this.getLedgerJournalTransDate();
                            break;
                    }

                    fundingSourcesCount = fundingSourceList.elements();
                    projSalesPrice = projEmplTransSale.SalesPrice;

                    projEmplTransCost.FundingSource = enumerateMap.currentKey();
                    projEmplTransCost.LineAmount = enumerateMap.currentValue();
                    projFundingSource = ProjFundingSource::find(projEmplTransCost.FundingSource);

                    if (fundingSourcesCount > 1)
                    {
                        // Multiple funding sources scenario
                        if (projTrans.qty() != 0)
                        {
                            projEmplTransCost.CostPrice = projEmplTransCost.LineAmount/projTrans.qty();
                        }
                        else
                        {
                            // Use Qty value of 1
                            projEmplTransCost.CostPrice = projEmplTransCost.LineAmount;
                        }
                    }

                    projEmplTransCost.TransId = projEmplTrans.TransId;
                    projEmplTransCost.LedgerStatusCost = this.projEmplTransCostLedgerStatus();
                    projEmplTransCost.TransStatus = this.retrieveTransStatus();
                    projEmplTransCost.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(projEmplTrans.DefaultDimension, projFundingSource.DefaultDimension);
                    projEmplTransCost.insert();
                }

                //Create ProjEmplTransSale record
				enumerateMap = ProjFundingEngine::ledgerDistributions( fundingSourceList,projTrans.transTurnover(),projTrans.currencyIdSales()).getEnumerator();
                while (enumerateMap.moveNext())
                {
                    projEmplTransSale = this.initializeProjEmplTransSale(projEmplTrans, projTrans, enumerateMap.currentKey(), enumerateMap.currentValue(), fundingSourcesCount, projSalesPrice);
					projEmplTransSale.insert();
                }
            }
        }

        Docu::copy(buffer, projEmplTrans);

        ResourcePeriodFacade::updatePeriod(projTrans.resource(), projTrans.transDate());

        if (this.parmCostUseOrig())
        {
            this.parmTransIdCost(this.parmTransIdOrig());
        }
        else
        {
            this.parmTransIdCost(projEmplTrans.TransId);
        }

        if (this.parmsalesUseOrig())
        {
            this.parmTransIdSales(this.parmTransIdOrig());
        }
        else
        {
            this.parmTransIdSales(projEmplTrans.TransId);
        }

        transIdNew = projEmplTrans.TransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projEmplTransCostLedgerStatus</Name>
				<Source><![CDATA[
    protected ProjLedgerStatus projEmplTransCostLedgerStatus()
    {
        ProjLedgerStatus projLedgerStatus;

        if (this.checkEnterNeverLedger())
        {
            projLedgerStatus = ProjLedgerStatus::Never;
        }
        else
        {
            if (projTrans.projLineProperty().ToBeCapitalize)
            {
                projLedgerStatus = this.parmLedgerStatusCost();
            }
            else if (this.parmLedgerStatusCost() == ProjLedgerStatus::BalanceSheet)
            {
                projLedgerStatus = ProjLedgerStatus::Operations;
            }
            else
            {
                projLedgerStatus = this.parmLedgerStatusCost();
            }
        }

        return projLedgerStatus;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>