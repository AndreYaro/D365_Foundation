<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSPostPackingSlip</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WhsPostPackingSlip</c> class is used to run batch job for packing slip posting.
/// </summary>
public class WhsPostPackingSlip extends RunBaseBatch implements BatchRetryable, SysErrorMessageHelpScopeIBatchProvider
{
    QueryRun       queryRun;
    container      loadsWithInvoicedOrders;
    WHSLoadId      loadIdToPost;
    ParmId         parmId;
    boolean        dummy;
    boolean        post;
    boolean        packingSlipJournalPosted;
    List           tmpPackSlipLoadLines;
    container      packedTmpPackSlipLoadLines;

    private boolean usedTotalPurchLineRegisteredQuantities;
    private boolean registeredQuantitiesCalculated;
   
    private boolean allowMultipleProductReceipts;
    private DialogField allowMultipleProductReceiptsField;

    private boolean disableRestrictLoadsToOnlyRegistered;
    private DialogField disableRestrictLoadsToOnlyRegisteredField;

    private WHSInstrumentationLogger instrumentationLogger;

    #DEFINE.CurrentVersion(6)
    #DEFINE.Version5(5)
    #DEFINE.Version4(4)
    #DEFINE.Version3(3)
    #DEFINE.Version2(2)

    #LOCALMACRO.CurrentList
        allowMultipleProductReceipts,
        usedTotalPurchLineRegisteredQuantities,
        registeredQuantitiesCalculated,
        disableRestrictLoadsToOnlyRegistered
    #ENDMACRO

    #LOCALMACRO.CurrentListV5
        allowMultipleProductReceipts,
        usedTotalPurchLineRegisteredQuantities,
        registeredQuantitiesCalculated,
        restrictLoadsToOnlyRegistered
    #ENDMACRO

    #LOCALMACRO.CurrentListV4
        allowMultipleProductReceipts,
        usedTotalPurchLineRegisteredQuantities,
        registeredQuantitiesCalculated
    #ENDMACRO

    #LOCALMACRO.CurrentListV3
        allowMultipleProductReceipts
    #ENDMACRO

    #LOCALMACRO.CurrentListV2
        dummy
    #ENDMACRO

    #LOCALMACRO.CurrentListNewSession
        #CurrentList,
        loadIdToPost,
        parmId,
        post,
        packedTmpPackSlipLoadLines,
        packingSlipJournalPosted
    #ENDMACRO
    
    #LOCALMACRO.ListV5NewSession
        #CurrentListV5,
        loadIdToPost,
        parmId,
        post,
        packedTmpPackSlipLoadLines,
        packingSlipJournalPosted
    #ENDMACRO

    #LOCALMACRO.ListV4NewSession
        #CurrentListV4,
        loadIdToPost,
        parmId,
        post,
        packedTmpPackSlipLoadLines,
        packingSlipJournalPosted
    #ENDMACRO

    #LOCALMACRO.ListV3NewSession
        #CurrentListV3,
        loadIdToPost,
        parmId,
        post,
        packedTmpPackSlipLoadLines,
        packingSlipJournalPosted
    #ENDMACRO

    #LOCALMACRO.ListV2NewSession
        #CurrentListV2,
        loadIdToPost,
        parmId,
        post,
        packedTmpPackSlipLoadLines,
        packingSlipJournalPosted
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>alterLoadLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts load line quantity to total received quantity.
    /// </summary>
    /// <param name="_packSlipLoadLine">
    /// Record representing packing slip of a load line.
    /// </param>
    /// <param name="_purchParmLine">
    /// <c>PurchParmLine</c> record.
    /// </param>
    /// <remarks>
    /// This method can be called in two situations:
    /// a) when multiple receipts have never been allowed (WhsPostPackingSlipCreatePackSlipLoadLineToggle disabled or by configuration setting)
    /// b) after several receipts have been performed with additional receipts allowed and then the "final" receipt has been posted with no additional receipts allowed
    ///
    /// In option a), load lines can be adjusted to the current receipt quantity.
    /// In option b), load lines need to be adjusted to the total received quantity on the load, which, to be reliable, requires all Received (and above) InventTrans to be associated with loads.
    /// Therefore, to determineReceivedQuantitiesFromLoadAssociation = WhsPostPackingSlipCreatePackSlipLoadLineToggle needs to be enabled AND no receipts without load can exist.
    /// If this is not true, fall back to previous behavior of setting the load
    /// </remarks>
    public void alterLoadLine(TMSTmpPackSlipLoadLine _packSlipLoadLine, PurchParmLine _purchParmLine)
    {
        WHSLoadLine loadLine = WHSLoadLine::findbyRecId(_packSlipLoadLine.LoadLineRefRecId, true);

        if (loadLine)
        {
            Qty receiveNowHandlingQty;
            Qty remainAfterHandlingQty;
            UnitOfMeasureSymbol fromUnit;

            // See remarks for background on determineReceivedQuantitiesFromLoadAssociation.
            boolean determineReceivedQuantitiesFromLoadAssociation = !WHSPurchLine::inventTransOriginHasReceiptsWithoutLoad(InventTransOrigin::findByInventTransId(loadLine.InventTransId).RecId);
            
            if (determineReceivedQuantitiesFromLoadAssociation)
            {
                InventTransIdSum inventTransIdSum;
                PurchLine purchLine = PurchLine::findInventTransId(loadLine.InventTransId);

                if (!WHSInventEnabled::exist(loadLine.ItemId))
                {
                    // In TMS-only case, inventTransIdSum will contain also the ordered transactions, since there is no linking to the load.
                    inventTransIdSum = InventTransIdSum::newTransOriginId(InventTransOrigin::findByInventTransId(purchLine.InventTransId).RecId);
                }
                else
                {
                    // Note that in WHS case, inventTransIdSum will not have any ordered transactions, since they are not linked to a load.
                    inventTransIdSum = InventTransIdSum_WHSLoad::newLoad(InventTransOrigin::findByInventTransId(purchLine.InventTransId).RecId, loadLine.LoadId);
                }
                    
                // Include issue as it is a cancellation of receipt and remove the ordered quantitity (required for TMS, as it is zero by definition in the WHS case)
                if (PdsGlobal::pdsIsCWItem(loadLine.ItemId))
                {
                    receiveNowHandlingQty = inventTransIdSum.pdsCWReceipt() + InventTransIdSum.pdsCWIssue() - InventTransIdSum.pdsCWOrdered();
                    remainAfterHandlingQty = 0;
                    fromUnit = purchLine.pdsCWUnitId();
                }
                else
                {
                    receiveNowHandlingQty = inventTransIdSum.receipt() + InventTransIdSum.issue() - InventTransIdSum.ordered();
                    remainAfterHandlingQty = 0;
                    fromUnit = purchLine.inventTable().inventUnitId();
                }
            }
            else
            {
                if (!_purchParmLine)
                {
                    receiveNowHandlingQty = 0;
                    remainAfterHandlingQty = 0;
                }
                else
                {
                    PurchLine purchLine = PurchLine::findRecId(_purchParmLine.PurchLineRecId);
                                
                    if (PdsGlobal::pdsIsCWItem(loadLine.ItemId))
                    {
                        receiveNowHandlingQty = _purchParmLine.PdsCWReceiveNow;
                        remainAfterHandlingQty = _purchParmLine.PdsCWRemainAfterInvent;
                        fromUnit = purchLine.pdsCWUnitId();
                    }
                    else
                    {
                        receiveNowHandlingQty = _purchParmLine.ReceiveNow;
                        remainAfterHandlingQty = _purchParmLine.RemainAfterInvent;
                        fromUnit = purchLine.PurchUnit;
                    }
                }
            }

            Qty purchParmLineReceiveNowQtyInLoadLineUOM = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(loadLine.ItemId,
                                                                                        loadLine.InventDimId,
                                                                                        receiveNowHandlingQty,
                                                                                        fromUnit,
                                                                                        loadLine.uom,
                                                                                        NoYes::No,
                                                                                        NoYes::No);

            if (receiveNowHandlingQty == 0 && remainAfterHandlingQty == 0)
            {
                loadLine.delete();
            }
            else if (purchParmLineReceiveNowQtyInLoadLineUOM != loadLine.Qty || remainAfterHandlingQty != loadLine.InventQty)
            {
                loadLine.Qty = purchParmLineReceiveNowQtyInLoadLineUOM;
                loadLine.InventQty = remainAfterHandlingQty;
                loadLine.write();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds query on packing slips for inbound.
    /// </summary>
    /// <returns>
    /// The query built.
    /// </returns>
    Query buildQuery()
    {
        Query query = new Query(queryStr(WHSPurchPackingSlipLoads));

        if (this.mustRestrictQueryToRegisteredTransactions())
        {
            this.restrictQueryToRegisteredTransactions(query);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustRestrictQueryToRegisteredTransactions</Name>
				<Source><![CDATA[
    protected boolean mustRestrictQueryToRegisteredTransactions()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>restrictQueryToRegisteredTransactions</Name>
				<Source><![CDATA[
    private void restrictQueryToRegisteredTransactions(Query _query)
    {
        QueryBuildDataSource loadTableDS = _query.dataSourceTable(tableNum(WHSLoadTable));
        QueryBuildDataSource inventTransDS = loadTableDS.addDataSource(tableNum(InventTrans));
        inventTransDS.joinMode(JoinMode::ExistsJoin);
        inventTransDS.addLink(fieldNum(WHSLoadTable, LoadId), fieldNum(InventTrans, LoadId));
        inventTransDS.addRange(fieldNum(InventTrans, StatusIssue)).value(queryValue(StatusIssue::None));
        inventTransDS.addRange(fieldNum(InventTrans, StatusReceipt)).value(queryValue(StatusReceipt::Registered));

        disableRestrictLoadsToOnlyRegistered = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canShipConfirm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether shipment for load could be confirmed.
    /// </summary>
    /// <param name="_loadTable">
    /// The <c>WHSLoadTable</c> record of the load being validated.
    /// </param>
    /// <returns>
    /// true if shipment for load could be confirmed; otherwise, false.
    /// </returns>
    /// <remarks>Adds a warning to InfoLog in case of return false.</remarks>
    protected boolean canShipConfirm(WHSLoadTable _loadTable)
    {
        if (!WhsPostPackingSlip::isShipConfirmEnabled(_loadTable, true))
        {
            return checkFailed(strFmt("@WAX5828", _loadTable.LoadId));
        }

        if (!_loadTable.canShipConfirm(false))
        {
            return false;
        }

        if (!this.validateFreightTerms(_loadTable.loadId))
        {
            return checkFailed(strFmt("@TRX1631", _loadTable.LoadId));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packingStructureExistsForShipment</Name>
				<Source><![CDATA[
    private boolean packingStructureExistsForShipment(WHSShipmentId _shipmentId)
    {
        return _shipmentId &&
            (select firstonly RecId from WHSUOMStructure
                where WHSUOMStructure.ShipmentId == _shipmentId
                    && WHSUOMStructure.Module == WHSModule::Purch).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>compareToASN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Compares a load line with ASN item that references the load line.
    /// </summary>
    /// <param name="_loadLine">
    /// Load line to be compared.
    /// </param>
    public void compareToASN(WHSLoadLine _loadLine)
    {
        WHSWorkCreatedQty workCreatedQty = WHSASNItemReceiptHandler::calculateWorkCreatedQtyForLoadLine(_loadLine);

        if (_loadLine.InventQty != workCreatedQty)
        {
            // If license plates are received without work creation, then WorkCreatedQty field will not be updated.
            if (!WHSUOMStructureReceiptHandler::isLoadLineASNReceivedWithoutPutawayWorkCreation(_loadLine, workCreatedQty))
            {
                this.createReceivingWorkExceptionLogEntry(_loadLine, workCreatedQty);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReceivingWorkExceptionLogEntry</Name>
				<Source><![CDATA[
    private void createReceivingWorkExceptionLogEntry(WHSLoadLine _loadLine, InventQty _actualReceiptQty)
    {
        WHSWorkExceptionLog log = this.initializeReceivingWorkExceptionLogEntry(_loadLine, _actualReceiptQty);
        log.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeReceivingWorkExceptionLogEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the work exception log entry for receiving.
    /// </summary>
    /// <param name = "_loadLine">The load line.</param>
    /// <param name = "_actualReceiptQty">The actual received quantity.</param>
    /// <returns>The work exception log entry.</returns>
    protected WHSWorkExceptionLog initializeReceivingWorkExceptionLogEntry(WHSLoadLine _loadLine, InventQty _actualReceiptQty)
    {
        PurchLine           purchLine = _loadLine.getOrderCommonFromLoadLine() as PurchLine;
        InventDim           inventDim = _loadLine.inventDim();
        WHSWorkExceptionLog log;

        log.ShipmentId          = _loadLine.ShipmentId;
        log.LoadId              = _loadLine.LoadId;
        log.InventLocationId    = inventDim.InventLocationId;
        log.WorkExceptionCode   = WHSParameters::find().asnMissingItemCode;
        log.ExceptionType       = WHSExceptionType::Receiving;
        log.OrderNum            = _loadLine.OrderNum;
        log.OrderLineNum        = str2num(int642str(purchLine.LineNumber));
        log.WorkTransType       = WHSWorkTransType::Purch;
        log.Message             = strFmt("@WAX:Log_LoadLineQtyDifferentFromTotalASNWorkCreatedQty", _loadLine.InventQty, _actualReceiptQty);
        
        return log;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    public Object dialog()
    {
        DialogRunbase dialog = super();

        if (WHSParameters::find().AllowMultipleProductReceiptsForLoad == WHSAllowMultipleProductReceiptsForLoad::Prompt)
        {
            allowMultipleProductReceiptsField = dialog.addFieldValue(extendedTypeStr(NoYesId), allowMultipleProductReceipts, "@WAX:AllowMultipleProductReceiptsForLoad", "@WAX:AllowMultipleProductReceiptsForLoadPromptHelp");
        }


        disableRestrictLoadsToOnlyRegisteredField = dialog.addFieldValue(extendedTypeStr(NoYesId), disableRestrictLoadsToOnlyRegistered, "@WAX:DisableLoadsToOnlyRegistered_Label", "@WAX:DisableLoadsToOnlyRegistered_HelpText");


        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPostRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains code to be executed after dialog run.
    /// </summary>
    /// <param name="dialog">
    /// The dialog.
    /// </param>
    public void dialogPostRun(DialogRunbase dialog)
    {
        super(dialog);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDialogLoadFilters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if load filters is applied on the dialog.
    /// </summary>
    /// <returns>true if load filters is applied on the dialog; otherwise, false.</returns>
    protected boolean validateDialogLoadFilters()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        boolean ret = super();

        if (ret && queryRun && inCheckClose && this.validateDialogLoadFilters())
        {
            Query query = queryRun.query();
            QueryBuildDataSource qbds = query.dataSourceTable(tablenum(WHSLoadTable));
            
            QueryBuildRange qbrLoadId = qbds.findRange(fieldNum(WHSLoadTable, LoadId));
            QueryBuildRange qbrLoadStatus = qbds.findRange(fieldNum(WHSLoadTable, LoadStatus));
           
            if (   (!qbrLoadId || !qbrLoadId.value())
                && (!qbrLoadStatus || !qbrLoadStatus.value()))
            {
                if (Box::YesNo(strFmt("@WAX:WarningForPackingSlipFiltering", "@ProductFramework_Dialog:QueryTabCaption"), DialogButton::No) == DialogButton::No)
                {
                    return false;
                }
            }
        }

        if (allowMultipleProductReceiptsField)
        {
            allowMultipleProductReceipts = allowMultipleProductReceiptsField.value();
        }

        disableRestrictLoadsToOnlyRegistered = disableRestrictLoadsToOnlyRegisteredField && disableRestrictLoadsToOnlyRegisteredField.value();
        this.updateQueryBasedOnRestrictLoads();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryBasedOnRestrictLoads</Name>
				<Source><![CDATA[
    internal void updateQueryBasedOnRestrictLoads()
    {
        if (queryRun)
        {
            Query query = queryRun.query();
            QueryBuildDataSource qbds = query.dataSourceTable(tableNum(InventTrans));

            if (qbds)
            {
                // If the data source is present, enable/disable it based on setting
                query.dataSourceTable(tableNum(InventTrans)).enabled(!disableRestrictLoadsToOnlyRegistered);
                queryRun = new queryRun(query);
            }
            else if (!disableRestrictLoadsToOnlyRegistered)
            {
                // Add the missing data source
                this.restrictQueryToRegisteredTransactions(query);
                queryRun = new queryRun(query);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new()
    {
        super();

        tmpPackSlipLoadLines = new List(Types::Container);

        queryRun = new QueryRun(this.buildQuery());
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        if (this.inGetSaveLast())
        {
            return [#CurrentVersion, #CurrentList, queryRun.pack()];
        }

        packedTmpPackSlipLoadLines = tmpPackSlipLoadLines.pack();

        if (queryRun)
        {
            return [#CurrentVersion, #CurrentListNewSession, queryRun.pack()];
        }
        
        return [#CurrentVersion, #CurrentListNewSession];
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    public QueryRun queryRun()
    {
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveLoads</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Generates a map with all loads that have to be ship confirmed at the same time and that can be actually ship confirmed.
    /// </summary>
    /// <param name="_loadTable">
    ///     The <c>WHSLoadTable</c> record of the load which user asked to ship confirm.
    /// </param>
    /// <returns>
    ///     A container with the loads that have to be ship confirmed.
    /// </returns>
    /// <remarks>
    ///     If load belongs to a route then we want to ship confirm all the loads on the route together.
    ///     If load doesn't belong to a route then we ship confirm only the load that user asked us to ship confirm.
    ///     If at least one of the loads doesn't match ship confirm criteria then we don't ship confirm loads at all.
    /// </remarks>
    private container retrieveLoads(WHSLoadTable _loadTable)
    {
        TMSRouteSegmentLoad     segmentLoad;
        container               loads;

        if (_loadTable.RouteCode)
        {
            while select Id from segmentLoad
                group by Id
                where segmentLoad.RouteCode == _loadTable.RouteCode
            {
                if (!this.canShipConfirm(WHSLoadTable::find(segmentLoad.Id)))
                {
                    loads = conNull();
                    break;
                }
                loads += segmentLoad.Id;
            }
        }
        else
        {
            if (this.canShipConfirm(_loadTable))
            {
                loads += _loadTable.LoadId;
            }
        }

        return loads;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContextBatchServer(this))
        {
            if (this.isInBatch())
            {
                using (var activityContext = this.instrumentationLogger().postPackingSlipActivities().run())
                {
                    int loadCount;

                    while (queryRun.next())
                    {
                        try
                        {
                            WHSLoadTable loadTable = queryRun.get(tableNum(WHSLoadTable));

                            this.parmLoadIdToPost(loadTable.LoadId);
                            this.preparePackingSlipPosting(this.parmLoadIdToPost());
                            this.postPackingSlipAndUpdateLoadAndShipment();
                          
                            ++loadCount;
                        }
                        catch (Exception::Error)
                        {
                            exceptionTextFallThrough();
                        }
                    }

                    this.instrumentationLogger().postPackingSlipActivities().postedLoadsCount(activityContext, loadCount);
                }
            }
            else
            {
                this.preparePackingSlipPosting(this.parmLoadIdToPost());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preparePackingSlipPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Confirms the Load and the Purchase Order if needed and prepares the data needed
    /// for the the packing slip posting.
    /// </summary>
    /// <param name="_loadId">
    /// The load ID to be processed.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Throws an exception if the packing slip update fails
    /// </exception>
    public void preparePackingSlipPosting(WHSLoadId _loadId)
    {
        try
        {
            using (var activityContext = this.instrumentationLogger().postPackingSlipActivities().preparePackingSlipPosting())
            {
                tmpPackSlipLoadLines = new List(Types::Container);

                WHSLoadTable loadTable = WHSLoadTable::find(_loadId, true);

                if (loadTable.RecId == 0)
                {
                    return;
                }

                this.instrumentationLogger().postPackingSlipActivities().loadRecId(activityContext, loadTable.RecId);

                boolean confirmPurchaseOrdersForLoad = false;
                boolean theLoadIsNotShipConfirm = false;

                ttsbegin;

                if (loadTable.LoadStatus != WHSLoadStatus::Received)
                {
                    if (!TMSAppointment::isAppointmentComplete(_loadId))
                    {
                        throw error(strFmt("@TRX2715", _loadId));
                    }

                    if (TMSRoute::find(loadTable.RouteCode).RouteStatus != TMSRouteStatus::Confirmed && !this.shipConfirm(_loadId))
                    {
                        theLoadIsNotShipConfirm = true;
                    }

                    confirmPurchaseOrdersForLoad = true;
                }

                if (WHSParameters::isReceivingCompletedWithAutoPostEnabledForPOLoads() && loadTable.LoadStatus == WHSLoadStatus::Received)
                {
                    this.confirmPurchaseOrdersForLoad(_loadId);
                }

                if (!theLoadIsNotShipConfirm)
                {
                    if (confirmPurchaseOrdersForLoad)
                    {
                        this.confirmPurchaseOrdersForLoad(_loadId);
                    }
    
                    this.resetLoadRegisteredQuantityCalculationVariables();

                    boolean hasRegisteredQuantity = this.updatePurchaseLoadLines(_loadId);
    
                    if (this.parmPost() && !hasRegisteredQuantity)
                    {
                        if (usedTotalPurchLineRegisteredQuantities || !registeredQuantitiesCalculated)
                        {
                            throw error("@WAX:ProductReceiptUpdateFailureNoRegisteredQtyMessage");
                        }
                        else
                        {
                            // With the new toggle, if there is no packing slip to post, still run the update of the load lines and load status determination
                            this.parmPost(false);
                        }
                    }
                }

                ttscommit;
            }
        }
        catch
        {
            throw error(strFmt("@WAX4206", _loadId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetLoadRegisteredQuantityCalculationVariables</Name>
				<Source><![CDATA[
    private void resetLoadRegisteredQuantityCalculationVariables()
    {
        usedTotalPurchLineRegisteredQuantities = false;
        registeredQuantitiesCalculated = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>confirmPurchaseOrdersForLoad</Name>
				<Source><![CDATA[
    /// <summary>
    /// Confirms purchase orders for load lines that match <paramref name="_loadId" />.
    /// </summary>
    /// <param name = "_loadId">A load ID.</param>
    protected void confirmPurchaseOrdersForLoad(WHSLoadId _loadId)
    {
        WHSLoadLine loadLine;

        while select OrderNum, InventTransType, TransportRequest from loadLine
            group by loadLine.OrderNum, loadLine.InventTransType, loadLine.TransportRequest
            where loadLine.LoadId             == _loadId                  &&
                    loadLine.InventTransType  == InventTransType::Purch   &&
                    loadLine.TransportRequest == NoYes::No
        {
            PurchTable purchTable = loadLine.orderHeader(true) as PurchTable;

            if (purchTable.DocumentState != VersioningDocumentState::Confirmed)
            {
                VersioningPurchaseOrder::newPurchaseOrder(purchTable).runPurchaseOrderConfirmationProcess();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchaseLoadLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates each load line and its related data.
    /// </summary>
    /// <param name = "_loadId">A load id.</param>
    /// <returns>true if purchase parm line quantity has been registered; otherwise, false.</returns>
    protected boolean updatePurchaseLoadLines(WHSLoadId _loadId)
    {
        WHSCaptureReceivingCompletedPackingSlip captureReceivingPackingSlip = WHSParameters::find().CaptureReceivingCompletedPackingSlip;
        boolean hasCreatedPurchParmUpdate;
        boolean hasBeenRegisteredDefaultQuery;
        boolean hasBeenRegisteredSortByShipmentQuery;

        if (captureReceivingPackingSlip != WHSCaptureReceivingCompletedPackingSlip::Always)
        {
            QueryRun loadLineQueryRun = new QueryRun(this.buildPurchaseLoadLinesQuery(_loadId));
            hasBeenRegisteredDefaultQuery = this.registerLoadLineQuantities(_loadId, loadLineQueryRun, false, true);
            if (WHSCreatePurchParmTableBuildPurchaseLoadLinesQueryFlight::instance().isEnabled())
            {
                hasCreatedPurchParmUpdate = hasBeenRegisteredDefaultQuery;
            }
            else
            {
                hasCreatedPurchParmUpdate = true;
            }
        }

        if (captureReceivingPackingSlip != WHSCaptureReceivingCompletedPackingSlip::Never)
        {
            QueryRun loadLineOrdByShipQueryRun = new QueryRun(this.buildPurchaseLoadLinesSortedByShipmentQuery(_loadId));
            hasBeenRegisteredSortByShipmentQuery = this.registerLoadLineQuantities(_loadId, loadLineOrdByShipQueryRun, true, !hasCreatedPurchParmUpdate);
        }

        return hasBeenRegisteredDefaultQuery || hasBeenRegisteredSortByShipmentQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerLoadLineQuantities</Name>
				<Source><![CDATA[
    private boolean registerLoadLineQuantities(WHSLoadId _loadId, QueryRun _loadLineQuery, boolean _groupPurchParmByShipment, boolean _createPurchParmUpdate)
    {
        if (_loadLineQuery.query().dataSourceCount() == 0)
        {
            return false;
        }

        WHSLoadLine         loadLinePreviousIteration;
        PurchParmUpdate     purchParmUpdate;
        PurchParmTable      purchParmTable;
        InventTransId       prevTransId;
        boolean             hasRegisteredQuantity;
        int                 i = WHSPostPackingSlip::getMaxUsedPackingSlipIdNum(_loadId);
        boolean             packingStructureExistsForShipment;

        while (_loadLineQuery.next())
        {
            WHSLoadLine loadLine = _loadLineQuery.get(tableNum(WHSLoadLine));

            if (loadLine.ShipmentId)
            {
                if (loadLine.ShipmentId != loadLinePreviousIteration.ShipmentId)
                {
                    packingStructureExistsForShipment = this.packingStructureExistsForShipment(loadLine.ShipmentId);
                }

                if (packingStructureExistsForShipment)
                {
                    this.compareToASN(loadLine);
                }
            }

            if (this.mustCreatePurchParmUpdate(loadLine, loadLinePreviousIteration) && _createPurchParmUpdate)
            {
                this.ensurePackingSlipPurchParmUpdateIsCreated(purchParmUpdate);
                this.parmParmId(purchParmUpdate.ParmId);
            }

            if (_groupPurchParmByShipment)
            {
                if (loadLinePreviousIteration.ShipmentId != loadLine.ShipmentId)
                {
                    ++i;
                    purchParmTable = this.createPackingSlipPurchParm(loadLine, i);
                }
            }
            else if (this.mustCreatePurchParm(loadLine, loadLinePreviousIteration))
            {
                ++i;
                purchParmTable = this.createPackingSlipPurchParm(loadLine, i);
            }

            PurchLine purchLine = loadLine.getOrderCommonFromLoadLine() as purchLine;
            PurchQty registeredPurchaseQty;
            InventQty registeredInventQty;
            PdsCWQty registeredCWQty;

            if (this.mustCalculateRegisteredQuantity(purchLine, loadLine, prevTransId))
            {
                registeredQuantitiesCalculated = true;

                prevTransId = loadLine.InventTransId;

                boolean determineReceivedQuantitiesFromLoadAssociation = WHSPurchLine::shouldDetermineRegisteredQuantitiesFromLoadId(InventTransOrigin::findByInventTransId(purchLine.InventTransId).RecId);

                if (determineReceivedQuantitiesFromLoadAssociation)
                {
                    var registeredQuantity = loadLine.registeredInboundQuantity();

                    registeredInventQty = registeredQuantity.qtyInInventUnit();
                    registeredCWQty = registeredQuantity.qtyInCWUnit();
                    registeredPurchaseQty = registeredQuantity.qtyInOrderUnit();
                }
                else
                {
                    usedTotalPurchLineRegisteredQuantities = true;

                    registeredPurchaseQty  = purchLine.registeredInPurchUnit();
                    registeredInventQty = purchLine.registered();
                    registeredCWQty = purchLine.pdsCWRegistered();
                }
            }

            PurchParmLine purchParmLine;

            if (registeredInventQty && registeredPurchaseQty)
            {
                purchParmLine = this.updatePurchParmLineQuantityDataWithCW(loadLine, purchLine, purchParmUpdate, registeredPurchaseQty, registeredInventQty, registeredCWQty, purchParmTable);
                hasRegisteredQuantity = true;
            }

            this.createPackSlipLoadLine(loadLine, purchParmLine);

            this.parmPost(true);

            loadLinePreviousIteration.data(loadLine);
        }

        return hasRegisteredQuantity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowMultipleProductReceiptsForLoad</Name>
				<Source><![CDATA[
    private boolean allowMultipleProductReceiptsForLoad()
    {
        WHSParameters whsParameters = WHSParameters::find();

        return whsParameters.AllowMultipleProductReceiptsForLoad == WHSAllowMultipleProductReceiptsForLoad::Yes
            || (allowMultipleProductReceipts
                && whsParameters.AllowMultipleProductReceiptsForLoad == WHSAllowMultipleProductReceiptsForLoad::Prompt);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCalculateRegisteredQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to calculate the registered quantity.
    /// </summary>
    /// <param name = "_purchLine">A purchase order line.</param>
    /// <param name = "_loadLine">A WHS load line.</param>
    /// <param name = "_prevTransId">The <c>InventTransId</c> of the previous load line.</param>
    /// <returns>true if the registered quantity must be calculated; otherwise, false.</returns>
    protected boolean mustCalculateRegisteredQuantity(PurchLine _purchLine, WHSLoadLine _loadLine, InventTransId _prevTransId)
    {
        return _purchLine.registered() && (!_prevTransId || _prevTransId != _loadLine.InventTransId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreatePurchParmUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defines if the <c>PurchParmUpdate</c> record must be created.
    /// </summary>
    /// <param name = "_loadLine">A load line.</param>
    /// <param name = "_loadLinePreviousIteration">A load line from previous loop iteration.</param>
    /// <returns>true if the <c>PurchParmUpdate</c> record must be created; otherwise, false.</returns>
    protected boolean mustCreatePurchParmUpdate(
        WHSLoadLine _loadLine,
        WHSLoadLine _loadLinePreviousIteration)
    {
        return !_loadLinePreviousIteration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreatePurchParm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defines if the <c>PurchParm</c> record must be created.
    /// </summary>
    /// <param name = "_loadLine">A load line.</param>
    /// <param name = "_loadLinePreviousIteration">A load line from previous loop iteration.</param>
    /// <returns>true if the <c>PurchParmUpdate</c> record must be created; otherwise, false.</returns>
    protected boolean mustCreatePurchParm(
        WHSLoadLine _loadLine,
        WHSLoadLine _loadLinePreviousIteration)
    {
        return _loadLinePreviousIteration.OrderNum != _loadLine.OrderNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPurchaseLoadLinesQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a query that extracts purchase load lines.
    /// </summary>
    /// <param name = "_loadId">A load id.</param>
    /// <returns>The query to extract load lines.</returns>
    protected Query buildPurchaseLoadLinesQuery(WHSLoadId _loadId)
    {
        Query query = new Query();
        QueryBuildDataSource loadLineDataSource = query.addDataSource(tableNum(WHSLoadLine));

        QueryBuildRange loadIdRange = loadLineDataSource.addRange(fieldNum(WHSLoadLine, LoadId));
        loadIdRange.value(_loadId);

        loadLineDataSource.addRange(fieldNum(WHSLoadLine, InventTransType)).value(queryValue(InventTransType::Purch));

        loadLineDataSource.addRange(fieldNum(WHSLoadLine, TransportRequest)).value(queryValue(NoYes::No));

        if (WHSParameters::find().CaptureReceivingCompletedPackingSlip == WHSCaptureReceivingCompletedPackingSlip::Optional)
        {
            QueryBuildDataSource shipmentDataSource = loadLineDataSource.addDataSource(tableNum(WHSShipmentTable));
            shipmentDataSource.addLink(fieldNum(WHSLoadLine, ShipmentId), fieldNum(WHSShipmentTable, ShipmentId));
            shipmentDataSource.joinMode(JoinMode::ExistsJoin);
            shipmentDataSource.addRange(fieldNum(WHSShipmentTable, ReceivingCompletedPackingSlipId)).value(queryValue(''));
        }

        loadLineDataSource.addSortField(fieldNum(WHSLoadLine, OrderNum));
        loadLineDataSource.addSortField(fieldNum(WHSLoadLine, WorkCreatedQty), SortOrder::Descending);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPurchaseLoadLinesSortedByShipmentQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a query that extracts purchase load lines sorted by shipment
    /// that belong to any shipments with ReceivingCompletedPackingSlipId value set.
    /// </summary>
    /// <param name = "_loadId">A load id.</param>
    /// <returns>The query to extract load lines.</returns>
    private Query buildPurchaseLoadLinesSortedByShipmentQuery(WHSLoadId _loadId)
    {
        Query query = new Query();

        if (WHSParameters::find().CaptureReceivingCompletedPackingSlip == WHSCaptureReceivingCompletedPackingSlip::Never)
        {
            return query;
        }

        QueryBuildDataSource loadLineDataSource = query.addDataSource(tableNum(WHSLoadLine));

        QueryBuildRange loadIdRange = loadLineDataSource.addRange(fieldNum(WHSLoadLine, LoadId));
        loadIdRange.value(_loadId);

        loadLineDataSource.addRange(fieldNum(WHSLoadLine, InventTransType)).value(queryValue(InventTransType::Purch));

        loadLineDataSource.addRange(fieldNum(WHSLoadLine, TransportRequest)).value(queryValue(NoYes::No));

        QueryBuildDataSource shipmentDataSource = loadLineDataSource.addDataSource(tableNum(WHSShipmentTable));
        shipmentDataSource.addLink(fieldNum(WHSLoadLine, ShipmentId), fieldNum(WHSShipmentTable, ShipmentId));
        shipmentDataSource.joinMode(JoinMode::ExistsJoin);
        shipmentDataSource.addRange(fieldNum(WHSShipmentTable, ReceivingCompletedPackingSlipId)).value(SysQuery::valueNot(''));

        loadLineDataSource.addSortField(fieldNum(WHSLoadLine, ShipmentId));
        loadLineDataSource.addSortField(fieldNum(WHSLoadLine, WorkCreatedQty), SortOrder::Descending);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ensurePackingSlipPurchParmUpdateIsCreated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ensures that the <c>PurchParmUpdate</c> record is created.
    /// </summary>
    /// <param name = "_purchParmUpdate">The purchase parm update instance.</param>
    protected void ensurePackingSlipPurchParmUpdateIsCreated(PurchParmUpdate _purchParmUpdate)
    {
        _purchParmUpdate.ParmId         = NumberSeq::newGetNum(CompanyInfo::numRefParmId()).num();
        _purchParmUpdate.DocumentStatus = DocumentStatus::PackingSlip;
        _purchParmUpdate.SpecQty        = PurchUpdate::Recorded;
        _purchParmUpdate.Proforma       = false;

        if (!PurchParmUpdate::exist(_purchParmUpdate.ParmId))
        {
            _purchParmUpdate.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPackingSlipPurchParm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new packing slip purchase parm record.
    /// </summary>
    /// <param name = "_loadLine">A load line.</param>
    /// <param name = "_maxUsedPackingSlipIdNum">A maximum positive integer that was used in PackingSlipId with same load ID.</param>
    /// <returns>The purchase parm instance.</returns>
    protected PurchParmTable createPackingSlipPurchParm(WHSLoadLine _loadLine, int _maxUsedPackingSlipIdNum)
    {
        PurchParmTable purchParmTable = this.initPackingSlipPurchParmFromLoadLine(_loadLine, _maxUsedPackingSlipIdNum);
        purchParmTable.insert();

        return purchParmTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPackingSlipPurchParmFromLoadLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes new packing slip instance of the <c>PurchParmTable</c> from a load line.
    /// </summary>
    /// <param name = "_loadLine">A load line.</param>
    /// <param name = "_maxUsedPackingSlipIdNum">A maximum positive integer that was used in PackingSlipId with the same load ID.</param>
    /// <returns>An instance of the <c>PurchParmTable</c>.</returns>
    protected PurchParmTable initPackingSlipPurchParmFromLoadLine(WHSLoadLine _loadLine, int _maxUsedPackingSlipIdNum)
    {
        PurchParmTable purchParmTable;

        purchParmTable.Ordering = DocumentStatus::PackingSlip;
        purchParmTable.initFromPurchTable(_loadLine.orderHeader() as PurchTable);
        purchParmTable.initPackingSlipPurchParmFromLoadLine(_loadLine, _maxUsedPackingSlipIdNum, this.parmParmId());

        return purchParmTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryForFindPurchParmLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query to retrieve <c>PurchParmLine</c> based on the WHS load line.
    /// </summary>
    /// <param name = "_purchParmLine">Purch parm line record.</param>
    /// <param name = "_loadLine">A load line record.</param>
    /// <param name = "_purchParmTable">A purchase order update record.</param>
    /// <returns>A query object.</returns>
    protected SysDaQueryObject buildQueryForFindPurchParmLine(PurchParmLine _purchParmLine, WHSLoadLine _loadLine, PurchParmTable _purchParmTable)
    {
        SysDaQueryObject queryObject = new SysDaQueryObject(_purchParmLine);

        queryObject.firstOnlyHint = true;
        queryObject.forUpdateHint = true;

        queryObject.whereClause(
            new SysDaEqualsExpression(new SysDaFieldExpression(_purchParmLine, fieldStr(PurchParmLine, InventTransId)), new SysDaValueExpression(_loadLine.InventTransId)).and(
            new SysDaEqualsExpression(new SysDaFieldExpression(_purchParmLine, fieldStr(PurchParmLine, ParmId)), new SysDaValueExpression(this.parmParmId()))));

        return queryObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPurchParmLineForLoadLine</Name>
				<Source><![CDATA[
    private PurchParmLine findPurchParmLineForLoadLine(WHSLoadLine _loadLine, PurchParmTable _purchParmTable)
    {
        PurchParmLine purchParmLine;

        SysDaFindStatement findStatement = new SysDaFindStatement();
        findStatement.execute(new SysDaFindObject(this.buildQueryForFindPurchParmLine(purchParmLine, _loadLine, _purchParmTable)));

        return purchParmLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchParmLineQuantityData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates existing or creates new purch parm line with updated quantity data.
    /// </summary>
    /// <param name = "_loadLine">A load line.</param>
    /// <param name = "_purchLine">A purchase order line.</param>
    /// <param name = "_purchParmUpdate">A purchase parm update instance.</param>
    /// <param name = "_registeredPurchQty">A purchase quantity.</param>
    /// <param name = "_registeredInventQty">An inventory quantity.</param>
    /// <param name = "_purchParmTable">A purchase parm table instance.</param>
    /// <returns>An instance of the <c>PurchParmLine</c>.</returns>
    protected PurchParmLine updatePurchParmLineQuantityData(
        WHSLoadLine _loadLine,
        PurchLine _purchLine,
        PurchParmUpdate _purchParmUpdate,
        PurchQty _registeredPurchQty,
        InventQty _registeredInventQty,
        PurchParmTable _purchParmTable)
    {
        PdsCWQty registeredCWQty = _purchLine.pdsCWRegistered();
        return this.updatePurchParmLineQuantityDataWithCW(_loadLine,
                                                          _purchLine,
                                                          _purchParmUpdate,
                                                          _registeredPurchQty,
                                                          _registeredInventQty,
                                                          registeredCWQty,
                                                          _purchParmTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchParmLineQuantityDataWithCW</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates existing or creates new purch parm line with updated quantity data.
    /// </summary>
    /// <param name = "_loadLine">A load line.</param>
    /// <param name = "_purchLine">A purchase order line.</param>
    /// <param name = "_purchParmUpdate">A purchase parm update instance.</param>
    /// <param name = "_registeredPurchQty">Registered quantity in purchase order unit.</param>
    /// <param name = "_registeredInventQty">Registered quantity in inventory unit.</param>
    /// <param name = "_registeredCWQty">Registered quantity in catch weight unit.</param>
    /// <param name = "_purchParmTable">A purchase parm table instance.</param>
    /// <returns>An instance of the <c>PurchParmLine</c>.</returns>
    protected PurchParmLine updatePurchParmLineQuantityDataWithCW(
        WHSLoadLine _loadLine,
        PurchLine _purchLine,
        PurchParmUpdate _purchParmUpdate,
        PurchQty _registeredPurchQty,
        InventQty _registeredInventQty,
        PdsCWQty _registeredCWQty,
        PurchParmTable _purchParmTable)
    {
        PurchParmLine purchParmLine = this.findPurchParmLineForLoadLine(_loadLine, _purchParmTable);

        PurchQuantity purchQuantity = PurchQuantity::construct(DocumentStatus::PackingSlip);
        
        if (purchParmLine)
        {
            purchParmLine.updatePackingSlipQty(
                purchQuantity,
                _purchLine,
                _purchParmUpdate,
                _registeredPurchQty,
                _registeredInventQty);

            this.setCWFieldOnPurchParmLine(purchParmLine, purchQuantity, _purchLine, _purchParmUpdate, _registeredCWQty);

            purchParmLine.update();
        }
        else
        {
            purchParmLine.initValue();
            purchParmLine.initFromPurchLine(_purchLine);
            purchParmLine.ParmId = this.parmParmId();
            purchParmLine.TableRefId = _purchParmTable.TableRefId;

            purchParmLine.updatePackingSlipQty(
                purchQuantity,
                _purchLine,
                _purchParmUpdate,
                _registeredPurchQty,
                _registeredInventQty);

            this.setCWFieldOnPurchParmLine(purchParmLine, purchQuantity, _purchLine, _purchParmUpdate, _registeredCWQty);

            purchParmLine.insert();
        }

        return purchParmLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCWFieldOnPurchParmLine</Name>
				<Source><![CDATA[
    private void setCWFieldOnPurchParmLine(
        PurchParmLine   _purchParmLine,
        PurchQuantity   _purchQuantity,
        PurchLine       _purchLine,
        PurchParmUpdate _purchParmUpdate,
        PdsCWInventQty  _cwRegistered
        )
    {
        if (PdsGlobal::pdsIsCWItem(_purchLine.ItemId))
        {
            [_purchParmLine.PdsCWReceiveNow, _purchParmLine.PdsCWRemainBeforeInvent, _purchParmLine.PdsCWRemainAfterInvent] = _purchQuantity.pdsCWQtyInvent(_purchLine, _purchParmUpdate.SpecQty, _cwRegistered);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPackSlipLoadLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a pack slip load line.
    /// </summary>
    /// <param name = "_loadLine">A load line.</param>
    /// <param name = "_purchParmLine">A purchase parm line.</param>
    protected void createPackSlipLoadLine(WHSLoadLine _loadLine, PurchParmLine _purchParmLine)
    {
        TMSTmpPackSlipLoadLine packSlipLoadLine = TMSTmpPackSlipLoadLine::createPackSlipLoadLine(_loadLine, _purchParmLine);

        tmpPackSlipLoadLines.addEnd(SysTableInMemorySerializer::packTable(packSlipLoadLine));
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPackingSlipAndUpdateLoadAndShipment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the packing slip and updates the related <c>WHSLoadLine</c> and <c>WHSShipmentTable</c> records
    /// of the received Purchase Order accordingly.
    /// </summary>
    /// <param name = "_loadId">The ID of the current load to be posted</param>
    public void postPackingSlipAndUpdateLoadAndShipment(WHSLoadId _loadId = this.parmLoadIdToPost())
    {
        try
        {
            using (var activityContext = this.instrumentationLogger().postPackingSlipActivities().postPackingSlipAndUpdateLoadAndShipment(tmpPackSlipLoadLines.elements()))
            {
                boolean packSlipRan;
                PurchFormLetter_PackingSlip purchFormLetter_PackingSlip = PurchFormLetter::construct(DocumentStatus::PackingSlip);

                if (this.parmPost())
                {
                    purchFormLetter_PackingSlip.parmCallerTable(null);
                    purchFormLetter_PackingSlip.parmCallerMenuItem(null);
                    purchFormLetter_PackingSlip.parmVersioningUpdateType(VersioningUpdateType::Initial);

                    purchFormLetter_PackingSlip.transDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
                    purchFormLetter_PackingSlip.parmDocumentOrigin(DocumentOrigin::Manual);
                    purchFormLetter_PackingSlip.parmId(this.parmParmId());
                    purchFormLetter_PackingSlip.purchParmUpdate(PurchParmUpdate::find(this.parmParmId()));
                    purchFormLetter_PackingSlip.parmShowDialog(this.shouldShowDialog());

                    purchFormLetter_PackingSlip.tmsParmRunFromSCS(true);
                    purchFormLetter_PackingSlip.showQueryForm(false);
                    purchFormLetter_PackingSlip.showBatchTab(false);
                    purchFormLetter_PackingSlip.printFormLetter(false);

                    ChargesManager_ProductReceipt::onInitCharges(purchFormLetter_PackingSlip.purchParmUpdate());

                    boolean skipLoadStatusUpdate = WHSParameters::isReceivingCompletedWithAutoPostEnabledForPOLoads()
                           && WHSLoadTable::find(_loadId).LoadStatus == WHSLoadStatus::Received;

                    using (var context = WHSProductReceiptSkipLoadStatusUpdateContext::newFromParameter(skipLoadStatusUpdate))
                    {
                        purchFormLetter_PackingSlip.startOperation();
                    }

                    if (purchFormLetter_PackingSlip.parmJournalRecord().RecId)
                    {
                        this.parmPackingSlipJournalPosted(true);

                        packSlipRan = true;
                        if (!this.allowMultipleProductReceiptsForLoad()
                            || WHSLoadTable::checkAllLinesReceivedForLoad(_loadId))
                        {
                            this.unpackPackSlipLoadLines();
                        }
                    }
                }

                if (!this.parmPost() || packSlipRan)
                {
                    ttsbegin;

                    // If we fall back due to using total registered quantities, fall back to previous behavior of forcibly setting the load status to Received.
                    // Links for packing slips have already been created during product receipt posting.
                    if ((usedTotalPurchLineRegisteredQuantities
                            || !registeredQuantitiesCalculated)
                        && (!this.allowMultipleProductReceiptsForLoad()
                            || WHSLoadTable::checkAllLinesReceivedForLoad(_loadId)))
                    {
                        WHSLoadTable loadTable = WHSLoadTable::find(_loadId, true);
                        this.updateLoadStatuses(loadTable);
                    }
                    else
                    {
                        if (!this.parmPost())
                        {
                            // If multiple product receipts aren't allowed, update load lines even if nothing was posted in order to close out the load.
                            // If this.parmPost() is true, then the same would have been called above.
                            this.unpackPackSlipLoadLines();
                        }
                        WHSLoadStatusUpdater::newFromLoadId(_loadId).updateWhenVendPackingSlipPosted();
                        WHSShipmentStatusUpdater::updateInboundShipmentsByLoad(_loadId);
                        this.updateLoadProductReceiptProcessingStatus(_loadId, WHSProductReceiptProcessingStatus::Processed);
                    }   
                    ttscommit;
                  
                    info("@WAX841");
                }
            }
        }
        catch
        {
            throw error(strFmt("@WAX4206", _loadId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldShowDialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the dialog should be shown.
    /// </summary>
    /// <returns>true if the dialog should be shown; otherwise, false.</returns>
    protected boolean shouldShowDialog()
    {
        return !this.isInBatch();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLoadStatuses</Name>
				<Source><![CDATA[
    private void updateLoadStatuses(WHSLoadTable _loadTable)
    {
        if (WHSParameters::isReceivingCompletedWithAutoPostEnabledForPOLoads())
        {
            _loadTable.ProductReceiptProcessingStatus = WHSProductReceiptProcessingStatus::Processed;
        }

        _loadTable.LoadStatus = WHSLoadStatus::Received;
        _loadTable.write();

        this.updateShipmentStatusByLoadId(_loadTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLoadProductReceiptProcessingStatus</Name>
				<Source><![CDATA[
    private void updateLoadProductReceiptProcessingStatus(WHSLoadId _loadId, WHSProductReceiptProcessingStatus _status)
    {
        if (!WHSParameters::isReceivingCompletedWithAutoPostEnabledForPOLoads())
        {
            return;
        }

        WHSLoadTable loadTable = WHSLoadTable::find(_loadId, true);

        loadTable.ProductReceiptProcessingStatus = _status;
        loadTable.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateShipmentStatusByLoadId</Name>
				<Source><![CDATA[
    private void updateShipmentStatusByLoadId(WHSLoadTable _loadTable)
    {
        using (var activityContext = this.instrumentationLogger().postPackingSlipActivities().updateShipmentStatusByLoadId(_loadTable.RecId))
        {
            WHSShipmentTable shipmentTable;
            WHSLoadLine      loadLine;
            
            while select forupdate shipmentTable
                where shipmentTable.LoadId == _loadTable.LoadId
                exists join loadLine
                    where shipmentTable.ShipmentId == loadLine.ShipmentId
            {
                shipmentTable.ShipmentStatus = WHSShipmentStatus::Received;
                shipmentTable.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLoadVendorPackingSlipJour</Name>
				<Source><![CDATA[
    private void createLoadVendorPackingSlipJour(WHSLoadTable _loadTable)
    {
        PurchParmTable      purchParmTable;
        VendPackingSlipJour vendPackingSlipJour;

        using (var activityContext = this.instrumentationLogger().postPackingSlipActivities().createLoadVendorPackingSlipJour(_loadTable.RecId))
        {
            while select RecId from vendPackingSlipJour
                exists join purchParmTable
                    where purchParmTable.Num    == vendPackingSlipJour.PackingSlipId
                        && purchParmTable.ParmId == this.parmParmId()
            {
                WHSLoadTableVendPackingSlipJour::createRecord(_loadTable.LoadId, _loadTable.DataAreaId, vendPackingSlipJour.RecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpackPackSlipLoadLines</Name>
				<Source><![CDATA[
    private void unpackPackSlipLoadLines()
    {
        using (var activityContext = this.instrumentationLogger().postPackingSlipActivities().unpackPackSlipLoadLines(tmpPackSlipLoadLines.elements()))
        {
            ttsbegin;

            ListEnumerator tmpPackSlipLoadLinesEnumerator = tmpPackSlipLoadLines.getEnumerator();
            while (tmpPackSlipLoadLinesEnumerator.moveNext())
            {
                container currentPackedTmpPackSlipLoadLine = tmpPackSlipLoadLinesEnumerator.current();

                TMSTmpPackSlipLoadLine packSlipLoadLine;
                SysTableInMemorySerializer::unpackTable(currentPackedTmpPackSlipLoadLine, packSlipLoadLine);

                PurchParmLine localPurchParmLine = PurchParmLine::findRecId(packSlipLoadLine.PackSlipRefRecId);

                ItemId itemId = localPurchParmLine.ItemId;

                if (TMSInventEnabled::exist(itemId) || !localPurchParmLine)
                {
                    this.alterLoadLine(packSlipLoadLine, localPurchParmLine);
                }
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaxUsedPackingSlipIdNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the maximum positive integer that was used in PackingSlipId with LoadId.
    /// </summary>
    /// <param name="_loadId">
    /// Load Id
    /// </param>
    /// <returns>
    /// The maximum positive integer that was used in PackingSlipId with LoadId.
    /// </returns>
    public static int getMaxUsedPackingSlipIdNum(WHSLoadId _loadId)
    {
        new InteropPermission(InteropKind::ClrInterop).assert();

        int                 maxUsed = 0;
        Str60               likeStr = strReplace(strReplace(strReplace(_loadId, '\\', '\\\\'), '*', '\\*'), '?', '\\?') + '_*';
        VendPackingSlipJour vendPackingSlipJour;

        while select PackingSlipId from vendPackingSlipJour
            where vendPackingSlipJour.PackingSlipId like likeStr
        {
            str suffix = subStr(vendPackingSlipJour.PackingSlipId, strLen(_loadId) + 2, strLen(vendPackingSlipJour.PackingSlipId));
            System.Int32 intSuffix;
            boolean validInt = System.Int32::TryParse(suffix, byref intSuffix);

            // Only accept valid positive integers without extra characters, e.g. leading zeroes
            if (validInt && intSuffix > 0 && int2Str(intSuffix) == suffix && intSuffix > maxUsed)
            {
                maxUsed = intSuffix;
            }
        }

        return maxUsed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shipConfirm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Run the transportation ship confirmation process to confirm rates and apportion misc charges.
    /// </summary>
    /// <param name="_loadId">
    /// The load to confirm the shipment.
    /// </param>
    /// <returns>
    /// true if load was ship confirmed; otherwise, false
    /// </returns>
    public boolean shipConfirm(WHSLoadId _loadId)
    {
        WHSLoadTable              loadTable    = WHSLoadTable::find(_loadId);
        WHSShipConfirmUTCDateTime loadShipDate = DateTimeUtil::getSystemDateTime();
        WHSLoadId                 loadId;
        container                 loads;
        container                 confirmedLoads;
        int                       numOfLoads;
        int                       i;
        boolean                   ret = false;

        
        if (loadTable.LoadStatus == WHSLoadStatus::Shipped)
        {
            // true - because load is actually ship confirmed
            return true;
        }
        else if (this.allowMultipleProductReceiptsForLoad()
            && loadTable.LoadShipConfirmUTCDateTime != utcDateTimeNull())
        {
            return true;
        }

        loads = this.retrieveLoads(loadTable);
        numOfLoads = conLen(loads);

        if (conlen(loads) == 0)
        {
            return ret;
        }

        try
        {
            ttsbegin;

            for (i = 1; i <= numOfLoads; ++i)
            {
                loadId = conPeek(loads, i);
                this.shipConfirmLoad(conPeek(loads, i), loadShipDate);
                confirmedLoads += loadId;
            }

            ttscommit;

            if (conLen(confirmedLoads) > 1)
            {
                ret = true;
                info(strFmt("@TRX1681", con2Str(confirmedLoads, ', ')));
            }
            else if (conLen(confirmedLoads) == 1)
            {
                ret = true;
                info(strFmt("@WAX2544", conPeek(confirmedLoads, 1)));
            }

            if (conLen(loadsWithInvoicedOrders) > 1)
            {
                info(strFmt("@TRX2710", con2Str(loadsWithInvoicedOrders, ', ')));
            }
            else if (conLen(loadsWithInvoicedOrders) == 1)
            {
                info(strFmt("@TRX2639", conPeek(loadsWithInvoicedOrders, 1)));
            }
        }
        catch
        {
            if (numOfLoads > 0)
            {
                this.tmsRouteUnConfirm(_loadId);
            }

            error(strFmt("@WAX2543", _loadId));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shipConfirmLoad</Name>
				<Source><![CDATA[
    /// <summary>
    /// Run the transportation ship confirmation process to confirm rates and apportion miscellaneous charges.
    /// </summary>
    /// <param name="_loadId">
    /// The load to confirm the shipment.
    /// </param>
    /// <param name="_loadShipDate">
    /// Shipping confirmation date in Coordinated Universal Time (UTC).
    /// </param>
    protected void shipConfirmLoad(
        WHSLoadId                 _loadId,
        WHSShipConfirmUTCDateTime _loadShipDate)
    {
        using (var activityContext = this.instrumentationLogger().shipConfirmActivities().postPackingSlipShipConfirm())
        {
            ttsbegin;

            this.tmsRouteConfirmation(_loadId, _loadShipDate);

            WHSLoadTable::setShipConfirmInfo(_loadId, _loadShipDate);

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQuerySelectButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to show query select button.
    /// </summary>
    /// <returns>
    /// True if to show query select button.
    /// </returns>
    boolean showQuerySelectButton()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    public boolean showQueryValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmsRouteConfirmation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs route confirmation on the load.
    /// </summary>
    /// <param name="_loadId">
    /// Id of the load.
    /// </param>
    /// <param name="_loadShipDate">
    /// Ship confirm date of the load.
    /// </param>
    /// <returns>
    /// True if the route is confirmed, otherwise false.
    /// </returns>
    boolean tmsRouteConfirmation(WHSLoadId _loadId, WHSShipConfirmUTCDateTime _loadShipDate)
    {
        TMSRoute        route;
        WHSLoadTable    loadTable;
        boolean         ret;
        Map             shipDateMap;

        if (_loadId)
        {
            loadTable = WHSLoadTable::find(_loadId);

            if (loadTable.LoadPaysFreight)
            {
                if (loadTable.RouteCode != '')
                {
                    route = TMSRoute::find(loadTable.RouteCode);
                    ret = route.loadRouteConfirmation(_loadId, _loadShipDate);
                }
                else if (loadTable.CarrierCode != '')
                {
                    shipDateMap = new Map(Types::String, Types::UtcDateTime);
                    shipDateMap.insert(loadTable.LoadId, _loadShipDate);
                    ret = WHSLoadTable::tmsLoadConfirmation(_loadId, shipDateMap);
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmsRouteUnConfirm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unconfirms route for a load.
    /// </summary>
    /// <param name="_loadId">
    /// Load id.
    /// </param>
    void tmsRouteUnConfirm(WHSLoadId _loadId)
    {
        TMSRoute::unConfirm(WHSLoadTable::find(_loadId).RouteCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version     version = RunBase::getVersion(_packedClass);
        boolean     ret = true;
        container   packedQuery;

        switch (version)
        {
            case #CurrentVersion:
                if (this.inGetSaveLast())
                {
                    [version, #CurrentList, packedQuery] = _packedClass;

                    if (!packedQuery)
                    {
                        ret = false;
                    }
                    else
                    {
                        queryRun = new QueryRun(packedQuery);
                    }
                }
                else
                {
                    [version, #CurrentListNewSession, packedQuery] = _packedClass;

                    tmpPackSlipLoadLines = List::create(packedTmpPackSlipLoadLines);

                    if (packedQuery)
                    {
                        queryRun = new QueryRun(packedQuery);
                    }
                }
                break;

            case #Version5:
                if (this.inGetSaveLast())
                {
                    boolean restrictLoadsToOnlyRegistered;
                    [version, #CurrentListV5, packedQuery] = _packedClass;

                    if (!packedQuery)
                    {
                        ret = false;
                    }
                    else
                    {
                        queryRun = new QueryRun(packedQuery);
                    }
                }
                else
                {
                    boolean restrictLoadsToOnlyRegistered;
                    [version, #ListV5NewSession, packedQuery] = _packedClass;

                    tmpPackSlipLoadLines = List::create(packedTmpPackSlipLoadLines);
                    disableRestrictLoadsToOnlyRegistered = !WHSAlwaysEnableInventTransOptimizationInPRPostingFlight::instance().isEnabled() && !restrictLoadsToOnlyRegistered;

                    if (packedQuery)
                    {
                        queryRun = new QueryRun(packedQuery);
                    }
                }
                break;

            case #Version4:
                if (this.inGetSaveLast())
                {
                    [version, #CurrentListV4, packedQuery] = _packedClass;

                    if (!packedQuery)
                    {
                        ret = false;
                    }
                    else
                    {
                        queryRun = new QueryRun(packedQuery);
                    }
                }
                else
                {
                    [version, #ListV4NewSession, packedQuery] = _packedClass;

                    tmpPackSlipLoadLines = List::create(packedTmpPackSlipLoadLines);

                    if (packedQuery)
                    {
                        queryRun = new QueryRun(packedQuery);
                    }
                }

                if (queryRun &&
                    queryRun.query() &&
                    queryRun.query().dataSourceTable(tableNum(InventTrans)))
                {
                    disableRestrictLoadsToOnlyRegistered = false;
                }
                else
                {
                    disableRestrictLoadsToOnlyRegistered = true;
                }
                break;

            case #Version3:
                if (this.inGetSaveLast())
                {
                    [version, #CurrentListV3, packedQuery] = _packedClass;

                    if (!packedQuery)
                    {
                        ret = false;
                    }
                    else
                    {
                        queryRun = new QueryRun(packedQuery);
                    }
                }
                else
                {
                    [version, #ListV3NewSession, packedQuery] = _packedClass;

                    tmpPackSlipLoadLines = List::create(packedTmpPackSlipLoadLines);

                    if (packedQuery)
                    {
                        queryRun = new QueryRun(packedQuery);
                    }
                }
                break;

            case #Version2:
                if (this.inGetSaveLast())
                {
                    [version, #CurrentListV2] = _packedClass;
                }
                else
                {
                    [version, #ListV2NewSession] = _packedClass;

                    tmpPackSlipLoadLines = List::create(packedTmpPackSlipLoadLines);
                }
                break;

            default:
                ret = false;
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFreightTerms</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the Pays Freight on the associated orders are in sync
    /// </summary>
    /// <param name="_loadId">
    /// The load Id of the load being validated.
    /// </param>
    /// <returns>
    /// true if freight terms are set correct; othwerwise, false.
    /// </returns>
    private boolean validateFreightTerms(WHSLoadId _loadId)
    {
        boolean paysFreightError;
        boolean hasInvoicedLines;

        // Will evaluate if the Pays Freight on the associated orders are in sync
        [hasInvoicedLines, paysFreightError] = WHSLoadTable::evaluateLoadPaysFreight(_loadId);

        if (hasInvoicedLines)
        {
            loadsWithInvoicedOrders += _loadId;
        }

        return !paysFreightError;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static WHSPostPackingSlip construct()
    {
        return new WHSPostPackingSlip();
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    static ClassDescription description()
    {
        return "@SYS11549";
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPackingSlipEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if post packing slip button should be enabled for the load
    /// </summary>
    /// <param name="_whsLoadTable">
    /// Load for which we want to generate packing slip
    /// </param>
    /// <returns>
    /// true if post packing slip button should be enabled; otherwise, false
    /// </returns>
    public static boolean isPackingSlipEnabled(WHSLoadTable _whsLoadTable)
    {
        return  _whsLoadTable.LoadId
            && _whsLoadTable.LoadDirection == WHSLoadDirection::Inbound
            && (_whsLoadTable.LoadStatus != WHSLoadStatus::Received || WHSPostPackingSlip::loadIsReadyForAutoposting(_whsLoadTable))
            && _whsLoadTable.isTransportRequest() == NoYes::No
            &&  WHSPostPackingSlip::tmsPOConfirmed(_whsLoadTable.LoadId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadIsReadyForAutoposting</Name>
				<Source><![CDATA[
    private static boolean loadIsReadyForAutoposting(WHSLoadTable _whsLoadTable)
    {
        return WHSParameters::isReceivingCompletedWithAutoPostEnabledForPOLoads()
            && _whsLoadTable.LoadStatus == WHSLoadStatus::Received
            && _whsLoadTable.ProductReceiptProcessingStatus == WHSProductReceiptProcessingStatus::ReadyForProcessing;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isShipConfirmEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if ship confirm button should be enabled for the load
    /// </summary>
    /// <param name="_whsLoadTable">
    /// Load to be ship confirmed
    /// </param>
    /// <param name="_fromPackingSlip">
    /// Boolean to determine whether to check the ship time.
    /// </param>
    /// <returns>
    /// true if ship confirm button should be enabled; otherwise, false
    /// </returns>
    public static boolean isShipConfirmEnabled(
        WHSLoadTable _whsLoadTable,
        boolean      _fromPackingSlip = false)
    {
        return _whsLoadTable.LoadId
            && _whsLoadTable.LoadDirection                          == WHSLoadDirection::Inbound
            && TMSRoute::find(_whsLoadTable.RouteCode).RouteStatus  != TMSRouteStatus::Confirmed
            && (_fromPackingSlip
            ||  !WHSShipmentTable::findByLoadId(_whsLoadTable.LoadId).ShipConfirmUTCDateTime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateLoadIdIfAvailable</Name>
				<Source><![CDATA[
    private static QueryRun populateLoadIdIfAvailable(Args _args, WHSPostPackingSlip _postPackingSlip)
    {
        QueryRun packingSlipQueryRun;

        if (_args.dataset() == tableNum(WHSLoadTable))
        {
            WHSLoadTable loadTable = _args.record() as WHSLoadTable;

            if (loadTable.LoadId)
            {
                _postPackingSlip.parmLoadIdToPost(loadTable.LoadId);

                packingSlipQueryRun    = _postPackingSlip.queryRun();
                Query packingSlipQuery  = packingSlipQueryRun.query();

                SysQuery::findOrCreateRange(packingSlipQuery.dataSourceTable(tableNum(WHSLoadTable)), fieldNum(WHSLoadTable, LoadId)).value(loadTable.LoadId);
            }
        }
        return packingSlipQueryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args args)
    {
        WHSPostPackingSlip  packingSlip         = WHSPostPackingSlip::construct();
        packingSlip.getLast();

        using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContextBatchController(packingSlip))
        {
            QueryRun            packingSlipQueryRun = WhsPostPackingSlip::populateLoadIdIfAvailable(args, packingSlip);
  
            if (packingSlip.prompt())
            {
                using (var activityContext = packingSlip.instrumentationLogger().postPackingSlipActivities().run())
                {
                    int loadCount;
                    packingSlipQueryRun = packingSlip.queryRun();

                    while (packingSlipQueryRun.next())
                    {
                        try
                        {
                            WHSLoadTable loadTable = packingSlipQueryRun.get(tableNum(WHSLoadTable));

                            if (!loadTable.canPostProductReceipt())
                            {
                                continue;
                            }

                            packingSlip.parmLoadIdToPost(loadTable.LoadId);

                            packingSlip.runOperation();

                            packingSlip.postPackingSlipAndUpdateLoadAndShipment();

                            if (packingSlip.parmPackingSlipJournalPosted())
                            {
                                info(strFmt("@WAX673", packingSlip.parmLoadIdToPost()));
                            }

                            ++loadCount;
                        }
                        catch(Exception::Error)
                        {
                            exceptionTextFallThrough();
                        }
                    }
                
                    packingSlip.instrumentationLogger().postPackingSlipActivities().postedLoadsCount(activityContext, loadCount);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shipConfirmAllLoads</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs the ship confirm process for all loads.
    /// </summary>
    /// <param name="_loadIdList">
    /// List of loadIds to be ship confirmed.
    /// </param>
    public static void shipConfirmAllLoads(List _loadIdList)
    {
        ListEnumerator     loadIdEnumerator;
        WHSLoadId          loadId;
        WHSPostPackingSlip postPackingSlip;

        loadIdEnumerator = _loadIdList.getEnumerator();

        while (loadIdEnumerator.moveNext())
        {
            postPackingSlip = WHSPostPackingSlip::construct();
            loadId = loadIdEnumerator.current();
            postPackingSlip.shipConfirm(loadId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmsPOConfirmed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether purchase orders of the load are confirmed.
    /// </summary>
    /// <param name="_loadId">
    /// Load id.
    /// </param>
    /// <returns>
    /// True if all the purchase orders of the load are confirmed.
    /// </returns>
    public static boolean tmsPOConfirmed(WHSLoadId _loadId)
    {
        PurchTable  purchTable;
        WHSLoadLine loadLine;

        select firstonly RecId from purchTable
            join LoadId, OrderNum, InventTransType, TransportRequest from loadLine
            where loadLine.LoadId           == _loadId                  &&
                  loadLine.OrderNum         == purchTable.PurchId       &&
                  loadLine.InventTransType  == InventTransType::Purch   &&
                  loadLine.TransportRequest == NoYes::No                &&
                  purchTable.DocumentState  < VersioningDocumentState::Confirmed;

        return purchTable.RecId == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLoadIdToPost</Name>
				<Source><![CDATA[
    public WHSLoadId parmLoadIdToPost(WHSLoadId _loadIdToPost = loadIdToPost)
    {
        loadIdToPost = _loadIdToPost;

        return loadIdToPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmId</Name>
				<Source><![CDATA[
    public ParmId parmParmId(ParmId _parmId = parmId)
    {
        parmId = _parmId;

        return parmId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPost</Name>
				<Source><![CDATA[
    public boolean parmPost(boolean _post = post)
    {
        post = _post;

        return post;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPackingSlipJournalPosted</Name>
				<Source><![CDATA[
    public boolean parmPackingSlipJournalPosted(boolean _packingSlipJournalPosted = packingSlipJournalPosted)
    {
        packingSlipJournalPosted = _packingSlipJournalPosted;

        return packingSlipJournalPosted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    private WHSInstrumentationLogger instrumentationLogger()
    {
        if (!instrumentationLogger)
        {
            instrumentationLogger = WHSInstrumentationLogger::createLogger(classId2Name(classIdGet(this)));
        }

        return instrumentationLogger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDisableRestrictLoadsToOnlyRegistered</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean parmDisableRestrictLoadsToOnlyRegistered(boolean _disableRestrictLoadsToOnlyRegistered = disableRestrictLoadsToOnlyRegistered)
    {
        disableRestrictLoadsToOnlyRegistered = _disableRestrictLoadsToOnlyRegistered;
        return disableRestrictLoadsToOnlyRegistered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowMultipleProductReceipts</Name>
				<Source><![CDATA[
    public boolean parmAllowMultipleProductReceipts(boolean _allowMultipleProductReceipts = allowMultipleProductReceipts)
    {
        allowMultipleProductReceipts = _allowMultipleProductReceipts;
        
        return allowMultipleProductReceipts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>errorMessageHelpScopeFormName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the form name used for the error context using a <c>SysErrorMessageHelpScope</c> class.
    /// </summary>
    /// <returns>The form name used for the error context.</returns>
    [Hookable(false)]
    public FormName errorMessageHelpScopeFormName()
    {
        return strFmt('%1_%2', formStr(Dialog), classStr(WhsPostPackingSlip));
    }

]]></Source>
			</Method>
			<Method>
				<Name>errorMessageHelpScopeActionName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the action name used for the error context using a <c>SysErrorMessageHelpScope</c> class.
    /// </summary>
    /// <returns>The action name used for the error context.</returns>
    [Hookable(false)]
    public str errorMessageHelpScopeActionName()
    {
        return menuItemActionStr(WHSPostPackingSlip);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>