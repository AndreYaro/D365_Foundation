<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxReconciliationReportDP</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>TaxReconciliationDP</c> class supports the <c>TaxReconciliationReport</c> SSRS report.
/// </summary>
/// <remarks>
/// This class declares variables, tables, enumerations, and so on, that can be used for the
/// <c>TaxReconciliationReport</c> SSRS report.
/// </remarks>
[
    SRSReportQuery(queryStr(TaxReconciliationReport)),
    SRSReportParameterAttribute(classStr(TaxReconciliationReportContract))
]
public class TaxReconciliationReportDP extends SrsReportDataProviderPreProcessTempDB
{
    Query                           detailQuery;
    QueryBuildDataSource            qbd;
    QueryBuildRange                 range;
    QueryRun                        detQueryRun;
    TmpTaxReconciliationNoVat       tmpTaxReconciliationNoVat;
    TaxReconciliationReportTmp      taxReconciliationReportTmp;
    FromDate                        fromDate;
    ToDate                          toDate;
    LedgerAccount                   fromAccount;
    LedgerAccount                   toAccount;
    TaxPeriod                       taxPeriod;
    TaxReconciliationReportCountry  reportForCountry;
    AccountNum                      previousAccountNum;
    TaxCode                         previousTaxCode;
    AccountName                     accountName;
    boolean                         details;
    boolean                         transVAT;
    boolean                         splitTaxCode;
    boolean                         groupTaxCode;
    boolean                         inserted;
    boolean                         printWithoutTax;
    boolean                         insert;
    int                             design;
    Set                             setSourceDocLine;

    protected boolean takeOwnershipOfTempTables = true;
    protected boolean useNewCalculationMethod;
    protected Map<MainAccountNum, AccountName> acctNameCache;

    protected boolean isTaxSpecificExchangeRateEnabled;

    private const int ExchangeRateMultiplier = 100;
    private const int DoNeedToAlignAmountsFlag = 1;
    private const int DoNotNeedToAlignAmountsFlag = 0;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmSkipReportTransaction</Name>
				<Source><![CDATA[
    public boolean parmSkipReportTransaction(boolean _skipReportTransaction = skipReportTransaction)
    {
        // This should be activated only when calcTax_v2 is used, otherwise the execution will crash
        if (FeatureStateProvider::isFeatureEnabled(SsrsPreProcessReportSkipDefaultDatabaseTrxScope::instance())
            && FeatureStateProvider::isFeatureEnabled(UseNewCalculationMethodForTaxReconciliationReportFeature::instance()))
        {
            skipReportTransaction = true;
        }

        return skipReportTransaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTakeOwnershipOfTempTables</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves or sets the value of takeOwnershipOfTempTables parameter.
    /// </summary>
    /// <param name = "_takeOwnershipOfTempTables">Parameter value to set.</param>
    /// <returns>Actual parameter value.</returns>
    public boolean parmTakeOwnershipOfTempTables(boolean _takeOwnershipOfTempTables = takeOwnershipOfTempTables)
    {
        takeOwnershipOfTempTables = _takeOwnershipOfTempTables;
        return takeOwnershipOfTempTables;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCntLedgerTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the number of ledger transactions for a given voucher, account number, tax reference ID,
    ///    and date.
    /// </summary>
    /// <param name="_subLedgerVoucherLink">
    ///    A table buffer of the <c>SubledgerVoucherLink </c> table.
    /// </param>
    /// <param name="_taxTransGeneralJournalAccountEntry">
    ///    A table buffer of the <c>TaxTransGeneralJournalAccountEntry </c> table.
    /// </param>
    /// <param name="_mainAccount">
    ///    A table buffer of the <c>MainAccount </c> table.
    /// </param>
    /// <returns>
    ///    The number of transactions that matched the search criteria.
    /// </returns>
    private int calcCntLedgerTrans(SubledgerVoucherGeneralJournalEntry _subledgerVoucherGeneralJournalEntry,
                                   TaxTransGeneralJournalAccountEntry _taxTransGeneralJournalAccountEntry,
                                   MainAccount _mainAccount
                                   )
    {
        GeneralJournalEntry                 generalJournalEntry;
        DimensionAttributeValueCombination  dimensionAttributeValueCombination;
        TaxTransGeneralJournalAccountEntry  taxTransGeneralJournalAccountEntry;
        TaxTrans                            taxTrans;
        GeneralJournalAccountEntry          generalJournalAccountEntry;
        MainAccount                         mainAccount;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;

        select count(RecId) from generalJournalEntry
            where generalJournalEntry.Ledger == Ledger::current()
            exists join subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalEntry.RecId
                    && subledgerVoucherGeneralJournalEntry.Voucher            == _subledgerVoucherGeneralJournalEntry.Voucher
                    && subledgerVoucherGeneralJournalEntry.AccountingDate     == _subledgerVoucherGeneralJournalEntry.AccountingDate
            exists join generalJournalAccountEntry
                where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
            exists join dimensionAttributeValueCombination
                where dimensionAttributeValueCombination.RecId == generalJournalAccountEntry.LedgerDimension
            exists join mainAccount
                where dimensionAttributeValueCombination.MainAccount == mainAccount.RecId
                  && mainAccount.MainAccountId == _mainAccount.MainAccountId
            exists join taxTrans
                where taxTrans.TransDate == subledgerVoucherGeneralJournalEntry.AccountingDate
                    && taxTrans.Voucher == subledgerVoucherGeneralJournalEntry.Voucher
                    && taxTrans.TaxPeriod == taxPeriod
            exists join taxTransGeneralJournalAccountEntry
                where taxTransGeneralJournalAccountEntry.TaxTrans == taxTrans.RecId
                    && taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry == _taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry
                    && taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry                   != 0;

        return any2int(generalJournalEntry.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCntTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the number of tax transactions for a given voucher and date.
    /// </summary>
    /// <param name="_generalJournalEntry">
    ///    A table buffer of the <c>GeneralJournalEntry</c> table.
    /// </param>
    /// <param name="_mainAccount">
    ///    A table buffer of the <c>MainAccount </c> table.
    /// </param>
    /// <returns>
    ///    The number of transactions that matched the search criteria.
    /// </returns>
    private int calcCntTaxTrans(SubledgerVoucherGeneralJournalEntry _subledgerVoucherGeneralJournalEntry,
                                GeneralJournalEntry _generalJournalEntry,
                                MainAccount _mainAccount
                                )
    {
        TaxTrans cntTaxTrans;

        select count(RecId) from cntTaxTrans
            where cntTaxTrans.Voucher   == _subledgerVoucherGeneralJournalEntry.Voucher
               && cntTaxTrans.TransDate == _generalJournalEntry.AccountingDate;

        return any2int(cntTaxTrans.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDetails</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Populates the <c>taxReconciliationReporttmp</c> table if a user chooses to print detail information.
    /// </summary>
    private void calcDetails()
    {
        GeneralJournalEntry                 generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherLink;
        DimensionAttributeValueCombination  dimensionAttributeValueCombination;
        GeneralJournalAccountEntry          generalJournalAccountEntry;
        MainAccount                         mainAccount;

        AccountNum oldAccountNum = '';
        Voucher    oldVoucher = '';

        void calcDetailsTaxInfo()
        {
            inserted = false;
            if (! splitTaxCode)
            {
                this.calcNoVat(subledgerVoucherLink, mainAccount, generalJournalAccountEntry);
            }
            if ((mainAccount.MainAccountId != oldAccountNum && oldAccountNum != '')
            || (subledgerVoucherLink.Voucher != oldVoucher && oldVoucher != ''))
            {
                taxReconciliationReportTmp.AccountNum   = oldAccountNum;
                taxReconciliationReportTmp.Voucher      = oldVoucher;
                taxReconciliationReportTmp.TransDate    = generalJournalEntry.AccountingDate;
                taxReconciliationReportTmp.Name         = MainAccount::getLocalizedNameByMainAccountId(taxReconciliationReportTmp.AccountNum);
                taxReconciliationReportTmp.Design       = design;
                taxReconciliationReportTmp.insert();
                taxReconciliationReportTmp.clear();
                inserted = true;
            }

            this.calcTax(mainAccount,subledgerVoucherLink.Voucher, generalJournalAccountEntry, subledgerVoucherLink.AccountingDate);

            if (mainAccount.MainAccountId != oldAccountNum)
            {
                oldAccountNum = mainAccount.MainAccountId;
            }
            if (subledgerVoucherLink.Voucher != oldVoucher)
            {
                oldVoucher = subledgerVoucherLink.Voucher;
            }
            if (! inserted && ! taxReconciliationReportTmp.AccountNum)
            {
                taxReconciliationReportTmp.AccountNum   = oldAccountNum;
                taxReconciliationReportTmp.Voucher      = oldVoucher;
                taxReconciliationReportTmp.TransDate    = generalJournalEntry.AccountingDate;
                taxReconciliationReportTmp.Name         = MainAccount::getLocalizedNameByMainAccountId(taxReconciliationReportTmp.AccountNum);
                taxReconciliationReportTmp.Design       = design;
                taxReconciliationReportTmp.insert();
                taxReconciliationReportTmp.clear();
                inserted = true;
            }
        }

        taxReconciliationReportTmp.clear();
        if (this.useNewCalculationMethod)
        {
            this.calcTax_v2();
        }
        else
        {
            while select TransactionCurrencyAmount,TransactionCurrencyCode, AccountingCurrencyAmount,PostingType, GeneralJournalEntry, LedgerDimension
                from generalJournalAccountEntry
            join AccountingDate, RecId from generalJournalEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                    && generalJournalEntry.Ledger == Ledger::current()
                    && generalJournalEntry.AccountingDate >= fromDate
                    && generalJournalEntry.AccountingDate <= toDate
            join Voucher, VoucherDataAreaId, GeneralJournalEntry, AccountingDate from subledgerVoucherLink
                where subledgerVoucherLink.GeneralJournalEntry == generalJournalEntry.RecId
            join MainAccount,RecId from dimensionAttributeValueCombination
                where generalJournalAccountEntry.LedgerDimension == dimensionAttributeValueCombination.RecId
            join MainAccountId, RecId from mainAccount
                order by mainAccount.MainAccountId, subledgerVoucherLink.Voucher
                where dimensionAttributeValueCombination.MainAccount == mainAccount.RecId
                    && (!fromAccount || mainAccount.MainAccountId  >= fromAccount)
                    && (!toAccount || mainAccount.MainAccountId  <= toAccount)
            {
                calcDetailsTaxInfo();
            }
        }

        if (! inserted && taxReconciliationReportTmp.AccountNum)
        {
            taxReconciliationReportTmp.Name     = MainAccount::getLocalizedNameByMainAccountId(taxReconciliationReportTmp.AccountNum);
            taxReconciliationReportTmp.Design   = design;
            taxReconciliationReportTmp.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcNoDetails</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Populates the <c>TaxReconciliationReporttmp</c> table with the tax information and ledger account
    ///    if a user chooses to print without detail information.
    /// </summary>
    private void calcNoDetails()
    {
        GeneralJournalEntry                 generalJournalEntry;
        DimensionAttributeValueCombination  dimensionAttributeValueCombination;
        TaxTransGeneralJournalAccountEntry  taxTransGeneralJournalAccountEntry;
        GeneralJournalAccountEntry          generalJournalAccountEntry;
        MainAccount                         mainAccount;
        AccountNum                          oldAccountNum = '';
        SubledgerVoucherGeneralJournalEntry subledgerVoucherLink;
        int                                 counterLedger = 0, counterTax = 0;

        void calcNoDetailsInfo()
        {
            if ((counterLedger <= counterTax) || (counterLedger == 1 && counterTax == 0 ))
            {
                inserted = false;
                this.calcNoVat(subledgerVoucherLink, mainAccount, generalJournalAccountEntry);

                if (mainAccount.MainAccountId != oldAccountNum && oldAccountNum != '')
                {
                    // For Iceladic features ignore any ledgerTrans transaction without TaxCode
                    // that do not have corresponding non-VAT transactions.
                    if (!printWithoutTax || (taxReconciliationReportTmp.TaxCode == '' && this.findTmpTaxReconNoVatByAccountNumber(oldAccountNum)))
                    {
                        taxReconciliationReportTmp.Name = MainAccount::getLocalizedNameByMainAccountId(taxReconciliationReportTmp.AccountNum);
                        taxReconciliationReportTmp.Design = design;
                        taxReconciliationReportTmp.insert();
                    }

                    taxReconciliationReportTmp.clear();
                    inserted = true;
                }

                this.calcTax(mainAccount, subledgerVoucherLink.Voucher, generalJournalAccountEntry, subledgerVoucherLink.AccountingDate);
                if (mainAccount.MainAccountId != oldAccountNum)
                {
                    oldAccountNum                         = mainAccount.MainAccountId;
                    taxReconciliationReportTmp.AccountNum = oldAccountNum;
                }
            }

            counterLedger = this.calcCntLedgerTrans(subledgerVoucherLink,taxTransGeneralJournalAccountEntry,mainAccount);
            counterTax    = this.calcCntTaxTrans(subledgerVoucherLink, generalJournalEntry,mainAccount);
        }

        taxReconciliationReportTmp.clear();
        if (this.useNewCalculationMethod)
        {
            this.calcTax_v2();
        }
        else
        {
            while select TransactionCurrencyAmount,TransactionCurrencyCode, AccountingCurrencyAmount,PostingType, GeneralJournalEntry, LedgerDimension
                    from generalJournalAccountEntry
                join AccountingDate, RecId from generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                        && generalJournalEntry.Ledger == Ledger::current()
                        && generalJournalEntry.AccountingDate >= fromDate
                        && generalJournalEntry.AccountingDate <= toDate
                join Voucher, VoucherDataAreaId, GeneralJournalEntry,AccountingDate from subledgerVoucherLink
                    where subledgerVoucherLink.GeneralJournalEntry == generalJournalEntry.RecId
                join MainAccount,RecId from dimensionAttributeValueCombination
                    where generalJournalAccountEntry.LedgerDimension == dimensionAttributeValueCombination.RecId
                join MainAccountId, RecId from mainAccount
                    order by mainAccount.MainAccountId, subledgerVoucherLink.Voucher
                    where dimensionAttributeValueCombination.MainAccount == mainAccount.RecId
                        && (!fromAccount || mainAccount.MainAccountId  >= fromAccount)
                        && (!toAccount || mainAccount.MainAccountId  <= toAccount)
            {
                calcNoDetailsInfo();
            }
        }

        if (! inserted && taxReconciliationReportTmp.AccountNum)
        {
            taxReconciliationReportTmp.Name   = MainAccount::getLocalizedNameByMainAccountId(taxReconciliationReportTmp.AccountNum);
            taxReconciliationReportTmp.Design = design;
            taxReconciliationReportTmp.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcNoVat</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Populates the <c>tmpTaxReconciliationNoVat</c> table with transactions from the <c>TaxTrans</c>
    ///    table.
    /// </summary>
    /// <param name="_subledgerVoucherLink">
    ///    The <c>SubledgerVoucherGeneralJournalEntry</c> table buffer that will be used to determine the set
    ///    of records for the temporary table.
    /// </param>
    /// <param name="_mainAccount">
    ///    The <c>MainAccount</c> table buffer that will be used to determine the set of records for the
    ///    temporary table.
    /// </param>
    /// <param name="_generalJournalAccountEntry">
    ///    The <c>GeneralJournalAccountEntry</c> table buffer that will be used to determine the set of
    ///    records for the temporary table.
    /// </param>
    private void calcNoVat(SubledgerVoucherGeneralJournalEntry _subledgerVoucherLink,
                           MainAccount _mainAccount,
                           GeneralJournalAccountEntry  _generalJournalAccountEntry
                           )
    {
        TaxTrans                           taxTrans;
        TaxTransGeneralJournalAccountEntry taxTransGeneralJournalAccountEntry;
        boolean                            editable = false;

        if (VendParameters::find().UseDocumentDate == NoYes::Yes)
        {
            select count(RecId) from taxTrans
                index hint VoucherDateIdx
                where taxTrans.Voucher             == _subledgerVoucherLink.Voucher
                   && taxTrans.SourceBaseAmountCur == abs(_generalJournalAccountEntry.TransactionCurrencyAmount)
             exists join taxTransGeneralJournalAccountEntry
                where taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry == _generalJournalAccountEntry.RecId
                    && taxTrans.RecId == taxTransGeneralJournalAccountEntry.TaxTrans;
        }
        else
        {
            select count(RecId) from taxTrans
                index hint VoucherDateIdx
                where taxTrans.Voucher              == _subledgerVoucherLink.Voucher
                    && taxTrans.TransDate           == _subledgerVoucherLink.AccountingDate
                    && taxTrans.SourceBaseAmountCur == abs(_generalJournalAccountEntry.TransactionCurrencyAmount)
             exists join taxTransGeneralJournalAccountEntry
                where taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry == _generalJournalAccountEntry.RecId
                    && taxTrans.RecId == taxTransGeneralJournalAccountEntry.TaxTrans;
        }

        if (_generalJournalAccountEntry.PostingType != LedgerPostingType::Tax && taxTrans.RecId == 0)
        {
            // If Print Totals per Tax Code option is selected, only total per ledger is required.
            if (printWithoutTax)
            {
                select forupdate tmpTaxReconciliationNoVat
                    where tmpTaxReconciliationNoVat.AccountNum == _mainAccount.MainAccountId;
                editable = tmpTaxReconciliationNoVat ? true:false;

                if (! editable)
                {
                    tmpTaxReconciliationNoVat.AccountNum = _mainAccount.MainAccountId;
                    tmpTaxReconciliationNoVat.AmountMST  = _generalJournalAccountEntry.AccountingCurrencyAmount;
                    tmpTaxReconciliationNoVat.insert();
                }
                else
                {
                    tmpTaxReconciliationNoVat.AmountMST += _generalJournalAccountEntry.AccountingCurrencyAmount;
                    tmpTaxReconciliationNoVat.update();
                }
            }
            else
            {
                tmpTaxReconciliationNoVat.AccountNum   =  _mainAccount.MainAccountId;
                tmpTaxReconciliationNoVat.AmountCur    = _generalJournalAccountEntry.TransactionCurrencyAmount;
                tmpTaxReconciliationNoVat.AmountMST    = _generalJournalAccountEntry.AccountingCurrencyAmount;
                tmpTaxReconciliationNoVat.Txt          = _generalJournalAccountEntry.Text;
                tmpTaxReconciliationNoVat.CurrencyCode = _generalJournalAccountEntry.TransactionCurrencyCode;
                tmpTaxReconciliationNoVat.TransDate    = _subledgerVoucherLink.AccountingDate;
                tmpTaxReconciliationNoVat.Voucher      = _subledgerVoucherLink.Voucher;
                tmpTaxReconciliationNoVat.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method will populate tmpTaxReconciliation table based on transactions stored in taxTrans table.
    /// </summary>
    /// <param name="_mainAccount">
    /// A table buffer of <c>MainAccount</c> for which the search for tax transactions (taxTrans) will be done.
    /// </param>
    /// <param name="_voucher">
    /// Voucher number for which the search for tax transactions (taxTrans) will be done.
    /// </param>
    /// <param name="_generalJournalAccountEntry">
    /// GeneralJournalAccountEntry record for which the search for tax transactions (taxTrans) will be done.
    /// </param>
    /// <param name="_accountingDate">
    /// Accounting date for which the search for tax transactions (taxTrans) will be done.
    /// </param>
    private void calcTax(MainAccount _mainAccount,
                         Voucher     _voucher,
                         GeneralJournalAccountEntry _generalJournalAccountEntry,
                         TransDate   _accountingDate)
    {
        AmountMST taxAmount;
        AmountMST taxInCostPriceMST;
        TaxTrans taxTrans;
        TaxTransGeneralJournalAccountEntry taxTransGeneralJournalAccountEntry;
        AccountingDistribution acctDistributionPrimary;
        AccountingDistribution acctDistTaxVariance;
        AccountingDistribution accDistPriceVariance;
        
        MainAccountLedgerDimensionView mainAccountTable;
        boolean  editable = false;

        TaxBase  taxBaseAmount;
        AccountingDistribution                   accDistParent;
        AccountingDistribution                   accDistDiscount;
        SubledgerJournalAccountEntry             subledgerJournalAccountEntry;
        SubledgerJournalAccountEntryDistribution subledgerJournalAccEntryDistParent;
        TaxReconciliationReportTmp               taxReconciliationReportTmpLocal;
        AccountName                              accountNameLocal = MainAccount::findByMainAccountId(_mainAccount.MainAccountId).Name;
        TaxCode                                  currentTaxCode;
        boolean                                  nonDetail = false; // flag indicating if a record in the temporary table can be editable (non-detail report);
                                                                    // in this case a record is updated only if the current tax code was fully processed


        void processCalculation()
        {
            inserted = false;

            if (splitTaxCode || printWithoutTax)
            {
                if (!details || printWithoutTax)
                {
                    nonDetail = true;

                    if (currentTaxCode != taxTrans.TaxCode || !taxReconciliationReportTmp.TaxCode)
                    {
                        if (taxReconciliationReportTmp.TaxCode)
                        {
                            taxReconciliationReportTmp.write(); // tax code changed, so we have to save a record
                        }

                        select forupdate taxReconciliationReportTmp
                        where taxReconciliationReportTmp.TaxCode    == taxTrans.TaxCode
                            && taxReconciliationReportTmp.AccountNum == _mainAccount.MainAccountId;
                        editable = taxReconciliationReportTmp ? true:false;
                    }
                }

                // For detail report create a record for each tax transaction.
                if (! editable)
                {
                    taxReconciliationReportTmp.TaxCode    = taxTrans.TaxCode;
                    taxReconciliationReportTmp.AccountNum = _mainAccount.MainAccountId;
                    taxReconciliationReportTmp.Name         = accountNameLocal;
                    taxReconciliationReportTmp.Design       = design;
                    if (!printWithoutTax)
                    {
                        taxReconciliationReportTmp.Voucher   = _voucher;
                        taxReconciliationReportTmp.TransDate = taxTrans.TransDate;
                    }
                }
            }

            switch (taxTrans.TaxDirection)
            {
                case TaxDirection::OutgoingTax:
                    taxReconciliationReportTmp.TaxAmountSales           += taxAmount;
                    taxReconciliationReportTmp.BaseAmountSales          += taxBaseAmount;
                    break;
                case TaxDirection::TaxExemptSales:
                    taxReconciliationReportTmp.BaseAmountSales          += taxBaseAmount;
                    break;
                case TaxDirection::IncomingTax:
                    taxReconciliationReportTmp.BaseAmountPurchase       += taxBaseAmount;
                    taxReconciliationReportTmp.TaxAmountPurchase        += taxAmount - taxInCostPriceMST;
                    break;
                case TaxDirection::TaxExemptPurchase:
                    taxReconciliationReportTmp.BaseAmountPurchase       += taxBaseAmount;
                    break;
                case TaxDirection::UseTax:
                    taxReconciliationReportTmp.TaxAmountReverseCharges  += taxAmount;
                    taxReconciliationReportTmp.BaseAmountReverseCharges += taxBaseAmount;
                    taxReconciliationReportTmp.TaxDeductible            += taxAmount - taxInCostPriceMST;
                    break;
                case TaxDirection::TaxTransaction:
                    if (taxAmount < 0)
                    {
                        taxReconciliationReportTmp.TaxAmountPurchase    += taxAmount;
                        taxReconciliationReportTmp.BaseAmountPurchase   += taxBaseAmount;
                    }
                    else
                    {
                        taxReconciliationReportTmp.TaxAmountSales       += taxAmount;
                        taxReconciliationReportTmp.BaseAmountSales      += taxBaseAmount;
                    }
                    break;

                case TaxDirection::OutgoingTax_W:
                    if (isTaxSpecificExchangeRateEnabled)
                    {
                        taxReconciliationReportTmp.TaxAmountSales += taxAmount;
                        taxReconciliationReportTmp.BaseAmountSales += taxBaseAmount;
                    }
                    break;

                case TaxDirection::IncomingTax_W:
                    if (isTaxSpecificExchangeRateEnabled)
                    {
                        taxReconciliationReportTmp.BaseAmountPurchase += taxBaseAmount;
                        taxReconciliationReportTmp.TaxAmountPurchase += taxAmount - taxInCostPriceMST;
                    }
                    break;

                default:
                    break;
            }

            // Create a new record and set editable variable:
            //  - for the detail report create a record for each tax transaction.
            //  - for the non-detail report create a record for each new tax code.
            if (splitTaxCode || printWithoutTax)
            {
                if (!editable)
                {
                    taxReconciliationReportTmp.insert();
                    if (nonDetail)
                    {
                        editable = true;    // for the non-detail report mark a record as editable right after the insertion
                    }
                }
                if (!nonDetail)     // don't clear a record for the non-detail report (data is being accumulated)
                {
                    taxReconciliationReportTmp.clear();
                }
                inserted = true;
            }

            currentTaxCode = taxTrans.TaxCode;
        }

        select firstOnly SourceDocumentLine from taxTrans
            where taxTrans.Voucher == _voucher  &&
                  taxTrans.TransDate == _accountingDate &&
                  taxTrans.TaxPeriod == taxPeriod
            exists join taxTransGeneralJournalAccountEntry
                where taxTrans.RecId == taxTransGeneralJournalAccountEntry.TaxTrans
                    && taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry == _generalJournalAccountEntry.RecId
                    && (taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::TransactionLineAccount
                        || taxTrans.TaxOrigin == TaxOrigin::Transfer)
                    && taxTrans.TaxOrigin != TaxOrigin::TaxReversed;

        if (taxTrans.SourceDocumentLine)
        {
            while select TaxCode, TaxBaseAmount, TaxDirection, Voucher, TransDate, TaxAmount, TaxInCostPriceMST, SourceDocumentLine from taxTrans
                order by TaxCode
                where taxTrans.Voucher == _voucher  &&
                      taxTrans.TransDate == _accountingDate &&
                      taxTrans.TaxPeriod == taxPeriod
                exists join taxTransGeneralJournalAccountEntry
                where taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry == _generalJournalAccountEntry.RecId &&
                        taxTransGeneralJournalAccountEntry.TaxTrans                 == taxTrans.RecId
                exists join mainAccountTable
                where  mainAccountTable.LedgerDimensionId == _generalJournalAccountEntry.LedgerDimension &&
                        mainAccountTable.MainAccount      == _mainAccount.MainAccountId
            {
                if (taxTrans.TaxBaseAmount != 0)
                {
                    select RecId, SourceDocumentLine,TransactionCurrencyAmount from acctDistributionPrimary
                        where acctDistributionPrimary.SourceDocumentLine == taxTrans.SourceDocumentLine
                            && acctDistributionPrimary.AmountSource == DistributionAmountSource::PrimaryAmount;

                    if (acctDistributionPrimary)
                    {
                        RefRecId acctDistributionPrimaryCurrentRecId, accDistParentCurrentRecId;

                        while select SourceDocumentLine,LedgerDimension,TransactionCurrencyAmount, ParentDistribution from acctDistributionPrimary
                            where acctDistributionPrimary.SourceDocumentLine == taxTrans.SourceDocumentLine
                               && acctDistributionPrimary.AmountSource == DistributionAmountSource::PrimaryAmount
                            join SourceDocumentLine, TransactionCurrencyAmount from accDistParent
                                where accDistParent.RecId == acctDistributionPrimary.ParentDistribution
                            join subledgerJournalAccEntryDistParent
                                where (subledgerJournalAccEntryDistParent.AccountingDistribution == acctDistributionPrimary.ParentDistribution
                                    || subledgerJournalAccEntryDistParent.ParentDistribution == accDistParent.RecId)
                            join subledgerJournalAccountEntry
                                where subledgerJournalAccountEntry.RecId == subledgerJournalAccEntryDistParent.SubledgerJournalAccountEntry
                                   && subledgerJournalAccountEntry.GeneralJournalAccountEntry == _generalJournalAccountEntry.RecId
                        {
                            if (   acctDistributionPrimary.RecId == acctDistributionPrimaryCurrentRecId
                                && accDistParent.RecId == accDistParentCurrentRecId)
                            {
                                continue;
                            }

                            acctDistributionPrimaryCurrentRecId = acctDistributionPrimary.RecId;
                            accDistParentCurrentRecId = accDistParent.RecId;

                            select sum(TransactionCurrencyAmount) from acctDistTaxVariance
                                where acctDistTaxVariance.ParentDistribution == acctDistributionPrimary.RecId                 &&
                                      acctDistTaxVariance.SourceDocumentLine == acctDistributionPrimary.SourceDocumentLine    &&
                                      acctDistTaxVariance.MonetaryAmount == MonetaryAmount::TaxVariance;

                            taxAmount = CurrencyExchange::calculateAmount((acctDistributionPrimary.TransactionCurrencyAmount + acctDistTaxVariance.TransactionCurrencyAmount),subledgerJournalAccountEntry.ExchangeRate1);

                            taxBaseAmount = CurrencyExchange::calculateAmount(accDistParent.TransactionCurrencyAmount, subledgerJournalAccountEntry.ExchangeRate1);
                            taxBaseAmount = taxAmount > 0 ? abs(taxBaseAmount) : -abs(taxBaseAmount);

                            TaxInCostPriceMST = 0;

                            if (!setSourceDocLine.in(taxTrans.SourceDocumentLine))
                            {
                                select sum(TransactionCurrencyAmount) from accDistDiscount
                                where (accDistDiscount.ParentDistribution == accDistParent.RecId                    ||
                                       accDistDiscount.ParentDistribution == accDistParent.ReferenceDistribution)   &&
                                      accDistDiscount.SourceDocumentLine == accDistParent.SourceDocumentLine        &&
                                      (accDistDiscount.MonetaryAmount == MonetaryAmount::Discount                   ||
                                      accDistDiscount.MonetaryAmount == MonetaryAmount::PriceAdjustment);

                                select sum(TransactionCurrencyAmount) from accDistPriceVariance
                                    where accDistPriceVariance.ParentDistribution == accDistParent.RecId                 &&
                                        accDistPriceVariance.SourceDocumentLine == accDistParent.SourceDocumentLine    &&
                                        accDistPriceVariance.MonetaryAmount == MonetaryAmount::PriceVariance;

                                AccountingDistribution accDistQuantityVariance;

                                select sum(TransactionCurrencyAmount) from accDistQuantityVariance
                                    where accDistQuantityVariance.ParentDistribution == accDistParent.RecId               &&
                                        accDistQuantityVariance.SourceDocumentLine == accDistParent.SourceDocumentLine    &&
                                        accDistQuantityVariance.MonetaryAmount == MonetaryAmount::QuantityVariance;

                                taxBaseAmount = CurrencyExchange::calculateAmount((accDistParent.TransactionCurrencyAmount + accDistDiscount.TransactionCurrencyAmount + accDistPriceVariance.TransactionCurrencyAmount + accDistQuantityVariance.TransactionCurrencyAmount),subledgerJournalAccountEntry.ExchangeRate1);
                                taxBaseAmount = taxAmount > 0 ? abs(taxBaseAmount) : -abs(taxBaseAmount);

                                taxInCostPriceMST = taxTrans.TaxInCostPriceMST;
                            }
                            setSourceDocLine.add(taxTrans.SourceDocumentLine);
                            processCalculation();
                        }
                    }
                    else
                    {
                        select RecId, TaxCode, Voucher, TransDate from taxReconciliationReportTmpLocal
                            where taxReconciliationReportTmpLocal.TaxCode == taxTrans.TaxCode &&
                                taxReconciliationReportTmpLocal.Voucher == _voucher &&
                                taxReconciliationReportTmpLocal.TransDate == taxTrans.TransDate;

                        select firstonly AccountingCurrencyAmount from  taxTransGeneralJournalAccountEntry
                            where taxTrans.RecId == taxTransGeneralJournalAccountEntry.TaxTrans
                                && taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry == _generalJournalAccountEntry.RecId;

                        if (taxTrans.TaxAmount
                            || !taxReconciliationReportTmpLocal.RecId
                            || !setSourceDocLine.in(taxTrans.SourceDocumentLine))
                        {
                            taxAmount = taxTrans.TaxAmount;
                            taxBaseAmount = taxTransGeneralJournalAccountEntry.AccountingCurrencyAmount;

                            taxInCostPriceMST = taxTrans.TaxInCostPriceMST;

                            setSourceDocLine.add(taxTrans.SourceDocumentLine);
                            processCalculation();
                        }
                        else
                        {
                            taxReconciliationReportTmp.clear();
                        }
                    }
                }
            }
        }
        else
        {
            while select TaxCode, TaxBaseAmount, TaxDirection, Voucher, TransDate, TaxAmount, TaxInCostPriceMST, SourceDocumentLine from taxTrans
                order by TaxCode
                where taxTrans.Voucher   == _voucher    &&
                      taxTrans.TransDate == _accountingDate &&
                      taxTrans.TaxPeriod == taxPeriod
                exists join taxTransGeneralJournalAccountEntry
                    where taxTrans.RecId == taxTransGeneralJournalAccountEntry.TaxTrans
                        && taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry == _generalJournalAccountEntry.RecId
                        && (taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::TransactionLineAccount
                            || taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::CashDiscount
                            || taxTrans.TaxOrigin == TaxOrigin::Transfer)
            {
                taxAmount = taxTrans.TaxAmount;
                taxBaseAmount = taxTrans.TaxBaseAmount;
                TaxInCostPriceMST = taxTrans.TaxInCostPriceMST;

                processCalculation();
            }
        }

        if (nonDetail && taxReconciliationReportTmp.TaxCode)
        {
            taxReconciliationReportTmp.write(); // save the last record in which we accumulate the data
            taxReconciliationReportTmp.clear();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTax_v2</Name>
				<Source><![CDATA[
    private void calcTax_v2()
    {
        TaxTrans taxTrans;
        TaxTransGeneralJournalAccountEntry taxTransGeneralJournalAccountEntry;
        MainAccountLedgerDimensionView mainAccountTable;
        AccountingDistribution acctDistributionPrimary;
        AccountingDistribution accDistParent;
        SubledgerJournalAccountEntryDistribution subledgerJournalAccEntryDistParent;
        SubledgerJournalAccountEntry subledgerJournalAccountEntry;
        AccountingDistribution acctDistTaxVariance;
        AccountingDistribution acctDist;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        MainAccount mainAccount;
        MainAccountTranslation mainAccountTranslation;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;

        TmpTaxReconciliationIntermediate tmpTaxReconciliationIntermediate;
        TaxReconciliationReportDP::setSkippingProperties(tmpTaxReconciliationIntermediate);

        if (TaxReportTmpTableDisposeFlight::instance().isEnabled())
        {
            tmpTaxReconciliationIntermediate.setConnection(this.parmUserConnection());
        } 
        else if (this.parmTakeOwnershipOfTempTables())
        {
            this.takeOwnershipOfTempTable(tmpTaxReconciliationIntermediate);
        }

        // Initial insert from TaxTrans table
        insert_recordset tmpTaxReconciliationIntermediate
        (
            SourceDocumentLine,
            TaxDirection,
            TaxCode,
            EntryAccountingDate,
            Voucher,
            Design,
            TaxInCostPriceMST,
            NeedToAlignAmounts,
            AccountingDate,
            MainAccountNum
        )
        select
            SourceDocumentLine,
            TaxDirection,
            TaxCode,
            TransDate,
            Voucher,
            design,
            TaxInCostPriceMST,
            DoNeedToAlignAmountsFlag
        from
            taxTrans
        group by
            taxTrans.SourceDocumentLine,
            taxTrans.TaxDirection,
            taxTrans.TaxCode,
            taxTrans.TransDate,
            taxTrans.Voucher,
            taxTrans.TaxInCostPriceMST,
            generalJournalEntry.AccountingDate,
            mainAccount.MainAccountId
        where taxTrans.TaxPeriod == taxPeriod
            && taxTrans.SourceDocumentLine != 0
            && taxTrans.TaxBaseAmount != 0
            && taxTrans.TaxOrigin != TaxOrigin::TaxReversed
        join taxTransGeneralJournalAccountEntry
            where taxTransGeneralJournalAccountEntry.TaxTrans == taxTrans.RecId
                && (taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::TransactionLineAccount
                    || taxTrans.TaxOrigin == TaxOrigin::Transfer)
        join generalJournalAccountEntry
            where generalJournalAccountEntry.RecId == taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry
        join AccountingDate from generalJournalEntry
            where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                && generalJournalEntry.Ledger == Ledger::current()
                && generalJournalEntry.AccountingDate >= fromDate
                && generalJournalEntry.AccountingDate <= toDate
        join subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && subledgerVoucherGeneralJournalEntry.Voucher == taxTrans.Voucher
        join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == generalJournalAccountEntry.LedgerDimension
        join MainAccountId from mainAccount
            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                && (!fromAccount || mainAccount.MainAccountId  >= fromAccount)
                && (!toAccount || mainAccount.MainAccountId  <= toAccount)
        exists join acctDistributionPrimary
            where acctDistributionPrimary.SourceDocumentLine == taxTrans.SourceDocumentLine
                && acctDistributionPrimary.AmountSource == DistributionAmountSource::PrimaryAmount;

        // Updating intermediate table with tax amount calculations
        container monetaryAmountsList_Primary = [
            MonetaryAmount::ExtendedPrice,
            MonetaryAmount::Charge
        ];

        update_recordset tmpTaxReconciliationIntermediate setting
            TaxAmount_Primary = acctDistributionPrimary.TransactionCurrencyAmount,
            TaxBaseAmount_Primary = accDistParent.TransactionCurrencyAmount,
            ExchangeRate1 = subledgerJournalAccountEntry.ExchangeRate1
        join TransactionCurrencyAmount from acctDistributionPrimary
            where acctDistributionPrimary.SourceDocumentLine == tmpTaxReconciliationIntermediate.SourceDocumentLine
                && acctDistributionPrimary.AmountSource == DistributionAmountSource::PrimaryAmount
        join TransactionCurrencyAmount from accDistParent
            where accDistParent.RecId == acctDistributionPrimary.ParentDistribution
                && accDistParent.MonetaryAmount in monetaryAmountsList_Primary
        join subledgerJournalAccEntryDistParent
            where subledgerJournalAccEntryDistParent.AccountingDistribution == acctDistributionPrimary.ParentDistribution
        join ExchangeRate1 from subledgerJournalAccountEntry
            where subledgerJournalAccountEntry.RecId == subledgerJournalAccEntryDistParent.SubledgerJournalAccountEntry;

        update_recordset tmpTaxReconciliationIntermediate setting
            TaxAmount_Primary = acctDistributionPrimary.TransactionCurrencyAmount,
            TaxBaseAmount_Primary = accDistParent.TransactionCurrencyAmount,
            ExchangeRate1 = subledgerJournalAccountEntry.ExchangeRate1
        join TransactionCurrencyAmount from acctDistributionPrimary
            where acctDistributionPrimary.SourceDocumentLine == tmpTaxReconciliationIntermediate.SourceDocumentLine
                && acctDistributionPrimary.AmountSource == DistributionAmountSource::PrimaryAmount
        join TransactionCurrencyAmount from accDistParent
            where accDistParent.RecId == acctDistributionPrimary.ParentDistribution
                && accDistParent.MonetaryAmount in monetaryAmountsList_Primary
        join subledgerJournalAccEntryDistParent
            where subledgerJournalAccEntryDistParent.ParentDistribution == accDistParent.RecId
        join ExchangeRate1 from subledgerJournalAccountEntry
            where subledgerJournalAccountEntry.RecId == subledgerJournalAccEntryDistParent.SubledgerJournalAccountEntry;

        // New table is necessary, as groupings in scope of set-based operations cannot be performed on updates
        TmpTaxReconciliationIntermediateCalculations tmpTaxReconciliationIntermediateCalculations;
        TaxReconciliationReportDP::setSkippingProperties(tmpTaxReconciliationIntermediateCalculations);

        if (TaxReportTmpTableDisposeFlight::instance().isEnabled())
        {
            tmpTaxReconciliationIntermediateCalculations.setConnection(this.parmUserConnection());
        }
        else if (this.parmTakeOwnershipOfTempTables())
        {
            this.takeOwnershipOfTempTable(tmpTaxReconciliationIntermediateCalculations);
        }

        // Calculating adjustments to tax amount
        insert_recordset tmpTaxReconciliationIntermediateCalculations
        (
            SourceDocumentLine,
            TaxAmount
        )
        select
            SourceDocumentLine
        from
            tmpTaxReconciliationIntermediate
        group by
            tmpTaxReconciliationIntermediate.SourceDocumentLine
        join acctDistributionPrimary
            where acctDistributionPrimary.SourceDocumentLine == tmpTaxReconciliationIntermediate.SourceDocumentLine
                && acctDistributionPrimary.AmountSource == DistributionAmountSource::PrimaryAmount
        join sum(TransactionCurrencyAmount) from acctDistTaxVariance
            where acctDistTaxVariance.ParentDistribution == acctDistributionPrimary.RecId
                && acctDistTaxVariance.SourceDocumentLine == acctDistributionPrimary.SourceDocumentLine
                && acctDistTaxVariance.MonetaryAmount == MonetaryAmount::TaxVariance;

        update_recordset tmpTaxReconciliationIntermediate setting
            TaxAmount_Distributions = tmpTaxReconciliationIntermediateCalculations.TaxAmount
        join TaxAmount from tmpTaxReconciliationIntermediateCalculations
            where tmpTaxReconciliationIntermediate.SourceDocumentLine == tmpTaxReconciliationIntermediateCalculations.SourceDocumentLine;

        delete_from tmpTaxReconciliationIntermediateCalculations;

        // Calculating adjustments to tax base amount
        container monetaryAmountsList_BaseAmountAdjustments = [
            MonetaryAmount::QuantityVariance,
            MonetaryAmount::PriceVariance,
            MonetaryAmount::Discount,
            MonetaryAmount::PriceAdjustment,
            MonetaryAmount::DiscountVariance
        ];

        insert_recordset tmpTaxReconciliationIntermediateCalculations
        (
            SourceDocumentLine,
            TaxBaseAmount
        )
        select
            SourceDocumentLine
        from
            tmpTaxReconciliationIntermediate
        group by
            tmpTaxReconciliationIntermediate.SourceDocumentLine
        join acctDistributionPrimary
            where acctDistributionPrimary.SourceDocumentLine == tmpTaxReconciliationIntermediate.SourceDocumentLine
                && acctDistributionPrimary.AmountSource == DistributionAmountSource::PrimaryAmount
        join accDistParent
            where accDistParent.RecId == acctDistributionPrimary.ParentDistribution
        join sum(TransactionCurrencyAmount) from acctDist
            where acctDist.SourceDocumentLine == accDistParent.SourceDocumentLine
                && acctDist.MonetaryAmount in monetaryAmountsList_BaseAmountAdjustments;

        update_recordset tmpTaxReconciliationIntermediate setting
            TaxBaseAmount_Distributions = tmpTaxReconciliationIntermediateCalculations.TaxBaseAmount
        join TaxBaseAmount from tmpTaxReconciliationIntermediateCalculations
            where tmpTaxReconciliationIntermediate.SourceDocumentLine == tmpTaxReconciliationIntermediateCalculations.SourceDocumentLine;

        delete_from tmpTaxReconciliationIntermediateCalculations;

        // SourceDocumentLine is not set in TaxTrans
        if (TaxReconciliationNoSDLFixFlight::instance().isEnabled())
        {
            insert_recordset tmpTaxReconciliationIntermediate
            (
                SourceDocumentLine,
                TaxDirection,
                TaxCode,
                EntryAccountingDate,
                Voucher,
                Design,
                TaxAmount_Primary,
                TaxBaseAmount_Primary,
                TaxInCostPriceMST,
                ExchangeRate1,
                NeedToAlignAmounts,
                AccountingDate,
                MainAccountNum
            )
            select
                SourceDocumentLine,
                TaxDirection,
                TaxCode,
                TransDate,
                Voucher,
                design,
                sum(TaxAmount),
                sum(TaxBaseAmount),
                sum(TaxInCostPriceMST),
                ExchangeRateMultiplier,
                DoNotNeedToAlignAmountsFlag
            from
                taxTrans
            group by
                taxTrans.SourceDocumentLine,
                taxTrans.TaxDirection,
                taxTrans.TaxCode,
                taxTrans.TransDate,
                taxTrans.Voucher,
                taxTrans.SourceRecId,
                generalJournalEntry.AccountingDate,
                mainAccount.MainAccountId
            where taxTrans.TaxPeriod == taxPeriod
                && taxTrans.SourceDocumentLine == 0
            join taxTransGeneralJournalAccountEntry
                where taxTrans.RecId == taxTransGeneralJournalAccountEntry.TaxTrans
                    && (taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::TransactionLineAccount
                        || taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::CashDiscount
                        || taxTrans.TaxOrigin == TaxOrigin::Transfer)
            join generalJournalAccountEntry
                where generalJournalAccountEntry.RecId == taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry
            join AccountingDate from generalJournalEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                    && generalJournalEntry.Ledger == Ledger::current()
                    && generalJournalEntry.AccountingDate >= fromDate
                    && generalJournalEntry.AccountingDate <= toDate
            join dimensionAttributeValueCombination
                where dimensionAttributeValueCombination.RecId == generalJournalAccountEntry.LedgerDimension
            join MainAccountId from mainAccount
                where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                    && (!fromAccount || mainAccount.MainAccountId  >= fromAccount)
                    && (!toAccount || mainAccount.MainAccountId  <= toAccount);
        }
        else
        {
            insert_recordset tmpTaxReconciliationIntermediate
            (
                SourceDocumentLine,
                TaxDirection,
                TaxCode,
                EntryAccountingDate,
                Voucher,
                Design,
                TaxAmount_Primary,
                TaxBaseAmount_Primary,
                TaxInCostPriceMST,
                ExchangeRate1,
                NeedToAlignAmounts,
                AccountingDate,
                MainAccountNum
            )
            select
                SourceDocumentLine,
                TaxDirection,
                TaxCode,
                TransDate,
                Voucher,
                design,
                TaxAmount,
                TaxBaseAmount,
                TaxInCostPriceMST,
                ExchangeRateMultiplier,
                DoNotNeedToAlignAmountsFlag
            from
                taxTrans
            group by
                taxTrans.SourceDocumentLine,
                taxTrans.TaxDirection,
                taxTrans.TaxCode,
                taxTrans.TransDate,
                taxTrans.Voucher,
                taxTrans.TaxAmount,
                taxTrans.TaxBaseAmount,
                taxTrans.TaxInCostPriceMST,
                generalJournalEntry.AccountingDate,
                mainAccount.MainAccountId
            where taxTrans.TaxPeriod == taxPeriod
                && taxTrans.SourceDocumentLine == 0
            join taxTransGeneralJournalAccountEntry
                where taxTrans.RecId == taxTransGeneralJournalAccountEntry.TaxTrans
                    && (taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::TransactionLineAccount
                        || taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::CashDiscount
                        || taxTrans.TaxOrigin == TaxOrigin::Transfer)
            join generalJournalAccountEntry
                where generalJournalAccountEntry.RecId == taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry
            join AccountingDate from generalJournalEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                    && generalJournalEntry.Ledger == Ledger::current()
                    && generalJournalEntry.AccountingDate >= fromDate
                    && generalJournalEntry.AccountingDate <= toDate
            join dimensionAttributeValueCombination
                where dimensionAttributeValueCombination.RecId == generalJournalAccountEntry.LedgerDimension
            join MainAccountId from mainAccount
                where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                    && (!fromAccount || mainAccount.MainAccountId  >= fromAccount)
                    && (!toAccount || mainAccount.MainAccountId  <= toAccount);
        }

        // No primary account distributions are associated with TaxTrans instance (Exempt Tax)
        insert_recordset tmpTaxReconciliationIntermediate
        (
            SourceDocumentLine,
            TaxDirection,
            TaxCode,
            EntryAccountingDate,
            Voucher,
            Design,
            TaxAmount_Primary,
            TaxInCostPriceMST,
            ExchangeRate1,
            NeedToAlignAmounts,
            TaxBaseAmount_Primary,
            AccountingDate,
            MainAccountNum
        )
        select
            SourceDocumentLine,
            TaxDirection,
            TaxCode,
            TransDate,
            Voucher,
            design,
            TaxAmount,
            TaxInCostPriceMST,
            ExchangeRateMultiplier,
            DoNotNeedToAlignAmountsFlag
        from
            taxTrans
        group by
            taxTrans.SourceDocumentLine,
            taxTrans.TaxDirection,
            taxTrans.TaxCode,
            taxTrans.TransDate,
            taxTrans.Voucher,
            taxTrans.TaxAmount,
            taxTrans.TaxInCostPriceMST,
            taxTransGeneralJournalAccountEntry.RecId,
            taxTransGeneralJournalAccountEntry.AccountingCurrencyAmount,
            generalJournalEntry.AccountingDate,
            mainAccount.MainAccountId
        where taxTrans.TaxPeriod == taxPeriod
            && taxTrans.SourceDocumentLine != 0
            && taxTrans.TaxBaseAmount != 0
            && taxTrans.TaxOrigin != TaxOrigin::TaxReversed
        join AccountingCurrencyAmount from taxTransGeneralJournalAccountEntry
            where taxTrans.RecId == taxTransGeneralJournalAccountEntry.TaxTrans
        join generalJournalAccountEntry
            where generalJournalAccountEntry.RecId == taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry
        join AccountingDate from generalJournalEntry
            where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                && generalJournalEntry.Ledger == Ledger::current()
                && generalJournalEntry.AccountingDate >= fromDate
                && generalJournalEntry.AccountingDate <= toDate
        join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == generalJournalAccountEntry.LedgerDimension
        join MainAccountId from mainAccount
            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                && (!fromAccount || mainAccount.MainAccountId  >= fromAccount)
                && (!toAccount || mainAccount.MainAccountId  <= toAccount)
        notexists join acctDistributionPrimary
            where acctDistributionPrimary.SourceDocumentLine == taxTrans.SourceDocumentLine
                && acctDistributionPrimary.AmountSource == DistributionAmountSource::PrimaryAmount;

        // Global cash discounts
        insert_recordset tmpTaxReconciliationIntermediate
        (
            SourceDocumentLine,
            TaxDirection,
            TaxCode,
            EntryAccountingDate,
            Voucher,
            Design,
            TaxAmount_Primary,
            TaxBaseAmount_Primary,
            TaxInCostPriceMST,
            ExchangeRate1,
            NeedToAlignAmounts,
            AccountingDate,
            MainAccountNum
        )
        select
            SourceDocumentLine,
            TaxDirection,
            TaxCode,
            TransDate,
            Voucher,
            design,
            TaxAmount,
            TaxBaseAmount,
            TaxInCostPriceMST,
            ExchangeRateMultiplier,
            DoNotNeedToAlignAmountsFlag
        from
            taxTrans
        group by
            taxTrans.SourceDocumentLine,
            taxTrans.TaxDirection,
            taxTrans.TaxCode,
            taxTrans.TransDate,
            taxTrans.Voucher,
            taxTrans.TaxAmount,
            taxTrans.TaxBaseAmount,
            taxTrans.TaxInCostPriceMST,
            generalJournalEntry.AccountingDate,
            mainAccount.MainAccountId
        where taxTrans.TaxPeriod == taxPeriod
            && taxTrans.SourceDocumentLine != 0
        join taxTransGeneralJournalAccountEntry
            where taxTrans.RecId == taxTransGeneralJournalAccountEntry.TaxTrans
            && taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::CashDiscount
        join generalJournalAccountEntry
            where generalJournalAccountEntry.RecId == taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry
        join AccountingDate from generalJournalEntry
            where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                && generalJournalEntry.Ledger == Ledger::current()
                && generalJournalEntry.AccountingDate >= fromDate
                && generalJournalEntry.AccountingDate <= toDate
        join subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && subledgerVoucherGeneralJournalEntry.Voucher == taxTrans.Voucher
        join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == generalJournalAccountEntry.LedgerDimension
        join MainAccountId from mainAccount
            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                && (!fromAccount || mainAccount.MainAccountId  >= fromAccount)
                && (!toAccount || mainAccount.MainAccountId  <= toAccount);

        // Assign main account names from main account translations table
        update_recordset tmpTaxReconciliationIntermediate setting
            MainAccountName = mainAccountTranslation.Name
        where
            tmpTaxReconciliationIntermediate.MainAccountName == ""
        join mainAccount
            where mainAccount.MainAccountId == tmpTaxReconciliationIntermediate.MainAccountNum
        join Name from mainAccountTranslation
            where mainAccountTranslation.MainAccount == mainAccount.RecId
                && mainAccountTranslation.LanguageId == DimensionCache::currentDimensionValueLanguageId();

        // Assign remaining main account names from main account table
        update_recordset tmpTaxReconciliationIntermediate setting
            MainAccountName = mainAccount.Name
        where
            tmpTaxReconciliationIntermediate.MainAccountName == ""
        join mainAccount
            where mainAccount.MainAccountId == tmpTaxReconciliationIntermediate.MainAccountNum;

        // Performing final tax and tax base amount calculations for each applicable tax direction
        update_recordset tmpTaxReconciliationIntermediate setting
            TaxAmountSales = (tmpTaxReconciliationIntermediate.TaxAmount_Primary + tmpTaxReconciliationIntermediate.TaxAmount_Distributions) * (tmpTaxReconciliationIntermediate.ExchangeRate1 / ExchangeRateMultiplier),
            BaseAmountSales = (tmpTaxReconciliationIntermediate.TaxBaseAmount_Primary + tmpTaxReconciliationIntermediate.TaxBaseAmount_Distributions) * (tmpTaxReconciliationIntermediate.ExchangeRate1 / ExchangeRateMultiplier)
        where
            tmpTaxReconciliationIntermediate.TaxDirection == TaxDirection::OutgoingTax;

        update_recordset tmpTaxReconciliationIntermediate setting
            BaseAmountSales = (tmpTaxReconciliationIntermediate.TaxBaseAmount_Primary + tmpTaxReconciliationIntermediate.TaxBaseAmount_Distributions)  * (tmpTaxReconciliationIntermediate.ExchangeRate1 / ExchangeRateMultiplier)
        where
            tmpTaxReconciliationIntermediate.TaxDirection == TaxDirection::TaxExemptSales;

        update_recordset tmpTaxReconciliationIntermediate setting
            TaxAmountPurchase = (tmpTaxReconciliationIntermediate.TaxAmount_Primary + tmpTaxReconciliationIntermediate.TaxAmount_Distributions) * (tmpTaxReconciliationIntermediate.ExchangeRate1 / ExchangeRateMultiplier) - tmpTaxReconciliationIntermediate.TaxInCostPriceMST,
            BaseAmountPurchase = (tmpTaxReconciliationIntermediate.TaxBaseAmount_Primary + tmpTaxReconciliationIntermediate.TaxBaseAmount_Distributions) * (tmpTaxReconciliationIntermediate.ExchangeRate1 / ExchangeRateMultiplier)
        where
            tmpTaxReconciliationIntermediate.TaxDirection == TaxDirection::IncomingTax;

        update_recordset tmpTaxReconciliationIntermediate setting
            BaseAmountPurchase = (tmpTaxReconciliationIntermediate.TaxBaseAmount_Primary + tmpTaxReconciliationIntermediate.TaxBaseAmount_Distributions) * (tmpTaxReconciliationIntermediate.ExchangeRate1 / ExchangeRateMultiplier)
        where
            tmpTaxReconciliationIntermediate.TaxDirection == TaxDirection::TaxExemptPurchase;

        update_recordset tmpTaxReconciliationIntermediate setting
            TaxAmountReverseCharges = (tmpTaxReconciliationIntermediate.TaxAmount_Primary + tmpTaxReconciliationIntermediate.TaxAmount_Distributions) * (tmpTaxReconciliationIntermediate.ExchangeRate1 / ExchangeRateMultiplier),
            BaseAmountReverseCharges = (tmpTaxReconciliationIntermediate.TaxBaseAmount_Primary + tmpTaxReconciliationIntermediate.TaxBaseAmount_Distributions) * (tmpTaxReconciliationIntermediate.ExchangeRate1 / ExchangeRateMultiplier),
            TaxDeductible = (tmpTaxReconciliationIntermediate.TaxAmount_Primary + tmpTaxReconciliationIntermediate.TaxAmount_Distributions) * (tmpTaxReconciliationIntermediate.ExchangeRate1 / ExchangeRateMultiplier) - tmpTaxReconciliationIntermediate.TaxInCostPriceMST
        where
            tmpTaxReconciliationIntermediate.TaxDirection == TaxDirection::UseTax;

        update_recordset tmpTaxReconciliationIntermediate setting
            TaxAmountPurchase = (tmpTaxReconciliationIntermediate.TaxAmount_Primary + tmpTaxReconciliationIntermediate.TaxAmount_Distributions) * (tmpTaxReconciliationIntermediate.ExchangeRate1 / ExchangeRateMultiplier),
            BaseAmountPurchase = (tmpTaxReconciliationIntermediate.TaxBaseAmount_Primary + tmpTaxReconciliationIntermediate.TaxBaseAmount_Distributions) * (tmpTaxReconciliationIntermediate.ExchangeRate1 / ExchangeRateMultiplier)
        where
            tmpTaxReconciliationIntermediate.TaxDirection == TaxDirection::TaxTransaction
            && tmpTaxReconciliationIntermediate.TaxAmount_Primary + tmpTaxReconciliationIntermediate.TaxAmount_Distributions < 0;

        update_recordset tmpTaxReconciliationIntermediate setting
            TaxAmountSales = (tmpTaxReconciliationIntermediate.TaxAmount_Primary + tmpTaxReconciliationIntermediate.TaxAmount_Distributions) * (tmpTaxReconciliationIntermediate.ExchangeRate1 / ExchangeRateMultiplier),
            BaseAmountSales = (tmpTaxReconciliationIntermediate.TaxBaseAmount_Primary + tmpTaxReconciliationIntermediate.TaxBaseAmount_Distributions) * (tmpTaxReconciliationIntermediate.ExchangeRate1 / ExchangeRateMultiplier)
        where
            tmpTaxReconciliationIntermediate.TaxDirection == TaxDirection::TaxTransaction
            && tmpTaxReconciliationIntermediate.TaxAmount_Primary + tmpTaxReconciliationIntermediate.TaxAmount_Distributions >= 0;

        if (isTaxSpecificExchangeRateEnabled)
        {
            update_recordset tmpTaxReconciliationIntermediate setting
                TaxAmountSales = (tmpTaxReconciliationIntermediate.TaxAmount_Primary + tmpTaxReconciliationIntermediate.TaxAmount_Distributions) * (tmpTaxReconciliationIntermediate.ExchangeRate1 / ExchangeRateMultiplier),
                BaseAmountSales = (tmpTaxReconciliationIntermediate.TaxBaseAmount_Primary + tmpTaxReconciliationIntermediate.TaxBaseAmount_Distributions) * (tmpTaxReconciliationIntermediate.ExchangeRate1 / ExchangeRateMultiplier)
            where
                tmpTaxReconciliationIntermediate.TaxDirection == TaxDirection::OutgoingTax_W;

            update_recordset tmpTaxReconciliationIntermediate setting
                TaxAmountPurchase = (tmpTaxReconciliationIntermediate.TaxAmount_Primary + tmpTaxReconciliationIntermediate.TaxAmount_Distributions) * (tmpTaxReconciliationIntermediate.ExchangeRate1 / ExchangeRateMultiplier) - tmpTaxReconciliationIntermediate.TaxInCostPriceMST,
                BaseAmountPurchase = (tmpTaxReconciliationIntermediate.TaxBaseAmount_Primary + tmpTaxReconciliationIntermediate.TaxBaseAmount_Distributions) * (tmpTaxReconciliationIntermediate.ExchangeRate1 / ExchangeRateMultiplier)
            where
                tmpTaxReconciliationIntermediate.TaxDirection == TaxDirection::IncomingTax_W;
        }

        // Aligning base amount signs where necessary
        update_recordset tmpTaxReconciliationIntermediate setting
            BaseAmountSales = -tmpTaxReconciliationIntermediate.BaseAmountSales
        where
            tmpTaxReconciliationIntermediate.BaseAmountSales * tmpTaxReconciliationIntermediate.TaxAmountSales < 0
            && tmpTaxReconciliationIntermediate.NeedToAlignAmounts == DoNeedToAlignAmountsFlag;

        update_recordset tmpTaxReconciliationIntermediate setting
            BaseAmountPurchase = -tmpTaxReconciliationIntermediate.BaseAmountPurchase
        where
            tmpTaxReconciliationIntermediate.BaseAmountPurchase * tmpTaxReconciliationIntermediate.TaxAmountPurchase < 0
            && tmpTaxReconciliationIntermediate.NeedToAlignAmounts == DoNeedToAlignAmountsFlag;

        update_recordset tmpTaxReconciliationIntermediate setting
            BaseAmountReverseCharges = -tmpTaxReconciliationIntermediate.BaseAmountReverseCharges
        where
            tmpTaxReconciliationIntermediate.BaseAmountReverseCharges * tmpTaxReconciliationIntermediate.TaxAmountReverseCharges < 0
            && tmpTaxReconciliationIntermediate.NeedToAlignAmounts == DoNeedToAlignAmountsFlag;

        // Assembling query to group and transfer records
        Query insertionQuery = new Query();
        QueryBuildDataSource intermediateTableQBDS = insertionQuery.addDataSource(tableNum(TmpTaxReconciliationIntermediate));

        if (details && splitTaxCode)
        {
            // We are not grouping anything here, so the entire block is done without SelectionField parameter
            intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, MainAccountNum));
            intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, MainAccountName));
            intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, Design));
            intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, TaxAmountPurchase));
            intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, TaxAmountReverseCharges));
            intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, TaxAmountSales));
            intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, BaseAmountPurchase));
            intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, BaseAmountReverseCharges));
            intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, BaseAmountSales));
            intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, TaxDeductible));
        }
        else
        {
            intermediateTableQBDS.addGroupByAndSelectionField(fieldNum(TmpTaxReconciliationIntermediate, MainAccountNum));
            intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, MainAccountName), SelectionField::Min);
            intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, Design), SelectionField::Min);
            intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, TaxAmountPurchase), SelectionField::Sum);
            intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, TaxAmountReverseCharges), SelectionField::Sum);
            intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, TaxAmountSales), SelectionField::Sum);
            intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, BaseAmountPurchase), SelectionField::Sum);
            intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, BaseAmountReverseCharges), SelectionField::Sum);
            intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, BaseAmountSales), SelectionField::Sum);
            intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, TaxDeductible), SelectionField::Sum);
        }

        if (details)
        {
            if (splitTaxCode)
            {
                intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, Voucher));
                intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, AccountingDate));
                intermediateTableQBDS.addSelectionField(fieldNum(TmpTaxReconciliationIntermediate, TaxCode));
            }
            else
            {
                intermediateTableQBDS.addGroupByAndSelectionField(fieldNum(TmpTaxReconciliationIntermediate, Voucher));
                intermediateTableQBDS.addGroupByAndSelectionField(fieldNum(TmpTaxReconciliationIntermediate, AccountingDate));
            }
        }

        if (splitTaxCode && !details)
        {
            intermediateTableQBDS.addGroupByAndSelectionField(fieldNum(TmpTaxReconciliationIntermediate, TaxCode));
        }

        QueryRun queryRun = new QueryRun(insertionQuery);
        queryRun.setRecord(tmpTaxReconciliationIntermediate);

        TaxReconciliationReportDP::setSkippingProperties(taxReconciliationReportTmp);

        RecordInsertList ril = new RecordInsertList(tableNum(TaxReconciliationReportTmp), false, false, false, false, false, taxReconciliationReportTmp);
        while (queryRun.next())
        {
            TmpTaxReconciliationIntermediate tmp = queryRun.get(tableNum(TmpTaxReconciliationIntermediate));

            taxReconciliationReportTmp.TaxAmountPurchase = tmp.TaxAmountPurchase;
            taxReconciliationReportTmp.TaxAmountReverseCharges = tmp.TaxAmountReverseCharges;
            taxReconciliationReportTmp.TaxAmountSales = tmp.TaxAmountSales;
            taxReconciliationReportTmp.BaseAmountPurchase = tmp.BaseAmountPurchase;
            taxReconciliationReportTmp.BaseAmountReverseCharges = tmp.BaseAmountReverseCharges;
            taxReconciliationReportTmp.BaseAmountSales = tmp.BaseAmountSales;
            taxReconciliationReportTmp.TaxDeductible = tmp.TaxDeductible;
            taxReconciliationReportTmp.AccountNum = tmp.MainAccountNum;
            taxReconciliationReportTmp.Name = tmp.MainAccountName;
            taxReconciliationReportTmp.Design = tmp.Design;

            if (details)
            {
                taxReconciliationReportTmp.Voucher = tmp.Voucher;
                taxReconciliationReportTmp.TransDate = tmp.AccountingDate;
            }

            if (splitTaxCode)
            {
                taxReconciliationReportTmp.TaxCode = tmp.TaxCode;
            }

            ril.add(taxReconciliationReportTmp);
        }

        ril.insertDatabase();
        inserted = true;

        // Cleanup
        if (SsrsPreProcessReportSkipDefaultDatabaseTrxScope::instance().isEnabled() || TaxReportTmpTableDisposeFlight::instance().isEnabled())
        {
            tmpTaxReconciliationIntermediate.dispose();
            tmpTaxReconciliationIntermediateCalculations.dispose();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>design</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Assigns which design is to be shown for the report.
    /// </summary>
    /// <remarks>
    ///    The corresponding design is executed depending on the selection of parameters by the user:
    ///    <list type="number">
    ///       <item>
    ///          <description>Design one is executed if the print sales tax code and sort order sales tax code
    ///          parameters are selected.</description>
    ///       </item>
    ///       <item>
    ///          <description>Design two is executed if the print sales tax code, print totals per tax code, and
    ///          show transactions without VAT parameters are not selected.</description>
    ///       </item>
    ///       <item>
    ///          <description>Design three is executed if the print sales tax code is selected and if the print
    ///          totals per tax code and sort order sales tax code parameters are not selected.</description>
    ///       </item>
    ///       <item>
    ///          <description>Design four is executed if print sales tax code and print totals per tax code
    ///          parameters are not selected and show transactions without VAT parameter is selected.</description>
    ///       </item>
    ///       <item>
    ///          <description>Design five is executed if either print sales tax code is selected and if sort order
    ///          sales tax code parameter is not selected, but print totals per tax code is selected or print sales
    ///          tax code is not selected and if print totals per tax code parameter is selected.</description>
    ///       </item>
    ///    </list>
    /// </remarks>
    private void design()
    {
        const int DesignOne   = 1;
        const int DesignTwo   = 2;
        const int DesignThree = 3;
        const int DesignFour  = 4;
        const int DesignFive  = 5;

        if (splitTaxCode)
        {
            if (groupTaxCode)
            {
                design = DesignOne;
            }
            else
            {
                if (printWithoutTax)
                {
                    design = DesignFive;
                }
                else
                {
                    design = DesignThree;
                }
            }
        }
        else
        {
            if (printWithoutTax)
            {
                design = DesignFive;
            }

            else
            {
                if (transVAT)
                {
                    design = DesignFour;
                }
                else
                {
                    design = DesignTwo;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTmpTaxReconNoVatByAccountNumber</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds whether there are corresponding records.
    /// </summary>
    /// <param name="_accountNumber">
    ///    The account number of the record to be checked.
    /// </param>
    /// <returns>
    ///    true if a record is found; otherwise, false.
    /// </returns>
    private boolean  findTmpTaxReconNoVatByAccountNumber(MainAccountNum _accountNumber)
    {
        boolean returnValue = false;

        if (_accountNumber)
        {
            tmpTaxReconciliationNoVat.selectForUpdate(false);

            select firstonly tmpTaxReconciliationNoVat
                where tmpTaxReconciliationNoVat.AccountNum == _accountNumber;

            if (tmpTaxReconciliationNoVat.RecId)
            {
                returnValue = true;
            }
        }
        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxReconciliationReportTmp</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the <c>TaxReconciliationReportTmp</c> table and returns a data table to the calling method.
    /// </summary>
    /// <returns>
    ///    The required report data from the <c>TaxReconciliationReportTmp</c> table.
    /// </returns>
    [
        SRSReportDataSet(tablestr(TaxReconciliationReportTmp))
    , Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public TaxReconciliationReportTmp getTaxReconciliationReportTmp()
    {
        select taxReconciliationReportTmp;
        return taxReconciliationReportTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        isTaxSpecificExchangeRateEnabled = TaxSpecificExchangeRateHelper::isTaxSpecificExchangeRateEnabled();
        setSourceDocLine = new Set(Types::Int64);
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>printNoVATTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Prints transactions without VAT.
    /// </summary>
    private void printNoVATTransaction()
    {
        // Before printing info regarding VAT information for a new ledger, print info for non-VAT trxs.
        if (previousAccountNum != taxReconciliationReportTmp.AccountNum && previousAccountNum !='')
        {
            // Print subtotal for non-VAT trns.
            range.value(previousAccountNum);
            detQueryRun = new QueryRun(detailQuery);
            detQueryRun.setRecord(tmpTaxReconciliationNoVat);
            while (detQueryRun.next())
            {
                tmpTaxReconciliationNoVat               = detQueryRun.get(tablenum(TmpTaxReconciliationNoVat));
                taxReconciliationReportTmp.AccountNum   = tmpTaxReconciliationNoVat.AccountNum;
                taxReconciliationReportTmp.AmountCur    = tmpTaxReconciliationNoVat.AmountCur;
                taxReconciliationReportTmp.AmountMST    = tmpTaxReconciliationNoVat.AmountMST;
                taxReconciliationReportTmp.Txt          = tmpTaxReconciliationNoVat.Txt;
                taxReconciliationReportTmp.CurrencyCode = tmpTaxReconciliationNoVat.CurrencyCode;
                taxReconciliationReportTmp.TransDate    = tmpTaxReconciliationNoVat.TransDate;
                taxReconciliationReportTmp.Voucher      = tmpTaxReconciliationNoVat.Voucher;
                taxReconciliationReportTmp.Name         = MainAccount::getLocalizedNameByMainAccountId(taxReconciliationReportTmp.AccountNum);
                taxReconciliationReportTmp.TransVAT     = NoYes::Yes;
                taxReconciliationReportTmp.Design       = design;
                taxReconciliationReportTmp.BaseAmountPurchase       = 0;
                taxReconciliationReportTmp.BaseAmountReverseCharges = 0;
                taxReconciliationReportTmp.BaseAmountSales          = 0;
                taxReconciliationReportTmp.TaxAmountPurchase        = 0;
                taxReconciliationReportTmp.TaxAmountReverseCharges  = 0;
                taxReconciliationReportTmp.TaxAmountSales           = 0;
                taxReconciliationReportTmp.TaxDeductible            = 0;
                taxReconciliationReportTmp.TaxCode                  = '';
                taxReconciliationReportTmp.insert();
                insert                                  = true;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReport</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Processes the report business logic.
    /// </summary>
    /// <remarks>
    ///    This method is used to process the report business logic, which is used by the
    ///    <c>TaxReconciliationReport</c> report.
    /// </remarks>
    public void processReport()
    {
        const int DesignEmpty = 0;

        AccountNum acctNum;
        TaxCode    taxCode;
        QueryRun   repQueryRun = new QueryRun(this.parmQuery());
        TaxReconciliationReportContract contract = this.parmDataContract() as TaxReconciliationReportContract;

        detQueryRun     = null;
        fromAccount     = contract.parmFromAccount();
        toAccount       = contract.parmToAccount();
        taxPeriod       = contract.parmTaxPeriod();
        fromDate        = contract.parmFromDate();
        toDate          = contract.parmToDate();
        details         = contract.parmDetails();
        splitTaxCode    = contract.parmSplitTaxCode();
        groupTaxCode    = contract.parmGroupTaxCode();
        printWithoutTax = contract.parmPrintWithoutTax();
        transVAT        = contract.parmTransVAT();

        acctNameCache = new Map(Types::String, Types::String);
        useNewCalculationMethod = FeatureStateProvider::isFeatureEnabled(UseNewCalculationMethodForTaxReconciliationReportFeature::instance());

        this.design();

        // This is done to allow directly transferring data from one TempDB table to another without causing a deadlock
        if (this.parmTakeOwnershipOfTempTables() && !TaxReportTmpTableDisposeFlight::instance().isEnabled())
        {
            this.takeOwnershipOfTempTable(taxReconciliationReportTmp);
        }

        // Determine what tax information needs to be extracted from LedgerTrans and TaxTrans into
        if (splitTaxCode && !printWithoutTax)
        {
            this.calcDetails();
            if (! transVAT)
            {
                delete_from taxReconciliationReportTmp
                    where taxReconciliationReportTmp.TaxCode == '';
            }
        }
        else
        {
            if (details && !printWithoutTax)
            {
                this.calcDetails();
            }
            else
            {
                this.calcNoDetails();
            }

            if (! transVAT && !printWithoutTax)
            {
                delete_from taxReconciliationReportTmp
                    where taxReconciliationReportTmp.BaseAmountPurchase == 0
                        && taxReconciliationReportTmp.BaseAmountReverseCharges == 0
                        && taxReconciliationReportTmp.BaseAmountSales == 0
                        && taxReconciliationReportTmp.TaxAmountPurchase == 0
                        && taxReconciliationReportTmp.TaxAmountReverseCharges == 0
                        && taxReconciliationReportTmp.TaxAmountSales == 0
                        && taxReconciliationReportTmp.TaxDeductible == 0;
            }
            else
            {
                if (details)
                {
                    delete_from taxReconciliationReportTmp
                        notexists join tmpTaxReconciliationNoVat
                            where taxReconciliationReportTmp.BaseAmountPurchase == 0
                                && taxReconciliationReportTmp.BaseAmountReverseCharges == 0
                                && taxReconciliationReportTmp.BaseAmountSales == 0
                                && taxReconciliationReportTmp.TaxAmountPurchase == 0
                                && taxReconciliationReportTmp.TaxAmountReverseCharges == 0
                                && taxReconciliationReportTmp.TaxAmountSales == 0
                                && taxReconciliationReportTmp.TaxDeductible == 0
                                && taxReconciliationReportTmp.Voucher == tmpTaxReconciliationNoVat.Voucher
                                && taxReconciliationReportTmp.AccountNum == tmpTaxReconciliationNoVat.AccountNum
                                && taxReconciliationReportTmp.TransDate == tmpTaxReconciliationNoVat.TransDate;
                }
            }
        }

        detailQuery = new Query();
        qbd         = detailQuery.addDataSource(tableNum(TmpTaxReconciliationNoVat));
        range       = qbd.addRange(fieldNum(TmpTaxReconciliationNoVat, AccountNum));

        if (groupTaxCode)
        {
            repQueryRun.query().dataSourceTable(tableNum(TaxReconciliationReportTmp)).clearSortIndex();
            repQueryRun.query().dataSourceTable(tableNum(TaxReconciliationReportTmp)).sortClear();
            repQueryRun.query().dataSourceTable(tableNum(TaxReconciliationReportTmp)).addSortField(fieldNum(TaxReconciliationReportTmp, TaxCode));
        }
        repQueryRun.setRecord(taxReconciliationReportTmp);

        taxReconciliationReportTmp.ttsbegin();

        while (repQueryRun.next())
        {
            taxReconciliationReportTmp.selectForUpdate(true);
            taxReconciliationReportTmp.IsVisible = NoYes::Yes;
            taxReconciliationReportTmp.update();

            if (! groupTaxCode || printWithoutTax)
            {
                if (taxReconciliationReportTmp.AccountNum != '')
                {
                    taxReconciliationReportTmp  = repQueryRun.get(tableNum(TaxReconciliationReportTmp));
                    insert                      = true;
                }
            }
            else
            {
                if (taxReconciliationReportTmp.TaxCode != '')
                {
                    taxReconciliationReportTmp  = repQueryRun.get(tableNum(TaxReconciliationReportTmp));
                    insert                      = true;
                }
            }

            acctNum = taxReconciliationReportTmp.AccountNum;
            taxCode = taxReconciliationReportTmp.TaxCode;

            if (transVAT || printWithoutTax)
            {
                this.printNoVATTransaction();
            }
            if (! groupTaxCode || printWithoutTax)
            {
                previousAccountNum = acctNum;
            }

            previousTaxCode = taxCode;
        }

        taxReconciliationReportTmp.ttscommit();

        if (transVAT || printWithoutTax)
        {
            taxReconciliationReportTmp.IsVisible = NoYes::Yes;
            this.printNoVATTransaction();
        }
        if (!insert)
        {
            taxReconciliationReportTmp.Design   = DesignEmpty;
            taxReconciliationReportTmp.insert();
        }

        if (printWithoutTax)
        {
            delete_from taxReconciliationReportTmp
                where taxReconciliationReportTmp.BaseAmountPurchase == 0
                    && taxReconciliationReportTmp.BaseAmountReverseCharges == 0
                    && taxReconciliationReportTmp.BaseAmountSales == 0
                    && taxReconciliationReportTmp.TaxAmountPurchase == 0
                    && taxReconciliationReportTmp.TaxAmountReverseCharges == 0
                    && taxReconciliationReportTmp.TaxAmountSales  == 0
                    && taxReconciliationReportTmp.TaxDeductible == 0
                    && taxReconciliationReportTmp.TransVAT == NoYes::No;
        }

        delete_from taxReconciliationReportTmp where taxReconciliationReportTmp.IsVisible == NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSkippingProperties</Name>
				<Source><![CDATA[
    private static void setSkippingProperties(Common _common)
    {
        _common.skipDataMethods(true);
        _common.skipEvents(true);
        _common.skipBusinessEvents(true);
        _common.recordLevelSecurity(false);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>