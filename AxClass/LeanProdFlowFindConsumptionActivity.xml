<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LeanProdFlowFindConsumptionActivity</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>LeanProdFlowFindConsumptionActivity</c> class finds the consumption subactivity and the consumption inventory dimensions for a consumed item.
/// </summary>
class LeanProdFlowFindConsumptionActivity
{
    InventTable                         inventTable;                    // the item that is consumed.
    InventDim                           inventDimInitial;               // initial consuming inventory dimensions.
    LeanProductionFlowActivity          aggregatedLeanProdFlowActivity; // the aggregated leanProductionFlow activity that consumes the item.
    KanbanRule                          kanbanRule;
    KanbanRule                          kanbanRuleCurrent;
    KanbanRulesConnectedSemiFinished    kanbanRulesConnected;
    LeanProductionFlow                  leanProductionFlow;
    List                                listAggregatedPlanActivities;   // a list of aggregated leanProductionFlow activities that may consume the item.
    boolean                             prioritizeForwardActivities;
    boolean                             findBestActivity;
    int                                 level;
    int                                 sequence;
    ItemId                              itemIdFinished;
    InventDimId                         inventDimIdFinished;
    InventQty                           quantityFinished;
    TransDateTime                       dateTimeFromFinished;
    TransDateTime                       dateTimeToFinished;
    LeanKanbanType                      leanKanbanType;

    PlanActivity                        aggregatedPlanActivity;
    InventDimGroupSetup                 inventDimGroupSetup;
    InventDim                           inventDimSearch;                // inventory dimension used to search for LeanProdFlowActivityPickingLocation
    InventDim                           inventDimInput;                 // inventory dimension retrieved from the resource or transfer issue location

    // intermediate results
    InventDim                           inventDimFinal;                         // final consuming inventory dimensions.
    LeanProductionFlowActivity          consumingLeanProdFlowActivity;          // the leanProductionFlow activity that issue the item.
    boolean                             doFindExecuted;

    // final results
    Map                                 mapResultConsumingLeanProdFlowActivity;
    Map                                 mapResultInventDimFinal;
    Map                                 mapResultAggregatedPlanActivity;
    Map                                 mapResultKanbanRule;

    LeanLocationCache                   leanLocationCache;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a picking activity to the prioritized result map.
    /// </summary>
    /// <param name="_kanbanRule">
    /// A <c>KanbanRule</c> record that represents the kanban rule that the picking activity belongs to.
    /// </param>
    /// <param name="_aggregatedPlanActivity">
    /// A <c>PlanActivity</c> record that represents the aggregated plan activity that the picking activity
    /// belongs to.
    /// </param>
    /// <param name="_consumingLeanProdFlowActivity">
    /// The <c>LeanProductionFlowActivity</c> that represents the picking activity.
    /// </param>
    /// <param name="_inventDimFound">
    /// The inventory dimension.
    /// </param>
    /// <param name="_inventDimFinal">
    /// The final inventory dimension.
    /// </param>
    /// <param name="_leanProdFlowActivityPickingLocation">
    /// The <c>LeanProductionFlowActivityPickingLocation</c> record where picking activity occurs.
    /// </param>
    /// <param name="_planActivityLocation">
    /// The <c>PlanActivityLocation</c> location value where the activity occurs.
    /// </param>
    /// <param name="_level">
    /// The level.
    /// </param>
    /// <param name="_sequence">
    /// The sequence.
    /// </param>
    /// <remarks>
    /// The method calculates a priority value for the result and inserts it into a map. After all results
    /// are computed, the best result will be the one that is the first element in the map.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void addResult(
        KanbanRule                          _kanbanRule,
        PlanActivity                        _aggregatedPlanActivity,
        LeanProductionFlowActivity          _consumingLeanProdFlowActivity,
        InventDim                           _inventDimFound,
        InventDim                           _inventDimFinal,
        LeanProdFlowActivityPickingLocation _leanProdFlowActivityPickingLocation,
        PlanActivityLocation                _planActivityLocation,
        int                                 _level,
        int                                 _sequence)
    {
        #define.PriorityOffsetSegmentOne(9)
        #define.PriorityOffSetSegmentTwo(7)
        #define.PriorityOffSetSegmentThree(4)
        #define.PriorityOffsetSegmentFour(0)
        #define.OnePriorityItemIdSpecified(4)
        #define.OnePriorityItemIdNotSpecified(3)
        #define.OnePriorityLocation(2)
        #define.OnePriorityFallback(1)

        LeanProductionFlowActivity  leanProductionFlowActivity;
        InventDim                   inventDim;
        PlanActivity                planActivity;
        KanbanRule                  kanbanRuleLocal;
        int                         seqmentOnePriority;
        int                         segmentTwoPriority;
        int                         segmentThreeMidValue = real2int(power(10,(#PriorityOffSetSegmentTwo-#PriorityOffSetSegmentThree)) / 2);
        int                         segmentFourMidValue  = real2int(power(10,#PriorityOffSetSegmentThree) / 2);

        if (_consumingLeanProdFlowActivity)
        {
            // fallback
            if (_planActivityLocation)
            {
                seqmentOnePriority = #OnePriorityLocation;
                segmentTwoPriority = 0;
            }

            // best match picking location
            if (_leanProdFlowActivityPickingLocation)
            {
                seqmentOnePriority = _leanProdFlowActivityPickingLocation.ItemId ? #OnePriorityItemIdSpecified : #OnePriorityItemIdNotSpecified;
                segmentTwoPriority = this.numberOfSpecifiedProductDimenions(_inventDimFound);
            }
        }
        else
        {
            seqmentOnePriority = #OnePriorityFallback;
            segmentTwoPriority = 0;
        }

        // prioritize level
        int segmentThreePriority = segmentThreeMidValue;
        segmentThreePriority += prioritizeForwardActivities ? -_level : _level;

        // sequence
        int segmentFourPriority = segmentFourMidValue;
        segmentFourPriority += prioritizeForwardActivities ?  -_sequence : _sequence;

        // buffers
        leanProductionFlowActivity.data(_consumingLeanProdFlowActivity);
        inventDim.data(_inventDimFinal);
        planActivity.data(_aggregatedPlanActivity);
        kanbanRuleLocal.data(_kanbanRule);

        // set priority
        int64 priority = any2int64(  seqmentOnePriority   * power(10,#PriorityOffsetSegmentOne)
                                   + segmentTwoPriority   * power(10,#PriorityOffSetSegmentTwo)
                                   + segmentThreePriority * power(10,#PriorityOffSetSegmentThree)
                                   + segmentFourPriority  * power(10,#PriorityOffSetSegmentFour));

        // insert into map with negative priority, so that the highest scoring item will be first when enumerated
        mapResultConsumingLeanProdFlowActivity.insert(-priority,leanProductionFlowActivity);
        mapResultInventDimFinal.insert(-priority,inventDim);
        mapResultAggregatedPlanActivity.insert(-priority,planActivity);
        mapResultKanbanRule.insert(-priority,kanbanRuleLocal);
    }

]]></Source>
			</Method>
			<Method>
				<Name>aggregatedPlanActivity</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the top level plan activity that the selected picking activity belongs to.
    /// </summary>
    /// <param name="_doFind">
    ///    A Boolean value that defines if a search must be executed before the result is returned; optional.
    /// </param>
    /// <returns>
    ///    The aggregated plan activity.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public PlanActivity aggregatedPlanActivity(boolean _doFind = true)
    {
        PlanActivity    planActivity;

        if (_doFind)
        {
            this.doFind();
        }

        if (mapResultAggregatedPlanActivity)
        {
            MapEnumerator me = mapResultAggregatedPlanActivity.getEnumerator();
            if (me.moveNext())
            {
                planActivity = me.currentValue();
            }
        }

        return planActivity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>consumingLeanProdFlowActivity</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the consuming production flow activity.
    /// </summary>
    /// <param name="_doFind">
    ///    A Boolean value that defines if a search must be executed before the result is returned; optional.
    /// </param>
    /// <returns>
    ///    The <c>LeanProductionFlowActivity</c> record that represents the consuming activity.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public LeanProductionFlowActivity consumingLeanProdFlowActivity(
        boolean _doFind = true
    )
    {
        LeanProductionFlowActivity  leanProductionFlowActivity;

        if (_doFind)
        {
            this.doFind();
        }

        if (mapResultConsumingLeanProdFlowActivity)
        {
            MapEnumerator me = mapResultConsumingLeanProdFlowActivity.getEnumerator();
            if (me.moveNext())
            {
                leanProductionFlowActivity = me.currentValue();
            }
        }

        return leanProductionFlowActivity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doFind</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the consuming activity.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void doFind()
    {
        if (!doFindExecuted)
        {
            this.init();

            // set cached variables
            inventDimGroupSetup    = inventDimGroupSetup ? inventDimGroupSetup : InventDimGroupSetup::newInventTable(inventTable);

            boolean done = !listAggregatedPlanActivities
                   || listAggregatedPlanActivities.empty();

            while (!done)
            {
                ListEnumerator le = listAggregatedPlanActivities.getEnumerator();
                sequence = 0;

                while (le.moveNext())
                {
                    sequence++;
                    aggregatedPlanActivity         = le.current();
                    aggregatedLeanProdFlowActivity = LeanProductionFlowActivity::findPlanActivity(aggregatedPlanActivity.RecId);
                    this.initResults();

                    this.initInventDim();

                    if (aggregatedPlanActivity.PlanActivityType == PlanActivityType::Process)
                    {
                    // try to find a specific picking activity for the item that is aggregated under the current plan activity
                    this.findByProdFlowActivityPickingLocation();
                    }

                    this.initResults();

                    // the fallback solution for the current plan activity
                    this.findByPlanActivityLocation();
                }

                if (level != 0)
                {
                    // withdrawal kanban or best result already outside the initial flow and we don't need the 'best' activity.
                    done =    leanKanbanType == LeanKanbanType::Withdrawal
                           || (!findBestActivity
                           &&  this.kanbanRule(false).RecId != kanbanRule.RecId);
                }

                if (!done)
                {
                    // done if there are no other rules to check
                    done =    !kanbanRulesConnected
                           || !kanbanRulesConnected.moveNext();
                }

                if (!done)
                {
                    kanbanRuleCurrent = kanbanRulesConnected.kanbanRule();
                    KanbanFlow kanbanFlowCurrent = kanbanRuleCurrent.kanbanFlow();
                    level = kanbanRulesConnected.isUpStream()
                                                       ? -kanbanRulesConnected.relativeLevel()
                                                       :  kanbanRulesConnected.relativeLevel();

                    // get activities for next flow
                    if (   kanbanRuleCurrent
                        && kanbanFlowCurrent)
                    {
                        listAggregatedPlanActivities = LeanProdFlowFindConsumptionActivity::listFromKanbanFlow(
                                                                                                    kanbanFlowCurrent,
                                                                                                    leanKanbanType);
                    }
                }
            }

            doFindExecuted = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByPlanActivityLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the consuming activity and the consuming inventory dimensions by the plan activity location.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void findByPlanActivityLocation()
    {
        PlanActivityLocation    planActivityLocation;
        boolean                 isLocationCached;

        if (!consumingLeanProdFlowActivity)
        {
            if (leanLocationCache)
            {
                container cachedLocation = leanLocationCache.getPlanActivityLocation(aggregatedPlanActivity.RecId);
                isLocationCached = cachedLocation != conNull();
                if (isLocationCached)
                {
                    [planActivityLocation] = cachedLocation;
                }
            }

            if (!isLocationCached)
            {
            planActivityLocation = aggregatedPlanActivity.nextLevelPlanActivityLocation(PlanActivityType::Pick);
            planActivityLocation = planActivityLocation ? planActivityLocation : aggregatedPlanActivity.planActivityLocation();
                if (leanLocationCache)
                {
                    leanLocationCache.setPlanActivityLocation(
                        aggregatedPlanActivity.RecId,
                        planActivityLocation);
                }
            }

            if (planActivityLocation)
            {
                consumingLeanProdFlowActivity = LeanProductionFlowActivity::findPlanActivity(planActivityLocation.PlanActivity);
            }

            this.setInventDimFinal(inventDimSearch);

            this.addResult(kanbanRuleCurrent,
                           aggregatedPlanActivity,consumingLeanProdFlowActivity,
                           inventDimSearch,inventDimFinal,
                           null,planActivityLocation,
                           level,sequence);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByProdFlowActivityPickingLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the consuming activity and the consuming inventory dimensions from the picking locations connected to the production flow activities.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void findByProdFlowActivityPickingLocation()
    {
        LeanProdFlowActivityPickingLocation leanProdFlowActivityPickingLocation;
        boolean                             isLocationCached;

        if (!consumingLeanProdFlowActivity)
        {
            if (leanLocationCache)
            {
                container cachedLocation = leanLocationCache.getProdFlowActivityPickingLocation(
                    inventTable.ItemId,
                    inventDimSearch.inventDimId,
                    aggregatedLeanProdFlowActivity.PlanActivity);

                isLocationCached = cachedLocation != conNull();
                if (isLocationCached)
                {
                    [leanProdFlowActivityPickingLocation] = cachedLocation;
                }
            }

            if (!isLocationCached)
            {
            leanProdFlowActivityPickingLocation = aggregatedLeanProdFlowActivity.leanProdFlowActivityPickingLocation(inventTable.ItemId,inventDimSearch);
                if (leanLocationCache)
                {
                    leanLocationCache.setProdFlowActivityPickingLocation(
                        inventTable.ItemId,
                        inventDimSearch.inventDimId,
                        aggregatedLeanProdFlowActivity.PlanActivity,
                        leanProdFlowActivityPickingLocation);
                }
            }

            if (leanProdFlowActivityPickingLocation)
            {
                consumingLeanProdFlowActivity = LeanProductionFlowActivity::find(leanProdFlowActivityPickingLocation.ProductionFlowActivity);

                InventDim inventDim = leanProdFlowActivityPickingLocation.inventDim();
                this.setInventDimFinal(inventDim);

                this.addResult(kanbanRuleCurrent,
                               aggregatedPlanActivity,consumingLeanProdFlowActivity,
                               inventDim,inventDimFinal,
                               leanProdFlowActivityPickingLocation,null,
                               level,sequence);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes class variables.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void init()
    {
        mapResultConsumingLeanProdFlowActivity = new Map(Types::Int64,Types::Record);
        mapResultInventDimFinal                = new Map(Types::Int64,Types::Record);
        mapResultAggregatedPlanActivity        = new Map(Types::Int64,Types::Record);
        mapResultKanbanRule                    = new Map(Types::Int64,Types::Record);
        level                                  = 0;
        sequence                               = 0;
        leanProductionFlow                     = LeanProductionFlow::findPlan(kanbanRule.plan().RecId);
        kanbanRuleCurrent                      = kanbanRule;

        if (!kanbanRulesConnected)
        {
            kanbanRulesConnected = KanbanRulesConnectedSemiFinished::newStandard(
                                                                        kanbanRule,
                                                                        itemIdFinished,
                                                                        inventDimIdFinished,
                                                                        dateTimeFromFinished,
                                                                        dateTimeToFinished,
                                                                        quantityFinished);
        }

        kanbanRulesConnected.reset(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the <c>InventDim</c> buffers that are used as search parameters and fallback dimensions.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void initInventDim()
    {
        switch (aggregatedPlanActivity.PlanActivityType)
        {
            case PlanActivityType::Transfer:
                inventDimInput = aggregatedPlanActivity.issueLocation().inventDim();
                inventDimSearch.data(inventDimInput);
                break;
            case PlanActivityType::Process:
                inventDimInput = this.resourceInputInventDim();
                inventDimSearch.data(inventDimInitial);
                if (!inventDimSearch.InventLocationId)
                {
                    inventDimSearch.data(inventDimInput);
                    inventDimSearch.mergeUsedDim(inventDimGroupSetup,inventDimInitial);
                }
                break;
        }

        if (!inventDimSearch.InventSiteId)
        {
            inventDimSearch.InventSiteId = InventLocation::find(inventDimSearch.InventLocationId).InventSiteId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initResults</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the result buffers.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void initResults()
    {
        consumingLeanProdFlowActivity = null;
        inventDimFinal                = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimFinal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the final consuming inventory dimensions.
    /// </summary>
    /// <param name="_doFind">
    ///    A Boolean value that defines if a search must be executed before the result is returned; optional.
    /// </param>
    /// <returns>
    /// A <c>InventDim</c> record that represents the consuming inventory dimensions.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public InventDim inventDimFinal(
        boolean _doFind = true
    )
    {
        InventDim       inventDim;

        if (_doFind)
        {
            this.doFind();
        }

        if (mapResultInventDimFinal)
        {
            MapEnumerator me = mapResultInventDimFinal.getEnumerator();
            if (me.moveNext())
            {
                inventDim = me.currentValue();
            }
        }

        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>kanbanRule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the kanban rule that the selected picking activity belongs to.
    /// </summary>
    /// <param name="_doFind">
    /// A Boolean value that indicates whether a search must be executed before the result is returned;
    /// optional.
    /// </param>
    /// <returns>
    /// The kanban rule.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public KanbanRule kanbanRule(boolean _doFind = true)
    {
        KanbanRule      kanbanRuleResult;

        if (_doFind)
        {
            this.doFind();
        }

        if (mapResultKanbanRule)
        {
            MapEnumerator me = mapResultKanbanRule.getEnumerator();
            if (me.moveNext())
            {
                kanbanRuleResult = me.currentValue();
            }
        }

        return kanbanRuleResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfSpecifiedProductDimenions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the number of specified product dimensions in a given <c>InventDim</c> record.
    /// </summary>
    /// <param name="_inventDim">
    ///    The <c>InventDim</c> record.
    /// </param>
    /// <returns>
    ///    The number of specified product dimensions.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected int numberOfSpecifiedProductDimenions(InventDim _inventDim)
    {
        int             result;

        if (inventDimGroupSetup.getProductDimensionGroup())
        {
            List list = InventDim::dimProductDimFieldList();
            if (   list
                && list.elements())
            {
                ListEnumerator le = list.getEnumerator();
                while (le.moveNext())
                {
                    FieldId dimFieldId = le.current();
                    if (   _inventDim.(dimFieldId) != InventDim::emptyDimField(dimFieldId)
                        && inventDimGroupSetup.isDimensionActive(dimFieldId))
                    {
                        result++;
                    }
                }
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDateTimeFromFinished</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public TransDateTime parmDateTimeFromFinished(TransDateTime _dateTimeFromFinished = dateTimeFromFinished)
    {
        dateTimeFromFinished = _dateTimeFromFinished;

        return dateTimeFromFinished;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDateTimeToFinished</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public TransDateTime parmDateTimeToFinished(TransDateTime _dateTimeToFinished = dateTimeToFinished)
    {
        dateTimeToFinished = _dateTimeToFinished;

        return dateTimeToFinished;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFindBestActivity</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public boolean parmFindBestActivity(boolean _findBestActivity = findBestActivity)
    {
        findBestActivity = _findBestActivity;

        return findBestActivity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDimIdFinished</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public InventDimId parmInventDimIdFinished(InventDimId _inventDimIdFinished = inventDimIdFinished)
    {
        inventDimIdFinished = _inventDimIdFinished;

        return inventDimIdFinished;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDimInitial</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public InventDim parmInventDimInitial(InventDim _inventDim = inventDimInitial)
    {
        inventDimInitial = _inventDim;

        return inventDimInitial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventTable</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public InventTable parmInventTable(InventTable _inventTable = inventTable)
    {
        inventTable = _inventTable;

        return inventTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemIdFinished</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public ItemId parmItemIdFinished(ItemId _itemIdFinished = itemIdFinished)
    {
        itemIdFinished = _itemIdFinished;

        return itemIdFinished;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmKanbanRule</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public KanbanRule parmKanbanRule(KanbanRule _kanbanRule = kanbanRule)
    {
        kanbanRule = _kanbanRule;

        return kanbanRule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmKanbanRulesConnected</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public KanbanRulesConnected parmKanbanRulesConnected(KanbanRulesConnected _kanbanRulesConnected = kanbanRulesConnected)
    {
        kanbanRulesConnected = _kanbanRulesConnected;

        return kanbanRulesConnected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLeanKanbanType</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public LeanKanbanType parmLeanKanbanType(LeanKanbanType _leanKanbanType = leanKanbanType)
    {
        leanKanbanType = _leanKanbanType;
        return leanKanbanType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmListAggregatedPlanActivities</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public List parmListAggregatedPlanActivities(List _listAggregatedPlanActivities = listAggregatedPlanActivities)
    {
        listAggregatedPlanActivities = _listAggregatedPlanActivities;

        return listAggregatedPlanActivities;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrioritizeForwardActivities</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public boolean parmPrioritizeForwardActivities(boolean _prioritizeForwardActivities = prioritizeForwardActivities)
    {
        prioritizeForwardActivities = _prioritizeForwardActivities;

        return prioritizeForwardActivities;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQuantityFinished</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public InventQty parmQuantityFinished(InventQty _quantityFinished = quantityFinished)
    {
        quantityFinished = _quantityFinished;

        return quantityFinished;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resourceInputInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the input inventory dimensions for the resource attached to the activity.
    /// </summary>
    /// <returns>
    ///    An <c>InventDim</c> record that represents input inventory dimensions.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected InventDim resourceInputInventDim()
    {
        InventDim               inventDim;

        WrkCtrResourceGroup wrkCtrResourceGroup = aggregatedPlanActivity.wrkCtrResourceGroup();

        if (wrkCtrResourceGroup.InputInventLocationId)
        {
            InventLocation inventLocation = InventLocation::find(wrkCtrResourceGroup.InputInventLocationId);

            if (inventLocation)
            {
                inventDim.InventSiteId     = inventLocation.InventSiteId;
                inventDim.InventLocationId = inventLocation.InventLocationId;
                inventDim.wmsLocationId    = wrkCtrResourceGroup.InputWMSLocationId;
            }
        }

        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventDimFinal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the <c>InventDimFinal</c> value by merging the initial inventory dimensions and the found
    ///    picking inventory dimensions.
    /// </summary>
    /// <param name="_inventDimPicking">
    ///    A <c>InventDim</c> record that represents the picking inventory dimensions.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void setInventDimFinal(InventDim _inventDimPicking)
    {
        InventDimParm   inventDimParmActive;
        InventDim       inventDimPicking;

        inventDimPicking.data(_inventDimPicking);
        inventDimPicking.clearProductDimensions();
        inventDimPicking = InventDim::findOrCreate(inventDimPicking);

        inventDimFinal.data(inventDimInitial);
        inventDimFinal.mergeUsedDim(inventDimGroupSetup,inventDimPicking);

        inventDimGroupSetup.inventDimParmActive(inventDimParmActive);

        if (inventDimFinal.InventLocationId)
        {
            if (!inventDimFinal.InventSiteId)
            {
                inventDimFinal.InventSiteId = InventLocation::find(inventDimFinal.InventLocationId).InventSiteId;
            }

            // fallback wmsLocation
            if (   inventDimParmActive.wmsLocationIdFlag
                && !inventDimFinal.wmsLocationId)
            {
                inventDimFinal               = InventDim::findOrCreate(inventDimFinal);
                inventDimFinal.wmsLocationId = WMSLocation::defaultItemLocation(inventTable.ItemId,InventDirection::Issue,inventDimPicking).wmsLocationId;
            }
        }

        inventDimFinal.clearNotActiveDim(inventDimGroupSetup);
        inventDimFinal = InventDim::findOrCreate(inventDimFinal);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    private static LeanProdFlowFindConsumptionActivity construct()
    {
        return new LeanProdFlowFindConsumptionActivity();
    }

]]></Source>
			</Method>
			<Method>
				<Name>listFromKanban</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the list of aggregated activities from a kanban.
    /// </summary>
    /// <param name="_kanban">
    /// The kanban that is used to build the list.
    /// </param>
    /// <returns>
    /// A list of <c>PlanActivity</c> records.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The method was called by using a kanban of unknown type.
    /// </exception>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static List listFromKanban(Kanban _kanban)
    {
        KanbanJob           kanbanJob;
        LeanKanbanJobType   leanKanbanJobType;

        List list = new List(Types::Record);

        switch (_kanban.Type)
        {
            case LeanKanbanType::Manufacturing:
                leanKanbanJobType = LeanKanbanJobType::Process;
                break;
            case LeanKanbanType::Withdrawal:
                leanKanbanJobType = LeanKanbanJobType::Transfer;
                break;
            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        while select kanbanJob
            order by kanbanJob.Sequence
            where kanbanJob.Kanban == _kanban.RecId
               && kanbanJob.Type   == leanKanbanJobType
        {
            PlanActivity planActivity = kanbanJob.planActivity();

            if (planActivity)
            {
                list.addEnd(planActivity);
            }
        }

        return list;
    }

]]></Source>
			</Method>
			<Method>
				<Name>listFromKanbanFlow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the list of aggregated activities from a kanban flow.
    /// </summary>
    /// <param name="_kanbanFlow">
    /// The kanban flow that is used to build the list.
    /// </param>
    /// <param name="_leanKanbanType">
    /// A kanban type that is used to decide which activities to include in the list.
    /// </param>
    /// <returns>
    /// A list of <c>PlanActivity</c> records.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The method was called by using an unknown kanban type.
    /// </exception>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static List listFromKanbanFlow(
        KanbanFlow     _kanbanFlow,
        LeanKanbanType _leanKanbanType)
    {
        PlanActivityType            planActivityType;

        List list = new List(Types::Record);

        switch (_leanKanbanType)
        {
            case LeanKanbanType::Manufacturing:
                planActivityType = PlanActivityType::Process;
                break;
            case LeanKanbanType::Withdrawal:
                planActivityType = PlanActivityType::Transfer;
                break;
            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        KanbanFlowWrapper kanbanFlowWrapper = KanbanFlowWrapper::newKanbanFlow(_kanbanFlow);
        PlanActivity planActivity = kanbanFlowWrapper.firstPlanActivity();

        while (planActivity)
        {
            if (planActivity.PlanActivityType == planActivityType)
            {
                list.addEnd(planActivity);
            }
            planActivity = kanbanFlowWrapper.nextPlanActivity();
        }

        return list;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newKanbanFlow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>LeanProdFlowFindConsumptionActivity</c> class.
    /// </summary>
    /// <param name="_inventTable">
    /// An <c>InventTable</c> record that represents the consuming item.
    /// </param>
    /// <param name="_inventDimInitial">
    /// An <c>InventDim</c> record that represents the initial consuming inventory dimensions.
    /// </param>
    /// <param name="_kanbanFlow">
    /// A <c>KanbanFlow</c> record that represents a kanban flow.
    /// </param>
    /// <param name="_kanbanRule">
    /// A <c>KanbanRule</c> record that represents a kanban rule.
    /// </param>
    /// <param name="_leanKanbanType">
    /// A <c>LeanKanbanType</c> enumeration value that represents the kanban type.
    /// </param>
    /// <param name="_prioritizeForwardActivities">
    /// A Boolean value that defines, if picking activities earlier or later in a flow must be prioritized; optional.
    /// </param>
    /// <param name="_findBestActivity">
    /// A Boolean value that defines, if the search must go through all connected rules or can be aborted when a higher priority rule is found; optional.
    /// </param>
    /// <param name="_kanbanRulesConnected">
    /// A <c>KanbanRulesConnected</c> object that is used to explore connected semi-finished kanban rules; optional.
    /// </param>
    /// <param name="_itemIdFinished">
    /// The item ID of the kanban; optional.
    /// </param>
    /// <param name="_inventDimIdFinished">
    /// The inventory dimension ID of the kanban; optional.
    /// </param>
    /// <param name="_quantityFinished">
    /// The ordered or received quantity of the kanban; optional.
    /// </param>
    /// <param name="_dateTimeFromFinished">
    /// A date and time value that is used to find connected kanban rules; optional.
    /// </param>
    /// <param name="_dateTimeToFinished">
    /// A date and time value that is used to find connected kanban rules; optional.
    /// </param>
    /// <returns>
    /// A new <c>LeanProdFlowFindConsumptionActivity</c> object.
    /// </returns>
    /// <remarks>
    /// The kanban rule must be specified.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static LeanProdFlowFindConsumptionActivity newKanbanFlow(
        InventTable          _inventTable,
        InventDim            _inventDimInitial,
        KanbanFlow           _kanbanFlow,
        KanbanRule           _kanbanRule,
        LeanKanbanType       _leanKanbanType
                                                          = _kanbanRule.KanbanType,
        boolean              _prioritizeForwardActivities = true,
        boolean              _findBestActivity            = true,
        KanbanRulesConnected _kanbanRulesConnected        = null,
        ItemId               _itemIdFinished              = '',
        InventDimId          _inventDimIdFinished         = InventDim::inventDimIdBlank(),
        InventQty            _quantityFinished            = 0,
        TransDateTime        _dateTimeFromFinished        = DateTimeUtil::getSystemDateTime(),
        TransDateTime        _dateTimeToFinished          = _dateTimeFromFinished
        )
    {
        List                                    list = LeanProdFlowFindConsumptionActivity::listFromKanbanFlow(_kanbanFlow,
                                                                                                               _leanKanbanType);

        LeanProdFlowFindConsumptionActivity leanProdFlowFindConsumptionActivity = LeanProdFlowFindConsumptionActivity::newParameters(_inventTable,
                                                                                                                                     _inventDimInitial,
                                                                                                                                     list,
                                                                                                                                     _leanKanbanType,
                                                                                                                                     _prioritizeForwardActivities,
                                                                                                                                     _findBestActivity,
                                                                                                                                     _kanbanRule,
                                                                                                                                     _kanbanRulesConnected,
                                                                                                                                     _itemIdFinished,
                                                                                                                                     _inventDimIdFinished,
                                                                                                                                     _quantityFinished,
                                                                                                                                     _dateTimeFromFinished,
                                                                                                                                     _dateTimeToFinished
                                                                                                                                     );

        return leanProdFlowFindConsumptionActivity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newKanbanJobPickingList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>LeanProdFlowFindConsumptionActivity</c> class.
    /// </summary>
    /// <param name="_kanbanJobPickingList">
    /// A <c>KanbanJobPickingList</c> record that represents a kanban picking list line.
    /// </param>
    /// <param name="_kanban">
    /// A <c>Kanban</c> record that represents a kanban that the picking list line belongs to; optional.
    /// </param>
    /// <param name="_kanbanFlow">
    /// A <c>KanbanFlow</c> record that represents a flow that the kanban operates on; optional.
    /// </param>
    /// <param name="_prioritizeForwardActivities">
    /// A Boolean value that defines, if picking activities earlier or later in a flow must be prioritized; optional.
    /// </param>
    /// <param name="_findBestActivity">
    /// A Boolean value that defines, if the search must go through all connected rules or can be aborted when a higher priority rule is found; optional.
    /// </param>
    /// <param name="_kanbanRule">
    /// A <c>KanbanRule</c> record that represents the kanban rule that the kanban was created from; optional.
    /// </param>
    /// <param name="_kanbanRulesConnected">
    /// A <c>KanbanRulesConnected</c> object that is used to explore connected semi-finished kanban rules; optional.
    /// </param>
    /// <param name="_itemIdFinished">
    /// The item ID of the kanban; optional.
    /// </param>
    /// <param name="_inventDimIdFinished">
    /// The inventory dimension ID of the kanban; optional.
    /// </param>
    /// <param name="_quantityFinished">
    /// The ordered or received quantity of the kanban; optional.
    /// </param>
    /// <param name="_dateTimeFromFinished">
    /// A date and time value that is used to find connected kanban rules; optional.
    /// </param>
    /// <param name="_dateTimeToFinished">
    /// A date and time value that is used to find connected kanban rules; optional.
    /// </param>
    /// <returns>
    /// A new <c>LeanProdFlowFindConsumptionActivity</c> object.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static LeanProdFlowFindConsumptionActivity newKanbanJobPickingList(
        KanbanJobPickingList _kanbanJobPickingList
        ,
        Kanban               _kanban                      = _kanbanJobPickingList.kanban(),
        KanbanFlow           _kanbanFlow                  = _kanban.kanbanFlow(),
        boolean              _prioritizeForwardActivities = true,
        boolean              _findBestActivity            = false,
        KanbanRule           _kanbanRule                  = _kanban.kanbanRule(),
        KanbanRulesConnected _kanbanRulesConnected        = null,
        ItemId               _itemIdFinished              = _kanban.ItemId,
        InventDimId          _inventDimIdFinished         = _kanban.InventDimId,
        InventQty            _quantityFinished            = _kanban.QuantityReceived ? _kanban.QuantityReceived : _kanban.QuantityOrdered,
        TransDateTime        _dateTimeFromFinished        = _kanban.DueDateTime,
        TransDateTime        _dateTimeToFinished          = _kanban.DueDateTime
        )
    {
        LeanKanbanType                          leanKanbanType = _kanban ? _kanban.Type : LeanKanbanType::Manufacturing;

        List list = _kanban ? LeanProdFlowFindConsumptionActivity::listFromKanban(_kanban)
                       : LeanProdFlowFindConsumptionActivity::listFromKanbanFlow(_kanbanFlow,leanKanbanType);

        LeanProdFlowFindConsumptionActivity leanProdFlowFindConsumptionActivity = LeanProdFlowFindConsumptionActivity::newParameters(
                                                                                                                            _kanbanJobPickingList.inventTable(),
                                                                                                                            _kanbanJobPickingList.inventDim(),
                                                                                                                            list,
                                                                                                                            leanKanbanType,
                                                                                                                            _prioritizeForwardActivities,
                                                                                                                            _findBestActivity,
                                                                                                                            _kanbanRule,
                                                                                                                            _kanbanRulesConnected,
                                                                                                                            _itemIdFinished,
                                                                                                                            _inventDimIdFinished,
                                                                                                                            _quantityFinished,
                                                                                                                            _dateTimeFromFinished,
                                                                                                                            _dateTimeToFinished
                                                                                                                            );

        return leanProdFlowFindConsumptionActivity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>LeanProdFlowFindConsumptionActivity</c> class.
    /// </summary>
    /// <param name="_inventTable">
    /// An <c>InventTable</c> record that represents the consuming item.
    /// </param>
    /// <param name="_inventDimInitial">
    /// An <c>InventDim</c> record that represents the initial consuming inventory dimensions.
    /// </param>
    /// <param name="_listAggregatedPlanActivities">
    /// A <c>List</c> of top level <c>PlanActivity</c> records.
    /// </param>
    /// <param name="_leanKanbanType">
    /// The kanban type.
    /// </param>
    /// <param name="_prioritizeForwardActivities">
    /// A Boolean value that defines, if picking activities earlier or later in a flow must be prioritized; optional.
    /// </param>
    /// <param name="_findBestActivity">
    /// A Boolean value that defines, if the search must go through all connected rules or can be aborted when a higher priority rule is found; optional.
    /// </param>
    /// <param name="_kanbanRule">
    /// A <c>KanbanRule</c> record that represents the kanban rule that the kanban was created from; optional.
    /// </param>
    /// <param name="_kanbanRulesConnected">
    /// A <c>KanbanRulesConnected</c> object that is used to explore connected semi-finished kanban rules; optional.
    /// </param>
    /// <param name="_itemIdFinished">
    /// The item ID of the kanban; optional.
    /// </param>
    /// <param name="_inventDimIdFinished">
    /// The inventory dimension ID of the kanban; optional.
    /// </param>
    /// <param name="_quantityFinished">
    /// The ordered or received quantity of the kanban; optional.
    /// </param>
    /// <param name="_dateTimeFromFinished">
    /// A date and time value that is used to find connected kanban rules; optional.
    /// </param>
    /// <param name="_dateTimeToFinished">
    /// A date and time value that is used to find connected kanban rules; optional.
    /// </param>
    /// <returns>
    /// A new <c>LeanProdFlowFindConsumptionActivity</c> object.
    /// </returns>
    /// <remarks>
    /// Mandatory parameters have been added, and must be supplied.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static  LeanProdFlowFindConsumptionActivity newParameters(
        InventTable _inventTable,
        InventDim   _inventDimInitial,
        List                 _listAggregatedPlanActivities,
        LeanKanbanType       _leanKanbanType,
        boolean              _prioritizeForwardActivities = true,
        boolean              _findBestActivity            = true,
        KanbanRule           _kanbanRule                  = null,
        KanbanRulesConnected _kanbanRulesConnected        = null,
        ItemId               _itemIdFinished              = '',
        InventDimId          _inventDimIdFinished         = InventDim::inventDimIdBlank(),
        InventQty            _quantityFinished            = 0,
        TransDateTime        _dateTimeFromFinished        = DateTimeUtil::getSystemDateTime(),
        TransDateTime        _dateTimeToFinished          = _dateTimeFromFinished
        )
    {
        LeanProdFlowFindConsumptionActivity leanProdFlowFindConsumptionActivity = LeanProdFlowFindConsumptionActivity::construct();

        leanProdFlowFindConsumptionActivity.parmInventTable(_inventTable);
        leanProdFlowFindConsumptionActivity.parmInventDimInitial(_inventDimInitial);
        leanProdFlowFindConsumptionActivity.parmListAggregatedPlanActivities(_listAggregatedPlanActivities);
        leanProdFlowFindConsumptionActivity.parmLeanKanbanType(_leanKanbanType);
        leanProdFlowFindConsumptionActivity.parmPrioritizeForwardActivities(_prioritizeForwardActivities);
        leanProdFlowFindConsumptionActivity.parmFindBestActivity(_findBestActivity);
        leanProdFlowFindConsumptionActivity.parmKanbanRule(_kanbanRule);
        leanProdFlowFindConsumptionActivity.parmKanbanRulesConnected(_kanbanRulesConnected);
        leanProdFlowFindConsumptionActivity.parmItemIdFinished(_itemIdFinished);
        leanProdFlowFindConsumptionActivity.parmInventDimIdFinished(_inventDimIdFinished);
        leanProdFlowFindConsumptionActivity.parmQuantityFinished(_quantityFinished);
        leanProdFlowFindConsumptionActivity.parmDateTimeFromFinished(_dateTimeFromFinished);
        leanProdFlowFindConsumptionActivity.parmDateTimeToFinished(_dateTimeToFinished);

        return leanProdFlowFindConsumptionActivity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLeanLocationCache</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public LeanLocationCache parmLeanLocationCache(LeanLocationCache _leanLocationCache = leanLocationCache)
    {
        leanLocationCache = _leanLocationCache;

        return leanLocationCache;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>
