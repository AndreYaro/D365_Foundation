<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxReport_ES</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///  The class <c>TaxReport_ES</c> generates the data for the tax report 340.
/// </summary>
class TaxReport_ES extends RunBaseBatch implements BatchRetryable
{
    TaxBookTableRecId           taxBookTableRecId;
    Description                 taxReportName;
    date                        fromDate, toDate;
    TaxReportNumMethod          numMethod;
    int                         numCounter;
    NumberSequenceFormat        numTemplate;
    TaxPeriod                   taxPeriod;
    ReplacementDeclaration_ES   replacementDeclaration;
    PreviousDeclaration_ES      previousDeclaration;
    Amount                      thresholdValue;
    QueryRun                    queryRun;

    DialogField             fldTaxBookTableRecId;
    DialogField             fldTaxReportName;
    DialogField             fldFromDate;
    DialogField             fldNumMethod;
    DialogField             fldNumCounter;
    DialogField             fldNumTemplate;
    DialogField             fldSettlementPeriod;
    DialogField             fldReplacementDeclaration;
    DialogField             fldPreviousDeclaration;
    DialogField             fldThresholdValue;

    #TaxReport340

    #define.PreviousVersion(3)
    #localmacro.PreviousList
        taxBookTableRecId,
        taxReportName,
        fromDate,
        numMethod,
        numCounter,
        numTemplate,
        taxPeriod,
        replacementDeclaration,
        previousDeclaration
    #endmacro

    #define.CurrentVersion(6)
    #localmacro.CurrentList
        taxBookTableRecId,
        taxReportName,
        fromDate,
        numMethod,
        numCounter,
        numTemplate,
        taxPeriod,
        replacementDeclaration,
        previousDeclaration,
        thresholdValue
    #endmacro

    #define.DeclarationLen(13)
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addCashCollectables</Name>
				<Source><![CDATA[
    private void addCashCollectables(TaxReportTable _taxReportTable, TransDate _fromDate, TransDate _toDate)
    {
        TmpCustVendVolume   tmpRecord;
        TmpCustVendVolume   tmpRecordPrevYear;
        TaxReportLines      taxReportLines;
        CustTable           custTable;

        tmpRecord = this.generateTmpRecordForCashCollectables(DateTimeUtil::getStartOfYearDate(new Session().preferredLocale(), _fromDate), _toDate);

        while select sum(AmountInCash), maxof(CashInvoiceDate) from tmpRecord
            group by CashInvoiceYear, AccountNum
        {
            if (tmpRecord.CashInvoiceDate >= fromDate
                    && abs(tmpRecord.AmountInCash)
                    && tmpRecord.CashInvoiceYear >= year(#OperationCodeSupportDate2012))
            {
                if (tmpRecord.CashInvoiceYear < year(fromDate))
                {
                    tmpRecordPrevYear = this.generateTmpRecordForCashCollectables(
                                            mkdate(1, 1, tmpRecord.CashInvoiceYear),
                                            mkdate(31, 12, tmpRecord.CashInvoiceYear),
                                            tmpRecord.AccountNum);

                    select firstonly sum(AmountInCash) from tmpRecordPrevYear
                        group by CashInvoiceYear, AccountNum
                            where tmpRecordPrevYear.CashInvoiceYear == tmpRecord.CashInvoiceYear &&
                                tmpRecordPrevYear.AccountNum == tmpRecord.AccountNum;

                    if ((tmpRecord.AmountInCash + tmpRecordPrevYear.AmountInCash) >= _taxReportTable.ThresholdAmount)
                    {
                        custTable = CustTable::find(tmpRecord.AccountNum);

                        taxReportLines.clear();

                        taxReportLines.RefRecId         = _taxReportTable.RecId;
                        taxReportLines.CashCollectable  = tmpRecord.AmountInCash + tmpRecordPrevYear.AmountInCash;
                        taxReportLines.CashInvoiceYear  = tmpRecord.CashInvoiceYear;
                        taxReportLines.vatNum           = custTable.getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, _toDate);
                        taxReportLines.Name             = this.getCustVendName(taxReportLines.VATNum, custTable);
                        taxReportLines.AccountNum       = tmpRecord.AccountNum;
                        taxReportLines.TaxBookType      = TaxBookType_ES::OutgoingTax;

                        taxReportLines.insert();
                    }
                }
                else if (tmpRecord.AmountInCash >= _taxReportTable.ThresholdAmount)
                {
                    custTable = CustTable::find(tmpRecord.AccountNum);

                    taxReportLines.clear();

                    taxReportLines.RefRecId         = _taxReportTable.RecId;
                    taxReportLines.CashCollectable  = tmpRecord.AmountInCash;
                    taxReportLines.CashInvoiceYear  = tmpRecord.CashInvoiceYear;
                    taxReportLines.vatNum           = custTable.getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, _toDate);
                    taxReportLines.Name             = this.getCustVendName(taxReportLines.VATNum, custTable);
                    taxReportLines.AccountNum       = tmpRecord.AccountNum;
                    taxReportLines.TaxBookType      = TaxBookType_ES::OutgoingTax;

                    taxReportLines.insert();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTaxTransToReportLine</Name>
				<Source><![CDATA[
    private void addTaxTransToReportLine(TaxTrans _taxTrans, TaxReportLines _taxReportLines, TaxBookTaxCodes _taxBookTaxCodes)
    {
        int             factor;

        factor = (_taxTrans.TaxDirection == TaxDirection::OutgoingTax ||
                _taxTrans.TaxDirection == TaxDirection::TaxExemptSales) ? -1 : 1;

        if (_taxTrans.TaxCode == _taxBookTaxCodes.TaxCode)
        {
            if (!_taxReportLines.TaxValue)
            {
                _taxReportLines.TaxValue = _taxTrans.TaxValue;
            }

            if (TaxGroupData::find(_taxTrans.TaxGroup, _taxTrans.TaxCode).IntracomVAT
              && VendInvoiceJour::findFromTaxTrans(_taxTrans.Voucher, _taxTrans.TransDate))
            {
                _taxReportLines.TaxBase   += _taxTrans.TaxBaseAmount;
            }
            else
            {
                _taxReportLines.TaxBase   += _taxTrans.TaxBaseAmount * factor;
            }

            _taxReportLines.TaxAmount += _taxTrans.TaxAmount * factor;
            _taxReportLines.TaxInCostPrice += _taxTrans.TaxInCostPriceRegulated * factor;
            _taxReportLines.update();
        }
        else
        {
            if (!_taxReportLines.TaxValueEq)
            {
                _taxReportLines.TaxValueEq = _taxTrans.TaxValue;
            }

            _taxReportLines.TaxBaseEq   += _taxTrans.TaxBaseAmount * factor;
            _taxReportLines.TaxAmountEq += _taxTrans.TaxAmount * factor;
            _taxReportLines.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkReportingPeriodValidity</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks the reporting dates for correctness.
    /// </summary>
    /// <param name="_taxReportTable">
    ///     The <c>taxReportTable</c> record.
    /// </param>
    private void checkReportingPeriodValidity(TaxReportTable _taxReportTable)
    {
        if (_taxReportTable.FromDate < #OperationCodeSupportDate2012)
        {
            if (_taxReportTable.ToDate > #OperationCodeSupportDate2012)
            {
                throw error(strfmt("@Tax:SpanishVATReportNotValidDeclarationPeriodErrorMessage",
                    _taxReportTable.FromDate,
                    _taxReportTable.ToDate,
                    fieldPName(TaxReportTable, FromDate),
                    fieldPName(TaxReportTable, ToDate),
                    #OperationCodeSupportDate2012));
            }
            else if (_taxReportTable.ToDate < #OperationCodeSupportDate2012)
            {
                info(strfmt("@GLS3800260", #OperationCodeSupportDate2012));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVATNumbers</Name>
				<Source><![CDATA[
    private void checkVATNumbers(TaxReportTable _taxReportTable)
    {
        TaxReportLines              taxReportLines;
        TaxReportLinesTaxTrans_ES   taxReportLinesTaxTrans;
        TaxTrans                    taxTrans;
        CustTrans                   custTrans;
        VendTrans                   vendTrans;
        SysInfoAction_Formrun       infoActionForm;

        while select RecId from taxReportLines
            where taxReportLines.vatNum == ''
               && taxReportLines.RefRecId == _taxReportTable.RecId
               && taxReportLines.TaxBookType == TaxBookType_ES::IncomingTax
        join RecId from taxReportLinesTaxTrans
            where taxReportLinesTaxTrans.TaxReportLines == taxReportLines.RecId
        join RecId, TransDate, Voucher from taxTrans
            where taxReportLinesTaxTrans.TaxTrans == taxTrans.RecId
        join AccountNum from vendTrans
            where vendTrans.TransDate == taxTrans.TransDate
               && vendTrans.Voucher == taxTrans.Voucher
        {
            infoActionForm = SysInfoAction_Formrun::newFormnameControlname(formStr(VendTable), identifierStr(VATNum));
            infoActionForm.parmCallerBuffer(VendTable::find(vendTrans.AccountNum));
            if (this.validateVATNumbers(VendTable::find(vendTrans.AccountNum).Party,CustVendACType::Vend))
            {
                warning(strFmt("@SYS332895", vendTrans.AccountNum), '', infoActionForm);
            }
        }

        while select RecId from taxReportLines
            where taxReportLines.vatNum == ''
               && taxReportLines.RefRecId == _taxReportTable.RecId
               && taxReportLines.TaxBookType == TaxBookType_ES::OutgoingTax
        join RecId from taxReportLinesTaxTrans
            where taxReportLinesTaxTrans.TaxReportLines == taxReportLines.RecId
        join RecId, TransDate, Voucher from taxTrans
            where taxReportLinesTaxTrans.TaxTrans == taxTrans.RecId
        join AccountNum from custTrans
            where custTrans.TransDate == taxTrans.TransDate
               && custTrans.Voucher == taxTrans.Voucher
        {
            infoActionForm = SysInfoAction_Formrun::newFormnameControlname(formStr(CustTable), identifierStr(VATNum));
            infoActionForm.parmCallerBuffer(CustTable::find(custTrans.AccountNum));
            if (this.validateVATNumbers(CustTable::find(custTrans.AccountNum).Party,CustVendACType::Cust))
            {
                warning(strFmt("@SYS332894", custTrans.AccountNum), '', infoActionForm);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxReportLines</Name>
				<Source><![CDATA[
    private void createTaxReportLines(boolean        _endYear,
                                      TaxBookTable   _taxBookTable,
                                      TaxReportTable _taxReportTable)
    {
        Query                               taxTransQuery;
        QueryRun                            taxTransQueryRun;
        QueryBuildRange                     taxCodeRange;
        TaxBookTaxCodes                     taxBookTaxCodes;
        TaxTrans                            taxTrans;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        GeneralJournalEntry                 generalJournalEntry;
        TaxReportLines                      taxReportLines;
        TaxReportLinesTaxTrans_ES           taxReportLinesTaxTrans;

        taxTransQuery = this.getTaxTransQuery(_taxBookTable, fromDate, toDate, _endYear);
        taxCodeRange = SysQuery::findOrCreateRange(taxTransQuery.dataSourceTable(tableNum(TaxTrans)), fieldNum(TaxTrans, TaxCode));

        while select taxBookTaxCodes
            where taxBookTaxCodes.TaxBookTable == _taxBookTable.RecId
        {
            taxCodeRange.value(taxBookTaxCodes.TaxCode);

            if (taxBookTaxCodes.TaxCodeEq)
            {
                taxCodeRange.value(queryRangeConcat(taxCodeRange.value(), taxBookTaxCodes.TaxCodeEq));
            }

            taxTransQueryRun = new QueryRun(taxTransQuery);

            while (taxTransQueryRun.next())
            {
                taxTrans = taxTransQueryRun.get(tableNum(TaxTrans));

                select firstonly RecId from subledgerVoucherGeneralJournalEntry
                    where  subledgerVoucherGeneralJournalEntry.Voucher == taxTrans.Voucher
                        && subledgerVoucherGeneralJournalEntry.AccountingDate  == taxTrans.TransDate
                        && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId  == taxTrans.DataAreaId
                join LedgerPostingJournal from generalJournalEntry
                    where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry;

                if (LedgerJournalName::find(generalJournalEntry.LedgerPostingJournal).JournalType != LedgerJournalType::PurchaseLedger)
                {
                    taxReportLines = this.getTaxReportLine(_taxReportTable, taxBookTaxCodes, taxTrans, _endYear);
                    if (taxReportLines.RecId)
                    {
                        taxReportLinesTaxTrans.clear();
                        taxReportLinesTaxTrans.TaxReportLines   = taxReportLines.RecId;
                        taxReportLinesTaxTrans.TaxTrans         = taxTrans.RecId;
                        taxReportLinesTaxTrans.insert();
                        this.addTaxTransToReportLine(taxTrans, taxReportLines, taxBookTaxCodes);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    /// interface.
    /// </summary>
    /// <returns>
    /// A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    /// A dialog box can be either built by using the <c>Dialog</c> class or by using a class that is
    /// created in the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        DialogRunbase   dialog      = super();

        dialog.addGroup("@SYS15111");
        fldTaxBookTableRecId        = dialog.addFieldValue(extendedTypeStr(TaxBookTableRecId), taxBookTableRecId);

        fldTaxReportName            = dialog.addField(extendedTypeStr(Description), "@SYS6303", "@SYS91817");

        dialog.addGroup("@SYS2163");
        fldSettlementPeriod         = dialog.addFieldValue(extendedTypeStr(TaxPeriod), taxPeriod);
        fldFromDate                 = dialog.addFieldValue(extendedTypeStr(TaxPeriodDate), fromDate, "@SYS5209", "@SYS12292");

        dialog.addGroup("@SYS91792");
        fldNumMethod                = dialog.addFieldValue(enumStr(TaxReportNumMethod), numMethod);

        dialog.addGroup("@SYS91793");
        fldNumCounter               = dialog.addFieldValue(extendedTypeStr(TaxReportLinesFirstNumber_ES), numCounter);
        fldNumTemplate              = dialog.addFieldValue(extendedTypeStr(TaxReportLinesNumberingTemplate_ES), numTemplate);

        dialog.addGroup("@SYS23845");
        fldReplacementDeclaration   = dialog.addFieldValue(extendedTypeStr(ReplacementDeclaration_ES), replacementDeclaration);
        fldPreviousDeclaration      = dialog.addFieldValue(extendedTypeStr(PreviousDeclaration_ES), previousDeclaration);
        fldPreviousDeclaration.allowEdit(replacementDeclaration);

        dialog.addGroup("@GLS3800254");
        fldThresholdValue            = dialog.addFieldValue(extendedTypeStr(Amount), thresholdValue, "@GLS3800236");

        this.registerEventHandlers();

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fldPreviousDeclaration_lookup</Name>
				<Source><![CDATA[
    private void fldPreviousDeclaration_lookup(FormStringControl _origDocumentNumControl)
    {
        SysTableLookup  sysTableLookup;

        sysTableLookup = SysTableLookup::newParameters(tableNum(TaxReportTable), _origDocumentNumControl);
        sysTableLookup.parmQuery(this.getPreviousDeclarationQuery());
        sysTableLookup.addLookupControl(0, true, identifierStr(declarationNum));
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fldPreviousDeclaration_modified</Name>
				<Source><![CDATA[
    private boolean fldPreviousDeclaration_modified(FormStringControl _previousDeclarationControl)
    {
        boolean ret;

        ret = _previousDeclarationControl.modified();

        if (ret)
        {
            fldPreviousDeclaration.value(this.formatPreviousDeclaration(fldPreviousDeclaration.value()));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fldPreviousDeclaration_validate</Name>
				<Source><![CDATA[
    private boolean fldPreviousDeclaration_validate(FormStringControl _origDocumentNumControl)
    {
        return TaxReportTable::isValidDocumentNum(
            _origDocumentNumControl.text(),
            extendedTypeId2pname(extendedTypeNum(PreviousDeclaration_ES)),
            #DeclarationLen);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fldReplacementDeclaration_modified</Name>
				<Source><![CDATA[
    private boolean fldReplacementDeclaration_modified(FormCheckBoxControl _replacementControl)
    {
        boolean ret;

        ret = _replacementControl.modified();

        if (ret)
        {
            fldPreviousDeclaration.allowEdit(fldReplacementDeclaration.value());
            fldPreviousDeclaration.value('');
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formatPreviousDeclaration</Name>
				<Source><![CDATA[
    private str formatPreviousDeclaration(str _previousDeclaration)
    {
        return _previousDeclaration ? strRFix(_previousDeclaration, #DeclarationLen, '0') : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>excludedLedgerTransTypes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ledger transaction types that should not be considered during the record generation.
    /// </summary>
    /// <returns>A container holding Ledger transaction types.</returns>
    protected container excludedLedgerTransTypes()
    {
        return [LedgerTransType::Interest, LedgerTransType::ExchAdjustment, LedgerTransType::CollectionLetter];
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateTmpRecordForCashCollectables</Name>
				<Source><![CDATA[
    private TmpCustVendVolume generateTmpRecordForCashCollectables(FromDate _fromDate, ToDate _toDate, AccountNum _custAccNum = '\"*\"')
    {
        CustTrans                           paymentCustTrans;
        CustTrans                           invoiceCustTrans;
        CustSettlement                      custSettlement;
        TaxReport347Account                 taxReport347Account;
        GeneralJournalAccountEntry          generalJournalAccountEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        DimensionAttributeValueCombination  dimensionAttributeValueCombination;

        TmpCustVendVolume                   tmpRecord;
        Yr                                  invoiceYear;
        TransDate                           dateStartYr = DateTimeUtil::getStartOfYearDate(new Session().preferredLocale(), _fromDate);

        container transTypes = this.excludedLedgerTransTypes();

        // Select only payments (see CustTrans.isPayment()) in the current fiscal year
        while select paymentCustTrans
            where !paymentCustTrans.Invoice
                && !(paymentCustTrans.TransType in transTypes)
                && !(paymentCustTrans.TransType == LedgerTransType::None && paymentCustTrans.BillOfExchangeStatus == CustVendNegInstStatus::None)
                && !paymentCustTrans.Prepayment
                && paymentCustTrans.TransDate >= dateStartYr
                && paymentCustTrans.TransDate <= _toDate
            join SettleAmountMST from custSettlement
                where custSettlement.TransRecId == paymentCustTrans.RecId
            join TransDate from invoiceCustTrans
                where  invoiceCustTrans.Invoice
                    && invoiceCustTrans.RecId == custSettlement.OffsetRecid
            // Filter payments posted to cash accounts
            exists join subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.Voucher == paymentCustTrans.Voucher
                    && subledgerVoucherGeneralJournalEntry.AccountingDate == paymentCustTrans.TransDate
            join RecId from generalJournalAccountEntry
                where generalJournalAccountEntry.GeneralJournalEntry == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
            join RecId from dimensionAttributeValueCombination
                where dimensionAttributeValueCombination.RecId == generalJournalAccountEntry.LedgerDimension
            join RecId from taxReport347Account
                where taxReport347Account.MainAccount == dimensionAttributeValueCombination.MainAccount
        {
            if (paymentCustTrans.isPayment() && !paymentCustTrans.reversed())
            {
                invoiceYear = year(invoiceCustTrans.TransDate);
                tmpRecord = this.populateTmpTableForCashCollectables(tmpRecord, paymentCustTrans, invoiceYear, -custSettlement.SettleAmountMST);
            }
        }

        while select paymentCustTrans
            // Select only payments (see CustTrans.isPayment()) in the current fiscal year
            where  paymentCustTrans.Prepayment
                && paymentCustTrans.TransDate >= dateStartYr
                && paymentCustTrans.TransDate <= _toDate
            // Filter payments posted to cash accounts
            exists join subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.Voucher == paymentCustTrans.Voucher
                    && subledgerVoucherGeneralJournalEntry.AccountingDate == paymentCustTrans.TransDate
            join RecId from generalJournalAccountEntry
                where generalJournalAccountEntry.GeneralJournalEntry == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
            join RecId from dimensionAttributeValueCombination
                where dimensionAttributeValueCombination.RecId == generalJournalAccountEntry.LedgerDimension
            join RecId from taxReport347Account
                where taxReport347Account.MainAccount == dimensionAttributeValueCombination.MainAccount
        {
            if (paymentCustTrans.isPayment() && !paymentCustTrans.reversed())
            {
                invoiceYear = year(paymentCustTrans.TransDate);
                tmpRecord = this.populateTmpTableForCashCollectables(tmpRecord, paymentCustTrans, invoiceYear, -paymentCustTrans.AmountMST);
            }
        }

        return tmpRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendName</Name>
				<Source><![CDATA[
    private Name getCustVendName(VATNum _vatNum, CustVendTable _custVendTable)
    {
        Name name = (select Name from taxVatNumTable where taxVatNumTable.vatNum == _vatNum).Name;
        return name ? name : _custVendTable.name();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        super();

        taxBookTableRecId       = fldTaxBookTableRecId.value();
        taxReportName           = fldTaxReportName.value();
        fromDate                = fldFromDate.value();
        numMethod               = fldNumMethod.value();
        numCounter              = fldNumCounter.value();
        numTemplate             = fldNumTemplate.value();
        taxPeriod               = fldSettlementPeriod.value();
        replacementDeclaration  = fldReplacementDeclaration.value();
        previousDeclaration     = fldPreviousDeclaration.value();
        thresholdValue          = fldThresholdValue.value();

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOperationType</Name>
				<Source><![CDATA[
    private TaxReportOperationType_ES getOperationType(TaxReportTable _taxReportTable, TaxReportLines _taxReportLines)
    {
        TaxReportToAscii340LineProcessor_ES lineProcessor = new TaxReportToAscii340LineProcessor_ES();

        lineProcessor.parmTaxReportLines(_taxReportLines);
        lineProcessor.resetParameters();
        lineProcessor.initCurrentTransaction();

        if (lineProcessor.getTaxBookType() == TaxBookType_ES::OutgoingTax)
        {
            lineProcessor.initCustVendTransaction();
            lineProcessor.initCountRegs();
        }
        else
        {
            lineProcessor.initVendorTrans();
            lineProcessor.initCountRegs();
            lineProcessor.initCorrectedCountVend();
        }

        return lineProcessor.getOperationType();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPreviousDeclarationQuery</Name>
				<Source><![CDATA[
    private Query getPreviousDeclarationQuery()
    {
        Query                   query;
        QueryBuildDataSource    dsTaxReportTable;
        TaxReportPeriod         taxReportPeriod;

        query = new Query();
        dsTaxReportTable = query.addDataSource(tableNum(TaxReportTable));
        //if fromDate/taxPeriod specified - select only declarations in the entered period
        if (fldFromDate.value() && fldSettlementPeriod.value())
        {
            taxReportPeriod = TaxReportPeriod::find(fldSettlementPeriod.value(), fldFromDate.value());
            dsTaxReportTable.addRange(fieldNum(TaxReportTable, FromDate)).value(queryValue(taxReportPeriod.FromDate));
            dsTaxReportTable.addRange(fieldNum(TaxReportTable, ToDate)).value(queryValue(taxReportPeriod.ToDate));
        }
        dsTaxReportTable.addRange(fieldNum(TaxReportTable, DocumentNum)).value(SysQuery::valueNotEmptyString());

        // Add selection fields for the query
        dsTaxReportTable.addSelectionField(fieldNum(TaxReportTable, DocumentNum));
        dsTaxReportTable.addSelectionField(fieldNum(TaxReportTable, ToDate));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxReportLine</Name>
				<Source><![CDATA[
    private TaxReportLines getTaxReportLine(
        TaxReportTable  _taxReportTable,
        TaxBookTaxCodes _taxBookTaxCodes,
        TaxTrans        _taxTrans,
        boolean         _endYear = false)
    {
        TaxReportLines taxReportLines;

        select firstonly forupdate * from taxReportLines
            where  taxReportLines.RefRecId      == _taxReportTable.RecId
                && taxReportLines.TaxCode       == _taxBookTaxCodes.TaxCode
                && taxReportLines.Voucher       == _taxTrans.Voucher
                && taxReportLines.TransDate     == _taxTrans.TransDate;

        if (!taxReportLines)
        {
            taxReportLines.clear();
            taxReportLines.initReportLine(_taxTrans, _taxBookTaxCodes);
            if (!_endYear || this.needReport(taxReportLines, _taxReportTable.ToDate))
            {
                taxReportLines.RefRecId = _taxReportTable.RecId;
                taxReportLines.insert();
            }
        }

        return taxReportLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxTransQuery</Name>
				<Source><![CDATA[
    private Query getTaxTransQuery(TaxBookTable _taxBookTable, date _fromDate, date _toDate, boolean _endYear = false)
    {
        Query                   query;
        QueryBuildDataSource    taxTransQdbs, taxReportTransQbds;
        str                     taxDirectionQueryValue;
        TransDate               dateStartPrevYr = DateTimeUtil::getStartOfYearDate(new Session().preferredLocale(),  prevYr(_toDate));
        TransDate               dateEndPrevYr = DateTimeUtil::getEndOfYearDate(new Session().preferredLocale(),  prevYr(_toDate));

        query = queryRun.query();
        taxTransQdbs = query.dataSourceTable(tableNum(TaxTrans));

        if (_endYear)
        {
            SysQuery::findOrCreateRange(taxTransQdbs, fieldNum(TaxTrans, TransDate)).value(queryRange(dateStartPrevYr, dateEndPrevYr));
        }
        else
        {
            SysQuery::findOrCreateRange(taxTransQdbs, fieldNum(TaxTrans, TransDate)).value(queryRange(_fromDate, _toDate));
        }

        switch (_taxBookTable.TaxBookType)
        {
            case TaxBookType_ES::IncomingTax:
                taxDirectionQueryValue = queryRangeConcat(queryValue(TaxDirection::IncomingTax), queryValue(TaxDirection::TaxExemptPurchase));
                taxDirectionQueryValue = queryRangeConcat(taxDirectionQueryValue, queryValue(TaxDirection::UseTax));
                sysQuery::findOrCreateRange(taxTransQdbs, fieldNum(TaxTrans, TaxDirection)).value(taxDirectionQueryValue);
                break;

            case TaxBookType_ES::OutgoingTax:
                taxDirectionQueryValue = queryRangeConcat(queryValue(TaxDirection::OutgoingTax), queryValue(TaxDirection::TaxExemptSales));
                sysQuery::findOrCreateRange(taxTransQdbs, fieldNum(TaxTrans, TaxDirection)).value(taxDirectionQueryValue);
                break;

            case TaxBookType_ES::AllTax:
                taxDirectionQueryValue = queryRangeConcat(taxDirectionQueryValue, queryValue(TaxDirection::IncomingTax));
                taxDirectionQueryValue = queryRangeConcat(taxDirectionQueryValue, queryValue(TaxDirection::TaxExemptPurchase));
                taxDirectionQueryValue = queryRangeConcat(taxDirectionQueryValue, queryValue(TaxDirection::OutgoingTax));
                taxDirectionQueryValue = queryRangeConcat(taxDirectionQueryValue, queryValue(TaxDirection::TaxExemptSales));
                taxDirectionQueryValue = queryRangeConcat(taxDirectionQueryValue, queryValue(TaxDirection::UseTax));
                sysQuery::findOrCreateRange(taxTransQdbs, fieldNum(TaxTrans, TaxDirection)).value(taxDirectionQueryValue);
                break;
        }

        taxReportTransQbds = SysQuery::findOrCreateDataSource(query, tableNum(TaxReportLinesTaxTrans_ES), tableNum(TaxTrans));
        taxReportTransQbds.joinMode(_endYear ? JoinMode::ExistsJoin : JoinMode::NoExistsJoin);
        taxReportTransQbds.relations(true);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the internal variables.
    /// </summary>
    /// <remarks>
    ///    This method is called when no <c>SysLastValue</c> record can be found when calling the
    ///    <c>SysLastValue.GetLast</c> method. Remember to call the <c>super</c> method.
    /// </remarks>
    public void initParmDefault()
    {
        super();

        numMethod = TaxReportNumMethod::TaxReport340Sequence;
        this.queryBuild();
    }

]]></Source>
			</Method>
			<Method>
				<Name>needReport</Name>
				<Source><![CDATA[
    private boolean needReport(TaxReportLines _taxReportLines, ToDate _toDate)
    {
        CustVendTrans        custVendTrans;
        CustVendTransDetails details;
        TaxReportTable       reportedTable;
        TaxReportLines       reportedLine;
        AmountMST            unpaidAmount;

        if (_taxReportLines.SourceTableId != tablenum(CustTrans) &&
            _taxReportLines.SourceTableId != tablenum(VendTrans))
            return false;

        custVendTrans = new DictTable(_taxReportLines.SourceTableId).makeRecord();
        if (_taxReportLines.SourceTableId == tablenum(CustTrans))
        {
            custVendTrans = CustTrans::find(_taxReportLines.SourceRecId);
        }
        else
        {
            custVendTrans = VendTrans::find(_taxReportLines.SourceRecId);
        }

        if (custVendTrans.Correct || ! custVendTrans.Invoice)
            return false;

        select firstonly RecId from reportedLine
            where reportedLine.TaxCode       == _taxReportLines.TaxCode      &&
                  ! reportedLine.Excluded                                   &&
                  reportedLine.SourceRecId   == _taxReportLines.SourceRecId  &&
                  reportedLine.SourceTableId == _taxReportLines.SourceTableId
        exists join reportedTable
            where reportedTable.RecId  == reportedLine.RefRecId &&
                  reportedTable.ToDate == _toDate;

        if (reportedLine.RecId)
            return false;

        details = new CustVendTransDetails(custVendTrans, _toDate);

        unpaidAmount = custVendTrans.AmountMST - details.amountMSTSettled();
        if (unpaidAmount > 0)
        {
            _taxReportLines.UnpaidInvoiceAmount = unpaidAmount;
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList, queryRun.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTmpTableForCashCollectables</Name>
				<Source><![CDATA[
    private TmpCustVendVolume populateTmpTableForCashCollectables(TmpCustVendVolume _tmpRecord, CustTrans _custTrans, Yr _invoiceYear, AmountMSTDebCred _amount)
    {
        _tmpRecord.CashInvoiceDate = _custTrans.TransDate;
        _tmpRecord.AccountNum = _custTrans.AccountNum;
        _tmpRecord.AmountInCash = _amount;
        _tmpRecord.CashInvoiceYear = _invoiceYear;
        _tmpRecord.insert();

        return _tmpRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBuild</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds the query required for the report <c>TaxReport_ES</c>.
    /// </summary>
    protected void queryBuild()
    {
        Query                   query;
        QueryBuildDataSource    taxTransQdbs;

        query = new Query();
        taxTransQdbs = query.addDataSource(tableNum(TaxTrans));

        taxTransQdbs.addRange(fieldNum(TaxTrans, TaxCode));
        taxTransQdbs.addRange(fieldNum(TaxTrans, TaxOrigin)).value(queryValue(TaxOrigin::Tax));
        taxTransQdbs.addRange(fieldNum(TaxTrans, TaxOrigin)).value(queryValue(TaxOrigin::Payment));
        taxTransQdbs.addRange(fieldNum(TaxTrans, TaxOrigin)).value(queryValue(TaxOrigin::TaxReversed));

        queryRun = new QueryRun(query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    public QueryRun queryRun()
    {
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerEventHandlers</Name>
				<Source><![CDATA[
    private void registerEventHandlers()
    {
        fldReplacementDeclaration.control().registerOverrideMethod(
            methodStr(FormCheckBoxControl, modified),
            methodStr(TaxReport_ES, fldReplacementDeclaration_modified),
            this);

        fldPreviousDeclaration.control().registerOverrideMethod(
            methodStr(FormStringControl, modified),
            methodStr(TaxReport_ES, fldPreviousDeclaration_modified),
            this);

        fldPreviousDeclaration.control().registerOverrideMethod(
            methodStr(FormStringControl, validate),
            methodStr(TaxReport_ES, fldPreviousDeclaration_validate),
            this);

        fldPreviousDeclaration.control().registerOverrideMethod(
            methodStr(FormStringControl, lookup),
            methodStr(TaxReport_ES, fldPreviousDeclaration_lookup),
            this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        #OCCRetryCount

        TaxReportPeriod                     taxReportPeriod;
        TaxReportTable                      taxReportTable;
        TaxBookTable                        taxBookTable;

        try
        {
            taxBookTable            = TaxBookTable::find(taxBookTableRecId);
            taxReportPeriod         = TaxReportPeriod::find(taxPeriod, fromDate);
            fromDate                = taxReportPeriod.FromDate;
            toDate                  = taxReportPeriod.ToDate;

            ttsbegin;

            taxReportTable.clear();
            taxReportTable.TaxBookTable             = taxBookTableRecId;
            taxReportTable.Description              = taxReportName;
            taxReportTable.FromDate                 = fromDate;
            taxReportTable.ToDate                   = toDate;
            taxReportTable.NumMethod                = numMethod;
            taxReportTable.TaxPeriod                = taxPeriod;
            taxReportTable.ReplacementDeclaration   = replacementDeclaration;
            taxReportTable.PreviousDeclaration      = previousDeclaration;
            taxReportTable.ThresholdAmount          = thresholdValue;

            this.checkReportingPeriodValidity(taxReportTable);

            taxReportTable.insert();

            this.createTaxReportLines(false, taxBookTable, taxReportTable);
            if (toDate == DateTimeUtil::getEndOfYearDate(new Session().preferredLocale(), toDate) && CashAccountingRegime_ES::isEnabled(toDate))
            {
                this.createTaxReportLines(true, taxBookTable, taxReportTable);
            }

            if (taxReportTable.isOperationCode2012Supported() &&
                (taxBookTable.TaxBookType == TaxBookType_ES::AllTax ||
                 taxBookTable.TaxBookType == TaxBookType_ES::OutgoingTax))
            {
                this.addCashCollectables(taxReportTable, fromDate, toDate);
            }

            this.checkVATNumbers(taxReportTable);
            this.setRecordNumbers(taxReportTable);
            this.setOperationTypes(taxReportTable);

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setOperationTypes</Name>
				<Source><![CDATA[
    private void setOperationTypes(TaxReportTable _taxReportTable)
    {
        TaxReportLines  taxReportLines;

        while select forupdate taxReportLines
            where taxReportLines.RefRecId == _taxReportTable.RecId
        {
            taxReportLines.OperationType = this.getOperationType(_taxReportTable, taxReportLines);
            taxReportLines.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRecordNumbers</Name>
				<Source><![CDATA[
    public void setRecordNumbers(TaxReportTable _taxReportTable)
    {
        TaxRepRecordNumbering_ES    recordNumbering;
        TaxReportLines              taxReportLines;

        recordNumbering = TaxRepRecordNumbering_ES::construct(numMethod,
                                                              numCounter,
                                                              numTemplate,
                                                              TaxBookTable::find(taxBookTableRecId).NumberSequenceTable);

        while select forupdate taxReportLines
            order by taxReportLines.TransDate, taxReportLines.Voucher, taxReportLines.AccountNum, taxReportLines.CashInvoiceYear
            where taxReportLines.RefRecId == _taxReportTable.RecId
        {
            taxReportLines.ReportRecord = recordNumbering.getNextRecordNumber(taxReportLines);
            taxReportLines.update();
        }

        _taxReportTable.FirstNum = recordNumbering.firstNum();
        _taxReportTable.LastNum  = recordNumbering.lastNum();
        _taxReportTable.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to add a Select button to the dialog box. If you change the return value to
    /// true, the button will be added.
    /// </summary>
    /// <returns>
    /// Always returns false.
    /// </returns>
    /// <remarks>
    /// If you click this button, it will show the query form. Therefore, the <c>queryRun</c> method has to
    /// return a valid <c>queryRun</c> object.
    /// </remarks>
    public boolean showQueryValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);
        container packedQuery;

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList, packedQuery] = _packedClass;

                if (packedQuery)
                {
                    queryRun = new QueryRun(packedQuery);
                }
                else
                {
                    this.queryBuild();
                }

                return true;

            case #PreviousVersion:
                [version, #PreviousList] = _packedClass;
                thresholdValue = 0;
                this.queryBuild();
                return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates the report parmeters.
    /// </summary>
    /// <param name="_calledFrom">
    ///     The calling object; optional.
    /// </param>
    /// <returns>
    ///     True if the data is valid ; otherwise , false.
    /// </returns>
    public boolean validate(Object _calledFrom = null)
    {
        boolean         ret = true;
        TaxReportPeriod taxReportPeriod;
        TaxBookTable    taxBookTable;
        TaxReportTable  taxReportTableInSamePeriod;

        taxBookTable = TaxBookTable::find(taxBookTableRecId);

        if (!taxBookTable)
        {
            throw error("@SYS91790");
        }

        if (!taxBookTable.NumberSequenceTable && numMethod == TaxReportNumMethod::NumberSequence)
        {
            throw error("@SYS91795");
        }

        if (replacementDeclaration == NoYes::Yes && !previousDeclaration)
        {
            ret = checkFailed(strFmt("@SYS84378", fieldPName(TaxReportTable, PreviousDeclaration)));
        }

        if (!fromDate)
        {
            ret = checkFailed("@SYS91557");
        }

        if (!taxPeriod)
        {
            ret = checkFailed("@SYS63293");
        }

        taxReportPeriod = TaxReportPeriod::find(taxPeriod, fromDate);
        if (!taxReportPeriod.RecId)
        {
            ret = checkFailed("@SYS24993");
        }

        select firstonly RecId from taxReportTableInSamePeriod
            where  taxReportTableInSamePeriod.FromDate                  == taxReportPeriod.FromDate
                && taxReportTableInSamePeriod.ToDate                    == taxReportPeriod.ToDate
                && taxReportTableInSamePeriod.ReplacementDeclaration    == replacementDeclaration
                && taxReportTableInSamePeriod.TaxBookTable              == taxBookTable.RecId;

        if (taxReportTableInSamePeriod.RecId)
        {
            if (replacementDeclaration)
            {
                ret = checkFailed(strFmt("@SYS334845", taxReportPeriod.FromDate, taxReportPeriod.ToDate));
            }
            else
            {
                ret = checkFailed(strFmt("@SYS328434", taxReportPeriod.FromDate, taxReportPeriod.ToDate));
            }
        }
        else
        {
            select firstonly RecId, ReplacementDeclaration from taxReportTableInSamePeriod
                where  taxReportTableInSamePeriod.FromDate      == taxReportPeriod.FromDate
                    && taxReportTableInSamePeriod.ToDate        == taxReportPeriod.ToDate
                    && taxReportTableInSamePeriod.TaxBookTable  == taxBookTable.RecId;

            if (replacementDeclaration == NoYes::No && taxReportTableInSamePeriod.RecId
                && taxReportTableInSamePeriod.ReplacementDeclaration == NoYes::Yes)
            {
                ret = checkFailed("@SYS328769");
            }
            else if (ret && replacementDeclaration == NoYes::Yes && !taxReportTableInSamePeriod.RecId)
            {
                ret = Box::yesNo(strFmt("@SYS332893",
                        taxReportPeriod.FromDate, taxReportPeriod.ToDate), DialogButton::Yes) == DialogButton::Yes;
            }
        }
        ret = ret && super(_calledFrom);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateVATNumbers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates VATnumber required or not for customer/vendor.
    /// </summary>
    /// <param name="_partyRecId">
    /// The _partyRecId of customer or vendor.
    /// </param>
    /// <param name="_custVendACType">
    /// customer or vendor type.
    /// </param>
    /// <returns>
    /// If 'True', the validation is required.
    /// </returns>
    private boolean validateVATNumbers(DirPartyRecId _partyRecId,CustVendACType _custVendACType)
    {
        boolean                ret;
        MandatoryVATNum        mandatoryVATNum;
        AddressCountryRegionId countryRegionId;
        #isoCountryRegionCodes

        countryRegionId = DirParty::primaryPostalAddress(_partyRecId).CountryRegionId;

        if (_custVendACType == CustVendACType::Cust)
        {
            mandatoryVATNum = CustParameters::find().MandatoryVATNum;
        }
        else
        {
            mandatoryVATNum = VendParameters::find().MandatoryVATNum;
        }

        if (mandatoryVATNum  == TaxVATNumCountryRegionType::None ||
            (countryRegionId == #isoBE   &&
                SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBE])))
        {
            return ret;
        }

        if (mandatoryVATNum == TaxVATNumCountryRegionType::EU)
        {
            if (IntrastatCountryRegionParameters::isCountryRegionStateInEU(DirParty::primaryPostalAddress(_partyRecId)))
                ret = true;
        }
        if (mandatoryVATNum == TaxVATNumCountryRegionType::DomesticEU)
        {
            if (IntrastatCountryRegionParameters::isCountryRegionStateInEU(DirParty::primaryPostalAddress(_partyRecId)) || IntrastatCountryRegionParameters::isDomestic(countryRegionId))
                ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static TaxReport_ES construct()
    {
        return new TaxReport_ES();
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS91791";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        TaxReport_ES taxReport_ES;

        taxReport_ES = TaxReport_ES::construct();

        if (taxReport_ES.prompt())
        {
            taxReport_ES.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls whether the batch task should be retried in case of transient errors.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>