<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SubledgerJournalizerProjectExtension</Name>
	<SourceCode>
		<Declaration><![CDATA[
[SourceDocumentEnumExtensionAttribute(enumStr(SourceDocument_VendorInvoice), SourceDocument_VendorInvoice::VendorInvoice),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocument_PayrollPayStatement), SourceDocument_PayrollPayStatement::PayStatement),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocument_CustomerInvoice), SourceDocument_CustomerInvoice::CustomerFreeTextInvoice),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocument_ProjectTimesheets), SourceDocument_ProjectTimesheets::Timesheets),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocument_TimesheetsIntercompany), SourceDocument_TimesheetsIntercompany::IntercompanyCost),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocument_ExpenseReport), SourceDocument_ExpenseReport::ExpenseReport),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocument_AdvancedLedgerEntry), SourceDocument_AdvancedLedgerEntry::AdvancedLedgerEntry),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocument_ProjAdvancedJournal), SourceDocument_ProjAdvancedJournal::ProjAdvancedJournal)]
class SubledgerJournalizerProjectExtension extends SubledgerJournalizerExtension
{
    private static AccountingEventTmp accountingEventTmp;
    private static ProjOpsInstrumentationLogger projOpsLogger = ProjOpsInstrumentationLogger::createLogger(classStr(SubledgerJournalizerProjectExtension));
    private static Map projBudgetTransactionLineMap = new Map(Types::Real, Types::AnyType);
    private static int actualHeaderLines = 0;
    private static int projBudgetTransactionLinesCount = 0;
    
    #localmacro.declareProjectRevenueLineContainerVariablesMacro
        RefRecId    transactionSalesCurrency;
        LegalEntityRecId    transactionSalesLegalEntityRecId;
        AmountCur   transactionCurrencySalesAmount;
        AccountingDate  accountingDate;
    #endmacro

    #localmacro.projectRevenueLineContainerMacro
        [
        transactionSalesCurrency,
        transactionSalesLegalEntityRecId,
        transactionCurrencySalesAmount,
        accountingDate
        ]
    #endmacro

    #localmacro.clearProjectRevenueLineContainerMacro
        transactionSalesCurrency = 0;
        transactionSalesLegalEntityRecId = 0;
        transactionCurrencySalesAmount = 0;
        accountingDate = dateNull();
    #endmacro

    #localmacro.declareProjectActualHeaderContainerVariablesMacro
        RefRecId            actualSourceDocumentLine;
        DataAreaId          actualProjectDataAreaId;
        ProjId              actualProjectId;
        ProjCategoryId      actualCategoryId;
        smmActivityNumber   actualActivityNumber;
        ProjLinePropertyId  actualLinePropertyId;
        CurrencyCode        actualTransactionCostCurrency;
        CurrencyCode        actualTransactionSalesCurrency;
        CurrencyCode        accountingCurrency;
        ProjTaxGroup        actualTaxGroupId;
        ProjTaxItemGroup    actualTaxItemGroupId;
        DimensionDefault    actualDefaultDimension;
        Qty                 actualQuantity;
        AmountCur           actualTransactionCurrencyCostAmount;
        AmountMST           actualAccountingCurrencyCostAmount;
        AmountCur           actualTransactionCurrencySalesAmount;
        AmountMST           actualAccountingCurrencySalesAmount;
    #endmacro

    #localmacro.projectActualHeaderContainerMacro
        [
        actualSourceDocumentLine,
        actualProjectDataAreaId,
        actualProjectId,
        actualCategoryId,
        actualActivityNumber,
        actualLinePropertyId,
        actualTransactionCostCurrency,
        actualTransactionSalesCurrency,
        accountingCurrency,
        actualTaxGroupId,
        actualTaxItemGroupId,
        actualDefaultDimension,
        actualQuantity,
        actualTransactionCurrencyCostAmount,
        actualAccountingCurrencyCostAmount,
        actualTransactionCurrencySalesAmount,
        actualAccountingCurrencySalesAmount
        ]
    #endmacro

    #localmacro.clearProjectActualHeaderContainerMacro
        actualSourceDocumentLine = 0;
        actualProjectDataAreaId = '';
        actualProjectId = '';
        actualCategoryId = '';
        actualActivityNumber = '';
        actualLinePropertyId = '';
        actualTransactionCostCurrency = '';
        actualTransactionSalesCurrency = '';
        accountingCurrency = '';
        actualTaxGroupId = '';
        actualTaxItemGroupId = '';
        actualDefaultDimension = 0;
        actualQuantity = 0;
        actualTransactionCurrencyCostAmount = 0;
        actualAccountingCurrencyCostAmount = 0;
        actualTransactionCurrencySalesAmount = 0;
        actualAccountingCurrencySalesAmount = 0;
    #endmacro

    #localmacro.declareProjectActualDetailContainerVariablesMacro
        ProjFundingSourceRefId  actualFundingSource;
        DimensionDefault        actualDetailDefaultDimension;
        AmountCur               actualTransactionCurrencyAmount;
        AmountMST               actualAccountingCurrencyAmount;
        List                    actualReferenceProjectAccountingDistribution;
        container               packedActualReferenceProjectAccountingDistribution;
        List                    actualLedgerUpdate;
        container               packedActualLedgerUpdate;
    #endmacro

    #localmacro.projectActualDetailContainerMacro
        [
        actualFundingSource,
        actualDetailDefaultDimension,
        actualTransactionCurrencyAmount,
        actualAccountingCurrencyAmount,
        packedActualReferenceProjectAccountingDistribution,
        packedActualLedgerUpdate
        ]
    #endmacro

    #localmacro.clearProjectActualDetailContainerMacro
        actualFundingSource = 0;
        actualDetailDefaultDimension = 0;
        actualTransactionCurrencyAmount = 0;
        actualAccountingCurrencyAmount = 0;
        actualReferenceProjectAccountingDistribution = new List(Types::Int64);
        actualLedgerUpdate = new List(Types::Container);
    #endmacro

    #localmacro.declareActualLedgerUpdateContainerVariablesMacro
        LedgerPostingType       actualLedgerUpdatePostingType;
        LedgerDimensionAccount  actualLedgerUpdateLedgerDimension;
        AmountMST               actualLedgerUpdateAccountingCurrencyAmount;
        Qty                     actualLedgerUpdateQuantity;
   #endmacro

    #localmacro.actualLedgerUpdateContainerMacro
        [
        actualFundingSource,
        actualLedgerUpdatePostingType,
        actualLedgerUpdateLedgerDimension,
        actualLedgerUpdateAccountingCurrencyAmount,
        actualLedgerUpdateQuantity
        ]
    #endmacro

    private ProjAdvancedJournalLine projAdvancedJournalLine;
    private boolean vendorInvoiceRetentionCalcFeature = ProjVendorInvoiceRetentionCalcFeatureHelper::isFeatureEnabled();
    private boolean vendorInvoiceRetentionTransitionFlight = ProjVendorInvoiceRetentionCalcFeatureHelper::isTransitionFlightEnabled();

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getProjAdvancedJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the project advanced journal line with a specified source document line.
    /// </summary>
    /// <param name = "_sourceDocumentLineRecId">The record ID of the source document line.</param>
    /// <returns>The project advanced journal line with a specified source document line.</returns>
    protected ProjAdvancedJournalLine getProjAdvancedJournalLine(SourceDocumentLineRecId _sourceDocumentLineRecId)
    {
        if (projAdvancedJournalLine.SourceDocumentLine != _sourceDocumentLineRecId)
        {
            projAdvancedJournalLine = ProjAdvancedJournalLine::findBySourceDocumentLine(_sourceDocumentLineRecId);
        }

        return projAdvancedJournalLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the project actuals based on information from accounting distributions and handles reservation of project
    /// budgets for the project actuals if project budgeting is enabled.
    /// Before project actuals are created, this method will create reversing project commitment entries as well as recognizes
    /// project revenue for time and material projects that were set up to accrue revenue.
    /// </summary>
    /// <param name="_sourceDocumentHeader">
    /// A record in the <c>_sourceDocumentHeader</c> table.
    /// </param>
    public void journalized(SourceDocumentHeader _sourceDocumentHeader)
    {
        ProjOpsBudgetingInstrumentationActivites activities = ProjOpsBudgetingInstrumentationActivites::construct(projOpsLogger);
        using (SysInstrumentationActivityContext activityContext = activities.instrumentSourceDocumentHeader(ProjOpsBudgetingInstrumentationActivites::SourceDocHeaderJournalized, _sourceDocumentHeader.RecId))
        {
            List projectActualHeaderList;

            boolean isLineLevelPostingEnabled = SubledgerJournalizerProjectExtension::isLineLevelPostingEnabled();
            boolean isAccountingDistributionCheckFlightEnabled = ProjAdvancedJournalAccountingDistributionCheckFlight::instance().isEnabled();

            SourceDocument sourceDocument = this.parmSubledgerJournalizer().parmSourceDocument();

            if (!sourceDocument)
            {
                sourceDocument = SourceDocument::newFromSourceDocumentHeader(_sourceDocumentHeader);
            }
            
            boolean hasProjectAccountingDistribution;

            if (isAccountingDistributionCheckFlightEnabled
                && isLineLevelPostingEnabled
                && sourceDocument is ProjAdvancedJournalSourceDocument)
            {
                hasProjectAccountingDistribution = SubledgerJournalizerProjectExtension::hasProjAccDistForAdvancedJournalDoc(sourceDocument);
            }
            else
            {
                hasProjectAccountingDistribution = SubledgerJournalizerProjectExtension::hasProject(_sourceDocumentHeader.RecId);
            }

            if (hasProjectAccountingDistribution &&
                SubledgerJournalizerProjectExtension::parmCanSupportActuals(_sourceDocumentHeader))
            {
                if (sourceDocument is TrvExpTableSourceDocument)
                {
                    // When line level posting, the document can be journalized multiple times
                    Map trvExpLines = sourceDocument.parmSourceDocumentLinesForCurrentVoucher();
                    MapEnumerator trvExpLineEnum = trvExpLines.getEnumerator();

                    while (trvExpLineEnum.moveNext())
                    {
                        ProjectCommitmentFacade::deleteProjectCommitments(trvExpLineEnum.current());

                        ProjFundingLimitTrackingManager::updateUsingSourceDocumentLine(trvExpLineEnum.current(), ProjFundingLimitTrackingAction::Release, false);
                    }
                }
                else
                {
                    if (sourceDocument is ProjAdvancedJournalSourceDocument
                        && isLineLevelPostingEnabled)
                    {
                        // When line level posting, the document can be journalized multiple times
                        Map journalLines = sourceDocument.parmSourceDocumentLinesForCurrentVoucher();
                        MapEnumerator journalLinesEnumerator = journalLines.getEnumerator();

                        while (journalLinesEnumerator.moveNext())
                        {
                            ProjectCommitmentFacade::deleteProjectCommitments(journalLinesEnumerator.current());
                            ProjFundingLimitTrackingManager::updateUsingSourceDocumentLine(journalLinesEnumerator.current(), ProjFundingLimitTrackingAction::Release, false);
                        }
                    }
                    else
                    {
                        ProjectCommitmentFacade::deleteProjectCommitmentsForDocument(_sourceDocumentHeader.RecId, sourceDocument.parmCurrentVoucher(curext()));
                        ProjFundingLimitTrackingManager::updateUsingSourceDocument(_sourceDocumentHeader.RecId, ProjFundingLimitTrackingAction::Release, false);
                    }
                }

                if (sourceDocument is TrvExpTableSourceDocument && TrvParameters::find().IsReleaseEncumbrancesOnCloseRequisition)
                {
                    Map trvExpLines = sourceDocument.parmSourceDocumentLinesForCurrentVoucher();
                    
                    MapEnumerator trvExpLineEnum = trvExpLines.getEnumerator();

                    while (trvExpLineEnum.moveNext())
                    {
                        TrvExpTrans trvExpTrans = TrvExpTrans::findBySourceDocumentLine(trvExpLineEnum.current());

                        TrvRequisitionLine trvReqLine = TrvRequisitionLine::find(trvExpTrans.MappedToRequisitionLine);
                    
                        if (trvReqLine)
                        {
                            ProjectCommitmentFacade::deleteProjectCommitments(trvReqLine.SourceDocumentLine);
                        }
                    }
                }
                
                boolean canProcessInvoice = SubledgerJournalizerProjectExtension::parmCanProcessInvoice(_sourceDocumentHeader);
                            
                if (sourceDocument is ProjAdvancedJournalSourceDocument)
                {
                    //
                    // Fee Type lines on journal with Accrued revenue set to false are not journalized, so they are not processed by standard process.
                    // Hour and Expense lines sales actuals are created through their extended price distributions, which are journalized regardless.
                    //
                    SubledgerJournalizerProjectExtension::processFeeLinesWithoutAccruedRevenue(sourceDocument);
                }
                else if (!canProcessInvoice)
                {
                    boolean processAccruedRevenue;

                    // If vendor retention feature transition flight is enabled, then always process accrued revenue.
                    // Whether accrued revenue will be needed will be determined by method
                    // validateVendorInvoiceLineCanAccrueRevenue() at a later phase.
                    if (vendorInvoiceRetentionTransitionFlight)
                    {
                        processAccruedRevenue = true;
                    }
                    // If vendor retention feature transition flight is not enabled, then
                    // skip project accrued revenue journal entries for invoice posting
                    // for project PO vendor retention release scenario.
                    // This will not be correct if user will post vendor invoice
                    // with multiple lines while one with retiage release only and the other one is not.
                    // Problem is that isVendorRetainage() attempts to determine by source doucument header
                    // which is wrong. This can only be determined in the source document line level.
                    // This issue is addressed by enabling ProjVendorInvoiceRetentionCalcTransitionFlight,
                    // which it won't get into logic.
                    else if (!vendorInvoiceRetentionCalcFeature
                        || !SubledgerJournalizerProjectExtension::isVendorRetainage(_sourceDocumentHeader.RecId))
                    {
                        processAccruedRevenue = true;
                    }

                    if (processAccruedRevenue)
                    {
                        SubledgerJournalizerProjectExtension::processAccruedRevenue(sourceDocument);
                    }
                }

                if (sourceDocument is ProjAdvancedJournalSourceDocument
                    && isLineLevelPostingEnabled)
                {
                    projectActualHeaderList = this.processProjectActualV2(sourceDocument, canProcessInvoice);
                }
                else
                {
                    projectActualHeaderList = SubledgerJournalizerProjectExtension::processProjectActual(sourceDocument, canProcessInvoice);
                }

                if (canProcessInvoice && projectActualHeaderList)
                {
                    using (var processInvoicesContext = SubledgerJournalizerProjectExtensionProcessInvoicesContext::instance())
                    {
                        processInvoicesContext.parmSourceDocument(sourceDocument);
                        SubledgerJournalizerProjectExtension::processInvoices(projectActualHeaderList, sourceDocument.parmCurrentVoucher(curext()));
                    }
                }
            }
            
            if (ProjItemReqNonStockedPriceUpdateFlight::instance().isEnabled())
            {
                this.processForNonStockedItemReq();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLineLevelPostingEnabled</Name>
				<Source><![CDATA[
    private static boolean isLineLevelPostingEnabled()
    {
        boolean enableProjEnableAdvancedJournalMultipleBatchTaskFeature = FeatureStateProvider::isFeatureEnabled(ProjEnableAdvancedJournalMultipleBatchTaskFeature::instance());
        boolean enableProjEnableAdvancedJournalErrorTransferFeature = FeatureStateProvider::isFeatureEnabled(ProjEnableAdvancedJournalErrorTransferFeature::instance());
        boolean isEnhancedPostingEnabled = FeatureStateProvider::isFeatureEnabled(ProjAdvancedJournalPostingEnhancementFeature::instance());

        return (enableProjEnableAdvancedJournalMultipleBatchTaskFeature
            || enableProjEnableAdvancedJournalErrorTransferFeature
            || isEnhancedPostingEnabled);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processForNonStockedItemReq</Name>
				<Source><![CDATA[
    private void processForNonStockedItemReq()
    {
        SourceDocument sourceDocument = this.parmSubledgerJournalizer().parmSourceDocument();
        if (sourceDocument is VendorInvoiceSourceDoc)
        {
            Map sdLines = sourceDocument.parmSourceDocumentLinesForCurrentVoucher();
            MapEnumerator sdLinesEnumerator = sdLines.getEnumerator();
                
            NumberSequenceCode voucherSeriesCode = ProjParameters::numRefProjJournalId().numberSequenceTable().NumberSequence;
            LedgerVoucher ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail, SysModule::Project, voucherSeriesCode);
            while (sdLinesEnumerator.moveNext())
            {
                SourceDocumentLine sourceDocumentLine = SourceDocumentLine::find(sdLinesEnumerator.current());
                SourceDocumentLineItem sdLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(sourceDocumentLine);

                if (sdLineItem is VendorInvoiceLineSourceDocLineItem)
                {
                    VendorInvoiceLineSourceDocLineItem vendInvoiceSDLineItem = sdLineItem as VendorInvoiceLineSourceDocLineItem;
                    VendInvoiceLineMap vendInvoiceLineMap = vendInvoiceSDLineItem.parmVendInvoiceLineMap();

                    if(!vendInvoiceLineMap.isNonPO())
                    {
                        PurchLine purchLine = vendInvoiceLineMap.purchLine();
                
                        if(purchLine.ProjId && purchLine.InventRefTransId && !purchLine.isStocked())
                        {
                            SalesLine salesLine = SalesLine::findInventTransId(purchLine.InventRefTransId);

                            PurchPrice purchPriceMST = this.getPurchPriceInAccountingCurrency(sourceDocument, sdLineItem, vendInvoiceLineMap);

                            if (this.needsPriceDiffPostingsByPurchPrice(salesLine, vendInvoiceSDLineItem, vendInvoiceLineMap, purchPriceMST))
                            {
                                this.postPriceDiffForPackingSlipByPurchPrice(salesLine, sourceDocumentLine, ledgerVoucher, purchPriceMST, voucherSeriesCode);
                            }
                        }
                    }
                }
            }
                
            ledgerVoucher.end();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchPriceInAccountingCurrency</Name>
				<Source><![CDATA[
    private PurchPrice getPurchPriceInAccountingCurrency(VendorInvoiceSourceDoc _vendInvoiceHeader, VendorInvoiceLineSourceDocLineItem _vendInvoiceLineItem, VendInvoiceLineMap _vendInvoiceLineMap)
    {
        PurchPrice purchPrice;
        if (_vendInvoiceLineMap.Qty != 0)
        {
            // _vendInvoiceLineMap.LineAmount will factor in the discount amount if it's discount has been configured.
            purchPrice = _vendInvoiceLineMap.LineAmount / _vendInvoiceLineMap.Qty;
        }
   
        CurrencyCode accountingCurrency = Ledger::accountingCurrency();
        if (_vendInvoiceLineMap.CurrencyCode != accountingCurrency)
        {
            LedgerRecId ledgerRecId = Ledger::current();
            AccountingDate accountingDate = _vendInvoiceLineItem.parmAccountingDate();
            CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(ledgerRecId, accountingDate);

            VendInvoiceInfoTable vendInvoiceInfoTable = VendInvoiceInfoTable::findSourceDocumentHeader(_vendInvoiceHeader.parmSourceDocumentHeader().RecId);
            if (vendInvoiceInfoTable.FixedExchRate)
            {
                currencyExchangeHelper.parmExchangeRate1(vendInvoiceInfoTable.ExchRate);
            }

            purchPrice = currencyExchangeHelper.calculateTransactionToAccounting(_vendInvoiceLineMap.CurrencyCode, purchPrice, true);

        }

        return purchPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needsPriceDiffPostings</Name>
				<Source><![CDATA[
    private boolean needsPriceDiffPostings(SalesLine _salesLine, VendorInvoiceLineSourceDocLineItem _vendInvoiceSDLineItem, VendInvoiceLineMap _vendInvoiceLineMap)
    {
        boolean ret = false;
        // If sales line is of type item requirement
        if (_salesLine && _salesLine.SalesType == SalesType::ItemReq)
        {
            // And full vendor invoice
            if (_vendInvoiceSDLineItem.parmQuantity() == _salesLine.SalesQty)
            {
                ProjItemTrans itemTrans;

                select firstonly itemTrans
                    where itemTrans.InventTransId == _salesLine.InventTransId;

                PurchPrice purchPriceOnVI = _vendInvoiceLineMap.PurchPrice;
                PurchPrice purchPriceCalculatedFromLineAmount = 0;
                if (_vendInvoiceLineMap.Qty != 0)
                {
                    purchPriceCalculatedFromLineAmount = _vendInvoiceLineMap.LineAmount / _vendInvoiceLineMap.Qty;
                }
                CostPrice costPriceOnTrans = CurrencyExchangeHelper::curAmount(itemTrans.costPrice(), _vendInvoiceLineMap.CurrencyCode, itemTrans.TransDate);

                // And item trans and vendor invoice purch price is different
                if (itemTrans && costPriceOnTrans != purchPriceOnVI && costPriceOnTrans != purchPriceCalculatedFromLineAmount)
                {
                    ret = true;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needsPriceDiffPostingsByPurchPrice</Name>
				<Source><![CDATA[
    private boolean needsPriceDiffPostingsByPurchPrice(SalesLine _salesLine, VendorInvoiceLineSourceDocLineItem _vendInvoiceSDLineItem, 
        VendInvoiceLineMap _vendInvoiceLineMap, PurchPrice _purchPriceMST)
    {
        boolean ret = false;
        // If sales line is of type item requirement
        if (_salesLine && _salesLine.SalesType == SalesType::ItemReq)
        {
            // And full vendor invoice
            if (_vendInvoiceSDLineItem.parmQuantity() == _salesLine.SalesQty)
            {
                ProjItemTrans itemTrans;

                select firstonly itemTrans
                    where itemTrans.InventTransId == _salesLine.InventTransId;

                CostPrice costPriceOnTransMST = itemTrans.costPrice();
                
                // And item trans and vendor invoice purch price is different
                if (itemTrans && costPriceOnTransMST != _purchPriceMST)
                {
                    ret = true;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPriceDiffForPackingSlip</Name>
				<Source><![CDATA[
    private void postPriceDiffForPackingSlip(SalesLine _salesLine, SourceDocumentLine _vendInvoiceSourceDocLine, LedgerVoucher _ledgerVoucher, VendInvoiceLineMap _vendInvoiceLineMap, NumberSequenceCode _voucherSeriesCode)
    {
        AccountingDistribution accountingDistribution;
        select firstonly accountingDistribution where accountingDistribution.SourceDocumentLine == _vendInvoiceSourceDocLine.RecId;

        if (!accountingDistribution)
        {
            return;
        }
        LedgerVoucherObject ledgerVoucherObject = LedgerVoucherObject::newVoucher(
                NumberSeq::newGetVoucherFromCode(_voucherSeriesCode, NumberSeqScopeFactory::createDataAreaScope(), true).voucher(),
                accountingDistribution.AccountingDate,
                SysModule::Project,
                LedgerTransType::Project,
                NoYes::No);

        _ledgerVoucher.addVoucher(ledgerVoucherObject);

        CustPackingSlipTrans packSlip;
        select firstonly packSlip
            where packSlip.SalesId == _salesLine.SalesId
                && packSlip.InventTransId == _salesLine.InventTransId;
            
        ProjItemTrans itemTrans;
        ProjItemTransCost itemTransCost;
        // Post the diff to a proj voucher using same postings as packing slip
        while select itemTrans join itemTransCost
            where itemTransCost.InventTransId == itemTrans.InventTransId
                && itemTransCost.ProjAdjustRefId == itemTrans.ProjAdjustRefId
                && itemTrans.InventTransId == _salesLine.InventTransId
        {
            CostPrice costOnTrans = CurrencyExchangeHelper::curAmount(itemTrans.costPrice(), _vendInvoiceLineMap.CurrencyCode, itemTrans.TransDate);
            if (costOnTrans != _vendInvoiceLineMap.PurchPrice)
            {
                AmountCur PurchPriceWithDiscount = ProjectSourceDocumentLineItemHelper::applyDiscountByRatio(_vendInvoiceLineMap.PurchPrice, _vendInvoiceLineMap.PurchPrice, _vendInvoiceLineMap.discAmount(), _vendInvoiceLineMap.discPercent());

                AmountCur diff = itemTrans.Qty * (PurchPriceWithDiscount - costOnTrans);

                diff = CurrencyExchangeHelper::mstAmount(diff, _vendInvoiceLineMap.CurrencyCode, itemTrans.TransDate);
                
                ProjPostItemPackingSlip_AdjCost projPost = new ProjPostItemPackingSlip_AdjCost(packSlip, itemTrans, itemTransCost, diff);
                projPost.parmLedgerVoucher(_ledgerVoucher);
                projPost.parmFundingSourceList(ProjPost::createSplitList(itemTransCost.FundingSource));
                projPost.parmLedgerOrigin(ProjOrigin::VendorInvoice);
                projPost.parmTransactionOrigin(ProjOrigin::VendorInvoice);
                projPost.parmTransIdOrig(itemTrans.ProjTransId);
                projPost.postCostAdjustment();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPriceDiffForPackingSlipByPurchPrice</Name>
				<Source><![CDATA[
    private void postPriceDiffForPackingSlipByPurchPrice(SalesLine _salesLine, SourceDocumentLine _vendInvoiceSourceDocLine, 
        LedgerVoucher _ledgerVoucher, PurchPrice _purchPriceMST, NumberSequenceCode _voucherSeriesCode)
    {
        AccountingDistribution accountingDistribution;
        select firstonly accountingDistribution where accountingDistribution.SourceDocumentLine == _vendInvoiceSourceDocLine.RecId;

        if (!accountingDistribution)
        {
            return;
        }
        LedgerVoucherObject ledgerVoucherObject = LedgerVoucherObject::newVoucher(
                NumberSeq::newGetVoucherFromCode(_voucherSeriesCode, NumberSeqScopeFactory::createDataAreaScope(), true).voucher(),
                accountingDistribution.AccountingDate,
                SysModule::Project,
                LedgerTransType::Project,
                NoYes::No);

        _ledgerVoucher.addVoucher(ledgerVoucherObject);

        CustPackingSlipTrans packSlip;
        select firstonly packSlip
            where packSlip.SalesId == _salesLine.SalesId
                && packSlip.InventTransId == _salesLine.InventTransId;
            
        ProjItemTrans itemTrans;
        ProjItemTransCost itemTransCost;
        // Post the diff to a proj voucher using same postings as packing slip
        while select itemTrans join itemTransCost
            where itemTransCost.InventTransId == itemTrans.InventTransId
                && itemTransCost.ProjAdjustRefId == itemTrans.ProjAdjustRefId
                && itemTrans.InventTransId == _salesLine.InventTransId
        {
            CostPrice costOnTrans = itemTrans.costPrice();
            if (costOnTrans != _purchPriceMST)
            {
                AmountCur diff = itemTrans.Qty * (_purchPriceMST - costOnTrans);

                ProjPostItemPackingSlip_AdjCost projPost = new ProjPostItemPackingSlip_AdjCost(packSlip, itemTrans, itemTransCost, diff);
                projPost.parmLedgerVoucher(_ledgerVoucher);
                projPost.parmFundingSourceList(ProjPost::createSplitList(itemTransCost.FundingSource));
                projPost.parmLedgerOrigin(ProjOrigin::VendorInvoice);
                projPost.parmTransactionOrigin(ProjOrigin::VendorInvoice);
                projPost.parmTransIdOrig(itemTrans.ProjTransId);
                projPost.postCostAdjustment();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>subscribe</Name>
				<Source><![CDATA[
    /// <summary>
    /// Subscribes to subledger journalizer events.
    /// </summary>
    protected void subscribe()
    {
        SubledgerJournalizer localSubledgerJournalizer;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            localSubledgerJournalizer = this.parmSubledgerJournalizer();
            localSubledgerJournalizer.shouldCreateRelievingSubledgerJournalEntryDelegate += eventhandler(this.shouldCreateRelievingSubledgerJournalEntryDelegateHandler);
            localSubledgerJournalizer.journalizedEventHandler += eventhandler(this.journalized);
        }

        if (!localSubledgerJournalizer
            && isConfigurationkeyEnabled(configurationKeyNum(BudgetReservation_PSN)))
        {
            localSubledgerJournalizer = this.parmSubledgerJournalizer();
            localSubledgerJournalizer.shouldCreateRelievingSubledgerJournalEntryDelegate += eventhandler(this.shouldCreateRelievingSubledgerJournalEntryDelegateHandler);
            
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreateRelievingSubledgerJournalEntryDelegateHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// An <c>AccountingDistributionTmp</c> record creation event handler delegate. It will be raised before the relieving accounting
    /// distribution tmp record is created to check if it is needed to be created or not.
    /// </summary>
    /// <param name = "_eventHandlerResult">
    /// The event handler result which contains result value from the delegate handler.
    /// </param>
    /// <param name = "_ledgerPostingType">
    /// The subledger posting type for the accounting distribution tmp record.
    /// </param>
    /// <param name = "_subledgerJournalAccountEntryRecId">
    /// The record ID of the <c>SubledgerJournalAccountEntryDistribution</c> table to be relieved.
    /// </param>
    /// <param name = "_businessEvent">
    /// The business event of the source document for the accounting distribution tmp record.
    /// </param>
    /// <remarks>
    /// The event handler result will be set to false while releasing the retention without invoice quantity for a purchase order.
    /// There would be no need to create subledger journal entry for Purchase order while invoicing only the Release amount.
    /// </remarks>
    internal void shouldCreateRelievingSubledgerJournalEntryDelegateHandler(EventHandlerResult _eventHandlerResult,
        LedgerPostingType _ledgerPostingType,
        SubledgerJournalAccountEntryRecId _subledgerJournalAccountEntryRecId,
        BusinessEvent _businessEvent)
    {
        boolean ret = true;
        
        if (_ledgerPostingType == LedgerPostingType::PurchOrder && FeatureStateProvider::isFeatureEnabled(ProjReleaseVendorRetentionSeperatelyForEncumbranceFlight::instance()))
        {
            SubledgerJournalAccountEntryDistribution subledgerJournalAccountEntryDistribution;

            select firstonly RecId, AccountingDistribution, SourceDocumentLine from subledgerJournalAccountEntryDistribution
                where subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry == _subledgerJournalAccountEntryRecId;

            if (subledgerJournalAccountEntryDistribution.RecId)
            {
                ProjOpsManagementLogger logger = ProjOpsManagementLogger::createLogger(classStr(SubledgerJournalizerProjectExtension));

                using (var activityContext = logger.projOpsManagementActivity().projReleaseVendorRetentionContext())
                {
                    PurchLine purchLine;
                    VendInvoiceInfoLine vendInvoiceInfoLine;

                    select firstonly RecId, PSAReleaseAmount from vendInvoiceInfoLine
                        where vendInvoiceInfoLine.PSAReleasePercent == 100
                            && vendInvoiceInfoLine.PSAReleaseAmount != 0
                            || vendInvoiceInfoLine.LineAmount == 0
                        join RecId, PurchId, ProjId from purchLine
                            where purchLine.SourceDocumentLine == subledgerJournalAccountEntryDistribution.SourceDocumentLine
                                && purchLine.PurchId == vendInvoiceInfoLine.OrigPurchId
                                && purchLine.ProjId != ''
                                && purchLine.PSARetainScheduleId != '';

                    if (vendInvoiceInfoLine.RecId
                        && (!_eventHandlerResult.hasResult()
                            || _eventHandlerResult.booleanResult() != false))
                    {
                        _eventHandlerResult.booleanResult(false);
                    }

                    logger.logInformation(strFmt('PurchId: %1, ProjId: %2, VendInvoiceInfoLine: %3, PSAReleaseAmount: %4',
                        purchLine.PurchId, purchLine.ProjId, vendInvoiceInfoLine.RecId, vendInvoiceInfoLine.PSAReleaseAmount));
                }
            }
        }
        else if (isConfigurationkeyEnabled(configurationKeyNum(BudgetReservation_PSN))
            && (_ledgerPostingType == LedgerPostingType::BudgetReservation_PSN))
        {
            ret = SubledgerJournalizerBudgetReservationExtension_PSN::shouldCreateGBRRelievingSubledgerJournalEntry(
                _ledgerPostingType,
                _subledgerJournalAccountEntryRecId,
                _businessEvent);

            if (!_eventHandlerResult.hasResult() || _eventHandlerResult.booleanResult() != ret)
            {
                _eventHandlerResult.booleanResult(ret);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInvoiceProposal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an invoice proposal for transactions that originate from the business document.
    /// </summary>
    /// <param name="_projectActualHeaderList">
    /// A list of project actual header records.
    /// </param>
    /// <returns>
    /// A list that contains project proposal IDs.
    /// </returns>
    private static List createInvoiceProposal(List _projectActualHeaderList)
    {
        List                                  proposalIdList;
        ListEnumerator                        le = _projectActualHeaderList.getEnumerator();
        Common                                common;
        ProjInvoiceProposalCreateLinesInit    createLinesInit;
        PSATmpProjProposalTrans               tmpProjProposalTrans;
        PSATmpProjProposalTrans               tmpProjProposalTransCreate;
        ProjInvoiceProposalCreateLines        createLines;
        ProjInvoiceProposalCreateLinesParams  createLinesParams;
        ProjInvoiceProposalInsertLines        insertLines;

        void fetchData()
        {
            tmpProjProposalTrans = createLinesInit.getProposalTransCreate();

            while select tmpProjProposalTrans
            {
                tmpProjProposalTransCreate.data(tmpProjProposalTrans);
                tmpProjProposalTransCreate.insert();
            }
        }

        while (le.moveNext())
        {
            common = le.current();

            createLinesInit = new ProjInvoiceProposalCreateLinesInit();

            switch (common.TableId)
            {
                case tableNum(ProjCostTrans) :
                    createLinesInit.initCost(common, 0);
                    break;

                case tableNum(ProjEmplTrans) :
                    createLinesInit.initEmpl(common, 0);
                    break;

                case tableNum(ProjItemTrans) :
                    createLinesInit.initItem(common, 0);
                    break;

                case tableNum(ProjRevenueTrans) :
                    createLinesInit.initRevenue(common, 0);
                    break;
            }

            fetchData();
        }

        if (tmpProjProposalTransCreate)
        {
            createLinesParams = ProjInvoiceProposalCreateLinesParams::construct();
            createLinesParams.parmInvoiceDate(tmpProjProposalTransCreate.TransDate);

            createLines = ProjInvoiceProposalCreateLines::newStandard(createLinesParams.pack());
            createLines.parmProposalTransCreate(tmpProjProposalTransCreate);

            insertLines = new ProjInvoiceProposalInsertLines(createLines, false);
            insertLines.parmShowMessages(false);
            insertLines.runOperation();

            proposalIdList = insertLines.getProposalIdList();
        }

        return proposalIdList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateProjTransPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates a <c>ProjTransPosting</c> record.
    /// </summary>
    /// <param name="_projectRevenueHeader">A project actual header record.</param>
    /// <param name="_projectActualDetail">A project actual detail record.</param>
    /// <param name="_projectActualHeaderContainer">A container that contains the project actual header values.</param>
    /// <param name="_projectActualDetailContainer">A container that contains the project actual detail values.</param>
    /// <param name="_actualLedgerUpdateContainer">A container that contains the actual ledger update values.</param>
    /// <param name="_voucher">The voucher number.</param>
    /// <param name="_canProcessInvoice">true if project transactions are invoiced during journalization; otherwise, false.</param>
    /// <param name = "_projTransId">The transaction ID.</param>
    /// <param name = "_sourceDocumentLineItem">A source document line item.</param>
    /// <param name = "_projCostSales">The amount type.</param>
    /// <param name = "_projAdjustRefId">The adjustment number.</param>
    /// <param name = "_ledgerTransDate">The ledger transaction date.</param>
    /// <returns>A <c>ProjTransPosting record.</c></returns>
    protected static ProjTransPosting populateProjTransPosting(
        Common                              _projectRevenueHeader,
        Common                              _projectActualDetail,
        container                           _projectActualHeaderContainer,
        container                           _projectActualDetailContainer,
        container                           _actualLedgerUpdateContainer,
        Voucher                             _voucher,
        boolean                             _canProcessInvoice,
        ProjTransIdBase                     _projTransId,
        SourceDocumentLineItem              _sourceDocumentLineItem,
        ProjCostSales                       _projCostSales,
        ProjAdjustRefId                     _projAdjustRefId,
        TransDate                           _ledgerTransDate)
    {
        #declareProjectActualHeaderContainerVariablesMacro
        #declareActualLedgerUpdateContainerVariablesMacro

        ProjFundingSourceRefId                  actualFundingSource;
        ProjTransPosting                        projTransPosting;
        ProjLedgerUpdate                        projLedgerUpdate = new ProjLedgerUpdate();
        SourceDocumentLineItemIProjectTransDate iProjectTransDate;
        SourceDocumentLineItemIProject          sourceDocumentLineItemIProject;
        SourceDocumentLineItemIProduct          sourceDocumentLineItemIProduct;
        SourceDocumentLineItemIInventory        sourceDocumentLineItemIInventory;

        #projectActualHeaderContainerMacro  = _projectActualHeaderContainer;
        #actualLedgerUpdateContainerMacro   = _actualLedgerUpdateContainer;

        sourceDocumentLineItemIProject = _sourceDocumentLineItem as SourceDocumentLineItemIProject;
        if (_sourceDocumentLineItem is SourceDocumentLineItemIProduct)
        {
            sourceDocumentLineItemIProduct = _sourceDocumentLineItem as SourceDocumentLineItemIProduct;
        }
        if (_sourceDocumentLineItem is SourceDocumentLineItemIInventory)
        {
            sourceDocumentLineItemIInventory = _sourceDocumentLineItem as SourceDocumentLineItemIInventory;
        }

        projTransPosting.TransId = _projTransId;
        if (sourceDocumentLineItemIInventory)
        {
            projTransPosting.InventTransId = sourceDocumentLineItemIInventory.parmLotId();
        }
        projTransPosting.ProjAdjustRefId = _projAdjustRefId;
        projTransPosting.TransactionOrigin = ProjectSourceDocumentLineItemHelper::projOrigin(_sourceDocumentLineItem);
        projTransPosting.ProjTransDate = _sourceDocumentLineItem.parmAccountingDate();

        if (_sourceDocumentLineItem is SourceDocumentLineItemIProjectTransDate)
        {
            iProjectTransDate = _sourceDocumentLineItem as SourceDocumentLineItemIProjectTransDate;
            projTransPosting.ProjTransDate = iProjectTransDate.parmProjTransDate();
        }

        projTransPosting.ProjId = actualProjectId;
        projTransPosting.ProjType = ProjTable::find(projTransPosting.ProjId).Type;
        projTransPosting.ActivityNumber = actualActivityNumber;
        projTransPosting.CategoryId = actualCategoryId;
        projTransPosting.ProjTransType = ProjectSourceDocumentLineItemHelper::projTransType(_sourceDocumentLineItem);
        projTransPosting.Resource = sourceDocumentLineItemIProject.parmProjectResourceRecId();
        projTransPosting.ResourceCategory = sourceDocumentLineItemIProject.parmProjectResourceCategoryRecId();
        if (sourceDocumentLineItemIProduct)
        {
            projTransPosting.EmplItemId = sourceDocumentLineItemIProduct.parmItemId();
        }
        projTransPosting.SubscriptionId = '';
        projTransPosting.Qty = actualLedgerUpdateQuantity;
        projTransPosting.CostSales = _projCostSales;
        projTransPosting.ProjFundingSource = actualFundingSource;
        projTransPosting.LedgerOrigin = ProjectSourceDocumentLineItemHelper::projOrigin(_sourceDocumentLineItem);
        projTransPosting.LedgerTransDate = _ledgerTransDate;
        projTransPosting.Voucher = _voucher;
        projTransPosting.PostingType = actualLedgerUpdatePostingType;
        projTransPosting.LedgerDimension = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(actualLedgerUpdateLedgerDimension);
        projTransPosting.DefaultDimension = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(actualLedgerUpdateLedgerDimension);
        projTransPosting.AmountMst = actualLedgerUpdateAccountingCurrencyAmount;

        if (projTransPosting.AmountMst < 0)
        {
            if (projTransPosting.Qty > 0)
            {
                projTransPosting.Qty = -projTransPosting.Qty;
            }
        }
        else if (projTransPosting.AmountMst > 0)
        {
            if (projTransPosting.Qty < 0)
            {
                projTransPosting.Qty = -projTransPosting.Qty;
            }
        }

        if (projTransPosting.DefaultDimension == 0
            && LedgerParameters::dimensionValuesUsedForSummaryAccount() == DimensionValuesToUseForSummaryAccount::SourceDocument
                && (_sourceDocumentLineItem is SourceDocumentLineItemITimesheets
                    || _sourceDocumentLineItem is ProjAdvancedJournalSourceDocumentLineItem))
        {
            projTransPosting.DefaultDimension = _sourceDocumentLineItem.parmDefaultDimension();
        }

        if (_canProcessInvoice)
        {
            projTransPosting.PaymentStatus = ProjPaymentStatus::Paid;
            projLedgerUpdate.setPaymentDatePaid(projTransPosting);
        }
        else
        {
            projLedgerUpdate.setPaymentDateStatus(projTransPosting);
        }
        return projTransPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerUpdates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>ProjTransPosting</c> records.
    /// </summary>
    /// <param name="_projectRevenueHeader">
    /// A project actual header record.
    /// </param>
    /// <param name="_projectActualDetail">
    /// A project actual detail record.
    /// </param>
    /// <param name="_projectActualHeaderContainer">
    /// A container that contains the project actual header values.
    /// </param>
    /// <param name="_projectActualDetailContainer">
    /// A container that contains the project actual detail values.
    /// </param>
    /// <param name="_packedActualLedgerUpdate">
    /// A container that contains the ledger update values that will be used to create the
    /// <c>ProjTransPosting</c> records.
    /// </param>
    /// <param name="_voucher">
    /// The voucher number.
    /// </param>
    /// <param name="_canProcessInvoice">
    /// Denotes whether project transactions are invoiced during journalization.
    /// </param>
    protected static void createLedgerUpdates(
        Common                  _projectRevenueHeader,
        Common                  _projectActualDetail,
        container               _projectActualHeaderContainer,
        container               _projectActualDetailContainer,
        container               _packedActualLedgerUpdate,
        Voucher                 _voucher,
        boolean                 _canProcessInvoice)
    {
        #declareProjectActualHeaderContainerVariablesMacro
        #declareProjectActualDetailContainerVariablesMacro
        #declareActualLedgerUpdateContainerVariablesMacro

        ListEnumerator                      actualLedgerUpdateEnumerator;
        SourceDocumentLineItem              sourceDocumentLineItem;

        ProjCostTrans                       projCostTrans;
        ProjCostTransCost                   projCostTransCost;
        ProjCostTransSale                   projCostTransSale;
        ProjItemTrans                       projItemTrans;
        ProjItemTransCost                   projItemTransCost;
        ProjItemTransSale                   projItemTransSale;
        ProjRevenueTrans                    projRevenueTrans;
        ProjRevenueTransSale                projRevenueTransSale;

        ProjTransIdBase                     projTransId;
        ProjCostSales                       projCostSales;
        ProjAdjustRefId                     projAdjustRefId;
        TransDate                           ledgerTransDate;

        ProjEmplTrans                       projEmplTrans;
        ProjEmplTransCost                   projEmplTransCost;
        ProjEmplTransSale                   projEmplTransSale;

        #clearProjectActualDetailContainerMacro
        #projectActualHeaderContainerMacro = _projectActualHeaderContainer;
        #projectActualDetailContainerMacro = _projectActualDetailContainer;
        sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(actualSourceDocumentLine));

        switch (_projectRevenueHeader.TableId)
        {
            case tableNum(ProjCostTrans):
                projCostTrans = _projectRevenueHeader;
                projTransId = projCostTrans.TransId;
                break;
            case tableNum(ProjItemTrans):
                projItemTrans = _projectRevenueHeader;
                projTransId = projItemTrans.ProjTransId;
                projAdjustRefId = projItemTrans.ProjAdjustRefId;
                break;
            case tableNum(ProjRevenueTrans):
                projRevenueTrans = _projectRevenueHeader;
                projTransId = projRevenueTrans.TransId;
                break;

            case tableNum(ProjEmplTrans):
                // If this condition fails, the SYS logic needs to fall to default so this should be the last case before default
                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                || isConfigurationkeyEnabled(configurationKeyNum(Project))
                || isConfigurationkeyEnabled(configurationKeyNum(PayrollAdministration))
                )
                {
                    projEmplTrans = _projectRevenueHeader;
                    projTransId = projEmplTrans.TransId;
                    break;
                }
            default:
                throw error(strFmt("@SYS22828",funcName()));
        }

        switch (_projectActualDetail.TableId)
        {
            case tableNum(ProjCostTransCost):
                projCostSales = ProjCostSales::Cost;
                projCostTransCost = _projectActualDetail;
                ledgerTransDate = projCostTransCost.LedgerTransdate;
                break;
            case tableNum(ProjItemTransCost):
                projCostSales = ProjCostSales::Cost;
                projItemTransCost = _projectActualDetail;
                ledgerTransDate = projItemTransCost.LedgerTransdate;
                break;
            case tableNum(ProjCostTransSale):
                projCostSales = ProjCostSales::Sales;
                projCostTransSale = _projectActualDetail;
                ledgerTransDate = projCostTransSale.LedgerTransdate;
                break;
            case tableNum(ProjItemTransSale):
                projCostSales = ProjCostSales::Sales;
                projItemTransSale = _projectActualDetail;
                ledgerTransDate = projItemTransSale.LedgerTransdate;
                break;
            case tableNum(ProjRevenueTransSale):
                projCostSales = ProjCostSales::Sales;
                projRevenueTransSale = _projectActualDetail;
                ledgerTransDate = projRevenueTransSale.LedgerTransdate;
                break;

            case tableNum(ProjEmplTransCost):
            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                || isConfigurationkeyEnabled(configurationKeyNum(Project))
                || isConfigurationkeyEnabled(configurationKeyNum(PayrollAdministration))
                )
                {
                    projCostSales = ProjCostSales::Cost;
                    projEmplTransCost = _projectActualDetail;
                    ledgerTransDate = projEmplTransCost.LedgerTransdate;
                    break;
                }
            case tableNum(ProjEmplTransSale):
            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                || isConfigurationkeyEnabled(configurationKeyNum(Project))
                || isConfigurationkeyEnabled(configurationKeyNum(PayrollAdministration))
                )
                {
                    projCostSales = ProjCostSales::Sales;
                    projEmplTransSale = _projectActualDetail;
                    ledgerTransDate = projEmplTransSale.LedgerTransdate;
                    break;
                }

            default:
                throw error(strFmt("@SYS22828",funcName()));
        }

        actualLedgerUpdate = List::create(_packedActualLedgerUpdate);
        actualLedgerUpdateEnumerator = actualLedgerUpdate.getEnumerator();
        while (actualLedgerUpdateEnumerator.moveNext())
        {
            ProjTransPosting projTransPosting = SubledgerJournalizerProjectExtension::populateProjTransPosting(
                _projectRevenueHeader,
                _projectActualDetail,
                _projectActualHeaderContainer,
                _projectActualDetailContainer,
                actualLedgerUpdateEnumerator.current(),
                _voucher,
                _canProcessInvoice,
                projTransId,
                sourceDocumentLineItem,
                projCostSales,
                projAdjustRefId,
                ledgerTransDate);

            projTransPosting.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjectActualCostDetail</Name>
				<Source><![CDATA[
    protected static Common createProjectActualCostDetail(
        Common _projectRevenueHeader,
        container _projectActualHeaderContainer,
        container _projectActualDetailContainer,
        Voucher _voucher)

    {
        #declareProjectActualHeaderContainerVariablesMacro
        #declareProjectActualDetailContainerVariablesMacro
        #declareActualLedgerUpdateContainerVariablesMacro

        SourceDocumentLineItem  sourceDocumentLineItem;
        ProjLedgerStatus costLedgerStatus;
        Common projectActualDetail;
        RefRecId localFundingSource;

        PriceCur transactionCurrencyPrice()
        {
            PriceCur ret;

            if (actualQuantity)
            {
                ret = CurrencyExchangeHelper::price(actualTransactionCurrencyAmount / actualQuantity, actualTransactionCostCurrency);
            }

            return ret;
        }

        Price accountingCurrencyPrice()
        {
            Price ret;

            if (actualQuantity)
            {
                ret = CurrencyExchangeHelper::price(actualAccountingCurrencyAmount / actualQuantity, accountingCurrency);
            }

            return ret;
        }

        ProjCostTransCost createProjCostTransCost()
        {
            ProjCostTransCost projCostTransCost;
            container projCostTransContainer;
           
            projCostTransCost.clear();
            projCostTransCost = SubledgerJournalizerProjectExtension::initializeProjCostTransCost(_projectRevenueHeader, costLedgerStatus, #projectActualHeaderContainerMacro, #projectActualDetailContainerMacro);
            projCostTransCost.insert();

            return projCostTransCost;
        }

        ProjEmplTransCost createProjEmplTransCost()
        {
            ProjEmplTransCost   projEmplTransCost;

            projEmplTransCost.clear();
            projEmplTransCost = SubledgerJournalizerProjectExtension::initializeProjEmplTransCost(_projectRevenueHeader, costLedgerStatus, accountingCurrencyPrice(), #projectActualHeaderContainerMacro, #projectActualDetailContainerMacro);
            projEmplTransCost.insert();

            return projEmplTransCost;
        }

        ProjItemTransCost createProjItemTransCost()
        {
            ProjItemTransCost   projItemTransCost;

            projItemTransCost.clear();
            projItemTransCost = subledgerJournalizerProjectExtension::initializeProjItemTransCost(_projectRevenueHeader, costLedgerStatus, _voucher ,#projectActualHeaderContainerMacro, #projectActualDetailContainerMacro);
            projItemTransCost.insert();

            return projItemTransCost;
        }

        #clearProjectActualDetailContainerMacro

        #projectActualHeaderContainerMacro = _projectActualHeaderContainer;
        sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(actualSourceDocumentLine));

        #projectActualDetailContainerMacro = _projectActualDetailContainer;

        localFundingSource = actualFundingSource;

        //Identify the cost ledger status based on Project details.
        costLedgerStatus = SubledgerJournalizerProjectExtension::getCostLedgerStatus(_projectRevenueHeader, _projectActualHeaderContainer, _projectActualDetailContainer, packedActualReferenceProjectAccountingDistribution);
        
        // the actual funding source might have been changed when getCostLedgerStatus was called
        actualFundingSource = localFundingSource;

        switch (_projectRevenueHeader.TableId)
        {
            case tableNum(ProjCostTrans):
                projectActualDetail = createProjCostTransCost();
                break;

            case tableNum(ProjItemTrans):
                projectActualDetail = createProjItemTransCost();
                break;

            case tableNum(ProjRevenueTrans):
                break;

            case tableNum(ProjEmplTrans):
                projectActualDetail = createProjEmplTransCost();
                break;

            default:
                throw error(strFmt("@SYS22828",funcName()));
        }

        actualReferenceProjectAccountingDistribution = null;
        if (projectActualDetail)
        {
            SubledgerJournalizerProjectExtension::updateProjectAccountingDistributions(projectActualDetail, packedActualReferenceProjectAccountingDistribution);
            SubledgerJournalizerProjectExtension::createLedgerUpdates(_projectRevenueHeader, projectActualDetail, _projectActualHeaderContainer, _projectActualDetailContainer, packedActualLedgerUpdate, _voucher, false);
        }

        return projectActualDetail;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCostLedgerStatus</Name>
				<Source><![CDATA[
    protected static ProjLedgerStatus getCostLedgerStatus(Common _projectRevenueHeader,
        container _projectActualHeaderContainer, 
        container _projectActualDetailContainer,
        container _packedActualReferenceProjectAccountingDistribution)
    {
        // _projectRevenueHeader (Project actual header record) parameter is used in the SubLedgerJournalizerProjectExtensionSubBillDeferral_Extension class to identify the transaction type using the tableId property.

        #declareProjectActualHeaderContainerVariablesMacro
        #declareProjectActualDetailContainerVariablesMacro
        #declareActualLedgerUpdateContainerVariablesMacro

        #projectActualHeaderContainerMacro = _projectActualHeaderContainer;
        #projectActualDetailContainerMacro = _projectActualDetailContainer;
        
        ProjLedgerStatus costLedgerStatus = ProjLedgerStatus::Operations;
        
        actualLedgerUpdate = List::create(packedActualLedgerUpdate);
        ListEnumerator actualLedgerUpdateEnumerator = actualLedgerUpdate.getEnumerator();
        while (actualLedgerUpdateEnumerator.moveNext())
        {
            #actualLedgerUpdateContainerMacro = actualLedgerUpdateEnumerator.current();
            if (actualLedgerUpdatePostingType == LedgerPostingType::ProjWIPCostvalue ||
                    actualLedgerUpdatePostingType == LedgerPostingType::ProjStatusAccountItem)
            {
                costLedgerStatus = ProjLedgerStatus::BalanceSheet;
                break;
            }
        }

        costLedgerStatus = SubledgerJournalizerProjectExtension::setProjOpsNoNeverLedgerStatus(actualSourceDocumentLine, costLedgerStatus);

        return costLedgerStatus;
            
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProjOpsNoNeverLedgerStatus</Name>
				<Source><![CDATA[
    private static ProjLedgerStatus setProjOpsNoNeverLedgerStatus(SourceDocumentLineRecId _actualSourceDocumentLine, ProjLedgerStatus _costLedgerStatus)
    {
        ProjLedgerStatus costLedgerStatus = _costLedgerStatus;
        if (_actualSourceDocumentLine && ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
        {
            ProjAdvancedJournalLine projAdvancedJrnLine = ProjAdvancedJournalLine::findBySourceDocumentLine(_actualSourceDocumentLine);
            if (projAdvancedJrnLine && projAdvancedJrnLine.shouldProcessSubcontractLineAsNeverLedger())
            {
                costLedgerStatus = ProjLedgerStatus::Never;
            }
            else if (projAdvancedJrnLine
                && projAdvancedJrnLine.ContractLineId
                && projAdvancedJrnLine.TransType == ProjTransType::Hour)
            {
                PsaContractLineItems contractLine = PSAContractLineItems::find(projAdvancedJrnLine.ContractLineId);
                ProjTable projTable = projTable::findByDataArea(projAdvancedJrnLine.ProjId, projAdvancedJrnLine.ProjDataAreaId);
                if (projTable && contractLine)
                {
                    ProjLedgerStatus projLedgerStatus = ProjRevRecHelper::getRevProfileV2(projTable, contractLine, true).EmplLedgerStatus;
                    if (projLedgerStatus == ProjLedgerStatus::Never
                        || projLedgerStatus == ProjLedgerStatus::None)
                    {
                        costLedgerStatus = projLedgerStatus;
                    }
                }
            }
        }

        return costLedgerStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjectActualCostDetailV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the project actual detail records only for journal lines that were submitted.
    /// </summary>
    /// <param name="_projectRevenueHeader">
    /// A project actual header record.
    /// </param>
    /// <param name="_projectActualHeaderContainer">
    /// A container that contains the project actual header values.
    /// </param>
    /// <param name="_projectActualDetailContainer">
    /// A container that contains the project actual detail values.
    /// </param>
    /// <param name="_voucher">
    /// The voucher number.
    /// </param>
    /// <returns>
    /// A project actual detail record.
    /// </returns>
    protected Common createProjectActualCostDetailV2(
        Common _projectRevenueHeader,
        container _projectActualHeaderContainer,
        container _projectActualDetailContainer,
        Voucher _voucher)

    {
        #declareProjectActualHeaderContainerVariablesMacro
        #declareProjectActualDetailContainerVariablesMacro
        #declareActualLedgerUpdateContainerVariablesMacro

        SourceDocumentLineItem  sourceDocumentLineItem;
        ProjLedgerStatus costLedgerStatus;
        Common projectActualDetail;
        RefRecId localFundingSource;

        PriceCur transactionCurrencyPrice()
        {
            PriceCur ret;

            if (actualQuantity)
            {
                ret = CurrencyExchangeHelper::price(actualTransactionCurrencyAmount / actualQuantity, actualTransactionCostCurrency);
            }

            return ret;
        }

        Price accountingCurrencyPrice()
        {
            Price ret;

            if (actualQuantity)
            {
                ret = CurrencyExchangeHelper::price(actualAccountingCurrencyAmount / actualQuantity, accountingCurrency);
            }

            return ret;
        }

        ProjCostTransCost createProjCostTransCost()
        {
            ProjCostTransCost projCostTransCost;
            container projCostTransContainer;
           
            projCostTransCost.clear();
            projCostTransCost = SubledgerJournalizerProjectExtension::initializeProjCostTransCost(_projectRevenueHeader, costLedgerStatus, #projectActualHeaderContainerMacro, #projectActualDetailContainerMacro);
            projCostTransCost.insert();

            return projCostTransCost;
        }

        ProjEmplTransCost createProjEmplTransCost()
        {
            ProjEmplTransCost   projEmplTransCost;

            projEmplTransCost.clear();
            projEmplTransCost = SubledgerJournalizerProjectExtension::initializeProjEmplTransCost(_projectRevenueHeader, costLedgerStatus, accountingCurrencyPrice(), #projectActualHeaderContainerMacro, #projectActualDetailContainerMacro);
            projEmplTransCost.insert();

            return projEmplTransCost;
        }

        ProjItemTransCost createProjItemTransCost()
        {
            ProjItemTransCost   projItemTransCost;

            projItemTransCost.clear();
            projItemTransCost = subledgerJournalizerProjectExtension::initializeProjItemTransCost(_projectRevenueHeader, costLedgerStatus, _voucher ,#projectActualHeaderContainerMacro, #projectActualDetailContainerMacro);
            projItemTransCost.insert();

            return projItemTransCost;
        }

        #clearProjectActualDetailContainerMacro

        #projectActualHeaderContainerMacro = _projectActualHeaderContainer;
        sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(actualSourceDocumentLine));

        #projectActualDetailContainerMacro = _projectActualDetailContainer;

        localFundingSource = actualFundingSource;

        //Identify the cost ledger status based on Project details.
        costLedgerStatus = SubledgerJournalizerProjectExtension::getCostLedgerStatus(_projectRevenueHeader, _projectActualHeaderContainer, _projectActualDetailContainer, packedActualReferenceProjectAccountingDistribution);
        
        // the actual funding source might have been changed when getCostLedgerStatus was called
        actualFundingSource = localFundingSource;

        switch (_projectRevenueHeader.TableId)
        {
            case tableNum(ProjCostTrans):
                projectActualDetail = createProjCostTransCost();
                break;

            case tableNum(ProjItemTrans):
                projectActualDetail = createProjItemTransCost();
                break;

            case tableNum(ProjRevenueTrans):
                break;

            case tableNum(ProjEmplTrans):
                projectActualDetail = createProjEmplTransCost();
                break;

            default:
                throw error(strFmt("@SYS22828",funcName()));
        }

        actualReferenceProjectAccountingDistribution = null;
        if (projectActualDetail)
        {
            this.updateProjectAccountingDistributionsV2(projectActualDetail, packedActualReferenceProjectAccountingDistribution);
            SubledgerJournalizerProjectExtension::createLedgerUpdates(_projectRevenueHeader, projectActualDetail, _projectActualHeaderContainer, _projectActualDetailContainer, packedActualLedgerUpdate, _voucher, false);
        }

        return projectActualDetail;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjCostTransCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes values to <c>ProjCostTransCost</c> table buffer.
    /// </summary>
    /// <param name = "_projectRevenueHeader">
    /// A project actual header record.
    /// </param>
    /// <param name = "_costLedgerStatus">
    /// The Ledger status.
    /// </param>
    /// <param name="_projectActualHeaderContainer">
    /// A container that contains the project actual header values.
    /// </param>
    /// <param name="_projectActualDetailContainer">
    /// A container that contains the project actual detail values.
    /// </param>
    /// <returns>
    /// The buffer of <c>ProjCostTransCost</c> table.
    /// </returns>
    protected static ProjCostTransCost initializeProjCostTransCost(Common _projectRevenueHeader, ProjLedgerStatus _costLedgerStatus, container _projectActualHeaderContainer, container _projectActualDetailContainer)
    {
        #declareProjectActualHeaderContainerVariablesMacro
        #declareProjectActualDetailContainerVariablesMacro

        ProjCostTransCost   projCostTransCost;

        #projectActualHeaderContainerMacro = _projectActualHeaderContainer;

        #projectActualDetailContainerMacro = _projectActualDetailContainer;

        CostPrice costPrice = actualQuantity ? actualAccountingCurrencyAmount / actualQuantity : actualAccountingCurrencyAmount;

        CostPrice costPriceCurrency = actualQuantity ? actualTransactionCurrencyAmount/ actualQuantity : actualTransactionCurrencyAmount;

        ProjCostTrans projCostTrans = _projectRevenueHeader;

        projCostTransCost.TransId = projCostTrans.TransId;

        SourceDocumentLineItem  sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(actualSourceDocumentLine));

        projCostTransCost.LedgerTransdate = sourceDocumentLineItem.parmAccountingDate();
        projCostTransCost.TransStatus = ProjTransStatus::Posted;
        projCostTransCost.LedgerStatusCost = _costLedgerStatus;
        projCostTransCost.wipPeriod = dateNull();

        projCostTransCost.FundingSource = actualFundingSource;
        projCostTransCost.DefaultDimension = actualDetailDefaultDimension ? actualDetailDefaultDimension: projCostTrans.DefaultDimension;
        projCostTransCost.LineAmount = actualTransactionCurrencyAmount;

        projCostTransCost.CostPrice = costPrice;
        projCostTransCost.CostPriceCurrency = costPriceCurrency;
        projCostTransCost.CostAmountLedger = actualAccountingCurrencyAmount;

        return projCostTransCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjItemTransCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes values to <c>ProjItemTransCost</c> table buffer.
    /// </summary>
    /// <param name = "_projectRevenueHeader">
    /// A project actual header record.
    /// </param>
    /// <param name = "_costLedgerStatus">
    /// The Ledger status.
    /// </param>
    /// <param name = "_voucher">
    /// The voucher number.
    /// </param>
    /// <param name="_projectActualHeaderContainer">
    /// A container that contains the project actual header values.
    /// </param>
    /// <param name="_projectActualDetailContainer">
    /// A container that contains the project actual detail values.
    /// </param>
    /// <returns>
    /// The buffer of <c>ProjItemTransCost</c> table.
    /// </returns>
    protected static ProjItemTransCost initializeProjItemTransCost(Common _projectRevenueHeader, ProjLedgerStatus _costLedgerStatus, Voucher _voucher, container _projectActualHeaderContainer, container _projectActualDetailContainer)
    {
        #declareProjectActualHeaderContainerVariablesMacro
        #declareProjectActualDetailContainerVariablesMacro

        ProjItemTransCost   projItemTransCost;

        #projectActualHeaderContainerMacro = _projectActualHeaderContainer;

        #projectActualDetailContainerMacro = _projectActualDetailContainer;

        ProjItemTrans projItemTrans = _projectRevenueHeader;

        projItemTransCost.InventTransId = projItemTrans.InventTransId;
        projItemTransCost.ProjAdjustRefId = projItemTrans.ProjAdjustRefId;

        SourceDocumentLineItem  sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(actualSourceDocumentLine));

        projItemTransCost.LedgerTransdate = sourceDocumentLineItem.parmAccountingDate();
        projItemTransCost.TransStatus = ProjTransStatus::Posted;
        projItemTransCost.LedgerStatusCost = _costLedgerStatus;
        projItemTransCost.wipPeriod = dateNull();

        projItemTransCost.FundingSource = actualFundingSource;
        projItemTransCost.DefaultDimension = actualDetailDefaultDimension ? actualDetailDefaultDimension: projItemTrans.DefaultDimension;

        if (InventTransOrigin::findByInventTransId(projItemTrans.InventTransId).RecId)
        {
            projItemTransCost.LineAmount = actualTransactionCurrencyAmount;
        }
        else
        {
            projItemTransCost.LineAmount = actualAccountingCurrencyAmount;
        }
        projItemTransCost.AmountMST = actualAccountingCurrencyAmount;

        projItemTransCost.ProjInventAdjust = false;
        projItemTransCost.ProjId = projItemTrans.ProjId;
        projItemTransCost.ItemType = ProjItemTrans::transactionOriginToItemType(projItemTrans.TransactionOrigin);
        projItemTransCost.CostType = ProjItemTransCostType::Cost;
        projItemTransCost.Voucher = _voucher;

        return projItemTransCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjEmplTransCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes values to <c>ProjEmplTransCost</c> table buffer.
    /// </summary>
    /// <param name = "_projectRevenueHeader">
    /// A project actual header record.
    /// </param>
    /// <param name = "_costLedgerStatus">
    /// The Ledger status.
    /// </param>
    /// <param name = "_accountingCurrencyPrice">
    /// The amount of accounting currency.
    /// </param>
    /// <param name="_projectActualHeaderContainer">
    /// A container that contains the project actual header values.
    /// </param>
    /// <param name="_projectActualDetailContainer">
    /// A container that contains the project actual detail values.
    /// </param>
    /// <returns>
    /// The buffer of <c>ProjEmplTransCost</c> table.
    /// </returns>
    protected static ProjEmplTransCost initializeProjEmplTransCost(Common _projectRevenueHeader, ProjLedgerStatus _costLedgerStatus, Price _accountingCurrencyPrice, container _projectActualHeaderContainer, container _projectActualDetailContainer)
    {
        #declareProjectActualHeaderContainerVariablesMacro
        #declareProjectActualDetailContainerVariablesMacro

        ProjEmplTransCost   projEmplTransCost;

        #projectActualHeaderContainerMacro = _projectActualHeaderContainer;

        #projectActualDetailContainerMacro = _projectActualDetailContainer;

        ProjEmplTrans projEmplTrans = _projectRevenueHeader;

        projEmplTransCost.TransId = projEmplTrans.TransId;
        SourceDocumentLineItem sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(actualSourceDocumentLine));
        projEmplTransCost.LedgerTransdate = sourceDocumentLineItem.parmAccountingDate();

        projEmplTransCost.TransStatus = ProjTransStatus::Posted;
        projEmplTransCost.LedgerStatusCost = _costLedgerStatus;
        projEmplTransCost.wipPeriod = dateNull();

        projEmplTransCost.FundingSource = actualFundingSource;
        projEmplTransCost.DefaultDimension = actualDetailDefaultDimension ? actualDetailDefaultDimension: projEmplTrans.DefaultDimension;
        projEmplTransCost.LineAmount = actualAccountingCurrencyAmount;

        if (sourceDocumentLineItem is TSTimesheetTransSourceDocLineItem)
        {
            TSTimesheetTransSourceDocLineItem tsTimesheetTransSourceDocLineItem = sourceDocumentLineItem as TSTimesheetTransSourceDocLineItem;

            ProjTrans projTrans = ProjTrans::newProjEmplTrans(projEmplTrans);

            // In case of multiple funding sources.
            if (ProjFundingSource::getFundingSources(projTrans).elements() > 1)
            {
                projEmplTransCost.CostPrice = actualQuantity ? (actualTransactionCurrencyAmount / actualQuantity) : actualTransactionCurrencyAmount;
            }
            else
            {
                projEmplTransCost.CostPrice = tsTimesheetTransSourceDocLineItem.parmProjectCostPrice();
            }
        }
        else
        {
            projEmplTransCost.CostPrice = _accountingCurrencyPrice;
        }

        return projEmplTransCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjectActualHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the project actual header record and performs the reservation of project budgets when
    /// project budgeting is enabled.
    /// </summary>
    /// <param name="_projectActualHeaderContainer">
    /// A container that contains the project actual header values.
    /// </param>
    /// <param name="_voucher">
    /// The voucher number.
    /// </param>
    /// <returns>
    /// A project actual header record.
    /// </returns>
    protected static Common createProjectActualHeader(container _projectActualHeaderContainer, Voucher _voucher)
    {
        #declareProjectActualHeaderContainerVariablesMacro

        #projectActualHeaderContainerMacro = _projectActualHeaderContainer;

        Common  projectActualHeader;

        ProjOpsFinancialsLogger logger = ProjOpsFinancialsLogger::createLogger(classStr(SubledgerJournalizerProjectExtension));

        using (var activityContext = logger.projOpsFinActivity().createProjectTransContext())
        {
            SourceDocumentLineItem              sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(actualSourceDocumentLine));
            SourceDocumentLine sourceDocumentLine = sourceDocumentLineItem.parmSourceDocumentLine();
            SourceDocumentLineImplementation    sourceDocumentLineImplementation = sourceDocumentLine.getSourceDocumentLineImplementation();
            SourceDocumentLineItemIProject      sourceDocumentLineItemIProject = sourceDocumentLineItem as SourceDocumentLineItemIProject;
        
            // Since timesheet trx will always contain 1 distributions,
            // we will reuse the TransID we generated for TSTimesheetTrans record
            // This is to easily find ProjEmplTrans/ProjEmplTransCost/ProjEmplTransSales records via TransId from TSTimesheetTrans
            // For the multiple funding scenario in timesheet, the ProjEmplTrans::transid will not be the same of the timesheet trans,
            // but this is not a problem because the ProjEmplTrans TransIdRef field always keep the trans id of the timesheet trans record
            ProjTransIdBase     transId;
            if (sourceDocumentLineItem is SourceDocumentLineItemITimesheets && !ProjEmplTrans::exist(sourceDocumentLineItemIProject.parmProjectTransactionId()))
            {
                transId = sourceDocumentLineItemIProject.parmProjectTransactionId();
            }
            else
            {
                transId = ProjParameters::newTransId();
            }

            activityContext.addCustomProperty(ProjOpsInstrumentationBaseActitivies::ProjectIdProperty, actualProjectId);
            activityContext.addCustomProperty(ProjOpsInstrumentationBaseActitivies::TransIdProperty, transId);
            activityContext.addCustomProperty(ProjOpsInstrumentationBaseActitivies::TransIdRefProperty, sourceDocumentLineItemIProject.parmProjectTransactionId());
            activityContext.addCustomProperty(ProjOpsInstrumentationBaseActitivies::VoucherProperty, _voucher);
            
            SubledgerJournalizerProjectExtension    subledgerJournalizerProjectExtension = new SubledgerJournalizerProjectExtension();

            switch (ProjectSourceDocumentLineItemHelper::projTransType(sourceDocumentLineItem))
            {
                case ProjTransType::Cost:
                    if (SubledgerJournalizerProjectExtension::shouldCreateProjCostTrans(sourceDocumentLineItem))
                    {
                        activityContext.addCustomProperty(ProjOpsInstrumentationBaseActitivies::TransTypeProperty, 'Cost');

                        projectActualHeader = subledgerJournalizerProjectExtension.createProjCostTrans(_projectActualHeaderContainer, sourceDocumentLineItem, sourceDocumentLineImplementation, sourceDocumentLineItemIProject, transId, _voucher);
                    }
                    break;

                case ProjTransType::Item:
                    if (SubledgerJournalizerProjectExtension::shouldCreateProjItemTrans(sourceDocumentLineItem))
                    {
                        activityContext.addCustomProperty(ProjOpsInstrumentationBaseActitivies::TransTypeProperty, 'Item');

                        projectActualHeader = subledgerJournalizerProjectExtension.createProjItemTrans(_projectActualHeaderContainer, sourceDocumentLineItem, sourceDocumentLineImplementation, sourceDocumentLineItemIProject, transId, _voucher);
                    }
                    break;

                case ProjTransType::Revenue:
                    activityContext.addCustomProperty(ProjOpsInstrumentationBaseActitivies::TransTypeProperty, 'Revenue');

                    projectActualHeader = subledgerJournalizerProjectExtension.createProjRevenueTrans(_projectActualHeaderContainer, sourceDocumentLineItem, sourceDocumentLineImplementation, sourceDocumentLineItemIProject, transId, _voucher);
                    break;

                case ProjTransType::Hour:
                    if (SubledgerJournalizerProjectExtension::shouldCreateProjHourTrans(sourceDocumentLineItem))
                    {
                        activityContext.addCustomProperty(ProjOpsInstrumentationBaseActitivies::TransTypeProperty, 'Hour');

                        projectActualHeader = subledgerJournalizerProjectExtension.createProjHourTrans(_projectActualHeaderContainer, sourceDocumentLineItem, sourceDocumentLineImplementation, sourceDocumentLineItemIProject, transId, _voucher);
                    }
                    break;

                default:
                    throw error(strFmt("@SYS22828",funcName()));
            }

            SubledgerJournalizerProjectExtension::updateProjectBudget(transId, _projectActualHeaderContainer);
        }

        return projectActualHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransDate</Name>
				<Source><![CDATA[
    protected ProjTransDate getTransDate(SourceDocumentLineItem _sourceDocumentLineItem)
    {
        ProjTransDate   projTransDate;
        SourceDocumentLineItemIProjectTransDate iProjectTransDate;

        projTransDate = _sourceDocumentLineItem.parmAccountingDate();

        if (_sourceDocumentLineItem is SourceDocumentLineItemIProjectTransDate)
        {
            iProjectTransDate = _sourceDocumentLineItem as SourceDocumentLineItemIProjectTransDate;
            projTransDate = iProjectTransDate.parmProjTransDate();
        }

        if (!projTransDate)
        {
            projTransDate = _sourceDocumentLineItem.parmBusinessEventDate();
        }

        if (!projTransDate)
        {
            projTransDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }

        return projTransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjCostTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>ProjCostTrans</c> record.
    /// </summary>
    /// <param name = "_projectActualHeaderContainer">The project actual header container.</param>
    /// <param name = "_sourceDocumentLineItem">The source document line item.</param>
    /// <param name = "_sourceDocumentLineImplementation">The source document line item implementation.</param>
    /// <param name = "_sourceDocumentLineItemIProject">The source document project line item.</param>
    /// <param name = "_transId">Transaction ID.</param>
    /// <param name = "_voucher">Voucher number.</param>
    /// <returns>
    /// The inserted <c>ProjCostTrans</c> table buffer.
    /// </returns>
    protected ProjCostTrans createProjCostTrans(Container _projectActualHeaderContainer,
                                                SourceDocumentLineItem _sourceDocumentLineItem,
                                                SourceDocumentLineImplementation _sourceDocumentLineImplementation,
                                                SourceDocumentLineItemIProject _sourceDocumentLineItemIProject,
                                                ProjTransIdBase _transId,
                                                Voucher _voucher)
    {
        ProjCostTrans projCostTrans = this.initializeProjCostTrans(_projectActualHeaderContainer,
                                                                _sourceDocumentLineItem,
                                                                _sourceDocumentLineImplementation,
                                                                _sourceDocumentLineItemIProject,
                                                                _transId,
                                                                _voucher);

        // Set the transaction to non-chargeable when Calculate sales price without retention considerations feature is on
        // and release retention is being invoiced.
        if (this.isNonBillable(_sourceDocumentLineItem, projCostTrans.TotalSalesAmountCur))
        {
            ProjLineProperty projLineProperty = this.findNonBillableLineProperty();
            if (projLineProperty)
            {
                projCostTrans.LinePropertyId = projLineProperty.LinePropertyId;
            }
        }

        projCostTrans.insert();

        if (_sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem && TaxIntegrationUtils::isTaxInformationEnabled())
        {
            VendorInvoiceLineSourceDocLineItem vendorInvoiceLineSourceDocLineItem = _sourceDocumentLineItem as VendorInvoiceLineSourceDocLineItem;
            VendInvoiceLineMap vendInvoiceLineMap = vendorInvoiceLineSourceDocLineItem.parmVendInvoiceLineMap();

            TransTaxInformationHelper::copyTransTaxInformation(vendInvoiceLineMap, projCostTrans);
            TransTaxInformationHelper::resetCustVendLocationByTransTable(projCostTrans);
        }

        SourceDocumentHeaderImplementation sourceDocumentHeaderImplementation = _sourceDocumentLineItem.parmSourceDocument().parmSourceDocumentHeader().getSourceDocumentImplementation();
        Docu::copy(_sourceDocumentLineImplementation, projCostTrans);
        Docu::copy(sourceDocumentHeaderImplementation, projCostTrans);

        return projCostTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjCostTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes values to <c>ProjCostTrans</c> table buffer.
    /// </summary>
    /// <param name = "_projectActualHeaderContainer">The project actual header container.</param>
    /// <param name = "_sourceDocumentLineItem">The source document line item.</param>
    /// <param name = "_sourceDocumentLineImplementation">The source document line item implementation.</param>
    /// <param name = "_sourceDocumentLineItemIProject">The source document project line item.</param>
    /// <param name = "_transId">Transaction ID.</param>
    /// <param name = "_voucher">Voucher number.</param>
    /// <returns>
    /// The buffer of <c>ProjCostTrans</c> table.
    /// </returns>
    protected ProjCostTrans initializeProjCostTrans(Container _projectActualHeaderContainer,
                                                    SourceDocumentLineItem _sourceDocumentLineItem,
                                                    SourceDocumentLineImplementation _sourceDocumentLineImplementation,
                                                    SourceDocumentLineItemIProject _sourceDocumentLineItemIProject,
                                                    ProjTransIdBase _transId,
                                                    Voucher _voucher)
    {
        ProjCostTrans   projCostTrans;

        #declareProjectActualHeaderContainerVariablesMacro
        #projectActualHeaderContainerMacro = _projectActualHeaderContainer;

        projCostTrans.ProjId = actualProjectId;
        projCostTrans.CategoryId = actualCategoryId;
        projCostTrans.ActivityNumber = actualActivityNumber;
        projCostTrans.LinePropertyId = actualLinePropertyId;
        projCostTrans.CurrencyIdCost = actualTransactionCostCurrency;
        projCostTrans.CurrencyId = actualTransactionSalesCurrency;
        projCostTrans.TaxGroupId = actualTaxGroupId;
        projCostTrans.TaxItemGroupId = actualTaxItemGroupId;
        projCostTrans.DefaultDimension = actualDefaultDimension;
        projCostTrans.Qty = actualQuantity;

        projCostTrans.TransId = _transId;
        projCostTrans.TransIdRef = _sourceDocumentLineItemIProject.parmProjectTransactionId();
        projCostTrans.AdjRefTransId = '';
        projCostTrans.TransactionOrigin = ProjectSourceDocumentLineItemHelper::projOrigin(_sourceDocumentLineItem);
        projCostTrans.TransDate = this.getTransDate(_sourceDocumentLineItem);
        projCostTrans.Txt = ProjectSourceDocumentLineItemHelper::transTxt(_sourceDocumentLineItem);

        ResourceRecid resourceRecId = _sourceDocumentLineItemIProject.parmProjectResourceRecId();
        ResourceCategoryRecId resourceCategoryRecId = _sourceDocumentLineItemIProject.parmProjectResourceCategoryRecId();

        projCostTrans.Resource = resourceRecId;
        projCostTrans.ResourceCategory = resourceCategoryRecId;
        projCostTrans.InvestmentTaxAmountMST = 0;
        projCostTrans.VoucherJournal = _voucher;

        if (_sourceDocumentLineImplementation && _sourceDocumentLineImplementation.TableId == tableNum(VendInvoiceTrans))
        {
            projCostTrans.VendInvoiceTrans = _sourceDocumentLineImplementation.RecId;

            if (FeatureStateProvider::isFeatureEnabled(ProjProjectTransactionsListPageVendFeature::instance()))
            {
                ProjVendInvoiceVendorInfo vendorInfo = ProjVendInvoiceVendorInfo::newFromVendorInvoiceTransRecId(projCostTrans.VendInvoiceTrans);

                projCostTrans.VendorAccount = vendorInfo.getVendorAccount();
                projCostTrans.VendorName = vendorInfo.getVendorName();
            }
        }
        // Displays vendor name/account for expense reports attached to project in the posted project transactions.
        else if (_sourceDocumentLineImplementation && _sourceDocumentLineImplementation.TableId == tableNum(TrvExpTrans) && FeatureStateProvider::isFeatureEnabled(ProjProjectTransactionsListPageVendFeature::instance()))
        {
            TrvExpTrans trvExpTrans;
            TrvExpTable trvExpTable;

            select firstonly VendAccount from trvExpTable
                join TrvExpTable, RecId from trvExpTrans
                    where trvExpTrans.RecId == _sourceDocumentLineImplementation.RecId
                        && trvExpTrans.TrvExpTable == trvExpTable.RecId;

            projCostTrans.VendorAccount = trvExpTable.VendAccount;
            projCostTrans.VendorName = VendTable::find(projCostTrans.VendorAccount).name();
        }

        return projCostTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNonBillable</Name>
				<Source><![CDATA[
    private boolean isNonBillable(SourceDocumentLineItem _sourceDocumentLineItem, Amount _totalSalesAmountCur)
    {
        VendInvoiceInfoLine _vendInvoiceInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(_sourceDocumentLineItem.parmSourceDocumentLine().RecId);

        if (!_totalSalesAmountCur
            && ProjSalesPriceWithoutRetentionFeatureHelper::isFeatureEnabled())
        {
            if (_vendInvoiceInfoLine
                && (_vendInvoiceInfoLine.PSAReleaseAmount || _vendInvoiceInfoLine.PSAReleasePercent))
            {
                return true;
            }
        }

        if (_vendInvoiceInfoLine
            && (vendorInvoiceRetentionTransitionFlight
                || _vendInvoiceInfoLine.PSAIsFinal == NoYes::Yes)
            && (!vendorInvoiceRetentionTransitionFlight
                || !_vendInvoiceInfoLine.LineAmount)
            && ProjVendorInvoiceRetentionCalcFeatureHelper::shouldProcessWithFeatureEnabledBySouceDocumentLineItem(
                vendorInvoiceRetentionCalcFeature,
                _sourceDocumentLineItem))
        {
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findNonBillableLineProperty</Name>
				<Source><![CDATA[
    private ProjLineProperty findNonBillableLineProperty()
    {
        ProjLineProperty projLineProperty;
        select firstonly projLineProperty where projLineProperty.ToBeInvoiced == NoYes::No;
        return projLineProperty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjHourTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>ProjEmplTrans</c> record.
    /// </summary>
    /// <param name = "_projectActualHeaderContainer">The project actual header container.</param>
    /// <param name = "_sourceDocumentLineItem">The source document line item.</param>
    /// <param name = "_sourceDocumentLineImplementation">The source document line item implementation.</param>
    /// <param name = "_sourceDocumentLineItemIProject">The source document project line item.</param>
    /// <param name = "_transId">ransaction ID.</param>
    /// <param name = "_voucher">Voucher number.</param>
    /// <returns>
    /// The inserted <c>ProjEmplTrans</c> table buffer.
    /// </returns>
    protected ProjEmplTrans createProjHourTrans(Container _projectActualHeaderContainer,
                                                SourceDocumentLineItem _sourceDocumentLineItem,
                                                SourceDocumentLineImplementation _sourceDocumentLineImplementation,
                                                SourceDocumentLineItemIProject _sourceDocumentLineItemIProject,
                                                ProjTransIdBase _transId,
                                                Voucher _voucher)
    {
        ProjEmplTrans projEmplTrans = this.initializeProjHourTrans(_projectActualHeaderContainer,
                                                                _sourceDocumentLineItem,
                                                                _sourceDocumentLineImplementation,
                                                                _sourceDocumentLineItemIProject,
                                                                _transId,
                                                                _voucher);
        
        // Set the transaction to non-chargeable when Calculate sales price without retention considerations feature is on
        // and release retention is being invoiced.
        if (this.isNonBillable(_sourceDocumentLineItem, projEmplTrans.TotalSalesAmountCur))
        {
            ProjLineProperty projLineProperty = this.findNonBillableLineProperty();
            if (projLineProperty)
            {
                projEmplTrans.LinePropertyId = projLineProperty.LinePropertyId;
            }
        }

        projEmplTrans.insert();

        // <GIN> <GTE>
        if (TaxParameters::checkTaxParameters_IN() || TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            TSTimesheetLine tsTimesheetLine = TSTimesheetTrans::findRecId(_sourceDocumentLineImplementation.RecId).timesheetLine();
            TransTaxInformationHelper::copyTransTaxInformation(tsTimesheetLine, projEmplTrans);
        }
        // </GIN> </GTE>

        return projEmplTrans;

    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjHourTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes values to <c>ProjEmplTrans</c> table buffer.
    /// </summary>
    /// <param name = "_projectActualHeaderContainer">The project actual header container.</param>
    /// <param name = "_sourceDocumentLineItem">The source document line item.</param>
    /// <param name = "_sourceDocumentLineImplementation">The source document line item implementation.</param>
    /// <param name = "_sourceDocumentLineItemIProject">The source document project line item.</param>
    /// <param name = "_transId">ransaction ID.</param>
    /// <param name = "_voucher">Voucher number.</param>
    /// <returns>
    /// The buffer of <c>ProjEmplTrans</c> table.
    /// </returns>
    protected ProjEmplTrans initializeProjHourTrans(Container _projectActualHeaderContainer,
                                                SourceDocumentLineItem _sourceDocumentLineItem,
                                                SourceDocumentLineImplementation _sourceDocumentLineImplementation,
                                                SourceDocumentLineItemIProject _sourceDocumentLineItemIProject,
                                                ProjTransIdBase _transId,
                                                Voucher _voucher)
    {
        ProjEmplTrans   projEmplTrans;
        
        #declareProjectActualHeaderContainerVariablesMacro
        #projectActualHeaderContainerMacro = _projectActualHeaderContainer;

        projEmplTrans.ProjId = actualProjectId;
        projEmplTrans.CategoryId = actualCategoryId;
        projEmplTrans.ActivityNumber = actualActivityNumber;
        projEmplTrans.LinePropertyId = actualLinePropertyId;
        projEmplTrans.CurrencyId = actualTransactionSalesCurrency;
        projEmplTrans.TaxGroupId = actualTaxGroupId;
        projEmplTrans.TaxItemGroupId = actualTaxItemGroupId;
        projEmplTrans.DefaultDimension = actualDefaultDimension;
        projEmplTrans.Qty = actualQuantity;

        projEmplTrans.TransId = _transId;
        projEmplTrans.TransIdRef = _sourceDocumentLineItemIProject.parmProjectTransactionId();
        projEmplTrans.AdjRefTransId = '';
        projEmplTrans.TransactionOrigin = ProjectSourceDocumentLineItemHelper::projOrigin(_sourceDocumentLineItem);
        projEmplTrans.TransDate = this.getTransDate(_sourceDocumentLineItem);
        projEmplTrans.Txt = ProjectSourceDocumentLineItemHelper::transTxt(_sourceDocumentLineItem);

        ResourceRecId resourceRecId = _sourceDocumentLineItemIProject.parmProjectResourceRecId();
        ResourceCategoryRecId resourceCategoryRecId = _sourceDocumentLineItemIProject.parmProjectResourceCategoryRecId();

        projEmplTrans.Resource = resourceRecId;
        projEmplTrans.ResourceCategory = resourceCategoryRecId;
        projEmplTrans.VoucherJournal = _voucher;
        PSAComponentGroupAssignment psaComponentGroupAssignment = PSAComponentGroupAssignment::findAssignment(actualProjectId,
                                                                                    resourceRecId,
                                                                                    actualCategoryId,
                                                                                    projEmplTrans.TransDate,
                                                                                    '','');

        projEmplTrans.psaIndirectComponentGroup = psaComponentGroupAssignment.IndirectComponentGroup;

        if (_sourceDocumentLineImplementation && _sourceDocumentLineImplementation.TableId == tableNum(VendInvoiceTrans))
        {
            projEmplTrans.VendInvoiceTrans = _sourceDocumentLineImplementation.RecId;
        }

        if (projEmplTrans.TransactionOrigin == ProjOrigin::Timesheet)
        {
            if (ResProjectResource::isUsingStartEndTime(resourceRecId))
            {
                TSTimesheetTrans tsTimesheetTrans = TSTimesheetTrans::findBySourceDocumentLine( _sourceDocumentLineImplementation.SourceDocumentLine);
                if (tsTimesheetTrans)
                {
                    projEmplTrans.FromTime = tsTimesheetTrans.TimeFrom;
                    projEmplTrans.ToTime = tsTimesheetTrans.TimeTo;
                }
            }

            projEmplTrans.PSAContractLineNum = PSAContractLineItemsSetup::find(projEmplTrans.ProjId, projEmplTrans.CategoryId).ContractLineNum;
        }

        if (TaxParameters::checkTaxParameters_IN())
        {
            ProjEmplTransTaxExtensionIN projEmplTransTaxExtensionIN = projEmplTrans.projEmplTransTaxExtensionIN();
            projEmplTrans.packProjEmplTrans_IN(projEmplTransTaxExtensionIN);
        }

        return projEmplTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjItemTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>ProjItemTrans</c> record.
    /// </summary>
    /// <param name = "_projectActualHeaderContainer">The project actual header container.</param>
    /// <param name = "_sourceDocumentLineItem">The source document line item.</param>
    /// <param name = "_sourceDocumentLineImplementation">The source document line item implementation.</param>
    /// <param name = "_sourceDocumentLineItemIProject">The source document project line item.</param>
    /// <param name = "_transId">Transaction ID.</param>
    /// <param name = "_voucher">Voucher number.</param>
    /// <returns>
    /// The inserted <c>ProjItemTrans</c> table buffer.
    /// </returns>
    protected ProjItemTrans createProjItemTrans(Container _projectActualHeaderContainer,
                                                SourceDocumentLineItem _sourceDocumentLineItem,
                                                SourceDocumentLineImplementation _sourceDocumentLineImplementation,
                                                SourceDocumentLineItemIProject _sourceDocumentLineItemIProject,
                                                ProjTransIdBase _transId,
                                                Voucher _voucher)
    {
        VendInvoiceInfoLine vendInvoiceInfoLine;
        PurchLine           purchLine;

        SourceDocumentLineItemIProjectRevenue   sourceDocumentLineItemIProjectRevenue;
        SourceDocumentLineItemIProduct          sourceDocumentLineItemIProduct;
        SourceDocumentLineItemIInventory        sourceDocumentLineItemIInventory;

        if (_sourceDocumentLineItem is SourceDocumentLineItemIProduct)
        {
            sourceDocumentLineItemIProduct = _sourceDocumentLineItem as SourceDocumentLineItemIProduct;
        }
        if (_sourceDocumentLineItem is SourceDocumentLineItemIInventory)
        {
            sourceDocumentLineItemIInventory = _sourceDocumentLineItem as SourceDocumentLineItemIInventory;
        }
        if (ProjectSourceDocumentLineItemHelper::implementsProjectRevenue(_sourceDocumentLineItem))
        {
            sourceDocumentLineItemIProjectRevenue = _sourceDocumentLineItem as SourceDocumentLineItemIProjectRevenue;
        }

        if (!sourceDocumentLineItemIProduct ||
            !sourceDocumentLineItemIInventory ||
            !sourceDocumentLineItemIProjectRevenue)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        ProjItemTrans projItemTrans = this.initializeProjItemTrans(_projectActualHeaderContainer,
                                                                _sourceDocumentLineItem,
                                                                _sourceDocumentLineImplementation,
                                                                _sourceDocumentLineItemIProject,
                                                                _transId,
                                                                _voucher,
                                                                sourceDocumentLineItemIProjectRevenue,
                                                                sourceDocumentLineItemIProduct,
                                                                sourceDocumentLineItemIInventory);
        
        // Set the transaction to non-chargeable when Calculate sales price without retention considerations feature is on
        // and release retention is being invoiced.
        if (this.isNonBillable(_sourceDocumentLineItem, projItemTrans.TotalSalesAmountCur))
        {
            ProjLineProperty projLineProperty = this.findNonBillableLineProperty();
            if (projLineProperty)
            {
                projItemTrans.LinePropertyId = projLineProperty.LinePropertyId;
            }
        }

        if (TaxParameters::checkTaxParameters_IN())
        {
            ProjItemTransTaxExtensionIN projItemTransTaxExtensionIN = projItemTrans.projItemTransTaxExtensionIN();
            projItemTrans.packProjItemTrans_IN(projItemTransTaxExtensionIN);
        }

        projItemTrans.insert();

        if (_sourceDocumentLineImplementation &&
                _sourceDocumentLineImplementation.TableId == tableNum(VendInvoiceInfoLine))
        {
            vendInvoiceInfoLine = _sourceDocumentLineImplementation;
            if (!vendInvoiceInfoLine.isNonPO())
            {
                purchLine = vendInvoiceInfoLine.purchLine();
            }
        }
        if (purchLine)
        {
            Docu::copy(purchLine, projItemTrans);
        }
        else
        {
            Docu::copy(_sourceDocumentLineImplementation, projItemTrans);
        }

        return projItemTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjItemTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes values to <c>ProjItemTrans</c> table buffer.
    /// </summary>
    /// <param name = "_projectActualHeaderContainer">The project actual header container.</param>
    /// <param name = "_sourceDocumentLineItem">The source document line item.</param>
    /// <param name = "_sourceDocumentLineImplementation">The source document line item implementation.</param>
    /// <param name = "_sourceDocumentLineItemIProject">The source document project line item.</param>
    /// <param name = "_transId">Transaction ID.</param>
    /// <param name = "_voucher">Voucher number.</param>
    /// <param name = "_sourceDocumentLineItemIProjectRevenue">The source document revenue line item.</param>
    /// <param name = "_sourceDocumentLineItemIProduct">The source document product line item.</param>
    /// <param name = "_sourceDocumentLineItemIInventory">The source document inventory line item.</param>
    /// <returns>
    /// The buffer of <c>ProjItemTrans</c> table.
    /// </returns>
    protected ProjItemTrans initializeProjItemTrans(Container _projectActualHeaderContainer,
                                                    SourceDocumentLineItem _sourceDocumentLineItem,
                                                    SourceDocumentLineImplementation _sourceDocumentLineImplementation,
                                                    SourceDocumentLineItemIProject _sourceDocumentLineItemIProject,
                                                    ProjTransIdBase _transId,
                                                    Voucher _voucher,
                                                    SourceDocumentLineItemIProjectRevenue _sourceDocumentLineItemIProjectRevenue,
                                                    SourceDocumentLineItemIProduct _sourceDocumentLineItemIProduct,
                                                    SourceDocumentLineItemIInventory _sourceDocumentLineItemIInventory)
    {
        ProjItemTrans projItemTrans;

        #declareProjectActualHeaderContainerVariablesMacro
        #projectActualHeaderContainerMacro = _projectActualHeaderContainer;

        projItemTrans.ProjId = actualProjectId;
        projItemTrans.CategoryId = actualCategoryId;
        projItemTrans.ActivityNumber = actualActivityNumber;
        projItemTrans.LinePropertyId = actualLinePropertyId;
        projItemTrans.CurrencyId = actualTransactionSalesCurrency;
        projItemTrans.TaxGroupId = actualTaxGroupId;
        projItemTrans.TaxItemGroupId = actualTaxItemGroupId;
        projItemTrans.DefaultDimension = actualDefaultDimension;
        projItemTrans.Qty = actualQuantity;

        projItemTrans.ProjTransId = _transId;
        projItemTrans.ProjTransIdRef = _sourceDocumentLineItemIProject.parmProjectTransactionId();
        projItemTrans.AdjRefTransId = '';
        projItemTrans.TransactionOrigin = ProjectSourceDocumentLineItemHelper::projOrigin(_sourceDocumentLineItem);
        projItemTrans.TransDate = this.getTransDate(_sourceDocumentLineItem);
        projItemTrans.Txt = _sourceDocumentLineItemIProduct.parmInventTable().itemName();

        projItemTrans.InventTransId = _sourceDocumentLineItemIInventory.parmLotId();
        projItemTrans.ProjAdjustRefId = NumberSeq::newGetNum(CompanyInfo::numRefParmId()).num();
        projItemTrans.ItemId = _sourceDocumentLineItemIProduct.parmItemId();
        projItemTrans.SalesUnit = _sourceDocumentLineItemIProjectRevenue.parmProjectSalesUnit();
        projItemTrans.InventDimId = _sourceDocumentLineItemIInventory.parmInventoryDimensionId();
        projItemTrans.LedgerDimension = 0;
        projItemTrans.PackingSlipId = '';
        projItemTrans.VoucherPackingSlip = _voucher;
        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            if (_sourceDocumentLineImplementation &&
                    _sourceDocumentLineImplementation.TableId == tableNum(VendInvoiceTrans))
            {
                //
                // This provides a link so that 'Pay When Paid' can determine if items have been paid for
                // a specific Vendor Invoice Transaction.
                //
                projItemTrans.VendInvoiceTransRecId = _sourceDocumentLineImplementation.RecId;

                if (FeatureStateProvider::isFeatureEnabled(ProjProjectTransactionsListPageVendFeature::instance()))
                {
                    ProjVendInvoiceVendorInfo vendorInfo = ProjVendInvoiceVendorInfo::newFromVendorInvoiceTransRecId(projItemTrans.VendInvoiceTransRecId);

                    projItemTrans.VendorAccount = vendorInfo.getVendorAccount();
                    projItemTrans.VendorName = vendorInfo.getVendorName();
                }
            }
        }

        return projItemTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjRevenueTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>ProjRevenueTrans</c> record.
    /// </summary>
    /// <param name = "_projectActualHeaderContainer">The project actual header container.</param>
    /// <param name = "_sourceDocumentLineItem">The source document line item.</param>
    /// <param name = "_sourceDocumentLineImplementation">The source document line item implementation.</param>
    /// <param name = "_sourceDocumentLineItemIProject">The source document project line item.</param>
    /// <param name = "_transId">Transaction ID.</param>
    /// <param name = "_voucher">Voucher number.</param>
    /// <returns>
    /// The inserted <c>ProjRevenueTrans</c> table buffer.
    /// </returns>
    protected ProjRevenueTrans createProjRevenueTrans(Container _projectActualHeaderContainer,
                                                    SourceDocumentLineItem _sourceDocumentLineItem,
                                                    SourceDocumentLineImplementation _sourceDocumentLineImplementation,
                                                    SourceDocumentLineItemIProject _sourceDocumentLineItemIProject,
                                                    ProjTransIdBase _transId,
                                                    Voucher _voucher)
    {
        ProjRevenueTrans projRevenueTrans = this.initializeProjRevenueTrans(_projectActualHeaderContainer,
                                                                            _sourceDocumentLineItem,
                                                                            _sourceDocumentLineImplementation,
                                                                            _sourceDocumentLineItemIProject,
                                                                            _transId,
                                                                            _voucher);
        
        // Set the transaction to non-chargeable when Calculate sales price without retention considerations feature is on
        // and release retention is being invoiced.
        if (this.isNonBillable(_sourceDocumentLineItem, projRevenueTrans.TotalSalesAmountCur))
        {
            ProjLineProperty projLineProperty = this.findNonBillableLineProperty();
            if (projLineProperty)
            {
                projRevenueTrans.LinePropertyId = projLineProperty.LinePropertyId;
            }
        }

        projRevenueTrans.insert();

        Docu::copy(_sourceDocumentLineImplementation, projRevenueTrans);

        return projRevenueTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjRevenueTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes values to <c>ProjRevenueTrans</c> table buffer.
    /// </summary>
    /// <param name = "_projectActualHeaderContainer">The project actual header container.</param>
    /// <param name = "_sourceDocumentLineItem">The source document line item.</param>
    /// <param name = "_sourceDocumentLineImplementation">The source document line item implementation.</param>
    /// <param name = "_sourceDocumentLineItemIProject">The source document project line item.</param>
    /// <param name = "_transId">Transaction ID.</param>
    /// <param name = "_voucher">Voucher number.</param>
    /// <returns>
    /// The buffer of <c>ProjRevenueTrans</c> table.
    /// </returns>
    protected ProjRevenueTrans initializeProjRevenueTrans(Container _projectActualHeaderContainer,
                                                        SourceDocumentLineItem _sourceDocumentLineItem,
                                                        SourceDocumentLineImplementation _sourceDocumentLineImplementation,
                                                        SourceDocumentLineItemIProject _sourceDocumentLineItemIProject,
                                                        ProjTransIdBase _transId,
                                                        Voucher _voucher)
    {
        ProjRevenueTrans   projRevenueTrans;

        #declareProjectActualHeaderContainerVariablesMacro
        #projectActualHeaderContainerMacro = _projectActualHeaderContainer;

        projRevenueTrans.ProjId = actualProjectId;
        projRevenueTrans.CategoryId = actualCategoryId;
        projRevenueTrans.ActivityNumber = actualActivityNumber;
        projRevenueTrans.LinePropertyId = actualLinePropertyId;
        projRevenueTrans.CurrencyId = actualTransactionSalesCurrency;
        projRevenueTrans.TaxGroupId = actualTaxGroupId;
        projRevenueTrans.TaxItemGroupId = actualTaxItemGroupId;
        projRevenueTrans.DefaultDimension = actualDefaultDimension;
        projRevenueTrans.Qty = actualQuantity;

        projRevenueTrans.TransId = _transId;
        projRevenueTrans.TransIdRef = _sourceDocumentLineItemIProject.parmProjectTransactionId();
        projRevenueTrans.AdjRefTransId = '';
        projRevenueTrans.TransactionOrigin = ProjectSourceDocumentLineItemHelper::projOrigin(_sourceDocumentLineItem);
        projRevenueTrans.TransDate = this.getTransDate(_sourceDocumentLineItem);
        projRevenueTrans.Txt = ProjectSourceDocumentLineItemHelper::transTxt(_sourceDocumentLineItem);
        projRevenueTrans.Resource = _sourceDocumentLineItemIProject.parmProjectResourceRecId();
        projRevenueTrans.ResourceCategory = _sourceDocumentLineItemIProject.parmProjectResourceCategoryRecId();
        projRevenueTrans.Price = 0;
        projRevenueTrans.smaBasePrice = 0;
        projRevenueTrans.smaEnddate = dateNull();
        projRevenueTrans.smaIndex = 0;
        projRevenueTrans.smaStartDate = dateNull();
        projRevenueTrans.smaSubscriptionId = '';
        projRevenueTrans.smaSubscriptionPeriodType = SMASubscriptionPeriodType::Regular;
        projRevenueTrans.VoucherJournal = _voucher;

        return projRevenueTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjectActualSalesDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the project actual detail record
    /// </summary>
    /// <param name="_projectRevenueHeader">
    /// A project actual header record.
    /// </param>
    /// <param name="_projectActualHeaderContainer">
    /// A container that contains the project actual header values.
    /// </param>
    /// <param name="_projectActualDetailContainer">
    /// A container that contains the project actual detail values.
    /// </param>
    /// <param name="_voucher">
    /// The voucher number.
    /// </param>
    /// <param name="_canProcessInvoice">
    /// A Boolean value that indicates whether project transactions are invoiced during journalization.
    /// </param>
    /// <returns>
    /// A project actual detail record.
    /// </returns>
    private static Common createProjectActualSalesDetail(
        Common _projectRevenueHeader,
        container _projectActualHeaderContainer,
        container _projectActualDetailContainer,
        Voucher _voucher,
        boolean _canProcessInvoice)

    {
        #declareProjectActualHeaderContainerVariablesMacro
        #declareProjectActualDetailContainerVariablesMacro
        #declareActualLedgerUpdateContainerVariablesMacro

        Common projectActualDetail;
        ProjLedgerSalesPosted isAccrued;
        ProjTrans_Virtual projTrans_Virtual;
        SourceDocumentLineItem sourceDocumentLineItem;
        SourceDocumentLineItemIProject sourceDocumentLineItemIProject;
        SourceDocumentLineItemIProduct sourceDocumentLineItemIProduct;
        SourceDocumentLineItem topSourceDocumentLineItem;

        PriceCur transactionCurrencyPrice()
        {
            PriceCur ret;

            if (actualQuantity)
            {
                ret = CurrencyExchangeHelper::price(actualTransactionCurrencyAmount / actualQuantity, actualTransactionSalesCurrency);
            }

            return ret;
        }

        AmountMST accountingCurrencyAccruedRevenueAmount()
        {
            return (isAccrued == NoYes::Yes ? actualAccountingCurrencyAmount : 0);
        }

        void setIsAccrued()
        {
            ListEnumerator actualLedgerUpdateEnumerator;

            isAccrued = NoYes::No;

            actualLedgerUpdate = List::create(packedActualLedgerUpdate);
            actualLedgerUpdateEnumerator = actualLedgerUpdate.getEnumerator();
            while (actualLedgerUpdateEnumerator.moveNext())
            {
                #actualLedgerUpdateContainerMacro = actualLedgerUpdateEnumerator.current();
                if (actualLedgerUpdatePostingType == LedgerPostingType::ProjSalesvalue)
                {
                    if (sourceDocumentLineItem is SourceDocumentLineItemIProject)
                    {
                        sourceDocumentLineItemIProject = sourceDocumentLineItem as SourceDocumentLineItemIProject;
                        
                        ProjAdvancedJournalLine projAdvJournalLine;

                        if (sourceDocumentLineItem is ProjAdvancedJournalSourceDocumentLineItem)
                        {
                            ProjAdvancedJournalSourceDocumentLineItem projAdvancedJournalSDLItem = sourceDocumentLineItem as ProjAdvancedJournalSourceDocumentLineItem;
                            projAdvJournalLine = projAdvancedJournalSDLItem.parmProjAdvancedJournalLine();
                        }

                        using (ProjectPostingParameters insertParameters = ProjectPostingParameters::parmProjContractLineNum(projAdvJournalLine.ContractLineId))
                        {
                            if (ProjectPosting::canAccrueRevenue(
                                    ProjTable::find(sourceDocumentLineItemIProject.parmProjectId()),
                                                    ProjCategory::find(sourceDocumentLineItemIProject.parmProjectCategoryId()),
                                                    ProjLineProperty::find(sourceDocumentLineItemIProject.parmProjectLineProperty()),
                                                    actualAccountingCurrencyAmount,
                                                    actualFundingSource))
                            {
                                isAccrued = NoYes::Yes;
                                break;
                            }
                        }
                    }
                    else
                    {
                        isAccrued = NoYes::Yes;
                        break;
                    }

                }
            }
        }

        ProjCostTransSale createProjCostTransSale()
        {
            ProjCostTransSale projCostTransSale;

            projCostTransSale = SubledgerJournalizerProjectExtension::initializeProjCostTransSale(_projectRevenueHeader, isAccrued, accountingCurrencyAccruedRevenueAmount(), #projectActualHeaderContainerMacro, #projectActualDetailContainerMacro);

            projCostTransSale.insert();

            return projCostTransSale;
        }

        ProjEmplTransSale createProjEmplTransSale()
        {
            ProjEmplTransSale projEmplTransSale;

            projEmplTransSale.clear();

            projEmplTransSale = SubledgerJournalizerProjectExtension::initializeProjEmplTransSale(_projectRevenueHeader, transactionCurrencyPrice(), isAccrued, accountingCurrencyAccruedRevenueAmount(), #projectActualHeaderContainerMacro, #projectActualDetailContainerMacro);

            projEmplTransSale.insert();

            return projEmplTransSale;
        }

        ProjItemTransSale createProjItemTransSale()
        {
            ProjItemTransSale projItemTransSale;

            projItemTransSale.clear();

            projItemTransSale = SubledgerJournalizerProjectExtension::initializeProjItemTransSale(_projectRevenueHeader, transactionCurrencyPrice(), isAccrued, accountingCurrencyAccruedRevenueAmount(), #projectActualHeaderContainerMacro, #projectActualDetailContainerMacro);

            projItemTransSale.insert();

            return projItemTransSale;
        }

        ProjRevenueTransSale createProjRevenueTransSale()
        {
            ProjRevenueTransSale projRevenueTransSale;

            projRevenueTransSale.clear();

            projRevenueTransSale = SubledgerJournalizerProjectExtension::initializeProjRevenueTransSale(_projectRevenueHeader, transactionCurrencyPrice(), isAccrued, accountingCurrencyAccruedRevenueAmount(), #projectActualHeaderContainerMacro, #projectActualDetailContainerMacro);

            projRevenueTransSale.insert();

            return projRevenueTransSale;
        }

        #clearProjectActualDetailContainerMacro

        #projectActualHeaderContainerMacro = _projectActualHeaderContainer;
        sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(actualSourceDocumentLine));

        #projectActualDetailContainerMacro = _projectActualDetailContainer;

        setIsAccrued();

        switch (_projectRevenueHeader.TableId)
        {
            case tableNum(ProjCostTrans):
                projectActualDetail = createProjCostTransSale();
                break;

            case tableNum(ProjItemTrans):
                projectActualDetail = createProjItemTransSale();
                break;

            case tableNum(ProjRevenueTrans):
                projectActualDetail = createProjRevenueTransSale();
                break;

            case tableNum(ProjEmplTrans):
                projectActualDetail = createProjEmplTransSale();
                break;

            default:
                throw error(strFmt("@SYS22828",funcName()));
        }

        actualReferenceProjectAccountingDistribution = null;
        SubledgerJournalizerProjectExtension::updateProjectAccountingDistributions(projectActualDetail, packedActualReferenceProjectAccountingDistribution);
        SubledgerJournalizerProjectExtension::createLedgerUpdates(_projectRevenueHeader, projectActualDetail, _projectActualHeaderContainer, _projectActualDetailContainer, packedActualLedgerUpdate, _voucher, _canProcessInvoice);

        topSourceDocumentLineItem = ProjectSourceDocumentLineItemHelper::sourceDocumentLineItemTopParent(sourceDocumentLineItem.parmSourceDocumentLine().RecId);

        if (actualFundingSource &&
            !ProjFundingLimitTrackingManager::isUsingDocumentMatching(topSourceDocumentLineItem) &&
            (ProjFundingSource::getFundingType(actualFundingSource) != ProjFundingType::OnHoldFundingSource))
        {
            sourceDocumentLineItemIProject = sourceDocumentLineItem as SourceDocumentLineItemIProject;
            if (sourceDocumentLineItem is SourceDocumentLineItemIProduct)
            {
                sourceDocumentLineItemIProduct = sourceDocumentLineItem as SourceDocumentLineItemIProduct;
            }

            projTrans_Virtual = ProjTrans_Virtual::construct();

            projTrans_Virtual.setActivityNumber(actualActivityNumber);
            projTrans_Virtual.setCategoryId(actualCategoryId);
            projTrans_Virtual.setCurrencyIdSales(actualTransactionSalesCurrency);
            projTrans_Virtual.setResource(sourceDocumentLineItemIProject.parmProjectResourceRecId());
            projTrans_Virtual.setResourceCategory(sourceDocumentLineItemIProject.parmProjectResourceCategoryRecId());
            if (sourceDocumentLineItemIProduct)
            {
                projTrans_Virtual.setItemId(sourceDocumentLineItemIProduct.parmItemId());
            }
            projTrans_Virtual.setLinePropertyId(actualLinePropertyId);
            projTrans_Virtual.setProjId(actualProjectId);
            projTrans_Virtual.setTransDate(sourceDocumentLineItem.parmAccountingDate());
            projTrans_Virtual.setTransType(ProjectSourceDocumentLineItemHelper::projTransType(sourceDocumentLineItem));

            ProjFundingEngine::updateFundingLimits(projTrans_Virtual,
                                                   actualFundingSource,
                                                   actualTransactionCurrencyAmount,
                                                   false,
                                                   true,
                                               "@SYS4110061");
        }

        return projectActualDetail;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjectActualSalesDetailV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the project actual detail records only for journal lines that were submitted.
    /// </summary>
    /// <param name="_projectRevenueHeader">
    /// A project actual header record.
    /// </param>
    /// <param name="_projectActualHeaderContainer">
    /// A container that contains the project actual header values.
    /// </param>
    /// <param name="_projectActualDetailContainer">
    /// A container that contains the project actual detail values.
    /// </param>
    /// <param name="_voucher">
    /// The voucher number.
    /// </param>
    /// <param name="_canProcessInvoice">
    /// A Boolean value that indicates whether project transactions are invoiced during journalization.
    /// </param>
    /// <returns>
    /// A project actual detail record.
    /// </returns>
    private Common createProjectActualSalesDetailV2(
        Common _projectRevenueHeader,
        container _projectActualHeaderContainer,
        container _projectActualDetailContainer,
        Voucher _voucher,
        boolean _canProcessInvoice)

    {
        #declareProjectActualHeaderContainerVariablesMacro
        #declareProjectActualDetailContainerVariablesMacro
        #declareActualLedgerUpdateContainerVariablesMacro

        Common projectActualDetail;
        ProjLedgerSalesPosted isAccrued;
        ProjTrans_Virtual projTrans_Virtual;
        SourceDocumentLineItem sourceDocumentLineItem;
        SourceDocumentLineItemIProject sourceDocumentLineItemIProject;
        SourceDocumentLineItemIProduct sourceDocumentLineItemIProduct;
        SourceDocumentLineItem topSourceDocumentLineItem;

        PriceCur transactionCurrencyPrice()
        {
            PriceCur ret;

            if (actualQuantity)
            {
                ret = CurrencyExchangeHelper::price(actualTransactionCurrencyAmount / actualQuantity, actualTransactionSalesCurrency);
            }

            return ret;
        }

        AmountMST accountingCurrencyAccruedRevenueAmount()
        {
            return (isAccrued == NoYes::Yes ? actualAccountingCurrencyAmount : 0);
        }

        void setIsAccrued()
        {
            ListEnumerator actualLedgerUpdateEnumerator;

            isAccrued = NoYes::No;

            actualLedgerUpdate = List::create(packedActualLedgerUpdate);
            actualLedgerUpdateEnumerator = actualLedgerUpdate.getEnumerator();
            while (actualLedgerUpdateEnumerator.moveNext())
            {
                #actualLedgerUpdateContainerMacro = actualLedgerUpdateEnumerator.current();
                if (actualLedgerUpdatePostingType == LedgerPostingType::ProjSalesvalue)
                {
                    if (sourceDocumentLineItem is SourceDocumentLineItemIProject)
                    {
                        sourceDocumentLineItemIProject = sourceDocumentLineItem as SourceDocumentLineItemIProject;
                        ProjAdvancedJournalLine projAdvJournalLine;

                        if (sourceDocumentLineItem is ProjAdvancedJournalSourceDocumentLineItem)
                        {
                            ProjAdvancedJournalSourceDocumentLineItem projAdvancedJournalSDLItem = sourceDocumentLineItem as ProjAdvancedJournalSourceDocumentLineItem;
                            projAdvJournalLine = projAdvancedJournalSDLItem.parmProjAdvancedJournalLine();
                        }

                        using (ProjectPostingParameters insertParameters = ProjectPostingParameters::parmProjContractLineNum(projAdvancedJournalLine.ContractLineId))
                        {
                            if (ProjectPosting::canAccrueRevenue(
                                    ProjTable::find(sourceDocumentLineItemIProject.parmProjectId()),
                                                    ProjCategory::find(sourceDocumentLineItemIProject.parmProjectCategoryId()),
                                                    ProjLineProperty::find(sourceDocumentLineItemIProject.parmProjectLineProperty()),
                                                    actualAccountingCurrencyAmount,
                                                    actualFundingSource))
                            {
                                isAccrued = NoYes::Yes;
                                break;
                            }
                        }
                    }
                    else
                    {
                        isAccrued = NoYes::Yes;
                        break;
                    }

                }
            }
        }

        ProjCostTransSale createProjCostTransSale()
        {
            ProjCostTransSale projCostTransSale;

            projCostTransSale = SubledgerJournalizerProjectExtension::initializeProjCostTransSale(_projectRevenueHeader, isAccrued, accountingCurrencyAccruedRevenueAmount(), #projectActualHeaderContainerMacro, #projectActualDetailContainerMacro);

            projCostTransSale.insert();

            return projCostTransSale;
        }

        ProjEmplTransSale createProjEmplTransSale()
        {
            ProjEmplTransSale projEmplTransSale;

            projEmplTransSale.clear();

            projEmplTransSale = SubledgerJournalizerProjectExtension::initializeProjEmplTransSale(_projectRevenueHeader, transactionCurrencyPrice(), isAccrued, accountingCurrencyAccruedRevenueAmount(), #projectActualHeaderContainerMacro, #projectActualDetailContainerMacro);

            projEmplTransSale.insert();

            return projEmplTransSale;
        }

        ProjItemTransSale createProjItemTransSale()
        {
            ProjItemTransSale projItemTransSale;

            projItemTransSale.clear();

            projItemTransSale = SubledgerJournalizerProjectExtension::initializeProjItemTransSale(_projectRevenueHeader, transactionCurrencyPrice(), isAccrued, accountingCurrencyAccruedRevenueAmount(), #projectActualHeaderContainerMacro, #projectActualDetailContainerMacro);

            projItemTransSale.insert();

            return projItemTransSale;
        }

        ProjRevenueTransSale createProjRevenueTransSale()
        {
            ProjRevenueTransSale projRevenueTransSale;

            projRevenueTransSale.clear();

            projRevenueTransSale = SubledgerJournalizerProjectExtension::initializeProjRevenueTransSale(_projectRevenueHeader, transactionCurrencyPrice(), isAccrued, accountingCurrencyAccruedRevenueAmount(), #projectActualHeaderContainerMacro, #projectActualDetailContainerMacro);

            projRevenueTransSale.insert();

            return projRevenueTransSale;
        }

        #clearProjectActualDetailContainerMacro

        #projectActualHeaderContainerMacro = _projectActualHeaderContainer;
        sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(actualSourceDocumentLine));

        #projectActualDetailContainerMacro = _projectActualDetailContainer;

        setIsAccrued();

        switch (_projectRevenueHeader.TableId)
        {
            case tableNum(ProjCostTrans):
                projectActualDetail = createProjCostTransSale();
                break;

            case tableNum(ProjItemTrans):
                projectActualDetail = createProjItemTransSale();
                break;

            case tableNum(ProjRevenueTrans):
                projectActualDetail = createProjRevenueTransSale();
                break;

            case tableNum(ProjEmplTrans):
                projectActualDetail = createProjEmplTransSale();
                break;

            default:
                throw error(strFmt("@SYS22828",funcName()));
        }

        actualReferenceProjectAccountingDistribution = null;
        this.updateProjectAccountingDistributionsV2(projectActualDetail, packedActualReferenceProjectAccountingDistribution);
        SubledgerJournalizerProjectExtension::createLedgerUpdates(_projectRevenueHeader, projectActualDetail, _projectActualHeaderContainer, _projectActualDetailContainer, packedActualLedgerUpdate, _voucher, _canProcessInvoice);

        topSourceDocumentLineItem = ProjectSourceDocumentLineItemHelper::sourceDocumentLineItemTopParent(sourceDocumentLineItem.parmSourceDocumentLine().RecId);

        if (actualFundingSource &&
            !ProjFundingLimitTrackingManager::isUsingDocumentMatching(topSourceDocumentLineItem) &&
            (ProjFundingSource::getFundingType(actualFundingSource) != ProjFundingType::OnHoldFundingSource))
        {
            sourceDocumentLineItemIProject = sourceDocumentLineItem as SourceDocumentLineItemIProject;
            if (sourceDocumentLineItem is SourceDocumentLineItemIProduct)
            {
                sourceDocumentLineItemIProduct = sourceDocumentLineItem as SourceDocumentLineItemIProduct;
            }

            projTrans_Virtual = ProjTrans_Virtual::construct();

            projTrans_Virtual.setActivityNumber(actualActivityNumber);
            projTrans_Virtual.setCategoryId(actualCategoryId);
            projTrans_Virtual.setCurrencyIdSales(actualTransactionSalesCurrency);
            projTrans_Virtual.setResource(sourceDocumentLineItemIProject.parmProjectResourceRecId());
            projTrans_Virtual.setResourceCategory(sourceDocumentLineItemIProject.parmProjectResourceCategoryRecId());
            if (sourceDocumentLineItemIProduct)
            {
                projTrans_Virtual.setItemId(sourceDocumentLineItemIProduct.parmItemId());
            }
            projTrans_Virtual.setLinePropertyId(actualLinePropertyId);
            projTrans_Virtual.setProjId(actualProjectId);
            projTrans_Virtual.setTransDate(sourceDocumentLineItem.parmAccountingDate());
            projTrans_Virtual.setTransType(ProjectSourceDocumentLineItemHelper::projTransType(sourceDocumentLineItem));

            ProjFundingEngine::updateFundingLimits(projTrans_Virtual,
                                                   actualFundingSource,
                                                   actualTransactionCurrencyAmount,
                                                   false,
                                                   true,
                                               "@SYS4110061");
        }

        return projectActualDetail;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreateProjHourTrans</Name>
				<Source><![CDATA[
    private static boolean shouldCreateProjHourTrans(SourceDocumentLineItem _sourceDocumentLineItem)
    {
        SourceDocumentLine sourceDocumentLine = _sourceDocumentLineItem.parmSourceDocumentLine();
        int enumId = enumName2Id(sourceDocumentLine.TypeEnumName);
        SourceDocumentTypeEnumValue sourceDocumentTypeEnumValue = sourceDocumentLine.TypeEnumValue;

        // For ProjOps intercompany vendor invoice scenario, we should not skip creation of hour cost transactions.
        // In this case, the bookable resource legal entity is different from the project legal entity, so have added
        // the following condition to check for intercompany.
        boolean skipCreation = enumId == enumNum(SourceDocumentLine_VendorInvoice)
                                && sourceDocumentTypeEnumValue == SourceDocumentLine_VendorInvoice::VendorInvoiceLine
                                && ProjProjectOperationsIntegrationFeatureHelper::isProcurementCategoriesEnabledWithProjOps()
                                && !ProjectSourceDocumentLineItemHelper::hasIntercompanyLedgerAccount(_sourceDocumentLineItem);

        return !skipCreation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreateProjCostTrans</Name>
				<Source><![CDATA[
    private static boolean shouldCreateProjCostTrans(SourceDocumentLineItem _sourceDocumentLineItem)
    {
        SourceDocumentLine sourceDocumentLine = _sourceDocumentLineItem.parmSourceDocumentLine();
        int enumId = enumName2Id(sourceDocumentLine.TypeEnumName);
        SourceDocumentTypeEnumValue sourceDocumentTypeEnumValue = sourceDocumentLine.TypeEnumValue;

        // For ProjOps intercompany vendor invoice scenario, we should not skip creation of expense cost transactions.
        // In this case, the bookable resource legal entity is different from the project legal entity, so have added
        // the following condition to check for intercompany.
        boolean skipCreation = ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled()
                                && ((enumId == enumNum(SourceDocumentLine_ExpenseReport)
                                    && sourceDocumentTypeEnumValue == SourceDocumentLine_ExpenseReport::ExpenseReportLine)
                                    || (enumId == enumNum(SourceDocumentLine_VendorInvoice)
                                        && sourceDocumentTypeEnumValue == SourceDocumentLine_VendorInvoice::VendorInvoiceLine
                                        && FeatureStateProvider::isFeatureEnabled(ProjOpsEnableProcurementCategoriesFeature::instance())
                                        && !ProjectSourceDocumentLineItemHelper::hasIntercompanyLedgerAccount(_sourceDocumentLineItem)));

        return !skipCreation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreateProjItemTrans</Name>
				<Source><![CDATA[
    protected static boolean shouldCreateProjItemTrans(SourceDocumentLineItem _sourceDocumentLineItem)
    {
        SourceDocumentLine sourceDocumentLine = _sourceDocumentLineItem.parmSourceDocumentLine();
        int enumId = enumName2Id(sourceDocumentLine.TypeEnumName);
        SourceDocumentTypeEnumValue sourceDocumentTypeEnumValue = sourceDocumentLine.TypeEnumValue;

        // For ProjOps intercompany vendor invoice scenario, we should not skip creation of item cost transactions.
        // In this case, the bookable resource legal entity is different from the project legal entity, so have added
        // the following condition to check for intercompany.
        boolean skipCreation = ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled()
                                && enumId == enumNum(SourceDocumentLine_VendorInvoice)
                                && sourceDocumentTypeEnumValue == SourceDocumentLine_VendorInvoice::VendorInvoiceLine
                                && FeatureStateProvider::isFeatureEnabled(ProjProjectOperationsProcurementIntegrationFeature::instance())
                                && !ProjectSourceDocumentLineItemHelper::hasIntercompanyLedgerAccount(_sourceDocumentLineItem);

        if (!skipCreation && ProjSkipDuplicateItemTransCreationFlight::instance().isEnabled())
        {
            // Avoid creation of duplicated transaction for project purchase order created from item requirements with non-stocked item.
            if (_sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
            {
                VendInvoiceInfoLine  vendInvoiceInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(sourceDocumentLine.RecId);
                if (vendInvoiceInfoLine)
                {
                    PurchLine purchLine = vendInvoiceInfoLine.purchLine();
                    SalesLine salesLineLocal = purchLine.salesLine();
                    if (SubledgerJournalizerProjectExtension::checkItemReq(salesLineLocal, purchLine, vendInvoiceInfoLine))
                    {
                        skipCreation = true;
                    }
                }
            }
        }

        return !skipCreation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkItemReq</Name>
				<Source><![CDATA[
    protected static boolean checkItemReq(SalesLine _salesLine, PurchLine _purchLine, VendInvoiceInfoLine _vendInvoiceInfoLine)
    {
        return _salesLine && _salesLine.SalesType == SalesType::ItemReq && !_salesLine.isStocked();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjCostTransSale</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes values to <c>ProjCostTransSale</c> table buffer.
    /// </summary>
    /// <param name = "_projectRevenueHeader">
    /// A project actual header record.
    /// </param>
    /// <param name = "_isAccrued">
    /// A Boolean value that indicates whether transactions are accured revenue.
    /// </param>
    /// <param name = "_accountingCurrencyAccruedRevenueAmount">
    /// The value of accounting currency accured revenue amount.
    /// </param>
    /// <param name="_projectActualHeaderContainer">
    /// A container that contains the project actual header values.
    /// </param>
    /// <param name="_projectActualDetailContainer">
    /// A container that contains the project actual detail values.
    /// </param>
    /// <returns>
    /// The buffer of <c>ProjCostTransSale</c> table.
    /// </returns>
    protected static ProjCostTransSale initializeProjCostTransSale(Common _projectRevenueHeader, boolean _isAccrued, Price _accountingCurrencyAccruedRevenueAmount, container _projectActualHeaderContainer, container _projectActualDetailContainer)
    {
        #declareProjectActualHeaderContainerVariablesMacro
        #declareProjectActualDetailContainerVariablesMacro

        ProjCostTransSale   projCostTransSale;

        #projectActualHeaderContainerMacro = _projectActualHeaderContainer;
        #projectActualDetailContainerMacro = _projectActualDetailContainer;

        SalesPrice salesPrice = actualQuantity ? actualTransactionCurrencyAmount / actualQuantity  : actualTransactionCurrencyAmount;

        ProjCostTrans projCostTrans = _projectRevenueHeader;

        projCostTransSale.TransId = projCostTrans.TransId;

        SourceDocumentLineItem  sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(actualSourceDocumentLine));

        projCostTransSale.LedgerTransdate = sourceDocumentLineItem.parmAccountingDate();
        projCostTransSale.TransStatus = ProjTransStatus::Posted;
        projCostTransSale.wipPeriod = dateNull();
        projCostTransSale.wipType = ProjWIPType::AccruedTurnover;
        projCostTransSale.ControlId = '';
        projCostTransSale.ControlVersion = 0;
        projCostTransSale.FundingSource = actualFundingSource;
        projCostTransSale.DefaultDimension = actualDetailDefaultDimension;
        projCostTransSale.SalesPrice = salesPrice;
        projCostTransSale.LineAmount = actualTransactionCurrencyAmount;

        ProjTable projTable;
        
        select firstonly projTable
            where projTable.ProjId == projCostTrans.ProjId;

        if (projTable.WIPProject &&
            (projTable.Type == ProjType::FixedPrice ||
             (projTable.ProjInvoiceProjId &&
              ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled() &&
              ProjMultipleContractLinesForProjectFeatureHelper::isTransTypeIncludedByBillingMethod(projTable.ProjId, projTable.ProjInvoiceProjId, ProjTransType::Cost, ProjContractBillingMethod::FixedPrice))))
        {
            if (ProjRevRecHelper::getSalesPriceMatchingPrincipleForProjTable(ProjTable::find(projTable.WIPProject)) != ProjSalesPriceMatchingPrincip::None)
            {
                projCostTransSale.LineAmount = 0;
                projCostTransSale.SalesPrice = 0;
            }
        }

        if (_isAccrued && ProjFundingSource::isExternalFunding(projCostTransSale.FundingSource))
        {
            projCostTransSale.LedgerSalesPosted = _isAccrued;
            projCostTransSale.LedgerSalesAmount = _accountingCurrencyAccruedRevenueAmount;
        }

        return projCostTransSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjItemTransSale</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes values to <c>ProjItemTransSale</c> table buffer.
    /// </summary>
    /// <param name = "_projectRevenueHeader">
    /// A project actual header record.
    /// </param>
    /// <param name = "_transactionCurrencyPrice">
    /// The value of transaction currency amount.
    /// </param>
    /// <param name = "_isAccrued">
    /// A Boolean value that indicates whether transactions are accured revenue.
    /// </param>
    /// <param name = "_accountingCurrencyAccruedRevenueAmount">
    /// The value of accounting currency accured revenue amount.
    /// </param>
    /// <param name="_projectActualHeaderContainer">
    /// A container that contains the project actual header values.
    /// </param>
    /// <param name="_projectActualDetailContainer">
    /// A container that contains the project actual detail values.
    /// </param>
    /// <returns>
    /// The buffer of <c>ProjItemTransSale</c> table.
    /// </returns>
    protected static ProjItemTransSale initializeProjItemTransSale(Common _projectRevenueHeader, Price _transactionCurrencyPrice, boolean _isAccrued, Price _accountingCurrencyAccruedRevenueAmount, container _projectActualHeaderContainer, container _projectActualDetailContainer)
    {
        #declareProjectActualHeaderContainerVariablesMacro
        #declareProjectActualDetailContainerVariablesMacro

        ProjItemTrans projItemTrans;
        ProjItemTransSale projItemTransSale;

        #projectActualHeaderContainerMacro = _projectActualHeaderContainer;
        #projectActualDetailContainerMacro = _projectActualDetailContainer;

        projItemTrans = _projectRevenueHeader;

        projItemTransSale.ProjTransId = projItemTrans.ProjTransId;

        SourceDocumentLineItem  sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(actualSourceDocumentLine));

        projItemTransSale.LedgerTransdate = sourceDocumentLineItem.parmAccountingDate();
        projItemTransSale.TransStatus = ProjTransStatus::Posted;
        projItemTransSale.wipPeriod = dateNull();
        projItemTransSale.wipType = ProjWIPType::AccruedTurnover;
        projItemTransSale.ControlId = '';
        projItemTransSale.ControlVersion = 0;
        projItemTransSale.FundingSource = actualFundingSource;
        projItemTransSale.DefaultDimension = actualDetailDefaultDimension;

        ProjTrans projTrans = ProjTrans::newProjItemTrans(projItemTrans);
        // In case of multiple funding sources.
        if (ProjFundingSource::getFundingSources(projTrans).elements() > 1)
        {
            projItemTransSale.SalesPrice = actualQuantity ? (actualTransactionCurrencyAmount / actualQuantity) : actualTransactionCurrencyAmount;
        }
        else
        {
            projItemTransSale.SalesPrice = _transactionCurrencyPrice;
        }

        if (!projItemTrans.ItemId)
        {
            SalesQty salesQty;

            ttsbegin;
                
            PurchLine purchLine = PurchLine::findProjectItemTransId(projItemTrans.ProjTransIdRef);

            // Unit conversion should be skipped for procurement categories.
            salesQty = projItemTrans.Qty;
            
            projItemTransSale.LineAmount = actualTransactionCurrencyAmount;
            projItemTrans = projItemTrans::find(projItemTrans.ProjTransId, true);
            projItemTrans.SalesQty = salesQty;
            projItemTrans.update();
            ttscommit;
        }
        else
        {
            PurchLine purchLine = PurchLine::findProjectItemTransId(projItemTrans.ProjTransIdRef);
            projItemTransSale.LineAmount = PriceDisc::price2Amount(
                                                            projItemTransSale.SalesPrice,
                                                            purchLine.PriceUnit ? purchLine.PriceUnit : projItemTrans.inventTable().salesPriceUnit(),
                                                            0,
                                                            projItemTrans.Qty,
                                                            0,
                                                            0,
                                                            0,
                                                            projItemTrans.CurrencyId,
                                                            0,
                                                            false);
        }

        if (_isAccrued && ProjFundingSource::isExternalFunding(projItemTransSale.FundingSource))
        {
            projItemTransSale.LedgerSalesPosted = true;
            projItemTransSale.LedgerSalesAmount = _accountingCurrencyAccruedRevenueAmount;
        }

        return projItemTransSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjRevenueTransSale</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes values to <c>ProjRevenueTransSale</c> table buffer.
    /// </summary>
    /// <param name = "_projectRevenueHeader">
    /// A project actual header record.
    /// </param>
    /// <param name = "_transactionCurrencyPrice">
    /// The value of transaction currency amount.
    /// </param>
    /// <param name = "_isAccrued">
    /// A Boolean value that indicates whether transactions are accured revenue.
    /// </param>
    /// <param name = "_accountingCurrencyAccruedRevenueAmount">
    /// The value of accounting currency accured revenue amount.
    /// </param>
    /// <param name="_projectActualHeaderContainer">
    /// A container that contains the project actual header values.
    /// </param>
    /// <param name="_projectActualDetailContainer">
    /// A container that contains the project actual detail values.
    /// </param>
    /// <returns>
    /// The buffer of <c>ProjRevenueTransSale</c> table.
    /// </returns>
    protected static ProjRevenueTransSale initializeProjRevenueTransSale(Common _projectRevenueHeader, Price _transactionCurrencyPrice, boolean _isAccrued, Price _accountingCurrencyAccruedRevenueAmount, container _projectActualHeaderContainer, container _projectActualDetailContainer)
    {
        #declareProjectActualHeaderContainerVariablesMacro
        #declareProjectActualDetailContainerVariablesMacro

        ProjRevenueTransSale projRevenueTransSale;

        ProjRevenueTrans projRevenueTrans = _projectRevenueHeader;

        #projectActualHeaderContainerMacro = _projectActualHeaderContainer;
        #projectActualDetailContainerMacro = _projectActualDetailContainer;

        projRevenueTransSale.TransId = projRevenueTrans.TransId;
        SourceDocumentLineItem sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(actualSourceDocumentLine));
        projRevenueTransSale.LedgerTransdate = sourceDocumentLineItem.parmAccountingDate();
        projRevenueTransSale.TransStatus = ProjTransStatus::Posted;
        projRevenueTransSale.wipPeriod = dateNull();
        projRevenueTransSale.wipType = ProjWIPType::AccruedTurnover;
        projRevenueTransSale.ControlId = '';
        projRevenueTransSale.ControlVersion = 0;
        projRevenueTransSale.FundingSource = actualFundingSource;
        projRevenueTransSale.DefaultDimension = actualDetailDefaultDimension;
        projRevenueTransSale.SalesPrice = _transactionCurrencyPrice;
        projRevenueTransSale.LineAmount = actualTransactionCurrencyAmount;

        if (_isAccrued && ProjFundingSource::isExternalFunding(projRevenueTransSale.FundingSource))
        {
            projRevenueTransSale.LedgerSalesPosted = _isAccrued;
            projRevenueTransSale.LedgerSalesAmount = _accountingCurrencyAccruedRevenueAmount;
        }

        return projRevenueTransSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjEmplTransSale</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes values to <c>ProjEmplTransSale</c> table buffer.
    /// </summary>
    /// <param name = "_projectRevenueHeader">
    /// A project actual header record.
    /// </param>
    /// <param name = "_transactionCurrencyPrice">
    /// The value of transaction currency amount.
    /// </param>
    /// <param name = "_isAccrued">
    /// A Boolean value that indicates whether transactions are accured revenue.
    /// </param>
    /// <param name = "_accountingCurrencyAccruedRevenueAmount">
    /// The value of accounting currency accured revenue amount.
    /// </param>
    /// <param name="_projectActualHeaderContainer">
    /// A container that contains the project actual header values.
    /// </param>
    /// <param name="_projectActualDetailContainer">
    /// A container that contains the project actual detail values.
    /// </param>
    /// <returns>
    /// The buffer of <c>ProjEmplTransSale</c> table.
    /// </returns>
    protected static ProjEmplTransSale initializeProjEmplTransSale(Common _projectRevenueHeader, Price _transactionCurrencyPrice, boolean _isAccrued, Price _accountingCurrencyAccruedRevenueAmount, container _projectActualHeaderContainer, container _projectActualDetailContainer)
    {
        ProjEmplTransSale projEmplTransSale;

        #declareProjectActualHeaderContainerVariablesMacro
        #declareProjectActualDetailContainerVariablesMacro

        ProjEmplTrans projEmplTrans = _projectRevenueHeader;

        #projectActualHeaderContainerMacro = _projectActualHeaderContainer;
        #projectActualDetailContainerMacro = _projectActualDetailContainer;

        projEmplTransSale.TransId = projEmplTrans.TransId;
        SourceDocumentLineItem sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(actualSourceDocumentLine));
        projEmplTransSale.LedgerTransdate = sourceDocumentLineItem.parmAccountingDate();
        projEmplTransSale.TransStatus = ProjTransStatus::Posted;
        projEmplTransSale.wipPeriod = dateNull();
        projEmplTransSale.wipType = ProjWIPType::AccruedTurnover;
        projEmplTransSale.ControlId = '';
        projEmplTransSale.ControlVersion = 0;
        projEmplTransSale.FundingSource = actualFundingSource;
        projEmplTransSale.DefaultDimension = actualDefaultDimension;

        if (sourceDocumentLineItem is TSTimesheetTransSourceDocLineItem)
        {
            TSTimesheetTransSourceDocLineItem tsTimesheetTransSourceDocLineItem = sourceDocumentLineItem as TSTimesheetTransSourceDocLineItem;

            ProjTrans projTrans = ProjTrans::newProjEmplTrans(projEmplTrans);

            ProjTable projTable;
            select firstonly projTable where projTable.ProjId == projEmplTrans.ProjId;

            if (projTable.WIPProject &&
                ProjMultipleContractLinesForProjectFeatureHelper::isFixedPriceBillingMethod(projTable, ProjTransType::Hour) &&
                ProjRevRecHelper::getSalesPriceMatchingPrincipleForProjTable(ProjTable::find(projTable.WIPProject)) != ProjSalesPriceMatchingPrincip::None)
            {
                projEmplTransSale.SalesPrice = 0;
            }
            else
            {

                // In case of multiple funding sources.
                if (ProjFundingSource::getFundingSources(projTrans).elements() > 1)
                {
                    projEmplTransSale.SalesPrice = actualQuantity ? (actualTransactionCurrencyAmount / actualQuantity) : actualTransactionCurrencyAmount;
                }
                else
                {
                    projEmplTransSale.SalesPrice = tsTimesheetTransSourceDocLineItem.parmProjectSalesPrice();
                }
            }

            actualTransactionCurrencyAmount = CurrencyExchangeHelper::amount(projEmplTrans.Qty * projEmplTransSale.SalesPrice, projEmplTrans.CurrencyId);
        }
        else
        {
            projEmplTransSale.SalesPrice = _transactionCurrencyPrice;
        }

        projEmplTransSale.LineAmount = actualTransactionCurrencyAmount;

        if (_isAccrued && ProjFundingSource::isExternalFunding(projEmplTransSale.FundingSource))
        {
            projEmplTransSale.LedgerSalesPosted = _isAccrued;
            projEmplTransSale.LedgerSalesAmount = _accountingCurrencyAccruedRevenueAmount;
        }

        return projEmplTransSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>distributionsForAccrual</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a query for the <c>AccountingDistribution</c> and <c>ProjectAccountingDistribution</c>
    /// records that will is to accrue project revenues.
    /// </summary>
    /// <param name="_sourceDocumentHeader">
    /// A record in the <c>_sourceDocumentHeader</c> table.
    /// </param>
    /// <param name="_currency">
    /// The currency value filter; optional
    /// </param>
    /// <param name="_transactionSalesLegalEntityRecId">
    /// The legal entity value filter; optional
    /// </param>
    /// <param name="_accountingDate">
    /// The accounting date value filter; optional
    /// </param>
    /// <param name="_transactionCurrencyAmountSign">
    /// Sign of the amount in transaction currency; optional
    /// </param>
    /// <returns>
    /// A query for the <c>AccountingDistribution</c> and <c>ProjectAccountingDistribution</c> records.
    /// </returns>
    public static Query distributionsForAccrual(
    SourceDocumentHeader _sourceDocumentHeader,
    RefRecId             _currency = 0,
    LegalEntityRecId     _transactionSalesLegalEntityRecId = 0,
    AccountingDate       _accountingDate = dateNull(),
    int                  _transactionCurrencyAmountSign = 0)
    {
        Query                   query;
        QueryBuildDataSource    qbdsProjectAccountingDistribution;
        QueryBuildDataSource    qbdsAccountingDistribution;
        QueryBuildDataSource    qbdsProjLineProperty;
        QueryBuildRange         qbrCurrency;
        QueryBuildRange         qbrLegalEntity;
        QueryBuildRange         qbrToBeAccrued;
        QueryBuildRange         qbrAccountingDate;
        QueryBuildRange         qbrTransactionCurrencyAmount;
        str                     transactionCurrencyAmountSignRange;

        query = SubledgerJournalizerProjectExtension::distributionsForJournalization(_sourceDocumentHeader);

        qbdsProjectAccountingDistribution = query.dataSourceTable(tableNum(ProjectAccountingDistribution));
        qbdsAccountingDistribution        = query.dataSourceTable(tableNum(AccountingDistribution));

        if (_currency)
        {
            qbrCurrency = qbdsProjectAccountingDistribution.addRange(fieldNum(ProjectAccountingDistribution, Currency));
            qbrCurrency.value(SysQuery::value(_currency));
        }

        if (_transactionSalesLegalEntityRecId)
        {
            qbrLegalEntity = qbdsAccountingDistribution.addRange(fieldNum(AccountingDistribution, AccountingLegalEntity));
            qbrLegalEntity.value(SysQuery::value(_transactionSalesLegalEntityRecId));
        }

        if (_accountingDate)
        {
            qbrAccountingDate = qbdsAccountingDistribution.addRange(fieldNum(AccountingDistribution, AccountingDate));
            qbrAccountingDate.value(SysQuery::value(_accountingDate));
        }
        // summarize positive and negative lines separately
        if (_transactionCurrencyAmountSign)
        {
            qbrTransactionCurrencyAmount = qbdsProjectAccountingDistribution.addRange(fieldNum(ProjectAccountingDistribution, TransactionCurrencyAmount));
            transactionCurrencyAmountSignRange = _transactionCurrencyAmountSign == 1? '(%1 >= 0)' : '(%1 <= 0)';
            qbrTransactionCurrencyAmount.value(strFmt(transactionCurrencyAmountSignRange, fieldStr(ProjectAccountingDistribution, TransactionCurrencyAmount)));
        }

        qbdsProjLineProperty = qbdsProjectAccountingDistribution.addDataSource(tableNum(ProjLineProperty));
        qbdsProjLineProperty.joinMode(JoinMode::ExistsJoin);
        qbdsProjLineProperty.relations(false);
        qbdsProjLineProperty.addLink(fieldNum(ProjectAccountingDistribution, ProjLineProperty), fieldNum(ProjLineProperty, RecId));
        qbrToBeAccrued = qbdsProjLineProperty.addRange(fieldNum(ProjLineProperty, ToBeAccrued));
        qbrToBeAccrued.value(SysQuery::value(boolean::true));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>distributionsForAccrualV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a query for the <c>AccountingDistribution</c> and <c>ProjectAccountingDistribution</c> for only return the lines are submitted.
    /// records that will is to accrue project revenues.
    /// </summary>
    /// <param name="_sourceDocument">
    /// A record in the <c>_sourceDocument</c> table.
    /// </param>
    /// <param name="_currency">
    /// The currency value filter; optional
    /// </param>
    /// <param name="_transactionSalesLegalEntityRecId">
    /// The legal entity value filter; optional
    /// </param>
    /// <param name="_accountingDate">
    /// The accounting date value filter; optional
    /// </param>
    /// <param name="_transactionCurrencyAmountSign">
    /// Sign of the amount in transaction currency; optional
    /// </param>
    /// <returns>
    /// A query for the <c>AccountingDistribution</c> and <c>ProjectAccountingDistribution</c> records for only return the lines are submitted.
    /// </returns>
    public static Query distributionsForAccrualV2(
    SourceDocument      _sourceDocument,
    RefRecId            _currency = 0,
    LegalEntityRecId    _transactionSalesLegalEntityRecId = 0,
    AccountingDate      _accountingDate = dateNull(),
    int                 _transactionCurrencyAmountSign = 0)
    {
        Query                   query;
        QueryBuildDataSource    qbdsProjectAccountingDistribution;
        QueryBuildDataSource    qbdsAccountingDistribution;
        QueryBuildDataSource    qbdsProjLineProperty;
        QueryBuildRange         qbrCurrency;
        QueryBuildRange         qbrLegalEntity;
        QueryBuildRange         qbrToBeAccrued;
        QueryBuildRange         qbrAccountingDate;
        QueryBuildRange         qbrTransactionCurrencyAmount;
        str                     transactionCurrencyAmountSignRange;

        query = SubledgerJournalizerProjectExtension::distributionsForJournalizationV2(_sourceDocument);

        qbdsProjectAccountingDistribution = query.dataSourceTable(tableNum(ProjectAccountingDistribution));
        qbdsAccountingDistribution        = query.dataSourceTable(tableNum(AccountingDistribution));

        if (_currency)
        {
            qbrCurrency = qbdsProjectAccountingDistribution.addRange(fieldNum(ProjectAccountingDistribution, Currency));
            qbrCurrency.value(SysQuery::value(_currency));
        }

        if (_transactionSalesLegalEntityRecId)
        {
            qbrLegalEntity = qbdsAccountingDistribution.addRange(fieldNum(AccountingDistribution, AccountingLegalEntity));
            qbrLegalEntity.value(SysQuery::value(_transactionSalesLegalEntityRecId));
        }

        if (_accountingDate)
        {
            qbrAccountingDate = qbdsAccountingDistribution.addRange(fieldNum(AccountingDistribution, AccountingDate));
            qbrAccountingDate.value(SysQuery::value(_accountingDate));
        }
        // summarize positive and negative lines separately
        if (_transactionCurrencyAmountSign)
        {
            qbrTransactionCurrencyAmount = qbdsProjectAccountingDistribution.addRange(fieldNum(ProjectAccountingDistribution, TransactionCurrencyAmount));
            transactionCurrencyAmountSignRange = _transactionCurrencyAmountSign == 1? '(%1 >= 0)' : '(%1 <= 0)';
            qbrTransactionCurrencyAmount.value(strFmt(transactionCurrencyAmountSignRange, fieldStr(ProjectAccountingDistribution, TransactionCurrencyAmount)));
        }

        qbdsProjLineProperty = qbdsProjectAccountingDistribution.addDataSource(tableNum(ProjLineProperty));
        qbdsProjLineProperty.joinMode(JoinMode::ExistsJoin);
        qbdsProjLineProperty.relations(false);
        qbdsProjLineProperty.addLink(fieldNum(ProjectAccountingDistribution, ProjLineProperty), fieldNum(ProjLineProperty, RecId));
        qbrToBeAccrued = qbdsProjLineProperty.addRange(fieldNum(ProjLineProperty, ToBeAccrued));
        qbrToBeAccrued.value(SysQuery::value(boolean::true));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>distributionsForAccrualQueryRun</Name>
				<Source><![CDATA[
    public static QueryRun distributionsForAccrualQueryRun(
    SourceDocumentHeader _sourceDocumentHeader,
    RefRecId             _currency = 0,
    LegalEntityRecId     _transactionSalesLegalEntityRecId = 0,
    AccountingDate       _accountingDate = dateNull(),
    int                  _transactionCurrencyAmountSign = 0)
    {
        Query                   query;
        QueryBuildDataSource    qbdsProjectAccountingDistribution;
        QueryBuildDataSource    qbdsAccountingDistribution;
        QueryBuildDataSource    qbdsProjLineProperty;
        QueryBuildRange         qbrCurrency;
        QueryBuildRange         qbrLegalEntity;
        QueryBuildRange         qbrToBeAccrued;
        QueryBuildRange         qbrAccountingDate;
        QueryBuildRange         qbrTransactionCurrencyAmount;
        str                     transactionCurrencyAmountSignRange;

        query = SubledgerJournalizerProjectExtension::distributionsForAccrual(_sourceDocumentHeader,
                                                                              _currency,
                                                                              _transactionSalesLegalEntityRecId,
                                                                              _accountingDate,
                                                                              _transactionCurrencyAmountSign);
        
        QueryRun queryRun = new QueryRun(query);
        queryRun.setRecord(accountingEventTmp);
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>distributionsForAccrualQueryRunV2</Name>
				<Source><![CDATA[
    public static QueryRun distributionsForAccrualQueryRunV2(
    SourceDocument _sourceDocument,
    RefRecId             _currency = 0,
    LegalEntityRecId     _transactionSalesLegalEntityRecId = 0,
    AccountingDate       _accountingDate = dateNull(),
    int                  _transactionCurrencyAmountSign = 0)
    {
        Query                   query;
        QueryBuildDataSource    qbdsProjectAccountingDistribution;
        QueryBuildDataSource    qbdsAccountingDistribution;
        QueryBuildDataSource    qbdsProjLineProperty;
        QueryBuildRange         qbrCurrency;
        QueryBuildRange         qbrLegalEntity;
        QueryBuildRange         qbrToBeAccrued;
        QueryBuildRange         qbrAccountingDate;
        QueryBuildRange         qbrTransactionCurrencyAmount;
        str                     transactionCurrencyAmountSignRange;

        query = SubledgerJournalizerProjectExtension::distributionsForAccrualV2(
                                                                              _sourceDocument,
                                                                              _currency,
                                                                              _transactionSalesLegalEntityRecId,
                                                                              _accountingDate,
                                                                              _transactionCurrencyAmountSign);
        
        QueryRun queryRun = new QueryRun(query);
        queryRun.setRecord(accountingEventTmp);
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>distributionsForJournalization</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a query for the <c>AccountingDistribution</c> and <c>ProjectAccountingDistribution</c> records
    /// that is used to create project actuals.
    /// </summary>
    /// <param name="_sourceDocumentHeader">
    /// A record in the <c>_sourceDocumentHeader</c> table.
    /// </param>
    /// <returns>
    /// A query for the <c>AccountingDistribution</c> and <c>ProjectAccountingDistribution</c> records.
    /// </returns>
    private static Query distributionsForJournalization(SourceDocumentHeader _sourceDocumentHeader)
    {
        QueryBuildDataSource qbdsAccountingDistribution;
        QueryBuildDataSource qbdsAccountingEventTmp;

        List accountingEventList = SubledgerJournalizerProjectExtension::getAccountingEvents(_sourceDocumentHeader);
        ListEnumerator accountingEventListEnumerator = accountingEventList.getEnumerator();
        Query query = new Query();
        query.allowCrossCompany(true);

        boolean useAccountingEventTmp = SubledgerJournalizerProjectExtension::canUseAccountingEventTmp(_sourceDocumentHeader.TypeEnumName);

        if (useAccountingEventTmp)
        {
            // Use <c>AccountingEventTmp</c> table to store all the accounting events for which to query from. This is needed for over
            // 2000 lines of project advanced journal lines to post successfully and avoid hitting the sql query parameter limit for
            // dynamically created queries in cases of large number of accounting events.
            delete_from accountingEventTmp;
            while (accountingEventListEnumerator.moveNext())
            {
                accountingEventTmp.AccountingEventRecId = accountingEventListEnumerator.current();
                accountingEventTmp.insert();
            }
   
            if (ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
            {
                qbdsAccountingEventTmp = query.addDataSource(tableNum(AccountingEventTmp));
                qbdsAccountingDistribution = qbdsAccountingEventTmp.addDataSource(tableNum(AccountingDistribution));
                qbdsAccountingDistribution.joinMode(JoinMode::InnerJoin);
                qbdsAccountingDistribution.relations(false);
                qbdsAccountingDistribution.addLink(fieldNum(AccountingEventTmp, AccountingEventRecId), fieldNum(AccountingDistribution, AccountingEvent));
            }
            else
            {
                qbdsAccountingDistribution = query.addDataSource(tableNum(AccountingDistribution));
            }
        }
        else
        {
            qbdsAccountingDistribution = query.addDataSource(tableNum(AccountingDistribution));
        }

        QueryBuildDataSource qbdsProjectAccountingDistribution = qbdsAccountingDistribution.addDataSource(tableNum(ProjectAccountingDistribution));
        qbdsProjectAccountingDistribution.fetchMode(QueryFetchMode::One2One);
        qbdsProjectAccountingDistribution.joinMode(JoinMode::InnerJoin);
        qbdsProjectAccountingDistribution.relations(false);
        qbdsProjectAccountingDistribution.addLink(fieldNum(AccountingDistribution, RecId), fieldNum(ProjectAccountingDistribution, AccountingDistribution));
        qbdsProjectAccountingDistribution.addRange(fieldNum(ProjectAccountingDistribution, ProjCostTransCost)).value(strFmt('@Proj:ProjCostTransCostRangeValue',
                                                        fieldStr(ProjectAccountingDistribution, ProjCostTransCost), SysQuery::value(0)));
        qbdsProjectAccountingDistribution.addRange(fieldNum(ProjectAccountingDistribution, ProjCostTransSale)).value(SysQuery::value(0));
        qbdsProjectAccountingDistribution.addRange(fieldNum(ProjectAccountingDistribution, ProjItemTransCost)).value(strFmt('@Proj:ProjCostTransCostRangeValue',
                                                        fieldStr(ProjectAccountingDistribution, ProjItemTransCost), SysQuery::value(0)));
        qbdsProjectAccountingDistribution.addRange(fieldNum(ProjectAccountingDistribution, ProjItemTransSale)).value(SysQuery::value(0));
        qbdsProjectAccountingDistribution.addRange(fieldNum(ProjectAccountingDistribution, ProjRevenueTransSale)).value(SysQuery::value(0));

        QueryBuildDataSource qbdsProjCostTransCost = qbdsProjectAccountingDistribution.addDataSource(tableNum(ProjCostTransCost));
        qbdsProjCostTransCost.joinMode(JoinMode::NoExistsJoin);
        qbdsProjCostTransCost.relations(false);
        qbdsProjCostTransCost.addLink(fieldNum(ProjectAccountingDistribution, ProjCostTransCost), fieldNum(ProjCostTransCost, RecId));

        if (useAccountingEventTmp)
        {
            QueryBuildDataSource qbdsLedgerSubQuery = SubledgerJournalizerProjectExtension::addLedgerSubQuery(qbdsAccountingDistribution);

            if (qbdsLedgerSubQuery)
            {
                qbdsAccountingEventTmp = qbdsLedgerSubQuery.addDataSource(tableNum(AccountingEventTmp));
                qbdsAccountingEventTmp.joinMode(JoinMode::InnerJoin);
                qbdsAccountingEventTmp.relations(false);
                qbdsAccountingEventTmp.addLink(fieldNum(SubledgerJournalEntry, AccountingEvent), fieldNum(AccountingEventTmp, AccountingEventRecId));
            }
        }
        else
        {
            SubledgerJournalizerProjectExtension::addLedgerSubQuery(qbdsAccountingDistribution);

            while (accountingEventListEnumerator.moveNext())
            {
                SubledgerJournalizerProjectExtension::getAccountingEventQueryRange(query).value(SysQuery::value(accountingEventListEnumerator.current()));
            }
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>distributionsForJournalizationV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a query for the <c>AccountingDistribution</c> and <c>ProjectAccountingDistribution</c> records
    /// that is used to create project actuals.  The query will only return the lines are submitted.
    /// </summary>
    /// <param name="_sourceDocument">
    /// A <c>SourceDocument</c> class object.
    /// </param>
    /// <returns>
    /// A query for the <c>AccountingDistribution</c> and <c>ProjectAccountingDistribution</c> records.
    /// </returns>
    private static Query distributionsForJournalizationV2(SourceDocument _sourceDocument)
    {
        QueryBuildDataSource qbdsAccountingDistribution;
        QueryBuildDataSource qbdsAccountingEventTmp;

        List accountingEventList = SubledgerJournalizerProjectExtension::getAccountingEventsV2(_sourceDocument);
        ListEnumerator accountingEventListEnumerator = accountingEventList.getEnumerator();
        Query query = new Query();
        query.allowCrossCompany(true);
        
        boolean enableProjJournalPostingAccountingDistributionFix = enumName2Id(_sourceDocument.parmSourceDocumentHeader().typeEnumName) == enumNum(SourceDocument_ProjAdvancedJournal);
        if (enableProjJournalPostingAccountingDistributionFix)
        {
            // Use <c>AccountingEventTmp</c> table to store all the accounting events for which to query from. This is needed for over
            // 2000 lines of project advanced journal lines to post successfully and avoid hitting the sql query parameter limit for
            // dynamically created queries in cases of large number of accounting events.
            delete_from accountingEventTmp;
            while (accountingEventListEnumerator.moveNext())
            {
                accountingEventTmp.AccountingEventRecId = accountingEventListEnumerator.current();
                accountingEventTmp.insert();
            }
   
            if (ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
            {
                qbdsAccountingEventTmp = query.addDataSource(tableNum(AccountingEventTmp));
                qbdsAccountingDistribution = qbdsAccountingEventTmp.addDataSource(tableNum(AccountingDistribution));
                qbdsAccountingDistribution.joinMode(JoinMode::InnerJoin);
                qbdsAccountingDistribution.relations(false);
                qbdsAccountingDistribution.addLink(fieldNum(AccountingEventTmp, AccountingEventRecId), fieldNum(AccountingDistribution, AccountingEvent));
            }
            else
            {
                qbdsAccountingDistribution = query.addDataSource(tableNum(AccountingDistribution));
            }
        }
        else
        {
            qbdsAccountingDistribution = query.addDataSource(tableNum(AccountingDistribution));
        }

        QueryBuildDataSource qbdsProjectAccountingDistribution = qbdsAccountingDistribution.addDataSource(tableNum(ProjectAccountingDistribution));
        qbdsProjectAccountingDistribution.fetchMode(QueryFetchMode::One2One);
        qbdsProjectAccountingDistribution.joinMode(JoinMode::InnerJoin);
        qbdsProjectAccountingDistribution.relations(false);
        qbdsProjectAccountingDistribution.addLink(fieldNum(AccountingDistribution, RecId), fieldNum(ProjectAccountingDistribution, AccountingDistribution));
        qbdsProjectAccountingDistribution.addRange(fieldNum(ProjectAccountingDistribution, ProjCostTransCost)).value(strFmt('@Proj:ProjCostTransCostRangeValue',
                                                        fieldStr(ProjectAccountingDistribution, ProjCostTransCost), SysQuery::value(0)));
        qbdsProjectAccountingDistribution.addRange(fieldNum(ProjectAccountingDistribution, ProjCostTransSale)).value(SysQuery::value(0));
        qbdsProjectAccountingDistribution.addRange(fieldNum(ProjectAccountingDistribution, ProjItemTransCost)).value(strFmt('@Proj:ProjCostTransCostRangeValue',
                                                        fieldStr(ProjectAccountingDistribution, ProjItemTransCost), SysQuery::value(0)));
        qbdsProjectAccountingDistribution.addRange(fieldNum(ProjectAccountingDistribution, ProjItemTransSale)).value(SysQuery::value(0));
        qbdsProjectAccountingDistribution.addRange(fieldNum(ProjectAccountingDistribution, ProjRevenueTransSale)).value(SysQuery::value(0));

        QueryBuildDataSource qbdsProjCostTransCost = qbdsProjectAccountingDistribution.addDataSource(tableNum(ProjCostTransCost));
        qbdsProjCostTransCost.joinMode(JoinMode::NoExistsJoin);
        qbdsProjCostTransCost.relations(false);
        qbdsProjCostTransCost.addLink(fieldNum(ProjectAccountingDistribution, ProjCostTransCost), fieldNum(ProjCostTransCost, RecId));

        if (enableProjJournalPostingAccountingDistributionFix)
        {
            QueryBuildDataSource qbdsLedgerSubQuery = SubledgerJournalizerProjectExtension::addLedgerSubQuery(qbdsAccountingDistribution);

            if (qbdsLedgerSubQuery)
            {
                qbdsAccountingEventTmp = qbdsLedgerSubQuery.addDataSource(tableNum(AccountingEventTmp));
                qbdsAccountingEventTmp.joinMode(JoinMode::InnerJoin);
                qbdsAccountingEventTmp.relations(false);
                qbdsAccountingEventTmp.addLink(fieldNum(SubledgerJournalEntry, AccountingEvent), fieldNum(AccountingEventTmp, AccountingEventRecId));
            }
        }
        else
        {
            SubledgerJournalizerProjectExtension::addLedgerSubQuery(qbdsAccountingDistribution);

            while (accountingEventListEnumerator.moveNext())
            {
                SubledgerJournalizerProjectExtension::getAccountingEventQueryRange(query).value(SysQuery::value(accountingEventListEnumerator.current()));
            }
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountingEventQueryRange</Name>
				<Source><![CDATA[
    private static QueryBuildRange getAccountingEventQueryRange(Query _query)
    {
        QueryBuildRange accountingEventRange;
        if (ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
        {
            accountingEventRange = _query.dataSourceTable(tableNum(AccountingDistribution)).addRange(fieldNum(AccountingDistribution, AccountingEvent));
        }
        else
        {
            accountingEventRange = _query.dataSourceTable(tableNum(SubledgerJournalEntry)).addRange(fieldNum(SubledgerJournalEntry, AccountingEvent));
        }
        return accountingEventRange;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountingEvents</Name>
				<Source><![CDATA[
    private static List getAccountingEvents(SourceDocumentHeader _sourceDocumentHeader)
    {
        List accountingEvents = new List(Types::Int64);

        AccountingEvent accountingEvent;
        while select RecId from accountingEvent
        where accountingEvent.SourceDocumentHeader == _sourceDocumentHeader.RecId
           && (accountingEvent.State == AccountingEventState::Complete
                || accountingEvent.State == AccountingEventState::Journalized)
        {
            accountingEvents.addEnd(accountingEvent.RecId);
        }

        if (!accountingEvents.elements())
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }
        return accountingEvents;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountingEventsV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method gets accounting events for the submitted journal lines only
    /// </summary>
    /// <param name="_sourceDocument">
    /// A <c>SourceDocument</c> class object.
    /// </param>
    /// <returns>
    /// A list of for the <c>AccountingEvent</c> record IDs.
    /// </returns>
    [Replaceable]
    protected static List getAccountingEventsV2(SourceDocument _sourceDocument)
    {
        List accountingEvents;
        ProjOpsFinancialsLogger logger = ProjOpsFinancialsLogger::createLogger(classStr(SubledgerJournalizerProjectExtension));
        SourceDocumentHeaderRecId sdhRecId = _sourceDocument.parmSourceDocumentHeader().RecId;
        boolean sourceDocumentRetryFlightEnabled = ProjAdvancedJournalPostingSourceDocumentRetryFlight::instance().isEnabled();
        int retryAllowed = SubledgerJournalizerProjectExtension::getRetryAllowedCount();
        
        if (sourceDocumentRetryFlightEnabled)
        {
            accountingEvents = SubledgerJournalizerProjectExtension::getAccountingEventsV2Enhanced(_sourceDocument, sdhRecId, logger);
        }
        else
        {
            int currentExecutionCount = 1;
            
            while (currentExecutionCount <= retryAllowed)
            {
                accountingEvents = SubledgerJournalizerProjectExtension::getAccountingEventsV2Enhanced(_sourceDocument, sdhRecId, logger);

                if (accountingEvents.elements() == 0 && currentExecutionCount < retryAllowed)
                {
                    // Sleep time starting from 0.5 seconds up to 2.0 seconds.
                    sleep(ProjConstants::DeadLockRetryInterval * currentExecutionCount);
                }
                else
                {
                    const str loggerFoundMsg = 'Method: %1. AccountingEvent is found. Retry counter: %2. SourceDocumentHeader: %3.';
                    logger.logInformation(strFmt(loggerFoundMsg, 'SubledgerJournalizerProjectExtension.getAccountingEventsV2()',
                        int2Str(currentExecutionCount), sdhRecId));
                    break;
                }

                currentExecutionCount++;
            }
        }
        
        if (accountingEvents.elements() == 0)
        {
            const str LoggerExceptionMsg = 'Exception type: %1. Method: %2. AccountingEvent not found. Retries exceeded max limit of: %3. SourceDocumentHeader: %4.';
            logger.logError(strFmt(LoggerExceptionMsg, 'Error', int2Str(retryAllowed),
                'SubledgerJournalizerProjectExtension.getAccountingEventsV2()', sdhRecId));
           
            if (sourceDocumentRetryFlightEnabled)
            {
                throw error(strFmt("@Proj:JournalLinePostingAccountingEventNotFound", _sourceDocument.parmDocumentNumber()));
            }

            throw error(Error::wrongUseOfFunction(funcName()));
        }

        return accountingEvents;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRetryAllowedCount</Name>
				<Source><![CDATA[
    protected static int getRetryAllowedCount()
    {
        const int RetryAllowed = 5;
        return RetryAllowed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountingEventsV2Original</Name>
				<Source><![CDATA[
    private static List getAccountingEventsV2Original(SourceDocument _sourceDocument, SourceDocumentHeaderRecId _sdhRecId, ProjOpsFinancialsLogger _logger)
    {
        const str LoggerInformationMsg = 'Method: %1. While loop records. SourceDocumentHeader: %2. AccountingDistribution: %3. AEState: %4. AEType: %5.';

        List accountingEvents = new List(Types::Int64);
        Map sourceDocumentLines = _sourceDocument.parmSourceDocumentLinesForCurrentVoucher();
        MapEnumerator sourceDocumentLinesEnum = sourceDocumentLines.getEnumerator();
        
        while (sourceDocumentLinesEnum.moveNext())
        {
            RefRecId sourceDocumentLineRecId = sourceDocumentLinesEnum.currentKey();
            boolean accountingEventAdded = false;

            AccountingEvent accountingEvent;
            AccountingDistribution accountingDistribution;

            while select RecId, State, Type from accountingEvent
                join accountingDistribution
                where accountingDistribution.SourceDocumentLine == sourceDocumentLineRecId
                      && accountingEvent.RecId == accountingDistribution.accountingEvent
            {
                _logger.logInformation(strFmt(LoggerInformationMsg, 'SubledgerJournalizerProjectExtension.getAccountingEventsV2Original()',
                    _sdhRecId, accountingDistribution.RecId,
                    enum2Symbol(enumNum(AccountingEventState), accountingEvent.State),
                    enum2Symbol(enumNum(AccountingEventType), accountingEvent.Type)));

                if (!accountingEventAdded)
                {
                    accountingEvents.addEnd(accountingDistribution.AccountingEvent);
                    accountingEventAdded = true;
                }
            }
        }

        return accountingEvents;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountingEventsV2Enhanced</Name>
				<Source><![CDATA[
    private static List getAccountingEventsV2Enhanced(SourceDocument _sourceDocument, SourceDocumentHeaderRecId _sdhRecId, ProjOpsFinancialsLogger _logger)
    {
        const str LoggerInformationMsg = 'Method: %1. While loop records. SourceDocumentHeader: %2. SourceDocumentLine: %3. AccountingDistribution: %4. SDLAccountingStatus: %5. AEState:%6. AEType: %7.';
        
        List accountingEvents = new List(Types::Int64);
        Map sourceDocumentLines = _sourceDocument.parmSourceDocumentLinesForCurrentVoucher();
        MapEnumerator sourceDocumentLinesEnum = sourceDocumentLines.getEnumerator();
        
        while (sourceDocumentLinesEnum.moveNext())
        {
            RefRecId sourceDocumentLineRecId = sourceDocumentLinesEnum.currentKey();

            AccountingEvent accountingEvent;
            AccountingDistribution accountingDistribution;
            SourceDocumentLine sourceDocumentLine;

            while select RecId, AccountingStatus from sourceDocumentLine
                where sourceDocumentLine.RecId == sourceDocumentLineRecId
            join RecId, AccountingEvent from accountingDistribution
                where accountingDistribution.SourceDocumentLine == sourceDocumentLine.RecId
            join RecId, State, Type from accountingEvent
                where accountingEvent.RecId == accountingDistribution.AccountingEvent
            {
                _logger.logInformation(strFmt(LoggerInformationMsg, 'SubledgerJournalizerProjectExtension.getAccountingEventsV2Enhanced()',
                    _sdhRecId, sourceDocumentLine.RecId, accountingDistribution.RecId,
                    enum2Symbol(enumNum(SourceDocumentLineAccountingStatus), sourceDocumentLine.AccountingStatus),
                    enum2Symbol(enumNum(AccountingEventState), accountingEvent.State),
                    enum2Symbol(enumNum(AccountingEventType), accountingEvent.Type)));
                    
                if (sourceDocumentLine.AccountingStatus == SourceDocumentLineAccountingStatus::Completed)
                {
                    accountingEvents.addEnd(accountingDistribution.AccountingEvent);
                    break;
                }
            }
        }

        return accountingEvents;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerSubQuery</Name>
				<Source><![CDATA[
    private static QueryBuildDataSource addLedgerSubQuery(QueryBuildDataSource _qbdsAccountingDistribution)
    {
        QueryBuildDataSource qbdsSubLedgerJournalEntry = null;

        if (!ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
        {
            QueryBuildDataSource qbdsSubLedgerJournalAccountEntryDistribution = _qbdsAccountingDistribution.addDataSource(tableNum(SubledgerJournalAccountEntryDistribution));
            qbdsSubLedgerJournalAccountEntryDistribution.joinMode(JoinMode::ExistsJoin);
            qbdsSubLedgerJournalAccountEntryDistribution.relations(false);
            qbdsSubLedgerJournalAccountEntryDistribution.addLink(fieldNum(AccountingDistribution, RecId), fieldNum(SubledgerJournalAccountEntryDistribution, AccountingDistribution));

            QueryBuildDataSource qbdsSubLedgerJournalAccountEntry = qbdsSubLedgerJournalAccountEntryDistribution.addDataSource(tableNum(SubledgerJournalAccountEntry));
            qbdsSubLedgerJournalAccountEntry.joinMode(JoinMode::InnerJoin);
            qbdsSubLedgerJournalAccountEntry.relations(false);
            qbdsSubLedgerJournalAccountEntry.addLink(fieldNum(SubledgerJournalAccountEntryDistribution, SubledgerJournalAccountEntry), fieldNum(SubledgerJournalAccountEntry, RecId));
            qbdsSubLedgerJournalAccountEntry = SubledgerJournalizerProjectExtension::addSubledgerJournalAccountEntriesPostingTypeRanges(qbdsSubLedgerJournalAccountEntry);

            qbdsSubLedgerJournalEntry = qbdsSubLedgerJournalAccountEntry.addDataSource(tableNum(SubledgerJournalEntry));
            qbdsSubLedgerJournalEntry.joinMode(JoinMode::InnerJoin);
            qbdsSubLedgerJournalEntry.relations(false);
            qbdsSubLedgerJournalEntry.addLink(fieldNum(SubledgerJournalAccountEntry, SubledgerJournalEntry), fieldNum(SubledgerJournalEntry, RecId));
        }

        return qbdsSubLedgerJournalEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSubledgerJournalAccountEntriesPostingTypeRanges</Name>
				<Source><![CDATA[
    public static QueryBuildDataSource addSubledgerJournalAccountEntriesPostingTypeRanges(QueryBuildDataSource _qbdsSubLedgerJournalAccountEntry)
    {
        _qbdsSubLedgerJournalAccountEntry.addRange(fieldNum(SubledgerJournalAccountEntry, PostingType)).value(SysQuery::value(LedgerPostingType::PurchConsump));
        _qbdsSubLedgerJournalAccountEntry.addRange(fieldNum(SubledgerJournalAccountEntry, PostingType)).value(SysQuery::value(LedgerPostingType::ProjStatusAccountItem));
        _qbdsSubLedgerJournalAccountEntry.addRange(fieldNum(SubledgerJournalAccountEntry, PostingType)).value(SysQuery::value(LedgerPostingType::ProjWIPCostvalue));
        _qbdsSubLedgerJournalAccountEntry.addRange(fieldNum(SubledgerJournalAccountEntry, PostingType)).value(SysQuery::value(LedgerPostingType::ProjCost));
        _qbdsSubLedgerJournalAccountEntry.addRange(fieldNum(SubledgerJournalAccountEntry, PostingType)).value(SysQuery::value(LedgerPostingType::ProjSalesvalue));
        _qbdsSubLedgerJournalAccountEntry.addRange(fieldNum(SubledgerJournalAccountEntry, PostingType)).value(SysQuery::value(LedgerPostingType::ProjSalesvalueOffset));
        _qbdsSubLedgerJournalAccountEntry.addRange(fieldNum(SubledgerJournalAccountEntry, PostingType)).value(SysQuery::value(LedgerPostingType::ProjTurnover));
        _qbdsSubLedgerJournalAccountEntry.addRange(fieldNum(SubledgerJournalAccountEntry, PostingType)).value(SysQuery::value(LedgerPostingType::Tax));
        _qbdsSubLedgerJournalAccountEntry.addRange(fieldNum(SubledgerJournalAccountEntry, PostingType)).value(SysQuery::value(LedgerPostingType::ProjPayrollAllocation));
        _qbdsSubLedgerJournalAccountEntry.addRange(fieldNum(SubledgerJournalAccountEntry, PostingType)).value(SysQuery::value(LedgerPostingType::IntercompanyCost));
        _qbdsSubLedgerJournalAccountEntry.addRange(fieldNum(SubledgerJournalAccountEntry, PostingType)).value(SysQuery::value(LedgerPostingType::Payroll));
        _qbdsSubLedgerJournalAccountEntry.addRange(fieldNum(SubledgerJournalAccountEntry, PostingType)).value(SysQuery::value(LedgerPostingType::PSAProjPurchRetain));

        return _qbdsSubLedgerJournalAccountEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccruedRevenueLineMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Summarizes accounting distribution values that are used to accrue project revenue.
    /// </summary>
    /// <param name="_sourceDocumentHeader">
    /// A record in the <c>SourceDocumentHeader</c> table.
    /// </param>
    /// <returns>
    /// A <c>Map</c> that contains the project revenue values.
    /// </returns>
    private static container getAccruedRevenueLineMap(SourceDocumentHeader _sourceDocumentHeader)
    {
        #declareProjectRevenueLineContainerVariablesMacro
        #define.Hash('#')

        Map                                     accruedRevenueLine;
        str                                     accruedRevenueLineKey;
        Query                                   query;
        QueryRun                                queryRun;
        AccountingDistribution                  accountingDistribution;
        ProjectAccountingDistribution           projectAccountingDistribution;
        SourceDocumentLineItem                  sourceDocumentLineItem;
        SourceDocumentLineItemITimesheets       iTimesheets;
        CompanyInfo                             ci;

        str accruedRevenueLineKey()
        {
            return int642str(projectAccountingDistribution.Currency) + #Hash +
            int642str(accountingDistribution.AccountingLegalEntity) + #Hash +
            int2str(date2num(accountingDistribution.AccountingDate)) + #Hash +
            int2str(real2int(sign(projectAccountingDistribution.TransactionCurrencyAmount)));
        }

        accruedRevenueLine = new Map(Types::String, Types::Container);
        boolean useAccountingEventTmp = SubledgerJournalizerProjectExtension::canUseAccountingEventTmp(_sourceDocumentHeader.TypeEnumName);

        if (useAccountingEventTmp)
        {
            queryRun = SubledgerJournalizerProjectExtension::distributionsForAccrualQueryRun(_sourceDocumentHeader);
        }
        else
        {
            query = SubledgerJournalizerProjectExtension::distributionsForAccrual(_sourceDocumentHeader);
            queryRun = new QueryRun(query);
        }

        boolean skipTaxNonRecoverableVariance = SubledgerJournalizerProjectExtension::skipTaxNonRecoverableVariance();

        while (queryRun.next())
        {
            accountingDistribution = queryRun.get(tableNum(AccountingDistribution));
            projectAccountingDistribution = queryRun.get(tableNum(ProjectAccountingDistribution));

            // Don't process work in process distributions for most types as this work was done with the extended price distribution
            // For revenue lines, we need to prcess the work in process distribution since it has no extended price distribution.
            //
            if (accountingDistribution.MonetaryAmount == MonetaryAmount::WorkInProcess)
            {
                ProjAdvancedJournalLine projAdvancedJournalLine = ProjAdvancedJournalLine::findBySourceDocumentLine(accountingDistribution.SourceDocumentLine);
                if (projAdvancedJournalLine && projAdvancedJournalLine.TransType != ProjTransType::Revenue)
                {
                    continue;
                }
            }

            if (ProjectSourceDocumentLineItemHelper::isProject(accountingDistribution.SourceDocumentLine))
            {
                sourceDocumentLineItem = ProjectSourceDocumentLineItemHelper::sourceDocumentLineItemTopParent(accountingDistribution.SourceDocumentLine);

                if (sourceDocumentLineItem is SourceDocumentLineItemITimesheets)
                {
                    iTimesheets = sourceDocumentLineItem as SourceDocumentLineItemITimesheets;
                    ci = CompanyInfo::findRecId(iTimesheets.parmProjectLegalEntity());
                }
                else
                {
                    ci = CompanyInfo::findRecId(accountingDistribution.AccountingLegalEntity);
                }

                changecompany (ci.DataArea)
                {
                    boolean canAccrueRev = false;

                    if (SubledgerJournalizerProjectExtension::parmCanBookActuals(sourceDocumentLineItem))
                    {
                        ProjAdvancedJournalLine projAdvJournalLine;

                        if (sourceDocumentLineItem is ProjAdvancedJournalSourceDocumentLineItem)
                        {
                            ProjAdvancedJournalSourceDocumentLineItem projAdvancedJournalSDLItem = sourceDocumentLineItem as ProjAdvancedJournalSourceDocumentLineItem;
                            projAdvJournalLine = projAdvancedJournalSDLItem.parmProjAdvancedJournalLine();
                        }

                        using (ProjectPostingParameters insertParameters = ProjectPostingParameters::parmProjContractLineNum(projAdvJournalLine.ContractLineId))
                        {
                            canAccrueRev = ProjectPosting::canAccrueRevenue(
                                            ProjTable::findRecId(projectAccountingDistribution.ProjTable),
                                            ProjCategory::findRecId(projectAccountingDistribution.ProjCategory),
                                            ProjLineProperty::findRecId(projectAccountingDistribution.ProjLineProperty),
                                            ProjectAccountingDistribution::transactionCurrencySalesAmount(
                                                accountingDistribution,
                                                projectAccountingDistribution),
                                            projectAccountingDistribution.ProjFundingSource);
                        }
                    }

                    if (canAccrueRev
                        && SubledgerJournalizerProjectExtension::validateVendorInvoiceLineCanAccrueRevenue(sourceDocumentLineItem))
                    {   
                        if ((skipTaxNonRecoverableVariance
                            && accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance)
                            || (accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable
                                && accountingDistribution.ReferenceDistribution == 0
                                && !ProjSalesValueInVoucherWithNonDectTaxFlight::instance().isEnabled()))
                        {
                            // Skip non-recoverable tax variance distribution as it is processed under non-recoverable tax distribution later.
                            continue;
                        }

                        //Project revenue lines
                        accruedRevenueLineKey = accruedRevenueLineKey();
                        if (accruedRevenueLine.exists(accruedRevenueLineKey))
                        {
                            #projectRevenueLineContainerMacro = accruedRevenueLine.lookup(accruedRevenueLineKey);
                            accruedRevenueLine.remove(accruedRevenueLineKey);
                        }
                        else
                        {
                            #clearProjectRevenueLineContainerMacro
                        }

                        transactionSalesCurrency = projectAccountingDistribution.Currency;
                        transactionSalesLegalEntityRecId = accountingDistribution.AccountingLegalEntity;
                        transactionCurrencySalesAmount += ProjectAccountingDistribution::transactionCurrencySalesAmount(accountingDistribution, projectAccountingDistribution);
                        accountingDate = accountingDistribution.AccountingDate;

                        // Add non-recoverable tax variance amount if one exists along with the non-recoverable tax amount.
                        if (skipTaxNonRecoverableVariance && accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable)
                        {
                            AccountingDistribution taxAccountingDistribution;
                            select firstonly TransactionCurrencyAmount from taxAccountingDistribution
                                where taxAccountingDistribution.SourceDocumentLine == accountingDistribution.SourceDocumentLine
                                   && taxAccountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance;

                            if (taxAccountingDistribution.TransactionCurrencyAmount)
                            {
                                transactionCurrencySalesAmount += taxAccountingDistribution.TransactionCurrencyAmount;
                            }
                        }

                        accruedRevenueLine.insert(accruedRevenueLineKey, #projectRevenueLineContainerMacro);
                    }
                }
            }
        }

        return accruedRevenueLine.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipTaxNonRecoverableVariance</Name>
				<Source><![CDATA[
    protected static boolean skipTaxNonRecoverableVariance()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateVendorInvoiceLineCanAccrueRevenue</Name>
				<Source><![CDATA[
    private static boolean validateVendorInvoiceLineCanAccrueRevenue(SourceDocumentLineItem _sourceDocumentLineItem)
    {
        boolean validateVendorInvoiceLineCanAccrueRevenue;

        if (ProjVendorInvoiceRetentionCalcFeatureHelper::isTransitionFlightEnabled())
        {
            boolean isVendorInvoiceLine = _sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem ? true : false;

            if (!isVendorInvoiceLine)
            {
                validateVendorInvoiceLineCanAccrueRevenue = true;
            }
            else
            {
                // Must be vendor invoice line item if it gets into here
                VendorInvoiceLineSourceDocLineItem vendorInvoiceLineSourceDocLineItem
                    = _sourceDocumentLineItem as VendorInvoiceLineSourceDocLineItem;

                if (ProjVendorInvoiceRetentionCalcFeatureHelper::shouldProcessWithFeatureEnabledBySouceDocumentLineItem(
                        ProjVendorInvoiceRetentionCalcFeatureHelper::isFeatureEnabled(),
                        vendorInvoiceLineSourceDocLineItem))
                {
                    // If feature is enable, then it should not accrue as long if it's a retention release only
                    validateVendorInvoiceLineCanAccrueRevenue =
                        vendorInvoiceLineSourceDocLineItem.isProjRetentionRelease() ? false : true;
                }
                else
                {
                    validateVendorInvoiceLineCanAccrueRevenue = true;
                }
            }
        }
        else
        {
            validateVendorInvoiceLineCanAccrueRevenue = true;
        }

        return validateVendorInvoiceLineCanAccrueRevenue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccruedRevenueLineMapV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Summarizes accounting distribution values that are used to accrue project revenue for only the lines submitted.
    /// </summary>
    /// <param name="_sourceDocument">
    /// A record in the <c>SourceDocument</c> table.
    /// </param>
    /// <returns>
    /// A <c>Map</c> that contains the project revenue values.
    /// </returns>
    private static container getAccruedRevenueLineMapV2(SourceDocument _sourceDocument)
    {
        #declareProjectRevenueLineContainerVariablesMacro
        #define.Hash('#')

        Map                                     accruedRevenueLine;
        str                                     accruedRevenueLineKey;
        Query                                   query;
        QueryRun                                queryRun;
        AccountingDistribution                  accountingDistribution;
        ProjectAccountingDistribution           projectAccountingDistribution;
        SourceDocumentLineItem                  sourceDocumentLineItem;
        SourceDocumentLineItemITimesheets       iTimesheets;
        CompanyInfo                             ci;

        str accruedRevenueLineKey()
        {
            return int642str(projectAccountingDistribution.Currency) + #Hash +
            int642str(accountingDistribution.AccountingLegalEntity) + #Hash +
            int2str(date2num(accountingDistribution.AccountingDate)) + #Hash +
            int2str(real2int(sign(projectAccountingDistribution.TransactionCurrencyAmount)));
        }

        accruedRevenueLine = new Map(Types::String, Types::Container);

        if (enumName2Id(_sourceDocument.parmSourceDocumentHeader().typeEnumName) == enumNum(SourceDocument_ProjAdvancedJournal))
        {
            queryRun = SubledgerJournalizerProjectExtension::distributionsForAccrualQueryRunV2(_sourceDocument);
        }
        else
        {
            query = SubledgerJournalizerProjectExtension::distributionsForAccrualV2(_sourceDocument);
            queryRun = new QueryRun(query);
        }

        boolean skipTaxNonRecoverableVariance = SubledgerJournalizerProjectExtension::skipTaxNonRecoverableVariance();

        while (queryRun.next())
        {
            accountingDistribution = queryRun.get(tableNum(AccountingDistribution));
            projectAccountingDistribution = queryRun.get(tableNum(ProjectAccountingDistribution));

            //
            // Don't process work in process distributions for most types as this work was done with the extended price distribution
            // For revenue lines, we need to prcess the work in process distribution since it has no extended price distribution.
            //
            if (accountingDistribution.MonetaryAmount == MonetaryAmount::WorkInProcess)
            {
                ProjAdvancedJournalLine projAdvancedJournalLine = ProjAdvancedJournalLine::findBySourceDocumentLine(accountingDistribution.SourceDocumentLine);
                if (projAdvancedJournalLine && projAdvancedJournalLine.TransType != ProjTransType::Revenue)
                {
                    continue;
                }
            }

            if (ProjectSourceDocumentLineItemHelper::isProject(accountingDistribution.SourceDocumentLine))
            {
                sourceDocumentLineItem = ProjectSourceDocumentLineItemHelper::sourceDocumentLineItemTopParent(accountingDistribution.SourceDocumentLine);

                if (sourceDocumentLineItem is SourceDocumentLineItemITimesheets)
                {
                    iTimesheets = sourceDocumentLineItem as SourceDocumentLineItemITimesheets;
                    ci = CompanyInfo::findRecId(iTimesheets.parmProjectLegalEntity());
                }
                else
                {
                    ci = CompanyInfo::findRecId(accountingDistribution.AccountingLegalEntity);
                }

                changecompany (ci.DataArea)
                {
                    boolean canAccrueRev = false;

                    if (SubledgerJournalizerProjectExtension::parmCanBookActuals(sourceDocumentLineItem))
                    {
                        ProjAdvancedJournalLine projAdvJournalLine;

                        if (sourceDocumentLineItem is ProjAdvancedJournalSourceDocumentLineItem)
                        {
                            ProjAdvancedJournalSourceDocumentLineItem projAdvancedJournalSDLItem = sourceDocumentLineItem as ProjAdvancedJournalSourceDocumentLineItem;
                            projAdvJournalLine = projAdvancedJournalSDLItem.parmProjAdvancedJournalLine();
                        }

                        using (ProjectPostingParameters insertParameters = ProjectPostingParameters::parmProjContractLineNum(projAdvJournalLine.ContractLineId))
                        {
                            canAccrueRev = ProjectPosting::canAccrueRevenue(
                                                ProjTable::findRecId(projectAccountingDistribution.ProjTable),
                                                ProjCategory::findRecId(projectAccountingDistribution.ProjCategory),
                                                ProjLineProperty::findRecId(projectAccountingDistribution.ProjLineProperty),
                                                ProjectAccountingDistribution::transactionCurrencySalesAmount(
                                                    accountingDistribution,
                                                    projectAccountingDistribution),
                                                projectAccountingDistribution.ProjFundingSource);
                        }
                    }

                    if (canAccrueRev
                        && SubledgerJournalizerProjectExtension::validateVendorInvoiceLineCanAccrueRevenue(sourceDocumentLineItem))
                    {
                        if (skipTaxNonRecoverableVariance && accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance)
                        {
                            // Skip non-recoverable tax variance distribution as it is processed under non-recoverable tax distribution later.
                            continue;
                        }

                        //Project revenue lines
                        accruedRevenueLineKey = accruedRevenueLineKey();
                        if (accruedRevenueLine.exists(accruedRevenueLineKey))
                        {
                            #projectRevenueLineContainerMacro = accruedRevenueLine.lookup(accruedRevenueLineKey);
                            accruedRevenueLine.remove(accruedRevenueLineKey);
                        }
                        else
                        {
                            #clearProjectRevenueLineContainerMacro
                        }

                        transactionSalesCurrency = projectAccountingDistribution.Currency;
                        transactionSalesLegalEntityRecId = accountingDistribution.AccountingLegalEntity;
                        transactionCurrencySalesAmount += ProjectAccountingDistribution::transactionCurrencySalesAmount(accountingDistribution, projectAccountingDistribution);
                        accountingDate = accountingDistribution.AccountingDate;

                        // Add non-recoverable tax variance amount if one exists along with the non-recoverable tax amount.
                        if (skipTaxNonRecoverableVariance && accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable)
                        {
                            AccountingDistribution taxAccountingDistribution;
                            select firstonly TransactionCurrencyAmount from taxAccountingDistribution
                                where taxAccountingDistribution.SourceDocumentLine == accountingDistribution.SourceDocumentLine
                                   && taxAccountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance;

                            if (taxAccountingDistribution.TransactionCurrencyAmount)
                            {
                                transactionCurrencySalesAmount += taxAccountingDistribution.TransactionCurrencyAmount;
                            }
                        }

                        accruedRevenueLine.insert(accruedRevenueLineKey, #projectRevenueLineContainerMacro);
                    }
                }
            }
        }

        return accruedRevenueLine.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getParentSublLedgerJournalAccountEntryPostingType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the ledger posting type for the parent distribution of the subledger journal distribution being processed.
    /// </summary>
    /// <param name="_subledgerJournalAccountEntry">
    /// A subldeger journal distribution entry.
    /// </param>
    /// <returns>
    /// The parent ledger posting type.
    /// </returns>
    private static LedgerPostingType getParentSublLedgerJournalAccountEntryPostingType(SubledgerJournalAccountEntry _subledgerJournalAccountEntry)
    {
        SubledgerJournalAccountEntryDistribution    subledgerJournalAccountEntryDistribution;
        SubledgerJournalAccountEntryDistribution    parentSubledgerJournalAccountEntryDistribution;
        SubledgerJournalAccountEntry                parentSubledgerJournalAccountEntry;
        AccountingDistribution                      accountingDistribution;

        select firstonly PostingType from parentSubledgerJournalAccountEntry
                where parentSubledgerJournalAccountEntry.LedgerDimension == _subledgerJournalAccountEntry.LedgerDimension
                    && parentSubledgerJournalAccountEntry.PostingType     != LedgerPostingType::Tax
                    && parentSubledgerJournalAccountEntry.SubledgerJournalEntry == _subledgerJournalAccountEntry.SubledgerJournalEntry
            exists join parentSubledgerJournalAccountEntryDistribution
                where parentSubledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry == parentSubledgerJournalAccountEntry.RecId
            exists join subledgerJournalAccountEntryDistribution
                where subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry == _subledgerJournalAccountEntry.RecId;
        
        return parentSubledgerJournalAccountEntry.PostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualLedgerUpdatePostingType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the actual ledger posting type to used for posting the transaction.
    /// </summary>
    /// <param name="_projTransType">
    /// <c>ProjTransType</c> associated to the subledger journal distribution being processed.
    /// </param>
    /// <param name="_projGroup">
    /// <c>ProjGroup</c> associated to the project on the subledger journal being processed.
    /// </param>
    /// <param name="_subledgerJournalAccountEntry">
    /// <c>SubledgerJournalAccountEntry</c> being processed.
    /// </param>
    /// <returns>
    /// The ledger posting type.
    /// </returns>
    protected static LedgerPostingType getActualLedgerUpdatePostingType(ProjTransType _projTransType, ProjGroup _projGroup, SubledgerJournalAccountEntry _subledgerJournalAccountEntry)
    {
        LedgerPostingType actualLedgerUpdatePostingType;

        if (_subledgerJournalAccountEntry.PostingType == LedgerPostingType::Tax ||
            _subledgerJournalAccountEntry.PostingType == LedgerPostingType::PurchConsump)
        {
            TaxParameters taxParameters = TaxParameters::find();
            if (taxParameters.PurchTaxOnOperations || MainAccount::findByLedgerDimension(_subledgerJournalAccountEntry.LedgerDimension).PostingType == LedgerPostingType::Tax)
            {
                LedgerPostingType postingType = SubledgerJournalizerProjectExtension::getParentSublLedgerJournalAccountEntryPostingType(_subledgerJournalAccountEntry);
                actualLedgerUpdatePostingType   = postingType ? postingType : _subledgerJournalAccountEntry.PostingType;
            }
            else if (_projTransType == ProjTransType::Item && _projGroup.ItemTransCost == ProjLedgerStatus::BalanceSheet)
            {
                LedgerPostingType postingType = SubledgerJournalizerProjectExtension::getParentSublLedgerJournalAccountEntryPostingType(_subledgerJournalAccountEntry);
                if (ProjLedgerPostingTypeCheckFlight::instance().isEnabled() && (postingType == LedgerPostingType::ProjCost || postingType == LedgerPostingType::IntercompanyCost))
                {
                    actualLedgerUpdatePostingType = LedgerPostingType::ProjCost;
                }
                else
                {
                    /* BUG-724296 assigning actualLedgerPostingType to LedgerPostingType::ProjStatusAccountItem instead of throwing exception
                    which was the behavior prior to adding  flight */
                    projOpsLogger.logInformation(strFmt('LedgerPostingType: %1, ProjTransType: %2, SubledgerJournalAccountEntry: %3, ProjLedgerPostingTypeCheckFlight: %4',
                            postingType, _projTransType, _subledgerJournalAccountEntry, ProjLedgerPostingTypeCheckFlight::instance().isEnabled()));
                    actualLedgerUpdatePostingType = LedgerPostingType::ProjStatusAccountItem;
                }
            }
            else if (_projTransType == ProjTransType::Cost && _projGroup.costTransCost == ProjLedgerStatus::BalanceSheet)
            {
                // The posting type stored in SUBLEDGERJOURNALACCOUNTENTRY table for Tax transactions have PostingType set to Tax. 
                // Here, we map it to correct Project Posting Type. Project Posting Type is determined from combination of
                // LedgerPostingType set in ProjGroup and LineProperty set on Transaction Line.
                if (_subledgerJournalAccountEntry.PostingType == LedgerPostingType::Tax && ProjLinePropertyCapitalizeCostCheckForPostingTypeFlightV2::instance().isEnabled())
                {
                    ProjLineProperty projLineProperty = SubledgerJournalizerProjectExtension::getProjLineProperty(_subledgerJournalAccountEntry);
                    if (projLineProperty.ToBeCapitalize == NoYes::No)
                    {
                        actualLedgerUpdatePostingType =  LedgerPostingType::ProjCost;
                    }
                    else
                    {
                        actualLedgerUpdatePostingType =  LedgerPostingType::ProjWIPCostvalue;
                    }
                }
                else
                {
                    actualLedgerUpdatePostingType = LedgerPostingType::ProjWIPCostvalue;
                }
            }
            else
            {
                actualLedgerUpdatePostingType =  LedgerPostingType::ProjCost;
            }
        }
        else if (_subledgerJournalAccountEntry.PostingType == LedgerPostingType::IntercompanyCost)
        {
            // In project ledger update posting table we use project cost because, like taxes, we don't report
            // the intercompany cost separately from regular cost in project statement
            actualLedgerUpdatePostingType = LedgerPostingType::ProjCost;
        }
        else
        {
            actualLedgerUpdatePostingType = _subledgerJournalAccountEntry.PostingType;
        }

        return actualLedgerUpdatePostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualLedgerUpdatePostingTypeV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the actual ledger posting type to used for posting the transaction.
    /// </summary>
    /// <param name="_projTransType">
    /// <c>ProjTransType</c> associated to the subledger journal distribution being processed.
    /// </param>
    /// <param name="_projTable">
    /// <c>ProjTable</c> associated to the project on the subledger journal being processed.
    /// </param>
    /// <param name="_subledgerJournalAccountEntry">
    /// <c>SubledgerJournalAccountEntry</c> being processed.
    /// </param>
    /// <returns>
    /// The ledger posting type.
    /// </returns>
    protected static LedgerPostingType getActualLedgerUpdatePostingTypeV2(ProjTransType _projTransType, ProjTable _projTable, SubledgerJournalAccountEntry _subledgerJournalAccountEntry)
    {
        LedgerPostingType actualLedgerUpdatePostingType;

        if (_subledgerJournalAccountEntry.PostingType == LedgerPostingType::Tax ||
            _subledgerJournalAccountEntry.PostingType == LedgerPostingType::PurchConsump)
        {
            TaxParameters taxParameters = TaxParameters::find();
            if (taxParameters.PurchTaxOnOperations || MainAccount::findByLedgerDimension(_subledgerJournalAccountEntry.LedgerDimension).PostingType == LedgerPostingType::Tax)
            {
                LedgerPostingType postingtype = SubledgerJournalizerProjectExtension::getParentSublLedgerJournalAccountEntryPostingType(_subledgerJournalAccountEntry);
                actualLedgerUpdatePostingType   = postingtype ? postingtype : _subledgerJournalAccountEntry.PostingType;
            }
            else
            {
                if (_projTransType == ProjTransType::Item && ProjRevRecHelper::item2LedgerStatus(ProjRevRecHelper::getRevProfileForTransactionType(_projTable, ProjTransType::Item).ItemLedgerStatus) == ProjLedgerStatus::BalanceSheet)
                {
                    actualLedgerUpdatePostingType = LedgerPostingType::ProjStatusAccountItem;
                }
                else if (_projTransType == ProjTransType::Cost && ProjRevRecHelper::cost2LedgerStatus(ProjRevRecHelper::getRevProfileForTransactionType(_projTable, ProjTransType::Cost).CostLedgerStatus) == ProjLedgerStatus::BalanceSheet)
                {
                    // The posting type stored in SUBLEDGERJOURNALACCOUNTENTRY table for Tax transactions have PostingType set to Tax.
                    // Here, we map it to correct Project Posting Type. Project Posting Type is determined from combination of
                    // LedgerPostingType set on RevenueProfile and LineProperty set on Transaction Line.
                    if (_subledgerJournalAccountEntry.PostingType == LedgerPostingType::Tax && ProjLinePropertyCapitalizeCostCheckForPostingTypeFlightV2::instance().isEnabled())
                    {
                        ProjLineProperty projLineProperty = SubledgerJournalizerProjectExtension::getProjLineProperty(_subledgerJournalAccountEntry);
                        if (projLineProperty.ToBeCapitalize == NoYes::No)
                        {
                            actualLedgerUpdatePostingType =  LedgerPostingType::ProjCost;
                        }
                        else
                        {
                            actualLedgerUpdatePostingType =  LedgerPostingType::ProjWIPCostvalue;
                        }
                    }
                    else
                    {
                        actualLedgerUpdatePostingType = LedgerPostingType::ProjWIPCostvalue;
                    }
                }
                else
                {
                    actualLedgerUpdatePostingType =  LedgerPostingType::ProjCost;
                }
            }
        }
        else if (_subledgerJournalAccountEntry.PostingType == LedgerPostingType::IntercompanyCost)
        {
            // In project ledger update posting table we use project cost because, like taxes, we don't report
            // the intercompany cost separately from regular cost in project statement
            actualLedgerUpdatePostingType = LedgerPostingType::ProjCost;
        }
        else
        {
            actualLedgerUpdatePostingType = _subledgerJournalAccountEntry.PostingType;
        }

        return actualLedgerUpdatePostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjectActualMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Summarizes accounting distribution values that are used to create project actuals
    /// </summary>
    /// <param name="_sourceDocumentHeader">
    /// A record in the <c>SourceDocumentHeader</c> table.
    /// </param>
    /// <returns>
    /// A Map that contains the project actual values.
    /// </returns>
    private static container getProjectActualMap(SourceDocumentHeader _sourceDocumentHeader)

    {
        #declareProjectActualHeaderContainerVariablesMacro
        #declareProjectActualDetailContainerVariablesMacro
        #declareActualLedgerUpdateContainerVariablesMacro

        Map                                     actualHeader;
        Map                                     actualHeader_actualCostDetail;
        Map                                     actualCostDetail;
        container                               packedActualCostDetail;
        Map                                     actualHeader_actualSalesDetail;
        Map                                     actualSalesDetail;
        container                               packedActualSalesDetail;
        str                                     projectActualHeaderKey;
        str                                     projectActualDetailKey;
        QueryRun                                queryRun;
        AccountingDistribution                  accountingDistribution;
        ProjectAccountingDistribution           projectAccountingDistribution;
        SourceDocumentLineItem                  sourceDocumentLineItem;
        SourceDocumentLineItemIProject          sourceDocumentLineItemIProject;
        AccountingDistribution                  referenceAccountingDistribution;
        ProjectAccountingDistribution           referenceProjectAccountingDistribution;

        SourceDocumentLineItemITimesheets       iTimesheets;

        ProjFundingLimitTracking                projFundingLimitTracking;
        ProjFundingLimitTracking                projFundingLimitTrackingLedgerUpdates;
        SourceDocumentLineItem                  topSourceDocumentLineItem;
        ProjFundingLimit                        projFundingLimit;
        ProjFundingLimit                        projFundingLimitLedgerUpdates;
        Set                                     processedDistributionForLedgerUpdate = new Set(Types::String);
        str                                     processedDistributionKey;
        boolean                                 useFundingLimitTracking;
        VendInvoiceInfoLine                     vendInvoiceLine;
        PurchLine                               purchLine;
        PSAPercent                              paymentRetentionPercentage;
        AmountCur                               paymentRetentionReleaseAmount;

        // For the case of retention, the calculation  of the amount in the tracking funding limit tracking table is
        // calculated by multiplication of accounting distribution allocation factor and retention percentage.
        // As for the case of tax, it is calculated by division of the total line amount times the receive amount to be invoiced.
        // Hence it is unavoidable to have rounding error and hence the rounding adjustment is required.
        // If this rounding adjustment is not used, then it may report false positive that the funding limit is exceeded.
        const real adjustmentError = 0.01;

        boolean vendorInvoiceRetentionCalcFeatureLocal = ProjVendorInvoiceRetentionCalcFeatureHelper::isFeatureEnabled();

        str projectActualHeaderKey()
        {
            return
                int642str(sourceDocumentLineItem.parmSourceDocumentLine().RecId) + '#' +
                CompanyInfo::findRecId(accountingDistribution.AccountingLegalEntity).DataArea + '#' +
                int642str(projectAccountingDistribution.ProjTable) + '#' +
                int642str(projectAccountingDistribution.ProjCategory) + '#' +
                int642str(projectAccountingDistribution.SmmActivities) + '#' +
                int642str(projectAccountingDistribution.ProjLineProperty) + '#' +
                ProjectAccountingDistribution::transactionCostCurrency(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem) + '#' +
                ProjectAccountingDistribution::transactionSalesCurrency(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem) + '#' +
                int642str(projectAccountingDistribution.TaxGroupHeading) + '#' +
                int642str(projectAccountingDistribution.TaxItemGroupHeading) + '#' +
            int642str(LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(accountingDistribution.LedgerDimension));
        }

        str projectActualDetailKey()
        {
            if (useFundingLimitTracking)
            {
                return int642str(projFundingLimit.FundingSource);
            }
            else
            {
                return
                int642str(projectAccountingDistribution.ProjFundingSource);
            }
        }

        void getReferenceProjectAccountingDistribution(ProjCostSales _projCostSales)
        {
            ProjectRevenueLine  projectRevenueLine;

            switch (_projCostSales)
            {
                case ProjCostSales::Cost:
                    switch (ProjectSourceDocumentLineItemHelper::projTransType(sourceDocumentLineItem))
                    {
                        case ProjTransType::Hour:
                        case ProjTransType::Cost:
                        case ProjTransType::Item:
                            referenceAccountingDistribution = AccountingDistribution::find(accountingDistribution.RecId);
                            referenceProjectAccountingDistribution = ProjectAccountingDistribution::find(projectAccountingDistribution.RecId);
                            break;

                        case ProjTransType::Revenue:
                            referenceAccountingDistribution = null;
                            referenceProjectAccountingDistribution = null;
                            break;

                        default:
                            throw error(strFmt("@SYS22828",funcName()));
                    }
                    break;

                case ProjCostSales::Sales:
                    switch (ProjectSourceDocumentLineItemHelper::projTransType(sourceDocumentLineItem))
                    {
                        case ProjTransType::Hour:
                        case ProjTransType::Cost:
                        case ProjTransType::Item:

                            if (sourceDocumentLineItem is ProjAdvancedJournalSourceDocumentLineItem)
                            {
                                referenceAccountingDistribution = ProjAdvancedJournalSourceDocumentLineItem::getWorkInProcessDistribution(accountingDistribution.RecId);
                            }
                            else
                            {
                                select firstonly referenceAccountingDistribution
                                    where referenceAccountingDistribution.ReferenceDistribution == accountingDistribution.RecId
                                        exists join projectRevenueLine
                                            where projectRevenueLine.SourceDocumentLine == referenceAccountingDistribution.SourceDocumentLine;
                            }

                            if (referenceAccountingDistribution)
                            {
                                referenceProjectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(referenceAccountingDistribution.RecId);
                            }
                            else
                            {
                                referenceProjectAccountingDistribution = null;
                            }
                            break;

                        case ProjTransType::Revenue:
                            referenceAccountingDistribution = AccountingDistribution::find(accountingDistribution.RecId);
                            referenceProjectAccountingDistribution = ProjectAccountingDistribution::find(projectAccountingDistribution.RecId);
                            break;

                        default:
                            throw error(strFmt("@SYS22828",funcName()));
                    }
                    break;
                default:
                    throw error(strFmt("@SYS22828",funcName()));
            }
        }

        void processLedgerUpdate()
        {

            ProjTransType projTransType = ProjectSourceDocumentLineItemHelper::projTransType(sourceDocumentLineItem);
            ProjTable projTableLocal = ProjTable::findRecId(projectAccountingDistribution.ProjTable);
            ProjGroup projectGroup = projTableLocal.projGroup();
            boolean projOpsEnableFixedRateAgreementsNonStockedFeature = FeatureStateProvider::IsFeatureEnabled(ProjOpsFixedRateAgreementsForNonStockedFeature::instance());

            sourceDocumentLineItem = ProjectSourceDocumentLineItemHelper::sourceDocumentLineItemTopParent(accountingDistribution.SourceDocumentLine);

            Query subLedgerJournalAccountEntryQuery = SubledgerJournalizerProjectExtension::subLedgerJournalAccountEntries(referenceProjectAccountingDistribution.AccountingDistribution);
            QueryRun subLedgerJournalAccountEntryQueryRun = new QueryRun(subLedgerJournalAccountEntryQuery);
            while (subLedgerJournalAccountEntryQueryRun.next())
            {
                SubledgerJournalAccountEntry subledgerJournalAccountEntry = subLedgerJournalAccountEntryQueryRun.get(tableNum(SubledgerJournalAccountEntry));
                boolean processLedgerUpdate = SubledgerJournalizerProjectExtension::shouldProcessLedgerUpdate(subledgerJournalAccountEntry.RecId);

                if (processLedgerUpdate)
                {
                    if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
                    {
                        actualLedgerUpdatePostingType = SubledgerJournalizerProjectExtension::getActualLedgerUpdatePostingTypeV2(projTransType, projTableLocal, subledgerJournalAccountEntry);
                    }
                    else
                    {
                        actualLedgerUpdatePostingType = SubledgerJournalizerProjectExtension::getActualLedgerUpdatePostingType(projTransType, projectGroup, subledgerJournalAccountEntry);
                    }

                    actualLedgerUpdateLedgerDimension = subledgerJournalAccountEntry.LedgerDimension;
                    actualLedgerUpdateAccountingCurrencyAmount = 0;
                    if (ProjectSourceDocumentLineItemHelper::projTransType(sourceDocumentLineItem) == ProjTransType::Hour)
                    {
                        actualLedgerUpdateQuantity = ProjectAccountingDistribution::quantity(accountingDistribution);
                    }
                    else
                    {
                        actualLedgerUpdateQuantity = 0;
                    }

                    boolean projFundingLimitLedgerUpdated = false;

                    if (useFundingLimitTracking)
                    {
                        while select Amount, ProjFundingLimit from projFundingLimitTrackingLedgerUpdates
                            where projFundingLimitTrackingLedgerUpdates.AccountingDistribution == referenceAccountingDistribution.RecId &&
                                  projFundingLimitTrackingLedgerUpdates.ProjectAccountingDistribution == referenceProjectAccountingDistribution.RecId &&
                                  projFundingLimitTrackingLedgerUpdates.Reversing == NoYes::No
                        {
                            if (projFundingLimitTrackingLedgerUpdates.Amount)
                            {
                                projFundingLimitLedgerUpdates = ProjFundingLimit::find(projFundingLimitTrackingLedgerUpdates.ProjFundingLimit, true);
                                actualFundingSource = projFundingLimitLedgerUpdates.FundingSource;
                                actualLedgerUpdateAccountingCurrencyAmount = projFundingLimitTrackingLedgerUpdates.Amount;

                                projFundingLimitLedgerUpdated = true;
                            }

                            actualLedgerUpdate.addEnd(#actualLedgerUpdateContainerMacro);
                        }
                    }

                    if (!projFundingLimitLedgerUpdated)
                    {
                        if (subledgerJournalAccountEntry.TransactionCurrencyAmount)
                        {
                            PercentPositive percent = (abs(referenceAccountingDistribution.TransactionCurrencyAmount) / abs(subledgerJournalAccountEntry.TransactionCurrencyAmount)) * 100;
                            actualLedgerUpdateAccountingCurrencyAmount = subledgerJournalAccountEntry.AccountingCurrencyAmount * percent / 100;

                            if (projOpsEnableFixedRateAgreementsNonStockedFeature)
                            {
                                // Find the ProjInvoiceCurrency record using project contract , transactioncurrency
                                ProjTable projTable;
                                ExchRate exchRate;
                                
                                select firstonly ProjInvoiceProjId from projTable
                                    where projTable.RecId == projectAccountingDistribution.ProjTable;

                                if (projTable)
                                {
                                    exchRate = ProjInvoiceCurrency::getFixedExchRate(projTable.ProjInvoiceProjId, subledgerJournalAccountEntry.TransactionCurrency);
                                }

                                if (exchRate)
                                {
                                    // calculate the AccountingCurrencyAmount for sales transaction to use the fixed exchange rate agreement setup for project operations scenarios.
                                    actualLedgerUpdateAccountingCurrencyAmount = CurrencyExchangeHelper::mstAmount(subledgerJournalAccountEntry.TransactionCurrencyAmount,
                                        subledgerJournalAccountEntry.TransactionCurrency,
                                        subledgerJournalAccountEntry.ExchangeRateDate,
                                        Currency::noYes2UnknownNoYes(NoYes::No),
                                        exchRate);
                                }
                            }
                        }
                        else
                        {
                            actualLedgerUpdateAccountingCurrencyAmount = 0;
                        }

                        // Vendor payment retention terms will only apply to project transactions of type item and with ProjCost posting type.
                        if (projTransType == ProjTransType::Item
                            && subledgerJournalAccountEntry.PostingType == LedgerPostingType::ProjCost
                            && sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem
                            && !ProjVendorInvoiceRetentionCalcFeatureHelper::shouldProcessWithFeatureEnabledBySouceDocumentLineItem(
                                vendorInvoiceRetentionCalcFeatureLocal,
                                sourceDocumentLineItem))
                        {
                            AccountingDistribution purchLineAccountingDistribution = AccountingDistribution::find(referenceAccountingDistribution.ReferenceDistribution);
                            if (SourceDocumentHeader::find(purchLineAccountingDistribution.SourceDocumentHeader).SourceRelationType == tableNum(PurchTable) &&
                                SourceDocumentLine::find(purchLineAccountingDistribution.SourceDocumentLine).SourceRelationType == tableNum(PurchLine))
                            {
                                // If this invocie has vendor payment retention terms, then calculate the actual ledger amount accordningly.
                                VendorInvoiceLineSourceDocLineItem vendorInvoiceLineSourceDocLineItem = sourceDocumentLineItem as VendorInvoiceLineSourceDocLineItem;
                                actualLedgerUpdateAccountingCurrencyAmount = vendorInvoiceLineSourceDocLineItem.calcTransactionAmountForProjectVendorInvoiceRetention(
                                    accountingDistribution, actualLedgerUpdateAccountingCurrencyAmount);
                            }
                        }

                        // When Non-deductible tax exists and <c>UseTax</c> is checked then don't add record with <c>LedgerPostingType - PurchConsump</c>
                        // to ledger updates in case of flight enabled.
                        if (SubledgerJournalizerProjectExtension::shouldProcessTaxInActualLedgerUpdate(subledgerJournalAccountEntry, actualLedgerUpdatePostingType))
                        {
                            VendInvoiceInfoLine vendInvoiceInfoLineLocal;
                            PurchLine purchLineLocal;

                            if (sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
                            {
                                vendInvoiceInfoLineLocal = VendInvoiceInfoline::findSourceDocumentLine(sourceDocumentLineItem.parmSourceDocumentLine().RecId);
                            }
                            else if (sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
                            {
                                purchLineLocal = PurchLine::findBySourceDocumentLine(sourceDocumentLineItem.parmSourceDocumentLine().RecId);
                            }

                            if (FeatureStateProvider::isFeatureEnabled(ProjEnableStreamlineCostAndSalesPriceCalcFeature::instance())
                                || ProjectCommitmentFacade::checkIfNonRecoverableTaxExists(vendInvoiceInfoLineLocal, purchLineLocal))
                            {
                                TaxGroup salesTaxGroup = vendInvoiceInfoLineLocal.TaxGroup ? vendInvoiceInfoLineLocal.TaxGroup : purchLineLocal.TaxGroup;

                                TaxGroupData taxGroupData;

                                if (ProjTaxesToProjectWhenUseTaxIsFirstFlightVendInvoice::instance().isEnabled())
                                {
                                    while select UseTax from taxGroupData
                                    where taxGroupData.TaxGroup == salesTaxGroup
                                        && taxGroupData.DataAreaId == curExt()
                                        && taxGroupData.UseTax == NoYes::No
                                    {
                                        actualLedgerUpdate.addEnd(#actualLedgerUpdateContainerMacro);
                                    }
                                }
                                else
                                {
                                    select firstonly UseTax from taxGroupData
                                    where taxGroupData.TaxGroup == salesTaxGroup
                                        && taxGroupData.DataAreaId == curExt();

                                    if (!taxGroupData.UseTax)
                                    {
                                        actualLedgerUpdate.addEnd(#actualLedgerUpdateContainerMacro);
                                    }
                                }
                            }
                        }
                        else
                        {
                            actualLedgerUpdate.addEnd(#actualLedgerUpdateContainerMacro);
                        }
                    }
                }
            }
        }

        void processAccountingDistribution()
        {
            sourceDocumentLineItem = ProjectSourceDocumentLineItemHelper::sourceDocumentLineItemTopParent(accountingDistribution.SourceDocumentLine);
            if (ProjectSourceDocumentLineItemHelper::hasProject(sourceDocumentLineItem))
            {
                sourceDocumentLineItemIProject = sourceDocumentLineItem as SourceDocumentLineItemIProject;

                boolean projOpsEnabled = ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled();

                if (SubledgerJournalizerProjectExtension::parmCanBookActuals(sourceDocumentLineItem))
                {
                    //Project actual headers
                    projectActualHeaderKey = projectActualHeaderKey();
                    if (actualHeader.exists(projectActualHeaderKey))
                    {
                        #projectActualHeaderContainerMacro = actualHeader.lookup(projectActualHeaderKey);
                        actualHeader.remove(projectActualHeaderKey);
                    }
                    else
                    {
                        #clearProjectActualHeaderContainerMacro
                    }

                    actualSourceDocumentLine = sourceDocumentLineItem.parmSourceDocumentLine().RecId;
                    if (sourceDocumentLineItem is SourceDocumentLineItemITimesheets)
                    {
                        iTimesheets = sourceDocumentLineItem as SourceDocumentLineItemITimesheets;

                        actualProjectDataAreaId = CompanyInfo::findRecId(iTimesheets.parmProjectLegalEntity()).DataArea;
                    }
                    else if (sourceDocumentLineItem is ProjAdvancedJournalSourceDocumentLineItem)
                    {
                        ProjAdvancedJournalSourceDocumentLineItem projAdvancedJournalSourceDocumentLineItem = sourceDocumentLineItem as ProjAdvancedJournalSourceDocumentLineItem;
                        actualProjectDataAreaId = projAdvancedJournalSourceDocumentLineItem.parmProjectDataAreaId();
                    }
                    else
                    {
                        actualProjectDataAreaId = CompanyInfo::findRecId(accountingDistribution.AccountingLegalEntity).DataArea;
                    }

                    changecompany (actualProjectDataAreaId)
                    {
                        actualProjectId = ProjTable::findRecId(projectAccountingDistribution.ProjTable).ProjId;
                        actualCategoryId = ProjCategory::findRecId(projectAccountingDistribution.ProjCategory).CategoryId;
                        actualActivityNumber = smmActivities::findWithRecId(projectAccountingDistribution.SmmActivities).ActivityNumber;
                        actualLinePropertyId = ProjLineProperty::findRecId(projectAccountingDistribution.ProjLineProperty).LinePropertyId;
                        actualTaxGroupId = TaxGroupHeading::findRecId(projectAccountingDistribution.TaxGroupHeading).TaxGroup;
                        actualTaxItemGroupId = TaxItemGroupHeading::findRecId(projectAccountingDistribution.TaxItemGroupHeading).TaxItemGroup;
                    }
                    actualTransactionCostCurrency = ProjectAccountingDistribution::transactionCostCurrency(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem);
                    actualTransactionSalesCurrency = ProjectAccountingDistribution::transactionSalesCurrency(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem);
                    accountingCurrency = Ledger::accountingCurrency(CompanyInfo::find(accountingDistribution.AccountingLegalEntity).RecId);
                    vendInvoiceLine = VendInvoiceInfoLine::findSourceDocumentLine(topSourceDocumentLineItem.parmSourceDocumentLine().RecId);
                    boolean projDimensionDefault = false;
     
                    ProjTable projTable;
                    select firstonly projTable
                        where projTable.RecId == projectAccountingDistribution.ProjTable;

                    if (vendInvoiceLine && actualProjectDataAreaId == curExt())
                    {
                        LedgerDimensionValueSet mergingDimension = vendInvoiceLine.DefaultDimension;

                        if (!mergingDimension && vendInvoiceLine.PurchLineRecId)
                        {
                            // Get dimension from purch line if <c>vendInvoiceLine</c> dimension is missing. After the PO is confirmed
                            // and invoiced, the invoice financial dimensions are fetched from the purch line.
                            purchLine = PurchLine::findRecId(vendInvoiceLine.PurchLineRecId);
                            
                            if (ProjVendInvoiceFinancialDimensionTemplateFlight::instance().isEnabled() && purchLine.AccountingDistributionTemplate)
                            {
                                ///When the financial dimension template on PO Line is having value, the financial dimensions are fetched
                                ///from the accounting distribution template for current accountingDistribution record to be logged
                                ///against the matching project transactions to be created using this macro.
                                mergingDimension = SubledgerJournalizerProjectExtension::getDefaultDimensionForAccountingDistribution(projOpsEnabled, accountingDistribution, sourceDocumentLineItem);
                            }
                            else
                            {
                                mergingDimension = purchLine.DefaultDimension;
                            }
                        }
                        else if (ProjVendInvoiceFinancialDimensionTemplateFlight::instance().isEnabled() && vendInvoiceLine.AccountingDistributionTemplate)
                        {
                            mergingDimension = SubledgerJournalizerProjectExtension::getDefaultDimensionForAccountingDistribution(projOpsEnabled, accountingDistribution, sourceDocumentLineItem);
                        }
                        
                        actualDefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(mergingDimension, projTable.DefaultDimension);
                        projDimensionDefault = true;
                    }
                    
                    ProjTransType projTransType = ProjectSourceDocumentLineItemHelper::projTransType(sourceDocumentLineItem);

                    if (!projDimensionDefault)
                    {
                        if (sourceDocumentLineItem is TSTimesheetTransSourceDocLineItem)
                        {
                            // When moving the amounts from the balance sheet to the P/L and posting timesheet, merge the dimensions
                            // from timesheet and the default dimensions set on the project – which is inclusive of Cost center.
                            SourceDocumentLineImplementation sourceDocumentLineImplementation = sourceDocumentLineItem.parmSourceDocumentLine().getSourceDocumentLineImplementation();
                            TSTimesheetLine tsTimesheetLine = TSTimesheetTrans::findRecId(sourceDocumentLineImplementation.RecId).timesheetLine();
                            actualDefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(tsTimesheetLine.DefaultDimension, projTable.DefaultDimension);
                        }
                        else
                        {
                            actualDefaultDimension = SubledgerJournalizerProjectExtension::getDefaultDimensionForAccountingDistribution(projOpsEnabled, accountingDistribution, sourceDocumentLineItem);
                        }
                    }

                    if (projTransType == ProjTransType::Revenue)
                    {
                        actualQuantity = 1;
                    }
                    else
                    {
                        if (accountingDistribution.SourceDocumentLine == sourceDocumentLineItem.parmSourceDocumentLine().RecId &&
                            (accountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice
                             || accountingDistribution.MonetaryAmount == MonetaryAmount::PayrollCost
                             || accountingDistribution.MonetaryAmount == MonetaryAmount::PayrollLiability
                             || accountingDistribution.MonetaryAmount == MonetaryAmount::WorkInProcess))
                        {
                            actualQuantity += ProjectAccountingDistribution::quantity(accountingDistribution);
                        }
                    }

                    if (useFundingLimitTracking)
                    {
                        actualTransactionCurrencyCostAmount += projFundingLimitTracking.Amount;
                        actualAccountingCurrencyCostAmount += projFundingLimitTracking.Amount;
                        actualTransactionCurrencySalesAmount += projFundingLimitTracking.Amount;
                        actualAccountingCurrencySalesAmount += projFundingLimitTracking.Amount;
                    }
                    else
                    {
                        actualTransactionCurrencyCostAmount += ProjectAccountingDistribution::transactionCurrencyCostAmount(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem);
                        actualAccountingCurrencyCostAmount += ProjectAccountingDistribution::accountingCurrencyCostAmount(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem);
                        actualTransactionCurrencySalesAmount += ProjectAccountingDistribution::transactionCurrencySalesAmount(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem);
                        actualAccountingCurrencySalesAmount += ProjectAccountingDistribution::accountingCurrencySalesAmount(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem);
                    }

                    actualHeader.insert(projectActualHeaderKey, #projectActualHeaderContainerMacro);

                    //Project actual details
                    projectActualDetailKey = projectActualDetailKey();

                    //Project actual cost detail
                    if (actualHeader_actualCostDetail.exists(projectActualHeaderKey))
                    {
                        packedActualCostDetail = actualHeader_actualCostDetail.lookup(projectActualHeaderKey);
                        actualCostDetail = Map::create(packedActualCostDetail);
                        actualHeader_actualCostDetail.remove(projectActualHeaderKey);
                    }
                    else
                    {
                        actualCostDetail = new Map(Types::String, Types::Container);
                    }

                    if (actualCostDetail.exists(projectActualDetailKey))
                    {
                        #projectActualDetailContainerMacro = actualCostDetail.lookup(projectActualDetailKey);
                        actualReferenceProjectAccountingDistribution = List::create(packedActualReferenceProjectAccountingDistribution);
                        actualLedgerUpdate = List::create(packedActualLedgerUpdate);
                        actualCostDetail.remove(projectActualDetailKey);
                    }
                    else
                    {
                        #clearProjectActualDetailContainerMacro
                    }

                    if (useFundingLimitTracking)
                    {
                        actualFundingSource = projFundingLimit.FundingSource;
                        actualTransactionCurrencyAmount += projFundingLimitTracking.Amount;
                        actualAccountingCurrencyAmount += projFundingLimitTracking.Amount;
                    }
                    else
                    {
                        actualFundingSource = projectAccountingDistribution.ProjFundingSource;
                        actualTransactionCurrencyAmount += ProjectAccountingDistribution::transactionCurrencyCostAmount(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem);
                        actualAccountingCurrencyAmount += ProjectAccountingDistribution::accountingCurrencyCostAmount(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem);
                    }

                    // When moving the amounts from the balance sheet to the P/L and posting timesheet or purchase order invoice,
                    // Consider the merged dimensions from the timesheet or purchase line and the default dimensions set on the project.
                    if (sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem
                        || sourceDocumentLineItem is TSTimesheetTransSourceDocLineItem)
                    {
                        actualDetailDefaultDimension = actualDefaultDimension;
                    }
                    else
                    {
                        actualDetailDefaultDimension = SubledgerJournalizerProjectExtension::getDefaultDimensionForAccountingDistribution(projOpsEnabled, accountingDistribution, sourceDocumentLineItem);
                    }

                    getReferenceProjectAccountingDistribution(ProjCostSales::Cost);
                    if (referenceProjectAccountingDistribution)
                    {
                        processedDistributionKey = strFmt("%1#%2",referenceProjectAccountingDistribution.RecId, ProjCostSales::Cost);

                        if (!processedDistributionForLedgerUpdate.in(processedDistributionKey))
                        {
                            actualReferenceProjectAccountingDistribution.addEnd(referenceProjectAccountingDistribution.RecId);
                            processLedgerUpdate();
                            processedDistributionForLedgerUpdate.add(processedDistributionKey);
                        }
                    }

                    // Since we're using one variable to store  the funding source on both ledger updates and actuals
                    // The Actual Cost funding source may have been overwritten when processLedgerUpdate was called (ie. a distribution can have mutiple funding sources)
                    // So we need to set it again here after calling processLedgerUpdate
                    if (useFundingLimitTracking)
                    {
                        actualFundingSource = projFundingLimit.FundingSource;
                    }

                    packedActualReferenceProjectAccountingDistribution = actualReferenceProjectAccountingDistribution.pack();
                    packedActualLedgerUpdate = actualLedgerUpdate.pack();

                    actualCostDetail.insert(projectActualDetailKey, #projectActualDetailContainerMacro);

                    actualHeader_actualCostDetail.insert(projectActualHeaderKey, actualCostDetail.pack());

                    //Project actual sales detail
                    if (actualHeader_actualSalesDetail.exists(projectActualHeaderKey))
                    {
                        packedActualSalesDetail = actualHeader_actualSalesDetail.lookup(projectActualHeaderKey);
                        actualSalesDetail = Map::create(packedActualSalesDetail);
                        actualHeader_actualSalesDetail.remove(projectActualHeaderKey);
                    }
                    else
                    {
                        actualSalesDetail = new Map(Types::String, Types::Container);
                    }

                    if (actualSalesDetail.exists(projectActualDetailKey))
                    {
                        #projectActualDetailContainerMacro = actualSalesDetail.lookup(projectActualDetailKey);
                        actualReferenceProjectAccountingDistribution = List::create(packedActualReferenceProjectAccountingDistribution);
                        actualLedgerUpdate = List::create(packedActualLedgerUpdate);
                        actualSalesDetail.remove(projectActualDetailKey);
                    }
                    else
                    {
                        #clearProjectActualDetailContainerMacro
                    }

                    if (useFundingLimitTracking)
                    {
                        actualFundingSource = projFundingLimit.FundingSource;
                        actualTransactionCurrencyAmount += projFundingLimitTracking.Amount;
                        actualAccountingCurrencyAmount += projFundingLimitTracking.Amount;
                    }
                    else
                    {
                        actualFundingSource = projectAccountingDistribution.ProjFundingSource;
                        actualTransactionCurrencyAmount += ProjectAccountingDistribution::transactionCurrencySalesAmount(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem);
                        actualAccountingCurrencyAmount += ProjectAccountingDistribution::accountingCurrencySalesAmount(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem);
                    }
                    
                    // When moving the amounts from the balance sheet to the P/L and purchase order invoice,
                    // Consider the merged dimensions from the purchase line and the default dimensions set on the project.
                    if (sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
                    {
                        actualDetailDefaultDimension = actualDefaultDimension;
                    }
                    else
                    {
                        actualDetailDefaultDimension = SubledgerJournalizerProjectExtension::getDefaultDimensionForAccountingDistribution(projOpsEnabled, accountingDistribution, sourceDocumentLineItem);
                    }

                    getReferenceProjectAccountingDistribution(ProjCostSales::Sales);
                    if (referenceProjectAccountingDistribution)
                    {
                        processedDistributionKey = strFmt("%1#%2",referenceProjectAccountingDistribution.RecId, ProjCostSales::Sales);

                        if (!processedDistributionForLedgerUpdate.in(processedDistributionKey))
                        {
                            actualReferenceProjectAccountingDistribution.addEnd(referenceProjectAccountingDistribution.RecId);
                            processLedgerUpdate();
                            processedDistributionForLedgerUpdate.add(processedDistributionKey);
                        }
                    }

                    packedActualReferenceProjectAccountingDistribution = actualReferenceProjectAccountingDistribution.pack();
                    packedActualLedgerUpdate = actualLedgerUpdate.pack();

                    actualSalesDetail.insert(projectActualDetailKey, #projectActualDetailContainerMacro);

                    actualHeader_actualSalesDetail.insert(projectActualHeaderKey, actualSalesDetail.pack());
                }
            }
        }

        actualHeader = new Map(Types::String, Types::Container);
        actualHeader_actualCostDetail = new Map(Types::String, Types::Container);
        actualHeader_actualSalesDetail = new Map(Types::String, Types::Container);

        queryRun = new QueryRun(SubledgerJournalizerProjectExtension::distributionsForJournalization(_sourceDocumentHeader));
        boolean useAccountingEventTmp = SubledgerJournalizerProjectExtension::canUseAccountingEventTmp(_sourceDocumentHeader.TypeEnumName);

        if (useAccountingEventTmp)
        {
            queryRun.setRecord(accountingEventTmp);
        }

        boolean vendorInvoiceRetentionTransitionFlightLocal = ProjVendorInvoiceRetentionCalcFeatureHelper::isTransitionFlightEnabled();
        
        while (queryRun.next())
        {
            accountingDistribution = queryRun.get(tableNum(AccountingDistribution));

            boolean processAccountingDistribution = SubledgerJournalizerProjectExtension::shouldProcessAccountingDistribution(accountingDistribution);
   
            if (processAccountingDistribution)
            {
                projectAccountingDistribution = queryRun.get(tableNum(ProjectAccountingDistribution));
                topSourceDocumentLineItem = ProjectSourceDocumentLineItemHelper::sourceDocumentLineItemTopParent(accountingDistribution.SourceDocumentLine);
                vendInvoiceLine = null;
                paymentRetentionPercentage = 0;
                paymentRetentionReleaseAmount = 0;

                //Calculate the vendor invoice retention percentage and vendor invoice retention release percentage.
                //If vendor invoice retention release percentage is 0 and this is PSAProjPurchRetain ledger posting type,
                //then skip this posting since there is nothing to release.
                if (topSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
                {
                    vendInvoiceLine = VendInvoiceInfoLine::findSourceDocumentLine(topSourceDocumentLineItem.parmSourceDocumentLine().RecId);

                    if (vendInvoiceLine.PSARetainagePercent || vendInvoiceLine.PSAReleaseAmount)
                    {
                        paymentRetentionPercentage = vendInvoiceLine.PSARetainagePercent;
                        paymentRetentionReleaseAmount = vendInvoiceLine.PSAReleaseAmount;
                    }

                    // If vendor invoice retention release percentage is zero, vendor retention cost amount calculation feature is enabled and release all retained amount is enabled
                    // then skip this posting since there is nothing to release.
                    if (paymentRetentionPercentage == 0
                        && (vendorInvoiceRetentionTransitionFlightLocal
                            || vendInvoiceLine.PSAIsFinal == NoYes::Yes)
                        && (!vendorInvoiceRetentionTransitionFlightLocal
                            || !vendInvoiceLine.LineAmount)
                        && ProjVendorInvoiceRetentionCalcFeatureHelper::shouldProcessWithFeatureEnabledBySouceDocumentLineItem(
                            vendorInvoiceRetentionCalcFeatureLocal,
                            topSourceDocumentLineItem))
                    {
                        continue;
                    }
                }

                //
                // Don't process work in process distributions for most types as this work was done with the extended price distribution
                // For revenue lines, we need to prcess the work in process distribution since it has no extended price distribution.
                //
                if (accountingDistribution.MonetaryAmount == MonetaryAmount::WorkInProcess)
                {
                    ProjAdvancedJournalLine projAdvancedJournalLine = ProjAdvancedJournalLine::findBySourceDocumentLine(accountingDistribution.SourceDocumentLine);
                    if (projAdvancedJournalLine && projAdvancedJournalLine.TransType != ProjTransType::Revenue)
                    {
                        continue;
                    }
                }

                if (ProjFundingLimitTrackingManager::isUsingDocumentMatching(topSourceDocumentLineItem))
                {
                    ProjFundingSource projFundingSource;

                    // Update funding limit spent as long as the assoicated founding source is not on hold.
                    while select forupdate projFundingLimit
                        exists join projFundingSource
                            where projFundingSource.RecId == projFundingLimit.FundingSource
                                && projFundingSource.RecId == projectAccountingDistribution.ProjFundingSource
                                && projFundingSource.FundingType != ProjFundingType::OnHoldFundingSource
                    {
                        useFundingLimitTracking = true;

                        processAccountingDistribution();

                        projFundingLimit.LimitSpent += projectAccountingDistribution.TransactionCurrencyAmount;
                        if (projFundingLimit.AmountMst - projFundingLimit.LimitSpent < -adjustmentError)
                        {
                            throw error("@SYS4110061");
                        }

                        projFundingLimit.update();
                    }

                    if (useFundingLimitTracking)
                    {
                        //Delete funding limit tracking since we already updated the Limit Spent of the funding limit
                        delete_from projFundingLimitTracking
                            where projFundingLimitTracking.AccountingDistribution == accountingDistribution.RecId
                            && projFundingLimitTracking.ProjectAccountingDistribution == projectAccountingDistribution.RecId
                            && projFundingLimitTracking.Reversing == NoYes::No;

                        // if vendor invoice and total amount > PO and qty < PO
                        // delete PO tracking information
                        if (SysTransactionScopeCache::get(classStr(SubledgerJournalizerProjectExtension), topSourceDocumentLineItem.parmSourceDocumentLine().RecId, false) == false)
                        {
                            if (!vendInvoiceLine.RecId)
                            {
                                vendInvoiceLine = VendInvoiceInfoLine::findSourceDocumentLine(topSourceDocumentLineItem.parmSourceDocumentLine().RecId);
                            }
                            purchLine = PurchLine::findRecId(vendInvoiceLine.PurchLineRecId);
                            if (purchLine.RecId != 0 && vendInvoiceLine.RecId != 0)
                            {
                                if (vendInvoiceLine.LineAmount >= purchLine.LineAmount && vendInvoiceLine.ReceiveNow < purchLine.PurchQty)
                                {
                                    if (purchLine.SourceDocumentLine != 0)
                                    {
                                        ProjFundingLimitTrackingManager::deleteFundingLimitTrackingSourceDocLine(purchLine.SourceDocumentLine);
                                    }
                                }
                            }

                            SysTransactionScopeCache::get(classStr(SubledgerJournalizerProjectExtension), topSourceDocumentLineItem.parmSourceDocumentLine().RecId, true);
                        }
                    }
                    else
                    {
                        // For documents that do distribution matching and don't have funding tracking record,
                        // We don't create Project actual entries for those since we made sure the allocation in done in other distributions
                        if (accountingDistribution.TransactionCurrencyAmount > 0)
                        {
                            useFundingLimitTracking = false;
                            processAccountingDistribution();
                        }
                    }
                }
                else
                {
                    useFundingLimitTracking = false;
                    processAccountingDistribution();
                }
            }
        }

        return [actualHeader.pack(), actualHeader_actualCostDetail.pack(), actualHeader_actualSalesDetail.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjectActualMapV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Summarizes accounting distribution values that are used to create project actuals for only the submitted journal lines.
    /// </summary>
    /// <param name="_sourceDocument">
    /// A record in the <c>SourceDocument</c> table.
    /// </param>
    /// <returns>
    /// A Map that contains the project actual values.
    /// </returns>
    private static container getProjectActualMapV2(SourceDocument _sourceDocument)

    {
        #declareProjectActualHeaderContainerVariablesMacro
        #declareProjectActualDetailContainerVariablesMacro
        #declareActualLedgerUpdateContainerVariablesMacro

        Map                                     actualHeader;
        Map                                     actualHeader_actualCostDetail;
        Map                                     actualCostDetail;
        container                               packedActualCostDetail;
        Map                                     actualHeader_actualSalesDetail;
        Map                                     actualSalesDetail;
        container                               packedActualSalesDetail;
        str                                     projectActualHeaderKey;
        str                                     projectActualDetailKey;
        QueryRun                                queryRun;
        AccountingDistribution                  accountingDistribution;
        ProjectAccountingDistribution           projectAccountingDistribution;
        SourceDocumentLineItem                  sourceDocumentLineItem;
        SourceDocumentLineItemIProject          sourceDocumentLineItemIProject;
        AccountingDistribution                  referenceAccountingDistribution;
        ProjectAccountingDistribution           referenceProjectAccountingDistribution;

        SourceDocumentLineItemITimesheets       iTimesheets;

        ProjFundingLimitTracking                projFundingLimitTracking;
        ProjFundingLimitTracking                projFundingLimitTrackingLedgerUpdates;
        SourceDocumentLineItem                  topSourceDocumentLineItem;
        ProjFundingLimit                        projFundingLimit;
        ProjFundingLimit                        projFundingLimitLedgerUpdates;
        Set                                     processedDistributionForLedgerUpdate = new Set(Types::String);
        str                                     processedDistributionKey;
        boolean                                 useFundingLimitTracking;
        VendInvoiceInfoLine                     vendInvoiceLine;
        PurchLine                               purchLine;
        PSAPercent                              paymentRetentionPercentage;
        AmountCur                               paymentRetentionReleaseAmount;

        // For the case of retention, the calculation  of the amount in the tracking funding limit tracking table is
        // calculated by multiplication of accounting distribution allocation factor and retention percentage.
        // As for the case of tax, it is calculated by division of the total line amount times the receive amount to be invoiced.
        // Hence it is unavoidable to have rounding error and hence the rounding adjustment is required.
        // If this rounding adjustment is not used, then it may report false positive that the funding limit is exceeded.
        const real adjustmentError = 0.01;

        boolean vendorInvoiceRetentionCalcFeatureLocal = ProjVendorInvoiceRetentionCalcFeatureHelper::isFeatureEnabled();

        str projectActualHeaderKey()
        {
            return
                int642str(sourceDocumentLineItem.parmSourceDocumentLine().RecId) + '#' +
                CompanyInfo::findRecId(accountingDistribution.AccountingLegalEntity).DataArea + '#' +
                int642str(projectAccountingDistribution.ProjTable) + '#' +
                int642str(projectAccountingDistribution.ProjCategory) + '#' +
                int642str(projectAccountingDistribution.SmmActivities) + '#' +
                int642str(projectAccountingDistribution.ProjLineProperty) + '#' +
                ProjectAccountingDistribution::transactionCostCurrency(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem) + '#' +
                ProjectAccountingDistribution::transactionSalesCurrency(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem) + '#' +
                int642str(projectAccountingDistribution.TaxGroupHeading) + '#' +
                int642str(projectAccountingDistribution.TaxItemGroupHeading) + '#' +
            int642str(LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(accountingDistribution.LedgerDimension));
        }

        str projectActualDetailKey()
        {
            if (useFundingLimitTracking)
            {
                return int642str(projFundingLimit.FundingSource);
            }
            else
            {
                return
                int642str(projectAccountingDistribution.ProjFundingSource);
            }
        }

        void getReferenceProjectAccountingDistribution(ProjCostSales _projCostSales)
        {
            ProjectRevenueLine  projectRevenueLine;

            switch (_projCostSales)
            {
                case ProjCostSales::Cost:
                    switch (ProjectSourceDocumentLineItemHelper::projTransType(sourceDocumentLineItem))
                    {
                        case ProjTransType::Hour:
                        case ProjTransType::Cost:
                        case ProjTransType::Item:
                            referenceAccountingDistribution = AccountingDistribution::find(accountingDistribution.RecId);
                            referenceProjectAccountingDistribution = ProjectAccountingDistribution::find(projectAccountingDistribution.RecId);
                            break;

                        case ProjTransType::Revenue:
                            referenceAccountingDistribution = null;
                            referenceProjectAccountingDistribution = null;
                            break;

                        default:
                            throw error(strFmt("@SYS22828",funcName()));
                    }
                    break;

                case ProjCostSales::Sales:
                    switch (ProjectSourceDocumentLineItemHelper::projTransType(sourceDocumentLineItem))
                    {
                        case ProjTransType::Hour:
                        case ProjTransType::Cost:
                        case ProjTransType::Item:

                            if (sourceDocumentLineItem is ProjAdvancedJournalSourceDocumentLineItem)
                            {
                                referenceAccountingDistribution = ProjAdvancedJournalSourceDocumentLineItem::getWorkInProcessDistribution(accountingDistribution.RecId);
                            }
                            else
                            {
                                select firstonly referenceAccountingDistribution
                                    where referenceAccountingDistribution.ReferenceDistribution == accountingDistribution.RecId
                                        exists join projectRevenueLine
                                            where projectRevenueLine.SourceDocumentLine == referenceAccountingDistribution.SourceDocumentLine;
                            }

                            if (referenceAccountingDistribution)
                            {
                                referenceProjectAccountingDistribution = ProjectAccountingDistribution::findByAccountingDistribution(referenceAccountingDistribution.RecId);
                            }
                            else
                            {
                                referenceProjectAccountingDistribution = null;
                            }
                            break;

                        case ProjTransType::Revenue:
                            referenceAccountingDistribution = AccountingDistribution::find(accountingDistribution.RecId);
                            referenceProjectAccountingDistribution = ProjectAccountingDistribution::find(projectAccountingDistribution.RecId);
                            break;

                        default:
                            throw error(strFmt("@SYS22828",funcName()));
                    }
                    break;
                default:
                    throw error(strFmt("@SYS22828",funcName()));
            }
        }

        void processLedgerUpdate()
        {

            ProjTransType projTransType = ProjectSourceDocumentLineItemHelper::projTransType(sourceDocumentLineItem);
            ProjTable projTableLocal = ProjTable::findRecId(projectAccountingDistribution.ProjTable);
            ProjGroup projectGroup = projTableLocal.projGroup();
            boolean projOpsEnableFixedRateAgreementsNonStockedFeature = FeatureStateProvider::IsFeatureEnabled(ProjOpsFixedRateAgreementsForNonStockedFeature::instance());

            sourceDocumentLineItem = ProjectSourceDocumentLineItemHelper::sourceDocumentLineItemTopParent(accountingDistribution.SourceDocumentLine);

            Query subLedgerJournalAccountEntryQuery = SubledgerJournalizerProjectExtension::subLedgerJournalAccountEntries(referenceProjectAccountingDistribution.AccountingDistribution);
            QueryRun subLedgerJournalAccountEntryQueryRun = new QueryRun(subLedgerJournalAccountEntryQuery);
            while (subLedgerJournalAccountEntryQueryRun.next())
            {
                SubledgerJournalAccountEntry subledgerJournalAccountEntry = subLedgerJournalAccountEntryQueryRun.get(tableNum(SubledgerJournalAccountEntry));
                boolean processLedgerUpdate = SubledgerJournalizerProjectExtension::shouldProcessLedgerUpdate(subledgerJournalAccountEntry.RecId);

                if (processLedgerUpdate)
                {
                    if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
                    {
                        actualLedgerUpdatePostingType = SubledgerJournalizerProjectExtension::getActualLedgerUpdatePostingTypeV2(projTransType, projTableLocal, subledgerJournalAccountEntry);
                    }
                    else
                    {
                        actualLedgerUpdatePostingType = SubledgerJournalizerProjectExtension::getActualLedgerUpdatePostingType(projTransType, projectGroup, subledgerJournalAccountEntry);
                    }

                    actualLedgerUpdateLedgerDimension = subledgerJournalAccountEntry.LedgerDimension;
                    actualLedgerUpdateAccountingCurrencyAmount = 0;
                    if (ProjectSourceDocumentLineItemHelper::projTransType(sourceDocumentLineItem) == ProjTransType::Hour)
                    {
                        actualLedgerUpdateQuantity = ProjectAccountingDistribution::quantity(accountingDistribution);
                    }
                    else
                    {
                        actualLedgerUpdateQuantity = 0;
                    }

                    boolean projFundingLimitLedgerUpdated = false;

                    if (useFundingLimitTracking)
                    {
                        while select Amount, ProjFundingLimit from projFundingLimitTrackingLedgerUpdates
                            where projFundingLimitTrackingLedgerUpdates.AccountingDistribution == referenceAccountingDistribution.RecId &&
                                  projFundingLimitTrackingLedgerUpdates.ProjectAccountingDistribution == referenceProjectAccountingDistribution.RecId &&
                                  projFundingLimitTrackingLedgerUpdates.Reversing == NoYes::No
                        {
                            if (projFundingLimitTrackingLedgerUpdates.Amount)
                            {
                                projFundingLimitLedgerUpdates = ProjFundingLimit::find(projFundingLimitTrackingLedgerUpdates.ProjFundingLimit, true);
                                actualFundingSource = projFundingLimitLedgerUpdates.FundingSource;
                                actualLedgerUpdateAccountingCurrencyAmount = projFundingLimitTrackingLedgerUpdates.Amount;

                                projFundingLimitLedgerUpdated = true;
                            }

                            actualLedgerUpdate.addEnd(#actualLedgerUpdateContainerMacro);
                        }
                    }

                    if (!projFundingLimitLedgerUpdated)
                    {
                        if (subledgerJournalAccountEntry.TransactionCurrencyAmount)
                        {
                            PercentPositive percent = (abs(referenceAccountingDistribution.TransactionCurrencyAmount) / abs(subledgerJournalAccountEntry.TransactionCurrencyAmount)) * 100;
                            actualLedgerUpdateAccountingCurrencyAmount = subledgerJournalAccountEntry.AccountingCurrencyAmount * percent / 100;

                            if (projOpsEnableFixedRateAgreementsNonStockedFeature)
                            {
                                // Find the ProjInvoiceCurrency record using project contract , transactioncurrency
                                ProjTable projTable;
                                ExchRate exchRate;

                                select firstonly ProjInvoiceProjId from projTable
                                    where projTable.RecId == projectAccountingDistribution.ProjTable;
                                
                                if (projTable)
                                {
                                    exchRate = ProjInvoiceCurrency::getFixedExchRate(projTable.ProjInvoiceProjId, subledgerJournalAccountEntry.TransactionCurrency);
                                }

                                if (exchRate)
                                {
                                    // calculate the AccountingCurrencyAmount for sales transaction to use the fixed exchange rate agreement setup for project operations scenarios.
                                    actualLedgerUpdateAccountingCurrencyAmount = CurrencyExchangeHelper::mstAmount(subledgerJournalAccountEntry.TransactionCurrencyAmount,
                                        subledgerJournalAccountEntry.TransactionCurrency,
                                        subledgerJournalAccountEntry.ExchangeRateDate,
                                        Currency::noYes2UnknownNoYes(NoYes::No),
                                        exchRate);
                                }
                            }
                        }
                        else
                        {
                            actualLedgerUpdateAccountingCurrencyAmount = 0;
                        }

                        // Vendor payment retention terms will only apply to project transactions of type item and with ProjCost posting type.
                        if (projTransType == ProjTransType::Item
                            && subledgerJournalAccountEntry.PostingType == LedgerPostingType::ProjCost
                            && sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem
                            && !ProjVendorInvoiceRetentionCalcFeatureHelper::shouldProcessWithFeatureEnabledBySouceDocumentLineItem(
                                vendorInvoiceRetentionCalcFeatureLocal,
                                sourceDocumentLineItem))
                        {
                            AccountingDistribution purchLineAccountingDistribution = AccountingDistribution::find(referenceAccountingDistribution.ReferenceDistribution);
                            if (SourceDocumentHeader::find(purchLineAccountingDistribution.SourceDocumentHeader).SourceRelationType == tableNum(PurchTable) &&
                                SourceDocumentLine::find(purchLineAccountingDistribution.SourceDocumentLine).SourceRelationType == tableNum(PurchLine))
                            {
                                // If this invocie has vendor payment retention terms, then calculate the actual ledger amount accordningly.
                                VendorInvoiceLineSourceDocLineItem vendorInvoiceLineSourceDocLineItem = sourceDocumentLineItem as VendorInvoiceLineSourceDocLineItem;
                                actualLedgerUpdateAccountingCurrencyAmount = vendorInvoiceLineSourceDocLineItem.calcTransactionAmountForProjectVendorInvoiceRetention(
                                    accountingDistribution, actualLedgerUpdateAccountingCurrencyAmount);
                            }
                        }

                        // When Non-deductible tax exists and <c>UseTax</c> is checked then don't add record with <c>LedgerPostingType - PurchConsump</c>
                        // to ledger updates in case of flight enabled.
                        if (SubledgerJournalizerProjectExtension::shouldProcessTaxInActualLedgerUpdate(subledgerJournalAccountEntry, actualLedgerUpdatePostingType))
                        {
                            VendInvoiceInfoLine vendInvoiceInfoLineLocal;
                            PurchLine purchLineLocal;

                            if (sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
                            {
                                vendInvoiceInfoLineLocal = VendInvoiceInfoline::findSourceDocumentLine(sourceDocumentLineItem.parmSourceDocumentLine().RecId);
                            }
                            else if (sourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
                            {
                                purchLineLocal = PurchLine::findBySourceDocumentLine(sourceDocumentLineItem.parmSourceDocumentLine().RecId);
                            }

                            if (ProjectCommitmentFacade::checkIfNonRecoverableTaxExists(vendInvoiceInfoLineLocal, purchLineLocal))
                            {
                                TaxGroup salesTaxGroup = vendInvoiceInfoLineLocal.TaxGroup ? vendInvoiceInfoLineLocal.TaxGroup : purchLineLocal.TaxGroup;

                                TaxGroupData taxGroupData;
                                select firstonly UseTax from taxGroupData
                                    where taxGroupData.TaxGroup == salesTaxGroup
                                        && taxGroupData.DataAreaId == curExt();

                                if (!taxGroupData.UseTax)
                                {
                                    actualLedgerUpdate.addEnd(#actualLedgerUpdateContainerMacro);
                                }
                            }
                        }
                        else
                        {
                            actualLedgerUpdate.addEnd(#actualLedgerUpdateContainerMacro);
                        }
                    }
                }
            }
        }


        void processAccountingDistribution()
        {
            sourceDocumentLineItem = ProjectSourceDocumentLineItemHelper::sourceDocumentLineItemTopParent(accountingDistribution.SourceDocumentLine);
            if (ProjectSourceDocumentLineItemHelper::hasProject(sourceDocumentLineItem))
            {
                sourceDocumentLineItemIProject = sourceDocumentLineItem as SourceDocumentLineItemIProject;

                boolean projOpsEnabled = ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled();

                if (SubledgerJournalizerProjectExtension::parmCanBookActuals(sourceDocumentLineItem))
                {
                    //Project actual headers
                    projectActualHeaderKey = projectActualHeaderKey();
                    if (actualHeader.exists(projectActualHeaderKey))
                    {
                        #projectActualHeaderContainerMacro = actualHeader.lookup(projectActualHeaderKey);
                        actualHeader.remove(projectActualHeaderKey);
                    }
                    else
                    {
                        #clearProjectActualHeaderContainerMacro
                    }

                    actualSourceDocumentLine = sourceDocumentLineItem.parmSourceDocumentLine().RecId;
                    if (sourceDocumentLineItem is SourceDocumentLineItemITimesheets)
                    {
                        iTimesheets = sourceDocumentLineItem as SourceDocumentLineItemITimesheets;

                        actualProjectDataAreaId = CompanyInfo::findRecId(iTimesheets.parmProjectLegalEntity()).DataArea;
                    }
                    else if (sourceDocumentLineItem is ProjAdvancedJournalSourceDocumentLineItem)
                    {
                        ProjAdvancedJournalSourceDocumentLineItem projAdvancedJournalSourceDocumentLineItem = sourceDocumentLineItem as ProjAdvancedJournalSourceDocumentLineItem;
                        actualProjectDataAreaId = projAdvancedJournalSourceDocumentLineItem.parmProjectDataAreaId();
                    }
                    else
                    {
                        actualProjectDataAreaId = CompanyInfo::findRecId(accountingDistribution.AccountingLegalEntity).DataArea;
                    }

                    changecompany (actualProjectDataAreaId)
                    {
                        actualProjectId = ProjTable::findRecId(projectAccountingDistribution.ProjTable).ProjId;
                        actualCategoryId = ProjCategory::findRecId(projectAccountingDistribution.ProjCategory).CategoryId;
                        actualActivityNumber = smmActivities::findWithRecId(projectAccountingDistribution.SmmActivities).ActivityNumber;
                        actualLinePropertyId = ProjLineProperty::findRecId(projectAccountingDistribution.ProjLineProperty).LinePropertyId;
                        actualTaxGroupId = TaxGroupHeading::findRecId(projectAccountingDistribution.TaxGroupHeading).TaxGroup;
                        actualTaxItemGroupId = TaxItemGroupHeading::findRecId(projectAccountingDistribution.TaxItemGroupHeading).TaxItemGroup;
                    }
                    actualTransactionCostCurrency = ProjectAccountingDistribution::transactionCostCurrency(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem);
                    actualTransactionSalesCurrency = ProjectAccountingDistribution::transactionSalesCurrency(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem);
                    accountingCurrency = Ledger::accountingCurrency(CompanyInfo::find(accountingDistribution.AccountingLegalEntity).RecId);
                    vendInvoiceLine = VendInvoiceInfoLine::findSourceDocumentLine(topSourceDocumentLineItem.parmSourceDocumentLine().RecId);
                    boolean projDimensionDefault = false;
     
                    ProjTable projTable;
                    select firstonly projTable
                        where projTable.RecId == projectAccountingDistribution.ProjTable;

                    if (vendInvoiceLine && actualProjectDataAreaId == curExt())
                    {
                        LedgerDimensionValueSet mergingDimension = vendInvoiceLine.DefaultDimension;

                        if (!mergingDimension && vendInvoiceLine.PurchLineRecId)
                        {
                            // Get dimension from purch line if <c>vendInvoiceLine</c> dimension is missing. After the PO is confirmed
                            // and invoiced, the invoice financial dimensions are fetched from the purch line.
                            purchLine = PurchLine::findRecId(vendInvoiceLine.PurchLineRecId);
                            mergingDimension = purchLine.DefaultDimension;
                        }
                        
                        actualDefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(mergingDimension, projTable.DefaultDimension);
                        projDimensionDefault = true;
                    }
                    
                    ProjTransType projTransType = ProjectSourceDocumentLineItemHelper::projTransType(sourceDocumentLineItem);

                    if (!projDimensionDefault)
                    {
                        if (sourceDocumentLineItem is TSTimesheetTransSourceDocLineItem)
                        {
                            // When moving the amounts from the balance sheet to the P/L and posting timesheet, merge the dimensions
                            // from timesheet and the default dimensions set on the project – which is inclusive of Cost center.
                            SourceDocumentLineImplementation sourceDocumentLineImplementation = sourceDocumentLineItem.parmSourceDocumentLine().getSourceDocumentLineImplementation();
                            TSTimesheetLine tsTimesheetLine = TSTimesheetTrans::findRecId(sourceDocumentLineImplementation.RecId).timesheetLine();
                            actualDefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(tsTimesheetLine.DefaultDimension, projTable.DefaultDimension);
                        }
                        else
                        {
                            actualDefaultDimension = SubledgerJournalizerProjectExtension::getDefaultDimensionForAccountingDistribution(projOpsEnabled, accountingDistribution, sourceDocumentLineItem);
                        }
                    }

                    if (projTransType == ProjTransType::Revenue)
                    {
                        actualQuantity = 1;
                    }
                    else
                    {
                        if (accountingDistribution.SourceDocumentLine == sourceDocumentLineItem.parmSourceDocumentLine().RecId &&
                            (accountingDistribution.MonetaryAmount == MonetaryAmount::ExtendedPrice
                             || accountingDistribution.MonetaryAmount == MonetaryAmount::PayrollCost
                             || accountingDistribution.MonetaryAmount == MonetaryAmount::PayrollLiability
                             || accountingDistribution.MonetaryAmount == MonetaryAmount::WorkInProcess))
                        {
                            actualQuantity += ProjectAccountingDistribution::quantity(accountingDistribution);
                        }
                    }

                    if (useFundingLimitTracking)
                    {
                        actualTransactionCurrencyCostAmount += projFundingLimitTracking.Amount;
                        actualAccountingCurrencyCostAmount += projFundingLimitTracking.Amount;
                        actualTransactionCurrencySalesAmount += projFundingLimitTracking.Amount;
                        actualAccountingCurrencySalesAmount += projFundingLimitTracking.Amount;
                    }
                    else
                    {
                        actualTransactionCurrencyCostAmount += ProjectAccountingDistribution::transactionCurrencyCostAmount(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem);
                        actualAccountingCurrencyCostAmount += ProjectAccountingDistribution::accountingCurrencyCostAmount(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem);
                        actualTransactionCurrencySalesAmount += ProjectAccountingDistribution::transactionCurrencySalesAmount(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem);
                        actualAccountingCurrencySalesAmount += ProjectAccountingDistribution::accountingCurrencySalesAmount(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem);
                    }

                    actualHeader.insert(projectActualHeaderKey, #projectActualHeaderContainerMacro);

                    //Project actual details
                    projectActualDetailKey = projectActualDetailKey();

                    //Project actual cost detail
                    if (actualHeader_actualCostDetail.exists(projectActualHeaderKey))
                    {
                        packedActualCostDetail = actualHeader_actualCostDetail.lookup(projectActualHeaderKey);
                        actualCostDetail = Map::create(packedActualCostDetail);
                        actualHeader_actualCostDetail.remove(projectActualHeaderKey);
                    }
                    else
                    {
                        actualCostDetail = new Map(Types::String, Types::Container);
                    }

                    if (actualCostDetail.exists(projectActualDetailKey))
                    {
                        #projectActualDetailContainerMacro = actualCostDetail.lookup(projectActualDetailKey);
                        actualReferenceProjectAccountingDistribution = List::create(packedActualReferenceProjectAccountingDistribution);
                        actualLedgerUpdate = List::create(packedActualLedgerUpdate);
                        actualCostDetail.remove(projectActualDetailKey);
                    }
                    else
                    {
                        #clearProjectActualDetailContainerMacro
                    }

                    if (useFundingLimitTracking)
                    {
                        actualFundingSource = projFundingLimit.FundingSource;
                        actualTransactionCurrencyAmount += projFundingLimitTracking.Amount;
                        actualAccountingCurrencyAmount += projFundingLimitTracking.Amount;
                    }
                    else
                    {
                        actualFundingSource = projectAccountingDistribution.ProjFundingSource;
                        actualTransactionCurrencyAmount += ProjectAccountingDistribution::transactionCurrencyCostAmount(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem);
                        actualAccountingCurrencyAmount += ProjectAccountingDistribution::accountingCurrencyCostAmount(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem);
                    }

                    // When moving the amounts from the balance sheet to the P/L and posting timesheet or purchase order invoice,
                    // Consider the merged dimensions from the timesheet or purchase line and the default dimensions set on the project.
                    if (sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem
                        || sourceDocumentLineItem is TSTimesheetTransSourceDocLineItem)
                    {
                        actualDetailDefaultDimension = actualDefaultDimension;
                    }
                    else
                    {
                        actualDetailDefaultDimension = SubledgerJournalizerProjectExtension::getDefaultDimensionForAccountingDistribution(projOpsEnabled, accountingDistribution, sourceDocumentLineItem);
                    }

                    getReferenceProjectAccountingDistribution(ProjCostSales::Cost);
                    if (referenceProjectAccountingDistribution)
                    {
                        processedDistributionKey = strFmt("%1#%2",referenceProjectAccountingDistribution.RecId, ProjCostSales::Cost);

                        if (!processedDistributionForLedgerUpdate.in(processedDistributionKey))
                        {
                            actualReferenceProjectAccountingDistribution.addEnd(referenceProjectAccountingDistribution.RecId);
                            processLedgerUpdate();
                            processedDistributionForLedgerUpdate.add(processedDistributionKey);
                        }
                    }

                    // Since we're using one variable to store  the funding source on both ledger updates and actuals
                    // The Actual Cost funding source may have been overwritten when processLedgerUpdate was called (ie. a distribution can have mutiple funding sources)
                    // So we need to set it again here after calling processLedgerUpdate
                    if (useFundingLimitTracking)
                    {
                        actualFundingSource = projFundingLimit.FundingSource;
                    }

                    packedActualReferenceProjectAccountingDistribution = actualReferenceProjectAccountingDistribution.pack();
                    packedActualLedgerUpdate = actualLedgerUpdate.pack();

                    actualCostDetail.insert(projectActualDetailKey, #projectActualDetailContainerMacro);

                    actualHeader_actualCostDetail.insert(projectActualHeaderKey, actualCostDetail.pack());

                    //Project actual sales detail
                    if (actualHeader_actualSalesDetail.exists(projectActualHeaderKey))
                    {
                        packedActualSalesDetail = actualHeader_actualSalesDetail.lookup(projectActualHeaderKey);
                        actualSalesDetail = Map::create(packedActualSalesDetail);
                        actualHeader_actualSalesDetail.remove(projectActualHeaderKey);
                    }
                    else
                    {
                        actualSalesDetail = new Map(Types::String, Types::Container);
                    }

                    if (actualSalesDetail.exists(projectActualDetailKey))
                    {
                        #projectActualDetailContainerMacro = actualSalesDetail.lookup(projectActualDetailKey);
                        actualReferenceProjectAccountingDistribution = List::create(packedActualReferenceProjectAccountingDistribution);
                        actualLedgerUpdate = List::create(packedActualLedgerUpdate);
                        actualSalesDetail.remove(projectActualDetailKey);
                    }
                    else
                    {
                        #clearProjectActualDetailContainerMacro
                    }

                    if (useFundingLimitTracking)
                    {
                        actualFundingSource = projFundingLimit.FundingSource;
                        actualTransactionCurrencyAmount += projFundingLimitTracking.Amount;
                        actualAccountingCurrencyAmount += projFundingLimitTracking.Amount;
                    }
                    else
                    {
                        actualFundingSource = projectAccountingDistribution.ProjFundingSource;
                        actualTransactionCurrencyAmount += ProjectAccountingDistribution::transactionCurrencySalesAmount(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem);
                        actualAccountingCurrencyAmount += ProjectAccountingDistribution::accountingCurrencySalesAmount(accountingDistribution, projectAccountingDistribution, sourceDocumentLineItem);
                    }
                    
                    // When moving the amounts from the balance sheet to the P/L and purchase order invoice,
                    // Consider the merged dimensions from the purchase line and the default dimensions set on the project.
                    if (sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
                    {
                        actualDetailDefaultDimension = actualDefaultDimension;
                    }
                    else
                    {
                        actualDetailDefaultDimension = SubledgerJournalizerProjectExtension::getDefaultDimensionForAccountingDistribution(projOpsEnabled, accountingDistribution, sourceDocumentLineItem);
                    }

                    getReferenceProjectAccountingDistribution(ProjCostSales::Sales);
                    if (referenceProjectAccountingDistribution)
                    {
                        processedDistributionKey = strFmt("%1#%2",referenceProjectAccountingDistribution.RecId, ProjCostSales::Sales);

                        if (!processedDistributionForLedgerUpdate.in(processedDistributionKey))
                        {
                            actualReferenceProjectAccountingDistribution.addEnd(referenceProjectAccountingDistribution.RecId);
                            processLedgerUpdate();
                            processedDistributionForLedgerUpdate.add(processedDistributionKey);
                        }
                    }

                    packedActualReferenceProjectAccountingDistribution = actualReferenceProjectAccountingDistribution.pack();
                    packedActualLedgerUpdate = actualLedgerUpdate.pack();

                    actualSalesDetail.insert(projectActualDetailKey, #projectActualDetailContainerMacro);

                    actualHeader_actualSalesDetail.insert(projectActualHeaderKey, actualSalesDetail.pack());
                }
            }
        }

        actualHeader = new Map(Types::String, Types::Container);
        actualHeader_actualCostDetail = new Map(Types::String, Types::Container);
        actualHeader_actualSalesDetail = new Map(Types::String, Types::Container);

        queryRun = new QueryRun(SubledgerJournalizerProjectExtension::distributionsForJournalizationV2(_sourceDocument));

        if (enumName2Id(_sourceDocument.parmSourceDocumentHeader().typeEnumName) == enumNum(SourceDocument_ProjAdvancedJournal))
        {
            queryRun.setRecord(accountingEventTmp);
        }

        boolean vendorInvoiceRetentionTransitionFlightLocal = ProjVendorInvoiceRetentionCalcFeatureHelper::isTransitionFlightEnabled();
        
        while (queryRun.next())
        {
            accountingDistribution = queryRun.get(tableNum(AccountingDistribution));

            boolean processAccountingDistribution = SubledgerJournalizerProjectExtension::shouldProcessAccountingDistribution(accountingDistribution);
   
            if (processAccountingDistribution)
            {
                projectAccountingDistribution = queryRun.get(tableNum(ProjectAccountingDistribution));
                topSourceDocumentLineItem = ProjectSourceDocumentLineItemHelper::sourceDocumentLineItemTopParent(accountingDistribution.SourceDocumentLine);
                vendInvoiceLine = null;
                paymentRetentionPercentage = 0;
                paymentRetentionReleaseAmount = 0;

                //Calculate the vendor invoice retention percentage and vendor invoice retention release percentage.
                //If vendor invoice retention release percentage is 0 and this is PSAProjPurchRetain ledger posting type,
                //then skip this posting since there is nothing to release.
                if (topSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem)
                {
                    VendorInvoiceLineSourceDocLineItem vendorInvoiceLineSourceDocLineItem = sourceDocumentLineItem as VendorInvoiceLineSourceDocLineItem;
                    vendInvoiceLine = VendInvoiceInfoLine::findSourceDocumentLine(topSourceDocumentLineItem.parmSourceDocumentLine().RecId);

                    if (vendInvoiceLine.PSARetainagePercent || vendInvoiceLine.PSAReleaseAmount)
                    {
                        paymentRetentionPercentage = vendInvoiceLine.PSARetainagePercent;
                        paymentRetentionReleaseAmount = vendInvoiceLine.PSAReleaseAmount;
                    }

                    // If vendor invoice retention release percentage is zero, vendor retention cost amount calculation feature is enabled and release all retained amount is enabled
                    // then skip this posting since there is nothing to release.
                    if (paymentRetentionPercentage == 0
                        && (vendorInvoiceRetentionTransitionFlightLocal
                            || vendInvoiceLine.PSAIsFinal == NoYes::Yes)
                        && (!vendorInvoiceRetentionTransitionFlightLocal
                            || !vendInvoiceLine.LineAmount)
                        && ProjVendorInvoiceRetentionCalcFeatureHelper::shouldProcessWithFeatureEnabledBySouceDocumentLineItem(
                            vendorInvoiceRetentionCalcFeatureLocal,
                            vendorInvoiceLineSourceDocLineItem))
                    {
                        continue;
                    }
                }

                //
                // Don't process work in process distributions for most types as this work was done with the extended price distribution
                // For revenue lines, we need to prcess the work in process distribution since it has no extended price distribution.
                //
                if (accountingDistribution.MonetaryAmount == MonetaryAmount::WorkInProcess)
                {
                    ProjAdvancedJournalLine projAdvancedJournalLine = ProjAdvancedJournalLine::findBySourceDocumentLine(accountingDistribution.SourceDocumentLine);
                    if (projAdvancedJournalLine && projAdvancedJournalLine.TransType != ProjTransType::Revenue)
                    {
                        continue;
                    }
                }

                if (ProjFundingLimitTrackingManager::isUsingDocumentMatching(topSourceDocumentLineItem))
                {
                    ProjFundingSource projFundingSource;

                    // Update funding limit spent as long as the assoicated founding source is not on hold.
                    while select forupdate projFundingLimit
                        exists join projFundingSource
                            where projFundingSource.RecId == projFundingLimit.FundingSource
                                && projFundingSource.RecId == projectAccountingDistribution.ProjFundingSource
                                && projFundingSource.FundingType != ProjFundingType::OnHoldFundingSource
                    {
                        useFundingLimitTracking = true;

                        processAccountingDistribution();

                        projFundingLimit.LimitSpent += projectAccountingDistribution.TransactionCurrencyAmount;
                        if (projFundingLimit.AmountMst - projFundingLimit.LimitSpent < -adjustmentError)
                        {
                            throw error("@SYS4110061");
                        }

                        projFundingLimit.update();
                    }

                    if (useFundingLimitTracking)
                    {
                        //Delete funding limit tracking since we already updated the Limit Spent of the funding limit
                        delete_from projFundingLimitTracking where projFundingLimitTracking.AccountingDistribution == accountingDistribution.RecId &&
                                                                projFundingLimitTracking.ProjectAccountingDistribution == projectAccountingDistribution.RecId &&
                                                                projFundingLimitTracking.Reversing == NoYes::No;

                        // if vendor invoice and total amount > PO and qty < PO
                        // delete PO tracking information
                        if (SysTransactionScopeCache::get(classStr(SubledgerJournalizerProjectExtension), topSourceDocumentLineItem.parmSourceDocumentLine().RecId, false) == false)
                        {
                            if (!vendInvoiceLine.RecId)
                            {
                                vendInvoiceLine = VendInvoiceInfoLine::findSourceDocumentLine(topSourceDocumentLineItem.parmSourceDocumentLine().RecId);
                            }
                            purchLine = PurchLine::findRecId(vendInvoiceLine.PurchLineRecId);
                            if (purchLine.RecId != 0 && vendInvoiceLine.RecId != 0)
                            {
                                if (vendInvoiceLine.LineAmount >= purchLine.LineAmount && vendInvoiceLine.ReceiveNow < purchLine.PurchQty)
                                {
                                    if (purchLine.SourceDocumentLine != 0)
                                    {
                                        ProjFundingLimitTrackingManager::deleteFundingLimitTrackingSourceDocLine(purchLine.SourceDocumentLine);
                                    }
                                }
                            }

                            SysTransactionScopeCache::get(classStr(SubledgerJournalizerProjectExtension), topSourceDocumentLineItem.parmSourceDocumentLine().RecId, true);
                        }
                    }
                    else
                    {
                        // For documents that do distribution matching and don't have funding tracking record,
                        // We don't create Project actual entries for those since we made sure the allocation in done in other distributions
                        if (accountingDistribution.TransactionCurrencyAmount > 0)
                        {
                            useFundingLimitTracking = false;
                            processAccountingDistribution();
                        }
                    }
                }
                else
                {
                    useFundingLimitTracking = false;
                    processAccountingDistribution();
                }
            }
        }

        return [actualHeader.pack(), actualHeader_actualCostDetail.pack(), actualHeader_actualSalesDetail.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProjLedgerStatusBalanceSheet</Name>
				<Source><![CDATA[
    private static boolean isProjLedgerStatusBalanceSheet(ProjTable _projTable, ProjTransType _projTransType)
    {
        boolean ret = true;
        if (!_projTable.ProjInvoiceProjId && ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            ret = false;
        }
        else
        {
            ret = (_projTransType == ProjTransType::Item && ProjRevRecHelper::getItemLedgerStatus(_projTable) == ProjLedgerStatus::BalanceSheet) ||
               (_projTransType == ProjTransType::Cost && ProjRevRecHelper::getCostLedgerStatus(_projTable) == ProjLedgerStatus::BalanceSheet) ||
               (_projTransType == ProjTransType::Hour && ProjRevRecHelper::getEmplLedgerStatus(_projTable) == ProjLedgerStatus::BalanceSheet);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasProject</Name>
				<Source><![CDATA[
    private static boolean hasProject(RefRecId _sourceDocumentHeader)
    {
        boolean                         hasProject;
        AccountingDistribution          accountingDistribution;
        ProjectAccountingDistribution   projectAccountingDistribution;

        select firstonly RecId from accountingDistribution
        where accountingDistribution.SourceDocumentHeader == _sourceDocumentHeader
            join RecId from projectAccountingDistribution
                where projectAccountingDistribution.AccountingDistribution == accountingDistribution.RecId;

        if (accountingDistribution.RecId)
        {
            hasProject = true;
        }
        else
        {
            hasProject = false;
        }

        return hasProject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasProjAccDistForAdvancedJournalDoc</Name>
				<Source><![CDATA[
    private static boolean hasProjAccDistForAdvancedJournalDoc(SourceDocument _sourceDocument)
    {
        boolean hasProject;
        AccountingDistribution accountingDistribution;
        ProjectAccountingDistribution projectAccountingDistribution;

        Map sourceDocumentLines = _sourceDocument.parmSourceDocumentLinesForCurrentVoucher();
        MapEnumerator sourceDocumentLinesEnum = sourceDocumentLines.getEnumerator();
        
        while (sourceDocumentLinesEnum.moveNext())
        {
            RefRecId sourceDocLineRecId = sourceDocumentLinesEnum.currentKey();

            select firstonly RecId from accountingDistribution
                where accountingDistribution.SourceDocumentLine == sourceDocLineRecId
                exists join projectAccountingDistribution
                    where projectAccountingDistribution.AccountingDistribution == accountingDistribution.RecId;

            if (accountingDistribution)
            {
                hasProject = true;
                break;
            }
        }

        return hasProject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVendorRetainage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current source document contains any vendor retainage transactions.
    /// </summary>
    /// <param name="_sourceDocumentHeaderRecId">
    /// The source document header record id.
    /// </param>
    /// <returns>
    /// True if the source document contains vendor retainage transactions.
    /// </returns>
    /// <remarks>
    /// Vendor retention detection should not be detected by source document header. It should be detected in the line level.
    /// This function should be obsoleted when <c>ProjVendorInvoiceRetentionCalcTransitionFlight</c> is depercated.
    /// Then no code path should call into this funcation anymore.
    /// </remarks>
    [SysObsoleteAttribute('This function is obsoleted because vendor retention detection should not be detected by source document header. It should be detected in the line level.', false, 12\07\2022)]
    public static boolean isVendorRetainage(RefRecId _sourceDocumentHeaderRecId)
    {
        VendInvoiceInfoLine             vendInvoiceInfoLine;
        SourceDocumentLine              sourceDocumentLine;
        boolean                         retval = false;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            select firstonly RecId from vendInvoiceInfoLine
            exists join RecId from sourceDocumentLine
            where sourceDocumentLine.SourceDocumentHeader == _sourceDocumentHeaderRecId
                  && vendInvoiceInfoLine.SourceDocumentLine == sourceDocumentLine.RecId
                  && vendInvoiceInfoLine.psaReleaseAmount
                  && !vendInvoiceInfoLine.ReceiveNow;

            retval = vendInvoiceInfoLine.RecId != 0;
        }

        return retval;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanBookActuals</Name>
				<Source><![CDATA[
    public static boolean parmCanBookActuals(SourceDocumentLineItem _sourceDocumentLineItem)
    {
        boolean canBookActuals;

        if (ProjectSourceDocumentLineItemHelper::implementsProject(_sourceDocumentLineItem))
        {
            if (_sourceDocumentLineItem.parmSourceDocument())
            {
                canBookActuals = SubledgerJournalizerProjectExtension::parmCanSupportActuals(_sourceDocumentLineItem.parmSourceDocument().parmSourceDocumentHeader());
            }
            else
            {
                canBookActuals = SubledgerJournalizerProjectExtension::parmCanSDLSupportActuals(_sourceDocumentLineItem);
            }
            if (canBookActuals)
            {
                if (_sourceDocumentLineItem is SourceDocumentLineItemIProduct)
                {
                    canBookActuals = ProjectSourceDocumentLineItemHelper::canProcessProject(_sourceDocumentLineItem);

                    if (canBookActuals)
                    {
                        ProjCostTrans projCostTrans;
                        ProjEmplTrans projEmplTrans;
                        ProjItemTrans projItemTrans;
                        VendInvoiceTrans vendInvoiceTrans;

                        SourceDocumentLine sourceDocumentLine = _sourceDocumentLineItem.parmSourceDocumentLine();

                        switch (ProjectSourceDocumentLineItemHelper::projTransType(_sourceDocumentLineItem))
                        {
                            case ProjTransType::Item:
                                select firstonly RecId from projItemTrans
                                    where projItemTrans.VendInvoiceTransRecId != 0
                                join vendInvoiceTrans
                                    where vendInvoiceTrans.SourceDocumentLine == sourceDocumentLine.RecId
                                        && projItemTrans.VendInvoiceTransRecId == vendInvoiceTrans.RecId;
                                break;

                            case ProjTransType::Cost:
                                select firstonly RecId from projCostTrans
                                    where projCostTrans.VendInvoiceTrans != 0
                                join vendInvoiceTrans
                                    where vendInvoiceTrans.SourceDocumentLine == sourceDocumentLine.RecId
                                        && projCostTrans.VendInvoiceTrans == vendInvoiceTrans.RecId;
                                break;

                            case ProjTransType::Hour:
                                select firstonly RecId from projEmplTrans
                                    where projempltrans.vendinvoicetrans != 0
                                join vendinvoicetrans
                                    where vendinvoicetrans.sourcedocumentline == sourcedocumentline.RecId
                                        && projempltrans.vendinvoicetrans == vendinvoicetrans.RecId;
                                break;
                        }

                        if (projItemTrans || projCostTrans || projEmplTrans)
                        {
                            canBookActuals = false;
                        }
                    }
                }
            }
        }

        return canBookActuals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanProcessInvoice</Name>
				<Source><![CDATA[
    private static boolean parmCanProcessInvoice(SourceDocumentHeader _sourceDocumentHeader)
    {
        boolean canProcessInvoice = false;

        if ((enumName2Id(_sourceDocumentHeader.TypeEnumName) == enumNum(SourceDocument_CustomerInvoice) &&
        _sourceDocumentHeader.TypeEnumValue == SourceDocument_CustomerInvoice::CustomerFreeTextInvoice))
        {
            canProcessInvoice = true;
        }

        return canProcessInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanSDLSupportActuals</Name>
				<Source><![CDATA[
    private static boolean parmCanSDLSupportActuals(SourceDocumentLineItem _sourceDocumentLineItem)
    {
        boolean                     canSDLSupportActuals;
        int                         enumId;
        SourceDocumentTypeEnumValue sourceDocumentTypeEnumValue;
        SourceDocumentLine          sourceDocumentLine;

        sourceDocumentLine          = _sourceDocumentLineItem.parmSourceDocumentLine();
        enumId                      = enumName2Id(sourceDocumentLine.TypeEnumName);
        sourceDocumentTypeEnumValue = sourceDocumentLine.TypeEnumValue;

        if (enumId == enumNum(SourceDocumentLine_VendorInvoice) && sourceDocumentTypeEnumValue == SourceDocumentLine_VendorInvoice::VendorInvoiceLine)
        {
            canSDLSupportActuals = true;
        }
        else if (enumId == enumNum(SourceDocumentLine_CustomerInvoice) && sourceDocumentTypeEnumValue == SourceDocumentLine_CustomerInvoice::CustomerFreeTextInvoiceLine)
        {
            canSDLSupportActuals = true;
        }
        else if (enumId == enumNum(SourceDocumentLine_ExpenseReport) && sourceDocumentTypeEnumValue == SourceDocumentLine_ExpenseReport::ExpenseReportLine)
        {
            canSDLSupportActuals = true;
        }
        else if (enumId == enumNum(SourceDocumentLine_ProjectTimesheets) && sourceDocumentTypeEnumValue == SourceDocumentLine_ProjectTimesheets::TimesheetTrans)
        {
            canSDLSupportActuals = true;
        }
        return canSDLSupportActuals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanSupportActuals</Name>
				<Source><![CDATA[
    private static boolean parmCanSupportActuals(SourceDocumentHeader _sourceDocumentHeader)
    {
        DictClass                           dictClass;
        Array                               extensionAttributes;
        int                                 i;
        SourceDocumentExtensionAttribute    extensionAttribute;
        SourceDocumentExtensionKey          sourceDocumentExtensionKey;
        boolean                             canSupportActuals;

        List listEnumsFromAttributes =
            SourceDocumentExtensionUtil::getEnumValuesFromAttributes(classStr(SubledgerJournalizerProjectExtension));
        ListEnumerator listEnumsFromAttributesEnumerator = listEnumsFromAttributes.getEnumerator();

        while (listEnumsFromAttributesEnumerator.moveNext())
        {
            container conEnumValue = listEnumsFromAttributesEnumerator.current();

            if (_sourceDocumentHeader.TypeEnumName == enumId2Name(conPeek(conEnumValue, 1)) &&
                _sourceDocumentHeader.TypeEnumValue == conPeek(conEnumValue, 2))
            {
                canSupportActuals = true;
                break;
            }
        }

        return canSupportActuals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInvoiceProposal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts invoices for transactions that originate from the business document.
    /// </summary>
    /// <param name="_projProposalJourList">
    /// A List of proposal IDs.
    /// </param>
    /// <param name="_voucher">
    /// The voucher number.
    /// </param>
    private static void postInvoiceProposal(List _projProposalJourList, Voucher _voucher)
    {
        ProjProposalRevenue             projProposalRevenue;
        ProjTransRevenueProposal        projTransRevenueProposal;
        ProjRevenueTrans                projRevenueTrans;
        ProjProposalRevenueDetail       projProposalRevenueDetail;
        ProjRevenueTransSale            projRevenueTransSale;
        ProjTransRevenueProposalSale    projTransRevenueProposalSale;
        ProjPost                        projPostInvoiceRevenue;
        ProjPost                        projPostRevenueProposalSale;
        ListEnumerator                  projProposalJourListEnumerator;
        PaymentStubInvoiceId            giroType;
        PaymMoneyTransferSlip           moneyTransferSlip;
        PaymId                          paymId;
        boolean                         isInvoicejournalCreated;

        void createInvoiceJournal(ProjProposalJour _projProposalJour)
        {
            ProjInvoiceJour         projInvoiceJour;
            NumberSeq               numberSeq;
            ProjProposalTotals      projProposalTotals;
            NoYes                   creditNote;

            projProposalTotals = new ProjProposalTotals(_projProposalJour);
            projProposalTotals.calc();
            if (projProposalTotals.projInvoiceTotalAmount() < 0)
            {
                creditNote = NoYes::Yes;
            }
            else
            {
                creditNote = NoYes::No;
            }

            numberSeq = ProjInvoiceJour::getNumSeqAndVoucher(_projProposalJour, creditNote);
            numberSeq.parmVoucherSequenceId(0);
            ttsbegin;

            projInvoiceJour.clear();
            projInvoiceJour.initFromProjProposal(_projProposalJour);

            projInvoiceJour.ProjInvoiceId       = numberSeq.num();
            projInvoiceJour.LedgerVoucher       = _voucher;
            projInvoiceJour.InvoiceDate         = _projProposalJour.InvoiceDate;

            // setting up exchange rates
            if (ProjInvoiceCurrency::exist(projInvoiceJour.ProjInvoiceProjId,projInvoiceJour.CurrencyId))
            {
                projInvoiceJour.ExchRate            = ProjInvoiceCurrency::find(projInvoiceJour.ProjInvoiceProjId,projInvoiceJour.CurrencyId).ExchRate;
                projInvoiceJour.ExchrateSecondary   = 0;
                projInvoiceJour.Triangulation       = NoYes::No;
            }
            else
            {
                projInvoiceJour.ExchRate            = ExchangeRateHelper::exchRate(projInvoiceJour.CurrencyId, projInvoiceJour.InvoiceDate);
                projInvoiceJour.ExchrateSecondary   = ExchangeRateHelper::exchRateSecond(projInvoiceJour.CurrencyId, projInvoiceJour.InvoiceDate);
                projInvoiceJour.Triangulation       = Currency::triangulation(projInvoiceJour.CurrencyId,projInvoiceJour.InvoiceDate);
            }
            projInvoiceJour.Qty                 = projProposalTotals.projInvoiceItemQty();
            projInvoiceJour.Weight              = projProposalTotals.projInvoiceItemWeight();
            projInvoiceJour.Volume              = projProposalTotals.projInvoiceItemVolume();
            projInvoiceJour.SumMarkup           = projProposalTotals.projInvoiceMarkup();
            projInvoiceJour.EndDisc             = projProposalTotals.projInvoiceEndDisc();
            projInvoiceJour.SumTax              = projProposalTotals.projInvoiceTaxTotal();
            projInvoiceJour.SalesOrderbalance   = projProposalTotals.projInvoiceBalance();
            projInvoiceJour.CostValue           = projProposalTotals.projInvoiceCostValue();
            projInvoiceJour.CashDisc            = projProposalTotals.projInvoiceCashDisc();
            projInvoiceJour.InvoiceRoundOff     = projProposalTotals.projInvoiceRoundOff();
            projInvoiceJour.InvoiceAmount       = projProposalTotals.projInvoiceTotalAmount();
            projInvoiceJour.DueDate             = dateNull();
            projInvoiceJour.calcDue();
            projInvoiceJour.CashDiscDate        = dateNull();
            projInvoiceJour.calcCashDiscDate();

            projInvoiceJour.smaSpecIndexCalc    = ProjFormletterParameters::find().smaSpecIndexCalc;

            if (numberSeq)
            {
                giroType = CustTable::find(projInvoiceJour.InvoiceAccount).GiroType;
                moneyTransferSlip = PaymMoneyTransferSlip::construct(giroType);
                moneyTransferSlip.init(giroType);
                moneyTransferSlip.parmNumSeqCode(numberSeq.parmNumberSequenceCode());
                paymId = moneyTransferSlip.ocrField(projInvoiceJour.InvoiceAccount, projInvoiceJour.ProjInvoiceId,
                    strLen(int642str(NumberSeq::highestV2(numberSeq.parmNumberSequenceId()))));

                projInvoiceJour.PaymId = strLRTrim(paymId);
            }

            // setting up exchange rates
            if (ProjInvoiceCurrency::exist(projInvoiceJour.ProjInvoiceProjId,projInvoiceJour.CurrencyId))
            {
                projInvoiceJour.ExchRate            = ProjInvoiceCurrency::find(projInvoiceJour.ProjInvoiceProjId,projInvoiceJour.CurrencyId).ExchRate;
                projInvoiceJour.ExchrateSecondary   = 0;
                projInvoiceJour.Triangulation       = NoYes::No;
            }
            else
            {
                projInvoiceJour.ExchRate            = ExchangeRateHelper::exchRate(projInvoiceJour.CurrencyId, projInvoiceJour.InvoiceDate);
                projInvoiceJour.ExchrateSecondary   = ExchangeRateHelper::exchRateSecond(projInvoiceJour.CurrencyId, projInvoiceJour.InvoiceDate);
                projInvoiceJour.Triangulation       = Currency::triangulation(projInvoiceJour.CurrencyId,projInvoiceJour.InvoiceDate);
            }

            projInvoiceJour.insert();

            Docu::copy(_projProposalJour, projInvoiceJour);

            //Update Proposal Journal
            _projProposalJour.selectForUpdate(true);
            _projProposalJour.ProjInvoiceId      = projInvoiceJour.ProjInvoiceId;
            _projProposalJour.InvoiceDate        = projInvoiceJour.InvoiceDate;
            _projProposalJour.ProjInvoiceId      = projInvoiceJour.ProjInvoiceId;
            _projProposalJour.ExchRate           = projInvoiceJour.ExchRate;
            _projProposalJour.ExchrateSecondary  = projInvoiceJour.ExchrateSecondary;
            _projProposalJour.Triangulation      = projInvoiceJour.Triangulation;
            _projProposalJour.LineProperty       = ProjLinePropertyCode::Invoiced;
            _projProposalJour.LedgerVoucher      = projInvoiceJour.LedgerVoucher;
            _projProposalJour.SalesOrderbalance  = projInvoiceJour.SalesOrderbalance;
            _projProposalJour.update();

            ttscommit;
        }

        if (!_projProposalJourList)
        {
            return;
        }

        projProposalJourListEnumerator = _projProposalJourList.getEnumerator();

        while (projProposalJourListEnumerator.moveNext())
        {
            isInvoicejournalCreated = false;
            while select projProposalRevenue
            where projProposalRevenue.ProposalId == projProposalJourListEnumerator.current()
            {
                if (isInvoicejournalCreated == false)
                {
                    //Create Invoice Header
                    createInvoiceJournal(projProposalRevenue.projProposalJour());
                    isInvoicejournalCreated = true;
                }

                projTransRevenueProposal    = ProjTrans::newProjProposalRevenue(projProposalRevenue);

                projPostInvoiceRevenue = ProjPost::newEnterSalesAccrued_Proposal(projProposalRevenue, null);
                projPostInvoiceRevenue.postTrans();

                while select projProposalRevenueDetail
                    where projProposalRevenueDetail.ProposalRefRecId == projProposalRevenue.RecId
                    join projRevenueTransSale
                        where projRevenueTransSale.RecId == projProposalRevenueDetail.SaleRefRecId
                            join projRevenueTrans
                                where projRevenueTrans.TransId == projRevenueTransSale.TransId
                {
                    projTransRevenueProposalSale = ProjTrans::newProjProposalRevenueSale(projProposalRevenue, projProposalRevenueDetail, projRevenueTransSale);

                    projPostRevenueProposalSale  = ProjPost::newEnterSalesAccrued_ProposalDetail(
                                                projProposalRevenue,
                                                projProposalRevenueDetail,
                                                projRevenueTrans,
                                                projRevenueTransSale,
                                                null,
                                                projTransRevenueProposalSale.ledgerSalesPosted());
                    projPostRevenueProposalSale.parmTaxParentReferenceRecId(projPostInvoiceRevenue.newTrans().RecId);
                    projPostRevenueProposalSale.parmTaxParentReferenceTableId(projPostInvoiceRevenue.newTrans().TableId);
                    projPostRevenueProposalSale.postTrans();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processFeeLinesWithoutAccruedRevenue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates the <c>ProjRevenueTrans</c> and <c>ProjRevenueTransSale</c> records associated with the provided project advanced
    ///     journal's fee type lines that do not accrue revenue, and therefore, were not posted to the general journal.
    /// </summary>
    /// <param name="_sourceDocument">
    ///     A project advanced journal source document record.
    /// </param>
    /// <remarks>
    ///     Will throw an error if the source document record provided is not a project advanced journal.
    /// </remarks>
    public static void processFeeLinesWithoutAccruedRevenue(SourceDocument _sourceDocument)
    {
        ProjAdvancedJournalLine projAdvancedJournalLine;
        ProjectAccountingDistribution projectAccountingDistribution;
        AccountingDistribution accountingDistribution;
        SourceDocumentLine sourceDocumentLine;

        ProjTable projTable;
        ProjCategory projCategory;
        ProjLineProperty projLineProperty;

        DimensionDefault defaultDimension;

        ProjTransIdBase createProjRevenueTrans()
        {
            ProjRevenueTrans   projRevenueTrans;

            projRevenueTrans.ProjId = projTable.ProjId;
            projRevenueTrans.CategoryId = projCategory.CategoryId;
            projRevenueTrans.LinePropertyId = projLineProperty.LinePropertyId;
 
            projRevenueTrans.CurrencyId = accountingDistribution.TransactionCurrency;
            projRevenueTrans.TaxGroupId = TaxGroupHeading::findRecId(projectAccountingDistribution.TaxGroupHeading).TaxGroup;
            projRevenueTrans.TaxItemGroupId = TaxItemGroupHeading::findRecId(projectAccountingDistribution.TaxItemGroupHeading).TaxItemGroup;
            projRevenueTrans.DefaultDimension = defaultDimension;
            projRevenueTrans.Qty = 1; // actual quantity is always set to 1 on fee type source document line items.

            projRevenueTrans.TransId =  ProjParameters::newTransId();
            projRevenueTrans.TransIdRef = projAdvancedJournalLine.ProjTransId;
            projRevenueTrans.AdjRefTransId = '';
            projRevenueTrans.TransactionOrigin = ProjOrigin::ProjAdvancedJournal;
            projRevenueTrans.TransDate = projAdvancedJournalLine.ProjTransDate;
            projRevenueTrans.Txt = projAdvancedJournalLine.Text;
            projRevenueTrans.Resource = projAdvancedJournalLine.ResourceId;
            projRevenueTrans.ResourceCategory = projAdvancedJournalLine.ResourceCategoryRoleId;
            projRevenueTrans.Price = 0;
            projRevenueTrans.smaBasePrice = 0;
            projRevenueTrans.smaEnddate = dateNull();
            projRevenueTrans.smaIndex = 0;
            projRevenueTrans.smaStartDate = dateNull();
            projRevenueTrans.smaSubscriptionId = '';
            projRevenueTrans.smaSubscriptionPeriodType = SMASubscriptionPeriodType::Regular;
            projRevenueTrans.VoucherJournal = projAdvancedJournalLine.Voucher;

            if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
            {
                ProjInvoiceProjId contractId = ProjTable::find(projRevenueTrans.ProjId).ProjInvoiceProjId;
                if (contractId)
                {
                    projRevenueTrans.PSAContractLineNum = ProjMultipleContractLinesForProjectFeatureHelper::getProjContractLineNumForTransType(projRevenueTrans.ProjId, contractId, ProjTransType::Revenue);
                }
            }

            projRevenueTrans.insert();

            SourceDocumentLineItem sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(sourceDocumentLine.RecId));
            SourceDocumentLineImplementation sourceDocumentLineImplementation = sourceDocumentLineItem.parmSourceDocumentLine().getSourceDocumentLineImplementation();
            Docu::copy(SourceDocumentLineImplementation, projRevenueTrans);

            projRevenueTrans.initProjRevenueTransTaxExtForProjOps_IN(sourceDocumentLineImplementation.SourceDocumentLine, projRevenueTrans);

            return projRevenueTrans.TransId;
        }

        RecId createProjRevenueTransSale(ProjTransIdBase _transId)
        {
            ProjRevenueTransSale    projRevenueTransSale;

            projRevenueTransSale.TransId = _transId;
            projRevenueTransSale.LedgerTransdate = accountingDistribution.AccountingDate;
            projRevenueTransSale.TransStatus = ProjTransStatus::Posted;
            projRevenueTransSale.wipPeriod = dateNull();
            projRevenueTransSale.wipType = ProjWIPType::AccruedTurnover;
            projRevenueTransSale.ControlId = '';
            projRevenueTransSale.ControlVersion = 0;
            projRevenueTransSale.FundingSource = projectAccountingDistribution.ProjFundingSource;
            projRevenueTransSale.DefaultDimension = defaultDimension;
            projRevenueTransSale.SalesPrice = CurrencyExchangeHelper::price(accountingDistribution.TransactionCurrencyAmount, accountingDistribution.TransactionCurrency);
            projRevenueTransSale.LineAmount = accountingDistribution.TransactionCurrencyAmount;

            projRevenueTransSale.insert();

            return projRevenueTransSale.RecId;
        }

        void processDistribution()
        {
            projTable = ProjTable::findRecId(projectAccountingDistribution.ProjTable);
            projCategory = ProjCategory::findRecId(projectAccountingDistribution.ProjCategory);
            projLineProperty = ProjLineProperty::findRecId(projectAccountingDistribution.ProjLineProperty);

            boolean canAccureRevenue;
            using (ProjectPostingParameters insertParameters = ProjectPostingParameters::parmProjContractLineNum(projAdvancedJournalLine.ContractLineId))
            {
                canAccureRevenue = ProjectPosting::canAccrueRevenue(
                                                projTable,
                                                projCategory,
                                                projLineProperty,
                                                projAdvancedJournalLine.ExtendedPrice,
                                                projectAccountingDistribution.ProjFundingSource);
            }

            if (!canAccureRevenue)
            {
                defaultDimension = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(accountingDistribution.LedgerDimension);

                ProjTransIdBase transId = createProjRevenueTrans();
                RecId projRevenueTransSaleRecId = createProjRevenueTransSale(transId);

                projectAccountingDistribution.ProjRevenueTransSale = projRevenueTransSaleRecId;
                projectAccountingDistribution.update();
            }
        }

        if (!(_sourceDocument is ProjAdvancedJournalSourceDocument))
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (ProjAdvancedJournalLineFeeWithoutAccruedRevenueFlight::instance().isEnabled() &&
            SubledgerJournalizerProjectExtension::isLineLevelPostingEnabled())
        {
            Map sourceDocumentLines = _sourceDocument.parmSourceDocumentLinesForCurrentVoucher();
            MapEnumerator sourceDocumentLinesEnum = sourceDocumentLines.getEnumerator();
        
            while (sourceDocumentLinesEnum.moveNext())
            {
                RefRecId sourceDocLineRecId = sourceDocumentLinesEnum.currentKey();

                while select forupdate * from projectAccountingDistribution
                    join accountingDistribution
                        where accountingDistribution.RecId == projectAccountingDistribution.AccountingDistribution
                    join RecId from sourceDocumentLine
                        where sourceDocumentLine.RecId == accountingDistribution.SourceDocumentLine
                            && sourceDocumentLine.RecId == sourceDocLineRecId
                    join projAdvancedJournalLine
                        where  projAdvancedJournalLine.SourceDocumentLine == sourceDocumentLine.RecId
                            && projAdvancedJournalLine.TransType == ProjTransType::Revenue
                {
                    processDistribution();
                }
            }
        }
        else
        {
            SourceDocumentHeader sourceDocumentHeader = _sourceDocument.parmSourceDocumentHeader();

            while select forupdate * from projectAccountingDistribution
                join accountingDistribution
                    where accountingDistribution.RecId == projectAccountingDistribution.AccountingDistribution
                join RecId from sourceDocumentLine
                    where sourceDocumentLine.RecId == accountingDistribution.SourceDocumentLine
                        && sourceDocumentLine.SourceDocumentHeader == sourceDocumentHeader.RecId
                join projAdvancedJournalLine
                    where  projAdvancedJournalLine.SourceDocumentLine == sourceDocumentLine.RecId
                        && projAdvancedJournalLine.TransType == ProjTransType::Revenue
            {
                processDistribution();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAccruedRevenue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Recognizes project revenue for time and material projects that were set up to accrue revenue.
    /// </summary>
    /// <param name="_sourceDocument">
    /// A <c>SourceDocument</c> instance.
    /// </param>
    public static void processAccruedRevenue(SourceDocument _sourceDocument)

    {
        #declareProjectRevenueLineContainerVariablesMacro

        container                       packedAccruedRevenueLine;
        Map                             accruedRevenueLine;
        MapEnumerator                   mapEnumerator;

        ProjectRevenueHeader            projectRevenueHeader;
        ProjectRevenueLine              projectRevenueLine;
        ProjectRevenueCaller            projectRevenueCaller;

        boolean enableProjEnableAdvancedJournalMultipleBatchTaskFeature = FeatureStateProvider::isFeatureEnabled(ProjEnableAdvancedJournalMultipleBatchTaskFeature::instance());
        boolean enableProjEnableAdvancedJournalErrorTransferFeature = FeatureStateProvider::isFeatureEnabled(ProjEnableAdvancedJournalErrorTransferFeature::instance());
        boolean isEnhancedPostingEnabled = FeatureStateProvider::isFeatureEnabled(ProjAdvancedJournalPostingEnhancementFeature::instance());

        if (_sourceDocument is ProjAdvancedJournalSourceDocument
            && (enableProjEnableAdvancedJournalMultipleBatchTaskFeature
                || enableProjEnableAdvancedJournalErrorTransferFeature
                || isEnhancedPostingEnabled))
        {
            packedAccruedRevenueLine = SubledgerJournalizerProjectExtension::getAccruedRevenueLineMapV2(_sourceDocument);
        }
        else
        {
            packedAccruedRevenueLine = SubledgerJournalizerProjectExtension::getAccruedRevenueLineMap(_sourceDocument.parmSourceDocumentHeader());
        }
            
        accruedRevenueLine = Map::create(packedAccruedRevenueLine);

        if (accruedRevenueLine.elements() > 0)
        {
            select projectRevenueHeader where projectRevenueHeader.ReferenceSourceDocumentHeader == _sourceDocument.parmSourceDocumentHeader().RecId;

            if (!projectRevenueHeader)
            {
                //Create project accrued revenue header
                projectRevenueHeader.clear();
                projectRevenueHeader.ReferenceSourceDocumentHeader = _sourceDocument.parmSourceDocumentHeader().RecId;
                projectRevenueHeader.insert();
            }

            //Create project revenue lines
            mapEnumerator = accruedRevenueLine.getEnumerator();
            while (mapEnumerator.moveNext())
            {
                #projectRevenueLineContainerMacro = mapEnumerator.currentValue();

                projectRevenueLine.clear();
                projectRevenueLine.ProjectRevenueHeader = projectRevenueHeader.RecId;
                projectRevenueLine.Currency = transactionSalesCurrency;
                projectRevenueLine.AccountingLegalEntity = transactionSalesLegalEntityRecId;
                projectRevenueLine.TransactionCurrencyAmount = transactionCurrencySalesAmount;
                projectRevenueLine.AccountingDate = accountingDate;
                projectRevenueLine.insert();
            }

            //Journalize project accrued revenue
            SourceDocumentProcessorFacade::submitSourceDocumentImplementation(projectRevenueHeader, false, SourceDocumentAccountingStatus::Completed);
            projectRevenueCaller = ProjectRevenueCaller::construct();
            projectRevenueCaller.parmVoucher(_sourceDocument.parmCurrentVoucher(curext()));
            SourceDocumentProcessorFacade::submitSourceDocumentImplementation(projectRevenueHeader, false, SourceDocumentAccountingStatus::Completed, projectRevenueCaller);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processInvoices</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and posts invoices for transactions that originate from the business document.
    /// </summary>
    /// <param name="_projectActualHeaderList">
    /// A list of project actual header records.
    /// </param>
    /// <param name="_voucher">
    /// The voucher number.
    /// </param>
    private static void processInvoices(List _projectActualHeaderList, Voucher _voucher)
    {
        List    projProposalJourList;

        // create invoice proposal
        projProposalJourList = SubledgerJournalizerProjectExtension::createInvoiceProposal(_projectActualHeaderList);

        // post Invoices for created proposal
        SubledgerJournalizerProjectExtension::postInvoiceProposal(projProposalJourList, _voucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processProjectActual</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the project actual records.
    /// </summary>
    /// <param name="_sourceDocument">
    /// A <c>SourceDocument</c> instance.
    /// </param>
    /// <param name="_canProcessInvoice">
    /// A Boolean value that indicates whether project transactions are invoiced during journalization.
    /// </param>
    /// <returns>
    /// A list that contains project actual header records.
    /// </returns>
    private static List processProjectActual(SourceDocument _sourceDocument, boolean _canProcessInvoice)

    {
        #declareProjectActualHeaderContainerVariablesMacro

        container                       packedActualHeader;
        Map                             actualHeader;
        container                       packedActualHeader_actualCostDetail;
        Map                             actualHeader_actualCostDetail;
        container                       packedActualCostDetail;
        Map                             actualCostDetail;
        container                       packedActualHeader_actualSalesDetail;
        Map                             actualHeader_actualSalesDetail;
        container                       packedActualSalesDetail;
        Map                             actualSalesDetail;

        MapEnumerator                   actualHeaderEnumerator;
        MapEnumerator                   actualDetailEnumerator;
        Common                          projectActualHeader;
        List                            projectActualHeaderList;
        container                       projectActualHeaderContainer;
        Voucher                         voucher;
        psaIndirectComponentTransJournalizer    indirectComponentJournalizer;
        SourceDocumentLineItem                  sourceDocumentLineItem;

        [packedActualHeader, packedActualHeader_actualCostDetail, packedActualHeader_actualSalesDetail] = SubledgerJournalizerProjectExtension::getProjectActualMap(_sourceDocument.parmSourceDocumentHeader());
        actualHeader = Map::create(packedActualHeader);
        actualHeader_actualCostDetail = Map::create(packedActualHeader_actualCostDetail);
        actualHeader_actualSalesDetail = Map::create(packedActualHeader_actualSalesDetail);

        if (actualHeader.elements())
        {
            actualHeaderLines = actualHeader.elements();
            projBudgetTransactionLinesCount = 0;
            projBudgetTransactionLineMap = new Map(Types::Real, Types::AnyType);
            actualHeaderEnumerator = actualHeader.getEnumerator();
            projectActualHeaderList = new List(Types::Record);
            while (actualHeaderEnumerator.moveNext())
            {
                projectActualHeaderContainer = actualHeaderEnumerator.currentValue();
       
	            #projectActualHeaderContainerMacro = projectActualHeaderContainer;

                if (_sourceDocument is TSTimesheetTableSourceDoc)
                {
                    voucher = _sourceDocument.parmCurrentVoucher(actualProjectDataAreaId);
                }

                changecompany (actualProjectDataAreaId)
                {
                    if (_sourceDocument is SourceDocumentILineVoucher)
                    {
                        SourceDocumentILineVoucher sourceDocumentILineVoucher = _sourceDocument as SourceDocumentILineVoucher;
                        AccountingDistribution accountingDistribution;

                        select firstonly AccountingEvent from accountingDistribution where accountingDistribution.SourceDocumentLine == actualSourceDocumentLine;
                        voucher = sourceDocumentILineVoucher.parmCurrentLineVoucher(AccountingEvent::find(accountingDistribution.AccountingEvent));
                    }
                    else if (!SysDictClass::isEqualOrSuperclass(classIdGet(_sourceDocument), classNum(TSTimesheetTableSourceDoc)))
                    {
                        voucher = _sourceDocument.parmCurrentVoucher(actualProjectDataAreaId);
                    }

                    projectActualHeader = SubledgerJournalizerProjectExtension::createProjectActualHeader(projectActualHeaderContainer, voucher);

                    if (ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled()
                        || ProjSkipDuplicateItemTransCreationFlight::instance().isEnabled())
                    {
                        // we skip creation of actual headers (Proj*Trans) for certain source documents (expense and vendor invoice lines)
                        // that have actuals created by CE/Dataverse side of Project Operations soluion,
                        // as result we have to opt-out from further processing and creation of the details
                        // the Proj*Trans and details for those documents will be created when processing corresponding AdvancedJournalLines
                        // for inbound actuals that hold reference to the original source document (expense, vendor invoice)
                        if (!projectActualHeader)
                        {
                            continue;
                        }
                    }

                    if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && projectActualHeader.TableId == tableNum(ProjRevenueTrans))
                    {
                        projectActualHeaderList.addEnd(projectActualHeader);
                    }
                    else
                    {
                        projectActualHeaderList.addEnd(projectActualHeader);
                    }
                    if (actualHeader_actualCostDetail.exists(actualHeaderEnumerator.currentKey()))
                    {
                        packedActualCostDetail = actualHeader_actualCostDetail.lookup(actualHeaderEnumerator.currentKey());

                        actualCostDetail = Map::create(packedActualCostDetail);
                        actualDetailEnumerator = actualCostDetail.getEnumerator();
                        while (actualDetailEnumerator.moveNext())
                        {
                            SubledgerJournalizerProjectExtension::createProjectActualCostDetail(projectActualHeader, actualHeaderEnumerator.currentValue(), actualDetailEnumerator.currentValue(), voucher);
                        }
                    }
                    else
                    {
                        throw error(strFmt("@SYS22828",funcName()));
                    }

                    if (actualHeader_actualSalesDetail.exists(actualHeaderEnumerator.currentKey()))
                    {
                        packedActualSalesDetail = actualHeader_actualSalesDetail.lookup(actualHeaderEnumerator.currentKey());

                        actualSalesDetail = Map::create(packedActualSalesDetail);
                        actualDetailEnumerator = actualSalesDetail.getEnumerator();
                        while (actualDetailEnumerator.moveNext())
                        {
                            SubledgerJournalizerProjectExtension::createProjectActualSalesDetail(projectActualHeader, actualHeaderEnumerator.currentValue(), actualDetailEnumerator.currentValue(), voucher, _canProcessInvoice);
                        }
                    }
                    else
                    {
                        throw error(strFmt("@SYS22828",funcName()));
                    }

                    if (isConfigurationkeyEnabled(configurationKeyNum(Project)) &&
                        psaIndirectComponentTransJournalizer::isIndirectComponentTransSource(projectActualHeader))
                    {
                        sourceDocumentLineItem = SubledgerJournalizerProjectExtension::getSourceDocLineItemFromHeaderContainer(projectActualHeaderContainer);

                        indirectComponentJournalizer = psaIndirectComponentTransJournalizer::constructForActualHeader(projectActualHeader, sourceDocumentLineItem);
                        indirectComponentJournalizer.journalize();
                    }
                    
                    SubledgerJournalizerProjectExtension::updateActualsOnPosting(projectActualHeader, actualSourceDocumentLine);
                }
            }
        }

        return projectActualHeaderList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processProjectActualV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the project actual records for only return the lines are submitted.
    /// </summary>
    /// <param name="_sourceDocument">
    /// A <c>SourceDocument</c> instance.
    /// </param>
    /// <param name="_canProcessInvoice">
    /// A Boolean value that indicates whether project transactions are invoiced during journalization.
    /// </param>
    /// <returns>
    /// A list that contains project actual header records.
    /// </returns>
    private List processProjectActualV2(SourceDocument _sourceDocument, boolean _canProcessInvoice)

    {
        #declareProjectActualHeaderContainerVariablesMacro

        container                       packedActualHeader;
        Map                             actualHeader;
        container                       packedActualHeader_actualCostDetail;
        Map                             actualHeader_actualCostDetail;
        container                       packedActualCostDetail;
        Map                             actualCostDetail;
        container                       packedActualHeader_actualSalesDetail;
        Map                             actualHeader_actualSalesDetail;
        container                       packedActualSalesDetail;
        Map                             actualSalesDetail;

        MapEnumerator                   actualHeaderEnumerator;
        MapEnumerator                   actualDetailEnumerator;
        Common                          projectActualHeader;
        List                            projectActualHeaderList;
        container                       projectActualHeaderContainer;
        Voucher                         voucher;
        psaIndirectComponentTransJournalizer    indirectComponentJournalizer;
        SourceDocumentLineItem                  sourceDocumentLineItem;

        [packedActualHeader, packedActualHeader_actualCostDetail, packedActualHeader_actualSalesDetail] = SubledgerJournalizerProjectExtension::getProjectActualMapV2(_sourceDocument);
        actualHeader = Map::create(packedActualHeader);
        actualHeader_actualCostDetail = Map::create(packedActualHeader_actualCostDetail);
        actualHeader_actualSalesDetail = Map::create(packedActualHeader_actualSalesDetail);

        if (actualHeader.elements())
        {
            actualHeaderEnumerator = actualHeader.getEnumerator();
            projectActualHeaderList = new List(Types::Record);
            while (actualHeaderEnumerator.moveNext())
            {
                projectActualHeaderContainer = actualHeaderEnumerator.currentValue();

                #projectActualHeaderContainerMacro = projectActualHeaderContainer;

                if (_sourceDocument is TSTimesheetTableSourceDoc)
                {
                    voucher = _sourceDocument.parmCurrentVoucher(actualProjectDataAreaId);
                }

                changecompany (actualProjectDataAreaId)
                {
                    if (_sourceDocument is SourceDocumentILineVoucher)
                    {
                        SourceDocumentILineVoucher sourceDocumentILineVoucher = _sourceDocument as SourceDocumentILineVoucher;
                        AccountingDistribution accountingDistribution;

                        select firstonly AccountingEvent from accountingDistribution where accountingDistribution.SourceDocumentLine == actualSourceDocumentLine;
                        voucher = sourceDocumentILineVoucher.parmCurrentLineVoucher(AccountingEvent::find(accountingDistribution.AccountingEvent));
                    }
                    else if (!SysDictClass::isEqualOrSuperclass(classIdGet(_sourceDocument), classNum(TSTimesheetTableSourceDoc)))
                    {
                        voucher = _sourceDocument.parmCurrentVoucher(actualProjectDataAreaId);
                    }

                    projectActualHeader = SubledgerJournalizerProjectExtension::createProjectActualHeader(projectActualHeaderContainer, voucher);

                    if (ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
                    {
                        // we skip creation of actual headers (Proj*Trans) for certain source documents (expense and vendor invoice lines)
                        // that have actuals created by CE/Dataverse side of Project Operations soluion,
                        // as result we have to opt-out from further processing and creation of the details
                        // the Proj*Trans and details for those documents will be created when processing corresponding AdvancedJournalLines
                        // for inbound actuals that hold reference to the original source document (expense, vendor invoice)
                        if (!projectActualHeader)
                        {
                            continue;
                        }
                    }

                    if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && projectActualHeader.TableId == tableNum(ProjRevenueTrans))
                    {
                        projectActualHeaderList.addEnd(projectActualHeader);
                    }
                    else
                    {
                        projectActualHeaderList.addEnd(projectActualHeader);
                    }
                    if (actualHeader_actualCostDetail.exists(actualHeaderEnumerator.currentKey()))
                    {
                        packedActualCostDetail = actualHeader_actualCostDetail.lookup(actualHeaderEnumerator.currentKey());

                        actualCostDetail = Map::create(packedActualCostDetail);
                        actualDetailEnumerator = actualCostDetail.getEnumerator();
                        while (actualDetailEnumerator.moveNext())
                        {
                            this.createProjectActualCostDetailV2(projectActualHeader, actualHeaderEnumerator.currentValue(), actualDetailEnumerator.currentValue(), voucher);
                        }
                    }
                    else
                    {
                        throw error(strFmt("@SYS22828",funcName()));
                    }

                    if (actualHeader_actualSalesDetail.exists(actualHeaderEnumerator.currentKey()))
                    {
                        packedActualSalesDetail = actualHeader_actualSalesDetail.lookup(actualHeaderEnumerator.currentKey());

                        actualSalesDetail = Map::create(packedActualSalesDetail);
                        actualDetailEnumerator = actualSalesDetail.getEnumerator();
                        while (actualDetailEnumerator.moveNext())
                        {
                            this.createProjectActualSalesDetailV2(projectActualHeader, actualHeaderEnumerator.currentValue(), actualDetailEnumerator.currentValue(), voucher, _canProcessInvoice);
                        }
                    }
                    else
                    {
                        throw error(strFmt("@SYS22828",funcName()));
                    }

                    if (isConfigurationkeyEnabled(configurationKeyNum(Project)) &&
                        psaIndirectComponentTransJournalizer::isIndirectComponentTransSource(projectActualHeader))
                    {
                        sourceDocumentLineItem = SubledgerJournalizerProjectExtension::getSourceDocLineItemFromHeaderContainer(projectActualHeaderContainer);

                        indirectComponentJournalizer = psaIndirectComponentTransJournalizer::constructForActualHeader(projectActualHeader, sourceDocumentLineItem);
                        indirectComponentJournalizer.journalize();
                    }
                    
                    SubledgerJournalizerProjectExtension::updateActualsOnPosting(projectActualHeader, actualSourceDocumentLine);
                }
            }
        }

        return projectActualHeaderList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processStocked</Name>
				<Source><![CDATA[
    public static void processStocked(VendInvoiceInfoTable  _vendInvoiceInfoTable)
    {
        VendInvoiceJour                     vendInvoiceJour;
        SourceDocumentLine                  sourceDocumentLine;
        SourceDocumentLineItem              sourceDocumentLineItem;
        SourceDocumentLineItemIProduct      sourceDocumentLineItemIProduct;
        SourceDocumentLineItemIProject      sourceDocumentLineItemIProject;
        SourceDocumentLineItemIInventory    sourceDocumentLineItemIInventory;
        InventTransOrigin                   purchLineInventTransOrigin;
        InventTransOrigin                   projectInventTransOrigin;
        ProjItemTrans                       projItemTrans;
        ProjBudgetTransactionManager        projBudgetTransactionManager;
        ProjBudgetTransaction               projBudgetTransaction;
        ProjBudgetTransactionLine           projBudgetTransactionLine;
        ProjForecastReduce                  projForecastReduce;
        ProjTrans_Virtual                   projTrans_Virtual;

        if (SubledgerJournalizerProjectExtension::hasProject(_vendInvoiceInfoTable.SourceDocumentHeader))
        {
            vendInvoiceJour = VendInvoiceJour::findSourceDocumentHeader(_vendInvoiceInfoTable.SourceDocumentHeader);
            if (vendInvoiceJour)
            {
                // Considering invoice line amount and currency for budget calculations
                VendInvoiceInfoLine vendInvoiceInfoLine;

                while select sourceDocumentLine
                    where sourceDocumentLine.SourceDocumentHeader == _vendInvoiceInfoTable.SourceDocumentHeader
                join CurrencyCode, LineAmount from vendInvoiceInfoLine
                    where vendInvoiceInfoLine.SourceDocumentLine == sourceDocumentLine.RecId
                {
                    sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(sourceDocumentLine);
                    if (sourceDocumentLineItem is SourceDocumentLineItemIProduct)
                    {
                        sourceDocumentLineItemIProduct = sourceDocumentLineItem as SourceDocumentLineItemIProduct;
                        if (sourceDocumentLineItemIProduct.parmStocked())
                        {
                            if (sourceDocumentLineItem is SourceDocumentLineItemIInventory)
                            {
                                sourceDocumentLineItemIInventory = sourceDocumentLineItem as SourceDocumentLineItemIInventory;

                                purchLineInventTransOrigin = InventTransOrigin::findByInventTransId(sourceDocumentLineItemIInventory.parmLotId());
                                projectInventTransOrigin = InventTransOrigin::find(InventTransOrigin::findMarkingRefInventTransOrigin(purchLineInventTransOrigin.RecId, sourceDocumentLineItemIProduct.parmItemId(), true));

                                while select projItemTrans
                                 where projItemTrans.InventTransId == projectInventTransOrigin.InventTransId &&
                                      projItemTrans.VoucherPackingSlip == vendInvoiceJour.CostLedgerVoucher
                                {
                                    if (projItemTrans)
                                    {
                                        if (ProjTable::find(projItemTrans.ProjId).UseBudgeting)
                                        {
                                            AmountCur costAmount = projItemTrans.TotalCostAmountCur;

                                            if (projItemTrans.CurrencyId != vendInvoiceInfoLine.CurrencyCode)
                                            {
                                                CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), sourceDocumentLineItem.parmAccountingDate());
                                                if (_vendInvoiceInfoTable.FixedExchRate)
                                                {
                                                    currencyExchangeHelper.parmExchangeRate1(_vendInvoiceInfoTable.ExchRate);
                                                }
                                                costAmount = currencyExchangeHelper.calculateAccountingToTransaction(vendInvoiceInfoLine.CurrencyCode, projItemTrans.TotalCostAmountCur, true);
                                            }

                                            sourceDocumentLineItemIProject = sourceDocumentLineItem as SourceDocumentLineItemIProject;
                                            projBudgetTransactionLine = ProjBudgetTransactionLine_Virtual::construct(
                                                                    ProjectSourceDocumentLineItemHelper::projTransType(sourceDocumentLineItem),
                                                                    sourceDocumentLineItem.parmAccountingDate(),
                                                                    projItemTrans.ProjTransId,
                                                                    projItemTrans.ProjId,
                                                                    projItemTrans.CategoryId,
                                                                    projItemTrans.Qty,
                                                                    vendInvoiceInfoLine.CurrencyCode,
                                                                    costAmount,
                                                                    projItemTrans.CurrencyId,
                                                                    projItemTrans.TotalSalesAmountCur,
                                                                    sourceDocumentLineItem.parmSourceDocumentLine().RecId,
                                                                    projItemTrans.ActivityNumber,
                                                                    sourceDocumentLineItemIProject.parmProjectLineProperty());

                                            projBudgetTransaction = new ProjBudgetTransaction();
                                            projBudgetTransaction.addBudgetTransactionLine(projBudgetTransactionLine);

                                            projBudgetTransactionManager =  ProjBudgetTransactionManager::newProjBudgetTransactionManager(projBudgetTransaction);
                                            projBudgetTransactionManager.parmAllowOverBudget(false);
                                            if (!projBudgetTransactionManager.adjustBudget(ProjBudgetAdjustmentType::Decrement))
                                            {
                                                throw error("@Proj:BudgetError");
                                            }
                                        }
                                        else if (ProjectSourceDocumentLineItemHelper::projTransType(sourceDocumentLineItem) != ProjTransType::Revenue)
                                        {
                                            projTrans_Virtual = ProjTrans_Virtual::construct();
                                            projTrans_Virtual.setTransType(ProjectSourceDocumentLineItemHelper::projTransType(sourceDocumentLineItem));
                                            projTrans_Virtual.setProjId(projItemTrans.ProjId);
                                            projTrans_Virtual.setActivityNumber(projItemTrans.ActivityNumber);
                                            projTrans_Virtual.setCategoryId(projItemTrans.CategoryId);
                                            projTrans_Virtual.setItemId(projItemTrans.ItemId);
                                            projTrans_Virtual.setTransDate(sourceDocumentLineItem.parmAccountingDate());
                                            projTrans_Virtual.setLinePropertyId(projItemTrans.LinePropertyId);

                                            projForecastReduce = ProjForecastReduce::newProjPost(projTrans_Virtual, projItemTrans.Qty, projItemTrans.TotalCostAmountCur);
                                            projForecastReduce.parmProjTransId(projItemTrans.ProjTransId);

                                            projForecastReduce.run();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>subLedgerJournalAccountEntries</Name>
				<Source><![CDATA[
    private static Query subLedgerJournalAccountEntries(RefRecId _accountingDistribution)
    {
        Query                   query;
        QueryBuildDataSource    qbdsSubLedgerJournalAccountEntry;
        QueryBuildDataSource    qbdsSubLedgerJournalAccountEntryDistribution;
        QueryBuildRange         qbrAccountingDistribution;

        query = new Query();

        qbdsSubLedgerJournalAccountEntry = query.addDataSource(tableNum(SubledgerJournalAccountEntry));
        SubledgerJournalizerProjectExtension::addSubledgerJournalAccountEntriesPostingTypeRanges(qbdsSubLedgerJournalAccountEntry);

        qbdsSubLedgerJournalAccountEntryDistribution = qbdsSubLedgerJournalAccountEntry.addDataSource(tableNum(SubledgerJournalAccountEntryDistribution));
        qbdsSubLedgerJournalAccountEntryDistribution.joinMode(JoinMode::ExistsJoin);
        qbdsSubLedgerJournalAccountEntryDistribution.relations(false);
        qbdsSubLedgerJournalAccountEntryDistribution.addLink(fieldNum(SubledgerJournalAccountEntry, RecId), fieldNum(SubledgerJournalAccountEntryDistribution, SubledgerJournalAccountEntry));
        qbrAccountingDistribution = qbdsSubLedgerJournalAccountEntryDistribution.addRange(fieldNum(SubledgerJournalAccountEntryDistribution, AccountingDistribution));
        qbrAccountingDistribution.value(SysQuery::value(_accountingDistribution));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjectAccountingDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the project actual detail reference of the <c>ProjectAccountingDistribution</c> records.
    /// </summary>
    /// <param name="_projectActualDetail">
    /// A project actual detail record.
    /// </param>
    /// <param name="_packedActualReferenceProjectAccountingDistribution">
    /// A container with the list of <c>ProjectAccountingDistribution</c> records to update.
    /// </param>
    private static void updateProjectAccountingDistributions(Common _projectActualDetail, container _packedActualReferenceProjectAccountingDistribution)
    {
        List                            actualReferenceProjectAccountingDistribution;
        ListEnumerator                  actualReferenceProjectAccountingDistributionEnumerator;
        ProjectAccountingDistribution   projectAccountingDistribution;
        ProjItemTransCost               projItemTransCost;

        actualReferenceProjectAccountingDistribution = List::create(_packedActualReferenceProjectAccountingDistribution);
        actualReferenceProjectAccountingDistributionEnumerator = actualReferenceProjectAccountingDistribution.getEnumerator();
        while (actualReferenceProjectAccountingDistributionEnumerator.moveNext())
        {
            projectAccountingDistribution = ProjectAccountingDistribution::find(actualReferenceProjectAccountingDistributionEnumerator.current(), true);

            switch (_projectActualDetail.TableId)
            {
                case tableNum(ProjCostTransCost):
                    projectAccountingDistribution.ProjCostTransCost = _projectActualDetail.RecId;
                    break;

                case tableNum(ProjItemTransCost):
                    projItemTransCost = _projectActualDetail;
                    projectAccountingDistribution.ProjItemTransCost = projItemTransCost.RecId;
                    break;

                case tableNum(ProjCostTransSale):
                    projectAccountingDistribution.ProjCostTransSale = _projectActualDetail.RecId;
                    break;

                case tableNum(ProjItemTransSale):
                    projectAccountingDistribution.ProjItemTransSale = _projectActualDetail.RecId;
                    break;

                case tableNum(ProjRevenueTransSale):
                    projectAccountingDistribution.ProjRevenueTransSale = _projectActualDetail.RecId;
                    break;

                case tableNum(ProjEmplTransCost):
                    if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                || isConfigurationkeyEnabled(configurationKeyNum(Project))
                || isConfigurationkeyEnabled(configurationKeyNum(PayrollAdministration))
                )
                    {
                        projectAccountingDistribution.ProjEmplTransCost = _projectActualDetail.RecId;
                    }
                    else
                    {
                        throw error(strFmt("@SYS22828", funcName()));
                    }
                    break;

                case tableNum(ProjEmplTransSale):
                    // If this condition fails, the SYS logic needs to fall to default so this should be the last case before default
                    if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                || isConfigurationkeyEnabled(configurationKeyNum(Project))
                || isConfigurationkeyEnabled(configurationKeyNum(PayrollAdministration))
                    )
                    {
                        projectAccountingDistribution.ProjEmplTransSale = _projectActualDetail.RecId;
                        break;
                    }
                default:
                    throw error(strFmt("@SYS22828",funcName()));
            }

            projectAccountingDistribution.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjectAccountingDistributionsV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the project actual detail reference of the <c>ProjectAccountingDistribution</c> records for only return the lines are submitted.
    /// </summary>
    /// <param name="_projectActualDetail">
    /// A project actual detail record.
    /// </param>
    /// <param name="_packedActualReferenceProjectAccountingDistribution">
    /// A container with the list of <c>ProjectAccountingDistribution</c> records to update.
    /// </param>
    private void updateProjectAccountingDistributionsV2(Common _projectActualDetail, container _packedActualReferenceProjectAccountingDistribution)
    {
        List                            actualReferenceProjectAccountingDistribution;
        ListEnumerator                  actualReferenceProjectAccountingDistributionEnumerator;
        ProjectAccountingDistribution   projectAccountingDistribution;
        ProjItemTransCost               projItemTransCost;

        SubledgerJournalizer                    localSubledgerJournalizer = this.parmSubledgerJournalizer();
        SourceDocument                          sourceDocumentForJournalizing = localSubledgerJournalizer.parmSourceDocument();
        Map                                     sourceDocumentLineItems = sourceDocumentForJournalizing.parmSourceDocumentLinesForCurrentVoucher();
        MapEnumerator                           sourceDocumentLineItemsEnumerator = sourceDocumentLineItems.getEnumerator();
        SourceDocumentLineItem                  sourceDocumentLineItem;
        SourceDocumentLine                      sourceDocumentLine;

        while (sourceDocumentLineItemsEnumerator.moveNext())
        {
            sourceDocumentLine     = SourceDocumentLine::find(sourceDocumentLineItemsEnumerator.currentKey());

            actualReferenceProjectAccountingDistribution = List::create(_packedActualReferenceProjectAccountingDistribution);
            actualReferenceProjectAccountingDistributionEnumerator = actualReferenceProjectAccountingDistribution.getEnumerator();
            while (actualReferenceProjectAccountingDistributionEnumerator.moveNext())
            {
                projectAccountingDistribution = ProjectAccountingDistribution::find(actualReferenceProjectAccountingDistributionEnumerator.current());

                if (AccountingDistribution::find(projectAccountingDistribution.AccountingDistribution).SourceDocumentLine != sourceDocumentLine.RecId)
                {
                    continue;
                }

                switch (_projectActualDetail.TableId)
                {
                    case tableNum(ProjCostTransCost):
                        projectAccountingDistribution.ProjCostTransCost = _projectActualDetail.RecId;
                        break;

                    case tableNum(ProjItemTransCost):
                        projItemTransCost = _projectActualDetail;
                        projectAccountingDistribution.ProjItemTransCost = projItemTransCost.RecId;
                        break;

                    case tableNum(ProjCostTransSale):
                        projectAccountingDistribution.ProjCostTransSale = _projectActualDetail.RecId;
                        break;

                    case tableNum(ProjItemTransSale):
                        projectAccountingDistribution.ProjItemTransSale = _projectActualDetail.RecId;
                        break;

                    case tableNum(ProjRevenueTransSale):
                        projectAccountingDistribution.ProjRevenueTransSale = _projectActualDetail.RecId;
                        break;

                    case tableNum(ProjEmplTransCost):
                        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                    || isConfigurationkeyEnabled(configurationKeyNum(Project))
                    || isConfigurationkeyEnabled(configurationKeyNum(PayrollAdministration))
                    )
                        {
                            projectAccountingDistribution.ProjEmplTransCost = _projectActualDetail.RecId;
                        }
                        else
                        {
                            throw error(strFmt("@SYS22828", funcName()));
                        }
                        break;

                    case tableNum(ProjEmplTransSale):
                        // If this condition fails, the SYS logic needs to fall to default so this should be the last case before default
                        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                    || isConfigurationkeyEnabled(configurationKeyNum(Project))
                    || isConfigurationkeyEnabled(configurationKeyNum(PayrollAdministration))
                        )
                        {
                            projectAccountingDistribution.ProjEmplTransSale = _projectActualDetail.RecId;
                            break;
                        }
                    default:
                        throw error(strFmt("@SYS22828",funcName()));
                }
                projectAccountingDistribution.selectForUpdate(true);
                projectAccountingDistribution.doUpdate();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjectBudget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the reservation of project budgets for the project actual if project budgeting is enabled.
    /// </summary>
    /// <param name="_transId">
    /// The transaction ID of the project actual header record.
    /// </param>
    /// <param name="_projectActualHeaderContainer">
    /// A container that contains the project actual header values.
    /// </param>
    private static void updateProjectBudget(ProjTransIdBase _transId, container _projectActualHeaderContainer)
    {
        #declareProjectActualHeaderContainerVariablesMacro

        ProjBudgetTransactionManager            projBudgetTransactionManager;
        ProjBudgetTransaction                   projBudgetTransaction;
        ProjBudgetTransactionLine               projBudgetTransactionLine;

        ProjForecastReduce                      projForecastReduce;
        ProjTrans_Virtual                       projTrans_Virtual;

        SourceDocumentLineItem                  sourceDocumentLineItem;
        SourceDocumentLineItemIProject          sourceDocumentLineItemIProject;
        SourceDocumentLineItemIProduct          sourceDocumentLineItemIProduct;

        #projectActualHeaderContainerMacro = _projectActualHeaderContainer;
        sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(actualSourceDocumentLine));
        sourceDocumentLineItemIProject = sourceDocumentLineItem as SourceDocumentLineItemIProject;
        if (sourceDocumentLineItem is SourceDocumentLineItemIProduct)
        {
            sourceDocumentLineItemIProduct = sourceDocumentLineItem as SourceDocumentLineItemIProduct;
        }
        //Incrementing the counting for each actual getting processed
        projBudgetTransactionLinesCount++;

        if (ProjTable::find(actualProjectId).UseBudgeting)
        {
            projBudgetTransactionLine = ProjBudgetTransactionLine_Virtual::construct(
                                        ProjectSourceDocumentLineItemHelper::projTransType(sourceDocumentLineItem),
                                        sourceDocumentLineItem.parmAccountingDate(),
                                        _transId,
                                        actualProjectId,
                                        actualCategoryId,
                                        actualQuantity,
                                        actualTransactionCostCurrency,
                                        actualTransactionCurrencyCostAmount,
                                        actualTransactionSalesCurrency,
                                        actualTransactionCurrencySalesAmount,
                                        sourceDocumentLineItem.parmSourceDocumentLine().RecId,
                                        actualActivityNumber,
                                        sourceDocumentLineItemIProject.parmProjectLineProperty());
            
            if (ProjUpdateBudgetSortedSourceDocumentLinesFlight::instance().isEnabled())
            {
                //List Storing projBudgetTransactionLines when there are multiple lines with same Cost Amount
                List projBudgetTransactionLinesList = new List(Types::Class);
                
                //If there is already an entry for specific cost amount in Map
                //Get the list corresponding to that Cost Amount
                if (projBudgetTransactionLineMap.exists(projBudgetTransactionLine.costAmount()))
                {
                    projBudgetTransactionLinesList = projBudgetTransactionLineMap.lookup(projBudgetTransactionLine.costAmount());
                }

                //If list is not empty we will append new ProjBudgetTransactionLine
                //In other case list will just have one element that is new ProjBudgetTransactionLine
                projBudgetTransactionLinesList.addEnd(projBudgetTransactionLine);
                

                //Insert in map <Cost Amount, List of ProjBudgetTransactionLines>
                //If we already have entry for specific Cost Amount, value will be overriden
                projBudgetTransactionLineMap.insert(projBudgetTransactionLine.costAmount(), projBudgetTransactionLinesList);
            }
            else
            {
                projBudgetTransaction = new ProjBudgetTransaction();
                projBudgetTransaction.addBudgetTransactionLine(projBudgetTransactionLine);

                projBudgetTransactionManager = ProjBudgetTransactionManager::newProjBudgetTransactionManager(projBudgetTransaction);
                projBudgetTransactionManager.parmAllowOverBudget(false);
                if (!projBudgetTransactionManager.adjustBudget(ProjBudgetAdjustmentType::Decrement))
                {
                    throw error(strFmt("@Proj:BudgetNotApproved", actualProjectId));
                }
            }
        }
        else if (ProjectSourceDocumentLineItemHelper::projTransType(sourceDocumentLineItem) != ProjTransType::Revenue)
        {
            projTrans_Virtual = ProjTrans_Virtual::construct();
            projTrans_Virtual.setTransType(ProjectSourceDocumentLineItemHelper::projTransType(sourceDocumentLineItem));
            projTrans_Virtual.setProjId(actualProjectId);
            projTrans_Virtual.setActivityNumber(actualActivityNumber);
            projTrans_Virtual.setCategoryId(actualCategoryId);
            if (sourceDocumentLineItemIProduct)
            {
                projTrans_Virtual.setItemId(sourceDocumentLineItemIProduct.parmItemId());
            }
            projTrans_Virtual.setResource(sourceDocumentLineItemIProject.parmProjectResourceRecId());
            projTrans_Virtual.setResourceCategory(sourceDocumentLineItemIProject.parmProjectResourceCategoryRecId());
            projTrans_Virtual.setTransDate(sourceDocumentLineItem.parmAccountingDate());
            projTrans_Virtual.setLinePropertyId(actualLinePropertyId);

            projForecastReduce = ProjForecastReduce::newProjPost(projTrans_Virtual, actualQuantity, actualTransactionCurrencyCostAmount);
            projForecastReduce.parmProjTransId(_transId);

            projForecastReduce.run();
        }

        //If we have reached end of line and sorted source document lines are enabled(map has data to be processed)
        if (actualHeaderLines == projBudgetTransactionLinesCount && !projBudgetTransactionLineMap.empty())
        {   
            SubledgerJournalizerProjectExtension::updateProjectBudgetWithSortedSourceDocumentLines(_projectActualHeaderContainer);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjectBudgetWithSortedSourceDocumentLines</Name>
				<Source><![CDATA[
    private static void updateProjectBudgetWithSortedSourceDocumentLines(container _projectActualHeaderContainer)
    {   
        #declareProjectActualHeaderContainerVariablesMacro

        ProjBudgetTransactionManager            projBudgetTransactionManager;
        ProjBudgetTransaction                   projBudgetTransaction;

        #projectActualHeaderContainerMacro = _projectActualHeaderContainer;
        List projBudgetTransactionLinesList = new List(Types::Class);
        //When we use an enumerator to traverse the map, the elements are in a sorted order
        MapEnumerator projBudgetTransactionLineEnumerator = projBudgetTransactionLineMap.getEnumerator();
        projBudgetTransaction = new ProjBudgetTransaction();

        while (projBudgetTransactionLineEnumerator.moveNext())
        {
            //List will have multiple entries when we have multiple ProjBudgetTransactionLines with same Cost Amount
            projBudgetTransactionLinesList = projBudgetTransactionLineEnumerator.currentValue();
            ListEnumerator listEnumerator = projBudgetTransactionLinesList.getEnumerator();
            while (listEnumerator.moveNext())
            {
                projBudgetTransaction.addBudgetTransactionLine(listEnumerator.current());
            }
        }

        projBudgetTransactionManager = ProjBudgetTransactionManager::newProjBudgetTransactionManager(projBudgetTransaction);
        projBudgetTransactionManager.parmAllowOverBudget(false);
        if (!projBudgetTransactionManager.adjustBudget(ProjBudgetAdjustmentType::Decrement))
        {
            throw error(strFmt("@Proj:BudgetNotApproved", actualProjectId));
        }

        actualHeaderLines = 0;
        projBudgetTransactionLinesCount = 0;
        projBudgetTransactionLineMap = new Map(Types::Real, Types::AnyType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSourceDocLineItemFromHeaderContainer</Name>
				<Source><![CDATA[
    private static SourceDocumentLineItem getSourceDocLineItemFromHeaderContainer(container _actualHeaderContainer)
    {
        #declareProjectActualHeaderContainerVariablesMacro
        SourceDocumentLine  sourceDocumentLine;

        #projectActualHeaderContainerMacro = _actualHeaderContainer;

        sourceDocumentLine = SourceDocumentLine::find(actualSourceDocumentLine);
        return SourceDocumentLineItem::newFromSourceDocumentLine(sourceDocumentLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldProcessAccountingDistribution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether the accounting distribution should be processed.
    /// </summary>
    /// <param name = "_accountingDistribution"><c>AccountingDistribution</c> table buffer.</param>
    /// <returns>true if this accounting distribution should be processed; otherwise, false.</returns>
    private static boolean shouldProcessAccountingDistribution(AccountingDistribution _accountingDistribution)
    {
        boolean process = true;

        if (ProjVendorInvoiceRetentionCalcFeatureHelper::isTransitionFlightEnabled())
        {
            if (_accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverableVariance)
            {
                AccountingDistribution parentAccountingDistribution = AccountingDistribution::find(_accountingDistribution.ParentDistribution);
                if (parentAccountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable)
                {
                    AccountingDistribution grandParentAccountingDistribution = AccountingDistribution::find(parentAccountingDistribution.ParentDistribution);
                    SourceDocumentLineItem grandParentSourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(grandParentAccountingDistribution.SourceDocumentLine));

                    if (grandParentSourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem
                        && (!FeatureStateProvider::isFeatureEnabled(ProjEnableStreamlineCostAndSalesPriceCalcFeature::instance())
                            || SubledgerJournalizerProjectExtension::isVendorRetentionRetaining(grandParentSourceDocumentLineItem))
                        && ProjVendorInvoiceRetentionCalcFeatureHelper::shouldProcessWithFeatureEnabledBySouceDocumentLineItem(
                            ProjVendorInvoiceRetentionCalcFeatureHelper::isFeatureEnabled(),
                            grandParentSourceDocumentLineItem))
                    {
                        process = false;
                    }
                }
            }
        }

        return process;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVendorRetentionRetaining</Name>
				<Source><![CDATA[
    private static boolean isVendorRetentionRetaining(VendorInvoiceLineSourceDocLineItem _vendorInvoiceLineSourceDocLineItem)
    {
        boolean isVendorRetentionRetaining;

        VendInvoiceInfoLine vendInvInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(_vendorInvoiceLineSourceDocLineItem.parmSourceDocumentLine().RecId);
        if (vendInvInfoLine)
        {
            isVendorRetentionRetaining = vendInvInfoLine.PSARetainageAmount ? true : false;
        }

        return isVendorRetentionRetaining;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldProcessLedgerUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether the ledger update should be processed.
    /// If the posting type is purch retain, then it should only be processed if the retain amount should be released.
    /// </summary>
    /// <param name = "_subLedgerJournalAccountEntryRecId"><c>SubLedgerJournalAccountEntry</c> record identifier.</param>
    /// <returns>true if this ledger update should be processed; otherwise, false.</returns>
    private static boolean shouldProcessLedgerUpdate(RecId _subLedgerJournalAccountEntryRecId)
    {
        boolean process = true;

        SubLedgerJournalAccountEntry subledgerJournalAccountEntry;
        SubledgerJournalAccountEntryDistribution subledgerJournalAccountEntryDistribution;
            
        select firstonly PostingType from subledgerJournalAccountEntry
                where subledgerJournalAccountEntry.RecId == _subLedgerJournalAccountEntryRecId
            join AccountingDistribution from subledgerJournalAccountEntryDistribution
                where subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry == subledgerJournalAccountEntry.RecId;
                    
        if (subledgerJournalAccountEntry.PostingType == LedgerPostingType::PSAProjPurchRetain)
        {
            // If this is PSAProjPurchRetain posting type, then it will only be valid if it the retain amount should be release.
            process = SubledgerJournalizerProjectExtension::isVendorInvoiceLineItemAndIsRetentionReleaseVendInvoice(subledgerJournalAccountEntryDistribution.AccountingDistribution);
        }

        return process;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVendorInvoiceLineItemAndIsRetentionReleaseVendInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if the vendor invoice line item is payment retention invoice and if retained amount is being released.
    /// </summary>
    /// <param name = "_accountingDistributionRecId"><c>AccountingDistribution</c> record identifier.</param>
    /// <returns>true if the vendor invoice line item reatined amount is being released; otherwise, false.</returns>
    private static boolean isVendorInvoiceLineItemAndIsRetentionReleaseVendInvoice(RefRecId _accountingDistributionRecId)
    {
        AccountingDistribution accountingDistribution = AccountingDistribution::find(_accountingDistributionRecId);
        sourceDocumentLineItem sourceDocumentLineItem = ProjectSourceDocumentLineItemHelper::sourceDocumentLineItemTopParent(accountingDistribution.SourceDocumentLine);
        return (sourceDocumentLineItem is VendorInvoiceLineSourceDocLineItem) &&
            VendInvoiceInfoLine::isRetentionReleaseVendInvoice(sourceDocumentLineItem.parmSourceDocumentLine().RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateActualsOnPosting</Name>
				<Source><![CDATA[
    private static void updateActualsOnPosting(Common _projectActualHeader, RefRecId _sourceDocLine)
    {
        if (ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
        {
            ProjTrans projTrans;

            switch (_projectActualHeader.TableId)
            {
                case tableNum(ProjEmplTrans):
                    ProjEmplTrans emplTrans = _projectActualHeader as ProjEmplTrans;
                    emplTrans.reread();
                    projTrans = ProjTrans::newProjEmplTrans(emplTrans);
                    break;
                case tableNum(ProjCostTrans):
                    ProjCostTrans costTrans = _projectActualHeader as ProjCostTrans;
                    costTrans.reread();
                    projTrans = ProjTrans::newProjCostTrans(costTrans);
                    break;
                case tableNum(ProjItemTrans):
                    ProjItemTrans itemTrans = _projectActualHeader as ProjItemTrans;
                    itemTrans.reread();
                    projTrans = ProjTrans::newProjItemTrans(itemTrans);
                    break;
                case tableNum(ProjRevenueTrans):
                    ProjRevenueTrans feeTrans = _projectActualHeader as ProjRevenueTrans;
                    feeTrans.reread();
                    projTrans = ProjTrans::newProjRevenueTrans(feeTrans);
                    break;
                default:
                    throw error(strFmt("@SYS22828",funcName()));
            }
            
            ProjAdvancedJournalLine jourLine = ProjAdvancedJournalLine::findBySourceDocumentLine(_sourceDocLine);
            ProjCDSActualsImport importActual = ProjCDSActualsImport::findByAdvancedJournalLine(jourLine.RecId);
            
            ProjActualsInvoicePostingUpdateParameters projActualsInvoicePostingUpdateParameters = ProjActualsInvoicePostingUpdateParameters::construct();
            projActualsInvoicePostingUpdateParameters.voucher = projTrans.voucherOriginal();
            projActualsInvoicePostingUpdateParameters.exchRate = projTrans.exchRateSales();
            projActualsInvoicePostingUpdateParameters.taxAmount = jourLine.taxAmount();
            
            if (importActual.TransType == ProjCDSTransType::Cost)
            {
                projActualsInvoicePostingUpdateParameters.accountingAmount = projTrans.transCost();
                projActualsInvoicePostingUpdateParameters.exchRate = jourLine.CostExchangeRate;
            }
            else if (importActual.TransType == ProjCDSTransType::Sales)
            {
                projActualsInvoicePostingUpdateParameters.accountingAmount = projTrans.transTurnover();
                projActualsInvoicePostingUpdateParameters.exchRate = jourLine.PriceExchangeRate;
            }
            
            importActual.updateOnInvoicePosting(projActualsInvoicePostingUpdateParameters);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultDimensionForAccountingDistribution</Name>
				<Source><![CDATA[
    private static DimensionDefault getDefaultDimensionForAccountingDistribution(boolean _projOpsEnabled, AccountingDistribution _accDist, SourceDocumentLineItem _sourceDocLineItem)
    {
        DimensionDefault defaultDimension;
        if (_projOpsEnabled && _sourceDocLineItem is ProjAdvancedJournalSourceDocumentLineItem)
        {
            ProjAdvancedJournalLine advJourLine = ProjAdvancedJournalLine::findBySourceDocumentLine(_accDist.SourceDocumentLine);
            if (advJourLine)
            {
                defaultDimension = advJourLine.DefaultDimension;
            }
        }
        
        if (!defaultDimension)
        {
            defaultDimension = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_accDist.LedgerDimension);
        }

        return defaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldProcessTaxInActualLedgerUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether the subledger posting type is purchase expenditure or sales tax to process the actual ledger update.
    /// </summary>
    /// <param name="_subledgerJournalAccountEntry">
    /// <c>SubledgerJournalAccountEntry</c> being processed.
    /// </param>
    /// <param name="_actualLedgerUpdatePostingType">
    /// The actual ledger posting type to check posting type as project cost.
    /// </param>
    /// <returns>
    /// true if the subledger posting type is purchase expenditure or sales tax; otherwise, false.
    /// </returns>
    protected static boolean shouldProcessTaxInActualLedgerUpdate(SubledgerJournalAccountEntry _subledgerJournalAccountEntry, LedgerPostingType _actualLedgerUpdatePostingType)
    {
        boolean isProcessTaxInLedgerUpdate = _subledgerJournalAccountEntry.PostingType == LedgerPostingType::PurchConsump
            && FeatureStateProvider::isFeatureEnabled(ProjEnableStreamlineCostAndSalesPriceCalcFeature::instance())
            && !ProjAllowPurchConsumpWhenNonDeductibleAndUseTaxFlightVendInvoice::instance().isEnabled();

        return isProcessTaxInLedgerUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjLineProperty</Name>
				<Source><![CDATA[
    private static ProjLineProperty getProjLineProperty(SubledgerJournalAccountEntry _subledgerJournalAccountEntry)
    {
        SubledgerJournalAccountEntryDistribution subledgerJournalAccountEntryDistribution;
        select firstonly sourceDocumentLine from subledgerJournalAccountEntryDistribution
            where subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry == _subledgerJournalAccountEntry.RecId;
        SourceDocumentLineItem sourceDocumentLineItem = ProjectSourceDocumentLineItemHelper::sourceDocumentLineItemTopParent(subledgerJournalAccountEntryDistribution.SourceDocumentLine);
        return ProjectSourceDocumentLineItemHelper::projLineProperty(sourceDocumentLineItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUseAccountingEventTmp</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public static boolean canUseAccountingEventTmp(EnumName _enumName)
    {
        boolean isValidDocType = false;

        switch(enumName2Id(_enumName))
        {
            case enumNum(SourceDocument_ProjAdvancedJournal):
            case enumNum(SourceDocument_ProjectTimesheets):
                isValidDocType = true;
                break;
        }
        
        return isValidDocType;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>