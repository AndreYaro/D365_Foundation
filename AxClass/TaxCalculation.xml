<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxCalculation</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>TaxCalculation</c> class is the tax calculation class.
/// </summary>
public class TaxCalculation extends Tax
{
    boolean useTaxUncommitted;
    boolean loadTaxUncommitted;
    boolean loadTaxTrans;
    boolean taxObligationWarningOccured;
    boolean checkTaxCalculationCurrencyLockNeeded;
    boolean lockAcquired;

    TaxableDocument taxableDocument;

    // As this class walks through all lines this variable hold the current
    // line being calculated.  This will not be valid if called outside of
    // the calculation loop found in calculateTax().
    TaxableLine taxableLineCurrentlyBeingCalculated;

    // Source Company
    SelectableDataArea  taxObligationSourceCompany;

    // <GIN>
    #ISOCountryRegionCodes
    // </GIN>
    // <GEERU>
    boolean useHeadingRecIdAsSourceRecId_RU;
    // </GEERU>

    #define.CurrentVersion(1)
    #localmacro.CurrentList
        useTaxUncommitted,
        loadTaxUncommitted
    #endmacro

    Microsoft.Dynamics.Tax.Instrumentation.ProcessCounters processCounters;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>newForSourceTypeDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for creating a new instance of <c>Tax</c> for <c>TaxSourceType</c>.
    /// </summary>
    /// <param name="_sourceType">
    ///    The type of the transaction to calculate taxes.
    /// </param>
    /// <param name="_initializationClass">
    ///    The initialization class for the given transaction.
    /// </param>
    /// <param name = "_result">An <c>EventHandlerResult</c> instance, where subscribers can provide the creation result.</param>
    static delegate void newForSourceTypeDelegate(TaxSourceType _taxSourceType, Object _initializationClass, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForSourceTypeWithTaxUncommittedDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for creating a new instance of <c>Tax</c> for <c>TaxSourceType</c>. This constructor causes
    ///    tax to use the <c>TaxUncommitted</c> table to load and persist taxes.
    /// </summary>
    /// <param name="_sourceType">
    ///    The type of the transaction to calculate taxes.
    /// </param>
    /// <param name="_initializationClass">
    ///    The initialization class for the given transaction. This is a different class for each transaction.
    /// </param>
    /// <param name="_loadTaxUncommitted">
    ///    A Boolean value that specifies whether during the construction to load the <c>TaxUncommitted</c>
    ///    records into taxes <c>TmpTaxWorkTrans</c> buffer which enables most of the inquiry functions to
    ///    work.
    /// </param>
    /// <param name="_loadTaxTrans">
    ///    A Boolean value that specifies whether during the construction to load the <c>TaxTrans</c>
    ///    records into taxes <c>TmpTaxWorkTrans</c> buffer which enables most of the inquiry functions to
    ///    work.
    /// </param>
    /// <param name="_maintainExistingTaxUncommitted">
    ///    A Boolean value which indicates that Tax should merge the newly calculated taxes with
    ///    existing records in TaxUncommitted.
    /// </param>
    /// <param name = "_result">An <c>EventHandlerResult</c> instance, where subscribers can provide the creation result.</param>
    static delegate void newForSourceTypeWithTaxUncommittedDelegate(
        TaxSourceType _taxSourceType, 
        Object _initializationClass, 
        boolean _loadTaxUncommitted, 
        boolean _loadTaxTrans, 
        boolean _maintainExistingTaxUncommitted, 
        EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>ajustQuantityForAdjustingInvoice_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ajusts the quantity for Adjusting Invoice.
    /// </summary>
    /// <param name="_quantity">
    /// Original quantity.
    /// </param>
    /// <returns>
    /// Actual quantity.
    /// </returns>
    private Qty ajustQuantityForAdjustingInvoice_IN(Qty _quantity)
    {
        CustInvoiceTable    custInvoiceTableLoc;
        CustRelatedInvoice  custRelatedInvoiceLoc;
        TaxTable            taxTableLoc;
        Qty                 resultQuantity = _quantity;

        if (this.headingTableId() == tableNum(CustInvoiceTable))
        {
            select firstonly RecId from custInvoiceTableLoc
                where custInvoiceTableLoc.RecId == this.headingRecId()
                join firstonly RecId from custRelatedInvoiceLoc
                    where custRelatedInvoiceLoc.CustInvoice            == custInvoiceTableLoc.RecId
                       && custRelatedInvoiceLoc.InvoiceAssociationType == InvoiceAssociationType::AdjustingInvoice;

            if (custRelatedInvoiceLoc.RecId)
            {
                select taxWorkTrans
                    join RecId from taxTableLoc
                    where taxTableLoc.TaxCode == taxWorkTrans.TaxCode
                       && taxTableLoc.TaxBase == TaxBaseType::AmountByUnit;
                if (taxTableLoc.RecId)
                {
                    resultQuantity = - _quantity;
                }
            }
        }

        return resultQuantity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateLineSpecificTaxCodes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the taxes for an individual line. This function does not calculate codes that are
    /// considered based on invoice total, tax on tax, and others It calculates only tax codes that are
    /// line specific.
    /// </summary>
    /// <returns>
    /// The tax amount calculated for this line for all codes which are not based on invoice total.
    /// </returns>
    protected TaxAmount calculateLineSpecificTaxCodes()
    {
        TaxAmount           taxAmount;

        if (taxCalculateLine)
        {
            taxAmount += this.calcTax();
            this.saveInProcessTransaction();

            if  (!taxCalculateTotal &&
                (exchRate           != ExchangeRateHelper::exchRate(sourceCurrencyCode, taxDate)          ||
                exchRateSecond      != ExchangeRateHelper::exchRateSecond(sourceCurrencyCode, taxDate)    ||
                triangulation       != Currency::triangulation(sourceCurrencyCode, taxDate)))
            {
                this.adjustAmount(exchRate,exchRateSecond);
            }
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates taxes total taxes excluding use taxes. This is the base calculate taxes method derived
    ///    classes are required to implement.
    /// </summary>
    /// <returns>
    ///    The tax amount excluding the use tax.
    /// </returns>
    public TaxAmountCur calculateTax()
    {
        TaxAmount               taxAmount;
        boolean                 linesExist = true;
        boolean                 success = true;

        Debug::assert(taxableDocument != null);

        if (!taxableDocument.getSourceHeader().RecId)
        {
            return 0;
        }

        if (this.skipTaxCalculations())
        {
            return 0;
        }

        if (!taxableDocument.getFirstLine())
        {
            return 0;
        }

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            return 0;
        }

        Microsoft.Dynamics.Ax.Xpp.ErrorException errorEx;
        Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource taxEventSourceLog = Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource::Log;
        System.Diagnostics.Stopwatch stopWatch;
        guid identifier;
        ReqReaderWriterLock lock = ReqReaderWriterLock::construct();
        str lockName = this.lockName();

        try
        {
            stopWatch = new System.Diagnostics.Stopwatch();
            identifier = newGuid();
            
            if (TaxCalculationInstrumentationToggle::instance().isEnabled())
            {
                taxEventSourceLog.CalculateTaxStart(identifier, TaxUncommitted::callStackInfo());
            }
            else
            {
                taxEventSourceLog.CalculateTaxStart(identifier);
            }

            stopWatch.Start();

            this.enterTaxableDocumentLock(lock, lockName);

            this.initializeCalculation();

            taxableLineCurrentlyBeingCalculated = taxableDocument.getCurrentLine();

            while (linesExist)
            {
                this.calculateTaxForLine();

                linesExist = taxableDocument.getNextLine();
                taxableLineCurrentlyBeingCalculated = taxableDocument.getCurrentLine();
            }

            taxableLineCurrentlyBeingCalculated = null;
            // <GIN>
            if (isIndiaCountryRegionEnabled)
            {
                //India has only PerLine Tax calculation. So should avoid 'Total' scenario.
                taxAmount = this.finalizeCalculation();
            }
            else
            {
                // </GIN>
                taxAmount = this.calculateTotalTaxCodes();

                taxAmount = this.finalizeCalculation();
                // <GIN>
            }
            // </GIN>
        }
        catch (errorEx) // errorEx is the same as Exception::Error
        {
            success = false;
			taxEventSourceLog.TaxProcessError(guid2Str(newGuid()),
											  errorEx.Message,
											  errorEx.StackTrace,
											  methodStr(TaxCalculation, calculateTax));
            throw Exception::Error;
        }
        finally
        {
            this.exitTaxableDocumentLock(lock, lockName);
            stopWatch.Stop();
            select count(RecId) from taxWorkTrans;
            taxEventSourceLog.CalculateTaxStop(identifier,
                                               SysCountryRegionCode::countryInfo(),
                                               tableId2Name(taxableDocument.getSourceHeader().TableId),
                                               TaxTelemetryConstants::salesTax,
                                               stopWatch.ElapsedMilliseconds,
                                               taxableDocumentLines,
                                               markupTransTaxableDocumentLines,
                                               taxWorkTrans.RecId,
                                               taxableDocument.getTaxIncluded(),
                                               taxableDocument.getSourceHeader().TableId,
                                               tableId2Name(taxableDocument.getSourceHeader().TableId),
                                               taxableDocument.getSourceHeader().RecId,
                                               success);
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lockName</Name>
				<Source><![CDATA[
    protected str lockName()
    {
        str lockName = strFmt("@TaxCalculationConcurrencyCheck:HeadingLockName",
            this.headingTableId(),
            this.headingRecId());

        return lockName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxableDocumentLockNeeded</Name>
				<Source><![CDATA[
    [Replaceable]
    protected boolean checkTaxableDocumentLockNeeded()
    {
        boolean ret = false;
        if (TaxCalculationConCurrencyCheckDefaultOnToggle::isEnabled()
            && this.useTaxUncommitted()
            && (this is TaxCalculationJournal
                || this is TaxPurch
                || this is TaxFreeInvoice))
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>enterTaxableDocumentLock</Name>
				<Source><![CDATA[
    protected void enterTaxableDocumentLock(ReqReaderWriterLock _lock, str _lockName)
    {
        if (_lock && checkTaxCalculationCurrencyLockNeeded)
        {
            lockAcquired = _lock.tryEnterWriterLock(_lockName);

            // The current thread can't acquire the lock because other threads are calculating tax and holding
            // the lock, it needs to wait for other threads' competition; otherwise, hold the lock directly.
            if (!lockAcquired)
            {
                int maxRetryCount; // The max retry count of entering lock.
                int retryWaitTime; // The wait time (ms) during each retry.
                [maxRetryCount, retryWaitTime] = this.getRetryConfiguration();

                // If acquired lock, stop retry; otherwise, retry to acquire
                // lock until the threshold (MaxRetryCount * RetryWaitTime).
                int retryCount = 0;
                while (!lockAcquired && retryCount < maxRetryCount)
                {
                    lockAcquired = _lock.tryEnterWriterLock(_lockName);
                    if (!lockAcquired)
                    {
                        retryCount++;
                        sleep(retryWaitTime);
                    }
                }
            }

            if (!lockAcquired)
            {
                throw error("@TaxCalculationConcurrencyCheck:TaxCalculationConcurrencyErrorAndSuggestions");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>exitTaxableDocumentLock</Name>
				<Source><![CDATA[
    protected void exitTaxableDocumentLock(ReqReaderWriterLock _lock, str _lockName)
    {
        if (lockAcquired)
        {
            _lock.exit(_lockName);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRetryConfiguration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the max retry count of entering lock and the wait time (ms) during each retry.
    /// </summary>
    /// <returns>The container of the configuration.</returns>
    [Replaceable(true)]
    protected container getRetryConfiguration()
    {
        // The bigger transaction needs more retry count and wait time.
        int transactionLineCount = this.getTransactionLineCount();
        int maxRetryCount = 100 + transactionLineCount;
        int retryWaitTime = 100 + transactionLineCount;

        // If users setup the multiple on the debug mode, expand the max retry count.
        int multiple = this.taxParameters().getTaxCalculationRetryNumber();
        if (multiple > 1)
        {
            maxRetryCount = maxRetryCount * multiple;
        }

        return [maxRetryCount, retryWaitTime];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionLineCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the transaction line count.
    /// </summary>
    /// <returns>The transaction line count.</returns>
    protected int getTransactionLineCount()
    {
        int transactionLineCount = 0;

        if (taxableDocument && taxableDocument.getJournalizedDocument())
        {
            transactionLineCount = taxableDocument.getJournalizedDocument().NumOfLines();
        }

        return transactionLineCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTaxForLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates taxes for a transaction line.
    /// </summary>
    /// <returns>
    /// The tax amount excluding use tax for the transaction line.
    /// </returns>
    [HookableAttribute(true)]
    protected TaxAmount calculateTaxForLine()
    {
        TaxAmountCur            baseAmount;
        TaxableInventoriedLine  taxableInventoriedLine;
        TaxAmount               taxAmount;
        TaxBase                 baseAmountExcludingTax;

        processCounters.StartCalculating();

        Debug::assert(taxableLineCurrentlyBeingCalculated != null);

        // this needs to be done outside of the tax group check because there are errors
        // that could be thrown from inside here - even if 1 of the tax groups
        // isn't supplied
        this.configureTaxForLine(taxableLineCurrentlyBeingCalculated);

        if (!TaxSolutionScopeIntegrationUtil::isCompanyEnabled()
            && taxableLineCurrentlyBeingCalculated.getTaxGroup()
            && taxableLineCurrentlyBeingCalculated.getTaxItemGroup())
        {
            taxableInventoriedLine = taxableLineCurrentlyBeingCalculated.getTaxableInventoriedLine();

            if (taxableInventoriedLine)
            {
                if (taxableDocument.getTaxIncluded())
                {
                    baseAmountExcludingTax = this.amountExclTax(
                        taxableLineCurrentlyBeingCalculated.getTransactionAmount(),
                        false,
                        true,
                        taxableLineCurrentlyBeingCalculated.getQuantity(),
                        taxableInventoriedLine.getUnit(),
                        taxableInventoriedLine.getItemId(),
                        this.parmUseHeadingRecIdAsSourceRecId_RU() ? this.sourceRecId() : taxableLineCurrentlyBeingCalculated.getSourceLine().RecId,
                        this.parmUseHeadingRecIdAsSourceRecId_RU() ? this.sourceTableId() : taxableLineCurrentlyBeingCalculated.getSourceLine().TableId);
                }
                else
                {
                    baseAmountExcludingTax = taxableLineCurrentlyBeingCalculated.getTransactionAmount();
                }
                //<GIN>
                if (LedgerJournalTrans_IN_Extension::existsAdvancePaymentForServiceTax_IN(ledgerJournalTransLoc))
                {
                    baseAmountExcludingTax = ledgerJournalTransLoc.servicetaxBaseamountForAdvancePayment_IN();
                }
                // </GIN>

                baseAmount = this.initializeTaxForLine(taxableDocument.getTaxIncluded(),
                                    baseAmountExcludingTax,
                                    taxableLineCurrentlyBeingCalculated.getTransactionAmount(),
                                    taxableLineCurrentlyBeingCalculated.getDefaultDimension(),
                                    taxableLineCurrentlyBeingCalculated.getOperationLedgerDimension(this.getCompany()),
                                    taxableLineCurrentlyBeingCalculated.getPostingType(),
                                    taxableLineCurrentlyBeingCalculated.getUnitAmount(),
                                    taxableInventoriedLine.getItemId(),
                                    taxableLineCurrentlyBeingCalculated.getQuantity(),
                                    taxableInventoriedLine.getUnit());
            }
            else
            {
                if (taxableDocument.getTaxIncluded())
                {
                    baseAmountExcludingTax = this.amountExclTax(
                        taxableLineCurrentlyBeingCalculated.getTransactionAmount(),
                        false,
                        false,
                        taxableLineCurrentlyBeingCalculated.getQuantity(),
                        '',
                        '',
                        this.parmUseHeadingRecIdAsSourceRecId_RU() ? this.sourceRecId() : taxableLineCurrentlyBeingCalculated.getSourceLine().RecId,
                        this.parmUseHeadingRecIdAsSourceRecId_RU() ? this.sourceTableId() : taxableLineCurrentlyBeingCalculated.getSourceLine().TableId);
                }
                else
                {
                    baseAmountExcludingTax = taxableLineCurrentlyBeingCalculated.getTransactionAmount();
                }
                //<GIN>
                if (LedgerJournalTrans_IN_Extension::existsAdvancePaymentForServiceTax_IN(ledgerJournalTransLoc))
                {
                    baseAmountExcludingTax = ledgerJournalTransLoc.servicetaxBaseamountForAdvancePayment_IN();
                }
                // </GIN>

                baseAmount = this.initializeTaxForLine(taxableDocument.getTaxIncluded(),
                                    baseAmountExcludingTax,
                                    taxableLineCurrentlyBeingCalculated.getTransactionAmount(),
                                    taxableLineCurrentlyBeingCalculated.getDefaultDimension(),
                                    taxableLineCurrentlyBeingCalculated.getOperationLedgerDimension(this.getCompany()),
                                    taxableLineCurrentlyBeingCalculated.getPostingType(),
                                    taxableLineCurrentlyBeingCalculated.getUnitAmount(),
                                    '',
                                    taxableLineCurrentlyBeingCalculated.getQuantity(),
                                    '');
            }

            taxAmount = this.calculateLineSpecificTaxCodes();
            taxableDocumentLines++;
        }

        processCounters.StopCalculating();

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTotalTaxCodes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the taxes that are based on the invoice total.
    /// </summary>
    /// <returns>
    /// The total tax amount calculated to this point.
    /// </returns>
    /// <remarks>
    /// This method does not calculate codes that are considered line-specific.
    /// </remarks>
    protected TaxAmountCur calculateTotalTaxCodes()
    {
        TaxAmountCur taxAmount;

        if (! this.checkTaxCodesInTotal())
        {
            throw error("@SYS22772");
        }

        if (taxCalculateTotal)
        {
            this.insertTotalInInternal(cashDiscPercent);
            taxAmount = this.calcTax();
            this.saveTotalInProcessTransaction();
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCalcEximTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used for India EximTax check.
    /// </summary>
    /// <returns>
    /// False in the base class.
    /// </returns>
    /// <remarks>
    /// The real logic will be implemented in its subclass TaxPurch
    /// </remarks>
    protected boolean canCalcEximTax_IN()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>configureTaxForLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Configures the tax engine for a transaction line.
    /// </summary>
    /// <param name="_taxableLine">
    /// An instance of the <c>TaxableLine</c> interface that represents a transaction line.
    /// </param>
    protected void configureTaxForLine(TaxableLine _taxableLine)
    {
        CurrencyExchangeHelper currencyExchangeHelper;
        TaxableInventoriedLine taxableInventoriedLine;

        Debug::assert(taxableDocument != null);

        taxableInventoriedLine = _taxableLine.getTaxableInventoriedLine();

        currencyExchangeHelper = _taxableLine.getCurrencyExchangeInformation();

        taxDate = currencyExchangeHelper.parmExchangeDate();

        if (this.getCompany() == curext())
        {
            // set exchange rates on tax.
            this.setExchRates(_taxableLine.getTransactionCurrency(), currencyExchangeHelper.parmExchangeRate1(), currencyExchangeHelper.parmExchangeRate2());
        }
        else
        {
            // Exchange rates for current company aren't valid for intercompany tax lines.
            // Since tax supports only 1 set of exchange rates use the currently defined rates.
            this.setExchRates(_taxableLine.getTransactionCurrency(), exchRate, exchRateSecond);
        }

        if (taxableLineCurrentlyBeingCalculated is LedgerJournalTaxLine)
        {
            LedgerJournalTaxLine  ledgerJournalTaxLine = taxableLineCurrentlyBeingCalculated as LedgerJournalTaxLine;

            if (BrazilParameters::isEnabled())
            {
                useAndConsumption_BR    = ledgerJournalTaxLine.useAndConsumption_BR();
            }
        }

        voucher = taxableDocument.getReferenceNumber();

        if (!_taxableLine.getTaxCode())
        {
            if (taxableInventoriedLine)
            {
                //intersect the groups
                this.insertIntersection(_taxableLine.getTaxGroup(),
                                        _taxableLine.getTaxItemGroup(),
                                        taxableInventoriedLine.getInventTransId(),
                                        _taxableLine.getTransactionText(),
                                        _taxableLine.getTaxRateDate(this.getCompany()),
                                        taxableDocument.getInvoiceId());
            }
            else
            {
                //intersect the groups
                this.insertIntersection(_taxableLine.getTaxGroup(),
                                        _taxableLine.getTaxItemGroup(),
                                        '',
                                        _taxableLine.getTransactionText(),
                                        _taxableLine.getTaxRateDate(this.getCompany()),
                                        taxableDocument.getInvoiceId(),
                                        _taxableLine.getGSTHSTTaxType_CA());
            }

            if (!this.checkTaxCodesByLine())
            {
                processCounters.StopCalculatingOnError();
                throw error("@SYS18447");
            }

            if (!this.checkTaxCodesInTotal())
            {
                processCounters.StopCalculatingOnError();
                throw error("@SYS18447");
            }
        }

        this.setCashDiscount(_taxableLine.getCashDiscountPercent(), _taxableLine.getCashDiscountAmount());
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finalizes tax calculations by processing tax adjustments and optionally inserting records into the
    ///    <c>TaxUncommitted</c> and <c>SourceDoucmentLine</c> tables.
    /// </summary>
    /// <param name="_calculateTaxDifferenceAmount">
    ///    true if tax difference amount need to be calculated; optional.
    /// </param>
    /// <param name="_doIsolateTransactionScope">
    /// true if <c>TaxUncommitted</c> should be maintained in a independent transaction scope; otherwise false.
    /// </param>
    /// <returns>
    ///    The final tax total amount.
    /// </returns>
    protected TaxAmountCur finalizeCalculation(
        boolean _calculateTaxDifferenceAmount = false,
        boolean _doIsolateTransactionScope = false
    )
    {
        Counter                  counterMax;
        Counter                  counter;
        Currency                 sourceCurrency;
        RefRecId                 adjustRecId[];
        RefTableId               adjustedTableId[];
        TaxAmountCur             pennyDiff[];
        TaxAmountCur             taxAmount;
        TaxBaseCur               amountIncludingTax;
        TaxBaseCur               amountExcludingTax;

        if (!amountInclTaxMap.empty())
        {
            while select SourceTableId, SourceRecId, sum(SourceTaxAmountCur)
            from taxWorkTrans
            group by SourceTableId, SourceRecId, sourceCurrencyCode
            where taxWorkTrans.TaxDirection    != TaxDirection::UseTax   &&
                  taxWorkTrans.TaxOrigin       != TaxOrigin::TaxReversed &&
                  taxWorkTrans.TaxOrigin       != TaxOrigin::Transfer
            {
                sourceCurrency = Currency::find(taxWorkTrans.SourceCurrencyCode);
                amountIncludingTax = sourceCurrency.amount_Instance(amountInclTaxMap.lookup([taxWorkTrans.SourceTableId, taxWorkTrans.SourceRecId]));
                amountExcludingTax = sourceCurrency.amount_Instance(amountExclTaxMap.lookup([taxWorkTrans.SourceTableId, taxWorkTrans.SourceRecId]));

                amountInclTaxMap.insert([taxWorkTrans.SourceTableId, taxWorkTrans.SourceRecId], amountIncludingTax);
                amountExclTaxMap.insert([taxWorkTrans.SourceTableId, taxWorkTrans.SourceRecId], amountExcludingTax);

                if (amountIncludingTax &&
                    amountExcludingTax + taxWorkTrans.SourceTaxAmountCur != amountIncludingTax)
                {
                    counterMax++;
                    adjustRecId[counterMax] = taxWorkTrans.SourceRecId;
                    adjustedTableId[counterMax] = taxWorkTrans.SourceTableId;
                    pennyDiff[counterMax] = amountExcludingTax +
                                            taxWorkTrans.SourceTaxAmountCur -
                                            amountIncludingTax;
                }
            }
            if (counterMax)
            {
                for (counter = 1; counter <= counterMax; counter++)
                    this.adjustPennyDiff(pennyDiff[counter], adjustedTableId[counter], adjustRecId[counter]);
            }
        }

        if (taxCalculateTotal)
        {
            boolean exchRateUpdate;

            while select ExchRate, SourceCurrencyCode, TransDate from taxWorkTrans 
                where taxWorkTrans.HeadingRecId == headingRecId
                    && taxWorkTrans.HeadingTableId == headingTableId
            {
                exchRateUpdate = taxWorkTrans.ExchRate && taxWorkTrans.ExchRate != ExchangeRateHelper::exchRate(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.TransDate);
                if (exchRateUpdate)
                {
                    break;
                }
            }

            if ( exchRateUpdate ||
                exchRate != ExchangeRateHelper::exchRate(sourceCurrencyCode, taxDate) ||
                exchRateSecond != ExchangeRateHelper::exchRateSecond(sourceCurrencyCode, taxDate) ||
                triangulation != Currency::triangulation(sourceCurrencyCode, taxDate))
            {
                this.adjustAmount(exchRate,exchRateSecond);
            }

            this.adjustTaxInCostPrice(0);
        }

        // <GIN>
        if (isIndiaCountryRegionEnabled
            && this.canCalcEximTax_IN())
        {
            this.calcTaxExim_IN(this.purchCalcTax());
        }
        // </GIN>

        this.roundTaxOnTaxGroup();

        this.loadTaxAdjustments();

        // <GEEU>
        // The core tax module only supports the bank exchange rate feature for three countries: CZ, HU and PL.
        boolean isNeedCalculateTaxDiffAmount = headingTableId == tableNum(LedgerJournalTable) 
            && TaxSalesTaxExchangeRateSpecificLegalEntity_PLFlight::instance().isEnabled()
            && TaxParameters::isBankExchRateEnabled_W();

        if (_calculateTaxDifferenceAmount &&
            this.parmUseTaxExchangeRate() &&
            (this.parmAccountingCurrency() != this.getTransactionalCurrency() || isNeedCalculateTaxDiffAmount))
        {
            this.initTaxTransactionExchangeRate();

            this.calculateTaxDifferenceAmount();
        }
        // </GEEU>

        // <GEERU>
        if (   SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU])
            && this.processExemptTax_RU())
        {
            this.clearExemptTaxAmounts_RU();
        }
        // </GEERU>

        this.updateTaxUncommitted(_doIsolateTransactionScope);

        taxAmount = this.totalTaxAmount();

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeCalculationForTaxIntegration</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finalizes tax calculations by processing tax adjustments and optionally inserting records into the
    ///    <c>TaxUncommitted</c> and <c>SourceDoucmentLine</c> tables.
    /// </summary>
    /// <param name="_calculateTaxDifferenceAmount">
    ///    true if tax difference amount need to be calculated; otherwise, false.
    /// </param>
    /// <param name="_doIsolateTransactionScope">
    /// true if <c>TaxUncommitted</c> should be maintained in a independent transaction scope; otherwise, false.
    /// </param>
    /// <returns>
    ///    The final tax total amount.
    /// </returns>
    protected TaxAmountCur finalizeCalculationForTaxIntegration(
        boolean _calculateTaxDifferenceAmount = false,
        boolean _doIsolateTransactionScope = false
    )
    {
        TaxAmountCur taxAmount;

        this.loadTaxAdjustments();

        boolean isNeedCalculateTaxDiffAmount = TaxIntegrationBankOrTaxSpecificExchangeRateIntercompanyFlight::instance().isEnabled()
            && headingTableId == tableNum(LedgerJournalTable);

        // For GEEU sepicific logic
        if (_calculateTaxDifferenceAmount
            && this.parmUseTaxExchangeRate()
            && (this.parmAccountingCurrency() != this.getTransactionalCurrency()
                || TaxSpecificExchangeRateHelper::isTaxSpecificExchRateEnabledByTable(this.headingTableId(), this.headingRecId())
                || isNeedCalculateTaxDiffAmount))
        {
            this.initTaxTransactionExchangeRate();

            this.calculateTaxDifferenceAmount();
        }

        this.updateTaxUncommitted(_doIsolateTransactionScope);

        taxAmount = this.totalTaxAmount();

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompany</Name>
				<Source><![CDATA[
    public SelectableDataArea getCompany()
    {
        TaxObligationCompany taxObligationCompany;

        SelectableDataArea getDestination()
        {
            if (taxableLineCurrentlyBeingCalculated)
            {
                return taxableLineCurrentlyBeingCalculated.getDestinationCompany();
            }
            else
            {
                return curext();
            }
        }

        // source document must implement taxable interfaces to activate intercompany functionality.
        if (!taxableDocument)
        {
            return curext();
        }

        taxObligationCompany = taxableDocument.getTaxObligationCompany();
        if (taxObligationCompany == TaxObligationCompany::Source
            && TaxParameters::find().PurchTaxOnOperations
            && !taxObligationWarningOccured)
        {
            taxObligationWarningOccured = true;
            warning("@SYS4003093");
            return curext();
        }

        if (taxObligationCompany == TaxObligationCompany::Source)
        {
            if (!taxObligationSourceCompany)
            {
                taxObligationSourceCompany = taxableDocument.getSourceCompany();
            }

            if (!taxObligationSourceCompany)
            {
                return getDestination();
            }

            return taxObligationSourceCompany;
        }
        else
        {
            return getDestination();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the invoice ID for a transaction.
    /// </summary>
    /// <returns>
    /// The invoice ID.
    /// </returns>
    public InvoiceId getInvoiceId()
    {
        if (taxableDocument)
        {
            return taxableDocument.getInvoiceId();
        }
        else
        {
            return super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaintainExistingTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>maintainExistingTaxUncommitted</c> value that indicates whether new records will
    ///    be added to the <c>TaxUncommitted</c> table.
    /// </summary>
    /// <returns>
    ///    true if newly calculated tax lines will be added to the <c>TaxUncommitted</c> table; otherwise,
    ///    false.
    /// </returns>
    public boolean getMaintainExistingTaxUncommitted()
    {
        return maintainExistingTaxUncommitted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOperationLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the operation ledger dimension for the specified transaction line.
    /// </summary>
    /// <param name="_sourceRecId">
    /// The Record ID of a transaction line.
    /// </param>
    /// <returns>
    /// The operation ledger dimension.
    /// </returns>
    public LedgerDimensionAccount getOperationLedgerDimension(RefRecId _sourceRecId)
    {
        Debug::assert(taxableDocument != null);

        if (!this.useSubLedgerJournalLines())
        {
            if (_sourceRecId)
            {
                return taxableDocument.getLineByRecId(_sourceRecId).getOperationLedgerDimension(this.getCompany());
            }
            else
            {
                return taxableLineCurrentlyBeingCalculated.getOperationLedgerDimension(this.getCompany());
            }
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the tax exchange rate date for the specified transaction line.
    /// </summary>
    /// <param name="_recId">
    ///    Record ID of a transaction line.
    /// </param>
    /// <returns>
    ///    The tax exchange rate date.
    /// </returns>
    public TransDate getTaxDate(RefRecId _recId = 0)
    {
        if (taxableDocument)
        {
            if (_recId)
            {
                return taxableDocument.getLineByRecId(_recId).getCurrencyExchangeInformation().parmExchangeDate();
            }
            else
            {
                return taxableLineCurrentlyBeingCalculated.getCurrencyExchangeInformation().parmExchangeDate();
            }
        }
        else
        {
            return super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the <c>TaxUncommitted</c> records into the <c>TmpTaxWorkTrans</c> buffer.
    /// </summary>
    /// <param name="_initializationClass">
    ///    The initialization class. The initialization class is a different class for each transaction that
    ///    calculates tax.
    /// </param>
    public void init(Object _initializationClass)
    {
        if (_initializationClass is TaxableDocument)
        {
            taxableDocument = _initializationClass;

            voucher = taxableDocument.getReferenceNumber();
            taxIncludedInItemPrice = taxableDocument.getTaxIncluded();
            headingRecId = taxableDocument.getSourceHeader().RecId;
            headingTableId = taxableDocument.getSourceHeader().TableId;
            taxModuleType = taxableDocument.getModuleType();
        }

        if ((!this.useTaxUncommitted()) && (this.useSubLedgerJournalLines()))
        {
            throw error("@SYS95118");
        }

        // this.useTaxUncommitted() returns true if the transaction supports the
        // use of TaxUncommitted.  The variable useTaxUncommitted indicates that on
        // this particular call, does the transaction want tax to use TaxUncommitted.
        useTaxUncommitted = useTaxUncommitted && this.useTaxUncommitted();
        if (useTaxUncommitted && loadTaxUncommitted)
        {
            this.loadFromTaxUncommitted();
        }

        checkTaxCalculationCurrencyLockNeeded = this.checkTaxableDocumentLockNeeded();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes maps when a new instance of a derived class is created.
    /// </summary>
    void initializeCalculation()
    {
        amountInclTaxMap   = new Map(Types::Container, Types::Real);
        amountExclTaxMap   = new Map(Types::Container, Types::Real);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTaxForLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads transaction line information into the <c>Tax</c> table.
    /// </summary>
    /// <param name="_amountInclTax">
    ///    A Boolean value that specifies whether the line amount includes tax.
    /// </param>
    /// <param name="_baseAmount">
    ///    The line amount excluding tax.
    /// </param>
    /// <param name="_baseAmountIncludingTax">
    ///    The line amount.
    /// </param>
    /// <param name="_dimensionDefault">
    ///    The default dimensions.
    /// </param>
    /// <param name="_operationLedgerDimension">
    ///    The operation account.
    /// </param>
    /// <param name="ledgerPostingType">
    ///    The ledger posting type for the transaction line.
    /// </param>
    /// <param name="_unitAmount">
    ///    The unit amount for the line.
    /// </param>
    /// <param name="_itemId">
    ///    The item ID if inventory is supported.
    /// </param>
    /// <param name="_quantity">
    ///    The quantity from the transaction line.
    /// </param>
    /// <param name="_baseUnit">
    ///    The unit on the transaction line.
    /// </param>
    /// <param name="_exchRate_W">
    ///    The exchange rate
    /// </param>
    /// <param name="_vatDueDate_W">
    ///    The VAT register date.
    /// </param>
    /// <returns>
    ///    The base amount, excluding taxes and cash discounts.
    /// </returns>
    protected TaxAmountCur initializeTaxForLine(boolean _amountInclTax,
                                                TaxBase _baseAmount,
                                                TaxBase _baseAmountIncludingTax,
                                                DimensionDefault _dimensionDefault,
                                                LedgerDimensionAccount _operationLedgerDimension,
                                                LedgerPostingType ledgerPostingType,
                                                TaxBase _unitAmount = 0,
                                                ItemId _itemId = '',
                                                Qty _quantity = 0,
                                                UnitOfMeasureSymbol _baseUnit = '',
                                                ExchRate            _exchRate_W = 0,
                                                VatDueDate_W        _vatDueDate_W = dateNull()
                                                )
    {
        taxIncludedInItemPrice = _amountInclTax;
        if (taxIncludedInItemPrice
        //<GIN>
            && !isIndiaCountryRegionEnabled
        //</GIN>
        )
        {
            //This is a tax included scenario.
            amountInclTaxMap.insert(this.taxTransOrigin(null), _baseAmountIncludingTax);
            amountExclTaxMap.insert(this.taxTransOrigin(null), _baseAmount);
        }

        if (this.taxParameters().TaxLessCashDisc)
        {
            if (cashDiscAmount)
            {
                // cash discount amount is always used versus the percentage if both are passed in.
                _baseAmount -= cashDiscAmount;
            }
            else
            {
                _baseAmount -= _baseAmount * cashDiscPercent / 100;
            }
        }

        // <GIN>
        if (isIndiaCountryRegionEnabled
            && this.headingTableId() == tableNum(CustInvoiceTable))
        {
        _quantity = this.ajustQuantityForAdjustingInvoice_IN(_quantity);
        }
        // </GIN>
        // <GEEU>
        this.insertLineInInternal(_baseAmount, _quantity,  _baseUnit, _itemId, _unitAmount, _dimensionDefault, _operationLedgerDimension, ledgerPostingType, _exchRate_W, _vatDueDate_W);
        // </GEEU>

        return _baseAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxTransactionExchangeRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize default tax exchange rate
    /// </summary>
    protected void initTaxTransactionExchangeRate()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPrePayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the current transaction line is a pre-payment.
    /// </summary>
    /// <returns>
    /// true if the transaction line that is being calculated is a prepayment; otherwise, false.
    /// </returns>
    protected boolean isPrePayment()
    {
        if (taxableLineCurrentlyBeingCalculated)
        {
            return taxableLineCurrentlyBeingCalculated.isPrePayment();
        }
        else
        {
            return super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadFromTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads tax records from the <c>TaxUncommitted</c> table into the <c>TmpTaxWorkTrans</c> table.
    /// </summary>
    protected void loadFromTaxUncommitted()
    {
        taxWorkTrans.loadFromTaxUncommitted(this.headingTableId(), headingRecId, this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadPerLineTaxAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads tax adjustments that are adjusting taxes for a specific line.
    /// </summary>
    /// <param name="_companyId">
    ///    A value that specifies whether a tax adjustment can be located in another company. If they can, the
    ///    current company and passed in company will be checked for adjustments.
    /// </param>
    /// <param name="_sourceTableId">
    ///    The table ID of the transaction line.
    /// </param>
    /// <param name="_sourceRecId">
    ///    The record ID of the transaction line.
    /// </param>
    /// <param name="_headingSourceTableId">
    ///    The table ID of the heading transaction line.
    /// </param>
    /// <param name="_headingSourceRecId">
    ///    The record ID of the heading transaction line.
    /// </param>
    protected void loadPerLineTaxAdjustments(
        SelectableDataArea  _companyId,
        RefTableId          _sourceTableId,
        RefRecId            _sourceRecId
        ,RefTableId         _headingSourceTableId = 0
        ,RefRecId           _headingSourceRecId = 0
        )
    {
        TaxCalculationAdjustment taxCalculationAdjustment;

        taxCalculationAdjustment = TaxCalculationAdjustment::construct(taxWorkTrans, this);
        // <GIN>
        if (isCustomsEnabled && this.documentStatus_IN() == DocumentStatus::BillOfEntry_IN)
        {
            taxCalculationAdjustment.parmHeadingTableId(_headingSourceTableId);
            taxCalculationAdjustment.parmHeadingRecId(_headingSourceRecId);
        }
        else
        {
        // </GIN>
        taxCalculationAdjustment.parmHeadingTableId(_sourceTableId);
        taxCalculationAdjustment.parmHeadingRecId(_sourceRecId);
        // <GIN>
        }
        // </GIN>
        taxCalculationAdjustment.parmAmountInclTaxMap(amountInclTaxMap);
        taxCalculationAdjustment.parmLineAmountIncludesTax(this.lineAmountIncludesTax());
        taxCalculationAdjustment.loadTaxAdjustments(_companyId, _sourceRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadTaxAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads tax adjustments that are adjusting the taxes for a transaction.
    /// </summary>
    protected void loadTaxAdjustments()
    {
        TaxCalculationAdjustment taxCalculationAdjustment;
        TmpTaxWorkTrans tmpTaxWorkTransLocal;

        if (this.allowSingleLineAdjustment())
        {
            tmpTaxWorkTransLocal.setTmpData(taxWorkTrans);
            this.generateTaxCodeMap();
            while select SourceTableId, SourceRecId, Company from tmpTaxWorkTransLocal
            group by tmpTaxWorkTransLocal.Company, tmpTaxWorkTransLocal.SourceTableId, tmpTaxWorkTransLocal.SourceRecId
            {
                this.loadPerLineTaxAdjustments(tmpTaxWorkTransLocal.Company, tmpTaxWorkTransLocal.SourceTableId, tmpTaxWorkTransLocal.SourceRecId
                // <GIN>
                    ,tmpTaxWorkTransLocal.ParentSourceTableId
                    ,tmpTaxWorkTransLocal.ParentSourceRecId
                // </GIN>
                );
            }
            this.clearTaxCodeMap();
        }
        else
        {
            if (this.useSalesTaxAdjustments())
            {
                taxCalculationAdjustment = TaxCalculationAdjustment::construct(taxWorkTrans, this);

                if (taxCalculationAdjustment)
                {
                    taxCalculationAdjustment.parmLineAmountIncludesTax(!amountInclTaxMap.empty());
                    taxCalculationAdjustment.parmAmountInclTaxMap(amountInclTaxMap);
                    taxCalculationAdjustment.loadTaxAdjustments();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Creates initializes the new instance of TaxCalculation.
    /// </summary>
    /// <param name="_initializationClass">
    ///    This is the initialization class.  The initialization class is a different class
    ///    for each of the transactions which calculate tax.
    /// </param>
    /// <param name="_useTaxUncommitted">
    ///    If True, then persist calculates taxes to TaxUncommitted.
    /// </param>
    /// <param name="_loadTaxUncommittedOnInit">
    ///    If True, then the TaxUncommitted records will be loaded into the Tax classes TmpTaxWorkTrans
    ///    buffer.  This enables many of the inquiry/adjustment methods on Tax to function corectly.
    /// </param>
    /// <param name="_loadTaxTrans">
    ///    If True, then the TaxTrans records will be loaded into the Tax classes TmpTaxWorkTrans
    ///    buffer.  This enables many of the inquiry/adjustment methods on Tax to function corectly.
    /// </param>
    /// <param name="skipInit">
    /// Set to true in order to skip the initialization of the object.  Defaulted to false.
    /// </param>
    /// <param name="_maintainExistingTaxUncommitted">
    ///    A Boolean value which indicates that Tax should merge the newly calculated taxes with
    ///    existing records in TaxUncommitted.
    /// </param>
    void new(Object _initializationClass, boolean _useTaxUncommitted, boolean _loadTaxUncommittedOnInit, boolean _loadTaxTrans, boolean skipInit = false, boolean _maintainExistingTaxUncommitted = false)
    {
        super();

        maintainExistingTaxUncommitted = _maintainExistingTaxUncommitted;
        useTaxUncommitted = _useTaxUncommitted;
        loadTaxUncommitted = _loadTaxUncommittedOnInit;
        loadTaxTrans = _loadTaxTrans;

        //when packing/unpacking the class it is not necessary to initialize the class.
        if (!skipInit)
        {
            this.init(_initializationClass);
        }

        processCounters = new Microsoft.Dynamics.Tax.Instrumentation.ProcessCounters(Microsoft.Dynamics.Tax.Instrumentation.PerformanceCounterCatalog::get_Instance().GetProcessCounters());
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseHeadingRecIdAsSourceRecId_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// If useHeadingRecIdAsSourceRecId_RU is "true" and SourceRecId is zero, HeadingRecId whould be used instead in sourceRecId() and taxTransOrigin() methods
    /// </summary>
    /// <param name="_useHeadingRecIdAsSourceRecId">
    /// use headingRecId as SourceRecId if it is zero
    /// </param>
    /// <returns>
    /// useHeadingRecIdAsSourceRecId sign
    /// </returns>
    public boolean parmUseHeadingRecIdAsSourceRecId_RU(boolean _useHeadingRecIdAsSourceRecId = useHeadingRecIdAsSourceRecId_RU)
    {
        useHeadingRecIdAsSourceRecId_RU = _useHeadingRecIdAsSourceRecId;
        return useHeadingRecIdAsSourceRecId_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setHeading_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Set heading journal
    /// </summary>
    /// <param name="_record">
    ///  heading record
    /// </param>
    /// <remarks>
    ///   Used with setTmpLedgerJournalTrans_RU to set heading ID, because default
    /// behavoiur of using journal does not work with temporery tables
    /// </remarks>
    public void setHeading_RU(Common _record)
    {
        headingTableId  = _record.TableId;
        headingRecId    = _record.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceLinesHaveTaxGroups</Name>
				<Source><![CDATA[
    protected boolean sourceLinesHaveTaxGroups()
    {
        return taxableDocument.doTaxGroupExistsForDocument();
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the record ID of the transaction line to calculate.
    /// </summary>
    /// <returns>
    ///    The record ID of the transaction line to calculate.
    /// </returns>
    /// <remarks>
    ///    This method is designed to be overridden by derived classes. The base implementation returns 0.
    /// </remarks>
    public RecId sourceRecId()
    {
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ, #isoHU, #isoPL]))
        {
            RefRecId sourceLineRecId;
            if (taxableLineCurrentlyBeingCalculated)
            {
                sourceLineRecId = taxableLineCurrentlyBeingCalculated.getSourceLine().RecId;
            }
            return this.useHeadingIds(sourceLineRecId) ? headingRecId : sourceLineRecId;
        }
        else
        {
            if (taxableLineCurrentlyBeingCalculated)
            {
                return taxableLineCurrentlyBeingCalculated.getSourceLine().RecId;
            }
            else
            {
                return super();
            }
        }
     }

]]></Source>
			</Method>
			<Method>
				<Name>useHeadingIds</Name>
				<Source><![CDATA[
     private boolean useHeadingIds(RefRecId _sourceLineRecId)
     {
         return (useHeadingRecIdAsSourceRecId_RU && !_sourceLineRecId);
     }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTableId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the table ID of the transaction to tax.
    /// </summary>
    /// <returns>
    ///    The table ID of the transaction to tax.
    /// </returns>
    /// <remarks>
    ///    This method is overridden by derived classes. The base implementation returns 0.
    /// </remarks>
    public RefTableId sourceTableId()
    {
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ, #isoHU, #isoPL]))
        {
            RefTableId sourceLineTableId;
            RefRecId sourceLineRecId;
            if (taxableLineCurrentlyBeingCalculated)
            {
                sourceLineTableId = taxableLineCurrentlyBeingCalculated.getSourceLine().TableId;
                sourceLineRecId = taxableLineCurrentlyBeingCalculated.getSourceLine().RecId;
            }
            return this.useHeadingIds(sourceLineRecId) ? headingTableId : sourceLineTableId;
        }
        else
        {
            if (taxableLineCurrentlyBeingCalculated)
            {
                return taxableLineCurrentlyBeingCalculated.getSourceLine().TableId;
            }
            else
            {
                return super();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>supportAmountByUnit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the tax calculation engine should calculate tax for the tax code Origin of
    ///    Amount Per Unit.
    /// </summary>
    /// <returns>
    ///    Always returns false.
    /// </returns>
    /// <remarks>
    ///    Journals do not support amount by unit calculations. Therefore, this method always returns false.
    /// </remarks>
    public boolean supportAmountByUnit()
    {
        if (taxableLineCurrentlyBeingCalculated)
        {
            return taxableLineCurrentlyBeingCalculated.supportAmountByUnit();
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxExists</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether tax records have either been calculated or loaded from the <c>TaxUncommitted</c>
    ///    table.
    /// </summary>
    /// <returns>
    ///    true if tax records have been calculated or loaded from the <c>TaxUncommitted</c> table; otherwise,
    ///    false.
    /// </returns>
    public boolean taxExists()
    {
        select firstonly RecId from taxWorkTrans;

        if (taxWorkTrans.RecId)
            return true;

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxPack</Name>
				<Source><![CDATA[
    public container taxPack()
    {
        container packedContainer;

        packedContainer = [#CurrentVersion, #CurrentList, super()];

        return packedContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a container that contains the table and record IDs of the specified record.
    /// </summary>
    /// <param name="_originRecord">
    /// The record for which a key container should be constructed.
    /// </param>
    /// <returns>
    /// A container that contains the table and record IDs of the specified record.
    /// </returns>
    /// <remarks>
    /// The container returned by this method is used as the key to maps that contain heterogeneous record
    /// types to avoid issues if the IDs of multiple records collide.
    /// </remarks>
    protected container taxTransOrigin(Common _originRecord)
    {
        return [this.sourceTableId(), this.sourceRecId()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxUnpack</Name>
				<Source><![CDATA[
    public boolean taxUnpack(container packedClass)
    {
        Version     version = RunBase::getVersion(packedClass);
        container   base;

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList, base] = packedClass;
                super(base);

                break;
            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSubLedgerJournalLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the current transaction to calculate supports the <c>SubLedgerDistributions</c>
    ///    or <c>SubLedgerJournalLines</c> records. By default, this base implementation is that they do not
    ///    support them. As the individual transaction support the sub-ledger, they must override this method
    ///    and return true.
    /// </summary>
    /// <returns>
    ///    true if the current transaction to calculate supports the <c>SubLedgerDistributions</c> or
    ///    <c>SubLedgerJournalLines</c> records; otherwise, false.
    /// </returns>
    public boolean useSubLedgerJournalLines()
    {
        if (taxableDocument)
        {
            return taxableDocument.useSourceDocumentFramework();
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>useTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the <c>Tax</c> class should use the <c>TaxUncommitted</c> table.
    /// </summary>
    /// <returns>
    ///    true if the <c>Tax</c> class should use the <c>TaxUncommitted</c> table; otherwise, false.
    /// </returns>
    public boolean useTaxUncommitted()
    {
        if (taxableDocument)
        {
            return taxableDocument.useTaxUncommitted();
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForSourceType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a new instance of the <c>Tax</c> class based on the transaction.
    /// </summary>
    /// <param name="_sourceType">
    ///    The type of the transaction to calculate taxes.
    /// </param>
    /// <param name="_initializationClass">
    ///    The initialization class for the given transaction.
    /// </param>
    /// <returns>
    ///    The correct <c>Tax</c> instance based on the calling transaction.
    /// </returns>
    [Replaceable]
    static TaxCalculation newForSourceType(TaxSourceType _sourceType, Object _initializationClass)
    {
        TaxFreeInvoice   taxFreeInvoice;
        TaxPurch         taxPurch;
        TaxCalculationJournal taxCalculationJournal;
        TrvTaxExpense    trvTaxExpense;
        TaxCalculationBankStatement taxCalculationBankStatement;

        switch (_sourceType)
        {
            case TaxSourceType::PurchaseOrder :
                taxPurch = new TaxPurch(_initializationClass, false, false, false);
                return taxPurch;
            case TaxSourceType::FreeTextInvoice :
                taxFreeInvoice = new TaxFreeInvoice(_initializationClass, false, false, false);
                return taxFreeInvoice;
            case TaxSourceType::Journals :
                taxCalculationJournal = new TaxCalculationJournal(_initializationClass, false, false, false);
                return taxCalculationJournal;
            case TaxSourceType::Expense :
                trvTaxExpense = new TrvTaxExpense(_initializationClass, false, false, false);
                return trvTaxExpense;
            case TaxSourceType::BankAccountReconcile:
                taxCalculationBankStatement = new TaxCalculationBankStatement(_initializationClass, false, false, false);
                return taxCalculationBankStatement;
            case TaxSourceType::ProjAdvancedJournal:
                TaxCalculationProjAdvancedJournal taxCalculationProjAdvancedJournal = new TaxCalculationProjAdvancedJournal(_initializationClass, false, false, false);
                return taxCalculationProjAdvancedJournal;
            default:
                var eventHandlerResult = new EventHandlerResult();
                TaxCalculation::newForSourceTypeDelegate(_sourceType, _initializationClass, eventHandlerResult);

                if (eventHandlerResult.hasResult())
                {
                    return eventHandlerResult.result();
                }

                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForSourceTypeWithTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a new instance of the <c>Tax</c> class based on the transaction. This constructor causes
    ///    tax to use the <c>TaxUncommitted</c> table to load and persist taxes.
    /// </summary>
    /// <param name="_sourceType">
    ///    The type of the transaction to calculate taxes.
    /// </param>
    /// <param name="_initializationClass">
    ///    The initialization class for the given transaction. This is a different class for each transaction.
    /// </param>
    /// <param name="_loadTaxUncommitted">
    ///    A Boolean value that specifies whether during the construction to load the <c>TaxUncommitted</c>
    ///    records into taxes <c>TmpTaxWorkTrans</c> buffer which enables most of the inquiry functions to
    ///    work.
    /// </param>
    /// <param name="_loadTaxTrans">
    ///    A Boolean value that specifies whether during the construction to load the <c>TaxTrans</c>
    ///    records into taxes <c>TmpTaxWorkTrans</c> buffer which enables most of the inquiry functions to
    ///    work.
    /// </param>
    /// <param name="_maintainExistingTaxUncommitted">
    ///    A Boolean value which indicates that Tax should merge the newly calculated taxes with
    ///    existing records in TaxUncommitted.
    /// </param>
    /// <returns>
    ///    The the correct Tax instance based on the calling transaction.
    /// </returns>
    [Replaceable]
    static TaxCalculation newForSourceTypeWithTaxUncommitted(TaxSourceType _sourceType, Object _initializationClass, boolean _loadTaxUncommitted, boolean _loadTaxTrans, boolean _maintainExistingTaxUncommitted = false)
    {
        TaxFreeInvoice   taxFreeInvoice;
        TaxPurch         taxPurch;
        TaxCalculationJournal taxCalculationJournal;
        TrvTaxExpense    trvTaxExpense;
        TaxCalculationBankStatement taxCalculationBankStatement;

        switch (_sourceType)
        {
            case TaxSourceType::PurchaseOrder :
                if (_initializationClass is PurchCalcTax_PurchReq_LineTax_PurchTotalsForm)
                {
                    taxPurch = new TaxPurchPurchReqPurchTotalsForm(_initializationClass, true, _loadTaxUncommitted, _loadTaxTrans, false, _maintainExistingTaxUncommitted);
                }
                else
                {
                    taxPurch = new TaxPurch(_initializationClass, true, _loadTaxUncommitted, _loadTaxTrans, false, _maintainExistingTaxUncommitted);
                }
                return taxPurch;
            case TaxSourceType::FreeTextInvoice :
                taxFreeInvoice = new TaxFreeInvoice(_initializationClass, true, _loadTaxUncommitted, _loadTaxTrans, false, _maintainExistingTaxUncommitted);
                return taxFreeInvoice;
            case TaxSourceType::Journals :
                taxCalculationJournal = new TaxCalculationJournal(_initializationClass, true, _loadTaxUncommitted, _loadTaxTrans, false, _maintainExistingTaxUncommitted);
                return taxCalculationJournal;
            case TaxSourceType::Expense :
                trvTaxExpense = new TrvTaxExpense(_initializationClass, true, _loadTaxUncommitted, _loadTaxTrans, false, _maintainExistingTaxUncommitted);
                return trvTaxExpense;
            case TaxSourceType::ProjAdvancedJournal :
                return new taxCalculationProjAdvancedJournal(_initializationClass, true, _loadTaxUncommitted, _loadTaxTrans, false, _maintainExistingTaxUncommitted);
            // <GBR>
            case TaxSourceType::ComplementaryInvoice:
                return new TaxComplementaryInvoice(_initializationClass, true, _loadTaxUncommitted, _loadTaxTrans, false, _maintainExistingTaxUncommitted);
            // </GBR>
            case TaxSourceType::BankAccountReconcile:
                taxCalculationBankStatement = new TaxCalculationBankStatement(_initializationClass, true, _loadTaxUncommitted, _loadTaxTrans, false, _maintainExistingTaxUncommitted);
                return taxCalculationBankStatement;
            default:
                var eventHandlerResult = new EventHandlerResult();
                TaxCalculation::newForSourceTypeWithTaxUncommittedDelegate(
                    _sourceType,
                    _initializationClass,
                    _loadTaxUncommitted,
                    _loadTaxTrans,
                    _maintainExistingTaxUncommitted,
                    eventHandlerResult);

                if (eventHandlerResult.hasResult())
                {
                    return eventHandlerResult.result();
                }

                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearExemptTaxAmounts_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the fields in the <c>TmpTaxWorkTrans</c> table which are normally
    ///    not calculated for the records which correspond to the exempt tax codes.
    /// </summary>
    private void clearExemptTaxAmounts_RU()
    {
        delete_from tmptax;

        while select taxWorkTrans
            where taxWorkTrans.ExemptTax == NoYes::Yes
        {
            taxWorkTrans.SourceTaxAmountCur         = 0;
            taxWorkTrans.SourceTaxAmountCurReal     = 0;
            taxWorkTrans.TaxAmount                  = 0;
            taxWorkTrans.TaxAmountCur               = 0;
            taxWorkTrans.TaxAmountRep               = 0;
            taxWorkTrans.SourceRegulateAmountCur    = 0;
            taxWorkTrans.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxModuleType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the buffer of <c>TaxModuleType</c>.
    /// </summary>
    /// <param name = "_taxModuleType">The value of enum <c>TaxModuleType</c>.</param>
    /// <returns>The value of enum <c>TaxModuleType</c>.</returns>
    [Hookable(false)]
    public TaxModuleType parmTaxModuleType(TaxModuleType _taxModuleType = taxModuleType)
    {
        taxModuleType = _taxModuleType;
        return taxModuleType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineAmountIncludesTax</Name>
				<Source><![CDATA[
    protected boolean lineAmountIncludesTax()
    {
        return !amountInclTaxMap.empty();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>