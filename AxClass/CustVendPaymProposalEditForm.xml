<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendPaymProposalEditForm</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>CustVendPaymProposalEditForm</c> class contains the shared logic between the customer and
/// vendor forms for editing a payment proposal.
/// </summary>
public class CustVendPaymProposalEditForm
{
    protected FormRun formRun;
    protected CustVendPaymProposal paymProposal;
    protected CustVendTransStatic custVendTransStatic;

    protected QueryBuildRange criteriaJournalId;
    protected QueryBuildRange qbrSpecRecId;

    protected FormDataSource custVendPaymProposalLine_ds;
    protected FormDataSource specTrans_ds;
    protected FormDataSource custVendTransOpen_ds;
    protected FormDataSource custVendTrans_ds;
    protected FormDataSource custVendTransCashDisc_ds;
    protected FormDataSource ledgerJournalTrans_ds;
    protected FormDataSource custVendPaymProposalLineOverview_ds;
    protected FormDataSource dirPartyTable_ds;

    protected FormFunctionButtonControl okButton;
    protected FormFunctionButtonControl ctrlBtnModifyPaymAttributes;

    protected boolean clearProposalWhenClosing;
    protected boolean mustRecalcPaymDate;

    protected FormDataSource custVendTransPayment_BR_ds;
    protected FormDataSource custTransEPRemit_BR_DS;
    protected boolean checkPaymMode;

    protected LedgerJournalId ledgerJournalId;
    protected LedgerJournalType ledgerJournalType;
    protected ModuleCustVend ledgerJournalModuleCustVend;

    protected boolean skipUserInteractionDuringSpecTransDelete;

    private boolean  transferInBatch;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>adjustInterestFineEdition_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjust interest and fine edition properties based on payment data.
    /// </summary>
    public void adjustInterestFineEdition_BR()
    {
        CustVendPaymProposalLine    custVendPaymProposalLine    = custVendPaymProposalLine_ds.cursor();
        CustVendTransOpen           custVendTransOpen           = custVendTransOpen_ds.cursor();
        FieldId                     fineAmountFieldId;
        FieldId                     interestAmountFieldId;
        FieldId                     fineCodeFieldId;
        FieldId                     interestCodeFieldId;
        boolean                     reversalTransaction = false;

        if (custVendTransOpen.TableId == tableNum(CustTransOpen))
        {
            fineAmountFieldId       = fieldNum(CustTransOpen, FineAmount_BR);
            interestAmountFieldId   = fieldNum(CustTransOpen, InterestAmount_BR);
            fineCodeFieldId         = fieldNum(CustTransOpen, FineCode_BR);
            interestCodeFieldId     = fieldNum(CustTransOpen, InterestCode_BR);

            if (custVendTransOpen.AmountCur < 0)
            {
                reversalTransaction = true;
            }
        }
        else
        {
            fineAmountFieldId       = fieldNum(VendTransOpen, FineAmount_BR);
            interestAmountFieldId   = fieldNum(VendTransOpen, InterestAmount_BR);
            fineCodeFieldId         = fieldNum(VendTransOpen, FineCode_BR);
            interestCodeFieldId     = fieldNum(VendTransOpen, InterestCode_BR);

            if (custVendTransOpen.AmountCur > 0)
            {
                reversalTransaction = true;
            }
        }

        if (custVendPaymProposalLine.PaymDate <= custVendTransOpen.DueDate)
        {
            custVendTransOpen_ds.object(fineAmountFieldId).allowEdit(false);
            custVendTransOpen_ds.object(interestAmountFieldId).allowEdit(false);
        }
        else
        {
            custVendTransOpen_ds.object(fineAmountFieldId).allowEdit(true);
            custVendTransOpen_ds.object(interestAmountFieldId).allowEdit(true);
        }

        if (reversalTransaction)
        {
            custVendTransOpen_ds.object(fineCodeFieldId).allowEdit(false);
            custVendTransOpen_ds.object(interestCodeFieldId).allowEdit(false);
        }
        else
        {
            custVendTransOpen_ds.object(fineCodeFieldId).allowEdit(true);
            custVendTransOpen_ds.object(interestCodeFieldId).allowEdit(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dataSourcePaymentOverviewExecuteQueryPre</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies the query before it is executed.
    /// </summary>
    /// <remarks>
    /// The payment overview datasource filters the payment proposal lines
    /// down to payments that are related to the vendor of the currently selected invoice.
    /// </remarks>
    public void dataSourcePaymentOverviewExecuteQueryPre()
    {
        CustVendPaymProposalLine currentPaymentProposalLine = this.findPaymentProposalLineForCurrentInvoice();
        QueryBuildDataSource paymentOverviewDataSource = custVendPaymProposalLineOverview_ds.queryBuildDataSource();

        paymentOverviewDataSource.clearRanges();
        paymentOverviewDataSource.addRange(fieldNum(CustVendPaymProposalLine, JournalId)).value(queryValue(currentPaymentProposalLine.JournalId));
        paymentOverviewDataSource.addRange(fieldNum(CustVendPaymProposalLine, AccountNum)).value(queryValue(currentPaymentProposalLine.AccountNum));
        paymentOverviewDataSource.addRange(fieldNum(CustVendPaymProposalLine, AccountNumCompany)).value(queryValue(currentPaymentProposalLine.AccountNumCompany));
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPaymentProposalLineForCurrentInvoice</Name>
				<Source><![CDATA[
    private CustVendPaymProposalLine findPaymentProposalLineForCurrentInvoice()
    {
        SpecTrans specTrans = specTrans_ds.cursor();
        CustVendPaymProposalLine currentPaymentProposalLine;

        select firstonly currentPaymentProposalLine
            where currentPaymentProposalLine.RecId == specTrans.SpecRecId
                && currentPaymentProposalLine.TableId == specTrans.SpecTableId
                && currentPaymentProposalLine.DataAreaId == specTrans.SpecCompany;

        return currentPaymentProposalLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dataSourcePaymentOverviewInitPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies the datasource after it has been initialized.
    /// </summary>
    public void dataSourcePaymentOverviewInitPost()
    {
        QueryBuildDataSource paymentOverviewDataSource = custVendPaymProposalLineOverview_ds.queryBuildDataSource();

        paymentOverviewDataSource.clearDynalinks();
        paymentOverviewDataSource.addOrderByField(fieldNum(CustVendPaymProposalLine, PaymMode));
        paymentOverviewDataSource.addOrderByField(fieldNum(CustVendPaymProposalLine, PaymDate));

        this.addSpecTransFilter(paymentOverviewDataSource);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSpecTransFilter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Filters out payment proposal lines that are not associated with a <c>SpecTrans</c> record.
    /// </summary>
    private void addSpecTransFilter(QueryBuildDataSource _paymentOverviewDataSource)
    {
        QueryBuildDataSource specTransDataSource = _paymentOverviewDataSource.addDataSource(tableNum(SpecTrans));
        specTransDataSource.joinMode(JoinMode::ExistsJoin);
        specTransDataSource.relations(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dataSourceDirPartyTableInitPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies the datasource after it has been initialized.
    /// </summary>
    public void dataSourceDirPartyTableInitPost()
    {
        dirPartyTable_ds.queryBuildDataSource().addSortField(fieldNum(DirPartyTable, Name), SortOrder::Ascending);
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustSettleDiscountAmounts</Name>
				<Source><![CDATA[
    private void adjustSettleDiscountAmounts(SpecTrans _specTrans, AmountCur _openTransAmountCur, boolean _cashDiscToTakeChanged = false)
    {
        if (abs(_specTrans.Balance01) > abs(_openTransAmountCur - _specTrans.CashDiscToTake))
        {
            // Adjust spec trans because balance plus cash discount is greater than amount remaining
            if (abs(_specTrans.Balance01) < abs(_openTransAmountCur))
            {
                // adjust cash discount when balance is less than open transaction amount remaining
                _specTrans.CashDiscToTake = _openTransAmountCur - _specTrans.Balance01;
            }

            _specTrans.Balance01 = _openTransAmountCur - _specTrans.CashDiscToTake;
        }
        else if (abs(_specTrans.Balance01) < abs(_openTransAmountCur - _specTrans.CashDiscToTake) && _cashDiscToTakeChanged)
        {
            // Adjust balance because balance plus cash discount is less than amount remaining
            _specTrans.Balance01 = _openTransAmountCur - _specTrans.CashDiscToTake;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountChangeSign</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts the specified amount so that it has the correct sign for accounts receivable or accounts
    ///    payable.
    /// </summary>
    /// <param name="_amountCur">
    ///    The amount to conditionally adjust.
    /// </param>
    /// <returns>
    ///    The adjusted amount.
    /// </returns>
    /// <remarks>
    ///    The Edit Payment Proposal forms allow for the user to enter payment amounts either as negative or
    ///    positive amounts. This method adjusts the sign according to the accounts receivable or accounts
    ///    payable context of the payment proposal.
    /// </remarks>
    public AmountCur amountChangeSign(AmountCur    _amountCur)
    {
        CustVendTransOpen   custVendTransOpen;
        AmountCur           amountCur = _amountCur;

        custVendTransOpen = custVendTransOpen_ds.cursor();

        if (custVendTransOpen.AmountCur < 0 && _amountCur > 0)
        {
            amountCur = -amountCur;
        }

        if (custVendTransOpen.AmountCur > 0 && _amountCur < 0)
        {
            amountCur = -amountCur;
        }

        return amountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buttonClickedBalanceControl</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Opens the Balance control form.
    /// </summary>
    /// <param name="_button">
    ///    The function button that was clicked on the form.
    /// </param>
    public void buttonClickedBalanceControl(FormFunctionButtonControl _button)
    {
        MenuFunction                    menuFunction;
        Args                            args;
        LedgerBalanceControlCalculation ledgerBalanceControlCalculation;

        ledgerBalanceControlCalculation = LedgerBalanceControlCalculation::construct();
        ledgerBalanceControlCalculation.parmLedgerJournalId(ledgerJournalId);
        ledgerBalanceControlCalculation.calcAmounts();

        args = new Args();
        args.parmObject(ledgerBalanceControlCalculation);

        menuFunction = new MenuFunction(_button.menuItemName(), _button.menuItemType());

        menuFunction.run(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buttonClickedModifyPaymAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Activates the function to change payment attributes.
    /// </summary>
    public void buttonClickedModifyPaymAttributes()
    {
        Args                        args = new Args();
        int specTransPositionAtModify = specTrans_ds.getPosition();

        args.record(specTrans_ds.cursor());
        args.parmObject(paymProposal);

        int lastLogLineNumber = infologLine();

        ctrlBtnModifyPaymAttributes.menufunction().run(args);

        InfoLogUtility::showInfologMessagesAfterLineNumber(lastLogLineNumber, "@SYS88509");

        specTrans_ds.research();
        specTrans_ds.setPosition(specTransPositionAtModify);
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferPaymentProposal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Activates the function that transfers a payment proposal to the journal.
    /// </summary>
    public void transferPaymentProposal()
    {
        Args args = new Args();

        args.parmObject(paymProposal);

        if (this.parmTransferInBatch())
        {
            ttsbegin;

            CustVendPaymProposalTransferToJournal transfer = CustVendPaymProposalTransferToJournal::constructForPaymProposal(paymProposal);
            BatchInfo transferBatchInfo = transfer.batchInfo();
            transferBatchInfo.parmBatchExecute(NoYes::Yes);
            transferBatchInfo.doBatch();

            CustVendPaymProposalBatchProcess::changeTargetState(
                paymProposal.ledgerJournalId(), 
                CustVendPaymProposalBatchProcessState::CreatedPaymentLines,
                transferBatchInfo.parmBatch().BatchJobId);

            ttscommit;

            formRun.close();
        }
        else
        {
            this.parmOKButton().menufunction().run(args);

            if (!CustVendPaymProposal::doesJournalContainAnyPaymentProposalLines(ledgerJournalId))
            {
                formRun.close();
                if (ledgerJournalTrans_ds)
                {
                    ledgerJournalTrans_ds.research(true);
                }
            }
            else
            {
                custVendPaymProposalLine_ds.research();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>custTransEPremitModified_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes code after the user has changed the field of CustTransEPRemit.
    /// </summary>
    /// <param name="_specTransRefRecId">
    /// The record ID related with the <c>CustTransEPRemit_BR</c> table
    /// </param>
    void custTransEPremitModified_BR(RecID    _specTransRefRecId)
    {
        CustTransEPRemit_BR         custTransEPRemit;
        CustVendPaymProposalLine    paymProposalLine = custVendPaymProposalLine_ds.cursor();

        custTransEPRemit = CustTransEPRemit_BR::findByRefRecId(_specTransRefRecId);
        paymProposalLine.EPRemitOccCode_BR  = custTransEPRemit.RemitOccCode;
        paymProposalLine.EPBankFolder_BR    = custTransEPRemit.BankFolder;
        paymProposalLine.EPInstruction_1_BR = custTransEPRemit.Instruction_1;
        paymProposalLine.EPInstruction_2_BR = custTransEPRemit.Instruction_2;
        paymProposalLine.EPDocumentType_BR  = custTransEPRemit.DocumentType;
        paymProposalLine.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendPaymProposalCalc</Name>
				<Source><![CDATA[
    public CustVendPaymProposalCalcPaym custVendPaymProposalCalc()
    {
        return paymProposal.parmPaymProposalCalcPaym();
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendPaymProposalLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the current payment proposal line.
    /// </summary>
    /// <param name="_specTrans">
    /// A related <c>SpecTrans</c> record to get the payment proposal line from; optional.
    /// </param>
    /// <returns>
    ///    A <c>CustVendPaymProposalLine</c> record buffer.
    /// </returns>
    public CustVendPaymProposalLine custVendPaymProposalLine(SpecTrans _specTrans = null)
    {
        CustVendPaymProposalLine custVendPaymProposalLine;
        SpecTrans specTransBuffer;

        if (_specTrans)
        {
            specTransBuffer = _specTrans;
        }
        else
        {
            specTransBuffer = specTrans_ds.cursor();
        }

        changecompany(specTransBuffer.SpecCompany)
        {
            select firstonly custVendPaymProposalLine
                where custVendPaymProposalLine.JournalCompany == specTransBuffer.SpecCompany
                    && custVendPaymProposalLine.TableId == specTransBuffer.SpecTableId
                    && custVendPaymProposalLine.RecId   == specTransBuffer.SpecRecId;
        }

        return custVendPaymProposalLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dataSourceCustVendTransInitPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes code after <c>init</c> has been run on the <c>CustTrans</c> or <c>VendTrans</c> data
    ///    source of the form.
    /// </summary>
    /// <param name="_custVendTrans">
    ///    A <c>CustVendTrans</c> data source.
    /// </param>
    public void dataSourceCustVendTransInitPost(FormDataSource _custVendTrans)
    {
        custVendTransStatic = CustVendTransStatic::newTrans(_custVendTrans.cursor());
        custVendTrans_ds.cacheAddMethod(custVendTransStatic.transMethodNameCustVendTableName(), false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustVendPaymProposalLineDataSource</Name>
				<Source><![CDATA[
    public void setCustVendPaymProposalLineDataSource(FormDataSource _custVendPaymProposalLine)
    {
        custVendPaymProposalLine_ds = _custVendPaymProposalLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSpecTransDataSource</Name>
				<Source><![CDATA[
    public void setSpecTransDataSource(FormDataSource _specTrans)
    {
        specTrans_ds = _specTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustVendTransOpenDataSource</Name>
				<Source><![CDATA[
    public void setCustVendTransOpenDataSource(FormDataSource _custVendTransOpen)
    {
        custVendTransOpen_ds = _custVendTransOpen;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustVendTransDataSource</Name>
				<Source><![CDATA[
    public void setCustVendTransDataSource(FormDataSource _custVendTrans)
    {
        custVendTrans_ds = _custVendTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustVendTransCashDiscDataSource</Name>
				<Source><![CDATA[
    public void setCustVendTransCashDiscDataSource(FormDataSource _custVendTransCashDisc)
    {
        custVendTransCashDisc_ds = _custVendTransCashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustVendPaymProposalLineOverviewDataSource</Name>
				<Source><![CDATA[
    public void setCustVendPaymProposalLineOverviewDataSource(FormDataSource _custVendPaymProposalLineOverview)
    {
        custVendPaymProposalLineOverview_ds = _custVendPaymProposalLineOverview;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustVendTransPayment_BRDataSource</Name>
				<Source><![CDATA[
    public void setCustVendTransPayment_BRDataSource(FormDataSource _custVendTransPayment_BR)
    {
        custVendTransPayment_BR_ds = _custVendTransPayment_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDirPartyTableDataSource</Name>
				<Source><![CDATA[
    public void setDirPartyTableDataSource(FormDataSource _dirPartyTable)
    {
        dirPartyTable_ds = _dirPartyTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dataSourceSpecTrans_initPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>FormDataSource</c> for the <c>SpecTrans</c> table.
    /// </summary>
    public void dataSourceSpecTrans_initPost()
    {
        container companies = CustVendOpenTransManager::findSharedServiceCompanies(curext());
        Query specTransQuery = specTrans_ds.query();
        specTransQuery.clearCompanyRange();

        for (int i = 1; i <= conLen(companies); i++)
        {
            specTransQuery.addCompanyRange(conPeek(companies, i));
        }

        specTransQuery.addQueryFilter(specTransQuery.dataSourceName(specTrans_ds.name()), fieldStr(SpecTrans, RefCompany)).value(con2Str(companies));
    }

]]></Source>
			</Method>
			<Method>
				<Name>dataSourceSpecTrans_writePost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes code after <c>super()</c> is called in the <c>write</c> method of the <c>SpecTrans
    /// </c>data source.
    /// </summary>
    public void dataSourceSpecTrans_writePost()
    {
        CustVendPaymProposalLine custVendPaymProposalLine_Save;
        custVendPaymProposalLine_Save.data(custVendPaymProposalLine_ds.cursor());

        SpecTrans specTrans;
        specTrans.data(specTrans_ds.cursor());
        int specTransPositionAtWrite = specTrans_ds.getPosition();

        if (custVendPaymProposalLine_Save.RecId != specTrans.SpecRecId)
        {
            select firstonly custVendPaymProposalLine_Save
                where custVendPaymProposalLine_Save.RecId == specTrans.SpecRecId
                    && custVendPaymProposalLine_Save.TableId == specTrans.SpecTableId;
        }

        if (mustRecalcPaymDate)
        {
            CustVendPaymProposalCalcPaym custVendPaymProposalCalcPaym = this.custVendPaymProposalCalc();
            custVendPaymProposalCalcPaym.calc(custVendTransOpen_ds.cursor());
            TransDate newPaymDate = custVendPaymProposalCalcPaym.paymDate();

            if (!newPaymDate)
            {
                // The call to CustVendPaymProposalCalcPaym.calc failed to produce a proposed payment date for the edited transaction.
                // One scenario where this occurs is when the proposal type is CashDisc and the user edited the transaction such that
                // no discount can be taken. When creating payment proposals this transaction would have been ignored, but in edit mode
                // we must not remove the transaction automatially from the proposal. See repro on bug - Dynamics Ax 4.1 56371.
                // Since we cannot process without a date of payment for the edited transaction we will use the payment date of the
                // proposed payment the transaction is currently associated with.
                newPaymDate = custVendPaymProposalLine_Save.PaymDate;
            }

            custVendTransOpen_ds.reread();

            paymProposal.removeCustVendTransOpen(custVendTransOpen_ds.cursor());

            paymProposal.addCustVendTransOpen(custVendTransOpen_ds.cursor(),
                newPaymDate,
                custVendPaymProposalCalcPaym.parmPaymCurrency(),
                custVendPaymProposalCalcPaym.paymAmountInvoiceCur());
            mustRecalcPaymDate = false;
        }
        else
        {
            paymProposal.reorgCustVendTransOpen(custVendTransOpen_ds.cursor(),
                custVendPaymProposalLine_Save.PaymDate,
                custVendPaymProposalLine_Save.CurrencyCode);
        }

        this.setDatasourceCursorToRow(SpecTrans, specTransPositionAtWrite);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDatasourceCursorToRow</Name>
				<Source><![CDATA[
    private void setDatasourceCursorToRow(SpecTrans _specTrans, int _specTransCurrentPosition)
    {
        // It's possible that the SpecTrans record has been deleted and recreated so
        // we may need to find the new record.
        _specTrans.reread();

        if (!_specTrans)
        {
            specTrans_ds.research();
        }

        specTrans_ds.setPosition(_specTransCurrentPosition);
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayCashDiscAmountToTake</Name>
				<Source><![CDATA[
    public AmountCur displayCashDiscAmountToTake(CustVendTransOpen _custVendTransOpen, CustVendTransCashDisc _custVendTransCashDisc)
    {
        AmountCur cashDiscToTake;

        cashDiscToTake = _custVendTransOpen.getCashDiscAmountToTake(_custVendTransCashDisc.CashDiscAmount);

        return cashDiscToTake;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayCashDiscdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the cash discount date for the given <c>CustVendTransOpen</c> table record.
    /// </summary>
    /// <param name = "_custVendTransOpen">
    /// The <c>CustVendTransOpen</c> table record to find the cash discount date for.
    /// </param>
    /// <returns>
    /// The cash discount date for the given <c>CustVendTransOpen</c> table record.
    /// </returns>
    public CashDiscdate displayCashDiscdate(CustVendTransOpen _custVendTransOpen)
    {
        return this.findCustVendTransCashDiscForDisplay(_custVendTransOpen).CashDiscdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayCashDiscAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the cash discount amount for the given <c>CustVendTransOpen</c> table record.
    /// </summary>
    /// <param name = "_custVendTransOpen">
    /// The <c>CustVendTransOpen</c> table record to find the cash discount amount for.
    /// </param>
    /// <returns>
    /// The cash discount amount for the given <c>CustVendTransOpen</c> table record.
    /// </returns>
    public DiscAmount displayCashDiscAmount(CustVendTransOpen _custVendTransOpen)
    {
        return this.findCustVendTransCashDiscForDisplay(_custVendTransOpen).CashDiscAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editPaymAmountPaymCur</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles the user change of the amount to be paid.
    /// </summary>
    /// <param name="_set">
    ///    A flag indicating whether the amount of the payment amount field is modified.
    /// </param>
    /// <param name="_specTrans">
    ///    The current <c>SpecTrans </c>record buffer.
    /// </param>
    /// <param name="_paymAmountCur">
    ///    The payment amount in the currency of the related payment line.
    /// </param>
    /// <returns>
    ///    The payment amount in the currency of the related payment line.
    /// </returns>
    public PaymAmountCur editPaymAmountPaymCur(
        boolean     _set,
        SpecTrans   _specTrans,
        AmountCur   _paymAmountCur)
    {
        AmountCur                   paymAmountCur;
        CustVendPaymProposalLine    paymProposalLine = this.custVendPaymProposalLine(_specTrans);
        CurrencyExchangeHelper      currencyExchangeHelper;
        CurrencyCode                pmtCompanyMstCurrency = '';
        AmountCur                   interimAmount;
        // <GBR>
        CustVendTransOpen           custVendTransOpen   = custVendTransOpen_ds.cursor();
        // </GBR>

        // This is invoked by changing the amount on the trans open line that is in the payment's currency.
        // The paymAmountPaymCur() edit method is tied to the field and invokes this method to convert the
        // new value to the transaction currency as well as to limit the value to a maximum based upon discounts.
        if (!paymProposalLine)
        {
            return 0;
        }

        if (_set)
        {
            // value was modified - convert the modified payment currency value to transaction currency
            paymAmountCur = this.amountChangeSign(_paymAmountCur);

            if (paymProposalLine.CurrencyCode == _specTrans.Code)
            {
                // same currency code, no conversion necessary
                _specTrans.Balance01 = _paymAmountCur;
            }
            else if (_specTrans.CrossRate != 0)
            {
                // The cross rate represents a direct currency conversion from the trans currency to the payment currency
                // Use the inverse of the cross rate to convert from payment currency to trans currency
                interimAmount = CurrencyExchange::calculateAmount(_paymAmountCur, 100 / _specTrans.CrossRate);

                interimAmount = ((_paymAmountCur / _specTrans.CrossRate) * 100);
                _specTrans.Balance01 = CurrencyExchange::round(interimAmount, _specTrans.Code);
            }
            else
            {
                // convert payment currency amount entered to payment company's MST
                currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(paymProposalLine.AccountNumCompany).RecId),
                                                                     paymProposalLine.PaymDate);
                interimAmount = currencyExchangeHelper.calculateTransactionToAccounting( paymProposalLine.CurrencyCode, _paymAmountCur, false);

                // get the MST currency of the payment company
                changecompany(paymProposalLine.AccountNumCompany)
                {
                    pmtCompanyMstCurrency = CompanyInfoHelper::standardCurrency();
                }

                // convert from payment company's MST to transaction company's MST using transaction company's exchange rate
                currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(_specTrans.RefCompany).RecId),
                                                                     paymProposalLine.PaymDate);
                interimAmount = currencyExchangeHelper.calculateTransactionToAccounting(pmtCompanyMstCurrency,interimAmount,false);

                // convert from transaction company's MST to transaction currency
                _specTrans.Balance01 = currencyExchangeHelper.calculateAccountingToTransaction(_specTrans.Code,interimAmount, true);
            }

            this.fieldModifiedSpecTrans_Balance01Pre();
            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                _specTrans.Balance01 += (custVendTransOpen.FineAmount_BR + custVendTransOpen.InterestAmount_BR);
            }
            // </GBR>
            specTrans_ds.write();
        }

        // convert transaction currency value to the payment currency
        if (paymProposalLine.CurrencyCode == _specTrans.Code)
        {
            // same currency code, no conversion necessary
            paymAmountCur = _specTrans.Balance01;
        }
        else if (_specTrans.CrossRate != 0)
        {
            // The cross rate represents a direct currency conversion from the trans currency to the payment currency
            paymAmountCur = CurrencyExchange::calculateAmount(_specTrans.Balance01, _specTrans.CrossRate);
        }
        else
        {
            // convert from transaction currency amount to transaction MST
            currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(_specTrans.RefCompany).RecId),
                                                                 paymProposalLine.PaymDate);
            interimAmount = currencyExchangeHelper.calculateTransactionToAccounting(_specTrans.Code,_specTrans.Balance01, false);

            if (pmtCompanyMstCurrency == '')
            {
                // get the MST currency of the payment company
                changecompany(paymProposalLine.AccountNumCompany)
                {
                    pmtCompanyMstCurrency = CompanyInfoHelper::standardCurrency();
                }
            }

            // convert from transaction MST to payment MST using the transaction company's exchange rate
            interimAmount = currencyExchangeHelper.calculateAccountingToTransaction(pmtCompanyMstCurrency, interimAmount, false);

            // convert fromp payment MST to payment currency
            currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(paymProposalLine.AccountNumCompany).RecId),
                                                                 paymProposalLine.PaymDate);
            paymAmountCur = currencyExchangeHelper.calculateAccountingToTransaction(paymProposalLine.CurrencyCode,interimAmount, true);
        }

        return paymAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldModified_BarCodeInfo_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Executes code when the user has changed the bar code info.
    /// </summary>
    public  void fieldModified_BarCodeInfo_BR()
    {
        CustVendPaymProposalLine    paymProposalLine = this.custVendPaymProposalLine();
        VendTransPayment_BR         vendTransPayment_BR;

        if (custVendTransPayment_BR_ds.cursor().TableId == tablenum(VendTransPayment_BR))
        {
            vendTransPayment_BR = custVendTransPayment_BR_ds.cursor();
        }

        paymProposalLine.EPTypedLine_BR   = vendTransPayment_BR.TypedLine_BR;
        paymProposalLine.EPBarCodeInfo_BR = vendTransPayment_BR.EPBarCodeInfo_BR;
        paymProposalLine.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldModified_CashDiscToTakePost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes code after the <c>super</c> method is called when the user has changed the cash discount
    ///    to take.
    /// </summary>
    public void fieldModified_CashDiscToTakePost()
    {
        specTrans_ds.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldModified_CashDiscToTakePre</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes code before the <c>super</c> method is called when the user has changed the cash discount
    ///    to take.
    /// </summary>
    /// <remarks>
    ///    Adjusts the amount to the correct sign and makes sure that the amount is not bigger than the
    ///    remaining discount.
    /// </remarks>
    public void fieldModified_CashDiscToTakePre()
    {
        SpecTrans   specTrans = specTrans_ds.cursor();
        CustVendTransOpen custVendTransOpen;
        CustVendTransOpenData custVendTransOpenData;
        CustVendCashDiscountHelper cashDiscountHelper;

        custVendTransOpen = custVendTransOpen_ds.cursor();
        custVendTransOpenData = CustVendTransOpenData::construct(custVendTransOpen);

        cashDiscountHelper = CustVendCashDiscountHelper::construct(custVendTransOpen);

        cashDiscountHelper.parmCashDiscountTaken(
            cashDiscountHelper.parmCashDiscountTaken()
            + custVendTransOpenData.findCashDiscountMarkedToBeTaken()
            - specTrans.orig().CashDiscToTake);

        specTrans.CashDiscToTake = cashDiscountHelper.validateCashDiscToTake(specTrans.CashDiscToTake);

        AmountCur remainingAmount = custVendTransOpenData.findRemainingAmountCur()
            + specTrans.orig().Balance01
            + specTrans.orig().CashDiscToTake;

        this.adjustSettleDiscountAmounts(specTrans, remainingAmount, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldModified_FineAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes code when the user has changed the fine amount.
    /// </summary>
    public void fieldModified_FineAmount_BR()
    {
        CustVendTransOpenData       custVendTransOpenData;
        CustVendTransOpen           custVendTransOpen;
        CustVendTransOpen           custVendTransOpenOld;
        SpecTrans                   specTrans                   = specTrans_ds.cursor();
        CustVendPaymProposalLine    custVendPaymProposalLine    = custVendPaymProposalLine_ds.cursor();

        // As the new value has not yet been saved to the database, this will retieve the last saved record
        switch (custVendTransOpen_ds.cursor().TableId)
        {
            case tablenum(CustTransOpen):
                custVendTransOpenOld = specTrans.custTransOpen();
                break;

            case tablenum(VendTransOpen):
                custVendTransOpenOld = specTrans.vendTransOpen();
                break;

            default:
                Debug::assert(false);
                break;
        }

        // set specTrans balance to current balance minus old fine value
        specTrans.Balance01 = specTrans.Balance01 - custVendTransOpenOld.FineAmount_BR;
        // Write entered value
        custVendTransOpen_ds.write();
        custVendTransOpen_ds.reread();
        custVendTransOpen_ds.refresh();
        custVendTransOpen = custVendTransOpen_ds.cursor();

        custVendTransOpenData = CustVendTransOpenData::construct(custVendTransOpen_ds.cursor());

        // Update specTrans with new balance
        specTrans.Balance01 = specTrans.Balance01 + custVendTransOpen.FineAmount_BR;

        // Updating Interest Amount Cur
        custVendTransOpen.FineAmountPaymCur_BR = CustVendPaymProposalEditForm::convertAmountTransCurToAmountPaymCur_BR(
                                                                            custVendTransOpen.FineAmount_BR,
                                                                            specTrans.RefCompany,
                                                                            custVendTransOpenData.custVendTrans().CurrencyCode,
                                                                            specTrans.SpecCompany,
                                                                            custVendPaymProposalLine.CurrencyCode,
                                                                            custVendPaymProposalLine.PaymDate,
                                                                            specTrans.CrossRate);

        custVendTransOpen.update();
        custVendTransOpen_ds.reread();
        custVendTransOpen_ds.refresh();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldModified_FineCodeDueDate_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes code when the user has changed the Fine Code or due date.
    /// </summary>
    public void fieldModified_FineCodeDueDate_BR()
    {
        CustVendTransOpenData       custVendTransOpenData;
        CustVendPaymProposalLine    custVendPaymProposalLine    = custVendPaymProposalLine_ds.cursor();
        CustVendTransOpen           custVendTransOpen           = custVendTransOpen_ds.cursor();

        CustVendFine_BR      custVendFine;
        FineCalculator_BR    fineCalculator;

        custVendTransOpen_ds.write();
        custVendTransOpen_ds.reread();
        custVendTransOpen_ds.refresh();

        custVendTransOpenData = CustVendTransOpenData::construct(custVendTransOpen_ds.cursor());

        custVendFine     = custVendTransOpen.CustVendTransOpen::custVendFine_BR();

        if (!custVendTransOpenData.parmCustVendTransOpen().FineCode_BR)
        {
            custVendTransOpen.FineAmount_BR = 0;
        }
        else
        {
            fineCalculator  = new FineCalculator_BR(custVendFine,
                                                    custVendPaymProposalLine.PaymDate,
                                                    custVendTransOpen.DueDate,
                                                    custVendTransOpen.AmountCur,
                                                    custVendTransOpenData.custVendTrans().CurrencyCode,
                                                    custVendTransOpen.getCalendarDerivation_BR());

            custVendTransOpen.FineAmount_BR = fineCalculator.calculate();
            if (custVendFine.TableId == tableNum(CustFineSetup_BR))
            {
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceBR00066, funcName());
            }
            else
            {
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceBR00065, funcName());
            }
        }
        this.adjustInterestFineEdition_BR();
        this.fieldModified_FineAmount_BR();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldModified_InterestAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes code when the user has changed the Interest amount.
    /// </summary>
    public  void fieldModified_InterestAmount_BR()
    {
        CustVendTransOpenData       custVendTransOpenData;
        CustVendTransOpen           custVendTransOpen;
        CustVendTransOpen           custVendTransOpenOld;
        SpecTrans                   specTrans                   = specTrans_ds.cursor();
        CustVendPaymProposalLine    custVendPaymProposalLine    = custVendPaymProposalLine_ds.cursor();

        // As the new value has not yet been saved to the database, this will retieve the last saved record
        switch (custVendTransOpen_ds.cursor().TableId)
        {
            case tablenum(CustTransOpen):
                custVendTransOpenOld = specTrans.custTransOpen();
                break;

            case tablenum(VendTransOpen):
                custVendTransOpenOld = specTrans.vendTransOpen();
                break;

            default:
                Debug::assert(false);
                break;
        }

        // set specTrans balance to current balance minus old interest value
        specTrans.Balance01 = specTrans.Balance01 - custVendTransOpenOld.InterestAmount_BR;

        // Write entered value
        custVendTransOpen_ds.write();
        custVendTransOpen_ds.reread();
        custVendTransOpen_ds.refresh();
        custVendTransOpen = custVendTransOpen_ds.cursor();

        custVendTransOpenData = CustVendTransOpenData::construct(custVendTransOpen_ds.cursor());

        // Update specTrans with new balance
        specTrans.Balance01 = specTrans.Balance01 + custVendTransOpen.InterestAmount_BR;

        // Updating Interest Amount Cur
        custVendTransOpen.InterestAmountPaymCur_BR = CustVendPaymProposalEditForm::convertAmountTransCurToAmountPaymCur_BR(
                                                                            custVendTransOpen.InterestAmount_BR,
                                                                            specTrans.RefCompany,
                                                                            custVendTransOpenData.custVendTrans().CurrencyCode,
                                                                            specTrans.SpecCompany,
                                                                            custVendPaymProposalLine.CurrencyCode,
                                                                            custVendPaymProposalLine.PaymDate,
                                                                            specTrans.CrossRate);

        custVendTransOpen.update();
        custVendTransOpen_ds.reread();
        custVendTransOpen_ds.refresh();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldModified_InterestCodeDueDate_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes code when the user has changed the Interest Code or due date.
    /// </summary>
    public void fieldModified_InterestCodeDueDate_BR()
    {
        CustVendTransOpenData       custVendTransOpenData;
        CustVendPaymProposalLine    custVendPaymProposalLine    = custVendPaymProposalLine_ds.cursor();
        CustVendTransOpen           custVendTransOpen           = custVendTransOpen_ds.cursor();

        CustVendInterest_BR      custVendFinInterest;
        InterestCalculator_Br    finInterestCalculator;

        custVendTransOpen_ds.write();

        custVendTransOpen_ds.reread();
        custVendTransOpen_ds.refresh();

        custVendTransOpenData = CustVendTransOpenData::construct(custVendTransOpen_ds.cursor());

        custVendFinInterest     = custVendTransOpen.custVendTransOpen::custVendInterest_BR();

        if (!custVendTransOpenData.parmCustVendTransOpen().InterestCode_BR)
        {
            custVendTransOpen.InterestAmount_BR = 0;
        }
        else
        {
            finInterestCalculator  = new InterestCalculator_Br(custVendFinInterest,
                                                               custVendPaymProposalLine.PaymDate,
                                                               custVendTransOpen.DueDate,
                                                               custVendTransOpen.AmountCur,
                                                               custVendTransOpenData.custVendTrans().CurrencyCode,
                                                               custVendTransOpen.getCalendarDerivation_BR());

            custVendTransOpen.InterestAmount_BR = finInterestCalculator.calculate();
            if (custVendFinInterest.TableId == tableNum(CustInterestSetup_BR))
            {
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceBR00066, funcName());
            }
            else
            {
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceBR00065, funcName());
            }
        }
        this.adjustInterestFineEdition_BR();
        this.fieldModified_InterestAmount_BR();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldModifiedCashDisc_CashDiscDate</Name>
				<Source><![CDATA[
    public void fieldModifiedCashDisc_CashDiscDate()
    {
        CustVendCreatePaymProposalType paymProposalCalcPaymDatePrinciple;

        paymProposalCalcPaymDatePrinciple = paymProposal.parmPaymProposalCalcPaym().parmPaymDatePrinciple();

        if (paymProposalCalcPaymDatePrinciple == CustVendCreatePaymProposalType::CashDisc ||
            paymProposalCalcPaymDatePrinciple == CustVendCreatePaymProposalType::DueDateAndCashDisc)
        {
            custVendTransCashDisc_ds.write();

            mustRecalcPaymDate  = true;

            specTrans_ds.reread();
            specTrans_ds.write();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldModifiedCashDisc_CashDiscDateAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes code when the user has changed the cash discount amount.
    /// </summary>
    public void fieldModifiedCashDisc_CashDiscDateAmount()
    {
        CustVendTransOpenData       custVendTransOpenData;
        SpecTrans                   specTrans                = specTrans_ds.cursor();
        CustVendTransOpen           custVendTransOpen;
        CustVendPaymProposalLine    custVendPaymProposalLine = custVendPaymProposalLine_ds.cursor();
        CustVendPaymModeTable       custVendPaymModeTable;
        CustVendCashDiscountHelper  cashDiscountHelper;

        custVendTransCashDisc_ds.write();
        // the above write invokes an update on the Cust/VendTransOpen table
        // need to reset the CustVendTransOpen datasource to get the updated data
        custVendTransOpen_ds.reread();
        custVendTransOpen_ds.refresh();

        custVendTransOpenData = CustVendTransOpenData::construct(custVendTransOpen_ds.cursor());

        if (BrazilParameters::isEnabled())
        {
            specTrans.Balance01 = custVendTransOpenData.remainAmountCashDisc(
                this.custVendPaymProposalLine().PaymDate,
                0,
                false,
                specTrans.orig().Balance01,
                specTrans.orig().CashDiscToTake);
        }
        else
        {
            specTrans.Balance01 = custVendTransOpenData.remainAmountCashDisc(
                this.custVendPaymProposalLine().PaymDate,
                0,
                true,
                specTrans.orig().Balance01,
                specTrans.orig().CashDiscToTake);
        }

        specTrans.Balance01 = this.amountChangeSign(specTrans.Balance01);
        specTrans.Balance01 = this.maxSpecAmount(specTrans.Balance01);

        custVendTransOpen = custVendTransOpen_ds.cursor();
        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            specTrans.Balance01 += (custVendTransOpenData.custVendTransOpen().FineAmount_BR + custVendTransOpenData.custVendTransOpen().InterestAmount_BR);
        }
        // </GBR>
        changecompany(custVendTransOpen.company())
        {
            cashDiscountHelper = CustVendCashDiscountHelper::construct(custVendTransOpen);
            cashDiscountHelper.parmDiscountDate(custVendPaymProposalLine.PaymDate);
            custVendPaymModeTable = custVendPaymProposalLine.paymModeTable();
            cashDiscountHelper.parmGraceDays(custVendPaymModeTable.DiscGraceDays);

            cashDiscountHelper.parmRemainingOpenBalance(
                custVendTransOpenData.findRemainingAmountCur()
                + specTrans.orig().Balance01);

            specTrans.CashDiscToTake = cashDiscountHelper.determineCashDiscForPartialSettlement(specTrans.Balance01);
        }

        custVendTransOpenData.setCashDisc(custVendPaymProposalLine.PaymDate,
                                          CustPaymModeTable::discGraceDays(custVendPaymProposalLine.PaymMode));

        custVendTransOpenData.custVendTransOpen().update();

        // this method is invoked in the company context of the currently selected transaction, this may be a different
        // company than the associated proposal line, ensure the proposal line datasource write method is invoked in the
        // proper company context
        changecompany(this.parmPaymProposal().parmLedgerJournalTableCompany())
        {
            custVendPaymProposalLine_ds.write();
        }

        specTrans_ds.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldModifiedPaymLine_AccountNumCompPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes code after the <c>super</c> method is called when the user has changed the customer or
    /// vendor company of the payment proposal.
    /// </summary>
    /// <remarks>
    /// This method is generally invoked by a <c>modified</c> override method after the call to the
    /// <c>super</c> method.
    /// </remarks>
    public void fieldModifiedPaymLine_AccountNumCompPost()
    {
        // Invoking custVendPaymProposalLine_ds.refresh() will not cause the display methods from CustVendPaymProposalLine
        // to be invoked due to them being cached on the datasource via CustVendPaymProposalLine_ds.addCacheMethod().
        // Invoking custVendPaymProposalLine_ds.write() will force recalculation and redisplay of the values tied to
        // display methods on CustVendPaymProposalLine. When focus leaves the modified line, write is not invoked again
        // thus the display methods are only invoked a single time.
        custVendPaymProposalLine_ds.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldModifiedSpecTrans_Balance01Post</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes code after <c>super()</c> is called when the user has changed the amount to be paid.
    /// </summary>
    public void fieldModifiedSpecTrans_Balance01Post()
    {
        specTrans_ds.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldModifiedSpecTrans_Balance01Pre</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes code before <c>super()</c> is called when the user has changed the amount to be paid.
    /// </summary>
    /// <remarks>
    ///    Adjusts the amount to the correct sign and makes sure that the amount is not bigger than the
    ///    remaining amount of the transaction.
    /// </remarks>
    public void fieldModifiedSpecTrans_Balance01Pre()
    {
        SpecTrans   specTrans = specTrans_ds.cursor();
        CustVendTransOpen custVendTransOpen;
        CustVendTransOpenData custVendTransOpenData;
        CustVendPaymModeTable       custVendPaymModeTable;
        CustVendPaymProposalLine    paymProposalLine = this.custVendPaymProposalLine();
        CustVendCashDiscountHelper  cashDiscountHelper;

        specTrans.Balance01 = this.amountChangeSign(specTrans.Balance01);
        specTrans.Balance01 = this.maxSpecAmount(specTrans.Balance01);

        custVendTransOpen = custVendTransOpen_ds.cursor();
        custVendTransOpenData = CustVendTransOpenData::construct(custVendTransOpen);

        if (BrazilParameters::isEnabled())
        {
            specTrans.Balance01 += (custVendTransOpen.FineAmount_BR + custVendTransOpen.InterestAmount_BR);
        }

        changecompany(custVendTransOpen.company())
        {
            custVendPaymModeTable = paymProposalLine.paymModeTable();

            cashDiscountHelper = CustVendCashDiscountHelper::construct(custVendTransOpen);
            cashDiscountHelper.parmDiscountDate(paymProposalLine.PaymDate);
            cashDiscountHelper.parmGraceDays(custVendPaymModeTable.DiscGraceDays);

            cashDiscountHelper.parmCashDiscountTaken(
                cashDiscountHelper.parmCashDiscountTaken()
                + custVendTransOpenData.findCashDiscountMarkedToBeTaken()
                - specTrans.orig().CashDiscToTake);

            cashDiscountHelper.parmRemainingOpenBalance(
                custVendTransOpenData.findRemainingAmountCur()
                + specTrans.orig().Balance01);

            specTrans.CashDiscToTake = cashDiscountHelper.determineCashDiscForPartialSettlement(specTrans.Balance01);
        }

        AmountCur remainingAmount = custVendTransOpenData.findRemainingAmountCur()
            + specTrans.orig().Balance01
            + specTrans.orig().CashDiscToTake;

        this.adjustSettleDiscountAmounts(specTrans, remainingAmount, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldModifiedTrans_DueDatePost</Name>
				<Source><![CDATA[
    public void fieldModifiedTrans_DueDatePost()
    {
        CustVendCreatePaymProposalType paymProposalCalcPaymDatePrinciple;

        paymProposalCalcPaymDatePrinciple = paymProposal.parmPaymProposalCalcPaym().parmPaymDatePrinciple();

        if (paymProposalCalcPaymDatePrinciple == CustVendCreatePaymProposalType::DueDate ||
            paymProposalCalcPaymDatePrinciple == CustVendCreatePaymProposalType::DueDateAndCashDisc)
        {
            mustRecalcPaymDate = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldModifiedTrans_PaymIdPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes code after the user has changed the payment ID of a transaction.
    /// </summary>
    public void fieldModifiedTrans_PaymIdPost()
    {
        custVendTrans_ds.refresh();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldModifiedTrans_PaymModePost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes code after the user has changed the method of payment of a transaction.
    /// </summary>
    public void fieldModifiedTrans_PaymModePost()
    {
        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            this.parmCheckPaymMode_BR(true);
        }
        // </GBR>

        mustRecalcPaymDate = true;

        custVendTrans_ds.refresh();
        // <GBR>
        if (BrazilParameters::isEnabled() &&
            custTransEPRemit_BR_DS)
        {
            custTransEPRemit_BR_DS.refresh();
        }
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldModifiedTrans_RemittanceLocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes the code when the user has changed the value of the <c>RemittanceLocation</c> field.
    /// </summary>
    public void fieldModifiedTrans_RemittanceLocation()
    {
        //require recalculation of the proposal
        mustRecalcPaymDate = true;

        //trigger the recalc
        custVendTrans_ds.refresh();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldModifiedTrans_VendPaymentGroup</Name>
				<Source><![CDATA[
    public void fieldModifiedTrans_VendPaymentGroup()
    {
        //require recalculation of the proposal
        mustRecalcPaymDate = true;

        //trigger the recalc
        custVendTrans_ds.refresh();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustVendTransCashDiscForDisplay</Name>
				<Source><![CDATA[
    private CustVendTransCashDisc findCustVendTransCashDiscForDisplay(CustVendTransOpen _custVendTransOpen)
    {
        CustVendPaymProposalLine custVendPaymProposalLineLocal;

        select firstonly custVendPaymProposalLineLocal
            where custVendPaymProposalLineLocal.AccountType == ledgerJournalModuleCustVend
                && custVendPaymProposalLineLocal.TransOpenRecId == _custVendTransOpen.RecId;

        CustVendTransCashDisc custVendTransCashDiscLocal = this.findCustVendTransCashDisc(_custVendTransOpen, custVendPaymProposalLineLocal);
        if (!custVendTransCashDiscLocal)
        {
            custVendTransCashDiscLocal = this.findLastPossibleCustVendTransCashDisc(_custVendTransOpen);
        }

        return custVendTransCashDiscLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustVendTransCashDisc</Name>
				<Source><![CDATA[
    private CustVendTransCashDisc findCustVendTransCashDisc(CustVendTransOpen _custVendTransOpen, CustVendPaymProposalLine _custVendPaymProposalLine)
    {
        CustVendTransCashDisc custVendTransCashDiscLocal;

        changecompany(_custVendTransOpen.company())
        {
            custVendTransCashDiscLocal = CustVendTransCashDisc::findByUseCashDisc(
                ledgerJournalModuleCustVend,
                _custVendTransOpen.TableId,
                _custVendTransOpen.RecId,
                _custVendTransOpen.UseCashDisc,
                _custVendPaymProposalLine.PaymDate,
                VendPaymModeTable::discGraceDays(_custVendPaymProposalLine.PaymMode));
        }

        return custVendTransCashDiscLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLastPossibleCustVendTransCashDisc</Name>
				<Source><![CDATA[
    private CustVendTransCashDisc findLastPossibleCustVendTransCashDisc(CustVendTransOpen _custVendTransOpen)
    {
        CustVendTransCashDisc custVendTransCashDiscLocal;

        changecompany(_custVendTransOpen.company())
        {
            custVendTransCashDiscLocal = CustVendTransCashDisc::findLastCashDisc(
                ledgerJournalModuleCustVend,
                _custVendTransOpen.TableId,
                _custVendTransOpen.RecId);
        }

        return custVendTransCashDiscLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formClosePost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes code after the payment proposal form has been closed.
    /// </summary>
    /// <remarks>
    ///    Clears the payment proposal if this option is selected when the payment proposal form is opened.
    /// </remarks>
    public void formClosePost()
    {
        if (clearProposalWhenClosing)
        {
            container inputParameters = [classIdGet(paymProposal), paymProposal.pack()];

            container result;
            System.InvalidOperationException ex;
            try
            {
                result = SysOperationSandbox::callStaticMethod(
                classNum(CustVendPaymProposal),
                staticMethodStr(CustVendPaymProposal, deleteLinesStatic),
                inputParameters,
                "@SYS104846");
            }
            catch (ex)
            {
                result = CustVendPaymProposal::deleteLinesStatic(inputParameters);
            }

            container paymProposalPack;
            [paymProposalPack] = result;
            paymProposal.unpack(paymProposalPack);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>formInitPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes code after <c>init</c> is called on the payment proposal form.
    /// </summary>
    /// <remarks>
    ///    Initializes this object.
    /// </remarks>
    public void formInitPost()
    {
        this.initDatasourceAllow();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymCustVendForSelectedCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets a customer or vendor account number based on a change in the <c>AccountNumCompany</c> value of
    ///    the <c>CustVendPaymProposalLine</c> table.
    /// </summary>
    /// <returns>
    ///    The account number of the customer or vendor in the selected company if found; otherwise empty.
    /// </returns>
    /// <remarks>
    ///    This method is intended to be invoked when the <c>AccountNumCompany</c> value of the current
    ///    payment proposal is modified.
    /// </remarks>
    public CustVendAC getPaymCustVendForSelectedCompany()
    {
        boolean isNewCompanyInSharedServiceBoundary;
        container companies;
        CustVendAC newAccountNum;
        DirPartyRecId party;
        CustVendPaymProposalLine custVendPaymProposalLine;
        CompanyId previousAccountNumCompany;
        CompanyId newAccountNumCompany;
        CustVendAC currentAccountNum;
        CustVendTable custVendTable;

        custVendPaymProposalLine = custVendPaymProposalLine_ds.cursor();
        previousAccountNumCompany = custVendPaymProposalLine.orig().AccountNumCompany;
        newAccountNumCompany = custVendPaymProposalLine.AccountNumCompany;
        currentAccountNum = custVendPaymProposalLine.AccountNum;

        // verify that the new company is within the shared service boundary of the current company as well as
        // within the same directory
        companies = CustVendOpenTransManager::findSharedServiceCompanies(previousAccountNumCompany);
        isNewCompanyInSharedServiceBoundary = confind(companies, newAccountNumCompany);

        if (isNewCompanyInSharedServiceBoundary)
        {
            // Verify that the new company contains a customer/vendor with the same Party as the current customer/vendor.

            changecompany(previousAccountNumCompany)
            {
                custVendTable = custVendTransStatic.custVendTable();
                select firstonly Party from custVendTable
                    where custVendTable.AccountNum == currentAccountNum;
            }
            party = custVendTable.Party;

            if (party != 0)
            {
                changecompany(newAccountNumCompany)
                {
                    custVendTable = custVendTransStatic.custVendTable();
                    select firstonly AccountNum from custVendTable
                        where custVendTable.Party == party;
                }
                newAccountNum = custVendTable.AccountNum;
            }
        }

        return newAccountNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    public void init(ModuleCustVend  _moduleCustVend = ModuleCustVend::Cust)
    {
        Args                args;
        menuItemNameDisplay menuItemNameDisplay;
        MenuFunction        menuFunction;
        ModuleCustVend      moduleCustVend;
        FormRun             startFormRun;

        if (prmisdefault(_moduleCustVend) && paymProposal)
        {
            moduleCustVend = ledgerJournalModuleCustVend;
        }
        else
        {
            moduleCustVend = _moduleCustVend;
        }

        args = new Args();
        args.caller(this);

        switch (moduleCustVend)
        {
            case ModuleCustVend::Cust :
                menuItemNameDisplay = menuitemdisplaystr(CustPaymProposalEdit);
                break;

            case ModuleCustVend::Vend :
                menuItemNameDisplay = menuitemdisplaystr(VendPaymProposalEdit);
                break;

            default :
                throw error(Error::wrongUseOfFunction(funcname()));
        }

        menuFunction = new MenuFunction(menuItemNameDisplay, MenuItemType::Display);
        startFormRun = menuFunction.create(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDatasourceAllow</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes permissions on the data sources of the payment proposal form.
    /// </summary>
    public void initDatasourceAllow()
    {
        if (custVendPaymProposalLine_ds)
        {
            custVendPaymProposalLine_ds.allowCreate(false);
            custVendPaymProposalLine_ds.allowDelete(false);
            custVendPaymProposalLine_ds.allowEdit(true);
        }

        if (specTrans_ds)
        {
            specTrans_ds.allowCreate(false);
            specTrans_ds.object(fieldnum(SpecTrans, Code)).allowEdit(false);
        }

        if (custVendTransOpen_ds)
        {
            custVendTransOpen_ds.allowCreate(false);
            custVendTransOpen_ds.allowDelete(false);
            custVendTransOpen_ds.object(custVendTransStatic.transOpenFieldIdCashDiscDate()).allowEdit(true);
            custVendTransOpen_ds.object(custVendTransStatic.transOpenFieldIdCashDiscAmount()).allowEdit(true);
        }

        if (custVendTrans_ds)
        {
            custVendTrans_ds.allowCreate(false);
            custVendTrans_ds.allowDelete(false);
        }

        if (custVendTransCashDisc_ds)
        {
            custVendTransCashDisc_ds.allowCreate(false);
            custVendTransCashDisc_ds.allowDelete(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>jumpRefCustVendTable</Name>
				<Source><![CDATA[
    public void jumpRefCustVendTable(CustVendAC _custVendAccount)
    {
        Args args = new Args();
        MenuFunction menuFunction;
        switch (ledgerJournalModuleCustVend)
        {
            case ModuleCustVend::Cust :
                args.record(CustTable::find(_custVendAccount));
                menuFunction = new MenuFunction(menuitemDisplayStr(CustTable), MenuItemType::Display);
                break;

            case ModuleCustVend::Vend :
                menuFunction = new MenuFunction(menuitemDisplayStr(VendTable), MenuItemType::Display);
                args.record(VendTable::find(_custVendAccount));
                break;
        }

        args.parmEnum(NoYes::Yes);
        menuFunction.run(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueDataAreaId</Name>
				<Source><![CDATA[
    public dataAreaId lastValueDataAreaId()
    {
        return curext();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueDesignName</Name>
				<Source><![CDATA[
    public identifierName lastValueDesignName()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueDesignNameForLedgerTrans</Name>
				<Source><![CDATA[
    public identifierName lastValueDesignNameForLedgerTrans(LedgerJournalTrans _ledgerJournalTrans = null)
    {
        if (_ledgerJournalTrans)
        {
            return enum2str(LedgerJournalName::journalType2ModuleCustVend(
                                LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalType));
        }

        return enum2str(ledgerJournalModuleCustVend);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueElementName</Name>
				<Source><![CDATA[
    public identifierName lastValueElementName()
    {
        return classId2Name(classidget(this));
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueType</Name>
				<Source><![CDATA[
    public UtilElementType lastValueType()
    {
        return UtilElementType::Class;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueUserId</Name>
				<Source><![CDATA[
    public userId lastValueUserId()
    {
        return curuserid();
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxSpecAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts the amount entered for payment to the maximum allowed amount to pay.
    /// </summary>
    /// <param name="_specAmount">
    ///    The entered amount in the current payment for payment.
    /// </param>
    /// <returns>
    ///    The entered amount or an amount adjusted to the maximum allowed amount.
    /// </returns>
    /// <remarks>
    ///    Checks that the user does not try to enter payments for a larger amount than the actual open amount
    ///    of the transaction.
    /// </remarks>
    public AmountCur maxSpecAmount(AmountCur _specAmount)
    {
        CustVendPaymProposalLine    paymProposalLine = this.custVendPaymProposalLine();
        CustVendPaymModeTable       custVendPaymModeTable;
        CustVendTransOpenData       custVendTransOpenData;
        CustVendTransOpen           custVendTransOpen;
        AmountCur                   amountCurRemaining;
        AmountCur                   amountMax       = _specAmount;
        UnspecificSpecific cashDiscUnspecificSpecific;
        CustParameters custParameters;
        VendParameters vendParameters;

        custVendTransOpen = custVendTransOpen_ds.cursor();

        changecompany(custVendTransOpen.company())
        {
            // Get the specific/unspecific setting for the transaction company
            switch (custVendTransOpen.TableId)
            {
                case tablenum(CustTransOpen):
                    custParameters = CustParameters::find();
                    cashDiscUnspecificSpecific = custParameters.CashDisc;
                    break;

                case tablenum(VendTransOpen):
                    vendParameters = VendParameters::find();
                    cashDiscUnspecificSpecific =  vendParameters.CashDisc;
                    break;
            }

            custVendPaymModeTable = paymProposalLine.paymModeTable();

            custVendTransOpenData = CustVendTransOpenData::construct(custVendTransOpen);

            SpecTrans specTrans = specTrans_ds.cursor().orig();

            if (BrazilParameters::isEnabled())
            {
                amountCurRemaining = custVendTransOpenData.findSettlementAmount(
                    _specAmount,
                    cashDiscUnspecificSpecific,
                    paymProposalLine.PaymDate,
                    false,
                    specTrans.Balance01,
                    specTrans.CashDiscToTake);
            }
            else
            {
                amountCurRemaining = custVendTransOpenData.findSettlementAmount(
                    _specAmount,
                    cashDiscUnspecificSpecific,
                    paymProposalLine.PaymDate,
                    true,
                    specTrans.Balance01,
                    specTrans.CashDiscToTake);
            }
        }

        if (abs(_specAmount) > abs(amountCurRemaining))
        {
            amountMax = amountCurRemaining;
        }

        return amountMax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifyPaymProposalAccounNumCompanyLookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Modifies the company lookup used to select the <c>AccountNumCompany</c> field on the current
    ///    <c>CustVendPaymProposalLine</c> record.
    /// </summary>
    /// <param name="_companyLookupForm">
    ///    The autogenerated lookup form for the <c>CompanyId</c> extended data type.
    /// </param>
    /// <remarks>
    ///    This method is intended to be invoked from the <c>performFormLookup</c> method override of a
    ///    <c>CompanyId</c> field on a <c>CustVendPaymProposalLine</c> record.This method will modify the
    ///    autogenerated query associated with the supplied <c>FormRun</c> lookup form.It will limit the
    ///    listed companies to those that have a customer or vendor associated with the customer or vendor of
    ///    the current <c>CustVendPaymProposalLine</c> record and are part of the same shared service boundary.
    /// </remarks>
    public void modifyPaymProposalAccounNumCompanyLookup(FormRun _companyLookupForm)
    {
        FormDataSource formDataSource;
        Query companyLookupQuery;
        QueryBuildDataSource qbdsDataArea;
        str companyLookupQueryRange;

        DataArea dataArea;
        VirtualDataAreaList virtualDataAreaList;
        DirPartyRecId proposalAccountParty;
        container companies;

        CustVendPaymProposalLine custVendPaymProposalLine;
        CustVendTable custVendTable;

        custVendPaymProposalLine = custVendPaymProposalLine_ds.cursor();
        changecompany(custVendPaymProposalLine.AccountNumCompany)
        {
            custVendTable = custVendTransStatic.custVendTable();

            select firstonly Party, DataAreaId from custVendTable
                where custVendTable.AccountNum == custVendPaymProposalLine.AccountNum;

            proposalAccountParty = custVendTable.Party;
        }

        //
        // If the cust/vend table is shared then the company lookup should include all concrete companies that share the cust/vend table
        //
        select firstonly IsVirtual from dataArea
            where dataArea.Id == custVendTable.DataAreaId;

        if (dataArea.IsVirtual)
        {
            while select Id from virtualDataAreaList
                where virtualDataAreaList.VirtualDataArea == custVendTable.DataAreaId
            {
                companyLookupQueryRange = queryRangeConcat(companyLookupQueryRange, virtualDataAreaList.Id);
            }
        }

        //
        // If the cust/vend account is mapped via directory then the company lookup should include all companies which contain a cust/vend
        // that is mapped to the current cust/vend
        //
        companies = CustVendOpenTransManager::findSharedServiceCompanies(custVendPaymProposalLine.AccountNumCompany);
        while select crossCompany:companies custVendTable
            where custVendTable.Party == proposalAccountParty
        {
            select firstonly IsVirtual from dataArea
                where dataArea.Id == custVendTable.DataAreaId;

            if (dataArea.IsVirtual)
            {
                // the cust/vend table is shared, extend the list of companies in the lookup to include all concrete companies that
                // share the cust/vend table
                while select Id from virtualDataAreaList
                    where virtualDataAreaList.VirtualDataArea == custVendTable.DataAreaId
                {
                    companyLookupQueryRange = queryRangeConcat(companyLookupQueryRange, virtualDataAreaList.Id);
                }
            }
            else
            {
                companyLookupQueryRange = queryRangeConcat(companyLookupQueryRange, custVendTable.company());
            }
        }

        //
        // Add a range to the lookup form's query to include only those companies identified as having a cust/vend that is associated with
        // the current cust/vend
        //
        formDataSource = _companyLookupForm.objectSet();
        companyLookupQuery = formDataSource.query();
        qbdsDataArea = companyLookupQuery.dataSourceTable(tablenum(DataArea));
        qbdsDataArea.addRange(fieldnum(DataArea, Id)).value(companyLookupQueryRange);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanEditPaymProposalLineCompany</Name>
				<Source><![CDATA[
    public boolean parmCanEditPaymProposalLineCompany()
    {
        boolean canEdit;

        canEdit = configurationkeynum(LedgerAdvIntercompanyAccounting) &&
                  ledgerJournalType != LedgerJournalType::CustBillOfExchangeAccept &&
                  ledgerJournalType != LedgerJournalType::CustBillOfExchangeDraw &&
                  ledgerJournalType != LedgerJournalType::CustBillOfExchangeProtest &&
                  ledgerJournalType != LedgerJournalType::CustBillOfExchangeRedraw &&
                  ledgerJournalType != LedgerJournalType::CustBillOfExchangeSettle &&
                  ledgerJournalType != LedgerJournalType::CustPaymRemittance &&
                  ledgerJournalType != LedgerJournalType::VendPromissoryNoteDraw &&
                  ledgerJournalType != LedgerJournalType::VendPromissoryNoteRedraw &&
                  ledgerJournalType != LedgerJournalType::VendPromissoryNoteSettle &&
                  ledgerJournalType != LedgerJournalType::VendPaymRemittance;

        return canEdit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckPaymMode_BR</Name>
				<Source><![CDATA[
    public boolean parmCheckPaymMode_BR(boolean _checkPaymMode = checkPaymMode)
    {
        checkPaymMode = _checkPaymMode;

        return checkPaymMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransferInBatch</Name>
				<Source><![CDATA[
    internal boolean parmTransferInBatch(boolean _transferInBatch = transferInBatch)
    {
        transferInBatch = _transferInBatch;

        return transferInBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmClearProposalWhenClosing</Name>
				<Source><![CDATA[
    public boolean parmClearProposalWhenClosing(boolean _clearProposalWhenClosing = clearProposalWhenClosing)
    {
        clearProposalWhenClosing = _clearProposalWhenClosing;

        return clearProposalWhenClosing;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCtrlBtnModifyPaymAttributes</Name>
				<Source><![CDATA[
    public FormFunctionButtonControl parmCtrlBtnModifyPaymAttributes(FormFunctionButtonControl _ctrlBtnModifyPaymAttributes = ctrlBtnModifyPaymAttributes)
    {
        ctrlBtnModifyPaymAttributes = _ctrlBtnModifyPaymAttributes;

        return ctrlBtnModifyPaymAttributes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOKButton</Name>
				<Source><![CDATA[
    public FormFunctionButtonControl parmOKButton(FormFunctionButtonControl _okButton = okButton)
    {
        okButton = _okButton;

        return okButton;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFormRun</Name>
				<Source><![CDATA[
    public void parmFormRun(FormRun  _formRun)
    {
        formRun         = _formRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalTrans_ds</Name>
				<Source><![CDATA[
    public FormDataSource parmLedgerJournalTrans_ds(FormDataSource _ledgerJournalTrans_ds = ledgerJournalTrans_ds)
    {
        ledgerJournalTrans_ds = _ledgerJournalTrans_ds;

        return ledgerJournalTrans_ds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymProposal</Name>
				<Source><![CDATA[
    public CustVendPaymProposal parmPaymProposal(CustVendPaymProposal _paymProposal = paymProposal)
    {
        paymProposal                = _paymProposal;

        if (!prmisDefault(_paymProposal))
        {
            ledgerJournalId             = paymProposal.ledgerJournalId();
            ledgerJournalType           = paymProposal.ledgerJournalType();
            ledgerJournalModuleCustVend = paymProposal.moduleCustVend();
        }

        return paymProposal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipUserInteractionDuringSpecTransDelete</Name>
				<Source><![CDATA[
    public boolean parmSkipUserInteractionDuringSpecTransDelete(boolean _skipUserInteractionDuringSpecTransDelete = skipUserInteractionDuringSpecTransDelete)
    {
        skipUserInteractionDuringSpecTransDelete = _skipUserInteractionDuringSpecTransDelete;

        return skipUserInteractionDuringSpecTransDelete;
    }

]]></Source>
			</Method>
			<Method>
				<Name>promptUserToProceedWithDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prompts the user with the option to continue deleting
    /// marked invoices.
    /// </summary>
    /// <param name="_multipleRecords">
    /// If true, the message that is presented to the user will be tailored
    /// for deleting multiple records; otherwise, it will be for deleting a single record.
    /// </param>
    /// <returns>
    /// True if the user wants to proceed; otherwise, false.
    /// </returns>
    public boolean promptUserToProceedWithDelete(boolean _multipleRecords = false)
    {
        str message = _multipleRecords ? "@CashManagement:RemoveInvoicesFromPaymProposal" : "@CashManagement:RemoveInvoiceFromPaymProposal";

        DialogButton userResponse = Box::yesNo(
            message,
            DialogButton::No,
            formRun.design().caption(),
            '');

        return userResponse == DialogButton::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendPaymProposalLinePostInit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds ranges to the queries of the form.
    /// </summary>
    public void custVendPaymProposalLinePostInit()
    {
        custVendPaymProposalLine_ds.queryBuildDataSource().addRange(fieldnum(CustVendPaymProposalLine, JournalId)).value(ledgerJournalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        if (CustVendPaymProposal::doesJournalContainAnyPaymentProposalLines(ledgerJournalId))
        {
            formRun.run();
            formRun.wait();
        }
        else
        {
            info("@SYS93093");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymProposal</Name>
				<Source><![CDATA[
    private void setPaymProposal(
        CustVendPaymProposal _paymProposal,
        ledgerJournalId      _ledgerJournalId,
        ledgerJournalType    _ledgerJournalType,
        ModuleCustVend       _moduleCustVend)
    {
        // Set the fields explicitly without referencing any internal
        // values to avoid any extra RPC's since paymProposal is
        // a server tier object
        paymProposal                = _paymProposal;
        ledgerJournalId             = _ledgerJournalId;
        ledgerJournalType           = _ledgerJournalType;
        ledgerJournalModuleCustVend = _moduleCustVend;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField_CashDiscAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates the cash discount amount.
    /// </summary>
    /// <param name="_cashDiscAmount">
    ///     The cash discount amount in transaction currency.
    /// </param>
    /// <param name="_transactionAmountCur">
    ///     The transaction amount.
    /// </param>
    /// <returns>
    ///     true if the cash discount amount is valid; otherwise, false.
    /// </returns>
    public boolean validateField_CashDiscAmount(AmountCur _cashDiscAmount, AmountCur _transactionAmountCur)
    {
        boolean isValid = true;

        if ((_transactionAmountCur > 0 && _cashDiscAmount < 0) ||
            (_transactionAmountCur < 0 && _cashDiscAmount > 0))
        {
            isValid = checkFailed("@SYS68141");
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateAndUpdateFineAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates a fine amount and updates <c>CustVendTransOpen</c> with the calculated value.
    /// </summary>
    /// <param name="_refCompany">
    /// The company where the transaction exists.
    /// </param>
    /// <param name="_specCompany">
    /// The company where the payment exists
    /// </param>
    /// <param name="_custVendTransOpen">
    /// The <c>CustVendTrans</c> record fines are being calculated for.
    /// </param>
    /// <param name="_paymentDate">
    /// The date of payment
    /// </param>
    /// <param name="_paymCurrencyCode">
    /// The payment currency
    /// </param>
    public static void calculateAndUpdateFineAmount_BR(
        CompanyId _refCompany,
        CompanyId _specCompany,
        CustVendTransOpen _custVendTransOpen,
        TransDate _paymentDate,
        CurrencyCode _paymCurrencyCode)
    {
        CustVendFine_BR custVendFine;
        FineCalculator_BR fineCalculator;
        CustVendTransOpenData custVendTransOpenData;

        custVendTransOpenData = CustVendTransOpenData::construct(_custVendTransOpen);
        custVendFine = _custVendTransOpen.CustVendTransOpen::custVendFine_BR();

        if (_custVendTransOpen.RecId && custVendFine)
        {
            changecompany(_refCompany)
            {
                _custVendTransOpen.selectForUpdate(true);

                fineCalculator = new FineCalculator_BR(
                    custVendFine,
                    _paymentDate,
                    _custVendTransOpen.DueDate,
                    _custVendTransOpen.AmountCur,
                    custVendTransOpenData.custVendTrans().CurrencyCode,
                    _custVendTransOpen.getCalendarDerivation_BR());

                // Calculating and updating fine amount
                _custVendTransOpen.FineAmount_BR = fineCalculator.calculate();

                // Updating Fine Amount Payment Currency
                _custVendTransOpen.FineAmountPaymCur_BR = CustVendPaymProposalEditForm::convertAmountTransCurToAmountPaymCur_BR(
                    _custVendTransOpen.FineAmount_BR,
                    _refCompany,
                    custVendTransOpenData.custVendTrans().CurrencyCode,
                    _specCompany,
                    _paymCurrencyCode,
                    _paymentDate);

                _custVendTransOpen.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateAndUpdateInterestAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates an interest amount and updates <c>CustVendTransOpen</c> with the calculated value.
    /// </summary>
    /// <param name="_refCompany">
    /// The company where the transaction exists.
    /// </param>
    /// <param name="_specCompany">
    /// The company where the payment exists
    /// </param>
    /// <param name="_custVendTransOpen">
    /// The <c>CustVendTrans</c> record interest is being calculated for.
    /// </param>
    /// <param name="_paymentDate">
    /// The date of payment
    /// </param>
    /// <param name="_paymCurrencyCode">
    /// The payment currency
    /// </param>
    public static void calculateAndUpdateInterestAmount_BR(CompanyId          _refCompany,
                                                              CompanyId          _specCompany,
                                                              CustVendTransOpen _custVendTransOpen,
                                                              TransDate         _paymentDate,
                                                              CurrencyCode      _paymCurrencyCode)
    {
        CustVendInterest_BR   custVendFinInterest;
        InterestCalculator_Br finInterestCalculator;
        CustVendTransOpenData    custVendTransOpenData;
        SpecTrans                specTransLoc;

        custVendTransOpenData   = CustVendTransOpenData::construct(_custVendTransOpen);
        custVendFinInterest = _custVendTransOpen.CustVendTransOpen::custVendInterest_BR();
        specTransLoc = SpecTrans::findByRef(_refCompany, _custVendTransOpen.TableId, _custVendTransOpen.RecId);

        if (_custVendTransOpen.RecId && custVendFinInterest)
        {
            changecompany(_refCompany)
            {
                _custVendTransOpen.selectForUpdate(true);
                finInterestCalculator  = new InterestCalculator_Br(custVendFinInterest,
                                                                   _paymentDate,
                                                                   _custVendTransOpen.DueDate,
                                                                   _custVendTransOpen.AmountCur,
                                                                   custVendTransOpenData.custVendTrans().CurrencyCode,
                                                                   _custVendTransOpen.getCalendarDerivation_BR());

                // Calculating and updating fine amount
                _custVendTransOpen.InterestAmount_BR = finInterestCalculator.calculate();

                // Updating Fine Amount Payment Currency
                _custVendTransOpen.InterestAmountPaymCur_BR = CustVendPaymProposalEditForm::convertAmountTransCurToAmountPaymCur_BR(
                                                                    _custVendTransOpen.InterestAmount_BR,
                                                                    _refCompany,
                                                                    custVendTransOpenData.custVendTrans().CurrencyCode,
                                                                    _specCompany,
                                                                    _paymCurrencyCode,
                                                                    _paymentDate,
                                                                    specTransLoc.CrossRate);

                _custVendTransOpen.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPaymentStatusValidForAddingLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the current <c>CustVendPaymentStatus</c> value for the current <c>LedgerJournalTrans</c> table buffer.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The current transaction.</param>
    /// <returns>true if valid status for adding a new <c>LedgerJournalTrans</c> record; otherwise, false.</returns>
    protected static boolean isPaymentStatusValidForAddingLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        return (_ledgerJournalTrans.PaymentStatus == CustVendPaymStatus::None);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAddLedgerJournalTrans</Name>
				<Source><![CDATA[
    protected static boolean canAddLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean ret;

        ret = _ledgerJournalTrans.checkAllowEdit();

        if (ret)
        {
            ret = !_ledgerJournalTrans.NoEdit;
        }

        if (ret)
        {
            ret = CustVendPaymProposalEditForm::isPaymentStatusValidForAddingLedgerJournalTrans(_ledgerJournalTrans);
        }

        if (ret)
        {
            ret = SpecTrans::getSpecTransCount(_ledgerJournalTrans.DataAreaId, _ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId) > 0;
        }

        if (ret)
        {
            ret = !CustVendPaymProposalEditForm::isPaymentAndRelateddInvoicesBeingEdited(_ledgerJournalTrans);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPaymentAndRelateddInvoicesBeingEdited</Name>
				<Source><![CDATA[
    /// <summary>
    /// Is the payment and the related invoices being edited by the same user in a different session.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The payment.</param>
    /// <returns>
    /// True when the payment and the related invocies are being edited; otherwise false.
    /// </returns>
    private static boolean isPaymentAndRelateddInvoicesBeingEdited(LedgerJournalTrans _ledgerJournalTrans)
    {
        return CustVendPaymProposalLine::findByLedgerJournalTransJournalNumAndRecId(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.RecId).RecId > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static CustVendPaymProposalEditForm construct()
    {
        CustVendPaymProposalEditForm    custVendPaymProposalEditForm = new CustVendPaymProposalEditForm();

        return custVendPaymProposalEditForm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertAmountTransCurToAmountPaymCur_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the specified amount from the currency of the open transaction to the currency of the payment.
    /// </summary>
    /// <param name="_amountTransCur">
    /// The amount in transaction currency to convert.
    /// </param>
    /// <param name="_transCompany">
    /// The company where the transaction exists.
    /// </param>
    /// <param name="_transCurrencyCode">
    /// The currency the transaction uses.
    /// </param>
    /// <param name="_paymCompany">
    /// The company where the payment exists.
    /// </param>
    /// <param name="_paymCurrencyCode">
    /// The payment currency.
    /// </param>
    /// <param name="_exchRateDate">
    /// The date to use for exchange rate calculations.
    /// </param>
    /// <param name="_crossRate">
    /// The cross rate to use; optional; default is 0.
    /// </param>
    /// <param name="_exchRate">
    /// The exhange rate to use; optional; default is 0.
    /// </param>
    /// <returns>
    /// Returns the amount converted to payment currency
    /// </returns>

    public static AmountCur convertAmountTransCurToAmountPaymCur_BR(
        Amount          _amountTransCur,
        CompanyId       _transCompany,
        CurrencyCode    _transCurrencyCode,
        CompanyId       _paymCompany,
        CurrencyCode    _paymCurrencyCode,
        TransDate       _exchRateDate   = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        ExchRate        _crossRate = 0,
        ExchRate        _exchRate = 0)
    {
        AmountCur amountPaymCur;
        AmountCur interimAmount;
        CurrencyCode transMstCurrency;
        CurrencyCode paymMstCurrency;

        CurrencyExchangeHelper transExchRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::current(_transCompany)), _exchRateDate);
        CurrencyExchangeHelper paymExchRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::current(_paymCompany)), _exchRateDate);

        if (_transCurrencyCode == _paymCurrencyCode)
        {
            // Currencies are the same between the marked transaction & the payment
            amountPaymCur = _amountTransCur;
        }
        else if (_crossRate != 0)
        {
            // Cross rate is specified, convert directly from payment to marked transaction currency
            amountPaymCur = CurrencyExchange::round(CurrencyExchange::calculateAmount(_amountTransCur, _crossRate), _paymCurrencyCode);
        }
        else
        {
            // Convert from transaction currency to transaction company currency
            interimAmount = transExchRateHelper.calculateTransactionCurrencyToReportingCurrency(_transCurrencyCode, _amountTransCur);

            if (_transCompany != _paymCompany)
            {
                // Convert from transaction company currency to payment company currency
                changecompany(_transCompany)
                {
                    // Get trans company currency
                    transMstCurrency = CompanyInfoHelper::standardCurrency();
                }

                changecompany(_paymCompany)
                {
                    // Get paym company currency
                    paymMstCurrency = CompanyInfoHelper::standardCurrency();
                }

                if (transMstCurrency != paymMstCurrency)
                {
                    interimAmount = paymExchRateHelper.calculateTransactionCurrencyToReportingCurrency(transMstCurrency, interimAmount);
                }
            }

            // Convert from payment company currency to payment currency
            if (_exchRate != 0)
            {
                paymExchRateHelper.parmExchangeRate1(_exchRate);
            }
            amountPaymCur = paymExchRateHelper.calculateCurrencyToCurrency(CompanyInfoHelper::standardCurrency(),
                                                                           _paymCurrencyCode,
                                                                           interimAmount,
                                                                           true);
        }

        return amountPaymCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newLedgerJournalTrans</Name>
				<Source><![CDATA[
    public static CustVendPaymProposalEditForm newLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        CustVendPaymProposalEditForm    custVendPaymProposalEditForm;
        CustVendPaymProposal            custVendPaymProposal;
        FormDataSource                  ledgerJournalTrans_DS;
        LedgerJournalTrans              ledgerJournalTrans;
        CustVendPaymProposalCalcPaym    custVendPaymProposalCalcPaym;

        if (!_ledgerJournalTrans.RecId)
        {
            throw error("@SYS93106");
        }

        if (!LedgerJournalTable::exist(_ledgerJournalTrans.JournalNum))
        {
            throw error(strfmt("@SYS62511", _ledgerJournalTrans.JournalNum));
        }

        custVendPaymProposal = CustVendPaymProposal::newLedgerJournal(_ledgerJournalTrans.JournalNum);
        ledgerJournalTrans_DS = FormDataUtil::getFormDataSource(_ledgerJournalTrans);

        if (ledgerJournalTrans_DS)
        {
            if (ledgerJournalTrans_DS.allowEdit())
            {
                for (ledgerJournalTrans = ledgerJournalTrans_DS.getFirst(true) ? ledgerJournalTrans_DS.getFirst(true) : ledgerJournalTrans_DS.cursor();
                    ledgerJournalTrans;
                    ledgerJournalTrans = ledgerJournalTrans_DS.getNext())
                {
                    // verify that the journal line can be edited
                    if (CustVendPaymProposalEditForm::canAddLedgerJournalTrans(ledgerJournalTrans))
                    {
                        // the CustVendPaymProposalCalcPaym instance used for creating proposal lines from journal lines will be initialized
                        // with values from the first journal line that is found that is valid for editing - Ax4.1 Bug#118
                        if (custVendPaymProposalCalcPaym == null)
                        {
                            custVendPaymProposalCalcPaym = CustVendPaymProposalCalcPaym::construct(custVendPaymProposal.ledgerJournalType());

                            // Set the PaymDateFixed value to the payment's date. This date is used when Method of Payment's Period == Total.
                            // When Period == Total the payment date used during proposal creation is the Total Payment Date.
                            custVendPaymProposalCalcPaym.parmPaymDateFixed(ledgerJournalTrans.TransDate);

                            // convert transaction date to its associated day of week
                            PreferredLocale locale = new xSession().preferredLocale();

                            custVendPaymProposalCalcPaym.parmPaymWeekDayFixed(
                                ledgerJournalTrans.TransDate - DateTimeUtil::getStartOfWeekDate(locale, ledgerJournalTrans.TransDate) + 1);

                            custVendPaymProposalCalcPaym.parmPaymCurrency(ledgerJournalTrans.CurrencyCode);

                            custVendPaymProposal.parmPaymProposalCalcPaym(custVendPaymProposalCalcPaym);
                        }

                        if (custVendPaymProposalCalcPaym.parmPaymDateFixed() == ledgerJournalTrans.TransDate &&
                            custVendPaymProposalCalcPaym.parmPaymCurrency() == ledgerJournalTrans.CurrencyCode)
                        {
                            // only allow journal lines with the same payment date and currency to be edited as a group - see Ax4.1 Bug#118
                            custVendPaymProposal.addLedgerJournalTrans(ledgerJournalTrans);
                        }
                        else
                        {
                            info(strfmt("@SYS93094", ledgerJournalTrans.Voucher));
                        }
                    }
                    else
                    {
                        info(strfmt("@SYS93094", ledgerJournalTrans.Voucher));
                    }
                }
            }
        }
        else
        {
            // a single record buffer was provided, process as single
            custVendPaymProposal.addLedgerJournalTrans(_ledgerJournalTrans);
        }

        custVendPaymProposalEditForm = CustVendPaymProposalEditForm::newPaymProposal(custVendPaymProposal, true, custVendPaymProposal.ledgerJournalId(), custVendPaymProposal.ledgerJournalType(), custVendPaymProposal.moduleCustVend());
        CustVendPaymProposalEditForm::updateFormForEditPaymentProposal(custVendPaymProposalEditForm, ledgerJournalTrans_DS);

        return custVendPaymProposalEditForm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFormForEditPaymentProposal</Name>
				<Source><![CDATA[
    private static void updateFormForEditPaymentProposal(CustVendPaymProposalEditForm _custVendPaymProposalEditForm, FormDataSource _ledgerJournalTrans_DS)
    {
        _custVendPaymProposalEditForm.parmOKButton().text("@CashManagement:UpdatePaymProposal");

        if (_ledgerJournalTrans_DS)
        {
            _custVendPaymProposalEditForm.parmLedgerJournalTrans_ds(_ledgerJournalTrans_DS);
            _ledgerJournalTrans_DS.allowEdit(false);
            _ledgerJournalTrans_DS.allowDelete(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPaymProposal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>CustVendPaymProposalEditForm</c> class.
    /// </summary>
    /// <param name="_custVendPaymProposal">
    /// The proposal from which to create the instance.
    /// </param>
    /// <param name="_clearOnClose">
    /// true to clear the proposal on close; otherwise, false.
    /// </param>
    /// <param name="_ledgerJournalId">
    /// The ledger journal ID; optional.
    /// </param>
    /// <param name="_ledgerJournalType">
    /// The ledger journal type; optional.
    /// </param>
    /// <param name="_moduleCustVend">
    /// The module; optional.
    /// </param>
    /// <returns>
    /// The new <c>CustVendPaymProposalEditForm</c> instance.
    /// </returns>
    /// <remarks>
    /// The <c>_ledgerJournalId</c>, <c>_ledgerJournalType</c> and <c>_moduleCustVend</c> parameters are
    /// provided to allow setting of these four values without requiring calls back to the
    /// <c>CustVendPaymProposal</c> object because that object exists on the server tier. This allows the
    /// caller to avoid three RPC calls when this method is called from the server tier. If the
    /// <c>_ledgerJournalId</c> parameter is not specified, then those values are read from the
    /// <c>_custVendPaymProposal</c> parameter.
    /// </remarks>
    public static CustVendPaymProposalEditForm newPaymProposal(
        CustVendPaymProposal    _custVendPaymProposal,
        boolean                 _clearOnClose = true,
        ledgerJournalId         _ledgerJournalId = '',
        ledgerJournalType       _ledgerJournalType = LedgerJournalType::Daily,
        ModuleCustVend          _moduleCustVend = ModuleCustVend::Cust
        )
    {
        CustVendPaymProposalEditForm    custVendPaymProposalEditForm;

        custVendPaymProposalEditForm = CustVendPaymProposalEditForm::construct();
        if (prmisDefault(_ledgerJournalId))
        {
            custVendPaymProposalEditForm.parmPaymProposal(_custVendPaymProposal);
        }
        else
        {
            custVendPaymProposalEditForm.setPaymProposal(_custVendPaymProposal, _ledgerJournalId, _ledgerJournalType, _moduleCustVend);
        }
        custVendPaymProposalEditForm.parmClearProposalWhenClosing(_clearOnClose);
        custVendPaymProposalEditForm.init();

        return custVendPaymProposalEditForm;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>