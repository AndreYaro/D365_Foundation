<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendOutPaym</Name>
	<SourceCode>
		<Declaration><![CDATA[
public abstract class CustVendOutPaym extends RunBase implements CustVendBankPaymFormat, CustVendPaymIPrinterSettingsProvider
{
    CompanyBankAccountId accountId;
    LedgerJournalId ledgerJournalId;
    PaymMode paymMode;

    Filename filename;
    NoYes printDocument;                  // Print document, i.e. check or bill of exchange
    NoYes printControlReport;             // Print control report when export file is created
    NoYes printAttendingNote;             // Print attending note
    NoYes printPaymAdvice;                // Print payment advice
    NoYes printPaymAdvicePrintMgmt;       // Print payment advice print management
    NoYes printPaymOrder;                 // Print payment order

    IdentifierName lastValueDesignName;

    boolean isSwapping;

    // Default dialog
    DialogGroup dialogGroupPrint;
    DialogField dialogFileName;
    DialogField dialogPrintDocument;
    DialogField dialogPrintControlReport;
    DialogField dialogPrintAttendingNote;
    DialogField dialogPrintPaymAdvice;
    DialogField dialogPrintPaymAdvicePrintMgmt;
    DialogField dialogPrintPaymOrder;

    QueryRun queryRun;
    List outPaymRecordList;
    CustVendPaymPrinterSettings custVendPaymPrinterSettings;
    RecordSortedList trackedPaymModeSequences;
    StreamIo file;
    CustVendOutPaymUserInteraction userInteraction;

    // <GEERU>
    boolean clientBank;

    // </GEERU>

    // This list defines which fields will be persisted and restored via the system's
    // SysLastValue functionality.
    #DEFINE.SysLastValuesCurrentVersion(3)
    #LOCALMACRO.SysLastValuesList
        ledgerJournalId,
        fileName,
        printDocument,
        printControlReport,
        printAttendingNote,
        printPaymAdvice,
        printPaymOrder,
        accountId,
        printPaymAdvicePrintMgmt
    #ENDMACRO

    #DEFINE.SysLastValuesVersion2(2)
    #LOCALMACRO.SysLastValuesListV2
        ledgerJournalId,
        fileName,
        printDocument,
        printControlReport,
        printAttendingNote,
        printPaymAdvice,
        printPaymOrder,
        accountId
    #ENDMACRO

    // This list defines how the object is serialized and unserialized as it is sent across the wire. This
    // list should contain all non-object types defined on this class declaration.
    #DEFINE.CurrentVersion(5)
    #LOCALMACRO.CurrentList
        ledgerJournalId,
        fileName,
        printDocument,
        printControlReport,
        printAttendingNote,
        printPaymAdvice,
        printPaymOrder,
        accountId,
        printPaymAdvicePrintMgmt
    #ENDMACRO

    #LOCALMACRO.CurrentListV4
        ledgerJournalId,
        fileName,
        printDocument,
        printControlReport,
        printAttendingNote,
        printPaymAdvice,
        printPaymOrder,
        accountId
    #ENDMACRO

    #define.Version3(3)
    #LOCALMACRO.CurrentListV3
        ledgerJournalId,
        fileName,
        printDocument,
        printControlReport,
        printAttendingNote,
        printPaymAdvice,
        printPaymOrder,
        accountId
    #ENDMACRO
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>callPrinterSettings</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Opens a printer settings dialog box for the specified payment document type.
    /// </summary>
    /// <param name="_documentType">
    ///    The payment document type.
    /// </param>
    /// <returns>
    ///    true if the printer settings dialog box was closed with the Ok button; otherwise, false.
    /// </returns>
    public boolean callPrinterSettings(PaymDocumentType  _documentType)
    {
        SRSPrintDestinationSettings printSettings = new SRSPrintDestinationSettings(this.getPrinterSettings(_documentType));
        boolean ok = SrsReportRunUtil::showSettingsDialog(printSettings);

        if (ok)
        {
            this.updatePrinterSettings(_documentType, printSettings.pack());
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    void check()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBankAccountNumber</Name>
				<Source><![CDATA[
    boolean checkBankAccountNumber()
    {
        QueryRun            checkBankQueryRun;
        LedgerJournalTrans  ledgerJournalTrans;
        BankAccountID       bankAccountID;

        if (this.multipleBankAccountsAllowed())
        {
            return true;
        }

        checkBankQueryRun = new QueryRun(queryRun.pack());

        while (checkBankQueryRun.next())
        {
            if (checkBankQueryRun.changed(tableNum(LedgerJournalTrans)))
            {
                ledgerJournalTrans = checkBankQueryRun.get(tableNum(LedgerJournalTrans));
                if (!bankAccountID)
                {
                    bankAccountID = ledgerJournalTrans.BankAccountId ? ledgerJournalTrans.BankAccountId : ledgerJournalTrans.parmOffsetAccount();
                }
                else
                {
                    if (bankAccountID != (ledgerJournalTrans.BankAccountId ? ledgerJournalTrans.BankAccountId : ledgerJournalTrans.parmOffsetAccount()))
                    {
                        return checkFailed("@SYS73795");
                    }
                }

                if (this.parmBankAccountID())
                {
                    return BankAccountTable::checkIsActive(this.parmBankAccountID(), ledgerJournalTrans.TransDate);
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUniquePaymMode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether more than one method of payment is included in the generation of payments, by
    ///    using the <c>QueryRun</c> class object.
    /// </summary>
    /// <returns>
    ///    true if more than one method of payment is included in the generation of payments; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The method of payment should be unique, if information from the method of payment is used in
    ///    headers or footers of the payment media.
    /// </remarks>
    public boolean checkUniquePaymMode()
    {
        boolean ok = true;

        if (queryRun && CustVendSumForPaym::countPaymModes(queryRun.query().pack()) > 1)
        {
            ok = checkFailed(strFmt("@SYS82372", this.interfaceName()));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkValues</Name>
				<Source><![CDATA[
    boolean checkValues(LedgerJournalTrans  _ledgerJournalTrans = null,
                        RunbaseProgress     _progress           = null)
    {
        boolean ret = true;

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank)
        {
            ret = BankAccountTable::checkIsActive(_ledgerJournalTrans.parmAccount(), _ledgerJournalTrans.TransDate);
        }
        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank)
        {
            ret = BankAccountTable::checkIsActive(_ledgerJournalTrans.parmOffsetAccount(), _ledgerJournalTrans.TransDate);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>close</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the epilogue of the media, such as an end record for a file.
    /// </summary>
    public void close()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeFile</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Closes the file if it is open.
    /// </summary>
    public void closeFile()
    {
        if (file != null)
        {
            File::SendFileToUser(file.getStream(), filename, classstr(PaymentFileTemporaryStorageStrategy));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>configurationKey</Name>
				<Source><![CDATA[
    // Inheriting classes generating output for electronic banking should return the configurationkey for Electronic Banking
    public configurationKeyId configurationKey()
    {
        return configurationKeyNum(Bank);
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendOutPaymRecordRootClassId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    The method should return the class ID of the corresponding parent of <c>CustVendOutPaymRecord</c>
    ///    classes.
    /// </summary>
    /// <returns>
    ///    The class ID.
    /// </returns>
    /// <remarks>
    ///    The class must be inherited from the <c>CustVendOutPaymRecord</c> class.
    /// </remarks>
    public classId custVendOutPaymRecordRootClassId()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddFileName</Name>
				<Source><![CDATA[
    protected void dialogAddFileName(DialogRunbase _dialog)
    {
        DialogRunbase dialog = _dialog;
        dialog.addGroup("@SYS26552");
        dialogFileName = dialog.addFieldValue(extendedTypeStr(FreeText), filename, "@SYS53669");
        dialogFileName.widthMode(FormWidth::SizeToAvailable);
        dialogFileName.allowEdit(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddPrintDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add print document dialog fields.
    /// </summary>
    /// <param name = "_documentType">The payment document type.</param>
    /// <param name = "_dialog">The dialog that will contain the print document dialog fields.</param>
    /// <param name = "_addPrintOption">Add print option; optional</param>
    /// <param name = "_makePrintGroup">Make print group; optional.</param>
    /// <param name = "_usePrintMgmt">Use print managment; optional.</param>
    protected void dialogAddPrintDocument(PaymDocumentType  _documentType,
                                          DialogRunbase     _dialog,
                                          boolean           _addPrintOption = false,
                                          boolean           _makePrintGroup = true,
                                          boolean           _usePrintMgmt = false)
    {
        if (_makePrintGroup)
        {
            this.dialogAddPrintGroup(_dialog);
        }

        switch (_documentType)
        {
            case PaymDocumentType::Document:
                dialogPrintDocument = _dialog.addFieldValue(enumStr(NoYes), printDocument, "@SYS101280", "@SYS78928");
                break;

            case PaymDocumentType::ControlReport:
                dialogPrintControlReport = _dialog.addFieldValue(enumStr(NoYes), printControlReport, "@SYS78925", "@SYS67272");
                break;

            case PaymDocumentType::AttendingNote:
                dialogPrintAttendingNote = _dialog.addFieldValue(enumStr(NoYes), printAttendingNote, "@SYS78926", "@SYS78929");
                break;

            case PaymDocumentType::PaymAdvice:

                dialogPrintPaymAdvice = _dialog.addFieldValue(enumStr(NoYes), printPaymAdvice, "@SYS55191", "@SYS78930");

                if (_usePrintMgmt)
                {
                    dialogPrintPaymAdvicePrintMgmt = _dialog.addFieldValue(enumStr(NoYes), printPaymAdvicePrintMgmt, "@SYS70782", "@SYS70782");
                    if (dialogPrintPaymAdvice.value() == NoYes::No)
                    {
                        dialogPrintPaymAdvicePrintMgmt.enabled(false);
                    }
                }

                break;
        }

        if (_addPrintOption)
        {
            this.dialogAddPrintOption(_documentType, _dialog);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPostRun</Name>
				<Source><![CDATA[
    public void dialogPostRun(DialogRunbase _dialog)
    {
        super(_dialog);

        if (dialogPrintPaymAdvicePrintMgmt)
        {
            dialogPrintPaymAdvice.registerOverrideMethod(methodStr(FormCheckBoxControl, modified), methodStr(CustVendOutPaym, dialogPrintPaymAdviceModified), this);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPrintPaymAdviceModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows the use of print management for payment advice when payment advice is enabled.
    /// </summary>
    /// <param name = "_formCheckBoxControl">The payment advice checkbox control.</param>
    /// <returns>true if the payment advice checkbox was modified; otherwise, false.</returns>
    public boolean dialogPrintPaymAdviceModified(FormCheckBoxControl _formCheckBoxControl)
    {
        boolean isPrintPaymAdviceModified;

        isPrintPaymAdviceModified = _formCheckBoxControl.modified();

        if (isPrintPaymAdviceModified)
        {
            if (dialogPrintPaymAdvice.value() == NoYes::Yes)
            {
                dialogPrintPaymAdvicePrintMgmt.enabled(true);
            }
            else
            {
                dialogPrintPaymAdvicePrintMgmt.enabled(false);
            }
        }

        return isPrintPaymAdviceModified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddPrintGroup</Name>
				<Source><![CDATA[
    private DialogGroup dialogAddPrintGroup(Dialog _dialog)
    {
        if (!dialogGroupPrint)
        {
            dialogGroupPrint = _dialog.addGroup("@SYS920");
        }

        return dialogGroupPrint;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogAddPrintOption</Name>
				<Source><![CDATA[
    protected void dialogAddPrintOption(PaymDocumentType    _documentType,
                                        DialogRunbase       _dialog,
                                        DialogMenuItemGroup _dialogMenuItemGroup = DialogMenuItemGroup::RightGrp)
    {
        #define.fixedPartOfName('OutPaymOptions')

        DictEnum    dictEnum;
        str         moduleName;
        str         documentTypeName;
        str         menuItemName;

        moduleName = this.dialogPrintOptionMenuItemPrefix();

        dictEnum = new DictEnum(enumNum(PaymDocumentType));

        documentTypeName = dictEnum.index2Symbol(enum2int(_documentType));

        menuItemName = strFmt('%1%2%3', moduleName, #fixedPartOfName, documentTypeName);

        _dialog.addMenuItemButton(MenuItemType::Action, menuItemName, _dialogMenuItemGroup );
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPrintOptionMenuItemPrefix</Name>
				<Source><![CDATA[
    abstract protected str dialogPrintOptionMenuItemPrefix()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPaymModeSpec</Name>
				<Source><![CDATA[
    abstract public CustVendPaymModeSpec findPaymModeSpec(PaymMode  _paymMode,
                                                          PaymSpec  _paymSpec)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPaymModeTable</Name>
				<Source><![CDATA[
    abstract public CustVendPaymModeTable findPaymModeTable(PaymMode  _paymMode, boolean _forUpdate = false)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>generatePaymentLines</Name>
				<Source><![CDATA[
    public void generatePaymentLines()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addGeneratePaymentLinesSort</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sorts the generated payment lines before they are processed.
    /// </summary>
    /// <param name="_queryRun">
    /// The generate payment lines query run.
    /// </param>
    protected void addGeneratePaymentLinesSort(QueryRun _queryRun)
    {
        this.addGeneratePaymentLineAccountNameSort(_queryRun);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addGeneratePaymentLineAccountNameSort</Name>
				<Source><![CDATA[
    private void addGeneratePaymentLineAccountNameSort(QueryRun _queryRun)
    {
        QueryBuildDataSource qbds;

        qbds = _queryRun.query().dataSourceTable(tableNum(DimensionCombinationValueNameTmp));
        if (!qbds)
        {
            qbds = _queryRun.query().dataSourceTable(tableNum(LedgerJournalTrans)).addDataSource(tableNum(DimensionCombinationValueNameTmp));
            qbds.relations(false);
            qbds.addLink(fieldNum(LedgerJournalTrans, LedgerDimension), fieldNum(DimensionCombinationValueNameTmp, DimensionAttributeValueCombination));
            qbds.joinMode(JoinMode::OuterJoin);
            qbds.fetchMode(QueryFetchMode::One2One);
            qbds.update(false);
            qbds.enabled(true);

            qbds.addSortField(fieldNum(DimensionCombinationValueNameTmp, Name));

            _queryRun.setRecord(CustVendPaymDialogUtility::generatePaymentLineAccountNames(ledgerJournalId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>generatePaymentLines_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Throws an error of missing overload.
    /// </summary>
    /// <param name="_postingLevel">
    /// The posting level for check payment method.
    /// </param>
    /// <remarks>
    /// This method should be overloaded on derived classes.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// This method is missing an overload.
    /// </exception>
    public void generatePaymentLines_BR(Posting_BR _postingLevel)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendPaymModeTableBuffer</Name>
				<Source><![CDATA[
    protected CustVendPaymModeTable getCustVendPaymModeTableBuffer(container    _packedQuery = queryRun.query().pack())
    {
        QueryRun                testQueryRun;
        CustPaymModeTable       custPaymModeTable;
        VendPaymModeTable       vendPaymModeTable;
        CustVendPaymModeTable   custVendPaymModeTable;

        testQueryRun = new QueryRun(_packedQuery);

        if (testQueryRun.query().dataSourceTable(tableNum(CustPaymModeTable)))
        {
            custVendPaymModeTable = custPaymModeTable;
        }
        else
        {
            custVendPaymModeTable = vendPaymModeTable;
        }

        return custVendPaymModeTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets values from the corresponding <c>Payment Format</c> dialog controls.
    /// </summary>
    /// <returns>
    /// true if values correctly retrieved from dialog control; otherwise,  false.
    /// </returns>
    public boolean getFromDialog()
    {
        if (dialogFileName)
        {
            filename = dialogFileName.value();
        }

        if (dialogPrintDocument)
        {
            printDocument = dialogPrintDocument.value();
        }

        if (dialogPrintControlReport)
        {
            printControlReport = dialogPrintControlReport.value();
        }

        if (dialogPrintAttendingNote)
        {
            printAttendingNote = dialogPrintAttendingNote.value();
        }

        if (dialogPrintPaymAdvice)
        {
            printPaymAdvice = dialogPrintPaymAdvice.value();
        }

        if (dialogPrintPaymAdvicePrintMgmt)
        {
            printPaymAdvicePrintMgmt = dialogPrintPaymAdvicePrintMgmt.value();
        }

        if (dialogPrintPaymOrder)
        {
            printPaymOrder = dialogPrintPaymOrder.value();
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Restores the pertinent values from the <c>SysLastValue</c> table.
    /// </summary>
    public void getLast()
    {
        container packedValues;
        //<GEERU>
        #ISOCountryRegionCodes
        //</GEERU>

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU ]))
        {
            super();
        }
        else
        {
            // </GEERU>

            if (xSysLastValue::existLast(this))
            {
                packedValues = xSysLastValue::getValue(this.lastValueDataAreaId(),
                                                       this.lastValueUserId(),
                                                       this.lastValueType(),
                                                       this.lastValueElementName(),
                                                       this.lastValueDesignName());

                this.unpackSysLastValues(packedValues);
            }
            // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOutPaymRecords</Name>
				<Source><![CDATA[
    public List getOutPaymRecords()
    {
        return outPaymRecordList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a list of payment records.
    /// </summary>
    /// <returns>
    /// A list of <c>LedgerJournalTrans</c> payment records.
    /// </returns>
    public List getPaymRecords()
    {
        List list = new List(Types::Record);

        if (outPaymRecordList)
        {
            LedgerJournalTrans ledgerJournalTrans;
            ListEnumerator le;
            le = outPaymRecordList.getEnumerator();
            while (le.moveNext())
            {
                CustVendOutPaymRecord custVendOutPaymRecord = le.current();

                if (custVendOutPaymRecord
                    && custVendOutPaymRecord.parmCustVendPaym()
                    && custVendOutPaymRecord.parmCustVendPaym().ledgerJournalTrans())
                {
                    ledgerJournalTrans.data(custVendOutPaymRecord.parmCustVendPaym().ledgerJournalTrans());
                    ledgerJournalTrans.reread();
                    list.addEnd(ledgerJournalTrans);
                }
            }
        }

        return list;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPrinterSettings</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the printer settings for the supplied payment document type.
    /// </summary>
    /// <param name="_documentType">
    ///    The payment document type.
    /// </param>
    /// <returns>
    ///    The printer settings for the supplied payment document type.
    /// </returns>
    public container getPrinterSettings(PaymDocumentType _documentType)
    {
        return custVendPaymPrinterSettings.getPrinterSettings(_documentType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSumByCurrency</Name>
				<Source><![CDATA[
    public TmpAccountSum getSumByCurrency()
    {
        TmpAccountSum           tmpAccountSum;
        ListEnumerator          enumOutPaymRecordList;
        CustVendOutPaymRecord   custVendOutPaymRecord;
        CustVendPaym            custVendPaym;

        enumOutPaymRecordList = outPaymRecordList.getEnumerator();

        while (enumOutPaymRecordList.moveNext())
        {
            custVendOutPaymRecord = enumOutPaymRecordList.current();

            custVendPaym = custVendOutPaymRecord.parmCustVendPaym();

            select firstonly tmpAccountSum
                where tmpAccountSum.AccountNum == custVendPaym.paymCurrencyCode();
            
            this.setBalancesOnTmpAccountSum(tmpAccountSum, custVendPaym);
            
            if (tmpAccountSum.RecId)
            {
                tmpAccountSum.update();
            }
            else
            {
                tmpAccountSum.AccountNum = custVendPaym.paymCurrencyCode();
                tmpAccountSum.insert();
            }
        }

        return tmpAccountSum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBalancesOnTmpAccountSum</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets the balance amount on <c>TmpAccountSum</c> table.
    /// </summary>
    /// <param name = "_tmpAccountSum">
    ///     An instance of <c>TmpAccountSum</c> table buffer.
    /// </param>
    /// <param name = "_custVendPaym">
    ///     An object of <c>CustVendPaym</c> class.
    /// </param>
    protected void setBalancesOnTmpAccountSum(TmpAccountSum _tmpAccountSum, CustVendPaym _custVendPaym)
    {
        _tmpAccountSum.Balance01Cur += _custVendPaym.paymAmountInForeignCurrency();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUniquePaymModeTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the generation of payment covers only one method of payment. If true, returns
    ///    the unique method of payment record.
    /// </summary>
    /// <param name="_packedQuery">
    ///    A packed <c>QueryRun</c> class object; optional. If not provided, the current <c>queryRun</c>
    ///    object for the class is used.
    /// </param>
    /// <returns>
    ///    The unique method of payment record, if unique, as a <c>CustVendPaymModeTable</c> record object.
    /// </returns>
    /// <remarks>
    ///    This method is applicable for export formats that are designed to handle only one method of payment
    ///    per payment media.
    /// </remarks>
    protected CustVendPaymModeTable getUniquePaymModeTable(container    _packedQuery = queryRun.query().pack())
    {
        QueryRun                testQueryRun;
        CustVendPaymModeTable   custVendPaymModeTable;
        tableId                 tableIdPaymModeTable;

        if (CustVendSumForPaym::countPaymModes(_packedQuery) > 1)
        {
            throw error(strFmt("@SYS82372", this.interfaceName()));
        }

        testQueryRun = new QueryRun(_packedQuery);

        tableIdPaymModeTable = this.getCustVendPaymModeTableBuffer(_packedQuery).TableId;

        while (testQueryRun.next())
        {
            if (testQueryRun.changed(tableIdPaymModeTable))
            {
                custVendPaymModeTable = testQueryRun.get(tableIdPaymModeTable);
                break;
            }
        }

        return custVendPaymModeTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interfaceName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the name of the format to be displayed in the user interface.
    /// </summary>
    /// <returns>
    ///    The name of the format to be displayed in the user interface.
    /// </returns>
    /// <remarks>
    ///    The method must return the name of the format to be displayed in the user interface. Formats
    ///    without an interface name cannot be used in electronic banking as export formats. They can serve as
    ///    parents for other formats though.
    /// </remarks>
    public PaymInterfaceName interfaceName()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBankPrenote</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the prenote is enabled for a particular bank.
    /// </summary>
    /// <returns>
    ///    true if the prenote is enabled; otherwise, false.
    /// </returns>
    protected boolean isBankPrenote()
    {
        return BankAccountTable::find(accountId).IsBankPrenote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOffsetAccountValid</Name>
				<Source><![CDATA[
    protected boolean isOffsetAccountValid(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean ok = _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank
            && _ledgerJournalTrans.parmOffsetAccount() == accountId;

        if (!ok) // Check for bridge posting
        {
            CustVendPaymModeTable paymModeTable = this.findPaymModeTable(_ledgerJournalTrans.PaymMode);

            // For bridging posting of BridgingAccountByBank, the bank account setting on the generate payment dialog should be same with the bridging bank account on journal line
            if (FeatureStateProvider::isFeatureEnabled(BankBridgedTransAutoClearingFeature::instance())
                && paymModeTable.FurtherPosting == NoYes::Yes 
                && paymModeTable.BridgingAccountByBank == NoYes::Yes)
            {
                ok = _ledgerJournalTrans.BridgingBankAccount == accountId;
            }
            else
            {
                ok = paymModeTable.FurtherPosting == NoYes::Yes
                    && paymModeTable.AccountType == LedgerJournalACType::Bank
                    && paymModeTable.parmPaymAccount() == accountId;
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSwappingPrompt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether values are being swapped between the client and server tiers.
    /// </summary>
    /// <returns>
    ///    true when swapping values between the client and server; otherwise, false.
    /// </returns>
    public boolean isSwappingPrompt()
    {
        return isSwapping || super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueDesignName</Name>
				<Source><![CDATA[
    public identifierName lastValueDesignName()
    {
        identifierName ret;

        if (lastValueDesignName)
        {
            ret = lastValueDesignName;
        }
        else
        {
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>multipleBankAccountsAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the payment export format is designed to handle payments from more than one bank
    ///    account per media.
    /// </summary>
    /// <returns>
    ///    true if the payment export format is designed to handle payments from multiple bank accounts;
    ///    otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The default is false. This means that usually a payment export format only handles payments from a
    ///    single bank account.
    /// </remarks>
    public boolean multipleBankAccountsAllowed()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new()
    {
        super();

        custVendPaymPrinterSettings = new CustVendPaymPrinterSettings();
        outPaymRecordList = new List(Types::Class);
    }

]]></Source>
			</Method>
			<Method>
				<Name>open</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the media (for example, creates a file) and creates the header of the media (for example,
    /// creates a start record for a file).
    /// </summary>
    public void open()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>openFile</Name>
				<Source><![CDATA[
    public StreamIo openFile(int _codepage, StreamType  _type = StreamType::AsciiIo)
    {
        return CustVendOutPaym::newFile(_codepage, _type);
    }

]]></Source>
			</Method>
			<Method>
				<Name>openExistingFile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>StreamIo</c> class to be used for appending to a <c>System.IO.Stream</c>.
    /// </summary>
    /// <param name = "_stream">
    /// The <c>System.IO.Stream</c> to append to.
    /// </param>
    /// <param name = "_codePage">
    /// The code page number for the character set to be written to stream.
    /// </param>
    /// <param name = "_type">
    /// The type of <c>StreamIo</c> class to create.
    /// </param>
    /// <returns>
    /// A new instance of the <c>StreamIo</c> class for appending to a <c>System.IO.Stream</c>.
    /// </returns>
    public StreamIo openExistingFile(System.IO.Stream _stream, int _codepage, StreamType _type = StreamType::AsciiIo)
    {
        return CustVendOutPaym::appendToFile(_stream, _codepage, _type);
    }

]]></Source>
			</Method>
			<Method>
				<Name>output</Name>
				<Source><![CDATA[
    /// <summary>
    /// A method that allows handling output operation by the concrete <c>PaymentFormat</c> implementation.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> record to be included in the report or file.
    /// </param>
    /// <exception cref="M:Exception::Error">
    /// This method must be overridden by concrete <c>PaymentFormat</c> class otherwise <c>missing
    /// overload</c> exception is thrown.
    /// </exception>
    void output(LedgerJournalTrans _ledgerJournalTrans)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, [#Currentlist, custVendPaymPrinterSettings.getAllPrinterSettingsPacked(), outPaymRecordList.pack()]];
    }

]]></Source>
			</Method>
			<Method>
				<Name>packSysLastValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Packs the data required for <c>SysLastValues</c>.
    /// </summary>
    /// <returns>
    ///    A container storing the data to be persisted by <c>SysLastValues</c>.
    /// </returns>
    /// <remarks>
    ///    The pack and unpack pattern does not have provisions for supporting different serialization and
    ///    <c>SysLastValues</c> pack lists. This separate packing mechanism has been implemented for
    ///    <c>SysLastValues</c> and is first defined on the class one level above the <c>RunBase</c> or
    ///    <c>RunBaseBatch</c> class. Derivative classes also implement this method so that a whole object can
    ///    be packed for <c>SysLastValues</c>.
    /// </remarks>
    protected container packSysLastValues()
    {
        return [#SysLastValuesCurrentVersion, #SysLastValuesList, custVendPaymPrinterSettings.getAllPrinterSettingsPacked()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>packValues</Name>
				<Source><![CDATA[
    public container packValues(boolean _isSwapping = false)
    {
        container packedClass;

        isSwapping = _isSwapping;
        packedClass = this.pack();
        isSwapping = false;
        return packedClass;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankAccountID</Name>
				<Source><![CDATA[
    public CompanyBankAccountId parmBankAccountID(CompanyBankAccountId _accountID = accountID)
    {
        accountID = _accountID;

        return accountID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmClientBank_RU</Name>
				<Source><![CDATA[
    public boolean parmClientBank_RU(boolean _clientBank = clientBank)
    {
        clientBank = _clientBank;
        return clientBank;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFile</Name>
				<Source><![CDATA[
    public StreamIo parmFile()
    {
        return file;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFileASCII</Name>
				<Source><![CDATA[
    public TextStreamIo parmFileASCII()
    {
        return file;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFilename</Name>
				<Source><![CDATA[
    public Filename parmFilename(Filename _filename = filename)
    {
        filename = _filename;

        return filename;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLastValueDesignName</Name>
				<Source><![CDATA[
    public identifierName parmLastValueDesignName(identifierName _lastValueDesignName = lastValueDesignName)
    {
        lastValueDesignName = _lastValueDesignName;

        return lastValueDesignName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalId</Name>
				<Source><![CDATA[
    public LedgerJournalId parmLedgerJournalId(LedgerJournalId _ledgerJournalId = ledgerJournalId)
    {
        ledgerJournalId = _ledgerJournalId;

        return ledgerJournalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymMode</Name>
				<Source><![CDATA[
    public PaymMode parmPaymMode(PaymMode _value = paymMode)
    {
        paymMode = _value;
        return paymMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQueryRun</Name>
				<Source><![CDATA[
    public QueryRun parmQueryRun(QueryRun _queryRun = queryRun)
    {
        queryRun = _queryRun;

        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareTransRecords</Name>
				<Source><![CDATA[
    // This method is called in the run() method of Class CustVendSumForPaym
    // before ttsbegin.
    // Therefore this method can be overridden to create dialogs for further
    // information per payment transaction.
    public void prepareTransRecords()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>printAttendingNote</Name>
				<Source><![CDATA[
    public void printAttendingNote()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>printControlReport</Name>
				<Source><![CDATA[
    public void printControlReport()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>printDocument</Name>
				<Source><![CDATA[
    public void printDocument()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>printPaymAdvice</Name>
				<Source><![CDATA[
    public void printPaymAdvice()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>printPaymOrder</Name>
				<Source><![CDATA[
    public void printPaymOrder()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>releasePaymentOrderNum_RU</Name>
				<Source><![CDATA[
    public void releasePaymentOrderNum_RU(LedgerJournalTrans   _ledgerJournalTrans,
                                          BankPaymentOrder_RU  _orderNum)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    void run()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>runReport</Name>
				<Source><![CDATA[
    protected void runReport(str  _menuItemOutputStr)
    {
        MenuFunction    menuFunction;
        Args            args;

        // <GEERU>
        #ISOCountryRegionCodes
        // </GEERU>

        //<GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) && this.parmClientBank_RU())
        {
            return;
        }
        // </GEERU>

        args = new Args();
        args.caller(this);

        menuFunction = new MenuFunction(_menuItemOutputStr, MenuItemType::Output);
        menuFunction.run(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveLast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Persists the pertinent values to the <c>SysLastValue</c> table.
    /// </summary>
    public void saveLast()
    {
        //<GEERU>
        #ISOCountryRegionCodes
        //</GEERU>

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU ]))
        {
            super();
        }
        else
        {
            // </GEERU>
            // Don't make the call to super as the #CurrentList and #SysLastValues lists are different,
            // requiring that we have specialized logic for the SysLastValues implementation.
            //super();

            // Persist the pertinent values to the SysLastValue table.
            xSysLastValue::putValue(this.packSysLastValues(),
                                this.lastValueDataAreaId(),
                                this.lastValueUserId(),
                                this.lastValueType(),
                                this.lastValueElementName(),
                                this.lastValueDesignName());
            // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>sequenceNum</Name>
				<Source><![CDATA[
    Counter sequenceNum(CustVendPaymModeTable    _custVendPaymModeTable)
    {
        if (!trackedPaymModeSequences)
        {
            return 0;
        }

        trackedPaymModeSequences.find(_custVendPaymModeTable);

        return _custVendPaymModeTable.LastSequenceNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether to add a select button to the dialog box.
    /// </summary>
    /// <returns>
    ///    Always returns false.
    /// </returns>
    /// <remarks>
    ///    If you click this button, it will show the query form. Therefore, the <c>queryRun</c> method has to
    ///    return a valid <c>queryRun</c> class. If you change the return value to true, the button will be
    ///    added.
    /// </remarks>
    public boolean showQueryValues()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>trackSequenceOnPaymMode</Name>
				<Source><![CDATA[
    protected void trackSequenceOnPaymMode(CustVendPaymModeTable    _paymModeTable)
    {
        #define.RecIdFieldName('RecId')

        DictTable   dictTable;
        DictField   dictField;

        if (!trackedPaymModeSequences)
        {
            trackedPaymModeSequences = new RecordSortedList(_paymModeTable.TableId);

            dictTable = new DictTable(_paymModeTable.TableId);

            dictField = new DictField(dictTable.id(), dictTable.fieldName2Id(#RecIdFieldName));

            trackedPaymModeSequences.sortOrder(dictField.id());
        }

        if (!trackedPaymModeSequences.find(_paymModeTable))
        {
            _paymModeTable.CustVendPaymModeTable::incLastSequenceNum();
            trackedPaymModeSequences.ins(_paymModeTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version     version;
        container   packedPrinterSettings, packedOutPaymRecordList, packedValues;

        version = RunBase::getVersion(_packedClass);

        switch (version)
        {
            case #CurrentVersion:
                [version, packedValues] = _packedClass;

                [#currentList, packedPrinterSettings, packedOutPaymRecordList] = packedValues;

                break;
            case #Version3:
                [version, #currentListV3, packedPrinterSettings] = _packedClass;

                break;
            case 1, 2:
                [version, filename, printControlReport] = _packedClass;
                break;
            default:
                return false;
        }

        if (packedPrinterSettings)
        {
            // Recreate the object from the packed values.
            custVendPaymPrinterSettings = CustVendPaymPrinterSettings::newForPackedPrinterSettings(packedPrinterSettings);
        }
        else
        {
            custVendPaymPrinterSettings = new CustVendPaymPrinterSettings();
        }

        if (packedOutPaymRecordList)
        {
            // Recreate the object from the packed values.
            outPaymRecordList = List::create(packedOutPaymRecordList);
        }
        else
        {
            outPaymRecordList = new List(Types::Class);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpackSysLastValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Unpacks the data required for <c>SysLastValues</c>.
    /// </summary>
    /// <param name="_packedValues">
    ///    The values stored by the <c>SysLastValues</c> framework that are to be unpacked.
    /// </param>
    /// <remarks>
    ///    The pack and unpack pattern does not have provisions for supporting different serialization and
    ///    <c>SysLastValues</c> pack lists. This separate packing mechanism has been implemented for
    ///    <c>SysLastValues</c> and is first defined on the class one level above the <c>RunBase</c> or
    ///    <c>RunBaseBatch</c> class. Derivative classes also implement this method so that a whole object can
    ///    be unpacked for <c>SysLastValues</c>.
    /// </remarks>
    protected void unpackSysLastValues(container _packedValues)
    {
        Version version = RunBase::getVersion(_packedValues);
        container packedPrinterSettings;

        switch (version)
        {
            case #SysLastValuesCurrentVersion:
                [version, #SysLastValuesList, packedPrinterSettings] = _packedValues;
                break;

            case #SysLastValuesVersion2:
                [version, #SysLastValuesListV2, packedPrinterSettings] = _packedValues;
                break;
        }

        if (packedPrinterSettings)
        {
            // Recreate the object from the packed values.
            custVendPaymPrinterSettings = CustVendPaymPrinterSettings::newForPackedPrinterSettings(packedPrinterSettings);
        }
        else
        {
            custVendPaymPrinterSettings = new CustVendPaymPrinterSettings();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpackValues</Name>
				<Source><![CDATA[
    public boolean unpackValues(container _packedClass, boolean _isSwapping = false)
    {
        boolean ret;

        isSwapping = _isSwapping;
        ret = this.unpack(_packedClass);
        isSwapping = false;
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatingLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to allow additional <c>LedgerJournalTrans</c> fields to be updated.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> object to be updated.
    /// </param>
    /// <param name = "_custVendOutPaymRecord">
    /// The <c>CustVendOutPaymRecord</c> record selected for payment format generation.
    /// </param>
    /// <param name = "_generateRemittanceFeeTrans">
    /// A Boolean value that indicates whether the <c>RemittanceFeeTrans</c> value should be generated.
    /// </param>
    delegate void updatingLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans, CustVendOutPaymRecord _custVendOutPaymRecord, boolean _generateRemittanceFeeTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>LedgerJournalTrans</c> record after processing it.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> object to be updated.
    /// </param>
    /// <param name="_custVendOutPaymRecord">
    /// The <c>CustVendOutPaymRecord</c> record selected for payment format generation.
    /// </param>
    /// <param name="_generateRemittanceFeeTrans">
    /// A Boolean value that indicates whether the <c>RemittanceFeeTrans</c> value should be generated.
    /// </param>
    protected void updateLedgerJournalTrans(
        LedgerJournalTrans _ledgerJournalTrans,
        CustVendOutPaymRecord _custVendOutPaymRecord,
    boolean _generateRemittanceFeeTrans)
    {
        LedgerJournalTrans  ledgerJournalTrans = _ledgerJournalTrans;

        if (! this.parmClientBank_RU())
        {
            ledgerJournalTrans.PaymentStatus = _custVendOutPaymRecord.paymStatus();
        }
        ledgerJournalTrans.PaymentSequenceNum = this.sequenceNum(CustVendPaymModeTable::findCommon(_ledgerJournalTrans));
        ledgerJournalTrans.FileCreated = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

        if (_generateRemittanceFeeTrans)
        {
            ledgerJournalTrans.generateRemittanceFeeTrans();
        }

        this.updatingLedgerJournalTrans(ledgerJournalTrans, _custVendOutPaymRecord, _generateRemittanceFeeTrans);

        ledgerJournalTrans.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePrinterSettings</Name>
				<Source><![CDATA[
    public void updatePrinterSettings(PaymDocumentType _documentType, container _printerSettings)
    {
        custVendPaymPrinterSettings.updatePrinterSettings(_documentType, _printerSettings);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Enables applying export format specific criteria on the <c>QueryRun</c> class object supplied to
    ///    the class.
    /// </summary>
    protected void updateQuery()
    {
        QueryBuildRange queryBuildRange;

        queryBuildRange = queryRun.query().dataSourceTable(tableNum(LedgerJournalTrans)).findRange(fieldNum(LedgerJournalTrans, JournalNum));

        if (queryBuildRange)
        {
            queryBuildRange.value(queryValue(ledgerJournalId));
        }

        this.addGeneratePaymentLinesSort(queryRun);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the state of the internal variables.
    /// </summary>
    /// <param name="_calledFrom">
    ///    Identifies the object from which this method is called. Default value is null.
    /// </param>
    /// <returns>
    ///    true if the internal variables are valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method must validate the state of the internal variables. It is called before closing the
    ///    dialog, and should be called in the <c>run</c> method.
    ///    It must only contain code that adds
    ///    warnings to the infolog.
    ///    throw is not allowed within this method.
    ///    The method should generally
    ///    return errors using the <c>Global::CheckFailed</c> method.
    ///    Export formats that are designed to
    ///    handle only one method of payment per payment media must call the <c>checkUniquePaymMode</c> method.
    /// </remarks>
    boolean validate(Object _calledFrom = null)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProgressLogger</Name>
				<Source><![CDATA[
    internal SysInstrumentationProgressLogger createProgressLogger()
    {
        str sourceName = CustVendInstrumentationFormatter::sourceNameWithModule(CustVendInstrumentationConstants::SourceNamePaymentGeneration, this.getModuleCustVend());

        return SysInstrumentationProgressLogger::createLogger(sourceName, CustVendInstrumentationConstants::InstrumentationNamespace);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getModuleCustVend</Name>
				<Source><![CDATA[
    private ModuleCustVend getModuleCustVend()
    {
        ModuleCustVend moduleCustVend;

        switch (this.dialogPrintOptionMenuItemPrefix())
        {
            case 'Cust':
                moduleCustVend = ModuleCustVend::Cust;
                break;

            case 'Vend':
                moduleCustVend = ModuleCustVend::Vend;
                break;
        }

        return ModuleCustVend;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findQueryRecordCount</Name>
				<Source><![CDATA[
    internal Counter findQueryRecordCount()
    {
        return QueryRun::getQueryRowCount(this.parmQueryRun().query(), intMax());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getClassName</Name>
				<Source><![CDATA[
    internal str getClassName()
    {
        return classId2Name(classIdGet(this));
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static Object construct(CustVendPaymModeClassId _classId)
    {
        CustVendOutPaym custVendOutPaym;

        if (! SysDictClass::isSuperclass(_classId, classNum(CustVendOutPaym)))
        {
            throw error("@SYS55187");
        }

        custVendOutPaym = new DictClass(_classId).makeObject();

        return custVendOutPaym;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustVendPaymFormat</Name>
				<Source><![CDATA[
    public static Object newCustVendPaymFormat(Common _paymFormat)
    {
        classId classId;

        CustPaymFormat  custPaymFormat;
        VendPaymFormat  vendPaymFormat;

        switch (_paymFormat.TableId)
        {
            case tableNum(CustPaymFormat):
                custPaymFormat = _paymFormat;
                classId = custPaymFormat.ClassId;

                if (! classId)
                {
                    throw error(strFmt("@SYS63358", "@SYS66246", custPaymFormat.Format, ''));
                }
                if (! SysDictClass::isSuperclass(classId,classNum(CustOutPaym)))
                {
                    throw error(strFmt("@SYS79732", custPaymFormat.Format));
                }
                break;

            case tableNum(VendPaymFormat):
                vendPaymFormat = _paymFormat;
                classId = vendPaymFormat.ClassId;

                if (! classId)
                {
                    throw error(strFmt("@SYS63358", "@SYS66246", vendPaymFormat.Format, ''));
                }
                if (! SysDictClass::isSuperclass(classId,classNum(VendOutPaym)))
                {
                    throw error(strFmt("@SYS79732", vendPaymFormat.Format));
                }

                break;
        }

        return CustVendOutPaym::construct(classId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustVendPaymInvoiceWithJournal</Name>
				<Source><![CDATA[
    public static CustVendOutPaym newCustVendPaymInvoiceWithJournal(CustVendPaymInvoiceWithJournal  _custVendPaymInvoiceWithJournal)
    {
        classId classId = _custVendPaymInvoiceWithJournal.parmPaymModeTable().ClassId;
        CustVendOutPaym custVendOutPaym;

        if (!classId)
        {
            throw error("@SYS82371");
        }

        custVendOutPaym = CustVendOutPaym::construct(classId);
        custVendOutPaym.parmLastValueDesignName(classId2Name(classIdGet(_custVendPaymInvoiceWithJournal)));
        custVendOutPaym.getLast();

        custVendOutPaym.parmLedgerJournalId(_custVendPaymInvoiceWithJournal.parmLedgerJournalId());

        if (_custVendPaymInvoiceWithJournal.parmPaymModeTable().AccountType == LedgerJournalACType::Bank)
        {
            switch (_custVendPaymInvoiceWithJournal.parmPaymModeTable().ClassId)
            {
                case classNum(CustBillOfExchangeDocument_ES):
                case classNum(VendOutPaym_Cheque):
                case classNum(CustOutPaym_Cheque):
                    custVendOutPaym.parmBankAccountID(_custVendPaymInvoiceWithJournal.parmPaymModeTable().parmPaymAccount());
                    break;
            }
        }

        custVendOutPaym.parmQueryRun(new QueryRun(_custVendPaymInvoiceWithJournal.parmQuery()));
        custVendOutPaym.updateQuery();

        return custVendOutPaym;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustVendPaymModeTable</Name>
				<Source><![CDATA[
    public static CustVendOutPaym newCustVendPaymModeTable(CustVendPaymModeTable    _custVendPaymModeTable)
    {
        return CustVendOutPaym::construct(_custVendPaymModeTable.ClassId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendPaymModeClassIdDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to provide a payment classId.
    /// </summary>
    /// <param name = "_sumForPaym">
    /// Identifies payment parameters.
    /// </param>
    /// <param name = "_classIdResult">
    /// An <c>EventHandlerResult</c> where the classId result can be returned.
    /// </param>
    static delegate void getCustVendPaymModeClassIdDelegate(CustVendSumForPaym _sumForPaym, EventHandlerResult _classIdResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendPaymModeClassIdDelegateHandler</Name>
				<Source><![CDATA[
    [SubscribesTo(classStr(CustVendOutPaym), staticDelegateStr(CustVendOutPaym, getCustVendPaymModeClassIdDelegate))]
    public static void getCustVendPaymModeClassIdDelegateHandler(CustVendSumForPaym _sumForPaym, EventHandlerResult _classIdResult)
    {
        if (_sumForPaym.parmClientBank_RU())
        {
            CustVendPaymModeTable paymModeTable = _sumForPaym.paymModeTable();
            if (paymModeTable.BankClientClassId_RU)
            {
                _classIdResult.result(paymModeTable.BankClientClassId_RU);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendPaymModeClassId</Name>
				<Source><![CDATA[
    private static CustVendPaymModeClassId getCustVendPaymModeClassId(CustVendSumForPaym _sumForPaym)
    {
        CustVendPaymModeClassId classId;

        boolean isRemittanceFormat = (_sumForPaym.bankFormat() == BankFormat::Remittance);

        if (_sumForPaym.parmSelectOnPaymFormat())
        {
            classId = _sumForPaym.paymFormatTable().ClassId;
        }
        else
        {
            CustVendPaymModeTable custVendPaymModeTable = _sumForPaym.paymModeTable();

            if (isRemittanceFormat)
            {
                classId = custVendPaymModeTable.ClassIdRemittance;
            }
            else
            {
                classId = custVendPaymModeTable.ClassId;
            }
        }

        EventHandlerResult classIdResult = new EventHandlerResult();
        CustVendOutPaym::getCustVendPaymModeClassIdDelegate(_sumForPaym, classIdResult);
        if (classIdResult.hasResult())
        {
            classId = classIdResult.result();
        }

        if (!classId)
        {
            if (isRemittanceFormat)
            {
                throw error("@CashManagement:RemittanceFormatMissing");
            }
            else
            {
                throw error("@SYS82371");
            }
        }

        return classId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendPaymModeTableDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to provide a <c>CustVendPaymModeTable</c> buffer.
    /// </summary>
    /// <param name = "_sumForPaym">
    /// Identifies payment parameters.
    /// </param>
    /// <param name = "_paymModeTableResult">
    /// An <c>EventHandlerResult</c> where the <c>CustVendPaymModeTable</c> result can be returned.
    /// </param>
    static delegate void getCustVendPaymModeTableDelegate(CustVendSumForPaym _sumForPaym, EventHandlerResult _paymModeTableResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendPaymModeTable</Name>
				<Source><![CDATA[
    private static CustVendPaymModeTable getCustVendPaymModeTable(CustVendSumForPaym _sumForPaym)
    {
        CustVendPaymModeTable custVendPaymModeTable;

        if (!_sumForPaym.parmSelectOnPaymFormat())
        {
            custVendPaymModeTable = _sumForPaym.paymModeTable();
        }

        EventHandlerResult paymModeTableResult = new EventHandlerResult();
        CustVendOutPaym::getCustVendPaymModeTableDelegate(_sumForPaym, paymModeTableResult);
        if (paymModeTableResult.hasResult())
        {
            custVendPaymModeTable = paymModeTableResult.result();
        }

        return custVendPaymModeTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializingNewCustVendSumForPaym</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to initialize <c>CustVendOutPaym</c>.
    /// </summary>
    /// <param name = "_sumForPaym">
    /// Identifies the payment parameters.
    /// </param>
    /// <param name = "_custVendOutPaym">
    /// The <c>CustVendOutPaym</c> instance that can be initialized.
    /// </param>
    static delegate void initializingNewCustVendSumForPaym(CustVendSumForPaym _sumForPaym, CustVendOutPaym _custVendOutPaym)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeNewCustVendSumForPaym</Name>
				<Source><![CDATA[
    private static void initializeNewCustVendSumForPaym(CustVendSumForPaym _sumForPaym, CustVendOutPaym _custVendOutPaym)
    {
        _custVendOutPaym.getLast();

        _custVendOutPaym.parmLedgerJournalId(_sumForPaym.parmLedgerJournalId());
        _custVendOutPaym.parmBankAccountID(_sumForPaym.parmBankAccountID());

        // Defines the sequence of the date, -1 applies the current user's preferences
        int monthDayYearSequence = -1;
        str currentDateTime = DateTimeUtil::toFormattedStr(DateTimeUtil::applyTimeZoneOffset(DateTimeUtil::utcNow(), DateTimeUtil::getUserPreferredTimeZone()),
            monthDayYearSequence,
            DateDay::Digits2,
            DateSeparator::None,
            DateMonth::Digits2,
            DateSeparator::None,
            DateYear::Digits4,
            TimeSeparator::Dot,
            TimeSeparator::Dot,
            DateFlags::None);
        Filename generatedFilename = strFmt('%1_%2_%3.txt', _custVendOutPaym.parmLedgerJournalId(), _custVendOutPaym.parmBankAccountID(), currentDateTime);
        _custVendOutPaym.parmFilename(generatedFilename);

        Args args = _sumForPaym.parmArgs();
        _custVendOutPaym.userInteraction(args);

        CustVendPaymModeTable custVendPaymModeTable = CustVendOutPaym::getCustVendPaymModeTable(_sumForPaym);
        _custVendOutPaym.parmPaymMode(custVendPaymModeTable.PaymMode);

        _custVendOutPaym.parmClientBank_RU(_sumForPaym.parmClientBank_RU());

        _custVendOutPaym.parmQueryRun(new QueryRun(_sumForPaym.queryRun().pack()));
        _custVendOutPaym.updateQuery();
        _custVendOutPaym.saveLast();

        CustVendOutPaym::initializingNewCustVendSumForPaym(_sumForPaym, _custVendOutPaym);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustVendSumForPaym</Name>
				<Source><![CDATA[
    public static CustVendOutPaym newCustVendSumForPaym(CustVendSumForPaym _sumForPaym)
    {
        CustVendPaymModeClassId classId = CustVendOutPaym::getCustVendPaymModeClassId(_sumForPaym);

        CustVendOutPaym custVendOutPaym = CustVendOutPaym::construct(classId);

        CustVendOutPaym::initializeNewCustVendSumForPaym(_sumForPaym, custVendOutPaym);

        return custVendOutPaym;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFile</Name>
				<Source><![CDATA[
    public static StreamIo newFile(int _codepage, StreamType _type = StreamType::AsciiIo)
    {
        StreamIo fileIo;

        switch (_type)
        {
            case StreamType::AsciiIo:
                fileIo = TextStreamIo::constructForWrite(_codepage);
                break;

            case StreamType::CommaIo:
                fileIo = CommaTextStreamIo::constructForWrite(_codepage);
                break;

            default:
                throw error ("@SYS62665");
        }

        return fileIo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>appendToFile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>StreamIo</c> class to be used for appending to a <c>System.IO.Stream</c>.
    /// </summary>
    /// <param name = "_stream">
    /// The <c>System.IO.Stream</c> to append to.
    /// </param>
    /// <param name = "_codePage">
    /// The code page number for the character set to be written to stream.
    /// </param>
    /// <param name = "_type">
    /// The type of <c>StreamIo</c> class to create.
    /// </param>
    /// <returns>
    /// A new instance of the <c>StreamIo</c> class for appending to a <c>System.IO.Stream</c>.
    /// </returns>
    public static StreamIo appendToFile(System.IO.Stream _stream, int _codepage, StreamType _type = StreamType::AsciiIo)
    {
        StreamIo fileIo;

        switch (_type)
        {
            case StreamType::AsciiIo:
                fileIo = TextStreamIo::constructForAppend(_stream, _codepage);
                break;

            case StreamType::CommaIo:
                fileIo = CommaTextStreamIo::constructForAppend(_stream, _codepage);
                break;

            default:
                throw error ("@SYS62665");
        }

        return fileIo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFileASCII</Name>
				<Source><![CDATA[
    protected static AsciiStreamIo newFileASCII()
    {
        return AsciiStreamIo::constructForWrite();
    }

]]></Source>
			</Method>
			<Method>
				<Name>str2SEPAstr</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Converts not authorised Unicode-characters into a SEPA-Transaction.
    /// </summary>
    /// <param name="_strTmp">
    ///  A string to be processed.
    /// </param>
    /// <param name="_charSetNum">
    ///  A number of character set; optional.
    /// </param>
    /// <returns>
    ///  A string with character suitable for SEPA.
    /// </returns>
    public static str str2SEPAstr(str _strTmp, int _charSetNum = 1)
    {
        str             originalChar;
        str             validCharacters;
        System.String   specificCharacters;
        int             originalCharPos;
        int             specificCharPos;
        str             charSets[];
        str             charSet;
        str             ret = _strTmp;

        validCharacters =    @"+,(/)-'(/)-?AAAAAAACEEEEIIIIDNOOOOOOUUUUYsaaaaaaaceeeeiiiidnoooooouuuuyty" +
                             @'AaAaAaCcCcCcDdDdEeEeEeEeGgGgGgIiIiIiIiKkLlLlLlLlNnNnNnOoOoRrRrSsSsSsTtTtUuUuUuUuYZzZzZzE' +
                              ' ';

        new InteropPermission(InteropKind::ClrInterop).assert();

        specificCharacters = @'&;[\]_`{|}~¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝßàáâãäåæçèéêëìíîïðñòóôõöøùúûüýþÿ' +
                             @'ĀāĂăĄąĆćĊċČčĎďĐđĒēĖėĘęĚěĜĝĞğĢģĪīĮįİıĲĳĶķĹĺĻļĽľŁłŃńŅņŇňŐőŒœŔŕŘřŚśŞşŠšŢţŤťŪūŮůŰűŲųŸŹźŻżŽž€' +
                              '\n';

        // Recommended charset for SEPA
        charSets[1] = @"A-Za-z0-9/\-\?:\(\)\.,'\+ ";
        // Additional charset for Austria
        charSets[2] = @'äöüßÄÖÜ&><"\|€$§%!=#~;\*\{\}\[\]@\\_°\^';

        charSet = '[^' + strFmt('%1%2', charSets[1], _charSetNum > 1 ? charSets[_charSetNum] : '') + ']';

        for (originalCharPos = 1; originalCharPos <= strlen(_strTmp); originalCharPos++)
        {
            originalChar = subStr(ret, originalCharPos, 1);

            if (System.Text.RegularExpressions.Regex::IsMatch(originalChar, charSet))
            {
                specificCharPos = specificCharacters.IndexOf(originalChar);

                ret = strPoke(ret, specificCharPos == -1 ? '.' : subStr(validCharacters, specificCharPos + 1, 1), originalCharPos);
            }
        }

        CodeAccessPermission::revertAssert();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>userInteraction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates a version of the <c>CustVendOutPaymUserInteraction</c> class. This class dictates
    /// the interactive or non-interactive payment generation activities.
    /// </summary>
    /// <param name = "_args">Args has data that provides the input to the plugin factory.</param>
    /// <returns>The default object which is interactive or non-default non-interactive object.</returns>
    public CustVendOutPaymUserInteraction userInteraction(Args _args = null)
    {
        if (userInteraction == null)
        {
            if (_args == null)
            {
                throw error(Error::missingParameter(this));
            }

            userInteraction = CustVendOutPaymUserInteraction::constructForGeneration(_args);
        }

        return userInteraction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGeneratePaymentLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether payment lines should be generated.
    /// </summary>
    /// <returns>
    ///     true if payment lines should be generated; otherwise, false.
    /// </returns>
    public boolean canGeneratePaymentLines()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transliterateUmlauts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transliterates German umlauts in the input string.
    /// </summary>
    /// <param name="_strTmp">
    /// Input string.
    /// </param>
    /// <returns>
    /// Input string with transliterated umlauts.
    /// </returns>
    public static str transliterateUmlauts(str _strTmp)
    {
        str charSet = 'ÄäÖöÜüẞß';
        str output = _strTmp;

        if (strFind(output, charSet, 1, intMax()))
        {
            int charCount = strLen(charSet);

            container transliterationRules[charCount];
            transliterationRules[1] = ['Ä', 'Ae'];
            transliterationRules[2] = ['ä', 'ae'];
            transliterationRules[3] = ['Ö', 'Oe'];
            transliterationRules[4] = ['ö', 'oe'];
            transliterationRules[5] = ['Ü', 'Ue'];
            transliterationRules[6] = ['ü', 'ue'];
            transliterationRules[7] = ['ẞ', 'Ss'];
            transliterationRules[8] = ['ß', 'ss'];

            for (int i = 1; i <= charCount; i++)
            {
                str umlaut, replacement;
                [umlaut, replacement] = transliterationRules[i];

                output = System.Text.RegularExpressions.Regex::Replace(output, umlaut, replacement);
            }
        }

        return output;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>