<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventCostTaskController</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>InventCostTaskController</c> class handles task scheduling when running an inventory closing
/// which is scheduled to run in batch.
/// </summary>
class InventCostTaskController
{
    InventParameters    inventParameters;
    InventClosing       inventClosing;
    RefRecId            batchJobId;
    RefRecId            batchRecId;
    Voucher             voucher;
    TransDate           transDate;
    InventClosingRunNum runNum;

    #define.DefaultBundleSize(40)
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addBundleTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a bundle task and adds it to a batch.
    /// </summary>
    /// <param name="_batchHeader">
    /// The instance of the <c>BatchHeader</c> class.
    /// </param>
    /// <param name="_bomLevel">
    /// The level for which the task should run.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventCostBundleTask</c> class.
    /// </returns>
    protected InventCostBundleTask addBundleTask(
                                            BatchHeader     _batchHeader,
                                            BOMLevel        _bomLevel)
    {
        return this.addTaskToBatchHeader(this.inventCostBundleTask(voucher, transDate, _bomLevel), _batchHeader);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addIterationCompletionTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a iteration completion task and adds it to a batch.
    /// </summary>
    /// <param name="_batchHeader">
    /// The instance of the <c>BatchHeader</c> class.
    /// </param>
    /// <param name="_bomLevel">
    /// The level for which the task should run.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventCostIterationCompletionTask</c> class.
    /// </returns>
    protected InventCostIterationCompletionTask addIterationCompletionTask(
                                            BatchHeader     _batchHeader,
                                            BOMLevel        _bomLevel)
    {
        return this.addTaskToBatchHeader(this.inventCostIterationCompletionTask(voucher, transDate, _bomLevel), _batchHeader);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerPostingTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a ledger posting task and adds it to a batch.
    /// </summary>
    /// <param name="_batchHeader">
    /// The instance of the <c>BatchHeader</c> class.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventCostEndTask</c> class.
    /// </returns>
    protected InventCostLedgerPostingTask addLedgerPostingTask(BatchHeader _batchHeader)
    {
        return this.addTaskToBatchHeader(this.inventCostLedgerPostingTask(voucher, transDate), _batchHeader);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLevelCompletionTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a level completion task and adds it to a batch.
    /// </summary>
    /// <param name="_batchHeader">
    /// The instance of the <c>BatchHeader</c> class.
    /// </param>
    /// <param name="_bomLevel">
    /// The level for which the task should run.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventCostLevelCompletionTask</c> class.
    /// </returns>
    protected InventCostLevelCompletionTask addLevelCompletionTask(
                                            BatchHeader     _batchHeader,
                                            BOMLevel        _bomLevel)
    {
        return this.addTaskToBatchHeader(this.inventCostLevelCompletionTask(voucher, transDate, _bomLevel), _batchHeader);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPrepareBatchTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates batch tasks for preparing an inventory closing.
    /// </summary>
    /// <param name="_addParm">
    /// A boolean value that indicates whether the parameter creation task should be added.
    /// </param>
    /// <param name="_addBundle">
    /// A boolean value that indicates whether the bundle task should be added.
    /// </param>
    /// <remarks>
    /// A <c>InventCostBundleTask</c> task will be created for bundling items for the first level.
    /// A <c>InventCostPrepareParmTask</c> task will be created for creating the <c>InventCostListParm</c> table.
    /// A <c>InventCostPrepareCompletionTask</c> task will be created with a dependency to the tasks created.
    /// </remarks>
    protected void addPrepareBatchTask( boolean _addParm,
                                        boolean _addBundle)
    {
        if (_addParm
            || _addBundle)
        {
            ttsbegin;
            BatchHeader batchHeader = this.batchHeader(batchJobId);

            InventCostPrepareCompletionTask inventCostPrepareCompletionTask = this.addPrepareCompletionTask(batchHeader);

            if (_addBundle)
            {
                InventCostBundleTask inventCostBundleTask = this.addBundleTask(batchHeader, this.getFirstLevel());
                batchHeader.addDependency(inventCostPrepareCompletionTask, inventCostBundleTask, BatchDependencyStatus::FinishedOrError);
            }

            if (_addParm)
            {
                InventCostPrepareParmTask inventCostPrepareParmTask = this.addPrepareParmTask(batchHeader);
                batchHeader.addDependency(inventCostPrepareCompletionTask, inventCostPrepareParmTask, BatchDependencyStatus::FinishedOrError);
            }

            batchHeader.save();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPrepareCompletionTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a preparation completion task and adds it to a batch.
    /// </summary>
    /// <param name="_batchHeader">
    /// The instance of the <c>BatchHeader</c> class.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventCostPrepareCompletionTask</c> class.
    /// </returns>
    protected InventCostPrepareCompletionTask addPrepareCompletionTask(BatchHeader  _batchHeader)
    {
        return this.addTaskToBatchHeader(this.inventCostPrepareCompletionTask(voucher, transDate), _batchHeader);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPrepareParmTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a parameter creation task and adds it to a batch.
    /// </summary>
    /// <param name="_batchHeader">
    /// The instance of the <c>BatchHeader</c> class.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventCostPrepareParmTask</c> class.
    /// </returns>
    protected InventCostPrepareParmTask addPrepareParmTask(BatchHeader  _batchHeader)
    {
        return this.addTaskToBatchHeader(this.inventCostPrepareParmTask(voucher, transDate), _batchHeader);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addReCalculationTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a recalculation task and adds it to a batch.
    /// </summary>
    /// <param name="_batchHeader">
    /// The instance of the <c>BatchHeader</c> class.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventCostReCalculationTask</c> class.
    /// </returns>
    protected InventCostReCalculationTask addReCalculationTask(
                                    BatchHeader     _batchHeader)
    {
        return this.addTaskToBatchHeader(this.inventCostReCalculationTask(voucher, transDate), _batchHeader);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTaskToBatchHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the batch information and adds the task to the batch header.
    /// </summary>
    /// <param name="_task">
    /// The instance of a task that will be added to the batch header.
    /// </param>
    /// <param name="_batchHeader">
    /// The instance of the <c>BatchHeader</c> class.
    /// </param>
    /// <returns>
    /// The instance of the task added to the batch header.
    /// </returns>
    private RunBaseBatch addTaskToBatchHeader(  RunBaseBatch    _task,
                                                BatchHeader     _batchHeader)
    {
        _task.batchInfo().resetBatchHeader();
        _task.batchInfo().parmGroupId(inventParameters.CloseBatchGroupId);

        _batchHeader.addRuntimeTask(_task, batchRecId);

        return _task;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignBundle</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates bundle records and assign item tasks to each bundle.
    /// </summary>
    /// <param name="_bomLevel">
    /// The level for which bundles should be created.
    /// </param>
    /// <param name="_numOfIteration">
    /// The iteration for which bundles should be created.
    /// </param>
    public void assignBundle(   BOMLevel        _bomLevel,
                                NumOfIteration  _numOfIteration)
    {
        InventCostList          inventCostList;
        RecId                   minRecId, maxRecId;
        RecId                   startRecId, endRecId;

        inventCostList.readPast(true);

        // find a block of contiguous tasks
        select firstonly RecId from inventCostList
            order by RecId asc
            where inventCostList.Voucher == voucher
               && inventCostList.bomLevel == _bomLevel
               && inventCostList.NumOfIteration == _numOfIteration
               && inventCostList.Bundle == 0;

        minRecId = inventCostList.RecId;
        startRecId = minRecId;

        select firstonly RecId from inventCostList
            order by RecId desc
            where inventCostList.Voucher == voucher
               && inventCostList.bomLevel == _bomLevel
               && inventCostList.NumOfIteration == _numOfIteration
               && inventCostList.Bundle == 0;

        maxRecId = inventCostList.RecId;

        InventCostBundleSize bundleSize = this.getBundleSize();

        while (startRecId <= maxRecId)
        {
            endRecId = startRecId + bundleSize - 1;

            ttsbegin;
            InventCostBundleRecId bundleRecId = this.createBundle(_bomLevel);

            update_recordset inventCostList
                setting Bundle = bundleRecId
            where inventCostList.Voucher == voucher
               && inventCostList.bomLevel == _bomLevel
               && inventCostList.NumOfIteration == _numOfIteration
               && inventCostList.Bundle == 0
               && inventCostList.RecId >= startRecId
               && inventCostList.RecId <= min(endRecId, maxRecId);
            ttscommit;

            startRecId = endRecId + 1;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>batchHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes a new instance of the <c>BatchHeader</c> class.
    /// </summary>
    /// <param name="_batchJobId">
    ///     The batch job ID under which tasks will be created.
    /// </param>
    /// <returns>
    ///     The instance of the <c>BatchHeader</c> class or null in case
    ///     _batchJobId doesn't exist.
    /// </returns>
    protected BatchHeader batchHeader(RefRecId _batchJobId = batchJobId)
    {
        return BatchHeader::construct(batchJobId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>bomLevelToProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the start level to process.
    /// </summary>
    /// <returns>
    /// The level that should be processed.
    /// </returns>
    /// <remarks>
    /// The return value can be -1 which indicates that no levels should be processed.
    /// </remarks>
    protected BOMLevel bomLevelToProcess()
    {
        BOMLevel bomLevel = this.bomLevelWaitingBundles();
        if (bomLevel == -1)
        {
            // No waiting bundles - Check waiting items
            bomLevel = this.bomLevelWaitingItems();
        }

        return bomLevel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bomLevelWaitingBundles</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the level for any waiting bundles.
    /// </summary>
    /// <returns>
    /// The level that should be processed.
    /// </returns>
    /// <remarks>
    /// The return value can be -1 which indicates that no levels should be processed.
    /// </remarks>
    private BOMLevel bomLevelWaitingBundles()
    {
        InventCostBundleList    inventCostBundleList;

        // Check for bundles not processed yet
        select firstonly Level from inventCostBundleList
            order by Level desc
            where inventCostBundleList.InventClosing == inventClosing.RecId
               && inventCostBundleList.ProcessingState == InventCostBundleState::Waiting;

        if (inventCostBundleList)
        {
            return inventCostBundleList.Level;
        }

        return -1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bomLevelWaitingItems</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the level for any waiting items.
    /// </summary>
    /// <returns>
    /// The level that should be processed.
    /// </returns>
    /// <remarks>
    /// The return value can be -1 which indicates that no levels should be processed.
    /// </remarks>
    private BOMLevel bomLevelWaitingItems()
    {
        InventCostList          inventCostList;

        // Check for items not assigned to bundle yet
        select firstonly bomLevel from inventCostList
            order by bomLevel desc
            where inventCostList.Voucher == voucher
               && inventCostList.Bundle == 0;

        if (inventCostList)
        {
            return inventCostList.bomLevel;
        }

        return -1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>continueExecution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the calculation should continue to run.
    /// </summary>
    /// <returns>
    /// true if the calculation should continue to run; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The calculation will stop running if the run is paused action has been taken
    /// or an error occurs while doing the claculation.
    /// </remarks>
    public boolean continueExecution()
    {
        return (inventClosing.RunNum         == runNum    &&
                inventClosing.StopRunning    == NoYes::No);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBatchTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates batch task for calculation one level.
    /// </summary>
    /// <param name="_bomLevel">
    /// The level for which the tasks should be created.
    /// </param>
    /// <remarks>
    /// A number of tasks will be created for a given level which is controlled by settings in the Inventory parameters.
    /// - A <c>InventCostBundleTask</c> task will be created for bundling items for the next level.
    /// - <c>CloseBatchHelpers</c> will determine how many calculation tasks that will be created for the level.
    ///   One of the calculation tasks will be waiting for the bundle task to complete.
    /// - A <c>InventCostLevelCompletionTask</c> task will be created with a dependency to the calculation tasks.
    /// </remarks>
    public void createBatchTasks(   BOMLevel    _bomLevel = this.getFirstLevel())
    {
        InventCostTaskBase              inventCostCompletionTask;
        InventCostBundleTask            inventCostBundleTask;

        int i;

        ttsbegin;

        BOMLevel totalBomLevel = this.getFirstLevel();
        NumberOf batchHelpers = max(1, inventParameters.CloseBatchHelpers);

        // Assign bundle to first level task
        if (this.continueExecution())
        {
            BatchHeader batchHeader = this.batchHeader();

            if (_bomLevel == -1)
            {
                this.createEndBatchTask(batchHeader, inventClosing.RunRecalculation);
            }
            else
            {
                if (_bomLevel == 0)
                {
                    // Check if items have been added for recalculation and assign to bundles
                    if (this.remainingItems(voucher, _bomLevel, inventClosing.NumOfIteration))
                    {
                        if (inventClosing.NumOfIteration)
                        {
                            this.createInventCostListForIteration(inventClosing.NumOfIteration);
                        }

                        this.assignBundle(0, inventClosing.NumOfIteration);

                        inventCostCompletionTask = this.addIterationCompletionTask(batchHeader, _bomLevel);
                    }
                    else
                    {
                        inventCostCompletionTask = this.addLevelCompletionTask(batchHeader, _bomLevel);
                    }
                }
                else
                {
                    inventCostCompletionTask = this.addLevelCompletionTask(batchHeader, _bomLevel);

                    inventCostBundleTask = this.addBundleTask(batchHeader, _bomLevel-1);
                }

                for (i = 1; i <= batchHelpers; i++)
                {
                    InventCostCalculateTask inventCostCalculateTask = this.inventCostCalculateTask(voucher, transDate, _bomLevel, totalBomLevel);

                    inventCostCalculateTask.batchInfo().resetBatchHeader();
                    inventCostCalculateTask.batchInfo().parmGroupId(inventParameters.CloseBatchGroupId);

                    batchHeader.addRuntimeTask(inventCostCalculateTask, batchRecId);

                    if (i == 1 &&
                        inventCostBundleTask)
                    {
                        batchHeader.addDependency(inventCostCalculateTask, inventCostBundleTask, BatchDependencyStatus::FinishedOrError);
                    }

                    batchHeader.addDependency(inventCostCompletionTask, inventCostCalculateTask, BatchDependencyStatus::FinishedOrError);
                }
            }

            batchHeader.save();

            this.updateClosingRecord();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventCostListForIteration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the work list for an inventory closing iteration.
    /// </summary>
    /// <param name = "_numOfIteration">The closing iteration.</param>
    /// <remarks>Recreate data in InventCostList to avoid duplicates.</remarks>
    protected void createInventCostListForIteration(NumOfIteration _numOfIteration)
    {
        InventCostList                          inventCostList;
        InventCostClosingIterationUpdateView    inventCostClosingIterationUpdateView;

        delete_from inventCostList
            where inventCostList.Voucher         == voucher
                && inventCostList.NumOfIteration == _numOfIteration
                && inventCostList.Bundle         == 0;

        insert_recordset inventCostList (ItemId, NumOfIteration, Voucher)
        select ItemId, NumOfIteration, Voucher
        from inventCostClosingIterationUpdateView
        order by Transactions desc
            where inventCostClosingIterationUpdateView.Voucher         == voucher
                && inventCostClosingIterationUpdateView.NumOfIteration == _numOfIteration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBundle</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the bundle record.
    /// </summary>
    /// <param name="_level">
    /// The level for which bundles should be created.
    /// </param>
    /// <returns>
    /// The ID of the created bundle record.
    /// </returns>
    protected InventCostBundleRecId createBundle(BOMLevel _level)
    {
        InventCostBundleList    inventCostBundleList;

        inventCostBundleList.ProcessingState = InventCostBundleState::Waiting;
        inventCostBundleList.InventClosing = inventClosing.RecId;
        inventCostBundleList.Level = _level;
        inventCostBundleList.insert();

        return inventCostBundleList.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createEndBatchTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates batch task for ending process of an inventory closing.
    /// </summary>
    /// <param name="_batchHeader">
    /// The instance of the <c>BatchHeader</c> class.
    /// </param>
    /// <param name="_runRecalculation">
    /// A boolean value that indicates whether recalculation should be run.
    /// </param>
    /// <remarks>
    /// A <c>InventCostLedgerPostingTask</c> task will be created.
    /// In case of recalculation the <c>InventCostReCalculationTask</c> task will be added to the batch with a dependency to the <c>InventCostLedgerPostingTask</c> task.
    /// </remarks>
    protected void createEndBatchTask(  BatchHeader                     _batchHeader,
                                        InventCostRunRecalculation      _runRecalculation
                                        )
    {
        InventCostLedgerPostingTask inventCostLedgerPostingTask = this.addLedgerPostingTask(_batchHeader);

        if (_runRecalculation)
        {
            InventCostReCalculationTask inventCostReCalculationTask = this.addReCalculationTask(_batchHeader);

            _batchHeader.addDependency(inventCostReCalculationTask, inventCostLedgerPostingTask, BatchDependencyStatus::FinishedOrError);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPrepareBatchTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates batch task for preparing an inventory closing.
    /// </summary>
    /// <remarks>
    /// A <c>InventCostBundleTask</c> task will be created for bundling items for the first level.
    /// A <c>InventCostPrepareParmTask</c> task will be created for creating the <c>InventCostListParm</c> table.
    /// A <c>InventCostPrepareCompletionTask</c> task will be created with a dependency to the tasks created.
    /// </remarks>
    public void createPrepareBatchTask()
    {
        if (this.continueExecution())
        {
            ttsbegin;
            this.addPrepareBatchTask(true, true);

            this.updateClosingRecord();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteBundles</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes all bundles associated to a inventory closing record.
    /// </summary>
    public void deleteBundles()
    {
        InventCostBundleList inventCostBundleList;

        delete_from inventCostBundleList
            where inventCostBundleList.InventClosing == inventClosing.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBundleSize</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the bundle size.
    /// </summary>
    /// <returns>
    /// The size of the bundle specified in inventory parameters.
    /// </returns>
    /// <remarks>
    /// If the bundle size has not been defined in the inventory parameters,
    /// the default size will be used and the inventory parameters updated.
    /// </remarks>
    protected InventCostBundleSize getBundleSize()
    {
        if (inventParameters.CloseBundleSize <= 0)
        {
            ttsbegin;
            inventParameters = InventParameters::find(true);
            inventParameters.CloseBundleSize = #DefaultBundleSize;
            inventParameters.update();
            ttscommit;
        }

        return inventParameters.CloseBundleSize;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the first level to process.
    /// </summary>
    /// <returns>
    /// The first level that should be processed.
    /// </returns>
    public BOMLevel getFirstLevel()
    {
        InventCostList  inventCostList;

        select firstonly bomLevel from inventCostList
            order by bomLevel desc
            where inventCostList.Voucher == voucher;

        return inventCostList.bomLevel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles errors when the inventory closing is running.
    /// </summary>
    /// <remarks>
    /// Sets the <c>StopRunning</c> flag to yes in the <c>InventClosing</c> record.
    /// </remarks>
    public void handleError()
    {
        CostManagementInstrumentationLogger instrumentationLogger = CostManagementInstrumentationLogger::createLogger(classStr(InventCostTaskController));
        
        using (var closingTaskControllerActivityContext = instrumentationLogger.closingTaskControllerActivities().stop(inventClosing))
        {
            ttsbegin;
            inventClosing = InventClosing::find(voucher, transDate, true);
            if (inventClosing)
            {
                inventClosing.setStopRunning(NoYes::Yes, NoYes::Yes);
                inventClosing.update();
            }
            ttscommit;
            error(strFmt("@SYS112625", inventClosing.AdjustmentType));
            info("@SYS112626");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the task controller.
    /// </summary>
    protected void init()
    {
        inventClosing = InventClosing::find(voucher, transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostBundleTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>InventCostBundleTask</c> class.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher of the inventory closing.
    /// </param>
    /// <param name="_transDate">
    /// The date of the inventory closing.
    /// </param>
    /// <param name="_bomLevel">
    /// The level for which the inventory closing should be performed.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventCostBundleTask</c> class.
    /// </returns>
    protected InventCostBundleTask inventCostBundleTask(
        Voucher             _voucher,
        TransDate           _transDate,
        BOMLevel            _bomLevel
    )
    {
        return InventCostBundleTask::newTask(_voucher, _transDate, _bomLevel);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostCalculateTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>InventCostCalculateTask</c> class.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher of the inventory closing.
    /// </param>
    /// <param name="_transDate">
    /// The date of the inventory closing.
    /// </param>
    /// <param name="_bomLevel">
    /// The level for which the inventory closing should be performed.
    /// </param>
    /// <param name="_totalBomLevel">
    /// The total levels for which the inventory closing should be performed.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventCostCalculateTask</c> class.
    /// </returns>
    protected InventCostCalculateTask inventCostCalculateTask(
        Voucher             _voucher,
        TransDate           _transDate,
        BOMLevel            _bomLevel,
        BOMLevel            _totalBomLevel
    )
    {
        return InventCostCalculateTask::newTask(_voucher, _transDate, _bomLevel, _totalBomLevel);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostIterationCompletionTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>InventCostIterationCompletionTask</c> class.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher of the inventory closing.
    /// </param>
    /// <param name="_transDate">
    /// The date of the inventory closing.
    /// </param>
    /// <param name="_bomLevel">
    /// The level for which the inventory closing should be performed.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventCostIterationCompletionTask</c> class.
    /// </returns>
    protected InventCostIterationCompletionTask inventCostIterationCompletionTask(
        Voucher             _voucher,
        TransDate           _transDate,
        BOMLevel            _bomLevel
        )
    {
        return InventCostIterationCompletionTask::newTask(_voucher, _transDate, _bomLevel);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostLedgerPostingTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>InventCostLedgerPostingTask</c> class.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher of the inventory closing.
    /// </param>
    /// <param name="_transDate">
    /// The date of the inventory closing.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventCostLedgerPostingTask</c> class.
    /// </returns>
    protected InventCostLedgerPostingTask inventCostLedgerPostingTask(
        Voucher             _voucher,
        TransDate           _transDate
    )
    {
        return InventCostLedgerPostingTask::newTask(_voucher, _transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostLevelCompletionTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>InventCostLevelCompletionTask</c> class.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher of the inventory closing.
    /// </param>
    /// <param name="_transDate">
    /// The date of the inventory closing.
    /// </param>
    /// <param name="_bomLevel">
    /// The level for which the inventory closing should be performed.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventCostLevelCompletionTask</c> class.
    /// </returns>
    protected InventCostLevelCompletionTask inventCostLevelCompletionTask(
        Voucher             _voucher,
        TransDate           _transDate,
        BOMLevel            _bomLevel
    )
    {
        return InventCostLevelCompletionTask::newTask(_voucher, _transDate, _bomLevel);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostPrepareCompletionTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>InventCostPrepareCompletionTask</c> class.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher of the inventory closing.
    /// </param>
    /// <param name="_transDate">
    /// The date of the inventory closing.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventCostPrepareCompletionTask</c> class.
    /// </returns>
    protected InventCostPrepareCompletionTask inventCostPrepareCompletionTask(
        Voucher             _voucher,
        TransDate           _transDate
    )
    {
        return InventCostPrepareCompletionTask::newTask(_voucher, _transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostPrepareParmTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>InventCostPrepareParmTask</c> class.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher of the inventory closing.
    /// </param>
    /// <param name="_transDate">
    /// The date of the inventory closing.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventCostPrepareParmTask</c> class.
    /// </returns>
    protected InventCostPrepareParmTask inventCostPrepareParmTask(
        Voucher             _voucher,
        TransDate           _transDate
    )
    {
        return InventCostPrepareParmTask::newTask(_voucher, _transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostReCalculationTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>InventCostReCalculationTask</c> class.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher of the inventory closing.
    /// </param>
    /// <param name="_transDate">
    /// The date of the inventory closing.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventCostReCalculationTask</c> class.
    /// </returns>
    protected InventCostReCalculationTask inventCostReCalculationTask(
        Voucher             _voucher,
        TransDate           _transDate
    )
    {
        return InventCostReCalculationTask::newTask(_voucher, _transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventCostBundleListCreated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether bundles has been generated.
    /// </summary>
    /// <returns>
    /// true if bundle task should run again; otherwise, false.
    /// </returns>
    protected boolean isInventCostBundleListCreated()
    {
        InventCostBundleList    inventCostBundleList;

        select firstonly RecId from inventCostBundleList
            where inventCostBundleList.InventClosing == inventClosing.RecId;

        return inventCostBundleList.RecId == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventCostListParmCreated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the calculation parameters has been generated.
    /// </summary>
    /// <returns>
    /// true if parameter creation task should run again; otherwise, false.
    /// </returns>
    protected boolean isInventCostListParmCreated()
    {
        InventCostListParm  inventCostListParm;

        select firstonly RecId from inventCostListParm
            where inventCostListParm.InventClosing == inventClosing.RecId;

        return inventCostListParm.RecId == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventCostListUnbundled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether <c>InventCostList</c> records are bundled.
    /// </summary>
    /// <param name="_bomLevel">
    /// The level for which to check for unbundled items.
    /// </param>
    /// <returns>
    /// true if <c>InventCostList</c> records are not bundled; otherwise, false.
    /// </returns>
    protected boolean isInventCostListUnbundled(BOMLevel _bomLevel)
    {
        InventCostList  inventCostList;

        select firstonly RecId from inventCostList
            where  inventCostList.Voucher == inventClosing.Voucher
                && inventCostList.bomLevel == _bomLevel
                && inventCostList.NumOfIteration == inventClosing.NumOfIteration
                && inventCostList.Bundle == 0;

        return inventCostList.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        inventParameters = InventParameters::find();
    }

]]></Source>
			</Method>
			<Method>
				<Name>numOfIterationToProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the start iteration to process.
    /// </summary>
    /// <returns>
    /// The iteration that should be processed.
    /// </returns>
    /// <remarks>
    /// The return value can be -1 which indicates that no iterations should be processed.
    /// </remarks>
    protected NumOfIteration numOfIterationToProcess()
    {
        NumOfIteration numOfIteration = this.numOfIterationWaitingBundles();
        if (numOfIteration == -1)
        {
            // No waiting bundles - Check waiting items
            numOfIteration = this.numOfIterationWaitingItems();
        }

        return numOfIteration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numOfIterationWaitingBundles</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the iteration for items part of waiting bundles.
    /// </summary>
    /// <returns>
    /// The iteration that should be processed.
    /// </returns>
    /// <remarks>
    /// The return value can be -1 which indicates that no iteration should be processed.
    /// </remarks>
    private NumOfIteration numOfIterationWaitingBundles()
    {
        InventCostBundleList    inventCostBundleList;
        InventCostList          inventCostList;

        select firstonly NumOfIteration
            from inventCostList
            order by NumOfIteration asc
            join ProcessingState
                from inventCostBundleList
            where inventCostList.Voucher == voucher
                && inventCostList.Bundle == inventCostBundleList.RecId
                && inventCostBundleList.ProcessingState == InventCostBundleState::Waiting;

        if (inventCostList)
        {
            return inventCostList.NumOfIteration;
        }

        return -1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numOfIterationWaitingItems</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the iteration for any waiting items.
    /// </summary>
    /// <returns>
    /// The iteration that should be processed.
    /// </returns>
    /// <remarks>
    /// The return value can be -1 which indicates that no iteration should be processed.
    /// </remarks>
    private NumOfIteration numOfIterationWaitingItems()
    {
        InventCostList  inventCostList;

        select firstonly NumOfIteration
            from inventCostList
            order by NumOfIteration asc
            where inventCostList.Voucher == voucher
                && inventCostList.Bundle == 0;

        if (inventCostList)
        {
            return inventCostList.NumOfIteration;
        }

        return -1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBatchJobId</Name>
				<Source><![CDATA[
    public RefRecId parmBatchJobId(RefRecId _batchJobId = batchJobId)
    {
        batchJobId = _batchJobId;

        return batchJobId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBatchRecId</Name>
				<Source><![CDATA[
    public RefRecId parmBatchRecId(RefRecId _batchRecId = batchRecId)
    {
        batchRecId = _batchRecId;

        return batchRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRunNum</Name>
				<Source><![CDATA[
    public InventClosingRunNum parmRunNum(InventClosingRunNum _runNum = runNum)
    {
        runNum = _runNum;

        return runNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransDate</Name>
				<Source><![CDATA[
    public TransDate parmTransDate(TransDate _transDate = transDate)
    {
        transDate = _transDate;

        return transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucher</Name>
				<Source><![CDATA[
    public Voucher parmVoucher(Voucher _voucher = voucher)
    {
        voucher = _voucher;

        return voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainingItems</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether any remaining items exists that has not been bundled.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher of the inventory closing.
    /// </param>
    /// <param name="_bomLevel">
    /// The level for which the check should be performed.
    /// </param>
    /// <param name="_numOfIteration">
    /// The iteration for which bundles should be created.
    /// </param>
    /// <returns>
    /// true if remaining items exist; otherwise, false.
    /// </returns>
    public boolean remainingItems(   Voucher         _voucher,
                                            BOMLevel        _bomLevel,
                                            NumOfIteration  _numOfIteration)
    {
        InventCostList  inventCostList;

        select firstonly RecId from inventCostList
            where inventCostList.Voucher == _voucher
               && inventCostList.bomLevel == _bomLevel
               && inventCostList.NumOfIteration == _numOfIteration
               && inventCostList.Bundle == 0;

        return inventCostList.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCurrentBundleComplete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the current bundle has finished processing,
    /// and if it has not, resets it so that it can be picked up for processing.
    /// </summary>
    /// <param name = "_bomLevel">BOM level of the current bundle.</param>
    /// <returns>true if the current bundle has finished; otherwise false.</returns>
    public boolean isCurrentBundleComplete(BOMLevel _bomLevel)
    {
        boolean isBundleComplete = true;
        InventCostBundleList    inventCostBundleList;

        select firstonly RecId from inventCostBundleList
            where inventCostBundleList.InventClosing == inventClosing.RecId
               && inventCostBundleList.Level == _bomLevel
               && inventCostBundleList.ProcessingState == InventCostBundleState::Processing;

        if (inventCostBundleList.RecId)
        {
            isBundleComplete = false;
        }

        return isBundleComplete;
    }

]]></Source>
			</Method>
			<Method>
				<Name>restartCurrentBundles</Name>
				<Source><![CDATA[
    /// <summary>
    /// Restarts the processing of the current bundles for the supplied bom level.
    /// </summary>
    /// <param name = "_bomLevel">A current <c>BOMLevel</c> to process.</param>
    public void restartCurrentBundles(BOMLevel _bomLevel)
    {
        this.resetBundleState();
        this.createBatchTasks(_bomLevel);
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetBundleState</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the state of all bundles that are currently processing to waiting state.
    /// </summary>
    protected void resetBundleState()
    {
        InventCostBundleList    inventCostBundleList;

        ttsbegin;
        update_recordset inventCostBundleList
            setting ProcessingState = InventCostBundleState::Waiting
            where   inventCostBundleList.InventClosing == inventClosing.RecId &&
                    inventCostBundleList.ProcessingState == InventCostBundleState::Processing;
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetIteration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the iteration for the inventory closing to the iteration to process next.
    /// </summary>
    protected void resetIteration()
    {
        NumOfIteration  numOfIteration = this.numOfIterationToProcess();

        if (numOfIteration != -1)
        {
            ttsbegin;
            inventClosing = InventClosing::find(voucher, transDate, true);
            inventClosing.NumOfIteration = numOfIteration;
            inventClosing.update();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resume</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resumes an inventory closing.
    /// </summary>
    /// <remarks>
    /// The calculation can be stopped by using the pause action.
    /// </remarks>
    public void resume()
    {
        BOMLevel bomLevel = this.bomLevelToProcess();

        if (!this.resumePrepareTasks(bomLevel))
        {
            this.resetBundleState();
            this.resetIteration();

            if (bomLevel >= 0)
            {
                this.createBatchTasks(bomLevel);
            }
            else
            {
                ttsbegin;
                BatchHeader batchHeader = this.batchHeader(batchJobId);

                this.createEndBatchTask(batchHeader, inventClosing.RunRecalculation);

                batchHeader.save();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resumePrepareTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resumes the preparation of inventory closing.
    /// </summary>
    /// <param name="_bomLevel">
    /// The level for which to check for unbundled items.
    /// </param>
    /// <returns>
    /// true if preparation tasks should run again; otherwise, false.
    /// </returns>
    protected boolean resumePrepareTasks(BOMLevel _bomLevel)
    {
        boolean isInventCostListParmCreated = this.isInventCostListParmCreated();
        boolean isInventCostBundleListCreated = this.isInventCostBundleListCreated();
        boolean isInventCostListUnbundled = this.isInventCostListUnbundled(_bomLevel);

        boolean resume = isInventCostListParmCreated || isInventCostBundleListCreated || isInventCostListUnbundled;

        if (resume)
        {
            this.addPrepareBatchTask(isInventCostListParmCreated, isInventCostBundleListCreated || isInventCostListUnbundled);
        }

        return resume;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Starts an inventory closing calculation.
    /// </summary>
    public void run()
    {
        CostManagementInstrumentationLogger logger =  CostManagementInstrumentationLogger::createLogger(classStr(InventCostTaskController));
        if (batchJobId)
        {
            using (var inventoryClosingActivityContext = logger.inventoryClosingActivities().createPrepareBatchTasks(inventClosing))
            {
                this.createPrepareBatchTask();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateClosingRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>InventClosing</c> record with helpers created; which indicates that multiple calculations are executed in parallel.
    /// </summary>
    protected void updateClosingRecord()
    {
        if (inventClosing.HelpersCreated == NoYes::No)
        {
            inventClosing = InventClosing::find(voucher, transDate, true);
            inventClosing.HelpersCreated = NoYes::Yes;
            inventClosing.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateIteration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates inventory closing record to next iteration.
    /// </summary>
    public void updateIteration()
    {
        ttsbegin;
        inventClosing = InventClosing::find(voucher, transDate, true);
        inventClosing.NumOfIteration++;
        inventClosing.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    private static InventCostTaskController construct()
    {
        return new InventCostTaskController();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>InventCostTaskController</c> class.
    /// </summary>
    /// <param name="_batchJobId">
    /// The batch job ID under which tasks will be created.
    /// </param>
    /// <param name="_batchRecId">
    /// The record ID of the batch record.
    /// </param>
    /// <param name="_voucher">
    /// The voucher of the inventory closing.
    /// </param>
    /// <param name="_transDate">
    /// The date of the inventory closing.
    /// </param>
    /// <param name="_runNum">
    /// The ID of the current inventory closing run.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventCostTaskController</c> class.
    /// </returns>
    public static InventCostTaskController newFromParameters(
                                                            RefRecId            _batchJobId,
                                                            RefRecId            _batchRecId,
                                                            Voucher             _voucher,
                                                            TransDate           _transDate,
                                                            InventClosingRunNum _runNum
                                                        )

    {
        InventCostTaskController taskController = InventCostTaskController::construct();

        taskController.parmBatchJobId(_batchJobId);
        taskController.parmBatchRecId(_batchRecId);
        taskController.parmVoucher(_voucher);
        taskController.parmTransDate(_transDate);
        taskController.parmRunNum(_runNum);

        taskController.init();

        return taskController;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>