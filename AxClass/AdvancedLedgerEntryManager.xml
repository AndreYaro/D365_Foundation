<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>AdvancedLedgerEntryManager</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///     The <c>AdvancedLedgerEntryManager</c> class performs several functions for the Advanced Ledger Entry feature.
/// </summary>
class AdvancedLedgerEntryManager
{
    #AdvancedLedgerEntryFaults

    AdvancedLedgerEntryHeader   advancedLedgerEntryHeader;
    AdvancedLedgerEntryLine     advancedLedgerEntryLine_Orig;
    AdvancedLedgerEntryLine     advancedLedgerEntryLine;
    WorkflowTable               workflowTableFieldList;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addMainAccountDimensionValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the dimension values that are associated to the main account.
    /// </summary>
    /// <param name="_mainAccountId">
    /// The ID of the main account.
    /// </param>
    /// <returns>
    /// The ID of the new main account.
    /// </returns>
    /// <remarks>
    /// Retrieves the main account default dimensions.
    /// </remarks>
    private Map addMainAccountDimensionValues(RecId _mainAccountId)
    {
        MainAccountLegalEntity          mainAccountLegalEntity;
        Map                             mainAccountDimensionSpecifiers;

        mainAccountLegalEntity = MainAccountLegalEntity::findByMainAccountLegalEntity(_mainAccountId, CompanyInfo::current());

        if (mainAccountLegalEntity.DefaultDimension)
        {
            mainAccountDimensionSpecifiers = LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(mainAccountLegalEntity.DefaultDimension);
        }

        return mainAccountDimensionSpecifiers;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkFlowStatusPreSubmit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return whether the <c>AdvancedLedgerEntryWFApprovalStatus</c> type parameter is in
    /// a pre-submit status
    /// </summary>
    /// <param name = "_workFlowStatus"></param>
    /// <returns>
    /// True if the <c>AdvancedLedgerEntryWFApprovalStatus</c> is in a pre-submit
    /// state; otherwise, false.
    /// </returns>
    final private boolean isWorkFlowStatusPreSubmit(AdvancedLedgerEntryWFApprovalStatus _workFlowStatus)
    {
        return (_workFlowStatus == AdvancedLedgerEntryWFApprovalStatus::None
                || _workFlowStatus == AdvancedLedgerEntryWFApprovalStatus::Draft
                || _workFlowStatus == AdvancedLedgerEntryWFApprovalStatus::NotSubmitted);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBudgetDocument</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks budget for all the advanced ledger entry lines.
    /// </summary>
    /// <param name="_checkAdvLedgerEntryBudgetControlStatus">
    ///     A boolean value to indicate whether the budgetary control setting for performing budget check on advance ledger line save should be considered
    ///     in determining whether budgetary control is required for advanced ledger entries.
    /// </param>
    /// <param name="_displayResultErrorWarnings">
    ///     A boolean value to indicate whether any errors or warnings from budget check result should be displayed in <c>Infolog</c>; optional, default is true.
    /// </param>
    public void checkBudgetDocument(
        boolean _checkAdvLedgerEntryBudgetControlStatus = true,
        boolean _displayResultErrorWarnings = true)
    {
        if (AdvancedLedgerEntryBudgetControl::isAdvLedgerEntryBudgetControlRequired(_checkAdvLedgerEntryBudgetControlStatus))
        {
            AdvancedLedgerEntryBudgetControl::runCheckBudget(
                SourceDocumentHeader::find(advancedLedgerEntryHeader.SourceDocumentHeader),
                true,
                _displayResultErrorWarnings,
                false,
                curUserId());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBudgetLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks budget for the advanced ledger entry line and any charges on it.
    /// </summary>
    /// <param name="_checkAdvLedgerEntryBudgetControlStatus">
    ///     A boolean value to indicate whether the budget control setting for performing budget check on advanced ledger entry line entry should be considered
    ///     in determining whether budget control is required for advanced ledger entries.
    /// </param>
    public void checkBudgetLine(boolean _checkAdvLedgerEntryBudgetControlStatus)
    {
        if (AdvancedLedgerEntryBudgetControl::isAdvLedgerEntryBudgetControlRequired(_checkAdvLedgerEntryBudgetControlStatus))
        {
            AdvancedLedgerEntryBudgetControl::runCheckBudgetLine(advancedLedgerEntryLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyAdvancedLedgerEntry</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a copy of advanced ledger entry header.
    /// </summary>
    /// <param name="_sourceHeader">
    ///     A record of the <c>AdvancedLedgerEntryHeader</c> table.
    /// </param>
    /// <returns>
    ///     A new record of the <c>AdvancedLedgerEntryHeader</c> table, created by copying field values
    ///     from the <paramref name="_sourceHeader"/> parameter, against a new Advanced ledger entry transaction number.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///     An error is thrown if advanced ledger entry header record is not found.
    /// </exception>
    public AdvancedLedgerEntryHeader copyAdvancedLedgerEntry(AdvancedLedgerEntryHeader _sourceHeader)
    {
        AdvancedLedgerEntryHeader targetHeader;
        AdvancedLedgerEntryLine   targetLine;
        AdvancedLedgerEntryLine   sourceLine;
        ReasonTableRef            targetReasonTableRef;
        ReasonTableRef            sourceReasonTableRef;

        if (!_sourceHeader)
        {
            throw error(strFmt("@SPS1272", funcName()));
        }

        if (AdvancedLedgerEntryManager::checkAdvancedLedgerEntryNumberSequence())
        {
            ttsbegin;
            targetHeader.data(_sourceHeader);
            targetHeader.TransactionNumber = AdvancedLedgerEntryManager::newAdvancedLedgerTransactionNumberReserved();
            targetHeader.TransactionStatus = AdvancedLedgerEntryTransactionStatus::Draft;

            // Check, if active ALE workflow template exist and then update the workflow status and workflow state accordingly.
            if (AdvancedLedgerEntryManager::activeWorkflowForCurrentCompanyExists())
            {
                targetHeader.WorkFlowStatus = AdvancedLedgerEntryWFApprovalStatus::Draft;
                targetHeader.WorkflowApprovalState = AdvancedLedgerEntryWFApprovalState::NotSubmitted;
            }

            targetHeader.AccountingDate = _sourceHeader.AccountingDate;
            targetHeader.FiscalCalendarPeriod = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(Ledger::fiscalCalendar(CompanyInfo::current()),
                                                            targetHeader.AccountingDate, FiscalPeriodType::Operating).RecId;
            targetHeader.SourceDocumentHeader = 0;

            sourceReasonTableRef = ReasonTableRef::find(_sourceHeader.ReasonTableRef);
            targetReasonTableRef.data(sourceReasonTableRef);
            targetReasonTableRef.insert();

            targetHeader.ReasonTableRef = targetReasonTableRef.RecId;
            targetHeader.insert();

            while select sourceLine
                where sourceLine.AdvancedLedgerEntryHeader == _sourceHeader.RecId
            {
                targetLine.data(sourceLine);
                targetLine.AdvancedLedgerEntryHeader = targetHeader.RecId;
                targetLine.SourceDocumentLine = 0;
                targetLine.insert();
            }
            ttscommit;
        }

        return targetHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodInit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Manages the logic when the init form method is triggered on the <c>AdvancedLedgerEntry</c> form.
    /// </summary>
    /// <param name="_element">
    /// A form run object for the <c>AdvancedLedgerEntry</c> form.
    /// </param>
    internal void formMethodInit(FormRun _element)
    {
        //
        // Currently, the _element method parameter is not used. It has been added
        // though to be consistent with the other form logic
        // handling methods, and because it makes sense to have this
        // object available to this method.
        //
        
        // Select the default workflow configuration corresponding to the advanced ledger entry template
        select DefaultConfiguration from workflowTableFieldList
                where workflowTableFieldList.TemplateName == workflowtypestr(AdvancedLedgerEntryTemplate)
                    && workflowTableFieldList.DefaultConfiguration == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceCreate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Manages the number sequence when a number is allocated when an advanced ledger entry header is being created.
    /// </summary>
    /// <param name="_element">
    ///     The form that uses the number sequence.
    /// </param>
    /// <param name="_advancedLedgerEntryHeaderDS">
    ///     The data source of the form that uses the number sequence.
    /// </param>
    public void formMethodDataSourceCreate(
        FormRun        _element,
        FormDataSource _advancedLedgerEntryHeaderDS)
    {
        this.numberSeqFormHandlerALEId(_element, _advancedLedgerEntryHeaderDS).formMethodDataSourceCreate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceCreatePre</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Manages the number sequence before a number is allocated when an advanced ledger entry header is being created.
    /// </summary>
    /// <param name="_element">
    ///     The form that uses the number sequence.
    /// </param>
    /// <param name="_advancedLedgerEntryHeaderDS">
    ///     The data source of the form that uses the number sequence.
    /// </param>
    public void formMethodDataSourceCreatePre(
        FormRun        _element,
        FormDataSource _advancedLedgerEntryHeaderDS)
    {
        this.numberSeqFormHandlerALEId(_element, _advancedLedgerEntryHeaderDS).formMethodDataSourceCreatePre();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceDelete</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Manages the number sequence during the deletion of an advanced ledger entry header.
    /// </summary>
    /// <param name="_element">
    ///     The form where the number sequence is being used.
    /// </param>
    /// <param name="_advancedLedgerEntryHeaderDS">
    ///     The data source of the form where the number sequence is being used.
    /// </param>
    public void formMethodDataSourceDelete(
        FormRun        _element,
        FormDataSource _advancedLedgerEntryHeaderDS)
    {
        this.numberSeqFormHandlerALEId(_element, _advancedLedgerEntryHeaderDS).formMethodDataSourceDelete();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceLinkActive</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Manages the number sequence when an advanced ledger entry header becomes active.
    /// </summary>
    /// <param name="_element">
    ///     The form where the number sequence is being used.
    /// </param>
    /// <param name="_advancedLedgerEntryHeaderDS">
    ///     The data source of the form where the number sequence is being used.
    /// </param>
    public void formMethodDataSourceLinkActive(
        FormRun        _element,
        FormDataSource _advancedLedgerEntryHeaderDS)
    {
        this.numberSeqFormHandlerALEId(_element, _advancedLedgerEntryHeaderDS).formMethodDataSourceLinkActive();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceActive</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Manages the logic when the advanced ledger entry header data source becomes active.
    /// </summary>
    /// <param name="_element">
    ///     The form where the number sequence is being used.
    /// </param>
    /// <param name="_advancedLedgerEntryHeaderDS">
    ///     The data source of the form where the number sequence is being used.
    /// </param>
    internal void formMethodDataSourceActive(FormRun _element, FormDataSource _advancedLedgerEntryHeaderDS)
    {
        this.parmAdvancedLedgerEntryHeader(_advancedLedgerEntryHeaderDS.cursor());
        this.enablePostButton(_element);
    }

]]></Source>
			</Method>
			<Method>
				<Name>enablePostButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the Post button from the <c>FormRun</c> parameter object
    /// should be enabled.
    /// </summary>
    /// <param name = "_element">
    /// The <c>FormRun</c> object containing the Post button.
    /// </param>
    internal void enablePostButton(FormRun _element)
    {
        int controlId = _element.controlId(formControlStr(AdvancedLedgerEntry, LedgerEntryPost));
        FormControl ledgerEntryPost = _element.control(controlId);
        ledgerEntryPost.enabled(false);

        // Enables the Post button when budget control passes for Advanced Ledger Entry record
        if (AdvancedLedgerEntryBudgetControl::getBudgetSourceBudgetCheckResult(advancedLedgerEntryHeader) != BudgetCheckResult::Failed)
        {
            if (advancedLedgerEntryHeader.WorkFlowStatus == AdvancedLedgerEntryWFApprovalStatus::Approved)
            {
                if (advancedLedgerEntryHeader.TransactionStatus != AdvancedLedgerEntryTransactionStatus::Posted)
                {
                    ledgerEntryPost.enabled(true);
                }
            }
            else if (this.isWorkFlowStatusPreSubmit(advancedLedgerEntryHeader.WorkFlowStatus))
            {
                if (!AdvancedLedgerEntryManager::activeWorkflowForCurrentCompanyExists())
                {
                    ledgerEntryPost.enabled(true);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceValidateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    /// Manages the number sequence during the validation of saving an advanced ledger entry header.
    /// </summary>
    /// <param name="_element">
    /// The form where the number sequence is being used.
    /// </param>
    /// <param name="_advancedLedgerEntryHeaderDS">
    /// The data source of the form where the number sequence is being used.
    /// </param>
    /// <returns>
    /// true if the advanced ledger entry number sequence passes validation; otherwise, false.
    /// </returns>
    public boolean formMethodDataSourceValidateWrite(
        FormRun _element,
        FormDataSource _advancedLedgerEntryHeaderDS)
    {
        return this.numberSeqFormHandlerALEId(_element, _advancedLedgerEntryHeaderDS).formMethodDataSourceValidateWrite();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceWrite</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Manages the number sequence during the saving of an advanced ledger entry header.
    /// </summary>
    /// <param name="_element">
    ///     The form where the number sequence is being used.
    /// </param>
    /// <param name="_advancedLedgerEntryHeaderDS">
    ///     The data source of the form where the number sequence is being used.
    /// </param>
    public void formMethodDataSourceWrite(
        FormRun        _element,
        FormDataSource _advancedLedgerEntryHeaderDS)
    {
        this.numberSeqFormHandlerALEId(_element, _advancedLedgerEntryHeaderDS).formMethodDataSourceWrite();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceALELineWrite</Name>
				<Source><![CDATA[
    /// <summary>
    /// Manages the business logic when the form triggers a write 
    /// method call on the <c>AdvancedLedgerEntryLine</c> table.
    /// </summary>
    /// <param name="_element">
    /// The form run object of the <c>AdvancedLedgerEntry</c> form where the write 
    /// is triggered.
    /// </param>
    /// <param name="_advancedLedgerEntryLineDS">
    /// The form data source for the <c>AdvancedLedgerEntryLine</c> table.
    /// </param>
    internal void formMethodDataSourceALELineWrite(
        FormRun _element,
        FormDataSource _advancedLedgerEntryLineDS)
    {
        if ((AdvancedLedgerEntryManager::activeWorkflowForCurrentCompanyExists() 
            && workflowTableFieldList.DefaultConfiguration)
            || (!this.isWorkFlowStatusPreSubmit(advancedLedgerEntryHeader.WorkFlowStatus)))
        {
            // Checks to see if workflow approval status is neither 'Rejected', 'ChangeRequested' nor 'PendingCompletion', only then change the workflow approval
            // status accordingly and enable the post button based on the journal line.
            if (advancedLedgerEntryHeader.WorkFlowStatus != AdvancedLedgerEntryWFApprovalStatus::Rejected
                    && advancedLedgerEntryHeader.WorkFlowStatus != AdvancedLedgerEntryWFApprovalStatus::ChangeRequested
                    && advancedLedgerEntryHeader.WorkFlowStatus != AdvancedLedgerEntryWFApprovalStatus::PendingCompletion)
            {
                if (_advancedLedgerEntryLineDS.cursor().RecId)
                {
                    advancedLedgerEntryHeader.WorkFlowStatus = AdvancedLedgerEntryWFApprovalStatus::Draft;
                }
                else
                {
                    advancedLedgerEntryHeader.WorkFlowStatus = AdvancedLedgerEntryWFApprovalStatus::None;
                }
            }
        }

        this.enablePostButton(_element);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Performs initialization for the <c>AdvancedLedgerEntryManager</c> class.
    /// </summary>
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberSeqFormHandlerALEId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates an instance of the <c>NumberSeqFormHandler</c> class for the advanced ledger entry identifier number sequence.
    /// </summary>
    /// <param name="_element">
    ///     The form where the number sequence is used.
    /// </param>
    /// <param name="_advancedLedgerEntryHeaderDS">
    ///     The data source of the form where the number sequence is used.
    /// </param>
    /// <returns>
    ///     An instance of the <c>NumberSeqFormHandler</c> class for the advanced ledger entry identifier number sequence.
    /// </returns>
    public NumberSeqFormHandler numberSeqFormHandlerALEId(
        FormRun        _element,
        FormDataSource _advancedLedgerEntryHeaderDS)
    {
        NumberSeqFormHandler    numberSeqFormHandler;
        NumberSequenceReference numberSequenceReference;

        if (!numberSeqFormHandler)
        {
            numberSequenceReference = LedgerParameters::numRefAdvancedLedgerEntryId();

            numberSeqFormHandler = NumberSeqFormHandler::newForm(numberSequenceReference.NumberSequenceId,
                                    _element,
                                    _advancedLedgerEntryHeaderDS,
                                    fieldNum(AdvancedLedgerEntryHeader, TransactionNumber));
        }

        return numberSeqFormHandler;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onSegmentChangedForPrimaryAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs updates when the primary account is changed.
    /// </summary>
    /// <param name="_segmentedEntryControl">
    /// The segmented entry control.
    /// </param>
    /// <param name="_dimensionControlSegment">
    /// The segment that was changed.
    /// </param>
    /// <param name="_currentMainAccountId">
    /// The record ID of the current main account.
    /// </param>
    /// <returns>
    /// The record ID of the new main account.
    /// </returns>
    /// <remarks>
    /// This method is designed to delegate the functionality that is needed by the segmented entry control's <c>onSegmentChanged</c> method.
    /// If and only if the segment that was changed is the Main Account, then the other segments on the control are updated with their defaults.
    /// </remarks>
    public MainAccountRecId onSegmentChangedForPrimaryAccount(
        SegmentedEntryControl   _segmentedEntryControl,
        DimensionControlSegment _dimensionControlSegment,
        MainAccountRecId        _currentMainAccountId)
    {
        MainAccountRecId    updatedMainAccountId;
        MainAccountRecId    mainAccountId;
        Map                 dimensionSpecifiers;

        updatedMainAccountId = _currentMainAccountId;

        changecompany(_segmentedEntryControl.parmDataAreaId())
        {
            if (_dimensionControlSegment.parmDimensionAttribute().RecId == DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount))
            {
                mainAccountId = _dimensionControlSegment.parmDimensionAttributeValue().EntityInstance;

                if ((mainAccountId != 0) && (_currentMainAccountId != mainAccountId))
                {
                    updatedMainAccountId = mainAccountId;

                    // Add dimension values from the main account
                    dimensionSpecifiers = this.addMainAccountDimensionValues(mainAccountId);

                    // Set values in segmented entry control
                    if (dimensionSpecifiers)
                    {
                        _segmentedEntryControl.setDimensionSpecifiers(dimensionSpecifiers, false);
                    }
                }
            }
        }

        return updatedMainAccountId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdvancedLedgerEntryHeader</Name>
				<Source><![CDATA[
    public AdvancedLedgerEntryHeader parmAdvancedLedgerEntryHeader(AdvancedLedgerEntryHeader _advancedLedgerEntryHeader)
    {
        advancedLedgerEntryHeader = _advancedLedgerEntryHeader;
        return advancedLedgerEntryHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdvancedLedgerEntryLine</Name>
				<Source><![CDATA[
    public AdvancedLedgerEntryLine parmAdvancedLedgerEntryLine(AdvancedLedgerEntryLine _advancedLedgerEntryLine)
    {
        advancedLedgerEntryLine = _advancedLedgerEntryLine;
        return advancedLedgerEntryLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdvancedLedgerEntryLine_Orig</Name>
				<Source><![CDATA[
    public AdvancedLedgerEntryLine parmAdvancedLedgerEntryLine_Orig(AdvancedLedgerEntryLine _advancedLedgerEntryLine_Orig)
    {
        advancedLedgerEntryLine_Orig = _advancedLedgerEntryLine_Orig;
        return advancedLedgerEntryLine_Orig;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTransAmountToAccountingAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates an amount in the accounting currency of the company.
    /// </summary>
    /// <param name="_amountCur">
    ///     The amount to convert to the accounting currency of the company.
    /// </param>
    /// <param name="_currencyCode">
    ///     The currency of the specified amount.
    /// </param>
    /// <param name="_exchangeDate">
    ///     The date used to determine the exchange rate for the calculation.
    /// </param>
    /// <param name="_exchangeRateType">
    ///     The exchange rate type to use.
    /// </param>
    /// <returns>
    ///     The amount in the accounting currency of the ledger.
    /// </returns>
    public static AmountMST calculateTransAmountToAccountingAmount(
        AmountCur    _amountCur,
        CurrencyCode _currencyCode,
        date         _exchangeDate,
        RecId        _exchangeRateType = 0)
    {
        CurrencyExchangeHelper currencyHelper;
        AmountMST              amountMST = 0;

        if (_amountCur != 0)
        {
            if (AdvancedLedgerEntryManager::validateCurrency(_currencyCode))
            {
                currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), _exchangeDate);
                _exchangeRateType = _exchangeRateType ? _exchangeRateType : Ledger::defaultExchangeRateType();
                currencyHelper.parmExchangeRateTypeRecId(_exchangeRateType);
                amountMST = currencyHelper.calculateTransactionToAccounting(_currencyCode, _amountCur, true);
            }
        }

        return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAdvancedLedgerEntryNumberSequence</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates the number sequence that is set up for the advanced ledger entry identifier.
    /// </summary>
    /// <param name="_numberSequenceReference">
    ///     The number sequence reference to validate.
    /// </param>
    /// <returns>
    ///     true if the number sequence is valid for advanced ledger entries; otherwise, false.
    /// </returns>
    public static boolean checkAdvancedLedgerEntryNumberSequence(NumberSequenceReference _numberSequenceReference = null)
    {
        boolean                 isValid = true;
        NumberSequenceTable     numberSequenceTable;
        NumberSequenceReference numberSequenceReference = _numberSequenceReference;

        if (!numberSequenceReference)
        {
            // Number sequence reference to check was not passed; find the reference for the advanced ledger entry number.
            numberSequenceReference = LedgerParameters::numRefAdvancedLedgerEntryId();
        }
        else if (NumberSequenceDatatype::find(numberSequenceReference.NumberSequenceDatatype).DatatypeId != extendedTypeNum(AdvancedLedgerEntryId))
        {
            // Number sequence reference that was passed is not for advanced ledger entry number.
            isValid = AifFault::checkFailedLogFault("@SPS1273");
        }

        if (isValid)
        {
            if (!numberSequenceReference)
            {
                isValid = AifFault::checkFailedLogFault(strFmt("@SPS1274", "@SPS1174", enum2str(NumberSeqModule::Ledger)));
            }
            else
            {
                numberSequenceTable = NumberSequenceTable::find(numberSequenceReference.NumberSequenceId);

                if (!numberSequenceTable)
                {
                    // The number sequence that was selected for the advanced ledger entry number does not exist.
                    isValid = false;
                    throw AifFault::faultList(strFmt("@SPS1274", numberSequenceReference.referenceLabel(), numberSequenceReference.referenceModuleLabel()), 'Validation failed');
                }
                else
                {
                    if (!numberSequenceTable.Continuous)
                    {
                        // The number sequence set up for advanced ledger entry number is not continuous.
                        isValid = AifFault::checkFailedLogFault(strFmt("@SPS1275", numberSequenceTable.NumberSequence));
                    }

                    if (numberSequenceTable.Blocked)
                    {
                        // The number sequence set up for advanced ledger entry number on hold.
                        isValid = AifFault::checkFailedLogFault(strFmt("@SPS1276", numberSequenceTable.NumberSequence));
                    }
                }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjCategoryId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates the <c>ProjCategoryId</c> field.
    /// </summary>
    /// <param name="_projCategoryId">
    ///     The <c>ProjCategoryId</c> field to examine the validity.
    /// </param>
    /// <returns>
    ///     true if the entered <c>ProjCategoryId</c> can be used; otherwise false.
    /// </returns>
    public static boolean checkProjCategoryId(ProjCategoryId _projCategoryId)
    {
        boolean         isValid = true;
        ProjCategory    projCategory = ProjCategory::find(_projCategoryId);

        isValid = projCategory.checkValid();

        if (projCategory.PSAIndirectComponent)
        {
            isValid = AifFault::checkFailedLogFault("@PSA11059");
        }

        if (isValid && projCategory.CategoryId)
        {
            isValid = projCategory.validateIfInactiveAllowed();
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjFundingSource</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates the <c>ProjFundingSource</c> field.
    /// </summary>
    /// <param name="_projId">
    ///     The <c>ProjId</c> field to examine the validity.
    /// </param>
    /// <param name="_projFundingSource">
    ///     The <c>ProjFuncingSource</c> field to examine the validity.
    /// </param>
    /// <returns>
    ///     true if the entered <c>ProjFundingSource</c> can be used; otherwise false.
    /// </returns>
    public static boolean checkProjFundingSource(
        ProjId   _projId,
        RefRecId _projFundingSource)
    {
        ProjInvoiceTable    projInvoiceTable;
        ProjFundingSource   projFundingSource;
        boolean             isValid = true;

        projInvoiceTable = ProjTable::find(_projId).projInvoice();

        if (_projFundingSource && projInvoiceTable)
        {
            projFundingSource = ProjFundingSource::find(_projFundingSource);

            if (!projFundingSource)
            {
                isValid = AifFault::checkFailedLogFault("@SPS1608");
            }

            if (projFundingSource.ContractId != projInvoiceTable.ProjInvoiceProjId)
            {
                isValid = AifFault::checkFailedLogFault("@SPS1609");
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransactionStatusForDelete</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if an advanced ledger entry can be deleted with the specified <c>AdvancedLedgerEntryTransactionStatus</c> enumeration value.
    /// </summary>
    /// <param name="_transactionStatus">
    ///     The <c>AdvancedLedgerEntryTransactionStatus</c> enumeration value.
    /// </param>
    /// <param name="_advancedLedgerEntryId">
    ///     The record ID of advanced ledger entry.
    /// </param>
    /// <param name="_showError">
    ///     A boolean value to show or hide the error message; optional.
    /// </param>
    /// <returns>
    ///     true if the advanced ledger entry can be deleted; otherwise, false.
    /// </returns>
    public static boolean checkTransactionStatusForDelete(
        AdvancedLedgerEntryTransactionStatus _transactionStatus,
        AdvancedLedgerEntryId                _advancedLedgerEntryId,
        boolean                              _showError = true)
    {
        boolean isValid = true;

        if (_transactionStatus == AdvancedLedgerEntryTransactionStatus::Posted)
        {
            isValid = _showError && AifFault::checkFailedLogFault(strFmt("@SPS1332", _advancedLedgerEntryId));
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransactionStatusForWrite</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if an advanced ledger entry can be written with the specified <c>AdvancedLedgerEntryTransactionStatus</c> enumeration value.
    /// </summary>
    /// <param name="_transactionStatus">
    ///     The <c>AdvancedLedgerEntryTransactionStatus</c> enumeration value.
    /// </param>
    /// <param name="_advancedLedgerEntryId">
    ///     The record ID of advanced ledger entry.
    /// </param>
    /// <param name="_showError">
    ///     A boolean value to show or hide the error message; optional.
    /// </param>
    /// <returns>
    ///     true if advanced ledger entry can be written; otherwise, false.
    /// </returns>
    public static boolean checkTransactionStatusForWrite(
        AdvancedLedgerEntryTransactionStatus _transactionStatus,
        AdvancedLedgerEntryId                _advancedLedgerEntryId,
        boolean                              _showError = true)
    {
        boolean isValid = true;

        if (_transactionStatus == AdvancedLedgerEntryTransactionStatus::Posted)
        {
            isValid = _showError && AifFault::checkFailedLogFault(strFmt("@SPS1331", _advancedLedgerEntryId));
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkValidJournalizingDefinition</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates that the journalizing definition record ID parameter references a valid journalizing definition.
    /// </summary>
    /// <param name="_journalizingDefinitionRecId">
    ///     The record ID of the journalizing definition to validate.
    /// </param>
    /// <param name="_transDate">
    ///     The transaction date to validate.
    /// </param>
    /// <param name="_showError">
    ///     A boolean value to show or hide the error message; optional.
    /// </param>
    /// <returns>
    ///     true if the entered <c>JournalizingDefinition</c> can be used; otherwise false.
    /// </returns>
    public static boolean checkValidJournalizingDefinition(
        RefRecId  _journalizingDefinitionRecId,
        TransDate _transDate,
        boolean   _showError = true)
    {
        SysDateEffectiveDataManager sysDateEffectiveDataManager;
        boolean isValid = true;
        JournalizingDefinition journalizingDefinition = JournalizingDefinition::findByRecId(_journalizingDefinitionRecId, false);

        sysDateEffectiveDataManager = SysDateEffectiveDataManager::construct(SysDateEffectiveSetupType::JournalizingDefinition);

        if (!_transDate)
        {
            isValid = _showError && AifFault::checkFailedLogFault("@SYS128707");
        }

        if (_journalizingDefinitionRecId <=0 || (!journalizingDefinition.RecId))
        {
            isValid = _showError && AifFault::checkFailedLogFault("@SYS132140");
        }
        else if (!sysDateEffectiveDataManager.findVersionByParentIdAndDate(_journalizingDefinitionRecId, _transDate).RecId)
        {
            isValid = _showError && AifFault::checkFailedLogFault("@SYS132141");
        }
        else if (journalizingDefinition.JournalizingDefinitionModuleValue != JournalizingDefinitionModuleId::GeneralLedger)
        {
            if (_showError)
            {
                throw AifFault::fault(strFmt("@SPS1702", journalizingDefinition.JournalizingDefinitionCode, JournalizingDefinitionModuleId::GeneralLedger), 'validation failed');
            }
            else
            {
                return false;
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWorkflowStatusForDeleteUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if an advanced ledger entry transaction could be deleted or updated with the specified <c>AdvancedLedgerEntryWFApprovalStatus</c> enumeration value.
    /// </summary>
    /// <param name="_workflowStatus">
    ///     An <c>AdvancedLedgerEntryWFApprovalStatus</c> enumeration value.
    /// </param>
    /// <param name="_advancedLedgerEntryId">
    ///     The ID of a budget transaction.
    /// </param>
    /// <returns>
    ///     true if an advanced ledger entry transaction could be deleted or updated that had the specified <c>AdvancedLedgerEntryWFApprovalStatus</c> enumeration value; otherwise, false.
    /// </returns>
    public static boolean checkWorkflowStatusForDeleteUpdate(
        AdvancedLedgerEntryWFApprovalStatus _workflowStatus,
        AdvancedLedgerEntryId               _advancedLedgerEntryId)
    {
        boolean isValid = true;

        if (_workflowStatus && (_workflowStatus != AdvancedLedgerEntryWFApprovalStatus::Rejected &&
            _workflowStatus != AdvancedLedgerEntryWFApprovalStatus::Draft))
        {
            isValid = AifFault::checkFailedLogFault(strFmt("@SPS1602", _advancedLedgerEntryId), #WorkflowStatusPreventsAdvancedLedgerEntryDeleteUpdate);
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Constructs a new instance using the default constructor.
    /// </summary>
    /// <returns>
    ///     A new instance of the <c>AdvancedLedgerEntryManager</c> class.
    /// </returns>
    public static AdvancedLedgerEntryManager construct()
    {
        // Create a new instance and return.
        return new AdvancedLedgerEntryManager();
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructFiscalPeriodLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a <c>SysReferenceTableLookup</c> class to be used by the advanced ledger entry feature.
    /// </summary>
    /// <param name="_formReferenceControl">
    /// A <c>FormReferenceControl</c> passed in from the calling form control.
    /// </param>
    /// <param name="_accountingDate">
    /// A date value used for constructing the <c>SysReferenceTableLookup</c>.
    /// </param>
    /// <returns>
    /// A <c>FiscalCalendarPeriod</c> table record.
    /// </returns>
    public static Common constructFiscalPeriodLookup(
        FormReferenceControl    _formReferenceControl,
        date                    _accountingDate)
    {
        Common                  fiscalCalendarPeriod;
        SysReferenceTableLookup sysReferenceTableLookup;
        Query                   query = new Query();
        QueryBuildDataSource    queryBuildFiscalCalendarPeriod, queryBuildLedgerFiscalCalendarPeriod;
        FiscalCalendar          fiscalCalendar;
        FiscalCalendarYear      fiscalCalendarYear;

        fiscalCalendar = FiscalCalendar::find(Ledger::fiscalCalendar(CompanyInfo::current()));

        if (fiscalCalendar.RecId)
        {
            fiscalCalendarYear = FiscalCalendarYear::findYearByCalendarDate(fiscalCalendar.RecId, _accountingDate);

            if (fiscalCalendarYear.RecId)
            {
                sysReferenceTableLookup = SysReferenceTableLookup::newParameters(tableNum(FiscalCalendarPeriod), _formReferenceControl, true);

                // Add ranges to only show fiscal calendar periods for the specified accounting date
                queryBuildFiscalCalendarPeriod = query.addDataSource(tableNum(FiscalCalendarPeriod));
                queryBuildFiscalCalendarPeriod.addRange(fieldNum(FiscalCalendarPeriod, FiscalCalendar)).value(SysQuery::value(fiscalCalendar.RecId));
                queryBuildFiscalCalendarPeriod.addRange(fieldNum(FiscalCalendarPeriod, FiscalCalendarYear)).value(SysQuery::value(fiscalCalendarYear.RecId));

                queryBuildFiscalCalendarPeriod.addRange(fieldNum(FiscalCalendarPeriod, StartDate)).value(SysQuery::range(dateNull(), _accountingDate));
                queryBuildFiscalCalendarPeriod.addRange(fieldNum(FiscalCalendarPeriod, EndDate)).value(SysQuery::range(_accountingDate, dateMax()));

                // Add range to only return open periods
                queryBuildLedgerFiscalCalendarPeriod = queryBuildFiscalCalendarPeriod.addDataSource(tableNum(LedgerFiscalCalendarPeriod));
                queryBuildLedgerFiscalCalendarPeriod.joinMode(JoinMode::ExistsJoin);
                queryBuildLedgerFiscalCalendarPeriod.relations(true);

                queryBuildLedgerFiscalCalendarPeriod.addRange(fieldNum(LedgerFiscalCalendarPeriod, Status)).value(SysQuery::value(FiscalPeriodStatus::Open));
                queryBuildLedgerFiscalCalendarPeriod.addRange(fieldNum(LedgerFiscalCalendarPeriod, Ledger)).value(SysQuery::value(Ledger::current()));

                // Sort by StartDate
                queryBuildFiscalCalendarPeriod.addSortField(fieldNum(FiscalCalendarPeriod, StartDate));

                // Specify fields to show on the lookup
                sysReferenceTableLookup.addLookupfield(fieldNum(FiscalCalendarPeriod, Name));
                sysReferenceTableLookup.addLookupfield(fieldNum(FiscalCalendarPeriod, Type));
                sysReferenceTableLookup.addLookupfield(fieldNum(FiscalCalendarPeriod, StartDate));
                sysReferenceTableLookup.addLookupfield(fieldNum(FiscalCalendarPeriod, EndDate));

                sysReferenceTableLookup.parmQuery(query);

                fiscalCalendarPeriod = sysReferenceTableLookup.performFormLookup();
            }
        }

        return fiscalCalendarPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doMultipleOpenPeriodsExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if multiple open periods exist for the passed-in accounting date.
    /// </summary>
    /// <param name="_accountingDate">
    /// An accounting date to be used by the method.
    /// </param>
    /// <returns>
    /// true if multiple open periods exist; otherwise, false.
    /// </returns>
    public static boolean doMultipleOpenPeriodsExist(date _accountingDate)
    {
        FiscalCalendarPeriod        fiscalCalendarPeriod;
        LedgerFiscalCalendarPeriod  ledgerFiscalCalendarPeriod;
        int                         openPeriodCount;

        while select fiscalCalendarPeriod
            order by fiscalCalendarPeriod.StartDate, fiscalCalendarPeriod.EndDate asc
            where fiscalCalendarPeriod.FiscalCalendar == Ledger::fiscalCalendar(CompanyInfo::current())
                && fiscalCalendarPeriod.StartDate <= _accountingDate
                && fiscalCalendarPeriod.EndDate >= _accountingDate
            exists join ledgerFiscalCalendarPeriod
                where ledgerFiscalCalendarPeriod.FiscalCalendarPeriod == fiscalCalendarPeriod.RecId
                    && ledgerFiscalCalendarPeriod.Ledger == Ledger::current()
                    && ledgerFiscalCalendarPeriod.Status == FiscalPeriodStatus::Open
        {
            // Make sure the Ledger module is open for this period
            if (LedgerFiscalCalendar::checkModuleIsOpen(SysModule::Ledger, _accountingDate, fiscalCalendarPeriod, false))
            {
                openPeriodCount++;

                if (openPeriodCount > 1)
                {
                    break;
                }
            }
        }

        return openPeriodCount > 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>firstOpenPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the first open fiscal period that includes the passed in date
    /// </summary>
    /// <param name="_accountingDate">
    /// The date for which the first open period is to be found
    /// </param>
    /// <returns>
    /// The <c>RecId</c> value of the first open fiscal period
    /// </returns>
    public static FiscalCalendarPeriodRecId firstOpenPeriod(date _accountingDate, boolean _showError = false)
    {
        FiscalCalendarPeriod        fiscalCalendarPeriod;
        LedgerFiscalCalendarPeriod  ledgerFiscalCalendarPeriod;
        FiscalCalendarPeriodRecId   firstOpenPeriod;

        while select fiscalCalendarPeriod
                order by fiscalCalendarPeriod.StartDate, fiscalCalendarPeriod.EndDate asc
                where fiscalCalendarPeriod.FiscalCalendar == Ledger::fiscalCalendar(CompanyInfo::current())
                    && fiscalCalendarPeriod.StartDate <= _accountingDate
                    && fiscalCalendarPeriod.EndDate >= _accountingDate
                exists join ledgerFiscalCalendarPeriod
                    where ledgerFiscalCalendarPeriod.FiscalCalendarPeriod == fiscalCalendarPeriod.RecId
                        && ledgerFiscalCalendarPeriod.Ledger == Ledger::current()
                        && ledgerFiscalCalendarPeriod.Status == FiscalPeriodStatus::Open
        {
            // Make sure the Ledger module is open for this period
            if (LedgerFiscalCalendar::checkModuleIsOpen(SysModule::Ledger, _accountingDate, fiscalCalendarPeriod, _showError))
            {
                firstOpenPeriod = fiscalCalendarPeriod.RecId;
                break;
            }
        }

        if (_showError && !firstOpenPeriod)
        {
            AifFault::checkFailedLogFault(literalStr("@SYS19250"), '', '', [_accountingDate]);
        }

        return firstOpenPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doMultipleClosingPeriodsExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if multiple closing periods exist for the passed-in accounting date.
    /// </summary>
    /// <param name="_accountingDate">
    /// An accounting date to be used by the method.
    /// </param>
    /// <returns>
    /// true if multiple closing periods exist; otherwise, false.
    /// </returns>
    public static boolean doMultipleClosingPeriodsExist(date _accountingDate)
    {
        FiscalCalendar          fiscalCalendar;
        FiscalCalendarYear      fiscalCalendarYear;
        FiscalCalendarPeriod    fiscalCalendarPeriod;

        fiscalCalendar = FiscalCalendar::find(Ledger::fiscalCalendar(CompanyInfo::current()));

        if (fiscalCalendar.RecId)
        {
            fiscalCalendarYear = FiscalCalendarYear::findYearByCalendarDate(fiscalCalendar.RecId, _accountingDate);

            if (fiscalCalendarYear.RecId)
            {
                select count (RecId) from fiscalCalendarPeriod
                    where fiscalCalendarPeriod.FiscalCalendar == fiscalCalendar.RecId
                        && fiscalCalendarPeriod.StartDate <= _accountingDate
                        && fiscalCalendarPeriod.EndDate >= _accountingDate;
            }
        }

        return fiscalCalendarPeriod.RecId > 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existLinesForALEHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if any advanced ledger entry lines exist for a advanced ledger entry header.
    /// </summary>
    /// <param name="_advancedLedgerEntryHeaderRecId">
    ///     The advanced ledger entry header record ID to examine the existence of line.
    /// </param>
    /// <returns>
    ///     true if at least one line exists for the specified advanced ledger entry header; otherwise, false.
    /// </returns>
    public static boolean existLinesForALEHeader(RecId _advancedLedgerEntryHeaderRecId)
    {
        // If no line exists for the specified advanced ledger entry header, return false.
        return (select firstonly RecId from advancedLedgerEntryLine
                    where advancedLedgerEntryLine.AdvancedLedgerEntryHeader == _advancedLedgerEntryHeaderRecId).RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateAdvancedLedgerEntryLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Generates a new line number for the <c>AdvancedLedgerEntryHeader</c> record.
    /// </summary>
    /// <param name="_advancedLedgerEntryHeaderRecId">
    ///     The record ID of <c>AdvancedLedgerEntryHeader</c> table to create the new line number.
    /// </param>
    /// <returns>
    ///     The new line number.
    /// </returns>
    public static LineNum generateAdvancedLedgerEntryLineNum(RecId _advancedLedgerEntryHeaderRecId)
    {
        AdvancedLedgerEntryLine advancedLedgerEntryLine;

        select maxof(LineNumber) from advancedLedgerEntryLine
            where advancedLedgerEntryLine.AdvancedLedgerEntryHeader == _advancedLedgerEntryHeaderRecId;

        return advancedLedgerEntryLine.LineNumber + 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupTransactionTxt</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Performs a lookup of the <c>LedgerJournalTxt</c> table.
    /// </summary>
    /// <param name="_control">
    ///     The form reference control to perform the lookup for.
    /// </param>
    public static void lookupTransactionTxt(FormStringControl _control)
    {
        SysTableLookup transactionTxtLookup;

        transactionTxtLookup = SysTableLookup::newParameters(tableNum(LedgerJournalTxt), _control, true);

        // Add the fields to be shown in the lookup form.
        transactionTxtLookup.addLookupfield(fieldNum(LedgerJournalTxt, Txt));
        transactionTxtLookup.addLookupfield(fieldNum(LedgerJournalTxt, Id));
        transactionTxtLookup.addLookupfield(fieldNum(LedgerJournalTxt, IdAlias));

        // Perform the lookup.
        transactionTxtLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForAdvancedLedgerEntryDocument</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Instantiates a new object based on the advanced ledger entry header.
    /// </summary>
    /// <param name="_advancedLedgerEntryHeader">
    ///     An advanced ledger entry header.
    /// </param>
    /// <returns>
    ///     A new instance of the <c>AdvancedLedgerEntryManager</c> class.
    /// </returns>
    public static AdvancedLedgerEntryManager newForAdvancedLedgerEntryDocument(AdvancedLedgerEntryHeader _advancedLedgerEntryHeader)
    {
        AdvancedLedgerEntryManager advancedLedgerEntryManager = new AdvancedLedgerEntryManager();
        advancedLedgerEntryManager.parmAdvancedLedgerEntryHeader(_advancedLedgerEntryHeader);

        return advancedLedgerEntryManager;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForAdvancedLedgerEntryLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Instantiates a new object based on the advanced ledger entry line.
    /// </summary>
    /// <param name="_advancedLedgerEntryLine">
    ///     An advanced ledger entry line.
    /// </param>
    /// <param name="_advancedLedgerEntryLine_Orig">
    ///     An original advanced ledger entry line.
    /// </param>
    /// <returns>
    ///     A new instance of the <c>AdvancedLedgerEntryManager</c> class.
    /// </returns>
    public static AdvancedLedgerEntryManager newForAdvancedLedgerEntryLine(
        AdvancedLedgerEntryLine _advancedLedgerEntryLine,
        AdvancedLedgerEntryLine _advancedLedgerEntryLine_Orig)
    {
        AdvancedLedgerEntryManager advancedLedgerEntryManager = new AdvancedLedgerEntryManager();
        advancedLedgerEntryManager.parmAdvancedLedgerEntryLine(_advancedLedgerEntryLine);
        advancedLedgerEntryManager.parmAdvancedLedgerEntryLine_Orig(_advancedLedgerEntryLine_Orig);

        return advancedLedgerEntryManager;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseAdvancedLedgerEntry</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a reversing entry for the specified advanced ledger entry record.
    /// </summary>
    /// <param name="_sourceHeader">
    ///     A record of the <c>AdvancedLedgerEntryHeader</c> table.
    /// </param>
    /// <returns>
    ///     A transaction number for the reversed transaction.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///     An error is thrown if advanced ledger entry header record is not found.
    /// </exception>
    public static AdvancedLedgerEntryId reverseAdvancedLedgerEntry(AdvancedLedgerEntryHeader _sourceHeader)
    {
        AdvancedLedgerEntryHeader targetHeader;
        AdvancedLedgerEntryLine   targetLine;
        AdvancedLedgerEntryLine   sourceLine;

        if (!_sourceHeader)
        {
            throw error(strFmt("@SPS1272", funcName()));
        }

        if (AdvancedLedgerEntryManager::checkAdvancedLedgerEntryNumberSequence())
        {
            ttsbegin;

            targetHeader.data(_sourceHeader);
            targetHeader.TransactionNumber = LedgerParameters::newAdvancedLedgerEntryId();
            targetHeader.TransactionStatus = AdvancedLedgerEntryTransactionStatus::Draft;

            // Check, if active ALE workflow template exist and then update the workflow status and workflow state accordingly.
            if (AdvancedLedgerEntryManager::activeWorkflowForCurrentCompanyExists())
            {
                targetHeader.WorkFlowStatus        = AdvancedLedgerEntryWFApprovalStatus::Draft;
                targetHeader.WorkflowApprovalState = AdvancedLedgerEntryWFApprovalState::NotSubmitted;
            }

            targetHeader.AccountingDate = _sourceHeader.ReverseDate;

            if (targetHeader.AccountingDate != _sourceHeader.AccountingDate)
            {
                targetHeader.FiscalCalendarPeriod = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(
                    Ledger::fiscalCalendar(),
                    targetHeader.AccountingDate).RecId;
            }

            targetHeader.ReverseEntry                   = NoYes::No;
            targetHeader.ReverseDate                    = dateNull();
            targetHeader.LedgerVoucher                  = '';
            targetHeader.AccountingDistributionTemplate = 0;
            targetHeader.SourceDocumentHeader           = 0;
            targetHeader.TransactionText                = strFmt("@SPS1928", _sourceHeader.TransactionNumber, _sourceHeader.TransactionText);
            targetHeader.insert();

            while select sourceLine
                where sourceLine.AdvancedLedgerEntryHeader == _sourceHeader.RecId
            {
                targetLine.data(sourceLine);
                targetLine.AmountCurCredit           = sourceLine.AmountCurDebit;
                targetLine.AmountCurDebit            = sourceLine.AmountCurCredit;
                targetLine.AdvancedLedgerEntryHeader = targetHeader.RecId;
                targetLine.SourceDocumentLine        = 0;
                targetLine.TransactionText           = strFmt("@SPS1928", _sourceHeader.TransactionNumber, sourceLine.TransactionText);
                targetLine.Quantity                  = sourceLine.Quantity * -1;
                targetLine.insert();
            }

            ttscommit;
        }

        return targetHeader.TransactionNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAccountingDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the specified date is within an open period for the ledger module.
    /// </summary>
    /// <param name="_date">
    ///     An accounting date.
    /// </param>
    /// <returns>
    ///     true if the date is within an open period for the ledger module; otherwise, false.
    /// </returns>
    public static boolean validateAccountingDate(AccountingDate _date)
    {
        boolean isValid = true;

        if (!AdvancedLedgerEntryManager::firstOpenPeriod(_date, true))
        {
            isValid = AifFault::checkFailedLogFault("@SPS1716");
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates the currency that is used with an advanced ledger entry.
    /// </summary>
    /// <param name="_currencyCode">
    ///     The currency to validate.
    /// </param>
    /// <returns>
    ///     true if the specified currency is valid; otherwise, false.
    /// </returns>
    public static boolean validateCurrency(CurrencyCode _currencyCode)
    {
        return Currency::exist(_currencyCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates the specified ledger dimension.
    /// </summary>
    /// <param name="_ledgerDimensionAdvancedLedgerEntry">
    ///     The ledger dimension to validate.
    /// </param>
    /// <param name="_date">
    ///     A date used to validate the ledger dimension.
    /// </param>
    /// <returns>
    ///     true if the ledger dimension is valid; otherwise, false.
    /// </returns>
    public static boolean validateLedgerDimension(
        DimensionDynamicAccount _ledgerDimensionAdvancedLedgerEntry,
        TransDate               _date)
    {
        boolean isValid = true;

        isValid = MainAccount::checkAllowPosting(
                    LedgerDimensionFacade::getMainAccountFromLedgerDimension(_ledgerDimensionAdvancedLedgerEntry).MainAccountId,
                        LedgerPostingType::LedgerJournal,
                        false,
                        true);

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLedgerDimensionWithManualEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the specified ledger dimension taking blocking for manual entry into account.
    /// </summary>
    /// <param name = "_ledgerDimensionAdvancedLedgerEntry">
    /// The ledger dimension to validate
    /// </param>
    /// <param name = "_date">
    /// A date used to validate the ledger dimension.
    /// </param>
    /// <param name = "_validateIsBlockedForManualEntry">
    /// Validate ledger dimension allows for manual entry.
    /// </param>
    /// <returns>
    /// true if the ledger dimension is valid; otherwise, false.
    ///</returns>
    public static boolean validateLedgerDimensionWithManualEntry(
        DimensionDynamicAccount _ledgerDimensionAdvancedLedgerEntry,
        TransDate _date,
        boolean _validateIsBlockedForManualEntry = true)
    {
        boolean isValid = true;

        isValid = MainAccount::checkAllowPosting(
                    LedgerDimensionFacade::getMainAccountFromLedgerDimension(_ledgerDimensionAdvancedLedgerEntry).MainAccountId,
                        LedgerPostingType::LedgerJournal,
                        false,
                        _validateIsBlockedForManualEntry);

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>activeWorkflowForCurrentCompanyExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if an active workflow exists for the current company.
    /// </summary>
    /// <returns>true if an active workflow exists for the current company; otherwise, false.</returns>
    public static boolean activeWorkflowForCurrentCompanyExists()
    {
        WorkflowTable           workflowTable;
        WorkflowVersionTable    workflowVersionTable;

        select firstonly workflowTable
                exists join workflowVersionTable
                where   workflowTable.TemplateName              == workflowTypeStr(AdvancedLedgerEntryTemplate)
                        && workflowTable.Type                   == WorkflowConfigurationType::Definition
                        && workflowTable.AssociationType        == WorkflowAssociationType::Company
                        && workflowTable.DataArea               == curExt()
                        && workflowVersionTable.WorkflowTable   == workflowTable.RecId
                        && workflowVersionTable.Enabled         == NoYes::Yes;

        return workflowTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newAdvancedLedgerTransactionNumberReserved</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a new advanced ledger entry transaction number and immediately consumes it.
    /// </summary>
    /// <returns>
    /// An advanced ledger entry transaction number.
    /// </returns>
    public static Num newAdvancedLedgerTransactionNumberReserved()
    {
        NumberSeq               numberSeq;
        Num                     transactionNumber;
        NumberSequenceReference numSeqReference = LedgerParameters::numRefAdvancedLedgerEntryId();

        if (numSeqReference)
        {
            numberSeq       = NumberSeq::newGetNum(numSeqReference);
            if (numberSeq)
            {
                transactionNumber = numberSeq.num();
            }
        }

        return transactionNumber;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>