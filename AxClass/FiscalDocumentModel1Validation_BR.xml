<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>FiscalDocumentModel1Validation_BR</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Validates fiscal document contents against specific rules to model 1 that may prevent it from being persisted.
/// </summary>
public class FiscalDocumentModel1Validation_BR extends FiscalDocumentValidationBase_BR
{

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>adjustMarkupAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts markup amount, if possible.
    /// </summary>
    /// <param name = "_pennyDiff">
    /// Difference between total amount and sum of lines amount.
    /// </param>
    /// <param name = "_totalAmount">
    /// The total line amount which can be adjusted.
    /// </param>
    /// <param name = "_markupClassification">
    /// The classification of markup amount.
    /// </param>
    /// <returns>
    /// True, if the line amount was adjusted; otherwise false.
    /// </returns>
    protected boolean adjustMarkupAmount(
        AmountMST _pennyDiff,
        FiscalDocumentMarkupSum_BR _totalAmount,
        MarkupClassification_BR _markupClassification)
    {
        boolean ret;

        if (abs(_pennyDiff) <= LedgerParameters::find().MaxRoundingDifferenceMST)
        {
            FiscalDocumentMarkupSum_BR amount = _totalAmount + _pennyDiff;

            switch (_markupClassification)
            {
                case MarkupClassification_BR::Freight:
                    fiscalDocumentParmData.parmTotalMarkupFreightAmount(amount);
                    break;

                case MarkupClassification_BR::Insurance:
                    fiscalDocumentParmData.parmTotalMarkupInsuranceAmount(amount);
                    break;

                case MarkupClassification_BR::Others:
                    fiscalDocumentParmData.parmTotalMarkupOtherAmount(amount);
                    break;

                default:
                    throw error(Error::wrongUseOfFunction(funcName()));
            }

            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>charges_SvcLineWithFreightOrInsurance</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether a miscellaneous charge of type freight or insurance is being applied to a service item.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::Complementary),
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::DeliverySlip),
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::Purch),
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::Sales),
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::MiscCharges)
    ]
    public boolean charges_SvcLineWithFreightOrInsurance()
    {
        if (this.parmFiscalDocumentLineParmData().parmItemType() == FiscalDocumentLineItemType_BR::Service)
        {
            if (this.parmFiscalDocumentMiscChargeParmData().parmType() == MarkupClassification_BR::Freight
                || this.parmFiscalDocumentMiscChargeParmData().parmType() == MarkupClassification_BR::Insurance)
            {
                logger.logError(strFmt("@GLS63975", this.parmFiscalDocumentLineParmData().parmItemId()));
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>charges_TypeOfMiscCharge</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether a miscellaneous charge is of type freight, insurance or other.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::Sales),
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::Return),
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::Complementary),
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::DeliverySlip),
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::MiscCharges)
    ]
    public boolean charges_TypeOfMiscCharge()
    {
        // This validation does not apply to Sales Return fiscal documents
        if (this.parmFiscalDocumentParmData().parmRefTableId() == tableNum(CustInvoiceJour)
            && this.parmFiscalDocumentParmData().parmDirection() == FiscalDocDirection_BR::Incoming)
        {
            return true;
        }

        if (this.parmFiscalDocumentMiscChargeParmData().parmType() != MarkupClassification_BR::Freight
            && this.parmFiscalDocumentMiscChargeParmData().parmType() != MarkupClassification_BR::Insurance
            && this.parmFiscalDocumentMiscChargeParmData().parmType() != MarkupClassification_BR::Others)
        {
            logger.logError("@GLS63976");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_CityFDocumentHasServiceItems</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether city fiscal documents have service items.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute,
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_CityFDocumentHasServiceItems()
    {
        if (this.parmFiscalDocumentParmData().isEFDocumentCity())
        {
            if (!this.parmFiscalDocumentParmData().hasServiceItems())
            {
                logger.logError("@GLS3800135");
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_CnpjNotBlankWhenNotForeign</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the account CNJP/CPF is not empty.
    /// </summary>
    /// <remarks>
    ///     This validation does not apply to foreign accounts.
    /// </remarks>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute,
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_CnpjNotBlankWhenNotForeign()
    {
        if (!this.parmFiscalDocumentParmData().isForeignOperation()
            && !this.parmFiscalDocumentParmData().parmThirdPartyCNPJCPF())
        {
            logger.logError(strFmt("@GLS64213",
                this.parmFiscalDocumentParmData().parmFiscalDocumentAccountType(),
                this.parmFiscalDocumentParmData().parmFiscalDocumentAccountNum()));
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_CNPJNumIsValid</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the third party CNJP/CPF is valid.
    /// </summary>
    /// <remarks>
    ///     This validation does not apply to foreign third parties.
    /// </remarks>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute,
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_CNPJNumIsValid()
    {
        DirPartyType    thirdPartyDirPartyType;
        CNPJCPFNum_BR   cnpjCpfToBeValidated = this.parmFiscalDocumentParmData().parmThirdPartyCNPJCPF();

        if (!this.parmFiscalDocumentParmData().isForeignOperation())
        {
            thirdPartyDirPartyType = this.parmFiscalDocumentParmData().thirdPartyType();

            switch (thirdPartyDirPartyType)
            {
                case DirPartyType::Organization:
                case DirPartyType::LegalEntity:
                    if (!FiscalInformationUtil_BR::isCNPJValid(cnpjCpfToBeValidated))
                    {
                        logger.logError(strFmt("@GLS64216",
                            this.parmFiscalDocumentParmData().parmFiscalDocumentAccountType(),
                            this.parmFiscalDocumentParmData().parmFiscalDocumentAccountNum()));
                        return false;
                    }
                    break;

                case DirPartyType::Person:
                    if (!FiscalInformationUtil_BR::isCPFValid(cnpjCpfToBeValidated))
                    {
                        logger.logError(strFmt("@GLS64216",
                            this.parmFiscalDocumentParmData().parmFiscalDocumentAccountType(),
                            this.parmFiscalDocumentParmData().parmFiscalDocumentAccountNum()));
                        return false;
                    }
                    break;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_ComplentaryFDocProperlyInformed</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the complemented fiscal document is properly informed.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::Complementary),
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header),
        NotApplicableExternalFiscalDocAttribute
    ]
    public boolean header_ComplentaryFDocProperlyInformed()
    {
        if (!this.parmFiscalDocumentParmData().parmComplementedFiscalDocument())
        {
            logger.logError("@GLS220084");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_CustVendTransDateIsValid</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the fiscal document due date is less than its document date.
    /// </summary>
    /// <remarks>
    ///     This validation does not apply to fiscal documents that don't have customer/vendor transactions or have installments.
    /// </remarks>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute,
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_CustVendTransDateIsValid()
    {
        date fiscalDocumentDate;
        date dueDate;

        if (!this.parmFiscalDocumentParmData().parmCustVendTrans()
            || this.parmFiscalDocumentParmData().parmCustVendTrans().qtyInstallments() > 0)
        {
            return true;
        }

        fiscalDocumentDate  = this.parmFiscalDocumentParmData().parmFiscalDocumentDate();
        dueDate             = this.parmFiscalDocumentParmData().parmCustVendTrans().parmDueDate();

        if (dueDate < fiscalDocumentDate)
        {
            logger.logError("@GLS64232");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_DeliveryAddressIsComplete</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the fiscal documentn delivery address is complete.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::Sales),
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::Return),
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::Complementary),
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_DeliveryAddressIsComplete()
    {
        if (!this.getDeliveryPostalAddress()
            || this.parmFiscalDocumentParmData().isForeignOperation())
        {
            return true;
        }

        if (!this.getDeliveryPostalAddress().Street
            || !this.getDeliveryPostalAddress().StreetNumber
            || !this.getDeliveryPostalAddress().City
            || !this.getDeliveryPostalAddress().ZipCode)
        {
            logger.logError("@GLS64230");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_DeliverySlipHasNoCustVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Verifies whether a delivery slip fiscal document has no customer transactions associated with it.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::DeliverySlip),
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_DeliverySlipHasNoCustVendTrans()
    {
        FiscalDocumentCustVendTransParmData_BR custVendTransParmData;

        custVendTransParmData = this.parmFiscalDocumentParmData().parmCustVendTrans();

        if (custVendTransParmData && custVendTransParmData.parmAmount() != 0)
        {
            logger.logError("@GLS220606");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_DeliverySlipHasNoDeliveryAddress</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether a delivery slip fiscal document does not have a delivery address.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::DeliverySlip),
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_DeliverySlipHasNoDeliveryAddress()
    {
        if (this.parmFiscalDocumentParmData().parmDeliveryLogisticsPostalAddress())
        {
            logger.logError("@GLS64344");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_DeliverySlipNotUsingEFDocForServ</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Verifies whether a delivery slip fiscal document is using a fiscal document type marked as electronic fiscal document for services.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::DeliverySlip),
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_DeliverySlipNotUsingEFDocForServ()
    {
        if (fiscalDocumentParmData.parmFiscalDocumentType().ElectronicInvoice)
        {
            logger.logError("@GLS3800139");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_DeliveryStateHasTwoDigits</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the delivery address state has two digits.
    /// </summary>
    /// <remarks>
    ///     This validation does not apply to foreign operations
    /// </remarks>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::Sales),
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::Return),
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_DeliveryStateHasTwoDigits()
    {
        if (!this.parmFiscalDocumentParmData().isForeignOperation()
            && this.getDeliveryPostalAddress())
        {
            if (strLen(this.getDeliveryPostalAddress().State) != 2)
            {
                logger.logError("@GLS64226");
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_fiscalDocumentHasLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the fiscal document has lines.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute,
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_fiscalDocumentHasLines()
    {
        str msg = "@GLS63984";

        if (!this.parmFiscalDocumentParmData().parmLines()
            || this.parmFiscalDocumentParmData().parmLines().elements() == 0)
        {
            logger.logError(msg);
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_IENumForNonForeignAccounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the third party IE number is valid.
    /// </summary>
    /// <remarks>
    ///     This validation does not apply to foreign operations.
    /// </remarks>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute,
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_IENumForNonForeignAccounts()
    {
        str ieNum;

        if (this.parmFiscalDocumentParmData().thirdPartyType() == DirPartyType::Person
            || this.parmFiscalDocumentParmData().thirdPartyType() == DirPartyType::Team
            || !this.parmFiscalDocumentParmData().parmThirdPartyIcmsContributor())
        {
            return true;
        }

        ieNum = this.parmFiscalDocumentParmData().parmThirdPartyIE();

        if (!this.parmFiscalDocumentParmData().isForeignOperation())
        {
            if (!ieNum)
            {
                logger.logError(strFmt("@GLS64214",
                    this.parmFiscalDocumentParmData().parmFiscalDocumentAccountType(),
                    this.parmFiscalDocumentParmData().parmFiscalDocumentAccountNum()));
                return false;
            }

            if (!FiscalInformationUtil_BR::isIEValid(ieNum, this.getThirdPartyPostalAddress().State))
            {
                logger.logError(strFmt("@GLS64215",
                    this.parmFiscalDocumentParmData().parmFiscalDocumentAccountType(),
                    this.parmFiscalDocumentParmData().parmFiscalDocumentAccountNum()));
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_installmentsNumbering</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Verifies whether installment numbering is correct.
    /// </summary>
    /// <remarks>
    ///     Installment numbers must start at 1 and be consecutive.
    /// </remarks>
    /// <returns>
    ///     True if installment numbers are correct; false otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute,
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_installmentsNumbering()
    {
        boolean                                 ok = true;
        List                                    listOfInstallments;
        ListEnumerator                          leInstallments;
        FiscalDocumentInstallmentParmData_BR    installment;
        boolean                                 installmentsMap [];
        int                                     installmentCount;

        if (!this.parmFiscalDocumentParmData().parmCustVendTrans())
        {
            return true;
        }

        listOfInstallments  = this.parmFiscalDocumentParmData().parmCustVendTrans().parmListOfInstallments();
        leInstallments      = listOfInstallments.getEnumerator();

        while (leInstallments.moveNext())
        {
            installment = leInstallments.current();
            installmentsMap[installment.parmInstallmentNumber()] = true;
        }

        for (installmentCount = 1; installmentCount <= listOfInstallments.elements(); installmentCount++)
        {
            if (installmentsMap[installmentCount] == false)
            {
                logger.logError("@GLS100285");
                ok = false;
                break;
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_IsPostingDateGreaterThanFDocDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the fiscal document invoice date is greater than posting date.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::All),
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_IsPostingDateGreaterThanFDocDate()
    {
        if (fiscalDocumentParmData.parmFiscalDocumentDate() > fiscalDocumentParmData.parmAccountingDate())
        {
            logger.logError("@GLS221047");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_IssueDateControl</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the fiscal document is being issued in a date later than the last one isued for the same series.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::All),
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header),
        NotApplicableExternalFiscalDocAttribute
    ]
    public boolean header_IssueDateControl()
    {
        FiscalEstablishmentId_BR fiscalEstablishmentId = FiscalDocument_BR::lastFiscalEstablishmentIdForSeries(this.parmFiscalDocumentParmData().parmFiscalDocumentSeries());
        date lastIssueDateForSameSeries = this.lastIssueDateForSeriesAndFiscalEstablishment(this.parmFiscalDocumentParmData().parmFiscalDocumentSeries(), fiscalEstablishmentId);

        if (fiscalDocumentParmData.parmFiscalDocumentIssuer() == FiscalDocumentIssuer_BR::OwnEstablishment
            && (fiscalDocumentParmData.parmFiscalDocumentDate() < lastIssueDateForSameSeries
                && fiscalDocumentParmData.parmFiscalEstablishmentID() == fiscalEstablishmentId))
        {
            logger.logError(strFmt("@GLS220079", lastIssueDateForSameSeries));
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastIssueDateForSeriesAndFiscalEstablishment</Name>
				<Source><![CDATA[
    private date lastIssueDateForSeriesAndFiscalEstablishment(FiscalDocumentSeries_BR _series, FiscalEstablishmentId_BR _fiscalEstablishment)
    {
        Query q = new Query();
        QueryBuildDataSource qbds = q.addDataSource(TableNum(FiscalDocument_BR));
        qbds.addSelectionField(FieldNum(FiscalDocument_BR, FiscalDocumentDate), SelectionField::Max);

        QueryBuildRange qbr = qbds.addRange(FieldNum(FiscalDocument_BR, FiscalDocumentIssuer));
        qbr.value(queryValue(FiscalDocumentIssuer_BR::OwnEstablishment));
        qbr = qbds.addRange(FieldNum(FiscalDocument_BR, FiscalDocumentSeries));
        qbr.value(queryValue(_series));
        qbr = qbds.addRange(FieldNum(FiscalDocument_BR, FiscalEstablishment));
        qbr.value(queryValue(_fiscalEstablishment));

        FiscalDocument_BR   fiscalDocument;
        QueryRun qr = new QueryRun(q);

        if (qr.next())
        {
            fiscalDocument = qr.get(TableNum(FiscalDocument_BR));
        }

        return fiscalDocument.FiscalDocumentDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_ModelIsSupportedForIssuing</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the fiscal document model is supported when the issuer is own establishment.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute,
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_ModelIsSupportedForIssuing()
    {
        FiscalDocModel_BR   fiscalDocModel;

        fiscalDocModel  = FiscalDocModel_BR::find(this.parmFiscalDocumentParmData().parmModel());

        if (this.parmFiscalDocumentParmData().parmFiscalDocumentIssuer() == FiscalDocumentIssuer_BR::OwnEstablishment &&
            (!fiscalDocModel || !fiscalDocModel.IssuingSupported))
        {
            logger.logError("@SYS4000358");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_NonTaxableCannotUseFDTForServ</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Verifies whether a fiscal document being issued on behalf of a non taxable vendor is using a fiscal document type
    ///     marked as electronic fiscal document for services.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::Purch),
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_NonTaxableCannotUseFDTForServ()
    {
        VendTable vendTable;

        if (fiscalDocumentParmData.parmFiscalDocumentIssuer() == FiscalDocumentIssuer_BR::OwnEstablishment)
        {
            vendTable = vendTable::find(fiscalDocumentParmData.parmFiscalDocumentAccountNum());
            if (vendTable
                && vendTable.NonTaxable_BR
                && fiscalDocumentParmData.parmFiscalDocumentType().ElectronicInvoice)
            {
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceBR00033, funcName());
                logger.logError("@GLS222853");
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_ReturnRequiresReferencedFDoc</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether a return fiscal document has the required fiscal reference properly configured.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::Return),
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_ReturnRequiresReferencedFDoc()
    {
        List listOfReferencedFiscalDocuments = this.parmFiscalDocumentParmData().parmListOfFiscalReference();

        if (!listOfReferencedFiscalDocuments
            || listOfReferencedFiscalDocuments.elements() == 0)
        {
            logger.logError("@GLS64228");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_SuframaNumber</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the fiscal document account suframa number is valid.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::Sales),
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::Complementary),
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::DeliverySlip),
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_SuframaNumber()
    {
        CustTable custTable = CustTable::find(this.parmFiscalDocumentParmData().parmFiscalDocumentAccountNum());

        if (!custTable.Suframa_BR)
        {
            return true;
        }

        if (!custTable.SuframaNumber_BR
            || strLen(custTable.SuframaNumber_BR) != 9)
        {
            logger.logError(strFmt("@GLS64221",
                this.parmFiscalDocumentParmData().parmFiscalDocumentAccountType(),
                this.parmFiscalDocumentParmData().parmFiscalDocumentAccountNum()));
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_sumOfMiscCharges</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the sum of miscellaneous charges match the totals informed on the fiscal document header.
    /// </summary>
    /// <returns>
    ///     True if the sum of each type of miscellaneous charge (Freight, Insurance and Others) occurences matches the totals informed on the header level; false otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute,
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_sumOfMiscCharges()
    {
        AmountMST                           sumOfFreight;
        AmountMST                           sumOfInsurance;
        AmountMST                           sumOfOthers;
        ListEnumerator                      leLines, leCharges;
        FiscalDocumentLineParmData_BR       line;
        FiscalDocumentMiscChargeParmData_BR charge;
        boolean                             ok = true;

        leLines = this.parmFiscalDocumentParmData().parmLines().getEnumerator();

        while (leLines.moveNext())
        {
            line = leLines.current();
            leCharges = line.parmListOfMiscCharges().getEnumerator();
            while (leCharges.moveNext())
            {
                charge = leCharges.current();
                switch (charge.parmType())
                {
                    case MarkupClassification_BR::Freight:
                        sumOfFreight    += charge.parmAmount();
                        break;
                    case MarkupClassification_BR::Insurance:
                        sumOfInsurance  += charge.parmAmount();
                        break;
                    case MarkupClassification_BR::Others:
                        sumOfOthers     += charge.parmAmount();
                        break;
                    case MarkupClassification_BR::SISCOMEX:
                        sumOfOthers     += charge.parmAmount();
                        break;
                }
            }
        }

        FiscalDocumentMarkupSum_BR totalMarkupFreightAmount = this.parmFiscalDocumentParmData().parmTotalMarkupFreightAmount();
        AmountMST pennyDiffFreight = sumOfFreight - totalMarkupFreightAmount;

        if (pennyDiffFreight && !this.adjustMarkupAmount(pennyDiffFreight, totalMarkupFreightAmount, MarkupClassification_BR::Freight))
        {
            logger.logError(strFmt("@GLS100284", MarkupClassification_BR::Freight, sumOfFreight, this.parmFiscalDocumentParmData().parmTotalMarkupFreightAmount()));
            ok = false;
        }

        FiscalDocumentMarkupSum_BR totalMarkupInsuranceAmount = this.parmFiscalDocumentParmData().parmTotalMarkupInsuranceAmount();
        AmountMST pennyDiffInsurance = sumOfInsurance - totalMarkupInsuranceAmount;

        if (pennyDiffInsurance && !this.adjustMarkupAmount(pennyDiffInsurance, totalMarkupInsuranceAmount, MarkupClassification_BR::Insurance))
        {
            logger.logError(strFmt("@GLS100284", MarkupClassification_BR::Insurance, sumOfInsurance, this.parmFiscalDocumentParmData().parmTotalMarkupInsuranceAmount()));
            ok = false;
        }

        FiscalDocumentMarkupSum_BR totalMarkupOtherAmount = this.parmFiscalDocumentParmData().parmTotalMarkupOtherAmount();
        AmountMST pennyDiffOthers = sumOfOthers - totalMarkupOtherAmount;

        if (pennyDiffOthers && !this.adjustMarkupAmount(pennyDiffOthers, totalMarkupOtherAmount, MarkupClassification_BR::Others))
        {
            logger.logError(strFmt("@GLS100284", MarkupClassification_BR::Others, sumOfOthers, this.parmFiscalDocumentParmData().parmTotalMarkupOtherAmount()));
            ok = false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_ThirdPartyAddressIsComplete</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the fiscal document third party address is complete.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute,
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_ThirdPartyAddressIsComplete()
    {
        CustTable               custTable;
        VendTable               vendTable;
        LogisticsPostalAddress  accountPostalAddress;

        if (this.parmFiscalDocumentParmData().isForeignOperation())
        {
            return true;
        }

        accountPostalAddress = LogisticsPostalAddress::findRecId(this.parmFiscalDocumentParmData().parmThirdPartyPostalAddress());

        if (!accountPostalAddress.Street
            || !accountPostalAddress.StreetNumber
            || !accountPostalAddress.City
            || !accountPostalAddress.ZipCode)
        {
            logger.logError(strFmt("@GLS64229",
                this.parmFiscalDocumentParmData().parmFiscalDocumentAccountType(),
                this.parmFiscalDocumentParmData().parmFiscalDocumentAccountNum()));
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_ThirdPartyAndDlvAddrInSameState</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the fiscal document delivery and invoice addresses are in the same state.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::Sales),
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::Return),
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_ThirdPartyAndDlvAddrInSameState()
    {
        if (fiscalDocumentParmData.parmDirection() == FiscalDocDirection_BR::Outgoing && this.getDeliveryPostalAddress())
        {
            if (!this.parmFiscalDocumentParmData().isForeignOperation() &&
                (this.getThirdPartyPostalAddress().State != this.getDeliveryPostalAddress().State
                || this.getThirdPartyPostalAddress().CountryRegionId != this.getDeliveryPostalAddress().CountryRegionId))
            {
                logger.logError("@GLS64220");
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_ThirdPartyFDocumentIsUnique</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the fiscal document number already exists for non-cancelled documents within the same series/Third Party Id.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::All),
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_ThirdPartyFDocumentIsUnique()
    {
        FiscalDocument_BR fiscalDocument;

        if (fiscalDocumentParmData.parmFiscalDocumentIssuer() == FiscalDocumentIssuer_BR::ThirdParty)
        {
            select RecId from fiscalDocument
                where fiscalDocument.FiscalDocumentIssuer == FiscalDocumentIssuer_BR::ThirdParty
                    && fiscalDocument.ThirdPartyCNPJCPF == fiscalDocumentParmData.parmThirdPartyCNPJCPF()
                    && fiscalDocument.FiscalDocumentSeries == fiscalDocumentParmData.parmFiscalDocumentSeries()
                    && fiscalDocument.FiscalDocumentNumber == fiscalDocumentParmData.parmFiscalDocumentNumber()
                    && fiscalDocument.Model == fiscalDocumentParmData.parmModel()
                    && fiscalDocument.RecId != fiscalDocumentParmData.parmFiscalDocumentRecId()
                    && fiscalDocument.Status != FiscalDocumentStatus_BR::Reversed;

            if (fiscalDocument)
            {
                logger.logError(strFmt("@GLS220083",
                                   fiscalDocumentParmData.parmFiscalDocumentAccountNum(),
                                   fiscalDocumentParmData.parmFiscalDocumentSeries(),
                                   #error001));
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_ThirdPartyNameNotEmpty</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the fiscal document third party name is not empty.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute,
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_ThirdPartyNameNotEmpty()
    {
        AccountName accountName;

        accountName = this.parmFiscalDocumentParmData().parmThirdPartyName();

        if (!accountName)
        {
            logger.logError(strFmt("@GLS64223",
                this.parmFiscalDocumentParmData().parmFiscalDocumentAccountType(),
                this.parmFiscalDocumentParmData().parmFiscalDocumentAccountNum()));
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_ThirdPartyStateHasTwoDigits</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the Third Party address state has two digits.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute,
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_ThirdPartyStateHasTwoDigits()
    {
        if (!this.parmFiscalDocumentParmData().isForeignOperation()
            && strLen(this.getThirdPartyPostalAddress().State) != 2)
        {
            logger.logError("@GLS64227");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_totalAmountToPurposeRegular</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the fiscal document with purpose regular has amount total different from zero.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute,
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_totalAmountToPurposeRegular()
    {
        if (this.parmFiscalDocumentParmData().parmPurpose() == FiscalDocumentPurpose_BR::Regular
            && this.parmFiscalDocumentParmData().parmTotalAmount() == 0)
        {
            logger.logError("@SYS4000726");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>header_VolumeInformation</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Verifies whether volume information (type and quantity) is present for fiscal documents issued by the company.
    /// </summary>
    /// <remarks>
    ///     This validations is applicable only when fiscal books integration is enabled for the company.
    /// </remarks>
    /// <returns>
    ///     True if volume information is properly informed in the fiscal document. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute,
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Header)
    ]
    public boolean header_VolumeInformation()
    {
        FiscalDocumentParmData_BR               fiscalDocument;
        ListEnumerator                          shipmentsEnumerator;
        FiscalDocumentShipmentStatParmData_BR   shipmentStat;
        boolean                                 okForVolumeType     = true;
        boolean                                 okForVolumeQuantity = true;

        fiscalDocument = this.parmFiscalDocumentParmData();

        if (fiscalDocument.parmFiscalDocumentIssuer() != FiscalDocumentIssuer_BR::OwnEstablishment
            || !fiscalDocument.hasProductItems())
        {
            return true;
        }

        if (fiscalDocument.parmListOfShipmentStat())
        {
            shipmentsEnumerator = fiscalDocument.parmListOfShipmentStat().getEnumerator();
            while (shipmentsEnumerator.moveNext())
            {
                shipmentStat = shipmentsEnumerator.current();
                if (okForVolumeType && !shipmentStat.parmVolumeType())
                {
                    logger.logError("@GLS100450");
                    okForVolumeType = false;
                }
                if (okForVolumeQuantity && !shipmentStat.parmVolumeQuantity())
                {
                    logger.logError("@GLS100451");
                    okForVolumeQuantity = false;
                }
            }
        }

        return okForVolumeType && okForVolumeQuantity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>line_CfopAndAddressesShouldBeCompatible</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether a fiscal document line CFOP is compatible with fiscal document addresses.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute,
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Line)
    ]
    public boolean line_CfopAndAddressesShouldBeCompatible()
    {
        CFOPTable_BR                cfopTable;
        CFOPAddressInformation_BR   cfopAddressInformationFrom, cfopAddressInformationTo;
        LogisticsPostalAddress      logisticsPostalAddressFrom, logisticsPostalAddressTo;

        if (!this.parmFiscalDocumentLineParmData().parmCFOP())
        {
            return true;
        }

        logisticsPostalAddressFrom = LogisticsPostalAddress::findRecId(this.parmFiscalDocumentParmData().parmFiscalEstablishmentPostalAddress());
        logisticsPostalAddressTo   = LogisticsPostalAddress::findRecId(this.parmFiscalDocumentParmData().parmThirdPartyPostalAddress());

        cfopAddressInformationFrom = new CFOPAddressInformation_BR(logisticsPostalAddressFrom);
        cfopAddressInformationTo   = new CFOPAddressInformation_BR(logisticsPostalAddressTo);

        cfopTable = CFOPTable_BR::findByCFOPId(this.parmFiscalDocumentLineParmData().parmCFOP());
        if (cfopTable.CustVendLocation != cfopAddressInformationFrom.getLocationRelativeTo(cfopAddressInformationTo))
        {
            logger.logError(strFmt("@GLS100449", cfopTable.cfopId, cfopTable.CustVendLocation));
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>line_CfopForProductItems</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether a fiscal document line for a product has a valid CFOP.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute,
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Line)
    ]
    public boolean line_CfopForProductItems()
    {
        str msg = "@GLS63970";

        if (this.parmFiscalDocumentLineParmData().parmItemType() == FiscalDocumentLineItemType_BR::Product
            && !this.parmFiscalDocumentLineParmData().parmCFOP())
        {
            logger.logError(msg);
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>line_deliverySlipHasNoServiceLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether a delivery slip fiscal document line is not for an item of type service.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::DeliverySlip),
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Line)
    ]
    public boolean line_deliverySlipHasNoServiceLines()
    {
        if (this.parmFiscalDocumentLineParmData().parmItemType() == FiscalDocumentLineItemType_BR::Service)
        {
            logger.logError("@GLS63986");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>line_FiscalReferenceMandatory</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the fiscal document has fiscal references according to what is required by each of its CFOP lines.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute,
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Line)
    ]
    public boolean line_FiscalReferenceMandatory()
    {
        CFOPTable_BR                        cfopTable;
        ListEnumerator                      le;
        FiscalDocumentReferencedParmData_BR fiscalDocumentReferencedParmData;

        cfopTable = CFOPTable_BR::findByCFOPId(this.parmFiscalDocumentLineParmData().parmCFOP());

        if (!cfopTable.FiscalRefMandatory)
            return true;

        le = this.parmFiscalDocumentParmData().parmListOfFiscalReference().getEnumerator();
        while (le.moveNext())
        {
            fiscalDocumentReferencedParmData = le.current();
            if (fiscalDocumentReferencedParmData.parmFiscalDocumentSourceText())
            {
                return true;
            }
        }

        logger.logError("@GLS61046");
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>line_ServiceCodeForServiceItems</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether a fiscal document line for a service has service code.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute,
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::Line)
    ]
    public boolean line_ServiceCodeForServiceItems()
    {
        if (this.parmFiscalDocumentLineParmData().parmItemType() == FiscalDocumentLineItemType_BR::Service)
        {
            TaxServiceCodeId_BR serviceCode = this.parmFiscalDocumentLineParmData().parmServiceCode();

            if (!serviceCode)
            {
                logger.logError("@GLS221024");
                return false;
            }

            List listOfTaxes = this.parmFiscalDocumentLineParmData().parmListOfTaxes();
            if (!listOfTaxes)
            {
                return true;
            }

            boolean hasInssTaxType = false;
            ListEnumerator listOfTaxTransEnumerator = listOfTaxes.getEnumerator();
            while (listOfTaxTransEnumerator.moveNext())
            {
                TaxType_BR taxType = listOfTaxTransEnumerator.current().parmType();
                if (taxType == TaxType_BR::INSS || taxType == TaxType_BR::INSSRetained)
                {
                    hasInssTaxType = true;
                    break;
                }
            }

            if (!hasInssTaxType)
            {
                return true;
            }

            RefRecId serviceType = this.serviceType(serviceCode);

            if (!serviceType)
            {
                logger.logError("@SpedReinf_AS:TheServiceTypeIsMandatoryForServices");
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tax_icmsExemptForSuframa</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the ICMS tax for a fiscal document whose customer is in the suframa region is exempt.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::Sales),
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::TaxTrans)
    ]
    public boolean tax_icmsExemptForSuframa()
    {
        CustTable   custTable;

        if (this.parmFiscalDocumentTaxTransParmData().parmType() != TaxType_BR::ICMS)
        {
            return true;
        }

        if (this.parmFiscalDocumentLineParmData().parmOrigin() != FITaxationOrigin_BR::DirectImport)
        {
            custTable = CustTable::find(this.parmFiscalDocumentParmData().parmFiscalDocumentAccountNum());

            if (custTable != null && custTable.Suframa_BR
            && this.parmFiscalDocumentTaxTransParmData().parmFiscalValue() != TaxFiscalValue_BR::WithoutCreditDebitExempt)
            {
                logger.logError("@GLS63974");
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tax_TaxationCodeIsWithinValidDates</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether the taxation code of a tax is date effective at the fiscal document transaciton date.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute,
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::TaxTrans)
    ]
    public boolean tax_TaxationCodeIsWithinValidDates()
    {
        TaxationCodeTable_BR    taxationCodeTable;
        TransDate               transactionDate = this.parmFiscalDocumentParmData().parmFiscalDocumentDate();

        taxationCodeTable = TaxationCodeTable_BR::find(this.parmFiscalDocumentTaxTransParmData().parmType(),
                                                       this.parmFiscalDocumentTaxTransParmData().parmTaxationCode());

        if (taxationCodeTable)
        {
            if (!TaxationCodeTable_BR::asOf(taxationCodeTable.RecId, transactionDate))
            {
                logger.logError(strFmt("@GLS63988",
                                          this.parmFiscalDocumentTaxTransParmData().parmType(),
                                          this.parmFiscalDocumentParmData().parmFiscalDocumentDate()));
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tax_TaxSubstitutionAndDifferentialRate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether a tax does not have tax substitution and differential rate applied at the same time.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute,
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::TaxTrans)
    ]
    public boolean tax_TaxSubstitutionAndDifferentialRate()
    {
        ListEnumerator                      listOfTaxTransEnumerator;
        FiscalDocumentTaxTransParmData_BR   taxTransParmData;
        boolean                             icmsSTFound;
        boolean                             icmsDiffFound;

        if (!this.parmFiscalDocumentLineParmData().parmListOfTaxes())
        {
            return true;
        }

        listOfTaxTransEnumerator    = this.parmFiscalDocumentLineParmData().parmListOfTaxes().getEnumerator();
        while (listOfTaxTransEnumerator.moveNext())
        {
            taxTransParmData = listOfTaxTransEnumerator.current();

            if (taxTransParmData.parmType() == TaxType_BR::ICMSDiff)
            {
                icmsDiffFound = true;
            }

            if (taxTransParmData.parmType() == TaxType_BR::ICMSST)
            {
                icmsSTFound = true;
            }
        }

        if (icmsDiffFound && icmsSTFound)
        {
            logger.logError(strFmt("@GLS63971", this.parmFiscalDocumentTaxTransParmData().parmType()));
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tax_TaxTranferHasNoDifferentialRateTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether a tax transaction in a tax transfer fiscal document does not have a differential rate applied to it.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::TaxTransfer),
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::TaxTrans)
    ]
    public boolean tax_TaxTranferHasNoDifferentialRateTax()
    {
        if (this.parmFiscalDocumentTaxTransParmData().parmType() == TaxType_BR::ICMSDiff && this.parmFiscalDocumentTaxTransParmData().parmTaxValue() > 0)
        {
            logger.logError("@GLS63972");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tax_TaxTranferHasNoTaxSubstitutionTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether a tax transaction in a tax transfer fiscal document does not have a tax substitution rate applied to it.
    /// </summary>
    /// <returns>
    ///     True if the validation succeeds. False otherwise.
    /// </returns>
    [
        FiscalDocumentValidationAttribute(FiscalDocumentClassification_BR::TaxTransfer),
        FiscalDocumentValidationElementAttribute(FiscalDocumentElement_BR::TaxTrans)
    ]
    public boolean tax_TaxTranferHasNoTaxSubstitutionTax()
    {
        if (this.parmFiscalDocumentTaxTransParmData().parmType() == TaxType_BR::ICMSST && this.parmFiscalDocumentTaxTransParmData().parmTaxAmount() > 0)
        {
            logger.logError("@GLS63973");
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>serviceType</Name>
				<Source><![CDATA[
    private RefRecId serviceType(TaxServiceCodeId_BR _serviceCode)
    {
        RefRecId serviceType;
        TaxServiceCode_BR serviceCode = TaxServiceCode_BR::find(_serviceCode);

        if (VendTable::find(this.parmfiscalDocumentParmData().parmFiscalDocumentAccountNum()).ServiceCodeOnDlvAddress_BR)
        {
            serviceType = TaxServiceCode_BR::findCompanyServiceCode(serviceCode.ParentServiceCode).ServiceType;
        }
        else
        {
            serviceType = serviceCode.ServiceType;
        }

        return serviceType;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>