<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailTransactionService</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Application.Instrumentation;
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;
using Microsoft.Dynamics.Commerce.Runtime.Services.CustomerOrder;
using Retail=Microsoft.Dynamics.Retail;

/// <summary>
/// The <c>RetailTransactionService</c> class is used as a service class between the Ax and the POS.
/// </summary>
class RetailTransactionService
{
    #define.Star('*')
    #define.EchoDefaultValue('__EchoDefaultValue__')

    #define.resultsCountOfTransaction(20)

    // <GIN>
    #ISOCountryRegionCodes
    // </GIN>

    // <GEERU>
    #EECountryRegionCodes
    // </GEERU>

    #define.Discounts('Discounts')

    #define.Discount('Discount')
    #define.Amount('Amount')
    #define.DiscountCode('DiscountCode')
    #define.PeriodicDiscountOfferId('PeriodicDiscountOfferId')

    private static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getLineDeliveryModesForShipping</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets line delivery modes for shipping.
    /// </summary>
    /// <param name = "xmlArgumentString">
    /// The XML document containing the criteria for getting delivery modes.
    /// </param>
    /// <returns>
    /// XML string with the sales line identifier and delivery modes.
    /// </returns>
    public static container getLineDeliveryModesForShipping(str xmlArgumentString = '')
    {
        return RetailTransactionServiceOrders::getLineDeliveryModesForShipping(xmlArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllDeliveryModes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets line delivery modes for shipping.
    /// </summary>
    /// <param name = "xmlArgumentString">
    /// The XML document containing the criteria for getting delivery modes.
    /// </param>
    /// <returns>
    /// XML string with the sales line identifier and delivery modes.
    /// </returns>
    public static container getAllDeliveryModes(str xmlArgumentString = '')
    {
        return RetailTransactionServiceOrders::getAllDeliveryModes(xmlArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>activateDevice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Activate the device.
    /// </summary>
    /// <param name="_deviceId">
    /// ID of the Device.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the terminal.
    /// </param>
    /// <param name="_staffId">
    /// ID of the staff.
    /// </param>
    /// <param name="_physicalDeviceId">
    /// ID of the physical device.
    /// </param>
    /// <param name="_forceActivate">
    /// A value indicating whether to force the Activation of a device when the physical device identifiers are different.
    /// </param>
    /// <param name="_deviceTypeValue">
    /// The device type value of the device to be activated.
    /// </param>
    /// <returns>
    /// A container object containing status of activation, error message (if any) and the details of the device - terminal, store
    /// </returns>
    /// <remarks>
    /// Validates the Device with the activation code and generates a token.
    /// </remarks>
    public static container activateDevice(RetailDeviceId _deviceId, RetailTerminalId _terminalId, RetailStaffId _staffId, RetailPhysicalDeviceId _physicalDeviceId = '', boolean _forceActivate = false, RetailDeviceTypeId _deviceTypeValue = -1)
    {
        return RetailTransactionServiceDevice::activateDevice(_deviceId, _terminalId, _staffId, _physicalDeviceId, _forceActivate, _deviceTypeValue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>massActivateDevice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Activate the device as part of mass activation.
    /// </summary>
    /// <param name="_deviceId">
    /// ID of the Device.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the terminal.
    /// </param>
    /// <param name="_staffId">
    /// ID of the staff.
    /// </param>
    /// <param name="_physicalDeviceId">
    /// ID of the physical device.
    /// </param>
    /// <param name="_deviceTypeValue">
    /// The device type value of the device to be activated.
    /// </param>
    /// <returns>
    /// A container object containing status of activation, error message (if any) and the details of the device - terminal, store
    /// </returns>
    /// <remarks>
    /// Validates the Device with the activation code and generates a token.
    /// </remarks>
    [SysObsolete('Use method activateDevice() instead', false, 13\05\2023)]
    public static container massActivateDevice(RetailDeviceId _deviceId, RetailTerminalId _terminalId, RetailStaffId _staffId, RetailPhysicalDeviceId _physicalDeviceId = '', RetailDeviceTypeId _deviceTypeValue = -1)
    {
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAvailableTerminals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the list of terminal with device activation information by the store number.
    /// </summary>
    /// <param name="_storeId">
    /// The store identifier.
    /// </param>
    /// <param name="_deviceType">
    /// The device type value to be searched.
    /// </param>
    /// <param name="_top">
    /// The number of terminal information records to get.
    /// </param>
    /// <param name="_skip">
    /// The number of terminal information records to skip.
    /// </param>
    /// <returns>
    /// A container having the list of terminals of the specified store in XML string.
    /// </returns>
    public static container getAvailableTerminals(RetailStoreId _storeId, RetailDeviceTypeId _deviceType = enum2int(RetailDeviceTypeBase::None), int64 _top = 100, int64 _skip = 0)
    {
        return RetailTransactionServiceDevice::getAvailableTerminals(_storeId, _deviceType, _top, _skip);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAvailableDevices</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the list of devices available for device activation based on the device type.
    /// </summary>
    /// <param name="_deviceType">
    /// The device type value to be searched.
    /// </param>
    /// <param name="_top">
    /// The number of device records to get.
    /// </param>
    /// <param name="_skip">
    /// The number of device records to skip.
    /// </param>
    /// <returns>
    /// A container having the list of devices associated with the device type in XML string.
    /// </returns>
    public static container getAvailableDevices(RetailDeviceTypeId _deviceType = -1, int64 _top = 100, int64 _skip = 0)
    {
        return RetailTransactionServiceDevice::getAvailableDevices(_deviceType, _top, _skip);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDiscountLineXml</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds Sales Discount Line XML for the given SalesLine InventTransId
    /// </summary>
    /// <param name="_xmlDoc">
    /// Parent XML document.
    /// </param>
    /// <param name="_xmlItem">
    /// Parent XML node the Discount Line XML will be added to.
    /// </param>
    /// <param name="_inventTrans">
    /// InventTransId of the sales line.
    /// </param>
    /// <param name="_fromQuote">
    /// True if the discount lines are from a Quote, False if they are from a Sales Order.
    /// </param>
    /// <remarks>
    /// Gets XML representing the associated SalesDiscountLines for the given SalesLine and adds them to the given Item xml node.
    /// </remarks>
    private static void addDiscountLineXml(XmlDocument _xmlDoc, XmlElement _xmlItem, InventTransId _inventTrans, boolean _fromQuote)
    {
        RetailSalesDiscountLine retailSalesDiscountLine;
        RetailSalesQuotationDiscountLine retailSalesQuoteDiscountLine;
        XmlElement xmlLineDiscounts, xmlLineRecord;

        //Get line level discount info
        xmlLineDiscounts = _xmlDoc.createElement(#Discounts);

        if (_fromQuote)
        {
            while select Amount, DiscountCode, PeriodicDiscountOfferId  from retailSalesQuoteDiscountLine
                    where retailSalesQuoteDiscountLine.InventTransId == _inventTrans
            {
                xmlLineRecord = _xmlDoc.createElement(#Discount);
                xmlLineRecord.setAttribute(#Amount, num2str(retailSalesQuoteDiscountLine.Amount,5,3,1,0));
                xmlLineRecord.setAttribute(#DiscountCode, retailSalesQuoteDiscountLine.DiscountCode);
                xmlLineRecord.setAttribute(#PeriodicDiscountOfferId, retailSalesQuoteDiscountLine.PeriodicDiscountOfferId);

                xmlLineDiscounts.appendChild(xmlLineRecord);
            }
        }
        else
        {
            while select Amount, DiscountCode, PeriodicDiscountOfferId  from retailSalesDiscountLine
                    where retailSalesDiscountLine.InventTransId == _inventTrans
            {
                xmlLineRecord = _xmlDoc.createElement(#Discount);
                xmlLineRecord.setAttribute(#Amount, num2str(retailSalesDiscountLine.Amount,5,3,1,0));
                xmlLineRecord.setAttribute(#DiscountCode, retailSalesDiscountLine.DiscountCode);
                xmlLineRecord.setAttribute(#PeriodicDiscountOfferId, retailSalesDiscountLine.PeriodicDiscountOfferId);

                xmlLineDiscounts.appendChild(xmlLineRecord);
            }
        }

        _xmlItem.appendChild(xmlLineDiscounts);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToGiftCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the record in <c>RetailGiftCardTransactions</c> table.
    /// Initially the gift card is marked as reserved.  Call giftCardRelease to clear the reservation.
    /// </summary>
    /// <param name="_cardNumber">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailGiftCardTransactions.storeId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailGiftCardTransactions.terminalId field.
    /// </param>
    /// <param name="_staffId">
    /// ID of the RetailGiftCardTransactions.staffId field.
    /// </param>
    /// <param name="_transactionId">
    /// ID of the RetailGiftCardTransactions.transactionId field.
    /// </param>
    /// <param name="_receiptId">
    /// ID of the RetailGiftCardTransactions.receiptId field.
    /// </param>
    /// <param name="_currencyCode">
    /// <c>CurrencyCode</c>
    /// </param>
    /// <param name="_amountMST">
    /// Value of the RetailGiftCardTransactions.amount field.
    /// </param>
    /// <param name="_transDate">
    /// Value of the RetailGiftCardTransactions.transDate field.
    /// </param>
    /// <param name="_transTime">
    /// Value of the RetailGiftCardTransactions.transTime field.
    /// </param>
    /// <param name="_dateSequence">
    /// Format of the date.
    /// </param>
    /// <param name="_channelId">
    /// ID of the RetailGiftCardTransactions.channel field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container addToGiftCard(RetailGiftCardId   _cardNumber,
                                           RetailStoreId       _storeId,
                                           RetailTerminalId    _terminalId,
                                           RetailStaffId       _staffId,
                                           RetailTransactionId _transactionId,
                                           RetailReceiptId     _receiptId,
                                           CurrencyCode     _currencyCode,
                                           AmountMST        _amountMST,
                                           str              _transDate,
                                           str              _transTime,
                                           int              _dateSequence = 321,
                                           RetailChannelRecId  _channelId = 0)
    {
        #OCCRetryCount

        RetailGiftCardTable tGiftCardTable;
        container giftCardStatus = [false, "", "", 0]; // Status, ErrorMsg, currenyCode, Balance
        str giftCardCompany;
        container conCompanies;
        str giftCardAddCompany;
        str result = "";
        Counter   pCounter = 0;

        // Get the channel id from storeid if the channelid is not set
        _channelId = RetailTransactionService::getChannelIdFromStoreId(_storeId, _channelId);

        try
        {
            giftCardCompany = RetailParameters::find().GiftCardCompany;
            changeCompany(giftCardCompany)
            {
                ttsbegin;
                tGiftCardTable = RetailGiftCardTable::find(_cardNumber, true);

                if (tGiftCardTable)
                {
                    if (_currencyCode == tGiftCardTable.CurrencyCode)
                    {
                        //Check for existing transaction
                        boolean _transactionExists=RetailGiftCardTransactions::findTransaction(RetailGiftCardOperation::AddTo, _cardNumber, _transactionId, _amountMST);

                        // In case the transaction exists, we need to check if the corr. reversal for that transaction exists too before proceeding to record the transaction.
                        int txnCountForGivenAmount = RetailGiftCardTransactions::countTransactions(RetailGiftCardOperation::AddTo, _cardNumber, _transactionId, _amountMST);
                        int txnCountForInverseAmount = RetailGiftCardTransactions::countTransactions(RetailGiftCardOperation::AddTo, _cardNumber, _transactionId, -_amountMST);

                        // To understand the logic behind the below 2 boolean flags, consider the following 2 scenarios:
                        // 1) Cashier performs AddTo, VoidAddTo, AddTo:
                        //    In this scenario, txnCountForGivenAmount should EQUAL txnCountForInverseAmount. Both should be 1
                        //    This is because any AddTo operation is only allowed when all previous AddTo's are cancelled out by Voids.
                        // 2) Cashier performs AddTo, VoidAddTo, AddTo, VoidAddTo:
                        //    In this scenario txnCountForGivenAmount = 1. txnCountForInverseAmount = 2.
                        //    We need to make sure txnCountForInverseAmount - txnCountForGivenAmount = 1
                        //    This is because we can only perform a Void operation iff there exists a previous AddTo.
                        boolean allowRepeatAddToOperation = _transactionExists && _amountMST > 0 && txnCountForGivenAmount == txnCountForInverseAmount;
                        boolean allowRepeatVoidAddToOperation = _transactionExists && _amountMST < 0 && abs(txnCountForGivenAmount - txnCountForInverseAmount) == 1;

                        if (!_transactionExists || allowRepeatAddToOperation || allowRepeatVoidAddToOperation)
                        {
                            tGiftCardTable.reserveCard(_terminalId, _channelId, _transactionId); // Lock new cards until paid for...

                            RetailGiftCardTransactions::add(RetailGiftCardOperation::AddTo, _cardNumber,_channelId,
                             _terminalId, _staffId, _transactionId, _receiptId, _amountMST,
                            str2Date(_transDate,_dateSequence), str2time(_transTime));

                            giftCardStatus = [true, '', tGiftCardTable.CurrencyCode, tGiftCardTable.balance()];

                            eventSource.EventWritePaymentsGiftCardAdd(tGiftCardTable.RecId);
                        }
                        else
                        {
                            giftCardStatus = [true, '', tGiftCardTable.CurrencyCode, tGiftCardTable.balance()];
                            eventSource.EventWritePaymentsGiftCardTransactionAlreadyExists(tGiftCardTable.RecId);
                        }
                    }
                    else
                    {
                        giftCardStatus = [false, "@RET2462"];
                        eventSource.EventWritePaymentsGiftCardTransactionInDifferentCurrency(tGiftCardTable.RecId);
                    }
                }
                else
                {
                    giftCardStatus = [false,"@RET2431"];
                    eventSource.EventWritePaymentsGiftCardDoesNotExist(tGiftCardTable.RecId);
                }

                ttscommit;
            }
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
            {
                retry;
            }

            giftCardStatus = [false, "@RET2429"];
            eventSource.EventWritePaymentsGiftCardTransactionErrorOccurred();
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    eventSource.EventWritePaymentsGiftCardUpdateConflictNotRecoveredError();
                }
                else
                {
                    eventSource.EventWritePaymentsGiftCardRetry(#RetryNum);
                    retry;
                }
            }
            else
            {
                eventSource.EventWritePaymentsGiftCardUpdateConflictException();
            }

            giftCardStatus = [false, "@RET2429"];
        }
        catch
        {
            giftCardStatus = [false, "@RET2429"];
            eventSource.EventWritePaymentsAddToGiftCardException();
        }

        return giftCardStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>authenticateDevice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Authenticate the device.
    /// </summary>
    /// <param name="deviceId">
    /// ID of the Device.
    /// </param>
    /// <param name="deviceToken">
    /// device token.
    /// </param>
    /// <param name="physicalDeviceId">
    /// physical device id.
    /// </param>
    /// <returns>
    /// A container object containing status of authentication, error message (if any)
    /// </returns>
    public static container authenticateDevice(RetailDeviceId deviceId, str deviceToken)
    {
        RetailDevice device;
        RetailTerminalTable terminal;
        container deviceAuthenticationResponse = [false, ""]; // Status, ErrorMsg

        // Disable cache before selecting the device
        device.disableCache(true);
        select firstonly device where device.DeviceId == deviceId;
        terminal = RetailTerminalTable::find(device.Terminal);

        if (device)
        {
            if (device.ActivationStatus != RetailDeviceActivationStatusBase::Activated)
            {
                // Device is not in Activated state
                deviceAuthenticationResponse = [false, "@REX4040052"];
            }
            else if (!device.validateToken(deviceToken) )
            {
                deviceAuthenticationResponse = [false, strFmt("@Retail:InvalidDeviceToken", terminal.terminalId)];
            }
            else if (!device.validateTokenExpiration(deviceToken) )
            {
                deviceAuthenticationResponse = [false, "@Retail:ExpiredDeviceToken"];
            }
            else
            {
                deviceAuthenticationResponse =  RetailTransactionServiceDevice::deviceManagementResponse(terminal, device, '');
            }
        }
        else
        {
            // Device is not found
            deviceAuthenticationResponse = [false, "@REX30"];
            ApplicationEventSource::EventWriteRetailTransactionServiceWarning(funcName(), 'Invalid device id.');
        }

        return deviceAuthenticationResponse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels the sales order.
    /// </summary>
    /// <param name="custOrderXmlStr">
    /// XML string having the header, line details and charges, payments associated with the sales order to be canceled.
    /// </param>
    /// <returns>
    /// A container having the status of order cancellation.
    /// </returns>
    public static container cancelCustomerOrder(str custOrderXmlStr)
    {
        return RetailTransactionServiceOrders::cancelCustomerOrder(custOrderXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDisbursementSlipExist_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the specified disbursement order number exists in Cash transactions.
    /// </summary>
    /// <param name="_storeId">
    /// The rerail store number identifier.
    /// </param>
    /// <param name="_cashDocId">
    /// The disbursement slip number identifier.
    /// </param>
    /// <param name="_amountCur">
    /// Amount in transaction currency.
    /// </param>
    /// <param name="_currencyCode">
    /// Currency code.
    /// </param>
    /// <param name="_transDate">
    /// Transaction date.
    /// </param>
    /// <param name="_custAccount">
    /// Customer account.
    /// </param>
    /// <returns>
    /// A <c>container</c> containing the check result.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message,
    /// 3 - check result status.
    /// </remarks>
    [SysObsolete('Returns in next shift processing is not required in Russia any longer.', false, 13\05\2023)]
    public static container cashDisbursementSlipExist_RU(RetailStoreId _storeId, RCashDocId _cashDocId, AmountCur _amountCur, CurrencyCode _currencyCode, TransDate _transDate, CustAccount _custAccount)
    {
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDisbursementSlipIsUsedInPayment_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the specified disbursement order number is used in payment transactions.
    /// </summary>
    /// <param name="_retailStoreId">
    /// Retail store number identifier.
    /// </param>
    /// <param name="_cashDocId">
    /// Cash slip order ID.
    /// </param>
    /// <returns>
    /// A <c>container</c> containing the check result.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message,
    /// 3 - check result status.
    /// </remarks>
    [SysObsolete('Returns in next shift processing is not required in Russia any longer.', false, 13\05\2023)]
    public static container cashDisbursementSlipIsUsedInPayment_RU(RetailStoreId _retailStoreId, RCashDocId _cashDocId)
    {
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeStoreForTerminal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Change the store for a terminal.
    /// </summary>
    /// <param name="terminalRecId">
    /// RecId of the terminal.
    /// </param>
    /// <param name="storeRecId">
    /// RecId of the store.
    /// </param>
    /// <returns>
    /// A container object containing status and error message (if any)
    /// </returns>
    public static container changeStoreForTerminal(RefRecId terminalRecId, RefRecId storeRecId)
    {
        RetailTerminalTable terminal;
        container response = [false, ""]; // Status, ErrorMsg

        try
        {
            select forUpdate terminal
             where terminal.RecId == terminalRecId;

            if (terminal)
            {
                // Update the terminal-store association
                terminal.StoreRecId = storeRecId;
                terminal.update();
                response = [true, ""];
            }
            else
            {
                // Terminal is not found
                response = [false, "@REX32"];
                ApplicationEventSource::EventWriteRetailTransactionServiceWarning(funcName(), 'Terminal does not exist.');
            }
        }
        catch
        {
            // Error
            response = [false, "@REX33"];
            ApplicationEventSource::EventWriteRetailTransactionServiceFailure(funcName(), 'An error occured while associating the terminal to store.');
        }

        return response;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clockIn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Registers clock-in for the worker specified.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_terminalId">
    /// Terminal id, where worker makes a time registration.
    /// </param>
    /// <returns>
    /// A container having information whether registration is successful.
    /// </returns>
    /// <remarks>
    /// If time registration fails, returned container will also have error message.
    /// </remarks>
    public static container clockIn(HcmPersonnelNumberId _personnelNumber, RetailTerminalId _terminalId)
    {
        return RetailTransactionServiceEmployee::clockIn(_personnelNumber, _terminalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clockOut</Name>
				<Source><![CDATA[
    /// <summary>
    /// Registers clock-out for the worker specified.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_terminalId">
    /// Terminal id, where worker makes a time registration.
    /// </param>
    /// <returns>
    /// A container having information whether registration is successful.
    /// </returns>
    /// <remarks>
    /// If time registration fails, returned container will also have error message.
    /// </remarks>
    public static container clockOut(HcmPersonnelNumberId _personnelNumber, RetailTerminalId _terminalId)
    {
        return RetailTransactionServiceEmployee::clockOut(_personnelNumber, _terminalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertCustomerQuoteToOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a quotation to sales order.
    /// </summary>
    /// <param name="custOrderXmlStr">
    /// XML string having the header, line details and charges, payments associated with the sales order to be created.
    /// </param>
    /// <returns>
    /// A container having the status of quote conversion and salesId of the sales order.
    /// </returns>
    public static container convertCustomerQuoteToOrder(str custOrderXmlStr)
    {
        return RetailTransactionServiceOrders::convertCustomerQuoteToOrder(custOrderXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create address for customer.
    /// </summary>
    /// <param name="custAccount">
    /// Customer account
    /// </param>
    /// <param name="custName">
    /// Customer name
    /// </param>
    /// <param name="street">
    /// Street
    /// </param>
    /// <param name="city">
    /// City
    /// </param>
    /// <param name="county">
    /// County
    /// </param>
    /// <param name="state">
    /// State
    /// </param>
    /// <param name="zip">
    /// Zip
    /// </param>
    /// <param name="country">
    /// Country
    /// </param>
    /// <param name="phone">
    /// Phone
    /// </param>
    /// <param name="email">
    /// Email
    /// </param>
    /// <param name="url">
    /// URL
    /// </param>
    /// <param name="taxGroup">
    /// Tax group
    /// </param>
    /// <param name="role">
    /// Role
    /// </param>
    /// <param name="streetNumber">
    /// Street number
    /// </param>
    /// <param name="districtName">
    /// District name
    /// </param>
    /// <param name="buildingCompliment">
    /// Building compliment
    /// </param>
    /// <param name="makePostalAddressPrimary">
    /// Optional. True if this should become the new primary address
    /// </param>
    /// <returns>
    /// A container with entity keys
    /// </returns>
    /// <remarks>
    /// Original parameter list consisted of a single _paramList parameter of type container.
    /// </remarks>
    public static container createAddress(  CustAccount                 custAccount,
                                            CustName                    custName,
                                            AddressStreet               street,
                                            AddressCity                 city,
                                            AddressCountyId             county,
                                            AddressStateId              state,
                                            AddressZipCodeId            zip,
                                            AddressCountryRegionId      country,
                                            Phone                       phone,
                                            Email                       email,
                                            URL                         url,
                                            TaxGroup                    taxGroup,
                                            LogisticsLocationRoleType   role,
                                            LogisticsAddressStreetNumber        streetNumber        = '',
                                            LogisticsAddressDistrictName        districtName        = '',
                                            LogisticsAddressBuildingCompliment  buildingCompliment  = '',
                                            // preserve default previous version behaviour
                                            boolean                     makePostalAddressPrimary = false)
    {
        return RetailTransactionServiceCustomer::createAddress(
            custAccount,
            custName,
            street,
            city,
            county,
            state,
            zip,
            country,
            phone,
            email,
            url,
            taxGroup,
            role,
            streetNumber,
            districtName,
            buildingCompliment,
            makePostalAddressPrimary);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCashDisbursementSlip_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates cash disbursement slip.
    /// </summary>
    /// <param name="_storeId">
    /// Retail store ID.
    /// </param>
    /// <param name="_currencyCode">
    /// Currency code
    /// </param>
    /// <param name="_amountCur">
    /// Amount in currency
    /// </param>
    /// <param name="_transDate">
    /// Transaction date
    /// </param>
    /// <param name="_custAccount">
    /// Customer account
    /// </param>
    /// <param name="_reasonOfReturn">
    /// Reason of cash return.
    /// </param>
    /// <param name="_represPersonName">
    /// The name of the representative person.
    /// </param>
    /// <param name="_represPersonCardInfo">
    /// Representative person card info.
    /// </param>
    /// <param name="_documentNum">
    /// Document number.
    /// </param>
    /// <param name="_documentDate">
    /// Document date.
    /// </param>
    /// <returns>
    /// A <c>Container</c> holding result info.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message (optional),
    /// 3 - created disbursement slip ID.
    /// </remarks>
    [SysObsolete('Returns in next shift processing is not required in Russia any longer.', false, 13\05\2023)]
    public static container createCashDisbursementSlip_RU(
        RetailStoreId _storeId,
        CurrencyCode _currencyCode,
        AmountCur _amountCur,
        TransDate _transDate,
        CustAccount _custAccount,
        BankCentralBankPurposeText _reasonOfReturn,
        PersonName _represPersonName,
        PayeeDocument_RU _represPersonCardInfo,
        DocumentNum _documentNum,
        DocumentDate _documentDate)
    {
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a customer order from the given details.
    /// </summary>
    /// <param name="custOrderXmlStr">
    /// XML string having the header, line details and charges, payments associated with the sales order to be created.
    /// </param>
    /// <returns>
    /// A container having the status and sales id of the order created.
    /// </returns>
    public static container createCustomerOrder(str custOrderXmlStr)
    {
        return RetailTransactionServiceOrders::createCustomerOrder(CustomerOrderInfo::FromXml(custOrderXmlStr), true, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOnlineCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an online customer order from the given details.
    /// </summary>
    /// <param name="custOrderXmlStr">
    /// XML string representing the header, line details and charges, payments associated with the sales order to be created.
    /// </param>
    /// <returns>
    /// A container having the status and sales id of the order created.
    /// </returns>
    /// <remarks>
    /// This method is used to create online orders and does not rely on the order synchronizer.
    /// The order synchronizer will not create a duplicate order, instead it will mark the <c>RetailTransactionTable</c> record with the created sales id.
    /// </remarks>
    public static container createOnlineCustomerOrder(str custOrderXmlStr)
    {
        return RetailTransactionServiceOrders::createOnlineCustomerOrder(CustomerOrderInfo::FromXml(custOrderXmlStr), true, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustomerQuote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a sales quotation from the given details.
    /// </summary>
    /// <param name="custOrderXmlStr">
    /// XML string having the header, line details and charges associated with the quote to be created.
    /// </param>
    /// <returns>
    /// A container having the status and quotation id of the quotation created.
    /// </returns>
    public static container createCustomerQuote(str custOrderXmlStr)
    {
        return RetailTransactionServiceOrders::createCustomerQuote(CustomerOrderInfo::FromXml(custOrderXmlStr));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustomerReturnOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a customer return order from the given details.
    /// </summary>
    /// <param name="custOrderXmlStr">
    /// XML string having the header, line details and charges, payments associated with the retrn order to be created.
    /// </param>
    /// <returns>
    /// A container having the status and sales id of the order created.
    /// </returns>
    public static container createCustomerReturnOrder(str custOrderXmlStr)
    {
        return RetailTransactionServiceOrders::createCustomerReturnOrder(CustomerOrderInfo::FromXml(custOrderXmlStr));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDiscountLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create Retail Sales Discount Line records for the given sales line xml fragment
    /// </summary>
    /// <param name="_xml">
    /// An XmlElement for an "Item" node in a Customer Order xml document.
    /// </param>
    /// <param name="_inventTrans">
    /// Sales Line InventTrans Id for the associated Sales Line record.
    /// </param>
    /// <param name="_forQuote">
    /// True to create discount lines for a quote, false to create discount lines for a sales order.
    /// </param>
    /// <remarks>
    /// Parses and inserts Retail Sales Discount Line records for the given Item/SalesLine entity.
    /// </remarks>
    private static void createDiscountLines(XmlElement _xml, InventTransId _inventTrans, boolean _forQuote = false)
    {
        int i;
        XmlElement  xmlLineDiscounts;
        XmlElement  xmlLineDiscountRecord;
        XmlNodeList xmlLineDiscountRecordList;
        Amount discountLineAmount;
        RetailDiscountCodeId discountCodeId;
        RetailOfferIdEx3 periodicDiscountOfferId;
        RetailSalesDiscountLine salesDiscountLineTable;
        RetailSalesQuotationDiscountLine quoteDiscountLineTable;

        if (_xml != null && _inventTrans)
        {
            xmlLineDiscounts = _xml.getNamedElement(#Discounts);

            if (xmlLineDiscounts != null)
            {
                xmlLineDiscountRecordList = xmlLineDiscounts.childNodes();

                if (xmlLineDiscountRecordList)
                {
                    for (i = 0 ; i < xmlLineDiscountRecordList.length(); i++)
                    {
                        xmlLineDiscountRecord = xmlLineDiscountRecordList.item(i);

                        discountLineAmount = str2num(xmlLineDiscountRecord.getAttribute(#Amount));
                        discountCodeId = xmlLineDiscountRecord.getAttribute(#DiscountCode);
                        periodicDiscountOfferId = xmlLineDiscountRecord.getAttribute(#PeriodicDiscountOfferId);

                        if (_forQuote)
                        {
                            quoteDiscountLineTable.clear();
                            quoteDiscountLineTable.InventTransId = _inventTrans;
                            quoteDiscountLineTable.Amount = discountLineAmount;
                            quoteDiscountLineTable.DiscountCode = discountCodeId;
                            quoteDiscountLineTable.PeriodicDiscountOfferId = periodicDiscountOfferId;
                            quoteDiscountLineTable.insert();
                        }
                        else
                        {
                            salesDiscountLineTable.clear();
                            salesDiscountLineTable.InventTransId = _inventTrans;
                            salesDiscountLineTable.Amount = discountLineAmount;
                            salesDiscountLineTable.DiscountCode = discountCodeId;
                            salesDiscountLineTable.PeriodicDiscountOfferId = periodicDiscountOfferId;
                            salesDiscountLineTable.insert();
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createExtendedLogOn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a record in <c>RetailStaffExtendedLogOn</c>table.
    /// </summary>
    /// <param name="_staffId">
    /// Staff ID.
    /// </param>
    /// <param name="_logOnKey">
    /// LogOn key.
    /// </param>
    /// <param name="_logOnType">
    /// LogOn key type.
    /// </param>
    /// <param name="_extraData">
    /// Device specific extra data as base 64 string.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container createExtendedLogOn(RetailStaffId _staffId, RetailStaffExtendedLogOnKey _logOnKey, RetailStaffExtendedLogOnType _logOnType, str _extraData)
    {
        return RetailTransactionServiceEmployee::createExtendedLogOn(_staffId, _logOnKey, _logOnType, _extraData);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventoryJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an inventory journal.
    /// </summary>
    /// <param name="inventLocationId">
    /// Identification of the warehouse.
    /// </param>
    /// <param name="description">
    /// Description of the journal.
    /// </param>
    /// <param name="source">
    /// Inventory journal source.
    /// </param>
    /// <param name="userId">
    /// The user identifier (worker personnel number).
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the creation of record is successful; else false and appropriate xml string.
    /// </returns>
    public static container createInventoryJournal(InventLocationId inventLocationId, JournalDescription description = '', InventJournalSource source = '', str userId = '')
    {
        container inventJournalContainer = [false, "", ""]; // Status, ErrorMsg, XmlResultSet

        RetailParametersEx2     storeInventoryParameter;
        InventJournalId         journalId;
        InventJournalTable      inventJournalTable;
        InventLocation          inventLocation;
        JournalTableData        inventJournalTableData;
        RetailParameters        retailStoreInventoryParam;
        HcmWorker               workerTable;

        XmlDocument             xmlDoc;
        XmlElement              xmlRoot;
        str                     personnelNumber;
        RecId                   personnelRecId = 0;

        if (userId != '')
        {
            select RecId from workerTable where workerTable.PersonnelNumber == userId;

            if (workerTable)
            {
                personnelRecId = workerTable.RecId;
            }
        }

        ttsbegin;

        inventLocation = InventLocation::find(inventLocationId);
        storeInventoryParameter = RetailParametersEx2::find();
        inventJournalTableData = JournalTableData::newTable(inventJournalTable);
        journalId = inventJournalTableData.nextJournalId();
        retailStoreInventoryParam = RetailParameters::find();

        inventJournalTable.initValue();
        inventJournalTable.JournalId = journalId;
        inventJournalTable.JournalNameId = retailStoreInventoryParam.DefaultInventJournalName;
        inventJournalTableData.initFromJournalName(inventJournalTableData.journalStatic().findJournalName(inventJournalTable.JournalNameId));
        inventJournalTable.Description = description;
        inventJournalTable.Source = source;
        inventJournalTable.JournalType = InventJournalType::Count;
        inventJournalTable.InventSiteId = inventLocation.InventSiteId;
        inventJournalTable.InventLocationId = inventLocation.InventLocationId;
        inventJournalTable.Worker = personnelRecId;

        inventJournalTable.insert();

        xmlDoc = XmlDocument::newBlank();
        xmlRoot = xmlDoc.createElement(tableStr(InventJournalTable));

        xmlRoot.setAttribute(fieldStr(InventJournalTable, JournalId), inventJournalTable.JournalId);
        xmlRoot.setAttribute(fieldStr(InventJournalTable, RecId), int642str(inventJournalTable.RecId));
        xmlRoot.setAttribute(fieldStr(InventJournalTable, InventLocationId), inventJournalTable.InventLocationId);
        xmlRoot.setAttribute(fieldStr(InventJournalTable, Description), inventJournalTable.Description);
        xmlRoot.setAttribute(fieldStr(inventJournalTable, DataAreaId), inventJournalTable.DataAreaId);
        xmlRoot.setAttribute(fieldStr(HcmWorker, PersonnelNumber), workerTable ? userId : '');

        xmlDoc.appendChild(xmlRoot);
        inventJournalContainer = [true, "", xmlDoc.toString()];

        ttscommit;

        ApplicationEventSource::EventWriteRetailTransactionServiceInfoLog(funcName(), strFmt('Inventory journal %1 has been created.', inventJournalTable.JournalId));

        return inventJournalContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPackingSlip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the PackingSlip for sales order transaction.
    /// </summary>
    /// <param name="_salesId">
    /// ID of the SalesTable.SalesId field.
    /// </param>
    /// <param name="_inventLocationId">
    /// Warehouse for which to create the packing list.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the value true and empty string if the PackingSlip creation is success; else false wih the appropriate string message.
    /// </returns>
    [SysObsolete('Use method createPackingSlipFromChannel() instead', false, 13\05\2023)]
    public static container createPackingSlip(SalesId _salesId, InventLocationId _inventLocationId = '')
    {
        RetailStoreTable retailstore;
        SalesTable salesTable;

        if (!_inventLocationId)
        {
            salesTable = SalesTable::find(_salesId);
            _inventLocationId = salesTable.InventLocationId;
        }

        select firstonly retailstore where
           (retailstore.inventLocation == _inventLocationId || retailstore.InventLocationIdForCustomerOrder == _inventLocationId)
            && retailstore.inventLocationDataAreaId == curExt();

        return RetailTransactionService::createPackingSlipFromChannel(_salesId, retailstore.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPackingSlipFromChannel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the PackingSlip for sales order transaction.
    /// </summary>
    /// <param name="_salesId">
    /// ID of the SalesTable.SalesId field.
    /// </param>
    /// <param name="_retailChannelRecId">
    /// Channel for which to create the packing list.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the value true and empty string if the PackingSlip creation is success; else false wih the appropriate string message.
    /// </returns>
    public static container createPackingSlipFromChannel(SalesId _salesId, RetailChannelRecId _retailChannelRecId)
    {
        return RetailTransactionServiceOrders::createPackingSlip(_salesId, '', _retailChannelRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPickingList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the PickingList for sales order transaction.
    /// </summary>
    /// <param name="_salesId">
    /// ID of the SalesTable.SalesId field.
    /// </param>
    /// <param name="_inventLocationId">
    ///  Warehouse for which to create the picking list.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the value true and empty string if the PickingList creation is success; else false wih the appropriate string message.
    /// </returns>
    [SysObsolete('Use method createPickingListFromChannel() instead', false, 13\05\2023)]
    public static container createPickingList(SalesId _salesId, InventLocationId _inventLocationId)
    {
        RetailStoreTable retailstore;

        select firstonly retailstore where
            (retailstore.inventLocation == _inventLocationId || retailstore.InventLocationIdForCustomerOrder == _inventLocationId)
            && retailstore.inventLocationDataAreaId == curExt();

        return RetailTransactionService::createPickingListFromChannel(_salesId, retailstore.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPickingListFromChannel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the PickingList for sales order transaction.
    /// </summary>
    /// <param name="_salesId">
    /// ID of the SalesTable.SalesId field.
    /// </param>
    /// <param name="_retailChannelRecId">
    ///  Retail channel rec id.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the value true and empty string if the PickingList creation is success; else false wih the appropriate string message.
    /// </returns>
    public static container createPickingListFromChannel(SalesId _salesId, RetailChannelRecId _retailChannelRecId)
    {
        return RetailTransactionServiceOrders::createPickingList(_salesId, '', _retailChannelRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPickListForCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates picking list for the given items.
    /// </summary>
    /// <param name="paramList">
    /// XML string having the items and pickup quantity details.
    /// </param>
    /// <returns>
    /// A container having the status of Pick list creation.
    /// </returns>
    public static container createPickListForCustomerOrder(container paramList)
    {
        return RetailTransactionServiceOrders::createPickListForCustomerOrder(paramList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPickingListForOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create picking list for the selected items in order.
    /// </summary>
    /// <param name = "pickingListXmlStr">XML string having line parameters and quantity.</param>
    /// <returns>A container having the picking list id created.</returns>
    public static container createPickingListForOrder(str pickingListXmlStr)
    {
        /* Sample of xml received.
        <?xml version="1.0" encoding="utf-16"?>
        <PickAndPackOrder xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <ChannelRecordId>ChannelRecordId</ChannelRecordId>
        <SalesId>SalerOrderNumber</SalesId>
        <SalesLineParameters>
        <PickAndPackSalesLine LineNumber="1" Quantity="1" />
        </SalesLineParameters>
        </PickAndPackOrder>
        */
        return RetailTransactionServiceOrders::createPickingListForOrder(pickingListXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChannels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets all channel configurations.
    /// </summary>
    /// <returns>
    /// A container with all of the channel configurations.
    /// </returns>
    public static container getChannels()
    {
        return RetailTransactionServiceChannelManagement::getChannels();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWishList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a wish list.
    /// </summary>
    /// <param name="wishListXml">
    /// The input xml string containing the wish list field information.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the creation of record is successful and false otherwise.
    /// </returns>
    public static container createWishList(str wishListXml)
    {
        return RetailTransactionServiceWishList::createWishList(wishListXml);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWishListLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a wish list line.
    /// </summary>
    /// <param name="wishListLineXml">
    /// The input xml string containing the wish list line field information.
    /// </param>
    /// <param name="filterAccountNumber">
    /// The filter account number. It is used to check the operation privilege and filter the result content.
    /// Set the value to null to skip filtering.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the creation of record is successful and false otherwise.
    /// </returns>
    public static container createWishListLine(str wishListLineXml, AccountNum filterAccountNumber)
    {
        return RetailTransactionServiceWishList::createWishListLine(wishListLineXml, filterAccountNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deactivateAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for deactivating a record in <c>LogisticsPostalAddress</c> table.
    /// </summary>
    /// <param name="addressRecId">
    /// The LogisticsPostalAddress Record Id.
    /// </param>
    /// <param name="custTableRecId">
    /// The CUSTTABLE Record Id.
    /// </param>
    /// <returns>
    /// Success or failure result.
    /// </returns>
    /// <remarks>
    /// Updates the ValidTo date making the record no longer valid.
    /// </remarks>
    public static container deactivateAddress(RefRecId addressRecId, RefRecId custTableRecId)
    {
        return RetailTransactionServiceCustomer::deactivateAddress(addressRecId, custTableRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deactivateDevice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Activate the device.
    /// </summary>
    /// <param name="deviceId">
    /// ID of the Device.
    /// </param>
    /// <param name="terminalId">
    /// ID of the terminal.
    /// </param>
    /// <param name="staffId">
    /// ID of the staff.
    /// </param>
    /// <returns>
    /// A container object containing status of activation, error message (if any) and the details of the device - terminal, store
    /// </returns>
    /// <remarks>
    /// Validates the Device with the activation code and generates a token.
    /// </remarks>
    public static container deactivateDevice(RetailDeviceId deviceId, RetailTerminalId terminalId, RetailStaffId staffId, str deviceToken)
    {
        return RetailTransactionServiceDevice::deactivateDevice(deviceId, terminalId, staffId, deviceToken, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteExtendedLogOn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove records from <c>RetailStaffExtendedLogOn</c>table.
    /// </summary>
    /// <param name="_staffId">
    /// Staff ID.
    /// </param>
    /// <param name="_logOnType">
    /// LogOn key type.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container deleteExtendedLogOn(RetailStaffId _staffId, RetailStaffExtendedLogOnType _logOnType)
    {
        return RetailTransactionServiceEmployee::deleteExtendedLogOn(_staffId, _logOnType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteInventoryJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete a journal record from <c>InventJournalTable</c> and <c>InventJournalTrans</c> tables.
    /// </summary>
    /// <param name="_journalId">
    /// The journal ID of the journal record to be deleted.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the delete of record is successful and false otherwise.
    /// </returns>
    public static container deleteInventoryJournal(InventJournalId _journalId)
    {
        return RetailTransactionServiceInventory::deleteInventoryJournal(_journalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWishList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes a wish list.
    /// </summary>
    /// <param name="wishListId">
    /// The id of the wish list to be deleted.
    /// </param>
    /// <param name="filterAccountNumber">
    /// The filter account number. It is used to check the operation privilege and filter the result content.
    /// Set the value to null to skip filtering.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the delete of record is successful and false otherwise.
    /// </returns>
    public static container deleteWishList(RecId wishListId, AccountNum filterAccountNumber)
    {
        return RetailTransactionServiceWishList::deleteWishList(wishListId, filterAccountNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWishListLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes a wish list line.
    /// </summary>
    /// <param name="lineId">
    /// The id of the line to be deleted.
    /// </param>
    /// <param name="wishListId">
    /// The id of the list to be deleted.  This is only used if line id is 0.
    /// </param>
    /// <param name="filterAccountNumber">
    /// The filter account number. It is used to check the operation privilege and filter the result content.
    /// Set the value to null to skip filtering.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the delete of record is successful and false otherwise.
    /// </returns>
    public static container deleteWishListLine(RecId lineId, RefRecId wishListId, AccountNum filterAccountNumber)
    {
        return RetailTransactionServiceWishList::deleteWishListLine(lineId, wishListId, filterAccountNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>echoRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// An echo method that respond with a container of the first ten string parameters
    /// </summary>
    /// <param name="parameter0">
    /// Parameter 0
    /// </param>
    /// <param name="parameter1">
    /// Parameter 1
    /// </param>
    /// <param name="parameter2">
    /// Parameter 2
    /// </param>
    /// <param name="parameter3">
    /// Parameter 3
    /// </param>
    /// <param name="parameter4">
    /// Parameter 4
    /// </param>
    /// <param name="parameter5">
    /// Parameter 5
    /// </param>
    /// <param name="parameter6">
    /// Parameter 6
    /// </param>
    /// <param name="parameter7">
    /// Parameter 7
    /// </param>
    /// <param name="parameter8">
    /// Parameter 8
    /// </param>
    /// <param name="parameter9">
    /// Parameter 9
    /// </param>
    /// <returns>
    /// A container of the first 10 parameters
    /// </returns>
    /// <remarks>
    /// This method serves as a test hook.
    /// </remarks>
    public static container echoRequest(str parameter0 = #EchoDefaultValue,
                                        str parameter1 = #EchoDefaultValue,
                                        str parameter2 = #EchoDefaultValue,
                                        str parameter3 = #EchoDefaultValue,
                                        str parameter4 = #EchoDefaultValue,
                                        str parameter5 = #EchoDefaultValue,
                                        str parameter6 = #EchoDefaultValue,
                                        str parameter7 = #EchoDefaultValue,
                                        str parameter8 = #EchoDefaultValue,
                                        str parameter9 = #EchoDefaultValue)
    {
        container results = [true, 'Successful.'];
        container parameters;
        container filterContainer;
        boolean success;
        str parameter;
        int i;

        // Handle the 1st parameter (in case of a filtering criteria)
        if (parameter0 == #EchoDefaultvalue)
        {
            return results;
        }
        else
        {
            filterContainer = RetailTransactionService::parseSerializedFilteringCriteria(parameter0);
            success = conPeek(filterContainer, 1);
            if (success)
            {
                // this is a filtering criteria
                filterContainer = conDel(filterContainer, 1, 2);
                results = conIns(results, conLen(results) + 1, filterContainer);
            }
            else
            {
                // this is a normal parameter
                results += parameter0;
            }
        }

        // Append all the rest of parameters if available.
        parameters = [parameter1,
                      parameter2,
                      parameter3,
                      parameter4,
                      parameter5,
                      parameter6,
                      parameter7,
                      parameter8,
                      parameter9];

        for (i = 1; i <= conLen(parameters); i++)
        {
            parameter = conPeek(parameters, i);

            if (parameter != #EchoDefaultValue)
            {
                results += parameter;
            }
            else
            {
                break;
            }
        }

        return results;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDuplicateSalesOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method verifies whether the requested customer order details are already created or not.
    /// </summary>
    /// <param name="custOrderInfo">
    /// Customer order infocustOrderInfo.
    /// </param>
    /// <returns>
    /// Returns SalesTable reference.
    /// </returns>
    public static SalesTable findDuplicateSalesOrder(CustomerOrderInfo  custOrderInfo)
    {
        RetailSalesTable     retailSalesTable;
        SalesTable           salesTable;
        boolean              matchFound = false; //'True' if Duplicate sales order found and don't allow for new order creation again
        RefRecId             salesPersonWorkerId = HcmWorker::findByPersonnelNumber(custOrderInfo.SalespersonStaffId).RecId;
        RefRecId             retailChannelRecId = str2Int64(custOrderInfo.ChannelRecordId);

        // Checking if any duplicate/previous sales orders created already. For POS, ChannelReferenceId is the receipt ID.
        select firstonly SalesTable from retailSalesTable
        join recId, SalesId from salesTable
        order by retailSalesTable.RecId desc
        Where retailSalesTable.SalesTable == salesTable.RecId
            && salesTable.SalesId != custOrderInfo.Id
            && salesTable.CustAccount == custOrderInfo.CustomerAccount
            && salesTable.WorkerSalesResponsible == salesPersonWorkerId
            && retailSalesTable.ChannelReferenceId == custOrderInfo.ChannelReferenceId
            && retailSalesTable.RetailChannel ==  retailChannelRecId
            && retailSalesTable.RetailTerminalId == custOrderInfo.TerminalId;

        if (retailSalesTable)
        {
            //Skip line validation because the order already exists due ChannelReferenceId uniqueness when real-time sync and flight are enabled for online stores
            if (RetailParameters::find().UseRTSForOnlineOrderCreation 
                && RetailSkipSalesLineComparisonInDuplicateValidationForEComOrderFlight::instance().isEnabled()
                && (RetailChannelTable::findByRecId(retailChannelRecId).ChannelType == RetailChannelType::OnlineStore 
                || RetailChannelTable::findByRecId(retailChannelRecId).ChannelType ==  RetailChannelType::SharePointOnlineStore))
            {
                return salesTable;
            }

            //Checking for duplicate saleslines
            SalesIdBase salesId = SalesTable::findRecId(retailSalesTable.SalesTable).SalesId;
            SalesLine salesLine;
            select count(recId) from salesLine where salesLine.SalesId == salesId;

            ItemInfoCollection items = custOrderInfo.Items as ItemInfoCollection;
            //allow only if number of lines in previous attempt and current attempt are same
            if (salesLine.RecId == items.get_Count())
            {
                matchFound = true;
                int i = 0;
                while select itemId, SalesQty, RetailVariantId from salesLine
                    order by salesLine.LineNum
                    where salesLine.SalesId == salesId
                {
                    //check if item,qty,Dimensions values are matched or not
                    ItemInfo itemInfo = items.get_Item(i) as ItemInfo;
                    if (salesLine.ItemId != itemInfo.ItemId || salesLine.SalesQty != itemInfo.Quantity || salesLine.RetailVariantId != itemInfo.VariantId)
                    {
                        matchFound = false;
                        break;
                    }

                    i++;
                }
            }
        }

        if (!matchFound)
        {
            salesTable.clear();
        }

        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCalculatedBalanceMST</Name>
				<Source><![CDATA[
    public static AmountMST getCalculatedBalanceMST(CustAccount _custAccount)
    {
        AmountMST balance;

        TypeOfCreditmaxCheck creditMaxCheck = CustParameters::find().CreditMaxCheck;

        CustCreditLimit     custCL = new CustCreditLimit(CustTable::find(_custAccount));

        custCL.typeOfCreditMaxCheck(creditMaxCheck);
        // this calculates the balance as calculated by the credit check.
        balance = custCL.getBalance();

        return balance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChannelIdFromStoreId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method to retun the channelid from the storeId if the store id has a value
    /// </summary>
    /// <param name="_storeId">
    /// ID of the RetailGiftCardTable.reservedByStoreId field.
    /// </param>
    /// <param name="_channelId">
    /// ID of the RetailGiftCardTable.channel field.
    /// </param>
    /// <returns>
    /// The channel id from the store id
    /// </returns>
    /// <remarks>
    /// For 6.2 EPOS client, ChannelId is not set so we can resolve it
    /// based on the StoreId.
    /// </remarks>
    private static RetailChannelRecId getChannelIdFromStoreId(RetailStoreId _storeId, RetailChannelRecId _channelId)
    {
        RetailChannelRecId channelIdFromStoreId;

        channelIdFromStoreId = _channelId;

        if ((_storeId != '') && (_channelId == 0))
        {
            channelIdFromStoreId = RetailStoreTable::find(_storeId).RecId;
        }

        return channelIdFromStoreId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChannelSalesOrderDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get channel appropriate details for a sales order
    /// </summary>
    /// <param name="salesId">
    /// Sales Id of the sales order to retrieve
    /// </param>
    /// <param name="channelId">
    /// The channel id where the sales order originated
    /// </param>
    /// <param name="channelRefId">
    /// The channel reference id of the sales order to retrieve
    /// </param>
    /// <returns>
    /// container: [succees, errormessage, xml]
    /// </returns>
    /// <remarks>
    /// success = True if the sales order was retrieved successfully, false otherwise
    /// errormessage = empty if success == True, otherwise an error message
    /// xml = xml document describing the sales order
    /// </remarks>
    public static container getChannelSalesOrderDetail(SalesId salesId, RefRecId channelId, RetailOrderChannelReferenceId channelRefId = "")
    {
        return RetailTransactionServiceOrders::getChannelSalesOrderDetail(salesId, channelId, channelRefId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCityRecId_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets primary key value for Cities table based on natural key fields
    /// </summary>
    /// <param name="_countryRegionId">
    /// Country code
    /// </param>
    /// <param name="_stateId">
    /// State code
    /// </param>
    /// <param name="_countyId">
    /// County code
    /// </param>
    /// <param name="_cityName">
    /// City name
    /// </param>
    /// <returns>
    /// Record Id of city
    /// </returns>
    /// <remarks>
    /// City table has no natural key [country/state/county/city]
    /// Assumption that there are no two cities with same name for given combination of country/state/county was made for Russia
    /// </remarks>
    private static LogisticsAddressCityRecId getCityRecId_RU(LogisticsAddressCountryRegionId  _countryRegionId,
                                                             LogisticsAddressStateId          _stateId,
                                                             LogisticsAddressCountyId         _countyId,
                                                             LogisticsAddressCityName         _cityName)
    {
        LogisticsAddressCity city;

        if (!_cityName)
        {
            return 0;
        }

        select firstOnly RecId from city
            where city.CountryRegionId == _countryRegionId
               && city.StateId == _stateId
               && city.CountyId == _countyId
               && city.Name == _cityName;

        return city.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCreditMemo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get credit memo balance and currency code.
    /// </summary>
    /// <param name="dataEntryId">
    /// Credit memo identifier (RetailCreditVoucherTable.entryId field).
    /// </param>
    /// <returns>
    /// <c>Container</c>
    /// </returns>
    public static container getCreditMemo(RetailCreditVoucherId dataEntryId)
    {
        return RetailTransactionServiceTransactions::getCreditMemo(dataEntryId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the customer details for a given customer account.
    /// </summary>
    /// <param name="custAccount">
    /// The value of CustAccount for which customer details has to be fetched.
    /// </param>
    /// <returns>
    /// A container having the customer details in a XML string.
    /// </returns>
    public static container getCustomer(CustAccount custAccount)
    {
        return RetailTransactionServiceCustomer::getCustomer(custAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerDataPackage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the specified customer (only one of the arguments needs to be populated).
    /// </summary>
    /// <param name="_custRecId">
    /// The desired customer's recId.
    /// </param>
    /// <param name="_accountNum">
    /// The desired customer's account number.
    /// </param>
    /// <param name="_custPartyRecId">
    /// The desired customer's party recId.
    /// </param>
    /// <param name="_channelId">
    /// The channel or store requesting the customer package (the customer will be added to their address book).
    /// </param>
    /// <param name="_versionNumber">
    /// The version number to indicate which functionality is supported.
    /// Version number 1: Returns default data and data from tables <c>DirPersonName</c>, <c>RetailMediaAndMasterEntityRelation</c>, and <c>RetailMediaResource</c>.
    /// Version number 3: Returns additional data from <c>RetailCustTable</c>.
    /// </param>
    /// <returns>
    /// If a customer within the current data area is found, a serialized CDX package representing the customer. If not found, an error message.
    /// </returns>
    public static container getCustomerDataPackage(RecId _custRecId, CustAccount _accountNum, RecId _custPartyRecId, RecId _channelId, int _versionNumber = 1)
    {
        return RetailTransactionServiceCustomer::getCustomerDataPackage(_custRecId, _accountNum, _custPartyRecId, _channelId, _versionNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method will retrive the customer account balance.
    /// </summary>
    /// <param name="_accountNum">
    /// The account for which we want the balance and credit limit.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency used to return the balance in.
    /// </param>
    /// <param name="_storeId">
    /// The store id of the store where this call originates from.
    /// </param>
    /// <returns>
    /// A container that contains the account balance, account credit limit, invoice account balance, invoice account credit limit and b2b invoice balance.
    /// In addition returns the maximum counter of the payment transactions that we pulled in Ax form the store.
    /// </returns>
    /// <remarks>
    /// If the customer has also an invoice account, it will return
    /// the balance and the credit limit for that account too. If the customer
    /// has an invoice account then the open invoice balance and count for the
    /// invoice account. If the customer invoice account is not setup then the
    /// open invoice balance and count for just the customer will be populated.
    /// The counter is used in POS to help identify the local transactions
    /// that were not yet pulled in AX.
    /// </remarks>
    public static container getCustomerBalance(AccountNum _accountNum, CurrencyCode _currencyCode, RetailStoreId _storeId)
    {
        container               custBalanceResponse = [false, 0, 0, 0, 0, 0];
        AmountMST               custBalance;
        AmountMST               custCreditLimit;
        AmountMST               invBalance;
        AmountMST               invCreditLimit;
        AmountMST               openInvoiceBalance = 0;
        Counter                 openInvoiceCount = 0;
        boolean                 calculateOpenInvoiceBalance = RetailB2BEcommerceFeature::isEnabled();
        CustTable               custTable;
        CustTable               invCustTable;
        int64                   transactionMaxReplicationCounter;
        RetailTransactionPaymentTrans  retailTransactionPaymentTrans;
        CurrencyExchangeHelper exchangeHelper = CurrencyExchangeHelper::construct();
        TransDate transDate;
        RetailTransTime transTime;
        str errorMessage = '';
        boolean success = false;
        int fromLine = Global::infologLine();

        exchangeHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));

        custTable = CustTable::find(_accountNum);
        if (custTable)
        {
            try
            {
                custBalance = RetailTransactionService::getCalculatedBalanceMST(custTable.AccountNum);
                custCreditLimit = custTable.CreditMax;
                if (custTable.InvoiceAccount)
                {
                    invCustTable = CustTable::find(custTable.InvoiceAccount);

                    // Copied balance and credit limit values from existing variable for customer, if customer has same account number in custAccount and invoiceAccount.
                    if (custTable.AccountNum == invCustTable.AccountNum)
                    {
                        invBalance = custBalance;
                        invCreditLimit = custCreditLimit;
                    }
                    else
                    {
                        invBalance = RetailTransactionService::getCalculatedBalanceMST(invCustTable.AccountNum);
                        invCreditLimit = invCustTable.CreditMax;
                    }

                    if (calculateOpenInvoiceBalance)
                    {
                        [openInvoiceBalance, openInvoiceCount] = invCustTable.openSalesInvoiceBalanceMSTWithCount();
                    }
                }
                else
                {
                    invBalance = 0;
                    invCreditLimit = 0;

                    if (calculateOpenInvoiceBalance)
                    {
                        [openInvoiceBalance, openInvoiceCount] = custTable.openSalesInvoiceBalanceMSTWithCount();
                    }
                }

                if (_currencyCode != Ledger::accountingCurrency())
                {
                    custBalance = exchangeHelper.calculateAccountingToTransaction(_currencyCode, custBalance, false);
                    custCreditLimit = exchangeHelper.calculateAccountingToTransaction(_currencyCode, custCreditLimit, false);
                    invBalance = exchangeHelper.calculateAccountingToTransaction(_currencyCode, invBalance, false);
                    invCreditLimit = exchangeHelper.calculateAccountingToTransaction(_currencyCode, invCreditLimit, false);
                }

                // Determines the last uploaded transaction based on date and time
                select firstonly transdate, transTime
                    from retailTransactionPaymentTrans
                    order by transdate desc, transTime desc
                    where retailTransactionPaymentTrans.store == _storeId;

                RefRecId channel;
                boolean useChannelId = false;
                if (retailTransactionPaymentTrans.RecId == 0 && !RetailDisableGetCustomerBalanceByChannelIdFlight::instance().isEnabled())
                {
                    channel = _storeId ? any2Int64(_storeId) : 0;
                    useChannelId = true;

                    select firstonly transdate, transTime
                        from retailTransactionPaymentTrans
                        order by transdate desc, transTime desc
                        where retailTransactionPaymentTrans.Channel == channel;
                }

                // if the retailTransactionPaymentTrans is null, i.e. there exists no entry in the table for that storeId,
                // default value transDate = 1/1/1900 and transTime = 0 is returned.
                // Otherwise, the given transDate and transTime from the entry is returned.
                if (retailTransactionPaymentTrans.RecId != 0)
                {
                    transDate = retailTransactionPaymentTrans.transDate;
                    transTime = retailTransactionPaymentTrans.transTime;
                }
                else
                {
                    eventSource.EventWriteCustomerGenericMessage(classStr(RetailTransactionService), funcName(), 'There are no transactions uploaded for the given store Id.');
                }

                // Logic using ReplicationCounter kept for backward compatibility
                if (useChannelId && !RetailDisableGetCustomerBalanceByChannelIdFlight::instance().isEnabled())
                {
                    select maxof(replicationCounterFromOrigin)
                        from retailTransactionPaymentTrans
                        where retailTransactionPaymentTrans.Channel == channel;
                }
                else
                {
                    select maxof(replicationCounterFromOrigin)
                        from retailTransactionPaymentTrans
                        where retailTransactionPaymentTrans.store == _storeId;
                }

                transactionMaxReplicationCounter = retailTransactionPaymentTrans.replicationCounterFromOrigin;

                success = true;
            }
            catch (Exception::Error)
            {
                errorMessage = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                eventSource.EventWriteCustomerRTSGetCustomerBalanceError(classStr(RetailTransactionService), funcName());
                success = false;
            }
        }
        else
        {
            // Return 0 if the customer was not found to avoid displaying errors to the user.
            // Note: Async customers do not exist in HQ and thus do not have a customer balance.
            success = true;
            custBalance = 0;
            custCreditLimit = 0;
            invBalance = 0;
            invCreditLimit = 0;
            openInvoiceBalance = 0;
            openInvoiceCount = 0;
        }

        custBalanceResponse = [success, errorMessage, custBalance, custCreditLimit, invBalance, invCreditLimit, transactionMaxReplicationCounter, transDate, transTime, openInvoiceBalance, openInvoiceCount];

        return custBalanceResponse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get customer history summary and sales orders
    /// </summary>
    /// <param name="_customerId">
    /// CustAccount id for the customer
    /// </param>
    /// <param name="_historyType">
    /// How much history to return
    /// </param>
    /// <returns>
    /// XML document containing history summary and list of sales orders
    /// </returns>
    /// <remarks>
    /// Returns a summary of history activity and list of sales orders for the configured period (30, 60, 90 days)
    /// </remarks>
    public static container getCustomerHistory(CustAccount _customerId, RetailCustomerHistoryType _historyType = RetailCustomerHistoryType::Days30)
    {
        return RetailTransactionServiceOrders::getCustomerHistory(_customerId, _historyType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the customer order for the given Id.
    /// </summary>
    /// <param name="_salesId">
    /// Value of the SalesId for which order needs to be fetched.
    /// </param>
    /// <param name="includeOnlineOrders">
    /// whether or not to include online orders in the search
    /// </param>
    /// <returns>
    /// A container having the order details in a XML string.
    /// </returns>
    public static container getCustomerOrder(SalesId _salesId, boolean includeOnlineOrders = false)
    {
        return RetailTransactionServiceOrders::getCustomerOrder(_salesId, includeOnlineOrders);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerOrderList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the customer order details for the given customer.
    /// </summary>
    /// <param name="_custAccount">
    /// Customer account number.
    /// </param>
    /// <param name="_startDate">
    /// The starting date to return orders (default is DateTimeUtil::minValue).
    /// </param>
    /// <param name="_endDate">
    /// The starting date to return orders (default is today's date).
    /// </param>
    /// <param name="_resultsMaxCount">
    /// The maximum amount of rows to return (default is 100).
    /// </param>
    /// <param name="_includeQuotes">
    /// Whether or not quotes should be included in the results (default is False, quotes are not included).
    /// </param>
    /// <returns>
    /// A container having the customer order details for the given customer.
    /// </returns>
    public static container getCustomerOrderList(CustAccount _custAccount, str _startDate = "", str _endDate = "", int _resultsMaxCount = 100, boolean _includeQuotes = false)
    {
        return RetailTransactionServiceOrders::getCustomerOrderList(_custAccount, _startDate, _endDate, _resultsMaxCount, _includeQuotes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerOrdersForPackSlip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get customer orders for pack slip creation
    /// </summary>
    /// <param name="_custAccount">
    /// Customer account
    /// </param>
    /// <returns>
    /// list of customer orders
    /// </returns>
    /// <remarks>
    /// Retrieves a list of all customer orders for the given customer which are available for packslip creation.
    /// </remarks>
    public static container getCustomerOrdersForPackSlip(CustAccount _custAccount)
    {
        return RetailTransactionServiceOrders::getCustomerOrdersForPackSlip(_custAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerQuote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the quotation for the given Quotation Id.
    /// </summary>
    /// <param name="_quotationId">
    /// Value of the QuotationId for which quote needs to be fetched.
    /// </param>
    /// <returns>
    /// A container having the quote details in a XML string.
    /// </returns>
    public static container getCustomerQuote(QuotationIdBase _quotationId)
    {
        return RetailTransactionServiceOrders::getCustomerQuote(_quotationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDistrictRecId_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets record id for districts based on natural key fields
    /// </summary>
    /// <param name="_countryRegionId">
    /// Country code
    /// </param>
    /// <param name="_stateId">
    /// State code
    /// </param>
    /// <param name="_countyId">
    /// County code
    /// </param>
    /// <param name="_cityRecId">
    /// Record id of city
    /// </param>
    /// <param name="_districtName">
    /// District name
    /// </param>
    /// <returns>
    /// Record id of district
    /// </returns>
    private static LogisticsAddressDistrictRecId getDistrictRecId_RU(LogisticsAddressCountryRegionId  _countryRegionId,
                                                                     LogisticsAddressStateId          _stateId,
                                                                     LogisticsAddressCountyId         _countyId,
                                                                     LogisticsAddressCityRecId        _cityRecId,
                                                                     LogisticsAddressDistrictName     _districtName)
    {
        LogisticsAddressDistrict district;

        if (!_districtName)
        {
            return 0;
        }

        if (_cityRecId)
        {
            select RecId from district
                where district.City == _cityRecId
                   && district.Name == _districtName;
        }
        else
        {
            select RecId from district
                where district.CountryRegionId_RU == _countryRegionId
                   && district.StateId_RU == _stateId
                   && district.CountyId_RU == _countyId
                   && district.City == 0
                   && district.Name == _districtName;
        }

        return district.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEFDocumentXML_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a list of Electronic Fiscal Documents on XML format.
    /// </summary>
    /// <param name="_startDate">
    /// The start of the range date.
    /// </param>
    /// <param name="_endDate">
    /// The end of the range date.
    /// </param>
    /// <param name="_fiscalEstablishmentId">
    /// The fiscal establishment from where the fiscal documents should be retrieved from.
    /// </param>
    /// <returns>
    /// A container with a success flag, a comment string, the list of XMLs.
    /// </returns>
    public static container getEFDocumentXML_BR(
        TransDate                   _startDate,
        TransDate                   _endDate,
        FiscalEstablishmentId_BR    _fiscalEstablishmentId)
    {
        FiscalDocument_BR       fiscalDocument;
        EFDocument_BR           efDocument;
        EFDocumentXML_BR        efDocumentXML;
        container               output = [true, ''];
        CustVendAC              accountNum;
        str 2                   status;
        ;

        try
        {
            while select FiscalDocumentAccountType, FiscalDocumentAccountNum, Status from fiscalDocument
                where   fiscalDocument.FiscalEstablishment  == _fiscalEstablishmentId
                    &&  fiscalDocument.FiscalDocumentDate   >= _startDate
                    &&  fiscalDocument.FiscalDocumentDate   <= _endDate
                    &&  (   fiscalDocument.Status    == FiscalDocumentStatus_BR::Approved
                        ||  fiscalDocument.Status    == FiscalDocumentStatus_BR::Cancelled
                        ||  fiscalDocument.Status    == FiscalDocumentStatus_BR::Denied
                        ||  fiscalDocument.Status    == FiscalDocumentStatus_BR::Discarded)
            join RecId from efDocument
                where   efDocument.RefRecId         == fiscalDocument.RecId
            join Submission from efDocumentXML
                where   efDocumentXML.EFDocRefRecId == efDocument.RecId
            {
                if (strLen(efDocumentXML.Submission) > 0)
                {
                    switch (fiscalDocument.FiscalDocumentAccountType)
                    {
                        case CustVendType_BR::Customer:
                            accountNum = fiscalDocument.FiscalDocumentAccountNum;
                            break;
                        case CustVendType_BR::Vendor:
                            accountNum = fiscalDocument.FiscalDocumentAccountNum;
                            break;
                    }

                    switch (fiscalDocument.Status)
                    {
                        case FiscalDocumentStatus_BR::Approved:
                            status = '00';
                            break;

                        case FiscalDocumentStatus_BR::Cancelled:
                            status = '02';
                            break;

                        case FiscalDocumentStatus_BR::Denied:
                            status = '04';
                            break;

                        case FiscalDocumentStatus_BR::Discarded:
                            status = '05';
                            break;
                    }

                    output = conins(output, conlen(output) + 1, efDocumentXML.Submission, accountNum, status);
                }
            }
        }
        catch
        {
            ApplicationEventSource::EventWriteRetailTransactionServiceFailure(funcName(), 'An error has occcured.');
            output = [false, "@RET2382"];
        }

        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEmployeeStoresFromAddressBook</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets all accessible stores for the employee.
    /// </summary>
    /// <param name="_staffId">
    /// The employee's identifier.
    /// </param>
    /// <param name="_top">
    /// The number of store records to get.
    /// </param>
    /// <param name="_skip">
    /// The number of store records to skip.
    /// </param>
    /// <returns>
    /// The list of accessible stores by this employee.
    /// </returns>
    public static container getEmployeeStoresFromAddressBook(RetailStaffId _staffId, int64 _top = 100, int64 _skip = 0)
    {
        return RetailtransactionserviceEmployee::getEmployeeStoresFromAddressBook(_staffId, _top, _skip);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchaseHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the recent purchases for a customer.
    /// </summary>
    /// <param name="_xmlArgumentString">
    /// XML document containing the arguments for the method call.  See remarks for example.
    /// </param>
    /// <returns>
    /// Collection of recent purchases.
    /// </returns>
    /// <remarks>
    /// Argument xml example:
    ///     <Arguments>
    ///         <CustomerAccountNumber>"1234"</CustomerAccountNumber>
    ///         <LanguageId>"en-us"</LanguageId>
    ///         <PagingInfo>
    ///             <Skip>1</Skip>
    ///             <Top>100</Top>
    ///         </PagingInfo>
    ///     </Arguments>
    /// </remarks>
    public static container getPurchaseHistory(str _xmlArgumentString = '')
    {
        return RetailTransactionServiceTransactions::getPurchaseHistory(_xmlArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGiftCardBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the status of the gift card.
    /// </summary>
    /// <param name="cardNumber">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container getGiftCardBalance(RetailGiftCardId cardNumber)
    {
        return RetailTransactionServiceTransactions::getGiftCardBalance(cardNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>giftCardInquiry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method performs gift card inquiry.
    /// </summary>
    /// <param name="cardNumber">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <param name = "historyCount">Specifies how much history, if any, should be returned.  Maximum value of ten (10).</param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container giftCardInquiry(RetailGiftCardId cardNumber, int historyCount)
    {
        return RetailTransactionServiceTransactions::giftCardInquiry(cardNumber, historyCount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventDimValues</Name>
				<Source><![CDATA[
    public static void getInventDimValues(ItemId itemId, InventDim inventDim, XmlElement xmlRecord)
    {
        RetailTransactionServiceInventory::getInventDimValues(itemId, inventDim, xmlRecord);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get an inventory journal object in XML format
    /// </summary>
    /// <param name="journalId">
    /// A journalID
    /// </param>
    /// <param name="storeId">
    /// A storeId
    /// </param>
    /// <returns>
    /// A container object with the details of a journal object in XML format
    /// </returns>
    /// <remarks>
    /// Get an inventory journal document in XML format
    /// </remarks>
    public static container getInventJournal(JournalId journalId, InventLocationId storeId)
    {
        return RetailTransactionServiceInventory::getInventJournal(journalId, storeId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventJournals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a list of inventory journals for stock counting
    /// </summary>
    /// <param name="storeId">
    /// A storeId
    /// </param>
    /// <returns>
    /// A list of inventory journals for stock counting
    /// </returns>
    public static container getInventJournals(InventLocationId storeId)
    {
        return RetailTransactionServiceInventory::getInventJournals(storeId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetLoyaltyCardRewardPointsStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the reward point status of the loyalty card(s) including Issued, Used, Expired, and Active points.
    /// </summary>
    /// <param name="channelLocalDateStr">
    /// The channel local date in 213 sequence.
    /// </param>
    /// <param name="_cardNumber">
    /// The loyalty card number.
    /// </param>
    /// <param name="_excludeBlocked">
    /// The flag indicating whether to exclude the card status if the card is blocked.
    /// </param>
    /// <param name="_excludeNoTender">
    /// The flag indicating whether to exclude the card status if the card is no tender.
    /// </param>
    /// <param name="_includeRelatedCardsForContactTender">
    /// The flag indicating whether to include the status of the related cards if the given card is contact tender.
    /// </param>
    /// <param name="_includeNonRedeemablePoints">
    /// The flag indicating whether to include non-redeemable points status in the result.
    /// </param>
    /// <param name="_includeActivePointsOnly">
    /// The flag indicating whether to return only the active points; otherwise, returns the status of issued, used and expired points as well.
    /// </param>
    /// <param name="_languageId">
    /// The language ID of the reward point description.
    /// </param>
    /// <returns>
    /// The result container contains [isSuccess, Message, PointStatusXML].
    /// A sample of XML is provided in the source code.
    /// </returns>
    public static container GetLoyaltyCardRewardPointsStatus(
        str channelLocalDateStr,
        RetailLoyaltyCardNumber _cardNumber,
        boolean _excludeBlocked,
        boolean _excludeNoTender,
        boolean _includeRelatedCardsForContactTender,
        boolean _includeNonRedeemablePoints,
        boolean _includeActivePointsOnly,
        LanguageIdAll _languageId = SystemParameters::getSystemLanguageId())
    {
        return RetailTransactionServiceLoyalty::GetLoyaltyCardRewardPointsStatus(
            channelLocalDateStr,
            _cardNumber,
            _excludeBlocked,
            _excludeNoTender,
            _includeRelatedCardsForContactTender,
            _includeNonRedeemablePoints,
            _includeActivePointsOnly,
            _languageId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetLoyaltyCardRewardPointsStatusWithExpiringPoints</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the reward point status of the loyalty card(s) including Issued, Used, Expired, and Active points.
    /// </summary>
    /// <param name="channelLocalDateStr">
    /// The channel local date in 213 sequence.
    /// </param>
    /// <param name="_cardNumber">
    /// The loyalty card number.
    /// </param>
    /// <param name="_excludeBlocked">
    /// The flag indicating whether to exclude the card status if the card is blocked.
    /// </param>
    /// <param name="_excludeNoTender">
    /// The flag indicating whether to exclude the card status if the card is no tender.
    /// </param>
    /// <param name="_includeRelatedCardsForContactTender">
    /// The flag indicating whether to include the status of the related cards if the given card is contact tender.
    /// </param>
    /// <param name="_includeNonRedeemablePoints">
    /// The flag indicating whether to include non-redeemable points status in the result.
    /// </param>
    /// <param name="_includeActivePointsOnly">
    /// The flag indicating whether to return only the active points; otherwise, returns the status of issued, used and expired points as well.
    /// </param>
    /// <param name="_languageId">
    /// The language ID of the reward point description.
    /// </param>
    /// <returns>
    /// The result container contains [isSuccess, Message, PointStatusXML].
    /// A sample of XML is provided in the source code.
    /// </returns>
    public static container GetLoyaltyCardRewardPointsStatusWithExpiringPoints(
        str channelLocalDateStr,
        RetailLoyaltyCardNumber _cardNumber,
        boolean _excludeBlocked,
        boolean _excludeNoTender,
        boolean _includeRelatedCardsForContactTender,
        boolean _includeNonRedeemablePoints,
        boolean _includeActivePointsOnly,
        boolean _includeExpiringAndUnvestedPoints,
        int64 _noOfDaysToExpiry,
        LanguageIdAll _languageId = SystemParameters::getSystemLanguageId())
    {
        return RetailTransactionServiceLoyalty::GetLoyaltyCardRewardPointsStatusWithExpiringPoints(
            channelLocalDateStr,
            _cardNumber,
            _excludeBlocked,
            _excludeNoTender,
            _includeRelatedCardsForContactTender,
            _includeNonRedeemablePoints,
            _includeActivePointsOnly,
            _includeExpiringAndUnvestedPoints,
            _noOfDaysToExpiry,
            _languageId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetLoyaltyCardTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get loyalty card transaction
    /// </summary>
    /// <param name="_cardNumber">
    /// The card number.
    /// </param>
    /// <param name="_rewardPointId">
    /// The reward point Id.
    /// </param>
    /// <param name="_top">
    /// The top count, i.e. the number of transactions to get.
    /// </param>
    /// <param name="_skip">
    /// The skip number, i.e. the number of transactions to skip.
    /// </param>
    /// <param name="_calculateTotalCount">
    /// The flag indicating whether the result should contains the total number of the transactions.
    /// </param>
    /// <returns>
    /// A container having the result.
    /// </returns>
    /// <remarks>
    /// The result container contains [isSuccess, Message, xmlResultString].
    /// A sample of the result XML is provided in the source code.
    /// </remarks>
    [SysObsolete('Use method GetLoyaltyCardTransactionLines() instead', false, 13\05\2023)]
    public static container GetLoyaltyCardTransactions(
        RetailLoyaltyCardNumber _cardNumber,
        RetailLoyaltyRewardPointId _rewardPointId,
        int64 _top = 1,
        int64 _skip = 0,
        boolean _calculateTotalCount = false)
    {
        return RetailTransactionServiceLoyalty::GetLoyaltyCardTransactions(_cardNumber, _rewardPointId, _top, _skip, _calculateTotalCount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetLoyaltyCardTransactionLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get loyalty card transaction lines.
    /// </summary>
    /// <param name="_cardNumber">
    /// The card number.
    /// </param>
    /// <param name="_rewardPointId">
    /// The reward point Id.
    /// </param>
    /// <param name="_top">
    /// The top count, i.e. the number of transactions to get.
    /// </param>
    /// <param name="_skip">
    /// The skip number, i.e. the number of transactions to skip.
    /// </param>
    /// <param name="_calculateTotalCount">
    /// The flag indicating whether the result should contains the total number of the transactions.
    /// </param>
    /// <returns>
    /// A container having the result.
    /// </returns>
    /// <remarks>
    /// The result container contains [isSuccess, Message, xmlResultString].
    /// A sample of the result XML is provided in the source code.
    /// </remarks>
    public static container GetLoyaltyCardTransactionLines(
        RetailLoyaltyCardNumber _cardNumber,
        RetailLoyaltyRewardPointId _rewardPointId,
        int64 _top = 1,
        int64 _skip = 0,
        boolean _calculateTotalCount = false)
    {
        return RetailTransactionServiceLoyalty::GetLoyaltyCardTransactionLines(_cardNumber, _rewardPointId, _top, _skip, _calculateTotalCount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLoyaltyPointsStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// The function calculates the used, issued, expired points, depending on the table and baseEnum (Used; Issued; Expired).
    /// </summary>
    /// <param name="pLoyaltyCardNo">
    /// ID of the RetailLoyaltyMSRCardTable.cardNumber field.
    /// </param>
    /// <returns>
    /// <c>Container</c> having calculated points.
    /// </returns>
    public static container getLoyaltyPointsStatus(RetailCardNumber    pLoyaltyCardNo)
    {
        return RetailLoyaltyManager::getLoyaltyPointStatus62(pLoyaltyCardNo);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetLoyaltyRewardPointsExpiringInNDays</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get loyalty card reward points expiring in next 'N' days (date and points expiring on that date).
    /// </summary>
    /// <param name="_channelLocalDateStr">
    /// The channel local date in 213 sequence.
    /// </param>
    /// <param name="_cardNumber">
    /// The card number.
    /// </param>
    /// <param name="_rewardPointId">
    /// The reward point Id.
    /// </param>
    /// <param name="_numberOfDays">
    /// The number of days until points are going to expire.
    /// </param>
    /// <param name="_calculateAggregatedPoints">
    /// The flag indicating whether the result should contains the aggregated points.
    /// </param>
    /// <param name="_top">
    /// The top count, i.e. the number of transactions to get.
    /// </param>
    /// <param name="_skip">
    /// The skip number, i.e. the number of transactions to skip.
    /// </param>
    /// <returns>
    /// A container having the result.
    /// </returns>
    /// <remarks>
    /// The result container contains [isSuccess, Message, xmlResultString].
    /// A sample of the result XML is provided in the source code.
    /// </remarks>
    public static container GetLoyaltyRewardPointsExpiringInNDays(
        str _channelLocalDateStr,
        RetailLoyaltyCardNumber _cardNumber,
        RetailLoyaltyRewardPointId _rewardPointId,
        int64 _noOfDaysToExpiry,
        boolean _calculateAggregatedPoints = false,
        int64 _top = 1,
        int64 _skip = 0)
    {
        return RetailTransactionServiceLoyalty::GetLoyaltyRewardPointsExpiringInNDays(_channelLocalDateStr, _cardNumber, _rewardPointId, _noOfDaysToExpiry, _calculateAggregatedPoints, _top, _skip);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetLoyaltyRewardPointActivityTimeline</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get loyalty card reward points activity timeline activities (activity date, activity entry type, and reward point amount qty for each activity).
    /// </summary>
    /// <param name="_channelLocalDateStr">
    /// The channel local date in 213 sequence.
    /// </param>
    /// <param name="_cardNumber">
    /// The card number.
    /// </param>
    /// <param name="_rewardPointId">
    /// The reward point Id.
    /// </param>
    /// <param name="_numberOfDays">
    /// The number of days until points are going to expire.
    /// </param>
    /// <param name="_top">
    /// The top count, i.e. the number of transactions to get.
    /// </param>
    /// <param name="_skip">
    /// The skip number, i.e. the number of transactions to skip.
    /// </param>
    /// <returns>
    /// A container having the result.
    /// </returns>
    /// <remarks>
    /// The result container contains [isSuccess, Message, xmlResultString].
    /// A sample of the result XML is provided in the source code.
    /// </remarks>
    public static container GetLoyaltyRewardPointActivityTimeline(
        str _channelLocalDateStr,
        RetailLoyaltyCardNumber _cardNumber,
        RetailLoyaltyRewardPointId _rewardPointId,
        int64 _top = 1,
        int64 _skip = 0)
    {
        return RetailTransactionServiceLoyalty::GetLoyaltyRewardPointActivityTimeline(_channelLocalDateStr, _cardNumber, _rewardPointId, _top, _skip);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetLoyaltyRewardPointActivityTimelineForExpiredPoints</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get loyalty card reward points activity timeline activities (activity date, activity entry type, and reward point amount qty for each activity).
    /// </summary>
    /// <param name="_channelLocalDateStr">
    /// The channel local date in 213 sequence.
    /// </param>
    /// <param name="_cardNumber">
    /// The card number.
    /// </param>
    /// <param name="_rewardPointId">
    /// The reward point Id.
    /// </param>
    /// <param name="_numberOfDays">
    /// The number of days until points are going to expire.
    /// </param>
    /// <param name="_top">
    /// The top count, i.e. the number of transactions to get.
    /// </param>
    /// <param name="_skip">
    /// The skip number, i.e. the number of transactions to skip.
    /// </param>
    /// <returns>
    /// A container having the result.
    /// </returns>
    /// <remarks>
    /// The result container contains [isSuccess, Message, xmlResultString].
    /// A sample of the result XML is provided in the source code.
    /// </remarks>
    public static container GetLoyaltyRewardPointActivityTimelineForExpiredPoints(
        str _channelLocalDateStr,
        RetailLoyaltyCardNumber _cardNumber,
        RetailLoyaltyRewardPointId _rewardPointId,
        int64 _top = 1,
        int64 _skip = 0)
    {
        return RetailTransactionServiceLoyalty::GetLoyaltyRewardPointActivityTimelineForExpiredPoints(_channelLocalDateStr, _cardNumber, _rewardPointId, _top, _skip);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getManagerHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a logbook of time registrations for the manager.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_storeIds">
    /// Ids of stores, where time registration can be viewed (comma separated value CSV of store IDs).
    /// </param>
    /// <param name="_regTypesStr">
    /// The type of time registration (comma separated value CSV of filters - up to 10 len).
    /// </param>
    /// <param name="_fromDate">
    /// Lower bound of the history returned.
    /// </param>
    /// <param name="_toDate">
    /// Upper bound of the history returned.
    /// </param>
    /// <param name="_jobId">
    /// Job Id of the specific break.
    /// </param>
    /// <returns>
    /// A container having history of time registrations.
    /// </returns>
    /// <remarks>
    /// _jobId parameter is used only if _regType == JmgTermRegType::BrkFlowStart, otherwise it will be skipped
    ///  if _regType == JmgTermRegType::BrkFlowStart and _jobId param is empty or not set, the method will return all the records with break activity disregarding the kind of break.
    /// </remarks>
    public static container getManagerHistory(HcmPersonnelNumberId _personnelNumber = '',
                str _storeIds = '',
                str _regTypesStr = '',
                utcDateTime _fromDate = DateTimeUtil::newDateTime(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), 0), // start of the current day
                utcDateTime _toDate = DateTimeUtil::addHours(DateTimeUtil::newDateTime(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), 0), 24), // end of the current day
                JmgJobId _jobId = '')
    {
        return RetailTransactionServiceEmployee::getManagerHistory(_personnelNumber,
                _storeIds,
                _regTypesStr,
                _fromDate,  // start of the current day
                _toDate,    // end of the current day
                _jobId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getManagerHistoryUtc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a logbook of time registrations for the manager in UTC time zone.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_storeIds">
    /// Ids of stores, where time registration can be viewed (comma separated value CSV of store IDs).
    /// </param>
    /// <param name="_regTypesStr">
    /// The type of time registration (comma separated value CSV of filters - up to 10 len).
    /// </param>
    /// <param name="_fromDate">
    /// Lower bound of the history returned.
    /// </param>
    /// <param name="_toDate">
    /// Upper bound of the history returned.
    /// </param>
    /// <param name="_jobIds">
    /// Job Ids of the break activities (comma separated value CSV of store IDs).
    /// </param>
    /// <param name="_top">
    /// The top count, i.e. the number of employee activities to get.
    /// </param>
    /// <param name="_skip">
    /// The skip number, i.e. the number of employee activities to skip.
    /// </param>
    /// <param name="_orderByField">
    /// The order by field name.
    /// </param>
    /// <param name="_sortOrder">
    /// The sort order.
    /// </param>
    /// <returns>
    /// A container having history of time registrations.
    /// </returns>
    /// <remarks>
    /// _jobId parameter is used only if _regType == JmgTermRegType::BrkFlowStart, otherwise it will be skipped
    ///  if _regType == JmgTermRegType::BrkFlowStart and _jobId param is empty or not set, the method will return all the records with break activity disregarding the kind of break
    /// </remarks>
    public static container getManagerHistoryUtc(HcmPersonnelNumberId _personnelNumber = '',
                str _storeIds = '',
                str _regTypesStr = '',
                utcdatetime _fromDate = DateTimeUtil::newDateTime(DateTimeUtil::date(DateTimeUtil::getSystemDateTime()), 0), // start of the current date and time (UTC time zone)
                utcdatetime _toDate = DateTimeUtil::addHours(DateTimeUtil::newDateTime(DateTimeUtil::date(DateTimeUtil::getSystemDateTime()), 0), 24), // end of the current date and time (UTC time zone)
                str _jobIds = '',
                int64 _top = 100,
                int64 _skip = 0,
                str _orderByField = fieldStr(JmgTermReg, RegDateTime),
                SortOrder _sortOrder = SortOrder::Descending)
    {
        return RetailTransactionServiceEmployee::getManagerHistoryUtc(_personnelNumber,
                _storeIds,
                _regTypesStr,
                _fromDate, // start of the current day
                _toDate, // end of the current day
                _jobIds,
                _top,
                _skip,
                _orderByField,
                _sortOrder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNotifications</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a list of notifications for subscribed operations.
    /// </summary>
    /// <param name="notificationSubscriptionJsonStr">
    /// The JSON string representation of NotificationSubscription.
    /// </param>
    /// <returns>
    /// A list of notifications in JSON format in a container object.
    /// </returns>
    public static server container getNotifications(str _notificationSubscriptionJsonStr)
    {
        return RetailTransactionServiceNotification::getNotifications(_notificationSubscriptionJsonStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOpenPurchaseOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a list of open purchase orders for a location
    /// </summary>
    /// <param name="locationId">
    /// A locationId
    /// </param>
    /// <returns>
    /// A list of purchase orders in XML format in a container object
    /// </returns>
    public static container getOpenPurchaseOrders(InventLocationId locationId)
    {
        return RetailTransactionServiceInventory::getOpenPurchaseOrders(locationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOpenTransferOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a list of open transfer orders for a store
    /// </summary>
    /// <param name="inventLocationId">
    /// A inventLocationId
    /// </param>
    /// <returns>
    /// A list of open transfer orders for a store
    /// </returns>
    /// <remarks>
    /// This is to get open transfer orders
    /// </remarks>
    public static container getOpenTransferOrders(InventLocationId inventLocationId)
    {
        return RetailTransactionServiceInventory::getOpenTransferOrders(inventLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventoryInboundOutboundDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a specific inventory document by the given search criteria.
    /// </summary>
    /// <param name = "_searchCriteriaJson">The search criteria in json format.</param>
    /// <returns>An inventory inbound/outbound document.</returns>
    public static container getInventoryInboundOutboundDocument(str _searchCriteriaJson)
    {
        return RetailTransactionServiceInventory::getInventoryInboundOutboundDocument(_searchCriteriaJson);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventoryInboundDocuments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of inbound inventory documents by the given search criteria.
    /// </summary>
    /// <param name = "_searchCriteriaJson">The search criteria in json format.</param>
    /// <returns>A list of inbound inventory documents.</returns>
    public static container getInventoryInboundDocuments(str _searchCriteriaJson)
    {
        return RetailTransactionServiceInventory::getInventoryInboundDocuments(_searchCriteriaJson);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventoryOutboundDocuments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of outbound inventory documents by the given search criteria.
    /// </summary>
    /// <param name = "_searchCriteriaJson">The search criteria in json format.</param>
    /// <returns>A list of outbound inventory documents.</returns>
    public static container getInventoryOutboundDocuments(str _searchCriteriaJson)
    {
        return RetailTransactionServiceInventory::getInventoryOutboundDocuments(_searchCriteriaJson);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventoryInboundOutboundDocumentLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of inbound inventory document lines by the given search criteria.
    /// </summary>
    /// <param name = "_searchCriteriaJson">The search criteria in json format.</param>
    /// <returns>A list of inbound inventory document lines.</returns>
    public static container getInventoryInboundOutboundDocumentLines(str _searchCriteriaJson)
    {
        return RetailTransactionServiceInventory::getInventoryInboundOutboundDocumentLines(_searchCriteriaJson);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPackingSlips</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the list of Packingslip journals for the given location.
    /// </summary>
    /// <param name="_storeId">
    /// Unique identification value of the Inventory location.
    /// </param>
    /// <returns>
    /// A container having the packing slip details in XML string.
    /// </returns>
    public static container getPackingSlips(InventLocationId _storeId)
    {
        return RetailTransactionServiceOrders::getPackingSlips(_storeId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPartyDataPackage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the specified party.
    /// </summary>
    /// <param name="_partyNum">
    /// The desired party's party number.
    /// </param>
    /// <param name="_channelId">
    /// The channel or store requesting the data package.
    /// </param>
    /// <returns>
    /// If a party is found, a serialized CDX package representing it. If not, an error message.
    /// </returns>
    public static container getPartyDataPackage(PartyNumber _partyNum, RecId _channelId)
    {
        return RetailTransactionServiceCustomer::getPartyDataPackage(_partyNum, _channelId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPickingList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the details of a picking list
    /// </summary>
    /// <param name="pickingId">
    /// A pickingId
    /// </param>
    /// <param name="_inventLocationId">
    /// A inventLocationId
    /// </param>
    /// <returns>
    /// A container object containing the details of a picking list
    /// </returns>
    /// <remarks>
    /// The picking list status is still atctive
    /// </remarks>
    public static container getPickingList(WMSPickingRouteID pickingId, InventLocationId _inventLocationId)
    {
        return RetailTransactionServiceOrders::getPickingList(pickingId, _inventLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPickingLists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a list of picking lists for a store
    /// </summary>
    /// <param name="inventLocationId">
    /// A inventLocationId
    /// </param>
    /// <returns>
    /// A container object containing a list of picking list in XML format
    /// </returns>
    /// <remarks>
    /// These picking lists are for a specific store
    /// </remarks>
    public static container getPickingLists(InventLocationId inventLocationId)
    {
        return RetailTransactionServiceOrders::getPickingLists(inventLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPickingListsForOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get all the open picking lists for the order.
    /// </summary>
    /// <param name = "_salesId">The sales order identifier.</param>
    /// <returns>The picking lists for the specified order.</returns>
    public static container getPickingListsForOrder(SalesId _salesId)
    {
        return RetailTransactionServiceOrders::GetPickingListsForOrder(_salesId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the product details based on item ID range or product ID range.
    /// </summary>
    /// <param name="_rangeValue">
    /// The range value of the search critieria field for which product details need to be fetched.
    /// </param>
    /// <param name="_includeDataSourceMap">
    /// Whether to include the mapping from data source names to table names.
    /// </param>
    /// <param name="_rangeFieldName">
    /// The search critieria field name.
    /// </param>
    /// <returns>
    /// A container having the product details in a XML string.
    /// </returns>
    public static container getProductData(str _rangeValue, boolean _includeDataSourceMap = false, str _rangeFieldName = 'ItemId')
    {
        return RetailTransactionServiceProduct::getProductData(_rangeValue, _includeDataSourceMap, _rangeFieldName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompressedProductData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the product details based on item ID range or product ID range.
    /// </summary>
    /// <param name="_rangeValue">
    /// The range value of the search critieria field for which product details need to be fetched.
    /// </param>
    /// <param name="_includeDataSourceMap">
    /// Whether to include the mapping from data source names to table names.
    /// </param>
    /// <param name="_rangeFieldName">
    /// The search critieria field name.
    /// </param>
    /// <returns>
    /// A container having the product details in a compressed XML string.
    /// </returns>
    public static container getCompressedProductData(str _rangeValue, boolean _includeDataSourceMap = false, str _rangeFieldName = 'ItemId')
    {
        using (RetailTransactionServiceProductContext context = RetailTransactionServiceProductContext::construct())
        {
            context.parmShouldCompressProductData(true);
            return RetailTransactionServiceProduct::getProductData(_rangeValue, _includeDataSourceMap, _rangeFieldName);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductsByCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the products by category.
    /// </summary>
    /// <param name="_currentChannelRecId">
    /// The record ID of current channel.
    /// </param>
    /// <param name="_categoryRecId">
    /// The record id of current category.
    /// </param>
    /// <param name="_startPosition">
    /// The starting record position.
    /// </param>
    /// <param name="_pageSize">
    /// The page size.
    /// </param>
    /// <param name="_orderByField">
    /// The order by field name.
    /// </param>
    /// <param name="_sortOrder">
    /// The sort order.
    /// </param>
    /// <param name="_includeTotalCount">
    /// Whether to include total number of records in the return value.
    /// </param>
    /// <param name="_languageId">
    /// The language to search in.
    /// </param>
    /// <param name="_otherChannelRecId">
    /// The record if for other store to search in.
    /// </param>
    /// <param name="_catalogRecId">
    /// The record ID of the catalog to search products from.
    /// </param>
    /// <param name="_attributeRecIdRangeValue">
    /// The attribute record ID range value to filter product attribute values by.
    /// </param>
    /// <param name="_includePrice">
    /// Whether to include product prices in the return value.
    /// </param>
    /// <param name="_includeProductsInDescendantCategories">
    /// Whether to include products in descendant categories.
    /// </param>
    /// <returns>
    /// A container having the products in a XML string.
    /// </returns>
    public static container getProductsByCategory(
            RetailChannelRecId  _currentChannelRecId,
            RefRecId            _categoryRecId,
            int64               _startPosition,
            int64               _pageSize,
            str                 _orderByField = 'ItemId',
            SortOrder           _sortOrder = SortOrder::Ascending,
            boolean             _includeTotalCount = false,
            str                 _languageId = '',
            RetailChannelRecId  _otherChannelRecId = 0,
            CatalogRefRecId     _catalogRecId = 0,
            str                 _attributeRecIdRangeValue = '',
            boolean             _includePrice = true,
            boolean             _includeProductsInDescendantCategories = false)
    {
        return RetailTransactionServiceProduct::getProductsByCategory(
            _currentChannelRecId,
            _categoryRecId,
            _startPosition,
            _pageSize,
            _orderByField,
            _sortOrder,
            _includeTotalCount,
            _languageId,
            _otherChannelRecId,
            _catalogRecId,
            _attributeRecIdRangeValue,
            _includePrice,
            _includeProductsInDescendantCategories
        );
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductsByKeyword</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the products by keyword search.
    /// </summary>
    /// <param name="_currentChannelRecId">
    /// The record ID of current channel.
    /// </param>
    /// <param name="_keyword">
    /// The keyword to search for.
    /// </param>
    /// <param name="_startPosition">
    /// The starting record position.
    /// </param>
    /// <param name="_pageSize">
    /// The page size.
    /// </param>
    /// <param name="_orderByField">
    /// The order by field name.
    /// </param>
    /// <param name="_sortOrder">
    /// The sort order.
    /// </param>
    /// <param name="_includeTotalCount">
    /// Whether to include total number of records in the return value.
    /// </param>
    /// <param name="_languageId">
    /// The language to search in.
    /// </param>
    /// <param name="_otherChannelRecId">
    /// The record ID of other channel.
    /// </param>
    /// <param name="_catalogRecId">
    /// The record ID of the catalog to search products from.
    /// </param>
    /// <param name="_attributeRecIdRangeValue">
    /// The attribute record ID range value to filter product attribute values by.
    /// </param>
    /// <returns>
    /// A container having the products in a XML string.
    /// </returns>
    public static container getProductsByKeyword(
        RetailChannelRecId _currentChannelRecId,
        str _keyword,
        int64 _startPosition,
        int64 _pageSize,
        str _orderByField = 'ItemId',
        SortOrder _sortOrder = SortOrder::Ascending,
        boolean _includeTotalCount = false,
        str _languageId = '',
        RetailChannelRecId _otherChannelRecId = 0,
        CatalogRefRecId _catalogRecId = 0,
        str _attributeRecIdRangeValue = '')
    {
        boolean includePrice = !RetailProductSkipPriceCalculationInGetProductsByKeywordFlight::instance().isEnabled();

        return RetailTransactionServiceProduct::getProductsByKeyword(
            _currentChannelRecId,
            _keyword,
            _startPosition,
            _pageSize,
            _orderByField,
            _sortOrder,
            _includeTotalCount,
            _languageId,
            _otherChannelRecId,
            _catalogRecId,
            _attributeRecIdRangeValue,
            includePrice
        );
    }

]]></Source>
			</Method>
			<Method>
				<Name>countProductVariants</Name>
				<Source><![CDATA[
    /// <summary>
    /// Count the variants of the products based on product IDs range.
    /// </summary>
    /// <param name = "productIds">
    /// The range value of product identifiers that are being counted, separated by comma.
    /// For example, a valid value could be "22565423130,22565423125,22565423120".
    /// </param>
    /// <returns>
    /// A container containing an array of product variants count in XML format.
    /// </returns>
    public static container countProductVariants(str productIds)
    {
        return RetailTransactionServiceProduct::countProductVariants(productIds);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchaseOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the details of a purchase order
    /// </summary>
    /// <param name="purchId">
    /// A purchId
    /// </param>
    /// <param name="inventLocationId">
    /// A inventLocationId
    /// </param>
    /// <returns>
    /// A container object containing the details of a purchase order in XML format
    /// </returns>
    /// <remarks>
    /// This is get an open purchase order
    /// </remarks>
    public static container getPurchaseOrder(PurchId purchId, InventLocationId inventLocationId = '')
    {
        return RetailTransactionServiceInventory::getPurchaseOrder(purchId, inventLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReturnLocationByInfocode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds return policy and new location for print labels
    /// </summary>
    /// <param name="_returnLocationPrintParameterXmlStr">
    /// XML string of serialized  LSRetailPosis.BusinessLogic.ReturnLocationPrintParameter object
    /// </param>
    /// <returns>
    /// Container with "Status", "ErrorMsg", "print return label" flag and "return location text"
    /// </returns>
    public static container getReturnLocationByInfocode(str _returnLocationPrintParameterXmlStr)
    {
        return RetailTransactionServiceInventory::getReturnLocationByInfocode(_returnLocationPrintParameterXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReturnLocationByReasonCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds return policy and new location for print labels
    /// </summary>
    /// <param name="_storeId">
    /// Transaction store id
    /// </param>
    /// <param name="_itemId">
    /// Product id
    /// </param>
    /// <param name="_reasonCodeId">
    /// Return reason code id
    /// </param>
    /// <returns>
    /// Container with "Status", "ErrorMsg", "print return label" flag and "return location text"
    /// </returns>
    public static container getReturnLocationByReasonCode(RetailStoreId _storeId, ItemId _itemId, ReturnReasonCodeId _reasonCodeId)
    {
        return RetailTransactionServiceInventory::getReturnLocationByReasonCode(_storeId, _itemId, _reasonCodeId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReturnReasonCodes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the reason codes.
    /// </summary>
    /// <returns>
    /// A container having the quote details in a XML string.
    /// </returns>
    public static container getReturnReasonCodes()
    {
        return RetailTransactionServiceOrders::getReturnReasonCodes();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the container <c>salesInvoice</c> having the data of the <c>CustTrans</c> and <c>CustTable</c>.
    /// </summary>
    /// <param name="_invoiceId">
    /// ID of the CustTrans.Invoice field.
    /// </param>
    /// <returns>
    /// Container <c>salesInvoice</c> having the data of the <c>CustTrans</c> and <c>CustTable</c>.
    /// </returns>
    public static container getSalesInvoice(InvoiceId _invoiceId)
    {
        return RetailTransactionServiceInvoices::getSalesInvoice(_invoiceId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesInvoiceDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the details of a sales invoice
    /// </summary>
    /// <param name="invoiceId">
    /// An invoiceId
    /// </param>
    /// <returns>
    /// A container object containing the details of a sales invoice in XML format
    /// </returns>
    /// <remarks>
    /// This is to get a sales invoice
    /// </remarks>
    public static container getSalesInvoiceDetail(InvoiceId invoiceId)
    {
        return RetailTransactionServiceOrders::getSalesInvoiceDetail(invoiceId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get list of invoice lines.
    /// </summary>
    /// <param name = "_xmlCriteriaRequest">The criteria request.</param>
    /// <returns>The list of invoice lines.</returns>
    public static container getInvoiceLines(str _xmlCriteriaRequest)
    {
        return RetailTransactionServiceOrders::getInvoiceLines(_xmlCriteriaRequest);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceLinesForReturn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the invoice lines for return.
    /// </summary>
    /// <param name = "_xmlCriteriaRequest">The criteria request.</param>
    /// <returns>The list of invoice lines and a consolidated header.</returns>
    public static container getInvoiceLinesForReturn(str _xmlCriteriaRequest)
    {
        return RetailTransactionServiceOrders::getInvoiceLinesForReturn(_xmlCriteriaRequest);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesInvoiceList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method loops the <c>CustTrans</c> table to get the list of the sales invoices.
    /// </summary>
    /// <param name="_custAccount">
    /// ID of the CustTrans.AccountNum field.
    /// </param>
    /// <returns>
    /// Container <c>salesInvoice</c> having the data of the <c>CustTrans</c> and <c>CustTable</c>.
    /// </returns>
    /// <remarks>
    /// RetailTransactionService::getSalesInvoice method returns the container <c>salesInvoice</c> having the data of the <c>CustTrans</c> and
    /// <c>CustTable</c>.
    /// </remarks>
    public static container getSalesInvoiceList(CustAccount _custAccount)
    {
        return RetailTransactionServiceInvoices::getSalesInvoiceList(_custAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the invoices based on a certain criteria.
    /// </summary>
    /// <param name = "_invoiceSearchCriteria">The invoice criteria.</param>
    /// <returns>The container data of the <c>CustTrans</c> and <c>CustTable</c>.</returns>
    public static container getInvoiceList(str _invoiceSearchCriteria)
    {
        return RetailTransactionServiceInvoices::getInvoiceList(_invoiceSearchCriteria);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesInvoicesBySalesId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a list of sales invoices for a sales order
    /// </summary>
    /// <param name="_salesId">
    /// A salesId
    /// </param>
    /// <returns>
    /// A container object containing the list of sales invoices in XML format
    /// </returns>
    /// <remarks>
    /// This is to get a list of sales invoices
    /// </remarks>
    public static container getSalesInvoicesBySalesId(SalesId _salesId)
    {
        return RetailTransactionServiceOrders::getSalesInvoicesBySalesId(_salesId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the container <c>salesOrder</c> having the data of the <c>SalesTable</c> and <c>CustTable</c>.
    /// </summary>
    /// <param name="_salesId">
    /// ID of the SalesTable.SalesId field.
    /// </param>
    /// <returns>
    /// Container <c>salesOrder</c> having the data of the <c>SalesTable</c> and <c>CustTable</c>.
    /// </returns>
    public static container getSalesOrder(SalesId _salesId)
    {
        SalesTable          salesTable;
        CustTable           custTable;
        container           salesOrder = [false,"","","","","","","","", "", "", 0, true, "", 0];
        SalesTotals         salesTotals;
        AmountCur           totalDepositsMade, totalAmount, totalTaxAmount, totalDiscountAmount, totalChargeAmount;
        RetailSalesTable                rsoTable;
        RetailTransactionOrderStatus    rtosTable;

        QueryRun queryRun = new QueryRun(RetailTransactionService::buildSalesOrderQuery(_salesId));
        queryRun.next();

        salesTable = queryRun.get(tableNum(SalesTable));
        rsoTable   = queryRun.get(tableNum(RetailSalesTable));
        rtosTable  = queryRun.get(tableNum(RetailTransactionOrderStatus));

        if (salesTable)
        {
            custTable       = CustTable::find(salesTable.CustAccount);

            salesTotals     = SalesTotals::construct(salesTable,SalesUpdate::All);
            salesTotals.calc();
            // totalAmount is the sales order balance due amount + previously invoiced amounts
            totalAmount     = salesTotals.totalAmount() + salesTable.amountInvoiced();
            totalTaxAmount  = salesTotals.totalTaxAmount();
            totalDiscountAmount = salesTotals.totalLineDisc();
            totalChargeAmount = salesTotals.totalMarkup();
        }

        // total invoice amounts paid
        totalDepositsMade = RetailTransactionPaymentsHelper::paymentsMade(_salesId);

        salesOrder = [true,                                                                         //0-result
                        "",                                                                           //1-comment
                        salesTable        ? salesTable.SalesId                                : "",   //2-SalesId
                        0,                                                                            //3-not used
                        salesTable        ? totalDepositsMade                                 : 0,    //4-Total deposits made to this sales order
                        salesTable        ? totalAmount                                       : 0,    //5-Total sales order amount
                        salesTable        ? salesTable.CustAccount                            : "",   //6-Customer Id on sales order
                        custTable         ? custTable.name()                                  : "",   //7-Customer name on sales order
                        salesTable        ? DateTimeUtil::toStr(salesTable.CreatedDateTime)   : "",   //8-Date of sales order creation
                        enum2str(salesTable.SalesType),                                               //9-sales type label
                        enum2str(salesTable.SalesStatus),                                             //10-sales status label
                        enum2int(salesTable ? salesTable.DocumentStatus : DocumentStatus::None),      //11-doc status
                        true,                                                                         //12-true = sales order (false = quotation)
                        salesTable        ? salesTable.DlvMode                                : "",   //13-Delivery mode
                        enum2int(salesTable ? salesTable.SalesStatus : SalesStatus::None),            //14-sales status
                        salesTable        ? totalTaxAmount                                    : 0,    //15-TaxAmount
                        salesTable        ? totalDiscountAmount                               : 0,    //16-DiscountAmount
                        salesTable        ? totalChargeAmount                                 : 0,    //17-ChargeAmount
                        salesTable        ? salesTable.InventLocationId                       : "",   //18-LocationId
                        salesTable        ? salesTable.InventSiteId                           : "",   //19-SiteId
                        rsoTable          ? rsoTable.ChannelReferenceId                       : "",   //20-Channel Ref Id.
                        rtosTable         ? rtosTable.TransactionId                           : "",   //21-TransactionId
                        salesTable        ? salesTable.Email                                  : "",   //22-Email
                        rsoTable          ? int642str(rsoTable.RetailChannel)                 : "0",  //23-Channel Identifier.
                        salesTable        ? int642str(salesTable.RecId)                       : "0"   //24-SalesTable Rec Identifier.
                     ];

        return salesOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSalesOrderQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a <c>Query</c> object that is used for querying the list of
    /// sales orders from <c>SalesTable</c> using specified filter conditions.
    /// </summary>
    /// <param name = "_salesId">
    /// The sales order Id.
    /// </param>
    /// <returns>
    /// The <c>Query</c> object created for querying the list of sales orders using specified filter conditions.
    /// </returns>
    protected static Query buildSalesOrderQuery(SalesId _salesId)
    {
        Query salesOrderQuery = new Query();

        QueryBuildDataSource salesTableQueryBuildDS = salesOrderQuery.addDataSource(tableNum(SalesTable));

        salesTableQueryBuildDS.addRange(fieldNum(SalesTable, SalesId)).value(queryvalue(_salesId));
        salesTableQueryBuildDS.addRange(fieldNum(SalesTable, SalesType)).value(queryvalue(SalesType::Sales));
        salesTableQueryBuildDS.addRange(fieldNum(SalesTable, SalesStatus)).value(queryValue(enum2int(SalesStatus::None)));
        salesTableQueryBuildDS.addRange(fieldNum(SalesTable, SalesStatus)).value(queryValue(enum2int(SalesStatus::Backorder)));
        salesTableQueryBuildDS.addRange(fieldNum(SalesTable, SalesStatus)).value(queryValue(enum2int(SalesStatus::Delivered)));
        salesTableQueryBuildDS.addRange(fieldNum(SalesTable, SalesStatus)).value(queryValue(enum2int(SalesStatus::Invoiced)));

        QueryBuildDataSource retailSalesTableQueryBuildDS = salesTableQueryBuildDS.addDataSource(tableNum(RetailSalesTable));
        retailSalesTableQueryBuildDS.addSelectionField(fieldnum(RetailSalesTable, ChannelReferenceId));
        retailSalesTableQueryBuildDS.addSelectionField(fieldnum(RetailSalesTable, RetailChannel));
        retailSalesTableQueryBuildDS.joinMode(JoinMode::OuterJoin);
        retailSalesTableQueryBuildDS.relations(true);

        QueryBuildDataSource RetailTransactionOrderStatusQueryBuildDS = salesTableQueryBuildDS.addDataSource(tableNum(RetailTransactionOrderStatus));
        RetailTransactionOrderStatusQueryBuildDS.addSelectionField(fieldnum(RetailTransactionOrderStatus, TransactionID));
        RetailTransactionOrderStatusQueryBuildDS.joinMode(JoinMode::OuterJoin);
        RetailTransactionOrderStatusQueryBuildDS.relations(true);

        return salesOrderQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesOrderDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the details of a sales order
    /// </summary>
    /// <param name="salesId">
    /// A salesId
    /// </param>
    /// <param name="storeId">
    /// A storeId
    /// </param>
    /// <returns>
    /// A container object containing the details of a sales order in XML format
    /// </returns>
    /// <remarks>
    /// This is to get open sales order
    /// </remarks>
    public static container getSalesOrderDetail(SalesId salesId, InventLocationId storeId)
    {
        return RetailTransactionServiceOrders::getSalesOrderDetail(salesId, storeId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesOrderList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method loops the <c>SalesTable</c> to get the list of the sales orders.
    /// </summary>
    /// <param name="_custAccount">
    /// ID of the SalesTable.CustAccount field.
    /// </param>
    /// <returns>
    /// Container <c>salesOrder</c> having the data of the <c>SalesTable</c> and <c>CustTable</c>.
    /// </returns>
    public static container getSalesOrderList(CustAccount _custAccount)
    {
        SalesTable          salesTable;

        container           salesOrder = [true,''];
        ;

        QueryRun queryRun = new QueryRun(RetailTransactionService::buildSalesOrderCreateLinesQuery(_custAccount));
        while(queryRun.next())
        {
            salesTable = queryRun.get(tableNum(SalesTable));
            salesOrder += RetailTransactionService::getSalesOrder(salesTable.SalesId);
        }

        return salesOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesOrderListForPrepayments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method loops the <c>SalesTable</c> to get the list of the sales orders for prepayments.
    /// </summary>
    /// <param name="_custAccount">
    /// ID of the SalesTable.CustAccount field.
    /// </param>
    /// <returns>
    /// Container <c>salesOrder</c> having the data of the <c>SalesTable</c> and <c>CustTable</c>.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container getSalesOrderListForPrepayments(CustAccount _custAccount)
    {
        #OCCRetryCount
        RetailPrePaymentTrans prePaymentTrans;
        SalesTable          salesTable;
        container           salesOrder = [true,''];

        ttsbegin;

        try
        {
            QueryRun queryRun = new QueryRun(RetailTransactionService::buildSalesOrderPaymentTransQuery(_custAccount));
            while(queryRun.next())
            {
                salesTable = queryRun.get(tableNum(SalesTable));
                salesOrder += RetailTransactionService::getSalesOrder(salesTable.SalesId);
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            salesOrder = [false,"@RET4490"];
            ttsabort;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch
        {
            salesOrder = [false,"@RET4490"];
            ttsabort;
        }

        return salesOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getShipments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the shipping information of delivered sales orders.
    /// </summary>
    /// <param name="salesOrderId">
    /// Sales id of the shipments to get.
    /// </param>
    /// <param name="shipmentId">
    /// Packing slip id of the shipments to get.
    /// </param>
    /// <returns>
    /// A <c>container</c> with success status, error message and xml result of data returned by the query.
    /// </returns>
    /// <remarks>
    /// Method runs the <c>RetailGetShipmentInfo</c> query and forms the xml result of the data.
    /// </remarks>
    public static container getShipments(str salesOrderId = '', str shipmentId = '')
    {
        return RetailTransactionServiceOrders::getShipments(salesOrderId, shipmentId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerOrderShipmentHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the history of all orders for a given customer, as well as their shipments.
    /// </summary>
    /// <param name="_xmlArgumentString">
    /// XML document containing the arguments for the method call.  See remarks for example.
    /// </param>
    /// <returns>
    /// Collection of orders and shipments in XML.
    /// </returns>
    /// <remarks>
    /// Argument xml example:
    ///     <Arguments>
    ///         <CustomerAccountNumber>"1234"</CustomerAccountNumber>
    ///         <PagingInfo>
    ///             <Skip>1</Skip>
    ///             <Top>100</Top>
    ///         </PagingInfo>
    ///     </Arguments>
    /// </remarks>
    public static container getCustomerOrderShipmentHistory(str _xmlArgumentString = '')
    {
        return RetailTransactionServiceOrders::getCustomerOrderShipmentHistory(_xmlArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBusinessPartnerOrderHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the history of all transactions and orders for a given business partner.
    /// </summary>
    /// <param name="_xmlArgumentString">
    /// XML document containing the arguments for the method call.  See remarks for example.
    /// </param>
    /// <returns>
    /// Collection of orders.
    ///     <ArrayOfOrderShipments>
    ///         <OrderShipments />
    ///     </ArrayOfOrderShipments>
    /// </returns>
    /// <remarks>
    /// Argument xml example:
    ///     <Arguments>
    ///         <BusinessPartnerId>"1234"</BusinessPartnerId>
    ///         <PagingInfo>
    ///             <Skip>1</Skip>
    ///             <Top>100</Top>
    ///         </PagingInfo>
    ///     </Arguments>
    /// </remarks>
    public static container getBusinessPartnerOrderHistory(str _xmlArgumentString = '')
    {
        return RetailTransactionServiceOrders::getBusinessPartnerOrderHistory(_xmlArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for retrieving the sales transactions. Performs the following:
    /// 1.Adds transaction details.
    /// 2.Adds item details.
    /// 3.Adds loyalty.
    /// Performs the following validations:
    /// 1.No transactions for the receipt ID.
    /// 2.Too many transactions were found for receipt ID.
    /// </summary>
    /// <param name="receiptId">
    /// ID of the RetailTransactionTable.receiptId field.
    /// </param>
    /// <param name="storeId">
    /// ID of the RetailTransactionTable.store field.
    /// </param>
    /// <param name="terminalId">
    /// ID of the RetailTransactionTable.terminal field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <remarks>
    /// RetailTransactionService.fillTransactionTable method returns the container <c>transTable</c> having the data of the <c>RetailTransactionTable</c>.
    /// RetailTransactionService.fillSalesTrans method returns the container <c>salesTrans</c> having the data of the <c>RetailTransactionSalesTrans</c> table.
    /// RetailTransactionService.fillLoyaltyTrans method returns <c>container</c> with the value in the RetailTransactionLoyaltyPointsTrans.cardNumber field.
    /// </remarks>
    public static container getTransaction(RetailReceiptId   receiptId,
                                                     RetailStoreId     storeId    = '',
                                                     RetailTerminalId  terminalId = '')
    {
        return RetailTransactionServiceTransactions::getTransactionByReceiptId(receiptId, storeId, terminalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionByTransactionId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for retrieving the sales transactions. Performs the following:
    /// 1.Adds transaction details.
    /// 2.Adds item details.
    /// 3.Adds loyalty.
    /// Performs the following validation:
    /// 1.No transaction for the transaction ID.
    /// </summary>
    /// <param name="transactionId">
    /// The <c>transactionId</c> field of the <c>RetailTransactionTable</c> table.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>

    public static container getTransactionByTransactionId(RetailTransactionId transactionId)
    {
        return RetailTransactionServiceTransactions::getTransactionByTransactionId(transactionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransferOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the details of a transfer order
    /// </summary>
    /// <param name="transferId">
    /// A transferId
    /// </param>
    /// <param name="inventLocationId">
    /// The invent loation id
    /// </param>
    /// <returns>
    /// A container object containing the details of a transfer order
    /// </returns>
    /// <remarks>
    /// This is to get an open transfer order
    /// </remarks>
    public static container getTransferOrder(InventTransferId transferId, InventLocationId inventLocationId = '')
    {
        return RetailTransactionServiceInventory::getTransferOrder(transferId, inventLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWishLists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of wish lists
    /// </summary>
    /// <param name="wishListId">
    /// A wish list id.
    /// </param>
    /// <param name="customerId">
    /// A customer id.
    /// </param>
    /// <param name="favoriteFilter">
    /// Indicates whether or not to filter by favorite.
    /// </param>
    /// <param name="publicFilter">
    /// Indicates whether or not to filter by public.
    /// </param>
    /// <returns>
    /// A list of wish lists matching the parameters.
    /// </returns>
    [SysObsolete('Use method getWishListsV3() instead', false, 13\05\2023)]
    public static container getWishLists(RecId wishListId,
                                                AccountNum customerId,
                                                boolean favoriteFilter,
                                                boolean publicFilter)
    {
        str settings = '';
        return RetailTransactionServiceWishList::getWishListsV3(wishListId, customerId, favoriteFilter, publicFilter, settings);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWishListsV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of wish lists.
    /// </summary>
    /// <param name="wishListId">
    /// A wish list id.
    /// </param>
    /// <param name="customerId">
    /// A customer id.
    /// </param>
    /// <param name="favoriteFilter">
    /// Indicates whether or not to filter by favorite.
    /// </param>
    /// <param name="publicFilter">
    /// Indicates whether or not to filter by public.
    /// </param>
    /// <returns>
    /// A list of wish lists matching the parameters.
    /// </returns>
    [SysObsolete('Use method getWishListsV3() instead', false, 11\08\2022)]
    public static container getWishListsV2(RecId wishListId,
                                                AccountNum customerId,
                                                boolean favoriteFilter,
                                                boolean publicFilter)
    {
        str settings = '';
        return RetailTransactionServiceWishList::getWishListsV3(wishListId, customerId, favoriteFilter, publicFilter, settings);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWishListsV3</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of wish lists.
    /// </summary>
    /// <param name="wishListId">
    /// A wish list id.
    /// </param>
    /// <param name="customerId">
    /// A customer id.
    /// </param>
    /// <param name="favoriteFilter">
    /// Indicates whether or not to filter by favorite.
    /// </param>
    /// <param name="publicFilter">
    /// Indicates whether or not to filter by public.
    /// </param>
    /// <param name="querySettingsJson">
    /// The query settings.
    /// </param>
    /// <returns>
    /// A list of wish lists matching the parameters.
    /// </returns>
    public static container getWishListsV3(RecId wishListId,
                                                AccountNum customerId,
                                                boolean favoriteFilter,
                                                boolean publicFilter,
                                                str querySettingsJson)
    {
        return RetailTransactionServiceWishList::getWishListsV3(wishListId, customerId, favoriteFilter, publicFilter, querySettingsJson);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkerCurrentTimeRegistrationState</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an information about the current worker's time registration status.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_terminalId">
    /// Terminal id associated with the time registration.
    /// </param>
    /// <returns>
    /// A container having information about the type of latest worker's time registration.
    /// </returns>
    /// <remarks>
    /// If time registration fails, returned container will also have an error message.
    /// </remarks>
    public static container getWorkerCurrentTimeRegistrationState(HcmPersonnelNumberId _personnelNumber, RetailTerminalId _terminalId = '')
    {
        return RetailTransactionServiceEmployee::getWorkerCurrentTimeRegistrationState(_personnelNumber, _terminalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkerHistoryUtc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a history of time registrations for the worker specified in UTC time zone.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_storeId">
    /// Number of the store, where time registration has been made.
    /// </param>
    /// <param name="_fromDate">
    /// Lower bound of the history returned.
    /// </param>
    /// <param name="_toDate">
    /// Upper bound of the history returned.
    /// </param>
    /// <param name="_top">
    /// The top count, i.e. the number of employee activities to get.
    /// </param>
    /// <param name="_skip">
    /// The skip number, i.e. the number of employee activities to skip.
    /// </param>
    /// <param name="_orderByField">
    /// The order by field name.
    /// </param>
    /// <param name="_sortOrder">
    /// The sort order.
    /// </param>
    /// <returns>
    /// A container having history of worker's registrations.
    /// </returns>
    public static container getWorkerHistoryUtc(HcmPersonnelNumberId _personnelNumber,
                RetailStoreId _storeId,
                utcdatetime _fromDate = DateTimeUtil::newDateTime(DateTimeUtil::date(DateTimeUtil::getSystemDateTime()), 0), // start of the current date and time (UTC time zone)
                utcdatetime _toDate = DateTimeUtil::addHours(DateTimeUtil::newDateTime(DateTimeUtil::date(DateTimeUtil::getSystemDateTime()), 0), 24), // end of the current date and time (UTC time zone)
                int64 _top = 100,
                int64 _skip = 0,
                str _orderByField = fieldStr(JmgTermReg, RegDateTime),
                SortOrder _sortOrder = SortOrder::Descending)
    {
        return RetailTransactionServiceEmployee::getWorkerHistoryUtc(
                _personnelNumber,
                _storeId,
                _fromDate,
                _toDate,
                _top,
                _skip,
                _orderByField,
                _sortOrder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>giftCardPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the record in <c>RetailGiftCardTransactions</c> table.
    /// </summary>
    /// <param name="_cardNumber">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailGiftCardTransactions.storeId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailGiftCardTransactions.terminalId field.
    /// </param>
    /// <param name="_staffId">
    /// ID of the RetailGiftCardTransactions.staffId field.
    /// </param>
    /// <param name="_transactionId">
    /// ID of the RetailGiftCardTransactions.transactionId field.
    /// </param>
    /// <param name="_receiptId">
    /// ID of the RetailGiftCardTransactions.receiptId field.
    /// </param>
    /// <param name="_currencyCode">
    /// <c>CurrencyCode</c>
    /// </param>
    /// <param name="_amountMST">
    /// Value of the RetailGiftCardTransactions.amount field.
    /// </param>
    /// <param name="_transDate">
    /// Value of the RetailGiftCardTransactions.transDate field.
    /// </param>
    /// <param name="_transTime">
    /// Value of the RetailGiftCardTransactions.transTime field.
    /// </param>
    /// <param name="_dateSequence">
    /// Format of the date.
    /// </param>
    /// <param name="_channelId">
    /// ID of the RetailGiftCardTransactions.channel field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container giftCardPayment(RetailGiftCardId   _cardNumber,
                                           RetailStoreId       _storeId,
                                           RetailTerminalId    _terminalId,
                                           RetailStaffId       _staffId,
                                           RetailTransactionId _transactionId,
                                           RetailReceiptId     _receiptId,
                                           CurrencyCode     _currencyCode,
                                           AmountMST        _amountMST,
                                           str              _transDate,
                                           str              _transTime,
                                           int              _dateSequence = 321,
                                           RetailChannelRecId  _channelId = 0)
    {
        // Get the channel id from storeid if the channelid is not set
        _channelId = RetailTransactionService::getChannelIdFromStoreId(_storeId, _channelId);

        return RetailTransactionServiceTransactions::giftCardPayment(
            _cardNumber,
            _channelId,
            _terminalId,
            _staffId,
            _transactionId,
            _receiptId,
            _currencyCode,
            _amountMST,
            _transDate,
            _transTime,
            _dateSequence);
    }

]]></Source>
			</Method>
			<Method>
				<Name>giftCardRelease</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used to release a gift card, after it has been issued.
    /// </summary>
    /// <param name="_cardNumber">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container giftCardRelease(RetailGiftCardId   _cardNumber)
    {
        return RetailTransactionServiceTransactions::giftCardRelease(_cardNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventoryLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for initializing the fields of <c>InventDim</c> with the values of <c>InventDimCombination</c> fields. Method checks for the
    /// available physical inventory.
    /// </summary>
    /// <param name="_itemId">
    /// <c>ItemId</c>
    /// </param>
    /// <param name="_variantId">
    /// ID of the inventDimCombination.RetailVariantId field.
    /// </param>
    /// </param>
    /// <param name="_includeNonStoreWarehouses">True to include warehouse locations that are not Retail stores, default is False.</param>
    /// <returns>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fail to initialize the values and on check for the available physical inventory.
    /// </exception>
    public static container inventoryLookup(ItemId _itemId, RetailVariantId _variantId = '', boolean _includeNonStoreWarehouses = false)
    {
        return RetailTransactionServiceInventory::inventoryLookup(_itemId, _variantId, _includeNonStoreWarehouses);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventoryLookupXml</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for initializing the fields of <c>InventDim</c> with the values of <c>InventDimCombination</c> fields. Method checks for the
    /// available physical inventory.
    /// </summary>
    /// <param name="_itemId">
    /// <c>ItemId</c>
    /// </param>
    /// <param name="_variantId">
    /// ID of the inventDimCombination.RetailVariantId field.
    /// </param>
    /// <param name="_includeNonStoreWarehouses">True to include warehouse locations that are not Retail stores, default is False.</param>
    /// <returns>
    /// The status and inventory details as an XML.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fail to initialize the values and on check for the available physical inventory.
    /// </exception>
    public static container inventoryLookupXml(ItemId _itemId, RetailVariantId _variantId = '', boolean _includeNonStoreWarehouses = false)
    {
        return RetailTransactionServiceInventory::inventoryLookupXml(_itemId, _variantId, _includeNonStoreWarehouses);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventoryLookupByStoreXml</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for initializing the fields of <c>InventDim</c> with the values of <c>InventDimCombination</c> fields. Method checks for the
    /// available physical inventory.
    /// </summary>
    /// <param name="_itemId">
    /// <c>ItemId</c>
    /// </param>
    /// <param name="_variantId">
    /// ID of the inventDimCombination.RetailVariantId field.
    /// </param>
    /// <param name="_includeNonStoreWarehouses">True to include warehouse locations that are not Retail stores, default is False.</param>
    /// <param name="_currentStoreId">Current store id.</param>
    /// <returns>
    /// The status and inventory details as an XML.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fail to initialize the values and on check for the available physical inventory.
    /// </exception>
    public static container inventoryLookupByStoreXml(ItemId _itemId, RetailVariantId _variantId, boolean _includeNonStoreWarehouses, RecId _currentStoreId)
    {
        return RetailTransactionServiceInventory::inventoryLookupByStoreXml(_itemId, _variantId, _includeNonStoreWarehouses, _currentStoreId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventoryLookupByStoreV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Queries inventory information for a specific inventory item from each inventory location in the current store's fulfillment group.
    /// </summary>
    /// <param name = "_itemId">The inventory item to query the inventory availability of.</param>
    /// <param name = "_variantId">The variant id of the item.</param>
    /// <param name = "_currentStoreId">The current store id.</param>
    /// <param name = "_pageSkip">The first index to be returned via pagination.</param>
    /// <param name = "_pageTop">The size of the results to be returned via pagination.</param>
    /// <param name = "_includeWarehouses">True to include warehouse locations that are not Retail stores, default is True.</param>
    /// <param name = "_listCurrentStoreFirst">True to place the current store as the first store returned, default is True.</param>
    /// <returns>The status and inventory details as a JSON string containing the list of InventoryInfo objects.</returns>
    /// <exception cref="Exception::Error">
    /// Throws an error if the method fails to check for the available physical inventory.
    /// </exception>
    public static container inventoryLookupByStoreV2(ItemId _itemId, RetailVariantId _variantId, RecId _currentStoreId, int _pageSkip, int _pageTop,
                                                            boolean _includeWarehouses = true, boolean _listCurrentStoreFirst = true)
    {
        return RetailTransactionServiceInventory::InventoryLookupByStoreV2(_itemId, _variantId, _currentStoreId, _pageSkip, _pageTop, _includeWarehouses, _listCurrentStoreFirst);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventoryLookupByStoreV3</Name>
				<Source><![CDATA[
    /// <summary>
    /// Queries inventory information for a specific inventory item from each inventory location in the current store's fulfillment group and returns a sorted list.
    /// </summary>
    /// <param name = "_searchCriteriaJson">The search criteria is JSON format.</param>
    /// <returns>The status and inventory details as a JSON string containing the list of InventoryInfo objects.</returns>
    /// <exception cref="Exception::Error">
    /// Throws an error if the method fails to check for the availablilities.
    /// </exception>
    public static container inventoryLookupByStoreV3(str _searchCriteriaJson)
    {
        return RetailTransactionServiceInventory::InventoryLookupByStoreV3Optimized(_searchCriteriaJson);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetProductAvailabilityByDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get available to a product by dimensions.
    /// </summary>
    /// <param name = "_xmlArgumentString">Xml document with arguments for InventLocationIds, ProductId, DimensionsCombinations, PivotDimensions.
    /// [_root]
    ///     <InventLocations>
    ///       <InventLocation Id="HOUSTON" />
    ///       <InventLocation Id="BOSTON" />
    ///     </InventLocations>
    ///     <Product Id="23456" />
    ///     <ProductDimensionCombinations>
    ///       <ProductDimensionCombination>
    ///         <ProductDimension DimensionType="Color" DimensionValue="Red"/>
    ///         <ProductDimension DimensionType="Style" DimensionValue="Men"/>
    ///       </ProductDimensionCombination>
    ///     </ProductDimensionCombinations>
    ///     <HorizontalProductDimensions>
    ///       <ProductDimension DimensionType="Size" DimensionValue="Small"/>
    ///       <ProductDimension DimensionType="Size" DimensionValue="Medium"/>
    ///     </HorizontalProductDimensions>
    /// [/_root]
    /// </param>
    /// <returns>Serialized collection of <c>Microsoft.Dynamics.Commerce.Runtime.DataModel.OrgUnitAvailability</c>. </returns>
    public static container GetProductAvailabilityByDimensions(str _xmlArgumentString)
    {
        return RetailTransactionServiceInventory::GetProductAvailabilityByDimensions(_xmlArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetAvailableToPromiseInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get available to promise inventory for a product at channel.
    /// </summary>
    /// <param name = "_productId">The product identifier.</param>
    /// <param name = "_channelId">The channel identifier.</param>
    /// <param name = "_custAccount">The customer account number.</param>
    /// <param name = "_resultsMaxCount">The maximum size of the result collection.</param>
    /// <returns>The collection of available to promise info for the item.</returns>
    public static container GetAvailableToPromiseInventory(EcoResProductRecId _productId, RetailChannelRecId _channelId, CustAccount _custAccount, int _resultsMaxCount)
    {
        return RetailTransactionServiceInventory::GetAvailableToPromiseInventory(_productId, _channelId, _custAccount, _resultsMaxCount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetAvailableToPromiseInventoryByWarehouse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get available to promise inventory for an item at an inventory location.
    /// </summary>
    /// <param name = "_xmlArgumentString">Xml document with arguments for ProductId, ChannelId, LocationId, CustomerAccountNumber, PagingInfo</param>
    /// <returns>The collection of available to promise inventory for the given item and location.</returns>
    public static container GetAvailableToPromiseInventoryByWarehouse(str _xmlArgumentString)
    {
        return RetailTransactionServiceInventory::GetAvailableToPromiseInventoryByWarehouse(_xmlArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>InventoryLookupOnDate_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for initializing the fields of <c>InventDim</c> with the values of <c>InventDimCombination</c> fields. Method checks for the
    /// on hand inventory on a specific date.
    /// </summary>
    /// <param name="_itemId">
    /// <c>ItemId</c>
    /// </param>
    /// <param name="_variantId">
    /// ID of the inventDimCombination.RetailVariantId field.
    /// </param>
    /// <param name="_transDate">
    /// A <c>string</c> representing the date for the status of the inventory.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fail to initialize the values and on check for the available physical inventory.
    /// </exception>
    public static container InventoryLookupOnDate_BR(   ItemId          _itemId,
                                                        RetailVariantId _variantId,
                                                        TransDate       _transDate)
    {
        return RetailTransactionServiceInventory::InventoryLookupOnDate_BR(
            _itemId,
            _variantId,
            _transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>issueCreditMemo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the record in <c>RetailCreditVoucherTable</c>.
    /// </summary>
    /// <param name="_storeId">
    /// ID of the RetailCreditVoucherTable.createdInStoreId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailCreditVoucherTable.createdByTerminalId field.
    /// </param>
    /// <param name="_staffId">
    /// ID of the RetailCreditVoucherTable.createdByStaffId field.
    /// </param>
    /// <param name="_transactionId">
    /// ID of the RetailCreditVoucherTable.createdByTransactionId field.
    /// </param>
    /// <param name="_receiptId">
    /// ID of the RetailCreditVoucherTable.createdByReceipId field.
    /// </param>
    /// <param name="_lineNum">
    /// ID of the RetailCreditVoucherTable.createdByLineNum field.
    /// </param>
    /// <param name="_currencyCode">
    /// ID of the RetailCreditVoucherTable.currencyCode field.
    /// </param>
    /// <param name="_amountMST">
    /// Value for the RetailCreditVoucherTable.amount field.
    /// </param>
    /// <param name="_transDate">
    /// Value for the RetailCreditVoucherTable.transDate field.
    /// </param>
    /// <param name="_transTime">
    /// Value for the RetailCreditVoucherTable.transTime field.
    /// </param>
    /// <param name="_dateSequence">
    /// Format of the date.
    /// </param>
    /// <returns>
    /// <c>Container</c>
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container issueCreditMemo(//RetailDataEntryId   _entryId,
                                                   RetailStoreId       _storeId,
                                                   RetailTerminalId    _terminalId,
                                                   RetailStaffId       _staffId,
                                                   RetailTransactionId _transactionId,
                                                   RetailReceiptId     _receiptId,
                                                   RetailLineNum       _lineNum,
                                                   CurrencyCode     _currencyCode,
                                                   AmountMST        _amountMST,
                                                   str              _transDate,//RBOTransDate     _transDate,
                                                   str              _transTime,//RetailTransTime     _transTime)
                                                   int              _dateSequence = 321)
    {
        return RetailTransactionServiceTransactions::issueCreditMemo(
            _storeId,
            _terminalId,
            _staffId,
            _transactionId,
            _receiptId,
            _lineNum,
            _currencyCode,
            _amountMST,
            _transDate,
            _transTime,
            _dateSequence);
    }

]]></Source>
			</Method>
			<Method>
				<Name>issueGiftCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// This issues a gift card that is not reserved to a terminal / store. This is used for supporting POS 5/61/62
    /// To issue a reserved gift card use the method <c>issueReservedGiftCard</c>
    /// </summary>
    /// <param name="_cardNumber">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailGiftCardTransactions.storeId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailGiftCardTransactions.terminalId field.
    /// </param>
    /// <param name="_staffId">
    /// ID of the RetailGiftCardTransactions.staffId field.
    /// </param>
    /// <param name="_transactionId">
    /// ID of the RetailGiftCardTransactions.transactionId field.
    /// </param>
    /// <param name="_receiptId">
    /// ID of the RetailGiftCardTransactions.receiptId field.
    /// </param>
    /// <param name="_currencyCode">
    /// <c>CurrencyCode</c>
    /// </param>
    /// <param name="_amountMST">
    /// Value of the RetailGiftCardTransactions.amount field.
    /// </param>
    /// <param name="_transDate">
    /// Value of the RetailGiftCardTransactions.transDate field.
    /// </param>
    /// <param name="_transTime">
    /// Value of the RetailGiftCardTransactions.transTime field.
    /// </param>
    /// <param name="_dateSequence">
    /// Format of the date.
    /// </param>
    /// <param name="_channelId">
    /// ID of the RetailGiftCardTransactions.channel field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container issueGiftCard(RetailGiftCardId   _cardNumber,
                                           RetailStoreId       _storeId,
                                           RetailTerminalId    _terminalId,
                                           RetailStaffId       _staffId,
                                           RetailTransactionId _transactionId,
                                           RetailReceiptId     _receiptId,
                                           CurrencyCode     _currencyCode,
                                           AmountMST        _amountMST,
                                           str              _transDate,
                                           str              _transTime,
                                           int              _dateSequence = 321,
                                           RetailChannelRecId  _channelId = 0)
    {
        // Get the channel id from storeid if the channelid is not set
        _channelId = RetailTransactionService::getChannelIdFromStoreId(_storeId, _channelId);

        return RetailTransactionServiceTransactions::issueGiftCard(
            _cardNumber,
            _channelId,
            _terminalId,
            _staffId,
            _transactionId,
            _receiptId,
            _currencyCode,
            _amountMST,
            _transDate,
            _transTime,
            _dateSequence,
            false); // Parameter: _reserved. Issue an unlocked gift card. Used for POS5,61,62
    }

]]></Source>
			</Method>
			<Method>
				<Name>IssueLoyaltyCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Issues a loyalty card, and joins the loyalty programs that are associated to the specificed channel.
    /// If channel recId is not provided, joins all available loyalty programs.
    /// </summary>
    /// <param name="_cardNumber">
    /// The card number.
    /// </param>
    /// <param name="_cardTenderType">
    /// The tender type of the loyalty card.
    /// </param>
    /// <param name="_partyRecId">
    /// The record identifier of the party of the card owner.
    /// </param>
    /// <param name="_channelRecId">
    /// The record identifier of the channel where the loyalty card is issued.
    /// </param>
    /// <returns>
    /// A container having the result.
    /// </returns>
    /// <remarks>
    /// The result container contains [isSuccess, Message, cardContainer, cardTierListContainer].
    /// The cardContainer contains [retailLoyaltyCard.RecId, retailLoyaltyCard.CardNumber, retailLoyaltyCard.CardTenderType, retailLoyaltyCard.Party].
    /// The cardTierListContainer contains a list of cardTierContainer.
    /// The cardTierContainer contains [cardTier.RecId, cardTier.Affiliation, cardTier.LoyaltyCard, cardTier.LoyaltyTier, cardTier.ValidFrom, cardTier.ValidTo].
    /// </remarks>
    public static container IssueLoyaltyCard(
        RetailLoyaltyCardNumber _cardNumber = '',
        RetailLoyaltyTenderType _cardTenderType = RetailLoyaltyTenderTypeBase::AsCardTender,
        DirPartyRecId _partyRecId = 0,
        RefRecid _channelRecId = 0)
    {
        return RetailTransactionServiceLoyalty::IssueLoyaltyCard(_cardNumber, _cardTenderType, _partyRecId, _channelRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>issueReservedGiftCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the record in <c>RetailGiftCardTransactions</c> table.
    /// Initially the gift card is marked as reserved.  Call giftCardRelease to clear the reservation.
    /// </summary>
    /// <param name="_cardNumber">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailGiftCardTransactions.storeId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailGiftCardTransactions.terminalId field.
    /// </param>
    /// <param name="_staffId">
    /// ID of the RetailGiftCardTransactions.staffId field.
    /// </param>
    /// <param name="_transactionId">
    /// ID of the RetailGiftCardTransactions.transactionId field.
    /// </param>
    /// <param name="_receiptId">
    /// ID of the RetailGiftCardTransactions.receiptId field.
    /// </param>
    /// <param name="_currencyCode">
    /// <c>CurrencyCode</c>
    /// </param>
    /// <param name="_amountMST">
    /// Value of the RetailGiftCardTransactions.amount field.
    /// </param>
    /// <param name="_transDate">
    /// Value of the RetailGiftCardTransactions.transDate field.
    /// </param>
    /// <param name="_transTime">
    /// Value of the RetailGiftCardTransactions.transTime field.
    /// </param>
    /// <param name="_dateSequence">
    /// Format of the date.
    /// </param>
    /// <param name="_channelId">
    /// ID of the RetailGiftCardTransactions.channel field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container issueReservedGiftCard(RetailGiftCardId   _cardNumber,
                                           RetailStoreId       _storeId,
                                           RetailTerminalId    _terminalId,
                                           RetailStaffId       _staffId,
                                           RetailTransactionId _transactionId,
                                           RetailReceiptId     _receiptId,
                                           CurrencyCode     _currencyCode,
                                           AmountMST        _amountMST,
                                           str              _transDate,
                                           str              _transTime,
                                           int              _dateSequence = 321,
                                           RetailChannelRecId  _channelId = 0)
    {
        // Get the channel id from storeid if the channelid is not set
        _channelId = RetailTransactionService::getChannelIdFromStoreId(_storeId, _channelId);
        
        return RetailTransactionServiceTransactions::issueGiftCard(
            _cardNumber,
            _channelId,
            _terminalId,
            _staffId,
            _transactionId,
            _receiptId,
            _currencyCode,
            _amountMST,
            _transDate,
            _transTime,
            _dateSequence,
            true);
        // Parameter: _reserved. Issue a locked gift card.
       
    }

]]></Source>
			</Method>
			<Method>
				<Name>MarkItemsReturned</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method updates the RetailTransactionSalesTrans.returnQty with the value in <c>returnQty</c> if the RetailTransactionSalesTrans.returnQty + returnQty > RetailTransactionSalesTrans.qty field.
    /// </summary>
    /// <param name="itemReturnXmlStr">
    /// Return items serialized to xml string.
    /// Example:
    /// <ArrayOfItemReturn>
    ///   <ItemReturn>
    ///     <TransactionId>100001</TransactionId>
    ///     <StoreId>1001</StoreId>
    ///     <TerminalId>1001</TerminalId>
    ///     <LineNumber>1</LineNumber>
    ///     <Quantity>1.00</Quantity>
    ///   </ItemReturn>
    ///   <ItemReturn>
    ///     <TransactionId>100002</TransactionId>
    ///     <StoreId>1001</StoreId>
    ///     <TerminalId>1001</TerminalId>
    ///     <LineNumber>2</LineNumber>
    ///     <Quantity>2.00</Quantity>
    ///   </ItemReturn>
    /// </ArrayOfItemReturn>
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container MarkItemsReturned(str itemReturnXmlStr)
    {
        return RetailTransactionServiceTransactions::MarkItemsReturned(itemReturnXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating new customer.
    /// </summary>
    /// <param name="custName">
    /// Customer name.
    /// </param>
    /// <param name="custGroup">
    /// Customer group
    /// </param>
    /// <param name="currency">
    /// Currency
    /// </param>
    /// <param name="languageId">
    /// Language ID
    /// </param>
    /// <param name="street">
    /// Street
    /// </param>
    /// <param name="zipCode">
    /// Zip code
    /// </param>
    /// <param name="state">
    /// State
    /// </param>
    /// <param name="county">
    /// County
    /// </param>
    /// <param name="phone">
    /// Phone
    /// </param>
    /// <param name="cellularPhone">
    /// Cell phone
    /// </param>
    /// <param name="email">
    /// Email
    /// </param>
    /// <param name="url">
    /// URL
    /// </param>
    /// <param name="multiLineDisc">
    /// Multiline discount
    /// </param>
    /// <param name="endDisc">
    /// End discount
    /// </param>
    /// <param name="lineDisc">
    /// Line discount
    /// </param>
    /// <param name="priceGroup">
    /// Price Group
    /// </param>
    /// <param name="taxGroup">
    /// Tax Group
    /// </param>
    /// <param name="creditMax">
    /// Credit Max
    /// </param>
    /// <param name="blocked">
    /// Blocked
    /// </param>
    /// <param name="orgId">
    /// Org ID
    /// </param>
    /// <param name="usePurchRequest">
    /// Use purchase request
    /// </param>
    /// <param name="vatNum">
    /// Vat Number
    /// </param>
    /// <param name="invoiceAccount">
    /// Invoice account
    /// </param>
    /// <param name="mandatoryCreditLimit">
    /// Mandotory credit limit
    /// </param>
    /// <param name="contactPersonId">
    /// Contact person ID
    /// </param>
    /// <param name="useOrderNumberReference">
    /// Use order number reference
    /// </param>
    /// <param name="receiptOption">
    /// Receipt option
    /// </param>
    /// <param name="receiptEmail">
    /// Receipt Email
    /// </param>
    /// <param name="city">
    /// City
    /// </param>
    /// <param name="country">
    /// Country
    /// </param>
    /// <param name="identificationNumber">
    /// Identification Number
    /// </param>
    /// <param name="storeRecId">
    /// Store Rec ID
    /// </param>
    /// <param name="DirPartyType">
    /// DirPartyType
    /// </param>
    /// <param name="streetNumber">
    /// Street Number
    /// </param>
    /// <param name="districtName">
    /// District Name
    /// </param>
    /// <param name="buildingCompliment">
    /// Building Complement
    /// </param>
    /// <param name="cnpjCpfNum_BR">
    /// CNPJ/CPF (Brazilian tax ID)
    /// </param>
    /// <param name="addressName">
    /// Address Name
    /// </param>
    /// <param name="addressType">
    /// Address Type
    /// </param>
    /// <param name="addressPhone">
    /// Address Phone
    /// </param>
    /// <param name="addressEmail">
    /// Address Email
    /// </param>
    /// <param name="addressUrl">
    /// Address URL
    /// </param>
    /// <param name="addressTaxGroup">
    /// Address Tax group
    /// </param>
    /// <param name="firstName">
    /// First name
    /// </param>
    /// <param name="middleName">
    /// Middle name
    /// </param>
    /// <param name="lastName">
    /// Last name
    /// </param>
    /// <param name="phoneExtension">
    /// Phone extension
    /// </param>
    /// <param name="retailCustAffiliations">
    /// A XML string having the details of customer affiliation list
    /// </param>
    /// <param name="externalIdentityId">
    /// The external identity identifier.
    /// </param>
    /// <param name="externalIdentityIssuer">
    /// The external identity issuer.
    /// </param>
    /// <param name="customerAttributes">
    /// An XML string containing the customer attributes
    /// </param>
    /// </param>
    /// <param name="custAttributesDataPackageVersion">
    /// Optional. The customer attributes data package version.
    /// <returns>
    /// Container with entity keys
    /// </returns>
    /// <remarks>This method has been deprecated in favor of newCustomerExt3.</remarks>
    public static container newCustomer(    DirPartyName                custName,
                                            //NameAlias                   custTableAlias,
                                            CustGroupId                 custGroup,
                                            CustCurrencyCode            currency,
                                            CustLanguageId              languageId,
                                            AddressStreet               street,
                                            AddressZipCodeId            zipCode,
                                            AddressStateId              state,
                                            AddressCountyId             county,
                                            Phone                       phone,
                                            PhoneMobile                 cellularPhone,
                                            LogisticsElectronicAddressLocator  email,
                                            URL                         url,
                                            CustMultiLineDiscCode       multiLineDisc,
                                            CustEndDiscCode             endDisc,
                                            CustLineDiscCode            lineDisc,
                                            CustPriceGroup              priceGroup,
                                            TaxGroup                    taxGroup,
                                            CustCreditMaxMST            creditMax,
                                            CustBlocked                 blocked,
                                            OrgId                       orgId,
                                            RetailUsePurchRequest       usePurchRequest,
                                            VATNum                      vatNum,
                                            CustInvoiceAccount          invoiceAccount,
                                            MandatoryCreditLimit        mandatoryCreditLimit,
                                            ContactPersonId             contactPersonId,
                                            RetailUseOrderNumberReference  useOrderNumberReference,
                                            RetailReceiptOption            receiptOption,
                                            RetailReceiptEmail             receiptEmail,
                                            AddressCity                 city,
                                            AddressCountryRegionId      country,
                                            CustIdentificationNumber    identificationNumber,
                                            int64                       storeRecId,
                                            DirPartyType                dirPartyRelationType,
                                            LogisticsAddressStreetNumber        streetNumber        = '',
                                            LogisticsAddressDistrictName        districtName        = '',
                                            LogisticsAddressBuildingCompliment  buildingCompliment  = '',
                                            CNPJCPFNum_BR                       cnpjCpfNum_BR       = '',
                                            CustName                    addressName = '',
                                            LogisticsLocationRoleType   addressType = LogisticsLocationRoleType::None,
                                            Phone                       addressPhone = '',
                                            LogisticsElectronicAddressLocator addressEmail = '',
                                            URL                         addressUrl = '',
                                            TaxGroup                    addressTaxGroup = '',
                                            FirstName firstName = '',
                                            MiddleName middleName = '',
                                            LastName lastName = '',
                                            PhoneLocal phoneExtension = '',
                                            str retailCustAffiliations = '',
                                            str externalIdentityId = '',
                                            str externalIdentityIssuer = '',
                                            str customerAttributes = '',
                                            int custAttributesDataPackageVersion = 1)
    {
        return RetailTransactionServiceCustomer::newCustomer(
            custName,
            custGroup,
            currency,
            languageId,
            street,
            zipCode,
            state,
            county,
            phone,
            cellularPhone,
            email,
            url,
            multiLineDisc,
            endDisc,
            lineDisc,
            priceGroup,
            taxGroup,
            creditMax,
            blocked,
            orgId,
            usePurchRequest,
            vatNum,
            invoiceAccount,
            mandatoryCreditLimit,
            contactPersonId,
            useOrderNumberReference,
            receiptOption,
            receiptEmail,
            city,
            country,
            identificationNumber,
            storeRecId,
            dirPartyRelationType,
            streetNumber,
            districtName,
            buildingCompliment,
            cnpjCpfNum_BR,
            addressName,
            addressType,
            addressPhone,
            addressEmail,
            addressUrl,
            addressTaxGroup,
            firstName,
            middleName,
            lastName,
            phoneExtension,
            retailCustAffiliations,
            externalIdentityId,
            externalIdentityIssuer,
            customerAttributes,
            custAttributesDataPackageVersion);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustomerFromDirParty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating new customer using existing dirParty record.
    /// </summary>
    /// <param name="dirPartyNumber">
    /// dirParty number.
    /// </param>
    /// <param name="storeRecId">
    /// Store Rec ID
    /// </param>
    /// <param name="cnpjCpfNum_BR">
    /// CNPJ/CPF (Brazilian tax ID).
    /// </param>
    /// <returns>
    /// Container with entity keys
    /// </returns>
    public static container newCustomerFromDirParty(
                DirPartyNumber      dirPartyNumber,
                int64               storeRecId,
                CNPJCPFNum_BR       cnpjCpfNum_BR = '')
    {
        return RetailTransactionServiceCustomer::newCustomerFromDirParty(
                dirPartyNumber,
                storeRecId,
                cnpjCpfNum_BR);
    }

]]></Source>
			</Method>
			<Method>
				<Name>packingSlipForCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates packing slip for the customer order.
    /// </summary>
    /// <param name="_salesId">
    /// Identification of the sales order.
    /// </param>
    /// <returns>
    /// A Container with the status of pack slip creation.
    /// </returns>
    public static container packingSlipForCustomerOrder(SalesId _salesId)
    {
        return RetailTransactionServiceOrders::packingSlipForCustomerOrder(_salesId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parseSerializedFilteringCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    /// Helper method to parse the serialized filtering criteria into a container of key-value pairs.
    /// </summary>
    /// <param name="filterCriteria">
    /// The serialzied filtering criteria.
    /// </param>
    /// <returns>
    /// A container of parsing results, comment, and key-value pairs. Each pair is a container [Key, Value].
    /// Example: [true, "successful", [key1, value1], [key2, value2], ...].
    /// </returns>
    /// <remarks>
    /// 1. Assumption: The filtering criteria is serialized from
    /// Microsoft.Dynamics.Commerce.Runtime.TransactionService.FilteringCriteria
    /// with System.Xml.Serialization.XmlSerializer.
    /// 2. Currently support type conversions for StartDate, StartTime, EndDate, EndTime, ResultsStartIndex, ResultsMaxCount.
    /// All the other customized filtering criteria will be returned as strings.
    /// </remarks>
    private static container parseSerializedFilteringCriteria(str filterCriteria)
    {
        container       results = [true, 'Successful'];
        str             error;
        int             fromLine, i;
        int             dateSequence = 321;
        XmlDocument     filteringCriteriaXml;
        XmlElement      xmlRoot;
        XmlElement      xmlRecord;
        XmlNodeList     xmlRecordList;

        // The serialized xml looks like this:
        //
        //<FilteringCriteria xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
        //  <ResultsStartIndex>0</ResultsStartIndex>
        //  <ResultsMaxCount>100</ResultsMaxCount>
        //  <StartTime>2012-05-22T17:54:15.8381225-07:00</StartTime>
        //  <StartTimeAxDateString>2012-05-22</StartTimeAxDateString>
        //  <StartTimeAxTimeString>17:54:15</StartTimeAxTimeString>
        //  <EndTime>2012-05-23T17:54:15.9575239-07:00</EndTime>
        //  <EndTimeAxDateString>2012-05-23</EndTimeAxDateString>
        //  <EndTimeAxTimeString>17:54:15</EndTimeAxTimeString>
        //  <AxDateSequence>321</AxDateSequence>
        //</FilteringCriteria>

        #define.ResultsStartIndexKey('ResultsStartIndex')
        #define.ResultsMaxCountKey('ResultsMaxCount')
        #define.StartTimeAxDateStringKey('StartTimeAxDateString')
        #define.StartTimeAxTimeStringKey('StartTimeAxTimeString')
        #define.EndTimeAxDateStringKey('EndTimeAxDateString')
        #define.EndTimeAxTimeStringKey('EndTimeAxTimeString')
        #define.AxDateSequenceKey('AxDateSequence')

        // local fucntion to parse integer property
        void parseIntegerProperty(str key)
        {
            if (xmlRoot == null)
            {
                throw error('xmlRoot is null');
            }

            xmlRecord = xmlRoot.getNamedElement(key);
            if (xmlRecord != null)
            {
                results = conIns(results, conLen(results) + 1, [key, str2int(xmlRecord.text())]);
                xmlRoot.removeChild(xmlRecord);
            }
        }

        // local function to parse date property
        void parseDateProperty(str key)
        {
            if (xmlRoot == null)
            {
                throw error('xmlRoot is null');
            }

            xmlRecord = xmlRoot.getNamedElement(key);
            if (xmlRecord != null)
            {
                results = conIns(results, conLen(results) + 1, [key, str2Date(xmlRecord.text(), dateSequence)]);
                xmlRoot.removeChild(xmlRecord);
            }
        }

        // local function to parse time property
        void parseTimeProperty(str key)
        {
            if (xmlRoot == null)
            {
                throw error('xmlRoot is null');
            }

            xmlRecord = xmlRoot.getNamedElement(key);
            if (xmlRecord != null)
            {
                results = conIns(results, conLen(results) + 1, [key, str2time(xmlRecord.text())]);
                xmlRoot.removeChild(xmlRecord);
            }
        }

        // local function to parse string property
        void parseStringProperty(str key)
        {
            if (xmlRoot == null)
            {
                throw error('xmlRoot is null');
            }

            xmlRecord = xmlRoot.getNamedElement(key);
            if (xmlRecord != null)
            {
                results = conIns(results, conLen(results) + 1, [key, xmlRecord.text()]);
                xmlRoot.removeChild(xmlRecord);
            }
        }

        try
        {
            fromLine = Global::infologLine();

            filteringCriteriaXml = new XmlDocument();
            filteringCriteriaXml.loadXml(filterCriteria);
            xmlRoot = filteringCriteriaXml.root();

            // Parse ResultsStartIndex & ResultsMaxCount
            parseIntegerProperty(#ResultsStartIndexKey);
            parseIntegerProperty(#ResultsMaxCountKey);

            // Parse the dates:
            // 1. Get the date sequence first
            parseIntegerProperty(#AxDateSequenceKey);

            // 2. Parse the date & time
            parseDateProperty(#StartTimeAxDateStringKey);
            parseTimeProperty(#StartTimeAxTimeStringKey);
            parseDateProperty(#EndTimeAxDateStringKey);
            parseTimeProperty(#EndTimeAxTimeStringKey);

            // Parse other properties
            xmlRecordList = xmlRoot.childNodes();
            if (xmlRecordList)
            {
                for (i = 0; i < xmlRecordList.length(); i++)
                {
                    xmlRecord = xmlRecordList.item(i);
                    results = conIns(results, conLen(results) + 1, [xmlRecord.name(), xmlRecord.text()]);
                }
            }
        }
        catch (Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            results = [false, error];
        }

        return results;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paySalesInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for calculating the payment for the sales invoice, create and post the payment journal.
    /// </summary>
    /// <param name="_invoiceId">
    /// ID of the CustTrans.Invoice field.
    /// </param>
    /// <param name="_paymentAmount">
    /// Amount stored in LedgerJournalTrans.AmountCurDebit if <c>_paymentAmount</c> is less than 0; else LedgerJournalTrans.AmountCurCredit.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailTerminalTable.TerminalId field.
    /// </param>
    /// <param name="_storeId">
    /// <c>RetailStoreId</c>
    /// </param>
    /// <param name="_transactionId">
    /// <c>RetailTransactionId</c>
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container paySalesInvoice(InvoiceId           _invoiceId,
                                            AmountCur           _paymentAmount,
                                            RetailTerminalId       _terminalId,
                                            RetailStoreId          _storeId,
                                            RetailTransactionId    _transactionId)
    {
        return RetailTransactionServiceTransactions::paySalesInvoice(
            _invoiceId,
            _paymentAmount,
            _terminalId,
            _storeId,
            _transactionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>payInvoices</Name>
				<Source><![CDATA[
    /// <summary>
    /// Pay multiple invoices given the input parameter.
    /// </summary>
    /// <param name = "_xmlInvoiceParameter">The xml contains invoice parameters to be paid.</param>
    /// <returns>
    /// The container result of pay invoices.
    /// </returns>
    public static container payInvoices(str _xmlInvoiceParameter)
    {
        return RetailTransactionServiceTransactions::payInvoices(_xmlInvoiceParameter);
    }

]]></Source>
			</Method>
			<Method>
				<Name>paySalesOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for payment of sales order. Method performs the following:
    /// 1.Creates and posts payment journal.
    /// 2.Return error if the total prepayment exceed the sales order total.
    /// </summary>
    /// <param name="_salesId">
    /// ID of the SalesTable.SalesId firld.
    /// </param>
    /// <param name="_paymentAmount">
    /// Amount stored in LedgerJournalTrans.AmountCurDebit if <c>_paymentAmount</c> is less than 0; else LedgerJournalTrans.AmountCurCredit.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailTerminalTable.TerminalId field.
    /// </param>
    /// <param name="_storeId">
    /// <c>RetailStoreId</c>
    /// </param>
    /// <param name="_transactionId">
    /// <c>RetailTransactionId</c>
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container paySalesOrder(SalesId           _salesId,
                                          AmountCur         _paymentAmount,
                                          RetailTerminalId     _terminalId,
                                          RetailStoreId        _storeId,
                                          RetailTransactionId  _transactionId)
    {
        return RetailTransactionServiceTransactions::paySalesOrder(
            _salesId,
            _paymentAmount,
            _terminalId,
            _storeId,
            _transactionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>PostLoyaltyCardRewardPointTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts reward points to the <c>RetailLoyaltyCardRewardPointTrans</c> table.
    /// </summary>
    /// <param name="_rewardPointTransXmlStr">
    /// The XML string that contains a list of reward point lines.
    /// </param>
    /// <returns>
    /// A container having the result.
    /// </returns>
    /// <remarks>
    /// The XML string has a root node RetailLoyaltyCardRewardPointTransList, which contains
    /// a list of RetailLoyaltyCardRewardPointTrans nodes. Each child node conains the field
    /// values of a <c>RetailLoyaltyCardRewardPointTrans</c> record. Refer to the
    /// <c>RetailLoyaltyCardRewardPointTrans</c> table for the meaning of each field.
    ///
    /// A sample of XML is provided in the source code of <c>RetailTransactionServiceLoyalty</c> class.
    /// </remarks>
    public static container PostLoyaltyCardRewardPointTrans(str _rewardPointTransXmlStr)
    {
        return RetailTransactionServiceLoyalty::PostLoyaltyCardRewardPointTrans(_rewardPointTransXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>PostLoyaltyCardRewardPointTransLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts reward points to the <c>RetailLoyaltyCardRewardPointTrans</c> table.
    /// </summary>
    /// <param name="_rewardPointTransXmlStr">
    /// The XML string that contains a list of reward point lines.
    /// </param>
    /// <returns>
    /// A container having the result.
    /// </returns>
    /// <remarks>
    /// The XML string has a root node RetailLoyaltyCardRewardPointTransList, which contains
    /// a list of RetailLoyaltyCardRewardPointTrans nodes. Each child node conains the field
    /// values of a <c>RetailLoyaltyCardRewardPointTrans</c> record. Refer to the
    /// <c>RetailLoyaltyCardRewardPointTrans</c> table for the meaning of each field.
    ///
    /// A sample of XML is provided in the source code of <c>RetailTransactionServiceLoyalty</c> class.
    /// </remarks>
    public static container PostLoyaltyCardRewardPointTransLines(str _rewardPointTransXmlStr)
    {
        return RetailTransactionServiceLoyalty::PostLoyaltyCardRewardPointTransLines(_rewardPointTransXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>retailServerStaffInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method gets the staff Id and returns detail information about the staff and permissions for staff.
    /// </summary>
    /// <param name="_staffId">
    /// Staff Id.
    /// </param>
    /// <returns>
    /// The Staff Information as a container.
    /// </returns>
    public static container retailServerStaffInfo(RetailStaffId _staffId)
    {
        return RetailTransactionServiceEmployee::retailServerStaffInfo(_staffId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>retailServerStaffInfoByExternalIdentity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method gets the staff Id and returns detail information about the staff and permissions for staff.
    /// </summary>
    /// <param name="_externalIdentityId">
    /// Primary external identity identifier (eg: AAD Tenent Id).
    /// </param>
    /// <param name="_externalSubIdentityId">
    /// Sub-identifier for external identity (eg: AAD Object Id).
    /// </param>
    /// <returns>
    /// The Staff Information as a container.
    /// </returns>
    public static container retailServerStaffInfoByExternalIdentity(str _externalIdentityId, str _externalSubIdentityId)
    {
        return RetailTransactionServiceEmployee::retailServerStaffInfoByExternalIdentity( _externalIdentityId, _externalSubIdentityId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>retailServerStaffIsPasswordValidForStaff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for validating if password is correct for a particular staff Id.
    /// </summary>
    /// <param name="_staffId">
    /// <c>RetailStaffId</c>
    /// </param>
    /// <param name="_password">
    /// <c>RetailStaffPassword</c>
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to create/update.
    /// </exception>
    public static container retailServerStaffIsPasswordValidForStaff(RetailStaffId _staffId, RetailStaffPassword _password)
    {
        container   results, staff_results;

        ttsBegin;
        try
        {
            results = RetailTransactionService::staffIsPasswordValidForStaff(_staffId, _password);

            if (conPeek(results, 1)  == true)
            {
                staff_results = results;
                ttsCommit;
            }
            else
            {
                staff_results = results;
                ttsAbort;
            }
        }
        catch
        {
            ttsAbort;
            throw error("@RET2382");
        }

        return staff_results;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retailServerStaffLogOff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method deletes the record from <c>RetailStaffLoginLog</c> table.
    /// </summary>
    /// <param name="_staffId">
    /// ID of the RetailStaffLoginLog.staffId field.
    /// </param>
    /// <param name="_storeRecId">
    /// RecID of the RetailStaffLoginLog.storeId field.
    /// </param>
    /// <param name="_terminalRecId">
    /// RecID of the RetailStaffLoginLog.terminalId field.
    /// </param>
    /// <param name="_logoffFromStore">
    /// True to logoff from store, false otherwise
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to delete.
    /// </exception>
    public static container retailServerStaffLogOff(RetailStaffId _staffId, RetailChannelRecId _storeRecId, RefRecId _terminalRecId, boolean _logoffFromStore = true)
    {
        return RetailTransactionServiceEmployee::retailServerStaffLogOff(_staffId, _storeRecId, _terminalRecId, _logoffFromStore);
    }

]]></Source>
			</Method>
			<Method>
				<Name>retailServerStaffLogOn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for updating the RetailStaffLoginLog.staffId with the value in <c>_staffId</c> if the record exists in <c>RetailStaffLoginLog</c>;
    /// else creates the record in <c>RetailStaffLoginLog</c>table.
    /// </summary>
    /// <param name="_staffId">
    /// ID of the RetailStaffLoginLog.staffId field.
    /// </param>
    /// <param name="_storeRecId">
    /// RecID of the RetailStaffLoginLog.storeId field.
    /// </param>
    /// <param name="_terminalRecId">
    /// RecID of the RetailStaffLoginLog.terminalId field.
    /// </param>
    /// <param name="_password">
    /// <c>RetailStaffPassword</c>
    /// </param>
    /// <param name="_loginToStore">
    /// True to login to a store, false to login without store association
    /// </param>
    /// <param name="_skipPasswordValidation">
    /// A value indicating whether password validation must not be performed.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to create/update.
    /// </exception>
    public static container retailServerStaffLogOn(RetailStaffId _staffId, RetailChannelRecId _storeRecId, RefRecId _terminalRecId, RetailStaffPassword _password, boolean _loginToStore=true, boolean _skipPasswordValidation = false)
    {
        return RetailTransactionServiceEmployee::retailServerStaffLogOn(_staffId, _storeRecId, _terminalRecId, _password, _loginToStore, _skipPasswordValidation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchCustomerOrderList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Search for customer sales orders.
    /// </summary>
    /// <param name="_custTerm">
    /// The customer name search term.
    /// </param>
    /// <param name="_orderTerm">
    /// The order search term.
    /// </param>
    /// <param name="_fromDate">
    /// The date to search from.
    /// </param>
    /// <param name="_toDate">
    /// The date to search to.
    /// </param>
    /// <param name="_resultsMaxCount">
    /// The maximum amount of rows to return (default is 100).
    /// </param>
    /// <returns>
    /// Container with the success, error and results.
    /// </returns>
    /// <remarks>
    /// Searches for sales orders using the given search terms/criteria
    /// </remarks>
    [SysObsolete('We only keep it for backward compatibility for customers using EPOS.', false, 26\08\2022)]
    public static container searchCustomerOrderList(str _custTerm, str _orderTerm, str _fromDate, str _toDate, int _resultsMaxCount = 100)
    {
        return RetailTransactionServiceOrders::searchCustomerOrderList(_custTerm, _orderTerm, _fromDate, _toDate, _resultsMaxCount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchCustomers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a keyword search of customers,
    /// and returns a list of customers matching the search terms provided.
    /// </summary>
    /// <param name="_searchString">
    /// A string of keywods to be searched (space delimited). To use this string
    /// in a query, it is constrained to a max length of 255 characters.
    /// </param>
    /// <param name="_recordsToSkip">
    /// The number of results to skip over before we start returning them.
    /// </param>
    /// <param name="_recordsToGet">
    /// The number of results to return.
    /// </param>
    /// <returns>
    /// A container containing an array of global customers in XML.
    /// </returns>
    public static container searchCustomers(str 255 _searchString, int _recordsToSkip = 0, int _recordsToGet = 50)
    {
        return RetailTransactionServiceCustomer::searchCustomers(_searchString, _recordsToSkip, _recordsToGet);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderListSearch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns a list of retail transactions that match the passed in criteria.
    /// </summary>
    /// <param name="_xmlArgumentString">
    /// XML arguments.
    /// </param>
    /// <returns>
    /// A list of orders that match all of the criteria parameters.
    /// </returns>
    /// <remarks>
    /// Xml argument example:
    /// <Arguments>
    ///  <CustomerAccountNumber/>
    ///  <CustomerName/>
    ///  <EmailAddress/>
    ///  <ReceiptEmailAddress/>
    ///  <SalesId />
    ///  <ReceiptId/>
    ///  <OrderStatus />
    ///  <DocumentStatus />
    ///  <StartDateTime/>
    ///  <EndDateTime/>
    ///  <StoreId/>
    ///  <OrderType />
    ///  <ChannelReferenceId/>
    ///  <ChannelIds/>
    ///  <BusinessPartnerId/>
    ///  <CustomerRequisition/>
    ///
    ///  <LimitTransactionType/>
    ///  <TransactionId/>
    ///  <IncludeDetails/>
    ///
    ///  <PagingInfo>
    ///    <Skip/>
    ///    <Top/>
    ///  </PagingInfo>
    ///</Arguments>
    /// </remarks>
    public static container getOrderListSearch(str _xmlArgumentString)
    {
        return RetailTransactionServiceTransactions::getOrderListSearch(_xmlArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchOrderList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns a list of retail transactions that match the passed in criteria.
    /// </summary>
    /// <param name="_transactionId">
    /// TransactionID to match against the RetailTransactionTable.TransactionId field.
    /// </param>
    /// <param name="_salesId">
    /// SalesID to match against the SalesTable.SalesId field.
    /// </param>
    /// <param name="_receiptId">
    /// ReceiptID to match against the RetailTransactionTable.ReceiptId field.
    /// </param>
    /// <param name="_channelRefId">
    /// Channel Reference ID to match against the SalesOrder.ChannelReferenceId field.
    /// </param>
    /// <param name="_custAccount">
    /// Customer Account Number to match against the RetailTransactionTable.CustAccount field.
    /// </param>
    /// <param name="_custFirstName">
    /// First name of customer who is linked to the RetailTransactionTable.
    /// </param>
    /// <param name="_custLastName">
    /// Last name of customer who is linked to the RetailTransactionTable.
    /// </param>
    /// <param name="_storeId">
    /// StoreId to match against the RetailTransactionTable.Store field.
    /// </param>
    /// <param name="_terminalId">
    /// TerminalId to match against the RetailTransactionTable.Terminal field.
    /// </param>
    /// <param name="_itemId">
    /// ItemId to match against the RetailTransactionSalesTrans.ItemId field.
    /// </param>
    /// <param name="_barcode">
    /// Barcode to match against the RetailTransactionSalesTrans.Barcode field.
    /// </param>
    /// <param name="_staffId">
    /// StaffId to match against the RetailTransactionTable.Staff field.
    /// </param>
    /// <param name="_startDate">
    /// RetailTransactionTable.CreatedDateTime field greater than or equal to startDate.
    /// </param>
    /// <param name="_endDate">
    /// RetailTransactionTable.CreatedDateTime field less than or equal to endDate.
    /// </param>
    /// <param name="_includeDetails">
    /// Whether to include all order information including order lines and attributes.
    /// </param>
    /// <param name="_receiptEmailAddress">
    /// ReceiptEmailAddress to match against the RetailTransactionTable.ReceiptEmail field.
    /// </param>
    /// <param name="_seachIdentifiers">
    /// SeachIdentifiers to math against the RetailTransactionTable with the following fields
    /// TransactionId
    /// ReceiptId
    /// SalesId
    /// CustomerAccount
    /// ChannelRefId
    /// </param>
    /// <param name="_resultsMaxCount">
    /// The maximum amount of rows to return (default is 20).
    /// </param>
    /// <param name="_retailTransactionTypes">
    /// Transaction types to be returned.
    /// </param>
    /// <param name="_serialNumber">
    /// SerialNumber to match against the RetailTransactionSalesTrans.InventSerialId field.
    /// </param>
    /// <param name="_transactionStatusTypes">
    /// Transaction's entry status to match against the RetailTransactionTable.EntryStatus field.
    /// </param>
    /// <param name="_includeNonTransactions">
    /// Whether or not to include non-transaction records (ie, records from SalesTable).  TRUE by default.
    /// </param>
    /// <returns>
    /// A list of orders that match all of the criteria parameters.
    /// </returns>
    [SysObsolete('Use method getOrderListSearch() instead', false, 31\01\2016)]
    public static container searchOrderList(RetailTransactionId _transactionId,
                                            SalesId _salesId,
                                            RetailReceiptId _receiptId,
                                            RetailOrderChannelReferenceId _channelRefId,
                                            CustAccount _custAccount,
                                            str _custFirstName,
                                            str _custLastName,
                                            RetailStoreId _storeId,
                                            RetailTerminalId _terminalId,
                                            RetailItemId _itemId,
                                            RetailBarcode _barcode,
                                            RetailStaffId _staffId,
                                            str _startDate,
                                            str _endDate,
                                            boolean _includeDetails,
                                            RetailReceiptEmail _receiptEmailAddress = '',
                                            String50 _seachIdentifiers = '',
                                            int _resultsMaxCount = #resultsCountOfTransaction,
                                            str _retailTransactionTypes = '',
                                            InventSerialId _serialNumber = '',
                                            str _transactionStatusTypes = '',
                                            boolean _includeNonTransactions = true)
    {
        return RetailTransactionServiceTransactions::searchOrderList(_transactionId,
                                                                     _salesId,
                                                                     _receiptId,
                                                                     _channelRefId,
                                                                     _custAccount,
                                                                     _custFirstName,
                                                                     _custLastName,
                                                                     _storeId,
                                                                     _terminalId,
                                                                     _itemId,
                                                                     _barcode,
                                                                     _staffId,
                                                                     _startDate,
                                                                     _endDate,
                                                                     _includeDetails,
                                                                     _receiptEmailAddress,
                                                                     _seachIdentifiers,
                                                                     _resultsMaxCount,
                                                                     _retailTransactionTypes,
                                                                     _serialNumber,
                                                                     _transactionStatusTypes,
                                                                     _includeNonTransactions);
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchSalesTransactionsByReceiptId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns a list of retail transactions that match the passed in receipt identifier.
    /// </summary>
    /// <param name="_xmlArgumentString">
    /// XML arguments.
    /// </param>
    /// <returns>
    /// A list of orders that match the given receipt identifier.
    /// </returns>
    /// <remarks>
    /// Xml argument example:
    /// <Arguments>
    ///  <ReceiptId/>
    ///  <DataAreaId />
    ///  <PagingInfo>
    ///    <Skip/>
    ///    <Top/>
    ///  </PagingInfo>
    ///</Arguments>
    /// </remarks>
    public static container searchSalesTransactionsByReceiptId(str _xmlArgumentString)
    {
        return RetailTransactionServiceTransactions::searchSalesTransactionsByReceiptId(_xmlArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendEmails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Send emails using the specified emailMessageCollectionXml.
    /// </summary>
    /// <param name="emailMessageCollectionXml">
    /// XML document containing the email messages contents, recipient email addresses, sender email addresses and
    /// the message properties, priority and batch group id.
    /// </param>
    /// <returns>A <c>Container</c> containing result info.</returns>
    public static container sendEmails(str emailMessageCollectionXml)
    {
       return RetailTransactionServiceCustomer::sendEmails(emailMessageCollectionXml);
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendEmail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Send an email using the specified template.
    /// </summary>
    /// <param name="emailId">
    /// The SysEmailMessageTable EmailId.
    /// </param>
    /// <param name="languageId">
    /// The Langauge of the email.
    /// </param>
    /// <param name="email">
    /// The Email Address to send to.
    /// </param>
    /// <param name="serializedMappings">
    /// The mappings to use in the substitution of tokens in the message.
    /// </param>
    /// <param name="xmlData">
    /// The xml data to use in the transform of the message.
    /// </param>
    /// <param name="isTraceable">
    /// Is the email traced.
    /// </param>
    /// <param name="isWithRetries">
    /// Should the email be retried.
    /// </param>
    /// <returns>
    /// Container with the success and error.
    /// </returns>
    /// <remarks>
    /// Schedules an email to be sent by the email distribution batch job.
    /// </remarks>
    public static container sendEmail(SysEmailId emailId, CustLanguageId languageId, Email email, str serializedMappings, str xmlData, boolean isTraceable, boolean isWithRetries)
    {
        str error = "@RET2445";
        boolean queueSuccessful = false;
        int fromLine;
        XmlDocument mappingsXml;
        XmlElement  xmlMappingRoot;
        XmlElement  xmlMapping;
        XmlElement  xmlMappingName;
        XmlElement  xmlMappingValue;
        Map mappings;
        str name;
        str value;
        SysEmailParameters emailParameters;

        try
        {
            fromLine = Global::infologLine();

            if (serializedMappings)
            {
                mappings = new Map(Types::String, Types::String);

                mappingsXml = new XmlDocument();
                mappingsXml.loadXml(serializedMappings);

                xmlMappingRoot = mappingsXml.documentElement();

                xmlMapping = xmlMappingRoot.firstChild();
                while (xmlMapping != null)
                {
                    xmlMappingName = xmlMapping.getNamedElement('Name');
                    xmlMappingValue = xmlMapping.getNamedElement('Value');

                    // If there's no key name, we skip this name/value pair.
                    if (xmlMappingName != null)
                    {
                        name = xmlMappingName.text();

                        if (xmlMappingValue != null)
                        {
                            value = xmlMappingValue.text();
                        }
                        else
                        {
                            // Explicitly clear this value; otherwise, we would
                            // end up using the value from the previous iteration.
                            value = '';
                        }

                        mappings.insert(name, value);
                    }

                    xmlMapping = xmlMapping.nextSibling();
                }
            }

            queueSuccessful = true;

            // SMTP server is same even across different companies.
            select firstonly SMTPRelayServerName from emailParameters;

            // Do not send email if SMTP server is not configured.
            if (emailParameters.SMTPRelayServerName != '')
            {
                SysEmailTable::sendMail(emailId, languageId, email, mappings, '', xmlData, isTraceable, '', isWithRetries);
            }
        }
        catch (Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            ApplicationEventSource::EventWriteRetailTransactionServiceFailure(funcName(), error);

        }

        // Returning the status as a container
        return [queueSuccessful, error];
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxInformationForJournalLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets India tax information of journal lines based on the set up on retail store.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record to be updated.
    /// </param>
    /// <param name="_storeId">
    /// The specific retail store Id.
    /// </param>
    public static void setTaxInformationForJournalLine_IN(LedgerJournalTrans _ledgerJournalTrans, RetailStoreId _storeId)
    {
        LedgerJournalTransTaxExtensionIN    ledgerJournalTransTaxExtensionIN;
        TransTaxInformation                 transTaxInformation;

        if (_ledgerjournaltrans.RecId)
        {
            ttsBegin;
            transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(_ledgerJournalTrans, true);
            transTaxInformation.CompanyLocation  = InventLocation::getDefaultLogisticsLocation_IN(RetailStoreTable::find(_storeId).inventLocation, LogisticsLocationRoleType::Delivery).RecId;
            TransTaxInformationHelper::initFromCompanyLocation(transTaxInformation);
            TransTaxInformationHelper::initFromTaxInformation(transTaxInformation);
            transTaxInformation.update();

            ledgerJournalTransTaxExtensionIN        = LedgerJournalTransTaxExtensionIN::findByLedgerJournalTrans(_ledgerJournalTrans.RecId, true);
            if (!ledgerJournalTransTaxExtensionIN)
            {
                ledgerJournalTransTaxExtensionIN.LedgerJournalTrans = _ledgerJournalTrans.RecId;
                ledgerJournalTransTaxExtensionIN.insert();
            }
            else
            {
                ledgerJournalTransTaxExtensionIN.update();
            }
            ttsCommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Settle a customer order
    /// </summary>
    /// <param name="custOrderXmlStr">
    /// XML document for the order
    /// </param>
    /// <returns>
    /// container [success, error]
    /// </returns>
    /// <remarks>
    /// Settles a customer order after pickup
    /// </remarks>
    public static container settleCustomerOrder(str custOrderXmlStr)
    {
        return RetailTransactionServiceOrders::settleCustomerOrder(CustomerOrderInfo::FromXml(custOrderXmlStr));
    }

]]></Source>
			</Method>
			<Method>
				<Name>staffChangePassword</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for updating the RetailStaffLoginLog.staffId with the value in <c>_staffId</c> if the record exists in <c>RetailStaffLoginLog</c>;
    /// else creates the record in <c>RetailStaffLoginLog</c>table.
    /// </summary>
    /// <param name="_staffId">
    /// ID of the RetailStaffLoginLog.staffId field.
    /// </param>
    /// <param name="_oldPassword">
    /// ID of the RetailStaffLoginLog.storeId field.
    /// </param>
    /// <param name="_newPassword">
    /// ID of the RetailStaffLoginLog.terminalId field.
    /// </param>
    /// <param name="changePassword">
    /// A flag indicating if the user has to change the password at next POS login.
    /// </param>
    /// <param name="_loginToStore">
    /// Boolean set to true to login to a particular store, set to false to login with only staffId and Password
    /// </param>
    /// <param name="_channelId">
    /// The channel or store requesting the data package.
    /// </param>
    /// <param name="_useLegacyPasswordHash">
    /// A value indicating whether to use the legacy password hash.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to create/update.
    /// </exception>
    public static container staffChangePassword(RetailStaffId _staffId, RetailStaffPassword _oldPassword, RetailStaffPassword _newPassword, boolean changePassword, boolean _loginToStore = true, RecId _channelId = 0, boolean _useLegacyPasswordHash = false)
    {
        return RetailTransactionServiceEmployee::staffChangePassword(_staffId, _oldPassword, _newPassword, changePassword, _loginToStore, _channelId, _useLegacyPasswordHash);
    }

]]></Source>
			</Method>
			<Method>
				<Name>staffIsPasswordValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns true if the <c>_password</c> is equal to <c>_realPassword</c>; else false.
    /// </summary>
    /// <param name="_password">
    /// <c>RetailStaffPassword</c>
    /// </param>
    /// <param name="_realPassword">
    /// <c>RetailStaffPassword</c>
    /// </param>
    /// <returns>
    /// true if the <c>_password</c> is equal to <c>_realPassword</c>; else false.
    /// </returns>
    public static boolean staffIsPasswordValid(RetailStaffPassword _password, RetailStaffPassword _realPassword)
    {
        return RetailTransactionServiceEmployee::staffIsPasswordValid(_password, _realPassword);
    }

]]></Source>
			</Method>
			<Method>
				<Name>staffIsPasswordValidForStaff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for validating if password is correct for a particular staff Id.
    /// </summary>
    /// <param name="_staffId">
    /// <c>RetailStaffId</c>
    /// </param>
    /// <param name="_password">
    /// <c>RetailStaffPassword</c>
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to create/update.
    /// </exception>
    public static container staffIsPasswordValidForStaff(RetailStaffId _staffId, RetailStaffPassword _password)
    {
        return RetailTransactionServiceEmployee::staffIsPasswordValidForStaff(_staffId, _password);
    }

]]></Source>
			</Method>
			<Method>
				<Name>staffLogOff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method deletes the record from <c>RetailStaffLoginLog</c> table.
    /// </summary>
    /// <param name="_staffId">
    /// ID of the RetailStaffLoginLog.staffId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailStaffLoginLog.storeId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailStaffLoginLog.terminalId field.
    /// </param>
    /// <param name="_logoffFromStore">
    /// Boolean logintostore. True to log-off from particular store/terminal.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to delete.
    /// </exception>
    public static container staffLogOff(RetailStaffId _staffId, RetailStoreId _storeId, RetailTerminalId _terminalId, boolean _logoffFromStore = true)
    {
        return RetailTransactionServiceEmployee::staffLogOff(_staffId, _storeId, _terminalId, _logoffFromStore);
    }

]]></Source>
			</Method>
			<Method>
				<Name>staffLogOn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for updating the RetailStaffLoginLog.staffId with the value in <c>_staffId</c> if the record exists in <c>RetailStaffLoginLog</c>;
    /// else creates the record in <c>RetailStaffLoginLog</c>table.
    /// </summary>
    /// <param name="_staffId">
    /// ID of the RetailStaffLoginLog.staffId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailStaffLoginLog.storeId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailStaffLoginLog.terminalId field.
    /// </param>
    /// <param name="_password">
    /// <c>RetailStaffPassword</c>
    /// </param>
    /// <param name="_loginToStore">
    /// Boolean set to true to login to a particular store, set to false to login with only staffId and Password
    /// </param>
    /// <param name="_skipPasswordValidation">
    /// A value indicating whether password validation must not be performed.
    /// </param>
    /// <param name="_useLegacyPasswordHash">
    /// A value indicating whether to use the legacy password hash.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to create/update.
    /// </exception>
    public static container staffLogOn(RetailStaffId _staffId, RetailStoreId _storeId, RetailTerminalId _terminalId, RetailStaffPassword _password, boolean _loginToStore = true, boolean _skipPasswordValidation = false, boolean _useLegacyPasswordHash = false)
    {
        return RetailTransactionServiceEmployee::staffLogOn(_staffId, _storeId, _terminalId, _password, _loginToStore, _skipPasswordValidation, _useLegacyPasswordHash);
    }

]]></Source>
			</Method>
			<Method>
				<Name>startBreak</Name>
				<Source><![CDATA[
    /// <summary>
    /// Registers break for the worker specified.
    /// </summary>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker.
    /// </param>
    /// <param name="_terminalId">
    /// Terminal id, where time registration is made.
    /// </param>
    /// <param name="_breakJobId">
    /// The job id of the break.
    /// </param>
    /// <returns>
    /// A container having information whether registration is successful.
    /// </returns>
    /// <remarks>
    /// With the job id we can specify the kind of break (e.g. break for lunch, break from work etc.).
    /// Currently, any kind of break can be added in JmgIpcActivity table.
    /// </remarks>
    public static container startBreak(HcmPersonnelNumberId _personnelNumber, RetailTerminalId _terminalId, JmgJobId _breakJobId)
    {
        return RetailTransactionServiceEmployee::startBreak(_personnelNumber, _terminalId, _breakJobId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateApplicationVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the client application version of a device.
    /// </summary>
    /// <param name="deviceId">
    /// The identifier of the Device.
    /// </param>
    /// <param name="appVersion">
    /// The application version.
    /// </param>
    /// <returns>
    /// A container object containing status of updating application version, error message (if any)
    /// </returns>
    public static container updateApplicationVersion(RetailDeviceId deviceId, str appVersion = "")
    {
        RetailDevice device;
        container updateAppVersionResponse = [false, ""]; // Status, ErrorMsg

        ttsbegin;
        device = retailDevice::find(deviceId, true);

        if (device != null)
        {
            try
            {
                // Updates the current client application version of the device into RetailDevice table
                appVersion = strLRTrim(appVersion);
                if (appVersion != '')
                {
                    device.CurrentVersion = appVersion;
                    device.update();
                    ttscommit;
                }
                else
                {
                    ApplicationEventSource::EventWriteRetailTransactionServiceInfoLog(funcName(), 'Input application version is empty.');
                    ttsabort;
                }

                updateAppVersionResponse = [true, ""];
            }
            catch
            {
                updateAppVersionResponse = [false, "@Retail:RetailUpdateApplicationVersionFailed"];
                ttsabort;
            }
        }
        else
        {
            // Device is not found
            updateAppVersionResponse = [false, "@REX30"];
            ApplicationEventSource::EventWriteRetailTransactionServiceWarning(funcName(), 'Invalid device id.');
            ttsabort;
        }

        return updateAppVersionResponse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update address
    /// </summary>
    /// <param name="addressRecId">
    /// Address RecId
    /// </param>
    /// <param name="custName">
    /// Customer Name
    /// </param>
    /// <param name="street">
    /// Street
    /// </param>
    /// <param name="city">
    /// City
    /// </param>
    /// <param name="county">
    /// County
    /// </param>
    /// <param name="state">
    /// State
    /// </param>
    /// <param name="zip">
    /// Zip
    /// </param>
    /// <param name="country">
    /// Country
    /// </param>
    /// <param name="phone">
    /// Phone
    /// </param>
    /// <param name="email">
    /// Email
    /// </param>
    /// <param name="url">
    /// URL
    /// </param>
    /// <param name="taxGroup">
    /// Tax group
    /// </param>
    /// <param name="role">
    /// Role
    /// </param>
    /// <param name="phoneRecId">
    /// Phone RecId
    /// </param>
    /// <param name="emailRecId">
    /// Email RecId
    /// </param>
    /// <param name="urlRecId">
    /// URL RecId
    /// </param>
    /// <param name="streetNumber">
    /// Street Number
    /// </param>
    /// <param name="districtName">
    /// District Name
    /// </param>
    /// <param name="buildingCompliment">
    /// Building Complement
    /// </param>
    /// <param name="makePostalAddressPrimary">
    /// Optional. True if this should become the new primary address
    /// </param>
    /// <param name="custPartyNumber">
    /// The customer party number.
    /// </param>
    /// <returns>
    /// A container with entity keys
    /// </returns>
    /// <remarks>
    /// Original parameter list consisted of a single _paramList parameter of type container.
    /// </remarks>
    public static container updateAddress(  RefRecId                    addressRecId,
                                            CustName                    custName,
                                            AddressStreet               street,
                                            AddressCity                 city,
                                            AddressCountyId             county,
                                            AddressStateId              state,
                                            AddressZipCodeId            zip,
                                            AddressCountryRegionId      country,
                                            Phone                       phone,
                                            LogisticsElectronicAddressLocator  email,
                                            URL                         url,
                                            TaxGroup                    taxGroup,
                                            LogisticsLocationRoleType   role,
                                            int64                       phoneRecId,
                                            int64                       emailRecId,
                                            int64                       urlRecId,
                                            LogisticsAddressStreetNumber        streetNumber        = '',
                                            LogisticsAddressDistrictName        districtName        = '',
                                            LogisticsAddressBuildingCompliment  buildingCompliment  = '',
                                            boolean                     makePostalAddressPrimary    = false,
                                            RecId                       custPartyNumber             = 0)
    {
        return RetailTransactionServiceCustomer::updateAddress(
            addressRecId,
            custName,
            street,
            city,
            county,
            state,
            zip,
            country,
            phone,
            email,
            url,
            taxGroup,
            role,
            phoneRecId,
            emailRecId,
            urlRecId,
            streetNumber,
            districtName,
            buildingCompliment,
            makePostalAddressPrimary,
            custPartyNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>upsertCustomerContacts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Upsert customer contacts.
    /// </summary>
    /// <param name = "_custTableRecId">
    /// The RecId of CustTable.
    /// </param>
    /// <param name = "_serializedContacts">
    /// The serialized list of <c>ContactInfo</c> in JSON format.
    /// </param>
    /// <returns>
    /// The serialized list of updated <c>ContactInfo</c> in JSON format.
    /// </returns>
    public static container upsertCustomerContacts(RecId _custTableRecId, str _serializedContacts)
    {
        return RetailTransactionServiceCustomer::upsertCustomerContacts(_custTableRecId, _serializedContacts);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateChannelPublishingStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Update the publishing status of a channel
    /// </summary>
    /// <param name="_channelId">
    ///     Channel Id
    /// </param>
    /// <param name="_publisingStatus">
    ///     New publishing status
    /// </param>
    /// <param name="_publisingStatusMessage">
    ///     The publishing status message
    /// </param>
    /// <returns>
    ///     A container which stores a Boolean result and the update result message in the following format
    ///     [result, message]
    /// </returns>
    public static container updateChannelPublishingStatus(
        RefRecId _channelId,
        RetailOnlineChannelPublishStatusType _publisingStatus,
        RetailOnlineChannelPublishStatusMessage _publisingStatusMessage = '')
    {
        boolean result = false;
        str message;
        RetailOnlineChannelPublishStatus publishingStatus;

        if (_channelId)
        {
            ttsbegin;
            publishingStatus = RetailOnlineChannelPublishStatus::findByChannel(_channelId, true);

            if (publishingStatus)
            {
                if (publishingStatus.canTransiteTo(_publisingStatus))
                {
                    publishingStatus.PublishStatus = _publisingStatus;
                    publishingStatus.PublishStatusMessage = _publisingStatusMessage;
                    publishingStatus.update();
                    result = true;
                }
                else
                {
                    message = strFmt("@RET490084", _channelId, enum2Value(_publisingStatus));
                }
            }
            else
            {
                message = strFmt("@RET490085", _channelId);
            }
            ttscommit;
        }
        else
        {
            message = "@RET490088";
        }

        return [result, message];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCreditMemo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for updating the record in <c>RetailCreditVoucherTable</c>.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailCreditVoucherTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailCreditVoucherTable.createdInStoreId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailCreditVoucherTable.createdByTerminalId field.
    /// </param>
    /// <param name="_staffId">
    /// ID of the RetailCreditVoucherTable.createdByStaffId field.
    /// </param>
    /// <param name="_transactionId">
    /// ID of the RetailCreditVoucherTable.createdByTransactionId field.
    /// </param>
    /// <param name="_receiptId">
    /// ID of the RetailCreditVoucherTable.createdByReceipId field.
    /// </param>
    /// <param name="_lineNum">
    /// ID of the RetailCreditVoucherTable.createdByLineNum field.
    /// </param>
    /// <param name="_amountMST">
    /// Value for the RetailCreditVoucherTable.amount field.
    /// </param>
    /// <param name="_transDate">
    /// Value for the RetailCreditVoucherTable.transDate field.
    /// </param>
    /// <param name="_transTime">
    /// Value for the RetailCreditVoucherTable.transTime field.
    /// </param>
    /// <param name="_dateSequence">
    /// Format of the date.
    /// </param>
    /// <returns>
    /// <c>Container</c>
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container updateCreditMemo(RetailCreditVoucherId  _dataEntryId,
                                             RetailStoreId          _storeId,
                                             RetailTerminalId       _terminalId,
                                             RetailStaffId          _staffId,
                                             RetailTransactionId    _transactionId,
                                             RetailReceiptId        _receiptId,
                                             RetailLineNum          _lineNum,
                                             AmountMST              _amountMST,
                                             str                    _transDate,//RBOTransDate     _transDate,
                                             str                    _transTime,//RetailTransTime     _transTime)
                                             int                    _dateSequence = 321)
    {
        return RetailTransactionServiceTransactions::updateCreditMemo(
            _dataEntryId,
            _storeId,
            _terminalId,
            _staffId,
            _transactionId,
            _receiptId,
            _lineNum,
            _amountMST,
            _transDate,
            _transTime,
            _dateSequence);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for updating an existing customer.
    /// </summary>
    /// <param name="custTableRecId">
    /// CustTable RecId.
    /// </param>
    /// <param name="custName">
    /// Customer Name.
    /// </param>
    /// <param name="custGroup">
    /// Customer group
    /// </param>
    /// <param name="currency">
    /// Currency
    /// </param>
    /// <param name="languageId">
    /// Language ID
    /// </param>
    /// <param name="phone">
    /// Phone
    /// </param>
    /// <param name="phoneRecId">
    /// Phone recid
    /// </param>
    /// <param name="cellularPhone">
    /// Cell phone
    /// </param>
    /// <param name="email">
    /// Email
    /// </param>
    /// <param name="emailRecId">
    /// Email recid
    /// </param>
    /// <param name="url">
    /// URL
    /// </param>
    /// <param name="urlRecId">
    /// Url recid
    /// </param>
    /// <param name="multiLineDisc">
    /// Multiline discount
    /// </param>
    /// <param name="endDisc">
    /// End discount
    /// </param>
    /// <param name="lineDisc">
    /// Line discount
    /// </param>
    /// <param name="priceGroup">
    /// Price Group
    /// </param>
    /// <param name="taxGroup">
    /// Tax Group
    /// </param>
    /// <param name="creditMax">
    /// Credit Max
    /// </param>
    /// <param name="blocked">
    /// Blocked
    /// </param>
    /// <param name="orgId">
    /// Org ID
    /// </param>
    /// <param name="usePurchRequest">
    /// Use purchase request
    /// </param>
    /// <param name="vatNum">
    /// Vat Number
    /// </param>
    /// <param name="invoiceAccount">
    /// Invoice account
    /// </param>
    /// <param name="mandatoryCreditLimit">
    /// Mandotory credit limit
    /// </param>
    /// <param name="contactPersonId">
    /// Contact person ID
    /// </param>
    /// <param name="useOrderNumberReference">
    /// Use order number reference
    /// </param>
    /// <param name="receiptOption">
    /// Receipt option
    /// </param>
    /// <param name="receiptEmail">
    /// Receipt Email
    /// </param>
    /// <param name="identificationNumber">
    /// Identification Number
    /// </param>
    /// <param name="firstName">
    /// First name
    /// </param>
    /// <param name="middleName">
    /// Middle name
    /// </param>
    /// <param name="lastName">
    /// Last name
    /// </param>
    /// <param name="phoneExtension">
    /// Phone extension
    /// </param>
    /// <param name="cellphoneRecId">
    /// Cell phone record id
    /// </param>
    /// <param name="retailCustAffiliations">
    /// A XML string having the details of customer affiliation list
    /// </param>
    /// <param name="customerAttributes">
    /// A XML string containing the customer attributes
    /// </param>
    /// <param name="channelId">
    /// Optional. The store channel identifier.
    /// </param>
    /// <param name="custAttributesDataPackageVersion">
    /// Optional. The customer attributes data package version.
    /// </param>
    /// <returns>
    /// Results in container.
    /// </returns>
    /// <remarks>This method has been deprecated in favor of updateCustomerExt3.</remarks>
    public static container updateCustomer( int64                       custTableRecId,
                                            DirPartyName                custName,
                                            CustGroupId                 custGroup,
                                            CustCurrencyCode            currency,
                                            CustLanguageId              languageId,
                                            Phone                       phone,
                                            int64                       phoneRecId,
                                            PhoneMobile                 cellularPhone,
                                            LogisticsElectronicAddressLocator  email,
                                            int64                       emailRecId,
                                            URL                         url,
                                            int64                       urlRecId,
                                            CustMultiLineDiscCode       multiLineDisc,
                                            CustEndDiscCode             endDisc,
                                            CustLineDiscCode            lineDisc,
                                            CustPriceGroup              priceGroup,
                                            TaxGroup                    taxGroup,
                                            CustCreditMaxMST            creditMax,
                                            CustBlocked                 blocked,
                                            OrgId                       orgId,
                                            RetailUsePurchRequest       usePurchRequest,
                                            VATNum                      vatNum,
                                            CustInvoiceAccount          invoiceAccount,
                                            MandatoryCreditLimit        mandatoryCreditLimit,
                                            ContactPersonId             contactPersonId,
                                            RetailUseOrderNumberReference  useOrderNumberReference,
                                            RetailReceiptOption            receiptOption,
                                            RetailReceiptEmail             receiptEmail,
                                            CustIdentificationNumber    identificationNumber,
                                            FirstName firstName = '',
                                            MiddleName middleName = '',
                                            LastName lastName = '',
                                            PhoneLocal phoneExtension = '',
                                            int64 cellphoneRecId = 0,
                                            str retailCustAffiliations = '',
                                            str customerAttributes = '',
                                            int64 channelId = 0,
                                            int custAttributesDataPackageVersion = 1)
    {
        return RetailTransactionServiceCustomer::updateCustomer(
            custTableRecId,
            custName,
            custGroup,
            currency,
            languageId,
            phone,
            phoneRecId,
            cellularPhone,
            email,
            emailRecId,
            url,
            urlRecId,
            multiLineDisc,
            endDisc,
            lineDisc,
            priceGroup,
            taxGroup,
            creditMax,
            blocked,
            orgId,
            usePurchRequest,
            vatNum,
            invoiceAccount,
            mandatoryCreditLimit,
            contactPersonId,
            useOrderNumberReference,
            receiptOption,
            receiptEmail,
            identificationNumber,
            firstName,
            middleName,
            lastName,
            phoneExtension,
            cellphoneRecId,
            retailCustAffiliations,
            customerAttributes,
            channelId,
            custAttributesDataPackageVersion);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomerOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the customer order.
    /// </summary>
    /// <param name="custOrderXmlStr">
    /// XML string having the details of order to be updated.
    /// </param>
    /// <returns>
    /// A container having the status and sales id of the order updated.
    /// </returns>
    public static container updateCustomerOrder(str custOrderXmlStr)
    {
        return RetailTransactionServiceOrders::updateCustomerOrder(CustomerOrderInfo::FromXml(custOrderXmlStr));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLinkedPaymentsRefundableAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates refundable amounts for the specified payment lines used in a linked refund.
    /// </summary>
    /// <param name="linkedRefundPaymentLinesXml">
    /// The list of payment lines whose refundable amounts is going to be updated.
    /// Example
    /// <LinkedRefundPayments>
    ///   <LinkedRefundPayment>
    ///     <StoreNumber>ST100001</StoreNumber>
    ///     <TerminalId>T001</TerminalId>
    ///     <TransactionId>Trans1001</TransactionId>
    ///     <LineNumber>1</LineNumber>
    ///     <PreviousRefundableAmount>10.00</PreviousRefundableAmount>
    ///     <UpdatedRefundableAmount>5.00</UpdatedRefundableAmount>
    ///   </LinkedRefundPayment>
    /// </LinkedRefundPayments>
    /// </param>
    /// <returns>A container having the status of the operation and error messages if any.</returns>
    public static container updateLinkedPaymentsRefundableAmount(str linkedRefundPaymentLinesXml)
    {
        return RetailTransactionServiceTransactions::updateLinkedPaymentsRefundableAmount(linkedRefundPaymentLinesXml);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomerQuote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates a sales quotation from the given details.
    /// </summary>
    /// <param name="custOrderXmlStr">
    /// XML string having the header, line details and charges associated with the quote to be updated.
    /// </param>
    /// <returns>
    /// A container having the status and quotation id of the quotation updated.
    /// </returns>
    public static container updateCustomerQuote(str custOrderXmlStr)
    {
        return RetailTransactionServiceOrders::updateCustomerQuote(CustomerOrderInfo::FromXml(custOrderXmlStr));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventDimValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the inventory dimension values from the xml document.
    /// </summary>
    /// <param name="inventDim">
    /// Instance of <c>InventDim</c> table.
    /// </param>
    /// <param name="itemInfo">
    /// Item info storing the dimension values.
    /// </param>
    static void updateInventDimValues(InventDim inventDim, ItemInfo itemInfo)
    {
        inventDim.InventSizeId = itemInfo.SizeId;
        inventDim.InventColorId = itemInfo.ColorId;
        inventDim.InventStyleId = itemInfo.StyleId;
        inventDim.ConfigId = itemInfo.ConfigId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventoryJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update an inventory journal document in AX
    /// </summary>
    /// <param name="ijXmlStr">
    /// An XML string with inventory journal line information
    /// </param>
    /// <returns>
    /// A container object with True or False as the first element
    /// </returns>
    /// <remarks>
    /// This method is used to update the counting journal on AX
    /// </remarks>
    public static container updateInventoryJournal(str ijXmlStr)
    {
        return RetailTransactionServiceInventory::updateInventoryJournal(ijXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateIssuedLoyaltyPoints</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the record in <c>RetailLoyaltyMSRCardTrans</c> table for Issued points.
    /// </summary>
    /// <param name="pTransactionId">
    /// ID of the RetailLoyaltyMSRCardTrans.transactionId field.
    /// </param>
    /// <param name="pLineNum">
    /// ID of the RetailLoyaltyMSRCardTrans.loyaltyPointTranslineNum field.
    /// </param>
    /// <param name="pStoreId">
    /// ID of the RetailLoyaltyMSRCardTrans.storeId field.
    /// </param>
    /// <param name="pTerminalId">
    /// ID of the RetailLoyaltyMSRCardTrans.terminalId field.
    /// </param>
    /// <param name="pLoyaltyCardNo">
    /// ID of the RetailLoyaltyMSRCardTable.cardNumber field.
    /// </param>
    /// <param name="pTransDate">
    /// Transaction date for the RetailLoyaltyMSRCardTrans.dateOfIssue field.
    /// </param>
    /// <param name="pDateSequence">
    /// Format of the date.
    /// </param>
    /// <param name="pIssuedPoints">
    /// Loyalty points of the RetailLoyaltyMSRCardTrans.points field.
    /// </param>
    /// <param name="pReceiptId">
    /// ID of the RetailLoyaltyMSRCardTrans.receiptId field.
    /// </param>
    /// <param name="pStaffId">
    /// ID of the RetailLoyaltyMSRCardTrans.staffId field.
    /// </param>
    /// <param name="pTime">
    /// Time value for the RetailLoyaltyMSRCardTrans.timeOfIssue field.
    /// </param>
    /// <returns>
    /// Container with the true and string message if the record is created in <c>RetailLoyaltyMSRCardTrans</c> table successfully; else false with
    /// appropriate string message.
    /// </returns>
    public static container updateIssuedLoyaltyPoints(  RetailTransactionId    pTransactionId,
                                                        LineNum             pLineNum,
                                                        RetailStoreId          pStoreId,
                                                        RetailTerminalId       pTerminalId,
                                                        RetailCardNumber       pLoyaltyCardNo,
                                                        str                 pTransDate,
                                                        int                 pDateSequence = 123,
                                                        RetailLoyaltyPoints    pIssuedPoints = 0,
                                                        RetailReceiptId        pReceiptId = "",
                                                        RetailStaffId          pStaffId = "",
                                                        str                 pTime = "00:00:00")
    {
        return RetailLoyaltyManager::updateLoyaltyIssuedPoints62(pTransactionId,
                                                            pLineNum,
                                                            pStoreId,
                                                            pTerminalId,
                                                            pLoyaltyCardNo,
                                                            pTransDate,
                                                            pDateSequence,
                                                            pIssuedPoints,
                                                            pReceiptId,
                                                            pStaffId,
                                                            pTime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePickingList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the picking list in Ax.
    /// </summary>
    /// <param name="xmlPickListStr">
    /// An XML string having the details of picking list.
    /// </param>
    /// <returns>
    /// A container having the status of updation.
    /// </returns>
    public static container updatePickingList(str xmlPickListStr)
    {
        return RetailTransactionServiceOrders::updatePickingList(xmlPickListStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchaseOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update a purchase order
    /// </summary>
    /// <param name="poXmlStr">
    /// An XML string for Purchase Order details
    /// </param>
    /// <returns>
    /// A container object to indicate update success or failure
    /// </returns>
    /// <remarks>
    /// This method is used to update a purchase order's receive now quantity
    /// </remarks>
    public static container updatePurchaseOrder(str poXmlStr)
    {
        return RetailTransactionServiceInventory::updatePurchaseOrder(poXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>commitDocumentOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Commit a document operation
    /// </summary>
    /// <param name="requestId">
    /// An unique guid string generated by client
    /// </param>
    /// <param name="operationName">
    /// The operation name 
    /// </param>
    /// <param name="document">
    /// An string for document
    /// </param>
    /// <param name="paramsDictionary">
    /// An string for params dictionary. Should be a valid json string serialized from CLR type Dictionary<string, string> instance.
    /// </param>
    /// <returns>
    /// A container object to indicate update success or failure as well as RequestId, CommitResult and CommitResultDetailCode
    /// </returns>
    /// <remarks>
    /// This method is used to commit a document operation.
    /// </remarks>
    public static container commitDocumentOperation(str requestId, str operationName, str document, str paramsDictionaryJson)
    {
        return RetailTransactionServiceDocumentOperation::commitDocumentOperation(requestId, operationName, document, paramsDictionaryJson);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocumentOperationStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a document operation status
    /// </summary>
    /// <param name="requestId">
    /// An unique guid string generated by client
    /// </param>
    /// <returns>
    /// A container object to indicate update success or failure as well as ResponseDocument, Status and ProcessingErrorCode
    /// </returns>
    /// <remarks>
    /// This method is used to get a document operation status.
    /// </remarks>
    public static container getDocumentOperationStatus(str requestId)
    {
        return RetailTransactionServiceDocumentOperation::getDocumentOperationStatus(requestId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStaffPassword</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates employee password.
    /// </summary>
    /// <param name="staffId">
    /// The staff identifier.
    /// </param>
    /// <param name="password">
    /// The new password.
    /// </param>
    /// <param name="changePassword">
    /// A flag indicating if the user has to change the password at next POS login.
    /// </param>
    /// <param name="passwordUpdateOperation">
    /// The retail authentication operation for password update.
    /// </param>
    /// <param name="channelId">
    /// The channel or store requesting the data package.
    /// </param>
    /// <param name="useLegacyPasswordHash">
    /// A value indicating whether to use the legacy password hash.
    /// </param>
    /// <returns>
    /// A container with the status, error message, password data and password salt.
    /// </returns>
    public static container updateStaffPassword(  str staffId,
                                                  str password,
                                                  int changePassword,
                                                  RetailAuthenticationOperation passwordUpdateOperation = RetailAuthenticationOperation::ResetPassword,
                                                  RecId channelId = 0,
                                                  boolean useLegacyPasswordHash = false)
    {
        #define.ErrorStaffNotFound(1)
        #define.ErrorSavingRecord(2)
        #define.PasswordComplexityValidationFailed(3)
        #define.PasswordHistoryValidationFailed(4)

        container updateStatus = [true,""];
        boolean                     validUpdate    = false;
        int                         fromLine;
        RetailStaffTable            staffTable;
        RetailStaffData             passwordData;
        str                         passwordSalt;
        container                   validatePasswordComplexityResult;
        container                   validatePasswordHistoryResult;
        str                         staffPasswordPackage = '';
        str                         staffPasswordData;

        try
        {
            fromLine = Global::infologLine();

            staffTable  = RetailStaffTable::find(staffId, true);  // Find the staffId for update

            if (staffTable)
            {
                // Check if the new password meets the complexity requirements specified.
                validatePasswordComplexityResult = RetailStaffTable::validatePasswordComplexity(password);

                if (conPeek(validatePasswordComplexityResult, 1))
                {
                    // check if the new password meets the history requirements specified.
                    validatePasswordHistoryResult = RetailStaffTable::validatePasswordHistory(staffId, password);

                    if (conPeek(validatePasswordHistoryResult, 1))
                    {
                        try
                        {
                            ttsbegin;

                            staffTable.Password = password;
                            staffTable.ChangePassword = changePassword;
                            staffTable.PasswordLastChangedDateTime = DateTimeUtil::utcNow();
                            staffTable.PasswordLastUpdatedOperation = passwordUpdateOperation;
                            staffTable.update();

                            ttscommit;

                            if (!useLegacyPasswordHash)
                            {
                                // If this call is from the new clients (version greater than 7.0), send password hash calculated based on the random salt.
                                staffPasswordData = staffTable.passwordData;
                            }
                            else
                            {
                                // If this call is from the old clients (AX 2012), send legacy password hash.
                                staffPasswordData = staffTable.LegacyPasswordData;
                            }

                            // If operation is ResetPassword and channelId exists, add updated password data package to the containier.
                            if (passwordUpdateOperation == RetailAuthenticationOperation::ResetPassword && channelId != 0)
                            {
                                staffPasswordPackage = RetailTransactionServiceEmployee::getStaffPasswordDataPackage(staffId, channelId);
                            }

                            updateStatus = updateStatus + [staffPasswordData, staffTable.passwordSalt, staffTable.PasswordHashAlgorithm, staffTable.PasswordLastChangedDateTime, enum2int(staffTable.PasswordLastUpdatedOperation), staffPasswordPackage, staffTable.LegacyLocalContext, staffTable.LegacyRegKeyData2Value];

                        }
                        catch (Exception::Error)
                        {
                            ttsabort;
                            ApplicationEventSource::EventWriteRetailTransactionServiceFailure(funcName(), RetailTransactionServiceUtilities::getInfologMessages(Global::infologLine()));
                            updateStatus = [false, "@RET2382", #ErrorSavingRecord];
                        }
                    }
                    else
                    {
                        updateStatus = [false, "@SYS4006632" + ":\n" + conPeek(validatePasswordHistoryResult, 2), #PasswordHistoryValidationFailed];
                    }
                }
                else
                {
                    updateStatus = [false, "@SYS4006632" + ":\n" + conPeek(validatePasswordComplexityResult, 2), #PasswordComplexityValidationFailed];
                }
            }
            else
            {
                updateStatus = [false, strFmt("@Retail:InvalidStaffIdError", staffId), #ErrorStaffNotFound];
            }
        }
        catch (Exception::Error)
        {
            ttsabort;
            ApplicationEventSource::EventWriteRetailTransactionServiceFailure(funcName(), RetailTransactionServiceUtilities::getInfologMessages(Global::infologLine()));
            updateStatus = [false, "@RET2382", #ErrorSavingRecord];
        }

        return updateStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransferOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update a transfer order.
    /// </summary>
    /// <param name="toXmlStr">
    /// An Xml string containing details of a transfer order.
    /// </param>
    /// <returns>
    /// A container object to indicate success or failure.
    /// </returns>
    /// <remarks>
    /// This allows updates for transfer order's ship now and receive now quantities.
    /// </remarks>
    public static container updateTransferOrder(str toXmlStr)
    {
        return RetailTransactionServiceInventory::updateTransferOrder(toXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransferOrderLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a list of transfer order lines.
    /// </summary>
    /// <param name="transferOrderLinesXmlStr">
    /// An Xml string containing the list of transfer order lines.
    /// </param>
    /// <returns>
    /// A container object to indicate success or failure.
    /// </returns>
    public static server container createTransferOrderLines(str transferOrderLinesXmlStr)
    {
        return RetailTransactionServiceInventory::createTransferOrderLines(transferOrderLinesXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransferOrderLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates a list of transfer order lines.
    /// </summary>
    /// <param name="transferOrderLinesXmlStr">
    /// An Xml string containing the list of transfer order lines.
    /// </param>
    /// <returns>
    /// A container object to indicate success or failure.
    /// </returns>
    public static server container updateTransferOrderLines(str transferOrderLinesXmlStr)
    {
        return RetailTransactionServiceInventory::updateTransferOrderLines(transferOrderLinesXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTransferOrderLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes a list of transfer order lines.
    /// </summary>
    /// <param name="transferOrderLinesXmlStr">
    /// An Xml string containing the list of transfer order lines.
    /// </param>
    /// <returns>
    /// A container object to indicate success or failure.
    /// </returns>
    public static server container deleteTransferOrderLines(str transferOrderLinesXmlStr)
    {
        return RetailTransactionServiceInventory::deleteTransferOrderLines(transferOrderLinesXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateTransferOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a transfer order or updates it if it exists already.
    /// </summary>
    /// <param name="transferOrderXmlStr">
    /// An Xml string containing details of the transfer order to be created.
    /// </param>
    /// <returns>
    /// A container object to indicate success or failure.
    /// </returns>
    public static server container createOrUpdateTransferOrder(str transferOrderXmlStr)
    {
        return RetailTransactionServiceInventory::createOrUpdateTransferOrder(transferOrderXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTransferOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the specified transfer order.
    /// </summary>
    /// <param name="transferId">
    /// The transfer order Id.
    /// </param>
    /// <returns>
    /// Returns a container in this containing status of the deletion as boolean flag and the error messgae if any delete error occurs.
    /// [operationResultStatusBoolean, errorMessage]
    /// </returns>
    public static server container deleteTransferOrder(InventTransferId transferId)
    {
        return RetailTransactionServiceInventory::deleteTransferOrder(transferId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>confirmPurchaseOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Confirms the approved purchase order.
    /// </summary>
    /// <param name="purchId">
    /// The purch  Id.
    /// </param>
    /// <returns>
    /// Returns a container in this containing status of the confirmation as boolean flag and the error messgae if any confimation error occurs.
    /// [operationResultStatusBoolean, errorMessage]
    /// </returns>
    public static server container confirmPurchaseOrder(PurchId purchId)
    {
        return RetailTransactionServiceInventory::confirmPurchaseOrder(purchId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateUsedLoyaltyPoints</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the record in <c>RetailLoyaltyMSRCardTrans</c> table for Issued points.
    /// </summary>
    /// <param name="pTransactionId">
    /// ID of the RetailLoyaltyMSRCardTrans.transactionId field.
    /// </param>
    /// <param name="pLineNum">
    /// ID of the RetailLoyaltyMSRCardTrans.loyaltyPointTranslineNum field.
    /// </param>
    /// <param name="pStoreId">
    /// ID of the RetailLoyaltyMSRCardTrans.storeId field.
    /// </param>
    /// <param name="pTerminalId">
    /// ID of the RetailLoyaltyMSRCardTrans.terminalId field.
    /// </param>
    /// <param name="pLoyaltyCardNo">
    /// ID of the RetailLoyaltyMSRCardTable.cardNumber field.
    /// </param>
    /// <param name="pTransDate">
    /// Transaction date for the RetailLoyaltyMSRCardTrans.dateOfIssue field.
    /// </param>
    /// <param name="pDateSequence">
    /// Format of the date.
    /// </param>
    /// <param name="pIssuedPoints">
    /// Loyalty points of the RetailLoyaltyMSRCardTrans.points field.
    /// </param>
    /// <param name="pReceiptId">
    /// ID of the RetailLoyaltyMSRCardTrans.receiptId field.
    /// </param>
    /// <param name="pStaffId">
    /// ID of the RetailLoyaltyMSRCardTrans.staffId field.
    /// </param>
    /// <param name="pTime">
    /// Time value for the RetailLoyaltyMSRCardTrans.timeOfIssue field.
    /// </param>
    /// <returns>
    /// Container with the true and string message if the record is created in <c>RetailLoyaltyMSRCardTrans</c> table successfully; else false with
    /// appropriate string message.
    /// </returns>
    public static container updateUsedLoyaltyPoints(  RetailTransactionId    pTransactionId,
                                                        LineNum                pLineNum,
                                                        RetailStoreId          pStoreId,
                                                        RetailTerminalId       pTerminalId,
                                                        RetailCardNumber       pLoyaltyCardNo,
                                                        str                    pTransDate,
                                                        int                    pDateSequence = 123,
                                                        RetailLoyaltyPoints    pIssuedPoints = 0,
                                                        RetailReceiptId        pReceiptId = "",
                                                        RetailStaffId          pStaffId = "",
                                                        str                    pTime = "00:00:00")
    {
        return RetailLoyaltyManager::updateLoyaltyUsedPoints62(pTransactionId,
                                                            pLineNum,
                                                            pStoreId,
                                                            pTerminalId,
                                                            pLoyaltyCardNo,
                                                            pTransDate,
                                                            pDateSequence,
                                                            pIssuedPoints,
                                                            pReceiptId,
                                                            pStaffId,
                                                            pTime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWishList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates a wish list.
    /// </summary>
    /// <param name="wishListXml">
    /// The input xml string containing updated field information.
    /// </param>
    /// <param name="filterAccountNumber">
    /// The filter account number. It is used to check the operation privilege and filter the result content.
    /// Set the value to null to skip filtering.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the update of record is successful and false otherwise.
    /// </returns>
    public static container updateWishList(str wishListXml, AccountNum filterAccountNumber)
    {
        return RetailTransactionServiceWishList::updateWishList(wishListXml, filterAccountNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWishListLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates a wish list line.
    /// </summary>
    /// <param name="wishListLineXml">
    /// The input xml string containing updated field information.
    /// </param>
    /// <param name="filterAccountNumber">
    /// The filter account number. It is used to check the operation privilege and filter the result content.
    /// Set the value to null to skip filtering.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the update of record is successful and false otherwise.
    /// </returns>
    public static container updateWishListLine(str wishListLineXml, AccountNum filterAccountNumber)
    {
        return RetailTransactionServiceWishList::updateWishListLine(wishListLineXml, filterAccountNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>upsertLogisticsElectronicAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts or updates the electronic address based on the locator.
    /// </summary>
    /// <param name="logisticsElectronicAddressRecId">
    /// RecId of LogisticsElectronic address.
    /// </param>
    /// <param name="value">
    /// Value of the loator.
    /// </param>/// <param name="parentLogisticsLocationId">
    /// Value of the Parent location Id.
    /// </param>
    /// <param name="type">
    /// Type of the electronic address.
    /// </param>
    /// <returns>
    /// A container object with Location Id and electronic address id.
    /// </returns>
    public static container upsertLogisticsElectronicAddress(
            RecId logisticsElectronicAddressRecId,
            LogisticsElectronicAddressLocator value,
            LogisticsLocationRecId parentLogisticsLocationId,
            LogisticsElectronicAddressMethodType type)
    {
        return RetailTransactionServiceCustomer::upsertLogisticsElectronicAddress(
            logisticsElectronicAddressRecId,
            value,
            parentLogisticsLocationId,
            type);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCreditMemo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for validating the credit vouchers.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailCreditVoucherTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailCreditVoucherTable.reservedByStoreId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailCreditVoucherTable.reservedByTerminalId field.
    /// </param>
    /// <returns>
    /// <c>Container</c>
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container validateCreditMemo(RetailCreditVoucherId _dataEntryId, RetailStoreId _storeId, RetailTerminalId _terminalId)
    {
        return RetailTransactionServiceTransactions::validateCreditMemo(_dataEntryId, _storeId, _terminalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCustomerStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for checking the status of the customer account i.e.,
    /// 1.Existence of the customer
    /// 2.Blocked/Unblocked
    /// 3.Credit limit
    /// </summary>
    /// <param name="_custAccount">
    /// ID of the CustTable.AccountNum field.
    /// </param>
    /// <param name="_salesAmount">
    /// <c>AmountMST</c>
    /// </param>
    /// <param name="_currencyCode">
    /// <c>CurrencyCode</c>
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to check the status of the customer account.
    /// </exception>
    public static container validateCustomerStatus(CustAccount _custAccount, AmountMST  _salesAmount, CurrencyCode _currencyCode)
    {
        return RetailTransactionServiceCustomer::validateCustomerStatus(_custAccount, _salesAmount, _currencyCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCustomerStatusV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for checking the status of the customer account i.e.,
    /// 1.Existence of the customer
    /// 2.Blocked/Unblocked
    /// 3.Credit limit
    /// </summary>
    /// <param name="_custAccount">
    /// ID of the CustTable.AccountNum field.
    /// </param>
    /// <param name="_salesAmount">
    /// <c>AmountMST</c>
    /// </param>
    /// <param name="_currencyCode">
    /// <c>CurrencyCode</c>
    /// </param>
    /// <param name="_skipCreditLimitCheckAmount">
    /// Amount that should not be considered during credit limit check.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to check the status of the customer account.
    /// </exception>
    public static container validateCustomerStatusV2(CustAccount _custAccount, AmountMST  _salesAmount, CurrencyCode _currencyCode, AmountMST _skipCreditLimitCheckAmount = 0)
    {
        if (RetailOrdersCreditLimitCheckForPickupFlight::instance().isEnabled())
        {
            return RetailTransactionServiceCustomer::validateCustomerStatusV2(_custAccount, _salesAmount, _currencyCode, _skipCreditLimitCheckAmount);
        }
        else
        {
            return RetailTransactionService::validateCustomerStatus(_custAccount, _salesAmount, _currencyCode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCustomerStatusV3</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for checking the status of the customer account i.e.,
    /// 1.Existence of the customer
    /// 2.Blocked/Unblocked
    /// 3.Credit limit
    /// </summary>
    /// <param name="_custAccount">
    /// ID of the CustTable.AccountNum field.
    /// </param>
    /// <param name="_salesAmount">
    /// <c>AmountMST</c>
    /// </param>
    /// <param name="_currencyCode">
    /// <c>CurrencyCode</c>
    /// </param>
    /// <param name="_skipCreditLimitCheckAmount">
    /// Amount that should not be considered during credit limit check.
    /// </param>
    /// <param name="_skipCreditLimitCheckDeliveredAmount">
    /// Delivered amount that should not be considered during credit limit check.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to check the status of the customer account.
    /// </exception>
    public static container validateCustomerStatusV3(CustAccount _custAccount, AmountMST  _salesAmount, CurrencyCode _currencyCode, AmountMST _skipCreditLimitCheckAmount = 0, AmountMST _skipCreditLimitCheckDeliveredAmount = 0)
    {
        if (RetailOrdersCreditLimitCheckForDeliveredPickupFlight::instance().isEnabled())
        {
            return RetailTransactionServiceCustomer::validateCustomerStatusV3(_custAccount, _salesAmount, _currencyCode, _skipCreditLimitCheckAmount, _skipCreditLimitCheckDeliveredAmount);
        }
        else
        {
            return RetailTransactionService::validateCustomerStatusV2(_custAccount, _salesAmount, _currencyCode, _skipCreditLimitCheckAmount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateGiftCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for validating the gift cards.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailGiftCardTable.reservedByStoreId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailGiftCardTable.reservedByTerminalId field.
    /// </param>
    /// <param name="_skipReserveValidation">
    /// Skip gift card reserve validation sign.
    /// </param>
    /// <param name="_channelId">
    /// ID of the RetailGiftCardTable.channel field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    [SysObsolete('Please, use the validateGiftCard2 method instead.', false, 30\06\2018)]
    public static container validateGiftCard(RetailGiftCardId _dataEntryId, RetailStoreId _storeId, RetailTerminalId _terminalId
                                             , boolean _skipReserveValidation = false
                                             , RetailChannelRecId _channelId = 0
    )
    {
        return RetailTransactionService::validateGiftCard2(_dataEntryId, _storeId, _terminalId, _skipReserveValidation, _channelId, '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateGiftCard2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for validating the gift cards.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailGiftCardTable.reservedByStoreId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailGiftCardTable.reservedByTerminalId field.
    /// </param>
    /// <param name="_skipReserveValidation">
    /// Skip gift card reserve validation sign.
    /// </param>
    /// <param name="_channelId">
    /// ID of the RetailGiftCardTable.channel field.
    /// </param>
    /// <param name="_transactionId">
    /// ID of the RetailGiftCardTable.reservedByTransactionId field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container validateGiftCard2(RetailGiftCardId _dataEntryId, RetailStoreId _storeId, RetailTerminalId _terminalId
                                             , boolean _skipReserveValidation = false
                                             , RetailChannelRecId _channelId = 0
                                             , RetailTransactionId _transactionId = ''
    )
    {
        // Get the channel id from storeid if the channelid is not set
        _channelId = RetailTransactionService::getChannelIdFromStoreId(_storeId, _channelId);

        return RetailTransactionServiceTransactions::validateGiftCard(_dataEntryId, _channelId, _terminalId
                                                                      // <GEERU>
                                                                      , _skipReserveValidation
                                                                      // </GEERU>
                                                                      , _transactionId
                                                                      );
    }

]]></Source>
			</Method>
			<Method>
				<Name>voidCreditMemo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used to check the status of the credit voucher i.e., voucher exists or voided or not voided.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailCreditVoucherTable.entryId field.
    /// </param>
    /// <returns>
    /// <c>Container</c>
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container voidCreditMemo(RetailCreditVoucherId _dataEntryId)
    {
        return RetailTransactionServiceTransactions::voidCreditMemo(_dataEntryId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>voidCreditMemoPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method checks for the status of the credit voucher i.e., voucher is in use or the voucher has any errors or the voucher does not exists.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailCreditVoucherTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailCreditVoucherTable.reservedByStoreId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailCreditVoucherTable.reservedByTerminalId field.
    /// </param>
    /// <returns>
    /// <c>Container</c>
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container voidCreditMemoPayment(RetailCreditVoucherId _dataEntryId, RetailStoreId _storeId, RetailTerminalId _terminalId)
    {
        return RetailTransactionServiceTransactions::voidCreditMemoPayment(_dataEntryId, _storeId, _terminalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>voidGiftCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used to check the status of the gift card i.e., card exists or voided or not voided.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container voidGiftCard(RetailGiftCardId _dataEntryId)
    {
        return RetailTransactionServiceTransactions::voidGiftCard(_dataEntryId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>voidGiftCardPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method checks for the status of the gift card i.e., card exists or the gift card has any errors.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailGiftCardTable.reservedByStoreId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailGiftCardTable.reservedByTerminalId field.
    /// </param>
    /// <param name="_channelId">
    /// ID of the RetailGiftCardTable.channel field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container voidGiftCardPayment(RetailGiftCardId _dataEntryId, RetailStoreId _storeId, RetailTerminalId _terminalId, RetailChannelRecId _channelId = 0)
    {
        // Get the channel id from storeid if the channelid is not set
        _channelId = RetailTransactionService::getChannelIdFromStoreId(_storeId, _channelId);

        return RetailTransactionServiceTransactions::voidGiftCardPayment(_dataEntryId, _channelId, _terminalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>voidOrRefundGiftCardPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refunds the amount passed-in to the giftcard associated with the passed-in _cardNumber.
    /// </summary>
    /// <param name = "_cardNumber">
    /// The gift card number associated with this particular transaction.
    /// </param>
    /// <param name = "_storeId">
    /// The Store identifier associated with this transaction.
    /// </param>
    /// <param name = "_terminalId">
    /// The terminal identifier associated with this transaction (e.g., HOUSTON-1).
    /// </param>
    /// <param name = "_transactionId">
    /// The transaction identifier associated with this transaction (e.g., HOUSTON-HOUSTON-1-22).
    /// </param>
    /// <param name = "_amountMST">
    /// The amount that will be refunded to the card number.
    /// </param>
    /// <param name = "_staffId">
    /// The user or staff identifier associated with this transaction (e.g., 000160).
    /// </param>
    /// <param name = "_receiptId">
    /// The receipt identifier associated with this transaction (e.g., STONON-1300004).
    /// </param>
    /// <param name = "_transDate">
    /// The transaction date when this current transaction is taking place.
    /// </param>
    /// <param name = "_transTime">
    /// The transaction time when this current transaction is taking place.
    /// </param>
    /// <param name = "_channelId">
    /// The channel identifier associated with this transaction (e.g., 5637144592).
    /// </param>
    /// <param name = "_dateSequence">
    /// Format of the date.
    /// </param>
    /// <returns>
    /// The gift card status as a container.
    /// </returns>
    public static container voidOrRefundGiftCardPayment(RetailGiftCardId _cardNumber,
                                                        RetailStoreId _storeId,
                                                        RetailTerminalId _terminalId,
                                                        RetailTransactionId _transactionId,
                                                        AmountMST _amountMST,
                                                        RetailStaffId _staffId,
                                                        RetailReceiptId _receiptId,
                                                        str _transDate,
                                                        str _transTime,
                                                        RetailChannelRecId _channelId,
                                                        int _dateSequence = 321)
    {
        // Get the channel id from storeid if the channelid is not set
        _channelId = RetailTransactionService::getChannelIdFromStoreId(_storeId, _channelId);

        return RetailTransactionServiceTransactions::VoidOrRefundGiftCardPayment(_cardNumber,
            _channelId,
            _terminalId,
            _transactionId,
            _amountMST,
            _staffId,
            _receiptId,
            _transDate,
            _transTime,
            _dateSequence);
    }

]]></Source>
			</Method>
			<Method>
				<Name>AcceptWishListInvitation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Accepts an wish list invitation.
    /// </summary>
    /// <param name="token">
    /// The invitation token.
    /// </param>
    /// <param name="customerAccount">
    /// The customer account who accepts the invitation.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the update of record is successful and false otherwise.
    /// </returns>
    public static container AcceptWishListInvitation(str token, CustAccount customerAccount)
    {
        return RetailTransactionServiceWishList::AcceptWishListInvitation(token, customerAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>CopyWishListLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies wish list lines to another list.
    /// </summary>
    /// <param name="wishListLinesXml">
    /// The input xml containing the lines to copy.
    /// </param>
    /// <param name="destinationWishList">
    /// The id of the destination wish list.
    /// </param>
    /// <param name="filterAccountNumber">
    /// The filter account number. It is used to check the operation privilege and filter the result content.
    /// Set the value to null to skip filtering.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the update of record is successful and false otherwise.
    /// </returns>
    /// <remarks>
    /// The lines can come from different lists.
    /// </remarks>
    public static container CopyWishListLines(str wishListLinesXml, recid destinationWishList, AccountNum filterAccountNumber)
    {
        return RetailTransactionServiceWishList::CopyWishListLines(wishListLinesXml, destinationWishList, filterAccountNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>CreateWishListContributors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates contributors to wish list.
    /// </summary>
    /// <param name="contributorsXml">
    /// The contributors in XML format.
    /// </param>
    /// <param name="filterAccountNumber">
    /// The filter account number. It is used to check the operation privilege and filter the result content.
    /// Set the value to null to skip filtering.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the update of record is successful and false otherwise.
    /// </returns>
    public static container CreateWishListContributors(str contributorsXml, AccountNum filterAccountNumber)
    {
        return RetailTransactionServiceWishList::CreateWishListContributors(contributorsXml, filterAccountNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>CreateWishListInvitations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates invitations for wish lists.
    /// </summary>
    /// <param name="invitationsXml">
    /// The invitations to create in XML format.
    /// </param>
    /// <param name="filterAccountNumber">
    /// The filter account number. It is used to check the operation privilege and filter the result content.
    /// Set the value to null to skip filtering.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the update of record is successful and false otherwise.
    /// </returns>
    public static container CreateWishListInvitations(str invitationsXml, AccountNum filterAccountNumber)
    {
        return RetailTransactionServiceWishList::CreateWishListInvitations(invitationsXml, filterAccountNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>DeleteWishListContributors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes contributors from wish list.
    /// </summary>
    /// <param name="contributorsXml">
    /// The contributors in XML format.
    /// </param>
    /// <param name="filterAccountNumber">
    /// The filter account number. It is used to check the operation privilege and filter the result content.
    /// Set the value to null to skip filtering.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the update of record is successful and false otherwise.
    /// </returns>
    public static container DeleteWishListContributors(str contributorsXml, AccountNum filterAccountNumber)
    {
        return RetailTransactionServiceWishList::DeleteWishListContributors(contributorsXml, filterAccountNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>MoveWishListLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves wish list lines to another list.
    /// </summary>
    /// <param name="wishListLinesXml">
    /// The input xml containing the lines to move.
    /// </param>
    /// <param name="destinationWishList">
    /// The id of the destination wish list.
    /// </param>
    /// <param name="filterAccountNumber">
    /// The filter account number. It is used to check the operation privilege and filter the result content.
    /// Set the value to null to skip filtering.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the update of record is successful and false otherwise.
    /// </returns>
    /// <remarks>
    /// The lines can come from different lists.
    /// </remarks>
    public static container MoveWishListLines(str wishListLinesXml, recid destinationWishList, AccountNum filterAccountNumber)
    {
        return RetailTransactionServiceWishList::MoveWishListLines(wishListLinesXml, destinationWishList, filterAccountNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSecureExtendedLogOn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a record in <c>RetailStaffExtendedLogOn</c>table.
    /// </summary>
    /// <param name="_staffId">
    /// Staff ID.
    /// </param>
    /// <param name="_logOnKey">
    /// LogOn key.
    /// </param>
    /// <param name="_logOnType">
    /// LogOn key type.
    /// </param>
    /// <param name="_extraData">
    /// Device specific extra data as base 64 string.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container createSecureExtendedLogOn(RetailStaffId _staffId, RetailStaffExtendedLogOnKey _logOnKey, RetailStaffExtendedLogOnType _logOnType, str _extraData)
    {
        return RetailTransactionServiceEmployee::createSecureExtendedLogOn(_staffId, _logOnKey, _logOnType, _extraData);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteFile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes file on AOS server.
    /// </summary>
    /// <param name="_fileName">
    /// A valid file name on AOS server.
    /// </param>
    /// <returns>
    /// A container: [success, errorMessage]
    /// </returns>
    [SysObsolete('This method is not supported.', false, 13\05\2023)]
    public static container deleteFile(str _fileName)
    {
        throw new System.UnauthorizedAccessException();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGiftCardPolicies</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the gift card policies.
    /// </summary>
    /// <param name="_cardNumber">
    /// The gift card number.
    /// </param>
    /// <returns>
    /// The gift card policies.
    /// </returns>
    public static container getGiftCardPolicies(RetailGiftCardId _cardNumber)
    {
        return RetailTransactionServiceTransactions::getGiftCardPolicies(_cardNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGiftCardPolicySet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the gift card policy set and face value.
    /// </summary>
    /// <param name="_cardNumber">
    /// The gift card number.
    /// </param>
    /// <returns>
    /// The gift card policy set and face value from gift card number range.
    /// </returns>
    public static container getGiftCardPolicySet(RetailGiftCardId _cardNumber)
    {
        return RetailTransactionServiceTransactions::getGiftCardPolicySet(_cardNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberSequenceSeedData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the number sequence seed data for a terminal.
    /// </summary>
    /// <param name="_terminalId">
    /// ID of the terminal.
    /// </param>
    /// <returns>
    /// A container object containing the xml with the available number sequence seed data.
    /// </returns>
    public static container getNumberSequenceSeedData(RetailTerminalId _terminalId)
    {
        return RetailTransactionServiceDevice::getNumberSequenceSeedData(_terminalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runLabelReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs SSRS label report for selected items and export it to files (one file for each report template).
    /// </summary>
    /// <param name="_reportDataXmlStr">
    /// xml string containing data for report (list of items, report date, type of label and type of file to export).
    /// </param>
    /// <returns>
    /// Container with result (operation result, error message, list of not printed items).
    /// </returns>
    /// <remarks>
    /// Reports templates are taken from default setup for items.
    /// </remarks>
    public static container runLabelReport(str _reportDataXmlStr)
    {
        return RetailLabelReportsManager::runLabelReport(_reportDataXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runSrsReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs SSRS report.
    /// </summary>
    /// <param name="_reportName">
    /// The report name.
    /// </param>
    /// <param name="_reportParametersXmlStr">
    /// Xml string containing parameters for the report.
    /// </param>
    /// <returns>
    /// Container with result (operation result, error message, reports content as base64string).
    /// </returns>
    public static container runSrsReport(str _reportName, str _reportParametersXmlStr)
    {
        return RetailTransactionServiceSrsReport::runSrsReport(_reportName, _reportParametersXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalListSearch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns a list of retail transactions that match the passed in criteria.
    /// </summary>
    /// <param name="_xmlArgumentString">
    /// XML arguments.
    /// </param>
    /// <returns>
    /// A list of orders that match all of the criteria parameters.
    /// </returns>
    /// <remarks>
    /// Xml argument example:
    /// <Arguments>
    ///  <CurrentChannelId/>
    ///  <TransactionIds/>
    ///  <ReceiptId/>
    ///  <ChannelReferenceId/>
    ///  <CustomerAccountNumber/>
    ///  <CustomerFirstName/>
    ///  <CustomerLastName/>
    ///  <StoreId/>
    ///  <TerminalId/>
    ///  <ItemId/>
    ///  <Barcode/>
    ///  <StaffId/>
    ///  <StartDateTime/>
    ///  <EndDateTime/>
    ///  <ReceiptEmailAddress/>
    ///  <SerialNumber/>
    ///  <IncludeDetails/>
    ///  <PagingInfo>
    ///    <Skip/>
    ///    <Top/>
    ///  </PagingInfo>
    ///</Arguments>
    /// </remarks>
    public static container getJournalListSearch(str _xmlArgumentString)

    {
        return RetailTransactionServiceTransactions::getJournalListSearch(_xmlArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMerchantPaymentPropertiesForHardwareProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the terminal merchant payment provider properties.
    /// </summary>
    /// <param name="_hardwareProfileId">
    /// The hardware profile identifier for the RetailHardwareProfile table to fetch the merchant payment provider properties from.
    /// </param>
    /// <returns>
    /// The merchant payment provider properties for the required channel.
    /// </returns>
    public static container getMerchantPaymentPropertiesForHardwareProfile(str _hardwareProfileId)
    {
        container res;
        str merchant = '';
        str error;
        int fromLine = Global::infologLine();

        try
        {
            container merchantInfoFromDatabase = RetailTransactionService::retrieveMerchantInfoForHardwareProfile(_hardwareProfileId);
            merchant = conPeek(merchantInfoFromDatabase, 1);

            if (merchant != '')
            {
                res = [true, '', merchant];
            }
            else
            {
                res = [false, strFmt("@Retail:NoMerchantPropertiesForHardwareProfile", _hardwareProfileId)];
            }
        }
        catch
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            ApplicationEventSource::EventWriteRetailTransactionServiceFailure(funcName(), error);
            res = [false, error];
        }

        return res;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMerchantPaymentInformationForHardwareProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the terminal merchant payment provider properties.
    /// </summary>
    /// <param name="_hardwareProfileId">
    /// The hardware profile identifier for the RetailHardwareProfile table to fetch the merchant payment provider properties from.
    /// </param>
    /// <param name = "_merchantInformationHash">
    /// The hash of the merchant information stored by the client.
    /// </param>
    /// <returns>
    /// The merchant payment provider properties and its hash for the required channel.
    /// </returns>
    public static container getMerchantPaymentInformationForHardwareProfile(str _hardwareProfileId, str _merchantInformationHash)
    {
        container res;
        str merchant = '', merchantPropertiesHashFromTable = '';
        str error;
        int fromLine = Global::infologLine();

        try
        {
            container merchantInfoFromDatabase = RetailTransactionService::retrieveMerchantInfoForHardwareProfile(_hardwareProfileId);
            merchant = conPeek(merchantInfoFromDatabase, 1);
            merchantPropertiesHashFromTable = conPeek(merchantInfoFromDatabase, 2);

            if (merchant != '')
            {
                // If the hash passed by the client matches the value in the DB, return container with empty results for client.
                // Else pass the values retrieved from the database.
                if (_merchantInformationHash == merchantPropertiesHashFromTable)
                {
                    res = [true, '', '', ''];
                }
                else
                {
                    res = [true, '', merchant, merchantPropertiesHashFromTable];
                }
            }
            else
            {
                res = [false, strFmt("@Retail:NoMerchantPropertiesForHardwareProfile", _hardwareProfileId)];
            }
        }
        catch
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            eventSource.EventWritePaymentsGetPaymentMerchantInfoFromHardwareProfileException(error);
            res = [false, error];
        }

        return res;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveMerchantInfoForHardwareProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the merchant information and its hash for a given hardware profile id from the database.
    /// </summary>
    /// <param name = "_hardwareProfileId">
    /// The hardware profile identifier for the RetailHardwareProfile table to fetch the merchant payment provider properties from.
    /// </param>
    /// <returns>The merchant payment provider properties and its hash for the required channel.</returns>
    private static container retrieveMerchantInfoForHardwareProfile(str _hardwareProfileId)
    {
        RetailHardwareProfile retailHardwareProfile;
        str merchantInformation = '', merchantPropertiesHash = '';
        container result;

        if (_hardwareProfileId != '')
        {
            select firstonly MerchantPropertiesHash, SecureMerchantProperties from retailHardwareProfile
            where retailHardwareProfile.profileId == _hardwareProfileId;

            if (retailHardwareProfile && retailHardwareProfile.EFT == RetailExternalNone::PaymentSDK && retailHardwareProfile.SecureMerchantProperties != conNull())
            {
                merchantInformation = retailHardwareProfile.secureMerchantPropertiesEdit(false, '');
                merchantPropertiesHash = retailHardwareProfile.getMerchantPropertiesHash();
            }
        }

        result = [merchantInformation, merchantPropertiesHash];
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentMerchantPropertiesByServiceAccountId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the merchant payment provider properties for the given service account identifiers.
    /// </summary>
    /// <param name="_serviceAccountIdCollection">
    /// The service account identifier collection.
    /// </param>
    /// <returns>
    /// The merchant payment provider properties.
    /// </returns>
    public static container getPaymentMerchantPropertiesByServiceAccountId(str _serviceAccountIdCollection)
    {
        XmlDocument doc = XmlDocument::newBlank();
        XmlElement                  rootNode;
        XmlElement                  recordNode;
        XmlElement                  fieldNode;
        int fromLine;
        str error = '';
        boolean success = true;
        str serviceAccountId;

        try
        {
            List serviceAccountIds = Global::strSplit(_serviceAccountIdCollection, ",");
            ListIterator iterator = new ListIterator(serviceAccountIds);
            fromLine = Global::infologLine();

            rootNode = doc.createElement('MerchantPropertiesCollection');
            doc.appendChild(rootNode);

            // Get merchant properties for each service account Id.
            while (iterator.more())
            {
                serviceAccountId = iterator.value();

                if (serviceAccountId)
                {
                    CreditCardConnectorName connectorName;
                    str propertiesAsXmlString;

                    // Extract Merchant properties for the given service account id
                    [propertiesAsXmlString, connectorName] = CreditCard::findMerchantAccountProperties(serviceAccountId);

                    // Add Payment Merchant Properties to the collection of Merchant properties.
                    recordNode = doc.createElement('MerchantProperties');
                    recordNode.setAttribute('ServiceAccountId', serviceAccountId);

                    fieldNode = doc.createElement('MerchantPropertiesXml');
                    fieldNode.text(propertiesAsXmlString);
                    recordNode.appendChild(fieldNode);
                    rootNode.appendChild(recordNode);
                }

                iterator.next();
            }

            ApplicationEventSource::EventWriteRetailTransactionServiceInfoLog(funcName(), strFmt('Merchant properties successfully added for the service account identifiers: %1', _serviceAccountIdCollection));

        }
        catch (Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            eventSource.EventWritePaymentsGetPaymentMerchantInfoFromServiceAccountException(error);
            success = false;
        }

        return [success, error, doc.xml()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustomerV4</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating new customer with extension properties.
    /// </summary>
    /// <param name="custName">The customer name.</param>
    /// <param name="custGroup">The customer group associated with the customer.</param>
    /// <param name="currency">The currency code.</param>
    /// <param name="languageId">The language identifier preferred for this customer.</param>
    /// <param name="street">The primary street address.</param>
    /// <param name="zipCode">The primary zip or postal code.</param>
    /// <param name="state">The primary state or province.</param>
    /// <param name="county">The primary county/region.</param>
    /// <param name="phone">The primary phone number.</param>
    /// <param name="cellularPhone">The primary cell phone number.</param>
    /// <param name="email">The primary e-mail address.</param>
    /// <param name="url">The primary URL for this customer.</param>
    /// <param name="multiLineDisc">Multiline discount</param>
    /// <param name="endDisc">End discount</param>
    /// <param name="lineDisc">Line discount</param>
    /// <param name="priceGroup">Price Group</param>
    /// <param name="taxGroup">The customer's tax group.</param>
    /// <param name="creditMax">The maximum credit limit.</param>
    /// <param name="blocked">A value indicating whether this customer is to be marked as blocked.</param>
    /// <param name="orgId">Org ID</param>
    /// <param name="usePurchRequest">A value indicating whether to use purchase requests.</param>
    /// <param name="vatNum">The customer's VAT number.</param>
    /// <param name="invoiceAccount">The customer's invoice account number.</param>
    /// <param name="mandatoryCreditLimit">A value indicating whether credit limit enforcement is mandatory.</param>
    /// <param name="contactPersonId">The contact person identifier.</param>
    /// <param name="useOrderNumberReference">A value indicating whether to use order number reference.</param>
    /// <param name="receiptOption">The customer's preferred receipt option.</param>
    /// <param name="receiptEmail">The customer's preferred receipt e-mail address.</param>
    /// <param name="city">The primary city name.</param>
    /// <param name="country">The primary country.</param>
    /// <param name="identificationNumber">The customer's identification number.</param>
    /// <param name="storeRecId">The record identifier of the store where the customer was created.</param>
    /// <param name="DirPartyType">The customer's directory party type.</param>
    /// <param name="streetNumber">The primary street number.</param>
    /// <param name="districtName">The primary district name.</param>
    /// <param name="buildingCompliment">The primary building complement.</param>
    /// <param name="cnpjCpfNum_BR">The Brazilian tax identification unmber (CNPJ/CPF).</param>
    /// <param name="addressName">The primary address name.</param>
    /// <param name="addressType">The primary address type.</param>
    /// <param name="addressPhone">The primary address telephone number.</param>
    /// <param name="addressEmail">The primary address e-mail address.</param>
    /// <param name="addressUrl">The primary address URL address.</param>
    /// <param name="addressTaxGroup">The primary address tax group,</param>
    /// <param name="firstName">The customer's first name.</param>
    /// <param name="middleName">The customer's middle name.</param>
    /// <param name="lastName">The customer's last name.</param>
    /// <param name="phoneExtension">Phone extension</param>
    /// <param name="retailCustAffiliations">A XML string having the details of customer affiliation list.</param>
    /// <param name="externalIdentityId">The external identity identifier.</param>
    /// <param name="externalIdentityIssuer">The external identity issuer.</param>
    /// <param name="customerAttributes">An XML string containing the customer attributes.</param>
    /// <param name="extensionProperties">Optional.The extension properties XML.</param>
    /// <param name="customerAttributes">Optional. An XML string having the details of customer attributes.</param>
    /// <param name="custAttributesDataPackageVersion">Optional.The customer attributes data package version.</param>
    /// <param name="optOutPersonalization">Optional.A value indicating whether personalization has been disabled.</param>
    /// <param name="optOutWebActivityTracking">Optional.A value indicating whether web activity tracking has been disabled.</param>
    /// <param name="customerTitleRecId">Optional.The record identifier of customer title.</param>
    /// <param name="allowOnAccountPayment">Optional. A value indicating whether OnAccount payment has been enabled</param>
    /// <returns>
    /// Container with entity keys.
    /// </returns>
    public static container newCustomerV4(
        DirPartyName custName,
        CustGroupId custGroup,
        CustCurrencyCode currency,
        CustLanguageId languageId,
        AddressStreet street,
        AddressZipCodeId zipCode,
        AddressStateId state,
        AddressCountyId county,
        Phone phone,
        PhoneMobile cellularPhone,
        LogisticsElectronicAddressLocator email,
        URL url,
        CustMultiLineDiscCode multiLineDisc,
        CustEndDiscCode endDisc,
        CustLineDiscCode lineDisc,
        CustPriceGroup priceGroup,
        TaxGroup taxGroup,
        CustCreditMaxMST creditMax,
        CustBlocked blocked,
        OrgId orgId,
        RetailUsePurchRequest usePurchRequest,
        VATNum vatNum,
        CustInvoiceAccount invoiceAccount,
        MandatoryCreditLimit mandatoryCreditLimit,
        ContactPersonId contactPersonId,
        RetailUseOrderNumberReference useOrderNumberReference,
        RetailReceiptOption receiptOption,
        RetailReceiptEmail receiptEmail,
        AddressCity city,
        AddressCountryRegionId country,
        CustIdentificationNumber identificationNumber,
        int64 storeRecId,
        DirPartyType dirPartyRelationType,
        LogisticsAddressStreetNumber streetNumber = '',
        LogisticsAddressDistrictName districtName = '',
        LogisticsAddressBuildingCompliment buildingCompliment  = '',
        CNPJCPFNum_BR cnpjCpfNum_BR = '',
        CustName addressName = '',
        LogisticsLocationRoleType addressType = LogisticsLocationRoleType::None,
        Phone addressPhone = '',
        LogisticsElectronicAddressLocator addressEmail = '',
        URL addressUrl = '',
        TaxGroup addressTaxGroup = '',
        FirstName firstName = '',
        MiddleName middleName = '',
        LastName lastName = '',
        PhoneLocal phoneExtension = '',
        str retailCustAffiliations = '',
        str externalIdentityId = '',
        str externalIdentityIssuer = '',
        str extensionProperties = '',
        str customerAttributes = '',
        int custAttributesDataPackageVersion = 1,
        RetailOptOutPersonalization optOutPersonalization = NoYes::No,
        RetailOptOutWebActivityTracking optOutWebActivityTracking = NoYes::No,
        DirNamePersonalTitleRecId customerTitleRecId = 0,
        MCRAllowOnAccount allowOnAccountPayment = NoYes::No)
    {
        using (RetailTransactionServiceCustomerContext context = RetailTransactionServiceCustomerContext::construct())
        {
            context.parmOptOutPersonalization(optOutPersonalization);
            context.parmOptOutWebActivityTracking(optOutWebActivityTracking);
            context.parmCustomerTitleRecId(customerTitleRecId);
            context.parmAllowOnAccountPayment(allowOnAccountPayment);

            return RetailTransactionService::newCustomerExt3(
                custName,
                custGroup,
                currency,
                languageId,
                street,
                zipCode,
                state,
                county,
                phone,
                cellularPhone,
                email,
                url,
                multiLineDisc,
                endDisc,
                lineDisc,
                priceGroup,
                taxGroup,
                creditMax,
                blocked,
                orgId,
                usePurchRequest,
                vatNum,
                invoiceAccount,
                mandatoryCreditLimit,
                contactPersonId,
                useOrderNumberReference,
                receiptOption,
                receiptEmail,
                city,
                country,
                identificationNumber,
                storeRecId,
                dirPartyRelationType,
                streetNumber,
                districtName,
                buildingCompliment,
                cnpjCpfNum_BR,
                addressName,
                addressType,
                addressPhone,
                addressEmail,
                addressUrl,
                addressTaxGroup,
                firstName,
                middleName,
                lastName,
                phoneExtension,
                retailCustAffiliations,
                externalIdentityId,
                externalIdentityIssuer,
                extensionProperties,
                customerAttributes,
                custAttributesDataPackageVersion);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustomerExt3</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating new customer with extension properties.
    /// </summary>
    /// <param name="custName">The customer name.</param>
    /// <param name="custGroup">The customer group associated with the customer.</param>
    /// <param name="currency">The currency code.</param>
    /// <param name="languageId">The language identifier preferred for this customer.</param>
    /// <param name="street">The primary street address.</param>
    /// <param name="zipCode">The primary zip or postal code.</param>
    /// <param name="state">The primary state or province.</param>
    /// <param name="county">The primary county/region.</param>
    /// <param name="phone">The primary phone number.</param>
    /// <param name="cellularPhone">The primary cell phone number.</param>
    /// <param name="email">The primary e-mail address.</param>
    /// <param name="url">The primary URL for this customer.</param>
    /// <param name="multiLineDisc">Multiline discount</param>
    /// <param name="endDisc">End discount</param>
    /// <param name="lineDisc">Line discount</param>
    /// <param name="priceGroup">Price Group</param>
    /// <param name="taxGroup">The customer's tax group.</param>
    /// <param name="creditMax">The maximum credit limit.</param>
    /// <param name="blocked">A value indicating whether this customer is to be marked as blocked.</param>
    /// <param name="orgId">Org ID</param>
    /// <param name="usePurchRequest">A value indicating whether to use purchase requests.</param>
    /// <param name="vatNum">The customer's VAT number.</param>
    /// <param name="invoiceAccount">The customer's invoice account number.</param>
    /// <param name="mandatoryCreditLimit">A value indicating whether credit limit enforcement is mandatory.</param>
    /// <param name="contactPersonId">The contact person identifier.</param>
    /// <param name="useOrderNumberReference">A value indicating whether to use order number reference.</param>
    /// <param name="receiptOption">The customer's preferred receipt option.</param>
    /// <param name="receiptEmail">The customer's preferred receipt e-mail address.</param>
    /// <param name="city">The primary city name.</param>
    /// <param name="country">The primary country.</param>
    /// <param name="identificationNumber">The customer's identification number.</param>
    /// <param name="storeRecId">The record identifier of the store where the customer was created.</param>
    /// <param name="DirPartyType">The customer's directory party type.</param>
    /// <param name="streetNumber">The primary street number.</param>
    /// <param name="districtName">The primary district name.</param>
    /// <param name="buildingCompliment">The primary building complement.</param>
    /// <param name="cnpjCpfNum_BR">The Brazilian tax identification unmber (CNPJ/CPF).</param>
    /// <param name="addressName">The primary address name.</param>
    /// <param name="addressType">The primary address type.</param>
    /// <param name="addressPhone">The primary address telephone number.</param>
    /// <param name="addressEmail">The primary address e-mail address.</param>
    /// <param name="addressUrl">The primary address URL address.</param>
    /// <param name="addressTaxGroup">The primary address tax group,</param>
    /// <param name="firstName">The customer's first name.</param>
    /// <param name="middleName">The customer's middle name.</param>
    /// <param name="lastName">The customer's last name.</param>
    /// <param name="phoneExtension">Phone extension</param>
    /// <param name="retailCustAffiliations">A XML string having the details of customer affiliation list.</param>
    /// <param name="externalIdentityId">The external identity identifier.</param>
    /// <param name="externalIdentityIssuer">The external identity issuer.</param>
    /// <param name="customerAttributes">An XML string containing the customer attributes.</param>
    /// <param name="extensionProperties">Optional.The extension properties XML.</param>
    /// <param name="customerAttributes">Optional. An XML string having the details of customer attributes.</param>
    /// <param name="custAttributesDataPackageVersion">Optional.The customer attributes data package version.</param>
    /// <param name="optOutPersonalization">Optional.A value indicating whether personalization has been disabled.</param>
    /// <param name="optOutWebActivityTracking">Optional.A value indicating whether web activity tracking has been disabled.</param>
    /// <param name="customerTitleRecId">Optional.The record identifier of customer title.</param>
    /// <returns>
    /// Container with entity keys.
    /// </returns>
    /// <remarks>This method has been deprecated in favor of newCustomerV4.</remarks>
    public static container newCustomerExt3(
        DirPartyName custName,
        CustGroupId custGroup,
        CustCurrencyCode currency,
        CustLanguageId languageId,
        AddressStreet street,
        AddressZipCodeId zipCode,
        AddressStateId state,
        AddressCountyId county,
        Phone phone,
        PhoneMobile cellularPhone,
        LogisticsElectronicAddressLocator email,
        URL url,
        CustMultiLineDiscCode multiLineDisc,
        CustEndDiscCode endDisc,
        CustLineDiscCode lineDisc,
        CustPriceGroup priceGroup,
        TaxGroup taxGroup,
        CustCreditMaxMST creditMax,
        CustBlocked blocked,
        OrgId orgId,
        RetailUsePurchRequest usePurchRequest,
        VATNum vatNum,
        CustInvoiceAccount invoiceAccount,
        MandatoryCreditLimit mandatoryCreditLimit,
        ContactPersonId contactPersonId,
        RetailUseOrderNumberReference useOrderNumberReference,
        RetailReceiptOption receiptOption,
        RetailReceiptEmail receiptEmail,
        AddressCity city,
        AddressCountryRegionId country,
        CustIdentificationNumber identificationNumber,
        int64 storeRecId,
        DirPartyType dirPartyRelationType,
        LogisticsAddressStreetNumber streetNumber = '',
        LogisticsAddressDistrictName districtName = '',
        LogisticsAddressBuildingCompliment buildingCompliment  = '',
        CNPJCPFNum_BR cnpjCpfNum_BR = '',
        CustName addressName = '',
        LogisticsLocationRoleType addressType = LogisticsLocationRoleType::None,
        Phone addressPhone = '',
        LogisticsElectronicAddressLocator addressEmail = '',
        URL addressUrl = '',
        TaxGroup addressTaxGroup = '',
        FirstName firstName = '',
        MiddleName middleName = '',
        LastName lastName = '',
        PhoneLocal phoneExtension = '',
        str retailCustAffiliations = '',
        str externalIdentityId = '',
        str externalIdentityIssuer = '',
        str extensionProperties = '',
        str customerAttributes = '',
        int custAttributesDataPackageVersion = 1,
        RetailOptOutPersonalization optOutPersonalization = NoYes::No,
        RetailOptOutWebActivityTracking optOutWebActivityTracking = NoYes::No,
        DirNamePersonalTitleRecId customerTitleRecId = 0)
    {
        if (RetailTransactionServiceCustomerContext::current() != null)
        {
            return RetailTransactionService::newCustomerExt2(
                custName,
                custGroup,
                currency,
                languageId,
                street,
                zipCode,
                state,
                county,
                phone,
                cellularPhone,
                email,
                url,
                multiLineDisc,
                endDisc,
                lineDisc,
                priceGroup,
                taxGroup,
                creditMax,
                blocked,
                orgId,
                usePurchRequest,
                vatNum,
                invoiceAccount,
                mandatoryCreditLimit,
                contactPersonId,
                useOrderNumberReference,
                receiptOption,
                receiptEmail,
                city,
                country,
                identificationNumber,
                storeRecId,
                dirPartyRelationType,
                streetNumber,
                districtName,
                buildingCompliment,
                cnpjCpfNum_BR,
                addressName,
                addressType,
                addressPhone,
                addressEmail,
                addressUrl,
                addressTaxGroup,
                firstName,
                middleName,
                lastName,
                phoneExtension,
                retailCustAffiliations,
                externalIdentityId,
                externalIdentityIssuer,
                extensionProperties,
                customerAttributes,
                custAttributesDataPackageVersion);
        }

        using (RetailTransactionServiceCustomerContext context = RetailTransactionServiceCustomerContext::construct())
        {
            context.parmOptOutPersonalization(optOutPersonalization);
            context.parmOptOutWebActivityTracking(optOutWebActivityTracking);
            context.parmCustomerTitleRecId(customerTitleRecId);

            // Set AllowOnAccount based on the store's default customer config.
            CustTable channelDefaultCustomer = CustTable::find(RetailChannelTable::findByRecId(storeRecId).DefaultCustAccount);
            MCRCustTable mcrDefaultCustTable = MCRCustTable::findByCustAccount(channelDefaultCustomer.AccountNum);

            context.parmAllowOnAccountPayment(mcrDefaultCustTable.AllowOnAccount);

            return RetailTransactionService::newCustomerExt2(
                custName,
                custGroup,
                currency,
                languageId,
                street,
                zipCode,
                state,
                county,
                phone,
                cellularPhone,
                email,
                url,
                multiLineDisc,
                endDisc,
                lineDisc,
                priceGroup,
                taxGroup,
                creditMax,
                blocked,
                orgId,
                usePurchRequest,
                vatNum,
                invoiceAccount,
                mandatoryCreditLimit,
                contactPersonId,
                useOrderNumberReference,
                receiptOption,
                receiptEmail,
                city,
                country,
                identificationNumber,
                storeRecId,
                dirPartyRelationType,
                streetNumber,
                districtName,
                buildingCompliment,
                cnpjCpfNum_BR,
                addressName,
                addressType,
                addressPhone,
                addressEmail,
                addressUrl,
                addressTaxGroup,
                firstName,
                middleName,
                lastName,
                phoneExtension,
                retailCustAffiliations,
                externalIdentityId,
                externalIdentityIssuer,
                extensionProperties,
                customerAttributes,
                custAttributesDataPackageVersion);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustomerExt2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating new customer with extension properties.
    /// </summary>
    /// <param name="custName">The customer name.</param>
    /// <param name="custGroup">The customer group associated with the customer.</param>
    /// <param name="currency">The currency code.</param>
    /// <param name="languageId">The language identifier preferred for this customer.</param>
    /// <param name="street">The primary street address.</param>
    /// <param name="zipCode">The primary zip or postal code.</param>
    /// <param name="state">The primary state or province.</param>
    /// <param name="county">The primary county/region.</param>
    /// <param name="phone">The primary phone number.</param>
    /// <param name="cellularPhone">The primary cell phone number.</param>
    /// <param name="email">The primary e-mail address.</param>
    /// <param name="url">The primary URL for this customer.</param>
    /// <param name="multiLineDisc">Multiline discount</param>
    /// <param name="endDisc">End discount</param>
    /// <param name="lineDisc">Line discount</param>
    /// <param name="priceGroup">Price Group</param>
    /// <param name="taxGroup">The customer's tax group.</param>
    /// <param name="creditMax">The maximum credit limit.</param>
    /// <param name="blocked">A value indicating whether this customer is to be marked as blocked.</param>
    /// <param name="orgId">Org ID</param>
    /// <param name="usePurchRequest">A value indicating whether to use purchase requests.</param>
    /// <param name="vatNum">The customer's VAT number.</param>
    /// <param name="invoiceAccount">The customer's invoice account number.</param>
    /// <param name="mandatoryCreditLimit">A value indicating whether credit limit enforcement is mandatory.</param>
    /// <param name="contactPersonId">The contact person identifier.</param>
    /// <param name="useOrderNumberReference">A value indicating whether to use order number reference.</param>
    /// <param name="receiptOption">The customer's preferred receipt option.</param>
    /// <param name="receiptEmail">The customer's preferred receipt e-mail address.</param>
    /// <param name="city">The primary city name.</param>
    /// <param name="country">The primary country.</param>
    /// <param name="identificationNumber">The customer's identification number.</param>
    /// <param name="storeRecId">The record identifier of the store where the customer was created.</param>
    /// <param name="DirPartyType">The customer's directory party type.</param>
    /// <param name="streetNumber">The primary street number.</param>
    /// <param name="districtName">The primary district name.</param>
    /// <param name="buildingCompliment">The primary building complement.</param>
    /// <param name="cnpjCpfNum_BR">The Brazilian tax identification unmber (CNPJ/CPF).</param>
    /// <param name="addressName">The primary address name.</param>
    /// <param name="addressType">The primary address type.</param>
    /// <param name="addressPhone">The primary address telephone number.</param>
    /// <param name="addressEmail">The primary address e-mail address.</param>
    /// <param name="addressUrl">The primary address URL address.</param>
    /// <param name="addressTaxGroup">The primary address tax group,</param>
    /// <param name="firstName">The customer's first name.</param>
    /// <param name="middleName">The customer's middle name.</param>
    /// <param name="lastName">The customer's last name.</param>
    /// <param name="phoneExtension">Phone extension</param>
    /// <param name="retailCustAffiliations">A XML string having the details of customer affiliation list.</param>
    /// <param name="externalIdentityId">The external identity identifier.</param>
    /// <param name="externalIdentityIssuer">The external identity issuer.</param>
    /// <param name="customerAttributes">An XML string containing the customer attributes.</param>
    /// <param name="extensionProperties">Optional.The extension properties XML.</param>
    /// <param name="customerAttributes">Optional. An XML string having the details of customer attributes.</param>
    /// <param name="custAttributesDataPackageVersion">Optional.The customer attributes data package version.</param>
    /// <param name="optOutPersonalization">Optional.A value indicating whether personalization has been disabled.</param>
    /// <param name="optOutWebActivityTracking">Optional.A value indicating whether web activity tracking has been disabled.</param>
    /// <returns>
    /// Container with entity keys.
    /// </returns>
    /// <remarks>This method has been deprecated in favor of newCustomerExt3.</remarks>
    public static container newCustomerExt2(
        DirPartyName custName,
        CustGroupId custGroup,
        CustCurrencyCode currency,
        CustLanguageId languageId,
        AddressStreet street,
        AddressZipCodeId zipCode,
        AddressStateId state,
        AddressCountyId county,
        Phone phone,
        PhoneMobile cellularPhone,
        LogisticsElectronicAddressLocator email,
        URL url,
        CustMultiLineDiscCode multiLineDisc,
        CustEndDiscCode endDisc,
        CustLineDiscCode lineDisc,
        CustPriceGroup priceGroup,
        TaxGroup taxGroup,
        CustCreditMaxMST creditMax,
        CustBlocked blocked,
        OrgId orgId,
        RetailUsePurchRequest usePurchRequest,
        VATNum vatNum,
        CustInvoiceAccount invoiceAccount,
        MandatoryCreditLimit mandatoryCreditLimit,
        ContactPersonId contactPersonId,
        RetailUseOrderNumberReference useOrderNumberReference,
        RetailReceiptOption receiptOption,
        RetailReceiptEmail receiptEmail,
        AddressCity city,
        AddressCountryRegionId country,
        CustIdentificationNumber identificationNumber,
        int64 storeRecId,
        DirPartyType dirPartyRelationType,
        LogisticsAddressStreetNumber streetNumber = '',
        LogisticsAddressDistrictName districtName = '',
        LogisticsAddressBuildingCompliment buildingCompliment  = '',
        CNPJCPFNum_BR cnpjCpfNum_BR = '',
        CustName addressName = '',
        LogisticsLocationRoleType addressType = LogisticsLocationRoleType::None,
        Phone addressPhone = '',
        LogisticsElectronicAddressLocator addressEmail = '',
        URL addressUrl = '',
        TaxGroup addressTaxGroup = '',
        FirstName firstName = '',
        MiddleName middleName = '',
        LastName lastName = '',
        PhoneLocal phoneExtension = '',
        str retailCustAffiliations = '',
        str externalIdentityId = '',
        str externalIdentityIssuer = '',
        str extensionProperties = '',
        str customerAttributes = '',
        int custAttributesDataPackageVersion = 1,
        RetailOptOutPersonalization optOutPersonalization = NoYes::No,
        RetailOptOutWebActivityTracking optOutWebActivityTracking = NoYes::No)
    {
        if (RetailTransactionServiceCustomerContext::current() != null)
        {
            return RetailTransactionService::newCustomerExt(
                custName,
                custGroup,
                currency,
                languageId,
                street,
                zipCode,
                state,
                county,
                phone,
                cellularPhone,
                email,
                url,
                multiLineDisc,
                endDisc,
                lineDisc,
                priceGroup,
                taxGroup,
                creditMax,
                blocked,
                orgId,
                usePurchRequest,
                vatNum,
                invoiceAccount,
                mandatoryCreditLimit,
                contactPersonId,
                useOrderNumberReference,
                receiptOption,
                receiptEmail,
                city,
                country,
                identificationNumber,
                storeRecId,
                dirPartyRelationType,
                streetNumber,
                districtName,
                buildingCompliment,
                cnpjCpfNum_BR,
                addressName,
                addressType,
                addressPhone,
                addressEmail,
                addressUrl,
                addressTaxGroup,
                firstName,
                middleName,
                lastName,
                phoneExtension,
                retailCustAffiliations,
                externalIdentityId,
                externalIdentityIssuer,
                extensionProperties,
                customerAttributes,
                custAttributesDataPackageVersion);
        }

        using (RetailTransactionServiceCustomerContext context = RetailTransactionServiceCustomerContext::construct())
        {
            context.parmOptOutPersonalization(optOutPersonalization);
            context.parmOptOutWebActivityTracking(optOutWebActivityTracking);

            return RetailTransactionService::newCustomerExt(
                custName,
                custGroup,
                currency,
                languageId,
                street,
                zipCode,
                state,
                county,
                phone,
                cellularPhone,
                email,
                url,
                multiLineDisc,
                endDisc,
                lineDisc,
                priceGroup,
                taxGroup,
                creditMax,
                blocked,
                orgId,
                usePurchRequest,
                vatNum,
                invoiceAccount,
                mandatoryCreditLimit,
                contactPersonId,
                useOrderNumberReference,
                receiptOption,
                receiptEmail,
                city,
                country,
                identificationNumber,
                storeRecId,
                dirPartyRelationType,
                streetNumber,
                districtName,
                buildingCompliment,
                cnpjCpfNum_BR,
                addressName,
                addressType,
                addressPhone,
                addressEmail,
                addressUrl,
                addressTaxGroup,
                firstName,
                middleName,
                lastName,
                phoneExtension,
                retailCustAffiliations,
                externalIdentityId,
                externalIdentityIssuer,
                extensionProperties,
                customerAttributes,
                custAttributesDataPackageVersion);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustomerExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating new customer with extension properties.
    /// </summary>
    /// <param name="custName">
    /// Customer name.
    /// </param>
    /// <param name="custGroup">
    /// Customer group
    /// </param>
    /// <param name="currency">
    /// Currency
    /// </param>
    /// <param name="languageId">
    /// Language ID
    /// </param>
    /// <param name="street">
    /// Street
    /// </param>
    /// <param name="zipCode">
    /// Zip code
    /// </param>
    /// <param name="state">
    /// State
    /// </param>
    /// <param name="county">
    /// County
    /// </param>
    /// <param name="phone">
    /// Phone
    /// </param>
    /// <param name="cellularPhone">
    /// Cell phone
    /// </param>
    /// <param name="email">
    /// Email
    /// </param>
    /// <param name="url">
    /// URL
    /// </param>
    /// <param name="multiLineDisc">
    /// Multiline discount
    /// </param>
    /// <param name="endDisc">
    /// End discount
    /// </param>
    /// <param name="lineDisc">
    /// Line discount
    /// </param>
    /// <param name="priceGroup">
    /// Price Group
    /// </param>
    /// <param name="taxGroup">
    /// Tax Group
    /// </param>
    /// <param name="creditMax">
    /// Credit Max
    /// </param>
    /// <param name="blocked">
    /// Blocked
    /// </param>
    /// <param name="orgId">
    /// Org ID
    /// </param>
    /// <param name="usePurchRequest">
    /// Use purchase request
    /// </param>
    /// <param name="vatNum">
    /// Vat Number
    /// </param>
    /// <param name="invoiceAccount">
    /// Invoice account
    /// </param>
    /// <param name="mandatoryCreditLimit">
    /// Mandotory credit limit
    /// </param>
    /// <param name="contactPersonId">
    /// Contact person ID
    /// </param>
    /// <param name="useOrderNumberReference">
    /// Use order number reference
    /// </param>
    /// <param name="receiptOption">
    /// Receipt option
    /// </param>
    /// <param name="receiptEmail">
    /// Receipt Email
    /// </param>
    /// <param name="city">
    /// City
    /// </param>
    /// <param name="country">
    /// Country
    /// </param>
    /// <param name="identificationNumber">
    /// Identification Number
    /// </param>
    /// <param name="storeRecId">
    /// Store Rec ID
    /// </param>
    /// <param name="DirPartyType">
    /// DirPartyType
    /// </param>
    /// <param name="streetNumber">
    /// Street Number
    /// </param>
    /// <param name="districtName">
    /// District Name
    /// </param>
    /// <param name="buildingCompliment">
    /// Building Complement
    /// </param>
    /// <param name="cnpjCpfNum_BR">
    /// CNPJ/CPF (Brazilian tax ID)
    /// </param>
    /// <param name="addressName">
    /// Address Name
    /// </param>
    /// <param name="addressType">
    /// Address Type
    /// </param>
    /// <param name="addressPhone">
    /// Address Phone
    /// </param>
    /// <param name="addressEmail">
    /// Address Email
    /// </param>
    /// <param name="addressUrl">
    /// Address URL
    /// </param>
    /// <param name="addressTaxGroup">
    /// Address Tax group
    /// </param>
    /// <param name="firstName">
    /// First name
    /// </param>
    /// <param name="middleName">
    /// Middle name
    /// </param>
    /// <param name="lastName">
    /// Last name
    /// </param>
    /// <param name="phoneExtension">
    /// Phone extension
    /// </param>
    /// <param name="retailCustAffiliations">
    /// A XML string having the details of customer affiliation list
    /// </param>
    /// <param name="externalIdentityId">
    /// The external identity identifier.
    /// </param>
    /// <param name="externalIdentityIssuer">
    /// The external identity issuer.
    /// </param>
    /// <param name="customerAttributes">
    /// An XML string containing the customer attributes
    /// </param>
    /// <param name="extensionProperties">
    /// Optional. Extension properties XML.
    /// </param>
    /// <param name="customerAttributes">
    /// Optional. An XML string having the details of customer attributes.
    /// </param>
    /// <param name="custAttributesDataPackageVersion">
    /// Optional. The customer attributes data package version.
    /// </param>
    /// <returns>
    /// Container with entity keys
    /// </returns>
    /// <remarks>This method has been deprecated in favor of newCustomerExt3.</remarks>
    public static container newCustomerExt(DirPartyName                custName,
                                        CustGroupId                 custGroup,
                                        CustCurrencyCode            currency,
                                        CustLanguageId              languageId,
                                        AddressStreet               street,
                                        AddressZipCodeId            zipCode,
                                        AddressStateId              state,
                                        AddressCountyId             county,
                                        Phone                       phone,
                                        PhoneMobile                 cellularPhone,
                                        LogisticsElectronicAddressLocator  email,
                                        URL                         url,
                                        CustMultiLineDiscCode       multiLineDisc,
                                        CustEndDiscCode             endDisc,
                                        CustLineDiscCode            lineDisc,
                                        CustPriceGroup              priceGroup,
                                        TaxGroup                    taxGroup,
                                        CustCreditMaxMST            creditMax,
                                        CustBlocked                 blocked,
                                        OrgId                       orgId,
                                        RetailUsePurchRequest       usePurchRequest,
                                        VATNum                      vatNum,
                                        CustInvoiceAccount          invoiceAccount,
                                        MandatoryCreditLimit        mandatoryCreditLimit,
                                        ContactPersonId             contactPersonId,
                                        RetailUseOrderNumberReference  useOrderNumberReference,
                                        RetailReceiptOption            receiptOption,
                                        RetailReceiptEmail             receiptEmail,
                                        AddressCity                 city,
                                        AddressCountryRegionId      country,
                                        CustIdentificationNumber    identificationNumber,
                                        int64                       storeRecId,
                                        DirPartyType                dirPartyRelationType,
                                        LogisticsAddressStreetNumber        streetNumber        = '',
                                        LogisticsAddressDistrictName        districtName        = '',
                                        LogisticsAddressBuildingCompliment  buildingCompliment  = '',
                                        CNPJCPFNum_BR                       cnpjCpfNum_BR       = '',
                                        CustName                    addressName = '',
                                        LogisticsLocationRoleType   addressType = LogisticsLocationRoleType::None,
                                        Phone                       addressPhone = '',
                                        LogisticsElectronicAddressLocator addressEmail = '',
                                        URL                         addressUrl = '',
                                        TaxGroup                    addressTaxGroup = '',
                                        FirstName firstName = '',
                                        MiddleName middleName = '',
                                        LastName lastName = '',
                                        PhoneLocal phoneExtension = '',
                                        str retailCustAffiliations = '',
                                        str externalIdentityId = '',
                                        str externalIdentityIssuer = '',
                                        str extensionProperties = '',
                                        str customerAttributes = '',
                                        int custAttributesDataPackageVersion = 1)
    {
        return RetailTransactionService::newCustomer(
        custName,
        custGroup,
        currency,
        languageId,
        street,
        zipCode,
        state,
        county,
        phone,
        cellularPhone,
        email,
        url,
        multiLineDisc,
        endDisc,
        lineDisc,
        priceGroup,
        taxGroup,
        creditMax,
        blocked,
        orgId,
        usePurchRequest,
        vatNum,
        invoiceAccount,
        mandatoryCreditLimit,
        contactPersonId,
        useOrderNumberReference,
        receiptOption,
        receiptEmail,
        city,
        country,
        identificationNumber,
        storeRecId,
        dirPartyRelationType,
        streetNumber,
        districtName,
        buildingCompliment,
        cnpjCpfNum_BR,
        addressName,
        addressType,
        addressPhone,
        addressEmail,
        addressUrl,
        addressTaxGroup,
        firstName,
        middleName,
        lastName,
        phoneExtension,
        retailCustAffiliations,
        externalIdentityId,
        externalIdentityIssuer,
        customerAttributes,
        custAttributesDataPackageVersion);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMediaStorageSasKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the media storage shared access signature key details.
    /// </summary>
    /// <returns>The container contains four values, 1.the result state, 2.error message, 3.shared access signature key, 4.shared access signature key expiration time in UTC.</returns>
    public static container getMediaStorageSasKey()
    {
        str containerName = RetailMediaHelper::AzureStorageSecuredImagesCategory;
        var result = RetailMediaHelper::getStorageSasKeyDetails(containerName);
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetOrderHistoryList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the history of all transactions and orders for a given customer.
    /// </summary>
    /// <param name="_xmlArgumentString">
    /// XML document containing the arguments for the method call.  See remarks for example.
    /// </param>
    /// <param name="_useJson">
    /// Whwer or not the methos should return results in JSOD format or not.  Defaults to No.
    /// </param>
    /// <returns>
    /// Collection of orders.
    /// </returns>
    /// <remarks>
    /// Argument xml example:
    ///     <Arguments>
    ///         <CustomerAccountNumber>"1234"</CustomerAccountNumber>
    ///         <IncludeDetails>"true"</IncludeDetails>
    ///         <PagingInfo>
    ///             <Skip>1</Skip>
    ///             <Top>100</Top>
    ///         </PagingInfo>
    ///     </Arguments>
    /// </remarks>
    public static container GetOrderHistoryList(str _xmlArgumentString = '', boolean _useJson = false)
    {
        //_UseJson is replaced by <SerializationFormat> tag in arguments.
        return RetailTransactionServiceTransactions::getOrderHistoryList(_xmlArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMerchantPaymentPropertiesForOnlineStore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the channel merchant payment provider properties.
    /// </summary>
    /// <param name="_channelId">
    /// The channel identifier to fetch the merchant payment provider properties from RetailChannelPaymentConnectorLine.
    /// </param>
    /// <returns>
    /// XML .
    /// </returns>
    public static container getMerchantPaymentPropertiesForOnlineStore(RetailChannelRecId  _channelId)
    {
        RetailChannelPaymentConnectorLine retailChannelPaymentConnectorLine;
        container res;
        XmlDocument xmlDoc;
        XmlElement xmlRoot;
        XmlElement xmlData;
        str error;
        int fromLine = Global::infologLine();
        boolean hasEntries = false;

        try
        {
            xmlDoc = XmlDocument::newBlank();
            xmlRoot = xmlDoc.createElement('Root');
            xmlDoc.appendChild(xmlRoot);

            if (_channelId != 0)
            {
                while select SecureMerchantProperties from retailChannelPaymentConnectorLine
                where retailChannelPaymentConnectorLine.OnlineChannel == _channelId
                {
                    if (retailChannelPaymentConnectorLine.SecureMerchantProperties != conNull())
                    {
                        var merchant = retailChannelPaymentConnectorLine.secureMerchantPropertiesEdit(false, '');

                        xmlData = xmlDoc.createElement('MerchantData');
                        xmlData.setAttribute('Key',  int642Str(retailChannelPaymentConnectorLine.RecId));
                        xmlData.setAttribute('Value', merchant);
                        xmlRoot.appendChild(xmlData);

                        hasEntries = true;
                    }
                }
            }

            if (hasEntries)
            {
                res = [true, "", xmlDoc.toString()];
            }
            else
            {
                res = [false, 'No Online store found'];
            }
        }
        catch
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            eventSource.EventWritePaymentsGetPaymentMerchantInfoForOnlineStoreException(error);
            res = [false, error];
        }

        return res;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustomerAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create customer address with extended parameters.
    /// </summary>
    /// <param name="custAccount">
    /// Customer account.
    /// </param>
    /// <param name="custName">
    /// Customer name.
    /// </param>
    /// <param name="street">
    /// Street.
    /// </param>
    /// <param name="city">
    /// City.
    /// </param>
    /// <param name="county">
    /// County.
    /// </param>
    /// <param name="state">
    /// State.
    /// </param>
    /// <param name="zip">
    /// Zip.
    /// </param>
    /// <param name="country">
    /// Country.
    /// </param>
    /// <param name="phone">
    /// Phone.
    /// </param>
    /// <param name="email">
    /// Email.
    /// </param>
    /// <param name="url">
    /// URL.
    /// </param>
    /// <param name="taxGroup">
    /// Tax group.
    /// </param>
    /// <param name="role">
    /// Role.
    /// </param>
    /// <param name="logisticsLocationRoleRecordId">
    /// LogisticsLocationRoleRecordId. If this is not given, Role will be used.
    /// </param>
    /// <param name="streetNumber">
    /// Street number.
    /// </param>
    /// <param name="districtName">
    /// District name.
    /// </param>
    /// <param name="buildingCompliment">
    /// Building compliment.
    /// </param>
    /// <param name="makePostalAddressPrimary">
    /// Optional. True if this should become the new primary address.
    /// </param>
    /// <param name="extensionProperties">
    /// Optional. Extension properties XML.
    /// </param>
    /// <returns>
    /// A container with entity keys.
    /// </returns>
    public static container createCustomerAddress(CustAccount            custAccount,
                                        CustName                    custName,
                                        AddressStreet               street,
                                        AddressCity                 city,
                                        AddressCountyId             county,
                                        AddressStateId              state,
                                        AddressZipCodeId            zip,
                                        AddressCountryRegionId      country,
                                        Phone                       phone,
                                        Email                       email,
                                        URL                         url,
                                        TaxGroup                    taxGroup,
                                        LogisticsLocationRoleType   role,
                                        LogisticsAddressStreetNumber        streetNumber,
                                        LogisticsAddressDistrictName        districtName,
                                        LogisticsAddressBuildingCompliment  buildingCompliment,
                                        boolean                     makePostalAddressPrimary,
                                        str                         extensionProperties,
                                        RecId                       logisticsLocationRoleRecordId)
    {
        RetailTransactionServiceCustomer_ExtendedParameters retailTransactionServiceCustomer_ExtendedParameters = RetailTransactionServiceCustomer::extendedParameters;
        retailTransactionServiceCustomer_ExtendedParameters.createAddress_logisticsLocationRoleRecordId = logisticsLocationRoleRecordId;

        return RetailTransactionServiceCustomer::createAddressExt(
        custAccount,
        custName,
        street,
        city,
        county,
        state,
        zip,
        country,
        phone,
        email,
        url,
        taxGroup,
        role,
        streetNumber,
        districtName,
        buildingCompliment,
        makePostalAddressPrimary,
        extensionProperties);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomerAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update customer address with extended parameters.
    /// </summary>
    /// <param name="addressRecId">
    /// Address RecId.
    /// </param>
    /// <param name="custName">
    /// Customer Name.
    /// </param>
    /// <param name="street">
    /// Street.
    /// </param>
    /// <param name="city">
    /// City.
    /// </param>
    /// <param name="county">
    /// County.
    /// </param>
    /// <param name="state">
    /// State.
    /// </param>
    /// <param name="zip">
    /// Zip.
    /// </param>
    /// <param name="country">
    /// Country.
    /// </param>
    /// <param name="phone">
    /// Phone.
    /// </param>
    /// <param name="email">
    /// Email.
    /// </param>
    /// <param name="url">
    /// URL.
    /// </param>
    /// <param name="taxGroup">
    /// Tax group.
    /// </param>
    /// <param name="role">
    /// Role.
    /// </param>
    /// <param name="phoneRecId">
    /// Phone RecId.
    /// </param>
    /// <param name="emailRecId">
    /// Email RecId.
    /// </param>
    /// <param name="urlRecId">
    /// URL RecId.
    /// </param>
    /// <param name="logisticsLocationRoleRecordId">
    /// LogisticsLocationRoleRecordId. If this is not given, Role will be used.
    /// </param>
    /// <param name="streetNumber">
    /// Street Number.
    /// </param>
    /// <param name="districtName">
    /// District Name.
    /// </param>
    /// <param name="buildingCompliment">
    /// Building Complement.
    /// </param>
    /// <param name="makePostalAddressPrimary">
    /// Optional. True if this should become the new primary address.
    /// </param>
    /// <param name="custPartyNumber">
    /// The customer party number.
    /// </param>
    /// <param name="extensionProperties">
    /// Optional. Extension properties XML.
    /// </param>
    /// <returns>
    /// A container with entity keys.
    /// </returns>
    public static container updateCustomerAddress(RefRecId               addressRecId,
                                        CustName                    custName,
                                        AddressStreet               street,
                                        AddressCity                 city,
                                        AddressCountyId             county,
                                        AddressStateId              state,
                                        AddressZipCodeId            zip,
                                        AddressCountryRegionId      country,
                                        Phone                       phone,
                                        LogisticsElectronicAddressLocator  email,
                                        URL                         url,
                                        TaxGroup                    taxGroup,
                                        LogisticsLocationRoleType   role,
                                        int64                       phoneRecId,
                                        int64                       emailRecId,
                                        int64                       urlRecId,
                                        LogisticsAddressStreetNumber        streetNumber,
                                        LogisticsAddressDistrictName        districtName,
                                        LogisticsAddressBuildingCompliment  buildingCompliment,
                                        boolean                     makePostalAddressPrimary,
                                        RecId                       custPartyNumber,
                                        str                         extensionProperties,
                                        RecId                       logisticsLocationRoleRecordId)
    {
        RetailTransactionServiceCustomer_ExtendedParameters retailTransactionServiceCustomer_ExtendedParameters = RetailTransactionServiceCustomer::extendedParameters;
        retailTransactionServiceCustomer_ExtendedParameters.updateAddress_logisticsLocationRoleRecordId = logisticsLocationRoleRecordId;

        return RetailTransactionServiceCustomer::updateAddressExt(
        addressRecId,
        custName,
        street,
        city,
        county,
        state,
        zip,
        country,
        phone,
        email,
        url,
        taxGroup,
        role,
        phoneRecId,
        emailRecId,
        urlRecId,
        streetNumber,
        districtName,
        buildingCompliment,
        makePostalAddressPrimary,
        custPartyNumber,
        extensionProperties);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAddressExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create address for customer with extended properties.
    /// </summary>
    /// <param name="custAccount">
    /// Customer account
    /// </param>
    /// <param name="custName">
    /// Customer name
    /// </param>
    /// <param name="street">
    /// Street
    /// </param>
    /// <param name="city">
    /// City
    /// </param>
    /// <param name="county">
    /// County
    /// </param>
    /// <param name="state">
    /// State
    /// </param>
    /// <param name="zip">
    /// Zip
    /// </param>
    /// <param name="country">
    /// Country
    /// </param>
    /// <param name="phone">
    /// Phone
    /// </param>
    /// <param name="email">
    /// Email
    /// </param>
    /// <param name="url">
    /// URL
    /// </param>
    /// <param name="taxGroup">
    /// Tax group
    /// </param>
    /// <param name="role">
    /// Role
    /// </param>
    /// <param name="streetNumber">
    /// Street number
    /// </param>
    /// <param name="districtName">
    /// District name
    /// </param>
    /// <param name="buildingCompliment">
    /// Building compliment
    /// </param>
    /// <param name="makePostalAddressPrimary">
    /// Optional. True if this should become the new primary address
    /// </param>
    /// <param name="extensionProperties">
    /// Optional. Extension properties XML.
    /// </param>
    /// <returns>
    /// A container with entity keys
    /// </returns>
    /// <remarks>
    /// Original parameter list consisted of a single _paramList parameter of type container.
    /// </remarks>
    public static container createAddressExt(CustAccount            custAccount,
                                        CustName                    custName,
                                        AddressStreet               street,
                                        AddressCity                 city,
                                        AddressCountyId             county,
                                        AddressStateId              state,
                                        AddressZipCodeId            zip,
                                        AddressCountryRegionId      country,
                                        Phone                       phone,
                                        Email                       email,
                                        URL                         url,
                                        TaxGroup                    taxGroup,
                                        LogisticsLocationRoleType   role,
                                        LogisticsAddressStreetNumber        streetNumber        = '',
                                        LogisticsAddressDistrictName        districtName        = '',
                                        LogisticsAddressBuildingCompliment  buildingCompliment  = '',
                                        boolean                     makePostalAddressPrimary = false,
                                        str                         extensionProperties = '')
    {
        return RetailTransactionService::createAddress(
        custAccount,
        custName,
        street,
        city,
        county,
        state,
        zip,
        country,
        phone,
        email,
        url,
        taxGroup,
        role,
        streetNumber,
        districtName,
        buildingCompliment,
        makePostalAddressPrimary);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAddressExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update address, implementation with extension properties.
    /// </summary>
    /// <param name="addressRecId">
    /// Address RecId
    /// </param>
    /// <param name="custName">
    /// Customer Name
    /// </param>
    /// <param name="street">
    /// Street
    /// </param>
    /// <param name="city">
    /// City
    /// </param>
    /// <param name="county">
    /// County
    /// </param>
    /// <param name="state">
    /// State
    /// </param>
    /// <param name="zip">
    /// Zip
    /// </param>
    /// <param name="country">
    /// Country
    /// </param>
    /// <param name="phone">
    /// Phone
    /// </param>
    /// <param name="email">
    /// Email
    /// </param>
    /// <param name="url">
    /// URL
    /// </param>
    /// <param name="taxGroup">
    /// Tax group
    /// </param>
    /// <param name="role">
    /// Role
    /// </param>
    /// <param name="phoneRecId">
    /// Phone RecId
    /// </param>
    /// <param name="emailRecId">
    /// Email RecId
    /// </param>
    /// <param name="urlRecId">
    /// URL RecId
    /// </param>
    /// <param name="streetNumber">
    /// Street Number
    /// </param>
    /// <param name="districtName">
    /// District Name
    /// </param>
    /// <param name="buildingCompliment">
    /// Building Complement
    /// </param>
    /// <param name="makePostalAddressPrimary">
    /// Optional. True if this should become the new primary address
    /// </param>
    /// <param name="custPartyNumber">
    /// The customer party number.
    /// </param>
    /// <param name="extensionProperties">
    /// Optional. Extension properties XML.
    /// </param>
    /// <returns>
    /// A container with entity keys
    /// </returns>
    /// <remarks>
    /// Original parameter list consisted of a single _paramList parameter of type container.
    /// </remarks>
    public static container updateAddressExt(RefRecId               addressRecId,
                                        CustName                    custName,
                                        AddressStreet               street,
                                        AddressCity                 city,
                                        AddressCountyId             county,
                                        AddressStateId              state,
                                        AddressZipCodeId            zip,
                                        AddressCountryRegionId      country,
                                        Phone                       phone,
                                        LogisticsElectronicAddressLocator  email,
                                        URL                         url,
                                        TaxGroup                    taxGroup,
                                        LogisticsLocationRoleType   role,
                                        int64                       phoneRecId,
                                        int64                       emailRecId,
                                        int64                       urlRecId,
                                        LogisticsAddressStreetNumber        streetNumber        = '',
                                        LogisticsAddressDistrictName        districtName        = '',
                                        LogisticsAddressBuildingCompliment  buildingCompliment  = '',
                                        boolean                     makePostalAddressPrimary    = false,
                                        RecId                       custPartyNumber             = 0,
                                        str                         extensionProperties         = '')
    {
        return RetailTransactionService::updateAddress(
        addressRecId,
        custName,
        street,
        city,
        county,
        state,
        zip,
        country,
        phone,
        email,
        url,
        taxGroup,
        role,
        phoneRecId,
        emailRecId,
        urlRecId,
        streetNumber,
        districtName,
        buildingCompliment,
        makePostalAddressPrimary,
        custPartyNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomerExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for updating an existing customer, with extension properties.
    /// </summary>
    /// <param name="custTableRecId">
    /// CustTable RecId.
    /// </param>
    /// <param name="custName">
    /// Customer Name.
    /// </param>
    /// <param name="custGroup">
    /// Customer group
    /// </param>
    /// <param name="currency">
    /// Currency
    /// </param>
    /// <param name="languageId">
    /// Language ID
    /// </param>
    /// <param name="phone">
    /// Phone
    /// </param>
    /// <param name="phoneRecId">
    /// Phone recid
    /// </param>
    /// <param name="cellularPhone">
    /// Cell phone
    /// </param>
    /// <param name="email">
    /// Email
    /// </param>
    /// <param name="emailRecId">
    /// Email recid
    /// </param>
    /// <param name="url">
    /// URL
    /// </param>
    /// <param name="urlRecId">
    /// Url recid
    /// </param>
    /// <param name="multiLineDisc">
    /// Multiline discount
    /// </param>
    /// <param name="endDisc">
    /// End discount
    /// </param>
    /// <param name="lineDisc">
    /// Line discount
    /// </param>
    /// <param name="priceGroup">
    /// Price Group
    /// </param>
    /// <param name="taxGroup">
    /// Tax Group
    /// </param>
    /// <param name="creditMax">
    /// Credit Max
    /// </param>
    /// <param name="blocked">
    /// Blocked
    /// </param>
    /// <param name="orgId">
    /// Org ID
    /// </param>
    /// <param name="usePurchRequest">
    /// Use purchase request
    /// </param>
    /// <param name="vatNum">
    /// Vat Number
    /// </param>
    /// <param name="invoiceAccount">
    /// Invoice account
    /// </param>
    /// <param name="mandatoryCreditLimit">
    /// Mandotory credit limit
    /// </param>
    /// <param name="contactPersonId">
    /// Contact person ID
    /// </param>
    /// <param name="useOrderNumberReference">
    /// Use order number reference
    /// </param>
    /// <param name="receiptOption">
    /// Receipt option
    /// </param>
    /// <param name="receiptEmail">
    /// Receipt Email
    /// </param>
    /// <param name="identificationNumber">
    /// Identification Number
    /// </param>
    /// <param name="firstName">
    /// First name
    /// </param>
    /// <param name="middleName">
    /// Middle name
    /// </param>
    /// <param name="lastName">
    /// Last name
    /// </param>
    /// <param name="phoneExtension">
    /// Phone extension
    /// </param>
    /// <param name="cellphoneRecId">
    /// Cell phone record id
    /// </param>
    /// <param name="retailCustAffiliations">
    /// A XML string having the details of customer affiliation list
    /// </param>
    /// <param name="customerAttributes">
    /// A XML string containing the customer attributes
    /// </param>
    /// <param name="extensionProperties">
    /// Optional. Extension properties XML.
    /// </param>
    /// <param name="customerAttributes">
    /// Optional. An XML string having the details of customer attributes.
    /// </param>
    /// <param name="channelId">
    /// Optional. The store channel identifier.
    /// </param>
    /// <param name="custAttributesDataPackageVersion">
    /// Optional. The customer attributes data package version.
    /// </param>
    /// <returns>
    /// Results in container.
    /// </returns>
    /// <remarks>This method has been deprecated in favor of updateCustomerExt3.</remarks>
    public static container updateCustomerExt(int64                 custTableRecId,
                                        DirPartyName                custName,
                                        CustGroupId                 custGroup,
                                        CustCurrencyCode            currency,
                                        CustLanguageId              languageId,
                                        Phone                       phone,
                                        int64                       phoneRecId,
                                        PhoneMobile                 cellularPhone,
                                        LogisticsElectronicAddressLocator  email,
                                        int64                       emailRecId,
                                        URL                         url,
                                        int64                       urlRecId,
                                        CustMultiLineDiscCode       multiLineDisc,
                                        CustEndDiscCode             endDisc,
                                        CustLineDiscCode            lineDisc,
                                        CustPriceGroup              priceGroup,
                                        TaxGroup                    taxGroup,
                                        CustCreditMaxMST            creditMax,
                                        CustBlocked                 blocked,
                                        OrgId                       orgId,
                                        RetailUsePurchRequest       usePurchRequest,
                                        VATNum                      vatNum,
                                        CustInvoiceAccount          invoiceAccount,
                                        MandatoryCreditLimit        mandatoryCreditLimit,
                                        ContactPersonId             contactPersonId,
                                        RetailUseOrderNumberReference  useOrderNumberReference,
                                        RetailReceiptOption            receiptOption,
                                        RetailReceiptEmail             receiptEmail,
                                        CustIdentificationNumber    identificationNumber,
                                        FirstName firstName = '',
                                        MiddleName middleName = '',
                                        LastName lastName = '',
                                        PhoneLocal phoneExtension = '',
                                        int64 cellphoneRecId = 0,
                                        str retailCustAffiliations = '',
                                        str extensionProperties = '',
                                        str customerAttributes = '',
                                        int64 channelId = 0,
                                        int custAttributesDataPackageVersion = 1)
    {
        return RetailTransactionService::updateCustomer(
        custTableRecId,
        custName,
        custGroup,
        currency,
        languageId,
        phone,
        phoneRecId,
        cellularPhone,
        email,
        emailRecId,
        url,
        urlRecId,
        multiLineDisc,
        endDisc,
        lineDisc,
        priceGroup,
        taxGroup,
        creditMax,
        blocked,
        orgId,
        usePurchRequest,
        vatNum,
        invoiceAccount,
        mandatoryCreditLimit,
        contactPersonId,
        useOrderNumberReference,
        receiptOption,
        receiptEmail,
        identificationNumber,
        firstName,
        middleName,
        lastName,
        phoneExtension,
        cellphoneRecId,
        retailCustAffiliations,
        customerAttributes,
        channelId,
        custAttributesDataPackageVersion);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomerExt2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for updating an existing customer, with extension properties.
    /// </summary>
    /// <param name="custTableRecId">The unique record identifier for the associated CustTable table.</param>
    /// <param name="custName">The customer name.</param>
    /// <param name="custGroup">The customer group associated with the customer.</param>
    /// <param name="currency">The currency code.</param>
    /// <param name="languageId">The language identifier preferred for this customer.</param>
    /// <param name="phone">The primary phone number.</param>
    /// <param name="phoneRecId">The record identifier for the telephone number.</param>
    /// <param name="cellularPhone">The primary cell phone number.</param>
    /// <param name="email">The primary e-mail address.</param>
    /// <param name="emailRecId">The record identifier for the primary e-mail address.</param>
    /// <param name="url">The primary URL for this customer.</param>
    /// <param name="urlRecId">The record identifier for the URL parameter.</param>
    /// <param name="multiLineDisc">The multiline discount.</param>
    /// <param name="endDisc">The end discount.</param>
    /// <param name="lineDisc">The line discount.</param>
    /// <param name="priceGroup">The customer price group.</param>
    /// <param name="taxGroup">The customer's tax group.</param>
    /// <param name="creditMax">The maximum credit limit.</param>
    /// <param name="blocked">A value indicating whether this customer is to be marked as blocked.</param>
    /// <param name="orgId">The organization identifier associated to this customer.</param>
    /// <param name="usePurchRequest">A value indicating whether to use purchase requests.</param>
    /// <param name="vatNum">The customer's VAT number.</param>
    /// <param name="invoiceAccount">The customer's invoice account number.</param>
    /// <param name="mandatoryCreditLimit">A value indicating whether credit limit enforcement is mandatory.</param>
    /// <param name="contactPersonId">The contact person identifier.</param>
    /// <param name="useOrderNumberReference">A value indicating whether to use order number reference.</param>
    /// <param name="receiptOption">The customer's preferred receipt option.</param>
    /// <param name="receiptEmail">The customer's preferred receipt e-mail address.</param>
    /// <param name="identificationNumber">The customer's identification number.</param>
    /// <param name="firstName">The customer's first name.</param>
    /// <param name="middleName">The customer's middle name.</param>
    /// <param name="lastName">The customer's last name.</param>
    /// <param name="phoneExtension">The customer's telephone extension number.</param>
    /// <param name="cellphoneRecId">The cell phone record identifier.</param>
    /// <param name="retailCustAffiliations">A XML string having the details of customer affiliation list.</param>
    /// <param name="customerAttributes">A XML string containing the customer attributes.</param>
    /// <param name="extensionProperties"> Optional. The extension properties XML.</param>
    /// <param name="customerAttributes">Optional. An XML string having the details of customer attributes.</param>
    /// <param name="channelId">Optional. The store channel identifier.</param>
    /// <param name="custAttributesDataPackageVersion">Optional.The customer attributes data package version.</param>
    /// <param name="optOutPersonalization">Optional.A value indicating whether personalization has been disabled.</param>
    /// <param name="optOutWebActivityTracking">Optional.A value indicating whether web activity tracking has been disabled.</param>
    /// <returns>
    /// Results in container.
    /// </returns>
    /// <remarks>This method has been deprecated in favor of updateCustomerExt3.</remarks>
    public static container updateCustomerExt2(
        int64 custTableRecId,
        DirPartyName custName,
        CustGroupId custGroup,
        CustCurrencyCode currency,
        CustLanguageId languageId,
        Phone phone,
        int64 phoneRecId,
        PhoneMobile cellularPhone,
        LogisticsElectronicAddressLocator email,
        int64 emailRecId,
        URL url,
        int64 urlRecId,
        CustMultiLineDiscCode multiLineDisc,
        CustEndDiscCode endDisc,
        CustLineDiscCode lineDisc,
        CustPriceGroup priceGroup,
        TaxGroup taxGroup,
        CustCreditMaxMST creditMax,
        CustBlocked blocked,
        OrgId orgId,
        RetailUsePurchRequest usePurchRequest,
        VATNum vatNum,
        CustInvoiceAccount invoiceAccount,
        MandatoryCreditLimit mandatoryCreditLimit,
        ContactPersonId contactPersonId,
        RetailUseOrderNumberReference useOrderNumberReference,
        RetailReceiptOption receiptOption,
        RetailReceiptEmail receiptEmail,
        CustIdentificationNumber identificationNumber,
        FirstName firstName = '',
        MiddleName middleName = '',
        LastName lastName = '',
        PhoneLocal phoneExtension = '',
        int64 cellphoneRecId = 0,
        str retailCustAffiliations = '',
        str extensionProperties = '',
        str customerAttributes = '',
        int64 channelId = 0,
        int custAttributesDataPackageVersion = 1,
        RetailOptOutPersonalization optOutPersonalization = NoYes::No,
        RetailOptOutWebActivityTracking optOutWebActivityTracking = NoYes::No)
    {
        if (RetailTransactionServiceCustomerContext::current() != null)
        {
            return RetailTransactionService::updateCustomerExt(
                custTableRecId,
                custName,
                custGroup,
                currency,
                languageId,
                phone,
                phoneRecId,
                cellularPhone,
                email,
                emailRecId,
                url,
                urlRecId,
                multiLineDisc,
                endDisc,
                lineDisc,
                priceGroup,
                taxGroup,
                creditMax,
                blocked,
                orgId,
                usePurchRequest,
                vatNum,
                invoiceAccount,
                mandatoryCreditLimit,
                contactPersonId,
                useOrderNumberReference,
                receiptOption,
                receiptEmail,
                identificationNumber,
                firstName,
                middleName,
                lastName,
                phoneExtension,
                cellphoneRecId,
                retailCustAffiliations,
                extensionProperties,
                customerAttributes,
                channelId,
                custAttributesDataPackageVersion);
        }

        using (RetailTransactionServiceCustomerContext context = RetailTransactionServiceCustomerContext::construct())
        {
            context.parmOptOutPersonalization(optOutPersonalization);
            context.parmOptOutWebActivityTracking(optOutWebActivityTracking);

            return RetailTransactionService::updateCustomerExt(
                custTableRecId,
                custName,
                custGroup,
                currency,
                languageId,
                phone,
                phoneRecId,
                cellularPhone,
                email,
                emailRecId,
                url,
                urlRecId,
                multiLineDisc,
                endDisc,
                lineDisc,
                priceGroup,
                taxGroup,
                creditMax,
                blocked,
                orgId,
                usePurchRequest,
                vatNum,
                invoiceAccount,
                mandatoryCreditLimit,
                contactPersonId,
                useOrderNumberReference,
                receiptOption,
                receiptEmail,
                identificationNumber,
                firstName,
                middleName,
                lastName,
                phoneExtension,
                cellphoneRecId,
                retailCustAffiliations,
                extensionProperties,
                customerAttributes,
                channelId,
                custAttributesDataPackageVersion);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomerExt3</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for updating an existing customer, with extension properties.
    /// </summary>
    /// <param name="custTableRecId">The unique record identifier for the associated CustTable table.</param>
    /// <param name="custName">The customer name.</param>
    /// <param name="custGroup">The customer group associated with the customer.</param>
    /// <param name="currency">The currency code.</param>
    /// <param name="languageId">The language identifier preferred for this customer.</param>
    /// <param name="phone">The primary phone number.</param>
    /// <param name="phoneRecId">The record identifier for the telephone number.</param>
    /// <param name="cellularPhone">The primary cell phone number.</param>
    /// <param name="email">The primary e-mail address.</param>
    /// <param name="emailRecId">The record identifier for the primary e-mail address.</param>
    /// <param name="url">The primary URL for this customer.</param>
    /// <param name="urlRecId">The record identifier for the URL parameter.</param>
    /// <param name="multiLineDisc">The multiline discount.</param>
    /// <param name="endDisc">The end discount.</param>
    /// <param name="lineDisc">The line discount.</param>
    /// <param name="priceGroup">The customer price group.</param>
    /// <param name="taxGroup">The customer's tax group.</param>
    /// <param name="creditMax">The maximum credit limit.</param>
    /// <param name="blocked">A value indicating whether this customer is to be marked as blocked.</param>
    /// <param name="orgId">The organization identifier associated to this customer.</param>
    /// <param name="usePurchRequest">A value indicating whether to use purchase requests.</param>
    /// <param name="vatNum">The customer's VAT number.</param>
    /// <param name="invoiceAccount">The customer's invoice account number.</param>
    /// <param name="mandatoryCreditLimit">A value indicating whether credit limit enforcement is mandatory.</param>
    /// <param name="contactPersonId">The contact person identifier.</param>
    /// <param name="useOrderNumberReference">A value indicating whether to use order number reference.</param>
    /// <param name="receiptOption">The customer's preferred receipt option.</param>
    /// <param name="receiptEmail">The customer's preferred receipt e-mail address.</param>
    /// <param name="identificationNumber">The customer's identification number.</param>
    /// <param name="firstName">The customer's first name.</param>
    /// <param name="middleName">The customer's middle name.</param>
    /// <param name="lastName">The customer's last name.</param>
    /// <param name="phoneExtension">The customer's telephone extension number.</param>
    /// <param name="cellphoneRecId">The cell phone record identifier.</param>
    /// <param name="retailCustAffiliations">A XML string having the details of customer affiliation list.</param>
    /// <param name="customerAttributes">A XML string containing the customer attributes.</param>
    /// <param name="extensionProperties"> Optional. The extension properties XML.</param>
    /// <param name="customerAttributes">Optional. An XML string having the details of customer attributes.</param>
    /// <param name="channelId">Optional. The store channel identifier.</param>
    /// <param name="custAttributesDataPackageVersion">Optional.The customer attributes data package version.</param>
    /// <param name="optOutPersonalization">Optional.A value indicating whether personalization has been disabled.</param>
    /// <param name="optOutWebActivityTracking">Optional.A value indicating whether web activity tracking has been disabled.</param>
    /// <param name="customerTitleRecId">Optional.The record identifier of customer title.</param>
    /// <returns>
    /// Results in container.
    /// </returns>
    public static container updateCustomerExt3(
        int64 custTableRecId,
        DirPartyName custName,
        CustGroupId custGroup,
        CustCurrencyCode currency,
        CustLanguageId languageId,
        Phone phone,
        int64 phoneRecId,
        PhoneMobile cellularPhone,
        LogisticsElectronicAddressLocator email,
        int64 emailRecId,
        URL url,
        int64 urlRecId,
        CustMultiLineDiscCode multiLineDisc,
        CustEndDiscCode endDisc,
        CustLineDiscCode lineDisc,
        CustPriceGroup priceGroup,
        TaxGroup taxGroup,
        CustCreditMaxMST creditMax,
        CustBlocked blocked,
        OrgId orgId,
        RetailUsePurchRequest usePurchRequest,
        VATNum vatNum,
        CustInvoiceAccount invoiceAccount,
        MandatoryCreditLimit mandatoryCreditLimit,
        ContactPersonId contactPersonId,
        RetailUseOrderNumberReference useOrderNumberReference,
        RetailReceiptOption receiptOption,
        RetailReceiptEmail receiptEmail,
        CustIdentificationNumber identificationNumber,
        FirstName firstName = '',
        MiddleName middleName = '',
        LastName lastName = '',
        PhoneLocal phoneExtension = '',
        int64 cellphoneRecId = 0,
        str retailCustAffiliations = '',
        str extensionProperties = '',
        str customerAttributes = '',
        int64 channelId = 0,
        int custAttributesDataPackageVersion = 1,
        RetailOptOutPersonalization optOutPersonalization = NoYes::No,
        RetailOptOutWebActivityTracking optOutWebActivityTracking = NoYes::No,
        DirNamePersonalTitleRecId customerTitleRecId = 0)
    {
        using (RetailTransactionServiceCustomerContext context = RetailTransactionServiceCustomerContext::construct())
        {
            context.parmOptOutPersonalization(optOutPersonalization);
            context.parmOptOutWebActivityTracking(optOutWebActivityTracking);
            context.parmCustomerTitleRecId(customerTitleRecId);

            return RetailTransactionService::updateCustomerExt2(
                custTableRecId,
                custName,
                custGroup,
                currency,
                languageId,
                phone,
                phoneRecId,
                cellularPhone,
                email,
                emailRecId,
                url,
                urlRecId,
                multiLineDisc,
                endDisc,
                lineDisc,
                priceGroup,
                taxGroup,
                creditMax,
                blocked,
                orgId,
                usePurchRequest,
                vatNum,
                invoiceAccount,
                mandatoryCreditLimit,
                contactPersonId,
                useOrderNumberReference,
                receiptOption,
                receiptEmail,
                identificationNumber,
                firstName,
                middleName,
                lastName,
                phoneExtension,
                cellphoneRecId,
                retailCustAffiliations,
                extensionProperties,
                customerAttributes,
                channelId,
                custAttributesDataPackageVersion);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>enrollUserCredentials</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enrolls a user's authentication credentials.
    /// </summary>
    /// <param name = "staffId">The staff identifier.</param>
    /// <param name = "grantType">The authentication grant type.</param>
    /// <param name = "credentialId">The credential identifier.</param>
    /// <param name = "credential">The user credential secret.</param>
    /// <param name = "additionalAuthenticationData">Any additional authentication data.</param>
    /// <returns>The enrollment data result container.</returns>
    public static container enrollUserCredentials(RetailStaffId staffId, str grantType, str credentialId, str credential, str additionalAuthenticationData)
    {
        return RetailTransactionServiceEmployee::enrollUserCredentials(staffId, grantType, credentialId, credential, additionalAuthenticationData);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unenrollUserCredentials</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes a user's authentication credentials.
    /// </summary>
    /// <param name = "staffId">The staff identifier.</param>
    /// <param name = "grantType">The authentication grant type.</param>
    /// <returns>The result of the operation.</returns>
    public static container unenrollUserCredentials(RetailStaffId staffId, str grantType)
    {
        return RetailTransactionServiceEmployee::unenrollUserCredentials(staffId, grantType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUserCredential</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a user's authentication credentials.
    /// </summary>
    /// <param name = "credentialId">The credential identifier.</param>
    /// <param name = "grantType">The authentication grant type.</param>
    /// <returns>The result of the operation containing the authentication credentials.</returns>
    public static container getUserCredential(str credentialId, str grantType)
    {
        return RetailTransactionServiceEmployee::getUserCredential(credentialId, grantType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetOrderDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get full details for a single given order.
    /// </summary>
    /// <param name = "_transactionId">The Transaction Id of the order.</param>
    /// <param name = "_salesId">The Sales Id of the order.</param>
    /// <returns>
    /// A collection of orders in the form...
    /// <ArrayOfSalesOrder>
    ///     <SalesOrder />
    /// </ArrayOfSalesOrder>
    /// </returns>
    public static container GetOrderDetails(
        RetailTransactionId _transactionId,
        SalesId _salesId)
    {
        return RetailTransactionServiceTransactions::GetOrderDetails( _transactionId, _salesId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetRecommendationServiceCredentials</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a container containing the credentials required to access the Cortana Analytics recommendation service.
    /// </summary>
    /// <returns>A container containing the credentials required to access the Cortana Analytics recommendation service.</returns>
    public static container GetRecommendationServiceCredentials()
    {
        return RetailTransactionServiceRecommendations::GetRecommendationServiceCredentials();
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetStorageAccessTokenForUpload</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the blob container Uri and shared access signature key for the container.
    /// </summary>
    /// <returns>The blob container Uri and the shared access signature key.</returns>
    public static container GetStorageAccessTokenForUpload()
    {
        return RetailTransactionServiceTaskRecorder::GetStorageAccessTokenForUpload();
    }

]]></Source>
			</Method>
			<Method>
				<Name>UploadRecording</Name>
				<Source><![CDATA[
    /// <summary>
    /// Uploads the recording to Lifecycle Services.
    /// </summary>
    /// <param name = "recordingXml">The recording to be uploaded and saved to Lifecycle Services.</param>
    /// <param name = "bpmLineId">The business process model line identifier used to save the recording to Lifecycle Services.</param>
    /// <returns>The result and the error if any.</returns>
    public static container UploadRecording(str recordingXml, int bpmLineId)
    {
        return RetailTransactionServiceTaskRecorder::UploadRecording(recordingXml, bpmLineId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GenerateRecordingFile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a recording file and uploads it to Azure storage.
    /// </summary>
    /// <param name = "recordingXml">The recording XML used to generate the recording file.</param>
    /// <param name = "recordingName">The name of the recording.</param>
    /// <returns>A container that contains an URL that points to the file in temp storage if the file upload was successful; an error container if the upload was failed.</returns>
    public static container GenerateRecordingFile(str recordingXml, str recordingName)
    {
        return RetailTransactionServiceTaskRecorder::GenerateRecordingFile(recordingXml, recordingName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GenerateTrainingDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a training document and uploads it to Azure storage.
    /// </summary>
    /// <param name = "recordingXml">The recording XML used to generate the training document.</param>
    /// <param name = "recordingName">The name of the recording.</param>
    /// <returns>A container that contains an URL that points to the file in temp storage if the file upload was successful; otherwise, an error container if the upload was failed.</returns>
    public static container GenerateTrainingDocument(str recordingXml, str recordingName)
    {
        return RetailTransactionServiceTaskRecorder::GenerateTrainingDocument(recordingXml, recordingName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GenerateBusinessProcessModelPackage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a business process model package and uploads it to Azure storage.
    /// </summary>
    /// <param name = "recordingXml">The recording XML used to generate the business process model package.</param>
    /// <param name = "recordingName">The name of the recording.</param>
    /// <returns>A container that contains an URL that points to the file in temp storage if the file upload was successful; otherwise, an error container if the upload was failed.</returns>
    public static container GenerateBusinessProcessModelPackage(str recordingXml, str recordingName)
    {
        return RetailTransactionServiceTaskRecorder::GenerateBusinessProcessModelPackage(recordingXml, recordingName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GenerateRecordingBundle</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a recording bundle and uploads it to Azure storage.
    /// </summary>
    /// <param name = "recordingXml">The recording XML used to generate the recording bundle.</param>
    /// <param name = "recordingName">The name of the recording.</param>
    /// <returns>A container that contains an URL that points to the file in temp storage if the file upload was successful; otherwise, an error container if the upload was failed.</returns>
    public static container GenerateRecordingBundle(str recordingXml, str recordingName)
    {
        return RetailTransactionServiceTaskRecorder::GenerateRecordingBundle(recordingXml, recordingName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>DownloadRecording</Name>
				<Source><![CDATA[
    /// <summary>
    /// Downloads the recording from LCS.
    /// </summary>
    /// <param name = "businessProcessModelLineId">The business process model line identifier.</param>
    /// <returns>A container that contains the recording if download was successful; otherwise, an error container if the upload was failed.</returns>
    public static container DownloadRecording(int64 businessProcessModelLineId)
    {
        return RetailTransactionServiceTaskRecorder::DownloadRecording(businessProcessModelLineId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>SearchTaskGuidesByTitle</Name>
				<Source><![CDATA[
    /// <summary>
    /// Searches task guides by title.
    /// </summary>
    /// <param name = "businessProcessModelFrameworkId">The business process model framework identifier.</param>
    /// <param name = "taskGuideSearchKeyword">The task guide search keyword.</param>
    /// <param name = "queryTypeValue">The query type value.</param>
    /// <returns>A container that contains a collection of task guide search results.</returns>
    public static container SearchTaskGuidesByTitle(int64 businessProcessModelFrameworkId, str taskGuideSearchKeyword, int queryTypeValue)
    {
        return RetailTransactionServiceTaskRecorder::SearchTaskGuidesByTitle(businessProcessModelFrameworkId, taskGuideSearchKeyword, queryTypeValue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>LoadRecordingFromFile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads a recording from an XML file.
    /// </summary>
    /// <param name = "recordingUrl">The recording URL.</param>
    /// <returns>A container that contains the recording loaded from the XML file.</returns>
    public static container LoadRecordingFromFile(str recordingUrl)
    {
        return RetailTransactionServiceTaskRecorder::LoadRecordingFromFile(recordingUrl);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetBusinessProcessModelLibraries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the business process model libraries.
    /// </summary>
    /// <returns>A container that contains a collection of library frameworks.</returns>
    public static container GetBusinessProcessModelLibraries()
    {
        return RetailTransactionServiceTaskRecorder::GetBusinessProcessModelLibraries();
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetBusinessProcessModelLibrary</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a single business process model library.
    /// </summary>
    /// <param name="businessProcessModelFrameworkId">The business process model framework identifier.</param>
    /// <param name="hierarchyDepth">The hierarchy depth of the framework.</param>
    /// <returns>
    /// A container that contains a single business process model library framework.
    /// </returns>
    public static container GetBusinessProcessModelLibrary(int64 businessProcessModelFrameworkId, int hierarchyDepth)
    {
        return RetailTransactionServiceTaskRecorder::GetBusinessProcessModelLibrary(businessProcessModelFrameworkId, hierarchyDepth);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductsByItemId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the products by item ID range.
    /// </summary>
    /// <param name="_currentChannelRecId">
    /// The record ID of current channel.
    /// </param>
    /// <param name="_itemIdRangeValue">
    /// The item ID range to search for.
    /// </param>
    /// <param name="_startPosition">
    /// The starting record position.
    /// </param>
    /// <param name="_pageSize">
    /// The page size.
    /// </param>
    /// <param name="_orderByField">
    /// The order by field name.
    /// </param>
    /// <param name="_sortOrder">
    /// The sort order.
    /// </param>
    /// <param name="_includeTotalCount">
    /// Whether to include total number of records in the return value.
    /// </param>
    /// <param name="_languageId">
    /// The language to search in.
    /// </param>
    /// <param name="_otherChannelRecId">
    /// The record ID of other channel.
    /// </param>
    /// <param name="_catalogRecId">
    /// The record ID of the catalog to search products from.
    /// </param>
    /// <param name="_attributeRecIdRangeValue">
    /// The attribute record ID range value to filter product attribute values by.
    /// </param>
    /// <param name="_includePrice">
    /// Whether to include product prices in the return value.
    /// </param>
    /// <returns>
    /// A container having the products in a XML string.
    /// </returns>
    public static container getProductsByItemId(
        RetailChannelRecId  _currentChannelRecId,
        str                 _itemIdRangeValue,
        int64               _startPosition,
        int64               _pageSize,
        str                 _orderByField = 'ItemId',
        SortOrder           _sortOrder = SortOrder::Ascending,
        boolean             _includeTotalCount = false,
        str                 _languageId = '',
        RetailChannelRecId  _otherChannelRecId = 0,
        CatalogRefRecId     _catalogRecId = 0,
        str                 _attributeRecIdRangeValue = '',
        boolean             _includePrice = true)
    {
        return RetailTransactionServiceProduct::getProductsByItemId(
            _currentChannelRecId,
            _itemIdRangeValue,
            _startPosition,
            _pageSize,
            _orderByField,
            _sortOrder,
            _includeTotalCount,
            _languageId,
            _otherChannelRecId,
            _catalogRecId,
            _attributeRecIdRangeValue,
            _includePrice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductsByProductRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the products by product record ID range.
    /// </summary>
    /// <param name="_currentChannelRecId">
    /// The record ID of current channel.
    /// </param>
    /// <param name="_productRecIdRangeValue">
    /// The product record ID range to search for.
    /// </param>
    /// <param name="_startPosition">
    /// The starting record position.
    /// </param>
    /// <param name="_pageSize">
    /// The page size.
    /// </param>
    /// <param name="_orderByField">
    /// The order by field name.
    /// </param>
    /// <param name="_sortOrder">
    /// The sort order.
    /// </param>
    /// <param name="_includeTotalCount">
    /// Whether to include total number of records in the return value.
    /// </param>
    /// <param name="_languageId">
    /// The language to search in.
    /// </param>
    /// <param name="_otherChannelRecId">
    /// The record ID of other channel.
    /// </param>
    /// <param name="_catalogRecId">
    /// The record ID of the catalog to search products from.
    /// </param>
    /// <param name="_attributeRecIdRangeValue">
    /// The attribute record ID range value to filter product attribute values by.
    /// </param>
    /// <param name="_includePrice">
    /// Whether to include product prices in the return value.
    /// </param>
    /// <returns>
    /// A container having the products in a XML string.
    /// </returns>
    public static container getProductsByProductRecId(
        RetailChannelRecId  _currentChannelRecId,
        str                 _productRecIdRangeValue,
        int64               _startPosition,
        int64               _pageSize,
        str                 _orderByField = 'ItemId',
        SortOrder           _sortOrder = SortOrder::Ascending,
        boolean             _includeTotalCount = false,
        str                 _languageId = '',
        RetailChannelRecId  _otherChannelRecId = 0,
        CatalogRefRecId     _catalogRecId = 0,
        str                 _attributeRecIdRangeValue = '',
        boolean             _includePrice = true)
    {
        return RetailTransactionServiceProduct::getProductsByProductRecId(
            _currentChannelRecId,
            _productRecIdRangeValue,
            _startPosition,
            _pageSize,
            _orderByField,
            _sortOrder,
            _includeTotalCount,
            _languageId,
            _otherChannelRecId,
            _catalogRecId,
            _attributeRecIdRangeValue,
            true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLinkExternalIdWithCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for Adding a link between an external identifier and a customer account.
    /// </summary>
    /// <param name="externalIdentityId">
    /// The external identity identifier.
    /// </param>
    /// <param name="externalIdentityProviderIssuer">
    /// The external identity provider issuer.
    /// </param>
    /// <param name="customerAccountNumber">
    /// The associated customer account.
    /// </param>
    /// <returns>
    /// Container with result of unlink request.
    /// </returns>
    public static container createLinkExternalIdWithCustomer(RetailExternalIdentityId externalIdentityId,
                                                             str externalIdentityProviderIssuer,
                                                             CustAccount customerAccountNumber)
    {
        return RetailTransactionServiceCustomer::createLinkExternalIdWithExistingCustomer(
            externalIdentityId,
            externalIdentityProviderIssuer,
            customerAccountNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initiateLinkExternalIdWithCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for initiating a link between an external identifier and an existing customer account.
    /// </summary>
    /// <param name="emailAddress">
    /// Email address used to look up customer account.
    /// </param>
    /// <param name="activationToken">
    /// The token for activating the link.
    /// </param>
    /// <param name="externalIdentityId">
    /// The external identity identifier.
    /// </param>
    /// <param name="externalIdentityIssuer">
    /// The external identity issuer.
    /// </param>
    /// <param name="customerAccountNumber">
    /// Customer account number.
    /// </param>
    /// <returns>
    /// Container with result of link up request.
    /// </returns>
    public static container initiateLinkExternalIdWithCustomer(Email    emailAddress,
                                                               str    activationToken,
                                                               RetailExternalIdentityId    externalIdentityId,
                                                               str    identityProviderIssuer,
                                                               CustAccount    customerAccountNumber)
    {
        return RetailTransactionServiceCustomer::initiateLinkExternalIdWithCustomer(
            emailAddress,
            activationToken,
            externalIdentityId,
            identityProviderIssuer,
            customerAccountNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeLinkExternalIdWithCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for finalize a link between an external identifier and an existing customer account.
    /// </summary>
    /// <param name="emailAddress">
    /// Email address used to look up customer account.
    /// </param>
    /// <param name="activationToken">
    /// The token for activating the link.
    /// </param>
    /// <returns>
    /// Container with result of link up request.
    /// </returns>
    public static container finalizeLinkExternalIdWithCustomer(Email    emailAddress,
                                                               str    activationToken)
    {
        return RetailTransactionServiceCustomer::finalizeLinkExternalIdWithCustomer(
            emailAddress,
            activationToken);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unlinkExternalIdFromCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for deleting an existing link between an external identifier and a customer account.
    /// </summary>
    /// <param name="externalIdentityId">
    /// The external identity identifier.
    /// </param>
    /// <param name="externalIdentityProviderIssuer">
    /// The external identity provider issuer.
    /// </param>
    /// <param name="customerAccountNumber">
    /// The associated customer account.
    /// </param>
    /// <returns>
    /// Container with result of unlink request.
    /// </returns>
    public static container unlinkExternalIdFromCustomer(RetailExternalIdentityId    externalIdentityId,
                                                         str    externalIdentityProviderIssuer,
                                                         CustAccount customerAccountNumber)
    {
        return RetailTransactionServiceCustomer::unlinkExternalIdFromCustomer(
            externalIdentityId,
            externalIdentityProviderIssuer,
            customerAccountNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateClientBook</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update client book.
    /// 1. If fromStaffId is null and toStaffId has value, it means adding customer to toStaffId's client book.
    /// 2. If fromStaffId has value and toStaffId is null, it means removing customer from fromStaffId's client book.
    /// 3. If both fromStaffId and toStaffId have values, it means reassigning customer.
    /// </summary>
    /// <param name = "_channelId">
    /// The channel identifier.
    /// </param>
    /// <param name = "_serializedClientBookChanges">
    /// The collection of client book changes in JSON format.
    /// </param>
    /// <returns>
    /// A base 64 encoded CDX package representing the client book update.
    /// </returns>
    public static container updateClientBook(RetailChannelRecId _channelId,
                                             str _serializedClientBookChanges)
    {
        return RetailTransactionServiceCustomer::updateClientBook(
            _channelId,
            _serializedClientBookChanges);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetSalesOrderDetailsByTransactionId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get full details for a single given sale transaction.
    /// </summary>
    /// <param name = "_xmlArgumentString">
    /// The XML document containing the identifier(s) for the entity whose details are to be retrieved.
    /// <![CDATA[
    ///   <_root>
    ///     <Arguments>
    ///         <TransactionId></TransactionId>
    ///     </Arguments>
    ///  </_root>
    ///  ]]]]]]><![CDATA[><![CDATA[>
    /// </param>
    /// <returns>
    /// A collection of orders in the form...
    /// <![CDATA[
    ///   <_root>
    ///     <ArrayOfSalesOrder>
    ///         <SalesOrder />
    ///     </ArrayOfSalesOrder>
    ///  </_root>
    ///  ]]]]]]><![CDATA[><![CDATA[>
    /// </returns>
    public static container GetSalesOrderDetailsByTransactionId(
        str _xmlArgumentString = '')
    {
        return RetailTransactionServiceTransactions::GetSalesOrderDetailsByTransactionId(_xmlArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAuditEventList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets audit event list.
    /// </summary>
    /// <param name = "_xmlArgumentString">
    /// The XML document containing the identifier(s) for the entity whose details are to be retrieved.
    /// </param>
    /// <returns><c>Container</c> with success value, error description (if any) and audit event list serialized to XML.</returns>
    public static container getAuditEventList(str _xmlArgumentString)
    {
        return RetailTransactionServiceAuditEvents::getAuditEventList(_xmlArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerAuditEvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Registers an audit event.
    /// </summary>
    /// <param name="_auditEventXmlStr">
    /// The input xml string containing the audit event information.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the creation of record is successful and false otherwise.
    /// </returns>
    public static container registerAuditEvent(str _auditEventXmlStr)
    {
        return RetailTransactionServiceAuditEvents::registerAuditEvent(_auditEventXmlStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAuditEventExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Valdiates whether an audit event of specified search criteria exists.
    /// </summary>
    /// <param name = "_xmlArgumentString">
    /// The XML document containing the search criteria of audit event to search for.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if a specified audit event exist, otherwise false.
    /// </returns>
    public static container validateAuditEventExists(str _xmlArgumentString = '')
    {
        return RetailTransactionServiceAuditEvents::validateAuditEventExists(_xmlArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetSalesOrderDetailsBySalesId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get full details for a single given order.
    /// </summary>
    /// <param name = "_xmlArgumentString">
    /// The XML document containing the identifier(s) for the entity whose details are to be retrieved.
    /// If multiple ids are given, priority is as follows: Receipt Id > Transction Id > Sales Id > Quote Id.
    /// <![CDATA[
    ///   <_root>
    ///     <Arguments>
    ///         <SalesId></SalesId>
    ///     </Arguments>
    ///  </_root>
    ///  ]]]]]]><![CDATA[><![CDATA[>
    /// </param>
    /// <returns>
    /// A collection of orders in the form...
    /// <![CDATA[
    ///   <_root>
    ///     <ArrayOfSalesOrder>
    ///         <SalesOrder />
    ///     </ArrayOfSalesOrder>
    ///  </_root>
    ///  ]]]]]]><![CDATA[><![CDATA[>
    /// </returns>
    public static container GetSalesOrderDetailsBySalesId(
        str _xmlArgumentString = '')
    {
        return RetailTransactionServiceTransactions::GetSalesOrderDetailsBySalesId(_xmlArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetSalesOrderDetailsByQuotationId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get full details for a single given quote.
    /// </summary>
    /// <param name = "_xmlArgumentString">
    /// The XML document containing the identifier(s) for the entity whose details are to be retrieved.
    /// If multiple ids are given, priority is as follows: Receipt Id > Transction Id > Sales Id > Quote Id.
    /// <![CDATA[
    ///   <_root>
    ///     <Arguments>
    ///         <QuotationId></QuotationId>
    ///     </Arguments>
    ///  </_root>
    ///  ]]]]]]><![CDATA[><![CDATA[>
    /// </param>
    /// <returns>
    /// A collection of orders in the form...
    /// <![CDATA[
    ///   <_root>
    ///     <ArrayOfSalesOrder>
    ///         <SalesOrder />
    ///     </ArrayOfSalesOrder>
    ///  </_root>
    ///  ]]]]]]><![CDATA[><![CDATA[>
    /// </returns>
    public static container GetSalesOrderDetailsByQuotationId(
        str _xmlArgumentString = '')
    {
        return RetailTransactionServiceTransactions::GetSalesOrderDetailsByQuotationId(_xmlArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ValidateCouponUsageLimits</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method for validating coupon usage limits.
    /// </summary>
    /// <param name="couponCodeIdCollection">
    /// The coupon code identifier collection.
    /// </param>
    /// <param name="customerAccount">
    /// The customer account on the transaction.
    /// </param>
    /// <param name="channelId">
    /// The channel identifier.
    /// </param>
    /// <returns>
    /// Container with validation result and invalid coupon code identifiers, if any.
    /// </returns>
    public static container ValidateCouponUsageLimits(str couponCodeIdCollection,
                                                         str    customerAccount,
                                                         int64  channelId)
    {
        return RetailTransactionServiceCoupon::ValidateCouponUsageLimits(
            couponCodeIdCollection,
            customerAccount,
            channelId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ValidateCouponUsageLimitsV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method for validating coupon usage limits.
    /// </summary>
    /// <param name="_criteriaJson">The validate criteria object JSON string.</param>
    /// <returns>Container with validation result and invalid coupon code identifiers, if any.</returns>
    public static container ValidateCouponUsageLimitsV2(str _criteria)
    {
        return RetailTransactionServiceCoupon::ValidateCouponUsageLimitsV2(_criteria);
    }

]]></Source>
			</Method>
			<Method>
				<Name>UpdateCouponUsage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method for updating coupon usage limits.
    /// </summary>
    /// <param name="couponCodeIdCollection">
    /// The coupon code identifier collection.
    /// </param>
    /// <param name="customerAccount">
    /// The customer account on the transaction.
    /// </param>
    /// <param name="channelId">
    /// The channel identifier.
    /// </param>
    /// <param name = "status">
    /// The coupon usage status.
    /// </param>
    /// <param name = "transactionId">
    /// The transaction identifier.
    /// </param>
    /// <param name = "receiptId">
    /// The receipt identifier.
    /// </param>
    /// <param name = "salesId">
    /// The sales identifier.
    /// </param>
    /// <returns>
    /// Container with validation result and invalid coupon code identifiers, if any.
    /// </returns>
    public static container UpdateCouponUsage(str couponCodeIdCollection,
                                                         str    customerAccount,
                                                         int64  channelId,
                                                         RetailCouponUsageStatus status,
                                                         str transactionId,
                                                         str receiptId,
                                                         str salesId)
    {
        return RetailTransactionServiceCoupon::UpdateCouponUsage(
            couponCodeIdCollection,
            customerAccount,
            channelId,
            Status,
            transactionId,
            receiptId,
            salesId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>UpdateCouponUsageV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method for updating coupon usage limits.
    /// </summary>
    /// <param name="couponCodeIdCollection">
    /// The coupon code identifier collection.
    /// </param>
    /// <param name="customerAccount">
    /// The customer account on the transaction.
    /// </param>
    /// <param name="channelId">
    /// The channel identifier.
    /// </param>
    /// <param name = "status">
    /// The coupon usage status.
    /// </param>
    /// <param name = "transactionId">
    /// The transaction identifier.
    /// </param>
    /// <param name = "receiptId">
    /// The receipt identifier.
    /// </param>
    /// <param name = "salesId">
    /// The sales identifier.
    /// </param>
    /// <param name = "isValidationRequired">
    /// A value indicating whether coupon usage validation is required during coupon usage update process.
    /// </param>
    /// <returns>
    /// Container with validation result and invalid coupon code identifiers, if any.
    /// </returns>
    public static container UpdateCouponUsageV2(str couponCodeIdCollection,
                                                         str    customerAccount,
                                                         int64  channelId,
                                                         RetailCouponUsageStatus status,
                                                         str transactionId,
                                                         str receiptId,
                                                         str salesId,
                                                         boolean isValidationRequired)
    {
        return RetailTransactionServiceCoupon::UpdateCouponUsageV2(
            couponCodeIdCollection,
            customerAccount,
            channelId,
            Status,
            transactionId,
            receiptId,
            salesId,
            isValidationRequired);
    }

]]></Source>
			</Method>
			<Method>
				<Name>PackFulfillmentLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the status of the fulfillment lines to Packed.
    /// </summary>
    /// <param name="_fulfillmentXmlString">
    /// XML string containing the fulfillment lines.
    /// </param>
    /// <returns>
    /// A <c>Container</c> containing result info.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message (optional)
    /// </remarks>
    public static container PackFulfillmentLines(str _fulfillmentXmlString)
    {
        return RetailTransactionServiceFulfillment::PackFulfillmentLines(_fulfillmentXmlString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>MarkFulfillmentLinesAsPacked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the status of the fulfillment lines to Packed.
    /// </summary>
    /// <param name="_fulfillmentXmlString">
    /// XML string containing the fulfillment lines.
    /// </param>
    /// <returns>
    /// A <c>Container</c> containing result info.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message (optional)
    /// 3 - Packing Slip Id of the new packing slip created for the fulfillment lines.
    /// 4 - result returned by extension implemented by partner.
    /// </remarks>
    public static container MarkFulfillmentLinesAsPacked(str _fulfillmentXmlString)
    {
        return RetailTransactionServiceFulfillment::MarkFulfillmentLinesAsPacked(_fulfillmentXmlString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>AcceptFulfillmentLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the status of the fulfillment lines to Accepted.
    /// </summary>
    /// <param name="_fulfillmentXmlString">
    /// XML string containing the fulfillment lines.
    /// </param>
    /// <returns>
    /// A <c>Container</c> containing result info.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message (optional)
    /// </remarks>
    public static container AcceptFulfillmentLines(str _fulfillmentXmlString)
    {
        return RetailTransactionServiceFulfillment::AcceptFulfillmentLines(_fulfillmentXmlString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shipFulfillmentLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ship the fulfillment lines.
    /// </summary>
    /// <param name="_fulfillmentXmlString">
    /// XML string containing the fulfillment lines.
    /// </param>
    /// <returns>
    /// A <c>Container</c> containing result info.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message (optional)
    /// </remarks>
    public static container shipFulfillmentLines(str _fulfillmentXmlString)
    {
        return RetailTransactionServiceFulfillment::shipFulfillmentLines(_fulfillmentXmlString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFulfillmentLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get list of fulfillment lines.
    /// </summary>
    /// <param name = "_fulfillmentSearchCriteriaXml">The fulfillment search criteria xml.</param>
    /// <returns>A container that has list of fulfillment lines that matches the fulfillment criteria.</returns>
    /// <remarks>
    /// Xml argument example:
    /// <TransactionServiceFulfillmentLineSearchCriteria>
    ///  <DeliveryTypeValue>1</DeliveryTypeValue/>
    ///  <SalesId/>
    ///  <CustomerId/>
    ///  <CustomerName/>
    ///  <EmailAddress/>
    ///  <ChannelReferenceId />
    ///  <ReceiptId/>
    ///  <FulfillmentStatusValue>5,6,7</FulfillmentStatusValue>
    ///  <OrderCreatedStartDate/>
    ///  <OrderCreatedEndDate/>
    ///  <RequestedDeliveryStartDate/>
    ///  <RequestedDeliveryEndDate/>
    ///  <RequestedReceiptStartDate/>
    ///  <RequestedReceiptEndDate/>
    ///  <DeliveryModeCode/>
    ///  <StartDateTime/>
    ///  <EndDateTime/>
    ///  <WarehouseId />
    ///  <StoreId/>
    ///
    ///  <PagingInfo>
    ///    <Skip/>
    ///    <Top/>
    ///  </PagingInfo>
    /// </TransactionServiceFulfillmentLineSearchCriteria>
    /// </remarks>
    public static container getFulfillmentLines(str _fulfillmentSearchCriteriaXml)
    {
        return RetailTransactionServiceFulfillment::getFulfillmentLines(_fulfillmentSearchCriteriaXml);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPackingSlipsData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the packing slip data given a sales order identifier.
    /// </summary>
    /// <param name = "salesId">The sales order identifier.</param>
    /// <returns>A <c>Container</c> containing result info.</returns>
    public static container getPackingSlipsData(str salesId)
    {
        return RetailTransactionServiceFulfillment::getPackingSlipsData(salesId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFulfillmentLinesByPackingSlipId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets fulfillment lines associated with the packing slip.
    /// </summary>
    /// <param name = "salesId">Sales Id of the packing slip.</param>
    /// <param name = "packingSlipId">Packing slip Id.</param>
    /// <returns>
    /// A container that has list of fulfillment lines of requested packing slip.
    /// </returns>
    public static container getFulfillmentLinesByPackingSlipId(SalesId salesId, PackingSlipId packingSlipId)
    {
        return RetailTransactionServiceFulfillment::getFulfillmentLinesByPackingSlipId(salesId, packingSlipId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>PickFulfillmentLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the status of the fulfillment lines to Picking.
    /// </summary>
    /// <param name="_fulfillmentXmlString">
    /// XML string containing the fulfillment lines.
    /// </param>
    /// <returns>
    /// A <c>Container</c> containing result info.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message (optional)
    /// </remarks>
    public static container PickFulfillmentLines(str _fulfillmentXmlString)
    {
        return RetailTransactionServiceFulfillment::PickFulfillmentLines(_fulfillmentXmlString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>rejectFulfillmentLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the status of the fulfillment lines to Rejected.
    /// </summary>
    /// <param name="_fulfillmentXmlString">
    /// XML string containing the fulfillment lines.
    /// </param>
    /// <returns>
    ///  A <c>Container</c> containing result info.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message (optional)
    /// </remarks>
    public static container rejectFulfillmentLines(str _fulfillmentXmlString)
    {
        return RetailTransactionServiceFulfillment::rejectFulfillmentLines(_fulfillmentXmlString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>MarkAsPicked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the status of the fulfillment lines to Picked.
    /// </summary>
    /// <param name="_fulfillmentXmlString">
    /// XML string containing the fulfillment lines.
    /// </param>
    /// <returns>
    /// A <c>Container</c> containing result info.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message (optional)
    /// </remarks>
    public static container MarkAsPicked(str _fulfillmentXmlString)
    {
        return RetailTransactionServiceFulfillment::MarkAsPicked(_fulfillmentXmlString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransferOrderComments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets all the comment made on the specified transfer order.
    /// </summary>
    /// <param name = "_transferId">The transfer order identifier.</param>
    /// <returns>A container containing the result of the operation and
    /// and the list of comment objects in xml format.</returns>
    /// <remarks>
    /// The xml that contains the comments has this format
    /// <![CDATA[
    /// <Comments>
    ///   <Comment Text="comment string one" AuthorStaffId="StaffId" AuthorName="commenter's name" RecordId="5678" CreatedDateTime="" />
    ///   <Comment Text="comment string two" AuthorStaffId="StaffId" AuthorName="commenter's name" RecordId="5679" CreatedDateTime="" />
    /// </Comments>
    /// ]]]]><![CDATA[>
    /// </remarks>
    public static server container getTransferOrderComments(InventTransferId _transferId)
    {
        return RetailTransactionServiceInventory::getTransferOrderComments(_transferId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCommentOnTransferOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a comment to the specified transfer order.
    /// </summary>
    /// <param name = "_transferId">The transfer order identifier.</param>
    /// <param name = "_staffId">The staff commenting on the transfer order.</param>
    /// <param name = "_comment">The transfer order comment.</param>
    /// <returns>The transfer order comment.</returns>
    /// <remarks>
    /// The xml that contains the comment has this format.
    /// <![CDATA[
    /// <Comments>
    ///   <Comment Text="comment string" AuthorStaffId="StaffId" AuthorName="commenter's name" RecordId="5678" CreatedDateTime="" />
    /// </Comments>
    /// ]]]]><![CDATA[>
    /// </remarks>
    public static server container addCommentOnTransferOrder(InventTransferId _transferId, RetailStaffId _commentedBy, str _comment)
    {
        return RetailTransactionServiceInventory::addCommentOnTransferOrder(_transferId, _commentedBy, _comment);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransferOrderJournals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the list of transfer order journal for the specified order.
    /// </summary>
    /// <param name = "_transferOrderId">The transfer order Id.</param>
    /// <returns>The collection of transfer order journal headers in xml format</returns>
    public static server container getTransferOrderJournals(str _transferOrderId)
    {
        return RetailTransactionServiceInventory::getTransferOrderJournals(_transferOrderId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransferOrderJournalDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the transfer order journal detail for the specified transfer journal voucher Id.
    /// </summary>
    /// <param name = "_transferOrderId">The transfer order Id.</param>
    /// <param name = "_voucherId">The voucher Id of the transfer journal being retrieved.</param>
    /// <returns>A containier [resultStatus, errorMessage, transferJournalDetailXmlStr]</returns>
    /// <remarks>
    /// The xml that contains the transfer journal detail has this format
    /// <![CDATA[
    ///   <TransferOrderJournal TransferId="10000" VoucherId="00001" UpdatedByWorker="00012" TransferDate="" >
    ///         <TransferOrderJournalLine ItemId="122" ProductName="item one" InventColorId="Red" InventSizeId="" InventStyleId="" InventVersionId="" ConfigId="" QtyShipped="1" />
    ///         <TransferOrderJournalLine ItemId="123" ProductName="item two" InventColorId="" InventSizeId="XL" InventStyleId="" InventVersionId="" ConfigId="" QtyShipped="1" />
    ///   </TransferOrderJournal>
    /// ]]]]><![CDATA[>
    /// </remarks>
    public static server container getTransferOrderJournalDetail(str _transferOrderId, str _voucherId)
    {
        return RetailTransactionServiceInventory::getTransferOrderJournalDetail(_transferOrderId, _voucherId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransferOrderJournalDetailV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the transfer order journal detail.
    /// </summary>
    /// <param name = "_searchCriteriaJson">The search criteria.</param>
    /// <returns>A containier [resultStatus, errorMessage, transferJournalDetailXmlStr]</returns>
    public static server container getTransferOrderJournalDetailV2(str _searchCriteriaJson)
    {
        return RetailTransactionServiceInventory::getTransferOrderJournalDetailV2(_searchCriteriaJson);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSecretValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the secret value as a string.
    /// </summary>
    /// <param name="_secretName">
    /// The name of the secret as defined by the user.
    /// </param>
    /// <returns>
    /// A container having the secret value as a string.
    /// </returns>
    public static container getSecretValue(str _secretName)
    {
        return RetailTransactionServiceSecretProvider::getSecretValue(_secretName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSalesOrderCreateLinesQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a <c>Query</c> object that is used for querying the list of
    /// sales orders from <c>SalesTable</c> using specified filter conditions.
    /// </summary>
    /// <param name = "_custAccount">
    /// The customer Id in the sales order.
    /// </param>
    /// <returns>
    /// The <c>Query</c> object created for querying the list of sales orders using specified filter conditions.
    /// </returns>
    protected static Query buildSalesOrderCreateLinesQuery(CustAccount _custAccount)
    {
        Query salesTableQuery = new Query();

        QueryBuildDataSource salesTableQueryBuildDS = salesTableQuery.addDataSource(tableNum(SalesTable));
        
        salesTableQueryBuildDS.addSelectionField(fieldNum(SalesTable, SalesType));
        salesTableQueryBuildDS.addSelectionField(fieldNum(SalesTable, CustAccount));
        salesTableQueryBuildDS.addSelectionField(fieldNum(SalesTable, SalesStatus));
        salesTableQueryBuildDS.addSelectionField(fieldNum(SalesTable, SalesId));

        salesTableQueryBuildDS.addRange(fieldNum(SalesTable, SalesType)).value(queryValue(SalesType::Sales));
        salesTableQueryBuildDS.addRange(fieldNum(SalesTable, CustAccount)).value(queryValue(_custAccount));
        salesTableQueryBuildDS.addRange(fieldNum(SalesTable, SalesStatus)).value(queryValue(enum2int(SalesStatus::None)));
        salesTableQueryBuildDS.addRange(fieldNum(SalesTable, SalesStatus)).value(queryValue(enum2int(SalesStatus::Backorder)));
        salesTableQueryBuildDS.addRange(fieldNum(SalesTable, SalesStatus)).value(queryValue(enum2int(SalesStatus::Delivered)));

        return salesTableQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSalesOrderPaymentTransQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a <c>Query</c> object that is used for querying the list of
    /// sales orders from <c>SalesTable</c> using specified filter conditions.
    /// </summary>
    /// <param name = "_custAccount">
    /// The customer Id in the sales order.
    /// </param>
    /// <returns>
    /// The <c>Query</c> object created for querying the list of sales orders using specified filter conditions.
    /// </returns>
    protected static Query buildSalesOrderPaymentTransQuery(CustAccount _custAccount)
    {
        Query salesTablePaymentQuery = new Query();

        QueryBuildDataSource salesTablePaymentQueryBuildDS = salesTablePaymentQuery.addDataSource(tableNum(SalesTable));

        salesTablePaymentQueryBuildDS.addSelectionField(fieldNum(SalesTable, SalesType));
        salesTablePaymentQueryBuildDS.addSelectionField(fieldNum(SalesTable, CustAccount));
        salesTablePaymentQueryBuildDS.addSelectionField(fieldNum(SalesTable, SalesStatus));
        salesTablePaymentQueryBuildDS.addSelectionField(fieldNum(SalesTable, SalesId));

        salesTablePaymentQueryBuildDS.addOrderByField(fieldNum(SalesTable, SalesId));

        salesTablePaymentQueryBuildDS.addRange(fieldNum(SalesTable, SalesType)).value(queryValue(SalesType::Sales));
        salesTablePaymentQueryBuildDS.addRange(fieldNum(SalesTable, CustAccount)).value(queryValue(_custAccount));
        salesTablePaymentQueryBuildDS.addRange(fieldNum(SalesTable, SalesStatus)).value(queryValue(enum2int(SalesStatus::None)));
        salesTablePaymentQueryBuildDS.addRange(fieldNum(SalesTable, SalesStatus)).value(queryValue(enum2int(SalesStatus::Backorder)));
        salesTablePaymentQueryBuildDS.addRange(fieldNum(SalesTable, SalesStatus)).value(queryValue(enum2int(SalesStatus::Delivered)));

        QueryBuildDataSource retailPrePaymentTransQueryBuildDS = salesTablePaymentQueryBuildDS.addDataSource(tableNum(RetailPrePaymentTrans));
        retailPrePaymentTransQueryBuildDS.joinMode(JoinMode::ExistsJoin);
        retailPrePaymentTransQueryBuildDS.relations(true);

        return salesTablePaymentQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxInformation_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new primary tax information record from XML.
    /// </summary>
    /// <param name = "_taxInformationXml">The XML string containing a tax information entity with nested tax registration number entities.</param>
    /// <returns>The XML containing the collection of tax information entities.</returns>
    /// <remarks>
    /// The primary tax information entity contains nested tax registration numbers.
    /// </remarks>
    public static container createTaxInformation_IN(str _taxInformationXml)
    {
        return RetailTransactionServiceCustomer::createTaxInformation_IN(_taxInformationXml);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdatePANNumber_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates a customer's PAN number.
    /// </summary>
    /// <param name = "_accountNum">The customer account number.</param>
    /// <param name = "_panNumber">The PAN number.</param>
    /// <returns>The container with the created or updated TaxInformationCustTable_IN record in XML.</returns>
    public static container createOrUpdatePANNumber_IN(str _accountNum, str _panNumber)
    {
        return RetailTransactionServiceCustomer::createOrUpdatePANNumber_IN(_accountNum, _panNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxIdentifiers_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates CNPJCPFNum_BR, IENum_BR, CCMNum_BR fields for a specific customer identified in the XML.
    /// </summary>
    /// <param name = "_taxIdentifiersDataXml">The XML string containing customer id and CNPJCPF, IE, CCM numbers.</param>
    /// <returns>A <c>Container</c> containing result info.</returns>
    public static container updateTaxIdentifiers_BR(str _taxIdentifiersDataXml)
    {
        return RetailTransactionServiceCustomer::updateTaxIdentifiers_BR(_taxIdentifiersDataXml);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerTimelineItemTypes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets customer time line item types.
    /// </summary>
    /// <returns>
    /// A container with entity keys.
    /// </returns>
    public static container getCustomerTimelineItemTypes()
    {
        return RetailTransactionServiceCustomer::getCustomerTimelineItemTypes();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerTimelineItems</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets customer time line items.
    /// </summary>
    /// <param name="criteriaJsonArgumentString">
    /// JSON string contains the criteria arguments for the method call.
    /// </param>
    /// <param name="querySettingsJsonArgumentString">
    /// JSON string contains the query settings arguments for the method call.
    /// </param>
    /// <returns>
    /// A container with entity keys.
    /// </returns>
    public static container getCustomerTimelineItems(str criteriaJsonArgumentString = '', str querySettingsJsonArgumentString = '')
    {
        return RetailTransactionServiceCustomer::getCustomerTimelineItems(criteriaJsonArgumentString, querySettingsJsonArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustomerActivity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates activity for the customer.
    /// </summary>
    /// <param name="jsonArgumentString">
    /// JSON string contains the arguments for the method call.
    /// </param>
    /// <returns>
    /// A container with entity keys.
    /// </returns>
    public static container createCustomerActivity(str jsonArgumentString = '')
    {
        return RetailTransactionServiceCustomer::createCustomerActivity(jsonArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustomerNote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates note for the customer.
    /// </summary>
    /// <param name="jsonArgumentString">
    /// JSON string contains the arguments for the method call.
    /// </param>
    /// <returns>
    /// A container with entity keys.
    /// </returns>
    public static container createCustomerNote(str jsonArgumentString = '')
    {
        return RetailTransactionServiceCustomer::createCustomerNote(jsonArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomerActivity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates activity for the customer.
    /// </summary>
    /// <param name="jsonArgumentString">
    /// JSON string contains the arguments for the method call.
    /// </param>
    /// <returns>
    /// A container with entity keys.
    /// </returns>
    public static container updateCustomerActivity(str jsonArgumentString = '')
    {
        return RetailTransactionServiceCustomer::updateCustomerActivity(jsonArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomerNote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates note for the customer.
    /// </summary>
    /// <param name="jsonArgumentString">
    /// JSON string contains the arguments for the method call.
    /// </param>
    /// <returns>
    /// A container with entity keys.
    /// </returns>
    public static container updateCustomerNote(str jsonArgumentString = '')
    {
        return RetailTransactionServiceCustomer::updateCustomerNote(jsonArgumentString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomerFiscalCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates FiscalCode field for a specific customer.
    /// </summary>
    /// <param name = "_accountNum">The customer account number.</param>
    /// <param name = "_fiscalCode">The fiscal code.</param>
    /// <returns>A <c>Container</c> containing result info.</returns>
    public static container updateCustomerFiscalCode(str _accountNum, str _fiscalCode)
    {
        return RetailTransactionServiceCustomer::updateCustomerFiscalCode(_accountNum, _fiscalCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateCurrentTaxRegistration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new or updates the current <c>TaxRegistration</c> record at a given <c>DirPartyLocation</c> having the specified tax registration type and number.
    /// </summary>
    /// <param name = "dirPartyLocationRecId">The <c>DirPartyLocation</c> record id.</param>
    /// <param name = "taxRegistrationType">The tax registration type.</param>
    /// <param name = "registrationNumber">The registration number.</param>
    /// <param name = "effectiveDate">The date used to search or create the current record.</param>
    /// <param name = "dateSequence">The date format.</param>
    /// <returns>A <c>Container</c> containing an XML with <c>TaxRegistration</c> entities having the same directory party location and tax registration type.</returns>
    public static container createOrUpdateCurrentTaxRegistration(
        DirPartyLocationRecId dirPartyLocationRecId,
        TaxRegistrationTypesList taxRegistrationType,
        str registrationNumber,
        str effectiveDate,
        int dateSequence = 321)
    {
        return RetailTransactionServiceCustomer::createOrUpdateCurrentTaxRegistration(dirPartyLocationRecId, taxRegistrationType, registrationNumber, effectiveDate, dateSequence);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTaxRegistration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes a tax registration record by identifier.
    /// </summary>
    /// <param name="taxRegistrationRecId">
    /// The TaxRegistration record identifier.
    /// </param>
    /// <returns>
    /// A container with the deletion status.
    /// </returns>
    public static container deleteTaxRegistration(RecId taxRegistrationRecId)
    {
        return RetailTransactionServiceCustomer::deleteTaxRegistration(taxRegistrationRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChecklists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the checklists.
    /// </summary>
    /// <param name="_checklistSearchCriteriaJson">
    /// The JSON string of the ChecklistSearchCriteria.
    /// </param>
    /// <param name="_queryResultSettingsJson">
    /// The JSON string of the QueryResultSettings.
    /// </param>
    /// <returns>
    /// A container with 3 elements. The 3rd element is the serialized JSON string of an array of Microsoft.Dynamics.Commerce.Runtime.DataModel.Checklist.
    /// </returns>
    public static container getChecklists(str _checklistSearchCriteriaJson, str _queryResultSettingsJson)
    {
        return RetailTransactionServiceTaskManagement::getChecklists(_checklistSearchCriteriaJson, _queryResultSettingsJson);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateChecklists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the checklists.
    /// </summary>
    /// <param name="_checklistListJson">
    /// The JSON string of an array of Microsoft.Dynamics.Commerce.Runtime.DataModel.Checklist.
    /// </param>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker who did the operation.
    /// </param>
    /// <returns>
    /// A container with 3 elements. The 3rd element is the serialized JSON string of an array of Microsoft.Dynamics.Commerce.Runtime.DataModel.Checklist.
    /// </returns>
    public static container updateChecklists(str _checklistListJson, HcmPersonnelNumberId _personnelNumber)
    {
        return RetailTransactionServiceTaskManagement::updateChecklists(_checklistListJson, _personnelNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tasks.
    /// </summary>
    /// <param name="_taskSearchCriteriaJson">
    /// The JSON string of the TaskSearchCriteria.
    /// </param>
    /// <param name="_queryResultSettingsJson">
    /// The JSON string of the QueryResultSettings.
    /// </param>
    /// <returns>
    /// A container with 3 elements. The 3rd element is the serialized JSON string of an array of Microsoft.Dynamics.Commerce.Runtime.DataModel.ChecklistTask.
    /// </returns>
    /// <remarks>
    /// // "Contact person" in the data contract should be the contactWorker in the table.
    /// </remarks>
    public static container getTasks(str _taskSearchCriteriaJson, str _queryResultSettingsJson)
    {
        return RetailTransactionServiceTaskManagement::getTasks(_taskSearchCriteriaJson, _queryResultSettingsJson);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the tasks.
    /// </summary>
    /// <param name="_taskInfoListJson">
    /// The JSON string of an array of Microsoft.Dynamics.Commerce.Runtime.DataModel.ChecklistTask.
    /// </param>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker who did the operation.
    /// </param>
    /// <returns>
    /// A container with 3 elements. The 3rd element is the serialized JSON string of an array of Microsoft.Dynamics.Commerce.Runtime.DataModel.ChecklistTask.
    /// </returns>
    /// <remarks>
    /// // "Contact person" in the data contract should be the contactWorker in the table.
    /// </remarks>
    public static container updateTasks(str _taskInfoListJson, HcmPersonnelNumberId _personnelNumber)
    {
        return RetailTransactionServiceTaskManagement::updateTasks(_taskInfoListJson, _personnelNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAdhocTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create adhoc task.
    /// </summary>
    /// <param name="_checklistTaskJson">
    /// The JSON string of a Microsoft.Dynamics.Commerce.Runtime.DataModel.ChecklistTask
    /// </param>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker who did the operation.
    /// </param>
    /// <param name="_channelId">
    /// Channel id where the ad hoc task will be created under
    /// </param>
    /// <returns>
    /// A container with 3 elements. The 3rd element is the serialized JSON string of a Microsoft.Dynamics.Commerce.Runtime.DataModel.ChecklistTask
    /// </returns>
    /// <remarks>
    /// // "Contact person" in the data contract should be the contactWorker in the table.
    /// </remarks>
    public static container createAdhocTask(str _checklistTaskJson, HcmPersonnelNumberId _personnelNumber, int64 _channelId)
    {
        return RetailTransactionServiceTaskManagement::createTask(_checklistTaskJson, _personnelNumber, _channelId, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create task.
    /// </summary>
    /// <param name="_checklistTaskJson">
    /// The JSON string of a Microsoft.Dynamics.Commerce.Runtime.DataModel.ChecklistTask
    /// </param>
    /// <param name="_personnelNumber">
    /// Personnel number of the worker who did the operation.
    /// </param>
    /// <returns>
    /// A container with 3 elements. The 3rd element is the serialized JSON string of a Microsoft.Dynamics.Commerce.Runtime.DataModel.ChecklistTask
    /// </returns>
    /// <remarks>
    /// // "Contact person" in the data contract should be the contactWorker in the table.
    /// </remarks>
    public static container createTask(str _checklistTaskJson, HcmPersonnelNumberId _personnelNumber)
    {
        return RetailTransactionServiceTaskManagement::createTask(_checklistTaskJson, _personnelNumber, 0, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTechnicalResponsibleCSRT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the technical responsible CSRT.
    /// </summary>
    /// <param name = "_fiscalEstablishmentId">The fiscal establishment id.</param>
    /// <returns>The result container.</returns>
    public static container getTechnicalResponsibleCSRT(str _fiscalEstablishmentId)
    {
        return RetailTransactionServiceFiscalEstablishment_BR::getTechnicalResponsibleCSRT(_fiscalEstablishmentId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getConsumerEFDocCsc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the consumer electronic fiscal document csc.
    /// </summary>
    /// <param name = "_fiscalEstablishmentId">The fiscal establishment id.</param>
    /// <returns>The result container.</returns>
    public static container getConsumerEFDocCsc(str _fiscalEstablishmentId)
    {
        return RetailTransactionServiceFiscalEstablishment_BR::getConsumerEFDocCsc(_fiscalEstablishmentId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesOrderIdByChannelReferenceId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get sales order details by channel reference id(order confirmation id).
    /// </summary>
    /// <param name = "_orderSearchJson"> The JSON document containing the identifier(s) for the entity whose details are to be retrieved.</param>
    /// <returns>A collection of orders in the form.</returns>
    public static container getSalesOrderIdByChannelReferenceId(str _orderSearchJson)
    {
        return RetailTransactionServiceTransactions::getSalesOrderIdByChannelReferenceId(_orderSearchJson);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderOriginators</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the order originator information of each order by transaction id or sales id.
    /// The order originator is an entity that keeps the information of who placed an order (employee) and for whom (customer).
    /// It contains the employee information (id and name), the customer information (id and name) and the identifier (transaction id or the sales id).
    /// If the information does not exist or we could not find, we will not populate the data.
    /// If the transaction id is used in parameters, then the channel information is required.
    /// </summary>
    /// <param name = "_orderOriginatorsParametersJsonString">
    /// A JSON formatted string the parameters to get the order originators.
    /// </param>
    /// <returns>
    /// A JSON formatted string with a list of order originators.
    /// </returns>
    public static container getOrderOriginators(str _orderOriginatorsParametersJsonString = '')
    {
        return RetailTransactionServiceTransactions::getOrderOriginators(_orderOriginatorsParametersJsonString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesOrdersByLookupCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get sales order order by transaction id or sales id with some details.
    /// </summary>
    /// <param name = "_lookupCriteriaJsonString">
    /// A JSON formatted string with the parameters to get the orders.
    /// </param>
    /// <returns>
    /// A JSON formatted string with a list of orders with some details.
    /// </returns>
    public static container getSalesOrdersByLookupCriteria(str _lookupCriteriaJsonString = '')
    {
        return RetailTransactionServiceTransactions::getSalesOrdersByLookupCriteria(_lookupCriteriaJsonString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>confirmSalesOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Confirm the sales order.
    /// </summary>
    /// <param name = "_confirmSalesOrderParametersJsonString">
    /// A JSON formatted string of the parameters to confirm the sales order.
    /// </param>
    /// <returns>
    /// A JSON formatted string with the confirmed sales order.
    /// </returns>
    public static container confirmSalesOrder(str _confirmSalesOrderParametersJsonString)
    {
        return RetailTransactionServiceOrders::confirmSalesOrder(_confirmSalesOrderParametersJsonString);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>