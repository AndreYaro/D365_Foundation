<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesCalcAvailableDlvDates_SalesLine</Name>
	<SourceCode>
		<Declaration><![CDATA[
class SalesCalcAvailableDlvDates_SalesLine extends SalesCalcAvailableDlvDates
{
    SalesLine       salesLine;
    SalesLine       salesLineOrig;
    SalesLine       salesLineCaller;
    SalesLineType   salesLineType;
    SalesTable      salesTable;

    Map             replacedIntercompanyChainInventTransIdsPerDataArea;

    // cached variables
    container       lastConfirmation;  // [lastConfirmDate, lastConfirmId]
    DataAreaId      receiptCalendarDataAreaId;

    #define.CurrentVersion(1)
    #LOCALMACRO.CurrentList
        salesLine,
        salesLineOrig,
        salesLineCaller,
        salesTable
    #ENDMACRO
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>deliveryDateControlActive</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the delivery date control is active or not.
    /// </summary>
    /// <returns>
    /// true if the delivery date control is active; otherwise, false.
    /// </returns>
    protected boolean deliveryDateControlActive()
    {
        boolean ok = super();

        if (ok)
        {
            if (!salesLineType)
            {
                salesLineType = salesLine.type();
            }

            if (!salesLineType.doDeliveryDateControl())
            {
                ok = false;
            }
        }

        if (ok)
        {
            if (salesLine.SalesQty < 0)
            {
                ok = false;
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCancelConfirmedDatesSet</Name>
				<Source><![CDATA[
    protected internal boolean shouldCancelConfirmedDatesSet()
    {
        // Do not allow setting the confirmed dates inside lead time for Batch CTP delivery date control type.
        return this.isDeliveryDateControlTypeMpsCTP() && this.isSelectedConfirmedShipDateInsideSalesLeadTime()
            ? true
            : super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSelectedConfirmedShipDateInsideSalesLeadTime</Name>
				<Source><![CDATA[
    private boolean isSelectedConfirmedShipDateInsideSalesLeadTime()
    {
        return this.parmShippingDateAvailableSelected() < this.effectiveOrderDate() + this.salesLeadTime();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkShippingDate</Name>
				<Source><![CDATA[
    void checkShippingDate(boolean _checkCalendar = false, boolean _modifiedField = true)
    {
        super(_checkCalendar, _modifiedField);

        this.checkShippingDateForMpsCTP();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkShippingDateForMpsCTP</Name>
				<Source><![CDATA[
    private void checkShippingDateForMpsCTP()
    {
        if (this.isDeliveryDateControlTypeMpsCTP()
            && !this.isDeliveryDateControlTypeModifiedToMpsCTP()
            && salesLine.MPSFullRunCTPStatus == MPSFullRunCTPStatus::NotReady)
        {
            errorText = this.errorTextHandling(this.isDeliveryDateControlTypeMpsOnlineCTP()
                ? "@SCM:MPSOnlineCTP_SalesLineNotInSyncWithPlanResult_AvailableDeliveryDates_Warning"
                : "@SCM:MPSFullRunCTP_SalesLineNotInSyncWithPlanResult_AvailableDeliveryDates_Warning", 
                Exception::Warning);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDeliveryDateControlTypeModifiedToMpsCTP</Name>
				<Source><![CDATA[
    private boolean isDeliveryDateControlTypeModifiedToMpsCTP()
    {
        return !salesLineOrig.isDeliveryDateControlTypeMpsCTP();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isShippingDateRequestedChanged</Name>
				<Source><![CDATA[
    private boolean isShippingDateRequestedChanged()
    {
        return salesLine.ShippingDateRequested != salesLineOrig.ShippingDateRequested;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showSalesCalcAvailableDlvDatesPrompt</Name>
				<Source><![CDATA[
    internal protected boolean showSalesCalcAvailableDlvDatesPrompt()
    {
        if (this.isDeliveryDateControlTypeMpsCTP()
            && salesLine.MPSFullRunCTPStatus == MPSFullRunCTPStatus::NotReady)
        {
            throw warning(this.isDeliveryDateControlTypeMpsOnlineCTP()
                ? "@SCM:MPSOnlineCTP_SalesLineNotInSyncWithPlanResult_AvailableDeliveryDates_Warning"
                : "@SCM:MPSFullRunCTP_SalesLineNotInSyncWithPlanResult_AvailableDeliveryDates_Warning");
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldShowAvailableDlvDatesDialogPrompt</Name>
				<Source><![CDATA[
    internal protected boolean shouldShowAvailableDlvDatesDialogPrompt()
    {
        if (this.isDeliveryDateControlTypeMpsCTP()
            && this.isMasterDateTypeConfirmed()
            && salesLine.MPSFullRunCTPStatus == MPSFullRunCTPStatus::NotReady)
        {
            return false;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isShippingDateInPast</Name>
				<Source><![CDATA[
    boolean isShippingDateInPast()
    {
        return super() && this.shouldConsiderBlankConfirmedDateAsPast();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldConsiderBlankConfirmedDateAsPast</Name>
				<Source><![CDATA[
    private boolean shouldConsiderBlankConfirmedDateAsPast()
    {
        return !(this.isDeliveryDateControlTypeMpsCTP() && this.isMasterDateTypeConfirmed() && !this.parmShippingDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesLeadTime</Name>
				<Source><![CDATA[
    public LeadTime salesLeadTime(CalendarDays _basedOnCalendarSetup = NoYes::Yes)
    {
        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>doModifiedFieldCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the check regarding changed fields should be performed or not.
    /// </summary>
    /// <returns>
    /// true if the check regarding changed fields should be performed; otherwise, false.
    /// </returns>
    protected boolean doModifiedFieldCheck()
    {
        if (MpsDeliveryDateControlTypeCTPHelper::isDeliveryDateControlTypeClassicCTP(deliveryDateControlMap.DeliveryDateControlType))
        {
            return false;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>doUpdateCaller</Name>
				<Source><![CDATA[
    protected boolean doUpdateCaller(boolean _disableDlvDateControl = false)
    {
        if (_disableDlvDateControl)
        {
            if (salesLineOrig.DeliveryDateControlType != SalesDeliveryDateControlType::None)
            {
                return true;
            }
        }
        else
        {
            if (deliveryDateControlMap.DlvMode                 != salesLineOrig.DlvMode                 ||
                deliveryDateControlMap.InventDimId             != salesLineOrig.InventDimId             ||
                deliveryDateControlMap.ShippingDateRequested   != salesLineOrig.ShippingDateRequested   ||
                deliveryDateControlMap.ShippingDateConfirmed   != salesLineOrig.ShippingDateConfirmed   ||
                deliveryDateControlMap.ReceiptDateRequested    != salesLineOrig.ReceiptDateRequested    ||
                deliveryDateControlMap.ReceiptDateConfirmed    != salesLineOrig.ReceiptDateConfirmed)
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAllUnitConversionInfoRequired</Name>
				<Source><![CDATA[
    protected boolean validateAllUnitConversionInfoRequired()
    {
        return EcoResProductUnitConverter::hasRequiredProductDimensionsForUnitConversion(salesLine.ItemId, salesLine.inventDim());
    }

]]></Source>
			</Method>
			<Method>
				<Name>doValidateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether changes have been made to fields that influence the delivery date control.
    /// </summary>
    /// <returns>
    /// true if changes have been made to fields that influence the delivery date control; otherwise, false.
    /// </returns>
    protected boolean doValidateWrite()
    {
        if (salesLine.isDeliveryDateControlTypeClassicCTP() || this.isDeliveryDateControlTypeMpsCTP())
        {
            //
            // at validateWrite the master planning explosion is incomplete which is required for CTP
            // the check must be done after write and commit as then the requirement profile can be updated (changes for the current line and new receipts (kanbans)).
            //

            return false;
        }

        if (salesLine.DlvMode                 != salesLineOrig.DlvMode                 ||
            salesLine.InventDimId             != salesLineOrig.InventDimId             ||
            salesLine.SalesQty                != salesLineOrig.SalesQty                ||
            salesLine.DeliveryPostalAddress   != salesLineOrig.DeliveryPostalAddress   ||
            salesLine.DeliveryDateControlType != salesLineOrig.DeliveryDateControlType)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldId2DlvDateType</Name>
				<Source><![CDATA[
    protected SalesDlvDateType fieldId2DlvDateType(FieldId _fieldId)
    {
        SalesDlvDateType    dlvDateType;

        switch (_fieldId)
        {
            case fieldNum(SalesLine,ReceiptDateRequested) :
                dlvDateType = SalesDlvDateType::RequestedReceipt;
                break;
            case fieldNum(SalesLine,ShippingDateRequested) :
                dlvDateType = SalesDlvDateType::RequestedShipping;
                break;
            case fieldNum(SalesLine,ShippingDateConfirmed) :
                dlvDateType = SalesDlvDateType::ConfirmedShipping;
                break;
            case fieldNum(SalesLine,ReceiptDateConfirmed) :
                dlvDateType = SalesDlvDateType::ConfirmedReceipt;
                break;
            default :
                dlvDateType = SalesDlvDateType::None;
                break;
        }

        return dlvDateType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItemId</Name>
				<Source><![CDATA[
    protected ItemId getItemId()
    {
        return salesLine.ItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyDerivedOrder</Name>
				<Source><![CDATA[
    public boolean interCompanyDerivedOrder()
    {
        return salesTable.InterCompanyOrder && salesLine.InterCompanyOrigin == InterCompanyOrigin::Derived;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyDirectDeliveryOrig</Name>
				<Source><![CDATA[
    public boolean interCompanyDirectDeliveryOrig()
    {
        return salesLine.DeliveryType == TradeLineDlvType::DropShip
            && salesLine.InventRefTransId
            && PurchLine::findInventTransId(salesLine.InventRefTransId).InterCompanyInventTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyOrder</Name>
				<Source><![CDATA[
    public boolean interCompanyOrder()
    {
        return salesTable.InterCompanyOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimIdUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies dimensions such as the warehouse on sales order lines where all the dimension fields are
    /// positioned in the <c>InventDim</c> table.
    /// </summary>
    /// <param name="_inventDim">
    /// The <c>InventDim</c> record that contains fields that have been modified.
    /// </param>
    /// <remarks>
    /// The reason why people use this method is that the key <c>InventDimId</c> field on the parent table
    /// that links to the <c>InventDim</c> record has not been updated at the time when the delivery date
    /// control is occurring. Therefore, the method is used to get the new value of the dimension field
    /// from the related <c>InventDim</c> table.
    /// </remarks>
    protected void inventDimIdUpdate(InventDim _inventDim)
    {
        if (_inventDim)
        {
            salesLine.setInventDimIdFromInventDim(_inventDim);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastConfirmation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the latest confirmation date and confirmation ID.
    /// </summary>
    /// <returns>
    /// A container that holds the latest confirmation date and the latest confirmation ID.
    /// </returns>
    public container lastConfirmation()
    {
        CustConfirmJour     custConfirmJour;
        CustConfirmTrans    custConfirmTrans;

        if (conLen(lastConfirmation) == 0)
        {
            select firstonly ConfirmDate, ConfirmDocNum from custConfirmJour
                order by ConfirmDate desc
                where custConfirmJour.SalesId == salesLineCaller.SalesId
                exists join custConfirmTrans
                    where custConfirmTrans.SalesId      == custConfirmJour.SalesId
                       && custConfirmTrans.ConfirmId    == custConfirmJour.ConfirmId
                       && custConfirmTrans.ConfirmDate  == custConfirmJour.ConfirmDate
                       && custConfirmTrans.InventTransId  == salesLineCaller.InventTransId;

            lastConfirmation = [custConfirmJour.ConfirmDate,custConfirmJour.ConfirmDocNum];
        }

        return lastConfirmation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>leadTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates sales lead time for the current instance of a sales line.
    /// </summary>
    /// <param name="_inventDim">
    ///     Inventory dimensions used to calculate sales lead time.
    /// </param>
    /// <returns>
    ///     Lead time in days.
    /// </returns>
    public LeadTime leadTime(InventDim _inventDim)
    {
        PriceDisc_Price     localPriceDisc;
        PriceGroupId        priceGroupId;
        SalesLine           committedLine;  // line committed to SalesLine table if called on temporary table buffer;
        LeadTime            leadTime;

        if (salesLineCaller.isTmp())
        {
            committedLine = SalesLine::findInventTransId(salesLine.InventTransId);
        }
        else
        {
            committedLine = salesLine;
        }

        if (committedLine.isCategoryBased())
        {
            leadTime = SalesParameters::find().LeadTimeSalesDefault;
        }
        else
        {
            if (committedLine.LineDeliveryType == LineDeliveryType::DeliveryLine)
            {
                SalesLine orderLine = SalesDeliverySchedule::findOrderLineForDeliveryLine(committedLine.InventTransId);
                localPriceDisc      = committedLine.salesPurchLineInterface().priceDisc_PriceCache(_inventDim, true);
                priceGroupId        = orderLine.priceGroupId();
            }
            else
            {
                localPriceDisc  = committedLine.salesPurchLineInterface().priceDisc_PriceCache(_inventDim, true);
                priceGroupId   = salesLine.priceGroupId();
            }

            if (!this.parmPriceDisc()                                   ||
                !this.parmPriceDisc().isEqual(localPriceDisc)           ||
                this.parmPriceDisc().parmPriceGroupId() != priceGroupId)
            {
                localPriceDisc.price();
                this.parmPriceDisc(localPriceDisc);
            }

            leadTime = this.parmPriceDisc().deliveryDays();
        }

        return leadTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Serializes the current instance of the current <c>SalesCalcAvailableDlvDates_SalesLine</c> class.
    /// </summary>
    /// <returns>
    ///    A container that contains the current <c>SalesCalcAvailableDlvDates_SalesLine</c> class.
    /// </returns>
    public container pack()
    {
        return [#CurrentVersion,#CurrentList] + [super()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventLocationId</Name>
				<Source><![CDATA[
    protected InventLocationId parmInventLocationId(InventLocationId  _inventLocationId = InventDim::find(salesLine.InventDimId).InventLocationId)
    {
        if (!prmisDefault(_inventLocationId))
        {
            InventDim inventDim = InventDim::find(salesLine.InventDimId);
            inventDim.InventLocationId = _inventLocationId;
            inventDim.initFromInventLocation(inventDim.inventLocation());
            salesLine.setInventDimIdFromInventDim(inventDim);
            deliveryDateControlMap.InventDimId = salesLine.InventDimId;
        }

        return _inventLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventSiteId</Name>
				<Source><![CDATA[
    protected InventSiteId parmInventSiteId(InventSiteId  _inventSiteId = InventDim::find(salesLine.InventDimId).InventSiteId)
    {
        if (!prmisDefault(_inventSiteId))
        {
            InventDim inventDim = InventDim::find(salesLine.InventDimId);
            inventDim.InventSiteId = _inventSiteId;
            salesLine.InventDimId = InventDim::findOrCreate(inventDim).InventDimId;
            deliveryDateControlMap.InventDimId = salesLine.InventDimId;
        }

        return _inventSiteId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesLine</Name>
				<Source><![CDATA[
    public SalesLine parmSalesLine(SalesLine _salesLine = salesLine)
    {
        deliveryDateControlMap = _salesLine.data();
        salesLine              = _salesLine.data();
        salesTable             = salesLine.salesTable().data();
        salesLineOrig          = _salesLine.orig();
        salesLineCaller        = _salesLine;

        if (!isConfigurationkeyEnabled(configurationKeyNum(TradeMultiShipTo)))
        {
            deliveryDateControlMap.PostalAddress    = salesTable.DeliveryPostalAddress;
        }

        return salesLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReceiptDateOpen</Name>
				<Source><![CDATA[
    public boolean isReceiptDateOpen()
    {
        changecompany (this.receiptCalendarDataAreaId())
        {
            return super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduleDateInReceiptCalendar</Name>
				<Source><![CDATA[
    protected SchedDate scheduleDateInReceiptCalendar(
        WorkCalendarSched   _workCalendarSched,
        SchedDirection      _schedDirection,
        SchedDate           _schedDateFrom,
        Days                _days,
        CalendarDays        _calendarDays)
    {
        changecompany (this.receiptCalendarDataAreaId())
        {
            return super(_workCalendarSched,
                         _schedDirection,
                         _schedDateFrom,
                         _days,
                         _calendarDays);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>receiptCalendarId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the receipt calendar ID for the customer and returns it.
    /// </summary>
    /// <returns>
    /// The receipt calendar ID for the customer.
    /// </returns>
    protected CalendarId receiptCalendarId()
    {
        if (!receiptCalendarId)
        {
            SalesLine receiptCalendarSalesLine = salesLine;
            SalesTable receiptCalendarSalesTable = salesTable;
            PurchLine intercompanyPurchLine;
            // Keep looping until we find the very first sales order in the nested direct delivery chain
            while (receiptCalendarSalesLine.isInterCompanyOrder())
            {
                intercompanyPurchLine = receiptCalendarSalesLine.interCompanyPurchLine();
                
                SalesLine interCompanySalesLineOriginal = intercompanyPurchLine.interCompanySalesLineOriginal();
                if (interCompanySalesLineOriginal.isDirectDelivery())
                {
                    receiptCalendarSalesLine = interCompanySalesLineOriginal;
                    receiptCalendarSalesTable = receiptCalendarSalesLine.salesTable();
                }
                else
                {
                    break;
                }
            }

            changecompany (receiptCalendarSalesLine.DataAreaId)
            {
                receiptCalendarId = this.receiptCalendarForSalesLine(receiptCalendarSalesLine, receiptCalendarSalesTable);
                receiptCalendarDataAreaId = receiptCalendarSalesLine.DataAreaId;
            }
        }

        return receiptCalendarId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>receiptCalendarForSalesLine</Name>
				<Source><![CDATA[
    private CalendarId receiptCalendarForSalesLine(SalesLine _receiptCalendarSalesLine, SalesTable _receiptCalendarSalesTable)
    {
        CalendarId salesLineReceiptCalendarId = LogisticsLocationExt::find(_receiptCalendarSalesLine.deliveryLocation()).SalesCalendarId;

        if (!salesLineReceiptCalendarId && _receiptCalendarSalesLine.AddressRefTableId && _receiptCalendarSalesLine.AddressRefRecId)
        {
            switch (_receiptCalendarSalesLine.AddressRefTableId)
            {
                case tableNum(LogisticsLocation) :
                    salesLineReceiptCalendarId = LogisticsLocationExt::find(_receiptCalendarSalesLine.AddressRefRecId).SalesCalendarId;
                    break;
                case tableNum(CustTable) :
                    salesLineReceiptCalendarId = (select custTable where custTable.TableId == _receiptCalendarSalesLine.AddressRefTableId && custTable.RecId == _receiptCalendarSalesLine.AddressRefRecId).SalesCalendarId;
                    break;
                default :
                    break;
            }
        }

        if (!salesLineReceiptCalendarId)
        {
            salesLineReceiptCalendarId = LogisticsLocationExt::find(_receiptCalendarSalesTable.deliveryLocation()).SalesCalendarId;
        }

        if (!salesLineReceiptCalendarId && _receiptCalendarSalesTable.AddressRefTableId && _receiptCalendarSalesTable.AddressRefRecId)
        {
            switch (_receiptCalendarSalesTable.AddressRefTableId)
            {
                case tableNum(LogisticsLocation) :
                    salesLineReceiptCalendarId = LogisticsLocationExt::find(_receiptCalendarSalesTable.AddressRefRecId).SalesCalendarId;
                    break;
                case tableNum(CustTable) :
                    salesLineReceiptCalendarId = (select custTable where custTable.TableId == _receiptCalendarSalesTable.AddressRefTableId && custTable.RecId == _receiptCalendarSalesTable.AddressRefRecId).SalesCalendarId;
                    break;
                default :
                    break;
            }
        }

        if (!salesLineReceiptCalendarId)
        {
            salesLineReceiptCalendarId = CustTable::find(_receiptCalendarSalesLine.CustAccount).SalesCalendarId;
        }

        return salesLineReceiptCalendarId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>receiptCalendarDataAreaId</Name>
				<Source><![CDATA[
    protected DataAreaId receiptCalendarDataAreaId()
    {
        if (!receiptCalendarId)
        {
            this.receiptCalendarId(); // the receiptCalendarId() method initializes both the receiptCalendarId and the receiptCalendarDataAreaId fields.
        }

        return receiptCalendarDataAreaId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeSalesLeadTimeBasedOnDeliveryDateControlType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the sales lead time based on the delivery date control type and sets that the sales lead time has been found.
    /// </summary>
    protected void initializeSalesLeadTimeBasedOnDeliveryDateControlType()
    {
        InventDim inventDim = InventDim::find(this.parmInventDimId());

        if (forceCalcToUseMarking)
        {
            salesLeadTime = this.leadTimeFromMarking(InventTransOriginSalesLine::findInventTransOriginId(salesLine.DataAreaId,salesLine.InventTransId));
            salesLeadTimeBasedOnCalendarSetup = salesLeadTime;

            if (salesLeadTime < 0)
            {
                salesLeadTime = this.leadTime(inventDim);
                salesLeadTimeBasedOnCalendarSetup = this.adjustLeadTimeForWorkingDays(salesLeadTime);
            }
        }
        else
        {
            this.calculateSalesLeadTimeBasedOnDeliveryDateControlType(inventDim);
        }

        salesLeadTimeFound = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSalesLeadTimeBasedOnDeliveryDateControlType</Name>
				<Source><![CDATA[
    private void calculateSalesLeadTimeBasedOnDeliveryDateControlType(InventDim _inventDim) 
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesCalcAvailableDlvDatesActivities().calculateSalesLeadTime())
        {
            SalesDeliveryDateControlType deliveryDateControlType = this.parmDeliveryDateControlType();

            activityContext
                .addCustomProperty('SalesDeliveryDateControlType', enum2Symbol(enumNum(SalesDeliveryDateControlType), deliveryDateControlType))
                .addCustomProperty('InventDimRecId', int642Str(_inventDim.RecId));

            switch (deliveryDateControlType)
            {
                case SalesDeliveryDateControlType::ATPPlusIssueMargin:
                    MarginIssue marginIssue = this.marginIssue(salesLine.ItemId, _inventDim);
                //
                // No break here.
                // The process of calculation ATP and "ATP + Issue margin" is
                // typically the same. The only difference is in adding an extra lead time in a latter case.
                //
                case SalesDeliveryDateControlType::ATP:
                    salesLeadTime = this.salesLeadTimeAtp(salesLine.ItemId, _inventDim.inventDimId, marginIssue, salesLine.InventTransId);
                    salesLeadTimeBasedOnCalendarSetup = salesLeadTime;
                    break;

                case SalesDeliveryDateControlType::CTP:
                case SalesDeliveryDateControlType::FullRunCTP:
                    if (MpsDeliveryDateControlTypeCTPHelper::isDeliveryDateControlTypeClassicCTP(deliveryDateControlType))
                    {
                        this.calculateSalesLeadTimeForCTP(_inventDim);
                    }
                    else
                    {
                        this.calculateSalesLeadTimeForMpsCTPDeliveryDateControlType(_inventDim);
                    }
                    break;

                case SalesDeliveryDateControlType::SalesLeadTime:
                case SalesDeliveryDateControlType::None:
                    // For SalesDeliveryDateControlType::None lead time should also be calculated.
                    this.calculateSalesLeadTimeForSalesLeadTimeDeliveryDateControlType(_inventDim);
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSalesLeadTimeForMpsCTPDeliveryDateControlType</Name>
				<Source><![CDATA[
    private void calculateSalesLeadTimeForMpsCTPDeliveryDateControlType(InventDim _inventDim)
    {
        if (salesLine.isDeliveryDateControlTypeMpsCTP())
        {
            if (salesLine.MPSFullRunCTPStatus == MPSFullRunCTPStatus::Ready)
            {
                this.calculateSalesLeadTimeForCTP(_inventDim);
            }
            else
            {
                // Sales lead time should be always taken under consideration.
                this.calculateSalesLeadTimeForSalesLeadTimeDeliveryDateControlType(_inventDim);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSalesLeadTimeForCTP</Name>
				<Source><![CDATA[
    private void calculateSalesLeadTimeForCTP(InventDim _inventDim)
    {
        salesLeadTime = this.leadTimeFromCTP(InventTransOriginSalesLine::findInventTransOriginId(salesLine.DataAreaId,salesLine.InventTransId));
        salesLeadTimeBasedOnCalendarSetup = salesLeadTime;

        if (salesLeadTime < 0)
        {
            salesLeadTime = this.leadTime(_inventDim);
            salesLeadTimeBasedOnCalendarSetup = this.adjustLeadTimeForWorkingDays(salesLeadTime);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSalesLeadTimeForSalesLeadTimeDeliveryDateControlType</Name>
				<Source><![CDATA[
    private void calculateSalesLeadTimeForSalesLeadTimeDeliveryDateControlType(InventDim _inventDim)
    {
        salesLeadTime = this.leadTime(_inventDim);
        salesLeadTimeBasedOnCalendarSetup = this.adjustLeadTimeForWorkingDays(salesLeadTime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deserializes the <paramref name="_packedClass" /> parameter to the current instance of the
    ///    <c>SalesCalcAvailableDlvDates_SalesLine</c> class.
    /// </summary>
    /// <param name="_packedClass">
    ///    The container that is used to deserialize the current instance of the
    ///    <c>SalesCalcAvailableDlvDates_SalesLine</c> class.
    /// </param>
    /// <returns>
    ///    true if the deserialization was successful; otherwise, false.
    /// </returns>
    public boolean unpack(container _packedClass)
    {
        int         version = RunBase::getVersion(_packedClass);
        container   packedSuper;

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList, packedSuper] = _packedClass;

                if (packedSuper)
                    return super(packedSuper);
            break;

            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesLeadTimeAtp</Name>
				<Source><![CDATA[
    protected LeadTime salesLeadTimeAtp(ItemId _itemId, InventDimId _inventDimId, MarginIssue _marginIssue, InventTransId _excludedInventTransId)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesCalcAvailableDlvDatesActivities().salesLeadTimeATP())
        {
            InventQty inventQty = this.calculateSalesLeadTimeAtpQuantity();

            var salesATPCalculation = this.initializeSalesAtpCalculation(_itemId, _inventDimId, _marginIssue);

            return salesATPCalculation.atpLeadTime(
                                inventQty,
                                this.effectiveOrderDate(),
                                _excludedInventTransId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSalesLeadTimeAtpQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the quantity used for calculating the ATP lead time.
    /// </summary>
    /// <returns>The ATP quantity.</returns>
    protected InventQty calculateSalesLeadTimeAtpQuantity()
    {
        return salesLineOrig.RecId ?
                salesLine.QtyOrdered - salesLineOrig.QtyOrdered + salesLineOrig.RemainInventPhysical - salesLine.pickedInTotalInventUnit()
                : salesLine.QtyOrdered - salesLine.pickedInTotalInventUnit();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeSalesAtpCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a sales ATP calculation object for an item and inventory dimensions.
    /// </summary>
    /// <param name = "_itemId">An item number.</param>
    /// <param name = "_inventDimId">An inventory dimension ID.</param>
    /// <param name = "_marginIssue">An issue margin.</param>
    /// <returns>The initialized <c>SalesATPCalculation</c> object.</returns>
    protected SalesATPCalculation initializeSalesAtpCalculation(ItemId _itemId, InventDimId _inventDimId, MarginIssue _marginIssue)
    {
        var salesATPCalculation = this.instantiateSalesAtpCalculation(_itemId, _inventDimId);

        salesATPCalculation.parmShippingDateRequested(deliveryDateControlMap.ShippingDateRequested);
        // marginIssue will be > 0 only for "ATP + Issue margin" delivery date control method.
        salesATPCalculation.parmMarginIssue(_marginIssue);
        salesATPCalculation.parmIssueMarginCalendarId(this.reqSetupDim().reqCalendarId());

        if (replacedIntercompanyChainInventTransIdsPerDataArea
            && replacedIntercompanyChainInventTransIdsPerDataArea.exists(salesLine.company()))
        {
            InventTransId replacedSalesLineInventTransId;
            InventTransId derivedPurchLineInventTransId;
            [replacedSalesLineInventTransId, derivedPurchLineInventTransId] = replacedIntercompanyChainInventTransIdsPerDataArea.lookup(salesLine.company());
            salesATPCalculation.parmReplacedSalesLineInventTransId(replacedSalesLineInventTransId);
            salesATPCalculation.parmDerivedPurchLineInventTransId(derivedPurchLineInventTransId);
        }

        return salesATPCalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateSalesAtpCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates a sales ATP calculation object for an item and inventory dimensions.
    /// </summary>
    /// <param name = "_itemId">An item number.</param>
    /// <param name = "_inventDimId">An inventory dimension ID.</param>
    /// <returns>The instantiated <c>SalesATPCalculation</c> object.</returns>
    [Replaceable]
    protected SalesATPCalculation instantiateSalesAtpCalculation(ItemId _itemId, InventDimId _inventDimId)
    {
        return SalesATPCalculation::newSalesCalculation(_itemId, _inventDimId, salesLine.CustAccount, salesLine.company());
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCaller</Name>
				<Source><![CDATA[
    protected void updateCaller(Common  _record,
                                boolean _disableDlvDateControl = false)
    {
        super(_record,_disableDlvDateControl);

        if (this.parmCheckOnly())
            return;

        if (_record.TableId != tableNum(SalesLine))
            throw error("@SYS18626");

        SalesLine salesLineCallerLocal = _record;

        if (this.parmCancelModifiedField())
        {
            if (salesLineCallerLocal.RecId)
            {
                salesLineCallerLocal.ShippingDateConfirmed   = salesLineOrig.ShippingDateConfirmed;
                salesLineCallerLocal.ShippingDateRequested   = salesLineOrig.ShippingDateRequested;
                salesLineCallerLocal.ReceiptDateConfirmed    = salesLineOrig.ReceiptDateConfirmed;
                salesLineCallerLocal.ReceiptDateRequested    = salesLineOrig.ReceiptDateRequested;
                salesLineCallerLocal.DeliveryDateControlType = salesLineOrig.DeliveryDateControlType;
            }
            return;
        }

        if (_disableDlvDateControl)
        {
            salesLineCallerLocal.DeliveryDateControlType = SalesDeliveryDateControlType::None;
        }
        else
        {
            salesLineCallerLocal.DlvMode               = deliveryDateControlMap.DlvMode;

            this.updateCallerInventDimId(salesLineCallerLocal);

            salesLineCallerLocal.ShippingDateRequested = deliveryDateControlMap.ShippingDateRequested;
            salesLineCallerLocal.ShippingDateConfirmed = deliveryDateControlMap.ShippingDateConfirmed;

            if (isConfigurationkeyEnabled(configurationKeyNum(SalesDeliveryDateControl)))
            {
                salesLineCallerLocal.ReceiptDateRequested  = deliveryDateControlMap.ReceiptDateRequested;
                salesLineCallerLocal.ReceiptDateConfirmed  = deliveryDateControlMap.ReceiptDateConfirmed;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCallerInventDimId</Name>
				<Source><![CDATA[
    protected void updateCallerInventDimId(salesLine _salesLineCaller)
    {
        InventDim inventDim;

        inventDim.initFromInventDim(_salesLineCaller.inventDim());
        inventDim.InventLocationId = this.parmInventLocationId();
        inventDim.InventSiteId = this.parmInventSiteId();

        _salesLineCaller.setInventDimId(InventDim::findOrCreate(inventDim).InventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    protected static SalesCalcAvailableDlvDates_SalesLine construct()
    {
        return new SalesCalcAvailableDlvDates_SalesLine();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newSalesLine</Name>
				<Source><![CDATA[
    public static SalesCalcAvailableDlvDates_SalesLine newSalesLine(SalesLine _salesLine,
                                                                    FieldId   _fieldId = 0,
                                                                    InventDim _inventDim = null)
    {
        SalesDeliveryDateControlType deliveryDateControlType = SalesLine::getDeliveryDateControlType(_salesLine);

        if (_salesLine.isSourcedViaProcurement() && deliveryDateControlType != SalesDeliveryDateControlType::None)
        {
            return IntercompanySalesCalcAvailableDlvDates_SalesLine::newSalesLine(_salesLine, _fieldId);
        }

        return SalesCalcAvailableDlvDates_SalesLine::newSalesCalcAvailableDlvDates_SalesLine(_salesLine, _fieldId, _inventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newSalesCalcAvailableDlvDates_SalesLine</Name>
				<Source><![CDATA[
    internal static SalesCalcAvailableDlvDates_SalesLine newSalesCalcAvailableDlvDates_SalesLine(
        SalesLine _salesLine,
        FieldId   _fieldId = 0,
        InventDim _inventDim = null)
    {
        SalesCalcAvailableDlvDates_SalesLine salesCalc = SalesCalcAvailableDlvDates_SalesLine::construct();

        SalesDlvDateType masterDateType = salesCalc.fieldId2DlvDateType(_fieldId);

        salesCalc.parmSalesLine(_salesLine);
        salesCalc.parmDlvModeIdSelected(_salesLine.DlvMode);

        InventDim localInventDim = salesCalc.initInventDim(_salesLine, _inventDim);

        salesCalc.initOrderEntryDeadline(_salesLine);
        salesCalc.parmRecalculateShippingDate(false);
        salesCalc.parmShowActualShipDates(true);
        salesCalc.parmShowConfirmation(true);
        salesCalc.initReqSetupDim(_salesLine.ItemId, localInventDim, _salesLine.DeliveryDateControlType);

        salesCalc.initMaster(masterDateType);

        return salesCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes inventDimId based on the given sales line.
    /// </summary>
    /// <param name = "_salesLine">The sales line.</param>
    /// <param name = "_inventDim">The invent dim that should be used instead of sales line invent dim.</param>
    /// <returns>The invent dim that is initialized in this object.</returns>
    public InventDim initInventDim(SalesLine _salesLine, InventDim _inventDim = null)
    {
        InventDim inventDim;
        InventDim localInventDim  = _salesLine.inventDim();

        if (_inventDim)
        {
            inventDim = _inventDim;

            this.inventDimIdUpdate(_inventDim);
            this.parmInventLocationIdSelected(this.parmInventLocationId());
            this.parmInventSiteIdSelected(this.parmInventSiteId());
        }
        else
        {
            inventDim = localInventDim;

            this.parmInventLocationIdSelected(inventDim.InventLocationId);
            this.parmInventSiteIdSelected(inventDim.InventSiteId);
        }

        localInventDim.InventLocationId = this.parmInventLocationIdSelected();
        localInventDim.InventSiteId     = this.parmInventSiteIdSelected();
        localInventDim.initFromInventLocation(localInventDim.inventLocation());
        localInventDim = InventDim::findOrCreate(localInventDim);

        this.parmInventLocationTransportShipping(inventDim.InventLocationId);
        this.parmInventDimId(localInventDim.InventDimId);

        return localInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMaster</Name>
				<Source><![CDATA[
    protected void initMaster(SalesDlvDateType _masterDateType = SalesDlvDateType::None)
    {
        super(_masterDateType);

        // For intercompany derived lines only confirmed dates are to be updated
        if (salesLine.InterCompanyOrigin == InterCompanyOrigin::Derived)
        {
            showTransferToRequestedButton = false;
            showTransferToConfirmedButton = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOrderEntryDeadline</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes order entry deadline group based on the given sales line.
    /// </summary>
    /// <param name = "_salesLine">The sales line.</param>
    public void initOrderEntryDeadline(SalesLine _salesLine)
    {
        this.parmOrderEntryDeadlineGroupId(CustTable::find(_salesLine.CustAccount).OrderEntryDeadlineGroupId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReplacedIntercompanyChainInventTransIdsPerDataArea</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the inventory transactions which must not be considered as supply or demand
    /// because they are part of the intercompany chain of order lines that must be replaced by the
    /// current sales line.
    /// </summary>
    /// <param name = "_replacedIntercompanyChainInventTransIdsPerDataArea">The map of (Key:DataAreaId, Value:[SalesLineInventTransId, DerivedPurchLineInventTransId]) pairs.</param>
    /// <returns>The set of containers of [DataAreaId, InventTransId] pairs.</returns>
    public Map parmReplacedIntercompanyChainInventTransIdsPerDataArea(Map _replacedIntercompanyChainInventTransIdsPerDataArea = replacedIntercompanyChainInventTransIdsPerDataArea)
    {
        replacedIntercompanyChainInventTransIdsPerDataArea = _replacedIntercompanyChainInventTransIdsPerDataArea;
        return replacedIntercompanyChainInventTransIdsPerDataArea;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>