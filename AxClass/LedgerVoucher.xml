<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerVoucher</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>LedgerVoucher</c> class collects all transactions to be posted in one action.
/// </summary>
/// <remarks>
///       This class is the main class of the general ledger posting API. An action can be the total posting of a journal or a number of postings from an invoice.
///   This class holds a list of voucher objects (through an object list class).
///   The API offers three services: "Check vouchers", "Post vouchers" and "Make a draft of the posting", and all postings into the general ledger must go through this API.
///   The logical flow for using the API is:
///   begin
///       open ledger (check, post or draft)
///       loop over every transaction
///           open voucher (optional)
///           create transaction
///           check voucher (optional)
///       end loop
///       end ledger
///   end
///   Postings that spawn allocations and accruals are fully supported.
///   The posting verifications made by the API include:
///
///    <list type="bullet">
///       <item>
///          <description>Voucher number
///          </description>
///       </item>
///       <item>
///          <description>Voucher balance
///          </description>
///       </item>
///       <item>
///          <description>Periods
///          </description>
///       </item>
///       <item>
///          <description>Account / Dimension restrictions
///          </description>
///       </item>
///       <item>
///          <description>User credentials
///          </description>
///       </item>
///    </list>
///       ///   Intercompany tranactions must be handled by the client calling the API.
///   The API is capable of handling * vouchers in 1 run.
///   The API is backwards compatible with the API from version 2.5.
///
/// </remarks>
abstract class LedgerVoucher
{
    LedgerEntryJournal ledgerEntryJournal;

    // collections
    LedgerPostingGeneralJournalController generalJournalController;
    LedgerPostingSubledgerJournalController ledgerPostingSubledgerJournalController;
    LedgerVoucherList ledgerVoucherList;
    Map balanceDemandValues;

    DetailSummary               detailSummary;
    boolean                     customLevelOfDetail;
    TransactionLogType          transactionLogType;
    TransTxt                    transactionLogTxt;
    NumberSequenceCode          voucherSeriesCode;

    RecId                       recId;
    RecordSortedList            bankAccountTransList;

    boolean                     checkAuto;
    boolean                     checkBlockedDimensions;
    boolean                     checkTransOnInsert;
    boolean                     skipBlockedForManualEntryCheck;

    JournalTableData            journalTableData;
    JournalCheckPost            journalCheckPost;

    TransDate                   lastTransDate;
    Voucher                     lastVoucher;
    CurrentOperationsTax        lastPostingLayer;

    Voucher                     voucherBeingReversed;

    boolean                     reversal;
    CompanyId                   companyId;

    Map                         tmpVoucherMap;
    Set                         validAccountingDateCache;
    Map                         validLedgerDimensionCache;
    Map                         ledgerAccountCache;

    SysModule sysModuleDefault;

    // <GIN>
    boolean                     taxWithholdkBankStatus;
    container                   allInvoiceCompany;
    boolean                     isAdvancePaymentForWHT;
    AmountCur                   advancePaymentWHT;
    container                   checkSTForInterCompany;
    TmpTaxWithholdTransInterCompany_IN  taxWithholdTransInterCompany;
    boolean                     isVATDeferment;
    boolean                     isTaxWithholdParametersEnabled;
    boolean                     isVATEnabled;
    boolean                     isIndiaLegalEntityEnabled;

    TaxWithholdAmountCur        postedInterCompanyWHT;
    TaxWithholdAmountCur        backWardAmountWHT;
    CompanyId                   currentCompany_IN;
    Map                         withholdTaxInvoiceCompanyCache;
    // </GIN>

    // <GCN>
    Voucher_CN                      voucherCN;
    LedgerVoucherTypeRefRecId_CN    ledgerVoucherTypeCN;
    // </GCN>

    boolean                     openingSheet_ES;

    LedgerPostingMessageLog     ledgerPostingMessageCollection;


    SysOperationProgress        bondProgress;
    Stack                       postingLayerStack;

    private PlExcludeExchAdj excludeExchAdj_PL;
    private boolean isAdvanceDeducted = false;

    private AccountingEventRecId accountingEventRecId;

    #define.one(1)
    #define.two(2)
    #ISOCountryRegionCodes
    
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmAccountingEventRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get and set the accounting event for the ledger voucher object
    /// </summary>
    /// <param name = "_accountingEventRecId">The accounting event that this ledger voucher belongs</param>
    /// <returns>Accounting event that this ledger voucher object belongs</returns>
    public AccountingEventRecId parmAccountingEventRecId(AccountingEventRecId _accountingEventRecId = accountingEventRecid)
    {
        accountingEventRecid = _accountingEventRecId;

        return accountingEventRecid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addAccountingDateToCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a valid accounting date and fiscal calendar period combination to the cache.
    /// </summary>
    /// <param name="_accountingDate">
    /// The accounting date.
    /// </param>
    /// <param name="_fiscalCalendarPeriodRecId">
    /// The fiscal calendar period.
    /// </param>
    public void addAccountingDateToCache(TransDate _accountingDate, FiscalCalendarPeriodRecId _fiscalCalendarPeriodRecId)
    {
        validAccountingDateCache.add([companyId, _accountingDate, _fiscalCalendarPeriodRecId]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBalanceDemand</Name>
				<Source><![CDATA[
    public void addBalanceDemand(
        MainAccount _mainAccount,
        TransDate _accountingDate,
        AmountMST _accountingCurrencyAmount)
    {
        DebCredProposal balanceDemand;
        AmountMST accountingCurrencyAmount;

        if (_mainAccount.DebitCreditBalanceDemand == DebCredProposal::None)
        {
            // nothing needed for DebCredProposal::None
            return;
        }

        if (balanceDemandValues == null)
        {
            balanceDemandValues = new Map(Types::Container, Types::Container);
        }

        if (balanceDemandValues.exists([_mainAccount.RecId, _accountingDate]))
        {
            [balanceDemand, accountingCurrencyAmount] = balanceDemandValues.lookup([_mainAccount.RecId, _accountingDate]);
            accountingCurrencyAmount += _accountingCurrencyAmount;
        }
        else
        {
            balanceDemand = _mainAccount.DebitCreditBalanceDemand;
            accountingCurrencyAmount = _accountingCurrencyAmount;
        }

        balanceDemandValues.insert([_mainAccount.RecId, _accountingDate], [balanceDemand, accountingCurrencyAmount]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerAccountToCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the ledger account for a ledger dimension to the cache.
    /// </summary>
    /// <param name="_ledgerAccount">
    /// The ledger account.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The ledger dimension.
    /// </param>
    public void addLedgerAccountToCache(DimensionDisplayValue _ledgerAccount, LedgerDimensionAccount _ledgerDimension)
    {
        ledgerAccountCache.insert(_ledgerDimension, _ledgerAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMainAccountToCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the main account for a valid ledger dimension, accounting date, and posting
    /// type combination to the cache.
    /// </summary>
    /// <param name="_mainAccount">
    /// The main account.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The ledger dimension.
    /// </param>
    /// <param name="_accountingDate">
    /// The accounting date.
    /// </param>
    /// <param name="_postingType">
    /// The posting type.
    /// </param>
    public void addMainAccountToCache(
        MainAccount _mainAccount,
        RecId _ledgerDimension,
        TransDate _accountingDate,
        LedgerPostingType _postingType)
    {
        validLedgerDimensionCache.insert([_ledgerDimension, _accountingDate, _postingType], _mainAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToGeneralJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the specified information to the general journal.
    /// </summary>
    /// <param name="_adjustedTransferLevel">
    /// The adjusted transfer level of the transaction.
    /// </param>
    /// <param name="_generalJournalEntry">
    /// The general journal account entry record.
    /// </param>
    /// <param name="_generalJournalAccountEntry">
    /// The general account account entry record
    /// </param>
    /// <param name="_ledgerEntry">
    /// The LedgerEntry record.
    /// </param>
    /// <param name="_taxTransactionRelationshipCollection">
    /// A collection of the <c>TaxTrans</c> table relationship information.
    /// </param>
    /// <param name="_crossCompanyTaxLinkCollections">
    /// A collection of cross company tax link collections.
    /// </param>
    /// <remarks>
    /// This method is for ledger posting framework internal use only.
    /// </remarks>
    public void addToGeneralJournal(
        DetailSummary _adjustedTransferLevel,
        GeneralJournalEntry _generalJournalEntry,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        LedgerEntry _ledgerEntry,
        LedgerPostingOneToManyCollection _taxTransactionRelationshipCollection,
        Map _crossCompanyTaxLinkCollections)
    {
        Debug::assert(generalJournalController != null);

        generalJournalController.parmIsReversal(reversal);

        generalJournalController.add(
            _adjustedTransferLevel,
            _generalJournalEntry,
            _generalJournalAccountEntry,
            ledgerEntryJournal,
            _ledgerEntry,
            _taxTransactionRelationshipCollection,
            _crossCompanyTaxLinkCollections);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToGeneralJournalEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the specified information to the general journal.
    /// </summary>
    /// <param name="_adjustedTransferLevel">
    /// The adjusted transfer level of the transaction.
    /// </param>
    /// <param name="_generalJournalEntry">
    /// The general journal account entry record.
    /// </param>
    /// <param name="_generalJournalAccountEntry">
    /// The general account account entry record
    /// </param>
    /// <param name="_ledgerEntry">
    /// The LedgerEntry record.
    /// </param>
    /// <param name="_taxTransactionRelationshipCollection">
    /// A collection of the tax transaction relationship information.
    /// </param>
    /// <param name="_crossCompanyTaxLinkCollections">
    /// A collection of cross company tax link collections.
    /// </param>
    /// <param name="_generalJournalEntryW">
    /// The country specific general journal entry record.
    /// </param>
    /// <param name="_generalJournalAccountEntryW">
    /// The country specific general journal account entry record.
    /// </param>
    /// <remarks>
    /// This method is for ledger posting framework internal use only.
    /// </remarks>
    public void addToGeneralJournalEntry(
        DetailSummary _adjustedTransferLevel,
        GeneralJournalEntry _generalJournalEntry,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        LedgerEntry _ledgerEntry,
        LedgerPostingOneToManyCollection _taxTransactionRelationshipCollection,
        Map _crossCompanyTaxLinkCollections
        , GeneralJournalEntry_W _generalJournalEntryW = null
        , GeneralJournalAccountEntry_W _generalJournalAccountEntryW = null
        )
    {
        Debug::assert(generalJournalController != null);

        generalJournalController.parmIsReversal(reversal);

        //<GIN>
        if (isVATEnabled)
        {
            generalJournalController.parmIsVATDeferment_IN(isVATDeferment);
        }
        //</GIN>

        generalJournalController.add(
            _adjustedTransferLevel,
            _generalJournalEntry,
            _generalJournalAccountEntry,
            ledgerEntryJournal,
            _ledgerEntry,
            _taxTransactionRelationshipCollection,
            _crossCompanyTaxLinkCollections
            // <GEEU>
            , _generalJournalEntryW
            , _generalJournalAccountEntryW
            // </GEEU>
            );
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToSubledgerJournalEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the specified information to the subledger journal.
    /// </summary>
    /// <param name="_adjustedTransferLevel">
    /// The adjusted transfer level of the transaction.
    /// </param>
    /// <param name="_generalJournalEntry">
    /// The general journal account entry record.
    /// </param>
    /// <param name="_generalJournalAccountEntry">
    /// The <c>GeneralJournalAccountEntry</c> record.
    /// </param>
    /// <param name="_taxTransactionRelationshipCollection">
    /// A collection of the tax transaction relationship information.
    /// </param>
    /// <remarks>
    /// This method is for ledger voucher framework internal use only.
    /// </remarks>
    public void addToSubledgerJournalEntry(
        DetailSummary _adjustedTransferLevel,
        GeneralJournalEntry _generalJournalEntry,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        LedgerPostingOneToManyCollection _taxTransactionRelationshipCollection)
    {
        if (ledgerPostingSubledgerJournalController == null)
        {
            ledgerPostingSubledgerJournalController = LedgerPostingSubledgerJournalController::construct();
            ledgerPostingSubledgerJournalController.parmAccountingEventRecId(this.parmAccountingEventRecId());
        }

        ledgerPostingSubledgerJournalController.add(
            _adjustedTransferLevel,
            _generalJournalEntry,
            _generalJournalAccountEntry,
            _taxTransactionRelationshipCollection);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a transaction to be posted.
    /// </summary>
    /// <param name = "_transaction">
    /// The <c>LedgerVoucherTransObject</c> instance.
    /// </param>
    /// <returns>
    /// true if the ledger posting transaction is valid; otherwise, false.
    /// </returns>
    boolean addTrans(LedgerVoucherTransObject _transaction)
    {
        LedgerVoucherObject reference;
        boolean isValid = true;

        reference = ledgerVoucherList.item();

        if (reference == null)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (checkTransOnInsert)
        {
            isValid = _transaction.checkData(this, reference);

            // don't need to check _transaction.isModified() or update the _transaction instance in the collection
            // after calling _transaction.checkData(..) even though the items in the collection do not have
            // reference semantics because the _transaction object has not been added to the collection yet
        }

        // add to collection last because the collection does not have reference semantics
        reference.addTrans(_transaction, true);

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a voucher to be posted.
    /// </summary>
    /// <param name = "_reference">
    /// The <c>LedgerVoucherObject</c> instance.
    /// </param>
    void addVoucher(LedgerVoucherObject _reference)
    {
        TransDate accountingDate;
        Voucher subledgerVoucher;
        CurrentOperationsTax postingLayer;
        boolean success;

        if (_reference.parmJournalNumber() != '')
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        _reference.initFromJournal(this);

        // <GIN>
        if (isIndiaLegalEntityEnabled)
        {
            _reference.parmIsTaxWithholdParametersEnabled_IN(isTaxWithholdParametersEnabled);
        }
        // </GIN>

        success = ledgerVoucherList.add(_reference);
        if (!success)
        {
            // adding an LVO with the same natural key twice is not supported or
            // allowed because the user's intention is not clear
            throw error(strFmt("@SYS30684", _reference.parmSubledgerVoucher()));
        }

        subledgerVoucher = _reference.parmSubledgerVoucher();
        accountingDate = _reference.parmAccountingDate();
        postingLayer = _reference.parmPostingLayer();

        lastTransDate = accountingDate;
        lastVoucher = subledgerVoucher;
        lastPostingLayer = postingLayer;

        // make it the current reference because LedgerVoucher.addTrans needs it for backward compatibility
        success = ledgerVoucherList.find(subledgerVoucher, accountingDate, postingLayer);
        Debug::assert(success);
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankAccountTransSum</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates summarized bank account transactions.
    /// </summary>
    /// <param name="_bankAccountTrans">
    ///    A temporary <c>BankAccountTrans </c>table record buffer. Generated by <c>BankVoucher</c>.
    /// </param>
    /// <returns>
    ///    true if the posting summarization level has the <c>DetailSummary::Summary</c> enumeration value; false if the posting summarization level has the <c>DetailSummary::Detail</c> enumeration value.
    /// </returns>
    /// <remarks>
    ///    This method is used by the <c>BankVoucher</c> class.
    ///    The temporary bank account transactions are inserted in the database when the <c>LedgerVoucher</c> parameter is posted.
    ///    Summarization follows
    ///    the <c>LedgerVoucher</c> parameter for Detail or Summary posting.
    /// </remarks>
    boolean bankAccountTransSum(BankAccountTrans _bankAccountTrans)
    {
        BankAccountTrans  bankAccountTrans;
        boolean           retVal;

        if (detailSummary != DetailSummary::Summary)
        {
            retVal = false;
        }
        else
        {
            this.initBankAccountTransList();

            bankAccountTrans.data(_bankAccountTrans);
            if (bankAccountTransList.find(bankAccountTrans))
            {
                bankAccountTrans.AmountCur          += _bankAccountTrans.AmountCur;
                bankAccountTrans.AmountMST          += _bankAccountTrans.AmountMST;
                bankAccountTrans.AmountReportingCurrency += _bankAccountTrans.AmountReportingCurrency;
                bankAccountTrans.AmountCorrect      += _bankAccountTrans.AmountCorrect;
                bankAccountTrans.BankTransAmountCur += _bankAccountTrans.BankTransAmountCur;
                bankAccountTrans.ReasonRefRecID =0;
            }

            bankAccountTransList.ins(bankAccountTrans, true);
            retVal = true;
        }
        return retVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankAccountTransSum_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates summarized bank account transactions.
    /// </summary>
    /// <param name="_bankAccountTrans">
    ///    A temporary <c>BankAccountTrans </c>table record buffer. Generated by <c>BankVoucher</c>.
    /// </param>
    /// <returns>
    ///    true if the posting summarization level has the <c>DetailSummary::Summary</c> enumeration value; false if the posting summarization level has the <c>DetailSummary::Detail</c> enumeration value.
    /// </returns>
    /// <remarks>
    ///    This method is used by the <c>BankVoucher</c> class.
    ///    The temporary bank account transactions are inserted in the database when the <c>LedgerVoucher</c> parameter is posted.
    ///    Always summarize
    /// </remarks>
    boolean bankAccountTransSum_BR(BankAccountTrans _bankAccountTrans)
    {
        BankAccountTrans  bankAccountTrans;
        boolean retVal;

        this.initBankAccountTransList();

        bankAccountTrans.data(_bankAccountTrans);

        if (bankAccountTransList.find(bankAccountTrans))
        {
            bankAccountTrans.AmountCur          += _bankAccountTrans.AmountCur;
            bankAccountTrans.AmountMST          += _bankAccountTrans.AmountMST;
            bankAccountTrans.AmountReportingCurrency += _bankAccountTrans.AmountReportingCurrency;
            bankAccountTrans.AmountCorrect      += _bankAccountTrans.AmountCorrect;
            bankAccountTrans.BankTransAmountCur += _bankAccountTrans.BankTransAmountCur;
            bankAccountTrans.ReasonRefRecID =0;
            bankAccountTrans.DefaultDimension = 0;

            bankAccountTransList.ins(bankAccountTrans, true);

            retVal = true;
        }
        return retVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bond_incProgress_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Increments the progress bar during an operation.
    /// </summary>
    /// <param name="_reference">
    /// The object of <c>LedgerVoucherObject</c> class.
    /// </param>
    protected void bond_incProgress_RU(LedgerVoucherObject _reference)
    {
        if (bondProgress)
        {
            bondProgress.setText(strFmt("@GLS111571", ledgerVoucherList.item().parmVoucher()), #one);
            bondProgress.setTotal(_reference.transElements(), #two);
            bondProgress.setCount(0, #two);
            bondProgress.incCount();
            _reference.parmBondProgress_RU(bondProgress);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bondLast2_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Bonds last 2 transactions.
    /// </summary>
    public void bondLast2_RU()
    {
        LedgerBondClient_RU bondClient = this.findLedgerVoucherObject().ledgerBondClient_RU();

        if (bondClient)
        {
            bondClient.bondLast2();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs validation for all the LedgerVoucherObject objects and LedgerVoucherTransObject objects held by the <c>LedgerVoucher</c> object.
    /// </summary>
    /// <returns>
    ///    true, if no errors were found; otherwise, false.
    /// </returns>
    boolean check()
    {
        LedgerVoucherObject reference;
        boolean ok = true;
        boolean haveMore;

        haveMore = ledgerVoucherList.first();
        while (haveMore)
        {
            reference = ledgerVoucherList.item();

            ok = this.checkNoErrorsInLedgerVoucher(reference, ok);

            haveMore = ledgerVoucherList.next();
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNoErrorsInLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether there are any errors in the given list.
    /// </summary>
    /// <param name = "_reference">
    /// The <c>LedgerVoucherObject</c> class.
    /// </param>
    /// <param name = "_ok">
    /// The boolean value.
    /// </param>
    /// <returns>
    /// Returns true if no errors were found; otherwise, false.
    /// </returns>
    protected boolean checkNoErrorsInLedgerVoucher(LedgerVoucherObject _reference, boolean _ok)
    {
        _ok = _reference.check(this) && _ok;

        return _ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAmountMSTAmountMSTSecundary</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if an MST amount is specified.
    /// </summary>
    /// <param name = "_amountMST">
    /// The <c>AmountMST</c> value.
    /// </param>
    /// <param name = "_amountMSTSecondary">
    /// The <c>AmountMSTSecondary</c> value.
    /// </param>
    /// <returns>
    /// true if an AmountMST or AmountMSTSecondary value are specified.
    /// </returns>
    protected boolean checkAmountMSTAmountMSTSecundary(AmountMST _amountMST, AmountMSTSecondary _amountMSTSecondary)
    {
        return (_amountMST || _amountMSTSecondary);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBalanceDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the balance demand.
    /// </summary>
    /// <returns>
    /// true if the balance demand requirements are met or if there are no requirements; otherwise, false.
    /// </returns>
    protected boolean checkBalanceDemand()
    {
        MainAccount mainAccount;
        LedgerBalanceMainAccountAmounts ledgerBalance;
        MapEnumerator enumerator;
        AmountMST accountingCurrencyBalance;
        AmountMST prevAccountingCurrencyBalance;
        DebCredProposal balanceDemand;
        MainAccountRecId mainAccountRecId;
        MainAccountRecId lastMainAccountRecId;
        TransDate endAccountingDate;
        TransDate startAccountingDate;
        TransDate lastCalcEndAccountingDate;
        boolean isValid;

        if (balanceDemandValues == null)
        {
            return true;
        }

        isValid = true;
        startAccountingDate = dateNull();

        enumerator = balanceDemandValues.getEnumerator();
        while (enumerator.moveNext())
        {
            [mainAccountRecId, endAccountingDate] = enumerator.currentKey();
            [balanceDemand, accountingCurrencyBalance] = enumerator.currentValue();

            if (mainAccountRecId != lastMainAccountRecId)
            {
                lastCalcEndAccountingDate = dateNull();
                prevAccountingCurrencyBalance = 0.0;
            }
            else
            {
                // lastCalcEndAccountingDate was set as endAccountingDate in previous calculation
                // Having the same date as startDate in current calculation might include duplicate balances from previous calculation
                lastCalcEndAccountingDate += 1;
            }

            if (accountingCurrencyBalance != 0.0)
            {
                if (ledgerBalance == null)
                {
                    ledgerBalance = LedgerBalanceMainAccountAmounts::construct();
                    ledgerBalance.parmIncludeRegularPeriod(true);
                    ledgerBalance.parmIncludeClosingPeriod(true);
                }

                mainAccount = MainAccount::find(mainAccountRecId);
                Debug::assert(mainAccount != null);

                startAccountingDate = lastCalcEndAccountingDate;

                ledgerBalance.parmAccountingDateRange(startAccountingDate, endAccountingDate);
                                
                Query query = new Query(queryStr(GeneralJournalBalanceMainAccount));
                ledgerBalance.parmGeneralJournalBaseQuery(query);
                
                ledgerBalance.calculateBalance(mainAccount);
                accountingCurrencyBalance += prevAccountingCurrencyBalance + ledgerBalance.getAccountingCurrencyBalance();

                if (balanceDemand == DebCredProposal::Debit && accountingCurrencyBalance < 0.0)
                {
                    isValid = checkFailed(strFmt(
                        "@SYS55113",
                        mainAccount.MainAccountId,
                        accountingCurrencyBalance,
                        endAccountingDate));
                }
                else if (balanceDemand == DebCredProposal::Credit && accountingCurrencyBalance > 0.0)
                {
                    isValid = checkFailed(strFmt(
                        "@SYS55114",
                        mainAccount.MainAccountId,
                        accountingCurrencyBalance,
                        endAccountingDate));
                }

                // include everything after the current date in the next iteration
				lastCalcEndAccountingDate = endAccountingDate;
                prevAccountingCurrencyBalance = accountingCurrencyBalance;
                lastMainAccountRecId = mainAccountRecId;
                endAccountingDate++;
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPostingType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks the posting type.
    /// </summary>
    /// <param name="_ledgerPostingType">
    ///    The posting type to check.
    /// </param>
    /// <returns>
    ///    true if the specified posting type is valid; otherwise, false.
    /// </returns>
    public boolean checkPostingType(LedgerPostingType _ledgerPostingType)
    {
        return (_ledgerPostingType != LedgerPostingType::None);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates an instance of the <c>LedgerVoucherObject</c> class passed in as a parameter.
    /// </summary>
    /// <param name="_voucher">
    ///    The voucher number of the <c>LedgerVoucherObject</c> object on which to perform the validation.
    /// </param>
    /// <param name="_accountingDate">
    ///    The accounting date of the <c>LedgerVoucherObject</c> object on which to perform the validation.
    /// </param>
    /// <param name="_postingLayer">
    ///    The posting layer of the <c>LedgerVoucherObject</c> object on which to perform the validation.
    /// </param>
    /// <returns>
    ///    true if no errors were found; otherwise, false.
    /// </returns>
    public boolean checkVoucher(Voucher _voucher, TransDate _accountingDate, CurrentOperationsTax _postingLayer)
    {
        LedgerVoucherObject  ledgerVoucherObject;
        boolean              retVal = true;

        if (ledgerVoucherList.find(_voucher, _accountingDate, _postingLayer))
        {
            ledgerVoucherObject = ledgerVoucherList.item();

            retVal = ledgerVoucherObject.check(this);
        }

        return retVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createVoucherLinks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates links in the LedgerTransVoucherLink table between the supplied
    /// parent information and the vouchers in the current LedgerVoucher class
    /// instance.
    /// </summary>
    /// <param name="_parentVoucher">
    /// The voucher number of the parent.
    /// </param>
    /// <param name="_parentTransDate">
    /// The transaction date of the parent.
    /// </param>
    /// <param name="_parentCompany">
    /// The company of the parent; optional.
    /// </param>
    /// <remarks>
    /// Call this method to create a relationship between two vouchers in the general journal.
    /// This method should be called in the database transaction used to create the general journal records.
    /// This method will iterate through the collection of LedgerVoucherObject class objects (there is one LedgerVoucherObject object
    /// per voucher number) contained in the LedgerVoucher class and insert LedgerTransVoucherLink records for each voucher number.
    /// The creation of the links has limited use in the application so this method should only be called if this
    /// functionality is required.
    /// </remarks>
    public void createVoucherLinks(Voucher _parentVoucher, TransDate _parentTransDate, CompanyId _parentCompany = curExt())
    {
        boolean haveRecords;
        LedgerVoucherObject ledgerVoucherObject;
        LedgerTransVoucherLink ledgerTransVoucherLink;
        RecId voucherGroupId;
        RecId previousVoucherGroupId;

        // must be within an existing database transaction
        Debug::assert(appl.ttsLevel() > 0);
        Debug::assert(_parentVoucher != '');

        haveRecords = ledgerVoucherList.first();

        if (haveRecords)
        {
            // check if a record for the parent already exists
            voucherGroupId = LedgerTransVoucherLink::findOrCreateParentVoucherLink(_parentVoucher, _parentTransDate, _parentCompany).RecId;
        }

        while (haveRecords)
        {
            ledgerVoucherObject = ledgerVoucherList.item();
            Voucher voucher = ledgerVoucherObject.parmSubledgerVoucher();
            TransDate transDate = ledgerVoucherObject.parmAccountingDate();

            RecId currentVoucherGroupId = LedgerTransVoucherLink::getCurrentVoucherGroupId(voucherGroupId, voucher, transDate);

            if (currentVoucherGroupId)
            {
                previousVoucherGroupId = voucherGroupId;
            }

            haveRecords = ledgerVoucherList.next();
        }

        LedgerTransVoucherLink::updateVoucherLinkParentGroup(previousVoucherGroupId, voucherGroupId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteFromPool</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes records from the ledger transaction pool for the specified journal batch number and voucher.
    /// </summary>
    /// <param name="_journalBatchNumber">
    /// The journal batch number.
    /// </param>
    /// <param name="_voucher">
    /// The voucher.
    /// </param>
    void deleteFromPool(
                        LedgerJournalId _journalBatchNumber,
                        Voucher _voucher
                        )
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>end</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Invokes the posting process.
    /// </summary>
    /// <returns>
    ///    true if the posting is executed without errors; otherwise, false.
    /// </returns>
    abstract boolean end()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLedgerVoucherObject</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds and returns the instance of the <c>LedgerVoucherObject</c> class passed in as a parameter.
    /// </summary>
    /// <param name="_voucher">
    ///    The voucher number of the instance of the <c>LedgerVoucherObject</c> class to find; optional.
    /// </param>
    /// <param name="_accountingDate">
    ///    The accounting date of the instance of the <c>LedgerVoucherObject</c> class to find; optional.
    /// </param>
    /// <param name="_postingLayer">
    ///    The posting layer of the instance of the <c>LedgerVoucherObject</c> class to find; optional.
    /// </param>
    /// <returns>
    ///    The instance of the <c>LedgerVoucherObject</c> class found.
    /// </returns>
    /// <remarks>
    ///    If no arguments were given, the method returns the last known <c>LedgerVoucherObject</c> object handled by the <c>LedgerVoucher</c> object.
    /// </remarks>
    LedgerVoucherObject findLedgerVoucherObject(
        Voucher _voucher = lastVoucher,
        TransDate _accountingDate = lastTransDate,
        CurrentOperationsTax _postingLayer = lastPostingLayer)
    {
        ledgerVoucherList.find(_voucher, _accountingDate, _postingLayer);

        return ledgerVoucherList.item();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrCreateReferenceSecCur_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds or creates and returns the instance of the <c>LedgerVoucherObject</c> class for dual warehousing posting layer.
    /// </summary>
    /// <returns>
    ///     The instance of the <c>LedgerVoucherObject</c> class found or created.
    /// </returns>
    /// <remarks>
    ///    The last values are updated and should be restored by calling method restoreReferenceSecCur_RU().
    /// </remarks>
    public LedgerVoucherObject findOrCreateReferenceSecCur_RU()
    {
        LedgerVoucherObject ledgerVoucherObject = ledgerVoucherList.item();
        LedgerVoucherObject origObject;
        SysModule           origSysModule;
        CurrentOperationsTax origPostingLayer;

        if (!postingLayerStack)
        {
            postingLayerStack = new Stack();
        }

        if (ledgerVoucherObject)
        {
            origPostingLayer    = ledgerVoucherObject.parmPostingLayer();
            origSysModule       = ledgerVoucherObject.parmSysModule();
        }
        else
        {
            origPostingLayer    = this.lastPostingLayer();
            origSysModule       = this.parmSysModuleDefault();
        }

        postingLayerStack.push([origPostingLayer]);

        if (!ledgerVoucherObject || ledgerVoucherObject.parmPostingLayer() != CurrentOperationsTax::WarehouseCur_RU)
        {
            origObject          = ledgerVoucherObject;
            ledgerVoucherObject = this.findReference(lastVoucher, lastTransDate, CurrentOperationsTax::WarehouseCur_RU);

            if (!ledgerVoucherObject)
            {
                ledgerVoucherObject = LedgerVoucherObject::newReference(lastVoucher, lastTransDate, origSysModule);

                if (origObject)
                {
                    ledgerVoucherObject.parmGeneralJournalEntry                 (origObject.parmGeneralJournalEntry());
                    ledgerVoucherObject.parmBondProgress_RU                     (origObject.parmBondProgress_RU());
                    ledgerVoucherObject.parmIsExplicitBudgetCheckRequired       (origObject.parmIsExplicitBudgetCheckRequired());
                    ledgerVoucherObject.parmPaymentReferenceDefault             (origObject.parmPaymentReferenceDefault());
                    ledgerVoucherObject.parmSkipPeriodStatusValidation          (origObject.parmSkipPeriodStatusValidation());
                    ledgerVoucherObject.parmSkipPeriodTypeValidation            (origObject.parmSkipPeriodTypeValidation());
                    ledgerVoucherObject.parmTrackTransactionAmountsByCurrency   (origObject.parmTrackTransactionAmountsByCurrency());
                    ledgerVoucherObject.parmUseBalanceDifference                (origObject.parmUseBalanceDifference());
                    ledgerVoucherObject.parmVoucherCheck                        (origObject.parmVoucherCheck());
                    ledgerVoucherObject.parmVoucherSeriesCode                   (origObject.parmVoucherSeriesCode());
                }

                ledgerVoucherObject.parmPostingLayer(CurrentOperationsTax::WarehouseCur_RU);

                this.addVoucher(ledgerVoucherObject);
            }

            if (origObject)
            {
                ledgerVoucherObject.parmIsCorrectionDefault(origObject.parmIsCorrectionDefault());
            }
        }

        return ledgerVoucherObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findReference</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds and returns the <c>LedgerVoucherObject</c> object matching the specified parameters.
    /// </summary>
    /// <param name="_subledgerVoucher">
    ///    The subledger voucher of the <c>LedgerVoucherObject</c> object to find.
    /// </param>
    /// <param name="_accountingDate">
    ///    The accounting date of the <c>LedgerVoucherObject</c> object to find.
    /// </param>
    /// <param name="_postingLayer">
    ///    The posting layer of the <c>LedgerVoucherObject</c> object to find.
    /// </param>
    /// <returns>
    ///    The <c>LedgerVoucherObject</c> object; otherwise, null.
    /// </returns>
    /// <remarks>
    ///    The last values are updated if the object is found.
    /// </remarks>
    public LedgerVoucherObject findReference(Voucher _subledgerVoucher, TransDate _accountingDate, CurrentOperationsTax _postingLayer)
    {
        boolean isFound;

        isFound = ledgerVoucherList.find(_subledgerVoucher, _accountingDate, _postingLayer);
        if (isFound)
        {
            // set the last values to maintain backward compatibility for LedgerVoucher.findLedgerVoucherObject()
            lastVoucher = _subledgerVoucher;
            lastTransDate = _accountingDate;
            lastPostingLayer = _postingLayer;
        }

        return ledgerVoucherList.item();
    }

]]></Source>
			</Method>
			<Method>
				<Name>flushAllWHTInvoiceCompany_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Used to reset the container value.
    /// </summary>
    public void flushAllWHTInvoiceCompany_IN()
    {
        allInvoiceCompany = conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInternalCollection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the internal collection of general journal entries.
    /// </summary>
    /// <returns>
    /// The internal collection of general journal entries.
    /// </returns>
    /// <remarks>
    /// This method should be used only when absolutely necessary.
    /// </remarks>
    public LedgerVoucherList getInternalCollection()
    {
        return ledgerVoucherList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerAccountFromCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ledger account of the ledger dimension from the cache.
    /// </summary>
    /// <param name="_ledgerDimension">
    /// The ledger dimension.
    /// </param>
    /// <returns>
    /// The ledger account of the ledger dimension; otherwise, an empty string.
    /// </returns>
    public DimensionDisplayValue getLedgerAccountFromCache(LedgerDimensionAccount _ledgerDimension)
    {
        if (ledgerAccountCache.exists(_ledgerDimension))
        {
            return ledgerAccountCache.lookup(_ledgerDimension);
        }
        else
        {
            return '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMainAccountFromCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the main account for the ledger dimension, accounting date, and posting type
    /// combination from the cache.
    /// </summary>
    /// <param name="_ledgerDimension">
    /// The ledger dimension.
    /// </param>
    /// <param name="_accountingDate">
    /// The accounting date.
    /// </param>
    /// <param name="_postingType">
    /// The posting type.
    /// </param>
    /// <returns>
    /// The main account if the ledger dimension, accounting date, and posting type combination
    /// is valid; otherwise, an empty record.
    /// </returns>
    public MainAccount getMainAccountFromCache(RecId _ledgerDimension, TransDate _accountingDate, LedgerPostingType _postingType)
    {
        if (validLedgerDimensionCache.exists([_ledgerDimension, _accountingDate, _postingType]))
        {
            return validLedgerDimensionCache.lookup([_ledgerDimension, _accountingDate, _postingType]);
        }
        else
        {
            return null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextTemporaryRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a temporary record ID.
    /// </summary>
    /// <returns>
    /// A temporary record ID.
    /// </returns>
    public RecId getNextTemporaryRecId()
    {
        return generalJournalController.getNextTemporaryRecId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransferLevel</Name>
				<Source><![CDATA[
    public DetailSummary getTransferLevel(LedgerDetailLevel _transactionTransferLevel)
    {
        DetailSummary adjustedTransferLevel;

        if (_transactionTransferLevel == LedgerDetailLevel::AsDefault)
        {
            adjustedTransferLevel = detailSummary;
        }
        else if (_transactionTransferLevel == LedgerDetailLevel::Detail)
        {
            adjustedTransferLevel = DetailSummary::Detail;
        }
        else if (_transactionTransferLevel == LedgerDetailLevel::Summary)
        {
            adjustedTransferLevel = DetailSummary::Summary;
        }
        else
        {
            Debug::assert(false);
        }

        return adjustedTransferLevel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWHTInvoiceCompanyFromCache_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get tax withhold amount from cache due to invoice company
    /// </summary>
    /// <param name="_companyId">
    /// Invoice company id
    /// </param>
    /// <param name="_voucher">
    /// Voucher number
    /// </param>
    /// <returns>
    /// Invoice company withhold amount
    /// </returns>
    public AmountCur getWHTInvoiceCompanyFromCache_IN(
        CompanyId   _companyId,
        Voucher     _voucher)
    {
        AmountCur   taxWithholdAmount;

        if (withholdTaxInvoiceCompanyCache.exists([_companyId, _voucher]))
        {
            taxWithholdAmount =  withholdTaxInvoiceCompanyCache.lookup([_companyId, _voucher]);
        }

        return taxWithholdAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBankAccountTransList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>RecordSortedList</c> instance for the <c>BankAccountTrans</c> table.
    /// </summary>
    protected void initBankAccountTransList()
    {
        if (!bankAccountTransList)
        {
            bankAccountTransList = new RecordSortedList(tableNum(BankAccountTrans));

            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                bankAccountTransList.sortOrder(
                    fieldNum(BankAccountTrans, TransDate),
                    fieldNum(BankAccountTrans, Voucher),
                    fieldNum(BankAccountTrans, LedgerDimension),
                    fieldNum(BankAccountTrans, LedgerTransType),
                    fieldNum(BankAccountTrans, AccountId),
                    fieldNum(BankAccountTrans, CurrencyCode),
                    fieldNum(BankAccountTrans, AccountStatement),
                    fieldNum(BankAccountTrans, AccountStatementDate),
                    fieldNum(BankAccountTrans, BankTransType),
                    fieldNum(BankAccountTrans, PaymReference),
                    fieldNum(BankAccountTrans, DepositNum),
                    fieldNum(BankAccountTrans, Reconciled),
                    fieldNum(BankAccountTrans, Included),
                    fieldNum(BankAccountTrans, Manual),
                    fieldNum(BankAccountTrans, ChequeNum),
                    fieldNum(BankAccountTrans, Cancel),
                    fieldNum(BankAccountTrans, BankTransCurrencyCode));
            }
            else
            {
            // </GBR>
                bankAccountTransList.sortOrder(
                    fieldNum(BankAccountTrans, TransDate),
                    fieldNum(BankAccountTrans, Voucher),
                    fieldNum(BankAccountTrans, LedgerDimension),
                    fieldNum(BankAccountTrans, LedgerTransType),
                    fieldNum(BankAccountTrans, AccountId),
                    fieldNum(BankAccountTrans, CurrencyCode),
                    fieldNum(BankAccountTrans, AccountStatement),
                    fieldNum(BankAccountTrans, AccountStatementDate),
                    fieldNum(BankAccountTrans, BankTransType),
                    fieldNum(BankAccountTrans, PaymReference),
                    fieldNum(BankAccountTrans, DepositNum),
                    fieldNum(BankAccountTrans, Reconciled),
                    fieldNum(BankAccountTrans, Included),
                    fieldNum(BankAccountTrans, DefaultDimension),
                    fieldNum(BankAccountTrans, Manual),
                    fieldNum(BankAccountTrans, ChequeNum),
                    fieldNum(BankAccountTrans, Cancel),
                    fieldNum(BankAccountTrans, BankTransCurrencyCode));
            // <GBR>
            }
            // </GBR>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxParameters_IN</Name>
				<Source><![CDATA[
    private void initTaxParameters_IN()
    {
        isIndiaLegalEntityEnabled = true;
        isTaxWithholdParametersEnabled = TaxWithholdParameters_IN::checkTaxParameters();
        isVATEnabled = TaxParameters::isVATEnable_IN();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAccountingDateValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that indicates whether the accounting date and fiscal calendar
    /// period combination is valid.
    /// </summary>
    /// <param name="_accountingDate">
    /// The accounting date.
    /// </param>
    /// <param name="_fiscalCalendarPeriodRecId">
    /// The fiscal calendar period.
    /// </param>
    /// <returns>
    /// true if the accounting date and fiscal calendar period combination is valid; otherwise, false.
    /// </returns>
    public boolean isAccountingDateValid(TransDate _accountingDate, FiscalCalendarPeriodRecId _fiscalCalendarPeriodRecId)
    {
        return validAccountingDateCache.in([companyId, _accountingDate, _fiscalCalendarPeriodRecId]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastAmountCur</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the last known transaction currency amount from a specified instance of the <c>LedgerVoucherObject</c> class.
    /// </summary>
    /// <param name="_voucher">
    ///    The voucher number of the instance of the <c>LedgerVoucherObject</c> class from which to find the amount; optional.
    /// </param>
    /// <param name="_accountingDate">
    ///    The accounting date of the instance of the <c>LedgerVoucherObject</c> class from which to find the amount; optional.
    /// </param>
    /// <param name="_postingLayer">
    ///    The posting layer of the instance of the <c>LedgerVoucherObject</c> class from which to find the amount; optional.
    /// </param>
    /// <returns>
    ///    The last known amount in currency.
    /// </returns>
    /// <remarks>
    ///    If the parameter is not supplied, the last known <c>LedgerVoucherObject</c> object will be used.
    /// </remarks>
    AmountCur lastAmountCur(Voucher _voucher = lastVoucher,
        TransDate _accountingDate = lastTransDate,
        CurrentOperationsTax _postingLayer = lastPostingLayer)
    {
        AmountCur  retVal = 0;

        if (ledgerVoucherList.find(_voucher, _accountingDate, _postingLayer))
        {
            retVal = ledgerVoucherList.item().lastAmountCur();
        }

        return retVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the last known accounting currency amount from a specified instance of the <c>LedgerVoucherObject</c> class.
    /// </summary>
    /// <param name="_voucher">
    ///    The voucher number of the instance of the <c>LedgerVoucherObject</c> class from which to find the amount; optional.
    /// </param>
    /// <param name="_accountingDate">
    ///    The accounting date of the instance of the <c>LedgerVoucherObject</c> class from which to find the amount; optional.
    /// </param>
    /// <param name="_postingLayer">
    ///    The posting layer of the instance of the <c>LedgerVoucherObject</c> class from which to find the amount; optional.
    /// </param>
    /// <returns>
    ///    The last known amount in MST.
    /// </returns>
    /// <remarks>
    ///    If the argument is not supplied, the last known <c>LedgerVoucherObject</c> object will be used.
    /// </remarks>
    AmountMST lastAmountMST(
        Voucher _voucher = lastVoucher,
        TransDate _accountingDate = lastTransDate,
        CurrentOperationsTax _postingLayer = lastPostingLayer)
    {
        AmountMST  retVal = 0;

        if (ledgerVoucherList.find(_voucher, _accountingDate, _postingLayer))
        {
            retVal = ledgerVoucherList.item().lastAmountMST();
        }

        return retVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastPostingLayer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the last posting layer value.
    /// </summary>
    /// <param name = "_lastPostingLayer">
    /// The <c>CurrentOperationsTax</c> enumeration value.
    /// </param>
    /// <returns>
    /// The current <c>CurrentOperationsTax</c> enumeration value.
    /// </returns>
    public CurrentOperationsTax lastPostingLayer(CurrentOperationsTax _lastPostingLayer = lastPostingLayer)
    {
        lastPostingLayer = _lastPostingLayer;

        return lastPostingLayer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or gets the last known transaction date.
    /// </summary>
    /// <param name="_lastTransDate">
    ///    The transaction date to set; optional.
    /// </param>
    /// <returns>
    ///    The last known transaction date.
    /// </returns>
    final TransDate lastTransDate(TransDate _lastTransDate = lastTransDate)
    {
        lastTransDate = _lastTransDate;
        return lastTransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or gets the last known voucher number.
    /// </summary>
    /// <param name="_lastVoucher">
    ///    The voucher number to set; optional.
    /// </param>
    /// <returns>
    ///    The last known voucher number.
    /// </returns>
    final Voucher lastVoucher(Voucher _lastVoucher = lastVoucher)
    {
        lastVoucher = _lastVoucher;
        return lastVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        // <GIN>
        #ISOCountryRegionCodes
        // </GIN>
        checkAuto               = true;
        checkTransOnInsert      = false;
        checkBlockedDimensions  = true;

        detailSummary = DetailSummary::Detail;

        ledgerVoucherList = LedgerVoucherList::construct();
        validAccountingDateCache = new Set(Types::Container);
        validLedgerDimensionCache = new Map(Types::Container, Types::Record);
        ledgerAccountCache = new Map(Types::Int64, Types::String);

        generalJournalController = LedgerPostingGeneralJournalController::construct();
        ledgerPostingMessageCollection = LedgerPostingMessageLog::construct();

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            this.initTaxParameters_IN();
            withholdTaxInvoiceCompanyCache = new Map(Types::Container, Types::Real);
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>numOfVouchers</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the number of <c>LedgerVoucherObject</c> objects added to the <c>LedgerVoucher</c>.
    /// </summary>
    /// <returns>
    ///    The count of <c>LedgerVoucherObject</c> objects
    /// </returns>
    /// <remarks>
    ///    The count is increased when adding a <c>LedgerVoucherObject</c> by calling the <c>addVoucher</c> method.
    /// </remarks>
    Counter numOfVouchers()
    {
        return ledgerVoucherList.elements();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerVoucherList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Used to set the parm method for list of ledger voucher.
    /// </summary>
    /// <param name="_ledgerVoucherList">
    /// Variable used to set list of ledger voucher.
    /// </param>
    /// <returns>
    /// Return the list of ledger voucher.
    /// </returns>
    internal LedgerVoucherList parmLedgerVoucherList(LedgerVoucherList _ledgerVoucherList = ledgerVoucherList)
    {
        ledgerVoucherList = _ledgerVoucherList;

        return ledgerVoucherList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdvancePaymentWHT_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Used to set the parm method for advance payment for withholding tax.
    /// </summary>
    /// <param name="_advancePaymentWHT">
    /// Variable used to set withholding tax value.
    /// </param>
    /// <returns>
    /// Return the default set amount.
    /// </returns>
    public AmountCur parmAdvancePaymentWHT_IN(AmountCur _advancePaymentWHT = advancePaymentWHT)
    {
        advancePaymentWHT = _advancePaymentWHT;

        return advancePaymentWHT;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllWHTInvoiceCompany_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Container used to hold company id for invoice and payment company.
    /// </summary>
    /// <param name="_companyId">
    /// Company id used to set in parm method.
    /// </param>
    /// <returns>
    /// Return the values hold in container.
    /// </returns>
    public container parmAllWHTInvoiceCompany_IN(container _companyId = allInvoiceCompany)
    {
        if (conPeek(_companyId, 5))
        {
            if (!conFind(allInvoiceCompany, conPeek(_companyId, 5)))
            {
                allInvoiceCompany += conPeek(_companyId, 5);
            }
        }

        return allInvoiceCompany;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBackWardAmountWHT_IN</Name>
				<Source><![CDATA[
    public TaxWithholdAmountCur parmBackWardAmountWHT_IN(TaxWithholdAmountCur _backWardAmountWHT = backWardAmountWHT)
    {
        backWardAmountWHT = _backWardAmountWHT;

        return backWardAmountWHT;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmcheckAuto</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets whether the posting process should automatically call the
    /// <c>check</c> method to make a validation before starting the posting process.
    /// </summary>
    /// <param name="_checkAuto">
    /// The value to set checkAuto to; optional.
    /// </param>
    /// <returns>
    /// The value of checkAuto.
    /// </returns>
    /// <remarks>
    /// The default setting of this parameter is true.
    /// </remarks>
    protected final boolean parmcheckAuto(boolean _checkAuto = checkAuto)
    {
        checkAuto = _checkAuto;
        return checkAuto;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckBank_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set Bank flag for banks transaction type.
    /// </summary>
    /// <param name="_checkBank">
    /// Used to set parm method.
    /// </param>
    /// <returns>
    /// Return true based on the passed parameter.
    /// </returns>
    public boolean parmCheckBank_IN(boolean _checkBank = taxWithholdkBankStatus)
    {
        taxWithholdkBankStatus = _checkBank;

        return taxWithholdkBankStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckBlockedDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or gets the value of the <c>checkBlockedDimensions</c> variable.
    /// </summary>
    /// <param name="_checkBlockedDimensions">
    ///    The value to set the <c>checkedBlockedDimensions</c> variable to; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>checkedBlockedDimensions</c> variable.
    /// </returns>
    final boolean parmCheckBlockedDimensions(boolean _checkBlockedDimensions = checkBlockedDimensions)
    {
        checkBlockedDimensions = _checkBlockedDimensions;
        return checkBlockedDimensions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckTransOnInsert</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or gets the checkTransOnInsert variable.
    ///    The checkTransOnInsert parameter determines if ledger transactions (LedgerVoucherTransObject) should be validated at the time of insertion into the
    ///    voucher, or later when validating the entire voucher.
    /// </summary>
    /// <param name="_checkTransOnInsert">
    ///    The value to set the variable checkTransOnInsert to; optional.
    /// </param>
    /// <returns>
    ///    The value of the variable checkTransOnInsert.
    /// </returns>
    /// <remarks>
    ///    The default setting of the parameter is false.
    /// </remarks>
    final boolean parmCheckTransOnInsert(boolean _checkTransOnInsert = checkTransOnInsert)
    {
        checkTransOnInsert = _checkTransOnInsert;
        return checkTransOnInsert;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCompanyId</Name>
				<Source><![CDATA[
    public CompanyId parmCompanyId(CompanyId _companyId = companyId)
    {
        companyId = _companyId;
        return companyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCurrentCompany_IN</Name>
				<Source><![CDATA[
    public CompanyId parmCurrentCompany_IN(CompanyId _currentCompany_IN = currentCompany_IN)
    {
        currentCompany_IN = _currentCompany_IN;

        return currentCompany_IN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustomDetailLevel</Name>
				<Source><![CDATA[
    boolean parmCustomDetailLevel(boolean _customLevelOfDetail = customLevelOfDetail)
    {
        customLevelOfDetail = _customLevelOfDetail;

        return customLevelOfDetail;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDetailSummary</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or gets the <c>detailSummary</c> variable.
    /// </summary>
    /// <param name="_detailSummary">
    ///    The <c>DetailSummary</c> enumeration value to set; either <c>DetailSummary::Detail</c> or <c>DetailSummary::Summary</c>.
    /// </param>
    /// <returns>
    ///    The value of the detailSummary variable.
    /// </returns>
    DetailSummary parmDetailSummary(DetailSummary  _detailSummary = detailSummary)
    {
        detailSummary = _detailSummary;
        return detailSummary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterCompanyTransForST_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Used to set the value for intercompany transaction.
    /// </summary>
    /// <param name="_checkSTForInterCompany">
    /// CheckSTForInterCompany id used to set value in parm method.
    /// </param>
    /// <returns>
    /// Return the values hold in container.
    /// </returns>
    public container parmInterCompanyTransForST_IN(container _checkSTForInterCompany = checkSTForInterCompany)
    {
        checkSTForInterCompany = _checkSTForInterCompany;

        return checkSTForInterCompany;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsVATDeferment_IN</Name>
				<Source><![CDATA[
    public boolean parmIsVATDeferment_IN(boolean _isVATDeferment = isVATDeferment)
    {
        isVATDeferment = _isVATDeferment;

        return isVATDeferment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalCheckPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or gets the <c>journalCheckPost</c> variable
    /// </summary>
    /// <param name="_journalCheckPost">
    ///    An instance of the <c>JournalCheckPost</c> class to which the <c>journalCheckPost</c> variable is set; optional.
    /// </param>
    /// <returns>
    ///    The <c>journalCheckPost</c> variable.
    /// </returns>
    /// <remarks>
    ///    Not currently used.
    /// </remarks>
    protected JournalCheckPost parmJournalCheckPost(JournalCheckPost _journalCheckPost = journalCheckPost)
    {
        journalCheckPost = _journalCheckPost;
        return journalCheckPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the journal number.
    /// </summary>
    /// <param name="_journalNumber">
    /// The journal number; optional.
    /// </param>
    /// <returns>
    /// The journal number.
    /// </returns>
    public LedgerJournalId parmJournalNumber(LedgerJournalId _journalNumber = ledgerEntryJournal.JournalNumber)
    {
        ledgerEntryJournal.JournalNumber = _journalNumber;

        return ledgerEntryJournal.JournalNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalTableData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or gets the <c>journalTableData</c> variable.
    /// </summary>
    /// <param name="_journalTableData">
    ///    An instance of the <c>JournalTableData</c> class to set the <c>journalTableData</c> variable to; optional.
    /// </param>
    /// <returns>
    ///    The <c>journalTableData</c> variable.
    /// </returns>
    /// <remarks>
    ///    Not currently used.
    /// </remarks>
    protected JournalTableData parmJournalTableData(JournalTableData _journalTableData = journalTableData)
    {
        journalTableData = _journalTableData;
        return journalTableData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalId</Name>
				<Source><![CDATA[
    // This method is obsolete and has been replaced with the parmJournalNumber method.
    public LedgerJournalId parmLedgerJournalId(LedgerJournalId _ledgerJournalId = ledgerEntryJournal.JournalNumber)
    {
        ledgerEntryJournal.JournalNumber = _ledgerJournalId;

        return ledgerEntryJournal.JournalNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerPostingMessageLog</Name>
				<Source><![CDATA[
    public LedgerPostingMessageLog parmLedgerPostingMessageLog(LedgerPostingMessageLog _ledgerPostingMessageCollection = ledgerPostingMessageCollection)
    {
        ledgerPostingMessageCollection = _ledgerPostingMessageCollection;

        return ledgerPostingMessageCollection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerVoucherType_CN</Name>
				<Source><![CDATA[
    public LedgerVoucherTypeRefRecId_CN parmLedgerVoucherType_CN(LedgerVoucherTypeRefRecId_CN _ledgerVoucherTypeCN = ledgerVoucherTypeCN)
    {
        ledgerVoucherTypeCN = _ledgerVoucherTypeCN;

        return ledgerVoucherTypeCN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOpeningSheet_ES</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Accessor for the <c>openingSheet_ES</c> variable.
    /// </summary>
    /// <param name="_openingSheet_ES">
    ///    Boolean flag which is enabled when posting from the opening sheet; optional.
    /// </param>
    /// <returns>
    ///    A <c>boolean</c> value that represents the <c>openingSheet_ES</c> variable.
    /// </returns>
    public boolean parmOpeningSheet_ES(boolean _openingSheet_ES = openingSheet_ES)
    {
        openingSheet_ES = _openingSheet_ES;
        return openingSheet_ES;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostedInterCompanyWHT_IN</Name>
				<Source><![CDATA[
    public TaxWithholdAmountCur parmPostedInterCompanyWHT_IN(TaxWithholdAmountCur _postedWHT = postedInterCompanyWHT)
    {
        postedInterCompanyWHT = _postedWHT;

        return postedInterCompanyWHT;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReversal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or gets the reversal variable. The reversal variable controls if the posting is a reversal posting.
    /// </summary>
    /// <param name="_reversal">
    ///    The value to set the reversal variable to; optional.
    /// </param>
    /// <returns>
    ///    The value of the reversal variable.
    /// </returns>
    final boolean parmReversal(boolean _reversal = reversal)
    {
        reversal = _reversal;
        return reversal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipBlockedForManualEntryCheck</Name>
				<Source><![CDATA[
    public boolean parmSkipBlockedForManualEntryCheck(boolean _skipBlockedForManualEntryCheck = skipBlockedForManualEntryCheck)
    {
        skipBlockedForManualEntryCheck = _skipBlockedForManualEntryCheck;
        return skipBlockedForManualEntryCheck;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSysModuleDefault</Name>
				<Source><![CDATA[
    public SysModule parmSysModuleDefault(SysModule _sysModuleDefault = sysModuleDefault)
    {
        sysModuleDefault = _sysModuleDefault;

        return sysModuleDefault;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxWithholdTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Used to set <c>TmpTaxWithholdTransInterCompany_IN</c> buffer.
    /// </summary>
    /// <param name="_taxWithholdTransInterCompany">
    /// Variable used to set <c>TmpTaxWithholdTransInterCompany_IN</c> buffer.
    /// </param>
    /// <returns>
    /// Return <c>TmpTaxWithholdTransInterCompany_IN</c> table buffer.
    /// </returns>
    public TmpTaxWithholdTransInterCompany_IN parmTaxWithholdTrans_IN(TmpTaxWithholdTransInterCompany_IN _taxWithholdTransInterCompany = taxWithholdTransInterCompany)
    {
        taxWithholdTransInterCompany = _taxWithholdTransInterCompany;

        return taxWithholdTransInterCompany;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTmpVoucherMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or gets the <c>tmpVoucherMap</c> variable.
    ///    This <c>Map</c> class variable represents a list of temporary voucher numbers to be replaced with continuous voucher numbers.
    /// </summary>
    /// <param name="_tmpVoucherMap">
    ///    An instance of the <c>Map</c> class to assign to the <c>tmpVoucherMap</c> variable; optional.
    /// </param>
    /// <returns>
    ///    The <c>Map</c> object assigned to the <c>tmpVoucherMap</c> variable.
    /// </returns>
    /// <remarks>
    ///    This method is used in journal posting when continuous voucher numbers are required.
    /// </remarks>
    Map parmTmpVoucherMap(Map _tmpVoucherMap = tmpVoucherMap)
    {
        tmpVoucherMap = _tmpVoucherMap;
        return tmpVoucherMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransactionLog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the type and the text for the entry made to the transaction log upon posting.
    /// </summary>
    /// <param name="_transactionLogType">
    ///    A <c>TransactionLogType</c> enumeration value that indicates the log type.
    /// </param>
    /// <param name="_transactionLogTxt">
    ///    The text string to write to the transaction log.
    /// </param>
    protected void parmTransactionLog(TransactionLogType _transactionLogType,
                                      TransTxt           _transactionLogTxt)
    {
        transactionLogType = _transactionLogType;
        transactionLogTxt  = _transactionLogTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucher_CN</Name>
				<Source><![CDATA[
    public Voucher_CN parmVoucher_CN(Voucher_CN _voucherCN = voucherCN)
    {
        voucherCN = _voucherCN;

        return voucherCN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucherSeriesCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>voucherSeriesCode</c> variable.
    /// </summary>
    /// <param name="_voucherSeriesCode">
    ///    A voucher series code; optional.
    /// </param>
    /// <returns>
    ///    A <c>NumberSequenceCode</c> value that represents the <c>voucherSeriesCode</c> variable.
    /// </returns>
    NumberSequenceCode parmVoucherSeriesCode(NumberSequenceCode _voucherSeriesCode = voucherSeriesCode)
    {
        voucherSeriesCode = _voucherSeriesCode;
        return voucherSeriesCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs posting of the vouchers within an instance of the <c>LedgerVoucher</c> class.
    /// </summary>
    /// <returns>
    ///    true if the posting was successful; otherwise, false.
    /// </returns>
    protected boolean post()
    {
        LedgerVoucherObject reference;
        Map generalJournalEntryRecIdValues;
        GeneralJournalEntryRecId generalJournalEntryRecId;
        LedgerTmpInterunitBalancerAccountEntry ledgerTmpInterunitBalancerAccountEntry;
        LedgerTmpInterunitBalancerTotal ledgerTmpInterunitBalancerTotal;
        boolean more;
        boolean ok = true;
        Voucher previousVoucher;

        // <GEERU>
        NoYes correspondenceEnabled = LedgerParameters::find().Correspondence_RU;
        #avifiles

        if (correspondenceEnabled)
        {
            bondProgress = SysOperationProgress::newMultiBar(#two, #aviUpdate, "@GLS101312");
            bondProgress.setTotal(this.numOfVouchers());
            bondProgress.setTotal(1, 2);
        }
        // </GEERU>

        if (checkAuto)
        {
            if (!this.check())
            {
                throw error("@SYS21533");
            }
        }

        FiscalCalendarPeriodRecId previousPeriod;

        ttsbegin;

        more = ledgerVoucherList.first();
        while (more)
        {
            reference = ledgerVoucherList.item();

            // <GCN>
            if (LedgerParameters::isChineseVoucher_CN()
                && reference.transElements() != 0)
            {
                if (ledgerVoucherTypeCN
                    && voucherCN
                    && reference.parmLedgerVoucherType_CN() == 0
                    && (reference.parmVoucher() == previousVoucher || previousVoucher == '')
                    && (reference.parmFiscalCalendarPeriod() == previousPeriod || previousPeriod == 0))
                {
                    reference.parmVoucher_CN(voucherCN);
                    reference.parmLedgerVoucherType_CN(ledgerVoucherTypeCN);

                    if (previousVoucher == '')
                    {
                        previousVoucher = reference.parmVoucher();
                    }

                    if (previousPeriod == 0)
                    {
                        previousPeriod = reference.parmFiscalCalendarPeriod();
                    }
                }
                else
                {
                    reference.initLedgerVoucherType_CN();
                    voucherCN = reference.parmVoucher_CN();
                    ledgerVoucherTypeCN = reference.parmLedgerVoucherType_CN();
                    previousVoucher = reference.parmVoucher();
                    previousPeriod = reference.parmFiscalCalendarPeriod();
                }
            }
            // </GCN>

            // <GEERU>
            if (correspondenceEnabled)
            {
                this.bond_incProgress_RU(reference);
            }
            // </GEERU>

            if (LedgerInterunitBalancer::isBalancingEnabled())
            {
                delete_from ledgerTmpInterunitBalancerTotal;
                delete_from ledgerTmpInterunitBalancerAccountEntry;

                reference.parmLedgerTmpInterunitBalancerAccountEntry(ledgerTmpInterunitBalancerAccountEntry);
                reference.parmLedgerTmpInterunitBalancerTotal(ledgerTmpInterunitBalancerTotal);
            }

            ok = reference.post(this) && ok;

            if (ledgerEntryJournal.JournalNumber != '')
            {
                this.deleteFromPool(
                    reference.parmSubledgerVoucher(),
                    ledgerEntryJournal.JournalNumber
                    );
            }

            more = ledgerVoucherList.next();
        }

        ok = this.postBankAccountTrans() && ok;

        // have to check balance demand before updating the general journal
        ok = this.checkBalanceDemand() && ok;

        if (!ok)
        {
            throw error("@SYS21533");
        }

        generalJournalController.transfer();
        generalJournalEntryRecIdValues = generalJournalController.getGeneralJournalEntryRecIdValues();

        if (ledgerPostingSubledgerJournalController != null)
        {
            ledgerPostingSubledgerJournalController.transfer();
        }

        more = ledgerVoucherList.first();
        while (more)
        {
            reference = ledgerVoucherList.item();

            if (reference.isPosted() && generalJournalEntryRecIdValues.exists([reference.parmSubledgerVoucher(), reference.parmAccountingDate()]))
            {
                generalJournalEntryRecId = generalJournalEntryRecIdValues.lookup([reference.parmSubledgerVoucher(), reference.parmAccountingDate()]);
                reference.parmGeneralJournalEntryRecId(generalJournalEntryRecId);
            }

            more = ledgerVoucherList.next();
        }

        if (transactionLogType != TransactionLogType::Unspecified)
        {
            TransactionLog::create(transactionLogType, transactionLogTxt);
        }

        ttscommit;

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postBankAccountTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts the list of bank account transactions.
    /// </summary>
    /// <returns>
    ///    true if posted without errors; otherwise, false.
    /// </returns>
    boolean postBankAccountTrans()
    {
        boolean             more;
        BankAccountTrans    bankAccountTrans;

        if (bankAccountTransList)
        {
            for (more = bankAccountTransList.first(bankAccountTrans);
                 more;
                 more = bankAccountTransList.next(bankAccountTrans))
            {
                // <GBR>
                if (!BrazilParameters::isEnabled() ||
                   (BrazilParameters::isEnabled() && bankAccountTrans.AmountCur != 0 && bankAccountTrans.AmountMST != 0))
                {
                // </GBR>
					bankAccountTrans.insert();

                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL, #isoHU]))
                    {
                        BankAccountTransPL bankAccountTransPL;
                        bankAccountTransPL.ExcludeExchAdj_PL = excludeExchAdj_PL;
                        bankAccountTransPL.BankAccountTrans = bankAccountTrans.RecId;
                        bankAccountTransPL.insert();
                    }
                // <GBR>
                }
                // </GBR>
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>releaseCNLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Release CN ledger voucher.
    /// </summary>
    /// <param name="_reference">
    /// The ledger voucher object reference.
    /// </param>
    protected void releaseCNLedgerVoucher(LedgerVoucherObject _reference)
    {
        //Release the Chinese ledger voucher.
        NumberSeq_Voucher_CN::release(
                LedgerVoucherType_CN::find(_reference.parmLedgerVoucherType_CN()).NumberSequenceTable,
                _reference.parmVoucher_CN(),
                _reference.parmAccountingDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>restoreReferenceSecCur_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Restores values which were updated in the method findOrCreateReferenceSecCur_RU
    /// </summary>
    public void restoreReferenceSecCur_RU()
    {
        if (!postingLayerStack || !postingLayerStack.qty())
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        [lastPostingLayer] = postingLayerStack.pop();
        this.findLedgerVoucherObject();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWHTInvoiceCompanyToCache_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates withhold tax amount into cache for invoice company
    /// </summary>
    /// <param name="_companyId">
    /// Invoice company id
    /// </param>
    /// <param name="_voucher">
    /// Voucher number
    /// </param>
    /// <param name="_taxAmount">
    /// Calculated withhold tax amount
    /// </param>
    /// <returns>
    /// Updated invoice company withhold tax amount
    /// </returns>
    public AmountCur updateWHTInvoiceCompanyToCache_IN(
        CompanyId       _companyId,
        Voucher         _voucher,
        TaxAmountCur    _taxAmount)
    {
        AmountCur   taxWithholdAmount = _taxAmount;

        if (withholdTaxInvoiceCompanyCache.exists([_companyId, _voucher]))
        {
            taxWithholdAmount +=  withholdTaxInvoiceCompanyCache.lookup([_companyId, _voucher]);

            withholdTaxInvoiceCompanyCache.remove([_companyId, _voucher]);
        }

        withholdTaxInvoiceCompanyCache.insert([_companyId, _voucher], taxWithholdAmount);

        return taxWithholdAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>literalOperationsTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the posting layer that will include the same records as the specified current posting layer.
    /// </summary>
    /// <param name="_currentOperationsTax">
    /// The currentOperationsTax value.
    /// </param>
    /// <returns>
    /// The OperationsTax value.
    /// </returns>
    public static OperationsTax literalOperationsTax(CurrentOperationsTax _currentOperationsTax)
    {
        OperationsTax postingLayer;

        switch (_currentOperationsTax)
        {
            case CurrentOperationsTax::Current:
                postingLayer = OperationsTax::Current;
                break;
            case CurrentOperationsTax::Operations:
                postingLayer = OperationsTax::OnlyOperations;
                break;
            case CurrentOperationsTax::Tax:
                postingLayer = OperationsTax::OnlyTax;
                break;
        }
        return postingLayer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newLedgerCheck</Name>
				<Source><![CDATA[
    static LedgerVoucher newLedgerCheck(DetailSummary      _detailSummary,
                                        SysModule          _sysModule,
                                        NumberSequenceCode _voucherSeriesCode,
                                        boolean            _approveJournal  = false,
                                        boolean            _posting         = true)
    {
        LedgerVoucher   ledgerVoucher;

        if (_approveJournal)
        {
            ledgerVoucher = LedgerVoucherCheckApprove::construct();
        }
        else
        {
            if (_posting)
            {
                ledgerVoucher = new LedgerVoucherCheck();
            }
            else
            {
                ledgerVoucher = new LedgerVoucherCheckExPosting();
            }
        }
        ledgerVoucher.parmDetailSummary(_detailSummary);
        ledgerVoucher.parmSysModuleDefault(_sysModule);
        ledgerVoucher.parmVoucherSeriesCode(_voucherSeriesCode);

        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newLedgerPost</Name>
				<Source><![CDATA[
    static LedgerVoucher newLedgerPost(DetailSummary        _detailSummary,
                                       SysModule            _sysModule,
                                       NumberSequenceCode   _voucherSeriesCode,
                                       TransactionLogType   _transactionLogType = TransactionLogType::Unspecified,
                                       TransTxt             _transactionLogTxt  = '',
                                       boolean              _approveJournal     = false,
                                       boolean              _posting            = true)
    {
        LedgerVoucher ledgerVoucher;

        if (_approveJournal)
        {
            ledgerVoucher = LedgerVoucherPostApprove::construct();
        }
        else
        {
            if (_posting)
            {
                ledgerVoucher = new LedgerVoucherPost();
            }
            else
            {
                ledgerVoucher = new LedgerVoucherPostExPosting();
            }
        }
        ledgerVoucher.parmDetailSummary(_detailSummary);
        ledgerVoucher.parmSysModuleDefault(_sysModule);
        ledgerVoucher.parmTransactionLog(_transactionLogType, _transactionLogTxt);
        ledgerVoucher.parmVoucherSeriesCode(_voucherSeriesCode);

        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newLedgerPostPersistable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>LedgerVoucherPostPersistable</c> class.
    /// </summary>
    /// <param name="_detailSummary">The detail summary.</param>
    /// <param name="_sysModule">The sys module.</param>
    /// <param name="_voucherSeriesCode">The voucher series code.</param>
    /// <param name="_transactionLogType">The transaction log type.</param>
    /// <param name="_transactionLogTxt">The transaction log txt.</param>
    /// <returns>An instance of the <c>LedgerVoucherPostPersistable</c> class.</returns>
    public static LedgerVoucher newLedgerPostPersistable(Common               _common,
                                                         DetailSummary        _detailSummary,
                                                         SysModule            _sysModule,
                                                         NumberSequenceCode   _voucherSeriesCode,
                                                         TransactionLogType   _transactionLogType = TransactionLogType::Unspecified,
                                                         TransTxt             _transactionLogTxt  = '')
    {
         return LedgerVoucherPostPersistable::newLedgerPostPersistable(_common,
                                                                       _detailSummary,
                                                                       _sysModule,
                                                                       _voucherSeriesCode,
                                                                       _transactionLogType,
                                                                       _transactionLogTxt);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromPersistedLedgerPostPersistable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a new instance of the <c>LedgerVoucherPostPersistable</c> class from a persisted instance.
    /// </summary>
    /// <param name = "_common">The reference to the table buffer that is the master of the posting.</param>
    /// <returns>A new instance of the <c>LedgerVoucherPostPersistable</c> class.</returns>
    public static LedgerVoucher newFromPersistedLedgerPostPersistable(Common _common)
    {
        return LedgerVoucherPostPersistable::newFromPersistedLedgerPostPersistable(_common);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newLedgerPostDiff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a ledger posting object configured for one-sided postings.
    /// </summary>
    /// <param name="_sysModule">
    /// The system module that initiates ledger posting.
    /// </param>
    /// <returns>
    /// A ledger posting object configured for one-sided postings.
    /// </returns>
    static LedgerVoucher newLedgerPostDiff(SysModule _sysModule = SysModule::Ledger)
    {
        LedgerVoucher journal = LedgerVoucher::newLedgerPost(DetailSummary::Detail, _sysModule, '');

        return journal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newLedgerPostProforma_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new ledger post proforma.
    /// </summary>
    /// <param name="_detailSummary">
    /// The detail summary.
    /// </param>
    /// <param name="_sysModule">
    /// The sys module.
    /// </param>
    /// <param name="_voucherSeriesCode">
    /// The voucher series code.
    /// </param>
    /// <param name="_transactionLogType">
    /// The transaction log type.
    /// </param>
    /// <param name="_transactionLogTxt">
    /// The transaction log txt.
    /// </param>
    /// <returns>
    /// The instance of the <c>LedgerVoucher</c> class.
    /// </returns>
    public static LedgerVoucher newLedgerPostProforma_CN(
        DetailSummary         _detailSummary,
        SysModule             _sysModule,
        NumberSequenceCode    _voucherSeriesCode,
        TransactionLogType    _transactionLogType = TransactionLogType::Unspecified,
        TransTxt              _transactionLogTxt = '')
    {
        LedgerVoucher   ledgerVoucher;

        ledgerVoucher = new LedgerVoucherPostProforma_CN();

        ledgerVoucher.parmDetailSummary(_detailSummary);
        ledgerVoucher.parmSysModuleDefault(_sysModule);
        ledgerVoucher.parmTransactionLog(_transactionLogType, _transactionLogTxt);
        ledgerVoucher.parmVoucherSeriesCode(_voucherSeriesCode);

        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>operationsTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts a <c>CurrentOperationsTax</c> enumeration value to an <c>OperationsTax</c> enumeration value.
    /// </summary>
    /// <param name="_currentOperationsTax">
    ///    The <c>CurrentOperationsTax</c> enumeration value to convert.
    /// </param>
    /// <returns>
    ///    A corresponding <c>OperationsTax</c> enumeration value.
    /// </returns>
    /// <remarks>
    ///    This is a lossless operation.
    /// </remarks>
    static OperationsTax operationsTax(CurrentOperationsTax _currentOperationsTax)
    {
        OperationsTax operationsTax;

        switch (_currentOperationsTax)
        {
            case CurrentOperationsTax::Current :
                operationsTax = OperationsTax::Current;
                break;

            case CurrentOperationsTax::Operations :
                operationsTax = OperationsTax::Operations;
                break;

            case CurrentOperationsTax::Tax :
                operationsTax = OperationsTax::Tax;
                break;
        }

        return operationsTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsAdvanceDeducted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>isAdvanceDeducted</c> variable which indicates whether advance amount deducted or not.
    /// </summary>
    /// <param name="_isAdvanceDeducted">
    /// The <c>isAdvanceDeducted</c> variable; optional.
    /// </param>
    /// <returns>
    /// true if the advance amount is deducted; otherwise, false.
    /// </returns>
    public boolean parmIsAdvanceDeducted(boolean _isAdvanceDeducted = isAdvanceDeducted)
    {
        isAdvanceDeducted = _isAdvanceDeducted;
        return isAdvanceDeducted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExcludeExchAdj_PL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value of the <c>excludeExchAdj</c> parameter.
    /// </summary>
    /// <param name="_excludeExchAdj_PL">
    /// The new value of the <c>excludeExchAdj_PL</c> parameter; optional.
    /// </param>
    /// <returns>
    /// The current value of <c>excludeExchAdj_PL</c> parameter.
    /// </returns>
    public PlExcludeExchAdj parmExcludeExchAdj_PL(PlExcludeExchAdj _excludeExchAdj_PL = excludeExchAdj_PL)
    {
        excludeExchAdj_PL = _excludeExchAdj_PL;
        return excludeExchAdj_PL;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>