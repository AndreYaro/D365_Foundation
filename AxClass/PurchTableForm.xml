<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PurchTableForm</Name>
	<SourceCode>
		<Declaration><![CDATA[
class PurchTableForm implements SysSaveable
{
    PurchTable                      purchTable;
    PurchaseType                    purchaseType;
    PurchaseType                    defaultPurchaseType;
    PurchId                         purchId;
    PurchId                         newPurchId;
    ProjId                          projId;
    VendAccount                     vendAccount;
    VendInvoiceAccount              invoiceAccount;
    boolean                         advancedStartup;
    PurchLine                       newlyCreatedPurchLine;
    boolean                         calcTaxStartup;
    // <GIN>
    FormFunctionButtonControl   buttonUpdateInvoiceRegistration;
    FormFunctionButtonControl   buttonUpdateBillOfEntry;
    FormFunctionButtonControl   buttonJournalBillOfEntry;
    FormDataSource              importOrderData;
    // </GIN>
    TradeLineNumberManager          lineNumberManager;
    boolean                         isHeaderVersioned;
    boolean                         isOrderInvoiceMatched;
    boolean                         isOrderInvoiceMatchedCalculated;
    AccountingDistributionView      distributionView;
    Object                          purchTableFormRun;
    DimensionEntryControl           dimensionEntryControlHeader;
    RecVersion                      purchTableRecVersion;
    NumberSeqFormHandler            numberSeqFormHandlerPurchId;
    boolean                         inPurchlineDeleteMarked;
    boolean                         changeManagementEnabled;

    #define.CurrentVersion(2)
    #localmacro.CurrentList
        advancedStartup,
        calcTaxStartup
    #endmacro

    #AssetRules
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>activate_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called by purchTable_ds.active method
    /// </summary>
    public void activate_BR()
    {
        purchTable.enableDataSourceFields_BR();
    }

]]></Source>
			</Method>
			<Method>
				<Name>can1099G1FieldsBeEdited</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the <c>1099G1</c> fields can be edited.
    /// </summary>
    /// <param name="_purchLine">
    /// A <c>PurchLine</c> table buffer.
    /// </param>
    /// <returns>
    /// true if the <c>1099G1</c> fields can be edited; otherwise, false.
    /// </returns>
    public boolean can1099G1FieldsBeEdited(PurchLine _purchLine)
    {
        return _purchLine.Tax1099Fields == Tax1099Base::findTax1099FieldsRecId(Tax1099G::unemploymentCompensation());
    }

]]></Source>
			</Method>
			<Method>
				<Name>can1099GFieldsBeEdited</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the <c>1099G</c> fields can be edited.
    /// </summary>
    /// <param name="_purchLine">
    /// A <c>PurchLine</c> table buffer.
    /// </param>
    /// <returns>
    /// true if the <c>1099G</c> fields can be edited; otherwise, false.
    /// </returns>
    public boolean can1099GFieldsBeEdited(PurchLine _purchLine)
    {
        boolean validTax1099Box;

        validTax1099Box = (_purchLine.Tax1099Fields == Tax1099Base::findTax1099FieldsRecId(Tax1099G::incomeTaxRefundsCreditsOffsets()));

        return validTax1099Box;
    }

]]></Source>
			</Method>
			<Method>
				<Name>can1099SFieldsBeEdited</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the <c>1099S</c> fields can be edited.
    /// </summary>
    /// <param name="_purchLine">
    /// A <c>PurchLine</c> table buffer.
    /// </param>
    /// <returns>
    /// true if the <c>1099S</c> fields can be edited; otherwise, false.
    /// </returns>
    public boolean can1099SFieldsBeEdited(PurchLine _purchLine)
    {
        boolean validTax1099Box;

        validTax1099Box = (_purchLine.Tax1099Fields == Tax1099Base::findTax1099FieldsRecId(Tax1099S::grossProceeds()));

        return validTax1099Box;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canNewLineBeAppended</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a new order line can be inserted after the currently selected one.
    /// </summary>
    /// <param name="_purchLine">
    ///     The currently selected purchase order line.
    /// </param>
    /// <returns>
    ///     false for order lines with multiple deliveries; otherwise, true.
    /// </returns>
    /// <remarks>
    ///     When working on order form and an order line with multiple deliveries is selected a new line should always be inserted before it.
    /// </remarks>
    public boolean canNewLineBeAppended(PurchLine _purchLine)
    {
        return _purchLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRenumberLineNumbers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the line number field can be edited.
    /// </summary>
    /// <returns>
    /// true if the line number field can be edited; otherwise, false.
    /// </returns>
    public boolean canRenumberLineNumbers()
    {
        return purchTable.canRenumberLineNumbers();
    }

]]></Source>
			</Method>
			<Method>
				<Name>create</Name>
				<Source><![CDATA[
    boolean  create()
    {
        Args            args = new Args();
        FormRun         purchCreateOrder;
        PurchTable      currentRecord = purchTable;

        args.name(this.createForm());
        args.caller(this);
        purchCreateOrder = classfactory.formRunClass(args);
        purchCreateOrder.init();
        purchCreateOrder.run();
        purchCreateOrder.wait();

        if (purchCreateOrder.closedOk())
        {
            return true;
        }
        else
        {
            purchTable = currentRecord;
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBudgetReservationLineBeEdited_PSN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether or not the budget reservation line field for a purchase order line can be edited.
    /// </summary>
    /// <param name="_dataSource">
    /// The data source representing the purchase order line.
    /// </param>
    /// <returns>
    /// true if the field can be edited; otherwise, false.
    /// </returns>
    public boolean canBudgetReservationLineBeEdited_PSN(FormDataSource _dataSource)
    {
        return _dataSource.numberOfRowsLoaded() > 0
                && _dataSource.object(fieldNum(PurchLine, BudgetReservationLine_PSN)).allowEdit();

    }

]]></Source>
			</Method>
			<Method>
				<Name>createForm</Name>
				<Source><![CDATA[
    str createForm()
    {
        return formStr(PurchCreateOrder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromVendorSearch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Launches the <c>PurchCreateOrder</c> form in order to create a new purchase order.
    /// </summary>
    /// <param name="_accountNumber">
    /// The vendor account number that is selected in the <c>VendSearchResults</c> form.
    /// </param>
    /// <returns>
    /// true when OK button in the <c>PurchCreateOrder</c> form is clicked.
    /// </returns>
    public boolean  createFromVendorSearch(VendAccount  _accountNumber)
    {
        Args            args = new Args();
        FormRun         purchCreateOrder;

        args.name(this.createForm());
        args.parm(_accountNumber);
        args.caller(this);
        purchCreateOrder = classfactory.formRunClass(args);
        purchCreateOrder.init();
        purchCreateOrder.run();
        purchCreateOrder.wait();

        return purchCreateOrder.closedOk();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLineAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a new order line can be created.
    /// </summary>
    /// <param name="_purchLine">
    /// The currently selected purchase order line.
    /// </param>
    /// <returns>
    /// true when order lines can be edited, the intercompany settings allow line creation and the current
    /// line is not a delivery line; otherwise, false.
    /// </returns>
    /// <remarks>
    /// If order lines can be edited, the intercompany settings enable for line creation and the current
    /// line is not a delivery schedule line.
    /// </remarks>
    boolean createLineAllowed(PurchLine _purchLine)
    {
        boolean  createLine = this.editHeaderAllowed();

        if (createLine
            && (purchTable.interCompanyAllowIndirectCreationOrig()
                || (_purchLine.LineDeliveryType == LineDeliveryType::DeliveryLine
                    && _purchLine.LineNumber != PurchDeliverySchedule::lastDeliveryLineNumber(_purchLine.InventTransId)
                   )
                )
            )
        {
            createLine = false;
        }

        return createLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultPurchaseType</Name>
				<Source><![CDATA[
    PurchaseType  defaultPurchaseType()
    {
        return PurchParameters::find().PurchaseType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteHeaderAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the specified purchase order can be deleted.
    /// </summary>
    /// <returns>
    ///    true if the purchase order can be edited, the intercompany settings can be deleted, and the
    ///    <c>checkDelete</c> method returns true; otherwise, false.
    /// </returns>
    boolean deleteHeaderAllowed()
    {
        PurchTableType localPurchTableType = purchTable.type();

        return (!localPurchTableType.interCompanyIsDerivedOrder() && localPurchTableType.checkDelete());
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteLineAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified order line can be deleted.
    /// </summary>
    /// <param name="_purchLine">
    /// The order line to be checked for deletion.
    /// </param>
    /// <returns>
    /// true when order lines can be edited, the intercompany settings allow line deletion, the current
    /// line is not a delivery line and the <c>checkDelete</c> method returns true; otherwise, false.
    /// </returns>
    /// <remarks>
    /// If order lines can be edited, the intercompany settings enable for line deletion, the current line
    /// is not a delivery schedule line, and the <c>checkDelete</c> method returns true.
    /// </remarks>
    boolean deleteLineAllowed(PurchLine _purchLine)
    {
        boolean deleteLine;

        if (_purchLine.isBudgetReservationLineReferenced()
            && (purchTable.isDocumentConfirmed()
            || _purchLine.isSourceDocumentLineCompletedOrFinalized()))
        {
            deleteLine = false;
        }
        else if (_purchLine.InterCompanyOrigin == InterCompanyOrigin::Derived
            && purchTable.isInterCompanyOrder()
            )
        {
            deleteLine = false;
        }
        else
        {
            deleteLine = _purchLine.LineDeliveryType != LineDeliveryType::DeliveryLine
                && this.editLineAllowed(_purchLine)
                && _purchLine.checkDelete(false, purchTable);
        }

        return deleteLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deliveryScheduleConversionAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether an order line can be converted to a delivery schedule.
    /// </summary>
    /// <param name="_purchLine">
    /// The purchase order line to be checked.
    /// </param>
    /// <returns>
    /// true when the specified line can be converted; otherwise, false.
    /// </returns>
    public boolean deliveryScheduleConversionAllowed(PurchLine _purchLine)
    {
        return _purchLine.RecId                                                                     //check on RecId before invoking server methods and other checks
            && (purchTable.PurchaseType == PurchaseType::Purch || purchTable.PurchaseType == PurchaseType::Journal)
            && _purchLine.PurchStatus == PurchStatus::Backorder                                     // Open order status
            && _purchLine.PurchQty >= 0                                                             // No negative qty
            && !_purchLine.AssetId                                                                  // not a Fixed Asset
            && _purchLine.ItemRefType == InventRefType::None                                        // no reference to other modules (eg production)
            && (!_purchLine.InterCompanyInventTransId                                               // no intercompany derived order
                || (!PurchTableFormDisableDeliveryScheduleForSourceIntercompanyOriginFlight::instance().isEnabled()
                    && _purchLine.InterCompanyOrigin == InterCompanyOrigin::Source))                
            && (!purchTable.ProjId || purchTable.isProjectSalesItemReqPO() || _purchLine.getProjCreditNoteSource().purchTable().isProjectSalesItemReqPO()) // not part of a project
            && PurchTableForm::deliveryScheduleConversionAllowedServer(_purchLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>design</Name>
				<Source><![CDATA[
    void  design()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>directDeliverySetLineAccess</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets line access on the <c>PurchLine</c> form data source that is related to direct deliveries.
    /// </summary>
    /// <param name="_purchLine">
    ///    The pointer of the form data source on which to set access.
    /// </param>
    void directDeliverySetLineAccess(PurchLine _purchLine)
    {
        FormDataSource  purchLine_ds = FormDataUtil::getFormDataSource(_purchLine);

        if (purchLine_ds
            && !purchTable.isInterCompanyOrder()
            && _purchLine.isDropShipment())
        {
            this.enableLinePurchQtyFields(_purchLine, false, false);
            purchLine_ds.object(fieldNum(PurchLine, PurchUnit)).allowEdit(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>distributionFormViewClosed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method called upon closing of the <c>AccountingDistribution</c> form.
    /// </summary>
    public void distributionFormViewClosed()
    {
        purchTableFormRun.distributionFormClosed();
    }

]]></Source>
			</Method>
			<Method>
				<Name>editHeaderAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the purchase order can be edited.
    /// </summary>
    /// <returns>
    ///     true when the purchase order can be edited; otherwise, false.
    /// </returns>
    boolean  editHeaderAllowed()
    {
        return purchTable.editAllowed();
    }

]]></Source>
			</Method>
			<Method>
				<Name>editLineAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the order line can be edited.
    /// </summary>
    /// <param name="_purchLine">
    /// The order line to be checked for edition.
    /// </param>
    /// <returns>
    /// true when the order line can be edited; otherwise, false.
    /// </returns>
    boolean  editLineAllowed(PurchLine _purchLine)
    {
        // <GBR>
        #ISOCountryRegionCodes
        // </GBR>

        return
            (!_purchLine.isInvoiced())
            // <GBR>
            && (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBR])
                    || purchTable.purchTable_BR().InvoiceRefRecId_BR == 0)
            // </GBR>
            && _purchLine.IsFinalized == NoYes::No
            && this.editHeaderAllowed();
    }

]]></Source>
			</Method>
			<Method>
				<Name>editLineAllowedIfBudgetResReferenced</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the purchase order line can be edited if budget reservation line is referenced.
    /// </summary>
    /// <param name="_purchLine">
    /// The order line to be checked for edition.
    /// </param>
    /// <returns>
    /// true when the order line can be edited; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The user is not able to edit or delete a purchase order line when the purchase order is at status confirmed and the order line
    /// references a budget reservation.
    /// </remarks>
    public boolean editLineAllowedIfBudgetResReferenced(PurchLine _purchLine)
    {
        boolean  editLine = true;

        if ((_purchLine.isBudgetReservationLineReferenced()
            && (purchTable.isDocumentConfirmed()
                || _purchLine.isSourceDocumentLineCompletedOrFinalized())))
        {
            editLine = false;
        }

        return editLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableBudgetReservationFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables or disables the budget reservation fields on the purchase order form.
    /// </summary>
    /// <param name="_purchLine">
    /// The current purchase order line.
    /// </param>
    public void enableBudgetReservationFields(PurchLine _purchLine)
    {
        boolean enableBudgetReservationLine;

        enableBudgetReservationLine = _purchLine.PurchReqId == ''
            && _purchLine.LineAmount >= 0
            && _purchLine.PurchQty >= 0
            && _purchLine.PurchStatus == PurchStatus::Backorder
            && _purchLine.BudgetReservationLine_PSN == 0
            && PurchTable.PurchaseType == PurchaseType::Purch
            && (purchTable.DocumentState == VersioningDocumentState::Approved
                || purchTable.DocumentState == VersioningDocumentState::Draft
                || ((purchTable.DocumentState == VersioningDocumentState::Confirmed) && (_purchLine.RecId == 0)));

        if (enableBudgetReservationLine)
        {
            SourceDocumentLineAccountingStatus  purchLineSourceDocumentLineAccountingStatus;

            purchLineSourceDocumentLineAccountingStatus = SourceDocumentLine::find(_purchLine.SourceDocumentLine).AccountingStatus;

            enableBudgetReservationLine = enableBudgetReservationLine
                && purchLineSourceDocumentLineAccountingStatus != SourceDocumentLineAccountingStatus::Completed
                && purchLineSourceDocumentLineAccountingStatus != SourceDocumentLineAccountingStatus::Canceled
                && purchLineSourceDocumentLineAccountingStatus != SourceDocumentLineAccountingStatus::Finalized;
        }

        enableDSField(_purchLine.dataSource(), fieldNum(PurchLine, BudgetReservationLine_PSN), enableBudgetReservationLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>editLineNumberAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the line number field should be editable.
    /// </summary>
    /// <param name="_purchLine">
    /// A buffer of the <c>PurchLine</c> table.
    /// </param>
    /// <returns>
    /// true if editing the line number field is allowed; otherwise, false.
    /// </returns>
    public boolean editLineNumberAllowed(PurchLine _purchLine)
    {
        boolean editLineNumberAllowed;

        // If the header is not versioned then the line cannot be.
        if (isHeaderVersioned)
        {
            editLineNumberAllowed = !_purchLine.isVersioned();
        }
        else
        {
            editLineNumberAllowed = true;
        }

        return editLineNumberAllowed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editPurchaseType</Name>
				<Source><![CDATA[
    boolean  editPurchaseType()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableEximInquiry_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the enabled property on buttons used for Exim Inquiry for selected purchase order.
    /// </summary>
    /// <param name="_purchQty">
    /// PurchQty of the selected purch line.
    /// </param>
    /// <param name="_isCustomsImportOrder">
    /// Boolean value for the selected purchase order is Import order or not.
    /// </param>
    /// <param name="_buttonEximAA">
    /// The form button control for Exim AA Inquiry.
    /// </param>
    /// <param name="_buttonEximDFIA">
    /// The form button control for Exim DFIA Inquiry.
    /// </param>
    /// <param name="_buttonEximDEPB">
    /// The form button control for Exim DEPB Inquiry.
    /// </param>
    /// <param name="_buttonEximEPCG">
    /// The form button control for Exim EPCG Inquiry.
    /// </param>
    public void enableEximInquiry_IN(
        PurchQty                    _purchQty,
        NoYesId                     _isCustomsImportOrder,
        FormFunctionButtonControl   _buttonEximAA,
        FormFunctionButtonControl   _buttonEximDFIA,
        FormFunctionButtonControl   _buttonEximDEPB,
        FormFunctionButtonControl   _buttonEximEPCG)
    {
        boolean           isButtonVisible;
        boolean           isInvoice;

        EximParameters_IN eximParameters = EximParameters_IN::find();

        isButtonVisible = TaxParameters::find().EximIncentiveSchemes_IN;
        isInvoice       = _isCustomsImportOrder && _purchQty > 0;

        _buttonEximAA.visible(isButtonVisible   && eximParameters.ActivateAA);
        _buttonEximDFIA.visible(isButtonVisible && eximParameters.ActivateDFIA);
        _buttonEximDEPB.visible(isButtonVisible && eximParameters.ActivateDEPB);
        _buttonEximEPCG.visible(isButtonVisible && eximParameters.ActivateEPCG);

        _buttonEximAA.enabled(isInvoice);
        _buttonEximDFIA.enabled(isInvoice);
        _buttonEximDEPB.enabled(isInvoice);
        _buttonEximEPCG.enabled(isInvoice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableInvoice4PaymButton_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Enables or disables the confirm button.
    /// </summary>
    /// <param name="_buttonInvoice4Paym">
    ///     The Invoice4Payment button.
    /// </param>
    public void enableInvoice4PaymButton_RU(FormFunctionButtonControl _buttonInvoice4Paym)
    {
        PurchTableCheckIfUpdateContract checkIfUpdateContract = PurchTableCheckIfUpdateContract::construct();
        PurchTableCanBeUpdatedContract  canBeUpdatedContract;
        container                       canBeUpdated;

        checkIfUpdateContract.parmCheckInvoice4Paym_RU(true);
        canBeUpdated = purchTable.checkIfUpdate(checkIfUpdateContract.pack());
        canBeUpdatedContract = PurchTableCanBeUpdatedContract::create(canBeUpdated);
        _buttonInvoice4Paym.enabled(canBeUpdatedContract.parmCanInvoice4PaymBeUpdated_RU());
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableLineCreditInvoiceButton</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Enables or disables the Credit Invoice menu item in the Lines action panel.
    /// </summary>
    /// <param name="_purchLine">
    ///    A table buffer that contains the current <c>PurchLine</c> record.
    /// </param>
    /// <param name="_buttonCustVendCreditInvoicingLines">
    ///    The Credit Invoice button in the Lines action panel.
    /// </param>
    public void enableLineCreditInvoiceButton(
        PurchLine                   _purchLine,
        FormFunctionButtonControl   _buttonCustVendCreditInvoicingLines)
    {
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES, #isoSE, #isoPL]))
        {
            _buttonCustVendCreditInvoicingLines.enabled(_purchLine.LineAmount < 0);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableLinePurchQtyFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Enables or disables the Qty or catch weight quantity field.
    /// </summary>
    /// <param name="_purchLine">
    ///    A table buffer that contains the current <c>PurchLine</c> record.
    /// </param>
    /// <param name="_enableUnit">
    ///    A Boolean value indicating whether to enable the appropriate purchase qty field.
    /// </param>
    /// <param name="_enableInventory">
    ///    A Boolean value indicating whether to enable the ordered qty field.
    /// </param>
    protected void enableLinePurchQtyFields(PurchLine _purchLine, boolean _enableUnit, boolean _enableInventory)
    {
        boolean isCWItem = PdsGlobal::pdsIsCWItem(_purchLine.ItemId);

        enableDSField(FormDataUtil::getFormDataSource(_purchLine), fieldNum(PurchLine, QtyOrdered), _enableInventory && !isCWItem);
        enableDSField(FormDataUtil::getFormDataSource(_purchLine), fieldNum(PurchLine, PurchQty), _enableUnit && !isCWItem);
        enableDSField(FormDataUtil::getFormDataSource(_purchLine), fieldNum(PurchLine, PdsCWQty), _enableUnit && isCWItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableLineReceivedNowFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Enables or disables the Qty or catch weight quantity receive now field.
    /// </summary>
    /// <param name="_purchLine">
    ///    A table buffer that contains the current <c>PurchLine</c> record.
    /// </param>
    /// <param name="_enable">
    ///    A Boolean value indicating whether to enable the appropriate qty field.
    /// </param>
    protected void enableLineReceivedNowFields(PurchLine _purchLine, boolean _enable)
    {
        boolean isCWItem = PdsGlobal::pdsIsCWItem(_purchLine.ItemId);

        //
        // the inventory received now field is enabled even for catch weight items
        //
        enableDSField(FormDataUtil::getFormDataSource(_purchLine), fieldNum(PurchLine, InventReceivedNow), _enable);
        enableDSField(FormDataUtil::getFormDataSource(_purchLine), fieldNum(PurchLine, PdsCWInventReceivedNow), _enable && isCWItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableLineRemainFinancialFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Enables or disables the Qty or catch weight remaining physical quantity field.
    /// </summary>
    /// <param name="_purchLine">
    ///    A table buffer that contains the current <c>PurchLine</c> record.
    /// </param>
    /// <param name="_enable">
    ///    A Boolean value indicating whether to enable the appropriate qty field.
    /// </param>
    protected void enableLineRemainFinancialFields(PurchLine _purchLine, boolean _enable)
    {
        boolean isCWItem = PdsGlobal::pdsIsCWItem(_purchLine.ItemId);

        enableDSField(FormDataUtil::getFormDataSource(_purchLine), fieldNum(PurchLine, RemainInventFinancial), _enable && !isCWItem);
        enableDSField(FormDataUtil::getFormDataSource(_purchLine), fieldNum(PurchLine, PdsCWRemainInventFinancial), _enable && isCWItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableLineRemainPhysicalFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Enables or disables the Qty or catch weight remaining physical quantity field.
    /// </summary>
    /// <param name="_purchLine">
    ///    A table buffer that contains the current <c>PurchLine</c> record.
    /// </param>
    /// <param name="_enable">
    ///    A Boolean value indicating whether to enable the appropriate qty field.
    /// </param>
    protected void enableLineRemainPhysicalFields(PurchLine _purchLine, boolean _enable)
    {
        boolean isCWItem = PdsGlobal::pdsIsCWItem(_purchLine.ItemId);

        enableDSField(FormDataUtil::getFormDataSource(_purchLine), fieldNum(PurchLine, RemainInventPhysical), _enable && !isCWItem);
        enableDSField(FormDataUtil::getFormDataSource(_purchLine), fieldNum(PurchLine, PdsCWRemainInventPhysical), _enable && isCWItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableUpdateJournalButtons</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the enabled property on buttons used for posting purchase orders when multiple orders are selected.
    /// </summary>
    /// <param name="_purchTable">
    ///    The <c>PurchTable</c> record that is used to determine whether the buttons must be enabled or
    ///    disabled.
    /// </param>
    /// <param name="_buttonUpdatePurchaseOrder">
    ///    The form button control for purchase order posting.
    /// </param>
    /// <param name="_buttonUpdateReceiptsList">
    ///    The form button control for receipt list updating.
    /// </param>
    /// <param name="_buttonUpdatePackingSlip">
    ///    The form button control for packing slip updating.
    /// </param>
    /// <param name="_buttonUpdateInvoice">
    ///    The form button control for invoice updating.
    /// </param>
    /// <param name="_buttonProformaPurchaseOrder">
    ///    The form button control for pro forma purchase order posting.
    /// </param>
    /// <param name="_buttonProformaReceiptsList">
    ///    The form button control for pro forma receipt list updating.
    /// </param>
    /// <param name="_buttonProformaPackingSlip">
    ///    The form button control for pro forma packing slip updating.
    /// </param>
    /// <param name="_buttonProformaInvoice">
    ///    The form button control for pro forma invoice updating.
    /// </param>
    /// <param name="_buttonUpdateInvoice4Paym">
    ///    The form button control for invoice 4 payment updating.
    /// </param>
    /// <param name="_buttonUpdateFacture">
    ///    The form button control for facture updating.
    /// </param>
    /// <param name="_buttonUpdateFactureEditLines">
    ///    The form button control for facture edit lines updating.
    /// </param>
    /// <param name="_buttonUpdateInvoice4PaymProforma">
    ///    The form button control for pro forma invoice 4 payment updating.
    /// </param>
    /// <param name="_buttonUpdateFactureProforma">
    ///    The form button control for pro forma facture updating.
    /// </param>
    /// <param name="_buttonUpdateFactureEditLinesProforma">
    ///    The form button control for pro forma facture edit lines updating.
    /// </param>
    /// <param name="_buttonConfirmationRequest">
    ///    The form button control for purchase order confirmation request.
    /// </param>
    /// <param name="_buttonBindingConfirmationRequest">
    ///    The form button control for purchase order binding confirmation request.
    /// </param>
    void enableUpdateJournalButtons(PurchTable                  _purchTable,
                                    FormFunctionButtonControl   _buttonUpdatePurchaseOrder,
                                    FormFunctionButtonControl   _buttonUpdateReceiptsList,
                                    FormFunctionButtonControl   _buttonUpdatePackingSlip,
                                    FormFunctionButtonControl   _buttonUpdateInvoice,
                                    FormFunctionButtonControl   _buttonProformaPurchaseOrder,
                                    FormFunctionButtonControl   _buttonProformaReceiptsList,
                                    FormFunctionButtonControl   _buttonProformaPackingSlip,
                                    FormFunctionButtonControl   _buttonProformaInvoice,
                                    FormFunctionButtonControl   _buttonUpdateInvoice4Paym = null,
                                    FormFunctionButtonControl   _buttonUpdateFacture = null,
                                    FormFunctionButtonControl   _buttonUpdateFactureEditLines = null,
                                    FormFunctionButtonControl   _buttonUpdateInvoice4PaymProforma = null,
                                    FormFunctionButtonControl   _buttonUpdateFactureProforma = null,
                                    FormFunctionButtonControl   _buttonUpdateFactureEditLinesProforma = null,
                                    FormFunctionButtonControl   _buttonConfirmationRequest = null,
                                    FormFunctionButtonControl   _buttonBindingConfirmationRequest = null)
    {
        FormDataSource      purchTable_ds;
        PurchTable          localPurchTable;
        container           canBeUpdated;
        boolean             enableConfirmationRequestButton;
        boolean             enableBindingConfirmationRequestButton;
        boolean             enablePurchaseOrderButton;
        boolean             enableReceiptsListButton;
        boolean             enablePackingSlipButton;
        boolean             enableInvoiceButton;
        // <GEERU>
        boolean             enableInvoice4PaymButton;
        boolean             enableFactureButton;
        boolean             enableCommFactureButton;
        // </GEERU>
        PurchTableCheckIfUpdateContract checkIfUpdateContract;
        PurchTableCanBeUpdatedContract  canBeUpdatedContract;
        // <GEERU><GIN>
        #ISOCountryRegionCodes
        // </GIN></GEERU>
        // <GEERU>
        boolean             countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        // <GIN>
        PurchTable_W        purchTable_W;
        FormDataSource      purchTable_W_ds;
        PurchTable_W        localPurchTable_W;
        container           checkUpdate;
        boolean             enableInvoiceRegistrationButton = buttonUpdateInvoiceRegistration   ? false : true;
        boolean             enableBillOfEntryButton         = buttonUpdateBillOfEntry           ? false : true;
        NoYes               isCustomsEnabled                = TaxParameters::isCustomsEnable_IN();
        CustomsVendBOETrans_IN customsVendBOETrans;
        boolean                enableButtonJournalBillOfEntry;

        PurchTableType      purchTableType;

        if (isCustomsEnabled)
        {
            select sum(BillOfEntryQty) from customsVendBOETrans
                group by PurchId
                    where customsVendBOETrans.PurchId == _purchTable.PurchId;
            enableButtonJournalBillOfEntry = (customsVendBOETrans.BillOfEntryQty != 0);
        }
        // </GIN>

        purchTable_ds   = FormDataUtil::getFormDataSource(_purchTable);
        localPurchTable = purchTable_ds.getFirst(true);

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            purchTable_W        = _purchTable.purchTable_W();

            purchTable_W_ds = FormDataUtil::getFormDataSource(purchTable_W);
            if (purchTable_W_ds)
            {
                localPurchTable_W = purchTable_W_ds.getFirst(true);
            }
        }
        // </GIN>

        if (localPurchTable)
        {
            while (localPurchTable)
            {
                // <GEERU>
                if (countryRegion_RU)
                {
                    if ((enablePurchaseOrderButton  == true)   && (enableReceiptsListButton == true) &&
                        (enablePackingSlipButton    == true)   && (enableInvoiceButton      == true) &&
                        (enableInvoice4PaymButton   == true)   && (enableFactureButton      == true) &&
                        (enableCommFactureButton    == true))
                    {
                        break;
                    }
                }
                else
                {
                    // </GEERU>
                    if ((enableConfirmationRequestButton == true)   && (enableBindingConfirmationRequestButton  == true) &&
                        (enablePurchaseOrderButton  == true)        && (enableReceiptsListButton                == true) &&
                        (enablePackingSlipButton    == true)        && (enableInvoiceButton                     == true))
                    {
                        break;
                    }
                    // <GEERU>
                }
                // </GEERU>

                checkIfUpdateContract = PurchTableCheckIfUpdateContract::construct();
                checkIfUpdateContract.parmCheckConfirmationRequest(!enableConfirmationRequestButton);
                checkIfUpdateContract.parmCheckBindingConfirmationRequest(!enableBindingConfirmationRequestButton);
                checkIfUpdateContract.parmCheckPurchaseOrder(!enablePurchaseOrderButton);
                checkIfUpdateContract.parmCheckReceiptsList(!enableReceiptsListButton);
                checkIfUpdateContract.parmCheckPackingSlip(!enablePackingSlipButton);
                checkIfUpdateContract.parmCheckInvoice(!enableInvoiceButton);
                checkIfUpdateContract.parmExcludePendingInvoice(false);
                // <GEERU>
                checkIfUpdateContract.parmCheckCommFacture_RU(!enableCommFactureButton);
                // </GEERU>

                canBeUpdated = localPurchTable.checkIfUpdate(checkIfUpdateContract.pack());
                canBeUpdatedContract = PurchTableCanBeUpdatedContract::create(canBeUpdated);

                purchTableType = localPurchTable.type();
                if (!enableConfirmationRequestButton)
                {
                    enableConfirmationRequestButton = canBeUpdatedContract.parmCanConfirmationRequestBeUpdated();
                }
                if (!enableBindingConfirmationRequestButton)
                {
                    enableBindingConfirmationRequestButton = canBeUpdatedContract.parmCanBindingConfirmationRequestBeUpdated();
                }
                if (!enablePurchaseOrderButton)
                {
                    enablePurchaseOrderButton = canBeUpdatedContract.parmCanPurchaseOrderBeUpdated();
                }
                if (!enableReceiptsListButton)
                {
                    enableReceiptsListButton = canBeUpdatedContract.parmCanReceiptsListBeUpdated();
                }
                if (!enablePackingSlipButton)
                {
                    enablePackingSlipButton = canBeUpdatedContract.parmCanPackingSlipBeUpdated();
                }
                if (!enableInvoiceButton)
                {
                    enableInvoiceButton = canBeUpdatedContract.parmCanInvoiceBeUpdated();
                }
                // <GIN>
                if (isCustomsEnabled
                    && localPurchTable_W.CustomsImportOrder_IN)
                {
                    enableInvoiceRegistrationButton = true;
                    enableBillOfEntryButton         = true;
                    buttonJournalBillOfEntry.enabled(enableButtonJournalBillOfEntry);
                }
                // </GIN>
                // <GEERU>
                if (countryRegion_RU)
                {
                    if (! enableInvoice4PaymButton)
                    {
                        enableInvoice4PaymButton = canBeUpdatedContract.parmCanInvoice4PaymBeUpdated_RU();
                    }
                    if (! enableFactureButton)
                    {
                        enableFactureButton = canBeUpdatedContract.parmCanFactureBeUpdated_RU();
                    }
                    if (! enableCommFactureButton)
                    {
                        enableCommFactureButton = canBeUpdatedContract.parmCanCommFactureBeUpdated_RU();
                    }
                }
                // </GEERU>

                localPurchTable = purchTable_ds.getNext();
                // <GIN>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
                {
                    if (purchTable_W_ds)
                    {
                        localPurchTable_W = purchTable_W_ds.getNext();
                    }
                }
                // </GIN>
            }

            this.setConfirmationButtonsState(_buttonConfirmationRequest,
                                             _buttonBindingConfirmationRequest,
                                              enableConfirmationRequestButton,
                                              enableBindingConfirmationRequestButton);

            if (_buttonUpdatePurchaseOrder)
            {
                _buttonUpdatePurchaseOrder.enabled(enablePurchaseOrderButton);
            }

            if (_buttonProformaPurchaseOrder)
            {
                _buttonProformaPurchaseOrder.enabled(enablePurchaseOrderButton);
            }

            if (_buttonUpdateReceiptsList)
            {
                _buttonUpdateReceiptsList.enabled(enableReceiptsListButton);
            }

            if (_buttonProformaReceiptsList)
            {
                _buttonProformaReceiptsList.enabled(enableReceiptsListButton);
            }

            if (_buttonUpdatePackingSlip)
            {
                _buttonUpdatePackingSlip.enabled(enablePackingSlipButton);
            }

            if (_buttonProformaPackingSlip)
            {
                _buttonProformaPackingSlip.enabled(enablePackingSlipButton);
            }

            if (_buttonUpdateInvoice)
            {
                _buttonUpdateInvoice.enabled(enableInvoiceButton);
            }

            if (_buttonProformaInvoice)
            {
                _buttonProformaInvoice.enabled(enableInvoiceButton);
            }

            // <GEERU>
            if (countryRegion_RU)
            {
                if (_buttonUpdateInvoice4Paym)
                {
                    _buttonUpdateInvoice4Paym.enabled(enableInvoice4PaymButton);
                    _buttonUpdateInvoice4PaymProforma.enabled(enableInvoice4PaymButton);
                }

                if (_buttonUpdateFactureEditLines)
                {
                    _buttonUpdateFactureEditLines.enabled(enableFactureButton && enableCommFactureButton);
                    _buttonUpdateFactureEditLinesProforma.enabled(enableFactureButton && enableCommFactureButton);
                }

                _buttonUpdateFacture.visible(enableInvoiceButton);
                _buttonUpdateFacture.enabled(enableCommFactureButton);
                
                _buttonUpdateFactureProforma.visible(enableInvoiceButton);
                _buttonUpdateFactureProforma.enabled(enableCommFactureButton);
                _buttonUpdateFactureEditLines.visible(! _buttonUpdateFacture.visible());
                _buttonUpdateFactureEditLinesProforma.visible(! _buttonUpdateFacture.visible());
            }
            // </GEERU>
        }
        // <GIN>
        else if (isCustomsEnabled
                && purchTable_W.CustomsImportOrder_IN)
        {
            checkUpdate = _purchTable.checkIfUpdate_IN();
            enablePurchaseOrderButton       = conPeek(checkUpdate, PurchTableType::posPurchaseOrder());
            enableInvoiceRegistrationButton = conPeek(checkUpdate, PurchTableType::posInvoiceRegistration_IN());
            enableBillOfEntryButton         = conPeek(checkUpdate, PurchTableType::posBillOfEntry_IN());
            enableReceiptsListButton        = conPeek(checkUpdate, PurchTableType::posReceiptsList_IN());
            enablePackingSlipButton         = conPeek(checkUpdate, PurchTableType::posPackingSlip_IN());
            enableInvoiceButton             = conPeek(checkUpdate, PurchTableType::posInvoice_IN());
        }
        if (isCustomsEnabled)
        {
            if (buttonUpdateInvoiceRegistration)
            {
                buttonUpdateInvoiceRegistration.enabled(enableInvoiceRegistrationButton && !enablePurchaseOrderButton);
            }
            if (buttonUpdateBillOfEntry)
            {
                buttonUpdateBillOfEntry.enabled(enableBillOfEntryButton);
            }
            buttonJournalBillOfEntry.enabled(enableButtonJournalBillOfEntry);
            if (purchTable_W.CustomsImportOrder_IN
                && _buttonUpdateReceiptsList
                && _buttonUpdatePackingSlip
                && _buttonUpdateInvoice)
            {
                _buttonUpdateReceiptsList.enabled(enableReceiptsListButton
                                                    && CustomsVendBOETrans_IN::findOrderId(_purchTable.PurchId)
                                                    && enableInvoiceButton);
                _buttonUpdatePackingSlip.enabled(enablePackingSlipButton
                                                    && CustomsVendBOETrans_IN::findOrderId(_purchTable.PurchId)
                                                    && enableInvoiceButton);
                _buttonUpdateInvoice.enabled(enableInvoiceButton
                                                && CustomsVendBOETrans_IN::findOrderId(_purchTable.PurchId));
            }
        }
        else if (!isCustomsEnabled
            && purchTable_W.CustomsImportOrder_IN
            && _buttonUpdatePurchaseOrder
            && buttonUpdateInvoiceRegistration
            && buttonUpdateBillOfEntry
            && _buttonUpdateReceiptsList
            && _buttonUpdatePackingSlip
            && _buttonUpdateInvoice)
        {
            _buttonUpdatePurchaseOrder.enabled(false);
            buttonUpdateInvoiceRegistration.enabled(false);
            buttonUpdateBillOfEntry.enabled(false);
            _buttonUpdateReceiptsList.enabled(false);
            _buttonUpdatePackingSlip.enabled(false);
            _buttonUpdateInvoice.enabled(false);
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>setConfirmationButtonsState</Name>
				<Source><![CDATA[
    private void setConfirmationButtonsState(FormFunctionButtonControl _buttonConfirmationRequest,
                                             FormFunctionButtonControl _buttonBindingConfirmationRequest,
                                             boolean                   _enableConfirmationRequestButton,
                                             boolean                   _enableBindingConfirmationRequestButton)
    {
        // If on the purchase table form user selects two POs, one for a vendor with enabled
        // vendor portal functionality and another one for a vendor with no vendor portal enabled,
        // both buttons should be disabled for processing, because they are mutually exclusive
        if (_enableConfirmationRequestButton && _enableBindingConfirmationRequestButton)
        {
            _enableConfirmationRequestButton = false;
            _enableBindingConfirmationRequestButton = false;
        }

        if (_buttonConfirmationRequest)
        {
            _buttonConfirmationRequest.enabled(_enableConfirmationRequestButton);
        }

        if (_buttonBindingConfirmationRequest)
        {
            _buttonBindingConfirmationRequest.enabled(_enableBindingConfirmationRequestButton);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEnabledAgreementButtons</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the buttons that are used for linking with purchase agreement lines are enabled.
    /// </summary>
    /// <param name="_purchTable">
    ///    The <c>PurchTable</c> record that is used to determine whether the buttons will be enabled or
    ///    disabled.
    /// </param>
    /// <param name="_purchLine">
    ///    The <c>PurchLine</c> record that is used to determine whether the buttons must be enabled or
    ///    disabled.
    /// </param>
    /// <returns>
    ///    A container with values for enabling the agreement buttons.
    /// </returns>
    public container getEnabledAgreementButtons(PurchTable _purchTable, PurchLine _purchLine)
    {
        boolean agreementLineEnabled, removeLinkEnabled, createLinkEnabled;
        boolean isLineUpdateAllowed = this.editLineAllowed(_purchLine);

        agreementLineEnabled = _purchLine.MatchingAgreementLine && _purchLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries;

        removeLinkEnabled = _purchLine.MatchingAgreementLine
            && _purchLine.LineDeliveryType != LineDeliveryType::DeliveryLine
            &&  isLineUpdateAllowed
            && _purchLine.IsFinalized == NoYes::No
            && _purchLine.isInvoiceMatched() == false;

        createLinkEnabled = _purchTable.MatchingAgreement
            &&  isLineUpdateAllowed
            && _purchLine.canAgreementBeLinked()
            && _purchLine.IsFinalized == NoYes::No
            && _purchLine.isInvoiceMatched() == false;

        return [agreementLineEnabled, createLinkEnabled, removeLinkEnabled];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeVendorQuery</Name>
				<Source><![CDATA[
    public void initializeVendorQuery(Query _query)
    {
        if (VendTable::isVendor())
        {
            VendAccountManager::makeMyVendorSelfServiceQuery(_query, tableNum(PurchTable));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    void initParmDefault()
    {
        advancedStartup = false;
        calcTaxStartup = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValues</Name>
				<Source><![CDATA[
    void  initValues()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanySetLineAccess</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the line access on the <c>PurchLine</c> form data source.
    /// </summary>
    /// <param name="_purchLine">
    ///    The cursor of the form data source to set access on.
    /// </param>
    void interCompanySetLineAccess(PurchLine _purchLine)
    {
        InterCompanyEndpointActionPolicy    interCompanyEndpointActionPolicy;
        FormDataSource                      purchLine_ds        = FormDataUtil::getFormDataSource(_purchLine);
        boolean                             isInterCompanyOrder = purchTable? purchTable.isInterCompanyOrder() : false;
        boolean                             itemBased           = _purchLine.ItemId != '';
        boolean                             stockedProduct     = _purchLine.isStocked();
        boolean                             isInvoiceMatched    = _purchLine.isInvoiceMatched();
        boolean                             isPackingSlipOrInvoiceUpdated = _purchLine.isPackingSlipOrInvoiceUpdated();
        boolean                             allowEditProject;
        boolean                             mustDefaultCostPriceAsSalesPrice;

        if (!purchLine_ds)
        {
            return;
        }

        if (isInterCompanyOrder
            && _purchLine.RecId)
        {
            purchLine_ds.object(fieldNum(PurchLine, ConfirmedDlv)).allowEdit(false);
            if (PurchParameters::find().IsSupplierShipmentDatesEnabled)
            {
                purchLine_ds.object(fieldNum(PurchLine, ConfirmedShipDate)).allowEdit(false);
            }
        }
        else
        {
            purchLine_ds.object(fieldNum(PurchLine, ConfirmedDlv)).allowEdit(_purchLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries);
            if (PurchParameters::find().IsSupplierShipmentDatesEnabled)
            {
                purchLine_ds.object(fieldNum(PurchLine, ConfirmedShipDate)).allowEdit(_purchLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries);
            }
        }
        if (isInterCompanyOrder
            &&  _purchLine.InterCompanyOrigin == InterCompanyOrigin::Derived)
        {
            purchLine_ds.object(fieldNum(PurchLine, ItemId)).allowEdit(false);
            this.enableLinePurchQtyFields(_purchLine, false, false);
            purchLine_ds.object(fieldNum(PurchLine, PurchUnit)).allowEdit(false);
        }
        else
        {
            this.enableLinePurchQtyFields(
                _purchLine,
                !isInvoiceMatched && _purchLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries,
                stockedProduct);
            purchLine_ds.object(fieldNum(PurchLine, PurchUnit)).allowEdit(!isInvoiceMatched && _purchLine.LineDeliveryType == LineDeliveryType::OrderLine);
        }
        if (isInterCompanyOrder
        &&  purchTable.InterCompanyDirectDelivery
        &&  _purchLine.InterCompanyOrigin == InterCompanyOrigin::Derived)
        {
            purchLine_ds.object(fieldNum(PurchLine, OverDeliveryPct)).allowEdit(false);
            purchLine_ds.object(fieldNum(PurchLine, UnderDeliveryPct)).allowEdit(false);
        }
        else
        {
            purchLine_ds.object(fieldNum(PurchLine, OverDeliveryPct)).allowEdit(true);
            purchLine_ds.object(fieldNum(PurchLine, UnderDeliveryPct)).allowEdit(true);
        }

        if ((!isInterCompanyOrder && _purchLine.isDropShipment())
            || (isInterCompanyOrder
                &&  purchTable.InterCompanyDirectDelivery
                &&  _purchLine.InterCompanyOrigin == InterCompanyOrigin::Derived)
                )
        {
            purchLine_ds.object(fieldNum(PurchLine, DeliveryDate)).allowEdit(false);
            purchLine_ds.object(fieldNum(PurchLine, DeliveryPostalAddress)).allowEdit(false);
            purchLine_ds.object(fieldNum(PurchLine, DeliveryName)).allowEdit(false);
            if (PurchParameters::find().IsSupplierShipmentDatesEnabled)
            {
                purchLine_ds.object(fieldNum(PurchLine, RequestedShipDate)).allowEdit(false);
            }
        }
        else
        {
            purchLine_ds.object(fieldNum(PurchLine, DeliveryDate)).allowEdit(_purchLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries);
            purchLine_ds.object(fieldNum(PurchLine, DeliveryName)).allowEdit(true);
            purchLine_ds.object(fieldNum(PurchLine, DeliveryPostalAddress)).allowEdit(!isInvoiceMatched);
            if (PurchParameters::find().IsSupplierShipmentDatesEnabled)
            {
                purchLine_ds.object(fieldNum(PurchLine, RequestedShipDate)).allowEdit(_purchLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries);
            }
        }

        if (isInterCompanyOrder)
        {
            interCompanyEndpointActionPolicy  = purchTable.interCompanyEndpointActionPolicy();
            purchLine_ds.object (fieldNum(PurchLine, PurchPrice)).allowEdit(!isInvoiceMatched && interCompanyEndpointActionPolicy.EditPrice);
            purchLine_ds.object (fieldNum(PurchLine, PriceUnit)).allowEdit(!isInvoiceMatched && interCompanyEndpointActionPolicy.EditPrice);
            purchLine_ds.object (fieldNum(PurchLine, LineAmount)).allowEdit(!isInvoiceMatched && interCompanyEndpointActionPolicy.EditPrice && _purchLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries);
            purchLine_ds.object (fieldNum(PurchLine, PurchMarkup)).allowEdit(!isInvoiceMatched && interCompanyEndpointActionPolicy.EditPrice);
            purchLine_ds.object (fieldNum(PurchLine, LineDisc)).allowEdit(!isInvoiceMatched && interCompanyEndpointActionPolicy.EditDiscount);
            purchLine_ds.object (fieldNum(PurchLine, LinePercent)).allowEdit(!isInvoiceMatched && interCompanyEndpointActionPolicy.EditDiscount);
            purchLine_ds.object (fieldNum(PurchLine, MultiLnDisc)).allowEdit(!isInvoiceMatched && interCompanyEndpointActionPolicy.EditDiscount);
            purchLine_ds.object (fieldNum(PurchLine, MultiLnPercent)).allowEdit(!isInvoiceMatched && interCompanyEndpointActionPolicy.EditDiscount);
        }
        else
        {
            purchLine_ds.object (fieldNum(PurchLine, PurchPrice)).allowEdit(!isInvoiceMatched);
            purchLine_ds.object (fieldNum(PurchLine, PriceUnit)).allowEdit(!isInvoiceMatched);
            purchLine_ds.object (fieldNum(PurchLine, LineAmount)).allowEdit(!isInvoiceMatched && _purchLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries);
            purchLine_ds.object (fieldNum(PurchLine, PurchMarkup)).allowEdit(!isInvoiceMatched);
            purchLine_ds.object (fieldNum(PurchLine, LineDisc)).allowEdit(!isInvoiceMatched);
            purchLine_ds.object (fieldNum(PurchLine, LinePercent)).allowEdit(!isInvoiceMatched);
            purchLine_ds.object (fieldNum(PurchLine, MultiLnDisc)).allowEdit(!isInvoiceMatched);
            purchLine_ds.object (fieldNum(PurchLine, MultiLnPercent)).allowEdit(!isInvoiceMatched);
        }

        // Disable inventory fields if not inventoried
        this.enableLineReceivedNowFields(_purchLine, stockedProduct);
        this.enableLineRemainPhysicalFields(_purchLine, stockedProduct);
        this.enableLineRemainFinancialFields(_purchLine, stockedProduct);

        // Disable delivery fields if not item based
        purchLine_ds.object(fieldNum(PurchLine, BarCode)).allowEdit(itemBased);
        purchLine_ds.object(fieldNum(PurchLine, BarCodeType)).allowEdit(itemBased);
        purchLine_ds.object(fieldNum(PurchLine, ReqPlanIdSched)).allowEdit(itemBased);
        purchLine_ds.object(fieldNum(PurchLine, ReqPOId)).allowEdit(itemBased);
        purchLine_ds.object(fieldNum(PurchLine, ItemRouteId)).allowEdit(itemBased);
        purchLine_ds.object(fieldNum(PurchLine, ItemBOMId)).allowEdit(itemBased);
        purchLine_ds.object(fieldNum(PurchLine, LineHeader)).allowEdit(itemBased);
        purchLine_ds.object(fieldNum(PurchLine, CovRef)).allowEdit(itemBased);
        purchLine_ds.object(fieldNum(PurchLine, LineNumber)).allowEdit(this.editLineNumberAllowed(_purchLine) && !isInvoiceMatched);

        boolean isTaxGroupEditable = !isInvoiceMatched
            && (!Tax::isTaxIntegrationEnabledForBusinessProcess(TaxIntegrationBusinessProcess::Purchase)
                || _purchLine.OverrideSalesTax == NoYes::yes);
        purchLine_ds.object(fieldNum(PurchLine, TaxGroup)).allowEdit(isTaxGroupEditable);
        purchLine_ds.object(fieldNum(PurchLine, TaxItemGroup)).allowEdit(isTaxGroupEditable);

        purchLine_ds.object(fieldNum(PurchLine, LedgerDimension)).allowEdit(!isInvoiceMatched && _purchLine.canEditLedgerDimensionDefaultAccount());
        purchLine_ds.object(fieldNum(PurchLine, DefaultDimension)).allowEdit(!isInvoiceMatched);

        if (_purchLine.ProjId)
        {
            allowEditProject = !isPackingSlipOrInvoiceUpdated && !isInvoiceMatched;
            purchLine_ds.object(fieldNum(PurchLine, ProjId)).allowEdit(allowEditProject);
            purchLine_ds.object(fieldNum(PurchLine, ProjCategoryId)).allowEdit(allowEditProject);
            purchLine_ds.object(fieldNum(PurchLine, ActivityNumber)).allowEdit(allowEditProject);
            purchLine_ds.object(fieldNum(PurchLine, ProjLinePropertyId)).allowEdit(allowEditProject);

            if (!_purchLine.ItemId && ProjParameters::find().DefaultCostPriceAsSalesPrice)
            {
                mustDefaultCostPriceAsSalesPrice = true;
            }

            if (ProjInvoiceTable::isSalesCurrencyLocked(ProjTable::find(_purchLine.ProjId).ProjInvoiceProjId))
            {
                purchLine_ds.object(fieldNum(PurchLine, ProjSalesCurrencyId)).allowEdit(false);
                purchLine_ds.object(fieldNum(PurchLine, ProjSalesCurrencyId)).skip(true);
            }
            else
            {
                purchLine_ds.object(fieldNum(PurchLine, ProjSalesCurrencyId)).allowEdit(allowEditProject && !mustDefaultCostPriceAsSalesPrice);
                purchLine_ds.object(fieldNum(PurchLine, ProjSalesCurrencyId)).skip(!(allowEditProject && !mustDefaultCostPriceAsSalesPrice));
            }

            purchLine_ds.object(fieldNum(PurchLine, ProjSalesUnitId)).allowEdit(allowEditProject);
            purchLine_ds.object(fieldNum(PurchLine, ProjSalesPrice)).allowEdit(allowEditProject && !mustDefaultCostPriceAsSalesPrice);
            purchLine_ds.object(fieldNum(PurchLine, ProjTaxGroupId)).allowEdit(allowEditProject);
            purchLine_ds.object(fieldNum(PurchLine, ProjTaxItemGroupId)).allowEdit(allowEditProject);
        }
        else
        {
            purchLine_ds.object(fieldNum(PurchLine, ProjId)).allowEdit(false);
            purchLine_ds.object(fieldNum(PurchLine, ProjCategoryId)).allowEdit(false);
            purchLine_ds.object(fieldNum(PurchLine, ActivityNumber)).allowEdit(false);
            purchLine_ds.object(fieldNum(PurchLine, ProjLinePropertyId)).allowEdit(false);
            purchLine_ds.object(fieldNum(PurchLine, ProjSalesCurrencyId)).allowEdit(false);
            purchLine_ds.object(fieldNum(PurchLine, ProjSalesUnitId)).allowEdit(false);
            purchLine_ds.object(fieldNum(PurchLine, ProjSalesPrice)).allowEdit(false);
            purchLine_ds.object(fieldNum(PurchLine, ProjTaxGroupId)).allowEdit(false);
            purchLine_ds.object(fieldNum(PurchLine, ProjTaxItemGroupId)).allowEdit(false);
        }

        this.setAllowEditProjectFields(_purchLine, purchLine_ds);
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceAccount</Name>
				<Source><![CDATA[
    CustInvoiceAccount  invoiceAccount(CustInvoiceAccount  _invoiceAccount = invoiceAccount)
    {
        invoiceAccount = _invoiceAccount;
        return invoiceAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAdvanced</Name>
				<Source><![CDATA[
    boolean isAdvanced(boolean _advancedStartup = advancedStartup)
    {
        advancedStartup = _advancedStartup;

        return advancedStartup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isButtonPrepayInvoiceEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables prepayment invoice action button on header.
    /// </summary>
    /// <returns>
    /// true when prepayment invoice button should be enabled; otherwise, false.
    /// </returns>
    public boolean isButtonPrepayInvoiceEnabled()
    {
        PurchPrepayTable    purchPrepayTable;
        boolean             isButtonPrepayInvoiceEnabled;

        if (!LedgerParameters::find().JournalizingDefinitionEnableValue && this.isPrepayPurchTableEnabled() && VendTable::canVendorBeUpdated(purchTable.OrderAccount, purchTable.InvoiceAccount, DocumentStatus::Invoice))
        {
            purchPrepayTable = PurchPrepayTable::findPurchId(purchTable.PurchId);

            if (purchPrepayTable.RecId && purchPrepayTable.PrepayAvailable >= 0.01 && !VendInvoiceTrans::existForPurchId(purchTable.PurchId) && !purchTable.isInterCompanyOrder())
            {
                isButtonPrepayInvoiceEnabled = true;
            }
        }

        return isButtonPrepayInvoiceEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isHeaderCreditInvoiceButtonEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Enables or disables the Credit Invoice menu item in the Header action panel.
    /// </summary>
    /// <returns>
    ///    true if the Credit Invoice menu item is enabled; otherwise, false.
    /// </returns>
    public boolean isHeaderCreditInvoiceButtonEnabled()
    {
        #ISOCountryRegionCodes

        PurchLine   negativePurchLine;
        boolean     isHeaderCreditInvoiceButtonEnabled;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES, #isoSE, #isoPL]))
        {
            select firstonly RecId from negativePurchLine
                where  negativePurchLine.PurchId == purchTable.PurchId
                    && negativePurchLine.LineAmount < 0;

            isHeaderCreditInvoiceButtonEnabled = negativePurchLine.RecId? true: false;
        }

        return isHeaderCreditInvoiceButtonEnabled || SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT])
            || FeatureStateProvider::isFeatureEnabled(CreditInvoicingForVendorInvoicesFeature::instance());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLineCalculationButtonEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the line level calculations menu items are enabled.
    /// </summary>
    /// <param name="_purchLine">
    ///    A table buffer that contains the current values from the <c>PurchLine</c> table.
    /// </param>
    /// <returns>
    ///    true if line calculation buttons should be enabled; otherwise, false.
    /// </returns>
    public boolean isLineCalculationButtonEnabled (PurchLine _purchLine)
    {
        return !_purchLine.isCategoryBased()
            && !_purchLine.isInvoiceMatched()
            && _purchLine.IsFinalized == NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPCExecuteButtonEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables or disables the applicable main line menu buttons
    /// </summary>
    /// <param name="_purchLine">
    ///    A table buffer containing the current <c>PurchLine Table</c> values.
    /// </param>
    /// <returns>
    ///     true if
    /// </returns>
    public boolean isPCExecuteButtonEnabled(PurchLine _purchLine)
    {
        boolean lineCanBeConfigured;
        boolean itemConfigurable = PCRuntimeLibrary::isConstraintBasedConfigurable(_purchLine.ItemId);

        if (_purchLine.LineDeliveryType == LineDeliveryType::OrderLine
            && !_purchLine.isCategoryBased()
            && itemConfigurable)
        {
            if ( !_purchLine.isInterCompanyOrder() )
            {
                lineCanBeConfigured = true;
            }
            else
            {
                // In the Intercompany case where the line is not created from another order and it is not configured yet
                // do allow configuring the line despite there is an intercompany sales order already created at the vendor
                if (! _purchLine.ItemRefType
                    && InventDim::find(_purchLine.InventDimId).configId == EcoResProductParameters::getConfigurationName())
                {
                    lineCanBeConfigured = true;
                }
            }
        }

        return lineCanBeConfigured;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPrepayPurchTableEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables advance action button on header when <c>PurchaseType</c> field of <c>PurchTable</c> table has <c>PurchaseType::Purch</c> enum value .
    /// When VendPurchTableIncludePrepaymentButtonInApprovalProcessFlight is enabled, 
    /// advance action button will be disabled when the PO workflow is in review or finalized
    /// </summary>
    /// <returns>
    ///    true if prepayment button should be enabled; otherwise, false.
    /// </returns>
    public boolean isPrepayPurchTableEnabled()
    {
        boolean canEnable = true;

        if (VendPurchTableIncludePrepaymentButtonInApprovalProcessFlight::instance().isEnabled())
        {
            canEnable = !(purchTable.DocumentState == VersioningDocumentState::InReview || purchTable.DocumentState == VersioningDocumentState::Finalized);
        }

        return canEnable && purchTable.PurchaseType == PurchaseType::Purch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRemovePrepayEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables advance action button on header when <c>PurchaseType</c> field of <c>PurchTable</c> table has <c>PurchaseType::Purch</c> enum value .
    /// </summary>
    /// <returns>
    ///    true if remove prepayment button should be enabled; otherwise, false.
    /// </returns>
    public boolean isRemovePrepayEnabled()
    {
        PurchPrepayTable purchPrepayTable;
        boolean canReverseUnsettledPrepayInvoices;

        if (!LedgerParameters::find().JournalizingDefinitionEnableValue && this.isPrepayPurchTableEnabled())
        {
            purchPrepayTable = PurchPrepayTable::findPurchId(purchTable.PurchId);

            if (purchPrepayTable.RecId)
            {
                if (purchPrepayTable.PrepayLimit == purchPrepayTable.PrepayAvailable)
                {
                    return true;
                }

                canReverseUnsettledPrepayInvoices = purchTable.checkCancel();

                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    canReverseUnsettledPrepayInvoices = canReverseUnsettledPrepayInvoices && purchTable.canModifyPurchaseOrder();
                }

                if (canReverseUnsettledPrepayInvoices && purchPrepayTable::existUnsettledPrepayInvoice(purchTable.PurchId))
                {
                    return true;
                }
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueDataAreaId</Name>
				<Source><![CDATA[
    DataAreaId lastValueDataAreaId()
    {
        return curext();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueDesignName</Name>
				<Source><![CDATA[
    IdentifierName lastValueDesignName()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueElementName</Name>
				<Source><![CDATA[
    // Template method, mustn't be named lastValueElementName
    public IdentifierName lastValueElementName()
    {
        return formStr(PurchTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueType</Name>
				<Source><![CDATA[
    // Template method, mustn't be named lastValueType
    public UtilElementType lastValueType()
    {
        return UtilElementType::Form;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueUserId</Name>
				<Source><![CDATA[
    // Template method, mustn't be named lastValueUserId
    public UserId lastValueUserId()
    {
        return curUserId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>linkActive</Name>
				<Source><![CDATA[
    boolean linkActive()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustFormResearchAfterDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the form must be researched after deleting the currently selected order line.
    /// </summary>
    /// <param name="_purchLine">
    /// The currently selected purchase order line.
    /// </param>
    /// <returns>
    /// true for order lines with multiple deliveries or direct delivery purchase order; otherwise, false.
    /// </returns>
    public boolean mustFormResearchAfterDelete(PurchLine _purchLine)
    {
        return (purchTable.MCRDropShipment || _purchLine.LineDeliveryType == LineDeliveryType::OrderLineWithMultipleDeliveries);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new(Common _source)
    {
        if (_source.TableId == tableNum(PurchTable))
        {
            this.purchTable(_source);
        }

        xSysLastValue::getLast(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonJournalBillOfEntry_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The button journal bill of entry parameter.
    /// </summary>
    /// <param name="_buttonJournalBillOfEntry">
    /// The button journal bill of entry.
    /// </param>
    public void parmButtonJournalBillOfEntry_IN(FormFunctionButtonControl _buttonJournalBillOfEntry)
    {
        buttonJournalBillOfEntry = _buttonJournalBillOfEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonUpdateBillOfEntry_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The parameter of button update bill of entry.
    /// </summary>
    /// <param name="_buttonUpdateBillOfEntry">
    /// The button update bill of entry.
    /// </param>
    public void parmButtonUpdateBillOfEntry_IN(FormFunctionButtonControl _buttonUpdateBillOfEntry)
    {
        buttonUpdateBillOfEntry = _buttonUpdateBillOfEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmButtonUpdateInvoiceRegistration_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The parameter of button update invoice registration.
    /// </summary>
    /// <param name="_buttonUpdateInvoiceRegistration">
    /// The button update invoice registration information.
    /// </param>
    public void parmButtonUpdateInvoiceRegistration_IN(FormFunctionButtonControl _buttonUpdateInvoiceRegistration)
    {
        buttonUpdateInvoiceRegistration = _buttonUpdateInvoiceRegistration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCalcTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>CalcTax</c> field.
    /// </summary>
    /// <param name="_calcTaxStartup">
    ///    The value of the <c>CalcTax</c> field when the form opens.
    /// </param>
    /// <returns>
    ///    true if tax totals are calculated when the purchase line is saved; otherwise, false.
    /// </returns>
    public boolean parmCalcTax(boolean _calcTaxStartup = calcTaxStartup)
    {
        calcTaxStartup = _calcTaxStartup;

        return calcTaxStartup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDimensionEntryControlHeader</Name>
				<Source><![CDATA[
    public DimensionEntryControl parmDimensionEntryControlHeader(DimensionEntryControl _dimensionEntryControlHeader = dimensionEntryControlHeader)
    {
        dimensionEntryControlHeader = _dimensionEntryControlHeader;
        return dimensionEntryControlHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmImpOrderData_IN</Name>
				<Source><![CDATA[
    public FormDataSource parmImpOrderData_IN(FormDataSource _importOrderData = importOrderData)
    {
        importOrderData = _importOrderData;

        return importOrderData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInPurchlineDeleteMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if multiple purchase order line are marked for deletion.
    /// </summary>
    /// <param name="_inPurchlineDeleteMarked">
    /// true if multiple purchase order lines are marked for deletion; otherwise false.
    /// </param>
    /// <returns>
    /// The value of the <c>inPurchlineDeleteMarked</c> parameter.
    /// </returns>
    /// <remarks>
    /// This was introduced for a performance optimization.
    /// It indicates we can skip updating the <c>PurchTable</c> header distribution on the line
    /// in case of multi-select deletion of lines.
    /// </remarks>
    public boolean parmInPurchlineDeleteMarked(boolean _inPurchlineDeleteMarked = inPurchlineDeleteMarked)
    {
        inPurchlineDeleteMarked = _inPurchlineDeleteMarked;

        return inPurchlineDeleteMarked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmChangeManagementEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the change management status.
    /// </summary>
    /// <param name="_changeManagementEnabled">
    /// true if change management is enabled; otherwise false.
    /// </param>
    /// <returns>
    /// The value of the <c>changeManagementEnabled</c> parameter.
    /// </returns>
    public boolean parmChangeManagementEnabled(boolean _changeManagementEnabled = changeManagementEnabled)
    {
        changeManagementEnabled = _changeManagementEnabled;
        return changeManagementEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsHeaderVersioned</Name>
				<Source><![CDATA[
    public boolean parmIsHeaderVersioned(boolean _isHeaderVersioned = isHeaderVersioned)
    {
        isHeaderVersioned = _isHeaderVersioned;
        return isHeaderVersioned;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNumberSeqFormHandlerPurchId</Name>
				<Source><![CDATA[
    public NumberSeqFormHandler parmNumberSeqFormHandlerPurchId(NumberSeqFormHandler _numberSeqFormHandlerPurchId = numberSeqFormHandlerPurchId)
    {
        numberSeqFormHandlerPurchId = _numberSeqFormHandlerPurchId;
        return numberSeqFormHandlerPurchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPurchTableFormRun</Name>
				<Source><![CDATA[
    public Object parmPurchTableFormRun(Object _purchTableFormRun = purchTableFormRun)
    {
        purchTableFormRun = _purchTableFormRun;

        return purchTableFormRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>project</Name>
				<Source><![CDATA[
    boolean project()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projId</Name>
				<Source><![CDATA[
    ProjId  projId(ProjId  _projId = projId)
    {
        projId = _projId;
        return projId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchLine_CreatePostSuper</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes post purchase line creation logic.
    /// </summary>
    /// <param name="_purchLine">
    /// A buffer of the <c>PurchLine</c> table.
    /// </param>
    public void purchLine_CreatePostSuper(PurchLine _purchLine)
    {
        this.setNewlyCreatedPurchLine(_purchLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchLine_CreatePreSuper</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes pre-purchase line creation logic.
    /// </summary>
    /// <param name="_purchLine">
    ///    A buffer of the <c>PurchLine</c> table.
    /// </param>
    public void purchLine_CreatePreSuper(PurchLine _purchLine)
    {
        lineNumberManager.setLine(_purchLine);
        if (_purchLine.LineDeliveryType == LineDeliveryType::OrderLineWithMultipleDeliveries)
        {
            //If the cursor is positioned on an order line with multiple deliveries, the new line should be inserted above instead of below as usual.
            lineNumberManager.setPreviousLineNumber(lineNumberManager.getPreviousLineNumber(_purchLine.LineNumber));
        }
        else
        {
            lineNumberManager.setPreviousLineNumber(_purchLine.LineNumber);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchLine_WritePostSuper</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Executes post-purchase line write logic.
    /// </summary>
    /// <param name="_inputContract">
    ///     An instance of the <c>PurchLineWritePostSuperInputContract</c> class.
    /// </param>
    /// <returns>
    ///     An instance of the <c>PurchLineWritePostSuperOutputContract</c> class.
    /// </returns>
    /// <remarks>
    ///    In previous version <c>purchLine</c> was passed in as parameter, now <c>purchLine</c> must be added to the input contract object passed in.
    /// </remarks>
    public PurchLineWritePostSuperOutputContract purchLine_WritePostSuper(PurchLineWritePostSuperInputContract _inputContract)
    {
        PurchLineWritePostSuperOutputContract   outputContractPost;

        //  For future implementation:
        //  To follow the pattern from the purchase line write method, code execution
        //  depending on the purchTableCheckUpdate method should be added in this if-block.
        /*
        if (_inputContract.parmPurchTableCheckUpdate())
        {
        }
        */

        _inputContract.parmPurchTable(purchTable);
        outputContractPost = PurchLineWritePostSuperOutputContract::create(PurchTableForm::purchLine_WritePostSuperServer(_inputContract.pack()));

        return outputContractPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchLine_WritePreSuper</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes pre-purchase line write logic.
    /// </summary>
    /// <param name="_inputContract">
    ///     An instance of the <c>PurchLineWritePreSuperInputContract</c> class.
    /// </param>
    /// <returns>
    ///     An instance of the <c>PurchLineWritePreSuperOutPutContract</c> class.
    /// </returns>
    /// <remarks>
    ///    In previous version <c>purchLine</c> was passed in as parameter, now <c>purchLine</c> must be added to the input contract object passed in.
    /// </remarks>
    public PurchLineWritePreSuperOutputContract purchLine_WritePreSuper(PurchLineWritePreSuperInputContract _inputContract)
    {
        PurchLineWritePreSuperOutputContract    outputConTract;
        PurchLine                               localPurchLine  = _inputContract.parmPurchLine();

        InventMovement  movement        = InventMovement::construct(localPurchLine);
        InventMovement  movement_Orig   = InventMovement::construct(localPurchLine.orig());

        _inputContract.parmPurchTableCheckUpdate(purchTable.checkUpdate());

        //  To follow the pattern from the purchase line write method, code execution
        //  depending on the purchTableCheckUpdate method should be added in this if-block.
        if (_inputContract.parmPurchTableCheckUpdate())
        {
            if (this.mustUpdateLineNumberManagerPreWrite(_inputContract))
            {
                lineNumberManager.setLine(localPurchLine);
                lineNumberManager.preUpdateLineNumber(false, FormDataUtil::getFormDataSource(localPurchLine));
            }

            if (localPurchLine.LineDeliveryType != LineDeliveryType::OrderLineWithMultipleDeliveries)
            {
                localPurchLine.RemainPurchPhysical  = localPurchLine.orig().RemainPurchPhysical + localPurchLine.PurchQty - localPurchLine.orig().PurchQty;
                localPurchLine.RemainInventPhysical = localPurchLine.orig().RemainInventPhysical + localPurchLine.QtyOrdered - localPurchLine.orig().QtyOrdered;

                if (PdsGlobal::pdsIsCWItem(localPurchLine.ItemId))
                {
                    movement.pdsCWSetRemainPhysical(movement_Orig.pdsCWRemainPhysical());
                    movement.pdsCWAddRemainPhysical(movement.pdsCWTransQty() - movement_Orig.pdsCWTransQty());
                }
            }
        }

        outputConTract = PurchLineWritePreSuperOutputContract::create(PurchTableForm::purchLine_WritePreSuperServer(_inputContract.pack()));
        outputConTract.parmPurchTableCheckUpdate(_inputContract.parmPurchTableCheckUpdate());

        return outputConTract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateLineNumberManagerPreWrite</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to prepare the line number manager to update the line number before calling write.
    /// </summary>
    /// <param name = "_purchLineWritePreSuperInputContract">An instance of the <c>PurchLineWritePreSuperInputContract</c> class.</param>
    /// <returns>true if the line number manager is to be updated; otherwise, false.</returns>
    protected boolean mustUpdateLineNumberManagerPreWrite(PurchLineWritePreSuperInputContract _purchLineWritePreSuperInputContract)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTable</Name>
				<Source><![CDATA[
    public PurchTable  purchTable(
        PurchTable  _purchTable     = purchTable)
    {
        if (purchId !=_purchTable.PurchId || purchTableRecVersion != _purchTable.RecVersion)
        {
            lineNumberManager = TradeLineNumberManager::construct();
            purchId = _purchTable.PurchId;
            purchTableRecVersion = _purchTable.RecVersion;
            isHeaderVersioned = _purchTable.isVersioned();
            isOrderInvoiceMatchedCalculated = false;
        }

        purchTable = _purchTable;

        return purchTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryPurchLine</Name>
				<Source><![CDATA[
    Query queryPurchLine(Query queryPurchLine)
    {
        return queryPurchLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryPurchTable</Name>
				<Source><![CDATA[
    Query queryPurchTable(Query queryPurchTable)
    {
        return queryPurchTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshDeliverySchedule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refreshes the delivery lines when order line or delivery line was modified.
    /// </summary>
    /// <param name="_purchLine">
    /// The changed purchase order line.
    /// </param>
    /// <param name="_resetPriceOnLineWithMultipleDeliveries">
    /// A Boolean value that indicates whether price on line with multiple deliveries should be
    /// recalculated.
    /// </param>
    /// <remarks>
    /// This method is overloaded on the <c>PurchTableForm_DlvScheduleSyncEnabled</c> class. When called on
    /// this base class it does nothing.
    /// </remarks>
    void refreshDeliverySchedule(PurchLine _purchLine, boolean _resetPriceOnLineWithMultipleDeliveries)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetPurchLine</Name>
				<Source><![CDATA[
    public void resetPurchLine(PurchLine _purchLine)
    {
        _purchLine.data(newlyCreatedPurchLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAllowEditAssetFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the <c>allowEdit</c> methods of the fixed asset fields for the active purchase line record.
    /// </summary>
    /// <param name="_purchTable">
    ///    The current active <see cref="T:PurchTable" /> buffer.
    /// </param>
    /// <param name="_purchLine">
    ///    The current active <see cref="T:PurchLine" /> buffer.
    /// </param>
    /// <param name="_purchLine_ds">
    ///    The data source for the current active <see cref="T:PurchLine" /> buffer.
    /// </param>
    public void setAllowEditAssetFields (PurchTable _purchTable, PurchLine _purchLine, FormDataSource _purchLine_ds)
    {
        #ISOCountryRegionCodes

        boolean canEdit;
        boolean assetAllowCreate;
        boolean newAssetGroupChecked;
        boolean doResetValue;
        boolean assetAllowEdit = true;

        [canEdit, assetAllowCreate] = PurchTableForm::setAllowEditAssetFieldsServer(_purchTable, _purchLine);

        // Check if editable state changed.
        if (!(_purchLine_ds.object(fieldNum(PurchLine, CreateFixedAsset)).allowEdit() == assetAllowCreate))
        {
            if (!assetAllowCreate)
            {
                doResetValue = true;
            }
        }

        if (assetAllowCreate)
        {
            if (_purchLine.AssetId
                && _purchLine.RecId
                && _purchLine.isInvoiced()
                && AssetTable::find(_purchLine.AssetId).PurchLineRecId == _purchLine.RecId)
            {
                assetAllowEdit = false;
            }
        }

        _purchLine_ds.object(fieldNum(PurchLine, CreateFixedAsset))
            .allowEdit(assetAllowCreate && assetAllowEdit && !_purchLine.AssetId);

        // Clear value if now not editable.
        if (doResetValue
            && _purchLine.CreateFixedAsset != NoYes::No
            && !_purchLine.isInvoiced())
        {
            _purchLine_ds.object(fieldNum(PurchLine, CreateFixedAsset)).setValue(NoYes::No);
        }

        newAssetGroupChecked = (assetAllowCreate && _purchLine.CreateFixedAsset == NoYes::Yes);

        _purchLine_ds.object(fieldNum(PurchLine, AssetGroup)).allowEdit(assetAllowCreate && newAssetGroupChecked);

        if ((!assetAllowCreate || !newAssetGroupChecked) && !_purchLine.isInvoiceMatched())
        {
            this.PurchaseOrderWithFixedAssetValueDisabled(_purchTable, _purchLine, _purchLine_ds);
            // If the line is not already invoiced, clear value if not editable and not already the default value.
            if (!(_purchLine_ds.object(fieldNum(PurchLine, AssetGroup)).getValue() == ""))
            {
                _purchLine_ds.object(fieldNum(PurchLine, AssetGroup)).setValue("");
                if (_purchLine.CreateFixedAsset == NoYes::Yes)
                {
                    _purchLine_ds.object(fieldNum(PurchLine, CreateFixedAsset)).setValue(NoYes::No);
                }
            }
        }

        doResetValue = false;

        _purchLine_ds.object(fieldNum(PurchLine, AssetId)).allowEdit(canEdit && (!newAssetGroupChecked) && assetAllowEdit);
        _purchLine_ds.object(fieldNum(PurchLine, AssetBookId)).allowEdit(canEdit && (!newAssetGroupChecked) && assetAllowEdit);

        // Check if editable state changed.
        if (!(_purchLine_ds.object(fieldNum(PurchLine, AssetTransTypePurch)).allowEdit()) == (canEdit && (!newAssetGroupChecked)))
        {
            if ((!canEdit) || (newAssetGroupChecked))
            {
                doResetValue = true;
            }
        }

        _purchLine_ds.object(fieldNum(PurchLine, AssetTransTypePurch)).allowEdit(canEdit && (!newAssetGroupChecked) && assetAllowEdit);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]))
        {
            _purchLine_ds.object(fieldNum(PurchLine, AssetTransTypePurch)).allowEdit(canEdit && assetAllowEdit);
        }

        // We will only reset the values of the asset fields in two cases.
        // 1. AllowAssetCreate has changed on the fixed asset
        // 2. The PO is marked AND no packing slip or invoice has been posted.
        if ((doResetValue) && (_purchLine.AssetId) &&
            ((newAssetGroupChecked) ||
            ((!canEdit) && (!_purchLine.isPackingSlipOrInvoiceUpdated()))))
        {
            // Clear value if now not editable.
            if (_purchLine.AssetId)
            {
                _purchLine_ds.object(fieldNum(PurchLine, AssetId)).setValue("");
            }
            if (_purchLine.AssetBookId)
            {
                _purchLine_ds.object(fieldNum(PurchLine, AssetBookId)).setValue("");
            }
            if (_purchLine.AssetTransTypePurch != AssetTransTypePurch::Acquisition)
            {
                _purchLine_ds.object(fieldNum(PurchLine, AssetTransTypePurch)).setValue(AssetTransTypePurch::Acquisition);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>PurchaseOrderWithFixedAssetValueDisabled</Name>
				<Source><![CDATA[
    private void PurchaseOrderWithFixedAssetValueDisabled(PurchTable _purchTable, PurchLine _purchLine, FormDataSource _purchLine_ds)
    {
        MenuFunction    menuFunction;
        Args            args;
        AssetParameters assertParams = AssetParameters::find();
        boolean         isDisabledFixedAssetsFileds = assertParams.AssetAllowAutoCreate == NoYes::No;
        boolean         isWorkFlowEnabled = this.isWorkflowVisibleForHeader(_purchTable);

        if (isDisabledFixedAssetsFileds && !(_purchLine_ds.object(fieldNum(PurchLine, AssetGroup)).getValue() == "") && isWorkFlowEnabled && _purchTable.DocumentState != VersioningDocumentState::Draft)
        {
            AssetId assetIdValueToSave = _purchLine.AssetId;

            args = new Args();
            args.record(_purchTable);
            args.parmEnum(VersioningAction::RequestChange);
            VersioningPurchaseOrder::main(args);

            _purchTable.reread();
            _purchLine.reread();
            _purchLine_ds.reread();
            
            _purchLine.AssetId = assetIdValueToSave;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAllowEditConsignmentFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets line access on the <c>PurchLine</c> form data source that originates from consignment.
    /// </summary>
    /// <param name="_purchLine">
    ///    The pointer of the form data source on which to set access.
    /// </param>
    public void setAllowEditConsignmentFields(PurchLine _purchLine)
    {
        if (_purchLine.isConsignmentOrder())
        {
            FormDataSource purchLine_ds = FormDataUtil::getFormDataSource(_purchLine);

            purchLine_ds.object(fieldNum(PurchLine, PurchQty)).allowEdit(false);
            purchLine_ds.object(fieldNum(PurchLine, PurchUnit)).allowEdit(false);
            purchLine_ds.object(fieldNum(PurchLine, QtyOrdered)).allowEdit(false);

            purchLine_ds.object(fieldNum(PurchLine, OverDeliveryPct)).allowEdit(false);
            purchLine_ds.object(fieldNum(PurchLine, UnderDeliveryPct)).allowEdit(false);

            purchLine_ds.object(fieldNum(PurchLine, RemainPurchPhysical)).allowEdit(false);
            purchLine_ds.object(fieldNum(PurchLine, RemainInventPhysical)).allowEdit(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAllowEditProjectFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets the enabled state of the Project fields.
    /// </summary>
    /// <param name="_purchLine">
    ///     The purchase line for which we are using as source data.
    /// </param>
    /// <param name="_purchLine_ds">
    ///    The data source for the current active <see cref="T:PurchLine" /> buffer.
    /// </param>
    public void setAllowEditProjectFields(PurchLine _purchLine, FormDataSource _purchLine_ds)
    {
        boolean isSubContract = _purchLine.isSubcontracted();

        if (isSubContract || _purchLine.isProjectBudgetReservationLineReferenced())
        {
            // ProjectIdentification group
            _purchLine_ds.object(fieldNum(PurchLine, ProjId)).allowEdit(false);
            _purchLine_ds.object(fieldNum(PurchLine, ProjId)).skip(true);
            _purchLine_ds.object(fieldNum(PurchLine, ActivityNumber)).allowEdit(false);
            _purchLine_ds.object(fieldNum(PurchLine, ActivityNumber)).skip(true);
            _purchLine_ds.object(fieldNum(PurchLine, ProjCategoryId)).allowEdit(false);
            _purchLine_ds.object(fieldNum(PurchLine, ProjCategoryId)).skip(true);
            _purchLine_ds.object(fieldNum(PurchLine, ItemId)).allowEdit(false);
            _purchLine_ds.object(fieldNum(PurchLine, ItemId)).skip(true);
            _purchLine_ds.object(fieldNum(PurchLine, ProjLinePropertyId)).allowEdit(false);
            _purchLine_ds.object(fieldNum(PurchLine, ProjLinePropertyId)).skip(true);

            // ProjSalesPrice group
            _purchLine_ds.object(fieldNum(PurchLine, ProjSalesCurrencyId)).allowEdit(false);
            _purchLine_ds.object(fieldNum(PurchLine, ProjSalesCurrencyId)).skip(true);
            _purchLine_ds.object(fieldNum(PurchLine, ProjSalesUnitId)).allowEdit(!isSubContract);
            _purchLine_ds.object(fieldNum(PurchLine, ProjSalesUnitId)).skip(isSubContract);
            _purchLine_ds.object(fieldNum(PurchLine, ProjSalesPrice)).allowEdit(!isSubContract);
            _purchLine_ds.object(fieldNum(PurchLine, ProjSalesPrice)).skip(isSubContract);

            // ProjSalesTax group
            _purchLine_ds.object(fieldNum(PurchLine, ProjTaxGroupId)).allowEdit(false);
            _purchLine_ds.object(fieldNum(PurchLine, ProjTaxGroupId)).skip(true);
            _purchLine_ds.object(fieldNum(PurchLine, ProjTaxItemGroupId)).allowEdit(false);
            _purchLine_ds.object(fieldNum(PurchLine, ProjTaxItemGroupId)).skip(true);
        }

        // ProjTransaction group
        _purchLine_ds.object(fieldNum(PurchLine, ProjTransId)).allowEdit(false);
        _purchLine_ds.object(fieldNum(PurchLine, ProjTransId)).skip(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAllowVisibleReductionEntryFields_JP</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the <c>isVisible</c> methods of the reduction entry fields group for the active purchase line record.
    /// </summary>
    /// <param name="_purchTable">
    ///    The current active <see cref="T:PurchTable" /> buffer.
    /// </param>
    /// <param name="_purchLine">
    ///    The current active <see cref="T:PurchLine" /> buffer.
    /// </param>
    /// <param name="_grpReductionEntry">
    ///    The reduction entry form group control.
    /// </param>
    public void setAllowVisibleReductionEntryFields_JP(
        PurchTable       _purchTable,
        PurchLine        _purchLine,
        FormGroupControl _grpReductionEntry)
    {
        AssetDocumentReductionEntry_JP     reductionEntryDocumentLoc;
        boolean                            isVisible                 = false;
        if (_purchLine.AssetId && _purchLine.AssetBookId)
        {
            reductionEntryDocumentLoc = AssetReductionEntryManager_JP::getAssetReductionEntryDocByAssetBook(
                _purchLine.AssetId,
                _purchLine.AssetBookId);

            if (reductionEntryDocumentLoc != null)
            {
                isVisible = true;
            }
        }

        _grpReductionEntry.visible(isVisible);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setHeaderAccess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the header access on the <c>PurchTable</c> form data source.
    /// </summary>
    public void setHeaderAccess()
    {
        InterCompanyEndpointActionPolicy interCompanyEndpointActionPolicy;
        PurchTableType editPurchtableType = purchTable.type();
        FormDataSource purchTable_ds = FormDataUtil::getFormDataSource(purchTable);
        boolean editDiscPercent = !PurchParameters::find().AutomaticTotalDiscount;

        if (!purchTable_ds)
        {
            return;
        }

        if (!isOrderInvoiceMatchedCalculated)
        {
            isOrderInvoiceMatchedCalculated = true;
            isOrderInvoiceMatched = purchTable.isInvoiceMatched();
        }

        purchTable_ds.object(fieldNum(PurchTable, OrderAccount)).allowEdit(editPurchtableType.editOrderAccount());
        purchTable_ds.object(fieldNum(PurchTable, InvoiceAccount)).allowEdit(editPurchtableType.editInvoiceAccount());

        purchTable_ds.object(fieldNum(PurchTable, PurchaseType)).allowEdit(!editPurchtableType.interCompanyIsDerivedOrder() && this.editPurchaseType() && editPurchtableType.editPurchType());

        if (purchTable.skipAddressFields())
        {
            purchTable_ds.object(fieldNum(PurchTable, DeliveryDate)).allowEdit(false);
            purchTable_ds.object(fieldNum(PurchTable, DeliveryPostalAddress)).allowEdit(false);
            purchTable_ds.object(fieldNum(PurchTable, DeliveryName)).allowEdit(false);
            if (PurchParameters::find().IsSupplierShipmentDatesEnabled)
            {
                purchTable_ds.object(fieldNum(PurchTable, RequestedShipDate)).allowEdit(false);
            }
        }
        else
        {
            purchTable_ds.object(fieldNum(PurchTable, DeliveryDate)).allowEdit(true);
            purchTable_ds.object(fieldNum(PurchTable, DeliveryName)).allowEdit(true);
            purchTable_ds.object(fieldNum(PurchTable, DeliveryPostalAddress)).allowEdit(true);
            if (PurchParameters::find().IsSupplierShipmentDatesEnabled)
            {
                purchTable_ds.object(fieldNum(PurchTable, RequestedShipDate)).allowEdit(true);
            }
        }

        purchTable_ds.object(fieldNum(PurchTable, InclTax)).allowEdit(!isOrderInvoiceMatched);
        purchTable_ds.object(fieldNum(PurchTable, InclTax)).skip(isOrderInvoiceMatched);
        purchTable_ds.object(fieldNum(PurchTable, CurrencyCode)).allowEdit(!isOrderInvoiceMatched);
        purchTable_ds.object(fieldNum(PurchTable, CurrencyCode)).skip(isOrderInvoiceMatched);
        purchTable_ds.object(fieldNum(PurchTable, MultiLineDisc)).allowEdit(!isOrderInvoiceMatched);
        purchTable_ds.object(fieldNum(PurchTable, MultiLineDisc)).skip(isOrderInvoiceMatched);
        purchTable_ds.object(fieldNum(PurchTable, EndDisc)).allowEdit(!isOrderInvoiceMatched);
        purchTable_ds.object(fieldNum(PurchTable, EndDisc)).skip(isOrderInvoiceMatched);
        purchTable_ds.object(fieldNum(PurchTable, MarkupGroup)).allowEdit(!isOrderInvoiceMatched);
        purchTable_ds.object(fieldNum(PurchTable, MarkupGroup)).skip(isOrderInvoiceMatched);

        if (purchTable.isInterCompanyOrder())
        {
            interCompanyEndpointActionPolicy  = purchTable.interCompanyEndpointActionPolicy();
            purchTable_ds.object(fieldNum(PurchTable, DiscPercent)).allowEdit(editDiscPercent && interCompanyEndpointActionPolicy.EditPrice && !isOrderInvoiceMatched);
            purchTable_ds.object(fieldNum(PurchTable, DiscPercent)).skip(!purchTable_ds.object(fieldNum(PurchTable, DiscPercent)).allowEdit());
        }
        else
        {
            purchTable_ds.object(fieldNum(PurchTable, DiscPercent)).allowEdit(editDiscPercent && !isOrderInvoiceMatched);
            purchTable_ds.object(fieldNum(PurchTable, DiscPercent)).skip(!purchTable_ds.object(fieldNum(PurchTable, DiscPercent)).allowEdit());
        }

        purchTable_ds.object(fieldNum(PurchTable, DefaultDimension)).allowEdit(!isOrderInvoiceMatched);

        if (dimensionEntryControlHeader)
        {
            dimensionEntryControlHeader.allowEdit(!isOrderInvoiceMatched);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNewlyCreatedPurchLine</Name>
				<Source><![CDATA[
    protected void setNewlyCreatedPurchLine(PurchLine _newlyCreatedPurchLine)
    {
        newlyCreatedPurchLine.data(_newlyCreatedPurchLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>subscribeToAccDistViewEvents</Name>
				<Source><![CDATA[
    public void subscribeToAccDistViewEvents(AccountingDistributionView _accountingDistributionView)
    {
        distributionView = _accountingDistributionView;

        distributionView.closedViewEventHandler += eventhandler(this.distributionFormViewClosed);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean  unpack(container  packedClass)
    {
        boolean ret;
        Integer version;

        if (typeOf(conPeek(packedClass,1)) != Types::Integer)
        {
            advancedStartup = conPeek(packedClass,1);
            ret = true;
        }
        else
        {
            version = conPeek(packedClass,1);

            switch (version)
            {
                case #CurrentVersion:
                    [version, #CurrentList] = packedClass;
                    ret = true;
                    break;
                case 1:
                    [version, #CurrentList] = packedClass;
                    calcTaxStartup = true;
                    ret = true;
                    break;
                default:
                    ret = false;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendAccount</Name>
				<Source><![CDATA[
    VendAccount  vendAccount(VendAccount  _vendAccount = vendAccount)
    {
        vendAccount = _vendAccount;
        return vendAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAssetFieldsBeEditedServer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the fixed asset fields can be edited.
    /// </summary>
    /// <param name="_purchTable">
    /// A table buffer that contains the current <c>PurchTable</c> table values.
    /// </param>
    /// <param name="_purchLine">
    /// A table buffer that contains the current <c>PurchLine</c> table values.
    /// </param>
    /// <returns>
    /// true if the asset fields can be edited; otherwise, false.
    /// </returns>
    /// <remarks>
    ///  The asset fields on a
    ///  <c>
    ///  PurchLine
    ///  </c>
    ///   table buffer can be edited if the following criteria are met:
    ///  <list type="bullet">
    ///   <item>
    ///   <description>The inventory reference type is empty or is set to the fixed asset type.</description>
    ///   </item>
    ///   <item>
    ///   <description>The purchase type is journal, purchase, subscription, or blanket.</description>
    ///   </item>
    ///   <item>
    ///   <description>None of the item quantities have been marked.</description>
    ///   </item>
    ///   <item>
    ///   <description>There is no project associated with the record.</description>
    ///   </item>
    ///   <item>
    ///   <description>The item is not a standard cost item.</description>
    ///   </item>
    ///   <item>
    ///   <description>None of the item quantity has been marked.</description>
    ///   </item>
    ///  </list>
    /// </remarks>
    protected static boolean canAssetFieldsBeEditedServer(PurchTable _purchTable, PurchLine _purchLine)
    {
        boolean ret;
        boolean validItemRefTypeForAssetFields;
        boolean validPurchaseTypeForAssetFields;

        validItemRefTypeForAssetFields = ((_purchLine.ItemRefType == InventRefType::None) ||
                                          (_purchLine.ItemRefType == InventRefType::FixedAsset));

        validPurchaseTypeForAssetFields = PurchTableForm::validatePurchaseTypeForAssetFields(_purchTable);

        ret = validItemRefTypeForAssetFields
            && validPurchaseTypeForAssetFields
            && !_purchLine.ProjId
            && _purchLine.LineDeliveryType == LineDeliveryType::OrderLine;

        // Check inventModel <> StdCost.  If it does, don't allow assignment of an Asset.
        // check only if item has been selected for the line as otherwise we cannot get a model group
        if (_purchLine.ItemId)
        {
            ret = ret && !(_purchLine.inventTable().modelGroup().InventModel == InventModel::StdCost);
            // If the item is stocked and post financial = false, don't allow assignment of an Asset.
            if (ret && _purchLine.isStocked() && !_purchLine.inventTable().modelGroup().PostOnhandFinancial)
            {
                ret = false;
            }
        }

        ret = ret && (_purchLine.qtyMarked() <= 0);

        ret = ret && (_purchLine.invoicedInTotal() == 0);

        ret = ret && !_purchLine.isSubcontracted();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePurchaseTypeForAssetFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether the purchase type is valid for asset fields.
    /// </summary>
    /// <param name = "_purchTable">
    /// A table buffer that contains the current <c>PurchTable</c> table values.
    /// </param>
    /// <returns>
    /// Returns true if the purchase type is valid for asset fields; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final static boolean validatePurchaseTypeForAssetFields(PurchTable _purchTable)
    {
        return ((_purchTable) && (
            (_purchTable.PurchaseType == PurchaseType::Journal) ||
            (_purchTable.PurchaseType == PurchaseType::Purch) ||
            (PurchTableFormFixedAssetNotClearedFlight::instance().isEnabled() && _purchTable.PurchaseType == PurchaseType::ReturnItem)
            ));
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static PurchTableForm construct(
        PurchTableFormId    _purchTableFormId,
        Common              _source)
    {
        PurchTableFormIdFactoryAttribute    attribute       = new PurchTableFormIdFactoryAttribute(_purchTableFormId);
        SysExtensionGenericInstantiation    instantiation   = new SysExtensionGenericInstantiation(_source);
        PurchTableForm                      instance        = SysExtensionAppClassFactory::getClassFromSysAttributeWithInstantiationStrategy(classStr(PurchTableForm), attribute, instantiation) as PurchTableForm;

        if (classIdGet(instance) == classNum(PurchTableForm))
        {
            return new PurchTableForm_DlvScheduleSyncEnabled(_source);
        }

        return instance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructFromArgs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs <c>PurchTableForm</c> object.
    /// </summary>
    /// <param name="_args">Arguments used to determine initial <c>PurchTableForm</c> parameters.</param>
    /// <returns><c>PurchTableForm</c> object.</returns>
    public static PurchTableForm constructFromArgs(Args _args)
    {
        PurchTableFormId    purchTableFormIdParam;
        Common              callerRecord = _args.record();

        if (_args.parmEnumType() == enumNum(PurchTableFormId))
        {
            purchTableFormIdParam = _args.parmEnum();
        }
        else
        {
            purchTableFormIdParam = PurchTableFormId::None;
        }
        return PurchTableForm::construct(purchTableFormIdParam, callerRecord);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAgreementLinkServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a link to the <c>AgreementLine</c> for the given <c>PurchLine</c>.
    /// </summary>
    /// <param name="_purchLine">
    ///     The currently selected <c>PurchLine</c>.
    /// </param>
    /// <param name="_agreementLine">
    ///     The  <c>AgreementLine</c> to be linked to the given <c>PurchLine</c>.
    /// </param>
    public static void createAgreementLinkServer(PurchLine _purchLine, AgreementLine _agreementLine)
    {
        AgreementLineReleasedLine agreementLineReleasedPurchLine;

        // Transfer information from agreement line and set up a link to agreement line.
        _purchLine.initFromAgreementLine(_agreementLine);

        // Clear all policies as now price information is coming from agreement.
        _purchLine.clearAllPriceDiscChangePolicies();

        // When the user manually creates a link to an agreement line, then also enable automatic (re)linking of agreement lines
        _purchLine.AgreementSkipAutoLink = NoYes::No;

        // Update line.
        _purchLine.update();

        // Create relation entity to agreement line.

        if (_purchLine.LineDeliveryType == LineDeliveryType::OrderLineWithMultipleDeliveries)
        {
            agreementLineReleasedPurchLine = AgreementLineReleasedLine::findByPurchLine(_purchLine);
            if (agreementLineReleasedPurchLine)
            {
                // Create relation entities to agreement line
                // for all delivery lines
                agreementLineReleasedPurchLine.linkPurchDeliverySchedule();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deliveryScheduleConversionAllowedServer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the server-side checks of the order line to delivery line conversion.
    /// </summary>
    /// <param name="_purchLine">
    /// The purchase order line to be checked.
    /// </param>
    /// <returns>
    /// true the line specified can be converted; otherwise, false.
    /// </returns>
    public static boolean deliveryScheduleConversionAllowedServer(PurchLine _purchLine)
    {
        return !_purchLine.receivedInTotal()    // not physically updated
            && !_purchLine.registered()
            && !_purchLine.arrived()
            && !_purchLine.invoicedInTotal();   // not financially updated
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyInventOnHandReserve</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens intercompany inventory on-hand reservation form.
    /// </summary>
    /// <param name="_purchLine"><c>PurchLine</c> record.</param>
    public static void interCompanyInventOnHandReserve(PurchLine _purchLine)
    {
        if (!_purchLine.RecId)
        {
            throw(error("@SYS28047"));
        }

        TradeInterCompany::construct(_purchLine).formRun(formStr(InventOnHandReserve));
    }

]]></Source>
			</Method>
			<Method>
				<Name>menuFunctionToRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the menu function to run.
    /// </summary>
    /// <param name = "_args">The arguments for running the class.</param>
    /// <returns>The menu function to run.</returns>
    static protected MenuFunction menuFunctionToRun(Args _args)
    {
        return new MenuFunction(menuitemDisplayStr(PurchTable), MenuItemType::Display);
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args args)
    {
        PurchTableForm::menuFunctionToRun(args).run(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newUnpack</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a <c>PurchTableForm</c> class object.
    /// </summary>
    /// <param name="_purchTable">
    ///     A table buffer of the <c>PurchTable</c> table.
    /// </param>
    /// <param name="_packedPurchTableForm">
    ///     A container type containing a packed <c>PurchTableForm</c> class.
    /// </param>
    /// <returns>
    ///     A <c>PurchTableForm</c> class object.
    /// </returns>
    static PurchTableForm  newUnpack(PurchTable   _purchTable, container _packedPurchTableForm)
    {
        PurchTableForm  purchTableForm = new PurchTableForm(_purchTable);

        purchTableForm.unpack(_packedPurchTableForm);

        return purchTableForm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openDeliveryScheduleForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens purchase delivery schedule form and waits until it is closed.
    /// </summary>
    /// <param name="_caller">A caller form.</param>
    /// <param name="_purchLine">A purchase line record.</param>
    /// <returns>Delivery schedule <c>FormRun</c> object.</returns>
    public static FormRun openDeliveryScheduleForm(Object _caller, PurchLine _purchLine)
    {
        Args    args = new Args();
        FormRun deliverySchedule;

        args.name(formStr(PurchDeliverySchedule));
        args.caller(_caller);
        args.record(_purchLine);
        deliverySchedule = classfactory.formRunClass(args);

        deliverySchedule.run();
        deliverySchedule.wait();

        return deliverySchedule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openIterCompanyInventTransForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens intercompany inventory transaction form.
    /// </summary>
    /// <param name="_purchLine">Purchase line record.</param>
    public static void openIterCompanyInventTransForm(PurchLine _purchLine)
    {
        if (!_purchLine.RecId)
        {
            throw(error("@SYS28047"));
        }

        TradeInterCompany::construct(_purchLine).formRun(formStr(InventTrans));
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchLine_WritePostSuperServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Executes serve side post-purchase line write logic.
    /// </summary>
    /// <param name="_packedInputContract">
    ///     A <c>container</c> type storing a packed <c>PurchLineWritePostSuperInputContract</c> object.
    /// </param>
    /// <returns>
    ///     A <c>container</c> type storing a packed <c>PurchLineWritePostSuperOutputContract</c> object.
    /// </returns>
    public static container  purchLine_WritePostSuperServer(container  _packedInputContract)
    {
        PurchLineWritePostSuperOutputContract   outputContract  = PurchLineWritePostSuperOutputContract::construct();
        PurchLineWritePostSuperInputContract    inputContract   = PurchLineWritePostSuperInputContract::create(_packedInputContract);
        PurchLine                               localPurchLine  = inputContract.parmPurchLine();
        PurchTable                              localPurchTable = inputContract.parmPurchTable();
        PurchLine                               creditNoteCheckPurchLine;

        //  To follow the pattern from the purchase line write method, code execution
        //  depending on the purchTableCheckUpdate method should be added in this if-block.
        if (inputContract.parmPurchTableCheckUpdate())
        {
            if (inputContract.parmCopyTaxGroupToMarkupTrans())
            {
                MarkupTrans::updateTaxGroup(localPurchLine.TableId, localPurchLine.RecId, localPurchLine.TaxGroup, inputContract.parmOrigTaxGroup(), inputContract.parmCopyTaxGroupToMarkupTrans());
            }

            if (inputContract.parmCopyOverrideSalesTaxToMarkupTrans())
            {
                MarkupTrans::updateOverrideSalesTax(
                        localPurchLine.TableId,
                        localPurchLine.RecId,
                        localPurchLine.OverrideSalesTax,
                        inputContract.parmCopyOverrideSalesTaxToMarkupTrans());
            }

            if (inputContract.parmUpdatePendingRegistrationsNonStocked())
            {
                localPurchLine.type(localPurchTable).updatePendingRegistrationsNonStocked(false);
            }

            if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
            {
                outputContract.parmRetailSumLinesHasChanged(localPurchLine.type(localPurchTable).updateRetailSumLines());
            }
        }

        if (localPurchLine.PurchQty < 0)
        {
            select firstonly creditNoteCheckPurchLine
                where creditNoteCheckPurchLine.PurchId == localPurchLine.PurchId
                    && !creditNoteCheckPurchLine.IsDeleted
                    && creditNoteCheckPurchLine.PurchQty > 0;

            if ((localPurchTable.CashDiscPercent && !creditNoteCheckPurchLine)
            || (creditNoteCheckPurchLine && localPurchLine.isInvoiced() && localPurchTable.CashDiscPercent))
            {
                outputContract.parmCreditNoteCashDiscMessage(true);
            }
        }

        return outputContract.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchLine_WritePreSuperServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Executes serve side pre-purchase line write logic.
    /// </summary>
    /// <param name="_packedInputContract">
    ///     A <c>container</c> type storing a packed <c>PurchLineWritePreSuperInputContract</c> object.
    /// </param>
    /// <returns>
    ///     A <c>container</c> type storing a packed <c>PurchLineWritePreSuperOutputContract</c> object.
    /// </returns>
    public static container purchLine_WritePreSuperServer(container  _packedInputContract)
    {
        PurchLineWritePreSuperOutputContract    outputContract  = PurchLineWritePreSuperOutputContract::construct();
        PurchLineWritePreSuperInputContract     inputContract   = PurchLineWritePreSuperInputContract::create(_packedInputContract);
        PurchLine                               localPurchLine  = inputContract.parmPurchLine();
        PurchTable                              localPurchTable = inputContract.parmPurchTable();

        //  To follow the pattern from the purchase line write method, code execution
        //  depending on the purchTableCheckUpdate method should be added in this if-block.
        if (inputContract.parmPurchTableCheckUpdate())
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
            {
                outputContract.parmRetailSumLinesHasChanged(localPurchLine.type(localPurchTable).updateRetailSumLines());
            }

            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && (localPurchLine.Tax1099Fields || localPurchLine.Tax1099RecId))
            {
                //Must make sure we write tax1099Detail only when we are writing purchLine to maintain relationship
                if (localPurchLine.Tax1099Fields)
                {
                    outputContract.parmTax1099Fields(Tax1099Fields::find(localPurchLine.Tax1099Fields));
                }
            }
        }

        outputContract.parmPurchLine(localPurchLine);
        return outputContract.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAllowEditAssetFieldsServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>canEdit</c> and <c>assetAllowCreate</c> enumeration values that are related to the
    ///    edit of asset fields for the purchase line.
    /// </summary>
    /// <param name="_purchTable">
    ///    The current active <c>PurchTable</c> table buffer.
    /// </param>
    /// <param name="_purchLine">
    ///    The current active <c>PurchLine</c> table buffer.
    /// </param>
    /// <returns>
    ///    A container that contains the <c>canEdit</c> and <c>assetAllowCreate</c> enumeration values.
    /// </returns>
    protected static container setAllowEditAssetFieldsServer(PurchTable _purchTable, PurchLine _purchLine)
    {
        boolean canEdit;
        boolean assetAllowCreate;

        canEdit = PurchTableForm::canAssetFieldsBeEditedServer(_purchTable, _purchLine);

        if (canEdit)
        {
            assetAllowCreate = AssetParameters::find().AssetAllowCreate;
        }

        return [canEdit, assetAllowCreate];
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupAssetGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets asset group on the line based on asset defined rules.
    /// </summary>
    /// <param name="_purchLine">
    ///    A <c>PurchLine</c> record for which the asset rules needs are to be looked up.
    /// </param>
    /// <returns>
    ///    true if an asset group can be set and if no user selection is required; otherwise, false.
    /// </returns>
    static container setupAssetGroup(PurchLine _purchLine)
    {
        container       assetRules;
        AssetGroupId    assetGroup;

        if (AssetParameters::canAssetBeAutoCreated()
            && _purchLine.allowCreateFixedAsset()
            && !_purchLine.receivedInTotalServer() 
            && !_purchLine.invoicedInTotalServer())
        {
            assetRules = _purchLine.findAndProcessRule(); 

            //AssetGroup is only set for purchase lines during creation
            if (assetRules && !_purchLine.RecId && _purchLine.PurchaseType == PurchaseType::Purch)
            {
                assetGroup = conPeek(assetRules, #AssetQualifierAssetGroupPosition);

                if (assetGroup)
                {
                    _purchLine.AssetGroup = assetGroup;
                    _purchLine.CreateFixedAsset = NoYes::Yes;
                }
            }
        }

        return assetRules;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isButtonPrepaymentEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables advance action button on header when <c>PurchaseType</c> field of <c>PurchTable</c> table has <c>PurchaseType::Purch</c> enum value .
    /// </summary>
    /// <returns>
    ///    true if prepayment button should be enabled; otherwise, false.
    /// </returns>
    public boolean isButtonPrepaymentEnabled()
    {
        boolean prepayEnabled;

        if (!LedgerParameters::find().JournalizingDefinitionEnableValue && this.isPrepayPurchTableEnabled())
        {
            prepayEnabled = true;
        }

        return prepayEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkflowVisibleForLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the workflow drop dialog menu and icon should be visible for the given purchase order line.
    /// </summary>
    /// <param name="_purchLine">
    /// The purchase order line to check.
    /// </param>
    /// <returns>
    /// true if there is a pending work item for current user or workflow history available for current line; otherwise, true.
    /// </returns>
    public static boolean isWorkflowVisibleForLine(PurchLine _purchLine)
    {
        boolean ret;

        if (_purchLine.canSubmitToWorkflow())
        {
            // if we can submit the purchase order we should not see the lines workflow drop dialog menu button and icon
            ret = false;
        }
        else
        {
            //If there is a pending work item for current user or workflow history available, we should see the drop dialog menu button and icon
            if (Workflow::findWorkItemsForCurrentUser(_purchLine).elements()
            ||  Workflow::findTrackingStatusForDocument(_purchLine))
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkflowVisibleForHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the header workflow drop dialog menu should be visible for the given purchase order.
    /// </summary>
    /// <param name="_purchTable">
    /// The purchase order to check.
    /// </param>
    /// <returns>
    /// true if change management is enabled or purchase order requires change management; otherwise, true.
    /// </returns>
    public boolean isWorkflowVisibleForHeader(PurchTable _purchTable)
    {
        //Hide drop dialog menu button
        boolean ret = false;

        if (changeManagementEnabled || _purchTable.ChangeRequestRequired)
        {
            //If change management is enabled or purchase order requires change management, show the drop dialog menu button
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFinancialEditingForLineWithBudgetReservationReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the financial fields editable or not on the purchase order form based
    /// on if the purchase order line is confirmed with a GBR reference.
    /// </summary>
    /// <param name="_purchLine">
    /// The current purchase order line.
    /// </param>
    public void setFinancialEditingForLineWithBudgetReservationReference(PurchLine _purchLine)
    {
        if (!this.editLineAllowedIfBudgetResReferenced(_purchLine))
        {
            enableDSField(_purchLine.dataSource(), fieldNum(PurchLine, ProcurementCategory), false);
            enableDSField(_purchLine.dataSource(), fieldNum(PurchLine, PurchMarkup), false);
            enableDSField(_purchLine.dataSource(), fieldNum(PurchLine, PurchQty), false);
            enableDSField(_purchLine.dataSource(), fieldNum(PurchLine, PurchUnit), false);
            enableDSField(_purchLine.dataSource(), fieldNum(PurchLine, PurchPrice), false);
            enableDSField(_purchLine.dataSource(), fieldNum(PurchLine, PriceUnit), false);
            enableDSField(_purchLine.dataSource(), fieldNum(PurchLine, LineAmount), false);
            enableDSField(_purchLine.dataSource(), fieldNum(PurchLine, LineDisc), false);
            enableDSField(_purchLine.dataSource(), fieldNum(PurchLine, LinePercent), false);
            enableDSField(_purchLine.dataSource(), fieldNum(PurchLine, MultiLnDisc), false);
            enableDSField(_purchLine.dataSource(), fieldNum(PurchLine, MultiLnPercent), false);
            enableDSField(_purchLine.dataSource(), fieldNum(PurchLine, TaxItemGroup), false);
            enableDSField(_purchLine.dataSource(), fieldNum(PurchLine, TaxGroup), false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkerPrimaryLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the buffer <c>LogisiticsLocation</c> for logged-in workers primary department
    /// </summary>
    /// <param name="_workerRecId">
    /// Worker record ID, default is current user worker ID
    /// </param>
    /// <returns>
    /// Returns <c>LogisticsLocation</c> buffer
    /// </returns>
    public LogisticsLocation getWorkerPrimaryLocation(HcmWorkerRecId _workerRecId = HcmWorker::userId2Worker(curUserId()))
    {
        LogisticsLocation logisticsLocation;
        DirPartyLocation dpLocation;
        DirPartyLocationRole dpLocationRole;
        LogisticsLocationRole addressPurpose;

        if (_workerRecId)
        {
            OMOperatingUnit department = HcmWorkerHelper::getPrimaryDepartment(_workerRecId);

            select firstonly logisticsLocation
            join IsPrimary from dpLocation
                order by dpLocation.IsPrimary desc
                where logisticsLocation.RecId == dpLocation.Location
                    && dpLocation.Party == department.RecId
            exists join dpLocationRole
                where dpLocationRole.PartyLocation == dpLocation.RecId
            exists join addressPurpose
                where addressPurpose.RecId == dpLocationRole.LocationRole
                    && addressPurpose.Type == LogisticsLocationRoleType::Invoice;
        }

        if (!logisticsLocation)
        {
            logisticsLocation = LogisticsLocation::find(DirPartyLocation::findPrimaryPartyLocation(CompanyInfo::current()).Location);
        }

        return logisticsLocation;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>