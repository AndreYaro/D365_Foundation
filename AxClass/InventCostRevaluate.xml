<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventCostRevaluate</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>InventCostRevaluate</c> class revaluates the inventory when a standard cost price changes.
/// </summary>

class InventCostRevaluate
{
    // Caller parameter
    InventItemPrice                 inventItemPrice;
    LedgerVoucher                   ledgerVoucher;

    // Records
    InventTable                     inventTable;
    InventDim                       inventDim;
    InventDimParm                   inventDimParm;
    InventItemPrice                 prevInventItemPrice;
    InventCostTrans                 costTransOld;
    InventCostTrans                 costTransNew;

    // Global variables
    InventCostTransVarianceList     inventCostTransVarianceList;
    InventClosing                   lastInventClosing;
    InventCostTransVarianceMap      inventCostTransVarianceMap;
    InventCostTransList             inventCostTransRevalOldList;
    InventCostTransList             inventCostTransRevalNewList;
    InventCostTransList             inventCostTransList;
    InventTransAdjustDataMap        inventTransAdjustDataMap;
    InventCostTransVarianceList     currentVarianceList;

    // Control variables
    boolean                         processInitialized;
    boolean                         recalcProd;
    boolean                         revaluationByPosting;

    // Use two recordSortedList to store the actual and estimated cost groups
    InventCostTransCostList         actCostList;
    InventCostTransCostList         estCostList;

    // <GEERU>
    InventTransCurrency_RU          inventTransCurrency;
    // </GEERU>
    #define.EmptyDefaultDimension(0)
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addInventCostTrans</Name>
				<Source><![CDATA[
    protected void addInventCostTrans()
    {
        this.addInventCostTransGroup1();
        this.addInventCostTransGroup2();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInventCostTransGroup1byDefault</Name>
				<Source><![CDATA[
    private void addInventCostTransGroup1byDefault()
    {
        InventCostTrans     costTrans;

        // Now add the transactions that have occured since the last closing.
        while select ItemId, FinancialInventDimId, sum(OnHandQty), sum(AccruedQty), sum(DeferredCOGSQty), sum(cogsQty) from costTrans
            group by ItemId, FinancialInventDimId
            where costTrans.ItemId              == inventItemPrice.ItemId
               && costTrans.ItemPriceRefRecId   == prevInventItemPrice.RecId
               && (costTrans.TransDate           >  lastInventClosing.TransDate)
        {
            // Fields might not have been selected
            costTrans.checkInvalidFieldAccess(false);

            // Add the record to the trans list
            inventCostTransList.add(costTrans, false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInventCostTransGroup1</Name>
				<Source><![CDATA[
    protected void addInventCostTransGroup1()
    {
        if (InventCostDimensionDefaultingSourceFeature::instance().isEnabled())
        {
            InventCostTrans    costTrans;
            InventCostTrans    costTransWithDimension;
            InventTransPosting inventTransPosting;
            InventTransOrigin  inventTransOrigin;

            if (revaluationByPosting)
            {
                while select ItemId, FinancialInventDimId, InventTransId, sum(OnHandQty), sum(AccruedQty), sum(DeferredCOGSQty), sum(cogsQty)
                    from costTrans
                    group by ItemId, FinancialInventDimId, InventTransId
                    where costTrans.ItemId               == inventItemPrice.ItemId
                       && costTrans.ItemPriceRefRecId    == prevInventItemPrice.RecId
                       && costTrans.TransDate            > lastInventClosing.TransDate
                {
                    select firstonly Voucher
                        from costTransWithDimension
                        order by costTransWithDimension.CostTransState desc
                        where costTransWithDimension.InventTransId         == costTrans.InventTransId
                            && costTransWithDimension.ItemId               == costTrans.ItemId
                            && costTransWithDimension.CostTransRefType     != InventCostTransRefType::InventoryRevaluation
                            && costTransWithDimension.FinancialInventDimId == costTrans.FinancialInventDimId
                            && costTransWithDimension.TransDate            >  lastInventClosing.TransDate
                        join inventTransPosting
                        where inventTransPosting.Voucher       == costTransWithDimension.Voucher
                            && inventTransPosting.ItemId        == costTrans.ItemId
                        exists join inventTransOrigin
                            where inventTransOrigin.Recid      == inventTransPosting.InventTransOrigin
                                && inventTransOrigin.InventTransId == costTrans.InventTransId;

                    costTrans.DefaultDimension = inventTransPosting.DefaultDimension;

                    // Fields might not have been selected
                    costTrans.checkInvalidFieldAccess(false);

                    // Add the record to the trans list
                    inventCostTransList.add(costTrans, false);
                }
            }
            else
            {
                this.addInventCostTransGroup1byDefault();
            }
        }
        else
        {
            this.addInventCostTransGroup1byDefault();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInventCostTransGroup2</Name>
				<Source><![CDATA[
    protected void addInventCostTransGroup2(boolean _allowZero = false)
    {
        InventCostTrans     costTrans;
        
        if (revaluationByPosting)
        {
            InventCostTrans    costTransWithDimension;
            InventTransPosting inventTransPosting;
            InventTransOrigin  inventTransOrigin;
            while select ItemId, FinancialInventDimId, TransRefId, InventTransId, sum(wipInQty), sum(wipOutQty) from costTrans
                group by ItemId, FinancialInventDimId, TransRefId, InventTransId
                where costTrans.ItemId              == inventItemPrice.ItemId
                   && costTrans.ItemPriceRefRecId   == prevInventItemPrice.RecId
                   && (costTrans.TransDate           >  lastInventClosing.TransDate)
                   && (costTrans.CostTransRefType == InventCostTransRefType::Production
                    || costTrans.CostTransRefType == InventCostTransRefType::ProductionFlow
                    || costTrans.CostTransRefType == InventCostTransRefType::WIPRevaluation)
            {
                if (costTrans.InventTransId)
                {
                    select firstonly Voucher
                        from costTransWithDimension
                        order by costTransWithDimension.CostTransState desc
                        where costTransWithDimension.InventTransId        == costTrans.InventTransId
                           && costTransWithDimension.TransRefId           == costTrans.TransRefId
                           && costTransWithDimension.ItemId               == costTrans.ItemId
                           && costTransWithDimension.CostTransRefType     != InventCostTransRefType::InventoryRevaluation
                           && costTransWithDimension.FinancialInventDimId == costTrans.FinancialInventDimId
                           && costTransWithDimension.TransDate            >  lastInventClosing.TransDate
                        join RecId from inventTransOrigin
                        where costTransWithDimension.InventTransId       == inventTransOrigin.InventTransId
                        join DefaultDimension from inventTransPosting
                        where inventTransPosting.Voucher                 == costTransWithDimension.Voucher
                           && inventTransPosting.InventTransOrigin       == inventTransOrigin.RecId
                           && inventTransPosting.ItemId                  == costTrans.ItemId;

                    costTrans.DefaultDimension = inventTransPosting.DefaultDimension;
                }
                // Fields might not have been selected
                costTrans.checkInvalidFieldAccess(false);

                costTrans.CostTransRefType = InventCostTransRefType::Production;

                // Add the record to the trans list
                inventCostTransList.add(costTrans, _allowZero);
            }
        }
        else
        {
            while select ItemId, FinancialInventDimId, TransRefId, DefaultDimension, sum(wipInQty), sum(wipOutQty) from costTrans
                group by ItemId, FinancialInventDimId, TransRefId, DefaultDimension
                where costTrans.ItemId              == inventItemPrice.ItemId
                   && costTrans.ItemPriceRefRecId   == prevInventItemPrice.RecId
                   && (costTrans.TransDate           >  lastInventClosing.TransDate)
                   && (costTrans.CostTransRefType == InventCostTransRefType::Production
                    || costTrans.CostTransRefType == InventCostTransRefType::ProductionFlow
                    || costTrans.CostTransRefType == InventCostTransRefType::WIPRevaluation)
            {
                // Fields might not have been selected
                costTrans.checkInvalidFieldAccess(false);

                costTrans.CostTransRefType = InventCostTransRefType::Production;

                // Add the record to the trans list
                inventCostTransList.add(costTrans, _allowZero);
            }
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>addInventCostTransSum</Name>
				<Source><![CDATA[
    protected void addInventCostTransSum()
    {
        InventCostTransSum      inventCostTransSum;
        InventDim               inventDimSum;
        InventCostTrans         costTrans;

        // first of all, check if I can use the inventCostTransSum
        if (InventItemPrice::stdCostFindDate(inventTable, lastInventClosing.TransDate, inventDim.InventDimId, inventDim).RecId == prevInventItemPrice.RecId)
        {
            // Get all the sum records for the last closing date for the inventory revaluation
            while select ItemId, FinancialInventDimId, sum(OnHandQty), sum(AccruedQty), sum(DeferredCOGSQty), sum(cogsQty) from inventCostTransSum
                group by ItemId, FinancialInventDimId
                where inventCostTransSum.InventClosingRefRecId == lastInventClosing.RecId
                   && inventCostTransSum.ItemId                == inventTable.ItemId
                #InventDimExistsJoin(InventCostTransSum.FinancialInventDimId, InventDimSum, inventDim, inventDimParm)
            {
                // Add the record to the trans list
                costTrans.initFromInventCostTransSum(inventCostTransSum);
                inventCostTransList.add(costTrans, false);
            }

            // Now get all sum records for the WIP revaluation
            costTrans.clear();

            if (revaluationByPosting)
            {
                while select ItemId, FinancialInventDimId, TransRefId, sum(wipInQty), sum(wipOutQty) from inventCostTransSum
                group by ItemId, FinancialInventDimId, TransRefId
                where inventCostTransSum.InventClosingRefRecId == lastInventClosing.RecId
                    && inventCostTransSum.ItemId                == inventTable.ItemId
                    && (inventCostTransSum.CostTransRefType     == InventCostTransRefType::Production
                    || inventCostTransSum.CostTransRefType     == InventCostTransRefType::ProductionFlow
                    || inventCostTransSum.CostTransRefType     == InventCostTransRefType::WIPRevaluation)
                    #InventDimExistsJoin(InventCostTransSum.FinancialInventDimId, InventDimSum, inventDim, inventDimParm)
                {
                    // Add the record to the trans list
                    costTrans.initFromInventCostTransSumWip(inventCostTransSum);
                    costTrans.CostTransRefType = InventCostTransRefType::Production;
                    inventCostTransList.add(costTrans, false);
                }
            }
            else
            {
                while select ItemId, FinancialInventDimId, TransRefId, DefaultDimension, sum(wipInQty), sum(wipOutQty) from inventCostTransSum
                group by ItemId, FinancialInventDimId, TransRefId, DefaultDimension
                where inventCostTransSum.InventClosingRefRecId == lastInventClosing.RecId
                   && inventCostTransSum.ItemId                == inventTable.ItemId
                   && (inventCostTransSum.CostTransRefType     == InventCostTransRefType::Production
                    || inventCostTransSum.CostTransRefType     == InventCostTransRefType::ProductionFlow
                    || inventCostTransSum.CostTransRefType     == InventCostTransRefType::WIPRevaluation)
                    #InventDimExistsJoin(InventCostTransSum.FinancialInventDimId, InventDimSum, inventDim, inventDimParm)
                {
                    // Add the record to the trans list
                    costTrans.initFromInventCostTransSumWip(inventCostTransSum);
                    costTrans.CostTransRefType = InventCostTransRefType::Production;
                    inventCostTransList.add(costTrans, false);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToTransRevalList</Name>
				<Source><![CDATA[
    protected void addToTransRevalList(
        InventCostTransList     _inventCostTransList,
        InventCostTrans         _costTrans,
        InventDimId             _inventDimId,
        container               _qty,
        InventCostTransType     _costTransType,
        CostTransRefId          _transRefId,
        DimensionDefault        _dimension,
        // Variance dimension can be different with costTrans in production flow within WIP stage
        DimensionDefault        _varianceDimension = _dimension)
    {
        // Quantities
        Qty             onHandQty, accruedQty, wipInQty, wipOutQty, defferedCOGSQty, cogsQty;

        // Records
        InventCostTrans costTrans;

        // Local voids
        void insertAndReset()
        {
            _inventCostTransList.insert(costTrans, true);

            // Add the variance to the map
            if (costTrans.VarianceQty != 0)
            {
                // The recordSortedList can just be inserted,
                // due to the fact that the records will be processed one by one
                currentVarianceList = InventCostTransVarianceList::newFromList(
                    inventCostTransVarianceList,
                    costTrans.VarianceQty,
                    _varianceDimension);

                inventCostTransVarianceMap.insert(InventCostTransVarianceMap::buildKey(costTrans),
                                                  currentVarianceList);
            }

            costTrans.resetQtyFields();
        }

        // Reset the variance list
        currentVarianceList = null;

        // Get the quantities
        [onHandQty, accruedQty, wipInQty, wipOutQty, defferedCOGSQty, cogsQty] = _qty;

        // Initialize cost trans record
        costTrans.data(_costTrans);
        costTrans.FinancialInventDimId = _inventDimId;
        // For the wip revaluation set also the reference to the production order
        costTrans.TransRefId           = _transRefId;
        costTrans.DefaultDimension     = _dimension;

        // For each qty create different records
        // No revaluation for accrued and COGs
        if (onHandQty || defferedCOGSQty)
        {
            costTrans.setInventoryRevaluation(_costTransType, onHandQty, defferedCOGSQty);
            insertAndReset();
        }
        if (wipInQty || wipOutQty)
        {
            costTrans.setWIPRevaluation(_costTransType, wipInQty, wipOutQty);
            insertAndReset();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToTransRevalListByPosting</Name>
				<Source><![CDATA[
    protected void addToTransRevalListByPosting(
        InventCostTransList     _inventCostTransList,
        InventCostTrans         _costTrans,
        InventDimId             _inventDimId,
        container               _qty,
        InventCostTransType     _costTransType,
        CostTransRefId          _transRefId,
        DimensionDefault        _dimension,
        InventTransId           _inventTransId,
        DimensionDefault        _varianceDimension = _dimension)
    {
        // Quantities
        Qty             onHandQty, accruedQty, wipInQty, wipOutQty, defferedCOGSQty, cogsQty;

        // Records
        InventCostTrans costTrans;

        // Local voids
        void insertAndReset()
        {
            _inventCostTransList.insert(costTrans, true);

            // Add the variance to the map
            if (costTrans.VarianceQty != 0)
            {
                // The recordSortedList can just be inserted,
                // due to the fact that the records will be processed one by one
                currentVarianceList = InventCostTransVarianceList::newFromList(
                    inventCostTransVarianceList,
                    costTrans.VarianceQty,
                    _varianceDimension);

                inventCostTransVarianceMap.insert(InventCostTransVarianceMap::buildKey(costTrans),
                                                  currentVarianceList);
            }

            costTrans.resetQtyFields();
        }

        // Reset the variance list
        currentVarianceList = null;

        // Get the quantities
        [onHandQty, accruedQty, wipInQty, wipOutQty, defferedCOGSQty, cogsQty] = _qty;

        // Initialize cost trans record
        costTrans.data(_costTrans);
        costTrans.FinancialInventDimId = _inventDimId;
        // For the wip revaluation set also the reference to the production order
        costTrans.TransRefId           = _transRefId;
        costTrans.DefaultDimension     = _dimension;

        if (revaluationByPosting)
        {
            costTrans.InventTransId = _inventTransId;
        }

        // For each qty create different records
        // No revaluation for accrued and COGs
        if (onHandQty || defferedCOGSQty)
        {
            costTrans.setInventoryRevaluation(_costTransType, onHandQty, defferedCOGSQty);
            insertAndReset();
        }
        if (wipInQty || wipOutQty)
        {
            costTrans.setWIPRevaluation(_costTransType, wipInQty, wipOutQty);
            insertAndReset();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the revaluation process.
    /// </summary>

    protected void init()
    {
        // Set control variables
        processInitialized  = false;

        revaluationByPosting = false;

        if (InventCostDimensionDefaultingSourceFeature::instance().isEnabled())
        {
            CostParameters costParameters = CostParameters::find();

            if (costParameters.DimensionDefaultingSource == DimensionDefaultingSource::Posting)
            {
                revaluationByPosting = true;
            }
        }

        // Set variables from inventItemPrice
        if ( ! inventTable || inventTable.ItemId != inventItemPrice.ItemId)
        {
            inventTable         = inventItemPrice.inventTable();
        }

        inventDim           = inventItemPrice.inventDim();

        // Initialize the inventDimParm record
        inventDimParm.initFromInventDim(inventDim);

        // InventCostTransList might be set using the parm method
        if (!inventCostTransList)
        {
            // Initialize the costTransList
            inventCostTransList = InventCostTransList::construct();
            recalcProd = true;
        }
        else
        {
            // Records to revaluate has been passed.
            // This is only done during backdate process
            // As a performance optimization, supress the recalculation of the production orders
            recalcProd = false;
        }

        // First of all, get the previous price
        // if a previous item price has been passed in, use this one
        if (!prevInventItemPrice)
        {
            this.initPrevInventItemPrice();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initActCostList</Name>
				<Source><![CDATA[
    protected void initActCostList()
    {
        // Initialize the list
        actCostList = InventCostTransCostList::newStdCostList(prevInventItemPrice.RecId,
                                                              this.varianceType(),
                                                              #EmptyDefaultDimension);    // Correct dimensions are assigned later
                                                                                                // in the method addToTransRevalList
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCostTransVarianceList</Name>
				<Source><![CDATA[
    protected void initCostTransVarianceList()
    {
        // Initialize the lists with the prev and new cost
        this.initActCostList();
        this.initEstCostList();

        // Initialize the list that holds the variance
        inventCostTransVarianceList = InventCostCreateVarianceList::createVarianceListFromCostListDelta(actCostList, estCostList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initEstCostList</Name>
				<Source><![CDATA[
    protected void initEstCostList()
    {
        // Initialize the list
        estCostList = InventCostTransCostList::newStdCostList(inventItemPrice.RecId,
                                                              this.varianceType(),
                                                              #EmptyDefaultDimension);    // Correct dimensions are assigned later
                                                                                                // in the method addToTransRevalList
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPrevInventItemPrice</Name>
				<Source><![CDATA[
    protected void initPrevInventItemPrice()
    {
        // Ensure that the price will be locked
        prevInventItemPrice = InventItemPrice::stdCostFindPrevLocked(inventTable.ItemId,
                                                                     inventItemPrice.InventDimId,
                                                                     inventItemPrice.CreatedDateTime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProcess</Name>
				<Source><![CDATA[
    protected void initProcess()
    {
        // Initialize the variance between old and new cost price
        // This list will be the base for the calculation of
        // the total variance for one inventCostTrans record
        this.initCostTransVarianceList();

        // Initialize the map
        inventCostTransVarianceMap = InventCostTransVarianceMap::construct();

        // Initialize the recordSortedLists
        inventCostTransRevalOldList = InventCostTransList::construct();
        inventCostTransRevalNewList = InventCostTransList::construct();

        // NOTE: in both cases, no inventTrans and inventDim can be passed
        // so the record are not fully initialized yet
        // Initialize cost trans record with the old price
        costTransOld = InventCostTrans::initInventCostTrans(InventCostTransState::Financial,
                                                            prevInventItemPrice,
                                                            inventTable,
                                                            ledgerVoucher.lastVoucher(),
                                                            ledgerVoucher.lastTransDate());

        // Now with the new price
        costTransNew = InventCostTrans::initInventCostTrans(InventCostTransState::Financial,
                                                            inventItemPrice,
                                                            inventTable,
                                                            ledgerVoucher.lastVoucher(),
                                                            ledgerVoucher.lastTransDate());

        // Init production data map for each inventCostList
        inventTransAdjustDataMap = InventTransAdjustDataMap::construct();

        // Set control variable, to prevent, that method will be called again
        processInitialized = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        lastInventClosing = InventClosing::findClosingDate(InventClosing::closingDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventCostTransList</Name>
				<Source><![CDATA[
    public InventCostTransList parmInventCostTransList(InventCostTransList _inventCostTransList = inventCostTransList)
    {
        inventCostTransList = _inventCostTransList;

        return inventCostTransList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventItemPrice</Name>
				<Source><![CDATA[
    public InventItemPrice parmInventItemPrice(InventItemPrice _inventItemPrice = inventItemPrice)
    {
        inventItemPrice = _inventItemPrice;

        return inventItemPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventTransCurrency_RU</Name>
				<Source><![CDATA[
    final public InventTransCurrency_RU parmInventTransCurrency_RU(InventTransCurrency_RU _inventTransCurrency = inventTransCurrency)
    {
        inventTransCurrency = _inventTransCurrency;
        if (! prmisdefault(_inventTransCurrency) && lastInventClosing.InventTransCurrency_RU != inventTransCurrency)
        {
            lastInventClosing = InventClosing::findClosingDate(InventClosing::closingDate(false, inventTransCurrency), inventTransCurrency);
        }

        return inventTransCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerVoucher</Name>
				<Source><![CDATA[
    public LedgerVoucher parmLedgerVoucher(LedgerVoucher _ledgerVoucher = ledgerVoucher)
    {
        ledgerVoucher = _ledgerVoucher;

        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrevInventItemPrice</Name>
				<Source><![CDATA[
    public InventItemPrice parmPrevInventItemPrice(InventItemPrice _prevInventItemPrice = prevInventItemPrice)
    {
        prevInventItemPrice = _prevInventItemPrice;

        return prevInventItemPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceType</Name>
				<Source><![CDATA[
    protected CostingVersionPriceType priceType()
    {
        return CostingVersionPriceType::Cost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCostTransList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Processes the transactions that need to be revaluated.
    /// </summary>

    protected void processCostTransList()
    {
        // Records
        InventCostTrans                 costTrans;
        InventCostTrans                 costTransProd;
        ProdTable                       prodTable;

        // Control variables
        boolean                         found;
        boolean                         callUpdate;
        InventTransId                   inventTransId;

        // Amounts
        CostAmount                      costAmount;
        InventItemCostGroupRollupList   inventItemCostGroupRollupList;

        callUpdate = false;

        found = inventCostTransList.first(costTrans);
        while (found)
        {
            // If at least one record has been found,
            // I need to pass them to the update framework
            callUpdate = true;

            // For the first time, initialize all the variables
            // I need to preform the processing
            if (!processInitialized)
            {
                this.initProcess();
            }

            if (revaluationByPosting)
            {
                this.addToTransRevalListByPosting(inventCostTransRevalOldList,
                                     costTransOld,
                                     costTrans.FinancialInventDimId,
                                     costTrans.getQtyFields(),
                                     InventCostTransType::Issue,
                                     costTrans.TransRefId,
                                     costTrans.revaluationDefaultDimension(inventTable),
                                     costTrans.InventTransId,
                                     costTrans.revaluationDefaultDimension(inventTable, true));

                this.addToTransRevalListByPosting(inventCostTransRevalNewList,
                                     costTransNew,
                                     costTrans.FinancialInventDimId,
                                     costTrans.getQtyFields(),
                                     InventCostTransType::Receipt,
                                     costTrans.TransRefId,
                                     costTrans.revaluationDefaultDimension(inventTable),
                                     costTrans.InventTransId,
                                     costTrans.revaluationDefaultDimension(inventTable, true));
            }
            else
            {
                // Add the old record
                this.addToTransRevalList(inventCostTransRevalOldList,
                                     costTransOld,
                                     costTrans.FinancialInventDimId,
                                     costTrans.getQtyFields(),
                                     InventCostTransType::Issue,
                                     costTrans.TransRefId,
                                     costTrans.revaluationDefaultDimension(inventTable),
                                     costTrans.revaluationDefaultDimension(inventTable, true));

                // Add the new record
                this.addToTransRevalList(inventCostTransRevalNewList,
                                     costTransNew,
                                     costTrans.FinancialInventDimId,
                                     costTrans.getQtyFields(),
                                     InventCostTransType::Receipt,
                                     costTrans.TransRefId,
                                     costTrans.revaluationDefaultDimension(inventTable),
                                     costTrans.revaluationDefaultDimension(inventTable, true));
            }

            // If we are manipulation a production issue,
            // add the information to the production data map
            if ( costTrans.isWIP() &&
                 costTrans.wipInQty         != 0 )
            {
                // Calc the cost amount which is the difference
                // between the previous and the actual cost price
                // As the quantity use the wipIn Qty, because variance qty is not set for
                // production issues. We are only looking at production issues here
                // <GEERU>
                costAmount = (inventTransCurrency == InventTransCurrency_RU::PrimaryCur              ?
                              (prevInventItemPrice.pcsPrice()          - inventItemPrice.pcsPrice()) :
                              (prevInventItemPrice.pcsPriceSecCur_RU() - inventItemPrice.pcsPriceSecCur_RU())) * costTrans.wipInQty;
                // </GEERU>

                // When the addToTransRevalList method has added a variance,
                // the currentVarianceList is still initialzed
                if (currentVarianceList)
                {
                    inventItemCostGroupRollupList = InventItemCostGroupRollupList::newFromVarianceList(currentVarianceList, inventItemPrice.RecId);
                }

                // I need to figure out the inventTransId belonging to this production order
                // Due to the fact, that the prodTable record might have been deleted, use the inventCostTrans
                // to find the appropriate record
                prodTable = ProdTable::find(costTrans.TransRefId);

                if (prodTable)
                {
                    inventTransId = prodTable.InventTransId;
                }
                else
                {
                    select firstonly InventTransId from costTransProd
                    where ((costTransProd.CostTransRefType == InventCostTransRefType::Production
                       && costTransProd.CostTransType    == InventCostTransType::Receipt)
                       || (costTransProd.CostTransRefType == InventCostTransRefType::ProductionFlow
                       && costTransProd.CostTransType    == InventCostTransType::Issue))
                       && costTransProd.TransRefId       == costTrans.TransRefId;

                    inventTransId = costTransProd.InventTransId;
                }

                inventTransAdjustDataMap.add(inventTransId,
                                             costTrans.ItemId,
                                             costAmount,
                                             inventItemPrice.RecId,
                                             inventItemCostGroupRollupList);
            }

            found = inventCostTransList.next(costTrans);
        }

        // Now, all the lists have been filled, hand them over to the
        // inventCostUpdate framework
        // First of all, the prev cost trans records. No variance has to be created for them
        if (callUpdate)
        {
            // Post transaction to ledger
            // <GEERU>
            InventCostPost::post(ledgerVoucher, inventTable, inventCostTransRevalOldList, null,                       InventAdjustmentSpec::Total, inventTransCurrency);
            InventCostPost::post(ledgerVoucher, inventTable, inventCostTransRevalNewList, inventCostTransVarianceMap, InventAdjustmentSpec::Total, inventTransCurrency);
            // </GEERU>

            InventCostUpdateGlobal::Instance().inventCostUpdate().finalizeCostTransVariance(inventCostTransRevalOldList, null);

            InventCostUpdateGlobal::Instance().inventCostUpdate().finalizeCostTransVariance(inventCostTransRevalNewList, inventCostTransVarianceMap);

            // If I have calculated adjustments for production orders,
            // adjust these
            if (inventTransAdjustDataMap && inventTransAdjustDataMap.elements() != 0)
            {
                // When calling recalc of a production order out of the backdateing process
                // no need to update prodcalc trans from the revaluation process
                // because this is done in the out process
                InventCostProdAdjust::adjustFromInventCostRevaluate(inventTransAdjustDataMap,
                                                                    ledgerVoucher,
                                                                    // <GEERU>
                                                                    recalcProd,
                                                                    inventTransCurrency,
                                                                    // </GEERU>
                                                                    true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNow</Name>
				<Source><![CDATA[
    public void updateNow()
    {
        // Initialize variables
        this.init();

        // First of all, initialize all the necessary variables
        if (this.validate())
        {
            ttsbegin;

            // If records has been passed using the parm method,
            // use them for the revaluation
            if (inventCostTransList.length() == 0)
            {
                // Ok, first of all, get the sum for this item
                this.addInventCostTransSum();

                // Now add the inventCostTrans records
                this.addInventCostTrans();
            }

            // Now process all the records from the list
            this.processCostTransList();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates whether there is something to revaluate.
    /// </summary>
    /// <returns>
    ///    true if there is something to revaluate; otherwise, false.
    /// </returns>

    protected boolean validate()
    {
        if (inventItemPrice.RecId == prevInventItemPrice.RecId ||
            !prevInventItemPrice)
        {
            // Prices are identical ==> noting to adjust
            return false;
        }

        if ( ! (inventItemPrice.ItemId
             && inventTable.inventItemType().mustInventBeControlled()))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>varianceType</Name>
				<Source><![CDATA[
    protected InventCostVarianceType varianceType()
    {
        return InventCostVarianceType::Revaluation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static InventCostRevaluate construct()
    {
        return new InventCostRevaluate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromInventCostTransList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of this class for the given parameters.
    /// </summary>
    /// <param name="_inventItemPrice">
    ///    The item price that is currently active.
    /// </param>
    /// <param name="_prevInventItemPrice">
    ///    The item price that was previously active.
    /// </param>
    /// <param name="_inventCostTransList">
    ///    The <c>InventCostTrans</c> records that must be revaluated.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher that should be used for the postings.
    /// </param>
    /// <returns>
    ///    An initialized instance of the class.
    /// </returns>

    public static InventCostRevaluate newFromInventCostTransList(
        InventItemPrice         _inventItemPrice,
        InventItemPrice         _prevInventItemPrice,
        InventCostTransList     _inventCostTransList,
        LedgerVoucher           _ledgerVoucher)
    {
        InventCostRevaluate     inventCostRevaluate;

        // Initalize instance
        inventCostRevaluate = InventCostRevaluate::newFromParameter(_inventItemPrice, _ledgerVoucher);

        // Set the preivious item price that should be used for the revaluation
        inventCostRevaluate.parmPrevInventItemPrice(_prevInventItemPrice);

        // Set the records that should be revaluated
        inventCostRevaluate.parmInventCostTransList(_inventCostTransList);

        return inventCostRevaluate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromParameter</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of this class for the given parameters.
    /// </summary>
    /// <param name="_inventItemPrice">
    ///    The item price that is currently active.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher that should be used for the postings.
    /// </param>
    /// <returns>
    ///    An initialized instance of the class.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    No ledger voucher or inventory item price is given.
    /// </exception>

    protected static InventCostRevaluate newFromParameter(
        InventItemPrice     _inventItemPrice,
        LedgerVoucher       _ledgerVoucher)
    {
        InventCostRevaluate    inventCostRevaluate;

        // A ledgerVoucher needs to be passed
        if ( ! _inventItemPrice ||
             ! _ledgerVoucher)
        {
            throw error("@SYS25407");
        }

        // Create instance
        inventCostRevaluate = InventCostRevaluate::construct();

        // Set parameters
        inventCostRevaluate.parmLedgerVoucher(_ledgerVoucher);
        inventCostRevaluate.parmInventItemPrice(_inventItemPrice);

        return inventCostRevaluate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>revaluateFromBackdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Revaluates <c>InventCostTrans</c> records when a backdating occurs.
    /// </summary>
    /// <param name="_inventItemPrice">
    ///    The item price that is currently active.
    /// </param>
    /// <param name="_prevInventItemPrice">
    ///    The item price that was previously active.
    /// </param>
    /// <param name="_inventCostTransList">
    ///    The <c>InventCostTrans</c> records that must be revaluated.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher that should be used for the postings.
    /// </param>
    /// <param name="_inventTransCurrency">
    /// The transaction currency: primary (default) or secondary - used for Dual Warehousing
    /// </param>

    public static void revaluateFromBackdate(
        InventItemPrice         _inventItemPrice,
        InventItemPrice         _prevInventItemPrice,
        InventCostTransList     _inventCostTransList,
        LedgerVoucher          _ledgerVoucher,
        InventTransCurrency_RU _inventTransCurrency = InventTransCurrency_RU::PrimaryCur)
    {
        InventCostRevaluate             inventCostRevaluate;
        TransDate                       prevTransDate;
        TransDate                       transDate;

        // The voucher is holding a different Trans Date,
        // because this is happening during a backdating
        // ==> Set the trans Date, for which the revaluation should take place
        prevTransDate = _ledgerVoucher.lastTransDate();

        // In case, that no revaluation was necessary, when this price was transfered (e.g. because of no items on stock)
        // use activation date instead for the transDate
        transDate       = _inventItemPrice.StdCostTransDate ? _inventItemPrice.StdCostTransDate : _inventItemPrice.ActivationDate;
         _ledgerVoucher.lastTransDate(transDate);

        // Initalize instance
        inventCostRevaluate = InventCostRevaluate::newFromInventCostTransList(_inventItemPrice,
                                                                              _prevInventItemPrice,
                                                                              _inventCostTransList,
                                                                              _ledgerVoucher);
        // <GEERU>
        inventCostRevaluate.parmInventTransCurrency_RU(_inventTransCurrency);
        // </GEERU>
        // Revaluate the list
        inventCostRevaluate.updateNow();

        // After the posting reset the transdate to the original one
        _ledgerVoucher.lastTransDate(prevTransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>revaluateFromStdCostChange</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Revaluates cost when a new price is activated.
    /// </summary>
    /// <param name="_inventItemPrice">
    ///    The item price that is currently active.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger Voucher that should be used for the postings.
    /// </param>
    /// <param name="_inventTransCurrency">
    /// The transaction currency: primary (default) or secondary - used for Dual Warehousing
    /// </param>

    public static void revaluateFromStdCostChange(
        InventItemPrice     _inventItemPrice,
        LedgerVoucher          _ledgerVoucher,
        InventTransCurrency_RU _inventTransCurrency = InventTransCurrency_RU::PrimaryCur)
    {
        InventCostRevaluate             inventCostRevaluate;

        // Initalize instance
        inventCostRevaluate = InventCostRevaluate::newFromParameter(_inventItemPrice,
                                                                    _ledgerVoucher);
        // <GEERU>
        inventCostRevaluate.parmInventTransCurrency_RU(_inventTransCurrency);
        // </GEERU>

        // Revaluate the std cost price
        inventCostRevaluate.updateNow();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>