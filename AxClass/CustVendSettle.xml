<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendSettle</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>CustVendSettle</c> class serves as the parent class of a hierarchy of five classes that
/// serve as the engine for settling customer and vendor transactions.
/// </summary>
/// <remarks>
/// This settlement can be performed from the customer table form, vendor table form or from a journal.
/// The <see cref="M:CustVendSettle.settleNow" /> method is the main method that performs the
/// settlement. All the other methods are sub-methods to this class. The settlement engine can only
/// settle transactions from the customer or vendor transactions form and the journals. The engine
/// cannot be used for extended development, if the functionality of settling customer or vendor
/// transactions is needed from somewhere else.
/// </remarks>
public abstract class CustVendSettle implements SysSaveable
{
    protected OffsetVoucher offsetVoucher;
    private LedgerJournalId relatedJournalId; // Journal Id of the related voucher
    private LedgerVoucher relatedLedgerVoucher;

    private PostingProfile postingProfile;

    protected CustVendTransSettleDistController debitSettleDistController;
    protected CustVendTransSettleDistController creditSettleDistController;

    private LedgerDimensionDefaultAccount dueToFromLedgerDimensionDebit;
    private LedgerDimensionDefaultAccount dueToFromLedgerDimensionCredit;

    private RecordSortedList rslTmpOverUnderReverseTax;
    private container conLedgerAccount;
    private container conTaxBaseAmountCur;
    private container conTaxAmounts_RU;
    private container conTaxTransRecId;
    private container conOriginalTaxTransRecId;

    private SettleDatePrinc datePrinciple;
    private TransDate saveDate;

    private CashDiscCode cashDiscTransCodeDebit;
    private CashDiscCode cashDiscTransCodeCredit;
    private LedgerDimensionDefaultAccount cashDiscLedgerDimensionDebit;
    private LedgerDimensionDefaultAccount cashDiscLedgerDimensionCredit;
    protected RecordSortedList custVendTransSettlementControl; // To control that no transactions are oversettled or negative settled
    private SysModule module;
    private boolean isSettleByLineEnabled;

    protected CustVendTransSettlement custVendTransSettlement; // Class that manages CustVendTrans and CustVendSettlement records created during settlement
    protected Counter settlementGroupPlaceHolder;

    protected VendSettleTax1099Manager vendTax1099Manager; // Class that manages 1099 during settlement

    private boolean isCashDiscountAdjustedForOverPayment;
    // Post in summary if cash discount is for the debit transaction or an over payment so that
    // the over payment and debit transaction will be summarized together.
    // Credit transactions should still be posted in detail.
    private boolean postCashDiscountInSummary;

    protected SettlementRemainingOpenAmounts remainingOpenAmounts;
    private SettlementFullSettlement fullSettlement;

    // <GEERU>
    private Voucher taxVoucherCredit;
    private Voucher taxVoucherDebit;
    // </GEERU>
    // <GIN>
    private CustTrans parentCustTrans;
    TransTaxInformationHelper transTaxInformationHelper;
    private TableId offsetTableId;
    // </GIN>

    private SettlementCashDiscountAmounts cashDiscountAmounts;

    private SettlementPairBankChequePaymTrans bankChequePaymTransCache;

    // <GTH>
    private boolean isAverageVATEnabled;
    private boolean isUnrealizedVATEnabled;
    private boolean isTaxInvoiceInfoFilled;

    private boolean mcrOrderCompletionEnabled;
    private MCROutOfBalanceReleaseType mcrOOBReleaseType;
    private AmountCur writeOffAmount;
    private CustVendTrans savedCustVendTransDebit;

    boolean isLatestSettlement;
    CustVendSettlement custVendSettlementLatest;
    // </GTH>

    // <GEERU>
    private CustVendExchAdjParm_W custVendExchAdjParm;
    protected ExchRateDiffCalcType_W exchRateDiffCalcType;
    private CustVendTrans firstCustVendTrans;
    private boolean isSettlementActive;
    // </GEERU>

    private CustSettleJournalizingEntries custSettleJournalizingEntries;
    private BankTransactionTypes bankTransactionTypes;

    private SettlementTransactionState debitTransState;
    private SettlementTransactionState creditTransState;
    private Set interCompanyReversalVouchers;
    private Set taxChargeIntercompanySet;
    private boolean skipReversePrePaymentTax;
    private CustVendAC accountNumber;

    protected SettlementPair settlementPair;
    private SettlementPreviousTotals settlementPreviousTotals;

    private CustVendSettleNowState settleNowState;
    private CustVendInstrumentationDimensionTracking instrumentationDimensionTracking = new CustVendInstrumentationDimensionTracking();

    private boolean existFineInterestBR = false;

    // <GEERU>
    private LedgerVoucher parentLedgerVoucher;
    private Set taxTransRecIDs;
    private List targetTaxLedgerParmsList;
    private AmountCur taxAgentPaymentAmountTransaction;
    private AmountMST taxAgentPaymentAmountAccounting;
    private AmountMSTSecondary taxAgentPaymentAmountReporting;
    private Set reversePostingLogSet;
    // </GEERU>

    // <GIN>
    protected Map expenseAmtMap;
    protected Map recoverableAmtMap;
    protected Map invoiceVoucherMap;
    // </GIN>

    // <GTE>
    Map taxDocumentLedgerVoucherMap;
    // </GTE>

    private LedgerDimensionAccount fixedAssetDiscountDimension;
    private boolean processConditionalTaxForPDC;
    private boolean isInsidePostExchRateDiff;
    private Set exchRateDiffTaxLedgerVoucherTransObjectTempRecIDs;
    private TaxAmount taxAmountUseTaxTotal;
    private LedgerDimensionAccount exchRateDiffTaxMergedLedgerDimension;

    private Set taxWithholdTransRecIds = new Set(typeName2Type(extendedTypeStr(RecId)));

    private CustVendSettlePendingJournalizationInstrumentationLogger settlePendingJournalizationLogger;
    private CustVendSettleLogger custVendSettleLogger;

    #ISOCountryRegionCodes

    #DEFINE.CurrentVersion(1)
    #LOCALMACRO.CurrentList
        datePrinciple,
        saveDate
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accountLossProfit</Name>
				<Source><![CDATA[
    [SysObsolete('This method is obsoleted. Use accountRealizedGainLossFromPostingProfile() instead', false, 01\12\2022)]
    abstract LedgerDimensionDefaultAccount accountLossProfit(Amount _exchRateDiff, CurrencyCode _currencyCode)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountNonrealLossProfit</Name>
				<Source><![CDATA[
    [SysObsolete('This method is obsoleted. Use accountUnrealizedGainLossFromPostingProfile() instead', false, 01\12\2022)]
    abstract LedgerDimensionDefaultAccount accountNonrealLossProfit(Amount _exchRateDiff, CurrencyCode _currencyCode)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountRealizedGainLossFromPostingProfile</Name>
				<Source><![CDATA[
    protected LedgerDimensionDefaultAccount accountRealizedGainLossFromPostingProfile(Amount _exchRateDiff, CurrencyCode _currencyCode, AccountNum _accountNum)
    {
        throw error(Error::missingOverride(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountUnrealizedGainLossFromPostingProfile</Name>
				<Source><![CDATA[
    protected LedgerDimensionDefaultAccount accountUnrealizedGainLossFromPostingProfile(Amount _exchRateDiff, CurrencyCode _currencyCode, AccountNum _accountNum)
    {
        throw error(Error::missingOverride(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultLedgerDimensionFromPostingProfile</Name>
				<Source><![CDATA[
    protected LedgerDimensionDefaultAccount getDefaultLedgerDimensionFromPostingProfile(
        AccountNum _accountNum,
        CurrencyGainLossAccountType _accountType,
        CurrencyCode _currencyCode,
        LedgerExchAdjPostingModule _postingModule)
    {
        LedgerDimensionDefaultAccount defaultLedgerDimension = LedgerExchAdjPosting::getLedgerDimensionFromParameters(
                LedgerExchAdjPostingSearchParameters::newFromParameters(
                    _postingModule,
                    _accountType,
                    _currencyCode,
                    _accountNum));

        if (defaultLedgerDimension == 0)
        {
            defaultLedgerDimension = CurrencyLedgerGainLossAccount::ledgerDimension(
                Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                _currencyCode,
                _accountType);
        }

        return defaultLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTransToTaxSortedList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a record in the <c>rslTmpOverUnderReverseTax</c> record sorted list using the specified
    ///    parameters.
    /// </summary>
    /// <param name="_invoiceRecId">
    ///    The record ID of the debit transaction.
    /// </param>
    /// <param name="_invoiceVoucher">
    ///    The voucher number of the debit transaction.
    /// </param>
    /// <param name="_invoiceCompany">
    ///    The company of the debit transaction.
    /// </param>
    /// <param name="_settlementDate">
    ///    The transaction date of the settlement.
    /// </param>
    /// <param name="_invoiceAmountMST">
    ///    The amount in the monetary standard currency (MST) of the debit transaction.
    /// </param>
    /// <param name="_invoiceSettleAmountMST">
    ///    The settled amount in the MST currency of the debit transaction.
    /// </param>
    /// <param name="_paymRecId">
    ///    The record ID of the credit transaction.
    /// </param>
    /// <param name="_paymCompany">
    ///    The company of the credit transaction.
    /// </param>
    /// <param name="_paymSettleAmountMst">
    ///    The settled amount in the MST currency of the credit transaction.
    /// </param>
    /// <param name="_paymToInvoiceExchRate">
    ///    The exchange rate between the credit transaction MST amount and the debit transaction MST amount.
    /// </param>
    /// <param name="_invoiceLedgerVoucher">
    ///    The settlement voucher number of the debit transaction; optional.
    /// </param>
    /// <param name="_paymLedgerVoucher">
    ///    The settlement voucher number of the credit transaction; optional.
    /// </param>
    /// <param name="_settlementGroup">
    ///    The settlement group number of the debit and credit transaction; optional.
    /// </param>
    /// <remarks>
    ///    A record is not added if the tax parameter for overpayment is not set in the debit transaction
    ///    company.
    /// </remarks>
    protected void addTransToTaxSortedList(
        RecId       _invoiceRecId,
        Voucher     _invoiceVoucher,
        CompanyId   _invoiceCompany,
        TransDate   _settlementDate,
        AmountMST   _invoiceAmountMST,
        AmountMST   _invoiceSettleAmountMST,
        RecId       _paymRecId,
        CompanyId   _paymCompany,
        AmountMST   _paymSettleAmountMst,
        ExchRate    _paymToInvoiceExchRate,
        Voucher     _invoiceLedgerVoucher   = '',
        Voucher     _paymLedgerVoucher      = '',
        Counter     _settlementGroup        = 0)
    {
        TmpSettleOverUnderReverseTax    tmpSettleOverUnderReverseTax;

        // only add record if the invoice company has over/under tax enabled
        changecompany(_invoiceCompany)
        {
            if (TaxParameters::find().TaxOnOverpayment == false)
            {
                return;
            }
        }

        tmpSettleOverUnderReverseTax.RefRecId = _invoiceRecId;
        tmpSettleOverUnderReverseTax.RefCompany = _invoiceCompany;
        tmpSettleOverUnderReverseTax.PaymCompany = _paymCompany;
        tmpSettleOverUnderReverseTax.PaymRefRecId = _paymRecId;

        if (!rslTmpOverUnderReverseTax.find(tmpSettleOverUnderReverseTax))
        {
            tmpSettleOverUnderReverseTax.clear();
            tmpSettleOverUnderReverseTax.RefRecId = _invoiceRecId;
            tmpSettleOverUnderReverseTax.Voucher = _invoiceVoucher;
            tmpSettleOverUnderReverseTax.TransDate = _settlementDate;
            tmpSettleOverUnderReverseTax.RefCompany = _invoiceCompany;
            tmpSettleOverUnderReverseTax.PaymCompany = _paymCompany;
            tmpSettleOverUnderReverseTax.PaymRefRecId = _paymRecId;
            tmpSettleOverUnderReverseTax.InvoiceLedgerVoucher = _invoiceLedgerVoucher;
            tmpSettleOverUnderReverseTax.PaymLedgerVoucher = _paymLedgerVoucher;
            tmpSettleOverUnderReverseTax.SettlementGroup = _settlementGroup;
            tmpSettleOverUnderReverseTax.PaymToInvoiceExchRate = _paymToInvoiceExchRate;
        }

        tmpSettleOverUnderReverseTax.AmountMST              += _invoiceAmountMST;
        tmpSettleOverUnderReverseTax.SettleAmountMST        += _invoiceSettleAmountMST;
        tmpSettleOverUnderReverseTax.PaymSettleAmountMst    += _paymSettleAmountMst;

        rslTmpOverUnderReverseTax.ins(tmpSettleOverUnderReverseTax, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>amount</Name>
				<Source><![CDATA[
    public AmountMST amount(AmountMST _amount)
    {
        return SettlementUtility::adjustAmountSign(_amount, this.parmModule());
    }

]]></Source>
			</Method>
			<Method>
				<Name>approvalVoucherDate</Name>
				<Source><![CDATA[
    protected container approvalVoucherDate(CustVendTrans _custVendTrans)
    {
        return [_custVendTrans.Voucher, _custVendTrans.TransDate];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAndPostTaxExchRateDiff_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates and posts tax on exchange rate difference.
    /// </summary>
    /// <param name="_exchRateDiff">
    /// Amount of exchange rate difference, for which tax should be calculated.
    /// </param>
    /// <param name="_custVendTrans">
    /// <c>CustVendTrans</c> record being settled.
    /// </param>
    /// <param name="_posting">
    /// Posting type for exchange rate difference.
    /// </param>
    /// <param name="_exchRateTrans">
    /// <c>CustVendTrans</c> records which is exchange rate adjustment.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> object at which posting performed; Optional.
    /// </param>
    /// <param name="_vatAdjustment">
    /// Indicates whether exch rate difference being posted is VAT Adjustment; Optional.
    /// </param>
    /// <param name="_postReporting">
    /// Indicates exchange rate difference is in reporting currency; Optional.
    /// </param>
    /// <param name="_defaultDimension">
    /// Default dimension being processed from distribution associated with _custVendTrans parameter; Optional.
    /// </param>
    /// <param name="_skipDistribution">
    /// Determines if distribution should be ignored when calculating posting tax; Optional.
    /// </param>
    /// <param name="_taxTransDefaultDimensions">
    /// The <c>TmpTaxTransDefaultDimension_RU</c> table which determines fractions of tax transactions for dimensions.
    /// </param>
    /// <returns>
    /// Amount of caclulated and posted tax.
    /// </returns>
    /// <remarks>
    /// Factor for calculation of exchange rate is determined as relation of total exchRateDiff(excluding unrealized
    /// revaluations of invoice and payments) to amount of source invoice or its not settled part.
    /// </remarks>
    public TaxAmount calcAndPostTaxExchRateDiff_RU(
        AmountMST           _exchRateDiff,
        CustVendTrans       _custVendTrans,
        LedgerPostingType   _posting,
        CustVendTrans       _exchRateTrans,
        LedgerVoucher       _ledgerVoucher = null,
        boolean             _vatAdjustment = false,
        boolean             _postReporting = false,
        DimensionDefault    _defaultDimension = 0,
        boolean             _skipDistribution = false,
        TmpTaxTransDefaultDimension_RU _taxTransDefaultDimensions = null)
    {
        TaxAmount               taxAmount;
        LedgerVoucher           ledgerVoucher   = _ledgerVoucher ? _ledgerVoucher : settlementPair.findLedgerVoucherByCompany(_custVendTrans.company());
        ExchAdjTaxableType_W    taxable         = custVendExchAdjParm.taxable(_posting);
        TaxExchDiff_RU          taxExchDiff;
        CustTransOpen           custTransOpen;
        CustTransOpenLine       custTransOpenLine;
        CustTransMarkedOpenLine custTransMarkedOpenLine;
        CustInvoiceLineIdRef    custInvoiceLineIdRef;
        CustInvoiceTrans        custInvoiceTrans;
        CustInterestTrans       custInterestTrans;
        MarkupTrans             markupTrans;
        AmountCur               origLineAmount;
        AmountMST               totalSettledAmountMst;
        Map                     sourceTransMap;
        RecId                   sourceRecId;
        TableId                 sourceTableId;
        Factor                  convertFactor = 1;

        taxTransRecIDs              = null;
        targetTaxLedgerParmsList    = null;

        if (taxable == ExchAdjTaxableType_W::Tax || taxable == ExchAdjTaxableType_W::Expense)
        {
            if (_postReporting && _custVendTrans.ReportingCurrencyAmount)
            {
                convertFactor = _exchRateDiff / _custVendTrans.ReportingCurrencyAmount;
            }
            else if (!_postReporting && _custVendTrans.AmountMST)
            {
                convertFactor = _exchRateDiff / _custVendTrans.AmountMST;
            }

            taxExchDiff = new TaxExchDiff_RU(
                ledgerVoucher.lastVoucher(),
                ledgerVoucher.lastTransDate(),
                '',
                _exchRateTrans,
                convertFactor);

            taxExchDiff.parmLedgerPostingType(_posting);
            taxExchDiff.parmIsFromSettlement(true);
            taxExchDiff.parmCustVendExchAdjParm(custVendExchAdjParm);
            taxExchDiff.parmVATAdjustment(_vatAdjustment);
            taxExchDiff.parmPostToReportingCurrency(_postReporting);

            if (!prmisDefault(_defaultDimension))
            {
                taxExchDiff.parmDimensionDefault(_defaultDimension);
                taxExchDiff.parmOverrideDefaultDimension(true);
                taxExchDiff.parmTaxTransDefaultDimensions(_taxTransDefaultDimensions);

                if (_custVendTrans.TableId == tableNum(CustTrans))
                {
                    taxExchDiff.parmRemoveProfitLossDimension(true);
                }
            }

            taxExchDiff.parmSkipDistribution(_skipDistribution);

            if (parentLedgerVoucher)
            {
                taxExchDiff.parmLedgerVoucherObject(parentLedgerVoucher.findLedgerVoucherObject(_custVendTrans.Voucher, _custVendTrans.TransDate));
            }

            custTransOpen = CustTransOpen::findRefId(_custVendTrans.RecId);

            if (custTransOpen && CustParameters::find().MarkOpenInvoiceLine && CustTransOpenLine::existByRefId(custTransOpen.RecId))
            {
                sourceTransMap = new Map(Types::Container, Types::Real);
                while select sum(AmountToSettle), sum(CashDiscLineToTake) from custTransMarkedOpenLine
                    join TableId from custTransOpenLine
                    join RecId, EntityType from custInvoiceLineIdRef group by RecId, EntityType
                    where custTransMarkedOpenLine.SpecTrans == SpecTrans::findByRef(custTransOpen.company(), custTransOpen.TableId, custTransOpen.RecId).RecId
                        && custTransOpenLine.RecId == custTransMarkedOpenLine.CustTransOpenLine
                        && custInvoiceLineIdRef.RecId == custTransOpenLine.CustInvoiceLineIdRef
                {
                    switch (custInvoiceLineIdRef.EntityType)
                    {
                        case CustInvoiceLineType::Customer:
                            select firstonly RecId, LineAmount, TaxAmount from custInvoiceTrans
                                where custInvoiceTrans.CustInvoiceLineIdRef == custInvoiceLineIdRef.RecId;

                            sourceTableId   = custInvoiceTrans.TableId;
                            sourceRecId     = custInvoiceTrans.RecId;
                            origLineAmount  = custInvoiceTrans.LineAmount + custInvoiceTrans.TaxAmount;
                            break;

                        case CustInvoiceLineType::MarkupTrans:
                            select firstonly RecId, Value, TaxAmount from markupTrans
                                where markupTrans.CustInvoiceLineIdRef == custInvoiceLineIdRef.RecId;

                            sourceTableId   = markupTrans.TableId;
                            sourceRecId     = markupTrans.RecId;
                            origLineAmount  = markupTrans.Value + markupTrans.TaxAmount;
                            break;

                        case CustInvoiceLineType::InterestNote:
                            select firstonly RecId, InterestAmount from custInterestTrans
                                where custInterestTrans.CustInvoiceLineIdRef == custInvoiceLineIdRef.RecId;

                            sourceTableId   = custInterestTrans.TableId;
                            sourceRecId     = custInterestTrans.RecId;
                            origLineAmount  = custInterestTrans.InterestAmount;
                            break;

                        default:
                            sourceRecId = 0;
                    }

                    if (sourceRecId && origLineAmount)
                    {
                        totalSettledAmountMst += settlementPair.getCalculator().calcSettleAmountMstForDebit(custTransMarkedOpenLine.AmountToSettle + custTransMarkedOpenLine.CashDiscLineToTake);
                        sourceTransMap.insert([sourceTableId, sourceRecId], (custTransMarkedOpenLine.AmountToSettle + custTransMarkedOpenLine.CashDiscLineToTake) / origLineAmount);
                    }
                    else
                    {
                        totalSettledAmountMst = 0;
                        break;
                    }
                }

                totalSettledAmountMst = CurrencyExchange::round(totalSettledAmountMst, settlementPair.getDebitCompanyCurrency());

                if (totalSettledAmountMst && totalSettledAmountMst < _custVendTrans.AmountMST)
                {
                    taxExchDiff.parmFactor(_exchRateDiff / totalSettledAmountMst);
                    taxExchDiff.parmSourceTransMap(sourceTransMap);
                }
            }

            taxExchDiff.calcAndPost(LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher), _custVendTrans.Voucher, _custVendTrans.TransDate, taxable == ExchAdjTaxableType_W::Tax);
            taxAmount                   = taxExchDiff.taxAmountCalculated();
            taxTransRecIDs              = taxExchDiff.taxTransRecIDs();
            targetTaxLedgerParmsList    = taxExchDiff.targetLedgerParmsList();
            exchRateDiffTaxLedgerVoucherTransObjectTempRecIDs = taxExchDiff.exchRateDiffTaxLedgerVoucherTransObjectTempRecIDs();
            taxAmountUseTaxTotal = taxExchDiff.getTaxAmountUseTaxTotal();
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcBalanceOnSelectedDate_W</Name>
				<Source><![CDATA[
    private AmountCur calcBalanceOnSelectedDate_W(
        SpecTrans     _specTrans,
        CustVendTrans _custVendTrans,
        Map           _reversedAmounts,
        AmountCur     _reversedAmount)
    {
        AmountCur reversedAmount = _reversedAmount;

        _specTrans.Balance01 += reversedAmount;

        reversedAmount = this.reversedAmount_RU(_reversedAmounts, settlementPair.getTransactionDate());

        if (abs(reversedAmount) > abs(_custVendTrans.remainAmountCur()))
        {
            _specTrans.Balance01 = 0;
        }
        else
        {
            reversedAmount = _custVendTrans.remainAmountCur() - reversedAmount;
            if (abs(_specTrans.Balance01) > abs(reversedAmount))
            {
                reversedAmount        = _specTrans.Balance01 - reversedAmount;
                _specTrans.Balance01 -= reversedAmount;
            }
            else
            {
                reversedAmount = 0;
            }
        }

        return reversedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcFinInterestOrFineForCreditCompany_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the amount of the Interest/Fine for the credit (payment) company.
    /// </summary>
    /// <param name="_amountCur">
    /// The amount of the Interest/Fine in the transaction currency of the debit transaction.
    /// </param>
    /// <returns>
    /// A container that includes the Interest/Fine amount for the payment company.  The first value is the Interest/Fine
    /// amount in tranaction currency.  The second amount is the Interest/Fine amount in MST currency.
    /// </returns>
    protected container calcFinInterestOrFineForCreditCompany_BR(AmountCur _amountCur)
    {
        AmountCur               amountCurForPaymCompany;
        AmountMST               amountMstForPaymCompany;
        CurrencyExchangeHelper  currencyHelper;

        Debug::assert(settlementPair.getCreditCompany() != settlementPair.getDebitCompany());

        // the transaction amount is just transafered.
        amountCurForPaymCompany = _amountCur;

        // convert the Interest/Fine amount in transaction currency to Mst in credit company using exchange rate in credit company and
        // debit transaction date.
        currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::current(settlementPair.getCreditCompany())), settlementPair.getCustVendTransDebit().TransDate);
        amountMstForPaymCompany = currencyHelper.calculateTransactionToAccounting(settlementPair.getCustVendTransDebit().CurrencyCode, amountCurForPaymCompany, true);

        return [amountCurForPaymCompany, amountMstForPaymCompany];
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountLossProfitTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger posting account for the tax settlement exchange adjustment
    /// posting.
    /// </summary>
    /// <param name="_exchRateDiff">
    /// Amount of the exchange rate adjustment.
    /// </param>
    /// <param name="_currencyCode">
    /// Currency code of the exchange adjustment posting.
    /// </param>
    /// <returns>
    /// <c>LedgerDimensionDefaultAccount</c> for the tax settlement exchange adjustment
    /// posting.
    /// </returns>
    /// <remarks>
    /// The logic for retrieving the account is identical for both the AP and AR side.
    /// This is because on the AR side the tax posting is money that is owed by the company.
    /// If the company owes more tax (overall transaction gain) it is a tax loss. On the AP side,
    /// the tax posting is an asset that can be netted out against owed tax to reduce what
    /// is owed. If the tax that can be netted out is now less (overall transaction gain),
    /// it's a tax loss as well.
    /// </remarks>
    private LedgerDimensionDefaultAccount accountLossProfitTax(
        Amount _exchRateDiff,
        CurrencyCode _currencyCode)
    {
        LedgerDimensionDefaultAccount defaultAccount;
        CurrencyGainLossAccountType accountType;

        if (_exchRateDiff > 0)
        {
            accountType = CurrencyGainLossAccountType::RealizedGain;
        }
        else
        {
            accountType = CurrencyGainLossAccountType::RealizedLoss;
        }

        defaultAccount = CurrencyLedgerGainLossAccount::ledgerDimension(
            Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
            _currencyCode,
            accountType);

        return defaultAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInvoiceTaxWithholdAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the amount of tax withholding that was previously decided on the invoice.
    /// </summary>
    /// <returns>
    ///    The amount of tax withholding in debit transaction currency.
    /// </returns>
    protected TaxWithholdAmount calcInvoiceTaxWithholdAmount()
    {
        TaxWithholdAmount taxWithholdAmount = 0;
        TaxWithholdTrans taxWithholdTrans;
        real sign = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoGB]) || TaxWithholdingGlobalFeature::isFeatureAndParamEnabled()
            ? -1 : 1;

        changecompany(settlementPair.getDebitCompany())
        {
            // Note: the posting (settling) of the tax withholding is done prior to the main
            // settlement process.  So at the time of settlement the SettleAmount fields on VendTrans
            // have already been updated with the tax withholding amount.

            // Find the amount of the tax withholding in invoice currency.
            if (!BrazilParameters::isEnabled() && settlementPair.getCustVendTransDebit().TableId == tableNum(VendTrans))
            {
                select sum(InvoiceTaxWithholdAmount) from taxWithholdTrans
                    where taxWithholdTrans.SpecTransId == settlementPair.getSpecTransDebit().RecId
                    && taxWithholdTrans.VendTransInvoiceId == settlementPair.getCustVendTransDebit().RecId;

                taxWithholdAmount = taxWithholdTrans.InvoiceTaxWithholdAmount;

                // Update the TaxWithholdTrans SpecTransId field.
                update_recordset taxWithholdTrans
                    setting SpecTransId = 0
                    where taxWithholdTrans.SpecTransId == settlementPair.getSpecTransDebit().RecId
                    && taxWithholdTrans.VendTransInvoiceId == settlementPair.getCustVendTransDebit().RecId;
            }
            else if (settlementPair.getCustVendTransDebit().TableId == tableNum(CustTrans))
            {
                select sum(InvoiceTaxWithholdAmount) from taxWithholdTrans
                    where taxWithholdTrans.SpecTransId == settlementPair.getSpecTransDebit().RecId
                    && taxWithholdTrans.CustTransInvoiceId == settlementPair.getCustVendTransDebit().RecId;

                taxWithholdAmount = sign * taxWithholdTrans.InvoiceTaxWithholdAmount;

                // Save for calculating CustSettlemoentLine before update
                while select RecId from taxWithholdTrans
                    where taxWithholdTrans.SpecTransId == settlementPair.getSpecTransDebit().RecId
                    && taxWithholdTrans.CustTransInvoiceId == settlementPair.getCustVendTransDebit().RecId
                {
                    taxWithholdTransRecIds.add(taxWithholdTrans.RecId);
                }

            }
        }

        return taxWithholdAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcRecoveryLOIByPaymVoucher_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Calculates the amount of interim recoverable Load On Inventory tax by payment tax trans.
    /// </summary>
    /// <param name="_paymTaxTrans">
    /// The payment tax trans.
    /// </param>
    /// <returns>
    /// The sum up amount of interim recoverable Load On Inventory tax.
    /// </returns>
    public TaxAmount calcRecoveryLOIByPaymVoucher_IN(
        TaxTrans                    _paymTaxTrans)
    {
        VendSettlement         vendSettlement;
        VendTrans              vendTransPayment;
        VendTrans              vendTransInvoice;
        LedgerTransVoucherLink ledgerTransVoucherLink;
        LedgerTransVoucherLink ledgerTransVoucherLinkRel;
        VendInvoiceJour        vendInvoiceJour;
        VendInvoiceTrans       vendInvoiceTrans;
        TaxTrans               taxTransRev;
        TaxTrans_IN            taxTransRev_IN;
        TaxTable               taxTable;
        TaxLedgerAccounts_IN   taxLedgerAccountsRev;
        Percent                settlePercent;
        boolean                isRecoverableCheckBoxUnmarked;
        TaxAmount              taxAmountLOI = 0;

        while select RecId, SettleAmountMST from vendSettlement
        join AmountMST from vendTransInvoice
            where vendTransInvoice.RecId            == vendSettlement.OffsetRecid
        join RecId,PurchId,InvoiceId,InvoiceDate,NumberSequenceGroup,InternalInvoiceId from vendInvoiceJour
            where vendInvoiceJour.LedgerVoucher     == vendSettlement.OffsetTransVoucher &&
                vendInvoiceJour.InvoiceDate         == vendTransInvoice.TransDate &&
                vendInvoiceJour.InvoiceAccount      == vendSettlement.AccountNum
        exists join vendTransPayment
            where vendTransPayment.RecId            == vendSettlement.TransRecId
        exists join ledgerTransVoucherLinkRel
            where ledgerTransVoucherLinkRel.Voucher == _paymTaxTrans.Voucher &&
                ledgerTransVoucherLinkRel.TransDate == _paymTaxTrans.TransDate
        exists join ledgerTransVoucherLink
            where ledgerTransVoucherLink.RecId      == ledgerTransVoucherLinkRel.VoucherGroupId &&
                ledgerTransVoucherLink.Voucher      == vendTransPayment.Voucher &&
                ledgerTransVoucherLink.TransDate    == vendTransPayment.TransDate
        {
            isRecoverableCheckBoxUnmarked = TaxItemGroupHeading::isRecoverableExpChkBoxUnMarked_IN(tableNum(PurchTable),
                                                    VendInvoiceJour::findRecId(vendInvoiceJour.RecId).purchTable().RecId);
            if (isRecoverableCheckBoxUnmarked)
            {
                continue;
            }

            if (vendTransInvoice.AmountMST)
            {
                settlePercent = abs(vendSettlement.SettleAmountMST * 100 / vendTransInvoice.AmountMST);
            }
            else
            {
                settlePercent = 0;
            }

            select sum(TaxInCostPriceRegulated) from taxTransRev
                where taxTransRev.TaxCode                     == _paymTaxTrans.TaxCode
                    && taxTransRev.SourceTableId              == tableNum(VendInvoiceTrans)
            exists join vendInvoiceTrans
                where vendInvoiceTrans.PurchID                == vendInvoiceJour.PurchId
                    && vendInvoiceTrans.RecId                 == taxTransRev.SourceRecId
                    && vendInvoiceTrans.InvoiceId             == vendInvoiceJour.InvoiceId
                    && vendInvoiceTrans.InvoiceDate           == vendInvoiceJour.InvoiceDate
                    && vendInvoiceTrans.NumberSequenceGroup   == vendInvoiceJour.NumberSequenceGroup
                    && vendInvoiceTrans.InternalInvoiceId     == vendInvoiceJour.InternalInvoiceId
            exists join taxTransRev_IN
                where taxTransRev_IN.RefRecId                 == taxTransRev.RecId
                    && taxTransRev_IN.TaxType                 == TaxType_IN::ServiceTax
            exists join taxTable
                where taxTable.TaxCode                        == taxTransRev.TaxCode
            exists join taxLedgerAccountsRev
                where taxLedgerAccountsRev.LedgerDimension    == taxTransRev_IN.RecoverableLedgerDimension
                    && taxLedgerAccountsRev.AccountType       == TaxAccountType_IN::ServiceTaxInterimRecoverableAccount
                    && taxLedgerAccountsRev.TaxComponentTable == taxTable.TaxComponentTable_IN;
            if (taxTransRev.TaxInCostPriceRegulated)
            {
                taxAmountLOI += CurrencyExchangeHelper::amount(settlePercent / 100 * taxTransRev.TaxInCostPriceRegulated);
            }
        }

        return taxAmountLOI;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcUnrealizedExchAdjCurrencyDeal_RU</Name>
				<Source><![CDATA[
    protected void calcUnrealizedExchAdjCurrencyDeal_RU()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcWHTRealizedExchAdjAmount_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the realized gain or loss for the withholding tax for a voucher.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The customer or vendor transaction information for the current transaction.
    /// </param>
    /// <returns>
    /// The realized gain or loss from the withholding transactions for the voucher that is being paid.
    /// </returns>
    /// <remarks>
    /// The calculation is performed by taking the payment amount and calculating what that was worth at
    /// the time of invoice and what it is worth at the time of invoice in the base currency. The
    /// difference is then added to the existing gain or loss. If AR, the amount is negative then that is a
    /// loss, if it is positive it is a gain. If AP, the amounts are the opposite. Therefore, we reverse
    /// the sign at the end.
    /// </remarks>
    protected AmountMST calcWHTRealizedExchAdjAmount_W(CustVendTrans _custVendTrans)
    {
        AmountMST           taxAmountMstOnInvDate;
        AmountMST           taxAmountMstOnPaymDate;
        AmountMST           realizedExchAdj = 0;
        TaxWithholdTrans    taxWithholdTrans;

        while select SpecTransId, InvoiceCurrency, PaymCurrency, CompetenceDate, PaymTaxWithholdAmount, TransDate
            from taxWithholdTrans
            where taxWithholdTrans.SpecTransId == settlementPair.getSpecTransDebit().RecId
        {
            taxAmountMstOnInvDate = 0;
            taxAmountMstOnPaymDate = 0;

            taxAmountMstOnInvDate = CurrencyExchangeHelper::mstAmount(taxWithholdTrans.PaymTaxWithholdAmount, taxWithholdTrans.InvoiceCurrency, taxWithholdTrans.CompetenceDate);

            taxAmountMstOnPaymDate = CurrencyExchangeHelper::mstAmount(taxWithholdTrans.PaymTaxWithholdAmount, taxWithholdTrans.PaymCurrency, taxWithholdTrans.TransDate);

            realizedExchAdj += taxAmountMstOnInvDate - taxAmountMstOnPaymDate;
        }

        // signs come in the opposite for AP than AR
        if (_custVendTrans.TableId == tableNum(VendTrans))
        {
            realizedExchAdj = -realizedExchAdj;
        }

        return realizedExchAdj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscLedgerDimensionForCreditCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the cash discount ledger account for the credit company.
    /// </summary>
    /// <returns>
    ///    The cash discount ledger account.
    /// </returns>
    protected LedgerDimensionDefaultAccount cashDiscLedgerDimensionForCreditCompany()
    {
        LedgerDimensionDefaultAccount   discLedgerDimension;
        boolean                         accountExists;

        changecompany(settlementPair.getCreditCompany())
        {
            // check if cash discount code exists in the payment company and get the appropiate ledger account
            if (this.parmModule() == SysModule::Cust)
            {
                discLedgerDimension = CashDisc::paidLedgerDimension(cashDiscTransCodeDebit);
            }
            else
            {
                discLedgerDimension = CashDisc::receivedLedgerDimension(cashDiscTransCodeDebit);
            }

            if (discLedgerDimension != 0)
            {
                // check if ledger account exists in the chart of accounts
                accountExists = MainAccount::exist(LedgerDimensionFacade::getMainAccountFromLedgerDimension(discLedgerDimension).RecId);
            }

            // account doesn't exist for discount code so use the system cash discount account
            if (discLedgerDimension == 0 || !accountExists)
            {
                discLedgerDimension = SettlementUtility::cashDiscountSystemLedgerDimension(this.parmModule());
            }
        }

        return discLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscMethod</Name>
				<Source><![CDATA[
    abstract UnspecificSpecific cashDiscMethod()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscVat</Name>
				<Source><![CDATA[
    abstract boolean cashDiscVat()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCurDealCanBeSettled_RU</Name>
				<Source><![CDATA[
    protected boolean checkCurDealCanBeSettled_RU()
    {
        boolean ret = true;

        if ((! settlementPair.getCustVendTransDebit().bankCurrencyTransferId_RU() && settlementPair.getCustVendTransCredit().bankCurrencyTransferId_RU()) ||
            (! settlementPair.getCustVendTransCredit().bankCurrencyTransferId_RU() &&  settlementPair.getCustVendTransDebit().bankCurrencyTransferId_RU()))
        {
            ret = checkFailed("@GLS114419");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfCanBeSettled_RU</Name>
				<Source><![CDATA[
    protected boolean checkIfCanBeSettled_RU(TransDate _settlementDate)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkOverdueJournal_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if overdue journal exists, then takes the date of last journal and
    /// validates that overdue debt amount on that date will not be changed by settlement operation.
    /// </summary>
    /// <returns>
    /// True if check succeed(overdue debt will not change); Otherwise fase.
    /// </returns>
    /// <remarks>
    /// This check can be disabled by unmarking validate checkbox on <c>OverdueJournalSettings_W</c> form.
    /// </remarks>
    protected boolean checkOverdueJournal_W()
    {
        boolean ret = true;

        if (settlementPair.getCustVendTransDebit().Invoice)
        {
            ret = OverdueJournalSettings_W::canTransactionBePosted(settlementPair.getCustVendTransDebit(), settlementPair.getCustVendTransDebit().TransDate, settlementPair.getCustVendTransOpenDebit().DueDate, settlementPair.getTransactionDate());
        }
        if (settlementPair.getCustVendTransCredit().Invoice)
        {
            ret = ret && OverdueJournalSettings_W::canTransactionBePosted(settlementPair.getCustVendTransCredit(), settlementPair.getCustVendTransCredit().TransDate, settlementPair.getCustVendTransOpenCredit().DueDate, settlementPair.getTransactionDate());
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndPostDueToDueFromTaxExpense</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method is used to create a due to or from transaction when the tax company is different then wither the invoice or payment company.
    /// </summary>
    /// <param name="_companyToFindIn">
    ///     The company where the <c>LedgerInterCompany</c> record exists.
    /// </param>
    /// <param name="_companyRelated">
    ///     The company that has the intercompany relationship.
    /// </param>
    /// <param name="_transactionCurrencyCode">
    ///     The transaction currency code for creating the due to/from tax transaction.
    /// </param>
    /// <param name="_transactionCurrencyAmount">
    ///     Tax amount to post in transaction currency.
    /// </param>
    /// <param name="_accountingCurrencyAmount">
    ///     Tax amount to post in accounting currency.
    /// </param>
    /// <param name="_reportingCurrencyAmount">
    ///     Tax amount to post in reporting currency.
    /// </param>
    private void createAndPostDueToDueFromTaxExpense(
        CompanyId _companyToFindIn,
        CompanyId _companyRelated,
        CurrencyCode _transactionCurrencyCode,
        Money _transactionCurrencyAmount,
        MoneyMST _accountingCurrencyAmount,
        MoneyMST _reportingCurrencyAmount)
    {
        LedgerVoucher                   ledgerVoucherLocal;
        LedgerDimensionDefaultAccount   dueToFromLedgerDimension;
        LedgerDimensionAccount          ledgerDimensionMerged;
        LedgerInterCompany              interCompany;

        changecompany(_companyToFindIn)
        {
            ledgerVoucherLocal = settlementPair.findOrCreateLedgerVoucherByCompany(_companyToFindIn);

            // Find intercompany associated account
            dueToFromLedgerDimension = LedgerInterCompany::getDestinationCompanyLedgerDimensionWithAmount(
                _transactionCurrencyAmount,
                _companyRelated,
                _companyToFindIn);

            ledgerDimensionMerged   = LedgerDimensionFacade::serviceCreateLedgerDimension(dueToFromLedgerDimension);

            this.createLedgerVoucherTransObject(ledgerVoucherLocal, LedgerPostingType::CrossCompanySettlement, ledgerDimensionMerged, _transactionCurrencyCode, _transactionCurrencyAmount, _accountingCurrencyAmount, _reportingCurrencyAmount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCreditNoteForCashDiscount_CZ</Name>
				<Source><![CDATA[
    /// <summary>
    ///     The method creates <c>CustInvoiceJour</c> and <c>CustInvoiceTrans</c>
    ///     for discount trans <c>CustTrans</c>
    /// </summary>
    /// <param name="_custVendTrans">
    ///     Source  <c>CustTrans</c> record for discount trans
    /// </param>
    /// <param name="_discTrans">
    ///     Discount trans <c>CustTrans</c> record
    /// </param>
    /// <param name="_cashDiscAmountMst">
    ///     Discount amount value in MST
    /// </param>
    /// <param name="_discLedgerDimension">
    ///     LedgerDimensionDefaultAccount value for <c>CustInvoiceTrans</c>
    /// </param>
    /// <remarks>
    ///     Reverse document is used for Czech Republic
    /// </remarks>
    protected void createCreditNoteForCashDiscount_CZ(
        CustVendTrans                   _custVendTrans,
        CustTrans                       _discTrans,
        AmountMST                       _cashDiscAmountMst,
        LedgerDimensionDefaultAccount   _discLedgerDimension)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInterestFineCustVendTrans_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the fine transactions for the settlement.
    /// </summary>
    /// <param name="_dataareaid">
    /// Company to search the voucher
    /// </param>
    /// <param name="_fineAmountCur">
    /// The Fine amount in the transaction currency.
    /// </param>
    /// <param name="_fineAmountMst">
    /// The Fine amount in the monetary standard (MST) currency.
    /// </param>
    /// <param name="_custVendTrans">
    /// The CustVendTrans record used to create the transaction.
    /// </param>
    /// <param name="_exchRate">
    /// The exchange rate of the Fine
    /// </param>
    /// <param name="_transactionTxt">
    /// Transaction text of the transaction
    /// </param>
    /// <param name="_dimensionDefault">
    /// Default dimension of the transaction
    /// </param>
    /// <returns>
    /// Financial Fine created
    /// </returns>
    /// <remarks>
    /// fineTrans receives _custVendTrans.data() to transform finInterestTrans in cust or vend trans. interestFineTrans.clear() is called
    /// because the data is not needed, just the table type
    /// </remarks>
    private CustVendTrans createInterestFineCustVendTrans_BR(
        CompanyId          _dataareaid,
        AmountCur          _fineAmountCur,
        AmountMST          _fineAmountMst,
        CustVendTrans      _custVendTrans,
        ExchRate           _exchRate,
        TransactionTxt     _transactionTxt,
        DimensionDefault   _dimensionDefault)
    {
        CustVendTrans               interestFineTrans       = _custVendTrans.data();
        LedgerVoucher               ledgerVoucher;

        ledgerVoucher = settlementPair.findLedgerVoucherByCompany(_dataareaid);

        postingProfile                      = _custVendTrans.PostingProfile;

        interestFineTrans.clear();

        interestFineTrans.OffsetRecId        = _custVendTrans.RecId;
        interestFineTrans.AccountNum         = _custVendTrans.AccountNum;
        interestFineTrans.TransDate          = settlementPair.getTransactionDate();
        interestFineTrans.Closed             = CustVendTransData::construct(interestFineTrans).maxSettlementDate(settlementPair.getTransactionDate());
        interestFineTrans.Voucher            = ledgerVoucher.lastVoucher();
        interestFineTrans.Approved           = NoYes::Yes;
        interestFineTrans.Txt                = _transactionTxt.txt();

        interestFineTrans.CurrencyCode       = _custVendTrans.CurrencyCode;

        interestFineTrans.AmountCur          = -this.amount(_fineAmountCur);
        interestFineTrans.AmountMST          = -this.amount(_fineAmountMst);
        interestFineTrans.ExchRate           = _exchRate;

        interestFineTrans.SettleAmountMST    = interestFineTrans.AmountMST;
        interestFineTrans.SettleAmountCur    = interestFineTrans.AmountCur;

        interestFineTrans.Correct            = ledgerVoucher.findLedgerVoucherObject().parmCorrection();

        interestFineTrans.LastSettleDate     = interestFineTrans.TransDate;
        interestFineTrans.LastSettleVoucher  = _custVendTrans.Voucher;
        interestFineTrans.LastSettleCompany  = _custVendTrans.DataAreaId;
        interestFineTrans.LastSettleAccountNum   = _custVendTrans.AccountNum;

        interestFineTrans.DefaultDimension = _dimensionDefault;

        interestFineTrans.TransType             = LedgerTransType::Interest;
        interestFineTrans.PaymReference         = settlementPair.getCustVendTransCredit().PaymReference;
        interestFineTrans.ExchAdjustment        = 0;
        interestFineTrans.LastExchAdj           = dateNull();
        interestFineTrans.Invoice               = '';
        interestFineTrans.CashDiscCode          = '';
        interestFineTrans.PaymMode              = '';

        interestFineTrans.initFromPostingProfile(postingProfile);

        custVendTransSettlement.addTransAndDefaultSettlement(interestFineTrans, settlementGroupPlaceHolder);

        return interestFineTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerTransSum_RU</Name>
				<Source><![CDATA[
    public void createLedgerTransSum_RU(
        AmountMST                      _exchRateDiffPart,
        LedgerPostingType              _posting,
        LedgerDimensionDefaultAccount  _defaultAccount,
        CustVendTrans                  _exchRateTrans,
        boolean                        _postingOperations           = true,
        CustVendTransPostingLogType_RU _postingLogType              = CustVendTransPostingLogType_RU::ExchAmountDiff,
        Set                            _taxTransRecIDs              = null,
        DimensionDefault               _defaultDimension            = 0,
        CurrencyCode                   _currency                    = CompanyInfoHelper::standardCurrency(),
        LedgerVoucher                  _ledgerVoucher               = this.parmLedgerVoucher_W(),
        NoYes                          _correct                     = _exchRateTrans.Correct,
        AmountCur                      _amountCur                   = 0,
        CustVendTrans                  _custVendTransDebit          = settlementPair.getCustVendTransDebit(),
        CustVendTrans                  _custVendTransCredit         = settlementPair.getCustVendTransCredit(),
        boolean                        _unrealized                  = false,
        boolean                        _createUnrealizedPostingLog  = false,
        AmountMST                      _standardExchRateDiff        = 0,
        RefTableId                     _invoiceTransTableId         = 0,
        RefRecId                       _invoiceTransRecId           = 0,
        boolean                        _invoicePostingInherited     = false,
        boolean                        _postingToReporting          = false,
        LedgerDimensionAccount         _summaryLedgerDimension      = 0,
        Voucher                        _inventVoucher               = '',
        TransDate                      _inventDate                  = dateNull())
    {
        AmountMST                           amountMST              = CurrencyExchangeHelper::amount(_exchRateDiffPart);
        RTax25ExchAdjDimension              exchAdjDimension       = custVendExchAdjParm.rTax25ExchAdjDimension();
        LedgerPostingType                   posting                = CustVendExchAdjustment_W::getFinalPostingType(_posting, _postingLogType);
        DimensionDefault                    exchRateDiffDefaultDimension = _defaultDimension;
        LedgerVoucherObject                 ledgerVoucherObject;
        LedgerVoucherTransObject            ledgerVoucherTransObject;
        AmountMSTSecondary                  amountMSTSecondary;
        DimensionDefault                    summaryLedgerDimension;
        CustVendTransPostingLog_RU          custVendTransPostingLog;
        CustVendTrans_W                     custVendTrans_W = _exchRateTrans.CustVendTrans::getCustVendTrans_W();

        CustVendTransExchAdjDistController_RU   distributionController;
        ListEnumerator                          le;
        CustVendTransCorrespondentDistribution  distribution;
        CustVendTrans                           custVendTrans = settlementPair.getCustVendTransDebit().Invoice ? settlementPair.getCustVendTransDebit() : settlementPair.getCustVendTransCredit();
        LedgerPostingType                       balancePosting = custVendTrans.TableId == tableNum(VendTrans) ?
                                                    LedgerPostingType::VendBalance :
                                                    LedgerPostingType::CustBalance;

        if (! amountMST)
        {
            return;
        }

        ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
        ledgerVoucherObject.parmAccountingDate(_exchRateTrans.TransDate);

        if (_postingToReporting)
        {
            amountMSTSecondary  = amountMST;
            amountMST           = 0;
        }

        exchRateDiffDefaultDimension = LedgerDimensionDefaultFacade::serviceReplaceAttributeValue(
            exchRateDiffDefaultDimension,
            _postingToReporting && custVendTrans_W.DefaultDimensionReporting_RU
                ? custVendTrans_W.DefaultDimensionReporting_RU
                : _exchRateTrans.DefaultDimension,
            exchAdjDimension.getDimAttr().RecId);

        summaryLedgerDimension = _summaryLedgerDimension ? _summaryLedgerDimension :
            LedgerDimensionFacade::serviceCreateLedgerDimension(_exchRateTrans.summaryLedgerDimension(), _postingToReporting && custVendTrans_W.DefaultDimensionReporting_RU ? custVendTrans_W.DefaultDimensionReporting_RU : _exchRateTrans.DefaultDimension);

        distributionController = CustVendTransExchAdjDistController_RU::construct();
        distributionController.ledgerDimensionObtained += eventhandler(this.ledgerDimensionObtainedEventHandler);
        distributionController.parmDefaultOffsetLedgerDimension(
             LedgerDimensionFacade::serviceCreateLedgerDimension(_defaultAccount, exchRateDiffDefaultDimension));
        distributionController.parmSourceDocumentLine(TaxReverseTaxCustVendSettle_RU::sourceDocumentLine(_invoiceTransTableId, _invoiceTransRecId));
        distributionController.parmPreferNotDistributionForOffset(_invoiceTransTableId == tableNum(MarkupTrans));

        le = distributionController.generateDistributions(
            custVendTrans,
            balancePosting,
            _amountCur,
            this.amount(amountMST),
            this.amount(amountMSTSecondary),
            summaryLedgerDimension,
            _summaryLedgerDimension ? true : false).getEnumerator();

        while (le.moveNext())
        {
            distribution = le.current();
            if (_postingOperations)
            {
                ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicMST_RU(_ledgerVoucher.findLedgerVoucherObject(),
                                                                                    posting,
                                                                                    distribution.offsetLedgerDimension(),
                                                                                    _currency,
                                                                                    distribution.accountingAmount(),
                                                                                    _correct);

                ledgerVoucherTransObject.parmReportingCurrencyAmount(distribution.reportingAmount());
                _ledgerVoucher.addTrans(ledgerVoucherTransObject);
            }

            ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicMST_RU(_ledgerVoucher.findLedgerVoucherObject(),
                                                                                this.getLedgerPostingType_Balance(),
                                                                                distribution.ledgerDimension(),
                                                                                _currency,
                                                                                -1 * distribution.accountingAmount(),
                                                                                _correct);

            if (isInsidePostExchRateDiff
                && CurrencyLedgerGainLossFromNetValueFeature_PL::isEnabled()
                && (   ledgerVoucherTransObject.parmPostingType() == LedgerPostingType::CustBalance
                    || ledgerVoucherTransObject.parmPostingType() == LedgerPostingType::VendBalance))
            {
                ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::Summary);
            }

            ledgerVoucherTransObject.parmAmountMSTSecondary(-1 * distribution.reportingAmount());
            _ledgerVoucher.addTrans(ledgerVoucherTransObject);

            if (_postingOperations)
            {
                _ledgerVoucher.bondLast2_RU();
            }
            if (! _unrealized || _createUnrealizedPostingLog)
            {
                LedgerDimensionDefaultAccount defaultAccount = 0;

                if (_defaultAccount || _invoicePostingInherited)
                {
                    defaultAccount = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(distribution.offsetLedgerDimension());
                }
                else if (isInsidePostExchRateDiff && CurrencyLedgerGainLossFromNetValueFeature_PL::isEnabled())
                {
                    defaultAccount = exchRateDiffTaxMergedLedgerDimension;
                }

                custVendTransPostingLog = this.createPostingTransLog_RU(
                    _postingLogType,
                    _exchRateTrans,
                    _posting,
                    defaultAccount,
                    LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(distribution.ledgerDimension()),
                    distribution.accountingAmount(),
                    distribution.reportingAmount(),
                    _taxTransRecIDs,
                    (_defaultAccount || _invoicePostingInherited) ?
                        LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(distribution.offsetLedgerDimension()) :
                        0,
                    distribution.transactionAmount(),
                    _custVendTransDebit,
                    _custVendTransCredit,
                    (!_postingToReporting && _unrealized && _createUnrealizedPostingLog) ? - _standardExchRateDiff : 0,
                    ( _postingToReporting && _unrealized && _createUnrealizedPostingLog) ? - _standardExchRateDiff : 0,
                    _exchRateTrans.Voucher,
                    _exchRateTrans.TransDate,
                    _correct,
                    LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(distribution.ledgerDimension()),
                    false,
                    _invoiceTransTableId,
                    _invoiceTransRecId);

                if (_inventVoucher)
                {
                    custVendTransPostingLog.InventVoucher = _inventVoucher;
                    custVendTransPostingLog.InventDate    = _inventDate;
                    custVendTransPostingLog.doUpdate();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerVoucherObject_RU</Name>
				<Source><![CDATA[
    protected LedgerVoucherObject createLedgerVoucherObject_RU(LedgerVoucher _ledgerVoucher)
    {
        NumberSeq           numberSeq;
        LedgerVoucherObject ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU ]))
        {
            if (ledgerVoucherObject && ledgerVoucherObject.transElements() && !settlementPair.getIsNewSettlementVoucherCreated())
            {
                numberSeq           = NumberSeq::newGetVoucherFromCode(_ledgerVoucher.parmVoucherSeriesCode());
                ledgerVoucherObject = LedgerVoucherObject::newVoucher(numberSeq.voucher(),
                                                                      settlementPair.getTransactionDate(),
                                                                      _ledgerVoucher.parmSysModuleDefault(),
                                                                      ledgerVoucherObject.parmLedgerTransType());
                _ledgerVoucher.addVoucher(ledgerVoucherObject);
            }

            if (ledgerVoucherObject && ! ledgerVoucherObject.transElements())
            {
                ledgerVoucherObject.parmTransDate(settlementPair.getTransactionDate());
            }
        }

        return ledgerVoucherObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerVoucherTransObject</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method is used to create a new <c>LedgerVoucherTransObject</c> corresponding to tax or expense and add it to the <c>LedgerVoucher</c> for the current company.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///     The <c>LedgerVoucher</c> instance for the current company.
    /// </param>
    /// <param name="_ledgerPostingType">
    ///     Posting type to be used for the current posting.
    /// </param>
    /// <param name="_ledgerDimensionId">
    ///     <c>LedgerDimensionAccount</c> to be used for current posting.
    /// </param>
    /// <param name="_transactionCurrencyCode">
    ///     The transaction currency code.
    /// </param>
    /// <param name="_transactionCurrencyAmount">
    ///     Tax amount to post in transaction currency.
    /// </param>
    /// <param name="_accountingCurrencyAmount">
    ///     Tax amount to post in accounting currency.
    /// </param>
    /// <param name="_reportingCurrencyAmount">
    ///     Tax amount to post in reporting currency.
    /// </param>
    private void createLedgerVoucherTransObject(
        LedgerVoucher _ledgerVoucher,
        LedgerPostingType _ledgerPostingType,
        LedgerDimensionAccount _ledgerDimensionId,
        CurrencyCode _transactionCurrencyCode,
        Money _transactionCurrencyAmount,
        MoneyMST _accountingCurrencyAmount,
        MoneyMST _reportingCurrencyAmount)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
            _ledgerVoucher.findLedgerVoucherObject(),
            _ledgerPostingType,
            _ledgerDimensionId,
            _transactionCurrencyCode,
            _transactionCurrencyAmount,
            _accountingCurrencyAmount,
            _reportingCurrencyAmount);

        _ledgerVoucher.addTrans(ledgerVoucherTransObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPostingTransLog_RU</Name>
				<Source><![CDATA[
    public CustVendTransPostingLog_RU createPostingTransLog_RU(CustVendTransPostingLogType_RU    _postingLogType,
                                                               CustVendTrans                     _custVendTrans,
                                                               LedgerPostingType                 _posting,
                                                               LedgerDimensionDefaultAccount     _defaultAccount,
                                                               LedgerDimensionDefaultAccount     _offsetDefaultAccount,
                                                               AmountMST                         _amountMST,
                                                               AmountMSTSecondary                _amountMSTSecondary            = 0,
                                                               Set                               _taxTransRecIDs                = null,
                                                               DimensionDefault                  _defaultDimension              = 0,
                                                               AmountCur                         _amountCur                     = 0,
                                                               CustVendTrans                     _custVendTransDebit            = settlementPair.getCustVendTransDebit(),
                                                               CustVendTrans                     _custVendTransCredit           = settlementPair.getCustVendTransCredit(),
                                                               AmountMST                         _settlementExchAdj             = 0,
                                                               AmountMSTSecondary                _reportingSettlementExchAdj    = 0,
                                                               Voucher                           _voucher                       = _custVendTrans.Voucher,
                                                               TransDate                         _transDate                     = _custVendTrans.TransDate,
                                                               Correct                           _correct                       = _custVendTrans.Correct,
                                                               DimensionDefault                  _offsetDefaultDimension        = _custVendTrans.DefaultDimension,
                                                               NoYesId                           _reverseTrans                  = false,
                                                               RefTableId                        _invoiceTransTableId           = 0,
                                                               RefRecId                          _invoiceTransRecId             = 0,
                                                               boolean                           _isReportingCurrencyTax        = false)
    {
        CustVendSettlePostingLog_RU     postingLog;
        CustVendTransPostingLog_RU      custVendTransPostingLog;
        LedgerPostingType               posting = CustVendExchAdjustment_W::getFinalPostingType(_posting, _postingLogType);
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU ]))
        {
            postingLog = CustVendSettlePostingLog_RU::newCustVendSettle(_postingLogType,
                                                                        _custVendTrans,
                                                                        _custVendTransDebit,
                                                                        _custVendTransCredit);

            postingLog.parmTaxTransRecIDs(_taxTransRecIDs);
            postingLog.parmVoucher(_voucher);
            postingLog.parmTransDate(_transDate);
            postingLog.parmCorrect(_correct);
            postingLog.parmReverseTrans(_reverseTrans);
            postingLog.parmInvoiceTransRecId(_invoiceTransRecId);
            postingLog.parmInvoiceTransTableId(_invoiceTransTableId);
            postingLog.parmIsReportingCurrencyTax(_isReportingCurrencyTax);
            postingLog.parmCustVendSettle(this);

            postingLog.createTrans(posting,
                                   LedgerDimensionFacade::serviceCreateLedgerDimension(_defaultAccount, _defaultDimension),
                                   LedgerDimensionFacade::serviceCreateLedgerDimension(_offsetDefaultAccount, _offsetDefaultDimension),
                                   _custVendTrans.CurrencyCode,
                                   _amountCur,
                                   _amountMST,
                                   _amountMSTSecondary,
                                   0,
                                   _settlementExchAdj,
                                   _reportingSettlementExchAdj);

            custVendTransPostingLog = postingLog.transPostingLog();
        }

        return custVendTransPostingLog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSettlementToReverseUnrealExchAdj</Name>
				<Source><![CDATA[
    // Refactor: Move to SettlementPair and split into separate credit / debit methods.
    /// <summary>
    /// Creates CustVendSettlement record for the debit or credit transaction.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The CustVendTrans table used to create the settlement record.
    /// </param>
    /// <param name="_custVendTransOpen">
    /// The CustVendTransOpen table used to create the settlement record.
    /// </param>
    /// <param name="_settleAmountMst">
    /// The amount to settle in the monetary standard (MST) currency.
    /// </param>
    /// <param name="_settleAmountCur">
    /// The amount to settle in transaction currency.
    /// </param>
    /// <param name="_settleAmountReporting">
    /// The amount to settle in reporting currency.
    /// </param>
    /// <param name="_realizedExchAdj">
    /// The amount of the realized exchange adjustment.
    /// </param>
    /// <param name="_realizedReportingExchAdj">
    /// The amount of the realized exchange adjustment in reporting currency.
    /// </param>
    /// <param name="_cashDiscAmount">
    /// The amount of the cash discount in the transaction currency.
    /// </param>
    /// <param name="_cashDiscAmountMst">
    /// The amount of the cash discount in the MST currency.
    /// </param>
    /// <param name="_cashDiscAmountReporting">
    /// The amount of the cash discount in the reporting currency.
    /// </param>
    /// <param name="_canBeReversed">
    /// true if settlement can be reversed; otherwise, false.
    /// </param>
    /// <param name="_settleTax1099Amount">
    /// The tax 1099 amount to settle in transaction currency.
    /// </param>
    /// <param name="_settleTax1099StateAmount">
    /// The tax 1099 state amount to settle in transaction currency.
    /// </param>
    /// <param name="_taxVoucher">
    /// The Tax Voucher.
    /// The voucher number of tax operation created when settlement.
    /// </param>
    /// <param name="_vatTaxAgentAmountCur">
    /// The amount of the tax agent in the transaction currency.
    /// </param>
    /// <param name="_vatTaxAgentAmountMST">
    /// The amount of the tax agent in the MST currency.
    /// </param>
    /// <param name="_vatTaxAgentAmountReporting">
    /// The amount of the tax agent in the reporting currency.
    /// </param>
    /// <param name="_interestAmount">
    /// The interest amount.
    /// </param>
    /// <param name="_fineAmount">
    /// The fine amount.
    /// </param>

    /// <summary>
    /// Creates the CustVendSettlement record to reverse the unrealized exchange adjustment.
    /// </summary>
    /// <param name="_unrealizedAmount">
    /// The unrealized exchange adjustment amount.
    /// </param>
    /// <param name="_unrealizedReportingAmount">
    /// The unrealized exchange adjustment amount in reporting currency.
    /// </param>
    /// <param name="_custVendTrans">
    /// The CustVendTrans table used to create the settlement record.
    /// </param>
    /// <param name="_custVendTransOpen">
    /// The CustVendTransOpen table used to create the settlement record.
    /// </param>
    /// <param name="_settlementVoucher">
    /// The Voucher number of the settlement; optional.
    /// </param>
    protected void createSettlementToReverseUnrealExchAdj(
        AmountMST _unrealizedAmount,
        AmountMSTSecondary _unrealizedReportingAmount,
        CustVendTrans _custVendTrans,
        CustVendTransOpen _custVendTransOpen,
        Voucher _settlementVoucher = '')
    {
        // init buffer to correct CustSettlement or VendSettlement
        CustVendSettlement custVendSettlement = this.initCustVendSettlementBuffer();
        AmountMST localUnrealizedAmount = _unrealizedAmount;
        AmountMSTSecondary localUnrealizedReportingAmount = _unrealizedReportingAmount;

        Debug::assert(_custVendTrans.company() == curext());

        // Vendor transaction have their signs reversed so same code can be used for customer
        // and vendor transactions.
        this.reverseAmounts(_custVendTrans);

        // reverse signs if vendor
        localUnrealizedAmount = this.amount(localUnrealizedAmount);
        localUnrealizedReportingAmount = this.amount(localUnrealizedReportingAmount);

        custVendSettlement.clear();

        // set common fields
        custVendSettlement.AccountNum = _custVendTrans.AccountNum;
        custVendSettlement.OffsetTransVoucher = _custVendTrans.LastSettleVoucher;
        custVendSettlement.TransRecId = _custVendTrans.RecId;
        custVendSettlement.TransOpen = _custVendTransOpen.RecId;
        custVendSettlement.TransType = _custVendTrans.TransType;
        custVendSettlement.DueDate = _custVendTransOpen.DueDate;

        custVendSettlement.OffsetCompany = _custVendTrans.LastSettleCompany;
        custVendSettlement.OffsetAccountNum = _custVendTrans.LastSettleAccountNum;

        custVendSettlement.ExchAdjustment = -localUnrealizedAmount;
        custVendSettlement.ExchAdjustmentReporting = -localUnrealizedReportingAmount;

        custVendSettlement.TransDate = max(_custVendTrans.TransDate, _custVendTrans.LastSettleDate);
        custVendSettlement.CanBeReversed = NoYes::No;

        if (_settlementVoucher == '')
        {
            custVendSettlement.SettlementVoucher = settlementPair.findVoucherNumberByCompany(_custVendTrans.company());
        }
        else
        {
            custVendSettlement.SettlementVoucher = _settlementVoucher;
        }

        custVendTransSettlement.addSettlement(custVendSettlement, settlementGroupPlaceHolder, _custVendTrans.TransType);

        this.reverseAmounts(_custVendTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxPostingTransLog_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates records in <c>CustVendTransPostingLog_RU</c> table.
    /// </summary>
    /// <param name="_exchRateTrans">
    /// Cursor of CustVendTrans map.
    /// </param>
    /// <param name="_correction">
    /// true if operation is a coreection.
    /// </param>
    protected void createTaxPostingTransLog_RU(CustVendTrans _exchRateTrans, boolean _correction)
    {
        ListEnumerator                  le;
        AmountMST                       taxAmountAccounting;
        AmountMSTSecondary              taxAmountReporting;
        TaxBase                         taxBaseAmountReporting;
        LedgerDimensionDefaultAccount   defaultAccount;
        LedgerDimensionDefaultAccount   offsetDefaultAccount;
        TaxCode                         taxCode;
        CustVendTransPostingLog_RU      postingLog;

        if (!targetTaxLedgerParmsList)
        {
            return;
        }

        le = targetTaxLedgerParmsList.getEnumerator();
        while (le.moveNext())
        {
            [taxAmountAccounting, taxAmountReporting, defaultAccount, offsetDefaultAccount, taxCode, taxBaseAmountReporting] = le.current();

            ttsbegin;
            postingLog = this.createPostingTransLog_RU(
                CustVendTransPostingLogType_RU::ExchAdjustment,
                _exchRateTrans,
                LedgerPostingType::Tax,
                defaultAccount,
                offsetDefaultAccount,
                taxAmountAccounting,
                taxAmountReporting,
                null,
                0,
                0,
                settlementPair.getCustVendTransDebit(),
                settlementPair.getCustVendTransCredit(),
                0,
                0,
                _exchRateTrans.Voucher,
                _exchRateTrans.TransDate,
                _correction,
                0,
                false,
                0,
                0,
                true);

            postingLog.TaxCode                  = taxCode;
            postingLog.TaxBaseAmountReporting   = taxBaseAmountReporting;
            postingLog.update();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>crossCompanyTxt</Name>
				<Source><![CDATA[
    protected abstract LedgerTransTxt crossCompanyTxt()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>datePrinciple</Name>
				<Source><![CDATA[
    SettleDatePrinc datePrinciple(SettleDatePrinc _datePrinciple = datePrinciple)
    {
        datePrinciple = _datePrinciple;

        return datePrinciple;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineGTAExpenseAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines GTA Expense amount.
    /// </summary>
    /// <param name="_inventTransId">
    /// The id of the invent transaction.
    /// </param>
    /// <param name="_voucher">
    /// The instance of the <c>Voucher</c> class.
    /// </param>
    /// <param name="_taxCode">
    /// The tax code.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxAmountCur</c> class.
    /// </returns>
    public TaxAmountCur determineGTAExpenseAmount_IN(
        InventTransId _inventTransId,
        Voucher       _voucher,
        TaxCode       _taxCode,
        TransDate     _transDate)
    {
        TaxAmountCur                    expenseAmount;
        TaxTrans                        taxTransLoc;
        LedgerJournalTrans              ledgerJournalTransCopy;
        TaxTrans_IN                     taxTransIN ;
        TransTaxInformation             transTaxInformation;

        while select RecId, TaxAmountCur, TaxInCostPriceCur, SourceTaxAmountCur, Voucher, Source, InventTransId from taxTransLoc
            join InterimRecoverableLedgerDimension from taxTransIN
                where taxTransLoc.RecId         == taxTransIN.RefRecId
                   && taxTransLoc.Voucher       == _voucher
                   && taxTransLoc.TaxCode       == _taxCode
                   && taxTransLoc.InventTransId == _inventTransId
                   && taxTransLoc.TransDate     == _transDate
                   && taxTransIN.InterimRecoverableLedgerDimension != 0
        {
            if (taxTransLoc.Source == TaxModuleType::Voucher)
            {
                select firstonly Voucher from ledgerJournalTransCopy
                    where ledgerJournalTransCopy.Voucher                == _voucher;

                transTaxInformation = transTaxInformationHelper.getTransTaxInformationByRecord(ledgerJournalTransCopy);

                if (ledgerJournalTransCopy && transTaxInformation.ServiceTaxGTAServiceCategory  == GTAServiceCategory_IN::Others)
                {
                    expenseAmount += taxTransLoc.TaxAmountCur - taxTransLoc.TaxInCostPriceCur ;
                }
            }
            if (taxTransLoc.Source == TaxModuleType::Purch          ||
                taxTransLoc.Source == TaxModuleType::PurchInvoice)
            {
                if (VendInvoiceTrans::findInventTransId(taxTransLoc.InventTransId).gtaServiceCategory_IN == GTAServiceCategory_IN::Others)
                {
                    expenseAmount += taxTransLoc.TaxAmountCur - taxTransLoc.TaxInCostPriceCur ;
                }
            }
        }

        return expenseAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineTransDate</Name>
				<Source><![CDATA[
    protected TransDate determineTransDate(CustVendTrans custVendTrans)
    {
        TransDate transDate;
        LedgerJournalTrans ledgerJournalTrans;
        TaxTable    taxTable;
        TaxTrans    taxTrans;
        TaxTrans reversedTaxTrans;
        TaxTransGeneralJournalAccountEntry taxTransGeneralJournalAccountEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        DimensionAttributeValueCombination dimensionAttributeValueCombination, reversedDimensionAttributeValueCombination;

        transDate = custVendTrans.TransDate;

        // Taxes are not always added as of the CustVendTrans.TransDate.  It is possible to add taxes on an invoice register
        // or approval journals and each journal can have a different date.  Therefore, we need to find the 'correct' tax transaction
        // date so these transactiosn can be reversed durring settlements.  This query looks up related tax transactions, ensures
        // those transactions have not already been reversed and uses that tax transaction date.
        while select TableId, RecId from ledgerJournalTrans
            where ledgerJournalTrans.VendTransId == custVendTrans.RecId
        {
            select firstonly TaxCode, Voucher, TaxAmount, TransDate
                from taxTrans
                where taxTrans.SourceTableId == ledgerJournalTrans.TableId
                   && taxTrans.SourceRecId   == ledgerJournalTrans.RecId
                   && taxTrans.ExemptTax     == NoYes::No
                   && (taxTrans.TaxDirection == TaxDirection::IncomingTax
                   || taxTrans.TaxDirection  == TaxDirection::OutgoingTax
                   || taxTrans.TaxDirection  == TaxDirection::UseTax)
                join RecId from taxTable
                where taxTable.TaxCode        == taxTrans.TaxCode
                      && taxTable.PaymentTaxCode != ''
                      && taxTable.TaxBase        != TaxBaseType::AmountByUnit
                join firstonly RecId from taxTransGeneralJournalAccountEntry
                where taxTrans.RecId == taxTransGeneralJournalAccountEntry.TaxTrans &&
                      taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::Tax
                outer join RecId from generalJournalAccountEntry
                where generalJournalAccountEntry.RecId == taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry
                join  Hash, RecId from dimensionAttributeValueCombination
                where ((dimensionAttributeValueCombination.RecId == generalJournalAccountEntry.LedgerDimension && taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry) ||
                      (dimensionAttributeValueCombination.RecId == taxTransGeneralJournalAccountEntry.LedgerDimension && !taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry));

            if (dimensionAttributeValueCombination.RecId)
            {
                select firstonly RecId from reversedTaxTrans
                    where reversedTaxTrans.Voucher    == taxTrans.Voucher
                       && reversedTaxTrans.TaxOrigin  == TaxOrigin::TaxReversed
                       && reversedTaxTrans.TaxAmount  == -taxTrans.TaxAmount
                    join firstonly RecId from taxTransGeneralJournalAccountEntry
                    where taxTrans.RecId == taxTransGeneralJournalAccountEntry.TaxTrans
                        && taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::Tax
                    outer join RecId from generalJournalAccountEntry
                    where generalJournalAccountEntry.RecId == taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry
                    join RecId from reversedDimensionAttributeValueCombination
                    where (((reversedDimensionAttributeValueCombination.RecId == generalJournalAccountEntry.LedgerDimension && taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry) ||
                            (reversedDimensionAttributeValueCombination.RecId == taxTransGeneralJournalAccountEntry.LedgerDimension && !taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry)) &&
                             reversedDimensionAttributeValueCombination.Hash == dimensionAttributeValueCombination.Hash);

                if (reversedDimensionAttributeValueCombination.RecId == 0)
                {
                    transDate = taxTrans.TransDate;
                    break;
                }
            }
        }

        return transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogDatePrinciple</Name>
				<Source><![CDATA[
    boolean dialogDatePrinciple()
    {
        DialogField     dialogDatePrinciple;
        DialogField     dialogDate;
        Dialog          dialog = new Dialog("@SYS25511");

        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        // <GEERU>
        if (countryRegion_RU)
        {
            dialogDatePrinciple = dialog.addFieldValue(enumStr(SettleDatePrinc), datePrinciple, "@SYS114020" ,"@CashManagement:CashManagement_CustVendSettle_DialogHelpText_DatePrinciple_RU");
        }
        else
        {
            // </GEERU>
            dialogDatePrinciple = dialog.addFieldValue(enumStr(SettleDatePrinc), datePrinciple, "@SYS16700" ,"@CashManagement:CashManagement_CustVendSettle_DialogHelpText_DatePrinciple");
            // <GEERU>
        }
        // </GEERU>
        dialogDate          = dialog.addFieldValue(extendedTypeStr(TransDate), saveDate, "@SYS10396", "@SYS70502");

        if (dialog.run())
        {
            datePrinciple   = dialogDatePrinciple.value();
            saveDate        = dialogDate.value();
            // <GEERU>
            if (countryRegion_RU)
            {
                xSysLastValue::saveLast(this);
            }
            // </GEERU>
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>discTxtCustVend</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a <c>CustCashDiscCust</c> enum or <c>VendCashDiscVend</c> enum respectively.
    /// </summary>
    /// <returns>
    ///    An enum value from the <c>LedgerTransTxt</c> enum.
    /// </returns>
    /// <remarks>
    ///    The method is overridden in the derived methods. The parent method on the <c>CustVendSettle</c>
    ///    class is empty.
    /// </remarks>
    abstract LedgerTransTxt discTxtCustVend()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>discTxtLedger</Name>
				<Source><![CDATA[
    abstract LedgerTransTxt discTxtLedger()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchAdjTxt</Name>
				<Source><![CDATA[
    abstract LedgerTransTxt exchAdjTxt(LedgerJournalACType _ledgerJournalACType = LedgerJournalACType::Ledger)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustVendTransByRecID</Name>
				<Source><![CDATA[
    private CustVendTrans findCustVendTransByRecID(RefRecId _recID, CustVendTrans _map)
    {
        CustVendTrans custVendTrans = _map;

        select firstonly forupdate crosscompany custVendTrans
            where custVendTrans.RecId == _recID;

        return custVendTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findInvoice</Name>
				<Source><![CDATA[
    abstract CustVendInvoiceJour findInvoice(
        CustVendAC _custVendAC,
        InvoiceId  _invoiceId,
        Voucher    _voucher,
        TransDate  _transDate)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>findInvVoucherFrmPymtRelVoucher_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Invoice voucher using the payment related voucher and transDate.
    /// </summary>
    /// <param name="_voucher">
    /// The payment related voucher.
    /// </param>
    /// <param name="_transDate">
    /// The Payment transaction transDate.
    /// </param>
    /// <returns>
    /// Returns voucher of the invoice settled by payment.
    /// </returns>
    private Voucher findInvVoucherFrmPymtRelVoucher_IN(Voucher _voucher, TransDate _transDate)
    {
        VendTrans   vendTransInv;
        VendInvoiceJour vendInvoiceJour;
        LedgerTransVoucherLink  ledgerTransVoucherLink;
        LedgerTransVoucherLink  ledgerTransVoucherLinkRel;

        select firstonly LastSettleVoucher,Voucher from vendTransInv
        exists join vendInvoiceJour
            where vendInvoiceJour.LedgerVoucher  == vendTransInv.Voucher
               && vendInvoiceJour.InvoiceAccount == vendTransInv.AccountNum
               && vendInvoiceJour.PurchId != ''
        exists join ledgerTransVoucherLink
            where ledgerTransVoucherLink.Voucher == vendTransInv.LastSettleVoucher
        exists join ledgerTransVoucherLinkRel
            where ledgerTransVoucherLinkRel.Voucher   == _voucher
               && ledgerTransVoucherLinkRel.TransDate == _transDate
               && ledgerTransVoucherLink.RecId        == ledgerTransVoucherLinkRel.VoucherGroupId;

        return vendTransInv.Voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLedgerInterCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the <c>LedgerInterCompany</c> record for the specified parameters.
    /// </summary>
    /// <param name="_companyToFindIn">
    ///    The company where the <c>LedgerInterCompany</c> record exists.
    /// </param>
    /// <param name="_companyRelated">
    ///    The company that has the intercompany relationship.
    /// </param>
    /// <returns>
    ///    The <c>LedgerInterCompany</c> record.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The intercompany accounting relationship is missing.
    /// </exception>
    protected LedgerInterCompany findLedgerInterCompany(
        CompanyId _companyToFindIn,
        CompanyId _companyRelated)
    {
        return LedgerInterCompany::findCompanyPair(_companyToFindIn, _companyRelated);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLedgerJournalNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the ledger journal number for the specified parameter.
    /// </summary>
    /// <param name="_specTrans">
    ///    The <c>SpecTrans</c> record that is used to find the ledger journal number.
    /// </param>
    /// <returns>
    ///    The ledger journal number for the parameter.
    /// </returns>
    /// <remarks>
    ///    Retrieves a blank if there is no ledger journal transaction associated with the <paramref
    ///    name="_specTrans" />.
    /// </remarks>
    protected LedgerJournalId findLedgerJournalNum(SpecTrans _specTrans)
    {
        TransDate           transDate;
        Voucher             foreignVoucher;
        LedgerJournalACType accountType;
        RecId               ledgerDimension;
        LedgerJournalTrans  ledgerJournalTrans;
        container           companyContainer;

        // If the specTrans TableId is not LedgerJournalTrans there isn't a Journal Type
        if (_specTrans.getSpecSourceTableId() != tableNum(LedgerJournalTrans))
        {
            return '';
        }

        companyContainer = [_specTrans.SpecCompany];
        // Find the ledgerJournalTrans record for the SpecTrans spec set
        select firstonly crossCompany:companyContainer
            AccountType, LedgerDimension, ForeignVoucher, ForeignCompany, JournalNum, TransDate, DataAreaId
            from ledgerJournalTrans
            where ledgerJournalTrans.RecId == _specTrans.getSpecSourceRecId();

        // If the LedgerJournalTrans has a foreign voucher this means it was created by the intercompany
        // accounting posting.  Need to find the original LedgerJournalTrans in the foreign company.
        if (ledgerJournalTrans.ForeignVoucher != '' && ledgerJournalTrans.ForeignCompany != '')
        {
            transDate = ledgerJournalTrans.TransDate;
            foreignVoucher = ledgerJournalTrans.ForeignVoucher;
            accountType = ledgerJournalTrans.AccountType;
            ledgerDimension = ledgerJournalTrans.LedgerDimension;
            companyContainer = conNull();
            companyContainer = [ledgerJournalTrans.ForeignCompany];

            select firstonly crossCompany:companyContainer JournalNum, DataAreaId from ledgerJournalTrans
                where ledgerJournalTrans.Voucher == foreignVoucher
                   && ledgerJournalTrans.TransDate == transDate
                   && ledgerJournalTrans.AccountType == accountType
                   && ledgerJournalTrans.LedgerDimension == ledgerDimension;
        }
        return ledgerJournalTrans.JournalNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findNumberSequenceCodeByCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the number sequence code that is used to create settlement transaction voucher numbers for
    ///    the specified company.
    /// </summary>
    /// <param name="_company">
    ///    The Company ID used to find the number sequence code.
    /// </param>
    /// <returns>
    ///    The number sequence code for the company.
    /// </returns>
    public NumberSequenceCode findNumberSequenceCodeByCompany(CompanyId _company)     // Refactor: this method should be eliminated
    {
        return settlementPair.findNumberSequenceCodeByCompany(_company);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fineLedgerDimension_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the default ledger dimension account
    /// </summary>
    /// <param name="_custVendTrans">
    /// The <c>CustVendTrans</c> table record
    /// </param>
    /// <param name="_custVendTransOpen">
    /// The <c>CustVendTransOpen</c> table record
    /// </param>
    /// <param name="_fineAmount">
    /// A real value with the fine amount; optional
    /// </param>
    /// <returns>
    /// The default ledger dimension account
    /// </returns>
    protected LedgerDimensionDefaultAccount fineLedgerDimension_BR(
        CustVendTrans       _custVendTrans,
        CustVendTransOpen   _custVendTransOpen,
        AmountCur           _fineAmount = 0)
    {
        LedgerDimensionDefaultAccount ledgerDimension;
        boolean accountExists;

        if (_custVendTransOpen.FineAmount_BR || _fineAmount)
        {
            changecompany(_custVendTrans.company())
            {
                ledgerDimension = CustLedgerAccounts::findFineAccount_BR(_custVendTrans.AccountNum,
                                                                         _custVendTrans.PostingProfile);
                if (ledgerDimension)
                {
                    // check if ledger account exists in the chart of accounts
                    accountExists = MainAccount::exist(LedgerDimensionFacade::getMainAccountFromLedgerDimension(ledgerDimension).RecId);

                    if (accountExists)
                    {
                        return ledgerDimension;
                    }

                    // it doesn't exist in chart of accounts use the system account
                    return this.fineSystemAccount_BR();
                }
            }
        }

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fineLedgerDimensionCreditCompany_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Fine ledger account for the credit (payment) company.
    /// </summary>
    /// <param name="_custVendAccount">
    /// CustVendAccount to search for ledger account.
    /// </param>
    /// <param name="_postingProfile">
    /// Posting profile to search for ledger account.
    /// </param>
    /// <returns>
    /// The Fine ledger account.
    /// </returns>
    protected LedgerDimensionDefaultAccount fineLedgerDimensionCreditCompany_BR(CustVendAC _custVendAccount, PostingProfile _postingProfile)
    {
        LedgerDimensionDefaultAccount finInterestLedgerAccount;
        boolean accountExists;

        changecompany(settlementPair.getCreditCompany())
        {
            // check if Fine Account exists in the payment company and get the appropiate ledger account
            if (this.parmModule() == SysModule::Cust)
            {
                finInterestLedgerAccount = CustLedgerAccounts::findFineAccount_BR(_custVendAccount, _postingProfile);
            }
            else
            {
                finInterestLedgerAccount = VendLedgerAccounts::findFineAccount_BR(_custVendAccount, _postingProfile);
            }

            if (finInterestLedgerAccount)
            {
                // check if ledger account exists in the chart of accounts
                accountExists = MainAccount::exist(LedgerDimensionFacade::getMainAccountFromLedgerDimension(finInterestLedgerAccount).RecId);
            }

            // account doesn't exist for discount code so use the system cash discount account
            if (!finInterestLedgerAccount || !accountExists)
            {
                finInterestLedgerAccount = this.fineSystemAccount_BR();
            }
        }

        return finInterestLedgerAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fineSystemAccount_BR</Name>
				<Source><![CDATA[
    protected LedgerDimensionDefaultAccount fineSystemAccount_BR()
    {
        return LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::CustFine_BR);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fineTxtCustVend_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a correct enum depending on Vendor or Customer.
    /// </summary>
    /// <returns>
    ///    An enum value from the <c>LedgerTransTxt</c> enum.
    /// </returns>
    /// <remarks>
    ///    The method is overridden in the derived methods. The parent method on the <c>CustVendSettle</c> class is empty.
    /// </remarks>
    public LedgerTransTxt fineTxtCustVend_BR()
    {
        return LedgerTransTxt::CustFine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fineTxtLedger_BR</Name>
				<Source><![CDATA[
    public LedgerTransTxt fineTxtLedger_BR()
    {
        return LedgerTransTxt::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendName_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the name of third party related to the transaction.
    /// </summary>
    /// <param name="_accountNum">
    /// The account number of the party.
    /// </param>
    /// <returns>
    /// The name of the party.
    /// </returns>
    public str getCustVendName_BR(CustVendAC _accountNum)
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDifferentProfileSettlementTransText</Name>
				<Source><![CDATA[
    private TransactionTextLarge getDifferentProfileSettlementTransText(
        CustVendTrans   _custVendTrans,
        LedgerVoucher   _ledgerVoucher,
        LedgerTransTxt  _ledgerTransTxt)
    {
        TransactionTxt  transactionTxt;

        transactionTxt = TransactionTxt::construct();
        transactionTxt.setType(_ledgerTransTxt);
        transactionTxt.setVoucher(_custVendTrans.Voucher);
        transactionTxt.setDate(_ledgerVoucher.lastTransDate());
        transactionTxt.setKey1(_custVendTrans.AccountNum);
        transactionTxt.setFormLetter(_custVendTrans.Voucher);

        return transactionTxt.txt();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingType_Balance</Name>
				<Source><![CDATA[
    public abstract LedgerPostingType getLedgerPostingType_Balance()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingType_CashDisc</Name>
				<Source><![CDATA[
    public abstract LedgerPostingType getLedgerPostingType_CashDisc()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingType_ExchRate</Name>
				<Source><![CDATA[
    public abstract LedgerPostingType getLedgerPostingType_ExchRate(Amount exchRateDiff)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingType_Settlement</Name>
				<Source><![CDATA[
    public abstract LedgerPostingType getLedgerPostingType_Settlement()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReverseChargeExpenseAmt_IN</Name>
				<Source><![CDATA[
    private TaxAmountCur getReverseChargeExpenseAmt_IN(TaxTrans _taxTransPayable)
    {
        TaxTrans                taxTransRec;
        TaxTrans_IN             taxTransIN;
        TaxLedgerAccounts_IN    taxLedgerAccount;
        LedgerTransVoucherLink  ledgerTransVoucherLinkRel;
        LedgerTransVoucherLink  ledgerTransVoucherLinkMain;
        VendTrans               vendTransPymt;
        TaxAmountCur            expenseAmtCur;

        // Find the Expense Amount during the Invoice.
        while select firstonly SourceRegulateAmountCur, TaxCode, Voucher from taxTransRec
            where taxTransRec.SourceRegulateAmountCur > 0
        join LedgerDimension,TaxComponentTable from taxTransIN
            where taxTransIN.RefRecId == taxTransRec.RecId
                && taxTransIN.RefRecId == _taxTransPayable.RecId
                && taxTransIN.gtaServiceCategory == GTAServiceCategory_IN::Others
        exists join ledgerTransVoucherLinkRel
            where ledgerTransVoucherLinkRel.Voucher == _taxTransPayable.Voucher
        exists join ledgerTransVoucherLinkMain
            where ledgerTransVoucherLinkMain.RecId == ledgerTransVoucherLinkRel.VoucherGroupId
        exists join vendTransPymt// Vendtrans generated by Payment
            where vendTransPymt.LastSettleVoucher == ledgerTransVoucherLinkMain.Voucher
                && taxTransRec.Voucher == vendTransPymt.Voucher
                && taxTransRec.TaxCode == _taxTransPayable.TaxCode
        {
            select firstonly RecId from taxLedgerAccount
                 where taxLedgerAccount.LedgerDimension       == LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(taxTransIN.LedgerDimension)
                    && taxLedgerAccount.AccountType           == TaxAccountType_IN::ServiceTaxExpenseAccount
                    && taxLedgerAccount.TaxComponentTable     == taxTransIN.TaxComponentTable;
            if (taxLedgerAccount.RecId && !invoiceVoucherMap.exists(taxTransRec.TaxCode + taxTransRec.Voucher))
            {
                expenseAmtCur += taxTransRec.SourceRegulateAmountCur;
                invoiceVoucherMap.insert(taxTransRec.TaxCode + taxTransRec.Voucher, expenseAmtCur);
            }
            if (expenseAmtCur && !expenseAmtMap.exists(taxTransRec.TaxCode + _taxTransPayable.Voucher))
            {
                expenseAmtMap.insert(taxTransRec.TaxCode + _taxTransPayable.Voucher, expenseAmtCur); //Insert to the Map to identify, the ExpenseAccount for the taxCode has been deducted.
            }
        }

        return expenseAmtCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReverseChargeRecoverableAmt_IN</Name>
				<Source><![CDATA[
    private TaxAmountCur getReverseChargeRecoverableAmt_IN(TaxTrans _taxTransPayable)
    {
        TaxTrans                taxTransRec;
        LedgerTransVoucherLink  ledgerTransVoucherLink;
        LedgerTransVoucherLink  ledgerTransVoucherLinkRel;
        LedgerTransVoucherLink  ledgerTransVoucherLinkInv;
        LedgerTransVoucherLink  ledgerTransVoucherLinkRelInv;
        VendTrans               vendTransPymt;
        TaxAmountCur            taxAmountCur;

        // Find the recoverable Amount reversed during the Invoice.
        while select SourceRegulateAmountCur,TaxCode, Voucher from taxTransRec
            where taxTransRec.SourceRegulateAmountCur > 0
        exists join ledgerTransVoucherLinkRel
            where ledgerTransVoucherLinkRel.Voucher    == _taxTransPayable.Voucher
        exists join ledgerTransVoucherLink
            where ledgerTransVoucherLink.RecId  == ledgerTransVoucherLinkRel.VoucherGroupId
        exists join vendTransPymt
            where vendTransPymt.LastSettleVoucher == ledgerTransVoucherLink.Voucher
        exists join ledgerTransVoucherLinkInv
            where ledgerTransVoucherLinkInv.Voucher == vendTransPymt.Voucher
        exists join ledgerTransVoucherLinkRelInv
            where ledgerTransVoucherLinkRelInv.VoucherGroupId == ledgerTransVoucherLinkInv.VoucherGroupId
                && ledgerTransVoucherLinkRelInv.RecId         != ledgerTransVoucherLinkInv.RecId
                && taxTransRec.Voucher                        == ledgerTransVoucherLinkRelInv.Voucher
                && taxTransRec.TransDate                      == ledgerTransVoucherLinkRelInv.TransDate
                && taxTransRec.TaxCode                        == _taxTransPayable.TaxCode
        {
            // If the same invoice is settled using multiple payments, with
            if (!invoiceVoucherMap.exists(taxTransRec.TaxCode + taxTransRec.Voucher))
            {
                taxAmountCur += taxTransRec.SourceRegulateAmountCur;
                invoiceVoucherMap.insert(taxTransRec.TaxCode + taxTransRec.Voucher, taxAmountCur);
            }
            // The Map key is [TaxCode + Voucher]. Because same TaxCode can come for multiple partially settled payments. Adding Voucher
            // uniquly distingushes them and extract the already settled amount.
            if (taxAmountCur && !recoverableAmtMap.exists(taxTransRec.TaxCode + _taxTransPayable.Voucher))
            {
                recoverableAmtMap.insert(taxTransRec.TaxCode + _taxTransPayable.Voucher, taxAmountCur);
            }
        }

        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSettlementList_MX</Name>
				<Source><![CDATA[
    /// <summary>
    /// Selects list of settlements.
    /// </summary>
    /// <returns>list of settlements.</returns>
    protected List getSettlementList_MX()
    {
        List list = new List(Types::Container);
        ListEnumerator listEnumerator = custVendTransSettlement.getCustVendTransSettlementList_MX().getEnumerator();
        CustInvoiceJour custInvoiceJour, offsetCustInvoiceJour;
        boolean isRetail = isConfigurationKeyEnabled(configurationKeyNum(Retail));

        while (listEnumerator.moveNext())
        {
            RefTableId tableId;
            RefRecId recId;
            CompanyId company;

            [tableId, recId, company] = listEnumerator.current();

            CustVendSettlement custVendSettlement = new DictTable(tableId).makeRecord();
            CustTrans custTrans;
            CustTrans offsetCustTrans;

            if (isRetail)
            {
                select firstonly crosscompany custVendSettlement
                    where custVendSettlement.DataAreaId == company
                        && custVendSettlement.RecId == recId
                    join CancelledPayment, TransType, AmountCur, AccountNum, TransDate, Invoice, Voucher from custTrans
                        where custTrans.RecId == custVendSettlement.TransRecId
                        outer join custInvoiceJour
                            where custInvoiceJour.InvoiceId == custTrans.Invoice
                                && custInvoiceJour.InvoiceDate == custTrans.TransDate
                                && custInvoiceJour.InvoiceAccount == custTrans.AccountNum
                    join CancelledPayment, TransType, AmountCur, AccountNum, TransDate, Invoice, Voucher from offsetCustTrans
                        where offsetCustTrans.RecId == custVendSettlement.OffsetRecId
                        outer join offsetCustInvoiceJour
                            where offsetCustInvoiceJour.InvoiceId == offsetCustTrans.Invoice
                                && offsetCustInvoiceJour.InvoiceDate == offsetCustTrans.TransDate
                                && offsetCustInvoiceJour.InvoiceAccount == offsetCustTrans.AccountNum;
            }
            else
            {
                select firstonly crosscompany custVendSettlement
                    where custVendSettlement.DataAreaId == company
                        && custVendSettlement.RecId == recId
                    join CancelledPayment, TransType, AmountCur, AccountNum, TransDate, Invoice, Voucher from custTrans
                        where custTrans.RecId == custVendSettlement.TransRecId
                    join CancelledPayment, TransType, AmountCur, AccountNum, TransDate, Invoice, Voucher from offsetCustTrans
                        where offsetCustTrans.RecId == custVendSettlement.OffsetRecId;
            }

            if (!custTrans.CancelledPayment
                && !offsetCustTrans.CancelledPayment
                && !this.isPaymentReversalSettled_MX(custTrans, offsetCustTrans))
            {
                if (isRetail && EInvoicePost_MX::checkSourceIsRetail(custInvoiceJour ? custInvoiceJour : offsetCustInvoiceJour))
                {
                    continue;
                }

                list.addEnd([custVendSettlement, company]);
            }
        }

        return list;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPaymentReversalSettled_MX</Name>
				<Source><![CDATA[
    private boolean isPaymentReversalSettled_MX(CustTrans _custTrans, CustTrans _offsetCustTrans)
    {
        RefRecId refRecId, offsetRefRecId;
        RefTableId refTableId, offsetRefTableId;

        [refRecId, refTableId] = _custTrans.getInvoiceReference();
        [offsetRefRecId, offsetRefTableId] = _offsetCustTrans.getInvoiceReference();

        return (_custTrans.AmountCur > 0
            && (_custTrans.TransType == LedgerTransType::Payment
                || (_custTrans.TransType == LedgerTransType::GeneralJournal
                    && refTableId
                    && !EInvoiceJour_MX::existCFDIByRef(refTableId, refRecId))))
            || (_offsetCustTrans.AmountCur > 0
            && (_offsetCustTrans.TransType == LedgerTransType::Payment
                || (_offsetCustTrans.TransType == LedgerTransType::GeneralJournal
                    && offsetRefTableId
                    && !EInvoiceJour_MX::existCFDIByRef(offsetRefTableId, offsetRefRecId))));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxCompanyVoucherDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method is used to find all the vouchers, companies and transaction dates related to the invoice.
    /// </summary>
    /// <param name="_invoiceCompany">
    ///     The invoice company.
    /// </param>
    /// <param name="_invoiceVoucher">
    ///     The invoice voucher number.
    /// </param>
    /// <param name="_invoiceDate">
    ///     The invoice date.
    /// </param>
    /// <returns>
    ///     A set containing all the related vouchers, companies and transaction dates.
    /// </returns>
    /// <remarks>
    ///     Vouchers may have been created in multiple companies because tax is going to a different company then the invoice.
    /// </remarks>
    private Set getTaxCompanyVoucherDate(DataAreaId _invoiceCompany, Voucher _invoiceVoucher, TransDate _invoiceDate)
    {
        LedgerJournalTrans  ledgerJournalTrans;
        LedgerJournalTable  ledgerJournalTable;
        Voucher             searchByForeignVoucher;
        SelectableDataArea  searchByForeignCompany;
        Set                 companyVoucherDateSet = new Set(Types::Container);
        container           companyVoucherDateContainer;

        companyVoucherDateSet.add([_invoiceCompany, _invoiceVoucher, _invoiceDate]);

        // Find the LedgerJournalTrans record for the given voucher, company and trans date.
        select firstonly crossCompany ForeignVoucher, TransDate, ForeignCompany from ledgerJournalTrans
            join TaxObligationCompany from ledgerJournalTable
                where ledgerJournalTrans.Voucher == _invoiceVoucher
                    && ledgerJournalTrans.Company == _invoiceCompany
                    && ledgerJournalTrans.TransDate == _invoiceDate
                    && ledgerJournalTable.JournalNum == ledgerJournalTrans.JournalNum;

        // If TaxObligationCompany is Source or if this is not an intercompany scenario we always follow the vendor company to find the tax trans record.
        if (ledgerJournalTable.TaxObligationCompany == TaxObligationCompany::Destination)
        {
            if (ledgerJournalTrans.ForeignVoucher != "")
            {
                // ForeignVoucher exists, so put it in the set and continue to search all LedgerJournalTrans records that have the same ForeignVoucher and ForeignCompany.
                companyVoucherDateContainer = [ledgerJournalTrans.ForeignCompany, ledgerJournalTrans.ForeignVoucher, ledgerJournalTrans.TransDate];

                if (!companyVoucherDateSet.in(companyVoucherDateContainer))
                {
                    companyVoucherDateSet.add(companyVoucherDateContainer);
                }

                searchByForeignVoucher = ledgerJournalTrans.ForeignVoucher;
                searchByForeignCompany = ledgerJournalTrans.ForeignCompany;
            }
            else
            {
                // ForeignVoucher does not exist, so continue to search all LedgerJournalTrans records that have the same Voucher and Company as the ForeignVoucher and ForeignCompany.
                searchByForeignVoucher = _invoiceVoucher;
                searchByForeignCompany = _invoiceCompany;
            }

            while select crossCompany Voucher, Company, TransDate from ledgerJournalTrans
                where ledgerJournalTrans.ForeignVoucher == searchByForeignVoucher
                    && ledgerJournalTrans.ForeignCompany == searchByForeignCompany
                    && ledgerJournalTrans.TransDate == _invoiceDate
                    && !(ledgerJournalTrans.Voucher == _invoiceVoucher && ledgerJournalTrans.Company == _invoiceCompany)
            {
                companyVoucherDateContainer = [ledgerJournalTrans.Company, ledgerJournalTrans.Voucher, ledgerJournalTrans.TransDate];

                if (!companyVoucherDateSet.in(companyVoucherDateContainer))
                {
                    companyVoucherDateSet.add(companyVoucherDateContainer);
                }
            }
        }

        return companyVoucherDateSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes class variables for the settlement process.
    /// </summary>
    /// <param name="_company">
    /// The spec company of the <c>SpecTrans</c> records to find.
    /// </param>
    /// <param name="_tableId">
    /// The spec table ID of the <c>SpecTrans</c> records to find.
    /// </param>
    /// <param name="_recId">
    /// The spec record ID of the <c>SpecTrans</c> records to find.
    /// </param>
    protected void init(CompanyId _company, TableId _tableId, RecId _recId)
    {
        custVendTransSettlement = CustVendTransSettlement::construct(this.parmModule());
        custVendTransSettlement.setOriginator(_company, _tableId, _recId);

        fullSettlement = SettlementFullSettlement::construct(this.parmModule(), _company, _tableId, _recId);

        if (this.ledgerJournalACType() == LedgerJournalACType::Cust)
        {
            custVendTransSettlementControl = new RecordSortedList(tableNum(CustTrans));
        }
        else
        {
            custVendTransSettlementControl = new RecordSortedList(tableNum(VendTrans));
        }

        custVendTransSettlementControl.sortOrder(fieldNum(Common, RecId));

        vendTax1099Manager = new VendSettleTax1099Manager();

        rslTmpOverUnderReverseTax = new RecordSortedList(tableNum(TmpSettleOverUnderReverseTax));
        rslTmpOverUnderReverseTax.sortOrder(
            fieldNum(TmpSettleOverUnderReverseTax, RefCompany),
            fieldNum(TmpSettleOverUnderReverseTax, RefRecId),
            fieldNum(TmpSettleOverUnderReverseTax, PaymCompany),
            fieldNum(TmpSettleOverUnderReverseTax, PaymRefRecId));

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
            && LedgerParameters::find().JournalizingDefinitionEnableValue == NoYes::Yes)
        {
            custSettleJournalizingEntries = CustSettleJournalizingEntries::construct(_company, _tableId, _recId);
        }

        debitTransState = SettlementTransactionState::None;
        creditTransState = SettlementTransactionState::None;

        // update the cashDiscDate on trans open records that will be settled.
        this.updateCashDiscDate(_company, _tableId, _recId);

        // <GEERU>
        exchRateDiffCalcType = LedgerParameters::find().ExchRateDiffCalcType_W;
        // </GEERU>
        isSettleByLineEnabled = (this.moduleCustVend() == ModuleCustVend::Cust && CustParameters::find().MarkOpenInvoiceLine);

        debitSettleDistController = CustVendTransSettleDistController::construct(isSettleByLineEnabled);
        creditSettleDistController = CustVendTransSettleDistController::construct(isSettleByLineEnabled);

        //<GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            transTaxInformationHelper = TransTaxInformationHelper::newHelper();
        }
        //</GIN>

        settleNowState = CustVendSettleNowState::construct();

        settleNowState.setSpecCompany(_company);
        settleNowState.setSpecTableId(_tableId);
        settleNowState.setSpecRecId(_recId);
        settleNowState.setBrazilEnabled(BrazilParameters::isEnabled());
        settleNowState.setCountryRegion_RU(SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]));
        settleNowState.initializeAgreementSet(this.moduleCustVend());
        settleNowState.setSpecTransRecordCount(SpecTrans::getSpecTransCount(_company, _tableId, _recId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSettlementPair</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of settlement pair, which represents single debit-credit relationship.
    /// </summary>
    protected abstract void createSettlementPair()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSettlementPair</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the settlement pair.
    /// </summary>
    protected void initSettlementPair()
    {
        settlementPair.voucherAdded += eventhandler(this.voucherAddedEventHandler_PSN);
        settlementPair.setPreviousTotals(settlementPreviousTotals);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendSettlementBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Instantiates either a <c>CustSettlement</c> or a <c>VendSettlement</c>.
    /// </summary>
    /// <returns>
    ///    The new <c>CustSettlement</c> or <c>VendSettlement</c> instance.
    /// </returns>
    /// <remarks>
    ///    This method is overridden in the derived methods. The parent method on the <c>CustVendSettle</c>
    ///    class is empty.In the method <c>adjustCashDiscOnSettlement</c>, a <c>CustVendSettlement</c> map is
    ///    declared. In order to select on this, this method is called to instantiate a <c>CustSettlement</c>
    ///    or a <c>VendSettlement</c>
    /// </remarks>
    abstract CustVendSettlement initCustVendSettlementBuffer()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendSettlementOffsetVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Instantiates either a <c>CustSettlementOffsetVoucher</c> or a <c>VendSettlementOffsetVoucher</c>.
    /// </summary>
    /// <returns>
    ///    The new <c>CustSettlementOffsetVoucher</c> or <c>VendSettlementOffsetVoucher</c> instance.
    /// </returns>
    protected abstract CustVendSettlementOffsetVoucher initCustVendSettlementOffsetVoucher()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendTransBuffer</Name>
				<Source><![CDATA[
    protected abstract CustVendTrans initCustVendTransBuffer()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendTransOpenBuffer</Name>
				<Source><![CDATA[
    protected abstract CustVendTransOpen initCustVendTransOpenBuffer()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initForNewSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes variables when a settlement is started.
    /// </summary>
    /// <remarks>
    /// This method updates the transaction date and increments the settlement group placeholder.
    /// </remarks>
    protected void initForNewSettlement()
    {
        // <GEERU><GEECZ>
        SettleDatePrinc originalDatePrinciple = datePrinciple;
        boolean countryRegion_RUCZ;
        changecompany(settlementPair.getDebitCompany())
        {
            countryRegion_RUCZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]) || CurrencyLedgerGainLossFromNetValueFeature_PL::isEnabled();
        }
        // </GEECZ></GEERU>
        // <GIN>
        TaxWithholdTrans_IN taxWithholdTrans;
        CustVendTrans_W custVendTrans_W;
        // </GIN>

        settlementGroupPlaceHolder++;

        // <GEERU>
        if (TaxParameters::find().ReverseSettlementDatePrinciple_W || SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            datePrinciple = offsetVoucher.parmUseDatePrinciple_RU() ? this.datePrinciple() : SettleDatePrinc::DateOfPayment;
        }
        // </GEERU

        // set the transaction date based on date principle
        if (datePrinciple == SettleDatePrinc::DaysDate)
        {
            settlementPair.setTransactionDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        }
        else if (datePrinciple == SettleDatePrinc::SelectDate)
        {
            settlementPair.setTransactionDate(saveDate);
        }
        else
        {
            settlementPair.setTransactionDate(max(settlementPair.getCustVendTransOpenDebit().TransDate, settlementPair.getCustVendTransOpenCredit().TransDate));
        }

        // <GEERU><GEECZ>
        if (countryRegion_RUCZ)
        {
            datePrinciple = originalDatePrinciple;
        }
        // </GEECZ></GEERU>

        settlementPair.initForNewSettlement();

        // <GIN>
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            if (settlementPair.getDebitCompany() != settlementPair.getCreditCompany())
            {
                // For Withholding Tax Transaction.......
                custVendTrans_W = settlementPair.getCustVendTransCredit().CustVendTrans::getCustVendTrans_W();
                if (custVendTrans_W.tdsAmount_IN || custVendTrans_W.tcsAmount_IN)
                {
                    changecompany(settlementPair.getCreditCompany())
                    {
                        select firstonly taxWithholdTrans
                            where taxWithholdTrans.Voucher  == settlementPair.getCustVendTransCredit().Voucher
                                && taxWithholdTrans.Posted;
                        if (taxWithholdTrans)
                        {
                            throw error(strFmt("@GLS6642", settlementPair.getCreditCompany()));
                        }
                    }
                }
            }
        }
        // </GIN>

        dueToFromLedgerDimensionDebit = 0;
        dueToFromLedgerDimensionCredit = 0;

        cashDiscTransCodeDebit = '';
        cashDiscTransCodeCredit = '';

        // <GEERU><GEECZ>
        if (countryRegion_RUCZ)
        {
            firstCustVendTrans = (  TaxParameters::find().ExchRateDiffDocType_RU == CustVendExchRateDiffDocType_RU::Invoice         ||
                                    settlementPair.getCustVendTransDebit().TransDate                 <= settlementPair.getCustVendTransCredit().TransDate                   ||
                                    this.isExchAmountDiff_RU()                                                                      ||
                                    CustVendExchAdjustment_W::isAdvanceAdjustment(null, settlementPair.getCustVendTransDebit(), settlementPair.getCustVendTransCredit()) ?
                                        settlementPair.getCustVendTransDebit() : settlementPair.getCustVendTransCredit());

            if (firstCustVendTrans.CurrencyCode == CompanyInfoHelper::standardCurrency()
                && settlementPair.getCustVendTransDebit().CurrencyCode != settlementPair.getCustVendTransCredit().CurrencyCode)
            {
                firstCustVendTrans = firstCustVendTrans.RecId == settlementPair.getCustVendTransDebit().RecId ? settlementPair.getCustVendTransCredit() : settlementPair.getCustVendTransDebit();
            }
            else if (firstCustVendTrans.CurrencyCode != CompanyInfoHelper::standardCurrency()
                && settlementPair.getCustVendTransDebit().CurrencyCode == settlementPair.getCustVendTransCredit().CurrencyCode)
            {
                if (TaxParameters::find().ExchRateDiffDocType_RU == CustVendExchRateDiffDocType_RU::Invoice
                    && !settlementPair.getCustVendTransDebit().Prepayment
                    &&  settlementPair.getCustVendTransCredit().Invoice
                    && !firstCustVendTrans.Invoice)
                {
                    firstCustVendTrans = settlementPair.getCustVendTransCredit();
                }
            }

            custVendExchAdjParm = CustVendExchAdjParm_W::newFromParm(firstCustVendTrans,
                                                                    this.isExchAmountDiff_RU(),
                                                                    false,
                                                                    CustVendExchAdjustment_W::isAdvanceAdjustment(firstCustVendTrans,
                                                                                                                settlementPair.getCustVendTransDebit(),
                                                                                                                settlementPair.getCustVendTransCredit()) ?
                                                                        LedgerTransType::AdvanceAdjustment_RU : LedgerTransType::ExchAdjustment,
                                                                    false,
                                                                    this.isCurrencyDeal_RU());
        }
        // </GEECZ></GEERU>
        cashDiscLedgerDimensionDebit = 0;
        cashDiscLedgerDimensionCredit = 0;

        debitSettleDistController.parmSpecTransId(settlementPair.getSpecTransDebit().RecId);
        creditSettleDistController.parmSpecTransId(settlementPair.getSpecTransCredit().RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initJournalNumCashDisc</Name>
				<Source><![CDATA[
    void initJournalNumCashDisc(CustVendTrans _custVendTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method is called when no <c>SysLastValue</c> record can be found in
    ///    <c>xSysLastValue.GetLast</c>.
    /// </summary>
    /// <remarks>
    ///    There is no code in this method.
    /// </remarks>
    public void initParmDefault()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxTrans_IN</Name>
				<Source><![CDATA[
    private void initTaxTrans_IN(
        TaxTrans _taxTransCopy,
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerVoucher      _ledgerVoucher)
    {
        _taxTransCopy.TaxDirection = TaxDirection::IncomingTax;
        _taxTransCopy.Source       = TaxModuleType::Voucher;
        _taxTransCopy.TaxAmountCur = _taxTransCopy.TaxAmount;
        _taxTransCopy.SourceRegulateAmountCur = _taxTransCopy.TaxAmountCur;
        _taxTransCopy.Voucher                 = _ledgerVoucher.lastVoucher();
        _taxTransCopy.TransDate               = _ledgerJournalTrans.TransDate;
        _taxTransCopy.SourceTaxAmountCur      = _taxTransCopy.SourceRegulateAmountCur;
        _taxTransCopy.TaxOrigin               = TaxOrigin::Payment;
        _taxTransCopy.InventTransId           = '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxTransIN_IN</Name>
				<Source><![CDATA[
    private void initTaxTransIN_IN(
        TaxTrans_IN _taxTransSettle,
        TaxTrans _taxTransCopy,
        LedgerVoucher _ledgerVoucher,
        TaxTable _taxTable,
        TaxTrans _taxTrans,
        LedgerJournalTrans _ledgerJournalTrans,
        VendTrans _vendTrans,
        TaxTrans_IN _taxTransIN,
        CurrencyExchangeHelper _exchRateHelper)
    {
        _taxTransSettle.RefRecId                     = _taxTransCopy.RecId;
        _taxTransSettle.TaxCode                      = _taxTransCopy.TaxCode;
        _taxTransSettle.TaxDirection                 = _taxTransCopy.TaxDirection;
        _taxTransSettle.Source                       = TaxModuleType::Voucher;
        _taxTransSettle.Voucher                      = _ledgerVoucher.lastVoucher();
        _taxTransSettle.TaxLedgerAccountGroup        = _taxTable.TaxLedgerAccountGroup_IN;
        _taxTransSettle.TaxComponentTable            = _taxTable.TaxComponentTable_IN;
        _taxTransSettle.TaxType                      = TaxType_IN::ServiceTax;
        _taxTransSettle.TaxValue                     = _taxTrans.TaxValue;
        _taxTransSettle.JournalType                  = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalType;
        _taxTransSettle.JournalNum                   = _ledgerJournalTrans.JournalNum;
        _taxTransSettle.JournalName                  = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalName;
        _taxTransSettle.SourceTableId                = _vendTrans.TableId;
        _taxTransSettle.SourceRecId                  = _vendTrans.RecId;
        _taxTransSettle.Vendor                       = _ledgerJournalTrans.parmAccount();
        _taxTransSettle.TaxPeriod                    = _taxTrans.TaxPeriod;
        _taxTransSettle.InvoiceAccount               = settlementPair.getCustVendTransDebit().AccountNum;
        _taxTransSettle.SourceCurrencyCode           = _taxTrans.CurrencyCode;
        _taxTransSettle.TaxLedgerAccountGroup        = _taxTable.TaxLedgerAccountGroup_IN;
        _taxTransSettle.TaxGroup                     = _taxTransIN.TaxGroup;
        _taxTransSettle.TaxItemGroup                 = _taxTransIN.TaxItemGroup;
        _taxTransSettle.TransDate                    = _ledgerJournalTrans.TransDate;
        _taxTransSettle.TransactionAmount            = _ledgerJournalTrans.AmountCurCredit?_ledgerJournalTrans.AmountCurCredit:_ledgerJournalTrans.AmountCurDebit;
        _taxTransSettle.TaxAmountSecondary           = _exchRateHelper.calculateAccountingToReportingAdjustment(_taxTransCopy.CurrencyCode, _taxTransCopy.TaxAmount, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertAgreementRecordList_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a container to a set.
    /// </summary>
    /// <param name="_agreementSet">
    /// The set which the container is added to.
    /// </param>
    /// <param name="_custVendTrans">
    /// A record of CustVendTrans map.
    /// </param>
    protected void insertAgreementRecordList_RU(Set _agreementSet, CustVendTrans _custVendTrans)
    {
        if (_agreementSet)
        {
            _agreementSet.add([_custVendTrans.company(),
                this.moduleCustVend() == ModuleCustVend::Cust ?  ModuleSalesPurch::Sales : ModuleSalesPurch::Purch,
                AgreementHeaderExt_RU::findByDefaultDimension(_custVendTrans.DefaultDimension).RecId,
                _custVendTrans.AccountNum]);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertSettlementOffsetVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method is used to insert a record in the <c>CustSettlementOffsetVoucher</c> or <c>VendSettlementOffsetVoucher</c> table.
    ///     This record is used while reversing the settlement.
    /// </summary>
    /// <param name="_settlementCompany">
    ///     The company in which to create the settlement record in, either invoice or payment.
    /// </param>
    /// <param name="_accountNum">
    ///     Account number of customer or vendor.
    /// </param>
    /// <param name="_settlementVoucher">
    ///     Settlement voucher number from the invoice or payment company.
    /// </param>
    /// <param name="_offsetCompany">
    ///     The company where the related voucher was created.
    /// </param>
    /// <param name="_offsetVoucher">
    ///     The related voucher number, not similar to settlement voucher.
    /// </param>
    /// <param name="_settlementOffsetVoucherType">
    ///     The type of transaction this record corresponds to.
    /// </param>
    private void insertSettlementOffsetVoucher(
        CompanyId _settlementCompany,
        CustVendAC _accountNum,
        Voucher _settlementVoucher,
        CompanyId _offsetCompany,
        Voucher _offsetVoucher,
        CustVendSettlementOffsetVoucherType _settlementOffsetVoucherType)
    {
        CustVendSettlementOffsetVoucher custVendSettlementOffsetVoucher;

        if (!interCompanyReversalVouchers.in([_settlementCompany, _accountNum, _settlementVoucher, _offsetCompany, _offsetVoucher, _settlementOffsetVoucherType]))
        {
            changecompany(_settlementCompany)
            {
                custVendSettlementOffsetVoucher = this.initCustVendSettlementOffsetVoucher();
                custVendSettlementOffsetVoucher.AccountNum = _accountNum;
                custVendSettlementOffsetVoucher.SettlementVoucher = _settlementVoucher;
                custVendSettlementOffsetVoucher.OffsetCompany = _offsetCompany;
                custVendSettlementOffsetVoucher.OffsetVoucher = _offsetVoucher;
                custVendSettlementOffsetVoucher.OffsetTransDate = settlementPair.getTransactionDate();
                custVendSettlementOffsetVoucher.OffsetType = _settlementOffsetVoucherType;
                custVendSettlementOffsetVoucher.insert();
            }

            interCompanyReversalVouchers.add([_settlementCompany, _accountNum, _settlementVoucher, _offsetCompany, _offsetVoucher, _settlementOffsetVoucherType]);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interestLedgerDimension_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the interest ledger dimension
    /// </summary>
    /// <param name="_custVendTrans">
    /// The <c>CustVendTrans</c> table record
    /// </param>
    /// <param name="_custVendTransOpen">
    /// The <c>CustVendTransOpen</c> table record
    /// </param>
    /// <param name="_finInterestAmount">
    /// A real value with the fine interest amount
    /// </param>
    /// <returns>
    /// The default interest ledger dimension
    /// </returns>
    protected LedgerDimensionDefaultAccount interestLedgerDimension_BR(
        CustVendTrans       _custVendTrans,
        CustVendTransOpen   _custVendTransOpen,
        AmountCur           _finInterestAmount = 0)
    {
        LedgerDimensionDefaultAccount ledgerDimension;
        boolean accountExists;

        if (_custVendTransOpen.InterestAmount_BR
                || _finInterestAmount)
        {
            changecompany(_custVendTrans.company())
            {
                ledgerDimension = CustLedgerAccounts::findInterestAccount_BR(_custVendTrans.AccountNum,
                                                                             _custVendTrans.PostingProfile);
                if (ledgerDimension)
                {
                    // check if ledger account exists in the chart of accounts
                    accountExists = MainAccount::exist(LedgerDimensionFacade::getMainAccountFromLedgerDimension(ledgerDimension).RecId);

                    if (accountExists)
                    {
                        return ledgerDimension;
                    }

                    // it doesn't exist in chart of accounts use the system account
                    return this.interestSystemAccount_BR();
                }
            }
        }

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interestLedgerDimensionCreditCompany_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Interest ledger account for the credit (payment) company.
    /// </summary>
    /// <param name="_custVendAccount">
    /// CustVendAccount to search for ledger account.
    /// </param>
    /// <param name="_postingProfile">
    /// Posting profile to search for ledger account.
    /// </param>
    /// <returns>
    /// The Interest ledger account.
    /// </returns>
    protected LedgerDimensionDefaultAccount interestLedgerDimensionCreditCompany_BR(CustVendAC _custVendAccount,PostingProfile _postingProfile)
    {
        LedgerDimensionDefaultAccount   finInterestLedgerAccount;
        boolean         accountExists;

        changecompany(settlementPair.getCreditCompany())
        {
            // check if Interest Account exists in the payment company and get the appropiate ledger account
            if (this.parmModule() == SysModule::Cust)
            {
                finInterestLedgerAccount = CustLedgerAccounts::findInterestAccount_BR(_custVendAccount,
                                                                                      _postingProfile);
            }
            else
            {
                finInterestLedgerAccount = VendLedgerAccounts::findInterestAccount_BR(_custVendAccount,
                                                                                      _postingProfile);
            }
            if (finInterestLedgerAccount)
            {
                // check if ledger account exists in the chart of accounts
                accountExists = MainAccount::exist(LedgerDimensionFacade::getMainAccountFromLedgerDimension(finInterestLedgerAccount).RecId);
            }

            // account doesn't exist for discount code so use the system cash discount account
            if (!finInterestLedgerAccount || !accountExists)
            {
                finInterestLedgerAccount = this.interestSystemAccount_BR();
            }
        }

        return finInterestLedgerAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interestSystemAccount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the interest system account
    /// </summary>
    /// <returns>
    /// The default interest system account
    /// </returns>
    protected LedgerDimensionDefaultAccount interestSystemAccount_BR()
    {
        return LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::CustInterest);
    }

]]></Source>
			</Method>
			<Method>
				<Name>interestTxtCustVend_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a correct enum depending on Vendor or Customer.
    /// </summary>
    /// <returns>
    ///    An enum value from the <c>LedgerTransTxt</c> enum.
    /// </returns>
    /// <remarks>
    ///    The method is overridden in the derived methods. The parent method on the <c>CustVendSettle</c> class is empty.
    /// </remarks>
    public LedgerTransTxt interestTxtCustVend_BR()
    {
        return LedgerTransTxt::CustInterest;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interestTxtLedger_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the transaction text type for financial interest
    /// </summary>
    /// <returns>
    /// The transaction text type
    /// </returns>
    public LedgerTransTxt interestTxtLedger_BR()
    {
        return LedgerTransTxt::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventSumAdjustOnAmountDiff_RU</Name>
				<Source><![CDATA[
    public void inventSumAdjustOnAmountDiff_RU(VendInvoiceTrans              _vendInvoiceTrans,
                                               AmountMST                     _amount,
                                               AmountMSTSecondary            _amountSec,
                                               Voucher                       _voucher,
                                               Voucher                       _invoiceVoucher,
                                               LedgerPostingType             _operationsPosting = LedgerPostingType::None,
                                               LedgerDimensionDefaultAccount _operationDefaultAccount = 0,
                                               LedgerVoucher                 _ledgerVoucher = null)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBadDebtAmortisation_RU</Name>
				<Source><![CDATA[
    private boolean isBadDebtAmortisation_RU()
    {
        return (settlementPair.getCustVendTransDebit().TransType  == LedgerTransType::RTax25_BadDebtDebitAmortisation    ||
                settlementPair.getCustVendTransDebit().TransType  == LedgerTransType::RTax25_BadDebtCreditAmortisation   ||
                settlementPair.getCustVendTransCredit().TransType == LedgerTransType::RTax25_BadDebtDebitAmortisation    ||
                settlementPair.getCustVendTransCredit().TransType == LedgerTransType::RTax25_BadDebtCreditAmortisation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCurrencyDeal_RU</Name>
				<Source><![CDATA[
    protected boolean isCurrencyDeal_RU()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isExchAmountDiff_RU</Name>
				<Source><![CDATA[
    public boolean isExchAmountDiff_RU()
    {
        boolean ret;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            ret = settlementPair.getCustVendTransDebit().CurrencyCode != CompanyInfoHelper::standardCurrency()
                    && settlementPair.getCustVendTransDebit().Invoice
                    && settlementPair.getCustVendTransCredit().CurrencyCode == CompanyInfoHelper::standardCurrency()
                    && ! settlementPair.getCustVendTransCredit().Invoice;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isGTAPartialPaym_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if it is the GTA partial payment.
    /// </summary>
    /// <param name="_taxTransLoc">
    /// The instance of the <c>TaxTrans</c> class.
    /// </param>
    /// <param name="_componentTransactions">
    /// The components of the transaction.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxAmount</c> class.
    /// </returns>
    public TaxAmount isGTAPartialPaym_IN(TaxTrans                       _taxTransLoc,
                                         ComponentTransactions_IN       _componentTransactions)
    {
        real factor = 1;

        if (_componentTransactions.PayableAmount != _taxTransLoc.TaxAmount)
        {
            factor = abs(_componentTransactions.PayableAmount)/abs(_taxTransLoc.TaxAmount);
        }
        else
        {
            factor =  1;
        }

        return factor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isGTAPartialPaymAdv_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if it is the GTA partial payment.
    /// </summary>
    /// <param name="_taxTransLoc">
    /// The instance of the <c>TaxTrans</c> class.
    /// </param>
    /// <param name="_detailTrans">
    /// The TaxSalesTaxPaymentHistoryDetailsTrans_IN.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxAmount</c> class.
    /// </returns>
    public TaxAmount isGTAPartialPaymAdv_IN(TaxTrans                                    _taxTransLoc,
                                            TaxSalesTaxPaymentHistoryDetailsTrans_IN    _detailTrans)
    {
        real factor = 1;

        if (_detailTrans.PayableAmountMST != _taxTransLoc.TaxAmount)
        {
            factor = abs(_detailTrans.PayableAmountMST)/abs(_taxTransLoc.TaxAmount);
        }
        else
        {
            factor =  1;
        }

        return factor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSettlementActive_W</Name>
				<Source><![CDATA[
    public boolean isSettlementActive_W()
    {
        return isSettlementActive;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueDataAreaId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns <c>curext()</c>, which is the current company code.
    /// </summary>
    /// <returns>
    ///    The current company code.
    /// </returns>
    public DataAreaId lastValueDataAreaId()
    {
        return curext();
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueDesignName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a blank value of the extended data type <c>identifiername</c>.
    /// </summary>
    /// <returns>
    ///    An <c>identifiername</c>, always blank.
    /// </returns>
    public IdentifierName lastValueDesignName()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueElementName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the classname of the instance "this".
    /// </summary>
    /// <returns>
    ///    The classname of the instance "this".
    /// </returns>
    public IdentifierName lastValueElementName()
    {
        return classId2Name(classIdGet(this));
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the enumeration <c>UtilElementType</c> "Class".
    /// </summary>
    /// <returns>
    ///    The enumeration <c>UtilElementType::Class</c>.
    /// </returns>
    public UtilElementType lastValueType()
    {
        return UtilElementType::Class;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueUserId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the current user ID.
    /// </summary>
    /// <returns>
    ///    The current user ID.
    /// </returns>
    public UserId lastValueUserId()
    {
        return curUserId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDimensionObtainedEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Overrides account to profitLoss if _isOffset, dimension to RTax25
    /// </summary>
    /// <param name="_isOffset">
    ///  is the LedgerDimensionAccount refers to offset
    /// </param>
    /// <param name="_anyType">
    ///    reference to LedgerDimensionAcount
    /// </param>
    public void ledgerDimensionObtainedEventHandler(boolean _isOffset, SysAnyType _anyType)
    {
        LedgerDimensionAccount  ledgerDimension         = _anyType.value();
        DimensionDefault        ledgerDefaultDimension;
        ledgerDefaultDimension = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(ledgerDimension);
        ledgerDefaultDimension = custVendExchAdjParm.rTax25ExchAdjDimension().getDefaultDimension(ledgerDefaultDimension);
        _anyType.value(LedgerDimensionFacade::serviceCreateLedgerDimension(LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(ledgerDimension), ledgerDefaultDimension));
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalACType</Name>
				<Source><![CDATA[
    abstract LedgerJournalACType ledgerJournalACType()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerPostingType_W</Name>
				<Source><![CDATA[
    abstract public LedgerPostingType ledgerPostingType_W()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerTransactionType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ledger transaction type of the settlement.
    /// </summary>
    /// <returns>The <c>LedgerTransType</c> of the settlement.</returns>
    public LedgerTransType ledgerTransactionType()
    {
        return settlementPair.getLedgerTransactionType();
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxInaccurateAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the maximum amount an invoice and payment may differ during settlement.
    /// </summary>
    /// <param name = "_company">The company in which the maximum difference amount is defined.</param>
    /// <returns>The real amount that an invoice and payment may differ by during settlement.</returns>
    public AmountMST maxInaccurateAmountMST(CompanyId _company = curext())
    {
        AmountMST maxInaccurateAmount;

        changecompany(_company)
        {
            maxInaccurateAmount = SettlementUtility::maxInaccurateAmountMST(this.parmModule());
        }

        return maxInaccurateAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxMSTDiff</Name>
				<Source><![CDATA[
    abstract AmountCur maxMSTDiff()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxPennyDiff</Name>
				<Source><![CDATA[
    abstract AmountMST maxPennyDiff()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCalcOutOfBalanceWriteOff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the amount that is being written off, if a sales order has been
    /// released from the out of balance workbench.
    /// </summary>
    /// <param name="_salesTableRecId">
    /// The record ID of the <c>SalesTable</c> record used to
    /// create the <c>MCRCustPaymTotals</c> object.
    /// </param>
    public void mcrCalcOutOfBalanceWriteOff(RefRecId _salesTableRecId)
    {
        MCRCustPaymTotals custPaymTotals = MCRCustPaymTotals::construct(tableNum(SalesTable), _salesTableRecId);

        if (custPaymTotals)
        {
            writeOffAmount = custPaymTotals.getTotalSalesAmount() - custPaymTotals.getTotalPaymAmount();
        }
        else
        {
            writeOffAmount = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>moduleCustVend</Name>
				<Source><![CDATA[
    protected abstract ModuleCustVend moduleCustVend()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>mstDiffTxtLedger</Name>
				<Source><![CDATA[
    abstract LedgerTransTxt mstDiffTxtLedger()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustOffsetOriginalSummaryDistributions</Name>
				<Source><![CDATA[
    protected boolean mustOffsetOriginalSummaryDistributions(
        boolean _debitHasMultipleSummaryEntries,
        boolean _creditHasMultipleSummaryEntries)
    {
        boolean postingProfileMismatch;
        boolean debitHasSourceDocumentData;
        boolean creditHasSourceDocumentData;
        List    debitPostedDistributions;
        List    creditPostedDistributions;
        LedgerDimensionAccount  debitDefaultLedgerDimension;
        LedgerDimensionAccount  creditDefaultLedgerDimension;
        boolean mustOffset = false;
        boolean countryRegion_RUEE;
        boolean countryRegion_IN;
        boolean offsetOriginalSummaryDistributions = true;
        CustVendTransDistributionController debitController;
        CustVendTransDistributionController creditController;
        boolean arePostingDefinitionsEnabledForPubSect = isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && LedgerParameters::find().JournalizingDefinitionEnableValue == NoYes::Yes;

        // Posting profile difference transactions are not needed in a cross company settlement because the due to/from transactions
        // will be done instead.
        if (settlementPair.getDebitCompany() == settlementPair.getCreditCompany())
        {
            // Core wants to default settlements to offset the original summary distributions.  Public Sector and
            // specific country regions have specialized logic for these scenarios.  Core does not want to impact
            // their current behavior.
            countryRegion_RUEE = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ, #isoEE, #isoHU, #isoLT, #isoLV]);
            if (countryRegion_RUEE)
            {
                offsetOriginalSummaryDistributions = false;
            }

            postingProfileMismatch = (settlementPair.getCustVendTransDebit().PostingProfile != settlementPair.getCustVendTransCredit().PostingProfile);
            debitHasSourceDocumentData = CustVendTransDistributionController::custVendTransHasSourceDocumentData(settlementPair.getCustVendTransDebit());
            creditHasSourceDocumentData = CustVendTransDistributionController::custVendTransHasSourceDocumentData(settlementPair.getCustVendTransCredit());

            if (offsetOriginalSummaryDistributions || postingProfileMismatch || debitHasSourceDocumentData || creditHasSourceDocumentData)
            {
                // get the posted distribution data from the controller now so we can detect need to post summary distributions
                // Note: Controller consumers generally allow posted distribution data to be discovered automatically. The results are cached on the controller and
                // will be used later if needed.

                debitDefaultLedgerDimension = this.determineDefaultSummaryDebitLedgerDimensionAccount();
                creditDefaultLedgerDimension = this.determineDefaultSummaryCreditLedgerDimensionAccount();

                countryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
                if (!countryRegion_IN && (arePostingDefinitionsEnabledForPubSect || EmplParameters_RU::enableAdvanceHolders()))
                {
                    if (!this.validateMultipleSummaryEntries(_debitHasMultipleSummaryEntries , _creditHasMultipleSummaryEntries)
                        && !FeatureStateProvider::isFeatureEnabled(AllowToSettleMultipleSummaryEntriesFeature_W::instance()))
                    {
                        return false;
                    }

                    if (arePostingDefinitionsEnabledForPubSect)
                    {
                        debitSettleDistController.parmUseGeneralLedgerDistribution(settlementPair.getCustVendTransDebit().TransType == LedgerTransType::Interest ||
                                                                                            settlementPair.getCustVendTransDebit().TransType == LedgerTransType::Tax);
                    }

                    // <GEERU><GEEU>
                    if (EmplParameters_RU::enableAdvanceHolders())
                    {
                        debitSettleDistController.parmAlernativeBalancePostingType(LedgerPostingType::EmplBalance_RU);
                        creditSettleDistController.parmAlernativeBalancePostingType(LedgerPostingType::EmplBalance_RU);
                        debitSettleDistController.parmUsePreciseComparison(true);
                        creditSettleDistController.parmUsePreciseComparison(true);
                    }
                    // </GEERU></GEEU>
                    debitPostedDistributions = debitSettleDistController.getDistributionFactors(
                        settlementPair.getCustVendTransDebit(),
                        this.getLedgerPostingType_Balance(),
                        debitDefaultLedgerDimension,
                        _debitHasMultipleSummaryEntries);

                    creditPostedDistributions = creditSettleDistController.getDistributionFactors(
                        settlementPair.getCustVendTransCredit(),
                        this.getLedgerPostingType_Balance(),
                        creditDefaultLedgerDimension,
                        _creditHasMultipleSummaryEntries);

                    mustOffset = debitSettleDistController.distributionDifferencesExist(creditSettleDistController);
                }
                else
                {
                    debitController = CustVendTransDistributionController::constructForSettlement(isSettleByLineEnabled, settlementPair.getSpecTransDebit().RecId);
                    debitPostedDistributions = debitController.getDistributionFactorsForPostingTypes(
                            settlementPair.getCustVendTransDebit(),
                            this.getLedgerPostingTypes_Balance(),
                            debitDefaultLedgerDimension,
                            _debitHasMultipleSummaryEntries);

                    creditController = CustVendTransDistributionController::constructForSettlement(isSettleByLineEnabled, settlementPair.getSpecTransCredit().RecId);
                    creditPostedDistributions = creditController.getDistributionFactorsForPostingTypes(
                            settlementPair.getCustVendTransCredit(),
                            this.getLedgerPostingTypes_Balance(),
                            creditDefaultLedgerDimension,
                            _creditHasMultipleSummaryEntries);

                    mustOffset = debitController.distributionDifferencesExist(creditController);
                }
            }
        }

        return mustOffset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateMultipleSummaryEntries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for multiple entries.
    /// </summary>
    /// <param name = "_debitHasMultipleSummaryEntries">A boolean flag to check multiple debit summary entries.</param>
    /// <param name = "_creditHasMultipleSummaryEntries">A boolean flag to check multiple credit summary entries.</param>
    /// <returns>true if multiple debit or credit summary entries; otherwise, false.</returns>
    protected boolean validateMultipleSummaryEntries (boolean _debitHasMultipleSummaryEntries, boolean _creditHasMultipleSummaryEntries)
    {
        return _debitHasMultipleSummaryEntries || _creditHasMultipleSummaryEntries ? false : true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDefaultSummaryDebitLedgerDimensionAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine the default debit summary ledger dimension account.
    /// </summary>
    /// <returns>The default debit summary ledger dimension account.</returns>
    protected LedgerDimensionAccount determineDefaultSummaryDebitLedgerDimensionAccount()
    {
        return LedgerDimensionFacade::serviceCreateLedgerDimension(settlementPair.getCustVendTransDebit().summaryLedgerDimension(), settlementPair.getCustVendTransDebit().DefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDefaultSummaryCreditLedgerDimensionAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine the default credit summary ledger dimension account.
    /// </summary>
    /// <returns>The default credit summary ledger dimension account.</returns>
    protected LedgerDimensionAccount determineDefaultSummaryCreditLedgerDimensionAccount()
    {
        return LedgerDimensionFacade::serviceCreateLedgerDimension(settlementPair.getCustVendTransCredit().summaryLedgerDimension(), settlementPair.getCustVendTransCredit().DefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>voucherAddedEventHandler_PSN</Name>
				<Source><![CDATA[
    private void voucherAddedEventHandler_PSN(str _voucher)
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
            && LedgerParameters::find().JournalizingDefinitionEnableValue == NoYes::Yes)
        {
            custVendTransSettlement.parmVoucherToBeProcessed().insert(_voucher, settlementPair.getCustVendTransCredit());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>CustVendSettle</c> class.
    /// </summary>
    protected void new()
    {
        settlementPreviousTotals = SettlementPreviousTotals::construct();
        remainingOpenAmounts = SettlementRemainingOpenAmounts::construct();
        cashDiscountAmounts = SettlementCashDiscountAmounts::construct();
        bankChequePaymTransCache = new SettlementPairBankChequePaymTrans();

        this.createSettlementPair();
        this.initSettlementPair();

        // <GTH>
        isAverageVATEnabled     = TaxThaiGovCertificationFeatureChecker::isAverageVATEnabled();
        isUnrealizedVATEnabled  = TaxThaiGovCertificationFeatureChecker::isUnrealizedVATEnabled();
        // </GTH>

        // <GEERU></GEECZ>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]))
        {
            xSysLastValue::getLast(this);
        }
        // </GEECZ></GEERU>

        interCompanyReversalVouchers = new Set(Types::Container);

        reversePostingLogSet = new Set(Types::Int64);

        settlePendingJournalizationLogger = CustVendSettlePendingJournalizationInstrumentationLogger::createLogger();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Serializes the current instance of the <c>CustVendSettle</c> class.
    /// </summary>
    /// <returns>
    ///    A container that contains the current instance of the <c>CustVendSettle</c> class.
    /// </returns>
    public container pack()
    {
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankTransactionTypes</Name>
				<Source><![CDATA[
    public BankTransactionTypes parmBankTransactionTypes(BankTransactionTypes _bankTransactionTypes = bankTransactionTypes)
    {
        bankTransactionTypes = _bankTransactionTypes;

        return bankTransactionTypes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendExchAdjParm_W</Name>
				<Source><![CDATA[
    public CustVendExchAdjParm_W parmCustVendExchAdjParm_W(CustVendExchAdjParm_W _custVendExchAdjParm = custVendExchAdjParm)
    {
        custVendExchAdjParm = _custVendExchAdjParm;

        return custVendExchAdjParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendTransCredit_W</Name>
				<Source><![CDATA[
    public CustVendTrans parmCustVendTransCredit_W(CustVendTrans _custVendTransCredit = settlementPair.getCustVendTransCredit())
    {
        settlementPair.setCustVendTransCredit(_custVendTransCredit);
        return settlementPair.getCustVendTransCredit();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendTransDebit_W</Name>
				<Source><![CDATA[
    public CustVendTrans parmCustVendTransDebit_W(CustVendTrans _custVendTransDebit = settlementPair.getCustVendTransDebit())
    {
        settlementPair.setCustVendTransDebit(_custVendTransDebit);
        return settlementPair.getCustVendTransDebit();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendTransSettlement_W</Name>
				<Source><![CDATA[
    public CustVendTransSettlement parmCustVendTransSettlement_W(CustVendTransSettlement _custVendTransSettlement = custVendTransSettlement)
    {
        custVendTransSettlement = _custVendTransSettlement;

        return custVendTransSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsCashDiscountAdjustedForOverPayment</Name>
				<Source><![CDATA[
    public boolean parmIsCashDiscountAdjustedForOverPayment(boolean _isCashDiscountAdjustedForOverPayment = isCashDiscountAdjustedForOverPayment)
    {
        isCashDiscountAdjustedForOverPayment = _isCashDiscountAdjustedForOverPayment;
        return isCashDiscountAdjustedForOverPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsTaxInvoiceInfoFilled</Name>
				<Source><![CDATA[
    public boolean parmIsTaxInvoiceInfoFilled(boolean _isTaxInvoiceInfoFilled = isTaxInvoiceInfoFilled)
    {
        isTaxInvoiceInfoFilled = _isTaxInvoiceInfoFilled;

        return isTaxInvoiceInfoFilled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerVoucher_W</Name>
				<Source><![CDATA[
    public LedgerVoucher parmLedgerVoucher_W(CompanyId          _companyId          = curext(),
                                             LedgerVoucher      _ledgerVoucher      = null,
                                             LedgerVoucherGroup _ledgerVoucherGroup = settlementPair.getLedgerVoucherGroup())
    {
        if (! _ledgerVoucher)
        {
            return settlementPair.findLedgerVoucherByCompany(_companyId);
        }

        _ledgerVoucher.parmCompanyId(_companyId);
        _ledgerVoucherGroup.addLedgerVoucher(_ledgerVoucher);

        return _ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmModule</Name>
				<Source><![CDATA[
    public SysModule parmModule(SysModule _module = module)
    {
        module = _module;
        return module;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParentCustTrans_IN</Name>
				<Source><![CDATA[
    public CustTrans parmParentCustTrans_IN(CustTrans _parentCustTrans = parentCustTrans)
    {
        parentCustTrans = _parentCustTrans;

        return parentCustTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParentLedgerVoucher_RU</Name>
				<Source><![CDATA[
    public LedgerVoucher parmParentLedgerVoucher_RU(LedgerVoucher _ledgerVoucher = parentLedgerVoucher)
    {
        parentLedgerVoucher = _ledgerVoucher;
        return parentLedgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRelatedJournalId</Name>
				<Source><![CDATA[
    public LedgerJournalId parmRelatedJournalId(LedgerJournalId _relatedJournalId = relatedJournalId)
    {
        relatedJournalId = _relatedJournalId;
        return relatedJournalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRelatedLedgerVoucher</Name>
				<Source><![CDATA[
    public LedgerVoucher parmRelatedLedgerVoucher(LedgerVoucher _relatedLedgerVoucher = relatedLedgerVoucher)
    {
        relatedLedgerVoucher = _relatedLedgerVoucher;
        return relatedLedgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSettlementGroupPlaceHolder_W</Name>
				<Source><![CDATA[
    public Counter parmSettlementGroupPlaceHolder_W(Counter _settlementGroupPlaceHolder = settlementGroupPlaceHolder)
    {
        settlementGroupPlaceHolder = _settlementGroupPlaceHolder;

        return settlementGroupPlaceHolder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransactionDate_W</Name>
				<Source><![CDATA[
    public TransDate parmTransactionDate_W(TransDate _transDate = settlementPair.getTransactionDate())
    {
        settlementPair.setTransactionDate(_transDate);
        return settlementPair.getTransactionDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pennyDiffTxt</Name>
				<Source><![CDATA[
    abstract LedgerTransTxt pennyDiffTxt()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCashDisc</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Posts the cash discount.
    /// </summary>
    /// <param name="_totalAmountCur">
    ///  The total amount of the cash discount.
    /// </param>
    /// <param name="_custVendTrans">
    ///  The debit customer or vendor transaction.
    /// </param>
    /// <param name="_exchRate">
    ///  The accounting currency exchange rate.
    /// </param>
    /// <param name="_exchRateReporting">
    ///  The reporting currency exchange rate.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///  The ledger voucher that will contain the cash discount accounting entries.
    /// </param>
    /// <param name="_discLedgerDimension">
    ///  The discount ledger dimension.
    /// </param>
    protected void postCashDisc(
        AmountCur                     _totalAmountCur,
        CustVendTrans                 _custVendTrans,
        ExchRate                      _exchRate,
        ExchRate                      _exchRateReporting,
        LedgerVoucher                 _ledgerVoucher,
        LedgerDimensionDefaultAccount _discLedgerDimension)
    {
        List distributions = new List(Types::Class);
        boolean skipDimensionValidation = false;
        boolean applyDefaultDimensions = true;
        boolean mergeDefaultWithOriginalDimension = true;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
            && this.useInvoiceLineAccount(_custVendTrans.CashDiscCode))
        {
            distributions = this.getCashDiscInvLineAccountDistributions_PSN(
                _totalAmountCur,
                _custVendTrans,
                _exchRate,
                _exchRateReporting,
                0);
            skipDimensionValidation = true;
            applyDefaultDimensions = false;
        }
        else
        {
            if (!_discLedgerDimension)
            {
                throw error(strFmt("@SYS24816", this.getLedgerPostingType_CashDisc()));
            }

            distributions = this.getCashDiscTaxDistributions(_totalAmountCur, _custVendTrans, _exchRate, _exchRateReporting);

            if (distributions.elements() == 0)
            {
                distributions = this.getCashDiscDistributions(_totalAmountCur, _custVendTrans, _exchRate, _exchRateReporting, _discLedgerDimension, mergeDefaultWithOriginalDimension);
            }

            if (distributions.elements() == 0)
            {
                distributions = this.getCashDiscSingleDistribution(_totalAmountCur, _custVendTrans, _exchRate, _exchRateReporting, _discLedgerDimension);
            }
        }

        this.postCashDiscDistributions(_custVendTrans, _ledgerVoucher, distributions, skipDimensionValidation, applyDefaultDimensions);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postClosing</Name>
				<Source><![CDATA[
    protected void postClosing(
        CustVendTrans    _custVendTrans,
        TransDate        _postingDate)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postConditionalTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates conditional tax transactions for the settlement.
    /// </summary>
    /// <param name="_currentSettleFactor">
    ///    The percent of the transaction that is settled including the current settlement.
    /// </param>
    /// <param name="_origSettleFactor">
    ///    The percent of the transaction that is settled excluding the current settlement.
    /// </param>
    /// <param name="_custVendTrans">
    ///    The <c>CustVendTrans</c> record that is used to calculate conditional tax.
    /// </param>
    /// <param name="_offsetCustVendTrans">
    ///    The <c>CustVendTrans</c> record that is the offset of the conditional tax transaction.
    /// </param>
    /// <param name="_cashDiscAmountCur">
    ///    The cash discount amount in the transaction currency.
    /// </param>
    /// <param name="_exchRate">
    /// The exchange rate between transaction and accounting currency.
    /// </param>
    /// <param name="_exchRateReporting">
    /// The exchange rate between accounting and transaction currency.
    /// </param>
    protected void postConditionalTax(
        Percent _currentSettleFactor,
        Percent _origSettleFactor,
        CustVendTrans _custVendTrans,
        CustVendTrans _offsetCustVendTrans,
        DiscAmount _cashDiscAmountCur,
        ExchRate _exchRate,
        ExchRate _exchRateReporting)
    {
        #ISOCountryRegionCodes

        if (_currentSettleFactor != _origSettleFactor)
        {
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT])
                && (settlementPair.getSpecTransDebit().getSpecSourceTableId() == tableNum(CustTable)
                    || settlementPair.getSpecTransDebit().getSpecSourceTableId()  == tableNum(VendTable))
                && (_custVendTrans.TransType == LedgerTransType::Payment
                    || _offsetCustVendTrans.TransType == LedgerTransType::Payment)
                && TaxSettlement::conditionalVat(_custVendTrans)
                )
            {
                throw error("@SYS311150");
            }

            // <GTH>
            if (!isAverageVATEnabled
                || (isAverageVATEnabled
                    && TaxAverageVATAdjust::canProcessConditionalSalesTax(
                        _custVendTrans.Voucher,
                        _custVendTrans.TransDate,
                        _offsetCustVendTrans.TransDate)))
            {
                // </GTH>
                this.taxSettlement(_custVendTrans,
                    _offsetCustVendTrans,
                    _cashDiscAmountCur,
                    (_currentSettleFactor - _origSettleFactor)*100,
                    _exchRate,
                    _exchRateReporting);
                // <GTH>
            }
            // </GTH>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postDiscTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the cash discount transactions for the settlement.
    /// </summary>
    /// <param name="_cashDiscAmountCur">
    /// The cash discount amount in the transaction currency.
    /// </param>
    /// <param name="_cashDiscAmountMst">
    /// The cash discount amount in the accounting currency.
    /// </param>
    /// <param name="_cashDiscAmountReporting">
    /// The cash discount amount in the reporting currency.
    /// </param>
    /// <param name="_custVendTrans">
    /// The CustVendTrans record used to create the transaction.
    /// </param>
    /// <param name="_custVendTransOpen">
    /// The CustVendTransOpen record used to create the transaction.
    /// </param>
    /// <param name="_custVendTransOffset">
    /// The CustVendTrans record that is the offset of the cash discount transaction.
    /// </param>
    /// <param name="_exchRate">
    /// The exchange rate of the cash discount between transaction and accounting currency.
    /// </param>
    /// <param name="_exchRateReporting">
    /// The exchange rate of the cash discount between accounting and reporting currency.
    /// </param>
    /// <param name="_discLedgerDimension">
    /// The cash discount ledger account.
    /// </param>
    /// <param name="_taxOnCashDiscAmount">
    /// The amount of tax on the cash discount amount.
    /// </param>
    /// <param name="_settledAmountCurDebit">
    /// The settled amount of the debit transaction in transaction currency.
    /// </param>
    /// <param name="_distributionController">
    /// The <c>CustVendTransSettleDistController</c> instance associated with the <paramref name="_custVendTrans"/> record.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The LedgerVoucher object used to create ledger transactions; optional.
    /// </param>
    /// <param name="_isOverPayment">
    /// A boolean that indicates whether the discount transaction being created to adjust cash discount because
    /// of an overpayment; optional.
    /// </param>
    protected void postDiscTrans(
        AmountCur           _cashDiscAmountCur,
        AmountMST           _cashDiscAmountMst,
        AmountMSTSecondary  _cashDiscAmountReporting,
        CustVendTrans       _custVendTrans,
        CustVendTransOpen   _custVendTransOpen,
        CustVendTrans       _custVendTransOffset,
        ExchRate            _exchRate,
        ExchRate            _exchRateReporting,
        LedgerDimensionDefaultAccount   _discLedgerDimension,
        AmountCur           _taxOnCashDiscAmount,
        AmountCur           _settledAmountCurDebit,
        CustVendTransSettleDistController _distributionController,
        LedgerVoucher       _ledgerVoucher = null,
        boolean             _isOverPayment = false)
    {
        CustVendTrans                   discTrans = _custVendTrans.data();
        CustVendTrans                   transToAdjust;
        CustVendSettlement              settlementToAdjust;

        LedgerVoucherTransObject        ledgerVoucherTransObject;
        LedgerVoucher                   ledgerVoucher;
        LedgerVoucherObject             ledgerVoucherObject;
        TransactionTxt                  cashDiscText;
        DimensionDefault                discTransDefaultDimension;
        boolean                         postDiscLedgerToCreditCompany;
        LedgerDimensionDefaultAccount   localDiscLedgerDimension = _discLedgerDimension;
        LedgerDimensionAccount          ledgerDimensionMerged;
        CurrencyExchangeHelper          exchangeRateHelper;
        List                            distributions;
        ListEnumerator                  distributionEnumerator;
        CustVendTransDistribution       distribution;
        LedgerJournalId                 ledgerJournalId = VendTrans::find(_custVendTrans.RecId).JournalNum;
        // <GEERU><GEECZ>
        AmountCur                       taxCashDiscAmount;
        LedgerBondClient_RU             ledgerBondClient;
        CustVendSettlePostingLog_RU     postingLog;
        int                             i;
        boolean                         countryRegion_RUCZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]);
        Set                             localTaxTransRecIDs;
        CustVendTrans_W                 custVendTrans_W;
        CustVendTransDistributionController  distributionController;
        // </GEECZ></GEERU>
        // <GEEU>
        boolean                         usePostingLog = CustVendTransPostingLog_RU::usePostingLog();
        // </GEEU>

        Debug::assert(curext() == _custVendTrans.company());

        if (_cashDiscAmountCur == 0)
        {
            // Discount amount is zero so there is nothing to post
            return;
        }

        if (_ledgerVoucher == null)
        {
            ledgerVoucher = settlementPair.findLedgerVoucherByCompany(_custVendTrans.company());
        }
        else
        {
            ledgerVoucher = _ledgerVoucher;
        }

        cashDiscText = TransactionTxt::construct(this.discTxtCustVend(),
                                          _custVendTrans.languageId(),
                                          settlementPair.getTransactionDate(),
                                          _custVendTrans.Invoice,
                                          _custVendTrans.Voucher);

        discTransDefaultDimension = this.getDiscTransDefaultDimension(_custVendTrans, _custVendTransOffset, _isOverPayment);

        if (_isOverPayment)
        {
            postingProfile = _custVendTransOffset.PostingProfile;
        }
        else
        {
            postingProfile = _custVendTrans.PostingProfile;
        }

        // <GEEU>
        if (usePostingLog)
        {
            if (! _taxOnCashDiscAmount && conTaxAmounts_RU == conNull())
            {
                this.createLedgerVoucherObject_RU(ledgerVoucher);
                if (countryRegion_RUCZ)
                {
                    ledgerBondClient = ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
                    if (ledgerBondClient)
                    {
                        ledgerBondClient.addNewLogObject();
                    }
                }
            }
            else
            {
                ledgerBondClient = ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
            }
        }
        // </GEEU>
        ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();

        discTrans.clear();

        discTrans.OffsetRecId           = _custVendTrans.RecId;
        discTrans.AccountNum            = _custVendTrans.AccountNum;
        discTrans.TransDate             = settlementPair.getTransactionDate();
        discTrans.Closed                = CustVendTransData::construct(discTrans).maxSettlementDate(settlementPair.getTransactionDate());
        discTrans.Voucher               = ledgerVoucherObject.parmReferenceNumber();
        discTrans.Approved              = NoYes::Yes;
        discTrans.Txt                   = cashDiscText.txt();

        discTrans.CurrencyCode = _custVendTrans.CurrencyCode;

        discTrans.AmountCur = -this.amount(_cashDiscAmountCur);
        discTrans.AmountMST = -this.amount(_cashDiscAmountMst);
        discTrans.ReportingCurrencyAmount = -this.amount(_cashDiscAmountReporting);
        discTrans.ExchRate  = _exchRate;
        discTrans.ReportingCurrencyExchRate = _exchRateReporting;
        discTrans.ReportingCurrencyCrossRate = _exchRateReporting;

        discTrans.SettleAmountMST       = discTrans.AmountMST;
        discTrans.SettleAmountCur       = discTrans.AmountCur;
        discTrans.SettleAmountReporting = discTrans.ReportingCurrencyAmount;

        discTrans.Correct = ledgerVoucherObject.parmIsCorrectionDefault();

        discTrans.LastSettleDate        = discTrans.TransDate;
        discTrans.LastSettleVoucher     = _custVendTrans.Voucher;
        discTrans.LastSettleAccountNum  = _custVendTrans.AccountNum;
        discTrans.LastSettleCompany     = _custVendTrans.DataAreaId;

        discTrans.DefaultDimension = discTransDefaultDimension;

        discTrans.TransType             = LedgerTransType::CashDiscount;
        discTrans.PaymReference         = settlementPair.getCustVendTransCredit().PaymReference;
        discTrans.ExchAdjustment        = 0;
        discTrans.LastExchAdj           = dateNull();
        discTrans.Invoice               = '';
        discTrans.CashDiscCode          = '';
        discTrans.PaymMode              = '';
        // <GEERU><GEECZ>
        if (countryRegion_RUCZ)
        {
            custVendTrans_W = discTrans.CustVendTrans::getCustVendTrans_W();
            custVendTrans_W.CorrectReporting_RU = discTrans.Correct;
            discTrans.CustVendTrans::packCustVendTrans_W(custVendTrans_W);
        }
        // </GEECZ></GEERU>

        this.initJournalNumCashDisc(discTrans);

        discTrans.initFromPostingProfile(postingProfile);

        if (_isOverPayment)
        {
            // for and over payment, need to find the records cash discount records and adjust the amounts on these records
            [transToAdjust, settlementToAdjust] = custVendTransSettlement.findTransAndSettlement(discTrans, settlementGroupPlaceHolder, discTrans.OffsetRecId);

            if (transToAdjust.AccountNum != '')
            {
                transToAdjust.AmountCur += discTrans.AmountCur;
                transToAdjust.AmountMST += discTrans.AmountMST;
                transToAdjust.ReportingCurrencyAmount += discTrans.ReportingCurrencyAmount;
                transToAdjust.SettleAmountCur += discTrans.SettleAmountCur;
                transToAdjust.SettleAmountMST += discTrans.SettleAmountMST;
                transToAdjust.SettleAmountReporting += discTrans.SettleAmountReporting;

                settlementToAdjust.SettleAmountCur += discTrans.SettleAmountCur;
                settlementToAdjust.SettleAmountMST += discTrans.SettleAmountMST;
                settlementToAdjust.SettleAmountReporting += discTrans.SettleAmountReporting;

                custVendTransSettlement.modifyTransAndSettlement(transToAdjust, settlementToAdjust, settlementGroupPlaceHolder, discTrans.OffsetRecId, true, true);
            }
            else
            {
                custVendTransSettlement.addTransAndDefaultSettlement(discTrans, settlementGroupPlaceHolder);
            }
        }
        else
        {
            custVendTransSettlement.addTransAndDefaultSettlement(discTrans, settlementGroupPlaceHolder);
        }

        cashDiscText.setType(this.discTxtLedger());
        ledgerVoucherObject.lastTransTxt(cashDiscText.txt());

        // create ledger transaction for payment company
        postDiscLedgerToCreditCompany = this.postDiscTransToCreditCompany(
            _custVendTrans,
            _custVendTransOffset,
            _cashDiscAmountCur - this.amount(_taxOnCashDiscAmount));

        ledgerVoucherObject.parmPaymentReference(settlementPair.getCustVendTransCredit().PaymReference);

        // <GEEU>
        if (usePostingLog && _custVendTransOffset.Prepayment)
        {
            if (! ((_custVendTrans.TableId == tableNum(CustTrans) && CustParameters::find().ReversePrepayment_W) ||
                   (_custVendTrans.TableId == tableNum(VendTrans) && VendParameters::find().ReversePrepayment_W)))
            {
                postingProfile = _custVendTransOffset.PostingProfile;
            }
        }
        // </GEEU>

        if (postDiscLedgerToCreditCompany)
        {
            // the ledger account need to be the Due to/from ledger account
            localDiscLedgerDimension = dueToFromLedgerDimensionDebit;

            ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
            exchangeRateHelper  = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
            exchangeRateHelper.parmExchangeRate1(discTrans.ExchRate);
            discTrans.setExchangeHelperReportingExchRate(exchangeRateHelper);

            ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(localDiscLedgerDimension);
            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                        ledgerVoucherObject,
                                        this.getLedgerPostingType_CashDisc(),
                                        ledgerDimensionMerged,
                                        _custVendTrans.CurrencyCode,
                                        -(discTrans.AmountCur + _taxOnCashDiscAmount),
                                        exchangeRateHelper);

            ledgerVoucherTransObject.parmSourceTableId(discTrans.TableId);
            ledgerVoucherTransObject.parmSourceRecId(discTrans.RecId);

            ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }
        else
        {
            // <GEERU>
            if (ledgerBondClient)
            {
                if (ledgerBondClient.currentLogLength())
                {
                    taxCashDiscAmount = _taxOnCashDiscAmount;
                }
                else
                {
                    taxCashDiscAmount = 0;
                }
            }
            else
            {
                taxCashDiscAmount = _taxOnCashDiscAmount;
            }
            // </GEERU>
            // create ledger transaction for the cash discount account
            this.postCashDisc(
                // <GEERU>
                discTrans.AmountCur + taxCashDiscAmount,
                // </GEERU>
                _custVendTrans,
                discTrans.ExchRate,
                discTrans.getReportingCombinedExchangeRate(),
                ledgerVoucher,
                localDiscLedgerDimension);
        }

        AssetPostCashDiscount::postAssetDiscountTransactions(
            _custVendTrans, discTrans, _taxOnCashDiscAmount, ledgerJournalId, ledgerVoucher, fixedAssetDiscountDimension, localDiscLedgerDimension);

        // create ledger transaction for the AR or AP account number(s)
        ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();

        ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(
                _isOverPayment ? _custVendTransOffset.summaryLedgerDimension(postingProfile) : _custVendTrans.summaryLedgerDimension(postingProfile),
                discTransDefaultDimension);

        boolean doesVoucherContainsMultipleSummaryEntries = CustVendSettleSummaryAccountRelief::voucherContainsMultipleSummaryEntries(
            _isOverPayment ? _custVendTransOffset : _custVendTrans,
            this.getLedgerPostingType_Balance());

        // Cash Discounts do not process line level settlements.
        distributionController = CustVendTransDistributionController::constructForSettlement(false, 0);
        distributions = distributionController.generateDistributions(
            _isOverPayment ? _custVendTransOffset : _custVendTrans,
            this.getLedgerPostingType_Balance(),
            discTrans.AmountCur,
            discTrans.AmountMST,
            discTrans.ReportingCurrencyAmount,
            ledgerDimensionMerged,
            doesVoucherContainsMultipleSummaryEntries);

        distributionEnumerator = distributions.getEnumerator();
        while (distributionEnumerator.moveNext())
        {
            distribution = distributionEnumerator.current();

            ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
                ledgerVoucherObject,
                this.getLedgerPostingType_Balance(),
                distribution.ledgerDimension(),
                _isOverPayment ? _custVendTransOffset.CurrencyCode : _custVendTrans.CurrencyCode,
                distribution.transactionAmount(),
                distribution.accountingAmount(),
                distribution.reportingAmount());

            ledgerVoucherTransObject.parmSourceTableId(discTrans.TableId);
            ledgerVoucherTransObject.parmSourceRecId(discTrans.RecId);
            ledgerVoucherTransObject.parmSkipDimensionValidation(true);
            if (postCashDiscountInSummary)
            {
                ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::Summary);
            }

            ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }

        ledgerVoucher.findLedgerVoucherObject().lastTransTxt("");
        // <GEERU>
        if (ledgerBondClient)
        {
            ledgerBondClient.bondLastVRef2CurrentLog();
            ledgerBondClient.removeCurrentLogObject();
        }
        if (usePostingLog)
        {
            postingLog = CustVendSettlePostingLog_RU::newCustVendSettle(CustVendTransPostingLogType_RU::CashDisc,
                                                                        discTrans,
                                                                        settlementPair.getCustVendTransDebit().PostingProfile == postingProfile ? settlementPair.getCustVendTransDebit() : settlementPair.getCustVendTransCredit(),
                                                                        settlementPair.getCustVendTransDebit().PostingProfile == postingProfile ? settlementPair.getCustVendTransCredit() : settlementPair.getCustVendTransDebit());
            postingLog.parmCustVendSettle(this);

            for (i = 1 ; i <= conLen(conTaxAmounts_RU); i ++)

            {
                localTaxTransRecIDs = new Set(typeName2Type(extendedTypeStr(RecId)));
                localTaxTransRecIDs.add(conPeek(contaxTransRecId, i));
                postingLog.parmTaxTransRecIDs(localTaxTransRecIDs);
                postingLog.createTrans(LedgerPostingType::Tax,
                                       0,
                                        LedgerDimensionFacade::serviceCreateLedgerDimension(_custVendTrans.summaryLedgerDimension(postingProfile), _custVendTrans.DefaultDimension),
                                       discTrans.CurrencyCode,
                                       conPeek(conTaxAmounts_RU, i),
                                       0,
                                       CurrencyExchangeHelper::amountCur2MSTSecond_RU(conPeek(conTaxAmounts_RU, i), discTrans.CurrencyCode, _exchRate, discTrans.TransDate),
                                       _exchRate);
            }
        }
        // </GEERU>

        // Post credit note for cash discount
        if (SysCountryRegionCode::isLegalEntityInCountryRegion(CustParameters::listOfCountriesForCreditNoteCashDisc(NoYes::Yes))
            &&  CustParameters::find().CreditNoteCashDiscount_CZ
            && discTrans is CustTrans)
        {
            this.createCreditNoteForCashDiscount_CZ(_custVendTrans, discTrans, _cashDiscAmountMst, _discLedgerDimension);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDiscTransDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the default dimension for a discount record.
    /// </summary>
    /// <param name = "_custVendTrans">
    /// The <c>CustVendTrans</c> table record used to determine the default dimension for the discount record.
    /// </param>
    /// <param name = "_custVendTransOffset">
    /// The <c>CustVendTrans</c> table record used to determine the default dimension for the discount record.
    /// </param>
    /// <param name = "_isOverPayment">
    /// A boolean that indicates whether the discount transaction being created to adjust cash discount because
    /// of an overpayment.
    /// </param>
    /// <returns>
    /// The default dimension for a discount record.
    /// </returns>
    protected DimensionDefault getDiscTransDefaultDimension(CustVendTrans _custVendTrans,
        CustVendTrans _custVendTransOffset,
        boolean _isOverPayment)
    {
        DimensionDefault discTransDefaultDimension;

        if (_custVendTrans.company() == _custVendTransOffset.company() && _isOverPayment)
        {
            discTransDefaultDimension = _custVendTransOffset.DefaultDimension;
        }
        else
        {
            discTransDefaultDimension = _custVendTrans.DefaultDimension;
        }

        return discTransDefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postDiscTransToCreditCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the ledger transactions when the cash discount is posted to the payment company.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The CustVendTrans record used to create the transaction.
    /// </param>
    /// <param name="_custVendTransOffset">
    /// The CustVendTrans record used as the offset to the transaction.
    /// </param>
    /// <param name="_discAmountCur">
    /// The cash discount amount in the transaction currency.
    /// </param>
    /// <returns>
    /// true if the cash discount is posted to the payment company; otherwise, false.
    /// </returns>
    protected boolean postDiscTransToCreditCompany(
        CustVendTrans _custVendTrans,
        CustVendTrans _custVendTransOffset,
        DiscAmount _discAmountCur)
    {
        boolean                         postLedgerToCreditCompany;
        LedgerInterCompany              interCompany;
        AmountMST                       discAmountPaymentMst;
        AmountMSTSecondary              discAmountPaymentReporting;
        LedgerVoucher                   paymentLedgerVoucher;
        LedgerVoucherObject             ledgerVoucherObject;
        TransactionTxt                  paymentCashDiscText;
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        LedgerDimensionDefaultAccount   paymentCashDiscLedgerDimension;
        CurrencyExchangeHelper          currencyHelper;
        LedgerDimensionAccount          ledgerDimensionMerged;

        // Only discounts for invoice transaction can be transfered to payment company.  To determine this the
        // discount amount must be positive, the CustVendTrans parameter must be the same as the debit transaction
        // and debit and credit companies must be different.
        if (_discAmountCur > 0 && settlementPair.getDebitCompany() != settlementPair.getCreditCompany() &&
            _custVendTrans.RecId == settlementPair.getCustVendTransDebit().RecId)
        {
            // Check if the LedgerInterCompany for credit company has cash discount post option set to PaymentCompany
            changecompany(settlementPair.getCreditCompany())
            {
                interCompany = this.findLedgerInterCompany(settlementPair.getCreditCompany(), settlementPair.getDebitCompany());
                if (interCompany.getCashDiscPostOptions(this.parmModule()) == CustVendSettleCompanyPostOption::PaymentCompany)
                {
                    postLedgerToCreditCompany = true;

                    // Use the payment date and exchange rate in payment company
                    currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(settlementPair.getCreditCompany()).RecId), _custVendTransOffset.TransDate);
                    discAmountPaymentMst = currencyHelper.calculateTransactionToAccounting(_custVendTrans.CurrencyCode, _discAmountCur, true);
                    discAmountPaymentReporting = currencyHelper.calculateTransactionCurrencyToReportingCurrency(_custVendTrans.CurrencyCode, _discAmountCur);

                    // set up transaction text for ledger transaction
                    paymentCashDiscText = TransactionTxt::construct(this.discTxtLedger(),
                                            _custVendTransOffset.languageId(),
                                            settlementPair.getTransactionDate(),
                                            _custVendTransOffset.Invoice,
                                            _custVendTransOffset.Voucher);

                    // set up ledger voucher for payment company
                    paymentLedgerVoucher = settlementPair.findLedgerVoucherByCompany(settlementPair.getCreditCompany());
                    ledgerVoucherObject = paymentLedgerVoucher.findLedgerVoucherObject();
                    ledgerVoucherObject.lastTransTxt(paymentCashDiscText.txt());
                    ledgerVoucherObject.parmPaymentReference(_custVendTransOffset.PaymReference);

                    // create ledger transaction for due to/from ledger account
                    ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(dueToFromLedgerDimensionCredit);
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
                        ledgerVoucherObject,
                        this.getLedgerPostingType_CashDisc(),
                        ledgerDimensionMerged,
                        _custVendTrans.CurrencyCode,
                        -this.amount(_discAmountCur),
                        -this.amount(discAmountPaymentMst),
                        -this.amount(discAmountPaymentReporting));

                    ledgerVoucherTransObject.parmSourceTableId(_custVendTransOffset.TableId);
                    ledgerVoucherTransObject.parmSourceRecId(_custVendTransOffset.RecId);
                    paymentLedgerVoucher.addTrans(ledgerVoucherTransObject);

                    paymentCashDiscLedgerDimension = this.cashDiscLedgerDimensionForCreditCompany();

                    ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(paymentCashDiscLedgerDimension, _custVendTransOffset.DefaultDimension);

                    // create ledger transaction for cash discount ledger account
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
                        ledgerVoucherObject,
                        this.getLedgerPostingType_CashDisc(),
                        ledgerDimensionMerged,
                        _custVendTrans.CurrencyCode,
                        this.amount(_discAmountCur),
                        this.amount(discAmountPaymentMst),
                        this.amount(discAmountPaymentReporting));

                    ledgerVoucherTransObject.parmSourceTableId(_custVendTransOffset.TableId);
                    ledgerVoucherTransObject.parmSourceRecId(_custVendTransOffset.RecId);
                    paymentLedgerVoucher.addTrans(ledgerVoucherTransObject);
                }
            }
        }

        return postLedgerToCreditCompany;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postDueToAndFrom</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates due to and due from transactions for the settlement.
    /// </summary>
    /// <param name="_settleAmountAccountingDebit">
    /// The amount to settle for the debit transaction in the accounting currency.
    /// </param>
    /// <param name="_settleAmountAccountingCredit">
    /// The amount to settle for the credit transaction in the accounting currency.
    /// </param>
    /// <param name="_settleAmountCurDebit">
    /// The amount to settle for the debit transaction in the transaction currency.
    /// </param>
    /// <param name="_settleAmountCurCredit">
    /// The amount to settle for the credit transaaction in the transaction currency.
    /// </param>
    /// <param name="_settleAmountReportingDebit">
    /// The amount to settle for the debit transaction in the reporting currency.
    /// </param>
    /// <param name="_settleAmountReportingCredit">
    /// The amount to settle for the credit transaction in the reporting currency.
    /// </param>
    protected void postDueToAndFrom(
        AmountMST           _settleAmountAccountingDebit,
        AmountMST           _settleAmountAccountingCredit,
        AmountCur           _settleAmountCurDebit,
        AmountCur           _settleAmountCurCredit,
        AmountMSTSecondary  _settleAmountReportingDebit,
        AmountMSTSecondary  _settleAmountReportingCredit)
    {
        CustVendTrans interCompanyTransDebit;
        CustVendTrans interCompanyTransCredit;
        AmountCur     localSettleAmountCur;

        if (settlementPair.getDebitCompany() != settlementPair.getCreditCompany())
        {
            Debug::assert(settlementPair.getDebitCompany() == curext());

            localSettleAmountCur = this.amount(_settleAmountCurDebit);

            dueToFromLedgerDimensionDebit = LedgerInterCompany::getOriginatingCompanyLedgerDimensionWithAmount(
                localSettleAmountCur,
                settlementPair.getDebitCompany(),
                settlementPair.getCreditCompany());

            interCompanyTransDebit = this.postDueToAndFromCreateTrans(
                settlementPair.getCustVendTransDebit(),
                settlementPair.getCustVendTransOpenDebit(),
                _settleAmountAccountingDebit,
                _settleAmountCurDebit,
                _settleAmountReportingDebit,
                dueToFromLedgerDimensionDebit,
                settlementPair.getExchRate().getDebitCurToDebitMstPrimary(),  // use the exchange rate on the payment date
                settlementPair.getExchRate().getDebitCurToDebitMstSecond(),
                debitSettleDistController);

            // <GEEU>
            if (CustVendTransPostingLog_RU::usePostingLog())
            {
                this.createPostingTransLog_RU(CustVendTransPostingLogType_RU::CrossCompanySettlement,
                                              settlementPair.getCustVendTransDebit(),
                                              LedgerPostingType::CrossCompanySettlement,
                                              settlementPair.getCustVendTransDebit().summaryLedgerDimension(settlementPair.getCustVendTransDebit().PostingProfile),
                                              dueToFromLedgerDimensionDebit,
                                              - this.amount(_settleAmountAccountingDebit),
                                              - this.amount(_settleAmountReportingDebit),
                                              null,
                                              settlementPair.getCustVendTransDebit().DefaultDimension,
                                              - localSettleAmountCur,
                                              settlementPair.getCustVendTransDebit(),
                                              settlementPair.getCustVendTransCredit(),
                                              0,
                                              0,
                                              interCompanyTransDebit.Voucher,
                                              interCompanyTransDebit.TransDate);
            }
            // </GEEU>
            changecompany(settlementPair.getCreditCompany())
            {
                // <GIN>
                CustVendSettle::checkServiceTaxPayment_IN(settlementPair.getCustVendTransCredit(), settlementPair.getCustVendTransDebit());
                // </GIN>
                localSettleAmountCur = this.amount(_settleAmountCurCredit);

                dueToFromLedgerDimensionCredit = LedgerInterCompany::getDestinationCompanyLedgerDimensionWithAmount(
                    localSettleAmountCur,
                    settlementPair.getDebitCompany(),
                    settlementPair.getCreditCompany());

                interCompanyTransCredit = this.postDueToAndFromCreateTrans(
                    settlementPair.getCustVendTransCredit(),
                    settlementPair.getCustVendTransOpenCredit(),
                    _settleAmountAccountingCredit,
                    _settleAmountCurCredit,
                    _settleAmountReportingCredit,
                    dueToFromLedgerDimensionCredit,
                    settlementPair.getCustVendTransCredit().ExchRate,   // use the exchange rate from the credit transaction
                    settlementPair.getCustVendTransCredit().ExchRateSecond,
                    creditSettleDistController);

                // <GEEU>
                if (CustVendTransPostingLog_RU::usePostingLog())
                {
                    this.createPostingTransLog_RU(CustVendTransPostingLogType_RU::CrossCompanySettlement,
                                                  settlementPair.getCustVendTransCredit(),
                                                  LedgerPostingType::CrossCompanySettlement,
                                                  dueToFromLedgerDimensionCredit,
                                                  settlementPair.getCustVendTransCredit().summaryLedgerDimension(settlementPair.getCustVendTransDebit().PostingProfile),
                                                  this.amount(_settleAmountAccountingCredit),
                                                  this.amount(_settleAmountReportingCredit),
                                                  null,
                                                  settlementPair.getCustVendTransCredit().DefaultDimension,
                                                  localSettleAmountCur,
                                                  settlementPair.getCustVendTransCredit(),
                                                  settlementPair.getCustVendTransDebit(),
                                                  0,
                                                  0,
                                                  interCompanyTransCredit.Voucher,
                                                  interCompanyTransCredit.TransDate);
                }
                // </GEEU>
            }

            // set last settled fields correctly
            interCompanyTransDebit.LastSettleVoucher = interCompanyTransCredit.Voucher;
            interCompanyTransDebit.LastSettleCompany = interCompanyTransCredit.DataAreaId;
            interCompanyTransDebit.LastSettleAccountNum = interCompanyTransCredit.AccountNum;
            interCompanyTransCredit.LastSettleVoucher = interCompanyTransDebit.Voucher;
            interCompanyTransCredit.LastSettleCompany = interCompanyTransDebit.DataAreaId;
            interCompanyTransCredit.LastSettleAccountNum = interCompanyTransDebit.AccountNum;

            // When the InterCompany trans record is created and the offsetRecId should
            // should point to another CustVendTrans record with the same settlement group and trans type,
            // setting the third parameter to true will support this.
            custVendTransSettlement.addTransAndDefaultSettlement(interCompanyTransDebit, settlementGroupPlaceHolder, true);
            custVendTransSettlement.addTransAndDefaultSettlement(interCompanyTransCredit, settlementGroupPlaceHolder, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postDueToAndFromCreateTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the due-to or due-from transactions for the specified settlement and transaction.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The <c>CustVendTrans</c> record that is used to create the due-to or due-from transaction.
    /// </param>
    /// <param name="_custVendTransOpen">
    /// The <c>CustVendTransOpen</c> record that is used to create the due-to or due-from transaction.
    /// </param>
    /// <param name="_settleAmountAccounting">
    /// The amount to settle in the accounting currency.
    /// </param>
    /// <param name="_settleAmountCur">
    /// The amount to settle in the transaction currency.
    /// </param>
    /// <param name="_settleAmountReporting">
    /// The amount to settle in the reporting currency.
    /// </param>
    /// <param name="_dueToFromLedgerDimension">
    /// The due-to or due-from ledger account.
    /// </param>
    /// <param name="_exchRatePrimary">
    /// The primary exchange rate for the due-to or due-from transaction.
    /// </param>
    /// <param name="_exchRateSecond">
    /// The second exchange rate for the due-to or due-from transaction.
    /// </param>
    /// <param name="_distributionController">
    /// The <c>CustVendTransSettleDistController</c> instance that is associated with the <paramref
    /// name="_custVendTrans" /> record.
    /// </param>
    /// <returns>
    /// The <c>CustVendTrans</c> record for the due-to or due-from transaction.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The intercompany accounting relationship is missing.
    /// </exception>
    protected CustVendTrans postDueToAndFromCreateTrans(
        CustVendTrans                   _custVendTrans,
        CustVendTransOpen               _custVendTransOpen,
        AmountMST                       _settleAmountAccounting,
        AmountCur                       _settleAmountCur,
        AmountMSTSecondary              _settleAmountReporting,
        LedgerDimensionDefaultAccount   _dueToFromLedgerDimension,
        ExchRate                        _exchRatePrimary,
        ExchRate                        _exchRateSecond,
        CustVendTransSettleDistController  _distributionController)
    {
        CustVendTrans               interCompanyTrans = _custVendTrans.data();
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        LedgerVoucher               ledgerVoucher;
        TransactionTxt              transactionTxt;
        TransTxt                    localTransTxt;
        LedgerTransTxt              localLedgerTransTxt;
        AmountMST                   localSettleAmountAccounting = _settleAmountAccounting;
        AmountCur                   localSettleAmountCur = _settleAmountCur;
        AmountMSTSecondary          localSettleAmountReporting = _settleAmountReporting;
        LedgerDimensionAccount      ledgerDimensionMerged;
        LedgerVoucherObject         ledgerVoucherObject;
        List                        distributions;
        ListEnumerator              distributionEnumerator;
        CustVendTransDistribution   distribution;
        LedgerDimensionAccount      distributionSummaryLedgerDimension;
        LedgerDimensionAccount      distributionDueToFromLedgerDimension;
        // <GIN>
        Percent                     distributionPercent;
        CurrencyExchangeHelper      exchangeRateHelperLoc;
        // </GIN>

        if (settlementPair.getDebitCompany() != settlementPair.getCreditCompany())
        {
            Debug::assert(_custVendTrans.company() == curext());

            this.reverseAmounts(settlementPair.getCustVendTransDebit());
            this.reverseTransOpenAmounts(settlementPair.getCustVendTransOpenDebit());

            localSettleAmountAccounting = this.amount(localSettleAmountAccounting);
            localSettleAmountCur = this.amount(localSettleAmountCur);
            localSettleAmountReporting = this.amount(localSettleAmountReporting);

            ledgerVoucher = settlementPair.findOrCreateLedgerVoucherByCompany(_custVendTrans.company());
            // <GEEU>
            if (CustVendTransPostingLog_RU::usePostingLog())
            {
                ledgerVoucherObject = this.createLedgerVoucherObject_RU(ledgerVoucher);
            }
            // </GEEU>

            localLedgerTransTxt = this.crossCompanyTxt();
            transactionTxt = TransactionTxt::construct(localLedgerTransTxt,
                                                _custVendTrans.languageId(),
                                                settlementPair.getTransactionDate(),
                                                _custVendTrans.Voucher,
                                                _custVendTrans.Voucher,
                                                _custVendTrans.AccountNum);
            localTransTxt = transactionTxt.txt();

            // create the custVendTrans record
            interCompanyTrans.clear();

            interCompanyTrans.AccountNum = _custVendTrans.AccountNum;
            interCompanyTrans.Voucher = ledgerVoucher.lastVoucher();
            interCompanyTrans.Invoice = _custVendTrans.Invoice;
            interCompanyTrans.TransDate = settlementPair.getTransactionDate();
            interCompanyTrans.DueDate = _custVendTrans.DueDate;

            interCompanyTrans.DefaultDimension = _custVendTrans.DefaultDimension;
            interCompanyTrans.PostingProfile = _custVendTrans.PostingProfile;
            interCompanyTrans.TransType = LedgerTransType::CrossCompanySettlement;
            interCompanyTrans.PaymMode = _custVendTrans.PaymMode;
            interCompanyTrans.PaymSpec = _custVendTrans.PaymSpec;
            interCompanyTrans.Txt = localTransTxt;

            interCompanyTrans.AmountCur = -localSettleAmountCur;
            interCompanyTrans.AmountMST = -localSettleAmountAccounting;
            interCompanyTrans.ReportingCurrencyAmount = -localSettleAmountReporting;

            interCompanyTrans.SettleAmountCur = interCompanyTrans.AmountCur;
            interCompanyTrans.SettleAmountMST = interCompanyTrans.AmountMST;
            interCompanyTrans.SettleAmountReporting = interCompanyTrans.ReportingCurrencyAmount;

            interCompanyTrans.CurrencyCode = _custVendTrans.CurrencyCode;
            interCompanyTrans.ExchRate = _exchRatePrimary;
            interCompanyTrans.ExchRateSecond = _exchRateSecond;

            interCompanyTrans.LastSettleDate = settlementPair.getTransactionDate();
            interCompanyTrans.Closed = interCompanyTrans.LastSettleDate;

            interCompanyTrans.initFromPostingProfile(_custVendTrans.PostingProfile);

            // <GIN>
            if (TaxWithholdParameters_IN::checkTaxParameters())
            {
                ledgerVoucher = this.postTaxToInvoiceCompany_IN(ledgerVoucherTransObject, ledgerVoucher, _custVendTrans, _dueToFromLedgerDimension);
                this.updateTaxWithholdTrans_IN(_custVendTrans.RecId, _custVendTrans.Voucher, interCompanyTrans.Voucher);
            }
            // </GIN>

            // Create ledger voucher transaction(s) for the AR or AP account

            ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(interCompanyTrans.summaryLedgerDimension(), interCompanyTrans.DefaultDimension);
            distributions = _distributionController.generateDistributions(
                _custVendTrans,
                this.getLedgerPostingType_Balance(),
                localSettleAmountCur,
                localSettleAmountAccounting,
                localSettleAmountReporting,
                ledgerDimensionMerged,
                false);

            ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
            distributionEnumerator = distributions.getEnumerator();
            while (distributionEnumerator.moveNext())
            {
                distribution = distributionEnumerator.current();
                distributionSummaryLedgerDimension = distribution.ledgerDimension();

                ledgerVoucherTransObject = this.initializeLedgerVoucherTransObjectBySummaryLedgerDimension(
                    ledgerVoucherObject,
                    LedgerPostingType::CrossCompanySettlement,
                    distributionSummaryLedgerDimension,
                    interCompanyTrans.CurrencyCode,
                    -distribution.transactionAmount(),
                    -distribution.accountingAmount(),
                    -distribution.reportingAmount(),
                    interCompanyTrans
                    );

                ledgerVoucher.addTrans(ledgerVoucherTransObject);

                // Create ledger voucher transaction(s) for the DueTo/DueFrom account
                // The distribution amounts and dimensions match the AR/AP entries created above, need to replace the account number with the DueTo/DueFrom account
                distributionDueToFromLedgerDimension = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(_dueToFromLedgerDimension, distributionSummaryLedgerDimension);
                ledgerVoucherTransObject = this.initializeLedgerVoucherTransObjectByDistributionDueToFromLedgerDimension(
                    ledgerVoucherObject,
                    LedgerPostingType::CrossCompanySettlement,
                    distributionDueToFromLedgerDimension,
                    interCompanyTrans.CurrencyCode,
                    distribution.transactionAmount(),
                    distribution.accountingAmount(),
                    distribution.reportingAmount());

                // <GIN>
                if (TaxWithholdParameters_IN::checkTaxParameters()
                    && ledgerVoucher.parmPostedInterCompanyWHT_IN())
                {
                    distributionPercent = distribution.transactionAmount() / localSettleAmountCur * 100;
                    exchangeRateHelperLoc = CurrencyExchangeHelper::newExchangeDate(
                        Ledger::current(),
                        _custVendTrans.TransDate);
                    exchangeRateHelperLoc.parmExchangeRate1(_exchRatePrimary);
                    exchangeRateHelperLoc.parmExchangeRate2(_exchRateSecond);
                    ledgerVoucherTransObject.parmAmountCur(ledgerVoucherTransObject.parmAmountCur() - ledgerVoucher.parmPostedInterCompanyWHT_IN() * distributionPercent / 100);
                    ledgerVoucherTransObject.parmAmountMST(exchangeRateHelperLoc.calculateTransactionToAccounting(_custVendTrans.CurrencyCode, ledgerVoucherTransObject.parmAmountCur(), true));
                    ledgerVoucherTransObject.parmReportingCurrencyAmount(CurrencyExchangeHelper::amountMST2MSTSecond_RU(ledgerVoucherTransObject.parmAmountMST()));

                    // reset withhold amount for ledger voucher
                    // only handle multiple lines settlement with withhold amount
                    ledgerVoucher.parmPostedInterCompanyWHT_IN(0);
                }
                // </GIN>

                ledgerVoucherTransObject.parmSourceTableId(interCompanyTrans.TableId);
                ledgerVoucherTransObject.parmSourceRecId(interCompanyTrans.RecId);
                ledgerVoucherTransObject.parmTransTxt(localTransTxt);

                ledgerVoucher.addTrans(ledgerVoucherTransObject);
                // <GEERU>
                ledgerVoucher.bondLast2_RU();
                // </GEERU>
            }

            this.reverseAmounts(settlementPair.getCustVendTransDebit());
            this.reverseTransOpenAmounts(settlementPair.getCustVendTransOpenDebit());
        }

        return interCompanyTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLedgerVoucherTransObjectBySummaryLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>LedgerVoucherTransObject</c> class and constructing value through parm methods.
    /// </summary>
    /// <param name = "_ledgerVoucherObject">
    /// The ledger posting reference used for defaulting.
    /// </param>
    /// <param name = "_postingType">
    /// The posting type of the general journal entry.
    /// </param>
    /// <param name = "_ledgerDimensionId">
    /// The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name = "_transactionCurrencyCode">
    /// The currency code of the general journal entry.
    /// </param>
    /// <param name = "_transactionCurrencyAmount">
    /// The amount in the transaction currency.
    /// </param>
    /// <param name = "_accountingCurrencyAmount">
    /// The amount in the accounting currency.
    /// </param>
    /// <param name = "_reportingCurrencyAmount">
    /// The amount in the reporting currency.
    /// </param>
    /// <param name = "_interCompanyTrans">
    /// The buffer of <c>CustVendTrans</c> table.
    /// </param>
    /// <returns>
    /// A new instance of the <c>LedgerVoucherTransObject</c> class.
    /// </returns>
    [Wrappable(true)]
    protected final LedgerVoucherTransObject initializeLedgerVoucherTransObjectBySummaryLedgerDimension(
        LedgerVoucherObject _ledgerVoucherObject,
        LedgerPostingType _postingType,
        LedgerDimensionAccount _ledgerDimensionId,
        CurrencyCode _transactionCurrencyCode,
        Money _transactionCurrencyAmount,
        MoneyMST _accountingCurrencyAmount,
        MoneyMST _reportingCurrencyAmount,
        CustVendTrans _interCompanyTrans
        )
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
            _ledgerVoucherObject,
            _postingType,
            _ledgerDimensionId,
            _transactionCurrencyCode,
            _transactionCurrencyAmount,
            _accountingCurrencyAmount,
            _reportingCurrencyAmount);

        ledgerVoucherTransObject.parmSourceTableId(_interCompanyTrans.TableId);
        ledgerVoucherTransObject.parmSourceRecId(_interCompanyTrans.RecId);
        ledgerVoucherTransObject.parmTransTxt(_interCompanyTrans.Txt);
        LedgerVoucherTransObject.parmSkipDimensionValidation(true);

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLedgerVoucherTransObjectByDistributionDueToFromLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>LedgerVoucherTransObject</c> class.
    /// </summary>
    /// <param name = "_ledgerVoucherObject">
    /// The ledger posting reference used for defaulting.
    /// </param>
    /// <param name = "_postingType">
    /// The posting type of the general journal entry.
    /// </param>
    /// <param name = "_ledgerDimensionId">
    /// The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name = "_transactionCurrencyCode">
    /// The currency code of the general journal entry.
    /// </param>
    /// <param name = "_transactionCurrencyAmount">
    /// The amount in the transaction currency.
    /// </param>
    /// <param name = "_accountingCurrencyAmount">
    /// The amount in the accounting currency.
    /// </param>
    /// <param name = "_reportingCurrencyAmount">
    /// The amount in the reporting currency.
    /// </param>
    /// <returns>
    /// A new instance of the <c>LedgerVoucherTransObject</c> class.
    /// </returns>
    [Wrappable(true)]
    protected final LedgerVoucherTransObject initializeLedgerVoucherTransObjectByDistributionDueToFromLedgerDimension(
        LedgerVoucherObject _ledgerVoucherObject,
        LedgerPostingType _postingType,
        LedgerDimensionAccount _ledgerDimensionId,
        CurrencyCode _transactionCurrencyCode,
        Money _transactionCurrencyAmount,
        MoneyMST _accountingCurrencyAmount,
        MoneyMST _reportingCurrencyAmount)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
            _ledgerVoucherObject,
            _postingType,
            _ledgerDimensionId,
            _transactionCurrencyCode,
            _transactionCurrencyAmount,
            _accountingCurrencyAmount,
            _reportingCurrencyAmount);

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postExchRateDiff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates exchange adjustment transactions for the settlement.
    /// </summary>
    /// <param name="_exchRateDiff">
    /// The amount of the exchange adjustment.
    /// </param>
    /// <param name="_exchRateReportingDiff">
    /// The amount of the exchange adjustment for the reporting currency.
    /// </param>
    /// <param name="_custVendTrans">
    /// The CustVendTrans record used to create the transaction.
    /// </param>
    /// <param name="_distributionController">
    /// The <c>CustVendTransSettleDistController</c> instance associated with the <paramref name="_custVendTrans"/> record.
    /// </param>
    /// <param name="_unrealized">
    /// true if an unrealized exchange adjustment; otherwise, false a realized exchange adjustment.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The LedgerVoucher object used to create ledger transactions; optional.
    /// </param>
    /// <remarks>
    /// The posting profile parameter is needed when that are different posting profiles on the
    /// debit and credit transaction.  In this case the offset account for exchange adjustment is found
    /// using the posting profile from the credit transaction.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// Intercompany accounting relationship is missing for the credit company.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Intercompany accounting relationship is missing for the debit company.
    /// </exception>
    protected void postExchRateDiff(
        AmountMST _exchRateDiff,
        AmountMSTSecondary _exchRateReportingDiff,
        CustVendTrans _custVendTrans,
        CustVendTransSettleDistController _distributionController,
        boolean _unrealized = false,
        LedgerVoucher _ledgerVoucher = null)

    {
        LedgerDimensionDefaultAccount exchGainLossLedgerDimension;
        LedgerDimensionDefaultAccount unrealizedExchGainLossLedgerDimensionAccounting;
        LedgerDimensionDefaultAccount unrealizedExchGainLossLedgerDimensionReporting;
        LedgerDimensionDefaultAccount realizedExchGainLossLedgerDimensionAccounting;
        LedgerDimensionDefaultAccount realizedExchGainLossLedgerDimensionReporting;
        boolean useCustVendExchPostingEngine;
        Counter unrealizedSign = 1;
        CustVendTrans exchRateTrans = _custVendTrans.data();
        LedgerVoucher ledgerVoucher;
        LedgerVoucher paymentLedgerVoucher;
        LedgerVoucherObject ledgerVoucherObject;
        TransactionTxt exchDiffText;
        TransactionTxt paymentExchDiffText;
        boolean postLedgerToPaymentCompany = false;
        CustVendTrans lastExchAdjTrans;
        AmountMST exchRateDiffForPaymCompanyAccounting;
        AmountMSTSecondary exchRateDiffForPaymCompanyReporting;
        LedgerInterCompany interCompany;
        DimensionDefault exchGainLossDefaultDimension;
        CustVendExchAdjPostingEngine custVendExchAdjPostingEngine;

        // <GEERU><GEECZ>
        TaxAmount taxAmount = 0;
        LedgerBondClient_RU ledgerBondClient;
        LedgerCurrencyParameters_RU ledgerCurrencyParameters;
        RTax25ExchAdjDimension exchAdjDimension;
        LedgerPostingType posting;
        boolean countryRegion_EE = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU]);
        boolean vatTransitAmountDiffPosted;
        CustVendTrans_W custVendTrans_W;
        boolean isRegisterApprovalInvoice;
        // </GEECZ></GEERU>

        Debug::assert(curext() == _custVendTrans.company());

        isInsidePostExchRateDiff = true;
        
        useCustVendExchPostingEngine = (!countryRegion_EE);

        // <GEERU><GEECZ>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]) && _custVendTrans.TableId == tableNum(VendTrans) && _custVendTrans.Invoice)
        {
            VendTrans approvalVendTrans = _custVendTrans;
            LedgerJournalVoucherChanged ledgerJournalVoucherChanged;
        
            select firstonly RecId from ledgerJournalVoucherChanged
                where ledgerJournalVoucherChanged.ToVoucher == approvalVendTrans.Voucher &&
                   ledgerJournalVoucherChanged.ToDate == approvalVendTrans.TransDate;

            isRegisterApprovalInvoice = ledgerJournalVoucherChanged.RecId != 0
                                        && LedgerJournalTable::find(approvalVendTrans.JournalNum).JournalType == LedgerJournalType::Approval;
        }

        boolean countryRegion_RUCZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ])
                                    || (CurrencyLedgerGainLossFromNetValueFeature_PL::isEnabled() && !isRegisterApprovalInvoice);

        boolean isCustVendExchAdjLedgerDimensionFlightEnabled = CustVendExchAdjLedgerDimensionFlight::instance().isEnabled();

        if (countryRegion_RUCZ)
        {
            exchAdjDimension = new RTax25ExchAdjDimension();
        }
        // </GEECZ></GEERU>

        if (_ledgerVoucher == null)
        {
            ledgerVoucher = settlementPair.findLedgerVoucherByCompany(_custVendTrans.company());
        }
        else
        {
            ledgerVoucher = _ledgerVoucher;
        }

        exchDiffText = TransactionTxt::construct(this.exchAdjTxt(),
                                          _custVendTrans.languageId(),
                                          settlementPair.getTransactionDate(),
                                          _custVendTrans.Invoice,
                                          _custVendTrans.Voucher);

        if (_unrealized)
        {
            unrealizedSign = -1;
        }

        // <GEERU><GEECZ>
        if (CustVendTransPostingLog_RU::usePostingLog())
        {
            ledgerVoucherObject = this.createLedgerVoucherObject_RU(ledgerVoucher);
        }
        // </GEECZ></GEERU>
        exchRateTrans.clear();
        // <GEERU><GEECZ>
        if (countryRegion_RUCZ)
        {
            exchRateTrans.RecId = settlementGroupPlaceHolder;  // this enables correct tax reference creation when posting tax on exch rate difference
        }
        // </GEECZ></GEERU>
        exchRateTrans.OffsetRecId           = _custVendTrans.RecId;
        exchRateTrans.PaymReference         = settlementPair.getCustVendTransCredit().PaymReference;
        exchRateTrans.AccountNum            = _custVendTrans.AccountNum;
        exchRateTrans.Invoice               = _custVendTrans.Invoice;
        exchRateTrans.Approved              = NoYes::Yes;

        exchRateTrans.Txt                    = exchDiffText.txt();

        exchRateTrans.Closed                 = CustVendTransData::construct(exchRateTrans).maxSettlementDate(settlementPair.getTransactionDate());
        exchRateTrans.TransType              = LedgerTransType::ExchAdjustment;

        exchRateTrans.CurrencyCode           = _custVendTrans.CurrencyCode;

        // <GEERU><GEECZ>
        if (countryRegion_RUCZ)
        {
            posting = this.getLedgerPostingType_ExchRate(-_exchRateDiff);
        }
        // </GEECZ></GEERU>
        if (_unrealized)
        {
            lastExchAdjTrans = CustVendTransStatic::newTrans(_custVendTrans).findVoucherDate(
                                                                                 _custVendTrans.LastExchAdjVoucher,
                                                                                 _custVendTrans.LastExchAdj);
            postingProfile                  = lastExchAdjTrans.PostingProfile;
            exchRateTrans.DefaultDimension  = lastExchAdjTrans.DefaultDimension;

            exchRateTrans.ExchAdjustmentUnrealized  = _exchRateDiff;
            exchRateTrans.ExchAdjustment            = _exchRateDiff;
            // <GEERU><GEECZ>
            if (countryRegion_EE)
            {
                exchRateTrans.Correct               = true;
            }
            if (countryRegion_RUCZ)
            {
                exchRateTrans.Correct               = true;
                custVendTrans_W = exchRateTrans.CustVendTrans::getCustVendTrans_W();
                custVendTrans_W.CorrectReporting_RU = true;
                exchRateTrans.CustVendTrans::packCustVendTrans_W(custVendTrans_W);
            }
            // </GEECZ></GEERU>

            exchRateTrans.ReportingExchAdjustmentUnrealized = _exchRateReportingDiff;
            exchRateTrans.ExchAdjustmentReporting = _exchRateReportingDiff;

            // the date on the reversal of unrealized exchange adjustment should be
            // the greater of last exchange adjustment date or the settlement date based on
            // the settlement posting date selection.
            exchRateTrans.TransDate = max(_custVendTrans.LastExchAdj, settlementPair.getTransactionDate());
        }
        else
        {
            postingProfile                          = _custVendTrans.PostingProfile;
            exchRateTrans.DefaultDimension          = _custVendTrans.DefaultDimension;
            exchRateTrans.ExchAdjustmentRealized    = -_exchRateDiff;
            exchRateTrans.ExchAdjustment            = -_exchRateDiff;

            exchRateTrans.ReportingExchAdjustmentRealized = -_exchRateReportingDiff;
            exchRateTrans.ExchAdjustmentReporting = -_exchRateReportingDiff;

            exchRateTrans.TransDate = settlementPair.getTransactionDate();
            // <GEERU><GEECZ>
            if (countryRegion_RUCZ)
            {
                ledgerCurrencyParameters = LedgerCurrencyParameters_RU::findParameters(Ledger::current(), _custVendTrans.CurrencyCode);
                exchAdjDimension.setProfitIds(ledgerCurrencyParameters.rTax25ProfitTableProfit, ledgerCurrencyParameters.rTax25ProfitTableLoss);

                exchAdjDimension.parmExchAdjType(RTax25ExchAdjDimension::postingType2AdjType(this.getLedgerPostingType_ExchRate(-_exchRateReportingDiff)));
                custVendTrans_W = exchRateTrans.CustVendTrans::getCustVendTrans_W();
                custVendTrans_W.DefaultDimensionReporting_RU = exchAdjDimension.getDefaultDimension(_custVendTrans.DefaultDimension);
                exchRateTrans.CustVendTrans::packCustVendTrans_W(custVendTrans_W);

                exchAdjDimension.parmExchAdjType(RTax25ExchAdjDimension::postingType2AdjType(posting));
                exchRateTrans.DefaultDimension = exchAdjDimension.getDefaultDimension(_custVendTrans.DefaultDimension);
            }
            // </GEECZ></GEERU>
        }

        if (useCustVendExchPostingEngine)
        {
            // If a new LedgerVoucherObject is created, it will be appended to the current ledgerVoucher. The return of this method is intentionally dropped.
            settlementPair.findOrCreateLedgerVoucherObjectByDate(ledgerVoucher, exchRateTrans.TransDate);
        }

        exchRateTrans.Voucher = ledgerVoucher.lastVoucher();

        exchRateTrans.AmountMST = _exchRateDiff * unrealizedSign;
        exchRateTrans.AmountCur = 0;
        exchRateTrans.ReportingCurrencyAmount = _exchRateReportingDiff * unrealizedSign;
        exchRateTrans.ExchRate = 100;
        exchRateTrans.ExchRateSecond = 0;
        exchRateTrans.ReportingCurrencyExchRate = 100.0;
        exchRateTrans.ReportingCurrencyCrossRate = 100.0;
        exchRateTrans.SettleAmountMST = _exchRateDiff * unrealizedSign;
        exchRateTrans.SettleAmountCur = 0;
        exchRateTrans.SettleAmountReporting = _exchRateReportingDiff * unrealizedSign;

        exchRateTrans.LastSettleDate        = exchRateTrans.TransDate;
        exchRateTrans.LastSettleVoucher     = _custVendTrans.Voucher;
        exchRateTrans.LastSettleAccountNum  = _custVendTrans.AccountNum;
        exchRateTrans.LastSettleCompany     = _custVendTrans.DataAreaId;

        exchRateTrans.initFromPostingProfile(postingProfile);
        this.reverseAmounts(exchRateTrans);

        custVendTransSettlement.addTransAndDefaultSettlement(exchRateTrans, settlementGroupPlaceHolder);

        this.reverseAmounts(exchRateTrans);

        if (settlementPair.getDebitCompany() != settlementPair.getCreditCompany() && _unrealized == false)
        {
            // Should already have the credit transaction ledgerInterCompany record
            interCompany = this.findLedgerInterCompany(settlementPair.getCreditCompany(), settlementPair.getDebitCompany());

            // check if exchange adjustment should be posted to payment company
            if (interCompany.getCurrencyExchPostOptions(this.parmModule()) == CustVendSettleCompanyPostOption::PaymentCompany)
            {
                changecompany(settlementPair.getCreditCompany())
                {
                    postLedgerToPaymentCompany = true;
                    paymentLedgerVoucher = settlementPair.findLedgerVoucherByCompany(settlementPair.getCreditCompany());

                    paymentExchDiffText = TransactionTxt::construct(this.exchAdjTxt(LedgerJournalACType::Ledger),
                        settlementPair.getCustVendTransCredit().languageId(),
                        settlementPair.getTransactionDate(),
                        settlementPair.getCustVendTransCredit().Invoice,
                        settlementPair.getCustVendTransCredit().Voucher);

                    ledgerVoucherObject = paymentLedgerVoucher.findLedgerVoucherObject();
                    ledgerVoucherObject.lastTransTxt(paymentExchDiffText.txt());
                    ledgerVoucherObject.parmPaymentReference(settlementPair.getCustVendTransCredit().PaymReference);

                    if (_exchRateDiff != 0)
                    {
                        // find the ledger account for the gain or loss this will be the account for the invoice company MST currency
                        exchGainLossLedgerDimension = this.accountRealizedGainLossFromPostingProfile(-_exchRateDiff, settlementPair.getDebitCompanyCurrency(), _custVendTrans.AccountNum);

                        [exchRateDiffForPaymCompanyAccounting, exchRateDiffForPaymCompanyReporting] = settlementPair.calcRealizedExchAdjAmountForPaymentCompany(_exchRateDiff);

                        // create ledger trans for the gain of loss account in the credit company,
                        // also use the credit transaction dimension.
                        this.postExchRateLedgerTrans(
                            paymentLedgerVoucher,
                            this.getLedgerPostingType_ExchRate(- exchRateDiffForPaymCompanyAccounting),
                            this.amount(exchRateDiffForPaymCompanyAccounting * unrealizedSign),
                            this.amount(exchRateDiffForPaymCompanyReporting * unrealizedSign),
                            exchGainLossLedgerDimension,
                            dueToFromLedgerDimensionCredit,
                            settlementPair.getCustVendTransCredit(),
                            exchRateTrans.TransDate,
                            settlementPair.getCustVendTransCredit().DefaultDimension,
                            0,
                            creditSettleDistController, // use the credit's controller explicitly
                            // <GEERU>
                            _unrealized,
                            exchRateTrans);
                            // </GEERU>
                    }
                }
            }
        }

        exchGainLossDefaultDimension = exchRateTrans.DefaultDimension;

        ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
        exchDiffText.setType(this.exchAdjTxt(LedgerJournalACType::Ledger));
        ledgerVoucherObject.lastTransTxt(exchDiffText.txt());
        ledgerVoucherObject.parmPaymentReference(settlementPair.getCustVendTransCredit().PaymReference);

        if (isCustVendExchAdjLedgerDimensionFlightEnabled)
        {
            custVendExchAdjPostingEngine = CustVendExchAdjPostingEngine::constructForSettlements(this.parmModule(),
            ledgerVoucher,
            exchRateTrans.TransDate,
            _custVendTrans,
            _unrealized,
            isSettleByLineEnabled,
            settlementPair.getSpecTransDebit().RecId);
        }

        // accounting currency and reporting currency exchange differences are handled separately due to the different gain/loss ledger dimensions

        if (_exchRateDiff != 0)
        {
            if (_unrealized)
            {
                if (isCustVendExchAdjLedgerDimensionFlightEnabled && custVendExchAdjPostingEngine.hasPreviousAccountingExchAdjLedgerDimension())
                {
                    exchGainLossLedgerDimension = custVendExchAdjPostingEngine.getLastAccountingExchAdjDimensionDefaultAccount();
                }
                else
                {
                    exchGainLossLedgerDimension = this.accountUnrealizedGainLossFromPostingProfile(_exchRateDiff, _custVendTrans.CurrencyCode, _custVendTrans.AccountNum);
                }
                unrealizedExchGainLossLedgerDimensionAccounting = exchGainLossLedgerDimension;
            }
            else
            {
                if (postLedgerToPaymentCompany)
                {
                    // the account with be the due from acount from the ledger intercompany
                    exchGainLossLedgerDimension = dueToFromLedgerDimensionDebit;
                }
                else
                {
                    exchGainLossLedgerDimension = this.accountRealizedGainLossFromPostingProfile(-_exchRateDiff, _custVendTrans.CurrencyCode, _custVendTrans.AccountNum);
                }

                realizedExchGainLossLedgerDimensionAccounting = exchGainLossLedgerDimension;
            }
            // <GEERU><GEECZ>
            if (countryRegion_RUCZ)
            {
                ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();
                if (ledgerBondClient)
                {
                    ledgerBondClient.addNewLogObject();
                }

                if (_custVendTrans.Invoice && ! _unrealized && TaxParameters::find().ExchRateDiffDocType_RU == CustVendExchRateDiffDocType_RU::Invoice)
                {
                    taxAmount = this.calcAndPostTaxExchRateDiff_RU(_exchRateDiff,
                        _custVendTrans,
                        posting,
                        exchRateTrans,
                        null,
                        false,
                        false,
                        0,
                        CurrencyLedgerGainLossFromNetValueFeature_PL::isEnabled());
                }

                taxAmount = _custVendTrans.TableId == tableNum(VendTrans) || ! TaxParameters::find().TaxSpecPosting_RU ? taxAmount : 0.0;

                if (_custVendTrans.TableId == tableNum(VendTrans))
                {
                    taxAmount = -taxAmount;
                    taxAmountUseTaxTotal = -taxAmountUseTaxTotal;
                }
                else
                {
                    taxAmountUseTaxTotal = 0;
                }
            }
            // </GEECZ></GEERU>

            if (!useCustVendExchPostingEngine)
            {
                this.postExchRateLedgerTrans(
                    ledgerVoucher,
                    this.getLedgerPostingType_ExchRate(- _exchRateDiff),
                    // <GEERU>
                    this.amount(_exchRateDiff * unrealizedSign + taxAmount + taxAmountUseTaxTotal),
                    // </GEERU>
                    0.0, // no reporting exchange diff value
                    exchGainLossLedgerDimension,
                    exchRateTrans.summaryLedgerDimension(),
                    _custVendTrans,
                    exchRateTrans.TransDate,
                    exchGainLossDefaultDimension,
                    exchRateTrans.DefaultDimension,
                    _distributionController,
                    // <GEERU>
                    _unrealized,
                    exchRateTrans);
                    // </GEERU>
            }

            // <GEERU><GEECZ>
            if (countryRegion_RUCZ)
            {
                if (taxAmount)
                {
                    if (CurrencyLedgerGainLossFromNetValueFeature_PL::isEnabled())
                    {
                        GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferencePL00049, funcName());
                    }

                    TaxAmount taxAmountWithoutUseTax = taxAmount + taxAmountUseTaxTotal;
                    if (taxAmountWithoutUseTax)
                    {
                        this.createLedgerTransSum_RU(taxAmountWithoutUseTax,
                                                     posting,
                                                     0,
                                                     exchRateTrans,
                                                     false,
                                                     CustVendTransPostingLogType_RU::ExchAdjustment,
                                                     taxTransRecIDs,
                                                     exchRateTrans.DefaultDimension,
                                                     exchRateTrans.CurrencyCode);
                    }

                    if (ledgerBondClient)
                    {
                        ledgerBondClient.bondLastVRef2CurrentLog();
                    }

                    this.postVATTransitAmountDiff_RU(exchRateTrans, false);
                    vatTransitAmountDiffPosted = true;
                }
                else if (taxTransRecIDs && ! taxTransRecIDs.empty())
                {
                    this.createPostingTransLog_RU(CustVendTransPostingLogType_RU::ExchAdjustment,
                                                  exchRateTrans,
                                                  posting,
                                                  0,
                                                  0,
                                                  0,
                                                  0,
                                                  taxTransRecIDs);
                }

                if (ledgerBondClient)
                {
                    ledgerBondClient.removeCurrentLogObject();
                }
            }
            // </GEECZ></GEERU>
        }

        taxAmountUseTaxTotal = 0;
        if (_exchRateReportingDiff != 0)
        {
            if (_unrealized)
            {
                if (isCustVendExchAdjLedgerDimensionFlightEnabled && custVendExchAdjPostingEngine.hasPreviousReportingExchAdjLedgerDimension())
                {
                    exchGainLossLedgerDimension = custVendExchAdjPostingEngine.getLastReportingExchAdjDimensionDefaultAccount();
                }
                else
                {
                    exchGainLossLedgerDimension = this.accountUnrealizedGainLossFromPostingProfile(_exchRateReportingDiff, _custVendTrans.CurrencyCode, _custVendTrans.AccountNum);
                }
                unrealizedExchGainLossLedgerDimensionReporting = exchGainLossLedgerDimension;
            }
            else
            {
                exchGainLossLedgerDimension = this.accountRealizedGainLossFromPostingProfile(-_exchRateReportingDiff, _custVendTrans.CurrencyCode, _custVendTrans.AccountNum);
                realizedExchGainLossLedgerDimensionReporting = exchGainLossLedgerDimension;
            }
            // <GEERU><GEECZ>
            if (countryRegion_RUCZ)
            {
                ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();
                if (ledgerBondClient)
                {
                    ledgerBondClient.addNewLogObject();
                }

                if (_custVendTrans.Invoice && ! _unrealized && TaxParameters::find().ExchRateDiffDocType_RU == CustVendExchRateDiffDocType_RU::Invoice)
                {
                    taxAmount = this.calcAndPostTaxExchRateDiff_RU(_exchRateReportingDiff,
                        _custVendTrans,
                        posting,
                        exchRateTrans,
                        null,
                        false,
                        true,
                        0,
                        CurrencyLedgerGainLossFromNetValueFeature_PL::isEnabled());
                }

                taxAmount = _custVendTrans.TableId == tableNum(VendTrans) || ! TaxParameters::find().TaxSpecPosting_RU ? taxAmount : 0.0;

                if (_custVendTrans.TableId == tableNum(VendTrans))
                {
                    taxAmount = -taxAmount;
                    taxAmountUseTaxTotal = -taxAmountUseTaxTotal;
                }
                else
                {
                    taxAmountUseTaxTotal = 0;
                }
            }
            // </GEECZ></GEERU>

            if (!useCustVendExchPostingEngine)
            {
                this.postExchRateLedgerTrans(
                    ledgerVoucher,
                    this.getLedgerPostingType_ExchRate(- _exchRateReportingDiff),
                    0.0, // no accounting exchange diff value
                    this.amount(_exchRateReportingDiff * unrealizedSign + taxAmount + taxAmountUseTaxTotal),
                    exchGainLossLedgerDimension,
                    exchRateTrans.summaryLedgerDimension(),
                    _custVendTrans,
                    exchRateTrans.TransDate,
                    exchGainLossDefaultDimension,
                    exchRateTrans.DefaultDimension,
                    _distributionController,
                    // <GEERU>
                    _unrealized,
                    exchRateTrans);
                    // </GEERU>
            }

            // <GEERU><GEECZ>
            if (countryRegion_RUCZ)
            {
                if (taxAmount)
                {
                    TaxAmount taxAmountWithoutUseTax = taxAmount + taxAmountUseTaxTotal;
                    if (taxAmountWithoutUseTax)
                    {
                        this.createLedgerTransSum_RU(taxAmountWithoutUseTax,
                            posting,
                            0,
                            exchRateTrans,
                            false,
                            CustVendTransPostingLogType_RU::ExchAdjustment,
                            taxTransRecIDs,
                            exchRateTrans.DefaultDimension,
                            exchRateTrans.CurrencyCode,
                            this.parmLedgerVoucher_W(),
                            exchRateTrans.Correct,
                            0,
                            settlementPair.getCustVendTransDebit(),
                            settlementPair.getCustVendTransCredit(),
                            false,
                            false,
                            0,
                            0,
                            0,
                            false,
                            true);
                    }

                    if (ledgerBondClient)
                    {
                        ledgerBondClient.bondLastVRef2CurrentLog();
                    }

                    if (!vatTransitAmountDiffPosted)
                    {
                        this.postVATTransitAmountDiff_RU(exchRateTrans, false);
                    }
                }

                this.createTaxPostingTransLog_RU(exchRateTrans, ledgerVoucher.findLedgerVoucherObject().parmCorrection());

                if (ledgerBondClient)
                {
                    ledgerBondClient.removeCurrentLogObject();
                }
            }
            // </GEECZ></GEERU>
        }

        if (useCustVendExchPostingEngine && (_exchRateDiff != 0 || _exchRateReportingDiff !=0 ))
        {
            if (!isCustVendExchAdjLedgerDimensionFlightEnabled || !custVendExchAdjPostingEngine)
            {
                custVendExchAdjPostingEngine = CustVendExchAdjPostingEngine::constructForSettlements(this.parmModule(),
                    ledgerVoucher,
                    exchRateTrans.TransDate,
                    _custVendTrans,
                    _unrealized,
                    isSettleByLineEnabled,
                    settlementPair.getSpecTransDebit().RecId);
            }

            if (_unrealized)
            {
                custVendExchAdjPostingEngine.addReversalExchangeAdjustment(
                    this.amount(_exchRateDiff * unrealizedSign),
                    unrealizedExchGainLossLedgerDimensionAccounting,
                    this.amount(_exchRateReportingDiff * unrealizedSign),
                    unrealizedExchGainLossLedgerDimensionReporting);
            }
            else
            {
                custVendExchAdjPostingEngine.addRealizedExchangeAdjustment(
                    this.amount(_exchRateDiff * unrealizedSign),
                    realizedExchGainLossLedgerDimensionAccounting,
                    this.amount(_exchRateReportingDiff * unrealizedSign),
                    realizedExchGainLossLedgerDimensionReporting);
            }
        }

        isInsidePostExchRateDiff = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postExchRateLedgerTrans</Name>
				<Source><![CDATA[
    protected void postExchRateLedgerTrans(LedgerVoucher _ledgerVoucher,
        LedgerPostingType _posting,
        AmountMST _exchRateDiffAccounting,
        Money _exchRateDiffReporting,
        LedgerDimensionDefaultAccount _ledgerProfitLossDimension,
        LedgerDimensionDefaultAccount _ledgerSumDimension,
        CustVendTrans _custVendTrans,
        TransDate _transDate,
        DimensionDefault _profitLossDefaultDimension,
        DimensionDefault _accountSumDefaultDimension,
        CustVendTransSettleDistController _distributionController,
        boolean _unrealized,
        CustVendTrans _exchRateTrans)
    {
        Voucher originalReferenceNumber;
        TransDate originalAccountingDate;
        TransTxt originalTransTxt;
        boolean isFound;
        LedgerPostingController ledgerPostingController;
        LedgerVoucherObject ledgerVoucherObject;
        LedgerDimensionAccount mergedLedgerDimension;
        LedgerVoucherTransObject ledgerVoucherTransObject;
        List distributions;
        ListEnumerator distributionEnumerator;
        CustVendTransDistribution distribution;
        boolean forceSingleDistribution;
        CustExchRateAdjustment custExchRateAdjustment;
        VendExchRateAdjustment vendExchRateAdjustment;
        CustVendTrans adjustmentCustVendTrans = this.initCustVendTransBuffer();
        MainAccountRecId profitLossMainAccountRecId;
        MainAccountLegalEntity profitLossMainAccountForLegalEntity;
        // <GEERU><GEECZ>
        LedgerCurrencyParameters_RU ledgerCurrencyParameters;
        RTax25ExchAdjDimension exchAdjDimension;
        LedgerBondClient_RU ledgerBondClient;
        CustVendTransPostingLog_RU custVendTransPostingLog;
        DimensionDefault defaultDimension;
        boolean countryRegion_EE = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU]);
        boolean countryRegion_RUCZPL = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ, #isoPL]);
        // </GEECZ></GEERU>

        if (_exchRateDiffAccounting == 0 && _exchRateDiffReporting == 0)
        {
            return;
        }

        ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();

        ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(_ledgerVoucher);
        ledgerVoucherObject = ledgerPostingController.getReference();

        originalReferenceNumber = ledgerVoucherObject.parmReferenceNumber();
        originalAccountingDate = ledgerVoucherObject.parmAccountingDate();
        originalTransTxt = ledgerVoucherObject.lastTransTxt();

        if (originalAccountingDate != _transDate)
        {
            // Search for and update the posting reference (LedgerVoucherObject).
            isFound = ledgerPostingController.findReference(originalReferenceNumber, _transDate);

            if (!isFound)
            {
                // No posting reference exists, so it needs to be created.
                ledgerVoucherObject = LedgerVoucherObject::newVoucher(
                    originalReferenceNumber,
                    _transDate,
                    this.parmModule(),
                    this.ledgerTransactionType());

                ledgerPostingController.addReference(ledgerVoucherObject);
            }

            // Transaction text on the LedgerVoucherObject is normally set in the calling method postExchRateDiff().
            // Because a different posting reference is used, make sure this has the correct transaction text.
            ledgerVoucherObject.lastTransTxt(originalTransTxt);
        }
        // <GEERU>
        ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();
        if (ledgerBondClient)
        {
            ledgerBondClient.addNewLogObject();
        }
        // </GEERU>

        // post to the gain/loss account

        // <GEERU><GEECZ><GEEPL>
        if (countryRegion_RUCZPL)
        {
            exchAdjDimension = new RTax25ExchAdjDimension();
            ledgerCurrencyParameters = LedgerCurrencyParameters_RU::findParameters(Ledger::current(), _custVendTrans.CurrencyCode);
            exchAdjDimension.setProfitIds(ledgerCurrencyParameters.rTax25ProfitTableProfit, ledgerCurrencyParameters.rTax25ProfitTableLoss);
            exchAdjDimension.parmExchAdjType(RTax25ExchAdjDimension::postingType2AdjType(_posting));
            defaultDimension = exchAdjDimension.getDefaultDimension(_profitLossDefaultDimension);
            mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerProfitLossDimension, defaultDimension);
        }
        else
        {
            // </GEECZ></GEERU></GEEPL>

            if (_unrealized)
            {
                mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerProfitLossDimension, _profitLossDefaultDimension);
            }
            else
            {
                profitLossMainAccountRecId = LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(_ledgerProfitLossDimension);
                profitLossMainAccountForLegalEntity = MainAccountLegalEntity::findByMainAccountLegalEntity(profitLossMainAccountRecId, CompanyInfo::current());
                mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerProfitLossDimension, _profitLossDefaultDimension, profitLossMainAccountForLegalEntity.DefaultDimension);
            }

            // <GEERU>
        }
        // </GEERU>
        ledgerVoucherTransObject = this.initializeLedgerVoucherTransObjectByLedgerDimension(
            ledgerVoucherObject,
            _posting,
            mergedLedgerDimension,
            _custVendTrans.CurrencyCode,
            -_exchRateDiffAccounting,
            -_exchRateDiffReporting);

        // <GEERU><GEECZ>
        if (countryRegion_EE)
        {
            ledgerVoucherTransObject.parmCorrect(_exchRateTrans.Correct);
        }
        // </GEECZ></GEERU>
        ledgerPostingController.addTrans(ledgerVoucherTransObject);

        if (CurrencyLedgerGainLossFromNetValueFeature_PL::isEnabled() && exchRateDiffTaxLedgerVoucherTransObjectTempRecIDs)
        {
            LedgerDimensionAccount taxLedgerDimension = custVendExchAdjParm.taxLedgerDimension(_posting, 0);
            DimensionDefault dimensionDefault = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(mergedLedgerDimension);
            exchRateDiffTaxMergedLedgerDimension = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(
                LedgerDimensionFacade::serviceCreateLedgerDimension(taxLedgerDimension, dimensionDefault),
                taxLedgerDimension);

            LedgerVoucherTransList transactionCollection = ledgerVoucherObject.getInternalCollection();
            boolean haveMore = transactionCollection.first();

            while (haveMore)
            {
                LedgerVoucherTransObject trans = transactionCollection.item();
                if (exchRateDiffTaxLedgerVoucherTransObjectTempRecIDs.in(trans.parmTempRecId())
                    && trans.parmLedgerDimensionId() != exchRateDiffTaxMergedLedgerDimension)
                {
                    trans.parmLedgerDimensionId(exchRateDiffTaxMergedLedgerDimension);
                    transactionCollection.update(trans);
                }

                haveMore = transactionCollection.next();
            }
        }

        // post to the summary account

        if (_unrealized)
        {
            // we are currently undoing a previously posted unrealized exchange adjustment
            // need to determine whether the adjustment was created with dimensions based on the original transaction to properly back it out
            // if the exchange adjustment was NOT generated with the option to get dimensions from the Transaction, then we force single distribution
            // to be created for the ledger dimemsion account value based on values from the exchange adjustment trans record

            // there is no Map that combines CustExchRateAdjustment and VendExchRateAdjustment, thus the separate implementation
            if (this.moduleCustVend() == ModuleCustVend::Cust)
            {
                select firstonly Dimensions, CreatedTransactionId from custExchRateAdjustment
                    exists join CreatedTransactionId from adjustmentCustVendTrans
                    where custExchRateAdjustment.CreatedTransactionId == adjustmentCustVendTrans.CreatedTransactionId &&
                          adjustmentCustVendTrans.Voucher == _custVendTrans.LastExchAdjVoucher &&
                          adjustmentCustVendTrans.TransDate == _custVendTrans.LastExchAdj &&
                          adjustmentCustVendTrans.TransType == LedgerTransType::ExchAdjustment;

                forceSingleDistribution = (custExchRateAdjustment.Dimensions != NoneTableTrans::Transaction);
            }
            else
            {
                select firstonly Dimensions, CreatedTransactionId from vendExchRateAdjustment
                    exists join CreatedTransactionId from adjustmentCustVendTrans
                    where vendExchRateAdjustment.CreatedTransactionId == adjustmentCustVendTrans.CreatedTransactionId &&
                          adjustmentCustVendTrans.Voucher == _custVendTrans.LastExchAdjVoucher &&
                          adjustmentCustVendTrans.TransDate == _custVendTrans.LastExchAdj &&
                          adjustmentCustVendTrans.TransType == LedgerTransType::ExchAdjustment;

                forceSingleDistribution = (vendExchRateAdjustment.Dimensions != NoneTableTrans::Transaction);
            }
        }
        else
        {
            // allow distributions to be generated normally for realized gains
            forceSingleDistribution = false;
        }

        // <GEERU><GEECZ><GEEPL>
        if (countryRegion_RUCZPL)
        {
            mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerSumDimension, defaultDimension);
        }
        else
        {
            // </GEECZ></GEERU></GEEPL>
            mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerSumDimension, _accountSumDefaultDimension);
            // <GEERU>
        }
        // </GEERU>
        distributions = _distributionController.generateDistributions(
            _custVendTrans,
            this.getLedgerPostingType_Balance(),
            0,                      // there is no transction currency value for a currency exchange adjustment
            _exchRateDiffAccounting,
            _exchRateDiffReporting,
            mergedLedgerDimension,
            forceSingleDistribution);

        distributionEnumerator = distributions.getEnumerator();
        while (distributionEnumerator.moveNext())
        {
            distribution = distributionEnumerator.current();

            // accounting and reporting adjustment values are posted individually

            if (distribution.accountingAmount() != 0.0)
            {
                ledgerVoucherTransObject = this.initializeLedgerVoucherTransObjectByLedgerDimension(
                    ledgerVoucherObject,
                    _posting,
                    distribution.ledgerDimension(),
                    _custVendTrans.CurrencyCode,
                    distribution.accountingAmount(),
                    0.0);

                ledgerVoucherTransObject.parmSkipDimensionValidation(true);

                // <GEERU><GEECZ>
                if (countryRegion_EE)
                {
                    ledgerVoucherTransObject.parmCorrect(_exchRateTrans.Correct);
                    ledgerVoucherTransObject.parmLedgerPostingType(this.getLedgerPostingType_Balance());

                    if (CurrencyLedgerGainLossFromNetValueFeature_PL::isEnabled()
                        && (   ledgerVoucherTransObject.parmPostingType() == LedgerPostingType::CustBalance
                            || ledgerVoucherTransObject.parmPostingType() == LedgerPostingType::VendBalance))
                    {
                        ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::Summary);
                    }
                }
                // </GEECZ></GEERU>
                ledgerPostingController.addTrans(ledgerVoucherTransObject);
            }

            if (distribution.reportingAmount() != 0.0)
            {
                ledgerVoucherTransObject = this.initializeLedgerVoucherTransObjectByLedgerDimension(
                    ledgerVoucherObject,
                    _posting,
                    distribution.ledgerDimension(),
                    _custVendTrans.CurrencyCode,
                    0.0,
                    distribution.reportingAmount());

                ledgerVoucherTransObject.parmSkipDimensionValidation(true);

                // <GEERU><GEECZ>
                if (countryRegion_EE)
                {
                    ledgerVoucherTransObject.parmCorrect(_exchRateTrans.Correct);
                    ledgerVoucherTransObject.parmLedgerPostingType(this.getLedgerPostingType_Balance());

                    if (CurrencyLedgerGainLossFromNetValueFeature_PL::isEnabled()
                        && (   ledgerVoucherTransObject.parmPostingType() == LedgerPostingType::CustBalance
                            || ledgerVoucherTransObject.parmPostingType() == LedgerPostingType::VendBalance))
                    {
                        ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::Summary);
                    }
                }
                // </GEECZ></GEERU>
                ledgerPostingController.addTrans(ledgerVoucherTransObject);
            }

            // <GEEU>
            if (!_exchRateTrans.Correct && CustVendTransPostingLog_RU::usePostingLog() && (distribution.accountingAmount() || distribution.reportingAmount()))
            {
                this.createPostingTransLog_RU(CustVendTransPostingLogType_RU::ExchAdjustment,
                                                _exchRateTrans,
                                                _posting,
                                                _ledgerProfitLossDimension,
                                                distribution.ledgerDimension(),
                                                - distribution.accountingAmount(),
                                                - distribution.reportingAmount(),
                                                null,
                                                _profitLossDefaultDimension,
                                                0,
                                                _custVendTrans,
                                                _custVendTrans.RecId == settlementPair.getCustVendTransCredit().RecId ? settlementPair.getCustVendTransDebit() : settlementPair.getCustVendTransCredit());
                if (custVendTransPostingLog)
                {
                    custVendTransPostingLog.OffsetLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(custVendTransPostingLog.OffsetLedgerDimension, defaultDimension);
                    custVendTransPostingLog.update();
                }
            }
            // </GEEU>
        }

        // <GEERU>
        if (ledgerBondClient)
        {
            ledgerBondClient.bondLog2Log();
            ledgerBondClient.removeCurrentLogObject();
        }
        // </GEERU>
        isFound = ledgerPostingController.findReference(originalReferenceNumber, originalAccountingDate);
        Debug::assert(isFound);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLedgerVoucherTransObjectByLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>LedgerVoucherTransObject</c> class.
    /// </summary>
    /// <param name = "_defaultLedgerPostingReference">
    /// The ledger posting reference used for defaulting.
    /// </param>
    /// <param name = "_postingType">
    /// The posting type of the general journal entry.
    /// </param>
    /// <param name = "_ledgerDimensionId">
    /// The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name = "_transactionCurrencyCode">
    /// The currency code of the general journal entry.
    /// </param>
    /// <param name = "_accountingCurrencyAmount">
    /// The amount in the accounting currency.
    /// </param>
    /// <param name = "_reportingCurrencyAmount">
    /// The amount in the reporting currency.
    /// </param>
    /// <returns>
    /// A new instance of the <c>LedgerVoucherTransObject</c> class.
    /// </returns>
    [Wrappable(true)]
    protected final LedgerVoucherTransObject initializeLedgerVoucherTransObjectByLedgerDimension(
        LedgerVoucherObject _defaultLedgerPostingReference,
        LedgerPostingType _postingType,
        LedgerDimensionAccount _ledgerDimensionId,
        CurrencyCode _transactionCurrencyCode,
        MoneyMST _accountingCurrencyAmount,
        MoneyMST _reportingCurrencyAmount)
                                                                                                  
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
            _defaultLedgerPostingReference,
            _postingType,
            _ledgerDimensionId,
            _transactionCurrencyCode,
            _accountingCurrencyAmount,
            _reportingCurrencyAmount);

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postFineTrans_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and post fine transaction for the settlement.
    /// </summary>
    /// <param name="_fineAmountCur">
    /// The Fine amount in the transaction currency.
    /// </param>
    /// <param name="_fineAmountMst">
    /// The Fine amount in the monetary standard (MST) currency.
    /// </param>
    /// <param name="_custVendTrans">
    /// The CustVendTrans record used to create the transaction.
    /// </param>
    /// <param name="_custVendTransOpen">
    /// The CustVendTransOpen record used to create the transaction.
    /// </param>
    /// <param name="_custVendTransOffset">
    /// The CustVendTrans record that is the offset of the Fine transaction.
    /// </param>
    /// <param name="_exchRate">
    /// The exchange rate of the Fine.
    /// </param>
    /// <param name="_fineLedgerDimension">
    /// The Fine ledger dimension default account.
    /// </param>
    /// <param name="_settledAmountMstDebit">
    /// The settled amount of the debit transaction in MST currency.
    /// </param>
    /// <param name="_distributionController">
    /// The <c>CustVendTransSettleDistController</c> instance associated with the <paramref name="_custVendTrans"/> record.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The LedgerVoucher object used to create ledger transactions; optional.
    /// </param>
    protected void postFineTrans_BR(AmountCur                       _fineAmountCur,
                                    AmountMST                       _fineAmountMst,
                                    CustVendTrans                   _custVendTrans,
                                    CustVendTransOpen               _custVendTransOpen,
                                    CustVendTrans                   _custVendTransOffset,
                                    ExchRate                        _exchRate,
                                    LedgerDimensionDefaultAccount   _fineLedgerDimension,
                                    AmountMST                       _settledAmountMstDebit,
                                    CustVendTransSettleDistController _distributionController,
                                    LedgerVoucher                   _ledgerVoucher = null)
    {
        CustVendTrans                   fineTrans       = _custVendTrans.data();
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        LedgerVoucher                   ledgerVoucher;
        LedgerVoucherObject             ledgerVoucherObject;
        TransactionTxt                  transactionTxt;
        DimensionDefault                dimension;
        boolean                         postFineLedgerToCreditCompany;
        LedgerDimensionDefaultAccount   localFineLedgerDimension = _fineLedgerDimension;
        LedgerDimensionAccount          ledgerDimensionMerged;
        NumberSeq                       numberSeq;
        NumberSequenceReference         numberSeqRef;
        LedgerInterCompany              interCompany;
        CurrencyExchangeHelper          exchangeRateHelper;
        List                            distributions;
        ListEnumerator                  distributionEnumerator;
        CustVendTransDistribution       distribution;

        Debug::assert(curext() == _custVendTrans.company());

        if (_fineAmountCur == 0)
        {
            // Fine amount is zero so there is nothing to post
            return;
        }

        switch (_custVendTransOpen.TableId)
        {
            case tableNum(CustTransOpen) :
                _fineAmountCur = -(_fineAmountCur);
                _fineAmountMst = -(_fineAmountMst);
                break;

            case tableNum(VendTransOpen) :
                _fineAmountCur = _fineAmountCur;
                _fineAmountMst = _fineAmountMst;
                break;
        }

        transactionTxt = TransactionTxt::construct(this.fineTxtCustVend_BR(),
                                            _custVendTrans.languageId(),
                                            settlementPair.getTransactionDate(),
                                            _custVendTrans.Invoice,
                                            _custVendTrans.Voucher);

        transactionTxt.setCustVendName(this.getCustVendName_BR(_custVendTrans.AccountNum));
        transactionTxt.setKey1(_custVendTrans.AccountNum);

        if (_custVendTrans.company() == _custVendTransOffset.company())
        {
            dimension = _custVendTransOffset.DefaultDimension;
        }
        else
        {
            // different company get dimension for transaction.
            dimension = _custVendTrans.DefaultDimension;
        }

        // Intercompany Accounting - Fine = Payment Company - No posting related to Fine is necessary to Invoice company
        if (settlementPair.getCreditCompany() != settlementPair.getDebitCompany())
        {
            interCompany    = this.findLedgerInterCompany(settlementPair.getCreditCompany(), settlementPair.getDebitCompany());
        }

        if (interCompany.getFinePostOptions_BR(this.parmModule()) == CustVendSettleCompanyPostOption::PaymentCompany)
        {
            this.postFineTransToCreditCompany_BR(_custVendTrans, _custVendTransOffset, _fineAmountCur);

            changecompany(settlementPair.getCreditCompany())
            {
                fineTrans = this.createInterestFineCustVendTrans_BR(settlementPair.getCreditCompany(), _fineAmountCur,_fineAmountMst,_custVendTrans, _exchRate, transactionTxt, dimension);
            }
        }
        else
        {
            if (_ledgerVoucher == null)
            {
                ledgerVoucher = settlementPair.findLedgerVoucherByCompany(_custVendTrans.company());
            }
            else
            {
                ledgerVoucher = _ledgerVoucher;
            }

            // In centralized payment scenario, the fine/interest transactions should appear
            // on the same voucher as the Due To.  Otherwise, fine/interest transactions
            // should have their own voucher
            if (settlementPair.getDebitCompany() != settlementPair.getCreditCompany())
            {
                ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
            }
            else
            {
                // Get new voucher for fine transaction
                numberSeqRef = settlementPair.numRefCustVendPaymVoucher();
                numberSeq = NumberSeq::newGetVoucher(numberSeqRef);

                ledgerVoucherObject = LedgerVoucherObject::newVoucher(numberSeq.voucher(),
                                                                     settlementPair.getTransactionDate(),
                                                                     this.parmModule(),
                                                                     this.ledgerTransactionType());
                ledgerVoucher.addVoucher(ledgerVoucherObject);
            }

            fineTrans = this.createInterestFineCustVendTrans_BR(curext(), _fineAmountCur, _fineAmountMst, _custVendTrans, _exchRate, transactionTxt, dimension);

            ledgerVoucherObject.lastTransTxt(transactionTxt.txt());

            // create ledger transaction for payment company
            postFineLedgerToCreditCompany = this.postFineTransToCreditCompany_BR(_custVendTrans, _custVendTransOffset, _fineAmountCur);

            ledgerVoucherObject.parmPaymentReference(settlementPair.getCustVendTransCredit().PaymReference);

            if (postFineLedgerToCreditCompany)
            {
                // the ledger account need to be the Due to/from ledger account
                localFineLedgerDimension = dueToFromLedgerDimensionDebit;
            }

            ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
            exchangeRateHelper  = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
            exchangeRateHelper.parmExchangeRate1(fineTrans.ExchRate);
            fineTrans.setExchangeHelperReportingExchRate(exchangeRateHelper);

            ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(localFineLedgerDimension, dimension);

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                    ledgerVoucherObject,
                                    this.postingTypeFine_BR(),
                                    ledgerDimensionMerged,
                                    _custVendTrans.CurrencyCode,
                                    -(fineTrans.AmountCur),
                                    exchangeRateHelper);
            ledgerVoucherTransObject.parmSourceTableId(fineTrans.TableId);
            ledgerVoucherTransObject.parmSourceRecId(fineTrans.RecId);
            ledgerVoucher.addTrans(ledgerVoucherTransObject);

            // create ledger transaction for the AR or AP account number(s)
            ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();

            ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(_custVendTrans.summaryLedgerDimension(postingProfile), dimension);

            distributions = _distributionController.generateDistributions(
                _custVendTrans,
                this.getLedgerPostingType_Balance(),
                fineTrans.AmountCur,
                fineTrans.AmountMST,
                fineTrans.ReportingCurrencyAmount,
                ledgerDimensionMerged,
                false);

            distributionEnumerator = distributions.getEnumerator();
            while (distributionEnumerator.moveNext())
            {
                distribution = distributionEnumerator.current();

                ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
                    ledgerVoucherObject,
                    this.getLedgerPostingType_Balance(),
                    distribution.ledgerDimension(),
                    _custVendTrans.CurrencyCode,
                    distribution.transactionAmount(),
                    distribution.accountingAmount(),
                    distribution.reportingAmount());

                ledgerVoucherTransObject.parmSourceTableId(fineTrans.TableId);
                ledgerVoucherTransObject.parmSourceRecId(fineTrans.RecId);
                ledgerVoucherTransObject.parmSkipDimensionValidation(true);
                if (postCashDiscountInSummary)
                {
                    ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::Summary);
                }

                ledgerVoucher.addTrans(ledgerVoucherTransObject);
            }

            ledgerVoucher.findLedgerVoucherObject().lastTransTxt("");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postFineTransToCreditCompany_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the ledger transactions when the Fine is posted to the payment company.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The CustVendTrans record used to create the transaction.
    /// </param>
    /// <param name="_custVendTransOffset">
    /// The CustVendTrans record used as the offset to the transaction.
    /// </param>
    /// <param name="_fineAmountCur">
    /// The Fine amount in the transaction currency.
    /// </param>
    /// <returns>
    /// true if the Fine is posted to the payment company; otherwise, false.
    /// </returns>
    protected boolean postFineTransToCreditCompany_BR(CustVendTrans _custVendTrans,
                                                      CustVendTrans _custVendTransOffset,
                                                      FineAmount_BR _fineAmountCur)
    {
        boolean                         postLedgerToCreditCompany;
        LedgerInterCompany              interCompany;
        FinInterestAmount_BR            fineAmountPaymentCur;
        AmountMST                       fineAmountPaymentMst;
        AmountMSTSecondary              fineAmountPaymentReporting;
        LedgerVoucher                   paymentLedgerVoucher;
        LedgerVoucherObject             ledgerVoucherObject;
        TransactionTxt                  paymentFineText;
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        LedgerDimensionDefaultAccount   paymentfineLedgerDimension;
        NumberSeq                       numberSeq;
        NumberSequenceReference         numberSeqRef;
        CurrencyExchangeHelper          currencyHelper;
        LedgerDimensionAccount          ledgerDimensionMerged;

        if (_fineAmountCur != 0 && settlementPair.getDebitCompany() != settlementPair.getCreditCompany() &&
            _custVendTrans.RecId == settlementPair.getCustVendTransDebit().RecId)
        {
            // Check if the LedgerInterCompany for credit company has Fine post option set to PaymentCompany
            changecompany(settlementPair.getCreditCompany())
            {
                interCompany            = this.findLedgerInterCompany(settlementPair.getCreditCompany(), settlementPair.getDebitCompany());
                if (interCompany.getFinePostOptions_BR(this.parmModule()) == CustVendSettleCompanyPostOption::PaymentCompany)
                {
                    postLedgerToCreditCompany = true;

                    currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(settlementPair.getCreditCompany()).RecId), _custVendTransOffset.TransDate);
                    fineAmountPaymentMst = currencyHelper.calculateTransactionToAccounting(_custVendTrans.CurrencyCode, _fineAmountCur, true);
                    fineAmountPaymentReporting = currencyHelper.calculateTransactionCurrencyToReportingCurrency(_custVendTrans.CurrencyCode, _fineAmountCur);

                    // calculate the Fine amount in payment company currency
                    [fineAmountPaymentCur, fineAmountPaymentMst] = this.calcFinInterestOrFineForCreditCompany_BR(_fineAmountCur);

                    // set up transaction text for ledger transaction
                    paymentFineText = TransactionTxt::construct(this.fineTxtLedger_BR(),
                                                                settlementPair.getCustVendTransCredit().languageId(),
                                                                settlementPair.getTransactionDate(),settlementPair.getCustVendTransCredit().Invoice,
                                                                settlementPair.getCustVendTransCredit().Voucher);

                    // set up ledger voucher for payment company
                    paymentLedgerVoucher = settlementPair.findLedgerVoucherByCompany(settlementPair.getCreditCompany());

                    // Get new voucher for fine transaction
                    numberSeqRef = settlementPair.numRefCustVendPaymVoucher();
                    numberSeq = NumberSeq::newGetVoucher(numberSeqRef);

                    ledgerVoucherObject = LedgerVoucherObject::newVoucher(numberSeq.voucher(),
                                                                         settlementPair.getTransactionDate(),
                                                                         this.parmModule(),
                                                                         this.ledgerTransactionType());
                    paymentLedgerVoucher.addVoucher(ledgerVoucherObject);

                    ledgerVoucherObject.lastTransTxt(paymentFineText.txt());
                    ledgerVoucherObject.parmPaymentReference(settlementPair.getCustVendTransCredit().PaymReference);

                    // create ledger transaction for due to/from ledger account
                    ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(settlementPair.getCustVendTransCredit().summaryLedgerDimension());
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
                        ledgerVoucherObject,
                        this.postingTypeFine_BR(),
                        ledgerDimensionMerged,
                        _custVendTrans.CurrencyCode,
                        -this.amount(_fineAmountCur),
                        -this.amount(fineAmountPaymentMst),
                        -this.amount(fineAmountPaymentReporting));

                    ledgerVoucherTransObject.parmSourceTableId(_custVendTransOffset.TableId);
                    ledgerVoucherTransObject.parmSourceRecId(_custVendTransOffset.RecId);
                    paymentLedgerVoucher.addTrans(ledgerVoucherTransObject);

                    paymentfineLedgerDimension = this.fineLedgerDimensionCreditCompany_BR(_custVendTrans.AccountNum,
                                                                                          _custVendTrans.PostingProfile);

                    ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(paymentfineLedgerDimension, _custVendTransOffset.DefaultDimension);

                    // create ledger transaction for Fine ledger account
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
                        ledgerVoucherObject,
                        this.postingTypeFine_BR(),
                        ledgerDimensionMerged,
                        _custVendTrans.CurrencyCode,
                        this.amount(_fineAmountCur),
                        this.amount(fineAmountPaymentMst),
                        this.amount(fineAmountPaymentReporting));

                    ledgerVoucherTransObject.parmSourceTableId(_custVendTransOffset.TableId);
                    ledgerVoucherTransObject.parmSourceRecId(_custVendTransOffset.RecId);
                    paymentLedgerVoucher.addTrans(ledgerVoucherTransObject);
                }
            }
        }

        return postLedgerToCreditCompany;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postForeignVendorAdv_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts foreign vendor information.
    /// </summary>
    /// <param name="_settlementFactor">
    /// The settlement factor.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal trans.
    /// </param>
    //This is a copy of method 'postGTAVendor_IN' except for the foreign vendor changes
    public void postForeignVendorAdv_IN(real                   _settlementFactor,
                                     LedgerJournalTrans     _ledgerJournalTrans)
    {
        TaxReportVoucher            taxReportVoucher;
        TaxTrans_IN                 taxTransloc;
        TaxTrans_IN                 taxTransSettle;
        TaxTrans                    taxTransCopy;
        TaxTrans                    taxTrans;
        TaxTable                    taxTable;
        TaxAmountCur                postExpenseAmount;
        RefRecId                    recoverableAccount;
        RefRecId                    expenseAccount;
        RefRecId                    interimRecoverable;
        real                        isPaymPartial=1;
        VendTrans                   vendTrans;
        LedgerVoucher               ledgerVoucher;

        PurchLine                   purchLineLoc;
        boolean                     isAuthorityVendor;
        TaxAuthorityAddress         taxAuthorityAddress;
        TaxPeriodHead               taxPeriodHead;
        RefRecId                    taxLedgerAccountSetup;
        CurrencyExchangeHelper      exchRateHelper;
        TaxTransGeneralJournalAccountEntry  taxTransGeneralJournalAccountEntry;
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        CustVendTrans_W             custVendTrans_W;
        TaxTrans_W                  taxTrans_W;
        TaxTrans_W                  taxTransCopy_W;
        TaxTrans                    taxTransrev;
        TaxSalesTaxPaymentHistory_IN                paymentHistory;
        TaxSalesTaxPaymentHistoryDetails_IN         historyDetails;
        TaxSalesTaxPaymentHistoryDetailsTrans_IN    detailTrans;
        TaxReportHierarchyNode_IN                   nodeTable;
        TransTaxInformation                         transTaxInformation;

        select firstonly Voucher, TaxRegistrationNumberTable_IN from  taxReportVoucher
            where taxReportVoucher.Voucher  == settlementPair.getCustVendTransDebit().Voucher;

        expenseAmtMap = new Map(Types::String, Types::Real);
        recoverableAmtMap = new Map(Types::String, Types::Real);
        invoiceVoucherMap = new Map(Types::String, Types::Real);

        custVendTrans_W = settlementPair.getCustVendTransDebit().CustVendTrans::getCustVendTrans_W();
        while select detailTrans
            where detailTrans.Mark == NoYes::Yes
            join RecId, TaxRegistrationNumbers_IN, TaxReportHierarchyNode_IN, TaxSalesTaxPaymentHistory_IN from historyDetails
                where historyDetails.RecId == detailTrans.TaxSalesTaxPaymentHistoryDetails_IN &&
                      historyDetails.TaxRegistrationNumbers_IN == taxReportVoucher.TaxRegistrationNumberTable_IN
            join RecId, RefTableRecId from nodeTable
                where nodeTable.RecId == historyDetails.TaxReportHierarchyNode_IN &&
                      nodeTable.RefTableRecId == custVendTrans_W.TaxComponentTable_IN
            join RecId, TaxReportVoucher from paymentHistory
                where paymentHistory.RecId == historyDetails.TaxSalesTaxPaymentHistory_IN &&
                      paymentHistory.TaxReportVoucher == taxReportVoucher.RecId
        {
            taxTransloc = TaxTrans_IN::findRecId(detailTrans.TaxTrans_IN);
            taxTable = TaxTable::find(TaxTrans::findRecId_IN(taxTransloc.RefRecId).TaxCode);

            taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::Table, taxReportVoucher.TaxRegistrationNumberTable_IN).RecId;
            if (!taxLedgerAccountSetup)
            {
                taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::All).RecId;
            }

            select firstonly taxTransrev
                where taxTransrev.RecId == taxTransloc.RefRecId;
            if (taxTransrev.RecId
                && taxTransrev.taxTrans_W().ServiceTaxReverseChargePercentage_IN)
            {
                // ComponentTransactions happen for actual accounts only for service tax. So get back the interim using them.
                this.postForeignVendorReverseChargeAdv_IN(_settlementFactor, _ledgerJournalTrans, detailTrans, custVendTrans_W.TaxComponentTable_IN);
                continue;
            }
            // Reverse charge feature end
            interimRecoverable = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountSetup, TaxAccountType_IN::ServiceTaxInterimRecoverableAccount, taxTable.TaxComponentTable_IN);

            interimRecoverable = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(interimRecoverable,
                                                                                                  taxTransloc.LedgerDimension);
            select taxTrans
                where taxTrans.RecId                == taxTransloc.InvoiceRefRecID
                join TaxType_IN, TaxTrans, TaxComponentTable_IN from taxTrans_W
                where taxTrans_W.TaxTrans == taxTrans.RecId
                    && taxTrans_W.TaxComponentTable_IN == custVendTrans_W.TaxComponentTable_IN
                    && taxTrans_W.TaxType_IN           == TaxType_IN::ServiceTax
            join LedgerDimension  from taxTransGeneralJournalAccountEntry
                where taxTransGeneralJournalAccountEntry.TaxTrans == taxTrans.RecId
                    && taxTransGeneralJournalAccountEntry.LedgerDimension == interimRecoverable
                    && taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::Tax;

            vendTrans= VendTrans::find(settlementPair.getCustVendTransDebit().RecId);

            // Posting will happen only when
            // Authority vendor posting + Recoverable
            purchLineLoc        = PurchLine::findInventTransId(taxTrans.InventTransId);

            if (!purchLineLoc.purchTable().vendTable_InvoiceAccount().isForeign() ||
                !purchLineLoc.purchTable().purchTable_W().CustomsImportOrder_IN)
            {
                continue;
            }

            select firstonly RecId from taxAuthorityAddress
                join TaxAuthority from taxPeriodHead
                    where taxAuthorityAddress.TaxAuthority  == taxPeriodHead.TaxAuthority   &&
                          taxPeriodHead.TaxPeriod           == taxTable.TaxPeriod           &&
                          taxAuthorityAddress.AccountNum    == _ledgerJournalTrans.parmAccount();

            isAuthorityVendor   = (taxAuthorityAddress.RecId != 0);

            transTaxInformation = transTaxInformationHelper.getTransTaxInformationByRecord(purchLineLoc);
            if (!transTaxInformation.ServiceTaxIsRecoverable && isAuthorityVendor)
            {
                continue;
            }
            exchRateHelper = CurrencyExchangeHelper::newLedger(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));
            exchRateHelper.parmExchangeRate1(settlementPair.getCustVendTransDebit().exchRateCurToMst());
            exchRateHelper.parmExchangeRate2(settlementPair.getCustVendTransDebit().ExchRateSecond);
            exchRateHelper.parmExchangeDate(taxTrans.TransDate);

            ledgerVoucher = settlementPair.findLedgerVoucherByCompany(settlementPair.getDebitCompany());

            if (taxTrans)
            {
                isPaymPartial = this.isGTAPartialPaymAdv_IN(taxTrans, detailTrans);
            }

            isPaymPartial = abs(isPaymPartial * _settlementFactor);

            if ((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST)*isPaymPartial !=0 &&
                 taxTrans_W.TaxType_IN ==TaxType_IN::ServiceTax )
            {
                taxTransCopy.data(taxTrans);
                taxTransCopy_W = taxTransCopy.taxTrans_W();

                taxTransCopy.Source                         = TaxModuleType::Voucher;
                taxTransCopy.Voucher                        = ledgerVoucher.lastVoucher();
                taxTransCopy.TransDate                      = _ledgerJournalTrans.TransDate;
                taxTransCopy.TaxOrigin                      = TaxOrigin::Payment;
                taxTransCopy.TaxAmount                      = - CurrencyExchange::round((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST) * isPaymPartial/100, taxTrans.CurrencyCode);
                taxTransCopy.TaxAmount                      = - CurrencyExchange::round((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST) * isPaymPartial/100, taxTrans.CurrencyCode);
                taxTransCopy.TaxAmountCur                   = - CurrencyExchange::round((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST) * isPaymPartial/100, taxTrans.CurrencyCode);
                taxTransCopy.SourceTaxAmountCur             = - CurrencyExchange::round((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST) * isPaymPartial/100, taxTrans.CurrencyCode);
                taxTransCopy.InventTransId                  = '';
                taxTransCopy.insert();

                taxTransSettle.RefRecId                     = taxTransCopy.RecId;
                taxTransSettle.InterimRecoverableLedgerDimension   = interimRecoverable;
                taxTransSettle.TaxAmount                    = taxTransCopy.TaxAmount;
                taxTransSettle.SourceTaxAmountCur           = taxTransCopy.SourceTaxAmountCur;
                taxTransSettle.SourceBaseAmountCur          = taxTransCopy.TaxBaseAmount;
                taxTransSettle.TaxCode                      = taxTransCopy.TaxCode;
                taxTransSettle.TaxDirection                 = taxTransCopy.TaxDirection;
                taxTransSettle.TaxComponentTable            = taxTransCopy_W.TaxComponentTable_IN;
                taxTransSettle.Source                       = TaxModuleType::Voucher;
                taxTransSettle.Voucher                      = ledgerVoucher.lastVoucher();
                taxTransSettle.TransDate                    = _ledgerJournalTrans.TransDate;
                taxTransSettle.CustVendRegistrationNumber   = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(
                                                                                                   VendTable::find(settlementPair.getCustVendTransDebit().AccountNum).Party)).stcRegistrationNumberTable;
                taxTransSettle.VoucherCurrency              = taxTransCopy.SourceCurrencyCode;
                taxTransSettle.TaxLedgerAccountGroup              = taxTable.TaxLedgerAccountGroup_IN;
                taxTransSettle.TaxComponentTable                 = taxTable.TaxComponentTable_IN;
                taxTransSettle.TaxType                      = TaxType_IN::ServiceTax;
                taxTransSettle.TaxValue                     = taxTrans.TaxValue;
                taxTransSettle.JournalType                  = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalType;
                taxTransSettle.JournalNum                   = _ledgerJournalTrans.JournalNum;
                taxTransSettle.JournalName                  = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalName;
                taxTransSettle.SourceTableId                = vendTrans.TableId;
                taxTransSettle.SourceRecId                  = vendTrans.RecId;
                taxTransSettle.Vendor                       = _ledgerJournalTrans.parmAccount();
                taxTransSettle.TaxPeriod                    = taxTrans.TaxPeriod;
                taxTransSettle.CompanyRegistrationNumber    = taxReportVoucher.TaxRegistrationNumberTable_IN;
                taxTransSettle.InvoiceAccount               = settlementPair.getCustVendTransDebit().AccountNum;
                taxTransSettle.SourceCurrencyCode           = taxTrans.CurrencyCode;
                taxTransSettle.TaxLedgerAccountGroup        = taxTable.TaxLedgerAccountGroup_IN;
                taxTransSettle.TaxGroup                     = taxTransloc.TaxGroup;
                taxTransSettle.TaxItemGroup                 = taxTransloc.TaxItemGroup;
                taxTransSettle.ExpenseLedgerDimension               =  0 ;
                taxTransSettle.TransactionAmount            = _ledgerJournalTrans.AmountCurCredit?_ledgerJournalTrans.AmountCurCredit:_ledgerJournalTrans.AmountCurDebit;
                taxTransSettle.TaxAmountSecondary           = exchRateHelper.calculateAccountingToReportingAdjustment(taxTransCopy.CurrencyCode,
                                                                                                                      taxTransCopy.TaxAmount,
                                                                                                                      true);
                taxTransSettle.insert();

                ledgerVoucher.findLedgerVoucherObject().lastTransTxt(_ledgerJournalTrans.Txt);
                ledgerVoucher.addTrans(LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                LedgerPostingType::ServiceTax_IN,
                                                                                interimRecoverable,
                                                                                taxTrans.CurrencyCode,
                                                                                - CurrencyExchange::round((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST) * isPaymPartial/100, taxTrans.CurrencyCode),
                                                                                exchRateHelper));

                postExpenseAmount = this.determineGTAExpenseAmount_IN(taxTrans.InventTransId,
                                                                    taxTrans.Voucher,
                                                                    taxTrans.TaxCode,
                                                                    taxTrans.TransDate);

                if (postExpenseAmount * isPaymPartial)
                {
                    isPaymPartial       = isPaymPartial/100;
                    postExpenseAmount   = postExpenseAmount * isPaymPartial;

                    expenseAccount              = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountSetup,TaxAccountType_IN::ServiceTaxExpenseAccount,taxTable.TaxComponentTable_IN);

                    expenseAccount  = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(expenseAccount,
                                                                                                       taxTransloc.LedgerDimension);

                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                LedgerPostingType::ServiceTax_IN,
                                                                                expenseAccount,
                                                                                taxTrans.CurrencyCode,
                                                                                CurrencyExchange::round(postExpenseAmount, taxTrans.CurrencyCode),
                                                                                exchRateHelper);
                    taxTransCopy.data(taxTrans);
                    taxTransCopy_W = taxTransCopy.taxTrans_W();

                    taxTransCopy.Source                     = TaxModuleType::Voucher;
                    taxTransCopy.Voucher                    = ledgerVoucher.lastVoucher();
                    taxTransCopy.TransDate                  = _ledgerJournalTrans.TransDate;
                    taxTransCopy.TaxAmount                  = CurrencyExchange::round(postExpenseAmount, taxTrans.CurrencyCode);
                    taxTransCopy.Voucher                    = _ledgerJournalTrans.Voucher;
                    taxTransCopy.TaxAmountCur               =  CurrencyExchange::round(postExpenseAmount, taxTrans.CurrencyCode);
                    taxTransCopy.SourceTaxAmountCur         =  CurrencyExchange::round(postExpenseAmount, taxTrans.CurrencyCode);
                    taxTransCopy.TaxOrigin                  = TaxOrigin::Payment;
                    taxTransCopy.InventTransId              = '';
                    taxTransCopy.insert();

                    if (taxTransCopy)
                    {
                        // TaxTrans will not exist in the case where a transaction is only being validated,
                        // and in that case the tax trans relationship should not be created
                        ledgerVoucherTransObject.addTaxTransRelationship(taxTransCopy.RecId, TaxTransRelationshipType::Tax);
                    }
                    ledgerVoucher.addTrans(ledgerVoucherTransObject);

                    taxTransSettle.RefRecId                 = taxTransCopy.RecId;
                    taxTransSettle.TaxCode                  = taxTransCopy.TaxCode;
                    taxTransSettle.TaxDirection             = taxTransCopy.TaxDirection;
                    taxTransSettle.TaxComponentTable        = taxTransCopy_W.TaxComponentTable_IN;
                    taxTransSettle.Source                   = TaxModuleType::Voucher;
                    taxTransSettle.ExpenseLedgerDimension           = expenseAccount;
                    taxTransSettle.ExpenseAmount            = taxTransCopy.TaxAmount;
                    taxTransSettle.SourceTaxAmountCur       =  taxTransCopy.SourceTaxAmountCur;
                    taxTransSettle.SourceBaseAmountCur      = taxTransCopy.TaxBaseAmount;
                    taxTransSettle.Voucher                  = ledgerVoucher.lastVoucher();
                    taxTransSettle.VoucherCurrency          = taxTransCopy.SourceCurrencyCode;
                    taxTransSettle.TaxLedgerAccountGroup          = taxTable.TaxLedgerAccountGroup_IN;
                    taxTransSettle.TaxComponentTable             = taxTable.TaxComponentTable_IN;
                    taxTransSettle.TaxType                  = TaxType_IN::ServiceTax;
                    taxTransSettle.TaxValue                 = taxTrans.TaxValue;
                    taxTransSettle.JournalType              = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalType;
                    taxTransSettle.JournalNum               = _ledgerJournalTrans.JournalNum;
                    taxTransSettle.JournalName              = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalName;
                    taxTransSettle.SourceTableId            = vendTrans.TableId;
                    taxTransSettle.SourceRecId              = vendTrans.RecId;
                    taxTransSettle.Vendor                   = _ledgerJournalTrans.parmAccount();
                    taxTransSettle.TaxPeriod                = taxTrans.TaxPeriod;
                    taxTransSettle.CompanyRegistrationNumber    = taxReportVoucher.TaxRegistrationNumberTable_IN;
                    taxTransSettle.CustVendRegistrationNumber   = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(
                                                                                                VendTable::find(settlementPair.getCustVendTransDebit().AccountNum).Party)).stcRegistrationNumberTable;

                    taxTransSettle.InvoiceAccount           = settlementPair.getCustVendTransDebit().AccountNum;
                    taxTransSettle.SourceCurrencyCode       = taxTrans.CurrencyCode;
                    taxTransSettle.TaxLedgerAccountGroup    = taxTable.TaxLedgerAccountGroup_IN;
                    taxTransSettle.TaxGroup                 = taxTransloc.TaxGroup;
                    taxTransSettle.TaxItemGroup             = taxTransloc.TaxItemGroup;
                    taxTransSettle.TransactionAmount        = _ledgerJournalTrans.AmountCurCredit?_ledgerJournalTrans.AmountCurCredit:_ledgerJournalTrans.AmountCurDebit;
                    taxTransSettle.TaxAmountSecondary       = exchRateHelper.calculateAccountingToReportingAdjustment(taxTransCopy.CurrencyCode,
                                                                                                                      taxTransCopy.TaxAmount,
                                                                                                                      true);
                    taxTransSettle.insert();
                }

                if (!((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST)* isPaymPartial - postExpenseAmount* isPaymPartial) ==0 &&
                    !postExpenseAmount)
                {
                    isPaymPartial       = isPaymPartial/100;

                    recoverableAccount  = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountSetup, TaxAccountType_IN::ServiceTaxRecoverableAccount, taxTable.TaxComponentTable_IN);

                    recoverableAccount  = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(recoverableAccount,
                                                                                                           taxTransloc.LedgerDimension);

                    taxTransCopy.data(taxTrans);
                    taxTransCopy_W = taxTransCopy.taxTrans_W();

                    taxTransCopy.Source              = TaxModuleType::Voucher;
                    taxTransCopy.TransDate           = _ledgerJournalTrans.TransDate;
                    taxTransCopy.Voucher             = ledgerVoucher.lastVoucher();
                    taxTransCopy.TaxAmount           = CurrencyExchange::round((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST) * isPaymPartial- postExpenseAmount, taxTrans.CurrencyCode);
                    taxTransCopy.TaxAmountCur        = CurrencyExchange::round((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST) * isPaymPartial- postExpenseAmount, taxTrans.CurrencyCode);
                    taxTransCopy.SourceTaxAmountCur  = CurrencyExchange::round((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST) * isPaymPartial- postExpenseAmount, taxTrans.CurrencyCode);
                    taxTransCopy.TaxOrigin           = TaxOrigin::Payment;
                    taxTransCopy.InventTransId       = '';
                    taxTransCopy.insert();

                    taxTransSettle.RefRecId                     = taxTransCopy.RecId;
                    taxTransSettle.TaxCode                      = taxTransCopy.TaxCode;
                    taxTransSettle.TaxDirection                 = taxTransCopy.TaxDirection;
                    taxTransSettle.TaxComponentTable            = taxTransCopy_W.TaxComponentTable_IN;
                    taxTransSettle.Source                       = TaxModuleType::Voucher;
                    taxTransSettle.Voucher                      = ledgerVoucher.lastVoucher();
                    taxTransSettle.SourceTaxAmountCur           = taxTransCopy.SourceTaxAmountCur;
                    taxTransSettle.TaxAmount                    = taxTransCopy.TaxAmount;
                    taxTransSettle.SourceBaseAmountCur          = taxTransCopy.TaxBaseAmount;
                    taxTransSettle.TaxLedgerAccountGroup              = taxTable.TaxLedgerAccountGroup_IN;
                    taxTransSettle.TaxComponentTable                 = taxTable.TaxComponentTable_IN;
                    taxTransSettle.TaxType                      = TaxType_IN::ServiceTax;
                    taxTransSettle.TaxValue                     = taxTrans.TaxValue;
                    taxTransSettle.JournalType                  = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalType;
                    taxTransSettle.JournalNum                   = _ledgerJournalTrans.JournalNum;
                    taxTransSettle.JournalName                  = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalName;
                    taxTransSettle.SourceTableId                = vendTrans.TableId;
                    taxTransSettle.SourceRecId                  = vendTrans.RecId;
                    taxTransSettle.Vendor                       = _ledgerJournalTrans.parmAccount();
                    taxTransSettle.TaxPeriod                    = taxTrans.TaxPeriod;
                    taxTransSettle.CompanyRegistrationNumber    = taxReportVoucher.TaxRegistrationNumberTable_IN;
                    taxTransSettle.CustVendRegistrationNumber   = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(
                                                                                                VendTable::find(settlementPair.getCustVendTransDebit().AccountNum).Party)).stcRegistrationNumberTable;
                    taxTransSettle.InvoiceAccount               = settlementPair.getCustVendTransDebit().AccountNum;
                    taxTransSettle.SourceCurrencyCode           = taxTrans.CurrencyCode;
                    taxTransSettle.TaxLedgerAccountGroup        = taxTable.TaxLedgerAccountGroup_IN;
                    taxTransSettle.TaxGroup                     = taxTransloc.TaxGroup;
                    taxTransSettle.TaxItemGroup                 = taxTransloc.TaxItemGroup;
                    taxTransSettle.TransactionAmount            = _ledgerJournalTrans.AmountCurCredit?_ledgerJournalTrans.AmountCurCredit:_ledgerJournalTrans.AmountCurDebit;
                    taxTransSettle.TaxAmountSecondary           = exchRateHelper.calculateAccountingToReportingAdjustment(taxTransCopy.CurrencyCode,
                                                                                                                          taxTransCopy.TaxAmount,
                                                                                                                          true);
                    taxTransSettle.insert();

                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                LedgerPostingType::ServiceTax_IN,
                                                                                recoverableAccount,
                                                                                taxTrans.CurrencyCode,
                                                                                CurrencyExchange::round((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST) * isPaymPartial- postExpenseAmount, taxTrans.CurrencyCode),
                                                                                exchRateHelper);
                    if (taxTransCopy)
                    {
                        // TaxTrans will not exist in the case where a transaction is only being validated,
                        // and in that case the tax trans relationship should not be created
                        ledgerVoucherTransObject.addTaxTransRelationship(taxTransCopy.RecId, TaxTransRelationshipType::Tax);
                    }

                    ledgerVoucher.addTrans(ledgerVoucherTransObject);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postForeignVendorReverseCharge_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts foreign vendor reverse charge.
    /// </summary>
    /// <param name="_settlementFactor">
    /// The settlement factor.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal trans.
    /// </param>
    /// <param name="_componentTransactions">
    /// The component trans.
    /// </param>
    public void postForeignVendorReverseCharge_IN(
        Factor                        _settlementFactor,
        LedgerJournalTrans          _ledgerJournalTrans,
        ComponentTransactions_IN    _componentTransactions)
    {
        TaxReportVoucher            taxReportVoucher;
        TaxTrans_IN                 taxTransloc;
        TaxTrans_IN                 taxTransSettle;
        TaxTrans                    taxTransCopy;
        TaxTrans                    taxTrans;
        TaxTable                    taxTable;
        TaxAmountCur                postExpenseAmount;
        RefRecId                    recoverableAccount;
        RefRecId                    expenseAccount;
        RefRecId                    interimRecoverable;
        real                        isPaymPartial=1;
        VendTrans                   vendTrans;
        LedgerVoucher               ledgerVoucher;
        RefRecId                    taxLedgerAccountSetup;
        CurrencyExchangeHelper      exchRateHelper;
        CustVendTrans_W             custVendTrans_W;
        TaxTrans_W                  taxTrans_W;
        TaxTrans_W                  taxTransCopy_W;
        PurchLine                   purchLineLoc;
        TaxAuthorityAddress         taxAuthorityAddressRev;
        TaxPeriodHead               taxPeriodHeadRev;
        TaxLedgerAccounts_IN        taxLedgerAccountsRev;
        TaxTrans_IN                 taxTransRev_IN;
        LedgerVoucherTransObject    ledgerVoucherTransObjectRev;
        VendTrans                   vendTransLoc,vendTransRev;
        VendInvoiceJour             vendInvoiceJourRev;
        TaxAmountCur                recoverableAmtCur;
        TaxAmountCur                expenseAmtCur;
        TaxAmount                   taxInCostPrice;
        boolean                     isAccruePayable = false;
        TransTaxInformation         transTaxInformation;

        select firstonly Voucher, TaxRegistrationNumberTable_IN from taxReportVoucher
            where taxReportVoucher.Voucher  == settlementPair.getCustVendTransDebit().Voucher;

        custVendTrans_W = settlementPair.getCustVendTransDebit().CustVendTrans::getCustVendTrans_W();
        // Create related vouchers (Recoverable entries) during authority payment, by reversing the IR created during invoices.
        while select RecId, TaxType_IN  from taxTrans_W
           where taxTrans_W.TaxTransRefRecId_IN  == _componentTransactions.TransRecid
              && taxTrans_W.TaxType_IN           == TaxType_IN::ServiceTax
           join taxTrans
              where taxTrans.RecId               == taxTrans_W.TaxTrans
                 && taxTrans.TaxCode             == _componentTransactions.TaxCode
           exists join taxTransRev_IN
              where taxTransRev_IN.RefRecId      == taxTrans.RecId
           exists join taxLedgerAccountsRev
              where taxLedgerAccountsRev.LedgerDimension       == taxTransRev_IN.PayableLedgerDimension
                 && (taxLedgerAccountsRev.AccountType          == TaxAccountType_IN::ServiceTaxInterimPayableAccount
                     || taxLedgerAccountsRev.AccountType       == TaxAccountType_IN::ServiceTaxPayableAccount)
                 && taxLedgerAccountsRev.TaxComponentTable     == _componentTransactions.TaxComponentTable
        {
            isAccruePayable = TaxItemGroupHeading::isAccruePayableAtInvoicing_IN(taxTrans.TaxItemGroup);

            taxTable = TaxTable::find(_componentTransactions.TaxCode);

            taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::Table, taxReportVoucher.TaxRegistrationNumberTable_IN).RecId;
            if (!taxLedgerAccountSetup)
            {
                taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::All).RecId;
            }
            taxTransloc = TaxTrans_IN::findRefRecId(_componentTransactions.TransRecid);
            interimRecoverable = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountSetup, TaxAccountType_IN::ServiceTaxInterimRecoverableAccount, taxTable.TaxComponentTable_IN);

            interimRecoverable = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(interimRecoverable,
                                                                                                  taxTransloc.LedgerDimension);
            vendTrans= VendTrans::find(settlementPair.getCustVendTransDebit().RecId);

            //IR which is reversed during invoice should be deducted from the total IP.Should be deducted only once.
            if (!recoverableAmtMap.exists(_componentTransactions.TaxCode + taxTrans.Voucher))
            {
                recoverableAmtCur = isAccruePayable ? this.getReverseChargeRecoverableAmtByInv_IN(taxTrans) : this.getReverseChargeRecoverableAmt_IN(taxTrans);
            }
            //Expense which is posted during invoice should be deducted from the total IP.Should be deducted only once.
            if (!expenseAmtMap.exists(_componentTransactions.TaxCode + taxTrans.Voucher))
            {
                expenseAmtCur = isAccruePayable? this.getReverseChargeExpenseAmtByInv_IN(taxTrans) : this.getReverseChargeExpenseAmt_IN(taxTrans);
            }

            // Posting will happen only when
            // Authority vendor posting + Recoverable
            if (taxTrans.InventTransId)
            {
                purchLineLoc = PurchLine::findInventTransId(taxTrans.InventTransId);
            }
            else
            {
                //This is when advance payment is made, there is no linked purchLine(blank inventTransid). Still the taxTrans has to be processed here.
                select firstonly purchLineLoc
                exists join vendInvoiceJourRev
                    where purchLineLoc.PurchId == vendInvoiceJourRev.PurchId
                exists join vendTransLoc
                    where vendTransLoc.Voucher == (isAccruePayable ? taxTrans.Voucher : this.findInvVoucherFrmPymtRelVoucher_IN(taxTrans.Voucher, taxTrans.TransDate))
                       && vendInvoiceJourRev.LedgerVoucher  == vendTransLoc.Voucher
                       && vendInvoiceJourRev.InvoiceAccount == vendTransLoc.AccountNum;
            }

            if (!purchLineLoc.purchTable().vendTable_InvoiceAccount().isForeign() ||
                !purchLineLoc.purchTable().purchTable_W().CustomsImportOrder_IN)
            {
                continue;
            }

            if (TaxTrans_IN::findRefRecId(taxTrans.RecId).gtaServiceCategory == GTAServiceCategory_IN::Others
                && TaxItemGroupHeading::find(taxTrans.TaxItemGroup).ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis)
            {
                continue;
            }
            select firstonly RecId from taxAuthorityAddressRev
               exists join taxPeriodHeadRev
                  where taxAuthorityAddressRev.TaxAuthority  == taxPeriodHeadRev.TaxAuthority
                     && taxPeriodHeadRev.TaxPeriod           == taxTable.TaxPeriod
                     && taxAuthorityAddressRev.AccountNum    == _ledgerJournalTrans.parmAccount();

            transTaxInformation = transTaxInformationHelper.getTransTaxInformationByRecord(purchLineLoc);

            // If taxTrans is from advance payment(InventTransId == 0) do not continue.
            if ((!transTaxInformation.ServiceTaxIsRecoverable && taxTrans.InventTransId != '') && taxAuthorityAddressRev.RecId != 0)
            {
                continue;
            }
            ledgerVoucher = settlementPair.findLedgerVoucherByCompany(settlementPair.getDebitCompany());
            exchRateHelper = CurrencyExchangeHelper::construct();
            exchRateHelper.parmExchangeRate1(settlementPair.getCustVendTransDebit().exchRateCurToMst());
            exchRateHelper.parmExchangeRate2(settlementPair.getCustVendTransDebit().ExchRateSecond);
            exchRateHelper.parmExchangeDate(taxTrans.TransDate);

            select firstonly vendTransLoc
                where vendTransLoc.Voucher == (isAccruePayable ? taxTrans.Voucher : this.findInvVoucherFrmPymtRelVoucher_IN(taxTrans.Voucher, taxTrans.TransDate));//Invoice time record.

            select sum(SettleAmountMST) from vendTransRev //Payment time record, summing up of multiple payments made if any, for single invoice.
                where vendTransRev.LastSettleVoucher  == (isAccruePayable ? taxTrans.Voucher : this.findInvVoucherFrmPymtRelVoucher_IN(taxTrans.Voucher, taxTrans.TransDate));
            //Check if the 'Interim Recoverable' of invoice is fully reversed.
            //If the sum of multiple payments made to settle an invoice is less than invoice amount, the IR of invoice will not be fully reversed.
            //The factor 'isPaymPartial' should be calculated only if the IR is not fully reversed.
            if (abs(vendTransRev.SettleAmountMST) < abs(vendTransLoc.AmountMST))
            {
                isPaymPartial = this.isGTAPartialPaym_IN(taxTrans, _componentTransactions);
            }

            isPaymPartial = abs(isPaymPartial * _settlementFactor);

            taxInCostPrice = isAccruePayable ? this.calcRecoveryLOIMSTByInvVoucher_IN(taxTrans) : this.calcRecoveryLOIByPaymVoucher_IN(taxTrans);

            taxTransCopy.data(taxTrans);
            taxTransCopy = this.resetTaxTrans_IN(taxTransCopy);
            if ( (taxTransCopy.TaxAmount- taxInCostPrice)*isPaymPartial !=0
                && taxTrans_W.TaxType_IN ==TaxType_IN::ServiceTax )
            {
                taxTransCopy_W = taxTransCopy.taxTrans_W();
                taxTransCopy.TaxAmount = (- CurrencyExchange::round((taxTransCopy.TaxAmount- taxInCostPrice) * isPaymPartial/100, taxTrans.CurrencyCode)
                                          + CurrencyExchangeHelper::amountCur2MST(recoverableAmtCur * isPaymPartial / 100, taxTrans.SourceCurrencyCode, 0, taxTrans.TransDate)
                                          + CurrencyExchangeHelper::amountCur2MST(expenseAmtCur * isPaymPartial / 100, taxTrans.SourceCurrencyCode, 0, taxTrans.TransDate));
                this.initTaxTrans_IN(taxTransCopy, _ledgerJournalTrans, ledgerVoucher);
                taxTransCopy.insert();

                exchRateHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));
                ledgerVoucher.findLedgerVoucherObject().lastTransTxt(_ledgerJournalTrans.Txt);

                ledgerVoucherTransObjectRev = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                   LedgerPostingType::ServiceTax_IN,
                                                                                   interimRecoverable,
                                                                                   taxTrans.CurrencyCode,
                                                                                   taxTransCopy.SourceRegulateAmountCur,
                                                                                   exchRateHelper);
                ledgerVoucherTransObjectRev.parmLedgerDetailLevel(LedgerDetailLevel::Summary);

                ledgerVoucher.addTrans(ledgerVoucherTransObjectRev);

                interimRecoverable  = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(interimRecoverable);
                taxTransSettle.InterimRecoverableLedgerDimension = interimRecoverable;
                taxTransSettle.RecoverableLedgerDimension   = interimRecoverable;
                taxTransSettle.TaxAmount                    = taxTransCopy.TaxAmount;
                taxTransSettle.SourceTaxAmountCur           = taxTransCopy.SourceTaxAmountCur;
                taxTransSettle.SourceRegulateAmountCur      = taxTransCopy.SourceRegulateAmountCur;
                taxTransSettle.PostedTaxAmout               = taxTransCopy.SourceRegulateAmountCur;
                taxTransSettle.SourceBaseAmountCur          = taxTransCopy.TaxBaseAmount;
                taxTransSettle.CustVendRegistrationNumber   = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(
                                                                                                   VendTable::find(settlementPair.getCustVendTransDebit().AccountNum).Party)).stcRegistrationNumberTable;
                taxTransSettle.VoucherCurrency              = taxTransCopy.SourceCurrencyCode;
                taxTransSettle.CompanyRegistrationNumber    = taxReportVoucher.TaxRegistrationNumberTable_IN;
                taxTransSettle.ExpenseLedgerDimension       =  0 ;
                this.initTaxTransIN_IN(taxTransSettle, taxTransCopy, ledgerVoucher, taxTable, taxTrans, _ledgerJournalTrans, vendTrans, taxTransloc, exchRateHelper);
                taxTransSettle.insert();

                postExpenseAmount =0;

                postExpenseAmount = this.determineGTAExpenseAmount_IN(taxTrans.InventTransId,
                                                                    taxTrans.Voucher,
                                                                    taxTrans.TaxCode,
                                                                    taxTrans.TransDate);
                if (postExpenseAmount * isPaymPartial)
                {
                    isPaymPartial       = isPaymPartial/100;
                    postExpenseAmount   = postExpenseAmount * isPaymPartial;

                    taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::Table, taxReportVoucher.TaxRegistrationNumberTable_IN).RecId;
                    if (!taxLedgerAccountSetup)
                    {
                        taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::All).RecId;
                    }
                    expenseAccount = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountSetup, TaxAccountType_IN::ServiceTaxExpenseAccount, taxTable.TaxComponentTable_IN);

                    expenseAccount  = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(expenseAccount,
                                                                                                       taxTransloc.LedgerDimension);

                    ledgerVoucherTransObjectRev = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                LedgerPostingType::ServiceTax_IN,
                                                                                expenseAccount,
                                                                                taxTrans.CurrencyCode,
                                                                                CurrencyExchange::round(postExpenseAmount, taxTrans.CurrencyCode),
                                                                                exchRateHelper);
                    ledgerVoucherTransObjectRev.parmLedgerDetailLevel(LedgerDetailLevel::Summary);
                    ledgerVoucher.addTrans(ledgerVoucherTransObjectRev);

                    taxTransCopy.data(taxTrans);
                    taxTransCopy = this.resetTaxTrans_IN(taxTransCopy);
                    taxTransCopy_W = taxTransCopy.taxTrans_W();
                    taxTransCopy.TaxAmount = CurrencyExchange::round(postExpenseAmount, taxTrans.CurrencyCode);
                    this.initTaxTrans_IN(taxTransCopy, _ledgerJournalTrans, ledgerVoucher);
                    taxTransCopy.Voucher = _ledgerJournalTrans.Voucher;
                    taxTransCopy.insert();

                    if (taxTransCopy.RecId)
                    {
                        // TaxTrans will not exist in the case where a transaction is only being validated,
                        // and in that case the tax trans relationship should not be created
                        ledgerVoucherTransObjectRev.addTaxTransRelationship(taxTransCopy.RecId, TaxTransRelationshipType::Tax);
                    }
                    ledgerVoucher.addTrans(ledgerVoucherTransObjectRev);

                    taxTransSettle.ExpenseLedgerDimension   = expenseAccount;
                    taxTransSettle.ExpenseAmount            = taxTransCopy.TaxAmount;
                    taxTransSettle.SourceTaxAmountCur       = taxTransCopy.SourceTaxAmountCur;
                    taxTransSettle.SourceRegulateAmountCur  = taxTransCopy.SourceRegulateAmountCur;
                    taxTransSettle.SourceBaseAmountCur      = taxTransCopy.TaxBaseAmount;
                    taxTransSettle.VoucherCurrency          = taxTransCopy.SourceCurrencyCode;
                    taxTransSettle.CompanyRegistrationNumber    = taxReportVoucher.TaxRegistrationNumberTable_IN;
                    taxTransSettle.CustVendRegistrationNumber   = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(
                                                                                                VendTable::find(settlementPair.getCustVendTransDebit().AccountNum).Party)).stcRegistrationNumberTable;
                    this.initTaxTransIN_IN(taxTransSettle, taxTransCopy, ledgerVoucher, taxTable, taxTrans, _ledgerJournalTrans, vendTrans, taxTransloc, exchRateHelper);
                    taxTransSettle.insert();
                }

                if (!((taxTransCopy.TaxAmount- taxInCostPrice)* isPaymPartial - postExpenseAmount* isPaymPartial) ==0 &&
                    !postExpenseAmount)
                {
                    isPaymPartial       = isPaymPartial/100;

                    recoverableAccount  = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountSetup, TaxAccountType_IN::ServiceTaxRecoverableAccount, taxTable.TaxComponentTable_IN);

                    recoverableAccount  = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(recoverableAccount,
                                                                                                           taxTransloc.LedgerDimension);

                    taxTransCopy.data(taxTrans);
                    taxTransCopy = this.resetTaxTrans_IN(taxTransCopy);
                    taxTransCopy_W = taxTransCopy.taxTrans_W();
                    taxTransCopy.TaxAmount = (CurrencyExchange::round((taxTransCopy.TaxAmount- taxInCostPrice) * isPaymPartial- postExpenseAmount, taxTrans.CurrencyCode)
                                                        - CurrencyExchangeHelper::amountCur2MST(recoverableAmtCur * isPaymPartial, taxTrans.SourceCurrencyCode, 0, taxTrans.TransDate)
                                                        - CurrencyExchangeHelper::amountCur2MST(expenseAmtCur * isPaymPartial, taxTrans.SourceCurrencyCode, 0, taxTrans.TransDate));
                    this.initTaxTrans_IN(taxTransCopy, _ledgerJournalTrans, ledgerVoucher);
                    taxTransCopy.insert();

                    ledgerVoucherTransObjectRev = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                    LedgerPostingType::ServiceTax_IN,
                                                                    recoverableAccount,
                                                                    taxTrans.CurrencyCode,
                                                                    taxTransCopy.SourceRegulateAmountCur,
                                                                    exchRateHelper);
                    ledgerVoucherTransObjectRev.parmLedgerDetailLevel(LedgerDetailLevel::Summary);
                    ledgerVoucher.addTrans(ledgerVoucherTransObjectRev);

                    recoverableAccount  = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(recoverableAccount);
                    taxTransSettle.ServiceRecoverableLedgerDimension   = recoverableAccount;
                    taxTransSettle.RecoverableLedgerDimension   = recoverableAccount;
                    taxTransSettle.SourceTaxAmountCur           = taxTransCopy.SourceTaxAmountCur;
                    taxTransSettle.SourceRegulateAmountCur      = taxTransCopy.SourceRegulateAmountCur;
                    taxTransSettle.PostedTaxAmout               = taxTransCopy.SourceRegulateAmountCur;
                    taxTransSettle.TaxAmount                    = taxTransCopy.TaxAmount;
                    taxTransSettle.SourceBaseAmountCur          = taxTransCopy.TaxBaseAmount;
                    taxTransSettle.CompanyRegistrationNumber    = taxReportVoucher.TaxRegistrationNumberTable_IN;
                    taxTransSettle.CustVendRegistrationNumber   = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(
                                                                                                VendTable::find(settlementPair.getCustVendTransDebit().AccountNum).Party)).stcRegistrationNumberTable;
                    this.initTaxTransIN_IN(taxTransSettle, taxTransCopy, ledgerVoucher, taxTable, taxTrans, _ledgerJournalTrans, vendTrans, taxTransloc, exchRateHelper);
                    taxTransSettle.insert();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postForeignVendorReverseChargeAdv_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts advance foreign vendor reverse charge.
    /// </summary>
    /// <param name="_settlementFactor">
    /// The settlement factor.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal trans.
    /// </param>
    /// <param name="_detailTrans">
    /// The <c>TaxSalesTaxPaymentHistoryDetailsTrans_IN</c> table.
    /// </param>
    /// <param name="_taxComponentTable">
    /// The record id of <c>TaxComponentTable_IN</c> table.
    /// </param>
    public void postForeignVendorReverseChargeAdv_IN(
        Factor                        _settlementFactor,
        LedgerJournalTrans          _ledgerJournalTrans,
        TaxSalesTaxPaymentHistoryDetailsTrans_IN    _detailTrans,
        RefRecId                                    _taxComponentTable)
    {
        TaxReportVoucher            taxReportVoucher;
        TaxTrans_IN                 taxTransloc;
        TaxTrans_IN                 taxTransSettle;
        TaxTrans_IN                 detailTransTaxTransLoc;
        TaxTrans                    taxTransCopy;
        TaxTrans                    taxTrans;
        TaxTrans                    detailTransTaxTrans;
        TaxTable                    taxTable;
        TaxAmountCur                postExpenseAmount;
        RefRecId                    recoverableAccount;
        RefRecId                    expenseAccount;
        RefRecId                    interimRecoverable;
        real                        isPaymPartial=1;
        VendTrans                   vendTrans;
        LedgerVoucher               ledgerVoucher;
        RefRecId                    taxLedgerAccountSetup;
        CurrencyExchangeHelper      exchRateHelper;
        CustVendTrans_W             custVendTrans_W;
        TaxTrans_W                  taxTrans_W;
        TaxTrans_W                  taxTransCopy_W;
        PurchLine                   purchLineLoc;
        TaxAuthorityAddress         taxAuthorityAddressRev;
        TaxPeriodHead               taxPeriodHeadRev;
        TaxLedgerAccounts_IN        taxLedgerAccountsRev;
        TaxTrans_IN                 taxTransRev_IN;
        LedgerVoucherTransObject    ledgerVoucherTransObjectRev;
        VendTrans                   vendTransLoc,vendTransRev;
        VendInvoiceJour             vendInvoiceJourRev;
        TaxAmountCur                recoverableAmtCur;
        TaxAmountCur                expenseAmtCur;
        TaxAmount                   taxInCostPrice;
        boolean                     isAccruePayable = false;
        TransTaxInformation         transTaxInformation;

        detailTransTaxTransLoc = TaxTrans_IN::findRecId(_detailTrans.TaxTrans_IN);
        detailTransTaxTrans = TaxTrans::findRecId_IN(detailTransTaxTransLoc.RefRecId);

        select firstonly Voucher, TaxRegistrationNumberTable_IN from taxReportVoucher
            where taxReportVoucher.Voucher  == settlementPair.getCustVendTransDebit().Voucher;

        custVendTrans_W = settlementPair.getCustVendTransDebit().CustVendTrans::getCustVendTrans_W();
        // Create related vouchers (Recoverable entries) during authority payment, by reversing the IR created during invoices.
        while select RecId, TaxType_IN  from taxTrans_W
           where taxTrans_W.TaxTransRefRecId_IN  == detailTransTaxTrans.RecId
              && taxTrans_W.TaxType_IN           == TaxType_IN::ServiceTax
           join taxTrans
              where taxTrans.RecId               == taxTrans_W.TaxTrans
                 && taxTrans.TaxCode             == detailTransTaxTrans.TaxCode
           exists join taxTransRev_IN
              where taxTransRev_IN.RefRecId      == taxTrans.RecId
           exists join taxLedgerAccountsRev
              where taxLedgerAccountsRev.LedgerDimension       == taxTransRev_IN.PayableLedgerDimension
                 && (taxLedgerAccountsRev.AccountType          == TaxAccountType_IN::ServiceTaxInterimPayableAccount
                     || taxLedgerAccountsRev.AccountType       == TaxAccountType_IN::ServiceTaxPayableAccount)
                 && taxLedgerAccountsRev.TaxComponentTable     == _taxComponentTable
        {
            isAccruePayable = TaxItemGroupHeading::isAccruePayableAtInvoicing_IN(taxTrans.TaxItemGroup);
            taxTransloc = TaxTrans_IN::findRecId(_detailTrans.TaxTrans_IN);
            taxTable = TaxTable::find(TaxTrans::findRecId_IN(taxTransloc.RefRecId).TaxCode);

            taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::Table, taxReportVoucher.TaxRegistrationNumberTable_IN).RecId;
            if (!taxLedgerAccountSetup)
            {
                taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::All).RecId;
            }

            interimRecoverable = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountSetup, TaxAccountType_IN::ServiceTaxInterimRecoverableAccount, taxTable.TaxComponentTable_IN);

            interimRecoverable = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(interimRecoverable,
                                                                                                  taxTransloc.LedgerDimension);
            vendTrans= VendTrans::find(settlementPair.getCustVendTransDebit().RecId);

            //IR which is reversed during invoice should be deducted from the total IP.Should be deducted only once.
            if (!recoverableAmtMap.exists(taxTable.TaxCode + taxTrans.Voucher))
            {
                recoverableAmtCur = isAccruePayable ? this.getReverseChargeRecoverableAmtByInv_IN(taxTrans) : this.getReverseChargeRecoverableAmt_IN(taxTrans);
            }
            //Expense which is posted during invoice should be deducted from the total IP.Should be deducted only once.
            if (!expenseAmtMap.exists(taxTable.TaxCode + taxTrans.Voucher))
            {
                expenseAmtCur = isAccruePayable? this.getReverseChargeExpenseAmtByInv_IN(taxTrans) : this.getReverseChargeExpenseAmt_IN(taxTrans);
            }

            // Posting will happen only when
            // Authority vendor posting + Recoverable
            if (taxTrans.InventTransId)
            {
                purchLineLoc = PurchLine::findInventTransId(taxTrans.InventTransId);
            }
            else
            {
                //This is when advance payment is made, there is no linked purchLine(blank inventTransid). Still the taxTrans has to be processed here.
                select firstonly purchLineLoc
                exists join vendInvoiceJourRev
                    where purchLineLoc.PurchId == vendInvoiceJourRev.PurchId
                exists join vendTransLoc
                    where vendTransLoc.Voucher == (isAccruePayable ? taxTrans.Voucher : this.findInvVoucherFrmPymtRelVoucher_IN(taxTrans.Voucher, taxTrans.TransDate))
                       && vendInvoiceJourRev.LedgerVoucher  == vendTransLoc.Voucher
                       && vendInvoiceJourRev.InvoiceAccount == vendTransLoc.AccountNum;
            }

            if (!purchLineLoc.purchTable().vendTable_InvoiceAccount().isForeign() ||
                !purchLineLoc.purchTable().purchTable_W().CustomsImportOrder_IN)
            {
                continue;
            }
            select firstonly RecId from taxAuthorityAddressRev
               exists join taxPeriodHeadRev
                  where taxAuthorityAddressRev.TaxAuthority  == taxPeriodHeadRev.TaxAuthority
                     && taxPeriodHeadRev.TaxPeriod           == taxTable.TaxPeriod
                     && taxAuthorityAddressRev.AccountNum    == _ledgerJournalTrans.parmAccount();

            transTaxInformation = transTaxInformationHelper.getTransTaxInformationByRecord(purchLineLoc);

            // If taxTrans is from advance payment(InventTransId == 0) do not continue.
            if ((!transTaxInformation.ServiceTaxIsRecoverable && taxTrans.InventTransId != '') && taxAuthorityAddressRev.RecId != 0)
            {
                continue;
            }
            ledgerVoucher = settlementPair.findLedgerVoucherByCompany(settlementPair.getDebitCompany());
            exchRateHelper = CurrencyExchangeHelper::construct();
            exchRateHelper.parmExchangeRate1(settlementPair.getCustVendTransDebit().exchRateCurToMst());
            exchRateHelper.parmExchangeRate2(settlementPair.getCustVendTransDebit().ExchRateSecond);
            exchRateHelper.parmExchangeDate(taxTrans.TransDate);

            select firstonly vendTransLoc
                where vendTransLoc.Voucher == (isAccruePayable ? taxTrans.Voucher : this.findInvVoucherFrmPymtRelVoucher_IN(taxTrans.Voucher, taxTrans.TransDate));//Invoice time record.

            select sum(SettleAmountMST) from vendTransRev //Payment time record, summing up of multiple payments made if any, for single invoice.
                where vendTransRev.LastSettleVoucher  == (isAccruePayable ? taxTrans.Voucher : this.findInvVoucherFrmPymtRelVoucher_IN(taxTrans.Voucher, taxTrans.TransDate));
            //Check if the 'Interim Recoverable' of invoice is fully reversed.
            //If the sum of multiple payments made to settle an invoice is less than invoice amount, the IR of invoice will not be fully reversed.
            //The factor 'isPaymPartial' should be calculated only if the IR is not fully reversed.
            if (abs(vendTransRev.SettleAmountMST) < abs(vendTransLoc.AmountMST))
            {
                isPaymPartial = this.isGTAPartialPaymAdv_IN(taxTrans, _detailTrans);
            }

            isPaymPartial = abs(isPaymPartial * _settlementFactor);

            taxInCostPrice = isAccruePayable ? this.calcRecoveryLOIMSTByInvVoucher_IN(taxTrans) : this.calcRecoveryLOIByPaymVoucher_IN(taxTrans);

            taxTransCopy.data(taxTrans);
            taxTransCopy = this.resetTaxTrans_IN(taxTransCopy);
            if ( (taxTransCopy.TaxAmount- taxInCostPrice)*isPaymPartial !=0
                && taxTrans_W.TaxType_IN ==TaxType_IN::ServiceTax )
            {
                taxTransCopy_W = taxTransCopy.taxTrans_W();
                taxTransCopy.TaxAmount = (- CurrencyExchange::round((taxTransCopy.TaxAmount- taxInCostPrice) * isPaymPartial/100, taxTrans.CurrencyCode)
                                          + CurrencyExchangeHelper::amountCur2MST(recoverableAmtCur * isPaymPartial / 100, taxTrans.SourceCurrencyCode, 0, taxTrans.TransDate)
                                          + CurrencyExchangeHelper::amountCur2MST(expenseAmtCur * isPaymPartial / 100, taxTrans.SourceCurrencyCode, 0, taxTrans.TransDate));
                this.initTaxTrans_IN(taxTransCopy, _ledgerJournalTrans, ledgerVoucher);
                taxTransCopy.insert();

                exchRateHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));
                ledgerVoucher.findLedgerVoucherObject().lastTransTxt(_ledgerJournalTrans.Txt);

                ledgerVoucherTransObjectRev = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                   LedgerPostingType::ServiceTax_IN,
                                                                                   interimRecoverable,
                                                                                   taxTrans.CurrencyCode,
                                                                                   taxTransCopy.SourceRegulateAmountCur,
                                                                                   exchRateHelper);
                ledgerVoucherTransObjectRev.parmLedgerDetailLevel(LedgerDetailLevel::Summary);

                ledgerVoucher.addTrans(ledgerVoucherTransObjectRev);

                interimRecoverable  = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(interimRecoverable);
                taxTransSettle.InterimRecoverableLedgerDimension = interimRecoverable;
                taxTransSettle.RecoverableLedgerDimension   = interimRecoverable;
                taxTransSettle.TaxAmount                    = taxTransCopy.TaxAmount;
                taxTransSettle.SourceTaxAmountCur           = taxTransCopy.SourceTaxAmountCur;
                taxTransSettle.SourceRegulateAmountCur      = taxTransCopy.SourceRegulateAmountCur;
                taxTransSettle.PostedTaxAmout               = taxTransCopy.SourceRegulateAmountCur;
                taxTransSettle.SourceBaseAmountCur          = taxTransCopy.TaxBaseAmount;
                taxTransSettle.CustVendRegistrationNumber   = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(
                                                                                                   VendTable::find(settlementPair.getCustVendTransDebit().AccountNum).Party)).stcRegistrationNumberTable;
                taxTransSettle.VoucherCurrency              = taxTransCopy.SourceCurrencyCode;
                taxTransSettle.CompanyRegistrationNumber    = taxReportVoucher.TaxRegistrationNumberTable_IN;
                taxTransSettle.ExpenseLedgerDimension       =  0 ;
                this.initTaxTransIN_IN(taxTransSettle, taxTransCopy, ledgerVoucher, taxTable, taxTrans, _ledgerJournalTrans, vendTrans, taxTransloc, exchRateHelper);
                taxTransSettle.insert();

                postExpenseAmount =0;

                postExpenseAmount = this.determineGTAExpenseAmount_IN(taxTrans.InventTransId,
                                                                    taxTrans.Voucher,
                                                                    taxTrans.TaxCode,
                                                                    taxTrans.TransDate);
                if (postExpenseAmount * isPaymPartial)
                {
                    isPaymPartial       = isPaymPartial/100;
                    postExpenseAmount   = postExpenseAmount * isPaymPartial;

                    taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::Table, taxReportVoucher.TaxRegistrationNumberTable_IN).RecId;
                    if (!taxLedgerAccountSetup)
                    {
                        taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::All).RecId;
                    }
                    expenseAccount = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountSetup, TaxAccountType_IN::ServiceTaxExpenseAccount, taxTable.TaxComponentTable_IN);

                    expenseAccount  = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(expenseAccount,
                                                                                                       taxTransloc.LedgerDimension);

                    ledgerVoucherTransObjectRev = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                LedgerPostingType::ServiceTax_IN,
                                                                                expenseAccount,
                                                                                taxTrans.CurrencyCode,
                                                                                CurrencyExchange::round(postExpenseAmount, taxTrans.CurrencyCode),
                                                                                exchRateHelper);
                    ledgerVoucherTransObjectRev.parmLedgerDetailLevel(LedgerDetailLevel::Summary);
                    ledgerVoucher.addTrans(ledgerVoucherTransObjectRev);

                    taxTransCopy.data(taxTrans);
                    taxTransCopy = this.resetTaxTrans_IN(taxTransCopy);
                    taxTransCopy_W = taxTransCopy.taxTrans_W();
                    taxTransCopy.TaxAmount = CurrencyExchange::round(postExpenseAmount, taxTrans.CurrencyCode);
                    this.initTaxTrans_IN(taxTransCopy, _ledgerJournalTrans, ledgerVoucher);
                    taxTransCopy.Voucher = _ledgerJournalTrans.Voucher;
                    taxTransCopy.insert();

                    if (taxTransCopy.RecId)
                    {
                        // TaxTrans will not exist in the case where a transaction is only being validated,
                        // and in that case the tax trans relationship should not be created
                        ledgerVoucherTransObjectRev.addTaxTransRelationship(taxTransCopy.RecId, TaxTransRelationshipType::Tax);
                    }
                    ledgerVoucher.addTrans(ledgerVoucherTransObjectRev);

                    taxTransSettle.ExpenseLedgerDimension   = expenseAccount;
                    taxTransSettle.ExpenseAmount            = taxTransCopy.TaxAmount;
                    taxTransSettle.SourceTaxAmountCur       = taxTransCopy.SourceTaxAmountCur;
                    taxTransSettle.SourceRegulateAmountCur  = taxTransCopy.SourceRegulateAmountCur;
                    taxTransSettle.SourceBaseAmountCur      = taxTransCopy.TaxBaseAmount;
                    taxTransSettle.VoucherCurrency          = taxTransCopy.SourceCurrencyCode;
                    taxTransSettle.CompanyRegistrationNumber    = taxReportVoucher.TaxRegistrationNumberTable_IN;
                    taxTransSettle.CustVendRegistrationNumber   = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(
                                                                                                VendTable::find(settlementPair.getCustVendTransDebit().AccountNum).Party)).stcRegistrationNumberTable;
                    this.initTaxTransIN_IN(taxTransSettle, taxTransCopy, ledgerVoucher, taxTable, taxTrans, _ledgerJournalTrans, vendTrans, taxTransloc, exchRateHelper);
                    taxTransSettle.insert();
                }

                if (!((taxtransCopy.TaxAmount- taxInCostPrice)* isPaymPartial - postExpenseAmount* isPaymPartial) ==0 &&
                    !postExpenseAmount)
                {
                    isPaymPartial       = isPaymPartial/100;

                    recoverableAccount  = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountSetup, TaxAccountType_IN::ServiceTaxRecoverableAccount, taxTable.TaxComponentTable_IN);

                    recoverableAccount  = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(recoverableAccount,
                                                                                                           taxTransloc.LedgerDimension);

                    taxTransCopy.data(taxTrans);
                    taxTransCopy = this.resetTaxTrans_IN(taxTransCopy);
                    taxTransCopy_W = taxTransCopy.taxTrans_W();
                    taxTransCopy.TaxAmount = (CurrencyExchange::round((taxTransCopy.TaxAmount- taxInCostPrice) * isPaymPartial- postExpenseAmount, taxTrans.CurrencyCode)
                                                        - CurrencyExchangeHelper::amountCur2MST(recoverableAmtCur * isPaymPartial, taxTrans.SourceCurrencyCode, 0, taxTrans.TransDate)
                                                        - CurrencyExchangeHelper::amountCur2MST(expenseAmtCur * isPaymPartial, taxTrans.SourceCurrencyCode, 0, taxTrans.TransDate));
                    this.initTaxTrans_IN(taxTransCopy, _ledgerJournalTrans, ledgerVoucher);
                    taxTransCopy.insert();

                    ledgerVoucherTransObjectRev = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                    LedgerPostingType::ServiceTax_IN,
                                                                    recoverableAccount,
                                                                    taxTrans.CurrencyCode,
                                                                    taxTransCopy.SourceRegulateAmountCur,
                                                                    exchRateHelper);
                    ledgerVoucherTransObjectRev.parmLedgerDetailLevel(LedgerDetailLevel::Summary);
                    ledgerVoucher.addTrans(ledgerVoucherTransObjectRev);

                    recoverableAccount  = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(recoverableAccount);
                    taxTransSettle.ServiceRecoverableLedgerDimension   = recoverableAccount;
                    taxTransSettle.RecoverableLedgerDimension   = recoverableAccount;
                    taxTransSettle.SourceTaxAmountCur           = taxTransCopy.SourceTaxAmountCur;
                    taxTransSettle.SourceRegulateAmountCur      = taxTransCopy.SourceRegulateAmountCur;
                    taxTransSettle.PostedTaxAmout               = taxTransCopy.SourceRegulateAmountCur;
                    taxTransSettle.TaxAmount                    = taxTransCopy.TaxAmount;
                    taxTransSettle.SourceBaseAmountCur          = taxTransCopy.TaxBaseAmount;
                    taxTransSettle.CompanyRegistrationNumber    = taxReportVoucher.TaxRegistrationNumberTable_IN;
                    taxTransSettle.CustVendRegistrationNumber   = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(
                                                                                                VendTable::find(settlementPair.getCustVendTransDebit().AccountNum).Party)).stcRegistrationNumberTable;
                    this.initTaxTransIN_IN(taxTransSettle, taxTransCopy, ledgerVoucher, taxTable, taxTrans, _ledgerJournalTrans, vendTrans, taxTransloc, exchRateHelper);
                    taxTransSettle.insert();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postGTAVendorAdv_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts GTA vendor information.
    /// </summary>
    /// <param name="_settlementFactor">
    /// The settlement factor.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal trans.
    /// </param>
    public void postGTAVendorAdv_IN(real                   _settlementFactor,
                                           LedgerJournalTrans     _ledgerJournalTrans)
    {
        TaxReportVoucher            taxReportVoucher;
        TaxTrans_IN                 taxTransloc;
        TaxTrans_IN                 taxTransSettle;
        //  ComponentTransactions_IN    componentTransactions;
        TaxTrans                    taxTransCopy;
        TaxTrans                    taxTrans;
        TaxTable                    taxTable;
        TaxAmountCur                postExpenseAmount;
        RefRecId                    recoverableAccount;
        RefRecId                    expenseAccount;
        RefRecId                    interimRecoverable;
        real                        isPaymPartial=1;
        VendTrans                   vendTrans;
        LedgerVoucher               ledgerVoucher;
        RefRecId                    taxLedgerAccountSetup;
        CurrencyExchangeHelper      exchRateHelper;
        MainAccountNum              accountNum;
        CustVendTrans_W             custVendTrans_W;
        TaxTrans_W                  taxTrans_W;
        TaxTrans_W                  taxTransCopy_W;
        TaxTrans                    taxTransRev;
        TaxSalesTaxPaymentHistory_IN                paymentHistory;
        TaxSalesTaxPaymentHistoryDetails_IN         historyDetails;
        TaxSalesTaxPaymentHistoryDetailsTrans_IN    detailTrans;
        TaxReportHierarchyNode_IN                   nodeTable;

        select firstonly Voucher, TaxRegistrationNumberTable_IN from taxReportVoucher
            where taxReportVoucher.Voucher  == settlementPair.getCustVendTransDebit().Voucher;

        expenseAmtMap = new Map(Types::String, Types::Real);
        recoverableAmtMap = new Map(Types::String, Types::Real);
        invoiceVoucherMap = new Map(Types::String, Types::Real);

        custVendTrans_W = settlementPair.getCustVendTransDebit().CustVendTrans::getCustVendTrans_W();
        while select detailTrans
            where detailTrans.Mark == NoYes::Yes
            join RecId, TaxRegistrationNumbers_IN, TaxReportHierarchyNode_IN, TaxSalesTaxPaymentHistory_IN from historyDetails
                where historyDetails.RecId == detailTrans.TaxSalesTaxPaymentHistoryDetails_IN &&
                      historyDetails.TaxRegistrationNumbers_IN == taxReportVoucher.TaxRegistrationNumberTable_IN
            join RecId, RefTableRecId from nodeTable
                where nodeTable.RecId == historyDetails.TaxReportHierarchyNode_IN &&
                      nodeTable.RefTableRecId == custVendTrans_W.TaxComponentTable_IN
            join RecId, TaxReportVoucher from paymentHistory
                where paymentHistory.RecId == historyDetails.TaxSalesTaxPaymentHistory_IN &&
                      paymentHistory.TaxReportVoucher == taxReportVoucher.RecId
        {
            taxTransloc = TaxTrans_IN::findRecId(detailTrans.TaxTrans_IN);
            taxTable = TaxTable::find(TaxTrans::findRecId_IN(taxTransloc.RefRecId).TaxCode);

            taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::Table, taxReportVoucher.TaxRegistrationNumberTable_IN).RecId;
            if (!taxLedgerAccountSetup)
            {
                taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::All).RecId;
            }

            interimRecoverable = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountSetup, TaxAccountType_IN::ServiceTaxInterimRecoverableAccount, taxTable.TaxComponentTable_IN);

            interimRecoverable = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(interimRecoverable,
                                                                                                  taxTransloc.LedgerDimension);

            select taxTrans
                 where taxTrans.RecId            == taxTransloc.InvoiceRefRecID
                 join TaxType_IN, TaxTrans, TaxComponentTable_IN from taxTrans_W
                    where taxTrans_W.TaxTrans == taxTrans.RecId
                    && taxTrans_W.TaxComponentTable_IN  == custVendTrans_W.TaxComponentTable_IN
                    && taxTrans_W.TaxType_IN       == TaxType_IN::ServiceTax;

            select firstonly taxTransRev
               where taxTransRev.RecId == taxTransloc.RefRecId;

            if (taxTransRev.RecId && taxTransRev.taxTrans_W().ServiceTaxReverseChargePercentage_IN)
            {
                // ComponentTransactions happen for actual accounts only for service tax. So get back the interim using them.
                this.postGTAVendorReverseChargeAdv_IN(_settlementFactor, _ledgerJournalTrans, detailTrans, custVendTrans_W.TaxComponentTable_IN);
                continue;
            }

            exchRateHelper = CurrencyExchangeHelper::construct();
            exchRateHelper.parmExchangeRate1(settlementPair.getCustVendTransDebit().exchRateCurToMst());
            exchRateHelper.parmExchangeRate2(settlementPair.getCustVendTransDebit().ExchRateSecond);
            exchRateHelper.parmExchangeDate(taxTrans.TransDate);

            vendTrans= VendTrans::find(settlementPair.getCustVendTransDebit().RecId);

            if (taxTrans)
            {
                isPaymPartial = this.isGTAPartialPaymAdv_IN(taxTrans, detailTrans);
            }

            isPaymPartial = abs(isPaymPartial * _settlementFactor);

            if (
                 (taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST) * isPaymPartial !=0
                 && VendTable::find(VendTrans::findVoucherDate(taxTrans.Voucher,taxTrans.TransDate).AccountNum).isGTA()
                 && taxTrans_W.TaxType_IN ==TaxType_IN::ServiceTax
               )
            {
                ledgerVoucher = settlementPair.findLedgerVoucherByCompany(settlementPair.getDebitCompany());
                // Inserting Tax Trans for Settlement if Partial Payments and adjustments based on settlement factor
                taxTransCopy.data(taxTrans);
                taxTransCopy_W = taxTransCopy.taxTrans_W();

                taxTransCopy.Source                         = TaxModuleType::Voucher;
                taxTransCopy.Voucher                        = ledgerVoucher.lastVoucher();
                taxTransCopy.TransDate                      = _ledgerJournalTrans.TransDate;
                taxTransCopy.TaxOrigin                      = TaxOrigin::Payment;
                taxTransCopy.TaxAmount                      = - CurrencyExchange::round((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST) * isPaymPartial/100, taxTrans.CurrencyCode);
                taxTransCopy.TaxAmount                      = - CurrencyExchange::round((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST) * isPaymPartial/100, taxTrans.CurrencyCode);
                taxTransCopy.TaxAmountCur                   = - CurrencyExchange::round((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST) * isPaymPartial/100, taxTrans.CurrencyCode);
                taxTransCopy.SourceTaxAmountCur             = - CurrencyExchange::round((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST) * isPaymPartial/100, taxTrans.CurrencyCode);
                taxTransCopy.InventTransId                  = '';
                taxTransCopy.insert();

                taxTransSettle.RefRecId                     = taxTransCopy.RecId;
                taxTransSettle.InterimRecoverableLedgerDimension    = interimRecoverable;
                taxTransSettle.TaxAmount                    = taxTransCopy.TaxAmount;
                taxTransSettle.SourceTaxAmountCur           = taxTransCopy.SourceTaxAmountCur;
                taxTransSettle.SourceBaseAmountCur          = taxTransCopy.TaxBaseAmount;
                taxTransSettle.TaxCode                      = taxTransCopy.TaxCode;
                taxTransSettle.TaxDirection                 = taxTransCopy.TaxDirection;
                taxTransSettle.TaxComponentTable            = taxTransCopy_W.TaxComponentTable_IN;
                taxTransSettle.Source                       = TaxModuleType::Voucher;
                taxTransSettle.Voucher                      = ledgerVoucher.lastVoucher();
                taxTransSettle.TransDate                    = _ledgerJournalTrans.TransDate;

                taxTransSettle.CustVendRegistrationNumber   = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(
                                                                                                   VendTable::find(settlementPair.getCustVendTransDebit().AccountNum).Party)).stcRegistrationNumberTable;
                taxTransSettle.VoucherCurrency              = taxTransCopy.SourceCurrencyCode;
                taxTransSettle.TaxLedgerAccountGroup        = taxTable.TaxLedgerAccountGroup_IN;
                taxTransSettle.TaxComponentTable            = taxTable.TaxComponentTable_IN;
                taxTransSettle.TaxType                      = TaxType_IN::ServiceTax;
                taxTransSettle.TaxValue                     = taxTrans.TaxValue;
                taxTransSettle.JournalType                  = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalType;
                taxTransSettle.JournalNum                   = _ledgerJournalTrans.JournalNum;
                taxTransSettle.JournalName                  = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalName;
                taxTransSettle.SourceTableId                = vendTrans.TableId;
                taxTransSettle.SourceRecId                  = vendTrans.RecId;
                taxTransSettle.Vendor                       = _ledgerJournalTrans.parmAccount();
                taxTransSettle.TaxPeriod                    = taxTrans.TaxPeriod;
                taxTransSettle.CompanyRegistrationNumber    = taxReportVoucher.TaxRegistrationNumberTable_IN;
                taxTransSettle.InvoiceAccount               = settlementPair.getCustVendTransDebit().AccountNum;
                taxTransSettle.SourceCurrencyCode           = taxTrans.CurrencyCode;
                taxTransSettle.TaxLedgerAccountGroup        = taxTable.TaxLedgerAccountGroup_IN;
                taxTransSettle.TaxGroup                     = taxTransloc.TaxGroup;
                taxTransSettle.TaxItemGroup                 = taxTransloc.TaxItemGroup;
                taxTransSettle.ExpenseLedgerDimension               = 0 ;
                taxTransSettle.TransactionAmount            = _ledgerJournalTrans.AmountCurCredit?_ledgerJournalTrans.AmountCurCredit:_ledgerJournalTrans.AmountCurDebit;
                exchRateHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));
                taxTransSettle.TaxAmountSecondary = exchRateHelper.calculateAccountingToReportingAdjustment(taxTransCopy.CurrencyCode,
                                                                                                            taxTransCopy.TaxAmount,
                                                                                                            true);
                taxTransSettle.insert();

                ledgerVoucher.findLedgerVoucherObject().lastTransTxt(_ledgerJournalTrans.Txt);

                ledgerVoucher.addTrans(LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                   LedgerPostingType::ServiceTax_IN,
                                                                                    interimRecoverable,
                                                                                   taxTrans.CurrencyCode,
                                                                                   - CurrencyExchange::round((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST) * isPaymPartial/100, taxTrans.CurrencyCode),
                                                                                   exchRateHelper));

                postExpenseAmount =0;

                accountNum = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(interimRecoverable);
                postExpenseAmount = this.determineGTAExpenseAmount_IN(taxTrans.InventTransId, taxTrans.Voucher, taxTrans.TaxCode,taxTrans.TransDate);

                if (postExpenseAmount * isPaymPartial)
                {
                    isPaymPartial       = isPaymPartial/100;
                    postExpenseAmount   = postExpenseAmount * isPaymPartial;

                    taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::Table, taxReportVoucher.TaxRegistrationNumberTable_IN).RecId;
                    if (!taxLedgerAccountSetup)
                    {
                        taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::All).RecId;
                    }
                    expenseAccount = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountSetup, TaxAccountType_IN::ServiceTaxExpenseAccount, taxTable.TaxComponentTable_IN);

                    expenseAccount  = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(expenseAccount,
                                                                                                       taxTransloc.LedgerDimension);

                    ledgerVoucher.addTrans(LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                   LedgerPostingType::ServiceTax_IN,
                                                                                   expenseAccount,
                                                                                   taxTrans.CurrencyCode,
                                                                                   CurrencyExchange::round(postExpenseAmount, taxTrans.CurrencyCode),
                                                                                   exchRateHelper));
                    // Inserting Tax Transactions for Settlement for expenseAccounts
                    taxTransCopy.data(taxTrans);
                    taxTransCopy_W = taxTransCopy.taxTrans_W();

                    taxTransCopy.Source                     = TaxModuleType::Voucher;
                    taxTransCopy.Voucher                    = ledgerVoucher.lastVoucher();
                    taxTransCopy.TransDate                  = _ledgerJournalTrans.TransDate;
                    taxTransCopy.TaxAmount                  = CurrencyExchange::round(postExpenseAmount, taxTrans.CurrencyCode);
                    taxTransCopy.Voucher                    = _ledgerJournalTrans.Voucher;
                    taxTransCopy.TaxAmountCur               =  CurrencyExchange::round(postExpenseAmount, taxTrans.CurrencyCode);
                    taxTransCopy.SourceTaxAmountCur         =  CurrencyExchange::round(postExpenseAmount, taxTrans.CurrencyCode);
                    taxTransCopy.TaxOrigin                  = TaxOrigin::Payment;
                    taxTransCopy.InventTransId              = '';
                    taxTransCopy.insert();

                    taxTransSettle.RefRecId                 = taxTransCopy.RecId;
                    taxTransSettle.TaxCode                  = taxTransCopy.TaxCode;
                    taxTransSettle.TaxDirection             = taxTransCopy.TaxDirection;
                    taxTransSettle.TaxComponentTable        = taxTransCopy_W.TaxComponentTable_IN;
                    taxTransSettle.Source                   = TaxModuleType::Voucher;
                    taxTransSettle.ExpenseLedgerDimension           = expenseAccount;
                    taxTransSettle.ExpenseAmount            = taxTransCopy.TaxAmount;
                    taxTransSettle.SourceTaxAmountCur       =  taxTransCopy.SourceTaxAmountCur;
                    taxTransSettle.SourceBaseAmountCur      = taxTransCopy.TaxBaseAmount;
                    taxTransSettle.Voucher                  = ledgerVoucher.lastVoucher();
                    taxTransSettle.VoucherCurrency          = taxTransCopy.SourceCurrencyCode;
                    taxTransSettle.TaxLedgerAccountGroup    = taxTable.TaxLedgerAccountGroup_IN;
                    taxTransSettle.TaxComponentTable        = taxTable.TaxComponentTable_IN;
                    taxTransSettle.TaxType                  = TaxType_IN::ServiceTax;
                    taxTransSettle.TaxValue                 = taxTrans.TaxValue;
                    taxTransSettle.JournalType              = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalType;
                    taxTransSettle.JournalNum               = _ledgerJournalTrans.JournalNum;
                    taxTransSettle.JournalName              = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalName;
                    taxTransSettle.SourceTableId            = vendTrans.TableId;
                    taxTransSettle.SourceRecId              = vendTrans.RecId;
                    taxTransSettle.Vendor                   = _ledgerJournalTrans.parmAccount();
                    taxTransSettle.TaxPeriod                = taxTrans.TaxPeriod;
                    taxTransSettle.CompanyRegistrationNumber = taxReportVoucher.TaxRegistrationNumberTable_IN;
                    taxTransSettle.CustVendRegistrationNumber   = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(
                                                                                                   VendTable::find(settlementPair.getCustVendTransDebit().AccountNum).Party)).stcRegistrationNumberTable;

                    taxTransSettle.InvoiceAccount           = settlementPair.getCustVendTransDebit().AccountNum;
                    taxTransSettle.SourceCurrencyCode       = taxTrans.CurrencyCode;
                    taxTransSettle.TaxLedgerAccountGroup    = taxTable.TaxLedgerAccountGroup_IN;
                    taxTransSettle.TaxGroup                 = taxTransloc.TaxGroup;
                    taxTransSettle.TaxItemGroup             = taxTransloc.TaxItemGroup;
                    taxTransSettle.TransactionAmount        = _ledgerJournalTrans.AmountCurCredit?_ledgerJournalTrans.AmountCurCredit:_ledgerJournalTrans.AmountCurDebit;
                    taxTransSettle.TaxAmountSecondary       = exchRateHelper.calculateAccountingToReportingAdjustment(taxTransCopy.CurrencyCode,
                                                                                                                     taxTransCopy.TaxAmount,
                                                                                                                     true);
                    taxTransSettle.insert();
                }

                if (!((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST)* isPaymPartial - postExpenseAmount* isPaymPartial) ==0 &&
                    !postExpenseAmount)
                {
                    isPaymPartial       = isPaymPartial/100;
                    taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::Table, taxReportVoucher.TaxRegistrationNumberTable_IN).RecId;
                    if (!taxLedgerAccountSetup)
                    {
                        taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::All).RecId;
                    }

                    recoverableAccount  = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountSetup, TaxAccountType_IN::ServiceTaxRecoverableAccount,taxTable.TaxComponentTable_IN);

                    recoverableAccount  = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(recoverableAccount,
                                                                                                           taxTransloc.LedgerDimension);

                    // Inserting Tax Transactions for Settlement for recoverable accounts
                    taxTransCopy.data(taxTrans);

                    taxTransCopy.Source              = TaxModuleType::Voucher;
                    taxTransCopy.TransDate           = _ledgerJournalTrans.TransDate;
                    taxTransCopy.Voucher             = ledgerVoucher.lastVoucher();
                    taxTransCopy.TaxAmount           = CurrencyExchange::round((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST) * isPaymPartial- postExpenseAmount, taxTrans.CurrencyCode);
                    taxTransCopy.TaxAmountCur        = CurrencyExchange::round((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST) * isPaymPartial- postExpenseAmount, taxTrans.CurrencyCode);
                    taxTransCopy.SourceTaxAmountCur  = CurrencyExchange::round((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST) * isPaymPartial- postExpenseAmount, taxTrans.CurrencyCode);
                    taxTransCopy.TaxOrigin           = TaxOrigin::Payment;
                    taxTransCopy.InventTransId       = '';
                    taxTransCopy.insert();

                    taxTransSettle.RefRecId                     = taxTransCopy.RecId;
                    taxTransSettle.TaxCode                      = taxTransCopy.TaxCode;
                    taxTransSettle.TaxDirection                 = taxTransCopy.TaxDirection;
                    taxTransSettle.TaxComponentTable                 = taxTransCopy.taxTrans_W().TaxComponentTable_IN;
                    taxTransSettle.Source                       = TaxModuleType::Voucher;
                    taxTransSettle.Voucher                      = ledgerVoucher.lastVoucher();
                    taxTransSettle.SourceTaxAmountCur           = taxTransCopy.SourceTaxAmountCur;
                    taxTransSettle.TaxAmount                    = taxTransCopy.TaxAmount;
                    taxTransSettle.SourceBaseAmountCur          = taxTransCopy.TaxBaseAmount;
                    taxTransSettle.TaxLedgerAccountGroup              = taxTable.TaxLedgerAccountGroup_IN;
                    taxTransSettle.TaxComponentTable                 = taxTable.TaxComponentTable_IN;
                    taxTransSettle.TaxType                      = TaxType_IN::ServiceTax;
                    taxTransSettle.TaxValue                     = taxTrans.TaxValue;
                    taxTransSettle.JournalType                  = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalType;
                    taxTransSettle.JournalNum                   = _ledgerJournalTrans.JournalNum;
                    taxTransSettle.JournalName                  = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalName;
                    taxTransSettle.SourceTableId                = vendTrans.TableId;
                    taxTransSettle.SourceRecId                  = vendTrans.RecId;
                    taxTransSettle.Vendor                       = _ledgerJournalTrans.parmAccount();
                    taxTransSettle.TaxPeriod                    = taxTrans.TaxPeriod;
                    taxTransSettle.CompanyRegistrationNumber    = taxReportVoucher.TaxRegistrationNumberTable_IN;
                    taxTransSettle.CustVendRegistrationNumber   = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(
                                                                                                   VendTable::find(settlementPair.getCustVendTransDebit().AccountNum).Party)).stcRegistrationNumberTable;
                    taxTransSettle.InvoiceAccount               = settlementPair.getCustVendTransDebit().AccountNum;
                    taxTransSettle.SourceCurrencyCode           = taxTrans.CurrencyCode;
                    taxTransSettle.TaxLedgerAccountGroup        = taxTable.TaxLedgerAccountGroup_IN;
                    taxTransSettle.TaxGroup                     = taxTransloc.TaxGroup;
                    taxTransSettle.TaxItemGroup                 = taxTransloc.TaxItemGroup;
                    taxTransSettle.TransactionAmount            = _ledgerJournalTrans.AmountCurCredit?_ledgerJournalTrans.AmountCurCredit:_ledgerJournalTrans.AmountCurDebit;
                    taxTransSettle.TaxAmountSecondary           = exchRateHelper.calculateAccountingToReportingAdjustment(taxTransCopy.CurrencyCode,
                                                                                                                          taxTransCopy.TaxAmount,
                                                                                                                          true);
                    taxTransSettle.insert();

                    ledgerVoucher.addTrans(LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                   LedgerPostingType::ServiceTax_IN,
                                                                                   recoverableAccount,
                                                                                   taxTrans.CurrencyCode,
                                                                                   CurrencyExchange::round((taxTrans.TaxAmount- taxTrans.TaxInCostPriceMST) * isPaymPartial- postExpenseAmount, taxTrans.CurrencyCode),
                                                                                   exchRateHelper));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postGTAVendorReverseCharge_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts GTA vendor information.
    /// </summary>
    /// <param name="_settlementFactor">
    /// The settlement factor.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal trans.
    /// </param>
    /// <param name="_componentTransactions">
    /// The Component transactions selected.
    /// </param>
    public void postGTAVendorReverseCharge_IN(
        Factor                      _settlementFactor,
        LedgerJournalTrans          _ledgerJournalTrans,
        ComponentTransactions_IN    _componentTransactions)
    {
        TaxReportVoucher            taxReportVoucher;
        TaxTrans_IN                 taxTransloc;
        TaxTrans_IN                 taxTransSettle;
        TaxTrans                    taxTransCopy;
        TaxTrans                    taxTrans;
        TaxTable                    taxTable;
        TaxAmountCur                postExpenseAmount;
        RefRecId                    recoverableAccount;
        RefRecId                    expenseAccount;
        RefRecId                    interimRecoverable;
        real                        isPaymPartial=1;
        VendTrans                   vendTrans;
        LedgerVoucher               ledgerVoucher;
        RefRecId                    taxLedgerAccountSetup;
        CurrencyExchangeHelper      exchRateHelper;
        MainAccountNum              accountNum;
        CustVendTrans_W             custVendTrans_W;
        TaxTrans_W                  taxTrans_W;
        TaxTrans_W                  taxTransCopy_W;
        PurchLine                   purchLineRev;
        TaxLedgerAccounts_IN        taxLedgerAccountsRev;
        TaxTrans_IN                 taxTransRev_IN;
        VendTable                   vendTableRev;
        LedgerVoucherTransObject    ledgerVoucherTransObjectRev;
        VendTrans                   vendTransLoc,vendTransRev;
        TaxAmountCur                recoverableAmtCur;
        TaxAmountCur                expenseAmtCur;
        VendInvoiceJour             vendInvoiceJourRev;
        TaxAmount                   taxInCostPrice;
        boolean                     isAccruePayable = false;

        select firstonly Voucher, TaxRegistrationNumberTable_IN from taxReportVoucher
            where taxReportVoucher.Voucher  == settlementPair.getCustVendTransDebit().Voucher;

        custVendTrans_W = settlementPair.getCustVendTransDebit().CustVendTrans::getCustVendTrans_W();

        while select RecId, TaxType_IN from taxTrans_W
          where taxTrans_W.TaxTransRefRecId_IN  == _componentTransactions.TransRecid
             && taxTrans_W.TaxType_IN           == TaxType_IN::ServiceTax
          join taxTrans
             where taxTrans.RecId               == taxTrans_W.TaxTrans
                && taxTrans.TaxCode             == _componentTransactions.TaxCode
          exists join  taxTransRev_IN
             where taxTransRev_IN.RefRecId      == taxTrans.RecId
          exists join taxLedgerAccountsRev
             where taxLedgerAccountsRev.LedgerDimension       == taxTransRev_IN.PayableLedgerDimension
                && (taxLedgerAccountsRev.AccountType          == TaxAccountType_IN::ServiceTaxPayableAccount
                    || taxLedgerAccountsRev.AccountType       == TaxAccountType_IN::ServiceTaxInterimPayableAccount)
                && taxLedgerAccountsRev.TaxComponentTable     == _componentTransactions.TaxComponentTable
        {
            taxTable = TaxTable::find(_componentTransactions.TaxCode);

            taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::Table, taxReportVoucher.TaxRegistrationNumberTable_IN).RecId;
            if (!taxLedgerAccountSetup)
            {
                taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::All).RecId;
            }

            taxTransloc = TaxTrans_IN::findRefRecId(_componentTransactions.TransRecid);

            isAccruePayable = TaxItemGroupHeading::isAccruePayableAtInvoicing_IN(taxTrans.TaxItemGroup);

            interimRecoverable = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountSetup, TaxAccountType_IN::ServiceTaxInterimRecoverableAccount, taxTable.TaxComponentTable_IN);

            interimRecoverable = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(interimRecoverable,
                                                                                                  taxTransloc.LedgerDimension);
            //IR which is reversed during invoice should be deducted from the total IP.Should be deducted only once.
            if (!recoverableAmtMap.exists(_componentTransactions.TaxCode + taxTrans.Voucher))
            {
                recoverableAmtCur = isAccruePayable ? this.getReverseChargeRecoverableAmtByInv_IN(taxTrans) : this.getReverseChargeRecoverableAmt_IN(taxTrans);
            }
            //Expense which is posted during invoice should be deducted from the total IP.Should be deducted only once.
            if (!expenseAmtMap.exists(_componentTransactions.TaxCode + taxTrans.Voucher))
            {
                expenseAmtCur = isAccruePayable? this.getReverseChargeExpenseAmtByInv_IN(taxTrans) : this.getReverseChargeExpenseAmt_IN(taxTrans);
            }
            // Posting will happen only when
            // Authority vendor posting + (IsRecoverableServiceTax_IN 'MARKED = TRUE'  + GTAServiceCategory_IN 'NOT EQUAL' to OTHERS ,during invoice).
            vendTableRev = VendTable::find(VendTrans::findVoucherDate(taxTrans.Voucher, taxTrans.TransDate).AccountNum);
            if (vendTableRev.RecId == 0)
            {
                select firstonly vendTableRev
                exists join vendTrans
                    where vendTrans.AccountNum == vendTableRev.AccountNum
                       && vendTrans.Voucher    == (isAccruePayable? taxTrans.Voucher : this.findInvVoucherFrmPymtRelVoucher_IN(taxTrans.Voucher, taxTrans.TransDate));
            }
            if (taxTrans.InventTransId)
            {
                select firstonly RecId,VendAccount from purchLineRev
                    where purchLineRev.InventTransId == taxTrans.InventTransId;

                if (vendTableRev.RecId == 0 && purchLineRev.VendAccount)
                {
                    vendTableRev = VendTable::find(purchLineRev.VendAccount);
                }
            }
            else
            {
                //This is when advance payment is made, there is no linked purchLine(blank inventTransid). Still the taxTrans has to be processed here.
                select firstonly RecId from purchLineRev
                exists join vendInvoiceJourRev
                    where purchLineRev.PurchId == vendInvoiceJourRev.PurchId
                exists join vendTransLoc
                    where vendTransLoc.Voucher == (isAccruePayable? taxTrans.Voucher : this.findInvVoucherFrmPymtRelVoucher_IN(taxTrans.Voucher, taxTrans.TransDate))
                       && vendInvoiceJourRev.LedgerVoucher  == vendTransLoc.Voucher
                       && vendInvoiceJourRev.InvoiceAccount == vendTransLoc.AccountNum;
            }

            if (purchLineRev.RecId)
            {
                if (vendTableRev.isForeign())
                {
                    // (1) If its PO with recoverable expense check box unmarked(TaxInfo tab), then Recoverable will be reversed during
                    //     Vendor payment itself. It will not wait for Authority Payament. So here in Authority Payment time
                    //     We are skipping the reversal for PO Interim recoverables when the check box is unmarked.
                    // (2) For reverse charge feature, payables are created for Non-GTA also(including foreign vendor).
                    //     So since foreign vendor is already posted from 'postForeignVendor_IN()' method.
                    //     Stop duplicate posting.
                    continue;
                }
            }

            if (TaxTrans_IN::findRefRecId(taxTrans.RecId).gtaServiceCategory == GTAServiceCategory_IN::Others
                && TaxItemGroupHeading::find(taxTrans.TaxItemGroup).ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis)
            {
                continue;
            }

            exchRateHelper = CurrencyExchangeHelper::construct();
            exchRateHelper.parmExchangeRate1(settlementPair.getCustVendTransDebit().exchRateCurToMst());
            exchRateHelper.parmExchangeRate2(settlementPair.getCustVendTransDebit().ExchRateSecond);
            exchRateHelper.parmExchangeDate(taxTrans.TransDate);

            vendTrans= VendTrans::find(settlementPair.getCustVendTransDebit().RecId);

            vendTransLoc = VendTrans::findVoucherDate(taxTrans.Voucher,taxTrans.TransDate); //Invoice time record.

            select sum(SettleAmountMST) from vendTransRev //Payment time record, summing up of multiple payments made if any, for single invoice.
                where vendTransRev.LastSettleVoucher  == taxTrans.Voucher;
            //Check if the 'Interim Recoverable' of invoice is fully reversed.
            //If the sum of multiple payments made to settle an invoice is less than invoice amount, the IR of invoice will not be fully reversed.
            //The factor 'isPaymPartial' should be calculated only if the IR is not fully reversed.
            if (abs(vendTransRev.SettleAmountMST) < abs(vendTransLoc.AmountMST))
            {
                isPaymPartial = this.isGTAPartialPaym_IN(taxTrans, _componentTransactions);
            }

            isPaymPartial = abs(isPaymPartial * _settlementFactor);

            taxInCostPrice =  isAccruePayable ? this.calcRecoveryLOIMSTByInvVoucher_IN(taxTrans) : this.calcRecoveryLOIByPaymVoucher_IN(taxTrans);

            taxTransCopy.data(taxTrans);
            taxTransCopy = this.resetTaxTrans_IN(taxTransCopy);
            if ( (taxTransCopy.TaxAmount- taxInCostPrice)*isPaymPartial !=0
                    && taxTrans_W.TaxType_IN ==TaxType_IN::ServiceTax )
            {
                ledgerVoucher = settlementPair.findLedgerVoucherByCompany(settlementPair.getDebitCompany());
                // Inserting Tax Trans for Settlement if Partial Payments and adjustments based on settlement factor

                taxTransCopy_W = taxTransCopy.taxTrans_W();
                // Move out - Begin
                taxTransCopy.TaxAmount = (- CurrencyExchange::round((taxTransCopy.TaxAmount - taxInCostPrice) * isPaymPartial/100,  taxTrans.CurrencyCode)
                                           + CurrencyExchangeHelper::amountCur2MST(recoverableAmtCur * isPaymPartial / 100, taxTrans.SourceCurrencyCode, 0, taxTrans.TransDate)
                                           + CurrencyExchangeHelper::amountCur2MST(expenseAmtCur * isPaymPartial / 100, taxTrans.SourceCurrencyCode, 0, taxTrans.TransDate));
                this.initTaxTrans_IN(taxTransCopy, _ledgerJournalTrans, ledgerVoucher);
                taxTransCopy.insert();

                exchRateHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));
                ledgerVoucher.findLedgerVoucherObject().lastTransTxt(_ledgerJournalTrans.Txt);
                ledgerVoucherTransObjectRev = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                   LedgerPostingType::ServiceTax_IN,
                                                                                    interimRecoverable,
                                                                                   taxTrans.CurrencyCode,
                                                                                   taxTransCopy.SourceRegulateAmountCur,
                                                                                   exchRateHelper);
                ledgerVoucherTransObjectRev.parmLedgerDetailLevel(LedgerDetailLevel::Summary);
                ledgerVoucher.addTrans(ledgerVoucherTransObjectRev);

                interimRecoverable  = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(interimRecoverable);
                taxTransSettle.InterimRecoverableLedgerDimension = interimRecoverable;
                taxTransSettle.RecoverableLedgerDimension   = interimRecoverable;
                taxTransSettle.TaxAmount                    = taxTransCopy.TaxAmount;
                taxTransSettle.SourceTaxAmountCur           = taxTransCopy.SourceTaxAmountCur;
                taxTransSettle.SourceRegulateAmountCur      = taxTransCopy.SourceRegulateAmountCur;
                taxTransSettle.PostedTaxAmout               = taxTransCopy.SourceRegulateAmountCur;
                taxTransSettle.SourceBaseAmountCur          = taxTransCopy.TaxBaseAmount;
                taxTransSettle.TaxComponentTable            = taxTransCopy_W.TaxComponentTable_IN;
                taxTransSettle.CustVendRegistrationNumber   = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(
                                                                                                   VendTable::find(settlementPair.getCustVendTransDebit().AccountNum).Party)).stcRegistrationNumberTable;
                taxTransSettle.VoucherCurrency              = taxTransCopy.SourceCurrencyCode;
                taxTransSettle.CompanyRegistrationNumber    = taxReportVoucher.TaxRegistrationNumberTable_IN;
                taxTransSettle.ExpenseLedgerDimension       = 0 ;
                this.initTaxTransIN_IN(taxTransSettle, taxTransCopy, ledgerVoucher, taxTable, taxTrans, _ledgerJournalTrans, vendTrans, taxTransloc, exchRateHelper);
                taxTransSettle.insert();

                postExpenseAmount =0;

                accountNum = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(interimRecoverable);
                postExpenseAmount = this.determineGTAExpenseAmount_IN(taxTrans.InventTransId, taxTrans.Voucher, taxTrans.TaxCode,taxTrans.TransDate);

                if (postExpenseAmount * isPaymPartial)
                {
                    isPaymPartial       = isPaymPartial/100;
                    postExpenseAmount   = postExpenseAmount * isPaymPartial;

                    taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::Table, taxReportVoucher.TaxRegistrationNumberTable_IN).RecId;
                    if (!taxLedgerAccountSetup)
                    {
                        taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::All).RecId;
                    }
                    expenseAccount = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountSetup, TaxAccountType_IN::ServiceTaxExpenseAccount, taxTable.TaxComponentTable_IN);

                    expenseAccount  = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(expenseAccount,
                                                                                                       taxTransloc.LedgerDimension);
                    // Inserting Tax Transactions for Settlement for expenseAccounts
                    taxTransCopy.data(taxTrans);
                    taxTransCopy = this.resetTaxTrans_IN(taxTransCopy);
                    taxTransCopy_W = taxTransCopy.taxTrans_W();
                    taxTransCopy.TaxAmount = CurrencyExchange::round(postExpenseAmount, taxTrans.CurrencyCode);
                    this.initTaxTrans_IN(taxTransCopy, _ledgerJournalTrans, ledgerVoucher);
                    taxTransCopy.Voucher = _ledgerJournalTrans.Voucher;
                    taxTransCopy.insert();

                    ledgerVoucherTransObjectRev = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                   LedgerPostingType::ServiceTax_IN,
                                                                                   expenseAccount,
                                                                                   taxTrans.CurrencyCode,
                                                                                   taxTransCopy.SourceRegulateAmountCur,
                                                                                   exchRateHelper);
                    ledgerVoucherTransObjectRev.parmLedgerDetailLevel(LedgerDetailLevel::Summary);
                    ledgerVoucher.addTrans(ledgerVoucherTransObjectRev);

                    taxTransSettle.TaxComponentTable          = taxTransCopy_W.TaxComponentTable_IN;
                    taxTransSettle.ExpenseLedgerDimension     = expenseAccount;
                    taxTransSettle.ExpenseAmount              = taxTransCopy.TaxAmount;
                    taxTransSettle.SourceTaxAmountCur         = taxTransCopy.SourceTaxAmountCur;
                    taxTransSettle.SourceRegulateAmountCur    = taxTransCopy.SourceRegulateAmountCur;
                    taxTransSettle.SourceBaseAmountCur        = taxTransCopy.TaxBaseAmount;
                    taxTransSettle.VoucherCurrency            = taxTransCopy.SourceCurrencyCode;
                    taxTransSettle.CompanyRegistrationNumber  = taxReportVoucher.TaxRegistrationNumberTable_IN;
                    taxTransSettle.CustVendRegistrationNumber = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(
                                                                                                   VendTable::find(settlementPair.getCustVendTransDebit().AccountNum).Party)).stcRegistrationNumberTable;
                    this.initTaxTransIN_IN(taxTransSettle, taxTransCopy, ledgerVoucher, taxTable, taxTrans, _ledgerJournalTrans, vendTrans, taxTransloc, exchRateHelper);
                    taxTransSettle.insert();
                }

                if (!((taxTrans.TaxAmount- taxInCostPrice)* isPaymPartial - postExpenseAmount* isPaymPartial) ==0 &&
                    !postExpenseAmount)
                {
                    isPaymPartial       = isPaymPartial/100;
                    taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::Table, taxReportVoucher.TaxRegistrationNumberTable_IN).RecId;
                    if (!taxLedgerAccountSetup)
                    {
                        taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::All).RecId;
                    }

                    recoverableAccount  = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountSetup, TaxAccountType_IN::ServiceTaxRecoverableAccount,taxTable.TaxComponentTable_IN);

                    recoverableAccount  = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(recoverableAccount,
                                                                                                           taxTransloc.LedgerDimension);

                    // Inserting Tax Transactions for Settlement for recoverable accounts
                    taxTransCopy.data(taxTrans);
                    taxTransCopy = this.resetTaxTrans_IN(taxTransCopy);
                    taxTransCopy_W = taxTransCopy.taxTrans_W();
                    taxTransCopy.TaxAmount = (CurrencyExchange::round((taxTransCopy.TaxAmount - taxInCostPrice) * isPaymPartial - postExpenseAmount, taxTrans.CurrencyCode)
                                                        - CurrencyExchangeHelper::amountCur2MST(recoverableAmtCur * isPaymPartial, taxTrans.SourceCurrencyCode, 0, taxTrans.TransDate)
                                                        - CurrencyExchangeHelper::amountCur2MST(expenseAmtCur * isPaymPartial, taxTrans.SourceCurrencyCode, 0, taxTrans.TransDate));
                    this.initTaxTrans_IN(taxTransCopy, _ledgerJournalTrans, ledgerVoucher);
                    taxTransCopy.insert();

                    ledgerVoucherTransObjectRev = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                   LedgerPostingType::ServiceTax_IN,
                                                                                   recoverableAccount,
                                                                                   taxTrans.CurrencyCode,
                                                                                   taxTransCopy.SourceRegulateAmountCur,
                                                                                   exchRateHelper);
                    ledgerVoucherTransObjectRev.parmLedgerDetailLevel(LedgerDetailLevel::Summary);
                    ledgerVoucher.addTrans(ledgerVoucherTransObjectRev);

                    recoverableAccount  = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(recoverableAccount);
                    taxTransSettle.ServiceRecoverableLedgerDimension   = recoverableAccount;
                    taxTransSettle.RecoverableLedgerDimension   = recoverableAccount;
                    taxTransSettle.TaxComponentTable            = taxTransCopy.taxTrans_W().TaxComponentTable_IN;
                    taxTransSettle.SourceTaxAmountCur           = taxTransCopy.SourceTaxAmountCur;
                    taxTransSettle.SourceRegulateAmountCur      = taxTransCopy.SourceRegulateAmountCur;
                    taxTransSettle.PostedTaxAmout               = taxTransCopy.SourceRegulateAmountCur;
                    taxTransSettle.TaxAmount                    = taxTransCopy.TaxAmount;
                    taxTransSettle.SourceBaseAmountCur          = taxTransCopy.TaxBaseAmount;
                    taxTransSettle.CompanyRegistrationNumber    = taxReportVoucher.TaxRegistrationNumberTable_IN;
                    taxTransSettle.CustVendRegistrationNumber   = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(
                                                                                                   VendTable::find(settlementPair.getCustVendTransDebit().AccountNum).Party)).stcRegistrationNumberTable;
                    this.initTaxTransIN_IN(taxTransSettle, taxTransCopy, ledgerVoucher, taxTable, taxTrans, _ledgerJournalTrans, vendTrans, taxTransloc, exchRateHelper);
                    taxTransSettle.insert();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postGTAVendorReverseChargeAdv_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts GTA vendor information.
    /// </summary>
    /// <param name="_settlementFactor">
    /// The settlement factor.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal trans.
    /// </param>
    /// <param name="_detailTrans">
    /// The TaxSalesTaxPaymentHistoryDetailsTrans_IN.
    /// </param>
    /// <param name="_taxComponentTable">
    /// The RefRecId of TaxComponentTable.
    /// </param>
    public void postGTAVendorReverseChargeAdv_IN(
        Factor                                      _settlementFactor,
        LedgerJournalTrans                          _ledgerJournalTrans,
        TaxSalesTaxPaymentHistoryDetailsTrans_IN    _detailTrans,
        RefRecId                                    _taxComponentTable)
    {
        TaxReportVoucher            taxReportVoucher;
        TaxTrans_IN                 taxTransloc;
        TaxTrans_IN                 taxTransSettle;
        TaxTrans_IN                 detailTransTaxTransLoc;
        TaxTrans                    taxTransCopy;
        TaxTrans                    taxTrans;
        TaxTrans                    detailTransTaxTrans;
        TaxTable                    taxTable;
        TaxAmountCur                postExpenseAmount;
        RefRecId                    recoverableAccount;
        RefRecId                    expenseAccount;
        RefRecId                    interimRecoverable;
        real                        isPaymPartial=1;
        VendTrans                   vendTrans;
        LedgerVoucher               ledgerVoucher;
        RefRecId                    taxLedgerAccountSetup;
        CurrencyExchangeHelper      exchRateHelper;
        MainAccountNum              accountNum;
        CustVendTrans_W             custVendTrans_W;
        TaxTrans_W                  taxTrans_W;
        TaxTrans_W                  taxTransCopy_W;
        PurchLine                   purchLineRev;
        TaxLedgerAccounts_IN        taxLedgerAccountsRev;
        TaxTrans_IN                 taxTransRev_IN;
        VendTable                   vendTableRev;
        LedgerVoucherTransObject    ledgerVoucherTransObjectRev;
        VendTrans                   vendTransLoc,vendTransRev;
        TaxAmountCur                recoverableAmtCur;
        TaxAmountCur                expenseAmtCur;
        VendInvoiceJour             vendInvoiceJourRev;
        TaxAmount                   taxInCostPrice;
        boolean                     isAccruePayable = false;

        detailTransTaxTransLoc = TaxTrans_IN::findRecId(_detailTrans.TaxTrans_IN);
        detailTransTaxTrans = TaxTrans::findRecId_IN(detailTransTaxTransLoc.RefRecId);

        select firstonly Voucher, TaxRegistrationNumberTable_IN from taxReportVoucher
            where taxReportVoucher.Voucher  == settlementPair.getCustVendTransDebit().Voucher;

        custVendTrans_W = settlementPair.getCustVendTransDebit().CustVendTrans::getCustVendTrans_W();

        while select RecId, TaxType_IN  from taxTrans_W
           where taxTrans_W.TaxTransRefRecId_IN  == detailTransTaxTrans.RecId
              && taxTrans_W.TaxType_IN           == TaxType_IN::ServiceTax
           join taxTrans
              where taxTrans.RecId               == taxTrans_W.TaxTrans
                 && taxTrans.TaxCode             == detailTransTaxTrans.TaxCode
           exists join taxTransRev_IN
              where taxTransRev_IN.RefRecId      == taxTrans.RecId
           exists join taxLedgerAccountsRev
              where taxLedgerAccountsRev.LedgerDimension       == taxTransRev_IN.PayableLedgerDimension
                 && (taxLedgerAccountsRev.AccountType          == TaxAccountType_IN::ServiceTaxInterimPayableAccount
                     || taxLedgerAccountsRev.AccountType       == TaxAccountType_IN::ServiceTaxPayableAccount)
                 && taxLedgerAccountsRev.TaxComponentTable     == _taxComponentTable
        {
            isAccruePayable = TaxItemGroupHeading::isAccruePayableAtInvoicing_IN(taxTrans.TaxItemGroup);

            taxTransloc = TaxTrans_IN::findRecId(_detailTrans.TaxTrans_IN);
            taxTable = TaxTable::find(TaxTrans::findRecId_IN(taxTransloc.RefRecId).TaxCode);

            taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::Table, taxReportVoucher.TaxRegistrationNumberTable_IN).RecId;
            if (!taxLedgerAccountSetup)
            {
                taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::All).RecId;
            }

            interimRecoverable = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountSetup, TaxAccountType_IN::ServiceTaxInterimRecoverableAccount, taxTable.TaxComponentTable_IN);

            interimRecoverable = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(interimRecoverable,
                                                                                                  taxTransloc.LedgerDimension);
            //IR which is reversed during invoice should be deducted from the total IP.Should be deducted only once.
            if (!recoverableAmtMap.exists(taxTable.TaxCode + taxTrans.Voucher))
            {
                recoverableAmtCur = isAccruePayable ? this.getReverseChargeRecoverableAmtByInv_IN(taxTrans) : this.getReverseChargeRecoverableAmt_IN(taxTrans);
            }
            //Expense which is posted during invoice should be deducted from the total IP.Should be deducted only once.
            if (!expenseAmtMap.exists(taxTable.TaxCode + taxTrans.Voucher))
            {
                expenseAmtCur = isAccruePayable ? this.getReverseChargeExpenseAmtByInv_IN(taxTrans) : this.getReverseChargeExpenseAmt_IN(taxTrans);
            }
            // Posting will happen only when
            // Authority vendor posting + (IsRecoverableServiceTax_IN 'MARKED = TRUE'  + GTAServiceCategory_IN 'NOT EQUAL' to OTHERS ,during invoice).
            vendTableRev = VendTable::find(VendTrans::findVoucherDate(taxTrans.Voucher, taxTrans.TransDate).AccountNum);
            if (vendTableRev.RecId == 0)
            {
                select firstonly vendTableRev
                exists join vendTrans
                    where vendTrans.AccountNum == vendTableRev.AccountNum
                       && vendTrans.Voucher    == (isAccruePayable ? taxTrans.Voucher : this.findInvVoucherFrmPymtRelVoucher_IN(taxTrans.Voucher, taxTrans.TransDate));
            }
            if (taxTrans.InventTransId)
            {
                select firstonly RecId,VendAccount from purchLineRev
                    where purchLineRev.InventTransId == taxTrans.InventTransId;

                if (vendTableRev.RecId == 0 && purchLineRev.VendAccount)
                {
                    vendTableRev = VendTable::find(purchLineRev.VendAccount);
                }
            }
            else
            {
                //This is when advance payment is made, there is no linked purchLine(blank inventTransid). Still the taxTrans has to be processed here.
                select firstonly RecId from purchLineRev
                exists join vendInvoiceJourRev
                    where purchLineRev.PurchId == vendInvoiceJourRev.PurchId
                exists join vendTransLoc
                    where vendTransLoc.Voucher == (isAccruePayable ? taxTrans.Voucher : this.findInvVoucherFrmPymtRelVoucher_IN(taxTrans.Voucher, taxTrans.TransDate))
                       && vendInvoiceJourRev.LedgerVoucher  == vendTransLoc.Voucher
                       && vendInvoiceJourRev.InvoiceAccount == vendTransLoc.AccountNum;
            }

            if (purchLineRev.RecId)
            {
                if (vendTableRev.isForeign())
                {
                    // (1) If its PO with recoverable expense check box unmarked(TaxInfo tab), then Recoverable will be reversed during
                    //     Vendor payment itself. It will not wait for Authority Payament. So here in Authority Payment time
                    //     We are skipping the reversal for PO Interim recoverables when the check box is unmarked.
                    // (2) For reverse charge feature, payables are created for Non-GTA also(including foreign vendor).
                    //     So since foreign vendor is already posted from 'postForeignVendor_IN()' method.
                    //     Stop duplicate posting.
                    continue;
                }
            }

            exchRateHelper = CurrencyExchangeHelper::construct();
            exchRateHelper.parmExchangeRate1(settlementPair.getCustVendTransDebit().exchRateCurToMst());
            exchRateHelper.parmExchangeRate2(settlementPair.getCustVendTransDebit().ExchRateSecond);
            exchRateHelper.parmExchangeDate(taxTrans.TransDate);

            vendTrans= VendTrans::find(settlementPair.getCustVendTransDebit().RecId);

            vendTransLoc = VendTrans::findVoucherDate(taxTrans.Voucher,taxTrans.TransDate); //Invoice time record.

            select sum(SettleAmountMST) from vendTransRev //Payment time record, summing up of multiple payments made if any, for single invoice.
                where vendTransRev.LastSettleVoucher  == taxTrans.Voucher;
            //Check if the 'Interim Recoverable' of invoice is fully reversed.
            //If the sum of multiple payments made to settle an invoice is less than invoice amount, the IR of invoice will not be fully reversed.
            //The factor 'isPaymPartial' should be calculated only if the IR is not fully reversed.
            if (abs(vendTransRev.SettleAmountMST) < abs(vendTransLoc.AmountMST))
            {
                isPaymPartial = this.isGTAPartialPaymAdv_IN(taxTrans, _detailTrans);
            }

            isPaymPartial = abs(isPaymPartial * _settlementFactor);

            taxInCostPrice = isAccruePayable ? this.calcRecoveryLOIMSTByInvVoucher_IN(taxTrans) : this.calcRecoveryLOIByPaymVoucher_IN(taxTrans);

            taxTransCopy.data(taxTrans);
            taxTransCopy =  this.resetTaxTrans_IN(taxTransCopy);
            if ( (taxTransCopy.TaxAmount- taxInCostPrice)*isPaymPartial !=0
                    && taxTrans_W.TaxType_IN ==TaxType_IN::ServiceTax )
            {
                ledgerVoucher = settlementPair.findLedgerVoucherByCompany(settlementPair.getDebitCompany());
                // Inserting Tax Trans for Settlement if Partial Payments and adjustments based on settlement factor
                taxTransCopy_W = taxTransCopy.taxTrans_W();
                // Move out - Begin
                taxTransCopy.TaxAmount = (- CurrencyExchange::round((taxTransCopy.TaxAmount - taxInCostPrice) * isPaymPartial/100,  taxTrans.CurrencyCode)
                                           + CurrencyExchangeHelper::amountCur2MST(recoverableAmtCur * isPaymPartial / 100, taxTrans.SourceCurrencyCode, 0, taxTrans.TransDate)
                                           + CurrencyExchangeHelper::amountCur2MST(expenseAmtCur * isPaymPartial / 100, taxTrans.SourceCurrencyCode, 0, taxTrans.TransDate));
                this.initTaxTrans_IN(taxTransCopy, _ledgerJournalTrans, ledgerVoucher);
                taxTransCopy.insert();

                exchRateHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));
                ledgerVoucher.findLedgerVoucherObject().lastTransTxt(_ledgerJournalTrans.Txt);
                ledgerVoucherTransObjectRev = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                   LedgerPostingType::ServiceTax_IN,
                                                                                    interimRecoverable,
                                                                                   taxTrans.CurrencyCode,
                                                                                   taxTransCopy.SourceRegulateAmountCur,
                                                                                   exchRateHelper);
                ledgerVoucherTransObjectRev.parmLedgerDetailLevel(LedgerDetailLevel::Summary);
                ledgerVoucher.addTrans(ledgerVoucherTransObjectRev);

                interimRecoverable  = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(interimRecoverable);
                taxTransSettle.InterimRecoverableLedgerDimension = interimRecoverable;
                taxTransSettle.RecoverableLedgerDimension   = interimRecoverable;
                taxTransSettle.TaxAmount                    = taxTransCopy.TaxAmount;
                taxTransSettle.SourceTaxAmountCur           = taxTransCopy.SourceTaxAmountCur;
                taxTransSettle.SourceRegulateAmountCur      = taxTransCopy.SourceRegulateAmountCur;
                taxTransSettle.PostedTaxAmout               = taxTransCopy.SourceRegulateAmountCur;
                taxTransSettle.SourceBaseAmountCur          = taxTransCopy.TaxBaseAmount;
                taxTransSettle.TaxComponentTable            = taxTransCopy_W.TaxComponentTable_IN;
                taxTransSettle.CustVendRegistrationNumber   = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(
                                                                                                   VendTable::find(settlementPair.getCustVendTransDebit().AccountNum).Party)).stcRegistrationNumberTable;
                taxTransSettle.VoucherCurrency              = taxTransCopy.SourceCurrencyCode;
                taxTransSettle.CompanyRegistrationNumber    = taxReportVoucher.TaxRegistrationNumberTable_IN;
                taxTransSettle.ExpenseLedgerDimension       = 0 ;
                this.initTaxTransIN_IN(taxTransSettle, taxTransCopy, ledgerVoucher, taxTable, taxTrans, _ledgerJournalTrans, vendTrans, taxTransloc, exchRateHelper);
                taxTransSettle.insert();

                postExpenseAmount =0;

                accountNum = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(interimRecoverable);
                postExpenseAmount = this.determineGTAExpenseAmount_IN(taxTrans.InventTransId, taxTrans.Voucher, taxTrans.TaxCode,taxTrans.TransDate);

                if (postExpenseAmount * isPaymPartial)
                {
                    isPaymPartial       = isPaymPartial/100;
                    postExpenseAmount   = postExpenseAmount * isPaymPartial;

                    taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::Table, taxReportVoucher.TaxRegistrationNumberTable_IN).RecId;
                    if (!taxLedgerAccountSetup)
                    {
                        taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::All).RecId;
                    }
                    expenseAccount = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountSetup, TaxAccountType_IN::ServiceTaxExpenseAccount, taxTable.TaxComponentTable_IN);

                    expenseAccount  = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(expenseAccount,
                                                                                                       taxTransloc.LedgerDimension);
                    // Inserting Tax Transactions for Settlement for expenseAccounts
                    taxTransCopy.data(taxTrans);
                    taxTransCopy = this.resetTaxTrans_IN(taxTransCopy);
                    taxTransCopy_W = taxTransCopy.taxTrans_W();
                    taxTransCopy.TaxAmount = CurrencyExchange::round(postExpenseAmount, taxTrans.CurrencyCode);
                    this.initTaxTrans_IN(taxTransCopy, _ledgerJournalTrans, ledgerVoucher);
                    taxTransCopy.Voucher = _ledgerJournalTrans.Voucher;
                    taxTransCopy.insert();

                    ledgerVoucherTransObjectRev = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                   LedgerPostingType::ServiceTax_IN,
                                                                                   expenseAccount,
                                                                                   taxTrans.CurrencyCode,
                                                                                   taxTransCopy.SourceRegulateAmountCur,
                                                                                   exchRateHelper);
                    ledgerVoucherTransObjectRev.parmLedgerDetailLevel(LedgerDetailLevel::Summary);
                    ledgerVoucher.addTrans(ledgerVoucherTransObjectRev);

                    taxTransSettle.TaxComponentTable          = taxTransCopy_W.TaxComponentTable_IN;
                    taxTransSettle.ExpenseLedgerDimension     = expenseAccount;
                    taxTransSettle.ExpenseAmount              = taxTransCopy.TaxAmount;
                    taxTransSettle.SourceTaxAmountCur         = taxTransCopy.SourceTaxAmountCur;
                    taxTransSettle.SourceRegulateAmountCur    = taxTransCopy.SourceRegulateAmountCur;
                    taxTransSettle.SourceBaseAmountCur        = taxTransCopy.TaxBaseAmount;
                    taxTransSettle.VoucherCurrency            = taxTransCopy.SourceCurrencyCode;
                    taxTransSettle.CompanyRegistrationNumber  = taxReportVoucher.TaxRegistrationNumberTable_IN;
                    taxTransSettle.CustVendRegistrationNumber = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(
                                                                                                   VendTable::find(settlementPair.getCustVendTransDebit().AccountNum).Party)).stcRegistrationNumberTable;
                    this.initTaxTransIN_IN(taxTransSettle, taxTransCopy, ledgerVoucher, taxTable, taxTrans, _ledgerJournalTrans, vendTrans, taxTransloc, exchRateHelper);
                    taxTransSettle.insert();
                }

                if (!((taxTransCopy.TaxAmount- taxInCostPrice)* isPaymPartial - postExpenseAmount* isPaymPartial) ==0 &&
                    !postExpenseAmount)
                {
                    isPaymPartial       = isPaymPartial/100;
                    taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::Table, taxReportVoucher.TaxRegistrationNumberTable_IN).RecId;
                    if (!taxLedgerAccountSetup)
                    {
                        taxLedgerAccountSetup = TaxLedgerAccountSetup_IN::findByTaxAccountGroup(taxTable.TaxLedgerAccountGroup_IN, TaxAccountCode_IN::All).RecId;
                    }

                    recoverableAccount  = TaxLedgerAccounts_IN::getAccountNum(taxLedgerAccountSetup, TaxAccountType_IN::ServiceTaxRecoverableAccount,taxTable.TaxComponentTable_IN);

                    recoverableAccount  = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(recoverableAccount,
                                                                                                           taxTransloc.LedgerDimension);

                    // Inserting Tax Transactions for Settlement for recoverable accounts
                    taxTransCopy.data(taxTrans);
                    taxTransCopy = this.resetTaxTrans_IN(taxTransCopy);
                    taxTransCopy_W = taxTransCopy.taxTrans_W();
                    taxTransCopy.TaxAmount = (CurrencyExchange::round((taxTransCopy.TaxAmount - taxInCostPrice) * isPaymPartial - postExpenseAmount, taxTrans.CurrencyCode)
                                                        - CurrencyExchangeHelper::amountCur2MST(recoverableAmtCur * isPaymPartial, taxTrans.SourceCurrencyCode, 0, taxTrans.TransDate)
                                                        - CurrencyExchangeHelper::amountCur2MST(expenseAmtCur * isPaymPartial, taxTrans.SourceCurrencyCode, 0, taxTrans.TransDate));
                    this.initTaxTrans_IN(taxTransCopy, _ledgerJournalTrans, ledgerVoucher);
                    taxTransCopy.insert();

                    ledgerVoucherTransObjectRev = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                   LedgerPostingType::ServiceTax_IN,
                                                                                   recoverableAccount,
                                                                                   taxTrans.CurrencyCode,
                                                                                   taxTransCopy.SourceRegulateAmountCur,
                                                                                   exchRateHelper);
                    ledgerVoucherTransObjectRev.parmLedgerDetailLevel(LedgerDetailLevel::Summary);
                    ledgerVoucher.addTrans(ledgerVoucherTransObjectRev);

                    recoverableAccount  = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(recoverableAccount);
                    taxTransSettle.ServiceRecoverableLedgerDimension   = recoverableAccount;
                    taxTransSettle.RecoverableLedgerDimension   = recoverableAccount;
                    taxTransSettle.TaxComponentTable            = taxTransCopy.taxTrans_W().TaxComponentTable_IN;
                    taxTransSettle.SourceTaxAmountCur           = taxTransCopy.SourceTaxAmountCur;
                    taxTransSettle.SourceRegulateAmountCur      = taxTransCopy.SourceRegulateAmountCur;
                    taxTransSettle.PostedTaxAmout               = taxTransCopy.SourceRegulateAmountCur;
                    taxTransSettle.TaxAmount                    = taxTransCopy.TaxAmount;
                    taxTransSettle.SourceBaseAmountCur          = taxTransCopy.TaxBaseAmount;
                    taxTransSettle.CompanyRegistrationNumber    = taxReportVoucher.TaxRegistrationNumberTable_IN;
                    taxTransSettle.CustVendRegistrationNumber   = TaxInformation_IN::findDefaultbyLocation(DirParty::primaryPostalAddressLocationRecId(
                                                                                                   VendTable::find(settlementPair.getCustVendTransDebit().AccountNum).Party)).stcRegistrationNumberTable;
                    this.initTaxTransIN_IN(taxTransSettle, taxTransCopy, ledgerVoucher, taxTable, taxTrans, _ledgerJournalTrans, vendTrans, taxTransloc, exchRateHelper);
                    taxTransSettle.insert();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingProfileSettle_CreateDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the general journal records for posting profile differences.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// The ledger voucher used for settlement.
    /// </param>
    /// <param name="_custVendTrans">
    /// The <c>CustVendTrans</c> record for used for settlement.
    /// </param>
    /// <param name="_distributionController">
    /// The <c>CustVendTransDistributionController</c> instance associated with the <paramref name="_custVendTrans"/> record.
    /// </param>
    /// <param name="_amountCur">
    /// The posting profile difference amount.
    /// </param>
    /// <param name="_amountAccounting">
    /// The posting profile difference accounting currency amount.
    /// </param>
    /// <param name="_amountReporting">
    /// The posting profile difference reporting currency amount.
    /// </param>
    /// <param name="_transTxt">
    /// The transaction text for the posting profile transactions.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code for the transaction amount.
    /// </param>
    /// <param name="_forceSingleDistribution">
    /// A boolean value that indicates whether to force the process to only generate a single distribution;
    /// optional.
    /// </param>
    protected void postingProfileSettle_CreateDistributions(
        LedgerVoucher           _ledgerVoucher,
        CustVendTrans           _custVendTrans,
        CustVendTransDistributionController _distributionController,
        AmountCur               _amountCur,
        AmountMST               _amountAccounting,
        Money                   _amountReporting,
        TransactionTextLarge    _transTxt,
        CurrencyCode            _currencyCode,
        boolean                 _forceSingleDistribution = false)
    {
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        LedgerVoucherObject         ledgerVoucherObject;
        LedgerDimensionAccount      ledgerDimensionMerged;
        List                        distributions;
        ListEnumerator              distributionEnumerator;
        CustVendTransDistribution   distribution;

        // create ledger transaction
        ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
        ledgerVoucherObject.parmLedgerTransType(LedgerTransType::Settlement);

        ledgerDimensionMerged = this.getLedgerDimensionMerged(_custVendTrans);

        distributions = _distributionController.generateDistributions(
            _custVendTrans,
            this.getLedgerPostingType_Balance(),
            _amountCur,
            _amountAccounting,
            _amountReporting,
            ledgerDimensionMerged,
            _forceSingleDistribution);

        distributionEnumerator = distributions.getEnumerator();
        while (distributionEnumerator.moveNext())
        {
            distribution = distributionEnumerator.current();

            ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
                ledgerVoucherObject,
                this.getLedgerPostingType_Settlement(),
                distribution.ledgerDimension(),
                _currencyCode,
                distribution.transactionAmount(),
                distribution.accountingAmount(),
                distribution.reportingAmount());

            ledgerVoucherTransObject.parmTransTxt(_transTxt);
            ledgerVoucherTransObject.parmSkipDimensionValidation(true);
            _ledgerVoucher.addTrans(ledgerVoucherTransObject);

            if (CustVendTransPostingLog_RU::usePostingLog())
            {
                this.settleForDifferentProfilesPostingLog_W(_ledgerVoucher, _custVendTrans, distribution);
            }

        }

        ledgerVoucherObject.lastTransTxt('');
        ledgerVoucherObject.parmLedgerTransType(LedgerTransType::None);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionMerged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a merged ledger dimension account.
    /// </summary>
    /// <param name = "_custVendTrans">
    /// The <c>CustVendTrans</c> record used for settlement.
    /// </param>
    /// <returns>
    /// An instance of <c>LedgerDimensionAccount</c>.
    /// </returns>
    protected LedgerDimensionAccount getLedgerDimensionMerged(CustVendTrans _custVendTrans)
    {
        return LedgerDimensionFacade::serviceCreateLedgerDimension(_custVendTrans.summaryLedgerDimension(), _custVendTrans.DefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingProfileSettle_CreateTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>CustVendTrans</c> and <c>CustVendSettlement</c> records for posting profile
    /// differences.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// The ledger voucher used for settlement.
    /// </param>
    /// <param name="_custVendTrans">
    /// The <c>CustVendTrans</c> record that is used for settlement.
    /// </param>
    /// <param name="_amountCur">
    /// The posting profile difference amount.
    /// </param>
    /// <param name="_amountAccounting">
    /// The posting profile difference accounting currency amount.
    /// </param>
    /// <param name="_amountReporting">
    /// The posting profile difference reporting currency amount.
    /// </param>
    /// <param name="_custVendTransSettlement">
    /// The instance of the <c>CustVendTransSettlement</c> class to use when the CustVendTrans and
    /// CustVendSettlement records are added.
    /// </param>
    /// <param name="_settlementGroupPlaceHolder">
    /// The placeholder settlement group for the settlement.
    /// </param>
    /// <param name="_transDimesion">
    /// The dimension of the new transactions.
    /// </param>
    /// <param name="_postingProfile">
    /// The posting profile of the new transactions.
    /// </param>
    /// <param name="_transTxt">
    /// The transaction text for the posting profile transactions.
    /// </param>
    protected void postingProfileSettle_CreateTrans(
        LedgerVoucher           _ledgerVoucher,
        CustVendTrans           _custVendTrans,
        AmountCur               _amountCur,
        AmountMST               _amountAccounting,
        Money                   _amountReporting,
        CustVendTransSettlement _custVendTransSettlement,
        Counter                 _settlementGroupPlaceHolder,
        DimensionDefault        _transDimesion,
        PostingProfile          _postingProfile,
        TransactionTextLarge    _transTxt)
    {
        CustVendTrans   localCustVendTrans;

        localCustVendTrans = this.initCustVendTransBuffer();

        localCustVendTrans.AccountNum = _custVendTrans.AccountNum;
        localCustVendTrans.Voucher = _ledgerVoucher.lastVoucher();
        localCustVendTrans.Invoice = _custVendTrans.Invoice;
        localCustVendTrans.TransDate = _ledgerVoucher.lastTransDate();

        localCustVendTrans.DefaultDimension  = _transDimesion;
        localCustVendTrans.PostingProfile = _postingProfile;
        localCustVendTrans.TransType = LedgerTransType::Settlement;
        localCustVendTrans.PaymMode = _custVendTrans.PaymMode;
        localCustVendTrans.PaymSpec = _custVendTrans.PaymSpec;
        localCustVendTrans.Txt = _transTxt;

        localCustVendTrans.AmountCur = _amountCur;
        localCustVendTrans.AmountMST = _amountAccounting;
        localCustVendTrans.ReportingCurrencyAmount = _amountReporting;
        localCustVendTrans.SettleAmountCur = localCustVendTrans.AmountCur;
        localCustVendTrans.SettleAmountMST = localCustVendTrans.AmountMST;
        localCustVendTrans.SettleAmountReporting = localCustVendTrans.ReportingCurrencyAmount;

        localCustVendTrans.CurrencyCode = _custVendTrans.CurrencyCode;
        localCustVendTrans.ExchRate = settlementPair.getExchRate().getDebitCurToDebitMstCombined();
        localCustVendTrans.ReportingCurrencyExchRate = settlementPair.getExchRate().getDebitCurToReporting();
        localCustVendTrans.ReportingCurrencyCrossRate = settlementPair.getExchRate().getDebitCurToReporting();

        localCustVendTrans.LastSettleDate = _ledgerVoucher.findLedgerVoucherObject().parmTransDate();
        localCustVendTrans.LastSettleVoucher = localCustVendTrans.Voucher;
        localCustVendTrans.LastSettleCompany = localCustVendTrans.DataAreaId;
        localCustVendTrans.LastSettleAccountNum = localCustVendTrans.AccountNum;
        localCustVendTrans.Closed = localCustVendTrans.LastSettleDate;

        localCustVendTrans.initFromPostingProfile(_postingProfile);

        // When the CustTrans record is created and the offsetRecId should
        // should point to another CustTrans record with the same settlement group and trans type.
        _custVendTransSettlement.addTransAndDefaultSettlement(localCustVendTrans, _settlementGroupPlaceHolder, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeFine_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the fine posting type
    /// </summary>
    /// <returns>
    /// The posting type
    /// </returns>
    public  LedgerPostingType postingTypeFine_BR()
    {
        return LedgerPostingType::CustFine_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeInterest_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the interest posting type
    /// </summary>
    /// <returns>
    /// The posting type
    /// </returns>
    public LedgerPostingType postingTypeInterest_BR()
    {
        return LedgerPostingType::CustInterest;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInterestTrans_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and post interest transaction for the settlement.
    /// </summary>
    /// <param name="_interestAmountCur">
    /// The interest amount in the transaction currency.
    /// </param>
    /// <param name="_interestAmountMst">
    /// The interest amount in the monetary standard (MST) currency.
    /// </param>
    /// <param name="_custVendTrans">
    /// The CustVendTrans record used to create the transaction.
    /// </param>
    /// <param name="_custVendTransOpen">
    /// The CustVendTransOpen record used to create the transaction.
    /// </param>
    /// <param name="_custVendTransOffset">
    /// The CustVendTrans record that is the offset of the interest transaction.
    /// </param>
    /// <param name="_exchRate">
    /// The exchange rate of the interest.
    /// </param>
    /// <param name="_interestLedgerDimension">
    /// The interest ledger dimension default account.
    /// </param>
    /// <param name="_settledAmountMstDebit">
    /// The settled amount of the debit transaction in MST currency.
    /// </param>
    /// <param name="_distributionController">
    /// The <c>CustVendTransSettleDistController</c> instance associated with the <paramref name="_custVendTrans"/> record.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The LedgerVoucher object used to create ledger transactions; optional.
    /// </param>
    protected void postInterestTrans_BR(AmountCur                           _interestAmountCur,
                                        AmountMST                           _interestAmountMst,
                                        CustVendTrans                       _custVendTrans,
                                        CustVendTransOpen                   _custVendTransOpen,
                                        CustVendTrans                       _custVendTransOffset,
                                        ExchRate                            _exchRate,
                                        LedgerDimensionDefaultAccount       _interestLedgerDimension,
                                        AmountMST                           _settledAmountMstDebit,
                                        CustVendTransSettleDistController   _distributionController,
                                        LedgerVoucher                       _ledgerVoucher = null)
    {
        CustVendTrans                   interestTrans       = _custVendTrans.data();
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        LedgerVoucher                   ledgerVoucher;
        LedgerVoucherObject             ledgerVoucherObject;
        TransactionTxt                  transactionTxt;
        DimensionDefault                dimension;
        boolean                         postInterestLedgerToCreditCompany;
        LedgerDimensionDefaultAccount   localinterestLedgerDimension = _interestLedgerDimension;
        LedgerDimensionAccount          ledgerDimensionMerged;
        NumberSeq                       numberSeq;
        NumberSequenceReference         numberSeqRef;
        LedgerInterCompany              interCompany;
        CurrencyExchangeHelper          exchangeRateHelper;
        List                            distributions;
        ListEnumerator                  distributionEnumerator;
        CustVendTransDistribution       distribution;

        Debug::assert(curext() == _custVendTrans.company());

        if (_interestAmountCur == 0)
        {
            // interest amount is zero so there is nothing to post
            return;
        }

        switch (_custVendTransOpen.TableId)
        {
            case tableNum(CustTransOpen) :
                _interestAmountCur = -(_interestAmountCur);
                _interestAmountMst = -(_interestAmountMst);
                break;

            case tableNum(VendTransOpen) :
                _interestAmountCur = _interestAmountCur;
                _interestAmountMst = _interestAmountMst;
                break;
        }

        transactionTxt = TransactionTxt::construct(this.interestTxtCustVend_BR(),
                                            _custVendTrans.languageId(),
                                            settlementPair.getTransactionDate(),
                                            _custVendTrans.Invoice,
                                            _custVendTrans.Voucher);

        transactionTxt.setCustVendName(this.getCustVendName_BR(_custVendTrans.AccountNum));
        transactionTxt.setKey1(_custVendTrans.AccountNum);

        if (_custVendTrans.company() == _custVendTransOffset.company())
        {
            dimension = _custVendTransOffset.DefaultDimension;
        }
        else
        {
            // different company get dimension for transaction.
            dimension = _custVendTrans.DefaultDimension;
        }

        // Intercompany Accounting - interest = Payment Company - No posting related to interest is necessary to Invoice company
        if (settlementPair.getCreditCompany() != settlementPair.getDebitCompany())
        {
            interCompany    = this.findLedgerInterCompany(settlementPair.getCreditCompany(), settlementPair.getDebitCompany());
        }

        if (interCompany.getInterestPostOptions_BR(this.parmModule()) == CustVendSettleCompanyPostOption::PaymentCompany)
        {
            postInterestLedgerToCreditCompany = this.postInterestTransToCreditCompany_BR(_custVendTrans, _custVendTransOffset, _interestAmountCur);

            changecompany(settlementPair.getCreditCompany())
            {
                interestTrans = this.createInterestFineCustVendTrans_BR(settlementPair.getCreditCompany(), _interestAmountCur,_interestAmountMst,_custVendTrans, _exchRate, transactionTxt, dimension);
            }
        }
        else
        {
            if (_ledgerVoucher == null)
            {
                ledgerVoucher = settlementPair.findLedgerVoucherByCompany(_custVendTrans.company());
            }
            else
            {
                ledgerVoucher = _ledgerVoucher;
            }

            // In centralized payment scenario, the fine/interest transactions should appear
            // on the same voucher as the Due To.  Otherwise, fine/interest transactions
            // should have their own voucher
            if (settlementPair.getDebitCompany() != settlementPair.getCreditCompany())
            {
                ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
            }
            else
            {
                // Get new voucher for interest transaction
                numberSeqRef = settlementPair.numRefCustVendPaymVoucher();
                numberSeq = NumberSeq::newGetVoucher(numberSeqRef);

                ledgerVoucherObject = LedgerVoucherObject::newVoucher(numberSeq.voucher(),
                                                                     settlementPair.getTransactionDate(),
                                                                     this.parmModule(),
                                                                     this.ledgerTransactionType());
                ledgerVoucher.addVoucher(ledgerVoucherObject);
            }

            interestTrans = this.createInterestFineCustVendTrans_BR(curext(), _interestAmountCur, _interestAmountMst, _custVendTrans, _exchRate, transactionTxt, dimension);

            ledgerVoucherObject.lastTransTxt(transactionTxt.txt());

            // create ledger transaction for payment company
            postInterestLedgerToCreditCompany = this.postInterestTransToCreditCompany_BR(_custVendTrans, _custVendTransOffset, _interestAmountCur);

            ledgerVoucherObject.parmPaymentReference(settlementPair.getCustVendTransCredit().PaymReference);

            if (postInterestLedgerToCreditCompany)
            {
                // the ledger account need to be the Due to/from ledger account
                localinterestLedgerDimension = dueToFromLedgerDimensionDebit;
            }

            ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
            exchangeRateHelper  = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
            exchangeRateHelper.parmExchangeRate1(interestTrans.ExchRate);
            interestTrans.setExchangeHelperReportingExchRate(exchangeRateHelper);

            ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(localinterestLedgerDimension, dimension);

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                    ledgerVoucherObject,
                                    this.postingTypeInterest_BR(),
                                    ledgerDimensionMerged,
                                    _custVendTrans.CurrencyCode,
                                    -(interestTrans.AmountCur),
                                    exchangeRateHelper);
            ledgerVoucherTransObject.parmSourceTableId(interestTrans.TableId);
            ledgerVoucherTransObject.parmSourceRecId(interestTrans.RecId);
            ledgerVoucher.addTrans(ledgerVoucherTransObject);

            // create ledger transaction for the AR or AP account number(s)
            ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();

            ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(_custVendTrans.summaryLedgerDimension(postingProfile), dimension);

            distributions = _distributionController.generateDistributions(
                _custVendTrans,
                this.getLedgerPostingType_Balance(),
                interestTrans.AmountCur,
                interestTrans.AmountMST,
                interestTrans.ReportingCurrencyAmount,
                ledgerDimensionMerged,
                false);

            distributionEnumerator = distributions.getEnumerator();
            while (distributionEnumerator.moveNext())
            {
                distribution = distributionEnumerator.current();

                ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
                    ledgerVoucherObject,
                    this.getLedgerPostingType_Balance(),
                    distribution.ledgerDimension(),
                    _custVendTrans.CurrencyCode,
                    distribution.transactionAmount(),
                    distribution.accountingAmount(),
                    distribution.reportingAmount());

                ledgerVoucherTransObject.parmSourceTableId(interestTrans.TableId);
                ledgerVoucherTransObject.parmSourceRecId(interestTrans.RecId);
                ledgerVoucherTransObject.parmSkipDimensionValidation(true);
                if (postCashDiscountInSummary)
                {
                    ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::Summary);
                }

                ledgerVoucher.addTrans(ledgerVoucherTransObject);
            }

            ledgerVoucher.findLedgerVoucherObject().lastTransTxt("");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInterestTransToCreditCompany_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the ledger transactions when the interest is posted to the payment company.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The CustVendTrans record used to create the transaction.
    /// </param>
    /// <param name="_custVendTransOffset">
    /// The CustVendTrans record used as the offset to the transaction.
    /// </param>
    /// <param name="_interestAmountCur">
    /// The interest amount in the transaction currency.
    /// </param>
    /// <returns>
    /// true if the interest is posted to the payment company; otherwise, false.
    /// </returns>
    protected boolean postInterestTransToCreditCompany_BR(CustVendTrans _custVendTrans,
                                                      CustVendTrans _custVendTransOffset,
                                                      FinInterestAmount_BR _interestAmountCur)
    {
        boolean                         postLedgerToCreditCompany;
        LedgerInterCompany              interCompany;
        FinInterestAmount_BR            interestAmountPaymentCur;
        AmountMST                       interestAmountPaymentMst;
        AmountMSTSecondary              interestAmountPaymentReporting;
        LedgerVoucher                   paymentLedgerVoucher;
        LedgerVoucherObject             ledgerVoucherObject;
        TransactionTxt                  paymentinterestText;
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        LedgerDimensionDefaultAccount   paymentinterestLedgerDimension;
        NumberSeq                       numberSeq;
        NumberSequenceReference         numberSeqRef;
        CurrencyExchangeHelper          currencyHelper;
        LedgerDimensionAccount          ledgerDimensionMerged;

        if (_interestAmountCur != 0 && settlementPair.getDebitCompany() != settlementPair.getCreditCompany() &&
            _custVendTrans.RecId == settlementPair.getCustVendTransDebit().RecId)
        {
            // Check if the LedgerInterCompany for credit company has interest post option set to PaymentCompany
            changecompany(settlementPair.getCreditCompany())
            {
                interCompany            = this.findLedgerInterCompany(settlementPair.getCreditCompany(), settlementPair.getDebitCompany());
                if (interCompany.getInterestPostOptions_BR(this.parmModule()) == CustVendSettleCompanyPostOption::PaymentCompany)
                {
                    postLedgerToCreditCompany = true;

                    currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(settlementPair.getCreditCompany()).RecId), _custVendTransOffset.TransDate);
                    interestAmountPaymentMst = currencyHelper.calculateTransactionToAccounting(_custVendTrans.CurrencyCode, _interestAmountCur, true);
                    interestAmountPaymentReporting = currencyHelper.calculateTransactionCurrencyToReportingCurrency(_custVendTrans.CurrencyCode, _interestAmountCur);

                    // calculate the interest amount in payment company currency
                    [interestAmountPaymentCur, interestAmountPaymentMst] = this.calcFinInterestOrFineForCreditCompany_BR(_interestAmountCur);

                    // set up transaction text for ledger transaction
                    paymentinterestText = TransactionTxt::construct(this.interestTxtLedger_BR(),
                                                                settlementPair.getCustVendTransCredit().languageId(),
                                                                settlementPair.getTransactionDate(),settlementPair.getCustVendTransCredit().Invoice,
                                                                settlementPair.getCustVendTransCredit().Voucher);

                    // set up ledger voucher for payment company
                    paymentLedgerVoucher = settlementPair.findLedgerVoucherByCompany(settlementPair.getCreditCompany());

                    // Get new voucher for interest transaction
                    numberSeqRef = settlementPair.numRefCustVendPaymVoucher();
                    numberSeq = NumberSeq::newGetVoucher(numberSeqRef);

                    ledgerVoucherObject = LedgerVoucherObject::newVoucher(numberSeq.voucher(),
                                                                         settlementPair.getTransactionDate(),
                                                                         this.parmModule(),
                                                                         this.ledgerTransactionType());
                    paymentLedgerVoucher.addVoucher(ledgerVoucherObject);

                    ledgerVoucherObject.lastTransTxt(paymentinterestText.txt());
                    ledgerVoucherObject.parmPaymentReference(settlementPair.getCustVendTransCredit().PaymReference);

                    // create ledger transaction for due to/from ledger account
                    ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(settlementPair.getCustVendTransCredit().summaryLedgerDimension());
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
                        ledgerVoucherObject,
                        this.postingTypeInterest_BR(),
                        ledgerDimensionMerged,
                        _custVendTrans.CurrencyCode,
                        -this.amount(_interestAmountCur),
                        -this.amount(interestAmountPaymentMst),
                        -this.amount(interestAmountPaymentReporting));

                    ledgerVoucherTransObject.parmSourceTableId(_custVendTransOffset.TableId);
                    ledgerVoucherTransObject.parmSourceRecId(_custVendTransOffset.RecId);
                    paymentLedgerVoucher.addTrans(ledgerVoucherTransObject);

                    paymentinterestLedgerDimension = this.interestLedgerDimensionCreditCompany_BR(_custVendTrans.AccountNum,
                                                                                          _custVendTrans.PostingProfile);

                    ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(paymentinterestLedgerDimension, _custVendTransOffset.DefaultDimension);

                    // create ledger transaction for interest ledger account
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
                        ledgerVoucherObject,
                        this.postingTypeInterest_BR(),
                        ledgerDimensionMerged,
                        _custVendTrans.CurrencyCode,
                        this.amount(_interestAmountCur),
                        this.amount(interestAmountPaymentMst),
                        this.amount(interestAmountPaymentReporting));

                    ledgerVoucherTransObject.parmSourceTableId(_custVendTransOffset.TableId);
                    ledgerVoucherTransObject.parmSourceRecId(_custVendTransOffset.RecId);
                    paymentLedgerVoucher.addTrans(ledgerVoucherTransObject);
                }
            }
        }

        return postLedgerToCreditCompany;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineLedgerTransTypeForPennyDiff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the proper <c>LedgerTransType</c> enumeration value for posting of a penny difference transaction.
    /// </summary>
    /// <param name = "_mstDiffMST">The penny difference amount in the accounting currency.</param>
    /// <returns>The proper <c>LedgerTransType</c> enumeration value for posting of a penny difference transaction.</returns>
    protected LedgerTransType determineLedgerTransTypeForPennyDiff(AmountMST _mstDiffMST)
    {
        LedgerTransType ledgerTransType;

        // if the difference amount in MST is less or equal the parameter's penny difference
        // amount this is considered a penny difference otherwise it will be an over under payment.
        if (abs(_mstDiffMST) <= this.maxMSTDiff())
        {
            ledgerTransType = LedgerTransType::PennyDifference;
        }
        // The MCRCallCenter config key is checked inside the mcrEnableOrderCompletion method
        else if (mcrOrderCompletionEnabled
              && mcrOOBReleaseType == MCROutOfBalanceReleaseType::WriteOff)
        {
            ledgerTransType = LedgerTransType::MCRUnderpayWriteOff;
        }
        else
        {
            ledgerTransType = LedgerTransType::OverUnder;
        }

        return ledgerTransType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPennyDiff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the penny difference transactions for the settlement.
    /// </summary>
    /// <param name="_mstDiffCur">
    /// The penny difference amount in the transaction currency.
    /// </param>
    /// <param name="_mstDiffMST">
    /// The penny difference amount in the accounting currency.
    /// </param>
    /// <param name="_mstDiffReporting">
    /// The penny difference amount in the reporting currency.
    /// </param>
    /// <param name="_custVendTrans">
    /// The CustVendTrans record used to create the penny difference transaction.
    /// </param>
    /// <param name="_distributionController">
    /// The <c>CustVendTransSettleDistController</c> instance associated with the <paramref name="_custVendTrans"/> record.
    /// </param>
    /// <param name="_taxAmountCur">
    /// The tax amount on the penny difference in the transaction currency.
    /// </param>
    /// <param name="_taxAmountMst">
    /// The tax amount on the penny difference in the accounting currency.
    /// </param>
    /// <param name="_taxAmountReporting">
    /// The tax amount on the penny difference in the reporting currency.
    /// </param>
    /// <param name="_defaultDimension">
    /// The dimension to use when creating penny difference transactions.
    /// </param>
    /// <param name="_custVendTransOffset">
    /// The CustVendTrans offset record.
    /// </param>
    /// <returns>
    /// The remaining tax amount.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Missing ledger account number for the cash discount amount.
    /// </exception>
    protected AmountMST postPennyDiff(
        DiscAmount          _mstDiffCur,
        AmountMST           _mstDiffMST,
        Money               _mstDiffReporting,
        CustVendTrans       _custVendTrans,
        CustVendTransSettleDistController _distributionController,
        TaxAmount           _taxAmountCur = 0,
        AmountMST           _taxAmountMst = 0,
        Money               _taxAmountReporting = 0,
        DimensionDefault    _defaultDimension    = _custVendTrans.DefaultDimension,
        CustVendTrans       _custVendTransOffset = _custVendTrans)
    {
        LedgerDimensionDefaultAccount   pageLedgerDimension;
        TaxAmount                       taxSettled;
        Money                           taxSettledReporting;
        AmountCur                       taxSettledCur;
        CustVendTrans                   mstDiffTrans  = _custVendTrans.data();
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        LedgerVoucher                   ledgerVoucher;
        LedgerVoucherObject             ledgerVoucherObject;
        TransactionTxt                  mstDiffText;
        LedgerDimensionAccount          ledgerDimensionMerged;
        List                            distributions;
        ListEnumerator                  distributionEnumerator;
        CustVendTransDistribution       distribution;
        // <GEERU><GEECZ>
        LedgerBondClient_RU             ledgerBondClient;
        // </GEECZ></GEERU>

        Debug::assert(_custVendTrans.company() == curext());

        ledgerVoucher = settlementPair.findLedgerVoucherByCompany(_custVendTrans.company());

        postingProfile = _custVendTrans.PostingProfile;

        LedgerTransType ledgerTransType = this.determineLedgerTransTypeForPennyDiff(_mstDiffMST);
        
        if (_taxAmountCur < 0)
        {
            if (_taxAmountCur < -_mstDiffCur)
            {
                taxSettledCur = -_mstDiffCur;
                taxSettled = -_mstDiffMST;
                taxSettledReporting = -_mstDiffReporting;
            }
            else
            {
                taxSettledCur = _taxAmountCur;
                taxSettled = _taxAmountMst;
                taxSettledReporting = _taxAmountReporting;
            }
        }
        else
        {
            if (_taxAmountCur > 0)
            {
                if (_taxAmountCur > -_mstDiffCur)
                {
                    taxSettledCur = -_mstDiffCur;
                    taxSettled = -_mstDiffMST;
                    taxSettledReporting = -_mstDiffReporting;
                }
                else
                {
                    taxSettledCur = _taxAmountCur;
                    taxSettled = _taxAmountMst;
                    taxSettledReporting = _taxAmountReporting;
                }
            }
        }

        mstDiffTrans.clear();

        // Need to set the text differently if it's an underpayment write off
        if (ledgerTransType == LedgerTransType::MCRUnderpayWriteOff)
        {
            mstDiffText = TransactionTxt::construct(LedgerTransTxt::MCRCustWriteOff,
                _custVendTrans.languageId(),
                settlementPair.getTransactionDate(),
                _custVendTrans.Invoice,
                _custVendTrans.Voucher);
        }
        else
        {
            mstDiffText = TransactionTxt::construct(this.pennyDiffTxt(),
                _custVendTrans.languageId(),
                settlementPair.getTransactionDate(),
                _custVendTrans.Invoice,
                _custVendTrans.Voucher);
        }

        mstDiffTrans.AccountNum             = _custVendTrans.AccountNum;
        mstDiffTrans.TransDate              = settlementPair.getTransactionDate();
        mstDiffTrans.Voucher                = ledgerVoucher.lastVoucher();
        mstDiffTrans.Approved               = NoYes::Yes;
        mstDiffTrans.Txt                    = mstDiffText.txt();
        mstDiffTrans.TransType              = ledgerTransType;
        mstDiffTrans.OffsetRecId            = _custVendTrans.RecId;

        mstDiffTrans.CurrencyCode           = _custVendTrans.CurrencyCode;
        mstDiffTrans.ExchRate               = _custVendTrans.exchRateCurToMst();
        mstDiffTrans.ReportingCurrencyExchRate = _custVendTrans.getReportingExchangeRate1();
        mstDiffTrans.ReportingCurrencyExchRateSecondary = _custVendTrans.getReportingExchangeRate2();
        mstDiffTrans.ReportingCurrencyCrossRate = _custVendTrans.getReportingCombinedExchangeRate();

        mstDiffTrans.AmountCur              = this.amount(_mstDiffCur + taxSettledCur);
        mstDiffTrans.AmountMST              = this.amount(_mstDiffMST + taxSettled);
        mstDiffTrans.ReportingCurrencyAmount = this.amount(_mstDiffReporting + taxSettledReporting);
        mstDiffTrans.SettleAmountCur        = mstDiffTrans.AmountCur;
        mstDiffTrans.SettleAmountMST        = mstDiffTrans.AmountMST;
        mstDiffTrans.SettleAmountReporting  = mstDiffTrans.ReportingCurrencyAmount;
        mstDiffTrans.LastSettleDate         = mstDiffTrans.TransDate;
        mstDiffTrans.LastSettleVoucher      = _custVendTrans.Voucher;
        mstDiffTrans.LastSettleAccountNum   = _custVendTrans.AccountNum;
        mstDiffTrans.LastSettleCompany      = _custVendTrans.DataAreaId;
        mstDiffTrans.Closed                 = settlementPair.getTransactionDate();
        mstDiffTrans.DefaultDimension       = _defaultDimension;

        mstDiffTrans.initFromPostingProfile(postingProfile);
        this.reverseAmounts(mstDiffTrans);

        custVendTransSettlement.addTransAndDefaultSettlement(mstDiffTrans, settlementGroupPlaceHolder);

        ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
        mstDiffText.setType(this.mstDiffTxtLedger());
        ledgerVoucherObject.lastTransTxt(mstDiffText.txt());
        // <GEERU>
        ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();
        if (ledgerBondClient)
        {
            ledgerBondClient.addNewLogObject();
        }
        // </GEERU>

        ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(mstDiffTrans.summaryLedgerDimension(), _defaultDimension);

        distributions = _distributionController.generateDistributions(
            _custVendTrans,
            this.getLedgerPostingType_Balance(),
            mstDiffTrans.AmountCur,
            mstDiffTrans.AmountMST,
            mstDiffTrans.ReportingCurrencyAmount,
            ledgerDimensionMerged,
            false);

        distributionEnumerator = distributions.getEnumerator();
        while (distributionEnumerator.moveNext())
        {
            distribution = distributionEnumerator.current();

            ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(ledgerVoucherObject,
                LedgerPostingType::MSTDiff,
                distribution.ledgerDimension(),
                _custVendTrans.CurrencyCode,
                distribution.transactionAmount(),
                distribution.accountingAmount(),
                distribution.reportingAmount());

            ledgerVoucherTransObject.parmSourceTableId(mstDiffTrans.TableId);
            ledgerVoucherTransObject.parmSourceRecId(mstDiffTrans.RecId);
            ledgerVoucherTransObject.parmSkipDimensionValidation(true);

            ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }

        if (ledgerTransType == LedgerTransType::PennyDifference)
        {
            pageLedgerDimension = LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::MSTDiff);
        }
        else if (ledgerTransType == LedgerTransType::MCRUnderpayWriteOff)
        {
            pageLedgerDimension = LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::MCRUnderpayWriteOff);
        }
        else
        {
            pageLedgerDimension = SettlementUtility::cashDiscountSystemLedgerDimension(this.parmModule());

            if (!pageLedgerDimension)
            {
                throw error(strFmt("@SYS24816", this.getLedgerPostingType_CashDisc()));
            }
        }

        DimensionDefault custVendDefaultDimension = CustVendTable::getDefaultDimension(this.moduleCustVend(), mstDiffTrans.AccountNum);

        DimensionDefault mainAccountDefaultDimension = MainAccountLegalEntity::findByMainAccountLegalEntity(
            LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(pageLedgerDimension),
            CompanyInfo::current()).DefaultDimension;

        ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(
            pageLedgerDimension,
            _defaultDimension,
            custVendDefaultDimension,
            mainAccountDefaultDimension);

        DimensionDefault mergedDefaultDimension = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(ledgerDimensionMerged);

        if (mstDiffTrans.AmountMST || mstDiffTrans.AmountCur || mstDiffTrans.ReportingCurrencyAmount || taxSettled)
        {
            CustVendTrans custVendTransOffset;
            custVendTransOffset = this.initCustVendTransBuffer();

            CustVendSettlement settlementOffset = custVendTransSettlement.findSettlementForCustVendTrans(_custVendTrans, settlementGroupPlaceHolder, _custVendTrans.OffsetRecId);
            custVendTransOffset = this.findCustVendTransByRecID(settlementOffset.OffsetRecId, custVendTransOffset);

            if (ledgerTransType == LedgerTransType::PennyDifference
                || ledgerTransType == LedgerTransType::MCRUnderpayWriteOff)
            {
                ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
                    ledgerVoucherObject,
                    ledgerTransType == LedgerTransType::PennyDifference
                        ? LedgerPostingType::MSTDiff // Penny difference posting
                        : LedgerPostingType::MCRUnderpayWriteOff, // Over-under payment posting
                    ledgerDimensionMerged,
                    _custVendTrans.CurrencyCode,
                    -(mstDiffTrans.AmountCur),
                    -(mstDiffTrans.AmountMST),
                    -(mstDiffTrans.ReportingCurrencyAmount));
                ledgerVoucherTransObject.parmSourceTableId(mstDiffTrans.TableId);
                ledgerVoucherTransObject.parmSourceRecId(mstDiffTrans.RecId);

                ledgerVoucher.addTrans(ledgerVoucherTransObject);

                if (!_custVendTrans.Invoice
                    && ((_custVendTrans.TableId == tableNum(CustTrans) && _custVendTrans.AmountCur > 0)
                    || (_custVendTrans.TableId == tableNum(VendTrans) && _custVendTrans.AmountCur < 0)))
                {
                    bankChequePaymTransCache.updateBankChequePaymTrans(
                    custVendTransOffset.RecId,
                    _custVendTrans.RecId,
                    _mstDiffCur,
                    0);
                }
            }
            else
            {
                this.postPennyDiffOnCashDisc(ledgerVoucher,
                    (mstDiffTrans.AmountCur),
                    _custVendTrans,
                    ledgerTransType,
                    mergedDefaultDimension,
                    pageLedgerDimension,
                    (mstDiffTrans.AmountMST),
                    (mstDiffTrans.ReportingCurrencyAmount));

                if (_custVendTrans.Invoice
                    || (_custVendTrans.TableId == tableNum(CustTrans) && _custVendTrans.AmountCur < 0)
                    || (_custVendTrans.TableId == tableNum(VendTrans) && _custVendTrans.AmountCur > 0))
                {
                    // transfer the amount from invoice to payment
                    CurrencyExchangeHelper currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::current()), settlementPair.getTransactionDate());
                    AmountMST diffCur = currencyHelper.calculateCurrencyToCurrency(_custVendTrans.CurrencyCode, custVendTransOffset.CurrencyCode, _mstDiffCur, true);

                    CashDiscAmount diffPayment = _mstDiffCur;
                    bankChequePaymTransCache.updateBankChequePaymTrans(
                        _custVendTrans.RecId,
                        custVendTransOffset.RecId,
                        0,
                        diffCur);
                }
                else
                {
                    bankChequePaymTransCache.updateBankChequePaymTrans(
                        custVendTransOffset.RecId,
                        _custVendTrans.RecId,
                        _mstDiffCur,
                        _mstDiffCur);
                }
            }
        }
        // <GEEU>
        if (CustVendTransPostingLog_RU::usePostingLog())
        {
            if (ledgerBondClient)
            {
                ledgerBondClient.bondLog2Log();
                ledgerBondClient.removeCurrentLogObject();
            }

            distributionEnumerator.reset();
            while (distributionEnumerator.moveNext())
            {
                distribution = distributionEnumerator.current();

                this.createPostingTransLog_RU(CustVendTransPostingLogType_RU::PennyDifference,
                    mstDiffTrans,
                    LedgerPostingType::MSTDiff,
                    distribution.ledgerDimension(),
                    pageLedgerDimension,
                    distribution.accountingAmount(),
                    distribution.reportingAmount(),
                    null,
                    mstDiffTrans.DefaultDimension,
                    distribution.transactionAmount(),
                    _custVendTrans,
                    _custVendTransOffset);
            }
        }
        // </GEEU>

        return taxSettled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldPostPennyDiffOnCashDisc</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if penny difference transactions for the cash discount should be posted.
    /// </summary>
    /// <returns>
    ///     true if penny difference transactions for the cash discount should be posted; otherwise, false.
    /// </returns>
    protected boolean shouldPostPennyDiffOnCashDisc()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPennyDiffOnCashDisc</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates the penny difference transactions for the cash discount.
    /// </summary>
    /// <param name = "_ledgerVoucher">
    ///     The <c>LedgerVoucher</c> object used to create penny difference transactions.
    /// </param>
    /// <param name = "_totalAmountCur">
    ///     The total amount on the penny difference in the transaction currency.
    /// </param>
    /// <param name = "_custVendTrans">
    ///     The <c>CustVendTrans</c> record used to create the penny difference transaction.
    /// </param>
    /// <param name = "_ledgerTransType">
    ///     The transaction type used to create penny difference transactions.
    /// </param>
    /// <param name = "_defaultDimension">
    ///     The dimension to use when creating penny difference transactions.
    /// </param>
    /// <param name = "_pennyDiffLedgerDimension">
    ///     The main account to use when creating penny difference transactions.
    /// </param>
    /// <param name = "_totalAmountMst">
    ///     The total amount on the penny difference in the accounting currency.
    /// </param>
    /// <param name = "_totalAmountReporting">
    ///     The total amount on the penny difference in the reporting currency.
    /// </param>

    void postPennyDiffOnCashDisc(LedgerVoucher                  _ledgerVoucher,
                                 AmountCur                      _totalAmountCur,
                                 CustVendTrans                  _custVendTrans,
                                 LedgerTransType                _ledgerTransType,
                                 DimensionDefault               _defaultDimension,
                                 LedgerDimensionDefaultAccount  _pennyDiffLedgerDimension,
                                 AmountMST                      _totalAmountMst,
                                 AmountMSTSecondary             _totalAmountReporting)
    {
        int idx = conLen(conLedgerAccount);
        LedgerDimensionDefaultAccount ledgerDimension;
        AmountCur remainAmountCur = -_totalAmountCur;
        AmountMST remainAmountMst;
        AmountMSTSecondary remainAmountReporting;
        AmountCur amountCur;
        LedgerVoucherTransObject ledgerVoucherTransObject;
        LedgerDimensionAccount ledgerDimensionMerged;
        LedgerVoucherObject ledgerVoucherObject;
        CurrencyExchangeHelper currencyHelper;

        if(this.shouldPostPennyDiffOnCashDisc())
        {
            if (idx)
            {
                int idxMax = idx;

                while (idx != 0)
                {
                    // if cash discount tax has been posted we can find the account here
                    ledgerDimension = conPeek(conLedgerAccount, idx);
                    if (idx == idxMax)
                    {
                        amountCur    = remainAmountCur;
                    }
                    else
                    {
                        amountCur    = conPeek(conTaxBaseAmountCur, idx);
                    }
                    // if no tax was posted we can find the account here
                    if (!ledgerDimension)
                    {
                        ledgerDimension = _pennyDiffLedgerDimension;
                    }
                    idx--;
                    remainAmountCur  -= amountCur;

                    ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();

                    currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), _custVendTrans.TransDate);
                    currencyHelper.parmExchangeRate1(_custVendTrans.exchRateCurToMst());
                    _custVendTrans.setExchangeHelperReportingExchRate(currencyHelper);

                    remainAmountMst = currencyHelper.calculateTransactionToAccounting(_custVendTrans.CurrencyCode, amountCur, true);
                    remainAmountReporting = currencyHelper.calculateTransactionCurrencyToReportingCurrency(_custVendTrans.CurrencyCode, amountCur);

                    ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimension, _defaultDimension);
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
                                                ledgerVoucherObject,
                                                LedgerPostingType::MSTDiff,
                                                ledgerDimensionMerged,
                                                _custVendTrans.CurrencyCode,    // should this be CompanyInfo::standardCurrency()?
                                                amountCur,
                                                remainAmountMst,
                                                remainAmountReporting);

                    ledgerVoucherTransObject.parmSourceTableId(_custVendTrans.TableId);
                    ledgerVoucherTransObject.parmSourceRecId(_custVendTrans.RecId);
                    ledgerVoucherTransObject.parmSkipDimensionValidation(true);
                    _ledgerVoucher.addTrans(ledgerVoucherTransObject);
                }
            }
            if (remainAmountCur)
            {
                if (!ledgerDimension)
                {
                    ledgerDimension = _pennyDiffLedgerDimension;
                }

                if (remainAmountCur == -_totalAmountCur)
                {
                    // since the remaining amount in transaction currency is the same as the amount passed in, can
                    // use the passed in values for the accounting and reporting currency amount.  This will avoid
                    // currency conversion rounding differences.
                    remainAmountMst = -_totalAmountMst;
                    remainAmountReporting = -_totalAmountReporting;
                }
                else
                {
                    ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
                    currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), _custVendTrans.TransDate);
                    currencyHelper.parmExchangeRate1(_custVendTrans.exchRateCurToMst());
                    _custVendTrans.setExchangeHelperReportingExchRate(currencyHelper);

                    remainAmountMst = currencyHelper.calculateTransactionToAccounting(_custVendTrans.CurrencyCode, remainAmountCur, true);
                    remainAmountReporting = currencyHelper.calculateTransactionCurrencyToReportingCurrency(_custVendTrans.CurrencyCode, remainAmountCur);
                }

                ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimension, _defaultDimension);
                ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
                                            ledgerVoucherObject,
                                            this.getLedgerPostingType_CashDisc(),
                                            ledgerDimensionMerged,
                                            _custVendTrans.CurrencyCode,
                                            remainAmountCur,
                                            remainAmountMst,
                                            remainAmountReporting);

                ledgerVoucherTransObject.parmTaxParentReferenceTableId(_custVendTrans.TableId);
                ledgerVoucherTransObject.parmTaxParentReferenceRecId(_custVendTrans.RecId);
                ledgerVoucherTransObject.parmSkipDimensionValidation(true);
                _ledgerVoucher.addTrans(ledgerVoucherTransObject);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postServiceTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Postss service tax information.
    /// </summary>
    /// <param name="_currentSettleFactor">
    /// The current settle factor.
    /// </param>
    /// <param name="_origSettleFactor">
    /// The original settle factor.
    /// </param>
    /// <param name="_custVendTrans">
    /// The cust vend trans.
    /// </param>
    /// <param name="_offsetCustVendTrans">
    /// The offset of cust vend trans.
    /// </param>
    /// <param name="_cashDiscAmountCur">
    /// The current cash disc amount.
    /// </param>
    /// <param name="_ledgerJournalType">
    /// The ledger journal type.
    /// </param>
    /// <param name="_sourceRecid">
    /// The source rec Id.
    /// </param>
    /// <param name="_tableId">
    /// The table id.
    /// </param>
    protected void postServiceTax_IN(
        Percent             _currentSettleFactor,
        Percent             _origSettleFactor,
        CustVendTrans       _custVendTrans,
        CustVendTrans       _offsetCustVendTrans,
        DiscAmount          _cashDiscAmountCur,
        LedgerJournalType   _ledgerJournalType = LedgerJournalType::Daily,
        RefRecId            _sourceRecid = 0,
        TableId             _tableId = 0)
    {
        TaxTrans            taxTransInvoiced;
        TaxItemGroupHeading taxItemGroup;
        boolean             createSettlementVoucher;
        boolean             isPOT;
        boolean             isRecoverableCheckBoxUnMarked;
        LedgerJournalTrans  ledgerJournalTransService;
        ServiceTaxServiceCodeSelection_IN   serviceTaxServiceCodeSelection;

        if (_currentSettleFactor != _origSettleFactor)
        {
            //Update service code to the transaction during settlement, if there are different service code on payment and invoice
            serviceTaxServiceCodeSelection = ServiceTaxServiceCodeSelection_IN::construct(_tableId, _sourceRecid, _custVendTrans, _offsetCustVendTrans);
            if (serviceTaxServiceCodeSelection)
            {
                serviceTaxServiceCodeSelection.processServiceCode();
            }

            // After posting an invoice with service tax, if its fetched from opentransaction (Functions>settlemnt)
            // For POT, the related voucher shud not be created. The original logic for cash basis, where it shud create related voucher; is being reused
            // for POT with added check to block related voucher, below. tableid= 212 here means its payment with Functions>settlemnt.
            // This is blocked only for invoice amount >= payment amount. For advance amount, related voucher is created for difference amount.
            select firstonly RecId from taxTransInvoiced
               where taxTransInvoiced.Voucher == settlementPair.getCustVendTransDebit().Voucher
                 join RecId, ReverseChargePercentage_IN from taxItemGroup
                    where taxItemGroup.TaxItemGroup == taxTransInvoiced.TaxItemGroup
                       && taxItemGroup.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis;
            isPOT = (taxTransInvoiced.RecId != 0);

            if (isPOT && taxItemGroup.ReverseChargePercentage_IN != 0)
            {
                //Set isPOT to true, when PI scenario(Payment first and invoice second). because related vouchers should not be there for invoice journals.
                //If isPOT is set to true, createSettlementVoucher will be false and taxSettlement_IN method is not called.
                ledgerJournalTransService = LedgerJournalTrans::find(this.findLedgerJournalNum(settlementPair.getSpecTransDebit()), settlementPair.getSpecTransDebit().vendTrans().Voucher, false);

                isPOT = (ledgerJournalTransService.Voucher == _custVendTrans.Voucher) ? true
                                                                                      : false;
            }

            // Check if the recoverable/Expense on the tax settlement checkbox is unmarked.
            // and the ItemTaxGroup is of POT and reverseCharge percentage is defined on the itemTaxGroup.
            isRecoverableCheckBoxUnMarked = TaxItemGroupHeading::isRecoverableExpChkBoxUnMarked_IN(settlementPair.getSpecTransCredit().getSpecSourceTableId(), settlementPair.getSpecTransCredit().getSpecSourceRecId());

            // If tax is not attached to payment & pot Basis tax Item Group is attached to invoice no need of tax transactions creation at the time of manual settlemt.
            // _tableId = PurchTable/SalesTable/CustInvoiceTable when direct settlemnt is done from respective orders. No Voucher here.But FTI correction is an exception case.
            // _tableId = LedgerJournalTrans comes for direct settlemnt from payment. Here For POT, no voucher irrespective of payment has tax or not.
            // For 3-way settlemnt for POT, if payment time Tax is there, then create voucher. No tax here, no Voucher.
            createSettlementVoucher = !(
                                            // Create the settlementVoucher during invoice posting when payment is attached and Recoverable/Expense on tax settlement checkbox is unmarked.
                                            ((_tableId == tableNum(PurchTable) && !isRecoverableCheckBoxUnMarked &&
                                                ((_offsetCustVendTrans.RecId && TaxSettlement_IN::isTaxPostedDuringPayment(_offsetCustVendTrans.Voucher, _offsetCustVendTrans.TransDate)) || !_offsetCustVendTrans.RecId)))// Voucher creation direct settlemnt from PO
                                                ||
                                            (_tableId == tableNum(SalesTable))// Voucher creation direct settlemnt from SO
                                                ||
                                            (_tableId == tableNum(CustInvoiceTable) && !CustInvoiceTable::findRecId(settlementPair.getSpecTransDebit().getSpecSourceRecId()).CorrectionReasonCode) // Voucher creation direct settlemnt from FTI
                                                ||
                                            (_tableId == tableNum(LedgerJournalTrans) &&
                                                (isPOT || (TaxSettlement_IN::isTaxPostedDuringPayment(_offsetCustVendTrans.Voucher, _offsetCustVendTrans.TransDate) && _offsetCustVendTrans.Prepayment)))
                                                // Voucher creation during direct settlement for POT with extra check of prepayment transaction.
                                                ||
                                            (
                                                (TaxSettlement_IN::isTaxPostedDuringPayment(_offsetCustVendTrans.Voucher, _offsetCustVendTrans.TransDate) == false) && isPOT// No PaymentTax & POT
                                            )// Create Tax voucher during POT 3-way settlemnt [ie, Invoice posted & payment posted. Both are linked for settlemnt] only if Tax is attached to the payment.
                                       );
            if (TaxSettlement_IN::serviceTax(_custVendTrans,_ledgerJournalType,_sourceRecid))
            {
                if (createSettlementVoucher)
                {
                    this.taxSettlement_IN(_custVendTrans,
                                          _offsetCustVendTrans,
                                          _cashDiscAmountCur,
                                          (_currentSettleFactor - _origSettleFactor) * 100,
                                          _tableId);
                }
            }
            if (TaxSettlement_IN::serviceTax(_offsetCustVendTrans,_ledgerJournalType,_sourceRecid))
            {
                if (createSettlementVoucher)
                {
                    this.taxSettlement_IN(_offsetCustVendTrans,
                                          _custVendTrans,
                                          _cashDiscAmountCur,
                                          (_currentSettleFactor - _origSettleFactor) * 100,
                                          _tableId);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxOverUnderPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the tax for an over or under payment.
    /// </summary>
    /// <param name="_taxAmountCur">
    /// The amount of the tax on over payment in the transaction currency.
    /// </param>
    /// <param name="_taxAmountMst">
    /// The amount of the tax on the over payment in the accounting currency.
    /// </param>
    /// <param name="_taxAmountReporting">
    /// The amount of the tax on the over payment in the reporting currency.
    /// </param>
    /// <param name="_overPaymTrans">
    /// The CustVendTrans record with the over payment.
    /// </param>
    /// <param name="_overPaymTransDistributionController">
    /// The <c>CustVendTransSettleDistController</c> instance associated with the <paramref name="_overPaymTrans"/> record.
    /// </param>
    /// <param name="_invoiceTrans">
    /// The CustVendTrans record with the tax that is being adjusted.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The LedgerVoucher object used to create ledger transactions.
    /// </param>
    /// <param name="_settlementGroupPlaceHolder">
    /// The settlement group of the transaction.
    /// </param>
    /// <remarks>
    /// Creates CustVendTrans record and CustVendSettlement record in the company of the over payment.
    /// Updates the settled amount and penny difference on the payment settlement record.
    /// Also post to the general journal for the AP or AR summary account.
    /// </remarks>
    protected void postTaxOverUnderPayment(
        AmountCur _taxAmountCur,
        AmountMST _taxAmountMst,
        AmountMSTSecondary _taxAmountReporting,
        CustVendTrans _overPaymTrans,
        CustVendTransSettleDistController _overPaymTransDistributionController,
        CustVendTrans _invoiceTrans,
        LedgerVoucher _ledgerVoucher,
        Counter _settlementGroupPlaceHolder)
    {
        CustVendTrans   mstDiffTrans  = _overPaymTrans.data();
        LedgerTransType ledgerTransType;
        LedgerVoucherTransObject ledgerVoucherTransObject;
        LedgerVoucherObject ledgerVoucherObject;
        TransactionTxt      mstDiffText;
        CustVendSettlement settlementToUpdate;
        LedgerDimensionAccount  ledgerDimensionMerged;
        List                    distributions;
        ListEnumerator          distributionEnumerator;
        CustVendTransDistribution distribution;

        Debug::assert(_overPaymTrans.company() == curext());

        postingProfile = _overPaymTrans.PostingProfile;
        ledgerTransType = LedgerTransType::OverUnder;

        // create custVendTrans record for the tax on over payment
        mstDiffTrans.clear();

        mstDiffText = TransactionTxt::construct(this.pennyDiffTxt(),
                                      _overPaymTrans.languageId(),
                                      settlementPair.getTransactionDate(),
                                      _overPaymTrans.Invoice,
                                      _overPaymTrans.Voucher);

        mstDiffTrans.AccountNum         = _overPaymTrans.AccountNum;
        mstDiffTrans.TransDate          = settlementPair.getTransactionDate();
        mstDiffTrans.Voucher            = _ledgerVoucher.lastVoucher();
        mstDiffTrans.Approved           = NoYes::Yes;
        mstDiffTrans.Txt                = mstDiffText.txt();
        mstDiffTrans.TransType          = ledgerTransType;
        mstDiffTrans.OffsetRecId        = _overPaymTrans.RecId;

        mstDiffTrans.CurrencyCode       = _overPaymTrans.CurrencyCode;
        mstDiffTrans.ExchRate           = _overPaymTrans.ExchRate;
        mstDiffTrans.ExchRateSecond     = _overPaymTrans.ExchRateSecond;
        mstDiffTrans.ReportingCurrencyExchRate = _overPaymTrans.ReportingCurrencyExchRate;
        mstDiffTrans.ReportingCurrencyExchRateSecondary = _overPaymTrans.ReportingCurrencyExchRateSecondary;
        mstDiffTrans.ReportingCurrencyCrossRate = _overPaymTrans.ReportingCurrencyCrossRate;

        mstDiffTrans.AmountCur          = this.amount(_taxAmountCur);
        mstDiffTrans.AmountMST          = this.amount(_taxAmountMst);
        mstDiffTrans.ReportingCurrencyAmount = this.amount(_taxAmountReporting);
        mstDiffTrans.SettleAmountCur    = mstDiffTrans.AmountCur;
        mstDiffTrans.SettleAmountMST    = mstDiffTrans.AmountMST;
        mstDiffTrans.SettleAmountReporting = mstDiffTrans.ReportingCurrencyAmount;

        mstDiffTrans.LastSettleDate         = mstDiffTrans.TransDate;
        mstDiffTrans.LastSettleVoucher      = _overPaymTrans.Voucher;
        mstDiffTrans.LastSettleAccountNum   = _overPaymTrans.AccountNum;
        mstDiffTrans.LastSettleCompany      = _overPaymTrans.DataAreaId;

        mstDiffTrans.Closed = settlementPair.getTransactionDate();

        mstDiffTrans.DefaultDimension = _overPaymTrans.DefaultDimension;

        mstDiffTrans.initFromPostingProfile(postingProfile);
        this.reverseAmounts(mstDiffTrans);

        // create the trans and related settlement record
        custVendTransSettlement.addTransAndDefaultSettlement(mstDiffTrans, _settlementGroupPlaceHolder);

        // update the settlement record with voucher number if not already set
        settlementToUpdate = custVendTransSettlement.findSettlementForCustVendTrans(_invoiceTrans, _settlementGroupPlaceHolder, _overPaymTrans.RecId);
        if (settlementToUpdate.TransRecId != 0)
        {
            if (settlementToUpdate.SettlementVoucher == '')
            {
                settlementToUpdate.SettlementVoucher = settlementPair.findVoucherNumberByCompany(curext());
                custVendTransSettlement.modifyTransAndSettlement(_invoiceTrans, settlementToUpdate, _settlementGroupPlaceHolder, _overPaymTrans.RecId, false, true);
            }
        }

        // update offset settlement record (this is the settlement for the payment)
        settlementToUpdate = custVendTransSettlement.findSettlementForCustVendTrans(_overPaymTrans, _settlementGroupPlaceHolder, _invoiceTrans.RecId);
        if (settlementToUpdate.TransRecId != 0)
        {
            if (settlementToUpdate.SettlementVoucher == '')
            {
                settlementToUpdate.SettlementVoucher = settlementPair.findVoucherNumberByCompany(curext());
            }
            settlementToUpdate.PennyDiff += _taxAmountCur;
            settlementToUpdate.SettleAmountCur += -_taxAmountCur;
            settlementToUpdate.SettleAmountMST += -_taxAmountMst;
            settlementToUpdate.SettleAmountReporting += -_taxAmountReporting;
            custVendTransSettlement.modifyTransAndSettlement(_overPaymTrans, settlementToUpdate, _settlementGroupPlaceHolder, _invoiceTrans.RecId, false, true);
        }

        ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
        mstDiffText.setType(this.mstDiffTxtLedger());
        ledgerVoucherObject.lastTransTxt(mstDiffText.txt());

        // Payment and invoice in same company so adjust the payment transaction AR or AP account

        ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(_overPaymTrans.summaryLedgerDimension(), _overPaymTrans.DefaultDimension);

        distributions = _overPaymTransDistributionController.generateDistributions(
            _overPaymTrans,
            this.getLedgerPostingType_Balance(),
            _taxAmountCur,
            _taxAmountMst,
            _taxAmountReporting,
            ledgerDimensionMerged,
            false);

        distributionEnumerator = distributions.getEnumerator();
        while (distributionEnumerator.moveNext())
        {
            distribution = distributionEnumerator.current();

            ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(ledgerVoucherObject,
                LedgerPostingType::MSTDiff,
                distribution.ledgerDimension(),
                _overPaymTrans.CurrencyCode,
                distribution.transactionAmount(),
                distribution.accountingAmount(),
                distribution.reportingAmount());

            ledgerVoucherTransObject.parmSourceTableId(_overPaymTrans.TableId);
            ledgerVoucherTransObject.parmSourceRecId(_overPaymTrans.RecId);
            _ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxToInvoiceCompany_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post the calculated tax to the invoice company.
    /// </summary>
    /// <param name="_ledgerVoucherTransObject">
    /// A <c>LedgerVoucherTransObject</c> object.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// A <c>LedgerVoucher</c> object.
    /// </param>
    /// <param name="_interCompanyTrans">
    /// The transaction record.
    /// </param>
    /// <param name="_dueToFromAccount">
    /// The due from account number.
    /// </param>
    /// <returns>
    /// A <c>LedgerVoucher</c> object.
    /// </returns>
    protected LedgerVoucher postTaxToInvoiceCompany_IN(LedgerVoucherTransObject                 _ledgerVoucherTransObject,
                                                       LedgerVoucher                            _ledgerVoucher,
                                                       CustVendTrans                            _interCompanyTrans,
                                                       LedgerDimensionDefaultAccount            _dueToFromAccount)
    {
        LedgerJournalTable              ledgerJournalTableLoc;
        LedgerJournalTrans              ledgerJournalTransLoc;
        LedgerPostingController         ledgerPostingController;
        TaxVoucherService               taxVoucherService;
        TaxWithholdAmountCur            taxWithholdAmountCur;
        JournalId                       intercompanyJournalNum;

        if (settlementPair.getDebitCompany() != settlementPair.getCreditCompany())
        {
            changecompany(_interCompanyTrans.company())
            {
                // check if the interCompanyTrans withhold tax posted or not
                select firstonly crossCompany JournalNum from  ledgerJournalTransLoc
                    where ledgerJournalTransLoc.Voucher == _interCompanyTrans.LastSettleVoucher;

                intercompanyJournalNum = ledgerJournalTransLoc.JournalNum;

                if (intercompanyJournalNum)
                {
                    // get ledger journal table journal num;
                    select firstonly crossCompany ledgerJournalTableLoc
                        where ledgerJournalTableLoc.JournalNum == intercompanyJournalNum;

                    if (ledgerJournalTableLoc)
                    {
                        taxVoucherService = TaxVoucherService::construct(ledgerJournalTableLoc);

                        ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(_ledgerVoucher);
                        taxVoucherService.parmLoggedInCompany_IN(settlementPair.getDebitCompany());
                        taxWithholdAmountCur = taxVoucherService.postWithholdIntercompany_IN(
                            ledgerPostingController,
                            intercompanyJournalNum,
                            _ledgerVoucher.lastVoucher(),
                            settlementPair.getCreditCompany(),
                            _interCompanyTrans.RecId,
                            _interCompanyTrans.LastSettleVoucher);

                        if (taxWithholdAmountCur)
                        {
                            _ledgerVoucher.parmPostedInterCompanyWHT_IN(taxWithholdAmountCur);
                            relatedLedgerVoucher.updateWHTInvoiceCompanyToCache_IN(
                                _interCompanyTrans.company(),
                                _interCompanyTrans.LastSettleVoucher,
                                taxWithholdAmountCur);
                        }
                    }
                }
            }
        }

        return _ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postVATTransForTaxAgent_RU</Name>
				<Source><![CDATA[
    private void postVATTransForTaxAgent_RU(
        AmountMST           _settleAmountAccounting,
        AmountCur           _settleAmountTransaction,
        AmountMSTSecondary  _settleAmountReporting,
        CustVendTrans       _custVendTransPayment)
    {
        VendSettleVATTransForTaxAgent_RU    vatTrans;
        LedgerVoucherObject                 ledgerVoucherObject;
        LedgerVoucher                       ledgerVoucher;

        AmountCur                           settleAmountTransaction = _custVendTransPayment.Prepayment ? _settleAmountTransaction - taxAgentPaymentAmountTransaction : _settleAmountTransaction;
        AmountMST                           settleAmountAccounting  = _custVendTransPayment.Prepayment ? _settleAmountAccounting  - taxAgentPaymentAmountAccounting  : _settleAmountAccounting;
        AmountMSTSecondary                  settleAmountReporting   = _custVendTransPayment.Prepayment ? _settleAmountReporting   - taxAgentPaymentAmountReporting   : _settleAmountReporting;

        if (_custVendTransPayment.TableId == tableNum(VendTrans) &&
            VendTable::find(_custVendTransPayment.AccountNum).vatTaxAgent_RU &&
            _custVendTransPayment.TransType == LedgerTransType::Payment)
        {
            ledgerVoucher = settlementPair.findLedgerVoucherByCompany(_custVendTransPayment.company());
            ledgerVoucherObject = this.createLedgerVoucherObject_RU(ledgerVoucher);
            vatTrans = VendSettleVATTransForTaxAgent_RU::construct();
            vatTrans.initFromSettlement(this, ledgerVoucherObject, ledgerVoucher);
            vatTrans.calcAndPostTaxes(settleAmountTransaction, settleAmountAccounting, settleAmountReporting);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postVATTransit_RU</Name>
				<Source><![CDATA[
    protected Voucher postVATTransit_RU(
        AmountMST           _settleAmountAccounting,
        AmountCur           _settleAmountTransaction,
        AmountMSTSecondary  _settleAmountReporting,
        CustVendTrans       _custVendTrans,
        NoYes               _correction = NoYes::No)
    {
        LedgerVoucherObject         ledgerVoucherObject;
        CustVendSettleVATTransit_RU vatTransit;
        LedgerVoucher               ledgerVoucher;

        ledgerVoucher = settlementPair.findLedgerVoucherByCompany(_custVendTrans.company());

        ledgerVoucherObject = this.createLedgerVoucherObject_RU(ledgerVoucher);
        ledgerVoucherObject.parmCorrection(_correction);

        vatTransit = CustVendSettleVATTransit_RU::newFromTrans(_custVendTrans);
        vatTransit.initFromSettlement(_custVendTrans,
                                      ledgerVoucherObject,
                                      _settleAmountAccounting,
                                      _settleAmountTransaction,
                                      _settleAmountReporting,
                                      this);

        vatTransit.calcAndPostTaxes();
        return ledgerVoucherObject.parmVoucher();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postVATTransitAmountDiff_RU</Name>
				<Source><![CDATA[
    public void postVATTransitAmountDiff_RU(CustVendTrans   _custVendTrans,
                                            boolean         _useSourceRecId  = true,
                                            LedgerVoucher   _ledgerVoucher   = null)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>processConditionalTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the conditional tax must be calculated on the settlement transactions.
    /// </summary>
    /// <param name="_origSettleFactorDebit">
    ///    The percent of the debit transaction that is settled excluding the current settlement.
    /// </param>
    /// <param name="_origSettleFactorCredit">
    ///    The percent of the credit transaction that is settled excluding the current settlement.
    /// </param>
    /// <param name="_cashDiscAmountCurDebit">
    ///    The cash discount amount for the debit transactions in the transaction currency.
    /// </param>
    /// <param name="_cashDiscAmountCurCredit">
    ///    The cash discount amount for the credit transactions in the transaction currency.
    /// </param>
    protected void processConditionalTax(
        Percent _origSettleFactorDebit,
        Percent _origSettleFactorCredit,
        DiscAmount _cashDiscAmountCurDebit,
        DiscAmount _cashDiscAmountCurCredit)
    {
        CustBillOfExchangeInvoice boeInvoice;
        VendPromissoryNoteInvoice pnInvoice;
        CustTrans custTransBoeInvoice;
        VendTrans vendTransPnInvoice;
        Percent currentSettleFactor;
        CustVendTrans custVendTransTaxDebit;
        VendRemitInvoiceRef_ES vendRemitInvoiceRef;
        PaymMethod paymMethod;
        CustTrans custTransPaym;
        boolean  postConditionalTax = true;

        changecompany(settlementPair.getDebitCompany())
        {
            if (TaxParameters::find().ConditionalTax)
            {
                // Debit company has conditional tax parameter
                switch (LedgerJournalTable::find(this.findLedgerJournalNum(settlementPair.getSpecTransDebit())).JournalType)
                {
                    case LedgerJournalType::CustBillOfExchangeDraw,
                         LedgerJournalType::CustBillOfExchangeProtest,
                         LedgerJournalType::CustBillOfExchangeRedraw,
                         LedgerJournalType::CustPaymRemittance,
                         LedgerJournalType::VendPromissoryNoteDraw,
                         LedgerJournalType::VendPromissoryNoteRedraw,
                         LedgerJournalType::VendPaymRemittance :
                        break;
                    case LedgerJournalType::CustBillOfExchangeSettle :
                        while select boeInvoice
                        where boeInvoice.BillOfExchangeId == settlementPair.getCustVendTransDebit().NegInstId
                        {
                            changecompany(boeInvoice.InvoiceCompany)
                            {
                                custTransBoeInvoice = CustTrans::findVoucherDate(boeInvoice.InvoiceVoucher, boeInvoice.InvoiceDate);
                            }
                            currentSettleFactor = boeInvoice.settleFactor(settlementPair.getCustVendTransDebit().NegInstId,
                                                                        -custTransBoeInvoice.AmountCur,
                                                                        custTransBoeInvoice.Voucher,
                                                                        custTransBoeInvoice.company(),
                                                                        custTransBoeInvoice.CurrencyCode);

                            this.postConditionalTax(
                                currentSettleFactor,
                                _origSettleFactorDebit,
                                custTransBoeInvoice,
                                settlementPair.getCustVendTransCredit(),
                                _cashDiscAmountCurDebit,
                                settlementPair.getExchRate().getDebitCurToDebitMstCombined(),
                                settlementPair.getExchRate().getDebitCurToReporting());
                        }
                        break;
                    case LedgerJournalType::VendPromissoryNoteSettle :
                        while select pnInvoice
                        where pnInvoice.PromissoryNoteId == settlementPair.getCustVendTransDebit().NegInstId
                        {
                            changecompany(pnInvoice.InvoiceCompany)
                            {
                                vendTransPnInvoice = VendTrans::findVoucherDate(pnInvoice.InvoiceVoucher, pnInvoice.InvoiceDate);
                            }
                            currentSettleFactor = pnInvoice.settleFactor(settlementPair.getCustVendTransDebit().NegInstId,
                                                                        -vendTransPnInvoice.AmountCur,
                                                                        vendTransPnInvoice.Voucher,
                                                                        vendTransPnInvoice.company(),
                                                                        vendTransPnInvoice.CurrencyCode);
                            // Post conditional tax for the vendor settlement when the journal type is Settle promissory note journal.
                            // Settle promissory note journal is settling against the draw promissory note journal instead of the vendor
                            // invoice journal.
                            // Conditional tax posting during the vendor settlement should use the currency of initial vendor invoice
                            // journal when the currency of draw promissory note journal is different from the initial vendor invoice
                            // journal.
                            // This issue only exists in the settling promissory note journal scenario.
                            ExchRate accountingExchRate = settlementPair.getExchRate().getDebitCurToDebitMstCombined();
                            ExchRate reportingExchRate = settlementPair.getExchRate().getDebitCurToReporting();

                            boolean recalculateExchRate = vendTransPnInvoice.CurrencyCode != settlementPair.getCustVendTransCredit().CurrencyCode;

                            if (recalculateExchRate)
                            {
                                [accountingExchRate, reportingExchRate] = this.getAccountingReportingExchRate(vendTransPnInvoice.CurrencyCode);
                            }

                            this.postConditionalTax(
                                currentSettleFactor,
                                _origSettleFactorDebit,
                                vendTransPnInvoice,
                                settlementPair.getCustVendTransCredit(),
                                _cashDiscAmountCurDebit,
                                accountingExchRate,
                                reportingExchRate);
                        }

                        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
                        {
                            while select vendRemitInvoiceRef
                                where vendRemitInvoiceRef.TransRecId == settlementPair.getCustVendTransDebit().RecId
                            {
                                vendTransPnInvoice = VendTrans::findByCompany(vendRemitInvoiceRef.InvoiceCompany, vendRemitInvoiceRef.InvoiceRecid);
                                this.processConditionalTax_ES(_origSettleFactorDebit, _cashDiscAmountCurDebit, vendTransPnInvoice);
                            }
                        }
                        break;
                    default :
                        if (!processConditionalTaxForPDC)
                        {
                            currentSettleFactor = settlementPair.getCustVendTransDebit().AmountCur ? settlementPair.getCustVendTransDebit().SettleAmountCur / settlementPair.getCustVendTransDebit().AmountCur : 0;

                            custVendTransTaxDebit = settlementPair.getCustVendTransDebit().data();
                            if (!TaxProcessConditionalTaxWithCorrectTransDateFlight::instance().isEnabled()) 
                            {
                                if (custVendTransTaxDebit.TableId == tableNum(VendTrans))
                                {
                                    custVendTransTaxDebit.TransDate = this.determineTransDate(custVendTransTaxDebit);
                                }
                            }
                        
                            this.postConditionalTax(
                                currentSettleFactor,
                                _origSettleFactorDebit,
                                custVendTransTaxDebit,
                                settlementPair.getCustVendTransCredit(),
                                _cashDiscAmountCurDebit,
                                settlementPair.getExchRate().getDebitCurToDebitMstCombined(),
                                settlementPair.getExchRate().getDebitCurToReporting());
                        }
                        break;
                }
            }
        }

        changecompany(settlementPair.getCreditCompany())
        {
            if (this.shouldPostConditionalTaxForCreditCompany())
            {
                currentSettleFactor = settlementPair.getCustVendTransCredit().AmountCur ? settlementPair.getCustVendTransCredit().SettleAmountCur / settlementPair.getCustVendTransCredit().AmountCur : 0;

                if (settlementPair.getCustVendTransCredit().TableId == tableNum(CustTrans))
                {
                    custTransPaym = settlementPair.getCustVendTransCredit();
                    paymMethod = CustTransPaym.PaymMethod;

                    if (paymMethod == NetCurrent::COD)
                    {
                        postConditionalTax = false;
                    }
                }

                if (postConditionalTax)
                {
                    this.postConditionalTax(
                        currentSettleFactor,
                        _origSettleFactorCredit,
                        settlementPair.getCustVendTransCredit(),
                        settlementPair.getCustVendTransDebit(),
                        _cashDiscAmountCurCredit,
                        settlementPair.getCustVendTransCredit().exchRateCurToMst(),
                        settlementPair.getCustVendTransCredit().getReportingCombinedExchangeRate());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountingReportingExchRate</Name>
				<Source><![CDATA[
    private container getAccountingReportingExchRate(CurrencyCode _fromCurrency)
    {
        TaxCurrencyConversionHelper taxCurrencyConversionHelper = new TaxCurrencyConversionHelper(_fromCurrency, settlementPair.getCustVendTransCredit().TransDate);
        ExchRate accountingExchRate = taxCurrencyConversionHelper.getExchRateTransactionToAccounting();
        ExchRate reportingExchRate = taxCurrencyConversionHelper.getExchRateTransactionToReporting();

        return [accountingExchRate, reportingExchRate];
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldProcessConditionalTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if conditional tax should be processed during the process current settlement.
    /// </summary>
    /// <returns>true if conditional tax should be processed; otherwise, false.</returns>
    /// <remarks>
    /// Currently, if LedgerJournalTrans.Cancel is true, it should not be processed.
    /// </remarks>
    private boolean shouldProcessConditionalTax()
    {
        // Skip the conditional tax process, if LedgerJournalTrans.Cancel is true.
        return !(settleNowState.getSpecTableId() == tableNum(LedgerJournalTrans)
                && LedgerJournalTrans::findRecId(settleNowState.getSpecRecId(), false).Cancel);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldPostConditionalTaxForCreditCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if conditional tax should be posted.
    /// </summary>
    /// <returns>true if conditional tax should be posted; otherwise, false.</returns>
    protected boolean shouldPostConditionalTaxForCreditCompany()
    {
        return TaxParameters::find().ConditionalTax == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processFine_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the amount of the Fine for the debit and credit transactions.
    /// </summary>
    /// <returns>
    ///    A container that contains the cash discount amounts.
    /// </returns>
    /// <remarks>
    ///    The first value in the container is the fine amount in the debit transaction currency.The
    ///    second value in the container is the fine amount in the credit transaction currency.The
    ///    third value in the container is the fine amount in the debit transaction monetary standard
    ///    (MST) currency.The fourth value in the container is the fine amount in the credit
    ///    transaction (MST) currency.
    /// </remarks>
    protected container processFine_BR()
    {
        AmountCur               fineAmountDebit;
        AmountCur               fineAmountCredit;
        AmountMST               fineAmountMstDebit;
        AmountMST               fineAmountMstCredit;
        AmountMSTSecondary      fineAmountReportingDebit;
        AmountMSTSecondary      fineAmountReportingCredit;
        LedgerRecId             ledgerRecId;

        CurrencyExchangeHelper  currencyHelper;

        currencyHelper = CurrencyExchangeHelper::construct();

        fineAmountDebit                 = settlementPair.getCustVendTransOpenDebit().FineAmount_BR;
        fineAmountMstDebit              = settlementPair.getExchRate().convertDebitCurToMst(fineAmountDebit, true);
        fineAmountReportingDebit        = settlementPair.getExchRate().convertDebitCurToReporting(fineAmountDebit);

        fineAmountCredit      = settlementPair.getCustVendTransOpenCredit().FineAmount_BR;

        ledgerRecId = Ledger::primaryLedger(CompanyInfo::current(settlementPair.getCreditCompany()));

        currencyHelper.parmLedgerRecId(ledgerRecId);
        currencyHelper.parmExchangeDate(settlementPair.getCustVendTransCredit().TransDate);
        currencyHelper.parmExchangeRate1(settlementPair.getCustVendTransCredit().ExchRate);
        currencyHelper.parmExchangeRate2(settlementPair.getCustVendTransCredit().ExchRateSecond);
        settlementPair.getCustVendTransCredit().setExchangeHelperReportingExchRate(currencyHelper);

        fineAmountMstCredit         = currencyHelper.calculateTransactionToAccounting(settlementPair.getCustVendTransCredit().CurrencyCode, fineAmountCredit, true);
        fineAmountReportingCredit   = currencyHelper.calculateTransactionCurrencyToReportingCurrency(settlementPair.getCustVendTransCredit().CurrencyCode, fineAmountCredit);

        this.updateAmountsOnTransactionForFine_BR(fineAmountDebit, fineAmountMstDebit, fineAmountReportingDebit, fineAmountCredit, fineAmountMstCredit, fineAmountReportingCredit);

        return [fineAmountDebit,
                fineAmountCredit,
                fineAmountMstDebit,
                fineAmountMstCredit,
                fineAmountReportingDebit,
                fineAmountReportingCredit];
    }

]]></Source>
			</Method>
			<Method>
				<Name>processInterest_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the amount of the Interest for the debit and credit transactions.
    /// </summary>
    /// <returns>
    ///    A container that contains the cash discount amounts.
    /// </returns>
    /// <remarks>
    ///    The first value in the container is the interest amount in the debit transaction currency.The
    ///    second value in the container is the interest amount in the credit transaction currency.The
    ///    third value in the container is the interest amount in the debit transaction monetary standard
    ///    (MST) currency.The fourth value in the container is the interest amount in the credit
    ///    transaction (MST) currency.
    /// </remarks>
    protected container processInterest_BR()
    {
        AmountCur               finInterestAmountDebit;
        AmountCur               finInterestAmountCredit;
        AmountMST               finInterestAmountMstDebit;
        AmountMST               finInterestAmountMstCredit;
        AmountMSTSecondary      finInterestAmountReportingDebit;
        AmountMSTSecondary      finInterestAmountReportingCredit;
        LedgerRecId             ledgerRecId;

        CurrencyExchangeHelper  currencyHelper;

        currencyHelper = CurrencyExchangeHelper::construct();

        finInterestAmountDebit          = settlementPair.getCustVendTransOpenDebit().InterestAmount_BR;
        finInterestAmountMstDebit       = settlementPair.getExchRate().convertDebitCurToMst(finInterestAmountDebit, true);
        finInterestAmountReportingDebit = settlementPair.getExchRate().convertDebitCurToReporting(finInterestAmountDebit);

        finInterestAmountCredit      = settlementPair.getCustVendTransOpenCredit().InterestAmount_BR;

        ledgerRecId = Ledger::primaryLedger(CompanyInfo::current(settlementPair.getCreditCompany()));

        currencyHelper.parmLedgerRecId(ledgerRecId);
        currencyHelper.parmExchangeDate(settlementPair.getCustVendTransCredit().TransDate);
        currencyHelper.parmExchangeRate1(settlementPair.getCustVendTransCredit().ExchRate);
        currencyHelper.parmExchangeRate2(settlementPair.getCustVendTransCredit().ExchRateSecond);
        settlementPair.getCustVendTransCredit().setExchangeHelperReportingExchRate(currencyHelper);

        finInterestAmountMstCredit          = currencyHelper.calculateTransactionToAccounting(settlementPair.getCustVendTransCredit().CurrencyCode, finInterestAmountCredit, true);
        finInterestAmountReportingCredit    = currencyHelper.calculateTransactionCurrencyToReportingCurrency(settlementPair.getCustVendTransCredit().CurrencyCode, finInterestAmountCredit);

        this.updateAmountsOnTransactionForInterest_BR(finInterestAmountDebit, finInterestAmountMstDebit, finInterestAmountReportingDebit, finInterestAmountCredit, finInterestAmountMstCredit, finInterestAmountReportingCredit);

        return [finInterestAmountDebit,
                finInterestAmountCredit,
                finInterestAmountMstDebit,
                finInterestAmountMstCredit,
                finInterestAmountReportingDebit,
                finInterestAmountReportingCredit];
    }

]]></Source>
			</Method>
			<Method>
				<Name>processServiceTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process service tax.
    /// </summary>
    /// <param name="_origSettleFactorDebit">
    /// The original settle factor debit.
    /// </param>
    /// <param name="_origSettleFactorCredit">
    /// The original settle factor credit.
    /// </param>
    /// <param name="_cashDiscAmountCurDebit">
    /// The current cash disc amount debit.
    /// </param>
    /// <param name="_cashDiscAmountCurCredit">
    /// The current cash disc amount credit.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal trans.
    /// </param>
    /// <param name="_tableId">
    /// The table id.
    /// </param>
    protected void processServiceTax_IN(
        Percent                 _origSettleFactorDebit,
        Percent                 _origSettleFactorCredit,
        DiscAmount              _cashDiscAmountCurDebit,
        DiscAmount              _cashDiscAmountCurCredit,
        LedgerJournalTrans      _ledgerJournalTrans = null,
        TableId                 _tableId = 0)
    {
        CustBillOfExchangeInvoice       boeInvoice;
        VendPromissoryNoteInvoice       pnInvoice;
        CustTrans                       custTransBoeInvoice;
        VendTrans                       vendTransPnInvoice;
        Percent                         currentSettleFactor;
        boolean                         postServiceTaxIN;
        CustVendTrans_W                 custVendTrans_W;

        if (TaxParameters::isServiceTaxEnable_IN())
        {
            TaxSettlement_IN::checkServiceTaxBasis(settlementPair.getCustVendTransDebit().Voucher, settlementPair.getCustVendTransDebit().TransDate, settlementPair.getCustVendTransCredit().Voucher, settlementPair.getCustVendTransCredit().TransDate);

            switch (LedgerJournalTable::find(this.findLedgerJournalNum(settlementPair.getSpecTransDebit())).JournalType)
            {
                case LedgerJournalType::CustBillOfExchangeDraw,
                     LedgerJournalType::CustBillOfExchangeProtest,
                     LedgerJournalType::CustBillOfExchangeRedraw,
                     LedgerJournalType::CustPaymRemittance,
                     LedgerJournalType::VendPromissoryNoteDraw,
                     LedgerJournalType::VendPromissoryNoteRedraw,
                     LedgerJournalType::VendPaymRemittance :
                    break;

                case LedgerJournalType::CustBillOfExchangeSettle :
                    while select boeInvoice
                        where boeInvoice.BillOfExchangeId == settlementPair.getCustVendTransDebit().NegInstId
                            && boeInvoice.InvoiceCompany  == curext()
                        join custTransBoeInvoice
                            where custTransBoeInvoice.Voucher   == boeInvoice.InvoiceVoucher
                               && custTransBoeInvoice.TransDate == boeInvoice.InvoiceDate
                    {
                        currentSettleFactor = boeInvoice.settleFactor(settlementPair.getCustVendTransDebit().NegInstId, -boeInvoice.InvoiceAmountCur, boeInvoice.InvoiceVoucher, boeInvoice.company(), boeInvoice.CurrencyCode);
                        postServiceTaxIN = TaxSettlement_IN::canPostServicetax(settlementPair.getCustVendTransCredit(), custTransBoeInvoice);
                        if (postServiceTaxIN == true)
                        {
                            this.postServiceTax_IN(currentSettleFactor, _origSettleFactorDebit, custTransBoeInvoice, settlementPair.getCustVendTransCredit(), _cashDiscAmountCurDebit, LedgerJournalType::CustBillOfExchangeSettle);
                        }
                    }
                    break;
                case LedgerJournalType::VendPromissoryNoteSettle :
                    while select pnInvoice
                        where pnInvoice.PromissoryNoteId == settlementPair.getCustVendTransDebit().NegInstId
                            && pnInvoice.InvoiceCompany  == curext()
                        join vendTransPnInvoice
                            where vendTransPnInvoice.Voucher == pnInvoice.InvoiceVoucher
                            && vendTransPnInvoice.TransDate  == pnInvoice.InvoiceDate
                    {
                        currentSettleFactor = pnInvoice.settleFactor(settlementPair.getCustVendTransDebit().NegInstId, -pnInvoice.InvoiceAmountCur, pnInvoice.InvoiceVoucher, pnInvoice.company(), pnInvoice.CurrencyCode);
                        postServiceTaxIN = TaxSettlement_IN::canPostServicetax(settlementPair.getCustVendTransCredit(), vendTransPnInvoice);
                        if (postServiceTaxIN == true)
                        {
                            this.postServiceTax_IN(currentSettleFactor, _origSettleFactorDebit, vendTransPnInvoice, settlementPair.getCustVendTransCredit(), _cashDiscAmountCurDebit, LedgerJournalType::VendPromissoryNoteSettle);
                        }
                    }
                    break;

                case LedgerJournalType::BankChequeReversal:
                    settlementPair.getCustVendTransDebit().Voucher = TaxSettlement_IN::determineRelatedVoucher(settlementPair.getCustVendTransDebit().Voucher, settlementPair.getCustVendTransDebit().TransDate);
                    currentSettleFactor = settlementPair.getCustVendTransDebit().AmountCur ? settlementPair.getCustVendTransDebit().SettleAmountCur / settlementPair.getCustVendTransDebit().AmountCur : 0;
                    this.postServiceTax_IN(currentSettleFactor, _origSettleFactorDebit, settlementPair.getCustVendTransDebit(), settlementPair.getCustVendTransCredit(), _cashDiscAmountCurDebit, LedgerJournalType::BankChequeReversal);
                    break;

                case LedgerJournalType::BankDepositPaymCancel:
                    settlementPair.getCustVendTransDebit().Voucher = TaxSettlement_IN::determineRelatedVoucher(settlementPair.getCustVendTransDebit().Voucher, settlementPair.getCustVendTransDebit().TransDate);
                    currentSettleFactor = settlementPair.getCustVendTransCredit().AmountCur ? settlementPair.getCustVendTransCredit().SettleAmountCur / settlementPair.getCustVendTransCredit().AmountCur : 0;
                    this.postServiceTax_IN(currentSettleFactor, _origSettleFactorDebit, settlementPair.getCustVendTransDebit(), settlementPair.getCustVendTransCredit(), _cashDiscAmountCurDebit, LedgerJournalType::BankDepositPaymCancel);
                    break;

                default :
                    if (_tableId == tableNum(PurchTable) || _tableId == tableNum(SalesTable) ||_tableId == tableNum(VendTable) || _tableId == tableNum(CustTable))
                    {
                        this.updateSTAdvancePayment_IN(settlementPair.getCustVendTransDebit(), settlementPair.getCustVendTransCredit(), _tableId);
                    }
                    currentSettleFactor = settlementPair.getCustVendTransDebit().AmountCur ? settlementPair.getCustVendTransDebit().SettleAmountCur / settlementPair.getCustVendTransDebit().AmountCur : 0;
                    this.postServiceTax_IN(currentSettleFactor, _origSettleFactorDebit, settlementPair.getCustVendTransDebit(), settlementPair.getCustVendTransCredit(), _cashDiscAmountCurDebit, 0,_ledgerJournalTrans.RecId,_tableId);
                    break;
            }
            // End switch

            if (settlementPair.getCustVendTransDebit().TableId == tableNum(VendTrans))
            {
                if (settlementPair.getCustVendTransDebit().TransType == LedgerTransType::Tax
                    && _ledgerJournalTrans.RecId != 0
                    && settlementPair.getCustVendTransDebit().AmountCur != 0)
                {
                    currentSettleFactor = settlementPair.getCustVendTransDebit().AmountCur ? (settlementPair.getCustVendTransDebit().SettleAmountCur / settlementPair.getCustVendTransDebit().AmountCur) : 0;
                    this.postForeignVendorAdv_IN((currentSettleFactor - _origSettleFactorDebit ) * 100, _ledgerJournalTrans);
                }
                custVendTrans_W = settlementPair.getCustVendTransDebit().CustVendTrans::getCustVendTrans_W();
                if (custVendTrans_W.Settlement_IN   == NoYes::Yes
                    && custVendTrans_W.gtaAmount_IN != 0
                    && settlementPair.getCustVendTransDebit().TransType    == LedgerTransType::Tax
                    && _ledgerJournalTrans.RecId != 0)
                {
                    currentSettleFactor = settlementPair.getCustVendTransDebit().AmountCur ? settlementPair.getCustVendTransDebit().SettleAmountCur / settlementPair.getCustVendTransDebit().AmountCur : 0;
                    this.postGTAVendorAdv_IN((currentSettleFactor - _origSettleFactorDebit ) * 100, _ledgerJournalTrans);
                }
            }
        }
        // End - If
    }

]]></Source>
			</Method>
			<Method>
				<Name>processStillOpenTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes transactions that that have a balance remaining after settlement.
    /// </summary>
    /// <param name="_origRemainDebitCur">
    /// The original amount of the debit transaction.
    /// </param>
    /// <remarks>
    /// This method uses the stillOpen array values to loop thru transactions that have a balance after settlement.
    /// If the unsettled amount is under the limit, under/over transactions are created.
    /// </remarks>
    protected void processStillOpenTransactions(AmountCur _origRemainDebitCur)
    {
        Counter currentIndex;
        CompanyId currentCompany;
        AmountMST totalUnderOverForCompany;
        AmountMST maxUnderOverAmountMst;
        boolean processAsUnspecific;
        AmountMST discAccumForOverTrans;
        CustVendTrans discTrans;
        boolean isCrossCompany;
        Set companiesWithTaxProcessed;
        boolean calcTaxForCompany;

        if (fullSettlement.isFullSettlement())
        {
            return;
        }

        companiesWithTaxProcessed = new Set(Types::String);

        for (currentIndex = remainingOpenAmounts.getCurrentIndex(); currentIndex > 0; currentIndex--)
        {
            // Find over/under amount for the company
            currentCompany = remainingOpenAmounts.getCompany(currentIndex);
            changecompany(currentCompany)
            {
                // There can be multiple transactions per company in the index, but we only want to
                // process each company once for over/under taxes.  Will use set called companiesWithTaxProccesed
                // and if company is already in the set this is indication that taxes where already calculated
                // and shouldn't be calculated again.
                if (companiesWithTaxProcessed.in(currentCompany))
                {
                    calcTaxForCompany = false;
                }
                else
                {
                    calcTaxForCompany = true;
                    companiesWithTaxProcessed.add(currentCompany);
                }

                totalUnderOverForCompany = remainingOpenAmounts.getAmountForCompany(currentCompany);

                maxUnderOverAmountMst = this.maxInaccurateAmountMST();

                if (totalUnderOverForCompany < 0 && this.cashDiscMethod() == UnspecificSpecific::Unspecific)
                {
                    CurrencyExchangeHelper currencyHelper = CurrencyExchangeHelper::construct();

                    // for all transactions with discount that were settled against the under/over transaction
                    // accumulate the discount amount on these transactions.

                    Set cashDiscountAmountsForCreditTrans = cashDiscountAmounts.getElementsFor(remainingOpenAmounts.getTransOpenRecId(currentIndex));
                    SetEnumerator enumerator = cashDiscountAmountsForCreditTrans.getEnumerator();

                    while (enumerator.moveNext())
                    {
                        SettlementCashDiscountAmountsElement currentCashDiscount = enumerator.current();
                        processAsUnspecific = true;

                        if (currentCompany == currentCashDiscount.getDebitCompany())
                        {
                            discAccumForOverTrans += currentCashDiscount.getAmountMst();
                        }
                        else
                        {
                            changecompany(currentCashDiscount.getDebitCompany())
                            {
                                discTrans = this.initCustVendTransBuffer();

                                select firstonly discTrans
                                    where discTrans.RecId == currentCashDiscount.getTransDebitRecId();
                            }

                            // if companies are different convert to disc amount to mst value in OverUnder company.
                            isCrossCompany = true;
                            currencyHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(currentCompany).RecId));
                            currencyHelper.parmExchangeDate(discTrans.TransDate);
                            discAccumForOverTrans += currencyHelper.calculateTransactionToAccounting(discTrans.CurrencyCode, currentCashDiscount.getAmountMst(), true);
                        }
                    }

                    if (discAccumForOverTrans == 0 ||
                        discAccumForOverTrans + maxUnderOverAmountMst < abs(totalUnderOverForCompany))
                    {
                        // The amount of discount taken isn't enought to cover the over/under
                        processAsUnspecific =  false;
                    }

                    if (isCrossCompany && processAsUnspecific)
                    {
                        // treat cross company treat as specific
                        this.processStillOpenTransSpecific(currentIndex, currentCompany, discAccumForOverTrans + maxUnderOverAmountMst, totalUnderOverForCompany, calcTaxForCompany);
                    }
                    else if (processAsUnspecific)
                    {
                        this.processStillOpenTransUnspecific(currentIndex, totalUnderOverForCompany, _origRemainDebitCur);
                    }

                    // Get new value from map, this could have been updated by the previous processing.
                    totalUnderOverForCompany = remainingOpenAmounts.getAmountForCompany(currentCompany);
                }
                
                if (this.canProcessStillOpenTransSpecific(totalUnderOverForCompany, maxUnderOverAmountMst))
                {
                    this.processStillOpenTransSpecific(currentIndex, currentCompany, maxUnderOverAmountMst, totalUnderOverForCompany, calcTaxForCompany);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canProcessStillOpenTransSpecific</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether or not processing should occur on open transactions to settle the remaining amount on the transaction
    /// by using the cash discount administration specific rules.
    /// </summary>
    /// <param name = "_totalUnderOverForCompany">The total under/over transaction amount for the current company in the MST currency.</param>
    /// <param name = "_maxUnderOverAmountMst">The maximum allowed under/over transaction amount in the monetary standard (MST) currency.</param>
    /// <returns>true if processing should occur; otherwise, false.</returns>
    protected boolean canProcessStillOpenTransSpecific(AmountMST _totalUnderOverForCompany, AmountMST _maxUnderOverAmountMst)
    {
        // check amount within limits for the company.
        // Check if settling a sales order if there is amount that needs to be written off.
        return (_totalUnderOverForCompany != 0
            && abs(_totalUnderOverForCompany) <= _maxUnderOverAmountMst)
            || (mcrOrderCompletionEnabled
                && _totalUnderOverForCompany == writeOffAmount
                && mcrOOBReleaseType == MCROutOfBalanceReleaseType::WriteOff);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processStillOpenTransSpecific</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts transactions to settle the remaining amount on the transaction by using the cash discount
    ///    administration specific rules.
    /// </summary>
    /// <param name="_currentIndex">
    ///    The current index value from the <c>processstillOpenIndex</c> array.
    /// </param>
    /// <param name="_currentCompany">
    ///    The overpayment transaction company.
    /// </param>
    /// <param name="_maxUnderOverAmountMst">
    ///    The maximum allowed under/over transaction amount in the monetary standard (MST) currency.
    /// </param>
    /// <param name="_totalUnderOverForCompany">
    ///    The total under/over transaction amount for the current company in the MST currency.
    /// </param>
    /// <param name="_processTax">
    ///    The flag that indicates if taxes for over and under payments were already processed.
    /// </param>
    protected void processStillOpenTransSpecific(
        Counter _currentIndex,
        CompanyId _currentCompany,
        AmountMST _maxUnderOverAmountMst,
        AmountMST _totalUnderOverForCompany,
        boolean _processTax)
    {
        CustVendTrans underOverTrans = this.initCustVendTransBuffer();
        CustVendTransOpen underOverTransOpen = this.initCustVendTransOpenBuffer();
        CustVendTrans offsetTrans;
        CurrencyExchangeHelper currencyHelper;
        AmountCur maxUnderOverAmountCur;
        AmountCur settleAmountCur;
        AmountMST settleAmountMst;
        AmountMSTSecondary settleAmountReporting;
        Percent underOverSettledFactor;
        AmountMST unrealizedExchAdjAmount;
        AmountMSTSecondary unrealizedReportingExchAdjAmount;
        CustVendSettlement settlementToUpdate;
        CurrencyCode currentCompanyCurrencyCode;
        TaxAmount taxAmountMst;
        TaxAmount taxAmountCur;
        TaxAmount taxAmountReporting;
        boolean setSettlementVoucherOnOffset;
        CustVendPrePaymentReversal prePaymentReversal;
        LedgerVoucher ledgerVoucher;
        CustVendTransSettleDistController distributionController = CustVendTransSettleDistController::construct(isSettleByLineEnabled);
        // <GEEU>
        CustVendTrans                     underOverTransOffset;
        CustVendSettlement                settlementOffset;
        CustVendExchAdjustment_W          custVendExchAdjustment;
        boolean                           usePostingLog = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]);

        if (usePostingLog)
        {
            underOverTransOffset = this.initCustVendTransBuffer();
        }
        // </GEEU>

        Debug::assert(_currentCompany == curext());

        currencyHelper = CurrencyExchangeHelper::construct();
        currencyHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(_currentCompany).RecId));
        currencyHelper.parmExchangeDate(settlementPair.getTransactionDate());

        // Find transactions
        underOverTrans = this.findCustVendTransByRecID(remainingOpenAmounts.getTransRecId(_currentIndex), underOverTrans);

        select firstonly forupdate underOverTransOpen
            where underOverTransOpen.RecId == remainingOpenAmounts.getTransOpenRecId(_currentIndex);

        this.reverseAmounts(underOverTrans);
        this.reverseTransOpenAmounts(underOverTransOpen);

        currencyHelper.parmExchangeRate1(underOverTrans.ExchRate);
        currencyHelper.parmExchangeRate2(underOverTrans.ExchRateSecond);
        underOverTrans.setExchangeHelperReportingExchRate(currencyHelper);

        maxUnderOverAmountCur = currencyHelper.calculateAccountingToTransaction(underOverTrans.CurrencyCode, _maxUnderOverAmountMst, true);

        settlementGroupPlaceHolder = remainingOpenAmounts.getGroup(_currentIndex);

        if (settlementGroupPlaceHolder == 0)
        {
            // Because there is no settlement this means that some class variables may not have been intialized.
            // Need to initialize some values such and debitCompany, creditCompany.  This is done by called initForNewSettlement.
            // initForNowSettlement uses the class variable CustVendTransOpenDebit so set the class variable to the underOver table buffer.
            settlementPair.setCustVendTransOpenDebit(underOverTransOpen);
            this.initForNewSettlement();
        }

        // Calculate the under over amount in transaction currency, this is the lesser of the amount
        // remaining on the transaction or the under/over amount for the company
        if (abs(underOverTrans.AmountCur - underOverTrans.SettleAmountCur) <= maxUnderOverAmountCur)
        {
            settleAmountCur = underOverTrans.AmountCur - underOverTrans.SettleAmountCur;
            settleAmountMst = underOverTrans.AmountMST - underOverTrans.SettleAmountMST + underOverTrans.ExchAdjustmentRealized;
            settleAmountReporting = underOverTrans.ReportingCurrencyAmount - underOverTrans.SettleAmountReporting + underOverTrans.ReportingExchAdjustmentRealized;
            underOverTrans.Closed = CustVendTransData::construct(underOverTrans).maxSettlementDate(settlementPair.getTransactionDate());
        }
        else
        {
            settleAmountCur = currencyHelper.calculateAccountingToTransaction(underOverTrans.CurrencyCode, _totalUnderOverForCompany, true);
            settleAmountMst = currencyHelper.calculateTransactionToAccounting(underOverTrans.CurrencyCode, settleAmountCur, true);
            settleAmountReporting = currencyHelper.calculateTransactionCurrencyToReportingCurrency(underOverTrans.CurrencyCode, settleAmountCur);

            underOverTrans.Closed = dateNull();
        }

        if (settleAmountCur != 0)
        {
            // Calculate the tax on over/under payment.
            if (_processTax && abs(_totalUnderOverForCompany) >= this.maxPennyDiff())
            {
                if (_totalUnderOverForCompany < 0)
                {
                    [taxAmountMst, taxAmountCur] = this.processTaxOnOverPayment(_totalUnderOverForCompany,
                        rslTmpOverUnderReverseTax,
                        underOverTrans,
                        distributionController);
                }
                else
                {
                    [taxAmountMst, taxAmountCur] = this.processTaxOnUnderPayment(_totalUnderOverForCompany,
                        underOverTrans,
                        distributionController,
                        settlementGroupPlaceHolder);
                }
                taxAmountReporting = currencyHelper.calculateTransactionCurrencyToReportingCurrency(underOverTrans.CurrencyCode, taxAmountCur);
            }

            // calculate the unrealized exchange adjustment amounts.
            currentCompanyCurrencyCode = CompanyInfoHelper::standardCurrency();
            underOverSettledFactor = SettlementUtility::calcSettleFactor(underOverTrans.AmountCur, underOverTrans.SettleAmountCur, settleAmountCur, 0);

            unrealizedExchAdjAmount = SettlementUtility::calcUnrealizedExchAdjToReverse(
                underOverTrans.AmountCur,
                underOverTrans.SettleAmountCur,
                underOverTrans.ExchAdjustmentUnrealized,
                underOverSettledFactor,
                currentCompanyCurrencyCode);

            unrealizedReportingExchAdjAmount = SettlementUtility::calcUnrealizedReportingExchAdjToReverse(
                underOverTrans.AmountCur,
                underOverTrans.SettleAmountCur,
                underOverTrans.ReportingExchAdjustmentUnrealized,
                underOverSettledFactor,
                underOverTrans.company());

            // update fields on the trans and trans open
            underOverTrans.SettleAmountCur += settleAmountCur;
            underOverTrans.SettleAmountMST += settleAmountMst;
            underOverTrans.SettleAmountReporting += settleAmountReporting;

            underOverTransOpen.AmountCur -= settleAmountCur;
            underOverTransOpen.AmountMST -= settleAmountMst;
            underOverTransOpen.ReportingCurrencyAmount -= settleAmountReporting;

            // <GEEU>
            if (usePostingLog)
            {
                settlementOffset = custVendTransSettlement.findSettlementForCustVendTrans(underOverTrans, settlementGroupPlaceHolder, underOverTrans.OffsetRecId);
                underOverTransOffset = this.findCustVendTransByRecID(settlementOffset.OffsetRecId, underOverTransOffset);

                this.postPennyDiff(this.amount(-settleAmountCur),
                    this.amount(-settleAmountMst),
                    this.amount(-settleAmountReporting),
                    underOverTrans,
                    distributionController,
                    taxAmountCur,
                    taxAmountMst,
                    taxAmountReporting,
                    remainingOpenAmounts.getDimension(_currentIndex),
                    underOverTransOffset);
            }
            else
            {
                // </GEEU>
                this.postPennyDiff(this.amount(-settleAmountCur),
                    this.amount(-settleAmountMst),
                    this.amount(-settleAmountReporting),
                    underOverTrans,
                    distributionController,
                    taxAmountCur,
                    taxAmountMst,
                    taxAmountReporting,
                    remainingOpenAmounts.getDimension(_currentIndex));
                // <GEEU>
            }
            // </GEEU>
            info(strFmt("@SYS129116", abs(settleAmountCur), underOverTrans.Voucher, underOverTrans.company()));

            if (underOverTrans.Prepayment)
            {
                if (TaxReversePrePayment::existPrePaymentTax(underOverTrans.TransDate, underOverTrans.Voucher))
                {
                    // if tax transaction exist for prepayment, reverse tax for the overpayment amount
                    ledgerVoucher = settlementPair.findLedgerVoucherByCompany(_currentCompany);
                    prePaymentReversal = CustVendPrePaymentReversal::newCustVendTrans(underOverTrans,
                        custVendTransSettlement,
                        settlementGroupPlaceHolder);

                    // <GEEU>
                    if (usePostingLog)
                    {
                        prePaymentReversal.reversePrePaymentTax(underOverTrans, ledgerVoucher, settleAmountCur, settleAmountMst, settleAmountReporting, underOverTransOffset);
                    }
                    else
                    {
                        // </GEEU>
                        prePaymentReversal.reversePrePaymentTax(underOverTrans, ledgerVoucher, settleAmountCur);
                        // <GEEU>
                    }
                    // </GEEU>
                }
            }

            // check for unrealized exchange adjustment
            // <GEERU>
            if (exchRateDiffCalcType == ExchRateDiffCalcType_W::Standard)
            {
                // </GEERU>
                if (unrealizedExchAdjAmount != 0 || unrealizedReportingExchAdjAmount != 0)
                {
                    this.updateExchAdjAmountOnTrans(0, unrealizedExchAdjAmount, 0, unrealizedReportingExchAdjAmount, underOverTrans, underOverTransOpen);
                    this.postExchRateDiff(unrealizedExchAdjAmount,
                        unrealizedReportingExchAdjAmount,
                        underOverTrans,
                        distributionController,
                        true);
                    this.createSettlementToReverseUnrealExchAdj(unrealizedExchAdjAmount, unrealizedReportingExchAdjAmount, underOverTrans, underOverTransOpen);
                }
                // <GEERU>
            }
            else
            {
                custVendExchAdjustment = CustVendExchAdjustment_W::newFromSettlement(this);
                custVendExchAdjustment.setCustVendTransSettlement(custVendTransSettlement);
                custVendExchAdjustment.setSettlementGroupPlaceHolder(settlementGroupPlaceHolder);

                custVendExchAdjustment.reverseUnrealizedExchAdj(underOverTrans,
                                                                underOverTransOpen,
                                                                settleAmountCur,
                                                                settlementPair.getTransactionDate(),
                                                                settlementPair.getCustVendTransCredit(),
                                                                false,
                                                                0);
            }
            // </GEERU>
            // update the trans and trans open records
            this.reverseAmounts(underOverTrans);

            this.updateTransOpen(underOverTrans, underOverTransOpen);
            underOverTrans.update();

            this.reverseAmounts(underOverTrans);

            custVendTransSettlementControl.ins(underOverTrans, true);

            // Only do the following if transaction state is Settled
            // update the penny diff, settle amount fields on the settlement record
            if (remainingOpenAmounts.getState(_currentIndex) == SettlementTransactionState::Settled)
            {
                settlementToUpdate = custVendTransSettlement.findSettlementForCustVendTrans(underOverTrans, settlementGroupPlaceHolder, underOverTrans.OffsetRecId);
                if (settlementToUpdate.TransRecId != 0)
                {
                    settlementToUpdate.SettleAmountCur += this.amount(settleAmountCur) - taxAmountCur;
                    settlementToUpdate.SettleAmountMST += this.amount(settleAmountMst) - taxAmountMst;
                    settlementToUpdate.SettleAmountReporting += this.amount(settleAmountReporting) - taxAmountReporting;
                    settlementToUpdate.PennyDiff += -(this.amount(settleAmountCur) - taxAmountCur);

                    if (settlementToUpdate.SettlementVoucher == '')
                    {
                        // Previous processing for this transaction didn't require a voucher, but will now add a voucher one for the penny diff.
                        // Need to also update SettlementVoucher field on this settlement and the offset settlement record
                        // with the current voucher number for the company.
                        settlementToUpdate.SettlementVoucher = settlementPair.findVoucherNumberByCompany(_currentCompany);

                        setSettlementVoucherOnOffset = true;
                        offsetTrans = this.initCustVendTransBuffer();
                        offsetTrans = this.findCustVendTransByRecID(settlementToUpdate.OffsetRecId, offsetTrans);
                    }

                    custVendTransSettlement.modifyTransAndSettlement(underOverTrans, settlementToUpdate, settlementGroupPlaceHolder, underOverTrans.OffsetRecId, false, true);
                }

                if (setSettlementVoucherOnOffset && offsetTrans.RecId != 0)
                {
                    settlementToUpdate = custVendTransSettlement.findSettlementForCustVendTrans(offsetTrans, settlementGroupPlaceHolder, underOverTrans.RecId);
                    if (settlementToUpdate.TransRecId != 0)
                    {
                        settlementToUpdate.SettlementVoucher = settlementPair.findVoucherNumberByCompany(_currentCompany);
                        custVendTransSettlement.modifyTransAndSettlement(offsetTrans, settlementToUpdate, settlementGroupPlaceHolder, underOverTrans.RecId, false, true);
                    }
                }
            }
        }

        // adjust amount in the map
        remainingOpenAmounts.adjustAmountForCompany(_currentCompany, -settleAmountMst);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processStillOpenTransUnspecific</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts transactions to settle the remaining amount on the transaction using the cash discount
    ///    administration unspecific rules.
    /// </summary>
    /// <param name="_underOverIndex">
    ///    The current index value from the <c>stillOpenIndex</c> array.
    /// </param>
    /// <param name="_totalOverUnderForCompany">
    ///    The total over transaction amount for the current company in the MST currency.
    /// </param>
    /// <param name="_origRemainDebitCur">
    ///    The original amount of the debit transaction.
    /// </param>
    /// <remarks>
    ///    The method assumes the transaction with the under or over amount is in the same company as the
    ///    transaction with the discount.
    /// </remarks>
    protected void processStillOpenTransUnspecific(
        Counter _underOverIndex,
        AmountMST _totalOverUnderForCompany,
        AmountCur _origRemainDebitCur)
    {
        CurrencyExchangeHelper currencyHelper;
        Counter currentDiscIndex;
        AmountMST discTakenMst;
        AmountMST underOverAmountMst;
        AmountMST settleAmountMstOver;
        AmountCur settleAmountCurOver;
        AmountMSTSecondary settleAmountReportingOver;
        AmountMST settleAmountMstDisc;
        AmountCur settleAmountCurDisc;
        AmountMSTSecondary settleAmountReportingDisc;
        CustVendTrans discTrans = this.initCustVendTransBuffer();
        CustVendTrans underOverTrans = this.initCustVendTransBuffer();
        CustVendTransOpen underOverTransOpen = this.initCustVendTransOpenBuffer();
        CustVendTransOpen discTransOpen = this.initCustVendTransOpenBuffer();
        Percent underOverSettledFactor;
        AmountMST unrealizedExchAdjAmount;
        AmountMSTSecondary unrealizedReportingExchAdjAmount;
        LedgerDimensionDefaultAccount discLedgerDimension;
        CustVendSettlement settlementToUpdate;
        LedgerVoucher ledgerVoucher;
        AmountCur taxOnCashDiscAmount;
        CustVendPrePaymentReversal prePaymentReversal;
        CustVendTransSettleDistController discTransSettleDistController = CustVendTransSettleDistController::construct(isSettleByLineEnabled);
        CustVendTransSettleDistController underOverTransSettleDistController = CustVendTransSettleDistController::construct(isSettleByLineEnabled);
        // <GEEU>
        CustVendTrans       underOverTransOffset;
        CustVendSettlement  settlementOffset;
        CustVendExchAdjustment_W  custVendExchAdjustment;
        boolean usePostingLog = CustVendTransPostingLog_RU::usePostingLog();

        if (usePostingLog)
        {
            underOverTransOffset = this.initCustVendTransBuffer();
        }
        // </GEEU>

        Debug::assert(curext() == remainingOpenAmounts.getCompany(_underOverIndex));
        currencyHelper = CurrencyExchangeHelper::construct();

        // loop thru all the debit transactions that had a discount taken for specified credit transaction
        Set cashDiscountAmountsForCreditTrans = cashDiscountAmounts.getElementsFor(remainingOpenAmounts.getTransOpenRecId(_underOverIndex));
        SetEnumerator enumerator = cashDiscountAmountsForCreditTrans.getEnumerator();

        AmountMST overUnderRemaining = _totalOverUnderForCompany;

        while (enumerator.moveNext())
        {
            if (overUnderRemaining == 0.0)
            {
                break;
            }

            SettlementCashDiscountAmountsElement currentCashDiscount = enumerator.current();

            Debug::assert(remainingOpenAmounts.getCompany(_underOverIndex) == currentCashDiscount.getDebitCompany());

            // get the disc trans record
            select firstonly forupdate discTrans
                where discTrans.RecId == currentCashDiscount.getTransDebitRecId();

            select firstonly discTransOpen
                where discTransOpen.RecId == currentCashDiscount.getTransOpenDebitRecId();

            this.reverseAmounts(discTrans);
            this.reverseTransOpenAmounts(discTransOpen);

            // The last settled date on the discount transaction contains the transaction date
            // for the discount so adjustment to cash discount should use the same date.
            settlementPair.setTransactionDate(discTrans.LastSettleDate);

            currencyHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(remainingOpenAmounts.getCompany(_underOverIndex)).RecId));
            currencyHelper.parmExchangeDate(discTrans.TransDate);

            discTakenMst = currentCashDiscount.getAmountMst();

            // Get the transaction with the under/over amount
            underOverTrans = this.findCustVendTransByRecID(remainingOpenAmounts.getTransRecId(_underOverIndex), underOverTrans);

            select firstonly forupdate underOverTransOpen
                where underOverTransOpen.RecId == remainingOpenAmounts.getTransOpenRecId(_underOverIndex);

            this.reverseAmounts(underOverTrans);
            this.reverseTransOpenAmounts(underOverTransOpen);

            underOverAmountMst = underOverTrans.AmountMST - underOverTrans.SettleAmountMST;

            // calculate the amount of over/under.  This is lesser of discount taken amount or the over/under remaining amount
            if (abs(underOverAmountMst) <= abs(discTakenMst))
            {
                settleAmountMstOver = underOverAmountMst;
                settleAmountCurOver = underOverTrans.AmountCur - underOverTrans.SettleAmountCur;
                settleAmountReportingOver = underOverTrans.ReportingCurrencyAmount - underOverTrans.SettleAmountReporting;
                underOverTrans.Closed = CustVendTransData::construct(underOverTrans).maxSettlementDate(settlementPair.getTransactionDate());
            }
            else
            {
                settleAmountMstOver = -discTakenMst;

                currencyHelper.parmExchangeRate1(underOverTrans.ExchRate);
                currencyHelper.parmExchangeRate2(underOverTrans.ExchRateSecond);
                underOverTrans.setExchangeHelperReportingExchRate(currencyHelper);

                settleAmountCurOver = currencyHelper.calculateAccountingToTransaction(underOverTrans.CurrencyCode, settleAmountMstOver, true);
                settleAmountReportingOver = currencyHelper.calculateTransactionCurrencyToReportingCurrency(underOverTrans.CurrencyCode, settleAmountCurOver);

                underOverTrans.Closed = dateNull();
            }

            CurrencyCode debitCompanyCurrency = Ledger::accountingCurrencyByLedger(
                Ledger::primaryLedger(CompanyInfo::findDataArea(currentCashDiscount.getDebitCompany()).RecId));

            CurrencyCode creditCompanyCurrency = Ledger::accountingCurrencyByLedger(currencyHelper.parmLedgerRecId());

            // Construct the exch rate to obtain debitCurToDebitMstCombined
            //debit = discTrans, credit = underOverTrans
            SettlementExchRate exchRate = SettlementExchRate::constructV2(
                discTrans.company(),
                debitCompanyCurrency,
                discTrans.CurrencyCode,
                0.0, // Cross-rate does not participate in calculation of debitCurToDebitMstCombined
                underOverTrans.company(),
                creditCompanyCurrency,
                underOverTrans.CurrencyCode,
                underOverTrans.TransDate,
                underOverTrans.exchRateCurToMst(),
                underOverTrans.getReportingCombinedExchangeRate());

            // get the settled amounts for the discTrans
            if (underOverTrans.CurrencyCode == discTrans.CurrencyCode)
            {
                // because transactions currency codes are the same, settled amount in transaction currencies are also the same
                settleAmountCurDisc = settleAmountCurOver;
            }
            else
            {
                // convert the settled in amount mst to discount transaction currency, use credit transaction exchange rate
                currencyHelper.parmExchangeRate1(exchRate.getDebitCurToDebitMstCombined());
                currencyHelper.parmExchangeRate2(0.0);
                settleAmountCurDisc = currencyHelper.calculateAccountingToTransaction(discTrans.CurrencyCode, settleAmountMstOver, true);
            }

            // since the discTrans and underOverTrans are in the same company the accounting and reporting amounts should be the same
            settleAmountMstDisc = settleAmountMstOver;
            settleAmountReportingDisc = settleAmountReportingOver;

            // calculate the unrealized exchange adjustment amounts.
            underOverSettledFactor = SettlementUtility::calcSettleFactor(underOverTrans.AmountCur, underOverTrans.SettleAmountCur, settleAmountCurOver, 0);
            unrealizedExchAdjAmount = SettlementUtility::calcUnrealizedExchAdjToReverse(
                underOverTrans.AmountCur,
                underOverTrans.SettleAmountCur,
                underOverTrans.ExchAdjustmentUnrealized,
                underOverSettledFactor,
                CompanyInfoHelper::standardCurrency());

            unrealizedReportingExchAdjAmount = SettlementUtility::calcUnrealizedReportingExchAdjToReverse(
                underOverTrans.AmountCur,
                underOverTrans.SettleAmountCur,
                underOverTrans.ReportingExchAdjustmentUnrealized,
                underOverSettledFactor,
                underOverTrans.company());

            // Update settle fields on underOverTrans and open
            underOverTrans.SettleAmountCur += settleAmountCurOver;
            underOverTrans.SettleAmountMST += settleAmountMstOver;
            underOverTrans.SettleAmountReporting += settleAmountReportingOver;
            underOverTransOpen.AmountCur -= settleAmountCurOver;
            underOverTransOpen.AmountMST -= settleAmountMstOver;
            underOverTransOpen.ReportingCurrencyAmount -= settleAmountReportingOver;

            // Update other fields on the underOverTrans
            underOverTrans.LastSettleDate = settlementPair.getTransactionDate();
            underOverTrans.LastSettleVoucher = discTrans.Voucher;
            underOverTrans.LastSettleCompany = discTrans.DataAreaId;
            underOverTrans.LastSettleAccountNum = discTrans.AccountNum;
            underOverTrans.OffsetRecId = discTrans.RecId;

            // Update the BankChequePaymTrans
            bankChequePaymTransCache.updateBankChequePaymTrans(discTrans.RecId, underOverTrans.RecId, settleAmountCurOver, settleAmountCurOver);

            // Set the voucher number on the LedgerVoucher instance.  This is needed because the transactions being
            // created should use the same voucher as the original discount taken.
            Debug::assert(currentCashDiscount.getVoucher() != '');
            ledgerVoucher = settlementPair.getLedgerVoucherGroup().findLedgerVoucher(
                remainingOpenAmounts.getCompany(_underOverIndex),
                settlementPair.findNumberSequenceCodeByCompany(remainingOpenAmounts.getCompany(_underOverIndex)));

            ledgerVoucher.lastVoucher(currentCashDiscount.getVoucher());
            ledgerVoucher.lastTransDate(settlementPair.getTransactionDate());
            Debug::assert(currentCashDiscount.getSettlementGroup() != 0);
            settlementGroupPlaceHolder = currentCashDiscount.getSettlementGroup();

            isCashDiscountAdjustedForOverPayment = true;

            // create cash discount trans for the additional amount being settled
            // The under/over amount will be treated as an adjustment to the cash discount so use the postDiscTrans() method to
            // create the transactions.
            postCashDiscountInSummary = true;
            discLedgerDimension = SettlementUtility::determineCashDiscountLedgerDimension(
                this.parmModule(),
                discTrans,
                discTransOpen,
                currentCashDiscount.getDiscountCode());

            taxOnCashDiscAmount = this.taxCashDisc(
                discTrans,
                settleAmountCurDisc,
                discLedgerDimension,
                exchRate.getDebitCurToDebitMstCombined(),
                exchRate.getDebitCurToReporting());

            this.postDiscTrans(settleAmountCurDisc,
                settleAmountMstDisc,
                settleAmountReportingDisc,
                discTrans,
                discTransOpen,
                underOverTrans,
                exchRate.getDebitCurToDebitMstCombined(),
                exchRate.getDebitCurToReporting(),
                discLedgerDimension,
                taxOnCashDiscAmount,
                0.0,
                discTransSettleDistController,
                ledgerVoucher,
                true);

            if (underOverTrans.Prepayment)
            {
                if (TaxReversePrePayment::existPrePaymentTax(underOverTrans.TransDate, underOverTrans.Voucher))
                {
                    // if tax transaction exist for prepayment, reverse tax for the overpayment amount
                    prePaymentReversal = CustVendPrePaymentReversal::newCustVendTrans(underOverTrans,
                        custVendTransSettlement,
                        currentCashDiscount.getSettlementGroup());
                    // <GEEU>
                    if (usePostingLog)
                    {
                        settlementOffset = custVendTransSettlement.findSettlementForCustVendTrans(underOverTrans, remainingOpenAmounts.getGroup(currentDiscIndex), underOverTrans.OffsetRecId);
                        underOverTransOffset = this.findCustVendTransByRecID(settlementOffset.OffsetRecId, underOverTransOffset);

                        prePaymentReversal.reversePrePaymentTax(underOverTrans, ledgerVoucher, settleAmountCurOver, settleAmountMstOver, settleAmountReportingOver, underOverTransOffset);
                    }
                    else
                    {
                        // </GEEU>
                        prePaymentReversal.reversePrePaymentTax(underOverTrans, ledgerVoucher, settleAmountCurOver);
                        // <GEEU>
                    }
                    // </GEEU>
                }
            }

            // check for unrealized exchange adjustment for the under/over transaction
            // <GEERU>
            if (exchRateDiffCalcType == ExchRateDiffCalcType_W::Standard)
            {
                // </GEERU>
                if (unrealizedExchAdjAmount != 0.0 || unrealizedReportingExchAdjAmount != 0.0)
                {
                    this.updateExchAdjAmountOnTrans(
                        0.0,
                        unrealizedExchAdjAmount,
                        0.0,
                        unrealizedReportingExchAdjAmount,
                        underOverTrans,
                        underOverTransOpen);

                    this.postExchRateDiff(
                        unrealizedExchAdjAmount,
                        unrealizedReportingExchAdjAmount,
                        underOverTrans,
                        underOverTransSettleDistController,
                        true,
                        ledgerVoucher);

                    this.createSettlementToReverseUnrealExchAdj(
                        unrealizedExchAdjAmount,
                        unrealizedReportingExchAdjAmount,
                        underOverTrans,
                        underOverTransOpen,
                        currentCashDiscount.getVoucher());
                }
                // <GEERU>
            }
            else
            {
                custVendExchAdjustment = CustVendExchAdjustment_W::newFromSettlement(this);
                custVendExchAdjustment.setCustVendTransSettlement(custVendTransSettlement);
                custVendExchAdjustment.setSettlementGroupPlaceHolder(settlementGroupPlaceHolder);
                custVendExchAdjustment.processRealizedExchAdj(
                    -(settleAmountMstDisc - settleAmountMstOver),
                    -(settleAmountReportingDisc - settleAmountReportingOver),
                    discTrans,
                    discTrans,
                    underOverTrans,
                    discTransOpen,
                    underOverTransOpen,
                    -settleAmountCurOver,
                    0,
                    0,
                    0,
                    '',
                    '',
                    1,
                    0,
                    0,
                    settlementPair.getTransactionDate(),
                    false,
                    false);
            }
            // </GEERU>

            // update the trans and trans open records
            this.reverseAmounts(underOverTrans);

            this.updateTransOpen(underOverTrans, underOverTransOpen);
            underOverTrans.update();

            this.reverseAmounts(underOverTrans);

            // update the discTrans, this needs to be updated because of the
            // realized exchange adjustment, no fields are changed on the discTransOpen
            // so this is not updated.
            this.reverseAmounts(discTrans);

            discTrans.update();

            this.reverseAmounts(discTrans);

            custVendTransSettlementControl.ins(underOverTrans, true);

            // Update fields on the the under/over transaction settlement record
            settlementToUpdate = custVendTransSettlement.findSettlementForCustVendTrans(underOverTrans, currentCashDiscount.getSettlementGroup(), discTrans.RecId);
            if (settlementToUpdate.TransRecId != 0)
            {
                settlementToUpdate.SettleAmountCur += this.amount(settleAmountCurOver);
                settlementToUpdate.SettleAmountMST += this.amount(settleAmountMstOver);
                settlementToUpdate.SettleAmountReporting += this.amount(settleAmountReportingOver);

                custVendTransSettlement.modifyTransAndSettlement(underOverTrans, settlementToUpdate, currentCashDiscount.getSettlementGroup(), discTrans.RecId, false, true);
            }

            // update fields on the discount transaction settlement record
            settlementToUpdate = custVendTransSettlement.findSettlementForCustVendTrans(discTrans, currentCashDiscount.getSettlementGroup(), underOverTrans.RecId);
            if (settlementToUpdate.TransRecId != 0)
            {
                settlementToUpdate.UtilizedCashDisc += this.amount(settleAmountCurDisc);

                custVendTransSettlement.modifyTransAndSettlement(discTrans, settlementToUpdate, currentCashDiscount.getSettlementGroup(), underOverTrans.RecId, false, true);
            }

            this.addTransToTaxSortedList(discTrans.RecId,
                discTrans.Voucher,
                discTrans.company(),
                settlementPair.getTransactionDate(),
                0,
                settleAmountMstDisc,
                underOverTrans.RecId,
                underOverTrans.company(),
                settleAmountMstOver,
                100.0,
                ledgerVoucher.lastVoucher(),
                ledgerVoucher.lastVoucher(),
                settlementGroupPlaceHolder);

            this.updateTransactionProject(discTrans, _origRemainDebitCur, settleAmountCurDisc);

            overUnderRemaining -= settleAmountMstOver;

            // adjust amount in the map
            remainingOpenAmounts.adjustAmountForCompany(remainingOpenAmounts.getCompany(_underOverIndex), -settleAmountMstOver);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTaxChargeIntercompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method is used to process the set containing a collection of <c>TaxChargeInterCompany</c> objects.
    ///     It creates two transactions, one for due to/from and the other for the expense.
    /// </summary>
    /// <param name="_taxChargeIntercompanySet">
    ///     Set containing a collection of <c>TaxChargeInterCompany</c> objects that contain the due to/from and expense account information.
    ///     This set only contains data if the tax company is different then the expense/charge company.
    /// </param>
    /// <param name="_accountNum">
    ///     Customer or vendor account number used on the invoice or payment.
    /// </param>
    private void processTaxChargeIntercompany(Set _taxChargeIntercompanySet, CustVendAC _accountNum)
    {
        SetEnumerator           taxChargeIntercompanySetEnum;
        TaxChargeIntercompany   taxChargeIntercompany;
        CurrencyExchangeHelper  currencyHelper;
        AmountMST               chargeAmountMst;
        AmountMSTSecondary      chargeAmountReporting;
        LedgerVoucher           ledgerVoucherLocal;
        Voucher                 taxVoucher;
        DataAreaId              taxCompany = curext();

        if (_taxChargeIntercompanySet && !_taxChargeIntercompanySet.empty())
        {
            taxChargeIntercompanySetEnum = _taxChargeIntercompanySet.getEnumerator();
            taxVoucher = settlementPair.findOrCreateLedgerVoucherByCompany(curext()).lastVoucher();

            while (taxChargeIntercompanySetEnum.moveNext())
            {
                taxChargeIntercompany = taxChargeIntercompanySetEnum.current();

                changecompany(taxChargeIntercompany.parmExpenseCompany())
                {
                    currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),  settlementPair.getTransactionDate());
                    chargeAmountMst = currencyHelper.calculateTransactionToAccounting(taxChargeIntercompany.parmCurrencyCode(), taxChargeIntercompany.parmChargeAmount(), true);
                    chargeAmountReporting = currencyHelper.calculateTransactionCurrencyToReportingCurrency(taxChargeIntercompany.parmCurrencyCode(), taxChargeIntercompany.parmChargeAmount());

                    ledgerVoucherLocal = settlementPair.findOrCreateLedgerVoucherByCompany(curext());

                    this.createLedgerVoucherTransObject(ledgerVoucherLocal,
                                        LedgerPostingType::CrossCompanySettlement,
                                        taxChargeIntercompany.parmDueToDueFromLedgerDimension(),
                                        taxChargeIntercompany.parmCurrencyCode(),
                                        -taxChargeIntercompany.parmChargeAmount(),
                                        -chargeAmountMst,
                                        -chargeAmountReporting);

                    this.createLedgerVoucherTransObject(ledgerVoucherLocal,
                                        LedgerPostingType::Tax,
                                        taxChargeIntercompany.parmExpenseLedgerDimension(),
                                        taxChargeIntercompany.parmCurrencyCode(),
                                        taxChargeIntercompany.parmChargeAmount(),
                                        chargeAmountMst,
                                        chargeAmountReporting);

                    this.insertSettlementOffsetVoucher(taxCompany, _accountNum, taxVoucher, curext(), ledgerVoucherLocal.lastVoucher(), CustVendSettlementOffsetVoucherType::Tax);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTaxOnOverPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the tax on an over-payment.
    /// </summary>
    /// <param name="_overUnderAmountMst">
    /// The amount of the over-payment in the monetary standard currency (MST).
    /// </param>
    /// <param name="_settledInvoicesList">
    /// A record sorted list of the debit transactions that were settled.
    /// </param>
    /// <param name="_overPaymTrans">
    /// The transaction with the over-payment.
    /// </param>
    /// <param name="_overPaymTransDistributionController">
    /// The <c>CustVendTransSettleDistController</c> instance that is associated with the <paramref
    /// name="_overPaymTrans" /> record.
    /// </param>
    /// <returns>
    /// A container that has the tax amount in MST currency and tax amount in transaction currency.
    /// </returns>
    protected container processTaxOnOverPayment(
        AmountMST _overUnderAmountMst,
        RecordSortedList _settledInvoicesList,
        CustVendTrans _overPaymTrans,
        CustVendTransSettleDistController _overPaymTransDistributionController)
    {
        CurrencyExchangeHelper currencyHelper;
        TmpSettleOverUnderReverseTax tmpSettleOverUnderReverseTax;
        TaxOverUnderPayment taxOverUnderPayment;
        boolean recordExists;
        LedgerVoucher ledgerVoucher;
        CustVendTrans invoiceTrans;
        Voucher overPaymentVoucher;
        TransDate overPaymentTransDate;
        AmountMST paymTotalTaxAmountMst;
        AmountCur paymTotalTaxAmountCur;
        AmountMST paymTaxAmountMst;
        AmountMST invoiceTaxAmountMst;
        AmountCur invoiceTaxAmountCur;
        AmountMSTSecondary invoiceTaxAmountReporting;
        AmountCur paymTaxAmountCur;
        AmountMSTSecondary paymTaxAmountReporting;

        DataAreaId      taxOnOverPaymCompany;
        Set             companyVoucherDateSet = new Set(Types::Container);
        SetEnumerator   companyVoucherDateSetEnum;
        Voucher         invoiceVoucherLocal;
        TransDate       invoiceTransDateLocal;
        AmountMST       overUnderAmountMST;

        // make sure this is an overpayment
        Debug::assert(_overUnderAmountMST <= 0);
        Debug::assert(_overPaymTrans.company() == curext());

        if (this.processTaxOnOverPaymentCalcPercent(_overUnderAmountMST, _settledInvoicesList, _overPaymTrans) == false)
        {
            return [0, 0];
        }

        // if there is a current voucher for the payment company save this number and date
        ledgerVoucher = settlementPair.getLedgerVoucherGroup().findLedgerVoucher(_overPaymTrans.company(), settlementPair.findNumberSequenceCodeByCompany(_overPaymTrans.company()));
        if (ledgerVoucher != null)
        {
            overPaymentTransDate = ledgerVoucher.lastTransDate();
            overPaymentVoucher = ledgerVoucher.lastVoucher();
        }

        // Post the tax amount for each invoice
        recordExists = _settledInvoicesList.first(tmpSettleOverUnderReverseTax);
        while (recordExists)
        {
            if (tmpSettleOverUnderReverseTax.PaymRefRecId == _overPaymTrans.RecId &&
                tmpSettleOverUnderReverseTax.PaymCompany == _overPaymTrans.company())
            {
                invoiceTrans = null;

                changecompany(tmpSettleOverUnderReverseTax.RefCompany)
                {
                    invoiceTrans = this.initCustVendTransBuffer();

                    select firstonly invoiceTrans
                        where invoiceTrans.RecId == tmpSettleOverUnderReverseTax.RefRecId;

                    [invoiceVoucherLocal, invoiceTransDateLocal] = this.approvalVoucherDate(invoiceTrans);
                }

                // Find all related companies, vouchers and dates.
                companyVoucherDateSet = this.getTaxCompanyVoucherDate(tmpSettleOverUnderReverseTax.RefCompany, invoiceVoucherLocal, invoiceTransDateLocal);
                companyVoucherDateSetEnum = companyVoucherDateSet.getEnumerator();

                while (companyVoucherDateSetEnum.moveNext())
                {
                    ledgerVoucher = null;

                    [taxOnOverPaymCompany, invoiceVoucherLocal, invoiceTransDateLocal] = companyVoucherDateSetEnum.current();

                    changecompany(taxOnOverPaymCompany)
                    {
                        // calculate overUnderAmountMST in the tax company MST
                        currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(),  settlementPair.getTransactionDate());
                        overUnderAmountMST = currencyHelper.calculateTransactionToAccounting(Ledger::accountingCurrency(CompanyInfo::findDataArea(_overPaymTrans.company()).RecId), _overUnderAmountMST, true);
                        taxOverUnderPayment = new TaxOverUnderPayment(
                            overUnderAmountMST,
                            _settledInvoicesList);
                        taxOverUnderPayment.parmOperationLedgerDimension(SettlementUtility::cashDiscountSystemLedgerDimension(this.parmModule()));
                        taxOverUnderPayment.parmRelatedLedgerVoucher(this.parmRelatedLedgerVoucher());
                        taxOverUnderPayment.setReverseTableId(_overPaymTrans.TableId);
                        taxOverUnderPayment.setReverseRecId(_overPaymTrans.RecId);

                        invoiceTaxAmountMst = taxOverUnderPayment.calcAndInsertTaxes(
                                            invoiceVoucherLocal,
                                            invoiceTransDateLocal,
                                            tmpSettleOverUnderReverseTax.Percent,
                                            tmpSettleOverUnderReverseTax.RefRecId,
                                            tmpSettleOverUnderReverseTax.TransDate);

                        if (taxOverUnderPayment.getIsTaxTransWorkAdded())
                        {
                            // if there isn't an existing ledger for the transaction, create a new ledger voucher.
                            ledgerVoucher = settlementPair.findOrCreateLedgerVoucherByCompany(taxOnOverPaymCompany);

                            // check if this is the voucher number that should be used for over payment transaction
                            if (tmpSettleOverUnderReverseTax.RefRecId == _overPaymTrans.OffsetRecId && taxOnOverPaymCompany == _overPaymTrans.company())
                            {
                                overPaymentTransDate = ledgerVoucher.lastTransDate();
                                overPaymentVoucher = ledgerVoucher.lastVoucher();
                            }
                            // Create the TaxTrans records and the Ledger transaction records for the tax account
                            taxOverUnderPayment.parmVoucher(ledgerVoucher.lastVoucher());

                            if (taxOnOverPaymCompany != _overPaymTrans.company() && invoiceTaxAmountMst != 0)
                            {
                                if (Ledger::reportingCurrency() != '')
                                {
                                    // tax and payment in different companies, use exchange rate on settlement date
                                    ExchangeRateHelper helper = ExchangeRateHelper::newExchangeDate(Ledger::current(), _overPaymTrans.CurrencyCode, settlementPair.getTransactionDate());
                                    helper.parmToCurrency(Ledger::reportingCurrency());
                                    helper.parmExchangeRateTypeRecId(Ledger::reportingCurrencyExchangeRateType());
                                    taxOverUnderPayment.parmSettlementReportingCrossRate(helper.getCrossRate());
                                }
                            }
                            else
                            {
                                // tax and payment in same company, use exchange rate from payment
                                taxOverUnderPayment.parmSettlementReportingCrossRate(_overPaymTrans.getReportingCombinedExchangeRate());
                            }
                            taxOverUnderPayment.saveAndPost(LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher));

                            taxChargeIntercompanySet = taxOverUnderPayment.getTaxChargeIntercompanySet();
                            this.processTaxChargeIntercompany(taxChargeIntercompanySet, _overPaymTrans.AccountNum);

                            // If  tax company and payment company are different, create due to/due from transaction in the tax company.
                            if (taxOnOverPaymCompany != _overPaymTrans.company() && invoiceTaxAmountMst != 0)
                            {
                                // convert tax mst amount to tax reporting amount using exchange rate on settlement date
                                currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(),  settlementPair.getTransactionDate());
                                // Keeping the transaction currency the same as accounting because all the tax transactions will be posted using the accounting currency.
                                invoiceTaxAmountCur = invoiceTaxAmountMst;
                                invoiceTaxAmountReporting = currencyHelper.calculateTransactionCurrencyToReportingCurrency(Ledger::accountingCurrency(), invoiceTaxAmountCur);

                                this.createAndPostDueToDueFromTaxExpense(taxOnOverPaymCompany, _overPaymTrans.company(), Ledger::accountingCurrency(), -invoiceTaxAmountCur, -invoiceTaxAmountMst, -invoiceTaxAmountReporting);

                                // Keep track of the inter company vouchers in order to reverse them when the settlement is reversed.
                                this.insertSettlementOffsetVoucher(_overPaymTrans.company(),
                                                                _overPaymTrans.AccountNum,
                                                                settlementPair.findOrCreateLedgerVoucherByCompany(_overPaymTrans.company()).lastVoucher(),
                                                                taxOnOverPaymCompany,
                                                                settlementPair.findOrCreateLedgerVoucherByCompany(taxOnOverPaymCompany).lastVoucher(),
                                                                CustVendSettlementOffsetVoucherType::Tax);
                            }
                            else
                            {
                                // convert over payment amount for invoice from mst currency to transaction currency using exchange rate on payment
                                currencyHelper = CurrencyExchangeHelper::newLedger(Ledger::current());
                                currencyHelper.parmExchangeRate1(_overPaymTrans.ExchRate);
                                currencyHelper.parmExchangeRate2(_overPaymTrans.ExchRateSecond);
                                _overPaymTrans.setExchangeHelperReportingExchRate(currencyHelper);

                                invoiceTaxAmountCur = currencyHelper.calculateAccountingToTransaction(_overPaymTrans.CurrencyCode, invoiceTaxAmountMst, true);
                                invoiceTaxAmountReporting = currencyHelper.calculateTransactionCurrencyToReportingCurrency(_overPaymTrans.CurrencyCode, invoiceTaxAmountCur);

                                // Payment and tax in same company so adjust the payment transaction AR or AP account
                                this.postTaxOverUnderPayment(
                                    -invoiceTaxAmountCur,
                                    -invoiceTaxAmountMst,
                                    -invoiceTaxAmountReporting,
                                    _overPaymTrans,
                                    _overPaymTransDistributionController,
                                    invoiceTrans,
                                    ledgerVoucher,
                                    tmpSettleOverUnderReverseTax.SettlementGroup);
                            }
                        }
                    }

                    // calculate the amount in payment mst
                    currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(),  settlementPair.getTransactionDate());
                    paymTaxAmountMst = currencyHelper.calculateTransactionToAccounting(Ledger::accountingCurrency(CompanyInfo::findDataArea(taxOnOverPaymCompany).RecId), invoiceTaxAmountMst, true);

                    // convert the paym amount mst to payment amount cur, use exchange rate on payment transaction
                    paymTaxAmountCur = currencyHelper.calculateAccountingToTransaction(_overPaymTrans.CurrencyCode, paymTaxAmountMst, true);
                    paymTaxAmountReporting = currencyHelper.calculateTransactionCurrencyToReportingCurrency(_overPaymTrans.CurrencyCode, paymTaxAmountCur);

                    // Done processing the tax now create the due/to from for payment if the tax
                    // and payment are in different companies.
                    if (taxOnOverPaymCompany != _overPaymTrans.company() && invoiceTaxAmountMst != 0)
                    {
                        ledgerVoucher = null;

                        // if there isn't an existing ledger for the transaction, create a new ledger voucher number
                        ledgerVoucher = settlementPair.findOrCreateLedgerVoucherByCompany(curext());

                        // adjust the payments AR or AP account
                        this.postTaxOverUnderPayment(
                            -paymTaxAmountCur,
                            -paymTaxAmountMst,
                            -paymTaxAmountReporting,
                            _overPaymTrans,
                            _overPaymTransDistributionController,
                            invoiceTrans,
                            ledgerVoucher,
                            tmpSettleOverUnderReverseTax.SettlementGroup);

                        // ledger transaction for due to/from account
                        this.createAndPostDueToDueFromTaxExpense(_overPaymTrans.company(), taxOnOverPaymCompany, _overPaymTrans.CurrencyCode, paymTaxAmountCur, paymTaxAmountMst, paymTaxAmountReporting);
                    }

                    paymTotalTaxAmountMst += paymTaxAmountMst;
                    paymTotalTaxAmountCur += paymTaxAmountCur;
                    invoiceTaxAmountMst = 0;
                }
            }
            recordExists = _settledInvoicesList.next(tmpSettleOverUnderReverseTax);
        }

        // if there is a current voucher for the payment company save this number and date
        ledgerVoucher = settlementPair.getLedgerVoucherGroup().findLedgerVoucher(_overPaymTrans.company(), settlementPair.findNumberSequenceCodeByCompany(_overPaymTrans.company()));
        if (ledgerVoucher != null && overPaymentVoucher != "")
        {
            ledgerVoucher.lastTransDate(overPaymentTransDate);
            ledgerVoucher.lastVoucher(overPaymentVoucher);
        }

        return [paymTotalTaxAmountMst, paymTotalTaxAmountCur];
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTaxOnOverPaymentCalcPercent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the percent of tax to be adjusted for an over payment.
    /// </summary>
    /// <param name="_overUnderAmountMst">
    ///    The amount of the over payment in the monetary standard currency (MST).
    /// </param>
    /// <param name="_settledInvoicesList">
    ///    A record sorted list of the debit transactions that were settled.
    /// </param>
    /// <param name="_overPaymTrans">
    ///    The transaction with the over payment.
    /// </param>
    /// <returns>
    ///    true if there is tax to calculate; otherwise, false.
    /// </returns>
    protected boolean processTaxOnOverPaymentCalcPercent(
        AmountMST _overUnderAmountMst,
        RecordSortedList _settledInvoicesList,
        CustVendTrans _overPaymTrans)
    {
        CurrencyCode paymCompanyCurrency;
        TmpSettleOverUnderReverseTax tmpSettleOverUnderReverseTax;
        boolean recordExists;
        Counter countOfRecordInList;
        AmountMST totalAmountMst;
        AmountMST remainOverUnderAmount;
        AmountMST invoicePortionOfOverUnderAmount;

        // calculate the total amount of all the invoices settled against the payment in
        // the payment company currency
        recordExists = _settledInvoicesList.first(tmpSettleOverUnderReverseTax);
        while (recordExists)
        {
            if (tmpSettleOverUnderReverseTax.PaymRefRecId == _overPaymTrans.RecId &&
                tmpSettleOverUnderReverseTax.PaymCompany == _overPaymTrans.company())
            {
                totalAmountMst += tmpSettleOverUnderReverseTax.PaymSettleAmountMst;
                countOfRecordInList++;
            }
            recordExists = _settledInvoicesList.next(tmpSettleOverUnderReverseTax);
        }

        if (totalAmountMst == 0)
        {
            return false;
        }

        _settledInvoicesList.first(tmpSettleOverUnderReverseTax);
        paymCompanyCurrency = CompanyInfoHelper::standardCurrency();

        // Within this loop all amounts are in the payment company Mst currency
        for (remainOverUnderAmount = _overUnderAmountMst; countOfRecordInList; remainOverUnderAmount -= invoicePortionOfOverUnderAmount)
        {
            if (tmpSettleOverUnderReverseTax.PaymRefRecId == _overPaymTrans.RecId &&
                tmpSettleOverUnderReverseTax.PaymCompany == _overPaymTrans.company())
            {
                countOfRecordInList--;
                if (countOfRecordInList)
                {
                    // Calculate the over payment that applies to current invocie
                    tmpSettleOverUnderReverseTax.OverPayPartAmountMST = (tmpSettleOverUnderReverseTax.PaymSettleAmountMst / totalAmountMst) * _overUnderAmountMst;
                    tmpSettleOverUnderReverseTax.OverPayPartAmountMST = CurrencyExchange::round(tmpSettleOverUnderReverseTax.OverPayPartAmountMST, paymCompanyCurrency);
                }
                else
                {
                    // Because this is the last record the over payment for current invoice is the remaining amouunt.
                    tmpSettleOverUnderReverseTax.OverPayPartAmountMST = remainOverUnderAmount;
                }

                invoicePortionOfOverUnderAmount = tmpSettleOverUnderReverseTax.OverPayPartAmountMST;

                if (tmpSettleOverUnderReverseTax.PaymSettleAmountMst)
                {
                    // calculate the percent that the over amount applied to this invoice is of the amountMst of the invoice
                    tmpSettleOverUnderReverseTax.Percent =
                        (tmpSettleOverUnderReverseTax.OverPayPartAmountMST / (-tmpSettleOverUnderReverseTax.AmountMST / (tmpSettleOverUnderReverseTax.PaymToInvoiceExchRate / 100))) * 100;
                }

                _settledInvoicesList.ins(tmpSettleOverUnderReverseTax, true);
                _settledInvoicesList.next(tmpSettleOverUnderReverseTax);
            }
            else
            {
                invoicePortionOfOverUnderAmount = 0;
                _settledInvoicesList.next(tmpSettleOverUnderReverseTax);
            }
        }

        if (totalAmountMst == 0)
        {
            return false;
        }
        else
        {
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTaxOnUnderPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the tax on an under-payment.
    /// </summary>
    /// <param name="_underAmountMst">
    /// Amount of the under-payment in the monetary standard currency (MST).
    /// </param>
    /// <param name="_underPaymTrans">
    /// The transaction with the under-payment.
    /// </param>
    /// <param name="_underPaymTransDistributionController">
    /// The <c>CustVendTransSettleDistController</c> instance that is associated with the <paramref
    /// name="_underPaymTrans" /> record.
    /// </param>
    /// <param name="_settlementGroupPlaceHolder">
    /// The settlement group of the transaction.
    /// </param>
    /// <returns>
    /// A container that has the tax amount in MST currency and tax amount in transaction currency.
    /// </returns>
    protected container processTaxOnUnderPayment(
        AmountMST _underAmountMst,
        CustVendTrans _underPaymTrans,
        CustVendTransSettleDistController _underPaymTransDistributionController,
        Counter _settlementGroupPlaceHolder)
    {
        AmountMST taxAmountMst;
        AmountCur taxAmountCur;
        AmountMSTSecondary taxAmountReporting;
        Percent underPercent;
        TaxOverUnderPayment taxOverUnderPayment;
        CurrencyExchangeHelper currencyHelper;
        LedgerVoucher ledgerVoucher;
        CustVendTrans offsetTrans;
        container companyContainer;
        DataAreaId          taxOnUnderPaymCompany;
        Set                 companyVoucherDateSet = new Set(Types::Container);
        SetEnumerator       companyVoucherDateSetEnum;
        Voucher             invoiceVoucherLocal;
        TransDate           invoiceTransDateLocal;
        AmountMST           paymTotalTaxAmountMst;
        AmountCur           paymTotalTaxAmountCur;
        AmountMST           paymTaxAmountMst;
        AmountCur           paymTaxAmountCur;
        AmountMSTSecondary  paymTaxAmountReporting;
        AmountMST           underAmountMST;

        // make sure this is an under payment
        Debug::assert(_underAmountMST >= 0);
        Debug::assert(_underPaymTrans.company() == curext());

        // check if company is setup for over/under trax
        if (TaxParameters::find().TaxOnOverpayment == false)
        {
            return [0, 0];
        }

        // calculate the percent used to adjust tax
        underPercent = (-_underAmountMST / _underPaymTrans.AmountMST) * 100;

        offsetTrans = this.initCustVendTransBuffer();

        if (_underPaymTrans.LastSettleCompany != '')
        {
            companyContainer += _underPaymTrans.LastSettleCompany;
            select firstonly crossCompany:companyContainer offsetTrans
            where offsetTrans.RecId == _underPaymTrans.OffsetRecId;
        }

        [invoiceVoucherLocal, invoiceTransDateLocal] = this.approvalVoucherDate(_underPaymTrans);

        // Find all related companies, vouchers and dates.
        companyVoucherDateSet = this.getTaxCompanyVoucherDate(_underPaymTrans.company(), invoiceVoucherLocal, invoiceTransDateLocal);

        companyVoucherDateSetEnum = companyVoucherDateSet.getEnumerator();

        while (companyVoucherDateSetEnum.moveNext())
        {
            [taxOnUnderPaymCompany, invoiceVoucherLocal, invoiceTransDateLocal] = companyVoucherDateSetEnum.current();

            changecompany(taxOnUnderPaymCompany)
            {
                // calculate underAmountMST in the tax company MST
                currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(),  settlementPair.getTransactionDate());
                underAmountMST = currencyHelper.calculateTransactionToAccounting(Ledger::accountingCurrency(CompanyInfo::findDataArea(_underPaymTrans.company()).RecId), _underAmountMST, true);
                // call tax methods to get amount of tax
                taxOverUnderPayment = new TaxOverUnderPayment(
                                        underAmountMST,
                                        rslTmpOverUnderReverseTax);

                taxOverUnderPayment.parmRelatedLedgerVoucher(this.parmRelatedLedgerVoucher());
                taxOverUnderPayment.parmOperationLedgerDimension(SettlementUtility::cashDiscountSystemLedgerDimension(this.parmModule()));
                taxOverUnderPayment.setReverseTableId(_underPaymTrans.TableId);
                taxOverUnderPayment.setReverseRecId(_underPaymTrans.RecId);

                taxAmountMst = taxOverUnderPayment.calcAndInsertTaxes(
                                    invoiceVoucherLocal,
                                    invoiceTransDateLocal,
                                    underPercent,
                                    _underPaymTrans.RecId,
                                    settlementPair.getTransactionDate());

                if (taxOverUnderPayment.getIsTaxTransWorkAdded())
                {
                    // if there isn't an existing ledger for the transaction, create a new ledger voucher.
                    ledgerVoucher = settlementPair.findOrCreateLedgerVoucherByCompany(taxOnUnderPaymCompany);

                    // post the tax
                    taxOverUnderPayment.parmVoucher(ledgerVoucher.lastVoucher());

                    if (taxOnUnderPaymCompany != _underPaymTrans.company() && taxAmountMst != 0)
                    {
                        if (Ledger::reportingCurrency() != '')
                        {
                            // tax and invoice in different companies, use exchange rate on settlement date
                            ExchangeRateHelper helper = ExchangeRateHelper::newExchangeDate(Ledger::current(), _underPaymTrans.CurrencyCode, settlementPair.getTransactionDate());
                            helper.parmToCurrency(Ledger::reportingCurrency());
                            helper.parmExchangeRateTypeRecId(Ledger::reportingCurrencyExchangeRateType());
                            taxOverUnderPayment.parmSettlementReportingCrossRate(helper.getCrossRate());
                        }
                    }
                    else
                    {
                        // tax and invoice in same company, use exchange rate from invoice.
                        taxOverUnderPayment.parmSettlementReportingCrossRate(_underPaymTrans.getReportingCombinedExchangeRate());
                    }

                    taxOverUnderPayment.saveAndPost(LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher));

                    taxChargeIntercompanySet = taxOverUnderPayment.getTaxChargeIntercompanySet();
                    this.processTaxChargeIntercompany(taxChargeIntercompanySet, _underPaymTrans.AccountNum);

                    // If  tax company and invoice company are different, create due to or from transaction in the tax company.
                    if (taxOnUnderPaymCompany != _underPaymTrans.company() && taxAmountMst != 0)
                    {
                        // convert tax mst amount to tax cur using exchange rate on settlement date date
                        currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(),  settlementPair.getTransactionDate());

                        // Keeping the transaction currency the same as accounting because all the tax transactions will be posted using the accounting currency.
                        taxAmountCur = taxAmountMst;
                        taxAmountReporting = currencyHelper.calculateTransactionCurrencyToReportingCurrency(Ledger::accountingCurrency(), taxAmountCur);

                        this.createAndPostDueToDueFromTaxExpense(taxOnUnderPaymCompany, _underPaymTrans.company(), Ledger::accountingCurrency(), -taxAmountCur, -taxAmountMst, -taxAmountReporting);

                        // Keep track of the inter company vouchers in order to reverse them when the settlement is reversed.
                        this.insertSettlementOffsetVoucher(_underPaymTrans.company(),
                                                        _underPaymTrans.AccountNum,
                                                        settlementPair.findOrCreateLedgerVoucherByCompany(_underPaymTrans.company()).lastVoucher(),
                                                        taxOnUnderPaymCompany,
                                                        settlementPair.findOrCreateLedgerVoucherByCompany(taxOnUnderPaymCompany).lastVoucher(),
                                                        CustVendSettlementOffsetVoucherType::Tax);
                    }
                    else
                    {
                        // Convert tax amount to under payment transaction currency
                        currencyHelper = CurrencyExchangeHelper::newLedger(Ledger::current());
                        currencyHelper.parmExchangeRate1(_underPaymTrans.ExchRate);
                        currencyHelper.parmExchangeRate2(_underPaymTrans.ExchRateSecond);
                        _underPaymTrans.setExchangeHelperReportingExchRate(currencyHelper);

                        taxAmountCur = currencyHelper.calculateAccountingToTransaction(_underPaymTrans.CurrencyCode, taxAmountMst, true);
                        taxAmountReporting = currencyHelper.calculateTransactionCurrencyToReportingCurrency(_underPaymTrans.CurrencyCode, taxAmountCur);

                        // Payment and tax in same company so adjust the payment transaction AR or AP account
                        this.postTaxOverUnderPayment(
                        -taxAmountCur,
                        -taxAmountMst,
                        -taxAmountReporting,
                        _underPaymTrans,
                        _underPaymTransDistributionController,
                        offsetTrans,
                        ledgerVoucher,
                        _settlementGroupPlaceHolder);
                    }
                }
            }

            // calculate the amount in invoice mst
            currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(),  settlementPair.getTransactionDate());
            paymTaxAmountMst = currencyHelper.calculateTransactionToAccounting(Ledger::accountingCurrency(CompanyInfo::findDataArea(taxOnUnderPaymCompany).RecId), taxAmountMst, true);

            // convert the paym amount mst to payment amount cur, use exchange rate on invoice transaction
            paymTaxAmountCur = currencyHelper.calculateAccountingToTransaction(_underPaymTrans.CurrencyCode, paymTaxAmountMst, true);
            paymTaxAmountReporting = currencyHelper.calculateTransactionCurrencyToReportingCurrency(_underPaymTrans.CurrencyCode, paymTaxAmountCur);

            // Done processing the tax now create the due/to from for under payment / invoice if the tax
            // and invoice are in different companies.
            if (taxOnUnderPaymCompany != _underPaymTrans.company() && taxAmountMst != 0)
            {
                ledgerVoucher = null;

                // if there isn't an existing ledger for the transaction, create a new ledger voucher number
                ledgerVoucher = settlementPair.findOrCreateLedgerVoucherByCompany(curext());

                // adjust the payments AR or AP account
                this.postTaxOverUnderPayment(
                    -paymTaxAmountCur,
                    -paymTaxAmountMst,
                    -paymTaxAmountReporting,
                    _underPaymTrans,
                    _underPaymTransDistributionController,
                    offsetTrans,
                    ledgerVoucher,
                    _settlementGroupPlaceHolder);

                // Create and post transaction for due to/ from account in invoice company.
                this.createAndPostDueToDueFromTaxExpense(_underPaymTrans.company(), taxOnUnderPaymCompany, _underPaymTrans.CurrencyCode, paymTaxAmountCur, paymTaxAmountMst, paymTaxAmountReporting);
            }
            paymTotalTaxAmountMst += paymTaxAmountMst;
            paymTotalTaxAmountCur += paymTaxAmountCur;
            taxAmountMst = 0;
        }

        return [paymTotalTaxAmountMst, paymTotalTaxAmountCur];
    }

]]></Source>
			</Method>
			<Method>
				<Name>processVatTaxAgentAmounts_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the tax agent amounts and updates the transaction records.
    /// </summary>
    /// <param name="_remainingSpecTransRecords">
    /// The number of <c>SpecTrans</c> table records not yet processed.
    /// </param>
    /// <returns>
    /// Container with tax agent amounts.
    /// </returns>
    protected container processVatTaxAgentAmounts_RU(NumberOfRecords _remainingSpecTransRecords)
    {
        VATTaxAgentPaymentAmounts_RU paymentAmounts;
        AmountMST                    amountAccountingDebit;
        AmountMST                    amountAccountingCredit;
        AmountCur                    settleAmountTransactionDebit;
        AmountCur                    amountTransactionDebit;
        AmountCur                    amountTransactionCredit;
        AmountMST                    amountReportingDebit;
        AmountMST                    amountReportingCredit;

        container calcAndUpdate(
            CustVendTrans      _custVendTrans,
            CustVendTransOpen  _custVendTransOpen,
            AmountCur          _amountTransaction,
            AmountMST          _amountAccounting,
            AmountMSTSecondary _amountReporting,
            CustVendTrans      _custVendTransOffset)
        {
            VendInvoiceJour              vendInvoiceJour;
            VendInvoiceTrans             vendInvoiceTrans;

            if (_custVendTrans.TableId != tableNum(VendTrans) ||
                ! _custVendTrans.Invoice                      ||
                ! VendTable::find(_custVendTrans.AccountNum).vatTaxAgent_RU)
            {
                return [0, 0, 0];
            }

            vendInvoiceJour = VendInvoiceJour::findFromVendTrans(
                _custVendTrans.Invoice,
                _custVendTrans.TransDate,
                _custVendTrans.AccountNum,
                false,
                _custVendTrans.Voucher);

            select firstonly TaxGroup, TaxItemGroup, RecId from vendInvoiceTrans
                where vendInvoiceTrans.PurchID             == vendInvoiceJour.PurchId
                   && vendInvoiceTrans.InvoiceId           == vendInvoiceJour.InvoiceId
                   && vendInvoiceTrans.InvoiceDate         == vendInvoiceJour.InvoiceDate
                   && vendInvoiceTrans.NumberSequenceGroup == vendInvoiceJour.NumberSequenceGroup
                   && vendInvoiceTrans.InternalInvoiceId   == vendInvoiceJour.InternalInvoiceId
                   && vendInvoiceTrans.TaxGroup
                   && vendInvoiceTrans.TaxItemGroup;

            if (! vendInvoiceTrans.RecId ||
                TaxTable::find(TaxTable::vatCode_RU(vendInvoiceTrans.TaxGroup,
                                                    vendInvoiceTrans.TaxItemGroup)).vatChargeSource_RU == VATChargeSource_RU::OwnFunds)
            {
                return [0, 0, 0];
            }

            paymentAmounts = VATTaxAgentPaymentAmounts_RU::construct(_custVendTrans);

            if (_custVendTransOffset.Prepayment)
            {
                paymentAmounts.calc(_amountTransaction, _amountAccounting, _amountReporting, _custVendTrans.TransDate, true);

                taxAgentPaymentAmountTransaction = paymentAmounts.totalTaxAgentAmountCur();
                taxAgentPaymentAmountAccounting  = paymentAmounts.totalTaxAgentAmountMST();
                taxAgentPaymentAmountReporting   = paymentAmounts.totalTaxAgentAmountReporting();

                return [0, 0, 0];
            }

            paymentAmounts.calc(_amountTransaction, _amountAccounting, _amountReporting);

            _amountTransaction  = paymentAmounts.totalTaxAgentAmountCur();
            _amountAccounting   = paymentAmounts.totalTaxAgentAmountMST();
            _amountReporting    = paymentAmounts.totalTaxAgentAmountReporting();

            if (_amountTransaction)
            {
                this.updateTransForVATTaxAgent_RU(
                    _custVendTrans,
                    _custVendTransOpen,
                    settlementPair.getSpecTransDebit(),
                    _amountTransaction,
                    _amountAccounting,
                    _amountReporting);
            }

            return [_amountTransaction, _amountAccounting, _amountReporting];
        }

        settleAmountTransactionDebit    = settlementPair.getCalculator().calcSettleAmountCurForDebit(_remainingSpecTransRecords);
        amountAccountingDebit           = settlementPair.getCalculator().calcSettleAmountMstForDebit(settleAmountTransactionDebit);
        amountReportingDebit            = settlementPair.getCalculator().calcSettleReportingAmountDebit(settleAmountTransactionDebit, 0);

        [amountTransactionDebit, amountAccountingDebit, amountReportingDebit] = calcAndUpdate(
            settlementPair.getCustVendTransDebit(),
            settlementPair.getCustVendTransOpenDebit(),
            settleAmountTransactionDebit,
            amountAccountingDebit,
            amountReportingDebit,
            settlementPair.getCustVendTransCredit());

        amountTransactionCredit = settlementPair.getCalculator().calcSettleAmountCurForCredit(settleAmountTransactionDebit);
        amountAccountingCredit  = settlementPair.getCalculator().calcSettleAmountMstForCredit(amountTransactionCredit, false);
        amountReportingCredit   = settlementPair.getCalculator().calcSettleReportingAmountCredit(amountTransactionCredit, false);

        [amountTransactionCredit, amountAccountingCredit, amountReportingCredit] = calcAndUpdate(
            settlementPair.getCustVendTransCredit(),
            settlementPair.getCustVendTransOpenCredit(),
            amountTransactionCredit,
            amountAccountingCredit,
            amountReportingCredit,
            settlementPair.getCustVendTransDebit());

        return [
            amountTransactionDebit,
            amountAccountingDebit,
            amountReportingDebit,
            amountTransactionCredit,
            amountAccountingCredit,
            amountReportingCredit];
    }

]]></Source>
			</Method>
			<Method>
				<Name>processVATTransit_RU</Name>
				<Source><![CDATA[
    protected container processVATTransit_RU(
        AmountMST          _settleAmountAccountingDebit,
        AmountMST          _settleAmountAccountingCredit,
        AmountCur          _settleAmountTransactionDebit,
        AmountCur          _settleAmountTransactionCredit,
        AmountMSTSecondary _settleAmountReportingDebit,
        AmountMSTSecondary _settleAmountReportingCredit,
        AmountMST          _vatTaxAgentAmountAccountingDebit,
        AmountCur          _vatTaxAgentAmountTransactionDebit,
        AmountMSTSecondary _vatTaxAgentAmountReportingDebit,
        AmountMST          _vatTaxAgentAmountAccountingCredit,
        AmountCur          _vatTaxAgentAmountTransactionCredit,
        AmountMSTSecondary _vatTaxAgentAmountReportingCredit)
    {
        Voucher taxVoucherCreditLocal;
        Voucher taxVoucherDebitLocal;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) && ! this.isBadDebtAmortisation_RU())
        {
            if (settlementPair.getCustVendTransCredit().Invoice)
            {
                changecompany(settlementPair.getCreditCompany())
                {
                    taxVoucherCreditLocal = this.postVATTransit_RU(
                        _settleAmountAccountingCredit   + _vatTaxAgentAmountAccountingCredit,
                        _settleAmountTransactionCredit  + _vatTaxAgentAmountTransactionCredit,
                        _settleAmountReportingCredit    + _vatTaxAgentAmountReportingCredit,
                        settlementPair.getCustVendTransCredit(),
                        settlementPair.getCustVendTransCredit().AmountCur < 0);

                    this.postVATTransForTaxAgent_RU(
                        _settleAmountAccountingCredit,
                        _settleAmountTransactionCredit,
                        _settleAmountReportingCredit,
                        settlementPair.getCustVendTransDebit());
                }
            }

            if (settlementPair.getCustVendTransDebit().Invoice)
            {
                changecompany(settlementPair.getDebitCompany())
                {
                    taxVoucherDebitLocal = this.postVATTransit_RU(
                        _settleAmountAccountingDebit  + _vatTaxAgentAmountAccountingDebit,
                        _settleAmountTransactionDebit + _vatTaxAgentAmountTransactionDebit,
                        _settleAmountReportingDebit   + _vatTaxAgentAmountReportingDebit,
                        settlementPair.getCustVendTransDebit(),
                        settlementPair.getCustVendTransDebit().AmountCur < 0);

                    this.postVATTransForTaxAgent_RU(
                        _settleAmountAccountingDebit,
                        _settleAmountTransactionDebit,
                        _settleAmountReportingDebit,
                        settlementPair.getCustVendTransCredit());
                }
            }
        }

        return [taxVoucherDebitLocal    ? taxVoucherDebitLocal  : taxVoucherDebit,
                taxVoucherCreditLocal   ? taxVoucherCreditLocal : taxVoucherCredit];
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseAmounts</Name>
				<Source><![CDATA[
    void reverseAmounts(CustVendTrans _custVendTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>reversedAmount_RU</Name>
				<Source><![CDATA[
    protected AmountCur  reversedAmount_RU(Map       _map,
                                           TransDate _transDate)
    {
        MapIterator  mapIterator = new MapIterator(_map);
        AmountCur    amountCur;
        while (mapIterator.more())
        {
            if (mapIterator.key() > _transDate)
            {
                if (abs(amountCur) < abs(mapIterator.value()))
                {
                    amountCur = mapIterator.value();
                }
            }
            mapIterator.next();
        }
        return amountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Reverses unrealized VAT according to given reversal journal.
    /// </summary>
    /// <param name="_unrealizedRev">
    ///     Given reversal journal.
    /// </param>
    public void reverseTax(CustVendUnrealizedRev _unrealizedRev)
    {
        LedgerVoucher                   ledgerVoucher;
        CustVendSettlement              settlement;
        CustVendSettlementExtensionTH   custVendSettlementExtensionTH;
        LedgerJournalTrans              ledgerJournalTrans;
        VendTrans                       vendTrans;
        CustTrans                       custTrans;
        DiscAmount                      discount;
        TaxWithholdTrans                taxWithholdTrans;
        VendSettlement                  vendSettlementLatest;

        Percent                     origSettledPercentDebit;        // Settled percent on debit transaction before current processing
        Percent                     origSettledPercentCredit;       // Settled percent on credit transaction before current processing

        Counter                     numberOfVoucher;
        boolean                     success = true;
        ModuleCustVend              moduleCustVend = this.moduleCustVend();

        if (!_unrealizedRev)
        {
            return;
        }

        ttsbegin;

        CustVendTrans custVendTransCredit = CustVendTrans::getEmptyTableBuffer(moduleCustVend);
        CustVendTrans custVendTransDebit = CustVendTrans::getEmptyTableBuffer(moduleCustVend);
        settlement                      = CustVendSettlement::getEmptyTableBuffer(moduleCustVend);
        custVendSettlementExtensionTH   = CustVendSettlementExtensionTH::getEmptyTableBuffer(moduleCustVend);
        custVendTransSettlement         = CustVendTransSettlement::construct(this.parmModule());

        CustVendSettleInitSettlementPairForReverseTaxParameters reverseTaxParameters = CustVendSettleInitSettlementPairForReverseTaxParameters::construct();
        reverseTaxParameters.parmUnrealizedRev(_unrealizedRev);

        while select custVendTransCredit
                order by custVendTransCredit.Voucher, custVendTransCredit.TransDate
            join settlement
                where custVendTransCredit.RecId == settlement.TransRecId
            join forupdate custVendTransDebit
                where settlement.OffsetRecId == custVendTransDebit.RecId
            exists join custVendSettlementExtensionTH
                where custVendSettlementExtensionTH.CustVendSettlement  == settlement.RecId
                    && custVendSettlementExtensionTH.UnrealizedRev      == _unrealizedRev.RecId
        {
            settlementPair.setCustVendTransDebit(custVendTransDebit);
            settlementPair.setCustVendTransCredit(custVendTransCredit);

            this.initSettlementPairForReverseTax(reverseTaxParameters);

            this.parmIsTaxInvoiceInfoFilled(true);

            if (_unrealizedRev.TableId == tableNum(VendUnrealizedRev))
            {
                select firstonly RecId from ledgerJournalTrans where ledgerJournalTrans.VendTransId == settlementPair.getCustVendTransDebit().RecId;
                vendTrans = settlementPair.getCustVendTransDebit();
                discount = vendTrans.displayDiscountUsed();
            }
            else
            {
                select firstonly RecId from ledgerJournalTrans where ledgerJournalTrans.CustTransId == settlementPair.getCustVendTransDebit().RecId;
                custTrans = settlementPair.getCustVendTransDebit();
                discount = custTrans.displayUtilizedCashDisc();
            }

            isLatestSettlement = this.isLatestSettlement_TH(settlement);
            if (isLatestSettlement)
            {
                custVendSettlementLatest = settlement;
            }

            if (ledgerJournalTrans.RecId)
            {
                settlementPair.getSpecTransDebit().SpecCompany = settlementPair.getDebitCompany();
                settlementPair.getSpecTransDebit().SpecTableId = tableNum(LedgerJournalTrans);
                settlementPair.getSpecTransDebit().SpecRecId   = ledgerJournalTrans.RecId;
            }

            if (settlementPair.getCustVendTransDebit().AmountCur - discount != 0)
            {
                select sum(PaymTaxWithholdAmount) from taxWithholdTrans
                    where taxWithholdTrans.VendTransInvoiceId == vendTrans.RecId
                    join RecId from vendSettlementLatest
                        where vendSettlementLatest.OffsetRecid == settlement.TransRecId
                            && vendSettlementLatest.TransRecId == vendTrans.RecId
                            && vendSettlementLatest.OffsetTransVoucher == taxWithholdTrans.Voucher;

                CustVendTrans custVendTransPayment = settlementPair.getCustVendTransCredit();
                CurrencyCode invoiceCurrencyCode = settlementPair.getCustVendTransDebit().CurrencyCode;
                if (custVendTransPayment.CurrencyCode == invoiceCurrencyCode)
                {
                    origSettledPercentDebit = (settlementPair.getCustVendTransDebit().SettleAmountCur - discount + settlement.SettleAmountCur + taxWithholdTrans.PaymTaxWithholdAmount) / (settlementPair.getCustVendTransDebit().AmountCur);
                }
                else
                {
                    // Convert the currency amount of invoice into the currency amount of payment, then get settled percent on debit transaction before current processing
                    origSettledPercentDebit = (CurrencyExchangeHelper::curAmount2CurAmount((settlementPair.getCustVendTransDebit().SettleAmountCur - discount), invoiceCurrencyCode, custVendTransPayment.CurrencyCode, custVendTransPayment.TransDate)
                            + settlement.SettleAmountCur + taxWithholdTrans.PaymTaxWithholdAmount) /
                        CurrencyExchangeHelper::curAmount2CurAmount((settlementPair.getCustVendTransDebit().AmountCur), invoiceCurrencyCode, custVendTransPayment.CurrencyCode, custVendTransPayment.TransDate);
                }
            }
            else
            {
                origSettledPercentDebit = 0;
            }
            origSettledPercentCredit = 0;

            // If unrealized VAT is to be reversed for multiple payment journals.
            settlementPair.forceNewVouchers();
            this.processConditionalTax(origSettledPercentDebit, origSettledPercentCredit, 0, 0);

            // Creates related voucher per payment journal.
            ledgerVoucher = settlementPair.findLedgerVoucherByCompany(settlementPair.getCreditCompany());
            if (ledgerVoucher)
            {
                ledgerVoucher.createVoucherLinks(settlementPair.getCustVendTransCredit().Voucher, settlementPair.getCustVendTransCredit().TransDate);
            }

            if (settlementPair.getLedgerVoucherGroup().end())
            {
                numberOfVoucher++;
            }
            else
            {
                success = false;
            }
        }

        if (success)
        {
            info(strFmt("@SYS25783", numberOfVoucher));
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSettlementPairForReverseTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initialzes <c>SettlementPair</c> class.
    /// </summary>
    /// <param name = "_parameters">
    ///     An instance of <c>CustVendSettleInitSettlementPairForReverseTaxParameters</c> class.
    /// </param>
    [Wrappable(true)]
    protected final void initSettlementPairForReverseTax(CustVendSettleInitSettlementPairForReverseTaxParameters _parameters)
    {
        settlementPair.setLedgerVoucherGroup(LedgerVoucherGroup::construct());
        settlementPair.setTransactionDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTransOpenAmounts</Name>
				<Source><![CDATA[
    void reverseTransOpenAmounts(CustVendTransOpen _custVendTransOpen)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of the variable <c>saveDate</c>.
    /// </summary>
    /// <param name="_saveDate">
    ///    The variable <paramref name="saveDate" />; optional.
    /// </param>
    /// <returns>
    ///    The value of the variable <c>saveDate</c>.
    /// </returns>
    TransDate saveDate(TransDate _saveDate = saveDate)
    {
        saveDate = _saveDate;

        return saveDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setOffsetVoucher</Name>
				<Source><![CDATA[
    protected void setOffsetVoucher(OffsetVoucher _offsetVoucher)
    {
        offsetVoucher = _offsetVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPostingProfile</Name>
				<Source><![CDATA[
    protected void setPostingProfile(PostingProfile _postingProfile)
    {
        postingProfile = _postingProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>areAdditionalEntriesRequiredForPD_PSN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Decides whether additional entries are required for posting definitions
    /// </summary>
    /// <param name = "_settleAmountCurDebit">
    /// The debit transaction settle amount in the transaction currency of the debit transaction.
    /// </param>
    /// <param name = "_settleAmountAccountingDebit">
    /// The debit transaction settle amount in the accounting currency.
    /// </param>
    /// <param name = "_settleAmountReportingDebit">
    /// The debit transaction settle amount in the reporting currency.
    /// </param>
    /// <returns>
    /// true if additional entries are required; otherwise, false.
    /// </returns>
    protected boolean areAdditionalEntriesRequiredForPD_PSN(
        AmountCur _settleAmountCurDebit,
        AmountMST _settleAmountAccountingDebit,
        AmountMST _settleAmountReportingDebit)
    {
        return (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
            && CustSettleJournalizingEntries::requiredAdditionalEntries(settlementPair.getCustVendTransDebit().TransType, settlementPair.getCustVendTransCredit().TransType)
            && custSettleJournalizingEntries.existGeneratedEntry(this.amount(_settleAmountCurDebit),
                                                                 this.amount(_settleAmountAccountingDebit),
                                                                 this.amount(_settleAmountReportingDebit),
                                                                 settlementPair.getCustVendTransDebit(),
                                                                 settlementPair.getCustVendTransCredit()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>reversePrePaymentTaxCredit</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Reverses the sales tax on a prepayment transaction.
    /// </summary>
    /// <param name = "_prePaymentReversal">
    ///     A instance of <c>CustVendPrePaymentReversal</c> class.
    /// </param>
    /// <param name = "_custVendSettlePrePaymentReversalContract">
    ///     A instance of <c>CustVendSettlePrePaymentReversalContract</c> class.
    /// </param>
    protected void reversePrePaymentTaxCredit(
        CustVendPrePaymentReversal _prePaymentReversal,
        CustVendSettlePrePaymentReversalContract _custVendSettlePrePaymentReversalContract)
    {
        _prePaymentReversal.reversePrePaymentTax(_custVendSettlePrePaymentReversalContract.parmCustVendTransPrePayment(),
            _custVendSettlePrePaymentReversalContract.parmLedgerVoucher(),
            _custVendSettlePrePaymentReversalContract.parmSettleAmountCurPrepayment());
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleForDifferentProfilesPostingLog_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// The method creates a settlement posting log for balance closing scenario.
    /// </summary>
    /// <param name = "_ledgerVoucher">The ledger voucher.</param>
    /// <param name = "_distributedTrans">The transaction being distributed.</param>
    /// <param name = "_distribution">The transaction distribution.</param>
    private void settleForDifferentProfilesPostingLog_W(
        LedgerVoucher _ledgerVoucher,
        CustVendTrans _distributedTrans,
        CustVendTransDistribution _distribution)
    {
        boolean                         reversePrepayment;
        LedgerDimensionDefaultAccount   defaultAccount;
        LedgerDimensionDefaultAccount   offsetDefaultAccount;
        CustVendTrans                   transDebit = settlementPair.getCustVendTransDebit(),
                                        transCredit = settlementPair.getCustVendTransCredit();
        CustVendTrans                   custVendTransDebitLocal = transDebit;
        CustVendTrans                   custVendTransCreditLocal = transCredit;
        CustVendTransPostingLogType_RU  custVendTransPostingLogType = CustVendTransPostingLogType_RU::Balance;
        int                             sign = -1;

        if ((_distributedTrans.RecId == transDebit.RecId && _distributedTrans.AccountingEvent)
            || (_distributedTrans.RecId == transCredit.RecId && ! transDebit.AccountingEvent))
        {
            if (transDebit.Prepayment || transCredit.Prepayment)
            {
                custVendTransPostingLogType = CustVendTransPostingLogType_RU::PrepaymentStorno;

                if (this.parmModule() == SysModule::Cust)
                {
                    reversePrepayment = CustParameters::find().ReversePrepayment_W;
                }
                else
                {
                    reversePrepayment = VendParameters::find().ReversePrepayment_W;
                }

                if (! reversePrepayment)
                {
                    custVendTransDebitLocal     = transCredit;
                    custVendTransCreditLocal    = transDebit;
                }

                sign = 1;
            }

            if (reversePrepayment || custVendTransPostingLogType == CustVendTransPostingLogType_RU::Balance)
            {
                if (custVendTransDebitLocal.RecId == _distributedTrans.RecId)
                {
                    defaultAccount = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(_distribution.ledgerDimension());
                }
                else
                {
                    defaultAccount = custVendTransDebitLocal.summaryLedgerDimension(custVendTransDebitLocal.PostingProfile);
                }

                if (custVendTransDebitLocal.RecId != _distributedTrans.RecId)
                {
                    offsetDefaultAccount = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(_distribution.ledgerDimension());
                }
                else
                {
                    offsetDefaultAccount = custVendTransCreditLocal.summaryLedgerDimension(custVendTransCreditLocal.PostingProfile);
                }

                if (! reversePrepayment && (firstCustVendTrans.RecId == transCredit.RecId || _distributedTrans.RecId == transCredit.RecId))
                {
                    sign = -sign;
                }

                this.createPostingTransLog_RU(
                    custVendTransPostingLogType,
                    (reversePrepayment || firstCustVendTrans.RecId == transCredit.RecId) ?
                        transCredit :
                        transDebit,
                    this.ledgerPostingType_W(),
                    defaultAccount,
                    offsetDefaultAccount,
                    (reversePrepayment ? -1 : -sign) * _distribution.accountingAmount(),
                    (reversePrepayment ? -1 : -sign) * _distribution.reportingAmount(),
                    null,
                    (custVendTransDebitLocal.RecId == _distributedTrans.RecId) ?
                        LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_distribution.ledgerDimension()) :
                        custVendTransDebitLocal.DefaultDimension,
                    (reversePrepayment ? -1 : -sign) * _distribution.transactionAmount(),
                    custVendTransDebitLocal,
                    custVendTransCreditLocal,
                    0,
                    0,
                    _ledgerVoucher.lastVoucher(),
                    _ledgerVoucher.lastTransDate(),
                    _ledgerVoucher.findLedgerVoucherObject().parmIsCorrectionDefault(),
                    (custVendTransDebitLocal.RecId == _distributedTrans.RecId) ?
                        custVendTransCreditLocal.DefaultDimension :
                        LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_distribution.ledgerDimension()),
                    true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleForDifferentProfilesOrPrepayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates settlement transactions when the transactions being settled have different posting profiles or are prepayment.
    /// </summary>
    /// <param name="_settleAmountAccountingDebit">
    /// The debit transaction settle amount in the accounting currency.
    /// </param>
    /// <param name="_settleAmountCurDebit">
    /// The debit transaction settle amount in the transaction currency of the debit transaction.
    /// </param>
    /// <param name="_settleAmountReportingDebit">
    /// The debit transaction settle amount in the reporting currency.
    /// </param>
    /// <param name="_settleAmountCurCredit">
    /// The credit transaction settle amount in the transaction currency of the credit transaction.
    /// </param>
    /// <param name="_settleAmountAccountingCredit">
    /// The credit transaction settle amount in the accounting currency.
    /// </param>
    /// <param name="_settleAmountReportingCredit">
    /// The credit transaction settle amount in the reporting currency.
    /// </param>
    /// <param name="_closeAmountAccounting">
    /// The closing amount in the accounting currency.
    /// </param>
    /// <param name="_closeAmountReporting">
    /// The closing amount in the reporting currency.
    /// </param>
    protected void settleForDifferentProfilesOrPrepayment(
        AmountMST _settleAmountAccountingDebit,
        AmountCur _settleAmountCurDebit,
        Money     _settleAmountReportingDebit,
        AmountCur _settleAmountCurCredit,
        AmountMST _settleAmountAccountingCredit,
        AmountMST _settleAmountReportingCredit,
        AmountMST _closeAmountAccounting,
        AmountMST _closeAmountReporting)
    {
        LedgerVoucher   ledgerVoucher;
        CustVendPrePaymentReversal prePaymentReversal;
        TransactionTextLarge settlementTransText;
        // <GEERU>
        boolean                         reversePrepayment;
        LedgerBondClient_RU             ledgerBondClient;
        LedgerVoucherObject             ledgerVoucherObject;
        AmountMST                       closeAmountAccounting       = _closeAmountAccounting;
        AmountMST                       closeAmountReporting        = _closeAmountReporting;
        AmountMST                       closeAmountTransaction      = _settleAmountCurDebit;
        CustVendTransPostingLogType_RU  custVendTransPostingLogType = CustVendTransPostingLogType_RU::Balance;
        CustVendTrans                   custVendTransDebitLocal     = settlementPair.getCustVendTransDebit(),
                                        custVendTransCreditLocal    = settlementPair.getCustVendTransCredit();
        int                             sign = -1;
        boolean                         isTaxAgent = VendTable::find(settlementPair.getCustVendTransDebit().AccountNum).vatTaxAgent_RU;
        boolean                         countryRegion_RUEE = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL]);

        List                            distributions;
        ListEnumerator                  distributionEnumerator;
        CustVendTransDistribution       distribution;
        CustVendTrans                   distributedTrans;
        LedgerDimensionDefaultAccount   defaultAccount;
        LedgerDimensionDefaultAccount   offsetDefaultAccount;

        void transferBalances(boolean _recordCustVendTrans)
        {
            if (reversePrepayment)
            {
                CustVendSettle::postingProfileSettle_RU(ledgerVoucher,
                                                        settlementPair.getCustVendTransDebit(),
                                                        _recordCustVendTrans ?
                                                            this.amount(_settleAmountCurCredit) :
                                                            distribution.transactionAmount(),
                                                        custVendTransSettlement,
                                                        settlementGroupPlaceHolder,
                                                        settlementPair.getCustVendTransDebit().DefaultDimension,
                                                        settlementPair.getCustVendTransDebit().PostingProfile,
                                                        LedgerTransTxt::Settlement,
                                                        _recordCustVendTrans ?
                                                            this.amount(-closeAmountAccounting) :
                                                            distribution.accountingAmount(),
                                                        _recordCustVendTrans ?
                                                            this.amount(-closeAmountReporting) :
                                                            distribution.reportingAmount(),
                                                        settlementPair.getCustVendTransCredit().CurrencyCode,
                                                        (! _recordCustVendTrans && settlementPair.getCustVendTransDebit().AccountingEvent) ?
                                                            distribution.ledgerDimension() : 0,
                                                        _recordCustVendTrans,
                                                        ! _recordCustVendTrans
                                                        );

                CustVendSettle::postingProfileSettle_RU(ledgerVoucher,
                                                        settlementPair.getCustVendTransCredit(),
                                                        _recordCustVendTrans ?
                                                            this.amount(-_settleAmountCurCredit) :
                                                            - distribution.transactionAmount(),
                                                        custVendTransSettlement,
                                                        settlementGroupPlaceHolder,
                                                        settlementPair.getCustVendTransCredit().DefaultDimension,
                                                        settlementPair.getCustVendTransCredit().PostingProfile,
                                                        LedgerTransTxt::Settlement,
                                                        _recordCustVendTrans ?
                                                            this.amount(closeAmountAccounting) :
                                                            -distribution.accountingAmount(),
                                                        _recordCustVendTrans ?
                                                            this.amount(closeAmountReporting) :
                                                            -distribution.reportingAmount(),
                                                        settlementPair.getCustVendTransCredit().CurrencyCode,
                                                        (! _recordCustVendTrans && settlementPair.getCustVendTransCredit().AccountingEvent) ?
                                                            distribution.ledgerDimension() : 0,
                                                        _recordCustVendTrans,
                                                        ! _recordCustVendTrans
                                                        );
            }
            else
            {
                if (firstCustVendTrans.RecId == settlementPair.getCustVendTransCredit().RecId)
                {
                    custVendTransDebitLocal     = settlementPair.getCustVendTransCredit();
                    custVendTransCreditLocal    = settlementPair.getCustVendTransDebit();
                }

                CustVendSettle::postingProfileSettle_RU(ledgerVoucher,
                                                        custVendTransDebitLocal,
                                                        _recordCustVendTrans ?
                                                            this.amount(-sign * closeAmountTransaction) :
                                                            distribution.transactionAmount(),
                                                        custVendTransSettlement,
                                                        settlementGroupPlaceHolder,
                                                        custVendTransCreditLocal.DefaultDimension,
                                                        custVendTransCreditLocal.PostingProfile,
                                                        LedgerTransTxt::Settlement,
                                                        _recordCustVendTrans ?
                                                            this.amount(-sign * closeAmountAccounting) :
                                                            distribution.accountingAmount(),
                                                        _recordCustVendTrans ?
                                                            this.amount(-sign * closeAmountReporting) :
                                                            distribution.reportingAmount(),
                                                        firstCustVendTrans.CurrencyCode,
                                                        (! _recordCustVendTrans && custVendTransCreditLocal.AccountingEvent
                                                        && !CustVendSettleDifferentPostingProfileForCreditNote_RUFlight::instance().isEnabled()) ?
                                                            distribution.ledgerDimension() : 0,
                                                        _recordCustVendTrans,
                                                        ! _recordCustVendTrans
                                                        );

                CustVendSettle::postingProfileSettle_RU(ledgerVoucher,
                                                        custVendTransDebitLocal,
                                                        _recordCustVendTrans ?
                                                            this.amount(sign * closeAmountTransaction) :
                                                            -distribution.transactionAmount(),
                                                        custVendTransSettlement,
                                                        settlementGroupPlaceHolder,
                                                        custVendTransDebitLocal.DefaultDimension,
                                                        custVendTransDebitLocal.PostingProfile,
                                                        LedgerTransTxt::Settlement,
                                                        _recordCustVendTrans ?
                                                            this.amount(sign * closeAmountAccounting) :
                                                            -distribution.accountingAmount(),
                                                        _recordCustVendTrans ?
                                                            this.amount(sign * closeAmountReporting) :
                                                            -distribution.reportingAmount(),
                                                        firstCustVendTrans.CurrencyCode,
                                                        (! _recordCustVendTrans && custVendTransDebitLocal.AccountingEvent) ?
                                                            distribution.ledgerDimension() : 0,
                                                        _recordCustVendTrans,
                                                        ! _recordCustVendTrans
                                                        );
            }
        }
        // </GEERU>

        if (settlementPair.getCustVendTransDebit().Prepayment || settlementPair.getCustVendTransCredit().Prepayment)
        {
            // The CustVendPrePaymentReversal class is used to reverse tax on prepayments.
            // <GEERU>
            if (!countryRegion_RUEE)
            {
                // </GEERU>
                prePaymentReversal = CustVendPrePaymentReversal::newCustVendTrans(settlementPair.getCustVendTransDebit(),
                    custVendTransSettlement,
                    settlementGroupPlaceHolder);
                // <GEERU>
            }
            else
            {
                custVendTransPostingLogType = CustVendTransPostingLogType_RU::PrepaymentStorno;

                if (this.parmModule() == SysModule::Cust)
                {
                    reversePrepayment = CustParameters::find().ReversePrepayment_W;
                }
                else
                {
                    reversePrepayment = VendParameters::find().ReversePrepayment_W;
                }

                if (! reversePrepayment)
                {
                    custVendTransDebitLocal     = settlementPair.getCustVendTransCredit();
                    custVendTransCreditLocal    = settlementPair.getCustVendTransDebit();
                }

                sign                        = 1;
            }
            // </GEERU>

            if (settlementPair.getCustVendTransDebit().Prepayment)
            {
                changecompany(settlementPair.getDebitCompany())
                {
                    // <GEERU>
                    if (!isTaxAgent &&
                        custVendTransDebitLocal.CustVendTrans::getCustVendTrans_W().CommProfileType_RU == CommProfileType_RU::General &&
                        !skipReversePrePaymentTax &&
                        TaxReversePrePayment::existPrePaymentTax(settlementPair.getCustVendTransDebit().TransDate, settlementPair.getCustVendTransDebit().Voucher))
                    // </GEERU>
                    {
                        // <GEERU>
                        // The CustVendPrePaymentReversal class is used to reverse tax on prepayments.
                        // class is created in corresponding company because of different successors can be creted based on data setup
                        if (countryRegion_RUEE)
                        {
                            prePaymentReversal = CustVendPrePaymentReversal::newCustVendTrans(settlementPair.getCustVendTransDebit(),
                                                                                              custVendTransSettlement,
                                                                                              settlementGroupPlaceHolder);
                            prePaymentReversal.parmCustVendSettle_RU(this);
                        }
                        // </GEERU>
                        // Only need to reverse tax if tax transactions exist for voucher and date
                        ledgerVoucher = settlementPair.findLedgerVoucherByCompany(settlementPair.getDebitCompany());

                        // <GEERU>
                        if (countryRegion_RUEE)
                        {
                            ledgerVoucherObject = this.createLedgerVoucherObject_RU(ledgerVoucher);

                            prePaymentReversal.reversePrePaymentTax(settlementPair.getCustVendTransDebit(),
                                                                    ledgerVoucher,
                                                                    _settleAmountCurDebit,
                                                                    _settleAmountAccountingDebit,
                                                                    _settleAmountReportingDebit,
                                                                    settlementPair.getCustVendTransCredit());

                            taxVoucherDebit = ledgerVoucher.lastVoucher();
                        }
                        else
                        // </GEERU>
                        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX]))
                        {
                            prePaymentReversal.reversePrePaymentTax(settlementPair.getCustVendTransDebit(), ledgerVoucher, _settleAmountCurDebit, 0, 0, settlementPair.getCustVendTransCredit());
                        }
                        else
                        {
                            prePaymentReversal.reversePrePaymentTax(settlementPair.getCustVendTransDebit(), ledgerVoucher, _settleAmountCurDebit);
                        }
                    }
                }
            }
            if (settlementPair.getCustVendTransCredit().Prepayment)
            {
                changecompany(settlementPair.getCreditCompany())
                {
                    // <GEERU>
                    if (!isTaxAgent &&
                        custVendTransCreditLocal.CustVendTrans::getCustVendTrans_W().CommProfileType_RU == CommProfileType_RU::General &&
                        !skipReversePrePaymentTax &&
                        TaxReversePrePayment::existPrePaymentTax(settlementPair.getCustVendTransCredit().TransDate, settlementPair.getCustVendTransCredit().Voucher))
                    // </GEERU>
                    {
                        // <GEERU>
                        // The CustVendPrePaymentReversal class is used to reverse tax on prepayments.
                        // class is created in corresponding company because of different successors can be creted based on data setup
                        if (countryRegion_RUEE)
                        {
                            prePaymentReversal = CustVendPrePaymentReversal::newCustVendTrans(settlementPair.getCustVendTransDebit(),
                                                                                              custVendTransSettlement,
                                                                                              settlementGroupPlaceHolder);
                            prePaymentReversal.parmCustVendSettle_RU(this);
                        }
                        // </GEERU>
                        // Only need to reverse tax if tax transactions exist for voucher and date
                        ledgerVoucher = settlementPair.findLedgerVoucherByCompany(settlementPair.getCreditCompany());

                        // <GEERU>
                        if (countryRegion_RUEE)
                        {
                            if (! ledgerVoucherObject)
                            {
                                ledgerVoucherObject = this.createLedgerVoucherObject_RU(ledgerVoucher);
                            }

                            prePaymentReversal.reversePrePaymentTax(settlementPair.getCustVendTransCredit(),
                                                                    ledgerVoucher,
                                                                    _settleAmountCurCredit,
                                                                    _settleAmountAccountingCredit,
                                                                    _settleAmountReportingCredit,
                                                                    settlementPair.getCustVendTransDebit());

                            taxVoucherCredit = ledgerVoucher.lastVoucher();
                        }
                        else
                        // </GEERU>
                        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX]))
                        {
                            prePaymentReversal.reversePrePaymentTax(settlementPair.getCustVendTransCredit(), ledgerVoucher, _settleAmountCurCredit, 0, 0, settlementPair.getCustVendTransDebit());
                        }
                        else
                        {
                            CustVendSettlePrePaymentReversalContract custVendSettlePrePaymentReversalContract = CustVendSettlePrePaymentReversalContract::constructReversePrePaymentTaxCredit(prePaymentReversal,
                                settlementPair.getCustVendTransCredit(),
                                ledgerVoucher,
                                _settleAmountCurCredit,
                                _settleAmountAccountingCredit,
                                _settleAmountReportingCredit,
                                settlementPair.getCustVendTransDebit());
                            this.reversePrePaymentTaxCredit(prePaymentReversal, custVendSettlePrePaymentReversalContract);

                        }
                    }
                }
            }
        }

        boolean debitHasMultipleSummaryEntries;
        boolean creditHasMultipleSummaryEntries;

        if (this.areAdditionalEntriesRequiredForPD_PSN(_settleAmountCurDebit, _settleAmountAccountingDebit, _settleAmountReportingDebit))
        {
            debitHasMultipleSummaryEntries = false;
            creditHasMultipleSummaryEntries = false;
        }
        else
        {
            //For RU customs journal we have a well-known GL posting scheme so for customs scenarios
            //we are enabling summary account relief, other scenarios will use defaulting logic
            // The same case for Vendor approval journal, additional transactions come from Invoice register journal.
            if (CustomJournalTable_RU::isVoucherRelatedToCustomsJournal(settlementPair.getCustVendTransDebit())
                || EmplParameters_RU::isVoucherRelatedToVendorApprovalJournal(settlementPair.getCustVendTransDebit()))
            {
                debitHasMultipleSummaryEntries = false;
            }
            else
            {
                debitHasMultipleSummaryEntries = CustVendSettleSummaryAccountRelief::voucherContainsMultipleSummaryEntries(
                    settlementPair.getCustVendTransDebit(),
                    this.getLedgerPostingType_Balance());
            }

            if (CustomJournalTable_RU::isVoucherRelatedToCustomsJournal(settlementPair.getCustVendTransCredit())
                || EmplParameters_RU::isVoucherRelatedToVendorApprovalJournal(settlementPair.getCustVendTransCredit()))
            {
                creditHasMultipleSummaryEntries = false;
            }
            else
            {
                creditHasMultipleSummaryEntries = CustVendSettleSummaryAccountRelief::voucherContainsMultipleSummaryEntries(
                    settlementPair.getCustVendTransCredit(),
                    this.getLedgerPostingType_Balance());
            }
        }

        // determine whether there is a need to offset the summary posting account distributions of the original transactions
        if (this.mustOffsetOriginalSummaryDistributions(debitHasMultipleSummaryEntries, creditHasMultipleSummaryEntries)
            || this.areAdditionalEntriesRequiredForPD_PSN(_settleAmountCurDebit, _settleAmountAccountingDebit, _settleAmountReportingDebit))
        {
            Debug::assert(settlementPair.getDebitCompany() == curext());

            ledgerVoucher = settlementPair.findLedgerVoucherByCompany(settlementPair.getDebitCompany());
            settlementTransText = this.getDifferentProfileSettlementTransText(settlementPair.getCustVendTransDebit(), ledgerVoucher, LedgerTransTxt::Settlement);

            // <GEERU>
            if (countryRegion_RUEE && ! SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
            {
                if (! ledgerVoucherObject)
                {
                    ledgerVoucherObject = this.createLedgerVoucherObject_RU(ledgerVoucher);
                }
                ledgerVoucherObject.parmCorrection(NoYes::No);
                ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();

                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoHU, #isoPL]) ||
                    exchRateDiffCalcType == ExchRateDiffCalcType_W::Standard)
                {
                    closeAmountAccounting   = _settleAmountAccountingDebit;
                    closeAmountReporting    = _settleAmountReportingDebit;
                }

                if (! reversePrepayment && firstCustVendTrans.RecId == settlementPair.getCustVendTransCredit().RecId)
                {
                    sign                        = -sign;
                    closeAmountTransaction      = -_settleAmountCurCredit;
                }
                // since there can be distributions and we have no ability to have more than
                // two settlement transactions per settlement group, we
                // record CustVendTrans and general ledger seperatly
                // the first is not distributed while the second is
                transferBalances(true);

                distributedTrans = settlementPair.getCustVendTransDebit().AccountingEvent ? settlementPair.getCustVendTransDebit() : settlementPair.getCustVendTransCredit();
                distributions =
                    debitSettleDistController.generateDistributions(
                        distributedTrans,
                        this.getLedgerPostingType_Balance(),
                        reversePrepayment ? this.amount(_settleAmountCurCredit) :
                                            this.amount(-sign * closeAmountTransaction),
                        this.amount((reversePrepayment ? -1 : -sign) * closeAmountAccounting),
                        this.amount((reversePrepayment ? -1 : -sign) * closeAmountReporting),
                        LedgerDimensionFacade::serviceCreateLedgerDimension(distributedTrans.summaryLedgerDimension(), distributedTrans.DefaultDimension),
                        false);
                distributionEnumerator = distributions.getEnumerator();
                while (distributionEnumerator.moveNext())
                {
                    distribution = distributionEnumerator.current();
                    if (ledgerBondClient)
                    {
                        ledgerBondClient.addNewLogObject();
                    }

                    transferBalances(false);

                    if (ledgerBondClient && ledgerBondClient.currentLogLength())
                    {
                        ledgerBondClient.bondLastVRef2CurrentLog();
                    }

                    if (reversePrepayment || custVendTransPostingLogType == CustVendTransPostingLogType_RU::Balance)
                    {
                        if (settlementPair.getCustVendTransCredit().Prepayment)
                        {
                            closeAmountTransaction = -_settleAmountCurCredit;
                        }

                        if (custVendTransDebitLocal.RecId == distributedTrans.RecId)
                        {
                            defaultAccount = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(distribution.ledgerDimension());
                        }
                        else
                        {
                            defaultAccount = custVendTransDebitLocal.summaryLedgerDimension(custVendTransDebitLocal.PostingProfile);
                        }

                        if (custVendTransDebitLocal.RecId != distributedTrans.RecId)
                        {
                            offsetDefaultAccount = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(distribution.ledgerDimension());
                        }
                        else
                        {
                            offsetDefaultAccount = custVendTransCreditLocal.summaryLedgerDimension(custVendTransCreditLocal.PostingProfile);
                        }

                        this.createPostingTransLog_RU(custVendTransPostingLogType,
                                                        (reversePrepayment || firstCustVendTrans.RecId == settlementPair.getCustVendTransCredit().RecId) ?
                                                            settlementPair.getCustVendTransCredit() :
                                                            settlementPair.getCustVendTransDebit(),
                                                        this.ledgerPostingType_W(),
                                                        defaultAccount,
                                                        offsetDefaultAccount,
                                                        (reversePrepayment ? 1 : -1) * distribution.accountingAmount(),
                                                        (reversePrepayment ? 1 : -1) * distribution.reportingAmount(),
                                                        null,

                                                        (custVendTransDebitLocal.RecId == distributedTrans.RecId) ?
                                                            LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(distribution.ledgerDimension()) :
                                                            custVendTransDebitLocal.DefaultDimension,
                                                        (reversePrepayment ? 1 : -1) * distribution.transactionAmount(),
                                                        custVendTransDebitLocal,
                                                        custVendTransCreditLocal,
                                                        0,
                                                        0,
                                                        ledgerVoucher.lastVoucher(),
                                                        ledgerVoucher.lastTransDate(),
                                                        ledgerVoucher.findLedgerVoucherObject().parmIsCorrectionDefault(),
                                                        (custVendTransDebitLocal.RecId == distributedTrans.RecId) ?
                                                            custVendTransCreditLocal.DefaultDimension :
                                                            LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(distribution.ledgerDimension()),
                                                        true);
                    }
                }
            }
            else
            {
                // </GEERU>

                ledgerVoucher = this.createSummaryAccountReliefTransactions(
                            ledgerVoucher,
                            _settleAmountAccountingDebit,
                            _settleAmountCurDebit,
                            _settleAmountReportingDebit,
                            settlementTransText,
                            debitHasMultipleSummaryEntries,
                            creditHasMultipleSummaryEntries);

                // <GEERU>
            }
            // </GEERU>
        }

        if (ledgerVoucher)
        {
            custVendTransSettlement.setLedgerVoucher(ledgerVoucher);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settlementControl</Name>
				<Source><![CDATA[
    protected abstract void settlementControl()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareInvoiceForSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prepares an invoice (debit transaction) for settlement.
    /// </summary>
    private void prepareInvoiceForSettlement()
    {
        if (!settleNowState.getAreDebitsDone() && (settleNowState.getAreCreditsDone() || settlementPair.getSpecTransDebit().Balance01 == 0))
        {
            boolean areDebitsDone = !settlementPair.fetchInvoice(
                settleNowState.getSpecCompany(),
                settleNowState.getSpecTableId(),
                settleNowState.getSpecRecId());
            settleNowState.setAreDebitsDone(areDebitsDone);

            // <GEERU><GEEU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ, #isoHU, #isoPL]))
            {
                settleNowState.setInvoiceReversedAmount(0);
            }
            // </GEEU></GEERU>
            if (!settleNowState.getAreDebitsDone())
            {
                debitTransState = SettlementTransactionState::Found;
                settleNowState.setIsDebitTransFullySettled(false);
                settleNowState.incrementSpecTransRecordsProcessed();
                instrumentationDimensionTracking.incrementNumberOfInvoices();

                accountNumber = settlementPair.getCustVendTransOpenDebit().AccountNum;

                settleNowState.setOrigRemainDebitCur(settlementPair.getCustVendTransOpenDebit().AmountCur);

                vendTax1099Manager.parmOrigTransOpenDebitAmountCur(-settlementPair.getCustVendTransOpenDebit().AmountCur);
                vendTax1099Manager.getTax1099Amount(settlementPair.getCustVendTransDebit());

                // <GEERU><GEEU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ, #isoHU, #isoPL]))
                {
                    settleNowState.setInvoiceReversedAmounts(Map::create(CustVendTransData::construct(settlementPair.getCustVendTransDebit()).mapReversedAmountsCur_RU()));
                }
                // </GEEU></GEERU>
            }
            else
            {
                debitTransState = SettlementTransactionState::None;

                CustVendTrans custVendTrans = settlementPair.getCustVendTransCredit();
                CustTrans custTrans = custVendTrans.TableId == tableNum(CustTrans) ? custVendTrans : null;

                SpecTrans specTransCredit = settlementPair.getSpecTransCredit();
                AmountCur specTransCreditBalance01 = custTrans ? specTransCredit.orig().Balance01 : -specTransCredit.orig().Balance01;

                if (!settleNowState.getAreCreditsDone() && custVendTrans.AmountCur != 0
                    && (!CustVendTransRemainingTotalTransNoPennyDiffFlight::instance().isEnabled()
                        || (custTrans && custTrans.RetailTransactionId != '')
                        || specTransCreditBalance01 != settlementPair.getCustVendTransOpenCredit().AmountCur))
                {
                    remainingOpenAmounts.add(
                        custVendTrans.RecId,
                        settlementPair.getCreditCompany(),
                        custVendTrans.exchRateCurToMst(),
                        settlementPair.getCustVendTransOpenCredit().RecId,
                        specTransCredit.Balance01,
                        custVendTrans.DefaultDimension,
                        creditTransState,
                        settlementGroupPlaceHolder);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preparePaymentForSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prepares a payment (credit transaction) for settlement.
    /// </summary>
    private void preparePaymentForSettlement()
    {
        if (!settleNowState.getAreCreditsDone() && (settleNowState.getAreDebitsDone() || settlementPair.getSpecTransCredit().Balance01 == 0))
        {
            boolean areCreditsDone = !settlementPair.fetchPayment(
                settleNowState.getSpecCompany(),
                settleNowState.getSpecTableId(),
                settleNowState.getSpecRecId());
            settleNowState.setAreCreditsDone(areCreditsDone);

            // <GIN>
            if (settleNowState.getAreCreditsDone()
                    && TaxWithholdParameters_IN::checkTaxParameters()
                    && TaxWithholdParameters_IN::findByCompany(settlementPair.getCreditCompany()).CrossCompanyPayment
                    && settlementPair.getCreditCompany() != settlementPair.getDebitCompany()
                    && TaxWithholdTrans_IN::hasTaxWHTTransByVoucher(settlementPair.getCustVendTransCredit().Voucher, settlementPair.getCustVendTransCredit().TransDate))
            {
                throw error(strFmt("@GLS6642", settlementPair.getCreditCompany()));
            }
            // </GIN>

            // <GEERU><GEEU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ, #isoHU, #isoPL]))
            {
                settleNowState.setPaymentReversedAmount(0);
            }
            // </GEEU></GEERU>

            if (!settleNowState.getAreCreditsDone())
            {
                creditTransState = SettlementTransactionState::Found;
                settleNowState.setIsCreditTransFullySettled(false);
                settleNowState.incrementSpecTransRecordsProcessed();
                instrumentationDimensionTracking.incrementNumberOfPayments();

                accountNumber = settlementPair.getCustVendTransOpenCredit().AccountNum;

                settleNowState.setOrigRemainCreditCur(settlementPair.getCustVendTransOpenCredit().AmountCur);
                // <GEERU><GEEU>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ, #isoHU, #isoPL]))
                {
                    settleNowState.setPaymentReversedAmounts(Map::create(CustVendTransData::construct(settlementPair.getCustVendTransCredit()).mapReversedAmountsCur_RU()));
                }
                // </GEEU></GEERU>
            }
            else
            {
                creditTransState = SettlementTransactionState::None;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDocumentJournalized</Name>
				<Source><![CDATA[
    private void isDocumentJournalized(CustVendTrans _custVendTrans)
    {
        if (_custVendTrans.AccountingEvent != 0)
        {
            AccountingEvent accountingEvent = AccountingEvent::find(_custVendTrans.AccountingEvent);

            if (accountingEvent.Type == AccountingEventType::PendingJournalized)
            {
                using (var proceedWithPendingJournalizationActivityContext = settlePendingJournalizationLogger.activityContextWithCustomProperties(CustVendSettlePendingJournalizationInstrumentationConstants::ProcessSettleWithPendingJournalization))
                {
                    proceedWithPendingJournalizationActivityContext.addCustomProperty(CustVendSettlePendingJournalizationInstrumentationConstants::ProcessCustVendTransRecId, any2Str(_custVendTrans.RecId));
                    if (SourceDocumentDetermineDistributionFactorsForSettlementFlight::instance().isEnabled())
                    {
                        proceedWithPendingJournalizationActivityContext.addCustomProperty(CustVendSettlePendingJournalizationInstrumentationConstants::ProceedSettleWithPendingJournalization, 'Yes');
                    }
                    else
                    {
                        proceedWithPendingJournalizationActivityContext.addCustomProperty(CustVendSettlePendingJournalizationInstrumentationConstants::ProceedSettleWithPendingJournalization, 'No');
                        throw error(strFmt("@SourceDocumentAccountingFramework:ThrowSettlementCannotBeDoneError", _custVendTrans.Invoice, ' ', _custVendTrans.Invoice));
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldProcessCurrentSettlement</Name>
				<Source><![CDATA[
    private boolean shouldProcessCurrentSettlement()
    {
        this.isDocumentJournalized(settlementPair.getCustVendTransCredit());
        this.isDocumentJournalized(settlementPair.getCustVendTransDebit());

        boolean shouldProcessCurrentSettlement = true;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ, #isoHU, #isoPL]))
        {
            taxVoucherCredit = '';
            taxVoucherDebit = '';

            if (!this.isBadDebtAmortisation_RU() && !this.checkIfCanBeSettled_RU(settlementPair.getTransactionDate()))
            {
                throw error("@GLS102725");
            }

            if (this.isCurrencyDeal_RU())
            {
                SettlementPair_VendCurrencyDeal_RU settlementPairCurrencyDeal = settlementPair;

                if (settlementPairCurrencyDeal.getBankAdvancedTransTypeCredit() != settlementPairCurrencyDeal.getBankAdvancedTransTypeDebit())
                {
                    shouldProcessCurrentSettlement = false;
                }
            }

            if (shouldProcessCurrentSettlement)
            {
                if (!this.checkCurDealCanBeSettled_RU())
                {
                    throw error("@GLS111008");
                }

                settleNowState.setPaymentReversedAmount(this.calcBalanceOnSelectedDate_W(
                            settlementPair.getSpecTransCredit(),
                            settlementPair.getCustVendTransCredit(),
                            settleNowState.getPaymentReversedAmounts(),
                            settleNowState.getPaymentReversedAmount()));

                shouldProcessCurrentSettlement = (settlementPair.getSpecTransCredit().Balance01 != 0.0);
            }

            if (shouldProcessCurrentSettlement)
            {
                settleNowState.setInvoiceReversedAmount(this.calcBalanceOnSelectedDate_W(
                            settlementPair.getSpecTransDebit(),
                            settlementPair.getCustVendTransDebit(),
                            settleNowState.getInvoiceReversedAmounts(),
                            settleNowState.getInvoiceReversedAmount()));

                shouldProcessCurrentSettlement = (settlementPair.getSpecTransDebit().Balance01 != 0.0);
            }
        }

        if (shouldProcessCurrentSettlement && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            if (!this.checkOverdueJournal_W())
            {
                throw error("@GLS111008");
            }
        }

        if (shouldProcessCurrentSettlement && !this.checkConsInvoice_JP())
        {
            throw error("@GLS111008");
        }

        return shouldProcessCurrentSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkConsInvoice_JP</Name>
				<Source><![CDATA[
    private boolean checkConsInvoice_JP()
    {
        boolean ret = true;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoJP]))
        {
            CustVendTrans custVendTrans;
            if (settlementPair.getCustVendTransDebit().Invoice)
            {
                custVendTrans = settlementPair.getCustVendTransDebit();
            }
            else if (settlementPair.getCustVendTransCredit().Invoice)
            {
                custVendTrans = settlementPair.getCustVendTransCredit();
            }

            if (custVendTrans)
            {
                changecompany(custVendTrans.company())
                {
                    CustVendConsInvoice_JP custVendConsInvoice = CustVendConsInvoice_JP::findByCustVendTrans(custVendTrans);

                    if (custVendConsInvoice && custVendConsInvoice.Status == CustVendConsInvoiceStatus_JP::Unconfirmed)
                    {
                        ret = checkFailed(strFmt(
                            "@ApplicationSuite_Localization:ErrorWhenSettleInvoiceInTheUnconfirmedConsInvoice",
                            custVendTrans.Invoice,
                            custVendTrans.company(),
                            custVendConsInvoice.ConsId));
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCurrentSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the current debit and credit transaction marked for settlement.
    /// </summary>
    /// <param name="_balancePostingProfile">
    /// A flag indicating whether to create additional transactions when the transactions have different posting profiles.
    /// </param>
    private void processCurrentSettlement(boolean _balancePostingProfile)
    {
        if (TaxWithholdingGlobalFeature::isExtendedWHTSupportedInCountryRegionOrParamEnabled()
            && !(settleNowState.getIsDebitTransFullySettled() && settleNowState.getIsCreditTransFullySettled())
            && (settlementPair.getSpecTransDebit().Balance01 != settlementPair.getCustVendTransOpenDebit().AmountCur))
        {
            settleNowState.setRealizedWhtExchAdjAmount(this.calcWHTRealizedExchAdjAmount_W(settlementPair.getCustVendTransDebit()));
        }

        TaxWithholdAmount debitTaxWithholdAmount = this.calcInvoiceTaxWithholdAmount();

        AmountCur vendorRetentionAmount;
        boolean includeVendRetentionFlightEnabled = FeatureStateProvider::isFeatureEnabled(ProjVendRetentionRefactorSettlementPercentFlight::instance());

        if (includeVendRetentionFlightEnabled)
        {
            // Get the vendor retention amount if conditional tax is enabled.
            vendorRetentionAmount = this.getRetentionAmount(settlementPair.getCustVendTransDebit());
        }

        // Add vendor retention amount to get the right calculation percetage for debit settlement factor.
        Percent origSettledPercentDebit = (settlementPair.getCustVendTransDebit().AmountCur  + vendorRetentionAmount) ? (settlementPair.getCustVendTransDebit().SettleAmountCur - debitTaxWithholdAmount) / (settlementPair.getCustVendTransDebit().AmountCur + vendorRetentionAmount) : 0;
        Percent origSettledPercentCredit = settlementPair.getCustVendTransCredit().AmountCur ? settlementPair.getCustVendTransCredit().SettleAmountCur / settlementPair.getCustVendTransCredit().AmountCur : 0;

        // <GBR>
        // Calculate and create fine and interest trans. Do this before cash discounts
        // so that specTrans.Balance01 is not adjusted before fine/interests have been
        // concidered.
        FinInterestAmount_BR finInterestAmountCurDebit;
        FinInterestAmount_BR finInterestAmountCurCredit;
        FinInterestAmount_BR finInterestAmountMstDebit;
        FinInterestAmount_BR finInterestAmountMstCredit;
        FinInterestAmount_BR finInterestAmountReportingDebit;
        FinInterestAmount_BR finInterestAmountReportingCredit;

        FineAmount_BR fineAmountCurDebit;
        FineAmount_BR fineAmountCurCredit;
        FineAmount_BR fineAmountMstDebit;
        FineAmount_BR fineAmountMstCredit;
        FineAmount_BR fineAmountReportingDebit;
        FineAmount_BR fineAmountReportingCredit;

        if (settleNowState.isBrazilEnabled())
        {
            [finInterestAmountCurDebit,
                finInterestAmountCurCredit,
                finInterestAmountMstDebit,
                finInterestAmountMstCredit,
                finInterestAmountReportingDebit,
                finInterestAmountReportingCredit] = this.processInterest_BR();

            [fineAmountCurDebit,
                fineAmountCurCredit,
                fineAmountMstDebit,
                fineAmountMstCredit,
                fineAmountReportingDebit,
                fineAmountReportingCredit] = this.processFine_BR();

            existFineInterestBR = finInterestAmountCurDebit || finInterestAmountCurCredit || fineAmountCurDebit || fineAmountCurCredit;
        }
        // </GBR>

        // Calculate and create the cash discount transactions
        container processCashDiscountResults = settlementPair.processCashDiscount(
            fullSettlement.isFullSettlement(),
            fullSettlement.getFullAmount(),
            settleNowState.getNumberOfSpecTransRecordsLeft());

        DiscAmount cashDiscountAmountDebit;
        DiscAmount cashDiscountAmountCredit;
        AmountMST cashDiscountAmountMstDebit;
        AmountMST cashDiscountAmountMstCredit;
        AmountMSTSecondary cashDiscountAmountReportingDebit;
        AmountMSTSecondary cashDiscountAmountReportingCredit;

        [cashDiscountAmountDebit,
            cashDiscountAmountCredit,
            cashDiscountAmountMstDebit,
            cashDiscountAmountMstCredit,
            cashDiscountAmountReportingDebit,
            cashDiscountAmountReportingCredit,
            cashDiscTransCodeDebit] = processCashDiscountResults;

        // Refactor: Remove ledger dimension calculation from SettlementPair and call SettlementUtility
        cashDiscLedgerDimensionDebit = settlementPair.getCashDiscount().getCashDiscLedgerDimensionDebit();
        cashDiscLedgerDimensionCredit = settlementPair.getCashDiscount().getCashDiscLedgerDimensionCredit();

        AmountCur vatTaxAgentAmountTransactionDebit;
        AmountMST vatTaxAgentAmountAccountingDebit;
        AmountCur vatTaxAgentAmountTransactionCredit;
        AmountMST vatTaxAgentAmountAccountingCredit;
        AmountMSTSecondary vatTaxAgentAmountReportingDebit;
        AmountMSTSecondary vatTaxAgentAmountReportingCredit;

        // <GEERU>
        if (settleNowState.isCountryRegion_RU())
        {
            [vatTaxAgentAmountTransactionDebit,
                vatTaxAgentAmountAccountingDebit,
                vatTaxAgentAmountReportingDebit,
                vatTaxAgentAmountTransactionCredit,
                vatTaxAgentAmountAccountingCredit,
                vatTaxAgentAmountReportingCredit
                ] = this.processVatTaxAgentAmounts_RU(settleNowState.getNumberOfSpecTransRecordsLeft());
        }
        // </GEERU>

        // Calculate settlement amount in debit and credit transaction currency
        AmountCur settleAmountCurDebit = settlementPair.getCalculator().calcSettleAmountCurForDebit(settleNowState.getNumberOfSpecTransRecordsLeft());

        // <GBR>
        if (settleNowState.isBrazilEnabled())
        {
            if (settlementPair.getCreditCompany() != settlementPair.getDebitCompany())
            {
                LedgerInterCompany interCompany = this.findLedgerInterCompany(settlementPair.getCreditCompany(), settlementPair.getDebitCompany());
                settleNowState.setFinInterestPostOption(interCompany.getFinInterestPostOptions_BR(this.parmModule()));
                settleNowState.setFinePostOption(interCompany.getFinePostOptions_BR(this.parmModule()));
            }

            // Intercompany Accounting -> Interest = Payment Company
            // Removing the Interest Amount from Debit settle (Invoice Company)
            if (settleNowState.isFinInterestPostOptionPaymentCompany()
                && finInterestAmountCurDebit != 0.0)
            {
                settleAmountCurDebit -= abs(finInterestAmountCurDebit);
            }

            // Intercompany Accounting -> Fine = Payment Company
            // Removing the Fine Amount from Debit settle (Invoice Company)
            if (settleNowState.isFinePostOptionPaymentCompany()
                && fineAmountCurDebit != 0.0)
            {
                settleAmountCurDebit -= abs(fineAmountCurDebit);
            }
        }
        // </GBR>

        AmountCur roundedSettleAmountCurDebit = CurrencyExchange::round(settleAmountCurDebit, settlementPair.getCustVendTransDebit().CurrencyCode);
        AmountCur settleAmountCurCredit = settlementPair.getCalculator().calcSettleAmountCurForCredit(settleAmountCurDebit);

        // <GBR>
        if (settleNowState.isBrazilEnabled())
        {
            // Intercompany Accounting -> Interest = Payment Company
            // Important to note: roundedSettleAmountCurDebit is based on settleAmountCurDebit
            // Adding back the interest amount to Credit Settle (Payment Company)
            if (settleNowState.isFinInterestPostOptionPaymentCompany()
                && finInterestAmountCurDebit)
            {
                settleAmountCurCredit -= abs(finInterestAmountCurDebit);
            }

            // Intercompany Accounting -> Fine = Payment Company
            // Adding back the fine amount to Credit Settle (Payment Company)
            if (settleNowState.isFinePostOptionPaymentCompany()
                && fineAmountCurDebit)
            {
                settleAmountCurCredit -= abs(fineAmountCurDebit);
            }
        }
        // </GBR>

        AmountCur roundedSettleAmountCurCredit = CurrencyExchange::round(settleAmountCurCredit, settlementPair.getCustVendTransCredit().CurrencyCode);

        if (settleAmountCurDebit != 0)
        {
            debitTransState = SettlementTransactionState::Settled;
            creditTransState = SettlementTransactionState::Settled;
        }

        if (includeVendRetentionFlightEnabled)
        {
            // If settlement amount is equal to transaction amount - already settled amount, vendor retention addition is not needed.
            CustVendTrans custVendTrans = settlementPair.getCustVendTransDebit().data();
            if (settleAmountCurDebit == (custVendTrans.AmountCur - custVendTrans.SettleAmountCur))
            {
                vendorRetentionAmount = 0;
            }
        }

        Percent settledFactorDebit = SettlementUtility::calcSettleFactor(
            settlementPair.getCustVendTransDebit().AmountCur + vendorRetentionAmount,
            settlementPair.getCustVendTransDebit().SettleAmountCur,
            settleAmountCurDebit,
            cashDiscountAmountDebit);

        Percent settledFactorCredit = SettlementUtility::calcSettleFactor(
            settlementPair.getCustVendTransCredit().AmountCur,
            settlementPair.getCustVendTransCredit().SettleAmountCur,
            settleAmountCurCredit,
            cashDiscountAmountCredit);

        // Update currency fields on debit and credit transactions
        if (settleNowState.isBrazilEnabled())
        {
            // In order to correctly update the "Transactions" it is necessary to consider the Interest/Fine amounts
            AmountCur finInterestAndFineAmountCurDebit = 0;
            AmountCur finInterestAndFineAmountCurCredit = 0;

            // Intercompany Accounting -> Interest = Payment Company
            if (settleNowState.isFinInterestPostOptionPaymentCompany()
                && (finInterestAmountCurDebit || finInterestAmountCurCredit))
            {
                finInterestAndFineAmountCurDebit += finInterestAmountCurDebit;
                finInterestAndFineAmountCurCredit += finInterestAmountCurCredit;
            }

            // Intercompany Accounting -> Fine = Payment Company
            if (settleNowState.isFinePostOptionPaymentCompany()
                && (fineAmountCurDebit || fineAmountCurCredit))
            {
                finInterestAndFineAmountCurDebit += fineAmountCurDebit;
                finInterestAndFineAmountCurCredit += fineAmountCurCredit;
            }

            // Adding the Interest and Fine Amounts
            settlementPair.updateSettleAmountCurOnTrans(
                roundedSettleAmountCurDebit + abs(finInterestAndFineAmountCurDebit),
                roundedSettleAmountCurCredit + abs(finInterestAndFineAmountCurCredit));
        }
        else
        {
            settlementPair.updateSettleAmountCurOnTrans(
                roundedSettleAmountCurDebit,
                roundedSettleAmountCurCredit);

            CustVendTrans custVendTransCredit = settlementPair.getCustVendTransCredit();

            if (custVendTransCredit.TableId == tableNum(CustTrans)
                &&FeatureStateProvider::isFeatureEnabled(IncludeOnlyPPDAmountsInSettlementTotal_MXFeature::instance()))
            {
                CustVendTrans custTransLoc = settlementPair.getCustVendTransDebit();
                if (!EInvoiceCFDIJournalHelper::isPUETransaction(custTransLoc))
                {
                    custVendTransCredit.SettleAmount_MX -= roundedSettleAmountCurCredit;
                }
            }
        }

        settleNowState.setIsDebitTransFullySettled(settlementPair.getCustVendTransDebit().AmountCur == settlementPair.getCustVendTransDebit().SettleAmountCur);
        settleNowState.setIsCreditTransFullySettled(settlementPair.getCustVendTransCredit().AmountCur == settlementPair.getCustVendTransCredit().SettleAmountCur);

        // Calculate settlement amount in MST credit transaction currency and update credit transaction
        AmountMST settleAmountMstCredit = settlementPair.getCalculator().calcSettleAmountMstForCredit(
            settleAmountCurCredit,
            settleNowState.getIsCreditTransFullySettled());
        AmountMST roundedSettleAmountMstCredit = CurrencyExchange::round(settleAmountMstCredit, settlementPair.getCreditCompanyCurrency());

        // Calculate settlement amount in MST debit transaction currency and update debit transaction
        AmountMST settleAmountMstDebit = settlementPair.getCalculator().calcSettleAmountMstForDebit(
            settleAmountCurDebit,
            roundedSettleAmountMstCredit);
        AmountMST roundedSettleAmountMstDebit = CurrencyExchange::round(settleAmountMstDebit, settlementPair.getDebitCompanyCurrency());

        // <GIN>
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            CustVendTrans_W custVendTransCreditW = settlementPair.getCustVendTransCredit().CustVendTrans::getCustVendTrans_W();
            CustVendTrans_W custVendTransDebitW = settlementPair.getCustVendTransDebit().CustVendTrans::getCustVendTrans_W();

            TableId specTableId = SpecTrans::findSpecSourceTableId(
                settleNowState.getSpecCompany(),
                settleNowState.getSpecTableId(),
                settleNowState.getSpecRecId());

            // Update the WHT fields based on the settledFactor.
            // Scenario : When taxes are calculated on invoice and making excess payment by selecting the invoice for settlement.
            // The taxes are calculated only on the excess Amount, so the TDSAmount_IN/TCSAmount_IN and TaxWithholdAmountOrigin_IN do not need to settle here.
            if (settledFactorDebit > 0
                && ((specTableId == tableNum(PurchTable) || specTableId == tableNum(SalesTable) || specTableId == tableNum(CustInvoiceTable))
                    && !(custVendTransCreditW.tdsAmount_IN || custVendTransCreditW.tcsAmount_IN))
                || (specTableId != tableNum(PurchTable) && specTableId != tableNum(SalesTable) && specTableId != tableNum(CustInvoiceTable)))
            {
                // Scenario : when invoice without TDS/TCS along with advance payment are used in payment journal, the standard settlefactor needs to be
                // refactored.
                if (settlementPair.getCustVendTransOpenDebit().TaxWithholdAmountOrigin_IN)
                {
                    Percent whtSettledfactor = settledFactorDebit;
                    settlementPair.getCustVendTransOpenDebit().tdsAmount_IN -= CurrencyExchange::round(settlementPair.getCustVendTransOpenDebit().tdsAmount_IN * whtSettledfactor, settlementPair.getCustVendTransDebit().CurrencyCode);
                    settlementPair.getCustVendTransOpenDebit().tcsAmount_IN -= CurrencyExchange::round(settlementPair.getCustVendTransOpenDebit().tcsAmount_IN * whtSettledfactor, settlementPair.getCustVendTransDebit().CurrencyCode);
                    settlementPair.getCustVendTransOpenDebit().TaxWithholdAmountOrigin_IN -= CurrencyExchange::round(settlementPair.getCustVendTransOpenDebit().TaxWithholdAmountOrigin_IN * whtSettledfactor, settlementPair.getCustVendTransDebit().CurrencyCode);
                }
            }

            // Scenario : When taxes are calculated on payment and making invoice with excessAmount than payment, by selecting the payment for settlement.
            // The taxes are calculated only on the excess Amount, so the TDSAmount_IN/TCSAmount_IN and TaxWithholdAmountOrigin_IN do not need to settle here.
            if (settledFactorCredit > 0
                && (specTableId == tableNum(LedgerJournalTrans)
                    && !(custVendTransDebitW.tdsAmount_IN || custVendTransDebitW.tcsAmount_IN))
                || specTableId != tableNum(LedgerJournalTrans))
            {
                // Scenario : when invoice without TDS/TCS along with advance payment are used in payment journal, the standard settlefactor needs to be
                // refactored.
                if (settlementPair.getCustVendTransOpenCredit().TaxWithholdAmountOrigin_IN)
                {
                    Percent whtSettledfactor = abs((settleAmountMstCredit + CurrencyExchangeHelper::mstAmount(cashDiscountAmountCredit, settlementPair.getCustVendTransCredit().CurrencyCode)) /settlementPair.getCustVendTransOpenCredit().TaxWithholdAmountOrigin_IN);
                    settlementPair.getCustVendTransOpenCredit().tdsAmount_IN -= CurrencyExchange::round(settlementPair.getCustVendTransOpenCredit().tdsAmount_IN * whtSettledfactor, settlementPair.getCustVendTransCredit().CurrencyCode);
                    settlementPair.getCustVendTransOpenCredit().tcsAmount_IN -= CurrencyExchange::round(settlementPair.getCustVendTransOpenCredit().tcsAmount_IN * whtSettledfactor, settlementPair.getCustVendTransCredit().CurrencyCode);
                    settlementPair.getCustVendTransOpenCredit().TaxWithholdAmountOrigin_IN -= CurrencyExchange::round(settlementPair.getCustVendTransOpenCredit().TaxWithholdAmountOrigin_IN * whtSettledfactor, settlementPair.getCustVendTransCredit().CurrencyCode);
                }
            }
        }
        // </GIN>

        // Calculate settlement amount in Reporting currency and update transactions
        AmountMSTSecondary roundedSettleAmountReportingCredit = settlementPair.getCalculator().calcSettleReportingAmountCredit(
            settleAmountCurCredit,
            settleNowState.getIsCreditTransFullySettled());
        AmountMSTSecondary roundedSettleAmountReportingDebit = settlementPair.getCalculator().calcSettleReportingAmountDebit(
            settleAmountCurDebit,
            roundedSettleAmountReportingCredit);

        // Calculate the realized exchange adjustment gain or loss amount
        AmountMST realizedExchAdjAmount = settlementPair.getCalculator().calcRealizedExchAdjAmount(
            settleAmountCurDebit,
            cashDiscountAmountDebit,
            roundedSettleAmountMstDebit + cashDiscountAmountMstDebit,
            cashDiscountAmountMstDebit,
            settleNowState.getIsDebitTransFullySettled());

        AmountMSTSecondary realizedReportingExchAdjAmount = settlementPair.calcRealizedReportingExchAdjAmount(
            settleAmountCurDebit,
            cashDiscountAmountDebit,
            roundedSettleAmountReportingDebit + cashDiscountAmountReportingDebit,
            cashDiscountAmountReportingDebit,
            settleNowState.getIsDebitTransFullySettled());

        if (TaxWithholdingGlobalFeature::isExtendedWHTSupportedInCountryRegionOrParamEnabled()
            && !(settleNowState.getIsDebitTransFullySettled()
                && settleNowState.getIsCreditTransFullySettled()))
        {
            realizedExchAdjAmount += settleNowState.getRealizedWhtExchAdjAmount();
            settlementPair.getCustVendTransDebit().SettleAmountMST -= settleNowState.getRealizedWhtExchAdjAmount();
        }

        AmountMST unrealizedExchAdjAmountDebit;
        AmountMST unrealizedExchAdjAmountCredit;
        AmountMSTSecondary unrealizedReportingExchAdjAmountDebit;
        AmountMSTSecondary unrealizedReportingExchAdjAmountCredit;

        // Calculate the unrealized exchange adjustment that needs to be reversed
        // For "core" exchRateDiffCalcType == ExchRateDiffCalcType_W::Standard is always true
        if (exchRateDiffCalcType == ExchRateDiffCalcType_W::Standard)
        {
            unrealizedExchAdjAmountDebit = SettlementUtility::calcUnrealizedExchAdjToReverse(
                settlementPair.getCustVendTransDebit().AmountCur,
                settlementPair.getCustVendTransDebit().SettleAmountCur,
                settlementPair.getCustVendTransDebit().ExchAdjustmentUnrealized,
                settledFactorDebit,
                settlementPair.getDebitCompanyCurrency());

            unrealizedExchAdjAmountCredit = SettlementUtility::calcUnrealizedExchAdjToReverse(
                settlementPair.getCustVendTransCredit().AmountCur,
                settlementPair.getCustVendTransCredit().SettleAmountCur,
                settlementPair.getCustVendTransCredit().ExchAdjustmentUnrealized,
                settledFactorCredit,
                settlementPair.getCreditCompanyCurrency());

            unrealizedReportingExchAdjAmountDebit = SettlementUtility::calcUnrealizedReportingExchAdjToReverse(
                settlementPair.getCustVendTransDebit().AmountCur,
                settlementPair.getCustVendTransDebit().SettleAmountCur,
                settlementPair.getCustVendTransDebit().ReportingExchAdjustmentUnrealized,
                settledFactorDebit,
                settlementPair.getCustVendTransDebit().company());

            unrealizedReportingExchAdjAmountCredit = SettlementUtility::calcUnrealizedReportingExchAdjToReverse(
                settlementPair.getCustVendTransCredit().AmountCur,
                settlementPair.getCustVendTransCredit().SettleAmountCur,
                settlementPair.getCustVendTransCredit().ReportingExchAdjustmentUnrealized,
                settledFactorCredit,
                settlementPair.getCustVendTransCredit().company());
        }
        // make sure the balance of transaction is zero when fully settled

        // <GBR>
        if (settleNowState.isBrazilEnabled())
        {
            // In order to correctly update the "Transactions" it is necessary to consider the Interest/Fine amounts
            AmountCur finInterestAndFineAmountMSTDebit = 0;
            AmountCur finInterestAndFineAmountMSTCredit = 0;
            AmountCur finInterestAndFineAmountReportingDebit = 0;
            AmountCur finInterestAndFineAmountReportingCredit = 0;

            // Intercompany Accounting -> Interest = Payment Company
            if (settleNowState.isFinInterestPostOptionPaymentCompany())
            {
                if (finInterestAmountMstDebit || finInterestAmountMstCredit)
                {
                    finInterestAndFineAmountMSTDebit += finInterestAmountMstDebit;
                    finInterestAndFineAmountMSTCredit += finInterestAmountMstCredit;
                }
                if (finInterestAmountReportingDebit || finInterestAmountReportingCredit)
                {
                    finInterestAndFineAmountReportingDebit += finInterestAmountReportingDebit;
                    finInterestAndFineAmountReportingCredit += finInterestAmountReportingCredit;
                }
            }

            // Intercompany Accounting -> Fine = Payment Company
            if (settleNowState.isFinePostOptionPaymentCompany())
            {
                if (fineAmountMstDebit || fineAmountMstCredit)
                {
                    finInterestAndFineAmountMSTDebit += fineAmountMstDebit;
                    finInterestAndFineAmountMSTCredit += fineAmountMstCredit;
                }
                if (fineAmountReportingDebit || fineAmountReportingCredit)
                {
                    finInterestAndFineAmountReportingDebit += fineAmountReportingDebit;
                    finInterestAndFineAmountReportingCredit += fineAmountReportingCredit;
                }
            }

            roundedSettleAmountMstDebit = settlementPair.adjustSettleAmountForFullySettled(
                roundedSettleAmountMstDebit + abs(finInterestAndFineAmountMSTDebit),
                realizedExchAdjAmount,
                unrealizedExchAdjAmountDebit,
                settleNowState.getIsDebitTransFullySettled()) - abs(finInterestAndFineAmountMSTDebit);

            roundedSettleAmountReportingDebit = settlementPair.adjustSettleAmountReportingForFullySettled(
                roundedSettleAmountReportingDebit + abs(finInterestAndFineAmountReportingDebit),
                realizedReportingExchAdjAmount,
                unrealizedReportingExchAdjAmountDebit,
                settleNowState.getIsDebitTransFullySettled()) - abs(finInterestAndFineAmountReportingDebit);

            settlementPair.updateSettleAmountMstOnDebitTrans(roundedSettleAmountMstDebit + abs(finInterestAndFineAmountMSTDebit), realizedExchAdjAmount, settleNowState.getIsDebitTransFullySettled());
            settlementPair.updateSettleAmountMstOnCreditTrans(roundedSettleAmountMstCredit + abs(finInterestAndFineAmountMSTCredit), 0, settleNowState.getIsCreditTransFullySettled());

            settlementPair.updateSettleAmountReportingOnDebitTrans(roundedSettleAmountReportingDebit + abs(finInterestAndFineAmountReportingDebit), realizedReportingExchAdjAmount, settleNowState.getIsDebitTransFullySettled());
            settlementPair.updateSettleAmountReportingOnCreditTrans(roundedSettleAmountReportingCredit + abs(finInterestAndFineAmountReportingCredit), 0, settleNowState.getIsCreditTransFullySettled());
        }
        else
        {
            // </GBR>

            roundedSettleAmountMstDebit = settlementPair.adjustSettleAmountForFullySettled(
                roundedSettleAmountMstDebit,
                realizedExchAdjAmount,
                unrealizedExchAdjAmountDebit,
                settleNowState.getIsDebitTransFullySettled());

            roundedSettleAmountReportingDebit = settlementPair.adjustSettleAmountReportingForFullySettled(
                roundedSettleAmountReportingDebit,
                realizedReportingExchAdjAmount,
                unrealizedReportingExchAdjAmountDebit,
                settleNowState.getIsDebitTransFullySettled());

            settlementPair.updateSettleAmountMstOnDebitTrans(roundedSettleAmountMstDebit, realizedExchAdjAmount, settleNowState.getIsDebitTransFullySettled());
            settlementPair.updateSettleAmountMstOnCreditTrans(roundedSettleAmountMstCredit, 0, settleNowState.getIsCreditTransFullySettled());

            settlementPair.updateSettleAmountReportingOnDebitTrans(roundedSettleAmountReportingDebit, realizedReportingExchAdjAmount, settleNowState.getIsDebitTransFullySettled());
            settlementPair.updateSettleAmountReportingOnCreditTrans(roundedSettleAmountReportingCredit, 0, settleNowState.getIsCreditTransFullySettled());

            // <GBR>
        }
        // </GBR>

        // <GEERU>
        if (exchRateDiffCalcType == ExchRateDiffCalcType_W::Standard)
        {
            // </GEERU>
            this.updateExchAdjAmountOnTrans(
                realizedExchAdjAmount,
                unrealizedExchAdjAmountDebit,
                realizedReportingExchAdjAmount,
                unrealizedReportingExchAdjAmountDebit,
                settlementPair.getCustVendTransDebit(),
                settlementPair.getCustVendTransOpenDebit());

            this.updateExchAdjAmountOnTrans(
                0,
                unrealizedExchAdjAmountCredit,
                0,
                unrealizedReportingExchAdjAmountCredit,
                settlementPair.getCustVendTransCredit(),
                settlementPair.getCustVendTransOpenCredit());
            // <GEERU>
        }
        else
        {
            if (firstCustVendTrans.RecId == settlementPair.getCustVendTransCredit().RecId)
            {
                this.updateExchAdjAmountOnTrans(
                    realizedExchAdjAmount,
                    unrealizedExchAdjAmountDebit,
                    realizedReportingExchAdjAmount,
                    unrealizedReportingExchAdjAmountDebit,
                    settlementPair.getCustVendTransDebit(),
                    settlementPair.getCustVendTransOpenDebit());
            }
        }
        // </GEERU>
        // Update other fields on transactions
        settlementPair.updateOtherSettlementFieldsOnTrans(settleNowState.getIsDebitTransFullySettled(), settleNowState.getIsCreditTransFullySettled());

        this.updateTransFor1099(settlementPair.getCustVendTransDebit().AmountCur, settleAmountCurDebit, cashDiscountAmountDebit);

        changecompany(settlementPair.getDebitCompany())
        {
            // <GEERU>
            if (settleNowState.isCountryRegion_RU())
            {
                this.insertAgreementRecordList_RU(settleNowState.getAgreementSet(), settlementPair.getCustVendTransDebit());
            }
            // </GEERU>

            if (settleNowState.getIsDebitTransFullySettled())
            {
                this.postClosing(settlementPair.getCustVendTransDebit(), settlementPair.getTransactionDate());
            }

            // post intercompany due to and due from transaction only if needed
            // <GBR>
            if (settleNowState.isBrazilEnabled()
                    && (settleNowState.isFinInterestPostOptionPaymentCompany()
                        || settleNowState.isFinePostOptionPaymentCompany()))
            {
                this.postDueToAndFrom(roundedSettleAmountMstDebit,
                    -roundedSettleAmountMstDebit,
                    roundedSettleAmountCurDebit,
                    -roundedSettleAmountCurDebit,
                    roundedSettleAmountReportingDebit,
                    -roundedSettleAmountReportingDebit);
            }
            else
            {
                if (settlementPair.getCustVendTransDebit().TableId == tableNum(CustTrans)
                    && !savedCustVendTransDebit
                    && settlementPair.getCustVendTransDebit().MCRPaymOrderID // Only execute if the debit side resulted from a MCR payment
                    && isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
                {
                    // Need to be sure that settlementPair.getCustVendTransDebit() is related to a sales order
                    settleNowState.setCustInvoiceJour(CustInvoiceJour::findFromCustTrans(
                        settlementPair.getCustVendTransDebit().Invoice,
                        settlementPair.getCustVendTransDebit().TransDate,
                        settlementPair.getCustVendTransDebit().AccountNum));

                    // If there is debit still not settled, it is possible that the business process
                    // is to write off this underpaid amount - so need to check if this has occured.
                    // If it is a write off calculate the portion that will be written off.
                    if (settleNowState.getCustInvoiceJour()
                        && settleNowState.getCustInvoiceJour().SalesId == settlementPair.getCustVendTransDebit().MCRPaymOrderID)
                    {
                        savedCustVendTransDebit = settlementPair.getCustVendTransDebit();
                        SalesTable salesTable = SalesTable::find(settleNowState.getCustInvoiceJour().SalesId);
                        if (salesTable
                            && RetailMCRChannelTable::mcrEnableOrderCompletion(salesTable))
                        {
                            mcrOrderCompletionEnabled = true;
                            mcrOOBReleaseType = salesTable.mcrSalesTable().OutOfBalanceReleased;
                            
                            // Bug 840846: mcrOOBReleaseType and writeOffAmount are later used together in canProcessStillOpenTransSpecific
                            // to validate if we still have open transactions to settle at the end of processStillOpenTransactions.
                            // There is no need to calculate writeOffAmount for other cases, so just skip that call entirely.
                            boolean doOOBBalanceCalculationForWriteOffOnlyFlight = RetailPaymentsDoOOBCalculationForWriteOffOnlyFlight::instance().isEnabled();
                            if (!doOOBBalanceCalculationForWriteOffOnlyFlight || (doOOBBalanceCalculationForWriteOffOnlyFlight && mcrOOBReleaseType == MCROutOfBalanceReleaseType::WriteOff))
                            {
                                this.mcrCalcOutOfBalanceWriteOff(salesTable.RecId);
                            }
                        }
                    }
                }
                // </GBR>
                this.postDueToAndFrom(roundedSettleAmountMstDebit,
                    roundedSettleAmountMstCredit,
                    roundedSettleAmountCurDebit,
                    roundedSettleAmountCurCredit,
                    roundedSettleAmountReportingDebit,
                    roundedSettleAmountReportingCredit);
                // <GBR>
            }
            // </GBR>

            // post cash discount, this includes calculating and posting tax on cash discount
            postCashDiscountInSummary = true;

            AmountCur taxOnCashDiscountAmount = this.taxCashDisc(
                settlementPair.getCustVendTransDebit(),
                cashDiscountAmountDebit,
                cashDiscLedgerDimensionDebit,
                settlementPair.getExchRate().getDebitCurToDebitMstCombined(),
                settlementPair.getExchRate().getDebitCurToReporting());

            this.postDiscTrans(cashDiscountAmountDebit,
                cashDiscountAmountMstDebit,
                cashDiscountAmountReportingDebit,
                settlementPair.getCustVendTransDebit(),
                settlementPair.getCustVendTransOpenDebit(),
                settlementPair.getCustVendTransCredit(),
                settlementPair.getExchRate().getDebitCurToDebitMstCombined(),
                settlementPair.getExchRate().getDebitCurToReporting(),
                cashDiscLedgerDimensionDebit,
                taxOnCashDiscountAmount,
                roundedSettleAmountCurDebit,
                debitSettleDistController);

            cashDiscountAmounts.add(
                settlementPair.getCustVendTransOpenCredit().RecId,
                settlementPair.getCustVendTransDebit().RecId,
                settlementPair.getCustVendTransOpenDebit().RecId,
                settlementPair.getDebitCompany(),
                cashDiscountAmountMstDebit,
                cashDiscTransCodeDebit,
                settlementGroupPlaceHolder,
                settlementPair.findVoucherNumberByCompany(settlementPair.getDebitCompany()));

            // <GBR>
            if (settleNowState.isBrazilEnabled())
            {
                // Posting Interest
                this.postInterestTrans_BR(finInterestAmountCurDebit,
                    finInterestAmountMstDebit,
                    settlementPair.getCustVendTransDebit(),
                    settlementPair.getCustVendTransOpenDebit(),
                    settlementPair.getCustVendTransCredit(),
                    settlementPair.getCustVendTransDebit().exchRateCurToMst(),
                    this.interestLedgerDimension_BR(settlementPair.getCustVendTransDebit(),settlementPair.getCustVendTransOpenDebit(), finInterestAmountMstDebit),
                    roundedSettleAmountMstDebit,
                    debitSettleDistController);

                // Posting Fine
                this.postFineTrans_BR(fineAmountCurDebit,
                    fineAmountMstDebit,
                    settlementPair.getCustVendTransDebit(),
                    settlementPair.getCustVendTransOpenDebit(),
                    settlementPair.getCustVendTransCredit(),
                    settlementPair.getCustVendTransDebit().exchRateCurToMst(),
                    this.fineLedgerDimension_BR(settlementPair.getCustVendTransDebit(), settlementPair.getCustVendTransOpenDebit(), fineAmountCurDebit),
                    roundedSettleAmountMstDebit,
                    debitSettleDistController);
            }
            // </GBR>

            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                && LedgerParameters::find().JournalizingDefinitionEnableValue == NoYes::Yes
                && (!settlementPair.getCustVendTransDebit().isReimbursement()
                    && (_balancePostingProfile
                        || settlementPair.getCustVendTransDebit().Prepayment
                        || settlementPair.getCustVendTransCredit().Prepayment
                        || CustSettleJournalizingEntries::requiredAdditionalEntries(settlementPair.getCustVendTransDebit().TransType, settlementPair.getCustVendTransCredit().TransType))))
            {
                this.settleForDifferentProfilesOrPrepayment(roundedSettleAmountMstDebit,
                    roundedSettleAmountCurDebit,
                    roundedSettleAmountReportingDebit,
                    roundedSettleAmountCurCredit,
                    // <GEERU>
                    roundedSettleAmountMstCredit,
                    roundedSettleAmountReportingCredit,
                    (firstCustVendTrans.RecId == settlementPair.getCustVendTransCredit().RecId ?
                        (-roundedSettleAmountMstCredit - realizedExchAdjAmount) :
                        roundedSettleAmountMstDebit),
                    (firstCustVendTrans.RecId == settlementPair.getCustVendTransCredit().RecId ?
                        (-roundedSettleAmountReportingCredit - realizedReportingExchAdjAmount) :
                        roundedSettleAmountReportingDebit)
                    // </GEERU>
                    );

                custSettleJournalizingEntries.parmCustVendDiscTransMap().insert(settlementPair.getCustVendTransOpenDebit().RecId, [cashDiscountAmountDebit, cashDiscountAmountMstDebit, cashDiscountAmountReportingDebit]);
            }
            // <GEERU>
            else if (_balancePostingProfile
                || settlementPair.getCustVendTransDebit().Prepayment
                || settlementPair.getCustVendTransCredit().Prepayment
                || !settleNowState.isCountryRegion_RU()
                || !VendTable::find(settlementPair.getCustVendTransDebit().AccountNum).vatTaxAgent_RU)
            // </GEERU>
            {
                // this handles the posting profile difference for the debit and credit transaction and also adjust
                // tax on prepayment transactions.
                // <GEERU>
                this.settleForDifferentProfilesOrPrepayment(roundedSettleAmountMstDebit,
                    roundedSettleAmountCurDebit,
                    roundedSettleAmountReportingDebit,
                    roundedSettleAmountCurCredit,
                    roundedSettleAmountMstCredit,
                    roundedSettleAmountReportingCredit,
                    firstCustVendTrans.RecId == settlementPair.getCustVendTransCredit().RecId ?
                        (-roundedSettleAmountMstCredit - realizedExchAdjAmount) :
                        roundedSettleAmountMstDebit,
                    firstCustVendTrans.RecId == settlementPair.getCustVendTransCredit().RecId ?
                        (-roundedSettleAmountReportingCredit - realizedReportingExchAdjAmount) :
                        roundedSettleAmountReportingDebit);
                // </GEERU>
            }

            // <GEERU><GEEU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                [taxVoucherDebit, taxVoucherCredit] = this.processVATTransit_RU(
                    roundedSettleAmountMstDebit - realizedExchAdjAmount + cashDiscountAmountMstDebit,
                    roundedSettleAmountMstCredit + cashDiscountAmountMstCredit,
                    roundedSettleAmountCurDebit + cashDiscountAmountDebit,
                    roundedSettleAmountCurCredit + cashDiscountAmountCredit,
                    roundedSettleAmountReportingDebit - realizedReportingExchAdjAmount + cashDiscountAmountReportingDebit,
                    roundedSettleAmountReportingCredit + cashDiscountAmountReportingCredit,
                    vatTaxAgentAmountAccountingDebit,
                    vatTaxAgentAmountTransactionDebit,
                    vatTaxAgentAmountReportingDebit,
                    vatTaxAgentAmountAccountingCredit,
                    vatTaxAgentAmountTransactionCredit,
                    vatTaxAgentAmountReportingCredit);
            }

            if (exchRateDiffCalcType == ExchRateDiffCalcType_W::Standard)
            {
                // </GEEU></GEERU>
                // Post realized exch adjustment
                if ((realizedExchAdjAmount != 0 || realizedReportingExchAdjAmount != 0)
                    && this.canPostRealizedExchAdjustment(settlementPair))
                {
                    this.postExchRateDiff(realizedExchAdjAmount,
                        realizedReportingExchAdjAmount,
                        settlementPair.getCustVendTransDebit(),
                        debitSettleDistController,
                        false);
                }

                // Back out unrealized exchange adjustment
                if (unrealizedExchAdjAmountDebit != 0 || unrealizedReportingExchAdjAmountDebit != 0)
                {
                    this.postExchRateDiff(unrealizedExchAdjAmountDebit,
                        unrealizedReportingExchAdjAmountDebit,
                        settlementPair.getCustVendTransDebit(),
                        debitSettleDistController,
                        true);

                    this.createSettlementToReverseUnrealExchAdj(unrealizedExchAdjAmountDebit, unrealizedReportingExchAdjAmountDebit, settlementPair.getCustVendTransDebit(), settlementPair.getCustVendTransOpenDebit());
                }
                // <GEERU><GEEU>
            }
            // </GEEU></GEERU>

            // <GIN>
            // Skip for cancelling/adjusting FTI, payment entries already reversed during cancelling FTI posting.
            if (TaxParameters::isServiceTaxEnable_IN())
            {
                TableId specTableIdLoc = SpecTrans::findSpecSourceTableId(
                    settleNowState.getSpecCompany(),
                    settleNowState.getSpecTableId(),
                    settleNowState.getSpecRecId());
                RecId specRecIdLoc = SpecTrans::findSpecSourceRecId(
                    settleNowState.getSpecCompany(),
                    settleNowState.getSpecTableId(),
                    settleNowState.getSpecRecId());

                LedgerJournalTrans ledgerJournalTrans = LedgerJournalTrans::find(relatedJournalId, settlementPair.getCustVendTransCredit().Voucher , false);

                if (!CustVendSettle::isOriginAdjustingInvoice_IN(specTableIdLoc, specRecIdLoc)
                    && specTableIdLoc == tableNum(CustInvoiceTable)
                    && CustInvoiceTable::findRecId(specRecIdLoc).CorrectionReasonCode)
                {
                    this.parmParentCustTrans_IN(settlementPair.getCustVendTransDebit());
                }

                this.processServiceTax_IN(
                    origSettledPercentDebit,
                    origSettledPercentCredit,
                    cashDiscountAmountDebit,
                    cashDiscountAmountCredit,
                    ledgerJournalTrans,
                    specTableIdLoc);
            }
            // </GIN>

            LedgerJournalTrans ledgerJournalTransLoc;
            select firstonly RecId from ledgerJournalTransLoc where ledgerJournalTransLoc.Voucher == settlementPair.getCustVendTransCredit().Voucher;
            if (ledgerJournalTransLoc.RecId)
            {
                processConditionalTaxForPDC = this.processPDCConditionalTax(ledgerJournalTransLoc.RecId);
            }

            if (this.shouldProcessConditionalTax())
            {
                this.processConditionalTax(origSettledPercentDebit, origSettledPercentCredit, cashDiscountAmountDebit, cashDiscountAmountCredit);
            }

            if (!FeatureStateProvider::isFeatureEnabled(TaxWithholdCustomerThresholdBasedOnPaymentOnlyFeature::instance()))
            {
                if (TaxWithholdParameters_IN::checkTaxParameters() && settlementPair.getCustVendTransDebit().TableId == tableNum(CustTrans))
                {
                    CustTrans custTransDebit = settlementPair.getCustVendTransDebit();
                    CustVendSettle::processInterimTaxWithholdWithReceiptDate(custTransDebit, settleAmountMstDebit, true, settlementPair.getTransactionDate());
                }
            }

            // <GTE>
            if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
            {
                this.processTax(origSettledPercentDebit, origSettledPercentCredit);
            }
            // </GTE>
        }

        changecompany(settlementPair.getCreditCompany())
        {
            // <GEERU>
            if (settleNowState.isCountryRegion_RU())
            {
                this.insertAgreementRecordList_RU(settleNowState.getAgreementSet(), settlementPair.getCustVendTransCredit());
            }
            // </GEERU>

            if (settleNowState.getIsCreditTransFullySettled())
            {
                this.postClosing(settlementPair.getCustVendTransCredit(), settlementPair.getTransactionDate());
            }

            // post cash discount, this includes calculating and posting tax on cash discount
            postCashDiscountInSummary = false;

            AmountCur taxOnCashDiscountAmount = this.taxCashDisc(
                settlementPair.getCustVendTransCredit(),
                cashDiscountAmountCredit,
                cashDiscLedgerDimensionCredit,
                settlementPair.getCustVendTransCredit().exchRateCurToMst(),
                settlementPair.getCustVendTransCredit().getReportingCombinedExchangeRate());

            this.postDiscTrans(cashDiscountAmountCredit,
                cashDiscountAmountMstCredit,
                cashDiscountAmountReportingCredit,
                settlementPair.getCustVendTransCredit(),
                settlementPair.getCustVendTransOpenCredit(),
                settlementPair.getCustVendTransCredit(),
                settlementPair.getCustVendTransCredit().exchRateCurToMst(),
                settlementPair.getCustVendTransCredit().getReportingCombinedExchangeRate(),
                cashDiscLedgerDimensionCredit,
                taxOnCashDiscountAmount,
                roundedSettleAmountCurDebit,
                creditSettleDistController);

            if (unrealizedExchAdjAmountCredit != 0 || unrealizedReportingExchAdjAmountCredit != 0)
            {
                // <GEERU>
                if (exchRateDiffCalcType == ExchRateDiffCalcType_W::Standard)
                {
                    // </GEERU>
                    this.postExchRateDiff(unrealizedExchAdjAmountCredit,
                        unrealizedReportingExchAdjAmountCredit,
                        settlementPair.getCustVendTransCredit(),
                        creditSettleDistController,
                        true);
                    this.createSettlementToReverseUnrealExchAdj(unrealizedExchAdjAmountCredit, unrealizedReportingExchAdjAmountCredit, settlementPair.getCustVendTransCredit(), settlementPair.getCustVendTransOpenCredit());
                    // <GEERU>
                }
                // </GEERU>
            }

            if (!FeatureStateProvider::isFeatureEnabled(TaxWithholdCustomerThresholdBasedOnPaymentOnlyFeature::instance()))
            {
                if (TaxWithholdParameters_IN::checkTaxParameters() && settlementPair.getCustVendTransCredit().TableId == tableNum(CustTrans))
                {
                    CustTrans custTransCredit = settlementPair.getCustVendTransCredit();
                    CustVendSettle::processInterimTaxWithholdWithReceiptDate(custTransCredit, settleAmountMstCredit, true, settlementPair.getTransactionDate());
                }
            }
        }

        boolean isCreditAnInvoice;

        changecompany(settlementPair.getDebitCompany())
        {
            // create settlement record for debit transaction, this is called after all settlement transaction
            // are created so it will have the correct settlement voucher number
            // <GBR>
            if (settleNowState.isBrazilEnabled())
            {
                if (settleNowState.isFinInterestPostOptionPaymentCompany()
                    || settleNowState.isFinePostOptionPaymentCompany())
                {
                    settlementPair.createSettlementForDebitTrans(
                        custVendTransSettlement,
                        settlementGroupPlaceHolder,
                        roundedSettleAmountMstDebit,
                        roundedSettleAmountCurDebit,
                        roundedSettleAmountReportingDebit,
                        realizedExchAdjAmount,
                        realizedReportingExchAdjAmount,
                        cashDiscountAmountDebit,
                        cashDiscountAmountMstDebit,
                        cashDiscountAmountReportingDebit,
                        NoYes::Yes,
                        -vendTax1099Manager.parmSettleDebitTax1099Amount(),
                        -vendTax1099Manager.parmSettleDebitTax1099StateAmount(),
                        taxVoucherDebit,
                        vatTaxAgentAmountTransactionDebit,
                        vatTaxAgentAmountAccountingDebit,
                        vatTaxAgentAmountReportingDebit,
                        finInterestAmountCurDebit,
                        fineAmountCurDebit);
                }
                else
                {
                    settlementPair.createSettlementForDebitTrans(
                        custVendTransSettlement,
                        settlementGroupPlaceHolder,
                        roundedSettleAmountMstDebit - abs(finInterestAmountMstDebit) - abs(fineAmountMstDebit),
                        roundedSettleAmountCurDebit - abs(finInterestAmountCurDebit) - abs(fineAmountCurDebit),
                        roundedSettleAmountReportingDebit - abs(finInterestAmountReportingDebit) - abs(fineAmountReportingDebit),
                        realizedExchAdjAmount,
                        realizedReportingExchAdjAmount,
                        cashDiscountAmountDebit,
                        cashDiscountAmountMstDebit,
                        cashDiscountAmountReportingDebit,
                        NoYes::Yes,
                        -vendTax1099Manager.parmSettleDebitTax1099Amount(),
                        -vendTax1099Manager.parmSettleDebitTax1099StateAmount(),
                        taxVoucherDebit,
                        vatTaxAgentAmountTransactionDebit,
                        vatTaxAgentAmountAccountingDebit,
                        vatTaxAgentAmountReportingDebit,
                        finInterestAmountCurDebit,
                        fineAmountCurDebit);
                }
            }
            else
            {
                // </GBR>
                settlementPair.createSettlementForDebitTrans(
                    custVendTransSettlement,
                    settlementGroupPlaceHolder,
                    roundedSettleAmountMstDebit,
                    roundedSettleAmountCurDebit,
                    roundedSettleAmountReportingDebit,
                    realizedExchAdjAmount,
                    realizedReportingExchAdjAmount,
                    cashDiscountAmountDebit,
                    cashDiscountAmountMstDebit,
                    cashDiscountAmountReportingDebit,
                    NoYes::Yes,
                    -vendTax1099Manager.parmSettleDebitTax1099Amount(),
                    // <GEERU>
                    -vendTax1099Manager.parmSettleDebitTax1099StateAmount(),
                    taxVoucherDebit,
                    vatTaxAgentAmountTransactionDebit,
                    vatTaxAgentAmountAccountingDebit,
                    vatTaxAgentAmountReportingDebit);
                    // </GEERU>
                // <GBR>
            }
            // </GBR>

            this.reverseAmounts(settlementPair.getCustVendTransDebit());
            this.updateTransOpen(settlementPair.getCustVendTransDebit(), settlementPair.getCustVendTransOpenDebit());

            // <GTH>
            if (isUnrealizedVATEnabled
                && settlementPair.getCustVendTransDebit().TableId == tableNum(CustTrans))
            {
                isCreditAnInvoice = this.updateTaxTransForCreditInvoice_TH();
            }
            // </GTH>

            settlementPair.getCustVendTransDebit().update();
            this.reverseAmounts(settlementPair.getCustVendTransDebit());

            // Update Project
            this.updateTransactionProject(settlementPair.getCustVendTransDebit(), settleNowState.getOrigRemainDebitCur(), roundedSettleAmountCurDebit);

            this.updateVendSettlementTax1099(roundedSettleAmountCurDebit, settlementPair.getExchRate().getPaymentToInvoice());

            // Update Advance Definition
            this.updateAdvanceDefinition(settlementPair.getCustVendTransDebit(), roundedSettleAmountCurDebit);
        }

        changecompany(settlementPair.getCreditCompany())
        {
            // <GBR>
            if (settleNowState.isBrazilEnabled())
            {
                // Posting Interest
                this.postInterestTrans_BR(finInterestAmountCurCredit,
                    finInterestAmountMstCredit,
                    settlementPair.getCustVendTransCredit(),
                    settlementPair.getCustVendTransOpenCredit(),
                    settlementPair.getCustVendTransCredit(),
                    settlementPair.getCustVendTransDebit().exchRateCurToMst(),
                    this.interestLedgerDimension_BR(settlementPair.getCustVendTransCredit(),settlementPair.getCustVendTransOpenCredit()),
                    roundedSettleAmountMstDebit,
                    creditSettleDistController);

                // Posting Fine
                this.postFineTrans_BR(fineAmountCurCredit,
                    fineAmountMstCredit,
                    settlementPair.getCustVendTransCredit(),
                    settlementPair.getCustVendTransOpenCredit(),
                    settlementPair.getCustVendTransCredit(),
                    settlementPair.getCustVendTransDebit().exchRateCurToMst(),
                    this.fineLedgerDimension_BR(settlementPair.getCustVendTransCredit(),settlementPair.getCustVendTransOpenCredit()),
                    roundedSettleAmountMstDebit,
                    creditSettleDistController);

                // create settlement record for credit transaction, this should be called after all settlement transaction
                // are created so it will have the correct settlement voucher number
                settlementPair.createSettlementForCreditTrans(
                    custVendTransSettlement,
                    settlementGroupPlaceHolder,
                    roundedSettleAmountMstCredit,
                    roundedSettleAmountCurCredit,
                    roundedSettleAmountReportingCredit,
                    0, // realized exch adj is always zero on credit transaction
                    0,
                    cashDiscountAmountCredit,
                    cashDiscountAmountMstCredit,
                    cashDiscountAmountReportingCredit,
                    NoYes::Yes,
                    vendTax1099Manager.parmSettleCreditTax1099Amount(),
                    vendTax1099Manager.parmSettleCreditTax1099StateAmount(),
                    taxVoucherCredit,
                    vatTaxAgentAmountTransactionCredit,
                    vatTaxAgentAmountAccountingCredit,
                    vatTaxAgentAmountReportingCredit,
                    finInterestAmountCurCredit,
                    fineAmountCurCredit);
            }
            else
            {
                // </GBR>

                // create settlement record for credit transaction, this should be called after all settlement transaction
                // are created so it will have the correct settlement voucher number
                settlementPair.createSettlementForCreditTrans(
                    custVendTransSettlement,
                    settlementGroupPlaceHolder,
                    roundedSettleAmountMstCredit,
                    roundedSettleAmountCurCredit,
                    roundedSettleAmountReportingCredit,
                    0, // realized exch adj is always zero on credit transaction
                    0,
                    cashDiscountAmountCredit,
                    cashDiscountAmountMstCredit,
                    cashDiscountAmountReportingCredit,
                    NoYes::Yes,
                    vendTax1099Manager.parmSettleCreditTax1099Amount(),
                    // <GEERU>
                    vendTax1099Manager.parmSettleCreditTax1099StateAmount(),
                    taxVoucherCredit,
                    vatTaxAgentAmountTransactionCredit,
                    vatTaxAgentAmountAccountingCredit,
                    vatTaxAgentAmountReportingCredit);
                // </GEERU>

                // <GBR>
            }
            // </GBR>

            // <GEERU><GEECZ>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]) && exchRateDiffCalcType != ExchRateDiffCalcType_W::Standard)
            {
                changecompany(settlementPair.getDebitCompany())
                {
                    LedgerVoucher localLedgerVoucher = this.parmLedgerVoucher_W(settlementPair.getDebitCompany());
                    Voucher localLedgerVoucherLastVoucher = localLedgerVoucher.lastVoucher();
                    TransDate localLedgerVoucherLastTransDate = localLedgerVoucher.lastTransDate();

                    CustVendExchAdjustment_W custVendExchAdjustment = CustVendExchAdjustment_W::newFromSettlement(this);
                    custVendExchAdjustment.setCustVendTransSettlement(custVendTransSettlement);
                    custVendExchAdjustment.setSettlementGroupPlaceHolder(settlementGroupPlaceHolder);

                    if (this.isCurrencyDeal_RU())
                    {
                        SettlementPair_VendCurrencyDeal_RU settlementPairCurrencyDeal = settlementPair;

                        custVendExchAdjustment.parmBankAdvancedTransType(settlementPairCurrencyDeal.getBankAdvancedTransTypeDebit());
                    }

                    custVendExchAdjustment.processRealizedExchAdj(
                        -realizedExchAdjAmount,
                        -realizedReportingExchAdjAmount,
                        firstCustVendTrans,
                        settlementPair.getCustVendTransDebit(),
                        settlementPair.getCustVendTransCredit(),
                        settlementPair.getCustVendTransOpenDebit(),
                        settlementPair.getCustVendTransOpenCredit(),
                        settleAmountCurDebit,
                        0,
                        cashDiscountAmountDebit,
                        cashDiscountAmountCredit,
                        taxVoucherDebit,
                        taxVoucherCredit,
                        settlementPair.getExchRate().getPaymentToInvoice());

                    localLedgerVoucher.lastVoucher(localLedgerVoucherLastVoucher);
                    localLedgerVoucher.lastTransDate(localLedgerVoucherLastTransDate);
                }
            }
            // </GEECZ></GEERU>

            this.reverseAmounts(settlementPair.getCustVendTransCredit());
            this.updateTransOpen(settlementPair.getCustVendTransCredit(), settlementPair.getCustVendTransOpenCredit());

            // <GTH>
            if (isUnrealizedVATEnabled
                && settlementPair.getCustVendTransCredit().TableId == tableNum(CustTrans))
            {
                if (settleNowState.getHasRealizedVAT())
                {
                    if (!isCreditAnInvoice)
                    {
                        this.updateCustReceipt_TH(settlementPair.getCustVendTransCredit());
                    }

                    settleNowState.setHasUpdateUnrealized(true);
                }

                this.updateTaxTransForUnrealizedVAT_TH(
                    settleNowState.getHasUnrealizedVAT(),
                    settleNowState.getHasUpdateUnrealized(),
                    isCreditAnInvoice,
                    settleNowState.getTaxInvoiceId(),
                    settleNowState.getTaxInvoiceDate(),
                    settleNowState.getSourceRecId());
            }
            // </GTH>

            settlementPair.getCustVendTransCredit().update();
            this.reverseAmounts(settlementPair.getCustVendTransCredit());

            // Update Project
            this.updateTransactionProject(settlementPair.getCustVendTransCredit(), settleNowState.getOrigRemainCreditCur(), roundedSettleAmountCurCredit);
        }

        this.addTransToTaxSortedList(settlementPair.getCustVendTransDebit().RecId,
            settlementPair.getCustVendTransDebit().Voucher,
            settlementPair.getDebitCompany(),
            settlementPair.getTransactionDate(),
            settlementPair.getCustVendTransDebit().AmountMST,
            roundedSettleAmountMstDebit,
            settlementPair.getCustVendTransCredit().RecId,
            settlementPair.getCreditCompany(),
            roundedSettleAmountMstCredit,
            settlementPair.getExchRate().getCreditMstToDebitMst(),
            settlementPair.findVoucherNumberByCompany(settlementPair.getDebitCompany()),
            settlementPair.findVoucherNumberByCompany(settlementPair.getCreditCompany()),
            settlementGroupPlaceHolder);

        custVendTransSettlementControl.ins(settlementPair.getCustVendTransDebit(), true);
        custVendTransSettlementControl.ins(settlementPair.getCustVendTransCredit(), true);

        // Reverse withholding tax when both payment and invoice have TDS.
        if (TaxWithholdParameters_IN::needReverseTDSForVendor()
            && this.parmOffsetTableId() == tableNum(VendTable))
        {
            TaxWithholdCustVendSettlementHelper_IN::processWithholdingTaxSettlement_IN(
                settlementPair.getCustVendTransDebit(),
                settlementPair.getCustVendTransCredit(),
                settleAmountCurCredit,
                settleAmountCurDebit,
                settleNowState.getIsDebitTransFullySettled(),
                custVendTransSettlement,
                settlementGroupPlaceHolder,
                settlementPair.getTransactionDate());
        }

        DiscAmount cashDiscAmountCurDebitToCredit = settlementPair.getCalculator().calcAmountCurFromDebitToCredit(cashDiscountAmountDebit);
        DiscAmount cashDiscAmountCurCreditToDebit = settlementPair.getCalculator().calcAmountCurFromCreditToDebit(cashDiscountAmountCredit);
        
        bankChequePaymTransCache.addBankChequePaymTrans(
            settlementPair,
            roundedSettleAmountCurDebit,
            roundedSettleAmountCurCredit,
            -cashDiscAmountCurCreditToDebit,
            -cashDiscAmountCurDebitToCredit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxTransForCreditInvoice_TH</Name>
				<Source><![CDATA[
    private boolean updateTaxTransForCreditInvoice_TH()
    {
        boolean isCreditAnInvoice = false;

        if (this.shouldUpdateTaxTransForCreditInvoice_TH())
        {
            TaxTrans taxTrans = TaxTrans::find(settlementPair.getCustVendTransDebit().Voucher, settlementPair.getCustVendTransDebit().TransDate);
            if (!taxTrans)
            {
                taxTrans = TaxTrans::find(settlementPair.getCustVendTransCredit().Voucher, settlementPair.getCustVendTransCredit().TransDate);
                isCreditAnInvoice = true;
            }

            if (taxTrans)
            {
                if (TaxTable::isRealizedVAT(taxTrans.TaxCode))
                {
                    settleNowState.setHasRealizedVAT(true);
                    if (isCreditAnInvoice)
                    {
                        this.updateCustReceipt_TH(settlementPair.getCustVendTransDebit());
                        this.updateCustTaxInvoice_TH(settlementPair.getCustVendTransCredit());

                        TaxTransExtensionTH taxTransExtensionTH;
                        select firstOnly forUpdate taxTransExtensionTH
                            exists join taxTrans
                                where taxTrans.RecId == taxTransExtensionTH.TaxTrans
                                    && taxTrans.SourceTableId == tableNum(CustTrans)
                                    && taxTrans.SourceRecId == settleNowState.getSourceRecId()
                                    && taxTrans.TaxOrigin == TaxOrigin::Payment;

                        if (taxTransExtensionTH)
                        {
                            RecId custInvoiceTableRecId = CustInvoiceTable::findPostedInvoice(
                                settleNowState.getCustInvoiceJour().InvoiceAccount,
                                settleNowState.getCustInvoiceJour().InvoiceId,
                                settleNowState.getCustInvoiceJour().InvoiceDate).RecId;

                            CustRelatedInvoice custRelatedInvoice;
                            select firstOnly InvoiceAssociationType from custRelatedInvoice
                                where custRelatedInvoice.OriginalCustInvoice == custInvoiceTableRecId
                                    && custRelatedInvoice.ParentCustInvoice == custInvoiceTableRecId;

                            if (custRelatedInvoice.InvoiceAssociationType != InvoiceAssociationType::CorrectedInvoice)
                            {
                                taxTransExtensionTH.TaxInvoiceId = this.getTaxInvoiceId(settleNowState.getTaxInvoiceId());
                            }

                            taxTransExtensionTH.TaxInvoiceDate = settleNowState.getTaxInvoiceDate();
                            taxTransExtensionTH.update();
                        }
                    }
                }
                else
                {
                    settleNowState.setHasUnrealizedVAT(true);
                    if (this.shouldUpdateCustTaxInvoice_TH(isCreditAnInvoice))
                    {
                        this.updateCustTaxInvoice_TH(settlementPair.getCustVendTransCredit());
                    }
                }
            }
        }

        return isCreditAnInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateTaxTransForCreditInvoice_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if it should update Taxtrans for credit invoice.
    /// </summary>
    /// <returns>Returns true if it should update TaxTrans for credit invoice; otherwise, false.</returns>
    protected boolean shouldUpdateTaxTransForCreditInvoice_TH()
    {
        return !settleNowState.getHasRealizedVAT() || !settleNowState.getHasUnrealizedVAT();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateCustTaxInvoice_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies if the customer tax invoice should be updated.
    /// </summary>
    /// <param name = "_isCreditAnInvoice">A boolean value whether the credit transaction is an invoice.</param>
    /// <returns>true if the customer tax invoice should be updated; otherwise, false.</returns>
    [Wrappable(true)]
    protected final boolean shouldUpdateCustTaxInvoice_TH(boolean _isCreditAnInvoice)
    {
        return _isCreditAnInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxTransForUnrealizedVAT_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the tax related fields for unrealized VAT.
    /// </summary>
    /// <param name = "_hasUnrealizedVAT">A boolean value whether there is an unrealized VAT.</param>
    /// <param name = "_hasUpdateUnrealized">A boolean value whether the unrealized VAT has been updated.</param>
    /// <param name = "_isCreditAnInvoice">A boolean value whether the credit transaction is an invoice.</param>
    /// <param name = "_taxInvoiceId">The tax invoice Id.</param>
    /// <param name = "_taxInvoiceDate">The tax invoice date.</param>
    /// <param name = "_sourceRecId">The Id of the source record.</param>
    [Wrappable(true)]
    protected final void updateTaxTransForUnrealizedVAT_TH(
        boolean _hasUnrealizedVAT,
        boolean _hasUpdateUnrealized,
        boolean _isCreditAnInvoice,
        DocumentNum _taxInvoiceId,
        TransDate _taxInvoiceDate,
        RecId _sourceRecId)
    {
        if (!_hasUnrealizedVAT || _hasUpdateUnrealized)
        {
            return;
        }

        boolean isCreditCorrectedInvoice = settlementPair.getCustVendTransCredit().Invoice != '';

        if (!_isCreditAnInvoice && !isCreditCorrectedInvoice)
        {
            this.updateCustTaxInvoice_TH(settlementPair.getCustVendTransCredit());
        }

        DocumentNum taxInvoiceId = _taxInvoiceId ? _taxInvoiceId : settleNowState.getTaxInvoiceId();
        TransDate taxInvoiceDate = _taxInvoiceDate ? _taxInvoiceDate : settleNowState.getTaxInvoiceDate();
        RecId sourceRecId = _sourceRecId ? _sourceRecId : settleNowState.getSourceRecId();

        TaxTrans taxTrans;
        TaxTransExtensionTH taxTransExtensionTH;
        update_recordset taxTransExtensionTH
            setting TaxInvoiceId = taxInvoiceId,
                TaxInvoiceDate = taxInvoiceDate
            exists join taxTrans
            where taxTrans.RecId == taxTransExtensionTH.TaxTrans
                && taxTrans.SourceTableId == tableNum(CustTrans)
                && taxTrans.SourceRecId == sourceRecId
                && taxTrans.TaxOrigin == TaxOrigin::Payment;

        settleNowState.setHasUpdateUnrealized(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRemainingOpenAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds remaining amounts that were left over from settling.
    /// </summary>
    private void addRemainingOpenAmounts()
    {
        // <GIN>
        if (TaxParameters::isServiceTaxEnable_IN())
        {
            CustVendSettle::checkServiceTaxPayment_IN(settlementPair.getCustVendTransCredit(), settlementPair.getCustVendTransDebit());
        }
        // </GIN>

        CustVendTrans custVendTransDebit = settlementPair.getCustVendTransDebit();
        CustTrans custTransDebit = custVendTransDebit.TableId == tableNum(CustTrans) ? custVendTransDebit : null;

        SpecTrans specTransDebit = settlementPair.getSpecTransDebit();
        AmountCur specTransDebitBalance01 = custTransDebit ? specTransDebit.orig().Balance01 : -specTransDebit.orig().Balance01;

        if (!settleNowState.getAreDebitsDone() && custVendTransDebit.AmountCur != 0
            && (!CustVendTransRemainingTotalTransNoPennyDiffFlight::instance().isEnabled()
                || (custTransDebit && custTransDebit.RetailTransactionId != '')
                || specTransDebitBalance01 != settlementPair.getCustVendTransOpenDebit().AmountCur))
        {
            if (!settlementPair.getCustVendTransCredit())
            {
                CustVendTrans custVendTransCredit = this.initCustVendTransBuffer();

                select firstonly DefaultDimension from custVendTransCredit
                    where custVendTransCredit.RecId == custVendTransDebit.OffsetRecId;

                settlementPair.setCustVendTransCredit(custVendTransCredit);
            }

            DimensionDefault defaultDimension;
            if (settlementPair.getCustVendTransCredit().DefaultDimension == 0
                || CustVendTransRemainingOpenAmountDimensionFlight::instance().isEnabled())
            {
                defaultDimension = custVendTransDebit.DefaultDimension;
            }
            else
            {
                defaultDimension = settlementPair.getCustVendTransCredit().DefaultDimension;
            }

            remainingOpenAmounts.add(
                custVendTransDebit.RecId,
                settlementPair.getDebitCompany(),
                custVendTransDebit.exchRateCurToMst(),
                settlementPair.getCustVendTransOpenDebit().RecId,
                specTransDebit.Balance01,
                defaultDimension,
                debitTransState,
                settlementGroupPlaceHolder);
        }

        CustVendTrans custVendTransCredit = settlementPair.getCustVendTransCredit();
        CustTrans custTransCredit = custVendTransCredit.TableId == tableNum(CustTrans) ? custVendTransCredit : null;

        SpecTrans specTransCredit = settlementPair.getSpecTransCredit();
        AmountCur specTransCreditBalance01 = custTransCredit ? specTransCredit.orig().Balance01 : -specTransCredit.orig().Balance01;

        if (!settleNowState.getAreCreditsDone() && custVendTransCredit.AmountCur != 0
            && (!CustVendTransRemainingTotalTransNoPennyDiffFlight::instance().isEnabled()
                || (custTransCredit && custTransCredit.RetailTransactionId != '')
                || specTransCreditBalance01 != settlementPair.getCustVendTransOpenCredit().AmountCur))
        {
            remainingOpenAmounts.add(
                custVendTransCredit.RecId,
                settlementPair.getCreditCompany(),
                custVendTransCredit.exchRateCurToMst(),
                settlementPair.getCustVendTransOpenCredit().RecId,
                specTransCredit.Balance01,
                custVendTransCredit.DefaultDimension,
                creditTransState,
                settlementGroupPlaceHolder);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldInitForNewSettlement</Name>
				<Source><![CDATA[
    private boolean shouldInitForNewSettlement()
    {
        return !settleNowState.getAreDebitsDone() && !settleNowState.getAreCreditsDone();
    }

]]></Source>
			</Method>
			<Method>
				<Name>positionSettlementPair</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prepares the <c>SettlementPair</c> object for settlement.
    /// </summary>
    private void positionSettlementPair()
    {
        this.prepareInvoiceForSettlement();
        this.preparePaymentForSettlement();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSettlementPair</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the <c>SettlementPair</c> instance for settlement.
    /// </summary>
    /// <param name="_balancePostingProfile">
    /// A flag indicating whether to create additional transactions when the transactions have different posting profiles.
    /// </param>
    [Wrappable(true)]
    protected final void processSettlementPair(boolean _balancePostingProfile)
    {
        if (this.shouldInitForNewSettlement())
        {
            // <GEERU>
            if (settleNowState.isCountryRegion_RU())
            {
                this.calcUnrealizedExchAdjCurrencyDeal_RU();
            }
            // </GEERU>

            this.initForNewSettlement();

            if (this.shouldProcessCurrentSettlement())
            {
                this.processCurrentSettlement(_balancePostingProfile);
                this.updateCollectionStatusForSettlement();
            }
        }
        else
        {
            this.addRemainingOpenAmounts();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCollectionStatusForSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update collection status for the settlement.
    /// </summary>
    internal void updateCollectionStatusForSettlement()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleNow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Settles the transactions associated with the specified parameters.
    /// </summary>
    /// <param name="_company">
    /// The spec company of the <c>SpecTrans</c> records to find.
    /// </param>
    /// <param name="_tableId">
    /// The spec table ID of the <c>SpecTrans</c> records to find.
    /// </param>
    /// <param name="_recId">
    /// The spec record ID of the <c>SpecTrans</c> records to find.
    /// </param>
    /// <param name="_balancePostingProfile">
    /// A flag indicating whether to create additional transactions when the transaction have different posting profiles.
    /// </param>
    /// <remarks>
    /// This method is the starting point of the settlement process.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// The transaction was oversettled.
    /// </exception>
    public void settleNow(dataAreaId _company, tableId _tableId, recId _recId, boolean _balancePostingProfile = true)
    {
        #ISOCountryRegionCodes

        using (SysInstrumentationActivityContext activityContext = this.getActivityContextForSettleNow())
        {
            ttsbegin;

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ, #isoHU, #isoPL]))
            {
                isSettlementActive = true;
            }

            custVendSettleLogger.logInformation('Start init process');
            this.init(_company, _tableId, _recId);

            if (settlementPair is SettlementPair_CustPaym && offsetVoucher is OffsetVoucherCust)
            {
                custVendSettleLogger.logInformation('Setup for custPaym settle');
                SettlementPair_CustPaym settlementPair_CustPaym = settlementPair as SettlementPair_CustPaym;
                OffsetVoucherCust offsetVoucherCust = offsetVoucher as OffsetVoucherCust;
                settlementPair_CustPaym.setIsAutoSettled(offsetVoucherCust.getIsAutoSettled());
            }

            custVendSettleLogger.logInformation(strFmt('Process settlement with balance posting profile: %1', any2Str(_balancePostingProfile)));
            while (!settleNowState.getAreDebitsDone() || !settleNowState.getAreCreditsDone())
            {
                this.positionSettlementPair();
                this.processSettlementPair(_balancePostingProfile);
            }

            if (_tableId != tableNum(ProjInvoiceJour))
            {
                custVendSettleLogger.logInformation('Process still open transactions');
                this.processStillOpenTransactions(settleNowState.getOrigRemainDebitCur());
            }

            bankChequePaymTransCache.insertAllBankChequePaymTrans();

            // check for over settlements
            custVendSettleLogger.logInformation('Check for over settlement');
            this.settlementControl();

            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                && LedgerParameters::find().JournalizingDefinitionEnableValue == NoYes::Yes)
            {
                custVendTransSettlement.parmCustSettleJournalizingEntries(custSettleJournalizingEntries);
                custSettleJournalizingEntries.parmBankTransactionTypes(bankTransactionTypes);
            }

            // Insert the CustVendTrans and CustVendSettlement records
            custVendSettleLogger.logInformation('Insert settlement records');
            custVendTransSettlement.post();

            this.updateTaxWithholdTransSpectransId();

            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                && LedgerParameters::find().JournalizingDefinitionEnableValue == NoYes::Yes)
            {
                custSettleJournalizingEntries.postJournalizingEntries();
            }

            SpecTrans::deleteSetForSingleOriginator(_company, _tableId, _recId);

            if (PublicSectorUtils::arePostingDefinitionsEnabledForPubSect()
                && LedgerParameters::find().IsSummarizeSettlementEnabled_PSN == NoYes::Yes)
            {
                CustVendSettleSummarization_PSN custVendSettleSummarization = CustVendSettleSummarization_PSN::construct(
                    accountNumber,
                    settlementPair.getTransactionDate(),
                    settlementPair.getLedgerVoucherGroup(),
                    settlementPair.numRefCustVendPaymVoucher(),
                    this.parmModule());

                custVendSettleSummarization.summarizeSettlementVoucherGroup();
            }

            if (this.moduleCustVend() == ModuleCustVend::Cust
                && EInvoiceCFDIParameters_MX::isElectronicInvoiceEnabled()
                && EInvoiceCFDIParameters_MX::find().CFDIVersion >= EInvoiceCFDIVersion_MX::V3_3)
            {
                EPaymentPost_MX::construct()
                    .processSettlement(this.getSettlementList_MX(), _tableId);

                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceMX00011, funcName());
            }

            // <GEERU>
            if (settleNowState.isCountryRegion_RU() && !AgreementHeaderExt_RU::checkAgreementCreditLimit(settleNowState.getAgreementSet()))
            {
                throw error("@SYS79485");
            }
            // </GEERU>

            ttscommit;

            this.captureSettleNowTelemetry(activityContext, _tableId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOffsetTableId</Name>
				<Source><![CDATA[
    internal TableId parmOffsetTableId(TableId _offsetTableId = offsetTableId)
    {
        offsetTableId = _offsetTableId;
        return offsetTableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityContextForSettleNow</Name>
				<Source><![CDATA[
    private SysInstrumentationActivityContext getActivityContextForSettleNow()
    {
        custVendSettleLogger = CustVendSettleLogger::createLogger(this.parmModule());
        return custVendSettleLogger.activityContextWithCustomProperties(CustVendInstrumentationConstants::SettleAction);
    }

]]></Source>
			</Method>
			<Method>
				<Name>captureSettleNowTelemetry</Name>
				<Source><![CDATA[
    private void captureSettleNowTelemetry(SysInstrumentationActivityContext _activityContext, TableId _originatingTableId)
    {
        int invoiceOrderOfMagnitude = instrumentationDimensionTracking.getInvoiceOrderOfMagnitude();
        int paymentOrderOfMagnitude = instrumentationDimensionTracking.getPaymentOrderOfMagnitude();

        _activityContext.addCustomProperty(CustVendInstrumentationConstants::InvoiceOrderOfMagnitude, int2Str(invoiceOrderOfMagnitude));
        _activityContext.addCustomProperty(CustVendInstrumentationConstants::PaymentOrderOfMagnitude, int2Str(paymentOrderOfMagnitude));

        _activityContext.addCustomProperty(CustVendInstrumentationConstants::OriginatingTable, tableId2Name(_originatingTableId));
        _activityContext.addCustomProperty(CustVendInstrumentationConstants::ClassName, classId2Name(classIdGet(this)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxInvoiceId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Tax invoice ID.
    /// </summary>
    /// <param name = "_taxInvoiceId">
    /// The Tax invoice ID.
    /// </param>
    /// <returns>
    /// The Tax invoice ID.
    /// </returns>
    [Wrappable(true)]
    protected final DocumentNum getTaxInvoiceId(DocumentNum _taxInvoiceId)
    {
        return _taxInvoiceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPDCConditionalTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if process conditional tax for PDC.
    /// </summary>
    /// <param name = "_ledgerJournalTransRecId">The recid of <c>LedgerJournalTrans</c>.</param>
    /// <returns>True if process conditional tax for PDC, otherwise false.</returns>
    private boolean processPDCConditionalTax(RecId _ledgerJournalTransRecId)
    {
        BankParameters bankParameters = BankParameters::find();
        if (bankParameters.EnablePDC
            && bankParameters.TaxEnablePDCConditionalTax
            && this.isBridgePosting(_ledgerJournalTransRecId))
        {
            processConditionalTaxForPDC = true;
            CustVendTransOpen custVendTransOpen = settlementPair.getCustVendTransOpenDebit();
            CustTrans custTrans;
            VendTrans vendTrans;
            Voucher settlementVoucher;
            if (custVendTransOpen.TableId == tableNum(CustTransOpen))
            {
                CustSettlement custSettlement;
                select firstonly SettlementVoucher, OffsetRecid from custSettlement
                    where custSettlement.TransRecId == custVendTransOpen.RefRecId
                    join custTrans
                        where custTrans.RecId == custSettlement.OffsetRecid
                            && custTrans.TransType == LedgerTransType::Payment;
                if (custSettlement.SettlementVoucher)
                {
                    settlementVoucher = custSettlement.SettlementVoucher;
                }
            }
            else if (custVendTransOpen.TableId == tableNum(VendTransOpen))
            {
                VendSettlement vendSettlement;
                select firstonly SettlementVoucher, OffsetRecid from vendSettlement
                    where vendSettlement.TransRecId == custVendTransOpen.RefRecId
                    join vendTrans
                        where vendTrans.RecId == vendSettlement.OffsetRecid
                            && vendTrans.TransType == LedgerTransType::Payment;
                if (vendSettlement.SettlementVoucher)
                {
                    settlementVoucher = vendSettlement.SettlementVoucher;
                }
            }

            if (custTrans || vendTrans)
            {
                
                if (this.checkSettledConditionalTaxExistedForPayment(custTrans, vendTrans, settlementVoucher))
                {
                    processConditionalTaxForPDC = false;
                }
            }
        }

        return processConditionalTaxForPDC;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSettledConditionalTaxExistedForPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if there is realized conditional tax(related voucher) for payment journal.
    /// </summary>
    /// <param name = "_custTrans">The record of <c>CustTrans</c> for payment.</param>
    /// <param name = "_vendTrans">The record of <c>VendTrans</c> for payment.</param>
    /// <param name = "_settlementVoucher">The settlement voucher for payment.</param>
    /// <returns>True if there was realized conditional tax for payment journal, otherwise false.</returns>
    private boolean checkSettledConditionalTaxExistedForPayment(CustTrans _custTrans,
        VendTrans _vendTrans,
        Voucher _settlementVoucher)
    {
        CustVendTrans custVendTrans;
        if (_custTrans)
        {
            custVendTrans = _custTrans;
        }
        else
        {
            custVendTrans = _vendTrans;
        }

        RecId voucherGroupId = LedgerTransVoucherLink::findVoucherGroupId(custVendTrans.Voucher, custVendTrans.TransDate);
        LedgerTransVoucherLink currentLink;
        select firstonly RecId from currentLink
            where currentLink.VoucherGroupId == voucherGroupId
                && currentLink.Voucher == custVendTrans.Voucher
                && currentLink.TransDate == custVendTrans.TransDate;

        LedgerTransVoucherLink ledgerTransVoucherLink;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        GeneralJournalEntry generalJournalEntry;
        TaxTrans taxTransloc;

        select firstonly RecId from ledgerTransVoucherLink
            where ledgerTransVoucherLink.VoucherGroupId == voucherGroupId
                && ledgerTransVoucherLink.RecId != currentLink.RecId
            exists join taxTransloc
                where taxTransloc.Voucher == ledgerTransVoucherLink.Voucher
                    && taxTransloc.TransDate == ledgerTransVoucherLink.TransDate
                    && ((custVendTrans.TableId == tableNum(CustTrans) && taxTransloc.SourceRecId == _custTrans.RecId)
                        || (custVendTrans.TableId == tableNum(VendTrans) && taxTransloc.SourceRecId == _vendTrans.RecId))
                    && taxTransloc.TaxOrigin == TaxOrigin::Payment
            exists join subledgerVoucherGeneralJournalEntry
                where LedgerTransVoucherLink.Voucher == subledgerVoucherGeneralJournalEntry.Voucher
                    && LedgerTransVoucherLink.TransDate == subledgerVoucherGeneralJournalEntry.AccountingDate
                    && LedgerTransVoucherLink.dataAreaId == subledgerVoucherGeneralJournalEntry.VoucherDataAreaId
            exists join generalJournalEntry
                where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalEntry.RecId
                    && subledgerVoucherGeneralJournalEntry.Voucher == _settlementVoucher;

        if (ledgerTransVoucherLink.RecId)
        {
            return true;
        }
        else
            return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBridgePosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if is bridge posting.
    /// </summary>
    /// <param name = "_ledgerJorunalTransRecId">The recid of <c>LedgerJournalTrans</c>.</param>
    /// <returns>True if is bridge posting, otherwise false.</returns>
    private boolean isBridgePosting(RecId _ledgerJorunalTransRecId)
    {
        LedgerJournalTrans ledgerJournalTransLoc = LedgerJournalTrans::findRecId(_ledgerJorunalTransRecId, false);
        LedgerJournalTable ledgerJournalTableLoc = ledgerJournalTransLoc.ledgerJournalTable();
        VendPaymModeTable vendPaymModeTable;
        CustPaymModeTable custPaymModeTable;

        boolean isBridgePosting;
        switch (ledgerJournalTableLoc.JournalType)
        {
            case LedgerJournalType::Payment:
            case LedgerJournalType::VendPaymRemittance:
                if (ledgerJournalTransLoc.PaymMode)
                {
                    vendPaymModeTable = VendPaymModeTable::find(ledgerJournalTransLoc.PaymMode);
                    if (vendPaymModeTable.FurtherPosting
                        && vendPaymModeTable.InterCompanyLedgerDimension
                        && LedgerDimensionFacade::areEqual(
                                vendPaymModeTable.InterCompanyLedgerDimension,
                                LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(ledgerJournalTransLoc.OffsetLedgerDimension)))
                    {
                        isBridgePosting = true;
                    }
                }
                break;

            case LedgerJournalType::CustPayment:
            case LedgerJournalType::CustPaymRemittance:
                if (ledgerJournalTransLoc.PaymMode)
                {
                    custPaymModeTable = CustPaymModeTable::find(ledgerJournalTransLoc.PaymMode);
                    if (custPaymModeTable.FurtherPosting
                        && custPaymModeTable.InterCompanyLedgerDimension
                        && LedgerDimensionFacade::areEqual(
                                custPaymModeTable.InterCompanyLedgerDimension,
                                LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(ledgerJournalTransLoc.OffsetLedgerDimension)))
                    {
                        isBridgePosting = true;
                    }
                }
                break;
            default:
                isBridgePosting = ledgerJournalTransLoc.FurtherPostingType;
        }
        return isBridgePosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostRealizedExchAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the realized exchange adjustment amount should be posted.
    /// </summary>
    /// <param name="_settlementPair">
    /// The Settlement Pair.
    /// </param>
    /// <returns>
    /// True if the realized exchange adjustment amount needs to be posted; otherwise, false.
    /// </returns>
    protected boolean canPostRealizedExchAdjustment(SettlementPair _settlementPair)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>targetTaxLedgerParmsList_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns list targetTaxLedgerParmsList.
    /// </summary>
    /// <returns>
    /// Returns list targetTaxLedgerParmsList.
    /// </returns>
    public List targetTaxLedgerParmsList_RU()
    {
        return targetTaxLedgerParmsList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxCashDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates and posts the tax on the cash discount.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The CustVendTrans record that contains the cash discount.
    /// </param>
    /// <param name="_cashDiscAmountCur">
    /// The amount of the cash discount in the transaction currency.
    /// </param>
    /// <param name="_cashDiscLedgerDimension">
    /// The ledger account used to post the cash discount.
    /// </param>
    /// <param name="_transactionToAccountingExchRate">
    /// The exchange rate between transaction and accounting currency.
    /// </param>
    /// <param name="_reportingExchangeRate">
    /// The exchange rate between reporting and accounting currency.
    /// </param>
    /// <returns>
    /// The tax on the cash discount.
    /// </returns>
    protected AmountCur taxCashDisc(
        CustVendTrans                   _custVendTrans,
        DiscAmount                      _cashDiscAmountCur,
        LedgerDimensionDefaultAccount   _cashDiscLedgerDimension,
        ExchRate                        _transactionToAccountingExchRate,
        ExchRate                        _reportingExchangeRate)
    {
        AmountCur               taxOnCashDiscAmount, taxOnCashDiscAmountTotal;
        CustVendInvoiceJour     custVendInvoiceJour;    // Variable used in regard to discount and tax
        TaxCashDisc             taxCashDisc;            // --- do ---
        TableId                 taxTableId;             // --- do ---
        RecId                   taxRecId;               // --- do ---
        Percent                 percent;
        Voucher                 voucherLocal;
        TransDate               transDateLocal;
        LedgerInterCompany      interCompany;
        LedgerPostingController ledgerPostingController;
        TransactionTxt          cashDiscText;
        ExchRate                transactionToAccountingExchRate, reportingExchangeRate;
        DataAreaId              taxOnCashDiscCompany;
        Set                     companyVoucherDateSet = new Set(Types::Container);
        SetEnumerator           companyVoucherDateSetEnum;
        CurrencyExchangeHelper  currencyExchangeHelper;
        AmountMST               taxOnCashDiscAmountMST;
        AmountMSTSecondary      taxOnCashDiscAmountReporting;
        boolean                 isCustVendSettlementSingleCompany;

        // <GEERU><GEECZ>
        LedgerBondClient_RU     ledgerBondClient;
        boolean                 countryRegion_RUCZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]);
        // </GEECZ></GEERU>

        Debug::assert(curext() == _custVendTrans.company());

        taxOnCashDiscCompany = curext();
        isCustVendSettlementSingleCompany = settlementPair.getCreditCompany() == settlementPair.getDebitCompany();

        // calculate what percentage the cash discount is of entire transaction amount.
        // This is the percentage of tax that will be adjusted.
        if (_custVendTrans.AmountCur)
        {
            percent = _cashDiscAmountCur / _custVendTrans.AmountCur * 100;
        }

        // find the invoice associated with the transaction
        custVendInvoiceJour = this.findInvoiceForCustVendProj(
            _custVendTrans.AccountNum,
            _custVendTrans.Invoice,
            _custVendTrans.Voucher,
            _custVendTrans.TransDate);

        boolean cashDiscVat;
        using (TaxIntegrationTaxJurisdictionParametersContext taxIntegrationTaxJurisdictionParametersContext = TaxIntegrationTaxJurisdictionParametersContext::construct(custVendInvoiceJour.TableId, custVendInvoiceJour.RecId))
        {
            cashDiscVat = this.cashDiscVat();
        }

        if (percent != 0 && cashDiscVat)
        {
            // <GEEU>
            if (CustVendTransPostingLog_RU::usePostingLog())
            {
                ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(settlementPair.findLedgerVoucherByCompany(_custVendTrans.company()));
                this.createLedgerVoucherObject_RU(ledgerPostingController.getJournal());

                ledgerBondClient = ledgerPostingController.getReference().ledgerBondClient_RU();

                if (ledgerBondClient)
                {
                    ledgerBondClient.addNewLogObject();
                }
            }
            // </GEEU>

            if (custVendInvoiceJour.RecId)
            {
                taxTableId = custVendInvoiceJour.TableId;
                taxRecId   = custVendInvoiceJour.RecId;
            }
            else
            {
                taxTableId = _custVendTrans.TableId;
                taxRecId   = _custVendTrans.RecId;
            }

            [voucherLocal, transDateLocal] = this.approvalVoucherDate(_custVendTrans);

            // Find all related companies, vouchers and dates.
            companyVoucherDateSet = this.getTaxCompanyVoucherDate(_custVendTrans.DataAreaId, voucherLocal, transDateLocal);

            companyVoucherDateSetEnum = companyVoucherDateSet.getEnumerator();

            while (companyVoucherDateSetEnum.moveNext())
            {
                [taxOnCashDiscCompany, voucherLocal, transDateLocal] = companyVoucherDateSetEnum.current();

                if (taxOnCashDiscCompany == curext())
                {
                    transactionToAccountingExchRate = _transactionToAccountingExchRate;
                    reportingExchangeRate           = _reportingExchangeRate;
                }
                else
                {
                    // Has to be 0 for Intercompany scenario because exchange rates are not compatible across companies.
                    transactionToAccountingExchRate = 0;
                    reportingExchangeRate           = 0;
                }

                changecompany(taxOnCashDiscCompany)
                {
                    cashDiscText = TransactionTxt::construct(this.discTxtCustVend(),
                                                  _custVendTrans.languageId(),
                                                  settlementPair.getTransactionDate(),
                                                  _custVendTrans.Invoice,
                                                  _custVendTrans.Voucher);

                    ledgerPostingController =
                        LedgerPostingController::newForLedgerPostingJournal(settlementPair.findOrCreateLedgerVoucherByCompany(taxOnCashDiscCompany));

                    // <GEEU>
                    if (CustVendTransPostingLog_RU::usePostingLog())
                    {
                        this.createLedgerVoucherObject_RU(ledgerPostingController.getJournal());

                        if (countryRegion_RUCZ)
                        {
                            ledgerBondClient = ledgerPostingController.getReference().ledgerBondClient_RU();
                            if (ledgerBondClient)
                            {
                                ledgerBondClient.addNewLogObject();
                            }
                        }
                    }
                    // </GEEU>

                    // Create instance of TaxCashDisc class, this class is used to calculate the tax.
                    taxCashDisc = new TaxCashDisc(voucherLocal,
                                                    transDateLocal,
                                                    taxTableId,
                                                    taxRecId,
                                                    _custVendTrans.CurrencyCode,
                                                    _custVendTrans.TableId,
                                                    _custVendTrans.RecId,
                                                    percent,
                                                    transactionToAccountingExchRate,
                                                    0,
                                                    UnknownNoYes::No);

                    taxCashDisc.parmOperationLedgerDimension(_cashDiscLedgerDimension);
                    taxCashDisc.parmSettlementReportingCrossRate(_reportingExchangeRate);
                    taxCashDisc.parmRelatedLedgerVoucher(this.parmRelatedLedgerVoucher());
                    taxCashDisc.parmCustVendSettlementSingleCompany(isCustVendSettlementSingleCompany);

                    if (settlementPair.getCustVendTransOpenDebit() && settlementPair.getCustVendTransOpenDebit().CashDiscountLedgerDimension)
                    {
                        taxCashDisc.parmDifferingCashDiscountLedgerDimension(settlementPair.getCustVendTransOpenDebit().CashDiscountLedgerDimension);
                    }

                    // When this is an intercompany settlement for a discount that will be transferred to the
                    // payment company the charge account field on the tax trans needs to be set to the
                    // due to/from account.  This is done be setting the parmDifferingCashDiscAccount.
                    if (_cashDiscAmountCur > 0 && settlementPair.getDebitCompany() != settlementPair.getCreditCompany() &&
                        _custVendTrans.RecId == settlementPair.getCustVendTransDebit().RecId)
                    {
                        changecompany(settlementPair.getCreditCompany())
                        {
                            interCompany = this.findLedgerInterCompany(settlementPair.getCreditCompany(), settlementPair.getDebitCompany());
                            if (interCompany.getCashDiscPostOptions(this.parmModule()) == CustVendSettleCompanyPostOption::PaymentCompany)
                            {
                                taxCashDisc.parmDifferingCashDiscountLedgerDimension(dueToFromLedgerDimensionDebit);
                            }
                        }
                    }

                    // Calculate the tax on the cash discount, creates TaxTrans records and post
                    // to the general journal for the tax ledger account.
                    ledgerPostingController.getJournal().findLedgerVoucherObject().lastTransTxt(cashDiscText.txt());
                    taxOnCashDiscAmount = taxCashDisc.calcAndPost(ledgerPostingController);
                    taxOnCashDiscAmountTotal = taxOnCashDiscAmountTotal + taxOnCashDiscAmount;

                    taxChargeIntercompanySet = taxCashDisc.getTaxChargeIntercompanySet();
                    this.processTaxChargeIntercompany(taxChargeIntercompanySet, _custVendTrans.AccountNum);

                    // If  tax company and invoice company are different, create due to and due from transaction.
                    if (taxOnCashDiscCompany != _custVendTrans.DataAreaId && taxOnCashDiscAmount != 0)
                    {
                        currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(taxOnCashDiscCompany).RecId), settlementPair.getTransactionDate());
                        taxOnCashDiscAmountMST = currencyExchangeHelper.calculateTransactionToAccounting(_custVendTrans.CurrencyCode, taxOnCashDiscAmount, true);
                        taxOnCashDiscAmountReporting = currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(_custVendTrans.CurrencyCode, taxOnCashDiscAmount);

                        this.createAndPostDueToDueFromTaxExpense(taxOnCashDiscCompany, _custVendTrans.DataAreaId, _custVendTrans.CurrencyCode, -taxOnCashDiscAmount, -taxOnCashDiscAmountMST, -taxOnCashDiscAmountReporting);

                        currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(_custVendTrans.DataAreaId).RecId), settlementPair.getTransactionDate());
                        taxOnCashDiscAmountMST = currencyExchangeHelper.calculateTransactionToAccounting(_custVendTrans.CurrencyCode, taxOnCashDiscAmount, true);
                        taxOnCashDiscAmountReporting = currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(_custVendTrans.CurrencyCode, taxOnCashDiscAmount);

                        this.createAndPostDueToDueFromTaxExpense(_custVendTrans.DataAreaId, taxOnCashDiscCompany, _custVendTrans.CurrencyCode, taxOnCashDiscAmount, taxOnCashDiscAmountMST, taxOnCashDiscAmountReporting);

                        // Keep track of the inter company vouchers in order to reverse them when the settlement is reversed.
                        this.insertSettlementOffsetVoucher(_custVendTrans.DataAreaId,
                                                        _custVendTrans.AccountNum,
                                                        settlementPair.findOrCreateLedgerVoucherByCompany(_custVendTrans.DataAreaId).lastVoucher(),
                                                        taxOnCashDiscCompany,
                                                        settlementPair.findOrCreateLedgerVoucherByCompany(taxOnCashDiscCompany).lastVoucher(),
                                                        CustVendSettlementOffsetVoucherType::Tax);
                    }

                    ledgerPostingController.getJournal().findLedgerVoucherObject().lastTransTxt('');

                    [conLedgerAccount, conTaxBaseAmountCur, conTaxTransRecId, conOriginalTaxTransRecId] = taxCashDisc.getContainers();

                    // <GEERU>
                    conTaxAmounts_RU = taxCashDisc.taxAmounts_RU();
                    // </GEERU>
                }
            }
        }
        else
        {
            conLedgerAccount = conNull();
            // <GEERU>
            conTaxAmounts_RU = conNull();
            // </GEERU>
        }

        return taxOnCashDiscAmountTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxSettlement</Name>
				<Source><![CDATA[
    protected void taxSettlement(
        CustVendTrans _invoiceTrans,
        CustVendTrans _paymentTrans,
        DiscAmount _cashDiscAmountCur,
        Percent _percent,
        ExchRate _exchRate,
        ExchRate _exchRateReporting)
    {
        CustVendInvoiceJour custVendInvoiceJour;
        TaxSettlement       taxSettlement;
        TableId             taxTableId;
        RecId               taxRecId;
        Percent             percent = _percent;
        LedgerVoucher       ledgerVoucher;
        AmountMST           taxExchAdjMst;
        AmountMSTSecondary  taxExchAdjReporting;
        LedgerJournalVoucherChanged ledgerJournalVoucherChanged;
        LedgerPostingController ledgerPostingController;
        LedgerVoucherObject ledgerVoucherObject;
        LedgerDimensionAccount mergedLedgerDimension;
        LedgerVoucherTransObject ledgerVoucherTransObject;
        TaxTrans taxTrans;
        TaxTable taxTable;
        Voucher invoiceVoucher;
        TransDate invoiceDate;

        // <GEEU>
        CustVendSettlePostingLog_RU postingLog;
        int                         i;
        Set                         localTaxTransRecIDs;
        RecId                       localTaxTransRecID;
        TaxAmount                   taxAmount;
        container                   taxTransRecIDsAndAmounts;
        // </GEEU>

        Debug::assert(curext() == _invoiceTrans.company());

        if (!TaxParameters::find().ConditionalTax)
        {
            return;
        }

        custVendInvoiceJour = this.findInvoiceForCustVendProj(
            _invoiceTrans.AccountNum,
            _invoiceTrans.Invoice,
            _invoiceTrans.Voucher,
            _invoiceTrans.TransDate);

        boolean cashDiscVat;
        using (TaxIntegrationTaxJurisdictionParametersContext taxIntegrationTaxJurisdictionParametersContext = TaxIntegrationTaxJurisdictionParametersContext::construct(custVendInvoiceJour.TableId, custVendInvoiceJour.RecId))
        {
            cashDiscVat = this.cashDiscVat();
        }

        if (cashDiscVat
            && _cashDiscAmountCur
            && _invoiceTrans.AmountCur)
        {
            percent -= (_cashDiscAmountCur / _invoiceTrans.AmountCur * 100);
        }

        if (_invoiceTrans.TableId == tableNum(VendTrans))
        {
            VendTrans vendTrans = _invoiceTrans;
            ledgerJournalVoucherChanged = LedgerJournalVoucherChanged::findFromVoucherSkippingAccrual(vendTrans.JournalNum, vendTrans.Voucher);
        }

        if (custVendInvoiceJour.RecId)
        {
            taxTableId = custVendInvoiceJour.TableId;
            taxRecId   = custVendInvoiceJour.RecId;
        }
        else
        {
            taxTableId = _invoiceTrans.TableId;
            taxRecId   = _invoiceTrans.RecId;
        }

        invoiceVoucher = ledgerJournalVoucherChanged.RecId ? ledgerJournalVoucherChanged.ToVoucher : _invoiceTrans.Voucher;
        invoiceDate = ledgerJournalVoucherChanged.RecId ? ledgerJournalVoucherChanged.ToDate    : _invoiceTrans.TransDate;

        // check for conditional tax records
        select firstonly RecId
            from taxTrans
            where taxTrans.Voucher == invoiceVoucher &&
                    taxTrans.TransDate == invoiceDate &&
                    (taxTrans.TaxOrigin           == TaxOrigin::Tax ||
                     taxTrans.TaxOrigin           == TaxOrigin::Transfer) &&
                    (taxTrans.TaxDirection       == TaxDirection::IncomingTax ||
                     taxTrans.TaxDirection       == TaxDirection::OutgoingTax ||
                     taxTrans.TaxDirection       == TaxDirection::TaxExemptSales ||
                     taxTrans.TaxDirection       == TaxDirection::TaxExemptPurchase ||
                     taxTrans.TaxDirection       == TaxDirection::UseTax)
            join PaymentTaxCode from taxTable
            where taxTable.TaxCode         == taxTrans.TaxCode           &&
                        taxTable.PaymentTaxCode  != '';

        if (taxTrans.RecId == 0)
        {
            return;
        }

        ledgerPostingController =
            LedgerPostingController::newForLedgerPostingJournal(settlementPair.findLedgerVoucherByCompany(_invoiceTrans.company()));

        // <GEEU>
        if (CustVendTransPostingLog_RU::usePostingLog())
        {
            this.createLedgerVoucherObject_RU(ledgerPostingController.getJournal());
        }
        // </GEEU>

        ledgerVoucher = settlementPair.findLedgerVoucherByCompany(_invoiceTrans.company());
        ledgerVoucher.findLedgerVoucherObject().lastTransTxt(_paymentTrans.Txt);

        taxSettlement = new TaxSettlement(ledgerJournalVoucherChanged.RecId ? ledgerJournalVoucherChanged.ToVoucher : _invoiceTrans.Voucher,
                                          ledgerJournalVoucherChanged.RecId ? ledgerJournalVoucherChanged.ToDate    : _invoiceTrans.TransDate,
                                          taxTableId,
                                          taxRecId,
                                          _invoiceTrans.CurrencyCode,
                                          _paymentTrans.TableId,
                                          _paymentTrans.RecId,
                                          percent,
                                          _exchRate,
                                          0,
                                          UnknownNoYes::No);
        taxSettlement.parmSettlementReportingCrossRate(_exchRateReporting);
        taxSettlement.parmEnableExchangeRatesGainLoss(true);
        taxSettlement.parmPercentIncludingCashDiscount(_percent);

        taxSettlement.parmInvoiceReportingCrossRate(_invoiceTrans.getReportingCombinedExchangeRate());
        taxSettlement.parmRelatedLedgerVoucher(this.parmRelatedLedgerVoucher());
        // <GTH>
        if (isUnrealizedVATEnabled)
        {
            taxSettlement.parmIsTaxInvoiceInfoFilled(this.parmIsTaxInvoiceInfoFilled());
            if (isLatestSettlement)
            {
                TaxAmountCur taxAmountToBeReversed;
                TaxBaseCur taxBaseAmountToBeReversed;

                [taxAmountToBeReversed, taxBaseAmountToBeReversed] = this.getAmountsToReverseForLastSettlement_TH(custVendSettlementLatest,
                    settlementPair.getCustVendTransDebit(),
                    _invoiceTrans.Voucher,
                    _invoiceTrans.TransDate);

                taxSettlement.parmIsLatestSettlement_TH(isLatestSettlement);
                taxSettlement.parmTaxAmountToBeReversed_TH(taxAmountToBeReversed);
                taxSettlement.parmTaxBaseAmountToBeReversed_TH(taxBaseAmountToBeReversed);
            }
        }
        // </GTH>
        taxSettlement.calcAndPost(ledgerPostingController);
        taxSettlement.reverseLinks(TaxTransRelationshipType::TransactionLineAccount);
        // <GEEU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU ]))
        {
            taxTransRecIDsAndAmounts = taxSettlement.getContainers_W();
            postingLog = CustVendSettlePostingLog_RU::newCustVendSettle(CustVendTransPostingLogType_RU::ConditionalTax,
                                                                        _invoiceTrans,
                                                                        _invoiceTrans,
                                                                        _paymentTrans);
            postingLog.parmVoucher(ledgerPostingController.getJournal().lastVoucher());
            postingLog.parmTransDate(ledgerPostingController.getJournal().lastTransDate());
            postingLog.parmCustVendSettle(this);

            for (i = 1; i <= conLen(taxTransRecIDsAndAmounts); i++)
            {
                [localTaxTransRecID, taxAmount] = conPeek(taxTransRecIDsAndAmounts, i);
                localTaxTransRecIDs = new Set(typeName2Type(extendedTypeStr(RecId)));
                localTaxTransRecIDs.add(localTaxTransRecID);

                postingLog.parmTaxTransRecIDs(localTaxTransRecIDs);
                postingLog.createTrans(LedgerPostingType::Tax,
                                       0,
                                       0,
                                       _invoiceTrans.CurrencyCode,
                                       taxAmount,
                                       0,
                                       0,
                                       _invoiceTrans.exchRateCurToMst());
            }
        }
        // </GEEU>

        taxExchAdjMst = taxSettlement.getTotalGainLossInAccountingAmount();
        taxExchAdjReporting = taxSettlement.getTotalGainLossInReportingCurrency();

        if (taxExchAdjMst || taxExchAdjReporting)
        {
            ledgerVoucherObject = ledgerPostingController.getReference();

            if (taxExchAdjMst)
            {
                mergedLedgerDimension = this.accountLossProfitTax(taxExchAdjMst, _invoiceTrans.CurrencyCode);
                mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(mergedLedgerDimension, _invoiceTrans.DefaultDimension);

                ledgerVoucherTransObject =
                    LedgerVoucherTransObject::newAdjustmentDefault(
                        ledgerVoucherObject,
                        this.getLedgerPostingType_ExchRateTax(taxExchAdjMst),
                        mergedLedgerDimension,
                        _invoiceTrans.CurrencyCode,
                        -taxExchAdjMst,
                        0.0);
                ledgerPostingController.addTrans(ledgerVoucherTransObject);
            }

            if (taxExchAdjReporting)
            {
                mergedLedgerDimension = this.accountLossProfitTax(taxExchAdjReporting, _invoiceTrans.CurrencyCode);
                mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(mergedLedgerDimension, _invoiceTrans.DefaultDimension);

                ledgerVoucherTransObject =
                    LedgerVoucherTransObject::newAdjustmentDefault(
                        ledgerVoucherObject,
                        this.getLedgerPostingType_ExchRateTax(taxExchAdjReporting),
                        mergedLedgerDimension,
                        _invoiceTrans.CurrencyCode,
                        0.0,
                        -taxExchAdjReporting);
                ledgerPostingController.addTrans(ledgerVoucherTransObject);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxSettlement_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Settles tax of given transaction.
    /// </summary>
    /// <param name="_invoiceTrans">
    /// The invoice of the transaction.
    /// </param>
    /// <param name="_paymentTrans">
    /// The payment information of the transaction.
    /// </param>
    /// <param name="_cashDiscAmountCur">
    /// The instance of the <c>DiscAmount</c> class.
    /// </param>
    /// <param name="_percent">
    /// The instance of the <c>Percent</c> class.
    /// </param>
    /// <param name="_tableId">
    /// The id of the table.
    /// </param>
    public void taxSettlement_IN(
        CustVendTrans _invoiceTrans,
        CustVendTrans _paymentTrans,
        DiscAmount    _cashDiscAmountCur,
        Percent       _percent,
        TableId       _tableId = 0)
    {
        CustVendInvoiceJour                 custVendInvoiceJour;
        TaxSettlement_IN                    taxSettlement;
        TableId                             taxTableId;
        RefRecId                            taxRecId;
        Percent                             percent = _percent;
        boolean                             finalPayment = false;
        boolean                             gtaVendor;
        LedgerJournalTrans                  ledgerJournalTrans;
        real                                settlementFactorLoc;
        boolean                             foreignVendor;
        CustInvoiceTable                    custInvoiceTableLoc;
        CustInvoiceJour                     custInvoiceJourLoc;
        LedgerPostingController             ledgerPostingController;
        TaxInformationVendTable_IN          taxInformationVendTableLoc;
        TaxTrans                            paymentTaxTrans;
        LedgerTransVoucherLink              ledgerTransVoucherLinkRel;
        LedgerTransVoucherLink              ledgerTransVoucherLink;
        TaxItemGroupHeading                 taxItemGroup;
        MainAccount                         mainAccount;
        TaxTransGeneralJournalAccountEntry  taxLink;
        GeneralJournalAccountEntry          generalJournalAccountEntry;
        DimensionAttributeValueCombination  dimAttrValueCombo;
        TaxTrans_W                  paymentTaxTrans_W;

        if (!TaxParameters::isServiceTaxEnable_IN())
        {
            return;
        }
        ledgerPostingController =
            LedgerPostingController::newForLedgerPostingJournal(settlementPair.findLedgerVoucherByCompany(_invoiceTrans.company()));
        if (percent == 100)
        {
            finalPayment = true;
        }
        if (percent == 100
            && this.cashDiscVat()
            && _cashDiscAmountCur
            && _invoiceTrans.AmountCur)
        {
            percent -= (_cashDiscAmountCur / _invoiceTrans.AmountCur * 100);
        }

        custVendInvoiceJour = this.findInvoice(_invoiceTrans.AccountNum,
                                               _invoiceTrans.Invoice,
                                               _invoiceTrans.Voucher,
                                               _invoiceTrans.TransDate);
        if (custVendInvoiceJour.RecId)
        {
            taxTableId = custVendInvoiceJour.TableId;
            taxRecId   = custVendInvoiceJour.RecId;
        }
        else
        {
            taxTableId = _invoiceTrans.TableId;
            taxRecId   = _invoiceTrans.RecId;
        }
        ledgerJournalTrans = LedgerJournalTrans::find(relatedJournalId, _paymentTrans.Voucher, false);

        if (_invoiceTrans.TableId == tableNum(VendTrans))
        {
            taxInformationVendTableLoc = VendTable::find(_invoiceTrans.AccountNum).getTaxInformationVendTable_IN();
            gtaVendor = taxInformationVendTableLoc.IsGTA;
            foreignVendor = (taxInformationVendTableLoc.IsForeign &&
                              VendInvoiceJour::findFromVendTrans(_invoiceTrans.Invoice,
                                                                 _invoiceTrans.TransDate,
                                                                 _invoiceTrans.AccountNum).purchTable().purchTable_W().CustomsImportOrder_IN);
        }

        if (VendTrans::findRefVoucher_IN(_invoiceTrans.Voucher) || CustTrans::findRefVoucher_IN(_invoiceTrans.Voucher))
        {
            settlementFactorLoc = _invoiceTrans.AmountCur ? _invoiceTrans.SettleAmountCur / _invoiceTrans.AmountCur : 0;
            percent             = settlementFactorLoc * 100;
        }

        if (_invoiceTrans.SettleAmountCur == _invoiceTrans.AmountCur && TaxParameters::find().TaxRecoverable_IN && (!gtaVendor && !foreignVendor) && _invoiceTrans.TableId != tableNum(CustTrans) )
        {
            finalPayment    = true;
            percent         = 100;
        }

        if (TaxParameters::find().TaxRecoverable_IN && !finalPayment && (!gtaVendor && !foreignVendor) && _invoiceTrans.TableId != tableNum(CustTrans))
        {
            return;
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(FreeTextInvoiceCorrection))
            && (percent != _percent)
            && custVendInvoiceJour.TableId == tableNum(CustInvoiceJour))
        {
            custInvoiceJourLoc = custVendInvoiceJour;

            select firstonly CorrectionReasonCode from custInvoiceTableLoc
                 where custInvoiceTableLoc.SourceDocumentHeader == custInvoiceJourLoc.SourceDocumentHeader;

            // Corrected invoice always has a reason code. This is a better check than STD 'custInvoiceTableLoc.isCorrectedInvoice()'
            // Very rarely RecId duplication can blow the standard logic.
            if (custInvoiceTableLoc.CorrectionReasonCode)
            {
                percent = _percent;
            }
        }
        // If payment time tax is calculated and posted, then don't post tax again. This scenario can happen in manual 3-way settlement
        // its not same for POT settlement even though the tax is calculated at the time of payment,
        // again it has to be posted at the time of manual settlement

        if (_tableId != tableNum(LedgerJournalTrans)// 3-way settlement
                        &&
            ( _tableId == tableNum(CustTable)
                         ||
               _tableId == tableNum(VendTable)
            )
           )
        {
            select firstonly * from ledgerTransVoucherLink
                where ledgerTransVoucherLink.Voucher         == _paymentTrans.Voucher
                    && ledgerTransVoucherLink.TransDate      == _paymentTrans.TransDate
                    && ledgerTransVoucherLink.VoucherGroupId == ledgerTransVoucherLink.RecId
                join * from ledgerTransVoucherLinkRel
                    where ledgerTransVoucherLinkRel.VoucherGroupId  == ledgerTransVoucherLink.RecId
                        && ledgerTransVoucherLinkRel.VoucherGroupId != ledgerTransVoucherLinkRel.RecId
                join RecId, TransDate, Voucher from paymentTaxTrans
                    where paymentTaxTrans.TransDate   == ledgerTransVoucherLinkRel.TransDate
                        && paymentTaxTrans.Voucher    == ledgerTransVoucherLinkRel.Voucher
                exists join TaxType_IN from paymentTaxTrans_W
                    where paymentTaxTrans_W.TaxTrans == paymentTaxTrans.RecId
                        && paymentTaxTrans_W.TaxType_IN == TaxType_IN::ServiceTax
                exists join RecId from taxItemGroup
                    where taxItemGroup.TaxItemGroup == paymentTaxTrans.TaxItemGroup
                       && taxItemGroup.ServiceTaxBasis_IN == ServiceTaxBasis_IN::CashBasis;
        }
        if (paymentTaxTrans.RecId)
        {
            // If tax is already posted, retrieve the account and see if there is balance available against that account.
            // If so, we shud create tax vouchers to settle the same.
            select firstonly * from taxLink
               where taxLink.TaxTrans == paymentTaxTrans.RecId
                  && taxLink.TaxTransRelationship == TaxTransRelationshipType::Tax
               join LedgerDimension from generalJournalAccountEntry
                  where generalJournalAccountEntry.RecId == taxLink.GeneralJournalAccountEntry
                     join RecId, MainAccount from dimAttrValueCombo
                        where dimAttrValueCombo.RecId == generalJournalAccountEntry.LedgerDimension
                           join mainAccount
                              where mainAccount.RecId == dimAttrValueCombo.MainAccount;
        }
        if (paymentTaxTrans.RecId == 0
            || (paymentTaxTrans.RecId // Create service tax vouchers, for reversed settlement.If balance is available its not reversed, so tax entry needs to be created.
                && TaxSettlement_IN::checkIfBalanceRemainsForAC(mainAccount) == true))
        {
            taxSettlement = new TaxSettlement_IN(_invoiceTrans.Voucher,
                                                    _invoiceTrans.TransDate,
                                                    _paymentTrans.Voucher,
                                                    _paymentTrans.TransDate,
                                                    taxTableId,
                                                    taxRecId,
                                                    _invoiceTrans.CurrencyCode,
                                                    _paymentTrans.TableId,
                                                    _paymentTrans.RecId,
                                                    percent,
                                                    _invoiceTrans.exchRateCurToMst(),
                                                    0,
                                                    UnknownNoYes::No,
                                                    ledgerJournalTrans,
                                                    finalPayment,
                                                    settlementPair.getCustVendTransCredit().DataAreaId,
                                                    _tableId);
            taxSettlement.calcAndPost(ledgerPostingController, _paymentTrans.DefaultDimension, parentCustTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxTransRecIDs_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Set of tax transactions recIDs inserted by calcAndPostTaxExchRateDiff_RU,which should be linked with posting log
    /// </summary>
    /// <returns>Set of recIDs or null</returns>
    Set taxTransRecIDs_RU()
    {
        return taxTransRecIDs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);

        switch (version)
        {
            case #CurrentVersion :
                [version,#CurrentList] = _packedClass;
                break;

            default :
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAdvanceDefinition</Name>
				<Source><![CDATA[
    protected abstract void updateAdvanceDefinition(CustVendTrans  _custVendTrans, AmountCur settleAmountCur)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAmountsOnTransactionForFine_BR</Name>
				<Source><![CDATA[
    private void updateAmountsOnTransactionForFine_BR(
                                                        AmountCur           _fineAmountDebit,
                                                        AmountMST           _fineAmountMSTDebit,
                                                        AmountMSTSecondary  _fineAmountReportingDebit,
                                                        AmountCur           _fineAmountCredit,
                                                        AmountMST           _fineAmountMSTCredit,
                                                        AmountMSTSecondary  _fineAmountReportingCredit
                                                        )
    {
        if (settlementPair.getCustVendTransDebit().RecId != 0)
        {
            _fineAmountDebit            = this.amount(_fineAmountDebit);
            _fineAmountMSTDebit         = this.amount(_fineAmountMSTDebit);
            _fineAmountReportingDebit   = this.amount(_fineAmountReportingDebit);
        }

        if (settlementPair.getCustVendTransCredit().RecId != 0)
        {
            _fineAmountCredit           = this.amount(_fineAmountCredit);
            _fineAmountMSTCredit        = this.amount(_fineAmountMSTCredit);
            _fineAmountReportingCredit  = this.amount(_fineAmountReportingCredit);
        }

        // update amounts on transaction for Fine
        if (_fineAmountDebit != 0)
        {
            this.updateTransForFine_BR(settlementPair.getCustVendTransDebit(), settlementPair.getCustVendTransOpenDebit(), settlementPair.getSpecTransDebit(), _fineAmountDebit, _fineAmountMSTDebit, _fineAmountReportingDebit);
        }

        if (_fineAmountCredit != 0)
        {
            this.updateTransForFine_BR(settlementPair.getCustVendTransDebit(), settlementPair.getCustVendTransOpenDebit(), settlementPair.getSpecTransDebit(), _fineAmountCredit, _fineAmountMSTCredit, _fineAmountReportingCredit);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAmountsOnTransactionForInterest_BR</Name>
				<Source><![CDATA[
    private void updateAmountsOnTransactionForInterest_BR(
                                                        AmountCur           _finInterestAmountDebit,
                                                        AmountMST           _finInterestAmountMstDebit,
                                                        AmountMSTSecondary  _finInterestAmountReportingDebit,
                                                        AmountCur           _finInterestAmountCredit,
                                                        AmountMST           _finInterestAmountMstCredit,
                                                        AmountMSTSecondary  _finInterestAmountReportingCredit
                                                        )
    {
        if (settlementPair.getCustVendTransDebit().RecId != 0)
        {
            _finInterestAmountDebit             = this.amount(_finInterestAmountDebit);
            _finInterestAmountMstDebit          = this.amount(_finInterestAmountMstDebit);
            _finInterestAmountReportingDebit    = this.amount(_finInterestAmountReportingDebit);
        }

        if (settlementPair.getCustVendTransCredit().RecId != 0)
        {
            _finInterestAmountCredit    = this.amount(_finInterestAmountCredit);
            _finInterestAmountMstCredit = this.amount(_finInterestAmountMstCredit);
        }

        // update amounts on transaction for Interest
        if (_finInterestAmountDebit != 0)
        {
            this.updateTransForInterest_BR(settlementPair.getCustVendTransDebit(), settlementPair.getCustVendTransOpenDebit(), settlementPair.getSpecTransDebit(), _finInterestAmountDebit, _finInterestAmountMstDebit, _finInterestAmountReportingDebit);
        }

        if (_finInterestAmountCredit != 0)
        {
            this.updateTransForInterest_BR(settlementPair.getCustVendTransDebit(), settlementPair.getCustVendTransOpenDebit(), settlementPair.getSpecTransDebit(), _finInterestAmountCredit, _finInterestAmountMstCredit, _finInterestAmountReportingCredit);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCashDiscDate</Name>
				<Source><![CDATA[
    protected abstract void updateCashDiscDate(
        CompanyId _company,
        TableId _tableId,
        RecId _recId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustReceipt_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates cust receipt number.
    /// </summary>
    /// <param name="_custVendTrans">
    /// CustTrans need to be updated.
    /// </param>
    private void updateCustReceipt_TH(CustVendTrans _custVendTrans)
    {
        CustTrans               custTrans;
        CustTransExtensionTH    custTransExtensionTH;
        if (_custVendTrans.TableId == tableNum(CustTrans))
        {
            custTrans = _custVendTrans;
            custTransExtensionTH = custTrans.custTransExtensionTH();

            if (!custTransExtensionTH.ReceiptId)
            {
                custTransExtensionTH.ReceiptId = NumberSeq::newGetNum(CustParameters::numRefCustReceiptId()).num();
            }

            custTrans.SysExtensionSerializerMap::packExtensionTable(custTransExtensionTH);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustTaxInvoice_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates cust tax invoice number.
    /// </summary>
    /// <param name="_custVendTrans">
    /// CustTrans need to be updated.
    /// </param>
    protected void updateCustTaxInvoice_TH(CustVendTrans _custVendTrans)
    {
        this.updateCustVendTransDocumentNum(_custVendTrans);

        settleNowState.setSourceRecId(_custVendTrans.RecId);
        settleNowState.setTaxInvoiceId(_custVendTrans.DocumentNum);
        settleNowState.setTaxInvoiceDate(_custVendTrans.TransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustVendTransDocumentNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates Document number.
    /// </summary>
    /// <param name = "_custVendTrans"><c>CustTrans</c> need to be updated.</param>
    protected void updateCustVendTransDocumentNum(CustVendTrans _custVendTrans)
    {
        _custVendTrans.DocumentNum = NumberSeq::newGetNum(CustParameters::numRefCustTaxInvoiceReceiptId()).num();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExchAdjAmountOnTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the exchange adjustment fields on the specified transactions.
    /// </summary>
    /// <param name="_realizedExchAdjAmount">
    /// The realized exchange adjustment amount.
    /// </param>
    /// <param name="_unrealizedExchAdjAmount">
    /// The unrealized exchange adjustment amount.
    /// </param>
    /// <param name="_realizedReportingExchAdjAmount">
    /// The realized exchange adjustment amount for reporting currency.
    /// </param>
    /// <param name="_unrealizedReportingExchAdjAmount">
    /// The unrealized exchange adjustment amount for reporting currency.
    /// </param>
    /// <param name="_custVendTrans">
    /// The CustVendTrans record to update.
    /// </param>
    /// <param name="_custVendTransOpen">
    /// The CustVendTransOpen record to update.
    /// </param>
    protected void updateExchAdjAmountOnTrans(
        AmountMST _realizedExchAdjAmount,
        AmountMST _unrealizedExchAdjAmount,
        AmountMSTSecondary _realizedReportingExchAdjAmount,
        AmountMSTSecondary _unrealizedReportingExchAdjAmount,
        CustVendTrans _custVendTrans,
        CustVendTransOpen _custVendTransOpen)
    {
        if (_realizedExchAdjAmount != 0)
        {
            _custVendTrans.ExchAdjustmentRealized    += _realizedExchAdjAmount;
            _custVendTrans.ExchAdjustment            += _realizedExchAdjAmount;
        }

        if (_unrealizedExchAdjAmount != 0)
        {
            _custVendTrans.ExchAdjustmentUnrealized  -= _unrealizedExchAdjAmount;
            _custVendTrans.ExchAdjustment            -= _unrealizedExchAdjAmount;

            _custVendTransOpen.AmountMST             -= _unrealizedExchAdjAmount;

            if (_custVendTransOpen.AmountMST == 0 || _custVendTransOpen.ExchAdjUnrealized == 0)
            {
                _custVendTransOpen.ExchAdjUnrealized = 0;
            }
            else
            {
                _custVendTransOpen.ExchAdjUnrealized -= _unrealizedExchAdjAmount;
            }
        }

        if (_realizedReportingExchAdjAmount != 0)
        {
            _custVendTrans.ReportingExchAdjustmentRealized += _realizedReportingExchAdjAmount;
            _custVendTrans.ExchAdjustmentReporting         += _realizedReportingExchAdjAmount;
        }

        if (_unrealizedReportingExchAdjAmount != 0)
        {
            _custVendTrans.ReportingExchAdjustmentUnrealized  -= _unrealizedReportingExchAdjAmount;
            _custVendTrans.ExchAdjustmentReporting            -= _unrealizedReportingExchAdjAmount;

            _custVendTransOpen.ReportingCurrencyAmount -= _unrealizedReportingExchAdjAmount;

            if (_custVendTransOpen.ReportingCurrencyAmount == 0 || _custVendTransOpen.ExchAdjUnrealizedReporting == 0)
            {
                _custVendTransOpen.ExchAdjUnrealizedReporting = 0;
            }
            else
            {
                _custVendTransOpen.ExchAdjUnrealizedReporting -= _unrealizedReportingExchAdjAmount;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSTAdvancePayment_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates STA advance payment information.
    /// </summary>
    /// <param name="_custVendTransDebit">
    /// The cust vend trans debit.
    /// </param>
    /// <param name="_custVendTransCredit">
    /// The cust vend trans credit.
    /// </param>
    /// <param name="_tableId">
    /// The table id.
    /// </param>
    public void updateSTAdvancePayment_IN(
        CustVendTrans _custVendTransDebit,
        CustVendTrans _custVendTransCredit,
        TableId       _tableId)
    {
        RecId                   voucherGroupId;
        LedgerTransVoucherLink  link;
        TaxTrans_IN             taxTrans, taxTransLoc;
        PurchIdBase             purchaseOrder;
        SalesIdBase             salesOrder;
        CustVendTrans_W         custVendTrans_W;

        ttsbegin;
        if (_tableId == tableNum(PurchTable) || _tableId == tableNum(VendTable))
        {
            voucherGroupId  = LedgerTransVoucherLink::findVoucherGroupId(_custVendTransCredit.Voucher, _custVendTransCredit.TransDate);
            select firstonly link
                where link.VoucherGroupId == voucherGroupId
                   && (link.Voucher   != _custVendTransCredit.Voucher
                   || link.TransDate  != _custVendTransCredit.TransDate);
            custVendTrans_W = _custVendTransCredit.CustVendTrans::getCustVendTrans_W();
            custVendTrans_W.AdvancePayment_IN = NoYes::Yes;
            custVendTrans_W.RefVoucher_IN     = link.Voucher;
            _custVendTransCredit.CustVendTrans::packCustVendTrans_W(custVendTrans_W);

            if (_custVendTransCredit.RecId)
            {
                purchaseOrder   = VendInvoiceJour::findFromVendTrans(_custVendTransCredit.Invoice, _custVendTransCredit.TransDate, _custVendTransCredit.AccountNum).PurchId;
                select firstonly taxTransLoc
                    where taxTransLoc.Voucher == link.Voucher &&
                        taxTransLoc.TransDate == link.TransDate ;
                if (taxTransLoc.RecId)
                {
                    if (taxTransLoc.PurchaseOrder != '')
                    {
                        update_recordset taxTrans
                            setting PurchaseOrder = '*'
                        where taxTrans.Voucher  == link.Voucher &&
                            taxTrans.TransDate  == link.TransDate;
                    }
                    else
                    {
                        update_recordset taxTrans
                            setting PurchaseOrder = purchaseOrder
                        where taxTrans.Voucher  == link.Voucher &&
                            taxTrans.TransDate  == link.TransDate;
                    }
                }
            }
        }
        if (_tableId == tableNum(SalesTable) || _tableId == tableNum(CustTable))
        {
            voucherGroupId  = LedgerTransVoucherLink::findVoucherGroupId(_custVendTransCredit.Voucher, _custVendTransCredit.TransDate);
            select firstonly link
                where link.VoucherGroupId == voucherGroupId
                   && (link.Voucher   != _custVendTransCredit.Voucher
                   || link.TransDate  != _custVendTransCredit.TransDate);
            custVendTrans_W = _custVendTransDebit.CustVendTrans::getCustVendTrans_W();
            custVendTrans_W.AdvancePayment_IN = NoYes::Yes;
            custVendTrans_W.RefVoucher_IN     = link.Voucher;
            _custVendTransDebit.CustVendTrans::packCustVendTrans_W(custVendTrans_W);
            if (_custVendTransDebit.RecId)
            {
                salesOrder = CustInvoiceJour::findFromCustTrans(_custVendTransDebit.Invoice, _custVendTransDebit.TransDate, _custVendTransDebit.AccountNum).SalesId;
                select firstonly SalesOrder from taxTransLoc
                    where taxTransLoc.Voucher == link.Voucher &&
                        taxTransLoc.TransDate == link.TransDate ;
                if (taxTransLoc.RecId)
                {
                    if (taxTransLoc.SalesOrder != '')
                    {
                        update_recordset taxTrans
                            setting SalesOrder = '*'
                        where taxTrans.Voucher  == link.Voucher &&
                            taxTrans.TransDate  == link.TransDate;
                    }
                    else
                    {
                        update_recordset taxTrans
                            setting SalesOrder = salesOrder
                        where taxTrans.Voucher  == link.Voucher &&
                            taxTrans.TransDate  == link.TransDate;
                    }
                }
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxWithholdTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the table for transaction record.
    /// </summary>
    /// <param name="_recId">
    /// The field is used to find the record.
    /// </param>
    /// <param name="_invoiceVoucher">
    /// The field is used to find the record.
    /// </param>
    /// <param name="_voucher">
    /// The field is used to find the record.
    /// </param>
    protected void updateTaxWithholdTrans_IN(RecId  _recId, Voucher _invoiceVoucher, Voucher _voucher)
    {
        TaxWithholdTrans_IN     taxWithholdTrans;
        TaxWithholdTrans        taxWithholdTransLoc;

        changecompany(settlementPair.getDebitCompany())
        {
            select firstonly Voucher from taxWithholdTrans
                where taxWithholdTrans.CustVendTransInvoiceId   == _recId
                   && taxWithholdTrans.InvoiceVoucher           == _invoiceVoucher;

            if (taxWithholdTrans.Voucher)
            {
                update_recordset taxWithholdTrans
                setting
                Voucher = _voucher
                where taxWithholdTrans.InvoiceVoucher            == _invoiceVoucher
                   && taxWithholdTrans.CustVendTransInvoiceId    == _recId ;

                update_recordset taxWithholdTransLoc
                setting
                Voucher = _voucher
                where taxWithholdTransLoc.VoucherInvoice            == _invoiceVoucher
                   && taxWithholdTransLoc.VendTransInvoiceId        == _recId ;

                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceIN00058, funcName());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransaction_W</Name>
				<Source><![CDATA[
    abstract CustVendSettlement updateTransaction_W(CustVendTrans       _custVendTrans,
                                                    CustVendTransOpen   _custVendTransOpen,
                                                    DiscAmount          _utilizedCashDisc   = 0,
                                                    PennyDiff           _pennyDiff          = 0,
                                                    NoYes               _canBeReversed      = NoYes::No,
                                                    boolean             _setOffsetRecId     = false,
                                                    boolean             _update             = false,
                                                    Voucher             _taxVoucher         = '',
                                                    boolean             _isGroupSettlement  = true,
                                                    RecId               _offsetRecId        = 0)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransactionProject</Name>
				<Source><![CDATA[
    [SysObsolete('This method is obsolete. Use updateTransactionProjectV2() instead.', false, 31\5\2022)]
    abstract void updateTransactionProject(CustVendTrans  _custVendTrans, AmountMST remainDebetCur, AmountMST settleAmountCur)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransactionProjectV2</Name>
				<Source><![CDATA[
    abstract void updateTransactionProjectV2(CustVendTrans _custVendTrans, AmountCur remainDebitCur, AmountCur settleAmountCur)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransactionReverseExchAdj_W</Name>
				<Source><![CDATA[
    abstract CustVendSettlement updateTransactionReverseExchAdj_W(CustVendTrans     _custVendTrans,
                                                    CustVendTransOpen _custVendTransOpen,
                                                    DiscAmount        _utilizedCashDisc  = 0,
                                                    boolean           _isGroupSettlement = true)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransFor1099</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the 1099 tax amount fields on the debit and credit transaction.
    /// </summary>
    /// <param name="_invoiceAmountCurDebit">
    ///    The original amount on the invoice.
    /// </param>
    /// <param name="_settleAmountCurDebit">
    ///    The calculated settlement debit amount for this transaction.
    /// </param>
    /// <param name="_discountAmountCurDebit">
    ///    The calculated settlement debit discount amount for this transaction.
    /// </param>
    protected void  updateTransFor1099( AmountCur _invoiceAmountCurDebit,
                                        AmountCur _settleAmountCurDebit,
                                        AmountCur _discountAmountCurDebit)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransForFine_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates fields on the specified transaction for the specified Fine amount.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The CustVendTrans record to update.
    /// </param>
    /// <param name="_custVendTransOpen">
    /// The CustVendTransOpen record to update.
    /// </param>
    /// <param name="_specTrans">
    /// The SpecTrans record to update.
    /// </param>
    /// <param name="_actualFineAmountCur">
    /// The Fine amount in the transaction currency.
    /// </param>
    /// <param name="_actualFineAmountMst">
    /// The Fine amount in the monetary standard (MST) currency.
    /// </param>
    /// <param name="_actualFineAmountReporting">
    /// The Fine amount in the reporting currency.
    /// </param>
    protected void updateTransForFine_BR(
        CustVendTrans _custVendTrans,
        CustVendTransOpen _custVendTransOpen,
        SpecTrans _specTrans,
        AmountCur _actualFineAmountCur,
        AmountMST _actualFineAmountMst,
        AmountMSTSecondary _actualFineAmountReporting)
    {
        CustVendTransPayment_BR paymentExt;

        // update CustVendTransOpen
        _custVendTransOpen.AmountCur += _actualFineAmountCur;
        _custVendTransOpen.AmountMST += _actualFineAmountMst;
        _custVendTransOpen.ReportingCurrencyAmount += _actualFineAmountReporting;

        // update Settle Fine amount on CustVendTrans
        _custVendTrans.SettleAmountCur -= _actualFineAmountCur;
        _custVendTrans.SettleAmountMST -= _actualFineAmountMst;
        _custVendTrans.SettleAmountReporting -= _actualFineAmountReporting;

        if (abs(_specTrans.Balance01) > abs(_custVendTrans.AmountCur + _custVendTrans.SettleAmountCur))
        {
            _specTrans.Balance01 = _custVendTrans.AmountCur - _custVendTrans.SettleAmountCur;
        }

        changecompany(_custVendTrans.company())
        {
            paymentExt = _custVendTrans.getPaymentExtension_BR();
            paymentExt.FineCode = _custVendTransOpen.FineCode_BR;
            paymentExt.FineAmount += _custVendTransOpen.FineAmount_BR;
            _custVendTrans.packExtensionTable(paymentExt);
        }

        // Set fine to zero on open trans since we no longer need it for this
        // settlement and to prevent incorrect fine on subsequent partial
        // settlements
        _custVendTransOpen.FineAmount_BR = 0;
        _custVendTransOpen.FineAmountPaymCur_BR = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransForInterest_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates fields on the specified transaction for the specified Interet amount.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The CustVendTrans record to update.
    /// </param>
    /// <param name="_custVendTransOpen">
    /// The CustVendTransOpen record to update.
    /// </param>
    /// <param name="_specTrans">
    /// The SpecTrans record to update.
    /// </param>
    /// <param name="_actualFinInterestAmountCur">
    /// The Interest amount in the transaction currency.
    /// </param>
    /// <param name="_actualFinInterestAmountMst">
    /// The Interest amount in the monetary standard (MST) currency.
    /// </param>
    /// <param name="_actualFinInterestAmountReporting">
    /// The Interest amount in the reporting currency.
    /// </param>
    protected void updateTransForInterest_BR(
        CustVendTrans _custVendTrans,
        CustVendTransOpen _custVendTransOpen,
        SpecTrans _specTrans,
        AmountCur _actualFinInterestAmountCur,
        AmountMST _actualFinInterestAmountMst,
        AmountMSTSecondary _actualFinInterestAmountReporting)
    {
        CustVendTransPayment_BR paymentExt;

        // update CustVendTransOpen
        _custVendTransOpen.AmountCur += _actualFinInterestAmountCur;
        _custVendTransOpen.AmountMST += _actualFinInterestAmountMst;
        _custVendTransOpen.ReportingCurrencyAmount += _actualFinInterestAmountReporting;

        // update Settle Interest amount on CustVendTrans
        _custVendTrans.SettleAmountCur -= _actualFinInterestAmountCur;
        _custVendTrans.SettleAmountMST -= _actualFinInterestAmountMst;
        _custVendTrans.SettleAmountReporting -= _actualFinInterestAmountReporting;

        if (abs(_specTrans.Balance01) > abs(_custVendTrans.AmountCur + _custVendTrans.SettleAmountCur))
        {
            _specTrans.Balance01 = _custVendTrans.AmountCur - _custVendTrans.SettleAmountCur;
        }

        changecompany(_custVendTrans.company())
        {
            paymentExt = _custVendTrans.getPaymentExtension_BR();
            paymentExt.InterestCode = _custVendTransOpen.InterestCode_BR;
            paymentExt.InterestAmount += _custVendTransOpen.InterestAmount_BR;
            _custVendTrans.packExtensionTable(paymentExt);
        }

        // Set interest to zero on open trans since we no longer need it for this
        // settlement and to prevent incorrect interest on subsequent partial
        // settlements
        _custVendTransOpen.InterestAmount_BR = 0;
        _custVendTransOpen.InterestAmountPaymCur_BR = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransForVATTaxAgent_RU</Name>
				<Source><![CDATA[
    protected void updateTransForVATTaxAgent_RU(
        CustVendTrans      _custVendTrans,
        CustVendTransOpen  _custVendTransOpen,
        SpecTrans          _specTrans,
        AmountCur          _actualTransaction,
        AmountMST          _actualAccounting,
        AmountMSTSecondary _actualReporting)
    {
        _custVendTransOpen.AmountCur   -= _actualTransaction;
        _custVendTrans.SettleAmountCur += _actualTransaction;

        _custVendTransOpen.AmountMST   -= _actualAccounting;
        _custVendTrans.SettleAmountMST += _actualAccounting;

        _custVendTransOpen.ReportingCurrencyAmount  -= _actualReporting;
        _custVendTrans.SettleAmountReporting        += _actualReporting;

        if (abs(_specTrans.Balance01) > abs(_custVendTrans.AmountCur - _custVendTrans.SettleAmountCur))
        {
            _specTrans.Balance01 = _custVendTrans.AmountCur - _custVendTrans.SettleAmountCur;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransOpen</Name>
				<Source><![CDATA[
    abstract void updateTransOpen(CustVendTrans custVendTrans, CustVendTransOpen _custVendTransOpen)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVendSettlementTax1099</Name>
				<Source><![CDATA[
    protected void updateVendSettlementTax1099(AmountCur _settleAmountCur, ExchRate _paymToInvoiceRate)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>useInvoiceLineAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to use the invoice line account or
    /// the cash discount account for discount posting.
    /// </summary>
    /// <param name="_cashDiscCode">
    /// The cash discount code used in the invoice.
    /// </param>
    /// <returns>
    /// true if the invoice line account should be used; otherwise, false.
    /// </returns>
    protected boolean useInvoiceLineAccount(CashDiscCode _cashDiscCode)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkServiceTaxPayment_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates advance payment of one company with taxes cannot be applied on the invoices of other company
    /// </summary>
    /// <param name="_custVendTransCredit">
    /// The payment custTrans passed
    /// </param>
    /// <param name="_custVendTransDebit">
    /// The invoice custTrans passed
    /// </param>
    /// <exception cref="Exception::Error">
    /// Taxes have been calculated and posted on the advance payment in %1 company. Advance payment of one company with taxes cannot be applied on the invoices of other company.
    /// </exception>

    public static void checkServiceTaxPayment_IN(CustVendTrans _custVendTransCredit, CustVendTrans _custVendTransDebit)
    {
        TaxTrans                paymentTaxTrans;
        TaxTrans_W              paymentTaxTrans_W;
        LedgerTransVoucherLink  ledgerTransVoucherLinkParent;
        LedgerTransVoucherLink  ledgerTransVoucherlinkChild;

        if (TaxParameters::isServiceTaxEnable_IN()
            && _custVendTransCredit.RecId != 0
            && LedgerInterCompany::findCompanyPair(_custVendTransCredit.company(), _custVendTransDebit.company()))
        {
            changecompany(_custVendTransCredit.company())
            {
                select firstonly RecId from ledgerTransVoucherLinkParent
                    where ledgerTransVoucherLinkParent.Voucher         == _custVendTransCredit.Voucher
                        && ledgerTransVoucherLinkParent.TransDate      == _custVendTransCredit.TransDate
                        && ledgerTransVoucherLinkParent.VoucherGroupId == ledgerTransVoucherLinkParent.RecId
                    join RecId, TransDate, Voucher from ledgerTransVoucherlinkChild
                        where ledgerTransVoucherlinkChild.VoucherGroupId  == ledgerTransVoucherLinkParent.RecId
                            && ledgerTransVoucherlinkChild.VoucherGroupId != ledgerTransVoucherlinkChild.RecId
                    join RecId, TransDate, Voucher from paymentTaxTrans
                        where paymentTaxTrans.TransDate   == ledgerTransVoucherlinkChild.TransDate
                            && paymentTaxTrans.Voucher    == ledgerTransVoucherlinkChild.Voucher
                    join RecId from paymentTaxTrans_W
                        where paymentTaxTrans_W.TaxTrans == paymentTaxTrans.RecId
                        && paymentTaxTrans_W.TaxType_IN == TaxType_IN::ServiceTax;

                if (paymentTaxTrans.RecId)
                {
                    throw error(strFmt("@GLS6642", _custVendTransCredit.company()));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransDimension_RU</Name>
				<Source><![CDATA[
    public static boolean checkTransDimension_RU(CustVendTrans        _custVendTransDebit,
                                                        CustVendTrans        _custVendTransCredit,
                                                        DimSettlementType_RU _dimSettlementType = DimSettlementType_RU::None)
    {
        DimensionAttributeValueSetStorage transDimStorage,
                                          offsetTransDimStorage;
        DimSettlementCtrlType_RU          dimSettlementCtrlType = (_custVendTransDebit.TableId == tableNum(CustTrans) ?
                                                                   CustParameters::find().DimSettlementCtrlType_RU :
                                                                   VendParameters::find().DimSettlementCtrlType_RU);

        boolean failMessage(CustVendTrans   _custVendTrans,
                            Name            _dimensionAttrName)
        {
            if (_dimSettlementType == DimSettlementType_RU::Auto)
            {
                return false;
            }

            return checkFailed(strFmt("@GLS113717", _custVendTrans.AccountNum, _dimensionAttrName));
        }

        boolean checkTransDimension(CustVendTrans   _custVendTrans,
                                    CustVendTrans   _custVendTransOffset)
        {
            boolean                     ret = true;

            DimSettlementCtrlType_RU    dimSettlementCtrlTypeEmpty;
            Set                         dimAttrNames;
            RecId                       dimAttrRecId;
            Name                        dimAttrName;

            SetEnumerator               setEnumerator;
            switch (_custVendTransDebit.TableId)
            {
                case tableNum(CustTrans):
                    dimAttrNames               = CustLedgerAccounts::dimensionAttrNamesForCheck_RU(_custVendTrans.AccountNum, _custVendTrans.PostingProfile);
                    dimSettlementCtrlTypeEmpty = CustLedger::find(_custVendTrans.PostingProfile).DimSettlementCtrlType_RU;
                    break;

                case tableNum(VendTrans):
                    dimAttrNames               = VendLedgerAccounts::dimensionAttrNamesForCheck_RU(_custVendTrans.AccountNum, _custVendTrans.PostingProfile);
                    dimSettlementCtrlTypeEmpty = VendLedger::find(_custVendTrans.PostingProfile).DimSettlementCtrlType_RU;
                    break;
            }

            if (dimAttrNames.elements())
            {
                transDimStorage       = DimensionAttributeValueSetStorage::find(_custVendTrans.DefaultDimension);
                offsetTransDimStorage = DimensionAttributeValueSetStorage::find(_custVendTransOffset.DefaultDimension);

                setEnumerator = dimAttrNames.getEnumerator();

                while (setEnumerator.moveNext())
                {
                    dimAttrName  = setEnumerator.current();
                    dimAttrRecId = DimensionAttribute::findByName(dimAttrName).RecId;

                    if (transDimStorage.getValueByDimensionAttribute(dimAttrRecId) != offsetTransDimStorage.getValueByDimensionAttribute(dimAttrRecId))
                    {
                        if (!transDimStorage.getValueByDimensionAttribute(dimAttrRecId) || !offsetTransDimStorage.getValueByDimensionAttribute(dimAttrRecId))
                        {
                            switch (dimSettlementCtrlTypeEmpty)
                            {
                                case DimSettlementCtrlType_RU::None:
                                    ret = failMessage(_custVendTrans, dimAttrName);
                                    break;

                                case DimSettlementCtrlType_RU::Manual:
                                    if (_dimSettlementType == DimSettlementType_RU::Auto)
                                    {
                                        ret = failMessage(_custVendTrans, dimAttrName);
                                    }
                                    break;

                                case DimSettlementCtrlType_RU::Auto:
                                    if (_dimSettlementType == DimSettlementType_RU::Manual)
                                    {
                                        ret = failMessage(_custVendTrans, dimAttrName);
                                    }
                                    break;
                            }
                        }
                        else
                        {
                            ret = failMessage(_custVendTrans, dimAttrName);
                        }
                    }
                }
            }

            return ret;
        }
        if (_dimSettlementType    == DimSettlementType_RU::None                                                               ||
            dimSettlementCtrlType == DimSettlementCtrlType_RU::None                                                           ||
           (_dimSettlementType    == DimSettlementType_RU::Manual && dimSettlementCtrlType == DimSettlementCtrlType_RU::Auto) ||
           (_dimSettlementType    == DimSettlementType_RU::Auto   && dimSettlementCtrlType == DimSettlementCtrlType_RU::Manual))
        {
            return true;
        }

        return (checkTransDimension(_custVendTransDebit, _custVendTransCredit) &&
                checkTransDimension(_custVendTransCredit, _custVendTransDebit));
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static CustVendSettle construct(SysModule _module)
    {
        CustVendSettle  custVendSettle;

        switch (_module)
        {
            case SysModule::Cust :
                custVendSettle = new CustVendSettle_Cust();
                break;

            case SysModule::Vend :
                custVendSettle = new CustVendSettle_Vend();
                break;

            default :
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        custVendSettle.parmModule(_module);

        return custVendSettle;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructCurrencyDeal_RU</Name>
				<Source><![CDATA[
    public static CustVendSettle constructCurrencyDeal_RU(SysModule          _module,
                                                          OffsetVoucher      _offsetVoucher,
                                                          LedgerVoucherGroup _ledgerVoucherGroup,
                                                          PostingProfile     _postingProfile  = '')
    {
        CustVendSettle custVendSettle;

        switch (_module)
        {
            case SysModule::Vend :
                custVendSettle = new CustVendSettle_VendCurrencyDeal_RU();
                break;

            default :
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        SettlementPair settlementPair = custVendSettle.settlementPair;
        settlementPair.setLedgerVoucherGroup(_ledgerVoucherGroup);
        custVendSettle.setOffsetVoucher(_offsetVoucher);
        custVendSettle.setPostingProfile(_postingProfile);
        custVendSettle.parmModule(_module);

        return custVendSettle;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructPayment</Name>
				<Source><![CDATA[
    static CustVendSettle constructPayment(SysModule            _module,
                                           OffsetVoucher        _offsetVoucher,
                                           LedgerVoucherGroup   _ledgerVoucherGroup,
                                           PostingProfile       _postingProfile  = '')
    {
        CustVendSettle  custVendSettle;

        switch (_module)
        {
            case SysModule::Cust :
                custVendSettle = new CustVendSettle_CustPaym();
                break;

            case SysModule::Vend :
                custVendSettle = new CustVendSettle_VendPaym();
                break;

            default :
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        SettlementPair settlementPair = custVendSettle.settlementPair;
        settlementPair.setLedgerVoucherGroup(_ledgerVoucherGroup);
        custVendSettle.setOffsetVoucher(_offsetVoucher);
        custVendSettle.setPostingProfile(_postingProfile);
        custVendSettle.parmModule(_module);

        return custVendSettle;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOriginAdjustingInvoice_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verifies if the free text invoice is a cancelling invoice.
    /// </summary>
    /// <param name="_tableId">
    ///    The TableId passed
    /// </param>
    /// <param name="_recId">
    ///    The RecId passed.
    /// </param>
    /// <returns>
    ///    true if the free text invoiceis a cancelling one; otherwise, false.
    /// </returns>
    public static boolean isOriginAdjustingInvoice_IN(TableId _tableId, CustInvoiceTableRefRecId _recId)
    {
        CustRelatedInvoice custRelatedInvoiceLoc;
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
            && _tableId == tableNum(CustInvoiceTable)
            && _recId)
        {
            select firstonly RecId from custRelatedInvoiceLoc
                where custRelatedInvoiceLoc.CustInvoice            == _recId
                   && custRelatedInvoiceLoc.InvoiceAssociationType == InvoiceAssociationType::AdjustingInvoice;
        }

        return custRelatedInvoiceLoc.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newOffsetVoucher</Name>
				<Source><![CDATA[
    static CustVendSettle newOffsetVoucher(SysModule            _module,
                                           OffsetVoucher        _offsetVoucher,
                                           LedgerVoucherGroup   _ledgerVoucherGroup,
                                           PostingProfile       _postingProfile = '')
    {
        CustVendSettle  custVendSettle;
        custVendSettle = CustVendSettle::construct(_module);

        SettlementPair settlementPair = custVendSettle.settlementPair;
        settlementPair.setLedgerVoucherGroup(_ledgerVoucherGroup);
        custVendSettle.setOffsetVoucher(_offsetVoucher);
        custVendSettle.setPostingProfile(_postingProfile);

        return custVendSettle;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingProfileSettle_RU</Name>
				<Source><![CDATA[
    public static void postingProfileSettle_RU(LedgerVoucher           _ledgerVoucher,
                                               CustVendTrans           _custVendTrans,
                                               AmountCur               _amountCur,
                                               CustVendTransSettlement _custVendTransSettlement,
                                               Counter                 _settlementGroupPlaceHolder,
                                               DimensionDefault        _transDefaultDimension,
                                               PostingProfile          _postingProfile     = _custVendTrans.PostingProfile,
                                               LedgerTransTxt          _ledgerTransTxt     = LedgerTransTxt::Settlement,
                                               AmountMST               _amountMST          = 0,
                                               AmountMSTSecondary      _amountMSTSecondary = 0,
                                               CurrencyCode            _currencyCode       = '',
                                               LedgerDimensionAccount  _ledgerDimension    = 0,
                                               boolean                 _recordCustVendTrans = true,
                                               boolean                 _postToGeneralLedger = true)
    {
        // static postingProfileSettle method was moved from CustVendSettle_XXX classes to CustVendPrePaymentReversal class
        CustVendPrePaymentReversal custVendPrePaymentReversal =
            CustVendPrePaymentReversal::newCustVendTrans(_custVendTrans, _custVendTransSettlement, _settlementGroupPlaceHolder);

        custVendPrePaymentReversal.postingProfileSettle(_ledgerVoucher,
                                                          _custVendTrans,
                                                          _amountCur,
                                                          _custVendTransSettlement,
                                                          _settlementGroupPlaceHolder,
                                                          _transDefaultDimension,
                                                          _postingProfile,
                                                          _ledgerTransTxt,
                                                          _amountMST,
                                                          _currencyCode,
                                                          _amountMSTSecondary,
                                                          _ledgerDimension,
                                                          _recordCustVendTrans,
                                                          _postToGeneralLedger);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processConditionalTax_ES</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs posting of conditional tax for Spanish scenarios (remittance without BOE/Promissory note).
    /// </summary>
    /// <param name="_origSettleFactorDebit">
    /// The percent of the debit transaction that is settled excluding the current settlement.
    /// </param>
    /// <param name="_cashDiscAmountCurDebit">
    /// The cash discount amount for the debit transactions in the transaction currency.
    /// </param>
    /// <param name="_custVendNegInstInvoice">
    /// A table buffer containing the invoice transaction for the negotiable instrument.
    /// </param>
    protected void processConditionalTax_ES(
        Percent _origSettleFactorDebit,
        DiscAmount _cashDiscAmountCurDebit,
        CustVendTrans _custVendNegInstInvoice)
    {
        AmountCur invoiceAmountCur;

        if (settlementPair.getCustVendTransDebit().CurrencyCode != _custVendNegInstInvoice.CurrencyCode)
        {
            ExchangeRateHelper exchangeRateHelper = exchangeRateHelper::construct();
            CurrencyExchangeHelper currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(settlementPair.getDebitCompany()).RecId), settlementPair.getCustVendTransDebit().TransDate);
            invoiceAmountCur = currencyHelper.calculateTransactionToTransaction(Ledger::primaryLedger(CompanyInfo::findDataArea(settlementPair.getDebitCompany()).RecId),
                                                                                _custVendNegInstInvoice.CurrencyCode,
                                                                                settlementPair.getCustVendTransDebit().CurrencyCode,
                                                                                -_custVendNegInstInvoice.AmountCur, 0, true);
        }
        else
        {
            invoiceAmountCur = -_custVendNegInstInvoice.AmountCur;
        }

        Percent currentSettleFactor = invoiceAmountCur ? settlementPair.getCustVendTransDebit().SettleAmountCur / invoiceAmountCur : 0;

        this.postConditionalTax(
            currentSettleFactor,
            _origSettleFactorDebit,
            _custVendNegInstInvoice,
            settlementPair.getCustVendTransCredit(),
            _cashDiscAmountCurDebit,
            settlementPair.getExchRate().getDebitCurToDebitMstCombined(),
            settlementPair.getExchRate().getDebitCurToReporting());
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSummaryAccountReliefTransactions</Name>
				<Source><![CDATA[
    private LedgerVoucher createSummaryAccountReliefTransactions(
        LedgerVoucher _ledgerVoucher,
        AmountMST _settleAmountAccountingDebit,
        AmountCur _settleAmountCurDebit,
        Money _settleAmountReportingDebit,
        TransactionTextLarge _settlementTransText,
        boolean _debitHasMultipleSummaryEntries,
        boolean _creditHasMultipleSummaryEntries)
    {
        CustVendTransDistributionController debitController;
        CustVendTransDistributionController creditController;

        // NOTE: the creation of the distributions was separated from the action of creating the trans because the processes are driven from different
        // data. The creation of the trans records is always driven from the debit record side, while the generation of the distributions is driven
        // from the debit and the credit side. Separation into explicit calls makes this difference evident and simplifies the calls.
        // In addition this allows the ordering of these steps to be modified to enable future modifications which detect posting account differences
        // at a more granular level to determine whether extra transactions need to be generated by the "posting profile differences" concept.

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
            && LedgerParameters::find().JournalizingDefinitionEnableValue == NoYes::Yes
            && CustSettleJournalizingEntries::requiredAdditionalEntries(settlementPair.getCustVendTransDebit().TransType, settlementPair.getCustVendTransCredit().TransType)
            && custSettleJournalizingEntries.existGeneratedEntry(
                                            this.amount(_settleAmountCurDebit),
                                            this.amount(_settleAmountAccountingDebit),
                                            this.amount(_settleAmountReportingDebit),
                                            settlementPair.getCustVendTransDebit(),
                                            settlementPair.getCustVendTransCredit()))

        {
            custSettleJournalizingEntries.parmCustVendTransLedgerVoucherMap().insert(settlementPair.getCustVendTransOpenDebit().RecId, _ledgerVoucher.findLedgerVoucherObject());
            custSettleJournalizingEntries.postJournalizingEntries();
        }

        if (BrazilParameters::isEnabled()
            && ReliefAmountGenerateNewVoucherFromInterestFlight::instance().isEnabled()
            && existFineInterestBR)
        {
            NumberSequenceReference numberSeqRef = settlementPair.numRefCustVendPaymVoucher();
            NumberSeq numberSeq = NumberSeq::newGetVoucher(numberSeqRef);

            LedgerVoucherObject ledgerVoucherObject = LedgerVoucherObject::newVoucher(numberSeq.voucher(),
                settlementPair.getTransactionDate(),
                this.parmModule(),
                this.ledgerTransactionType());

            _ledgerVoucher.addVoucher(ledgerVoucherObject);
        }

        // create the ledger voucher transactions associated with the debit
        debitController = this.createCustVendTransDistributionControllerForDebit(isSettleByLineEnabled, settlementPair.getSpecTransDebit().RecId);
        this.postingProfileSettle_CreateDistributions(_ledgerVoucher,
            settlementPair.getCustVendTransDebit(),
            debitController,
            this.amount(-_settleAmountCurDebit),
            this.amount(-_settleAmountAccountingDebit),
            this.amount(-_settleAmountReportingDebit),
            _settlementTransText,
            settlementPair.getCustVendTransDebit().CurrencyCode,
            _debitHasMultipleSummaryEntries);

        // create the ledger voucher transactions associated with the credit
        creditController = this.createCustVendTransDistributionControllerForCredit(isSettleByLineEnabled, settlementPair.getSpecTransCredit().RecId);
        this.postingProfileSettle_CreateDistributions(_ledgerVoucher,
            settlementPair.getCustVendTransCredit(),
            creditController,
            this.amount(_settleAmountCurDebit),
            this.amount(_settleAmountAccountingDebit),
            this.amount(_settleAmountReportingDebit),
            _settlementTransText,
            settlementPair.getCustVendTransDebit().CurrencyCode,
            _creditHasMultipleSummaryEntries);

        // create the trans and settlement trans associated with the debit
        if (VendTransAssignSummaryAccountIdToSettlementTransFlight::instance().isEnabled() && settlementPair.getCustVendTransDebit().TableId == tableNum(VendTrans))
        {
            VendTransSettlement vendTransSettlement = custVendTransSettlement as VendTransSettlement;
            vendTransSettlement.setNextTransSummaryAccount(settlementPair.getCustVendTransDebit().SummaryAccountId);
        }
        this.postingProfileSettle_CreateTrans(_ledgerVoucher,
            settlementPair.getCustVendTransDebit(),
            this.amount(-_settleAmountCurDebit),
            this.amount(-_settleAmountAccountingDebit),
            this.amount(-_settleAmountReportingDebit),
            custVendTransSettlement,
            settlementGroupPlaceHolder,
            settlementPair.getCustVendTransDebit().DefaultDimension,
            settlementPair.getCustVendTransDebit().PostingProfile,
            _settlementTransText);

        // create the trans and settlement trans associated with the credit
        if (VendTransAssignSummaryAccountIdToSettlementTransFlight::instance().isEnabled() && settlementPair.getCustVendTransCredit().TableId == tableNum(VendTrans))
        {
            VendTransSettlement vendTransSettlement = custVendTransSettlement as VendTransSettlement;
            vendTransSettlement.setNextTransSummaryAccount(settlementPair.getCustVendTransCredit().SummaryAccountId);
        }
        this.postingProfileSettle_CreateTrans(_ledgerVoucher,
            settlementPair.getCustVendTransDebit(),
            this.amount(_settleAmountCurDebit),
            this.amount(_settleAmountAccountingDebit),
            this.amount(_settleAmountReportingDebit),
            custVendTransSettlement,
            settlementGroupPlaceHolder,
            settlementPair.getCustVendTransCredit().DefaultDimension,
            settlementPair.getCustVendTransCredit().PostingProfile,
            _settlementTransText);

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
            && CustSettleJournalizingEntries::requiredAdditionalEntries(settlementPair.getCustVendTransDebit().TransType, settlementPair.getCustVendTransCredit().TransType)
            && custSettleJournalizingEntries.existGeneratedEntry(
                                            this.amount(_settleAmountCurDebit),
                                            this.amount(_settleAmountAccountingDebit),
                                            this.amount(_settleAmountReportingDebit),
                                            settlementPair.getCustVendTransDebit(),
                                            settlementPair.getCustVendTransCredit()))
        {
            custSettleJournalizingEntries.parmCustVendTransLedgerVoucherMap().insert(settlementPair.getCustVendTransOpenDebit().RecId, _ledgerVoucher.findLedgerVoucherObject());
        }

        return _ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustVendTransDistributionControllerForDebit</Name>
				<Source><![CDATA[
    /// <summary>
    ///  An instance of the <c>CustVendTransDistributionController</c> class for settlements.
    /// </summary>
    /// <param name="_isSettleByLineEnabled">
    ///  Identifies when line level settlements are enabled.
    /// </param>
    /// <param name="_currentSpecTransId">
    ///  Identifies the current invoice line that is being settled for line level settlements.
    /// </param>
    /// <returns>
    /// An instance of the <c>CustVendTransDistributionController</c> class.
    /// </returns>
    protected CustVendTransDistributionController createCustVendTransDistributionControllerForDebit(boolean _isSettleByLineEnabled, RefRecId _currentSpecTransId)
    {
        return CustVendTransDistributionController::constructForSettlement(_isSettleByLineEnabled, settlementPair.getSpecTransDebit().RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustVendTransDistributionControllerForCredit</Name>
				<Source><![CDATA[
    /// <summary>
    ///  An instance of the <c>CustVendTransDistributionController</c> class for settlements.
    /// </summary>
    /// <param name="_isSettleByLineEnabled">
    ///  Identifies when line level settlements are enabled.
    /// </param>
    /// <param name="_currentSpecTransId">
    ///  Identifies the current invoice line that is being settled for line level settlements.
    /// </param>
    /// <returns>
    /// An instance of the <c>CustVendTransDistributionController</c> class.
    /// </returns>
    protected CustVendTransDistributionController createCustVendTransDistributionControllerForCredit(boolean _isSettleByLineEnabled, RefRecId _currentSpecTransId)
    {
        return CustVendTransDistributionController::constructForSettlement(_isSettleByLineEnabled, settlementPair.getSpecTransCredit().RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscCurrencyHelper</Name>
				<Source><![CDATA[
    private CurrencyExchangeHelper getCashDiscCurrencyHelper(
        ExchRate _exchRate,
        ExchRate _exchRateReporting)
    {
        CurrencyExchangeHelper              currencyHelper;

        currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), settlementPair.getTransactionDate());
        currencyHelper.parmExchangeRate1(_exchRate);
        currencyHelper.parmReportingExchangeRate1(_exchRateReporting);

        return currencyHelper;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a list of cash discount distributions.
    /// </summary>
    /// <param name="_totalAmountCur">
    ///  The total amount of the cash discount.
    /// </param>
    /// <param name="_custVendTrans">
    ///  The debit customer or vendor transaction.
    /// </param>
    /// <param name="_exchRate">
    ///  The accounting currency exchange rate.
    /// </param>
    /// <param name="_exchRateReporting">
    ///  The reporting currency exchange rate.
    /// </param>
    /// <param name="_discLedgerDimension">
    /// The discount ledger dimension.
    /// </param>
    /// <param name="_mergeDefaultWithOriginalDimension">
    ///  True when the default ledger dimension should be merged with the ledger dimensions of the original document; optional.
    /// </param>
    /// <returns>
    /// A list of distributions.
    /// </returns>
    protected List getCashDiscDistributions(
        AmountCur                     _totalAmountCur,
        CustVendTrans                 _custVendTrans,
        ExchRate                      _exchRate,
        ExchRate                      _exchRateReporting,
        LedgerDimensionDefaultAccount _discLedgerDimension,
        boolean                       _mergeDefaultWithOriginalDimension = true)

    {
        CustVendTransDistributionController distributionController;
        CurrencyExchangeHelper              currencyHelper;
        List                                originalExpenseRevenueAccountTypes;
        List                                distributions;

        distributionController = CustVendTransDistributionController::constructForSettlement(isSettleByLineEnabled, settlementPair.getSpecTransDebit().RecId);

        currencyHelper = this.getCashDiscCurrencyHelper(_exchRate, _exchRateReporting);

        originalExpenseRevenueAccountTypes = CustVendSettlePostingTypes::construct(_custVendTrans).getOriginalPostingAccountTypes();

        //Find the distributions for the the cash discount amount
        distributions = distributionController.generateDistributionsForPostingTypes(
                _custVendTrans,
                originalExpenseRevenueAccountTypes,
                _totalAmountCur,
                currencyHelper.calculateTransactionToAccounting(_custVendTrans.CurrencyCode, _totalAmountCur, true),
                currencyHelper.calculateTransactionCurrencyToReportingCurrency(_custVendTrans.CurrencyCode, _totalAmountCur),
                _discLedgerDimension,
                false,
                _mergeDefaultWithOriginalDimension);

        return distributions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscInvLineAccountDistributions_PSN</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Get a list of distributions for the Invoice Line Account option.
    /// </summary>
    /// <param name="_totalAmountCur">
    ///  The total amount of the cash discount.
    /// </param>
    /// <param name="_custVendTrans">
    ///  The debit customer or vendor transaction.
    /// </param>
    /// <param name="_exchRate">
    ///  The accounting currency exchange rate.
    /// </param>
    /// <param name="_exchRateReporting">
    ///  The reporting currency exchange rate.
    /// </param>
    /// <param name="_cashDiscountDefaultAccount">
    ///  The discount ledger dimension.
    /// </param>
    /// <returns>
    ///  A list of distributions.
    /// </returns>
    private List getCashDiscInvLineAccountDistributions_PSN(
        AmountCur                       _totalAmountCur,
        CustVendTrans                   _custVendTrans,
        ExchRate                        _exchRate,
        ExchRate                        _exchRateReporting,
        LedgerDimensionDefaultAccount   _cashDiscountDefaultAccount)

    {
        CustVendTransDistributionController distributionController;
        List                                originalExpenseRevenueAccountTypes;
        List                                distributions  = new List(Types::Class);
        CurrencyExchangeHelper              currencyHelper;

        distributionController = CustVendTransDistributionController::constructForSettlement(isSettleByLineEnabled, settlementPair.getSpecTransDebit().RecId);

        currencyHelper = this.getCashDiscCurrencyHelper(_exchRate, _exchRateReporting);

        originalExpenseRevenueAccountTypes = CustVendSettlePostingTypes::construct(_custVendTrans).getOriginalPostingAccountTypes();

        distributions = distributionController.generateDistributionsForPostingTypes(
                _custVendTrans,
                originalExpenseRevenueAccountTypes,
                _totalAmountCur,
                currencyHelper.calculateTransactionToAccounting(_custVendTrans.CurrencyCode, _totalAmountCur, true),
                currencyHelper.calculateTransactionCurrencyToReportingCurrency(_custVendTrans.CurrencyCode, _totalAmountCur),
                _cashDiscountDefaultAccount);

        return distributions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscSingleDistribution</Name>
				<Source><![CDATA[
    private List getCashDiscSingleDistribution(
        AmountCur                     _totalAmountCur,
        CustVendTrans                 _custVendTrans,
        ExchRate                      _exchRate,
        ExchRate                      _exchRateReporting,
        LedgerDimensionDefaultAccount _discLedgerDimension)

    {
        List                                distributions;
        CustVendTransDistribution           distribution;
        CurrencyExchangeHelper              currencyHelper;

        distributions = new List(Types::Class);

        currencyHelper = this.getCashDiscCurrencyHelper(_exchRate, _exchRateReporting);

        distribution =  new CustVendTransDistribution(
                _discLedgerDimension,
                _totalAmountCur,
                currencyHelper.calculateTransactionToAccounting(_custVendTrans.CurrencyCode, _totalAmountCur, true),
                currencyHelper.calculateTransactionCurrencyToReportingCurrency(_custVendTrans.CurrencyCode, _totalAmountCur));

        distributions.addEnd(distribution);

        return distributions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscTaxDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of distributions for a cash discount
    /// on an invoice with taxes applied.
    /// </summary>
    /// <param name="_totalAmountCur">
    /// The total amount of the cash discount.
    /// </param>
    /// <param name="_custVendTrans">
    /// The debit customer or vendor transaction.
    /// </param>
    /// <param name="_exchRate">
    /// The accounting currency exchange rate.
    /// </param>
    /// <param name="_exchRateReporting">
    /// The reporting currency exchange rate.
    /// </param>
    /// <returns>
    /// A list of distributions.
    /// </returns>
    /// <remarks>
    /// The distributions are based on the original invoice's line
    /// amounts, then split based on the taxes on each invoice line.
    /// </remarks>
    protected List getCashDiscTaxDistributions(
        AmountCur _totalAmountCur,
        CustVendTrans _custVendTrans,
        ExchRate _exchRate,
        ExchRate _exchRateReporting)
    {
        TaxTrans taxTrans;

        AmountCur lineCashDiscountAmount;
        AmountCur remainingTotalAmountCur = _totalAmountCur;
        AmountMST totalTaxBaseAmount = 0.0;

        RecId currentSourceRecId = 0;
        AmountMST taxBaseAmount = 0.0;
        AmountMST totalTaxAmount = 0.0;

        int64 sourceRecIdCount = 0;
        int64 sourceRecIdProcessed = 0;

        List sourceInvoiceLines =  new List(Types::Container);
        List cashDiscDistributions;
        List distributions  = new List(Types::Class);

        Set settlementTaxTransReversalRecIds = new Set(Types::Int64);

        while select SourceRecId, TaxAmount, TaxBaseAmount from taxTrans
            order by taxTrans.SourceRecId
            where taxTrans.Voucher == _custVendTrans.Voucher
                && taxTrans.TransDate == _custVendTrans.TransDate
        {
            if (taxTrans.SourceRecId != currentSourceRecId)
            {
                if (currentSourceRecId != 0)
                {
                    sourceInvoiceLines.addEnd([currentSourceRecId, taxBaseAmount, totalTaxAmount]);
                }

                currentSourceRecId = taxTrans.SourceRecId;
                taxBaseAmount = taxTrans.TaxBaseAmount;
                totalTaxAmount = 0.0;

                sourceRecIdCount++;
                totalTaxBaseAmount += taxTrans.TaxBaseAmount;
            }

            totalTaxAmount += taxTrans.TaxAmount;
        }

        sourceInvoiceLines.addEnd([currentSourceRecId, taxBaseAmount, totalTaxAmount]);

        if (totalTaxBaseAmount == 0)
        {
            return distributions;
        }

        ListEnumerator le = sourceInvoiceLines.getEnumerator();

        while (le.moveNext())
        {
            [currentSourceRecId, taxBaseAmount, totalTaxAmount] = le.current();

            sourceRecIdProcessed++;

            if (sourceRecIdProcessed == sourceRecIdCount)
            {
                lineCashDiscountAmount = remainingTotalAmountCur;
            }
            else
            {
                // Find the cash discount amount in terms of the TaxBaseAmount
                lineCashDiscountAmount = (taxBaseAmount / totalTaxBaseAmount) * _totalAmountCur;
                lineCashDiscountAmount = CurrencyExchange::round(lineCashDiscountAmount, _custVendTrans.CurrencyCode);
            }

            remainingTotalAmountCur -= lineCashDiscountAmount;

            cashDiscDistributions = this.getCashDiscTaxDistributionsForInvoiceLine(
                lineCashDiscountAmount,
                _custVendTrans,
                _exchRate,
                _exchRateReporting,
                totalTaxAmount,
                currentSourceRecId,
                settlementTaxTransReversalRecIds);

            distributions.appendList(cashDiscDistributions);
        }

        return distributions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscTaxDistributionsForInvoiceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of distributions for a cash discount on an invoice line
    /// that has taxes applied.
    /// </summary>
    /// <param name="_totalCashDiscountLineAmount">
    ///  The total amount of the cash discount for the specified invoice line.
    /// </param>
    /// <param name="_custVendTrans">
    ///  The debit customer or vendor transaction.
    /// </param>
    /// <param name="_exchRate">
    ///  The accounting currency exchange rate.
    /// </param>
    /// <param name="_exchRateReporting">
    ///  The reporting currency exchange rate.
    /// </param>
    /// <param name="_totalTaxAmount">
    ///  The total tax amount for the specified invoice line.
    /// </param>
    /// <param name="_sourceLineRecId">
    ///  The ID of the invoice line.
    /// </param>
    /// <param name="_settlementTaxTransReversalRecIds">
    ///  A set of settlement tax transaction reversal record IDs.
    /// </param>
    /// <returns>
    ///  A list of distributions.
    /// </returns>
    /// <remarks>
    /// The distributions are based on the taxes applied to the invoice line.
    /// </remarks>
    protected List getCashDiscTaxDistributionsForInvoiceLine(
        AmountCur _totalCashDiscountLineAmount,
        CustVendTrans _custVendTrans,
        ExchRate _exchRate,
        ExchRate _exchRateReporting,
        AmountCur _totalTaxAmount,
        RefRecId _sourceLineRecId,
        Set _settlementTaxTransReversalRecIds)
    {
        TaxTrans taxTrans;
        TaxLedgerAccountGroup taxLedgerAccountGroup;
        TaxTable taxTable;
        LedgerDimensionDefaultAccount cashDiscountWithoutTaxCodeDefaultAccount;
        LedgerDimensionDefaultAccount cashDiscountDefaultAccount;
        int64 taxTransCount;
        int64 taxTransProcessed;
        AmountCur cashDiscountAmount;
        AmountCur remainingTotalAmountCur;
        CustVendTransDistributionController distributionController;
        List cashDiscDistributions;
        List distributions  = new List(Types::Class);
        CurrencyExchangeHelper currencyHelper;

        remainingTotalAmountCur = _totalCashDiscountLineAmount;

        currencyHelper = this.getCashDiscCurrencyHelper(_exchRate, _exchRateReporting);

        cashDiscountWithoutTaxCodeDefaultAccount = SettlementUtility::determineCashDiscountLedgerDimension(
            this.parmModule(),
            _custVendTrans,
            settlementPair.getCustVendTransOpenDebit(),
            cashDiscTransCodeDebit,
            true);

        select count(RecId) from taxTrans
            where taxTrans.Voucher == _custVendTrans.Voucher
                && taxTrans.TransDate == _custVendTrans.TransDate
                && taxTrans.SourceRecId == _sourceLineRecId;

        taxTransCount = taxTrans.RecId;

        while select TaxCode, TaxAmount, SourceDocumentLine, TaxGroup from taxTrans
            order by taxTrans.RecId
            where taxTrans.Voucher == _custVendTrans.Voucher
                && taxTrans.TransDate == _custVendTrans.TransDate
                && taxTrans.SourceRecId == _sourceLineRecId
        {
            taxTransProcessed++;

            cashDiscountDefaultAccount = cashDiscountWithoutTaxCodeDefaultAccount;

            if (this.isCashDiscLedgerDimensionOverriden())
            {
                cashDiscountDefaultAccount = settlementPair.getCustVendTransOpenDebit().CashDiscountLedgerDimension;
            }
            else
            {
                //Find cash discount ledger dimension from the tax code ledger posting group override
                select firstonly CashDiscountOutgoingLedgerDimension, CashDiscountIncomingLedgerDimension from taxLedgerAccountGroup
                    join RecId from taxTable
                        where taxTable.TaxCode == taxTrans.TaxCode
                            && taxTable.TaxAccountGroup == taxLedgerAccountGroup.TaxAccountGroup;

                if (_custVendTrans.TableId == tableNum(CustTrans))
                {
                    if (taxLedgerAccountGroup.CashDiscountOutgoingLedgerDimension)
                    {
                        cashDiscountDefaultAccount = taxLedgerAccountGroup.CashDiscountOutgoingLedgerDimension;
                    }
                }
                else
                {
                    if (taxLedgerAccountGroup.CashDiscountIncomingLedgerDimension)
                    {
                        cashDiscountDefaultAccount = taxLedgerAccountGroup.CashDiscountIncomingLedgerDimension;
                    }
                }
            }

            // If there are no taxes on the invoice line, allocate the cash discount to the first tax code.
            if (taxTransProcessed == taxTransCount || _totalTaxAmount == 0.0)
            {
                cashDiscountAmount = remainingTotalAmountCur;
            }
            else
            {
                // Find the cash discount amount in terms of the TaxAmount
                cashDiscountAmount = (taxTrans.TaxAmount / _totalTaxAmount) * _totalCashDiscountLineAmount;
                cashDiscountAmount = CurrencyExchange::round(cashDiscountAmount, _custVendTrans.CurrencyCode);
            }

            remainingTotalAmountCur -= cashDiscountAmount;

            distributionController = CustVendTransDistributionController::constructForSettlement(isSettleByLineEnabled, settlementPair.getSpecTransDebit().RecId);
            cashDiscDistributions = distributionController.generateDistributionsFromTaxLink(
                    _custVendTrans,
                    taxTrans.RecId,
                    cashDiscountDefaultAccount,
                    cashDiscountAmount,
                    currencyHelper.calculateTransactionToAccounting(_custVendTrans.CurrencyCode, cashDiscountAmount, true),
                    currencyHelper.calculateTransactionCurrencyToReportingCurrency(_custVendTrans.CurrencyCode, cashDiscountAmount));

            if (this.canReverseTaxWithCashDiscount(taxTrans.TaxGroup, _custVendTrans))
            {
                cashDiscDistributions = this.applyTaxTransRecIdToDistributions(
                    _custVendTrans,
                    taxTrans,
                    cashDiscDistributions,
                    _settlementTaxTransReversalRecIds);
            }

            distributions.appendList(cashDiscDistributions);

            if (remainingTotalAmountCur == 0.0)
            {
                break;
            }
        }

        return distributions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReverseTaxWithCashDiscount</Name>
				<Source><![CDATA[
    private boolean canReverseTaxWithCashDiscount(TaxGroup _taxGroup, CustVendTrans _custVendTrans)
    {
        boolean canReverseTaxWithCashDiscount;

        // find the invoice associated with the transaction
        CustVendInvoiceJour custVendInvoiceJour = this.findInvoiceForCustVendProj(
            _custVendTrans.AccountNum,
            _custVendTrans.Invoice,
            _custVendTrans.Voucher,
            _custVendTrans.TransDate);

        boolean cashDiscVat;
        using (TaxIntegrationTaxJurisdictionParametersContext taxIntegrationTaxJurisdictionParametersContext = TaxIntegrationTaxJurisdictionParametersContext::construct(custVendInvoiceJour.TableId, custVendInvoiceJour.RecId))
        {
            cashDiscVat = this.cashDiscVat();
        }

        if (cashDiscVat)
        {
            TaxGroupHeading taxGroupHeading = TaxGroupHeading::find(_taxGroup);

            boolean shouldReverseTaxOnCashDisc = taxGroupHeading.TaxReverseOnCashDisc;
            if (custVendInvoiceJour)
            {
                TaxIntegrationTaxJurisdictionParameters taxIntegrationTaxJurisdictionParameters = TaxIntegrationFacade::getTaxJurisdictionParameters(
                    custVendInvoiceJour.TableId,
                    custVendInvoiceJour.RecId);

                if (taxIntegrationTaxJurisdictionParameters && !taxIntegrationTaxJurisdictionParameters.empty())
                {
                    shouldReverseTaxOnCashDisc = taxIntegrationTaxJurisdictionParameters.shouldReverseTaxOnCashDisc();
                }
            }

            if (shouldReverseTaxOnCashDisc
                && ((this.moduleCustVend() == ModuleCustVend::Cust)
                || (this.moduleCustVend() == ModuleCustVend::Vend && TaxParameters::find().PurchTaxOnOperations == false)))
            {
                canReverseTaxWithCashDiscount = true;
            }
        }

        return canReverseTaxWithCashDiscount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyTaxTransRecIdToDistributions</Name>
				<Source><![CDATA[
    private List applyTaxTransRecIdToDistributions(
        CustVendTrans _custVendTrans,
        TaxTrans _invoiceTaxTrans,
        List _cashDiscDistributions,
        Set _settlementTaxTransReversalRecIds)
    {
        TaxTrans settlementTaxCashDiscReverseTaxTrans;

        if (_custVendTrans.AccountingEvent)
        {
            LedgerVoucher ledgerVoucher = settlementPair.findLedgerVoucherByCompany(_custVendTrans.company());

            select firstonly RecId from settlementTaxCashDiscReverseTaxTrans
                where settlementTaxCashDiscReverseTaxTrans.SourceDocumentLine == _invoiceTaxTrans.SourceDocumentLine
                    && settlementTaxCashDiscReverseTaxTrans.TaxOrigin == TaxOrigin::CashDisc
                    && settlementTaxCashDiscReverseTaxTrans.Source == TaxModuleType::Voucher
                    && settlementTaxCashDiscReverseTaxTrans.TaxCode == _invoiceTaxTrans.TaxCode
                    && settlementTaxCashDiscReverseTaxTrans.Voucher == ledgerVoucher.lastVoucher();
        }
        else
        {
            LedgerVoucher ledgerVoucher = settlementPair.findLedgerVoucherByCompany(_custVendTrans.company());

            while select RecId from settlementTaxCashDiscReverseTaxTrans
                where settlementTaxCashDiscReverseTaxTrans.SourceTableId == _custVendTrans.TableId
                    && settlementTaxCashDiscReverseTaxTrans.SourceRecId == _custVendTrans.RecId
                    && settlementTaxCashDiscReverseTaxTrans.TaxOrigin == TaxOrigin::CashDisc
                    && settlementTaxCashDiscReverseTaxTrans.Source == TaxModuleType::Voucher
                    && settlementTaxCashDiscReverseTaxTrans.TaxCode == _invoiceTaxTrans.TaxCode
                    && settlementTaxCashDiscReverseTaxTrans.Voucher == ledgerVoucher.lastVoucher()
            {
                if (_settlementTaxTransReversalRecIds.in(settlementTaxCashDiscReverseTaxTrans.RecId))
                {
                    continue;
                }
                else
                {
                    _settlementTaxTransReversalRecIds.add(settlementTaxCashDiscReverseTaxTrans.RecId);
                    break;
                }
            }
        }

        return CustVendTransDistribution::applyTaxTransRecId(_cashDiscDistributions, settlementTaxCashDiscReverseTaxTrans.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingType_ExchRateTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger posting type for the tax settlement exchange adjustment posting.
    /// </summary>
    /// <param name="_exchRateDiff">
    /// Amount of the exchange rate adjustment.
    /// </param>
    /// <returns>
    /// <c>LedgerPostingType</c> for the tax settlement exchange adjustment posting.
    /// </returns>
    /// <remarks>
    /// The logic for retrieving the posting type is identical for both the AP and AR side.
    /// This is because on the AR side the tax posting is money that is owed by the company.
    /// If the company owes more tax (overall transaction gain) it is a tax loss. On the AP side,
    /// the tax posting is an asset that can be netted out against owed tax to reduce what
    /// is owed. If the tax that can be netted out is now less (overall transaction gain),
    /// it's a tax loss as well.
    /// </remarks>
    private LedgerPostingType getLedgerPostingType_ExchRateTax(Amount _exchRateDiff)
    {
        return _exchRateDiff > 0 ? LedgerPostingType::ExchRateGain : LedgerPostingType::ExchRateLoss;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingTypes_Balance</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Gets a list that constains the balance posting type.
    /// </summary>
    /// <returns>
    ///  A list that contains the balance posting type.
    /// </returns>
    /// <remarks>
    ///  The list will contain either the CustBalance or VendBalance posting type.
    /// </remarks>
    public List getLedgerPostingTypes_Balance()
    {
        List ledgerPostingTypes = new List(Types::Enum);

        ledgerPostingTypes.addEnd(this.getLedgerPostingType_Balance());

        return ledgerPostingTypes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCashDiscLedgerDimensionOverriden</Name>
				<Source><![CDATA[
    private boolean isCashDiscLedgerDimensionOverriden()
    {
        boolean ret;

        if (settlementPair.getCustVendTransOpenDebit().CashDiscountLedgerDimension)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCashDiscDistributions</Name>
				<Source><![CDATA[
    private void postCashDiscDistributions(
        CustVendTrans _custVendTrans,
        LedgerVoucher _ledgerVoucher,
        List _distributions,
        boolean _skipDimensionValidation = false,
        boolean _applyDefaultDimensions = false)
    {
        LedgerVoucherObject ledgerVoucherObject;
        LedgerVoucherTransObject ledgerVoucherTransObject;
        CustVendTransDistribution distribution;
        ListEnumerator distributionEnumerator;
        CustVendTransPostingLog_RU custVendTransPostingLog;

        // Create the cash discount distributions
        ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();

        DimensionDefault custVendDefaultDimension;
        if (_applyDefaultDimensions)
        {
            custVendDefaultDimension = CustVendTable::getDefaultDimension(this.moduleCustVend(), _custVendTrans.AccountNum);
        }

        distributionEnumerator = _distributions.getEnumerator();
        while (distributionEnumerator.moveNext())
        {
            distribution = distributionEnumerator.current();
            LedgerDimensionAccount ledgerDimension = distribution.ledgerDimension();

            if (_applyDefaultDimensions)
            {
                DimensionDefault mainAccountDefaultDimension = MainAccountLegalEntity::findByMainAccountLegalEntity(
                        LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(ledgerDimension),
                        CompanyInfo::current()).DefaultDimension;

                ledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(
                    ledgerDimension,
                    _custVendTrans.DefaultDimension,
                    custVendDefaultDimension,
                    mainAccountDefaultDimension);
            }

            fixedAssetDiscountDimension = ledgerDimension;

            ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
                    ledgerVoucherObject,
                    this.getLedgerPostingType_CashDisc(),
                    ledgerDimension,
                    _custVendTrans.CurrencyCode,
                    -distribution.transactionAmount(),
                    -distribution.accountingAmount(),
                    -distribution.reportingAmount());

            if (taxChargeIntercompanySet && !taxChargeIntercompanySet.empty() && taxChargeIntercompanySet.elements() > 0)
            {
                ledgerVoucherTransObject.parmTaxParentReferenceTableId(_custVendTrans.TableId);
                ledgerVoucherTransObject.parmTaxParentReferenceRecId(_custVendTrans.RecId);
                ledgerVoucherTransObject.setTaxTransRelationshipType(TaxTransRelationshipType::CashDiscount);
            }
            else if (distribution.parmTaxTransRecId())
            {
                ledgerVoucherTransObject.addTaxTransRelationship(
                    distribution.parmTaxTransRecId(),
                    TaxTransRelationshipType::CashDiscount,
                    curExt(),
                    -distribution.accountingAmount(),
                    -distribution.transactionAmount());
            }

            if (postCashDiscountInSummary)
            {
                ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::Summary);
            }

            ledgerVoucherTransObject.parmSkipDimensionValidation(_skipDimensionValidation);

            _ledgerVoucher.addTrans(ledgerVoucherTransObject);

            if (CustVendTransPostingLog_RU::usePostingLog())
            {
                custVendTransPostingLog = this.createPostingTransLog_RU(CustVendTransPostingLogType_RU::CashDisc,
                                                                        _custVendTrans,
                                                                        this.getLedgerPostingType_CashDisc(),
                                                                        distribution.ledgerDimension(),
                                                                        _custVendTrans.summaryLedgerDimension(postingProfile),
                                                                        _ledgerVoucher.lastAmountMST(),
                                                                        _ledgerVoucher.findLedgerVoucherObject().lastAmountMSTSecondary_RU(),
                                                                        null,
                                                                        LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(distribution.ledgerDimension()),
                                                                        _ledgerVoucher.lastAmountCur(),
                                                                        settlementPair.getCustVendTransDebit().PostingProfile == postingProfile ? settlementPair.getCustVendTransDebit() : settlementPair.getCustVendTransCredit(),
                                                                        settlementPair.getCustVendTransDebit().PostingProfile == postingProfile ? settlementPair.getCustVendTransCredit() : settlementPair.getCustVendTransDebit());

                if (custVendTransPostingLog)
                {
                    custVendTransPostingLog.Voucher   = _ledgerVoucher.lastVoucher();
                    custVendTransPostingLog.TransDate = _ledgerVoucher.lastTransDate();

                    GeneralJournalEntry generalJournalEntry;
                    GeneralJournalAccountEntry generalJournalAccountEntry;
                    SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;

                    select count(RecId) from generalJournalAccountEntry
                        group by LedgerDimension
                        where generalJournalAccountEntry.PostingType == this.getLedgerPostingType_Balance()
                    exists join subledgerVoucherGeneralJournalEntry
                        where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalAccountEntry.GeneralJournalEntry
                            && subledgerVoucherGeneralJournalEntry.AccountingDate == _custVendTrans.TransDate
                            && subledgerVoucherGeneralJournalEntry.Voucher == _custVendTrans.Voucher
                            && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == _custVendTrans.dataAreaId
                    exists join generalJournalEntry
                        where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                            && generalJournalEntry.PostingLayer == CurrentOperationsTax::Current;

                    if (generalJournalAccountEntry.LedgerDimension)
                    {
                        custVendTransPostingLog.OffsetLedgerDimension = generalJournalAccountEntry.LedgerDimension;
                        
                        next generalJournalAccountEntry;
                        if (generalJournalAccountEntry)
                        {
                            custVendTransPostingLog.OffsetLedgerDimension = 0;
                        }
                    }

                    if (!custVendTransPostingLog.OffsetLedgerDimension)
                    {
                        custVendTransPostingLog.OffsetLedgerDimension =
                            LedgerDimensionFacade::serviceCreateLedgerDimension(_custVendTrans.summaryLedgerDimension(postingProfile), settlementPair.getCustVendTransCredit().DefaultDimension);
                    }
                    custVendTransPostingLog.update();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcRecoveryLOIMSTByInvVoucher_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Calculates the amount of interim recoverable Load On Inventory tax by Invoiced tax trans.
    /// </summary>
    /// <param name="_InvTaxTrans">
    /// The invoice tax trans.
    /// </param>
    /// <returns>
    /// The sum up amount of interim recoverable Load On Inventory tax.
    /// </returns>
    public TaxAmount calcRecoveryLOIMSTByInvVoucher_IN(
        TaxTrans                    _InvTaxTrans)
    {
        VendSettlement         vendSettlement;
        VendTrans              vendTransPayment;
        VendTrans              vendTransInvoice;
        VendInvoiceJour        vendInvoiceJour;
        VendInvoiceTrans       vendInvoiceTrans;
        TaxTrans               taxTransRev;
        TaxTrans_IN            taxTransRevIN;
        TaxTable               taxTable;
        TaxLedgerAccounts_IN   taxLedgerAccountsRev;
        Percent                settlePercent;
        boolean                isRecoverableCheckBoxUnmarked;
        TaxAmount              taxAmountLOI = 0;

        while select SettleAmountMST from vendSettlement
        join AmountMST from vendTransInvoice
            where vendTransInvoice.RecId            == vendSettlement.OffsetRecid
                && vendTransInvoice.Voucher         == _InvTaxTrans.Voucher
                && vendTransInvoice.TransDate       == _InvTaxTrans.TransDate
        join RecId,PurchId,InvoiceId,InvoiceDate,NumberSequenceGroup,InternalInvoiceId from vendInvoiceJour
            where vendInvoiceJour.LedgerVoucher     == vendSettlement.OffsetTransVoucher &&
                vendInvoiceJour.InvoiceDate         == vendTransInvoice.TransDate &&
                vendInvoiceJour.InvoiceAccount      == vendSettlement.AccountNum
        exists join vendTransPayment
            where vendTransPayment.RecId                == vendSettlement.TransRecId
                && vendTransPayment.LastSettleVoucher   == vendTransInvoice.Voucher
        {
            // Legacy issue: currently the checkbox of 'Recoverable/Expense on tax settlement'doesn't work.
            isRecoverableCheckBoxUnmarked = TaxItemGroupHeading::isRecoverableExpChkBoxUnMarked_IN(tableNum(PurchTable),
                                                   VendInvoiceJour::findRecId(vendInvoiceJour.RecId).purchTable().RecId);
            if (isRecoverableCheckBoxUnmarked)
            {
                continue;
            }

            if (vendTransInvoice.AmountMST)
            {
                settlePercent = abs(vendSettlement.SettleAmountMST * 100 / vendTransInvoice.AmountMST);
            }
            else
            {
                settlePercent = 0;
            }

            select sum(TaxInCostPriceRegulated) from taxTransRev
                where taxTransRev.TaxCode                     == _InvTaxTrans.TaxCode
                    && taxTransRev.SourceTableId              == tableNum(VendInvoiceTrans)
            exists join vendInvoiceTrans
                where vendInvoiceTrans.PurchID                == vendInvoiceJour.PurchId
                    && vendInvoiceTrans.RecId                 == taxTransRev.SourceRecId
                    && vendInvoiceTrans.InvoiceId             == vendInvoiceJour.InvoiceId
                    && vendInvoiceTrans.InvoiceDate           == vendInvoiceJour.InvoiceDate
                    && vendInvoiceTrans.NumberSequenceGroup   == vendInvoiceJour.NumberSequenceGroup
                    && vendInvoiceTrans.InternalInvoiceId     == vendInvoiceJour.InternalInvoiceId
            exists join taxTransRevIN
                where taxTransRevIN.RefRecId                 == taxTransRev.RecId
                    && taxTransRevIN.TaxType                 == TaxType_IN::ServiceTax
            exists join taxTable
                where taxTable.TaxCode                        == taxTransRev.TaxCode
            exists join taxLedgerAccountsRev
                where taxLedgerAccountsRev.LedgerDimension    == taxTransRevIN.RecoverableLedgerDimension
                    && taxLedgerAccountsRev.AccountType       == TaxAccountType_IN::ServiceTaxInterimRecoverableAccount
                    && taxLedgerAccountsRev.TaxComponentTable == taxTable.TaxComponentTable_IN;
            if (taxTransRev.TaxInCostPriceRegulated)
            {
                taxAmountLOI += CurrencyExchangeHelper::amount(settlePercent / 100 * taxTransRev.TaxInCostPriceRegulated);
            }
        }
        return taxAmountLOI;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReverseChargeExpenseAmtByInv_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets service tax expense amount by tax trans, which are generated during invoice time.
    /// </summary>
    /// <param name="_taxTransInv">
    /// Tax trans generated during invoice time.
    /// </param>
    /// <returns>
    /// Tax amount.
    /// </returns>
    /// <remarks>
    /// This method is similar to getReverseChargeExpenseAmt_IN(), and the only difference is that getReverseChargeExpenseAmtByInv_IN() bases on tax trans generated during Invoice time.
    /// </remarks>
    private TaxAmountCur getReverseChargeExpenseAmtByInv_IN(TaxTrans _taxTransInv)
    {
        TaxTrans                taxTransRec;
        TaxTrans_IN             taxTransIN;
        TaxLedgerAccounts_IN    taxLedgerAccount;
        VendTrans               vendTransInv;
        TaxAmountCur            expenseAmtCur;

        // Find the Expense Amount during the Invoice.
        while select firstonly SourceRegulateAmountCur, TaxCode, Voucher from taxTransRec
            where taxTransRec.SourceRegulateAmountCur > 0
                && taxTransRec.RecId == _taxTransInv.RecId
        join LedgerDimension,TaxComponentTable from taxTransIN
            where taxTransIN.RefRecId            == taxTransRec.RecId
                && taxTransIN.gtaServiceCategory == GTAServiceCategory_IN::Others
        exists join vendTransInv
            where vendTransInv.Voucher              == _taxTransInv.Voucher
                && vendTransInv.LastSettleVoucher   != ''
                && vendTransInv.Voucher             == taxTransRec.Voucher
                && taxTransRec.TaxCode              == _taxTransInv.TaxCode
        {
            select firstonly RecId from taxLedgerAccount
                where taxLedgerAccount.LedgerDimension       == LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(taxTransIN.LedgerDimension)
                    && taxLedgerAccount.AccountType           == TaxAccountType_IN::ServiceTaxExpenseAccount
                    && taxLedgerAccount.TaxComponentTable     == taxTransIN.TaxComponentTable;
            if (taxLedgerAccount.RecId && !invoiceVoucherMap.exists(taxTransRec.TaxCode + taxTransRec.Voucher))
            {
                expenseAmtCur += taxTransRec.SourceRegulateAmountCur;
                invoiceVoucherMap.insert(taxTransRec.TaxCode + taxTransRec.Voucher, expenseAmtCur);
            }
            if (expenseAmtCur && !expenseAmtMap.exists(taxTransRec.TaxCode + _taxTransInv.Voucher))
            {
                expenseAmtMap.insert(taxTransRec.TaxCode + _taxTransInv.Voucher, expenseAmtCur); //Insert to the Map to identify, the ExpenseAccount for the taxCode has been deducted.
            }
        }
        return expenseAmtCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReverseChargeRecoverableAmtByInv_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the service tax recoverable amount by tax trans, which are generated during invoice time.
    /// </summary>
    /// <param name="_taxTransInv">
    /// The tax trans generated during invoice time.
    /// </param>
    /// <returns>
    /// Tax amount.
    /// </returns>
    private TaxAmountCur getReverseChargeRecoverableAmtByInv_IN(TaxTrans _taxTransInv)
    {
        TaxTrans                taxTransRec;
        VendTrans               vendTransInv;
        TaxAmountCur            taxAmountCur;
        LedgerTransVoucherLink  ledgerTransVoucherLinkInv;
        LedgerTransVoucherLink  ledgerTransVoucherLinkRelInv;

        // Find the recoverable Amount reversed during the Invoice.
        while select SourceRegulateAmountCur,TaxCode, Voucher from taxTransRec
            where taxTransRec.SourceRegulateAmountCur > 0
        exists join vendTransInv
            where vendTransInv.LastSettleVoucher != ''
                && vendTransInv.Voucher          == _taxTransInv.Voucher
        exists join ledgerTransVoucherLinkInv
            where ledgerTransVoucherLinkInv.Voucher == vendTransInv.Voucher
        exists join ledgerTransVoucherLinkRelInv
            where ledgerTransVoucherLinkRelInv.VoucherGroupId == ledgerTransVoucherLinkInv.VoucherGroupId
                && ledgerTransVoucherLinkRelInv.RecId         != ledgerTransVoucherLinkInv.RecId
                && taxTransRec.Voucher                        == ledgerTransVoucherLinkRelInv.Voucher
                && taxTransRec.TransDate                      == ledgerTransVoucherLinkRelInv.TransDate
                && taxTransRec.TaxCode                        == _taxTransInv.TaxCode
        {
            // If the same invoice is settled using multiple payments
            if (!invoiceVoucherMap.exists(taxTransRec.TaxCode + taxTransRec.Voucher))
            {
                taxAmountCur += taxTransRec.SourceRegulateAmountCur;
                invoiceVoucherMap.insert(taxTransRec.TaxCode + taxTransRec.Voucher, taxAmountCur);
            }
            // The Map key is [TaxCode + Voucher]. Because same TaxCode can come for multiple partially settled payments. Adding Voucher
            // uniquly distingushes them and extract the already settled amount.
            if (taxAmountCur && !recoverableAmtMap.exists(taxTransRec.TaxCode + _taxTransInv.Voucher))
            {
                recoverableAmtMap.insert(taxTransRec.TaxCode + _taxTransInv.Voucher, taxAmountCur);
            }
        }

        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReversePostingLogSet_RU</Name>
				<Source><![CDATA[
    public Set parmReversePostingLogSet_RU(Set _reversePostingLogSet = reversePostingLogSet)
    {
        reversePostingLogSet = _reversePostingLogSet;
        return reversePostingLogSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipReversePrePaymentTax_W</Name>
				<Source><![CDATA[
    public boolean parmSkipReversePrePaymentTax_W(boolean _skipReversePrePaymentTax = skipReversePrePaymentTax)
    {
        skipReversePrePaymentTax = _skipReversePrePaymentTax;
        return skipReversePrePaymentTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetTaxTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Convert taxtrans. Previous reverse charge logic assume that service tax interim payable tax trans(IP) will exists all the time.
    /// But when user mark the checkbox 'is Accrue payable at Invoicing' on tax item group level, then the tax amount will directly credit to service tax payable account.
    /// So, there will no IP-P tax trans be generated during payment. To allign with current behavior, we will use P trans (invoice time) when the checkbox 'is Accrue payable at Invoicing' is marked.
    /// This method is created to do this convertion.
    /// </summary>
    /// <param name="_taxTrans">
    /// Tax trans.
    /// </param>
    /// <returns>
    /// Tax trans.
    /// </returns>
    private TaxTrans resetTaxTrans_IN(TaxTrans _taxTrans)
    {
        real signOfAccruePayable = -1;

        if (TaxItemGroupHeading::isAccruePayableAtInvoicing_IN(_taxTrans.TaxItemGroup))
        {
            _taxTrans.SourceBaseAmountCur           = _taxTrans.SourceBaseAmountCur * signOfAccruePayable;
            _taxTrans.SourceBaseAmountCurRegulated  = _taxTrans.SourceBaseAmountCurRegulated * signOfAccruePayable;
            _taxTrans.SourceRegulateAmountCur       = _taxTrans.SourceRegulateAmountCur * signOfAccruePayable;
            _taxTrans.SourceTaxAmountCur            = _taxTrans.SourceTaxAmountCur * signOfAccruePayable;
            _taxTrans.TaxAmount                     = _taxTrans.TaxAmount * signOfAccruePayable;
            _taxTrans.TaxAmountCur                  = _taxTrans.TaxAmountCur * signOfAccruePayable;
            _taxTrans.TaxBaseAmount                 = _taxTrans.TaxBaseAmount * signOfAccruePayable;
            _taxTrans.TaxBaseAmountCur              = _taxTrans.TaxBaseAmountCur * signOfAccruePayable;
            _taxTrans.TaxInCostPrice                = _taxTrans.TaxInCostPrice * signOfAccruePayable;
            _taxTrans.TaxInCostPriceCur             = _taxTrans.TaxInCostPriceCur * signOfAccruePayable;
            _taxTrans.TaxInCostPriceMST             = _taxTrans.TaxInCostPriceMST * signOfAccruePayable;
            _taxTrans.TaxInCostPriceRegulated       = _taxTrans.TaxInCostPriceRegulated * signOfAccruePayable;
        }

        return _taxTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAmountsToReverseForLastSettlement_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the tax amount and tax base amount to be reversed for other settled transactions in the same settled group.
    /// </summary>
    /// <param name="_custVendSettlementLatest">
    /// Latest settlement record.
    /// </param>
    /// <param name="_custVendTransDebit">
    /// Invoice transactions  (CustTrans / VendTrans) - Invoices.
    /// </param>
    /// <param name="_voucher">
    /// Voucher number to fetch the tax transaction record.
    /// </param>
    /// <param name="_transDate">
    /// Trans date to fetch the tax transaction record.
    /// </param>
    /// <returns>
    /// A container with tax amount and tax base amount to be reversed.
    /// </returns>
    protected container getAmountsToReverseForLastSettlement_TH(CustVendSettlement _custVendSettlementLatest,  CustVendTrans _custVendTransDebit, Voucher _voucher, TransDate _transDate)
    {
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLatestSettlement_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the given settlement is the last settlement.
    /// </summary>
    /// <param name="_vendSettlement">
    /// Current settlement record.
    /// </param>
    /// <returns>
    /// true if the current record is the lastest settlement; otherwise, false.
    /// </returns>
    protected boolean isLatestSettlement_TH(VendSettlement _vendSettlement)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Process tax for GTE on the settlement transactions.
    /// </summary>
    /// <param name="_origSettleFactorDebit">
    ///    The percent of the debit transaction that is settled excluding the current settlement.
    /// </param>
    /// <param name="_origSettleFactorCredit">
    ///    The percent of the credit transaction that is settled excluding the current settlement.
    /// </param>
    protected void processTax(Percent _origSettleFactorDebit, Percent _origSettleFactorCredit)
    {
        Common                              invoiceTaxDocumentTransaction;
        Common                              paymentTaxDocumentTransaction;
        ITaxDocument                        invoiceTaxDocument;
        ITaxDocument                        paymentTaxDocument;
        TaxDocument                         invoiceTaxDocumentTable;
        TaxDocument                         paymentTaxDocumentTable;
        Percent                             invoiceCurrentSettleFactor;
        Percent                             paymentCurrentSettleFactor;
        TaxEngineTaxSettlement              taxEngineTaxSettlement;
        LedgerDimensionDefaultAccount       partyDefaultAccount;

        invoiceCurrentSettleFactor = settlementPair.getCustVendTransDebit().AmountCur ? settlementPair.getCustVendTransDebit().SettleAmountCur / settlementPair.getCustVendTransDebit().AmountCur : 0;
        paymentCurrentSettleFactor = settlementPair.getCustVendTransCredit().AmountCur ? settlementPair.getCustVendTransCredit().SettleAmountCur / settlementPair.getCustVendTransCredit().AmountCur : 0;
 
        if (invoiceCurrentSettleFactor || paymentCurrentSettleFactor)
        {
            invoiceTaxDocumentTransaction = TaxDocumentGeneralJournalEntryLink::findByVoucherAndAccountingDate(settlementPair.getCustVendTransDebit().Voucher, settlementPair.getCustVendTransDebit().TransDate);
            paymentTaxDocumentTransaction = TaxDocumentGeneralJournalEntryLink::findByVoucherAndAccountingDate(settlementPair.getCustVendTransCredit().Voucher, settlementPair.getCustVendTransCredit().TransDate);
            
            if (invoiceTaxDocumentTransaction)
            {
                invoiceTaxDocument = TaxBusinessService::getTaxDocumentBySource(invoiceTaxDocumentTransaction.TableId, invoiceTaxDocumentTransaction.RecId);
                if (invoiceTaxDocument)
                {
                    invoiceTaxDocumentTable = TaxDocument::findByGUID(invoiceTaxDocument.getGUID());
                }
            }

            if (paymentTaxDocumentTransaction)
            {
                paymentTaxDocument = TaxBusinessService::getTaxDocumentBySource(paymentTaxDocumentTransaction.TableId, paymentTaxDocumentTransaction.RecId);
                if (paymentTaxDocument)
                {
                    paymentTaxDocumentTable = TaxDocument::findByGUID(paymentTaxDocument.getGUID());
                }
            }
            
            if (invoiceTaxDocument || paymentTaxDocument)
            {
                System.Diagnostics.Stopwatch sw = System.Diagnostics.Stopwatch::StartNew();

                if (this is CustVendSettle_Vend)
                {
                    partyDefaultAccount = LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(settlementPair.getCustVendTransDebit().AccountNum, LedgerJournalACType::Vend);
                }
                else if (this is CustVendSettle_Cust)
                {
                    partyDefaultAccount = LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(settlementPair.getCustVendTransDebit().AccountNum, LedgerJournalACType::Cust);
                }
                
                taxEngineTaxSettlement = TaxEngineTaxSettlement::construct(
                    settlementPair.getCustVendTransDebit().RecId,
                    settlementPair.getCustVendTransCredit().RecId,
                    _origSettleFactorDebit,
                    _origSettleFactorCredit,
                    invoiceCurrentSettleFactor,
                    paymentCurrentSettleFactor,
                    settlementPair.getCustVendTransDebit().TransDate,
                    settlementPair.getCustVendTransCredit().TransDate,
                    partyDefaultAccount,
                    settlementPair.getTransactionDate(),
                    TaxEngineTaxJournalUtil::getTaxJournalType(this));
                
                taxEngineTaxSettlement.parmInvoiceTaxDocument(invoiceTaxDocument);
                taxEngineTaxSettlement.parmPaymentTaxDocument(paymentTaxDocument);
                taxEngineTaxSettlement.parmInvoiceDefaultDimension(settlementPair.getCustVendTransDebit().DefaultDimension);
                taxEngineTaxSettlement.parmPaymentDefaultDimension(settlementPair.getCustVendTransCredit().DefaultDimension);
                taxEngineTaxSettlement.calcAndPost(relatedLedgerVoucher, settlementPair.getCustVendTransDebit().Voucher, settlementPair.getCustVendTransCredit().Voucher);

                sw.Stop();
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceIN00143, funcName(), GlobalizationInstrumentationHelper::DefaultFeatureVersion, SysCountryRegionCode::countryInfo(), sw.ElapsedMilliseconds);
            }
        }

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled() && taxEngineTaxSettlement)
        {
            taxDocumentLedgerVoucherMap = taxEngineTaxSettlement.getTaxDocumentMapForSettlement();
        }
        // </GTE>
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxDocumentLedgerVoucherMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax document ledger voucher map.
    /// </summary>
    /// <returns>Tax document ledger voucher map.</returns>
    public Map getTaxDocumentLedgerVoucherMap()
    {
        return taxDocumentLedgerVoucherMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processInterimTaxWithhold</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes withholding tax to generate related voucher for settlement/undo-settlement.
    ///
    /// Note: This method is obsolete. Use CustVendSettle::processInterimTaxWithholdWithReceiptDate() instead.
    /// </summary>
    /// <param name = "_custTrans">Record for customer trans.</param>
    /// <param name = "_settledAmountMST">Settled accounting amount.</param>
    /// <param name = "_isSettlement">true, if it is invoice/payment settlement process; false, if it is invoice/payment unsettlement process</param>
    [SysObsolete('This method is obsolete. Use CustVendSettle::processInterimTaxWithholdWithReceiptDate() instead.', false, 28\9\2020)]
    public static void processInterimTaxWithhold(
        CustTrans _custTrans,
        AmountMST _settledAmountMST,
        boolean _isSettlement)
    {
        // This function is obsolete.
    }

]]></Source>
			</Method>
			<Method>
				<Name>processInterimTaxWithholdWithReceiptDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes withholding tax to generate related voucher for settlement/undo-settlement.
    /// </summary>
    /// <param name = "_custTrans">Record for customer trans.</param>
    /// <param name = "_settledAmountMST">Settled accounting amount.</param>
    /// <param name = "_isSettlement">true, if it is invoice/payment settlement process; false, if it is invoice/payment unsettlement process</param>
    /// <param name = "_receiptDate">Related voucher date</param>
    public static void processInterimTaxWithholdWithReceiptDate(
        CustTrans _custTrans,
        AmountMST _settledAmountMST,
        boolean _isSettlement,
        date _receiptDate)
    {
        // Call it for old extension
        CustVendSettle::processInterimTaxWithhold(_custTrans, _settledAmountMST, _isSettlement);

        TaxWithholdTrans_IN taxWithholdTrans;
        TaxWithholdGroupHeading taxWithholdGroupHeading;

        select firstonly RecId from taxWithholdGroupHeading
            where taxWithholdGroupHeading.TaxLiabilityOnPayment_IN == NoYes::Yes
            join RecId from taxWithholdTrans
                where taxWithholdGroupHeading.TaxWithholdGroup == taxWithholdTrans.TaxWithholdGroup
                    && taxWithholdTrans.Voucher == _custTrans.Voucher
                    && taxWithholdTrans.TransDate == _custTrans.TransDate;
        if (!taxWithholdGroupHeading.RecId)
        {
            return;
        }

        NumberSequenceReference numberSequenceReference = CustParameters::numRefTaxWithholdRelatedVoucher_IN();
        NumberSequenceTable numberSequenceTable = numberSequenceReference.numberSequenceTable();
        if (!numberSequenceTable)
        {
            throw error(strFmt("@SYS53911", numberSequenceReference.referenceLabel(), numberSequenceReference.referenceModuleLabel()));
        }
        LedgerVoucher ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail, SysModule::Cust, numberSequenceTable.NumberSequence);
        LedgerPostingController ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher);
        Voucher voucher = NumberSeq::newGetVoucherFromId(numberSequenceTable.RecId, false).voucher();
        LedgerVoucherObject ledgerPostingReference = LedgerVoucherObject::newReference(voucher, _receiptDate);
        ledgerPostingController.addReference(ledgerPostingReference);
        LedgerVoucherTransObject ledgerVoucherTransObject;
        CurrencyExchangeHelper currencyExchangeHelper;
        
        TaxWithholdTrans_IN reverseTaxWithholdTrans;
        TaxWithholdTable taxWithholdTable;

        Factor settledFactor = _isSettlement ? _settledAmountMST / _custTrans.AmountMST * -1 : _settledAmountMST / _custTrans.AmountMST * 1;

        while select taxWithholdTrans
            where taxWithholdTrans.Voucher == _custTrans.Voucher
                && taxWithholdTrans.TransDate == _custTrans.TransDate
                && taxWithholdTrans.IsTaxInterim == NoYes::Yes
                && taxWithholdTrans.Settled == NoYes::No
            join LedgerDimension, TaxWithholdRoundOffType, TaxWithholdRoundOff from taxWithholdTable
                where taxWithholdTable.TaxWithholdCode == taxWithholdTrans.TaxWithholdCode
            join TaxLiabilityOnPayment_IN from taxWithholdGroupHeading
                where taxWithholdGroupHeading.TaxWithholdGroup == taxWithholdTrans.TaxWithholdGroup
                    && taxWithholdGroupHeading.TaxLiabilityOnPayment_IN == NoYes::Yes
        {
            currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), taxWithholdTrans.TransDate);

            reverseTaxWithholdTrans = CustVendSettle::initSettlementTaxWithholdTrans(
                taxWithholdTrans,
                settledFactor,
                voucher,
                _custTrans.isPayment(),
                true,
                _receiptDate);

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAccountingAmountsDefault(
                ledgerPostingController.getReference(),
                LedgerPostingType::TCS_IN,
                LedgerDimensionFacade::serviceCreateLedgerDimension(taxWithholdTrans.LedgerDimension, _custTrans.DefaultDimension),
                taxWithholdTrans.CurrencyCode,
                reverseTaxWithholdTrans.TaxWithholdAmountCur,
                reverseTaxWithholdTrans.TaxWithholdAmount,
                currencyExchangeHelper);

            ledgerPostingController.addTrans(ledgerVoucherTransObject);

            // Create ledger voucher trans for TCS payable
            reverseTaxWithholdTrans = CustVendSettle::initSettlementTaxWithholdTrans(
                taxWithholdTrans,
                settledFactor * -1,
                voucher,
                _custTrans.isPayment(),
                false,
                _receiptDate);

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAccountingAmountsDefault(
                ledgerPostingController.getReference(),
                LedgerPostingType::TCS_IN,
                LedgerDimensionFacade::serviceCreateLedgerDimension(taxWithholdTable.LedgerDimension, _custTrans.DefaultDimension),
                taxWithholdTrans.CurrencyCode,
                reverseTaxWithholdTrans.TaxWithholdAmountCur,
                reverseTaxWithholdTrans.TaxWithholdAmount,
                currencyExchangeHelper);

            ledgerPostingController.addTrans(ledgerVoucherTransObject);
        }

        ledgerVoucher.createVoucherLinks(_custTrans.Voucher, _custTrans.TransDate);
        ledgerVoucher.end();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSettlementTaxWithholdTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes settlement of TaxWithholdTran_IN
    /// </summary>
    /// <param name = "_origTaxWithholdTrans">Original tax withhold trans</param>
    /// <param name = "_factor">Factor for settlement amount fields</param>
    /// <param name = "_reversalVoucher">Reversal voucher</param>
    /// <param name = "_isPayment">turn if original trans is payment; otherwise, false</param>
    /// <param name = "_isTaxInterim">trun if original tax trans is for interim account; otherwise, false</param>
    /// <param name = "_receiptDate">Receipt date for the withholding transactions</param>
    /// <returns>Reversed record for tax withhold trans</returns>
    [Hookable(false)]
    public static TaxWithholdTrans_IN initSettlementTaxWithholdTrans(
        TaxWithholdTrans_IN _origTaxWithholdTrans,
        Factor _factor,
        Voucher _reversalVoucher,
        boolean _isPayment,
        boolean _isTaxInterim,
        date _receiptDate)
    {
        TaxWithholdTable taxWithholdTable = TaxWithholdTable::find(_origTaxWithholdTrans.TaxWithholdCode);
        
        ttsbegin;
        TaxWithholdTrans_IN reverseTaxWithholdTrans;
        reverseTaxWithholdTrans.clear();
        reverseTaxWithholdTrans.data(_origTaxWithholdTrans);
        reverseTaxWithholdTrans.AmountOriginMST = CurrencyExchange::roundWithRuleType(_origTaxWithholdTrans.AmountOriginMST * _factor, _origTaxWithholdTrans.TaxWithholdCurrency, CurrencyRoundingRuleType::Amount);
        reverseTaxWithholdTrans.TaxWithholdBaseAmountCur = CurrencyExchange::roundWithRuleType(_origTaxWithholdTrans.TaxWithholdBaseAmountCur * _factor, _origTaxWithholdTrans.CurrencyCode, CurrencyRoundingRuleType::Amount);
        reverseTaxWithholdTrans.TaxWithholdAmountCur = CurrencyExchange::roundWithRuleType(_origTaxWithholdTrans.TaxWithholdAmountCur * _factor, _origTaxWithholdTrans.CurrencyCode, CurrencyRoundingRuleType::Amount);
        reverseTaxWithholdTrans.WithholdBaseAmount = CurrencyExchange::roundWithRuleType(_origTaxWithholdTrans.WithholdBaseAmount * _factor, _origTaxWithholdTrans.TaxWithholdCurrency, CurrencyRoundingRuleType::Amount);
        reverseTaxWithholdTrans.TaxWithholdAmount = CurrencyExchange::roundWithRuleType(_origTaxWithholdTrans.TaxWithholdAmount * _factor, _origTaxWithholdTrans.TaxWithholdCurrency, CurrencyRoundingRuleType::Amount);
        reverseTaxWithholdTrans.TaxWithholdAmountOrigin = CurrencyExchange::roundWithRuleType(_origTaxWithholdTrans.TaxWithholdAmountOrigin * _factor, _origTaxWithholdTrans.TaxWithholdCurrency, CurrencyRoundingRuleType::Amount);
        reverseTaxWithholdTrans.TaxTaxWithholdAmount = CurrencyExchange::roundWithRuleType(_origTaxWithholdTrans.TaxTaxWithholdAmount * _factor, _origTaxWithholdTrans.TaxWithholdCurrency, CurrencyRoundingRuleType::Amount);
        reverseTaxWithholdTrans.AdjustedBaseAmount = CurrencyExchange::roundWithRuleType(_origTaxWithholdTrans.AdjustedBaseAmount * _factor, _origTaxWithholdTrans.CurrencyCode, CurrencyRoundingRuleType::Amount);
        reverseTaxWithholdTrans.AdjustedTaxWithholdAmount = CurrencyExchange::roundWithRuleType(_origTaxWithholdTrans.AdjustedTaxWithholdAmount * _factor, _origTaxWithholdTrans.CurrencyCode, CurrencyRoundingRuleType::Amount);
        if (!_isTaxInterim)
        {
            reverseTaxWithholdTrans.LedgerDimension = taxWithholdTable.LedgerDimension;
        }
        if (_isPayment && !_isTaxInterim)
        {
            reverseTaxWithholdTrans.IsPartOfTurnOver = NoYes::Yes;
        }
        reverseTaxWithholdTrans.IsTaxInterim = _isTaxInterim;
        reverseTaxWithholdTrans.Voucher = _reversalVoucher;
        reverseTaxWithholdTrans.SourceTransVoucher = _origTaxWithholdTrans.Voucher;
        reverseTaxWithholdTrans.SourceTransDate = _origTaxWithholdTrans.TransDate;
        reverseTaxWithholdTrans.TransDate = _receiptDate;

        reverseTaxWithholdTrans.insert();
        ttscommit;

        return reverseTaxWithholdTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxWithholdTransSpectransId</Name>
				<Source><![CDATA[
    private void updateTaxWithholdTransSpectransId()
    {
        TaxWithholdTrans taxWithholdTrans;
        Enumerator RecIdEnumerator = taxWithholdTransRecIds.getEnumerator();

        while (RecIdEnumerator.moveNext())
        {
            select forUpdate taxWithholdTrans
                    where taxWithholdTrans.RecId == RecIdEnumerator.current();
            taxWithholdTrans.SpecTransId = 0;
            taxWithholdTrans.Update();
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>getRetentionAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fetches the vendor retention amount during vendor settlement process when conditional tax is enabled.
    /// </summary>
    /// <returns>vendor retention amount.
    /// </returns>
    private AmountCur getRetentionAmount(CustVendTrans _custVendTrans)
    {
        AmountCur retentionAmount;

        // When conditional tax is enabled and vendor tax options are set to <c>NotSplittingTaxByRetainedAmount</c>, find and return vendor retention amount.
        if (_custVendTrans.AmountCur
            && _custVendTrans.AmountCur != _custVendTrans.SettleAmountCur
            && _custVendTrans.TransType == LedgerTransType::Purch
            && _custVendTrans.InvoiceProject == NoYes::Yes
            && TaxParameters::find().ConditionalTax == NoYes::Yes
            && ProjParameters::find().VendorTaxOptions == ProjDefaultTaxOptions::NotSplittingTaxByRetainedAmount)
        {
            VendInvoiceTrans vendInvoiceTrans;
            select sum(PSARetainageAmount) from vendInvoiceTrans
                where vendInvoiceTrans.InvoiceId == _custVendTrans.Invoice
                   && vendInvoiceTrans.PSARetainageAmount != 0;
            if (vendInvoiceTrans.PSARetainageAmount)
            {
                retentionAmount = vendInvoiceTrans.PSARetainageAmount;
            }
        }
        return retentionAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findInvoiceForCustVendProj</Name>
				<Source><![CDATA[
    private CustVendInvoiceJour findInvoiceForCustVendProj(
        CustVendAC _custVendAC,
        InvoiceId  _invoiceId,
        Voucher    _voucher,
        TransDate  _transDate)
    {
        CustVendInvoiceJour custVendInvoiceJour = this.findInvoice(
            _custVendAC,
            _invoiceId,
            _voucher,
            _transDate);

        if (!custVendInvoiceJour
            && Tax::isTaxIntegrationEnabledForBusinessProcess(TaxIntegrationBusinessProcess::Project))
        {
            custVendInvoiceJour = ProjInvoiceJour::find(_invoiceId, _transDate);
        }
        return custVendInvoiceJour;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>