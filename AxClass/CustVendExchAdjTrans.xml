<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendExchAdjTrans</Name>
	<SourceCode>
		<Declaration><![CDATA[
abstract class CustVendExchAdjTrans
{
    CustVendExchAdj exchangeAdjustmentController;

    CustVendTable custVendTable;
    CustVendTrans custVendTrans;
    CustVendTransOpen custVendTransOpen;
    CustVendSettlement custVendSettlement;

    CustExchAdjustmentUnrealized custExchAdjustmentUnrealized;

    Counter progressCounter;
    RunbaseProgress progress;

    Map lastExchangeAdjustmentHistory;

    LedgerVoucher ledgerVoucher;

    #ISOCountryRegionCodes

    TransDate periodStart;
    Set failedTransSet;

    Counter settlementGroupPlaceHolder;
    CustVendTransSettlement custVendTransSettlement;
    CustVendTransSettlement custVendSettlementCurDeal;
    TransDate previousUnrealizedDate;

    private CustVendExchAdjPostingEngine custVendExchAdjPostingEngine;

    private System.Diagnostics.Stopwatch stopWatch = new System.Diagnostics.Stopwatch();

    private int ledgerVoucherGenerateElapsedMilliseconds;
    private int ledgerPostingElapsedMilliseconds;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addNewLedgerVoucherObject</Name>
				<Source><![CDATA[
    private void addNewLedgerVoucherObject(CustVendTrans _custVendTrans)
    {
        NumberSeq numberSeq;
        Voucher voucher;
        TransactionTxt transactionTextVoucher;

        numberSeq = numberSeq::newGetVoucher(this.getNumberSequence());
        voucher = numberSeq.voucher();

        transactionTextVoucher = TransactionTxt::construct();
        transactionTextVoucher.setType(this.getLedgerTransactionText());
        transactionTextVoucher.setVoucher(voucher);
        transactionTextVoucher.setFormLetter(_custVendTrans.Invoice);
        transactionTextVoucher.setKey1(_custVendTrans.AccountNum);

        ledgerVoucher.addVoucher(
            LedgerVoucherObject::newVoucher(
                voucher,
                exchangeAdjustmentController.postingDate(),
                exchangeAdjustmentController.module(),
                LedgerTransType::ExchAdjustment));

        ledgerVoucher.findLedgerVoucherObject().lastTransTxt(transactionTextVoucher.txt(exchangeAdjustmentController.transExchAdjTxt()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentTransactionCurrencyExchangeRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current transaction currency exchange rate.
    /// </summary>
    /// <param name = "_ledger">The ledger context that is used for retrieving exchange rate information.</param>
    /// <param name = "_fromCurrency">The currency that is used for retrieving exchange rate information.</param>
    /// <param name = "_exchangeDate">The exchange rate date that is used for retrieving exchange rate information.</param>
    /// <returns>The current transaction currency exchange rate.</returns>
    protected CurrencyExchangeRate getCurrentTransactionCurrencyExchangeRate(LedgerRecId _ledger, CurrencyCode _fromCurrency, TransDate _exchangeDate)
    {
        return ExchangeRateHelper::getCrossRate_Static(_ledger, _fromCurrency, _exchangeDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExchRateFromExchRateType</Name>
				<Source><![CDATA[
    private CurrencyExchangeRate getExchRateFromExchRateType(LedgerRecId _ledger, CurrencyCode _fromCurrency, CurrencyCode _toCurrency, TransDate _exchangeDate, RefRecId _exchRateTypeRecId)
    {
        ExchangeRateHelper helper = ExchangeRateHelper::newExchangeDate(_ledger, _fromCurrency, _exchangeDate);
        helper.parmToCurrency(_toCurrency);
        helper.parmExchangeRateTypeRecId(_exchRateTypeRecId);
        return helper.getCrossRate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentReportingCurrencyExchangeRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current reporting currency exchange rate.
    /// </summary>
    /// <param name = "_ledger">The ledger context that is used for retrieving exchange rate information.</param>
    /// <param name = "_fromCurrency">The form currency that is used for retrieving exchange rate information.</param>
    /// <param name = "_toCurrency">The to currency that is used for retrieving exchange rate information.</param>
    /// <param name = "_exchangeDate">The exchange rate date that is used for retrieving exchange rate information.</param>
    /// <returns>The current reporting currency exchange rate.</returns>
    protected CurrencyExchangeRate getCurrentReportingCurrencyExchangeRate(LedgerRecId _ledger, CurrencyCode _fromCurrency, CurrencyCode _toCurrency, TransDate _exchangeDate)
    {
        ExchangeRateHelper helper = ExchangeRateHelper::newExchangeDate(_ledger, _fromCurrency, _exchangeDate);
        helper.parmToCurrency(_toCurrency);
        helper.parmExchangeRateTypeRecId(Ledger::reportingCurrencyExchangeRateType());
        return helper.getCrossRate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCurrencyExchangeHelperFromLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of <c>CurrencyExchangeHelper</c> class.
    /// </summary>
    /// <param name = "_ledger">The ledger RecId used to create the instance of <c>CurrencyExchangeHelper</c>.</param>
    /// <returns>An instance of <c>CurrencyExchangeHelper</c> class.</returns>
    protected CurrencyExchangeHelper initCurrencyExchangeHelperFromLedger(LedgerRecId _ledger)
    {
        return CurrencyExchangeHelper::newLedger(_ledger);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSettlementAdjustments</Name>
				<Source><![CDATA[
    protected container calculateSettlementAdjustments(
        CustVendTrans _custVendTrans,
        CustVendSettlement _custVendSettlement,
        boolean _findLastExchangeAdjustment)
    {
        AmountMST accountingCurrencySettlementAdjustment;
        AmountMST reportingCurrencySettlementAdjustment;

        LedgerRecId currentLedgerRecId = Ledger::current();
        
        if (_custVendTrans.CurrencyCode != Ledger::accountingCurrencyByLedger(currentLedgerRecId))
        {
            if (_findLastExchangeAdjustment && _custVendTrans.LastExchAdjRate == 0.0)
            {
                // If no previous adjustments exist, there should be no new adjustments for the reversal
                accountingCurrencySettlementAdjustment = 0;
            }
            else
            {
                CurrencyExchangeRate currentTransactionCurrencyExchangeRate;

                // Determine the accounting currency exchange rate that will be compared to the original exchange rate
                // in order to calculate the adjustment.
                if (_findLastExchangeAdjustment && _custVendTrans.LastExchAdjRate)
                {
                    currentTransactionCurrencyExchangeRate = _custVendTrans.LastExchAdjRate;
                }
                else
                {
                    if (FeatureStateProvider::isFeatureEnabled(CustVendExchRateTypeEnhancementFeature::instance()))
                    {
                        RecId exchRateTypeMSTRecId = this.getExchRateTypeRecIdEnhanced(_custVendTrans.AccountNum, true);
                        currentTransactionCurrencyExchangeRate = this.getExchRateFromExchRateType(
                            currentLedgerRecId,
                            _custVendTrans.CurrencyCode,
                            Ledger::accountingCurrency(currentLedgerRecId),
                            this.getExchangeRateDateToUse(_custVendTrans),
                            exchRateTypeMSTRecId);
                    }
                    else
                    {
                        currentTransactionCurrencyExchangeRate = this.getCurrentTransactionCurrencyExchangeRate(currentLedgerRecId, _custVendTrans.CurrencyCode, this.getExchangeRateDateToUse(_custVendTrans));
                    }
                }

                // We could simply subtract the current and original exchange rate and multiply it by the
                // SettleAmountCur to determine the accounting currency adjustment, but we need the
                // currentAccountingCurrencySettlementAmount in order to determine if there is a reporting
                // currency adjustment. This explains the extra step in the calculation.
                CurrencyExchangeHelper accountingCurrencyExchangeHelper = this.initCurrencyExchangeHelperFromLedger(currentLedgerRecId);
                accountingCurrencyExchangeHelper.parmExchangeRate1(currentTransactionCurrencyExchangeRate);

                AmountMST currentAccountingCurrencySettlementAmount = accountingCurrencyExchangeHelper.calculateTransactionToAccounting(
                    _custVendTrans.CurrencyCode,
                    _custVendSettlement.SettleAmountCur,
                    true);

                // The original exchange rate is used rather than the rate used at the time of the settlement.
                // This is due to the fact that we are trying to adjust the unrealized portion of the exchange
                // adjustment, which only looks at the original value of the document compared to the the value
                // of the document now.
                accountingCurrencyExchangeHelper.parmExchangeRate1(_custVendTrans.ExchRate);
                accountingCurrencyExchangeHelper.parmExchangeRate2(_custVendTrans.ExchRateSecond);

                AmountMST originalAccountingCurrencySettlementAmount = accountingCurrencyExchangeHelper.calculateTransactionToAccounting(
                    _custVendTrans.CurrencyCode,
                    _custVendSettlement.SettleAmountCur,
                    true);

                // No need to round this result since both amounts are already rounded.
                accountingCurrencySettlementAdjustment = currentAccountingCurrencySettlementAmount - originalAccountingCurrencySettlementAmount;
            }
        }

        CurrencyCode currentReportingCurrency = Ledger::reportingCurrencyByLedger(currentLedgerRecId);

        // Determine the reporting currency settlement adjustment
        if (_custVendTrans.getReportingCombinedExchangeRate() != 0
            && currentReportingCurrency != ''
            && _custVendTrans.CurrencyCode != currentReportingCurrency)
        {
            // Only adjust when a reporting currency exchange rate exists. If a rate does not exist, it means
            // there was no reporting currency set up when the transaction was originally created, or data was
            // upgraded prior to the enablement of reporting currency revaluations.

            // When the reporting currency is the same as the transaction currency, there are no reporting currency
            // adjustments to be made since the two amounts should always equal.

            // If a reporting currency does not exist, do not attempt to revalue since it signifies reporting currency
            // amounts should not be calculated.

            CurrencyExchangeRate currentReportingCurrencyExchangeRate;

            if (_findLastExchangeAdjustment && _custVendTrans.LastExchAdjRateReporting == 0.0)
            {
                // If no previous adjustments exist, there should be no new adjustments for the reversal
                reportingCurrencySettlementAdjustment = 0;
            }
            else
            {
                if (_findLastExchangeAdjustment && _custVendTrans.LastExchAdjRateReporting)
                {
                    currentReportingCurrencyExchangeRate = _custVendTrans.LastExchAdjRateReporting;
                }
                else
                {
                    if (FeatureStateProvider::isFeatureEnabled(CustVendExchRateTypeEnhancementFeature::instance()))
                    {
                        RecId exchRateTypeReportingRecId = this.getExchRateTypeRecIdEnhanced(_custVendTrans.AccountNum, false);
                        currentReportingCurrencyExchangeRate = this.getExchRateFromExchRateType(
                            currentLedgerRecId,
                            _custVendTrans.CurrencyCode,
                            Ledger::reportingCurrency(currentLedgerRecId),
                            this.getExchangeRateDateToUse(_custVendTrans),
                            exchRateTypeReportingRecId);
                    }
                    else
                    {
                        currentReportingCurrencyExchangeRate = this.getCurrentReportingCurrencyExchangeRate(currentLedgerRecId, _custVendTrans.CurrencyCode, currentReportingCurrency, this.getExchangeRateDateToUse(_custVendTrans));
                    }
                }

                // New reporting currency adjustment rates come from the active reporting currency exchange rates.
                CurrencyExchangeHelper reportingCurrencyExchangeHelper = this.initCurrencyExchangeHelperFromLedger(currentLedgerRecId);
                reportingCurrencyExchangeHelper.parmReportingExchangeRate1(currentReportingCurrencyExchangeRate);

                AmountMST currentReportingCurrencySettlementAmount = reportingCurrencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(
                    _custVendTrans.CurrencyCode,
                    _custVendSettlement.SettleAmountCur);

                // Original reporting currency adjustment rates are based on the original document rates.
                custVendTrans.setExchangeHelperReportingExchRate(reportingCurrencyExchangeHelper);

                AmountMST originalReportingCurrencySettlementAmount = reportingCurrencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(
                    _custVendTrans.CurrencyCode,
                    _custVendSettlement.SettleAmountCur);

                // No need to round this result since both amounts are already rounded.
                reportingCurrencySettlementAdjustment = currentReportingCurrencySettlementAmount - originalReportingCurrencySettlementAmount;
            }
        }

        return [accountingCurrencySettlementAdjustment, reportingCurrencySettlementAdjustment];
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTrans</Name>
				<Source><![CDATA[
    public boolean checkTrans()
    {
        if ((custVendTrans.ExchAdjustment || custVendTrans.ExchAdjustmentReporting)
            && custVendTrans.LastExchAdj > exchangeAdjustmentController.postingDate())
        {
            info(strFmt("@SYS68767", custVendTrans.Voucher, date2StrUsr(exchangeAdjustmentController.postingDate(), DateFlags::FormatAll), date2StrUsr(custVendTrans.LastExchAdj, DateFlags::FormatAll)));
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOpenTransQuery</Name>
				<Source><![CDATA[
    protected abstract Query createOpenTransQuery(Query _baseQuery)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSettledTransQuery</Name>
				<Source><![CDATA[
    protected abstract Query createSettledTransQuery(Query _baseQuery)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReversedTransQuery</Name>
				<Source><![CDATA[
    protected Query createReversedTransQuery(Query _baseQuery)
    {
        return new Query();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBankChequeCancelTransQuery</Name>
				<Source><![CDATA[
    protected Query createBankChequeCancelTransQuery(Query _baseQuery)
    {
        return new Query();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBankDepositCancelTransQuery</Name>
				<Source><![CDATA[
    protected Query createBankDepositCancelTransQuery(Query _baseQuery)
    {
        return new Query();
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendExchRateAdjustment</Name>
				<Source><![CDATA[
    protected abstract void custVendExchRateAdjustment()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendTable_W</Name>
				<Source><![CDATA[
    abstract protected CustVendTable custVendTable_W()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExchRateTypeRecIdEnhanced</Name>
				<Source><![CDATA[
    private RecId getExchRateTypeRecIdEnhanced(CustVendAC _custVendAC, boolean _isAccounting)
    {
        RecId exchRateTypeRecId;
        CustVendExchAdjRateSource currentRateSource = exchangeAdjustmentController.module() == SysModule::Cust ?
            CustParameters::find().ExchAdjRateSource :
            VendParameters::find().ExchAdjRateSource;

        switch (currentRateSource)
        {
            case CustVendExchAdjRateSource::Group:
                ModuleCustVend moduleCustVend = exchangeAdjustmentController.module() == SysModule::Cust ? ModuleCustVend::Cust : ModuleCustVend::Vend;
                SysGroup groupId = CustVendTable::findModule(moduleCustVend, _custVendAC).GroupId;
                if (groupId)
                {
                    CustVendGroup custVendGroup = CustVendGroup::findByModule(exchangeAdjustmentController.module(), groupId);
                    exchRateTypeRecId = _isAccounting ? custVendGroup.AccountingCurrencyExchangeRateType : custVendGroup.ReportingCurrencyExchangeRateType;
                }
                break;
            case CustVendExchAdjRateSource::Specific:
                if (_isAccounting)
                {
                    exchRateTypeRecId = exchangeAdjustmentController.module() == SysModule::Cust ?
                        CustParameters::find().AccountingCurrencyExchangeRateType :
                        VendParameters::find().AccountingCurrencyExchangeRateType;
                }
                else
                {
                    exchRateTypeRecId = exchangeAdjustmentController.module() == SysModule::Cust ?
                        CustParameters::find().ReportingCurrencyExchangeRateType :
                        VendParameters::find().ReportingCurrencyExchangeRateType;
                }
                break;
            default:
                break;
        }

        if (!exchRateTypeRecId)
        {
            if (_isAccounting)
            {
                exchRateTypeRecId = Ledger::defaultExchangeRateType();
            }
            else
            {
                exchRateTypeRecId = Ledger::reportingCurrencyExchangeRateType() ? Ledger::reportingCurrencyExchangeRateType() : Ledger::defaultExchangeRateType();
            }
        }

        return exchRateTypeRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchAdjustSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Settlement exchange adjustment for the current document.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///  This parameter is not used.
    /// </param>
    protected void exchAdjustSettlement(LedgerVoucher _ledgerVoucher = null)
    {
        // <GEERU>
        boolean standardReverse = !SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU]);
        boolean countryRegion_RUCZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]);
        // </GEERU>

        // Determine the adjustments that were made the last time. These will be used to "reverse"
        // the previous adjustment.
        container settlementAdjustments = this.calculateSettlementAdjustments(
            custVendTrans,
            custVendSettlement,
            true);

        AmountMST previousAdjustmentAccountingCurrency = conPeek(settlementAdjustments, 1);
        AmountMSTSecondary previousAdjustmentReportingCurrency = conPeek(settlementAdjustments, 2);

        // Determine the new adjustments. Once the previous adjustments are reversed, these
        // adjustments will be applied.
        settlementAdjustments = this.calculateSettlementAdjustments(
            custVendTrans,
            custVendSettlement,
            false);

        AmountMST newAdjustmentAccountingCurrency = conPeek(settlementAdjustments, 1);
        AmountMSTSecondary newAdjustmentReportingCurrency = conPeek(settlementAdjustments, 2);

        if ((this.shouldAdjustAmount(newAdjustmentAccountingCurrency, previousAdjustmentAccountingCurrency)
            || this.shouldAdjustAmount(newAdjustmentReportingCurrency, previousAdjustmentReportingCurrency))
            && this.checkTrans())
        {
            if (CustVendExchAdjLedgerPostTelemetryFlight::instance().isEnabled())
            {
                this.startNewTiming(this.stopWatch);
            }

            if (!countryRegion_RUCZ)
            {
                if (!ledgerVoucher)
                {
                    this.initLedgerVoucher();
                }
                this.addNewLedgerVoucherObject(custVendTrans);
            }

            custVendExchAdjPostingEngine.reload(
                exchangeAdjustmentController,
                this.getExchangeRateDateToUse(custVendTrans),
                custVendTrans,
                custVendTransOpen,
                custVendSettlement,
                lastExchangeAdjustmentHistory,
                ledgerVoucher);

            // The settlement date determines the date to use for any settlement records generated
            TransDate settlementDate = max(custVendTrans.TransDate, exchangeAdjustmentController.postingDate());

            // If dealing with a past exchange adjustment, back out that adjustment before creating the
            // new adjustment.

            if (!custVendExchAdjPostingEngine.isPreviousRevaluationReversal()
                && (custVendTrans.LastExchAdjRate || custVendTrans.LastExchAdjRateReporting))
            {
                // When the last adjustment was made (the one just before this one) it created an
                // adjustment. This backs out that adjustment on the new adjustment date which
                // basically "clears" any adjustments so the new one will appear and impact
                // the customer balance as of the adjustment date.
                custVendExchAdjPostingEngine.addExchangeAdjustment(
                    -previousAdjustmentAccountingCurrency,
                    -previousAdjustmentReportingCurrency,
                    settlementDate,
                    exchangeAdjustmentController.postingDate(),
                    true,
                // <GEEU>
                standardReverse);
                // </GEEU>

                // When the last exchange adjustment was made (the one just before this one) it backed
                // out the adjustment out on the settlement date. This reverses that reversal so there
                // is no impact to the customer balance on the settlement date. The reversal flag is set
                // to false since this is the reversal of a reversal.
                custVendExchAdjPostingEngine.addExchangeAdjustment(
                    previousAdjustmentAccountingCurrency,
                    previousAdjustmentReportingCurrency,
                    custVendSettlement.TransDate,
                    custVendSettlement.TransDate,
                    false,
                    true);
            }

            // When performing an Invoice date adjustment, the key point is to get the "balance" back
            // to the original amount, so the only work necessary is to reverse out the last adjustment.
            // This is why new adjustments are only posted when using an adjustment method of something
            // other than the Invoice date method.

            if (exchangeAdjustmentController.exchPrinciples() != CustVendExchPrinciples::InvDatePrinciple)
            {
                // Post the new adjustment that was calculated using the exchange adjustment date. This
                // ensures customer balances appear correct as of the adjustment date.
                custVendExchAdjPostingEngine.addExchangeAdjustment(
                    newAdjustmentAccountingCurrency,
                    newAdjustmentReportingCurrency,
                    settlementDate,
                    exchangeAdjustmentController.postingDate(),
                    false,
                    false);

                // Using the settlement date (out in the future), back out the new adjustment. This
                // reverses the adjustment that will be made later so the balances appear correct
                // on the settlement date.
                custVendExchAdjPostingEngine.addExchangeAdjustment(
                    -newAdjustmentAccountingCurrency,
                    -newAdjustmentReportingCurrency,
                    custVendSettlement.TransDate,
                    custVendSettlement.TransDate,
                    true,
                    false);
            }

            if (CustVendExchAdjLedgerPostTelemetryFlight::instance().isEnabled())
            {
                ledgerVoucherGenerateElapsedMilliseconds += this.stopTimingAndGetDurationInMs(this.stopWatch);
                this.startNewTiming(this.stopWatch);
            }

            if (ledgerVoucher)
            {
                this.postLedgerVoucher(custVendTrans);
            }
            else
            {
                custVendExchAdjPostingEngine.end();
            }

            if (CustVendExchAdjLedgerPostTelemetryFlight::instance().isEnabled())
            {
                ledgerPostingElapsedMilliseconds += this.stopTimingAndGetDurationInMs(this.stopWatch);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCurrencyExchangeHelperByExchangeDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of <c>CurrencyExchangeHelper</c> from ledger and date.
    /// </summary>
    /// <param name = "_ledger">The ledger record.</param>
    /// <param name = "_exchangeDate">The exchange date.</param>
    /// <returns>An instance of <c>CurrencyExchangeHelper</c>.</returns>
    protected CurrencyExchangeHelper initCurrencyExchangeHelperByExchangeDate(LedgerRecId _ledger, TransDate _exchangeDate)
    {
        return CurrencyExchangeHelper::newExchangeDate(_ledger, _exchangeDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchAdjustTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Exchange adjustment for the current open document
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///  This parameter is not used.
    /// </param>
    protected void exchAdjustTrans(LedgerVoucher _ledgerVoucher = null)
    {
        // <GEERU>
        boolean countryRegion_RUCZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]);
        // </GEERU>

        AmountMST previousAccountingCurrencyAdjustmentAmount = custVendTransOpen.ExchAdjUnrealized;
        AmountMSTSecondary previousReportingCurrencyAdjustmentAmount = custVendTransOpen.ExchAdjUnrealizedReporting;

        CurrencyExchangeHelper currencyExchangeHelper = this.initCurrencyExchangeHelperByExchangeDate(
            Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
            this.getExchangeRateDateToUse(custVendTrans));

        if (FeatureStateProvider::isFeatureEnabled(CustVendExchRateTypeEnhancementFeature::instance()))
        {
            RecId exchRateTypeMSTRecId = this.getExchRateTypeRecIdEnhanced(custVendTrans.AccountNum, true);
            currencyExchangeHelper.parmExchangeRateTypeRecId(exchRateTypeMSTRecId);
        }

        // Calculate accounting currency adjustments
        AmountMST newAccountingCurrencyAmount = currencyExchangeHelper.calculateTransactionToAccounting(
            custVendTrans.CurrencyCode,
            custVendTransOpen.AmountCur,
            true);

        // No rounding necessary on this amount since both amounts are already rounded. It is very important to use
        // the custVendTransOpen amount in order to handle partial settlements.  Since we are using the open amount,
        // it is necessary to note that it actually contains the previous adjustment since AmountMST is updated to reflect
        // the true value of the document at a given point in time.  This explains why the previous adjustment is removed
        // from that amount prior to posting the new adjustment later.
        AmountMST accountingCurrencyExchangeAdjustmentAmount = newAccountingCurrencyAmount - custVendTransOpen.AmountMST;

        AmountMSTSecondary reportingCurrencyExchangeAdjustmentAmount;
        // Calculate reporting currency adjustments
        if (custVendTrans.getReportingCombinedExchangeRate() != 0
            && Ledger::isReportingCurrencyDefined())
        {
            // Only adjust when a reporting currency exchange rate exists. If a rate does not exist, it means
            // there was no reporting currency set up when the transaction was originally created, or data was
            // upgraded prior to the enablement of reporting currency revaluations.

            // If a reporting currency does not exist in the ledger, do not attempt to revalue since it signifies
            // reporting currency amounts should no longer be calculated.
            if (FeatureStateProvider::isFeatureEnabled(CustVendExchRateTypeEnhancementFeature::instance()))
            {
                RecId exchRateTypeReportingRecId = this.getExchRateTypeRecIdEnhanced(custVendTrans.AccountNum, false);
                currencyExchangeHelper.parmReportingExchangeRateTypeRecId(exchRateTypeReportingRecId);
            }

            AmountMSTSecondary newReportingCurrencyAmount = currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(
                custVendTrans.CurrencyCode,
                custVendTransOpen.AmountCur);

            // No rounding necessary on this amount since both amounts are already rounded. It is very important to use
            // the custVendTransOpen amount in order to handle partial settlements.  Since we are using the open amount,
            // it is necessary to note that it actually contains the previous adjustment since ReportingCurrencyAmount is updated to reflect
            // the true value of the document at a given point in time.  This explains why the previous adjustment is removed
            // from that amount prior to posting the new adjustment later.
            reportingCurrencyExchangeAdjustmentAmount = newReportingCurrencyAmount - custVendTransOpen.ReportingCurrencyAmount;
        }

        if ((this.shouldAdjustAmount(accountingCurrencyExchangeAdjustmentAmount, custVendTransOpen.ExchAdjUnrealized)
            || this.shouldAdjustAmount(reportingCurrencyExchangeAdjustmentAmount, custVendTransOpen.ExchAdjUnrealizedReporting))
            && this.checkTrans())
        {
            if (CustVendExchAdjLedgerPostTelemetryFlight::instance().isEnabled())
            {
                this.startNewTiming(stopWatch);
            }

            if (!countryRegion_RUCZ)
            {
                if (!ledgerVoucher)
                {
                    this.initLedgerVoucher();
                }
                this.addNewLedgerVoucherObject(custVendTrans);
            }

            custVendExchAdjPostingEngine.reload(
                exchangeAdjustmentController,
                this.getExchangeRateDateToUse(custVendTrans),
                custVendTrans,
                custVendTransOpen,
                custVendSettlement,
                lastExchangeAdjustmentHistory,
                ledgerVoucher);

            // The settlement date determines the date to use for any settlement records generated
            TransDate settlementDate = max(custVendTrans.TransDate, exchangeAdjustmentController.postingDate());

            // Reverse the previous adjustment
            custVendExchAdjPostingEngine.addExchangeAdjustment(
                -custVendTransOpen.ExchAdjUnrealized,
                -custVendTransOpen.ExchAdjUnrealizedReporting,
                settlementDate,
                exchangeAdjustmentController.postingDate(),
                true,
                true);

            // When performing an Invoice date adjustment, the key point is to get the "balance" back
            // to the original amount, so the only work necessary is to reverse out the last adjustment.
            // This is why new adjustments are only posted when using an adjustment method of something
            // other than the Invoice date method.

            if (exchangeAdjustmentController.exchPrinciples() != CustVendExchPrinciples::InvDatePrinciple)
            {
                // Post the new adjustment. At this point it is necessary to "adjust" the adjustment by
                // the amount that was previously backed out. This is because the open amount is updated
                // when the previous adjustments were backed out. As a result we need to be sure to include
                // the full adjustment, and not just the adjustment since the last adjustment.
                custVendExchAdjPostingEngine.addExchangeAdjustment(
                    CurrencyExchange::round(accountingCurrencyExchangeAdjustmentAmount + previousAccountingCurrencyAdjustmentAmount, Ledger::accountingCurrency()),
                    CurrencyExchange::round(reportingCurrencyExchangeAdjustmentAmount + previousReportingCurrencyAdjustmentAmount, Ledger::reportingCurrency()),
                    settlementDate,
                    exchangeAdjustmentController.postingDate(),
                    false,
                    false);
            }

            if (CustVendExchAdjLedgerPostTelemetryFlight::instance().isEnabled())
            {
                ledgerVoucherGenerateElapsedMilliseconds += this.stopTimingAndGetDurationInMs(this.stopWatch);
                this.startNewTiming(this.stopWatch);
            }

            if (ledgerVoucher)
            {
                this.postLedgerVoucher(custVendTrans);
            }
            else
            {
                custVendExchAdjPostingEngine.end();
            }

            if (CustVendExchAdjLedgerPostTelemetryFlight::instance().isEnabled())
            {
                ledgerPostingElapsedMilliseconds += this.stopTimingAndGetDurationInMs(this.stopWatch);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExchangeRateDateToUse</Name>
				<Source><![CDATA[
    public TransDate getExchangeRateDateToUse(CustVendTrans _custVendTrans)
    {
        TransDate exchangeRateDateToUse;

        if (exchangeAdjustmentController.exchPrinciples() == CustVendExchPrinciples::InvDatePrinciple)
        {
            exchangeRateDateToUse = _custVendTrans.TransDate;
        }
        else
        {
            exchangeRateDateToUse = exchangeAdjustmentController.exchRateDate();
        }

        return exchangeRateDateToUse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerTransactionText</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Gets the transaction text for use with the new transaction.
    /// </summary>
    /// <returns>
    ///  A <c>LedgerTransTxt</c> text.
    /// </returns>
    protected abstract LedgerTransTxt getLedgerTransactionText()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getModule</Name>
				<Source><![CDATA[
    protected abstract ModuleCustVend getModule()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getModule_W</Name>
				<Source><![CDATA[
    protected abstract SysModule getModule_W()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberSequence</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Gets the currency revaluation number sequence referernce.
    /// </summary>
    /// <returns>
    ///  A new <c>NumberSequenceReference</c> instance.
    /// </returns>
    protected abstract NumberSequenceReference getNumberSequence()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Initialiazes the <c>LedgerVoucher</c> class.
    /// </summary>
    protected void initLedgerVoucher()
    {
        NumberSeq numberSeq = numberSeq::newGetVoucher(this.getNumberSequence());

        ledgerVoucher = LedgerVoucher::newLedgerPost(
            DetailSummary::Detail,
            exchangeAdjustmentController.module(),
            numberSeq.parmVoucherSequenceCode());

        ledgerVoucher.parmCheckBlockedDimensions(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Initializes a new instance of the <c>CustVendExchAdjTrans</c> class.
    /// </summary>
    /// <param name="_exchangeRateController">
    ///  The customer or vendor exchange rate controller.
    /// </param>
    void new(CustVendExchAdj _exchangeRateController)
    {
        exchangeAdjustmentController = _exchangeRateController;
        lastExchangeAdjustmentHistory = new Map(Types::Int64, Types::Container);
        custVendExchAdjPostingEngine = CustVendExchAdjPostingEngine::constructUninitializedImplementation(_exchangeRateController);

        // <GEERU>
        custVendSettlementCurDeal = _exchangeRateController.parmCustVendTransSettlementCurDeal_RU();
        previousUnrealizedDate = _exchangeRateController.parmPreviousUnrealizedDate_RU();
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>postLedgerVoucher</Name>
				<Source><![CDATA[
    private void postLedgerVoucher(CustVendTrans _custVendTrans)
    {
        if (ledgerVoucher.numOfVouchers() > 1000)
        {
            ledgerVoucher.end();
            this.initLedgerVoucher();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processOpenTransactions_W</Name>
				<Source><![CDATA[
    protected void processOpenTransactions_W(QueryRun _queryRun, CustVendExchAdjustment_W custVendExchAdjustment, boolean _unrealized = true, LedgerVoucher _ledgerVoucher = null)
    {
        PostingProfile postingProfileLoc = exchangeAdjustmentController.postingProfile();
        DimensionDefault defaultDimensionLoc = exchangeAdjustmentController.defaultDimension();

        _queryRun.reset();

        while (_queryRun.next())
        {
            if (custVendTable.CustVendTable::hasChangedInQuery(_queryRun))
            {
                custVendTable = custVendTable.CustVendTable::getFromQuery(_queryRun);
            }

            if (custVendTrans.CustVendTrans::hasChangedInQuery(_queryRun))
            {
                custVendTrans = custVendTrans.CustVendTrans::getFromQuery(_queryRun);
                custExchAdjustmentUnrealized = custVendTrans.ExchAdjustmentUnrealized;

                this.progressUpdate(strFmt(
                    "@SYS27234",
                    custVendTrans.AccountNum,
                    custVendTrans.Voucher,
                    custVendTrans.CurrencyCode));

                if (exchangeAdjustmentController.postingSpec() == AccountChoice::Account)
                {
                    postingProfileLoc = custVendTrans.PostingProfile;
                }

                switch (exchangeAdjustmentController.dimSpec())
                {
                    case NoneTableTrans::None:
                        defaultDimensionLoc = 0;
                        break;

                    case NoneTableTrans::Table:
                        defaultDimensionLoc = custVendTable.DefaultDimension;
                        break;

                    case NoneTableTrans::Transaction:
                        defaultDimensionLoc = custVendTrans.DefaultDimension;
                        break;

                    default:
                        throw error("@SYS18879");
                }

                if (custVendExchAdjustment)
                {
                    CustVendExchAdjustment_W::reverseTransAmounts(custVendTrans);
                    AmountCur openAmountTransaction;
                    AmountMST openAmountAccounting;
                    AmountMSTSecondary openAmountReporting;
                    [openAmountTransaction, openAmountAccounting, openAmountReporting] = CustVendExchAdjustment_W::getOpenAmounts(custVendTrans, exchangeAdjustmentController.postingDate(), custVendSettlementCurDeal);

                    if (openAmountTransaction || openAmountAccounting || openAmountReporting)
                    {
                        custVendTransOpen = CustVendTransOpen::findRefId(custVendTrans.TableId, custVendTrans.RecId, true);
                        CustVendExchAdjustment_W::reverseTransOpenAmounts(custVendTransOpen);
                        if (_unrealized)
                        {
                            settlementGroupPlaceHolder++;
                            custVendExchAdjustment.setSettlementGroupPlaceHolder(settlementGroupPlaceHolder);

                            boolean unrealizedResult = custVendExchAdjustment.processUnrealizedExchAdj(
                                custVendTrans,
                                custVendTransOpen,
                                exchangeAdjustmentController.postingDate(),
                                exchangeAdjustmentController.exchRateDate(),
                                exchangeAdjustmentController.dimSpec(),
                                defaultDimensionLoc,
                                postingProfileLoc,
                                exchangeAdjustmentController.postingSpec());

                            if (!unrealizedResult)
                            {
                                failedTransSet.add(custVendTrans.RecId);
                            }
                        }
                        else if (!failedTransSet.in(custVendTrans.RecId))
                        {
                            settlementGroupPlaceHolder++;
                            custVendExchAdjustment.setSettlementGroupPlaceHolder(settlementGroupPlaceHolder);
                            custVendExchAdjustment.recalcFutureRealizedExchAdj(custVendTrans, custVendTransOpen, exchangeAdjustmentController.postingDate());
                        }
                    }
                }
            }

            if (!custVendExchAdjustment && custVendTransOpen.CustVendTransOpen::hasChangedInQuery(_queryRun))
            {
                custVendTransOpen = custVendTransOpen.CustVendTransOpen::getFromQuery(_queryRun);
                this.exchAdjustTrans();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>progressUpdate</Name>
				<Source><![CDATA[
    private void progressUpdate(str _text)
    {
        progressCounter++;
        progress.setCount(progressCounter);
        progress.setText(_text);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldAdjustAmount</Name>
				<Source><![CDATA[
    public boolean shouldAdjustAmount(AmountMST _adjustmentAmount, AmountMST _previousUnrealizedExchangeAdjustment)
    {
        boolean ret = true;

        switch (exchangeAdjustmentController.exchPrinciples())
        {
            case CustVendExchPrinciples::MinMaxPrinciple:
                if (_adjustmentAmount >= 0)
                {
                    ret = false;
                }
                break;

            case CustVendExchPrinciples::InvDatePrinciple:
                if (!_previousUnrealizedExchangeAdjustment)
                {
                    ret = false;
                }
                break;

            default :
                if (!_adjustmentAmount && !_previousUnrealizedExchangeAdjustment)
                {
                    ret = false;
                }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogTxt</Name>
				<Source><![CDATA[
    protected abstract TransTxt transactionLogTxt()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogType</Name>
				<Source><![CDATA[
    protected abstract TransactionLogType transactionLogType()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProgressLogger</Name>
				<Source><![CDATA[
    private SysInstrumentationProgressLogger createProgressLogger()
    {
        str sourceName = CustVendInstrumentationFormatter::sourceNameWithModule(CustVendInstrumentationConstants::SourceNameForeignCurrencyRevaluation, this.getModule());

        return SysInstrumentationProgressLogger::createLogger(SourceName, CustVendInstrumentationConstants::InstrumentationNamespace);
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public CreatedTransactionId update(QueryRun _queryRun)
    {
        #OCCRetryCount

        const int DeadlockRetryWait = 500;

        CreatedTransactionId createdTransactionId;

        SysInstrumentationProgressLogger progressLogger = this.createProgressLogger();

        using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextForStage(CustVendInstrumentationConstants::ForeignCurrencyRevaluationGenerate))
        {
            try
            {
                if (ledgerVoucher)
                {
                    this.initLedgerVoucher();
                }

                createdTransactionId = this.doUpdate(_queryRun);
            }
            catch (Exception::UpdateConflict)
            {
                if (appl.ttsLevel() > 0)
                {
                    throw Exception::UpdateConflict;
                }
                else if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    progressLogger.logRetryOnUpdateConflict();
                    _queryRun.reset();
                    retry;
                }
            }
            catch (Exception::Deadlock)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::Deadlock;
                }
                else
                {
                    progressLogger.logRetryOnDeadlock();

                    sleep(DeadlockRetryWait);
                    _queryRun.reset();
                    retry;
                }
            }
        }

        return createdTransactionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doUpdate</Name>
				<Source><![CDATA[
    private CreatedTransactionId doUpdate(QueryRun _queryRun)
    {
        #macrolib.AviFiles

        Counter progressTotal = QueryRun::getQueryRowCount(_queryRun.query(), intMax());

        exchangeAdjustmentController.progressInit("@SYS55328", progressTotal, #AviFindFile);
        progress = exchangeAdjustmentController.parmProgress();
        progress.setText("@SYS26577");

        boolean countryRegion_RUCZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]);
        Counter settledInvoiceQueryCount;

        if (countryRegion_RUCZ)
        {
            failedTransSet = new Set(typeName2Type(extendedTypeStr(RecId)));
            custVendTransSettlement = CustVendTransSettlement::construct(this.getModule_W());
        }

        SysInstrumentationProgressLogger progressLogger = this.createProgressLogger();

        ttsbegin;

        custVendSettlement = CustVendSettlement::getEmptyTableBuffer(this.getModule());
        custVendTrans = CustVendTrans::getEmptyTableBuffer(this.getModule());
        custVendTransOpen = CustVendTransOpen::getEmptyTableBuffer(this.getModule());
        custVendTable = CustVendTable::getEmptyTableBuffer(this.getModule());

        CustVendExchAdjustment_W  custVendExchAdjustment_W;
        Counter settledInvoicesProcessed, reversedSettledInvoiceQueryCount, reversedBankChequeQueryCount, reversedBankDepositQueryCount, openInvoiceQueryCount;

        if (LedgerParameters::find().ExchRateDiffCalcType_W != ExchRateDiffCalcType_W::Standard)
        {
            custVendExchAdjustment_W = CustVendExchAdjustment_W::newFromExchAdj(exchangeAdjustmentController, this);
            custVendExchAdjustment_W.setCustVendTransSettlement(custVendTransSettlement);

            QueryRun queryRun = this.updateQueryRun_W(_queryRun);
            this.processOpenTransactions_W(queryRun, custVendExchAdjustment_W);
            this.processOpenTransactions_W(queryRun, custVendExchAdjustment_W, false);
        }
        else
        {
            // Run on settled transactions
            QueryRun settledTransQuery = new QueryRun(this.createSettledTransQuery(_queryRun.query()));

            settledInvoiceQueryCount = QueryRun::getQueryRowCount(settledTransQuery.query(), intMax());

            SysInstrumentationProgressStage progressStage = progressLogger.createStage(CustVendInstrumentationConstants::ForeignCurrencyRevaluationRevalueSettledTrans, settledInvoiceQueryCount);

            using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextWithProgressMonitor(progressStage))
            {
                while (settledTransQuery.next())
                {
                    if (custVendTrans.CustVendTrans::hasChangedInQuery(settledTransQuery))
                    {
                        custVendTrans = custVendTrans.CustVendTrans::getFromQuery(settledTransQuery);
                    }

                    custVendSettlement = custVendSettlement.CustVendSettlement::getFromQuery(settledTransQuery);

                    this.progressUpdate(strFmt(
                        "@SYS27234",
                        custVendTrans.AccountNum,
                        custVendTrans.Voucher,
                        custVendTrans.CurrencyCode));

                    select forupdate custVendTransOpen
                        where custVendTransOpen.RefRecId == custVendTrans.RecId;

                    this.exchAdjustSettlement();

                    settledInvoicesProcessed++;

                    progressLogger.trackProgress(settledInvoicesProcessed);
                }
            }

            // Run on reversed settled transactions
            QueryRun reversedSettledTransQuery = new QueryRun(this.createReversedTransQuery(_queryRun.query()));

            reversedSettledInvoiceQueryCount = QueryRun::getQueryRowCount(reversedSettledTransQuery.query(), intMax());
            Counter reversedSettledInvoicesProcessed;

            progressStage = progressLogger.createStage(CustVendInstrumentationConstants::ForeignCurrencyRevaluationRevalueReversedSettledTrans, reversedSettledInvoiceQueryCount);

            using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextWithProgressMonitor(progressStage))
            {
                while (reversedSettledTransQuery.next())
                {
                    if (custVendTrans.CustVendTrans::hasChangedInQuery(reversedSettledTransQuery))
                    {
                        custVendTrans = custVendTrans.CustVendTrans::getFromQuery(reversedSettledTransQuery);
                    }

                    custVendSettlement = custVendSettlement.CustVendSettlement::getFromQuery(reversedSettledTransQuery);

                    this.progressUpdate(strFmt(
                        "@SYS27234",
                        custVendTrans.AccountNum,
                        custVendTrans.Voucher,
                        custVendTrans.CurrencyCode));

                    select forupdate custVendTransOpen
                        where custVendTransOpen.RefRecId == custVendTrans.RecId;

                    this.exchAdjustSettlement();

                    reversedSettledInvoicesProcessed++;

                    progressLogger.trackProgress(reversedSettledInvoicesProcessed);
                }
            }

            // Run on reversed bank check transactions
            QueryRun reversedBankChequeTransQuery = new QueryRun(this.createBankChequeCancelTransQuery(_queryRun.query()));

            reversedBankChequeQueryCount = QueryRun::getQueryRowCount(reversedBankChequeTransQuery.query(), intMax());
            Counter reversedBankChequeQueryProcessed;

            progressStage = progressLogger.createStage(CustVendInstrumentationConstants::ForeignCurrencyRevaluationRevalueReversedSettledTrans, reversedBankChequeQueryCount);

            using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextWithProgressMonitor(progressStage))
            {
                while (reversedBankChequeTransQuery.next())
                {
                    if (custVendTrans.CustVendTrans::hasChangedInQuery(reversedBankChequeTransQuery))
                    {
                        custVendTrans = custVendTrans.CustVendTrans::getFromQuery(reversedBankChequeTransQuery);
                    }

                    custVendSettlement = custVendSettlement.CustVendSettlement::getFromQuery(reversedBankChequeTransQuery);

                    this.progressUpdate(strFmt(
                        "@SYS27234",
                        custVendTrans.AccountNum,
                        custVendTrans.Voucher,
                        custVendTrans.CurrencyCode));

                    select forupdate custVendTransOpen
                        where custVendTransOpen.RefRecId == custVendTrans.RecId;

                    this.exchAdjustSettlement();

                    reversedBankChequeQueryProcessed++;

                    progressLogger.trackProgress(reversedBankChequeQueryProcessed);
                }
            }

            if (this.getModule() == ModuleCustVend::Cust)
            {
                // Run on reversed bank deposit transactions
                QueryRun reversedBankDepositTransQuery = new QueryRun(this.createBankDepositCancelTransQuery(_queryRun.query()));

                reversedBankDepositQueryCount = QueryRun::getQueryRowCount(reversedBankDepositTransQuery.query(), intMax());
                Counter reversedBankDepositQueryProcessed;

                progressStage = progressLogger.createStage(CustVendInstrumentationConstants::ForeignCurrencyRevaluationRevalueReversedSettledTrans, reversedBankDepositQueryCount);

                using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextWithProgressMonitor(progressStage))
                {
                    while (reversedBankDepositTransQuery.next())
                    {
                        if (custVendTrans.CustVendTrans::hasChangedInQuery(reversedBankDepositTransQuery))
                        {
                            custVendTrans = custVendTrans.CustVendTrans::getFromQuery(reversedBankDepositTransQuery);
                        }

                        custVendSettlement = custVendSettlement.CustVendSettlement::getFromQuery(reversedBankDepositTransQuery);

                        this.progressUpdate(strFmt(
                            "@SYS27234",
                            custVendTrans.AccountNum,
                            custVendTrans.Voucher,
                            custVendTrans.CurrencyCode));

                        select forupdate custVendTransOpen
                            where custVendTransOpen.RefRecId == custVendTrans.RecId;

                        this.exchAdjustSettlement();

                        reversedBankDepositQueryProcessed++;

                        progressLogger.trackProgress(reversedBankDepositQueryProcessed);
                    }
                }
            }

            // Run on open transactions.
            QueryRun openTransQuery = new QueryRun(this.createOpenTransQuery(_queryRun.query()));
            openInvoiceQueryCount = QueryRun::getQueryRowCount(openTransQuery.query(), intMax());

            if (countryRegion_RUCZ)
            {
                this.processOpenTransactions_W(openTransQuery, custVendExchAdjustment_W);
            }
            else
            {
                Counter openInvoicesProcessed;

                progressStage = progressLogger.createStage(CustVendInstrumentationConstants::ForeignCurrencyRevaluationRevalueOpenTrans, openInvoiceQueryCount);

                using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextWithProgressMonitor(progressStage))
                {
                    while (openTransQuery.next())
                    {
                        if (custVendTable.CustVendTable::hasChangedInQuery(openTransQuery))
                        {
                            custVendTable = custVendTable.CustVendTable::getFromQuery(openTransQuery);
                        }

                        if (custVendTrans.CustVendTrans::hasChangedInQuery(openTransQuery))
                        {
                            custVendTrans = custVendTrans.CustVendTrans::getFromQuery(openTransQuery);
                            custExchAdjustmentUnrealized = custVendTrans.ExchAdjustmentUnrealized;

                            this.progressUpdate(strFmt(
                                "@SYS27234",
                                custVendTrans.AccountNum,
                                custVendTrans.Voucher,
                                custVendTrans.CurrencyCode));
                        }

                        if (custVendTransOpen.CustVendTransOpen::hasChangedInQuery(openTransQuery))
                        {
                            custVendTransOpen = custVendTransOpen.CustVendTransOpen::getFromQuery(openTransQuery);
                            custVendTransOpen.selectForUpdate(true);
                            this.exchAdjustTrans();
                        }

                        openInvoicesProcessed++;
                        progressLogger.trackProgress(openInvoicesProcessed);
                    }
                }
            }
        }

        using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextForStage(CustVendInstrumentationConstants::ForeignCurrencyRevaluationPostLedgerVoucher))
        {
            if (CustVendExchAdjLedgerPostTelemetryFlight::instance().isEnabled())
            {
                this.startNewTiming(this.stopWatch);
            }

            if (ledgerVoucher)
            {
                ledgerVoucher.end();
            }

            if (CustVendExchAdjLedgerPostTelemetryFlight::instance().isEnabled())
            {
                ledgerPostingElapsedMilliseconds += this.stopTimingAndGetDurationInMs(this.stopWatch);
            }
        }

        int totalTrans = settledInvoiceQueryCount + reversedSettledInvoiceQueryCount + reversedBankChequeQueryCount + reversedBankDepositQueryCount + openInvoiceQueryCount;
        if (totalTrans)
        {
            progressLogger.logInformation(strFmt('Ledger voucher generation takes %1 ms, ledger posting takes %2 ms', ledgerVoucherGenerateElapsedMilliseconds / totalTrans, ledgerPostingElapsedMilliseconds / totalTrans));
        }

        if (countryRegion_RUCZ)
        {
            custVendTransSettlement.post();
        }

        TransactionLog::create(this.transactionLogType(), this.transactionLogTxt());
        this.custVendExchRateAdjustment();

        // The transaction id is used to determine which adjustments need to be printed.
        CreatedTransactionId createdTransactionId = appl.curTransactionId();

        ttscommit;

        return createdTransactionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryRun_W</Name>
				<Source><![CDATA[
    protected QueryRun updateQueryRun_W(QueryRun _queryRun)
    {
        if (CustVendExchAdjTransUpdateQueryWUseOriginalQueryFlight::instance())
        {
            return new QueryRun(_queryRun.pack());
        }
        else
        {
            return this.copyQueryRunTwoRanges_W(_queryRun);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyQueryRunTwoRanges_W</Name>
				<Source><![CDATA[
    private QueryRun copyQueryRunTwoRanges_W(QueryRun _queryRun)
    {
        Query query = new Query();

        TableId custVendTableId = this.custVendTable_W().TableId;
        QueryBuildDataSource dsDestination = query.addDataSource(custVendTableId);
        dsDestination.update(true);
        QueryBuildDataSource dsSource = _queryRun.query().dataSourceTable(custVendTableId);
        this.copyRanges_W(dsSource, dsDestination);

        TableId custVendTransId = CustVendTrans::getEmptyTableBuffer(this.getModule()).TableId;
        dsDestination = dsDestination.addDataSource(custVendTransId);
        dsDestination.relations(true);
        dsDestination.update(true);
        dsSource = _queryRun.query().dataSourceTable(custVendTransId);
        this.copyRanges_W(dsSource, dsDestination);

        return new QueryRun(query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyRanges_W</Name>
				<Source><![CDATA[
    private void copyRanges_W(QueryBuildDataSource _dsSource, QueryBuildDataSource _dsDestination)
    {
        int rangeCount = _dsSource.rangeCount();
        for (int cx = 1; cx <= rangeCount; cx++)
        {
            QueryBuildRange rangeSource = _dsSource.range(cx);
            _dsDestination.addRange(rangeSource.field()).value(rangeSource.value());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static CustVendExchAdjTrans construct(SysModule _module, CustVendExchAdj _custVendExchRate)
    {
        CustVendExchAdjTrans custVendExchAdjTrans;

        switch (_module)
        {
            case SysModule::Cust:
                custVendExchAdjTrans = new CustExchAdjTrans(_custVendExchRate);
                break;

            case SysModule::Vend:
                custVendExchAdjTrans = new VendExchAdjTrans(_custVendExchRate);
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return custVendExchAdjTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>startNewTiming</Name>
				<Source><![CDATA[
    private void startNewTiming(System.Diagnostics.Stopwatch _stopWatch)
    {
        _stopWatch.Reset();
        _stopWatch.Start();
    }

]]></Source>
			</Method>
			<Method>
				<Name>stopTimingAndGetDurationInMs</Name>
				<Source><![CDATA[
    private int stopTimingAndGetDurationInMs(System.Diagnostics.Stopwatch _stopWatch)
    {
        _stopWatch.Stop();
        System.TimeSpan timeSpan = _stopWatch.Elapsed;
        return real2int(timeSpan.TotalMilliseconds);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>