<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BudgetCalculateBalance</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>BudgetCalculateBalance</c> class queries for budget and posted ledger amounts by fiscal
///    period and uses the information to create records in the <c>BudgetTmpBalance</c> temporary table.
/// </summary>
public class BudgetCalculateBalance implements SysPackable
{
    private const str GeneralJournalAccountEntryDataSourceName = 'GeneralJournalAccountEntry_1';
    private const str FiscalCalendarPeriodName = 'FCP';

    DimensionFocusNameTmp   dimensionFocusNameTmp;
    DimensionFocusNameTmp   dimensionFocusNameDescriptionTmp;

    LedgerDimensionBudget   ledgerDimensionBudget;
    BudgetModelId           budgetModelId;
    FiscalCalendarRecId     fiscalCalendarRecId;
    TransDate               startDate;
    TransDate               endDate;
    NoYes                   includeSubModels;
    NoYes                   calculateLedgerAmounts;
    BudgetType              budgetType;
    AllDraftCompleted       budgetTransactionStatusFilterValue;
    NoYes                   filterByBudgetType;
    Name                    dimensionFocus;
    Map                     dimensionNamesAndValues;
    NoYes                   accumulateAmounts;
    CurrentOperationsTax    ledgerCategory;
    Query                   query;
    LedgerDimensionBase     ledgerDimension;

    ApportionmentAmountMST  accumulatedApportionmentAmount;
    boolean                 isApportionmentBudgetEnabled;
    boolean                 isPreliminaryBudgetEnabled;
    BudgetBalancesActualsGroupByType budgetBalancesActualsGroupByType;

    #define.CurrentVersion(2)

    #localmacro.CurrentList
        ledgerDimensionBudget,
        budgetModelId,
        fiscalCalendarRecId,
        startDate,
        endDate,
        includeSubModels,
        calculateLedgerAmounts,
        budgetType,
        filterByBudgetType,
        dimensionFocus,
        accumulateAmounts,
        ledgerCategory,
        accumulatedApportionmentAmount
    #endmacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calculatePeriodBalances</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Queries for budget and ledger account posted amounts by fiscal period.
    /// </summary>
    /// <returns>
    ///    A set of <c>BudgetTmpBalance</c> records, one for each fiscal period.
    /// </returns>
    public BudgetTmpBalance calculatePeriodBalances()
    {
        BudgetTmpBalance revisedBudgetBalances;
        BudgetTmpBalance originalBudgetBalances;
        BudgetTmpBalance apportionmentBudgetBalances;
        BudgetTmpBalance preliminaryBudgetBalances;
        BudgetTmpBalance actualsAndBudgetBalances;

        if (hasTableAccess(tablenum(BudgetModel))
            && hasTableAccess(tablenum(BudgetTransactionHeader))
            && hasTableAccess(tablenum(BudgetTransactionLine))
            && hasTableAccess(tablenum(FiscalCalendar))
            && hasTableAccess(tablenum(FiscalCalendarPeriod))
            && hasTableAccess(tablenum(DimensionHierarchy))
            && hasTableAccess(tablenum(DimensionHierarchyLevel))
            && hasTableAccess(tablenum(DimensionAttributeValue))
            && hasTableAccess(tablenum(DimensionAttributeLevelValue))
            && hasTableAccess(tablenum(DimensionAttributeValueGroupCombination))
            && hasTableAccess(tablenum(Ledger)))
        {
            if (this.parmQuery()
                 && (this.parmStartDate() != dateNull())
                 && (this.parmEndDate() != dateNull())
                 && BudgetTransactionManager::validateDimensionFocus(this.parmDimensionFocus()))
            {
                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    this.initializeForPublicSector();
                }

                // Insert revised budget balances into a BudgetTmpBalance buffer.
                Query queryRevisedBudget = this.getRevisedBudgetQuery();

                QueryBuildDataSource budgetTransactionHeaderDataSource = queryRevisedBudget.dataSourceTable(tablenum(BudgetTransactionHeader));
                QueryBuildDataSource budgetTransactionLineDataSource = queryRevisedBudget.dataSourceTable(tablenum(BudgetTransactionLine));
                QueryBuildDataSource fiscalCalendarPeriodDataSource = queryRevisedBudget.dataSourceTable(tablenum(FiscalCalendarPeriod));

                // Data source unique IDs are used in the field mapping from the source query to the target table.
                int budgetTransactionLineUniqueId = budgetTransactionLineDataSource.uniqueId();
                int fiscalCalendarPeriodUniqueId = fiscalCalendarPeriodDataSource.uniqueId();

                Map insertRecordsetMap = new Map(Types::String, Types::Container);

                this.addDestinationFieldToFieldMapping(
                    insertRecordsetMap,
                    fiscalCalendarPeriodUniqueId,
                    fieldStr(FiscalCalendarPeriod, RecId),
                    fieldStr(BudgetTmpBalance, FiscalCalendarPeriodRecId));

                this.addDestinationFieldToFieldMapping(
                    insertRecordsetMap,
                    budgetTransactionLineUniqueId,
                    'SUM(' + fieldStr(BudgetTransactionLine, AccountingCurrencyAmount) + ')',
                    fieldStr(BudgetTmpBalance, RevisedAmount));

                Query::insert_recordset(revisedBudgetBalances, insertRecordsetMap, queryRevisedBudget);

                //Insert original budget balances into a BudgetTmpBalance buffer.
                Query queryOriginalBudget = this.getOriginalBudgetQuery();

                budgetTransactionLineDataSource = queryOriginalBudget.dataSourceTable(tablenum(BudgetTransactionLine));
                fiscalCalendarPeriodDataSource = queryOriginalBudget.dataSourceTable(tablenum(FiscalCalendarPeriod));

                // Data source unique IDs are used in the field mapping from the source query to the target table.
                budgetTransactionLineUniqueId = budgetTransactionLineDataSource.uniqueId();
                fiscalCalendarPeriodUniqueId = fiscalCalendarPeriodDataSource.uniqueId();

                insertRecordsetMap = new Map(Types::String, Types::Container);

                this.addDestinationFieldToFieldMapping(
                    insertRecordsetMap,
                    fiscalCalendarPeriodUniqueId,
                    fieldStr(FiscalCalendarPeriod, RecId),
                    fieldStr(BudgetTmpBalance, FiscalCalendarPeriodRecId));

                this.addDestinationFieldToFieldMapping(
                    insertRecordsetMap,
                    budgetTransactionLineUniqueId,
                    'SUM(' + fieldStr(BudgetTransactionLine, AccountingCurrencyAmount) + ')',
                    fieldStr(BudgetTmpBalance, OriginalAmount));

                Query::insert_recordset(originalBudgetBalances, insertRecordsetMap, queryOriginalBudget);

                if (isApportionmentBudgetEnabled)
                {
                    // Insert apportionment budget balances into a BudgetTmpBalance buffer.
                    Query queryApportionment = this.getBudgetQueryFilteredByTransType(BudgetTransactionType::Apportionment);

                    budgetTransactionLineDataSource = queryApportionment.dataSourceTable(tablenum(BudgetTransactionLine));
                    fiscalCalendarPeriodDataSource = queryApportionment.dataSourceTable(tablenum(FiscalCalendarPeriod));

                    // Data source unique IDs are used in the field mapping from the source query to the target table.
                    budgetTransactionLineUniqueId = budgetTransactionLineDataSource.uniqueId();
                    fiscalCalendarPeriodUniqueId = fiscalCalendarPeriodDataSource.uniqueId();

                    insertRecordsetMap = new Map(Types::String, Types::Container);

                    this.addDestinationFieldToFieldMapping(
                        insertRecordsetMap,
                        fiscalCalendarPeriodUniqueId,
                        fieldStr(FiscalCalendarPeriod, RecId),
                        fieldStr(BudgetTmpBalance, FiscalCalendarPeriodRecId));

                    this.addDestinationFieldToFieldMapping(
                        insertRecordsetMap,
                        budgetTransactionLineUniqueId,
                        'SUM(' + fieldStr(BudgetTransactionLine, AccountingCurrencyAmount) + ')',
                        fieldStr(BudgetTmpBalance, ApportionmentAmount));

                    Query::insert_recordset(apportionmentBudgetBalances, insertRecordsetMap, queryApportionment);
                }
                else if (isPreliminaryBudgetEnabled)
                {
                    // Insert preliminary budget balances into a BudgetTmpBalance buffer.
                    Query queryPreliminaryBudget = this.getBudgetQueryFilteredByTransType(BudgetTransactionType::PreliminaryBudget);

                    budgetTransactionLineDataSource = queryPreliminaryBudget.dataSourceTable(tablenum(BudgetTransactionLine));
                    fiscalCalendarPeriodDataSource = queryPreliminaryBudget.dataSourceTable(tablenum(FiscalCalendarPeriod));

                    // Data source unique IDs are used in the field mapping from the source query to the target table.
                    budgetTransactionLineUniqueId = budgetTransactionLineDataSource.uniqueId();
                    fiscalCalendarPeriodUniqueId = fiscalCalendarPeriodDataSource.uniqueId();

                    insertRecordsetMap = new Map(Types::String, Types::Container);

                    this.addDestinationFieldToFieldMapping(
                    insertRecordsetMap,
                    fiscalCalendarPeriodUniqueId,
                    fieldStr(FiscalCalendarPeriod, RecId),
                    fieldStr(BudgetTmpBalance, FiscalCalendarPeriodRecId));

                    this.addDestinationFieldToFieldMapping(
                    insertRecordsetMap,
                    budgetTransactionLineUniqueId,
                    'SUM(' + fieldStr(BudgetTransactionLine, AccountingCurrencyAmount) + ')',
                    fieldStr(BudgetTmpBalance, PreliminaryAmount));

                    Query::insert_recordset(preliminaryBudgetBalances, insertRecordsetMap, queryPreliminaryBudget);
                }

                if (calculateLedgerAmounts == NoYes::Yes)
                {
                    // Insert actual ledger balances into a BudgetTmpBalance buffer.
                    Query queryActuals = this.getActualLedgerAmountsQuery();

                    QueryBuildDataSource generalJournalAccountEntryDataSource = queryActuals.dataSourceTable(tableNum(GeneralJournalAccountEntry));
                    fiscalCalendarPeriodDataSource = queryActuals.dataSourceTable(tableNum(FiscalCalendarPeriod));

                    // Data source unique IDs are used in the field mapping from the source query to the target table.
                    int generalJournalAccountEntryUniqueId = generalJournalAccountEntryDataSource.uniqueId();
                    fiscalCalendarPeriodUniqueId = fiscalCalendarPeriodDataSource.uniqueId();

                    insertRecordsetMap = new Map(Types::String, Types::Container);

                    this.addDestinationFieldToFieldMapping(
                    insertRecordsetMap,
                    fiscalCalendarPeriodUniqueId,
                    fieldStr(FiscalCalendarPeriod, RecId),
                    fieldStr(BudgetTmpBalance, FiscalCalendarPeriodRecId));

                    this.addDestinationFieldToFieldMapping(
                    insertRecordsetMap,
                    fiscalCalendarPeriodUniqueId,
                    'MIN(' + fieldStr(FiscalCalendarPeriod, StartDate) + ')',
                    fieldStr(BudgetTmpBalance, Period));

                    this.addDestinationFieldToFieldMapping(
                    insertRecordsetMap,
                    generalJournalAccountEntryUniqueId,
                    'SUM(' + fieldStr(GeneralJournalAccountEntry, AccountingCurrencyAmount) + ')',
                    fieldStr(BudgetTmpBalance, LedgerAmount));

                    Query::insert_recordset(actualsAndBudgetBalances, insertRecordsetMap, queryActuals);
                }

                FiscalCalendarPeriod fiscalCalendarPeriod;

                // Because there might be fiscal calendar periods during which no transactions occurred,
                // insert any fiscal calendar periods that are missing within the given start and end date.
                insert_recordset actualsAndBudgetBalances (Period, FiscalCalendarPeriodRecId)
                    select StartDate, RecId from fiscalCalendarPeriod
                        where fiscalCalendarPeriod.Type == FiscalPeriodType::Operating
                            && fiscalCalendarPeriod.StartDate >= this.parmStartDate()
                            && fiscalCalendarPeriod.EndDate <= this.parmEndDate()
                            && fiscalCalendarPeriod.FiscalCalendar == this.parmFiscalCalendarRecId()
                        notexists join actualsAndBudgetBalances
                            where actualsAndBudgetBalances.FiscalCalendarPeriodRecId == fiscalCalendarPeriod.RecId;

                // Consolidate values into a single table buffer and calculate variance.
                if (isApportionmentBudgetEnabled)
                {
                    update_recordset actualsAndBudgetBalances
                        setting RevisedAmount = revisedBudgetBalances.RevisedAmount,
                                OriginalAmount = originalBudgetBalances.OriginalAmount,
                                ApportionmentAmount = apportionmentBudgetBalances.ApportionmentAmount,
                                Variance = apportionmentBudgetBalances.ApportionmentAmount - actualsAndBudgetBalances.LedgerAmount
                            outer join revisedBudgetBalances
                                where revisedBudgetBalances.FiscalCalendarPeriodRecId == actualsAndBudgetBalances.FiscalCalendarPeriodRecId
                            outer join originalBudgetBalances
                                where originalBudgetBalances.FiscalCalendarPeriodRecId == actualsAndBudgetBalances.FiscalCalendarPeriodRecId
                            outer join apportionmentBudgetBalances
                                where apportionmentBudgetBalances.FiscalCalendarPeriodRecId == actualsAndBudgetBalances.FiscalCalendarPeriodRecId;
                }
                else if (isPreliminaryBudgetEnabled)
                {
                    update_recordset actualsAndBudgetBalances
                        setting RevisedAmount = revisedBudgetBalances.RevisedAmount,
                                OriginalAmount = originalBudgetBalances.OriginalAmount,
                                PreliminaryAmount = preliminaryBudgetBalances.PreliminaryAmount,
                                Variance = revisedBudgetBalances.RevisedAmount - actualsAndBudgetBalances.LedgerAmount
                            outer join revisedBudgetBalances
                                where revisedBudgetBalances.FiscalCalendarPeriodRecId == actualsAndBudgetBalances.FiscalCalendarPeriodRecId
                            outer join originalBudgetBalances
                                where originalBudgetBalances.FiscalCalendarPeriodRecId == actualsAndBudgetBalances.FiscalCalendarPeriodRecId
                            outer join preliminaryBudgetBalances
                                where preliminaryBudgetBalances.FiscalCalendarPeriodRecId == actualsAndBudgetBalances.FiscalCalendarPeriodRecId;
                }
                else
                {
                    update_recordset actualsAndBudgetBalances
                        setting RevisedAmount = revisedBudgetBalances.RevisedAmount,
                                OriginalAmount = originalBudgetBalances.OriginalAmount,
                                Variance = revisedBudgetBalances.RevisedAmount - actualsAndBudgetBalances.LedgerAmount
                            outer join revisedBudgetBalances
                                where revisedBudgetBalances.FiscalCalendarPeriodRecId == actualsAndBudgetBalances.FiscalCalendarPeriodRecId
                            outer join originalBudgetBalances
                                where originalBudgetBalances.FiscalCalendarPeriodRecId == actualsAndBudgetBalances.FiscalCalendarPeriodRecId;
                }

                // Update the value for percent of budget.
                if (isApportionmentBudgetEnabled)
                {
                    update_recordset actualsAndBudgetBalances
                        setting PercentOfBudget = actualsAndBudgetBalances.LedgerAmount * 100 / actualsAndBudgetBalances.ApportionmentAmount
                            where actualsAndBudgetBalances.ApportionmentAmount != 0;
                }
                else
                {
                    update_recordset actualsAndBudgetBalances
                        setting PercentOfBudget = actualsAndBudgetBalances.LedgerAmount * 100 / actualsAndBudgetBalances.RevisedAmount
                            where actualsAndBudgetBalances.RevisedAmount != 0;
                }

                // Update the values for accumulated revised budget and accumulated apportionment.
                AmountMST accumulatedRevisedAmount;
                AmountMST accumulatedApportionment;

                while select forupdate actualsAndBudgetBalances order by actualsAndBudgetBalances.Period
                {
                    accumulatedApportionment += actualsAndBudgetBalances.ApportionmentAmount;
                    accumulatedRevisedAmount += actualsAndBudgetBalances.RevisedAmount;

                    ttsbegin;

                    actualsAndBudgetBalances.AccumlatedRevisedAmount = accumulatedRevisedAmount;
                    actualsAndBudgetBalances.AccumulatedApportionment = accumulatedApportionment;
                    actualsAndBudgetBalances.update();

                    ttscommit;
                }

                // Flip the sign of revisedAmount and ledgerAmount values if budget type is revenue.
                if (this.parmFilterByBudgetType() == NoYes::Yes && this.parmBudgetType() == budgetType::Revenue)
                {
					update_recordset actualsAndBudgetBalances
						setting OriginalAmount = -1 * actualsAndBudgetBalances.OriginalAmount,
							RevisedAmount = -1 * actualsAndBudgetBalances.RevisedAmount,
							LedgerAmount = -1 * actualsAndBudgetBalances.LedgerAmount,
                            Variance = -1 * actualsAndBudgetBalances.Variance;
				}
            }
        }

        return actualsAndBudgetBalances;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBaseBudgetQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a general query for budget amounts grouped by fiscal calendar period.
    /// Budget transaction types are not filtered.
    /// </summary>
    /// <returns>
    /// The constructed instance of the <c>Query</c> class.
    /// </returns>
    private Query getBaseBudgetQuery()
    {
        // Create a copy of the query to avoid editing the original query.
        Query queryBudget = new Query(this.parmQuery());

        TransDate startDateLocal = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(this.parmFiscalCalendarRecId(), this.parmStartDate(), FiscalPeriodType::Operating).StartDate;

        if (startDateLocal != dateNull())
        {
            // Use period start date when it is available.
            this.parmStartDate(startDateLocal);
        }

        TransDate endDateLocal = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(this.parmFiscalCalendarRecId(), this.parmEndDate(), FiscalPeriodType::Operating).EndDate;

        if (endDateLocal != dateNull())
        {
            // Use period end date when it is available.
            this.parmEndDate(endDateLocal);
        }

        QueryBuildDataSource budgetTransactionHeaderDataSource = queryBudget.dataSourceTable(tablenum(BudgetTransactionHeader));
        QueryBuildDataSource budgetTransactionLineDataSource = queryBudget.dataSourceTable(tablenum(BudgetTransactionLine));

        // The BudgetTransactionLine table's field name 'Date' is a reserved keyword in SQL.
        // To support a range that needs to be applied to this field, join to BudgetTransactionLineView,
        // which exposes the 'Date' field named as 'TransactionDate'.
        QueryBuildDataSource budgetTransactionLineViewDataSource = budgetTransactionLineDataSource.addDataSource(tableNum(BudgetTransactionLineView));
        budgetTransactionLineViewDataSource.relations(false);
        budgetTransactionLineViewDataSource.addLink(fieldNum(BudgetTransactionLine, RecId), fieldNum(BudgetTransactionLineView, RecId));
        budgetTransactionLineViewDataSource.fetchMode(QueryFetchMode::One2One);

        // Ignore any ranges or filters that were set on these fields; set their value now.
        budgetTransactionHeaderDataSource.clearRange(fieldnum(BudgetTransactionHeader, PrimaryLedger));
        queryBudget.clearQueryFilters(budgetTransactionHeaderDataSource, fieldstr(BudgetTransactionHeader, PrimaryLedger));
        budgetTransactionHeaderDataSource.addRange(fieldnum(BudgetTransactionHeader, PrimaryLedger)).value(int642str(Ledger::current()));

        budgetTransactionLineDataSource.clearRange(fieldnum(BudgetTransactionLine, Date));
        queryBudget.clearQueryFilters(budgetTransactionLineDataSource, fieldstr(BudgetTransactionLine, Date));
        budgetTransactionLineDataSource.addRange(fieldnum(BudgetTransactionLine, Date)).value(
            SysQuery::range(this.parmStartDate(), this.parmEndDate()));

        budgetTransactionHeaderDataSource.clearRange(fieldnum(BudgetTransactionHeader, BudgetTransactionType));
        queryBudget.clearQueryFilters(budgetTransactionHeaderDataSource, fieldstr(BudgetTransactionHeader, BudgetTransactionType));

        if (this.parmFilterByBudgetType() == NoYes::Yes)
        {
            queryBudget.dataSourceTable(tablenum(BudgetTransactionLine)).clearRange(fieldnum(BudgetTransactionLine, BudgetType));
            queryBudget.clearQueryFilters(budgetTransactionLineDataSource, fieldstr(BudgetTransactionLine, BudgetType));
            queryBudget.dataSourceTable(tablenum(BudgetTransactionLine)).addRange(fieldnum(BudgetTransactionLine, BudgetType)).value(int2str(enum2int(this.parmBudgetType())));
        }

        QueryFilter queryFilterBudgetModel = queryBudget.findQueryFilter(budgetTransactionHeaderDataSource, fieldstr(BudgetTransactionHeader, BudgetModelId));

        if (!queryFilterBudgetModel || (queryFilterBudgetModel.status() == RangeStatus::Hidden))
        {
            str budgetModelValue;

            if (this.parmIncludeSubModels() == NoYes::Yes)
            {
                // Query using the Budget model and all of its submodels.
                budgetModelValue = BudgetTransactionManager::getAllSubModelsForQueryRange(this.parmBudgetModelId());
            }
            else
            {
                // Query using only the current Budget model.
                budgetModelValue = SysQuery::value(this.parmBudgetModelId());
            }

            budgetTransactionHeaderDataSource.addRange(fieldnum(BudgetTransactionHeader, BudgetModelId)).value(budgetModelValue);
        }

        QueryBuildDataSource fiscalCalendarPeriodDataSource = budgetTransactionLineDataSource.addDataSource(tableNum(FiscalCalendarPeriod), FiscalCalendarPeriodName);
        fiscalCalendarPeriodDataSource.relations(false);
        fiscalCalendarPeriodDataSource.fetchMode(QueryFetchMode::One2One);

        // This range is used to join each BudgetTransactionLineView record to the appropriate FiscalCalendarPeriod
        // record based on the line's transaction date. The BudgetTransactionLine table's field name 'Date' is a reserved
        // keyword in SQL.  BudgetTransactionLineView is used instead, for it exposes the 'Date' field named as 'TransactionDate'.
        QueryBuildRange periodTransactionDateQBR = budgetTransactionLineViewDataSource.addRange(fieldNum(BudgetTransactionLineView, TransactionDate));
        periodTransactionDateQBR.value(
            strFmt('((%1 >= %2.%3) && (%1 <= %2.%4))',
                fieldStr(BudgetTransactionLineView, TransactionDate),
                FiscalCalendarPeriodName,
                fieldStr(FiscalCalendarPeriod, StartDate),
                fieldStr(FiscalCalendarPeriod, EndDate)));

        QueryBuildRange fiscalCalendarPeriodFiscalCalendarQBR = fiscalCalendarPeriodDataSource.addRange(fieldNum(FiscalCalendarPeriod, FiscalCalendar));
        fiscalCalendarPeriodFiscalCalendarQBR.value(queryValue(fiscalCalendarRecId));

        QueryBuildRange fiscalCalendarPeriodTypeQBR = fiscalCalendarPeriodDataSource.addRange(fieldNum(FiscalCalendarPeriod, Type));
        fiscalCalendarPeriodTypeQBR.value(queryValue(FiscalPeriodType::Operating));

        queryBudget.clearGroupBy();
        SysQuery::findOrCreateGroupByField(queryBudget, fiscalCalendarPeriodDataSource, fieldNum(FiscalCalendarPeriod, RecId));

        queryBudget.clearAllFields();

        fiscalCalendarPeriodDataSource.addSelectionField(fieldNum(FiscalCalendarPeriod, RecId));
        budgetTransactionLineDataSource.addSelectionField(fieldNum(BudgetTransactionLine, AccountingCurrencyAmount), SelectionField::Sum);

        return queryBudget;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRevisedBudgetQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a query for revised budget amounts grouped by fiscal calendar period.
    /// </summary>
    /// <returns>
    /// The constructed instance of the <c>Query</c> class.
    /// </returns>
    [Wrappable(true)]
    protected final Query getRevisedBudgetQuery()
    {
        Query queryRevisedBudget = this.getBaseBudgetQuery();

        QueryBuildDataSource budgetTransactionHeaderDataSource = queryRevisedBudget.dataSourceTable(tablenum(BudgetTransactionHeader));

        // Only retrieve budget amounts for budget transaction types that contribute to revised budget.
        if (isPreliminaryBudgetEnabled)
        {
            budgetTransactionHeaderDataSource.addRange(fieldnum(BudgetTransactionHeader, BudgetTransactionType)).value(
                strfmt('(%1 != %2) && (%1 != %3) && (%1 != %4)',
                    fieldstr(BudgetTransactionHeader, BudgetTransactionType),
                    int2str(enum2int(BudgetTransactionType::Encumbrance)),
                    int2str(enum2int(BudgetTransactionType::PreEncumbrance)),
                    int2Str(enum2int(BudgetTransactionType::Apportionment))));
        }
        else
        {
            // Exclude transaction types Encumbrance, PreEncumbrance, Apportionment, and PreliminaryBudget from the query
            budgetTransactionHeaderDataSource.addRange(fieldnum(BudgetTransactionHeader, BudgetTransactionType)).value(
                BudgetCalculateBalance::getBudgetTransactionTypeExpression(false));
        }

        return queryRevisedBudget;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginalBudgetQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a query for original budget amounts grouped by fiscal calendar period.
    /// </summary>
    /// <returns>
    /// The constructed instance of the <c>Query</c> class.
    /// </returns>
    [Wrappable(true)]
    protected final Query getOriginalBudgetQuery()
    {
        Query queryOriginalBudget = this.getBaseBudgetQuery();

        QueryBuildDataSource budgetTransactionHeaderDataSource = queryOriginalBudget.dataSourceTable(tablenum(BudgetTransactionHeader));

        // Only retrieve budget amounts for budget transaction types that contribute to original budget.
        budgetTransactionHeaderDataSource.clearRange(fieldnum(BudgetTransactionHeader, BudgetTransactionType));
        budgetTransactionHeaderDataSource.addRange(fieldnum(BudgetTransactionHeader, BudgetTransactionType)).value(
            strFmt('(%1 == %2) || (%1 == %3) || (%1 == %4) || (%1 == %5) || (%1 == %6) || (%1 == %7)',
                fieldstr(BudgetTransactionHeader, BudgetTransactionType),
                int2str(enum2int(BudgetTransactionType::OriginalBudget)),
                int2str(enum2int(BudgetTransactionType::SalesForecast)),
                int2str(enum2int(BudgetTransactionType::PurchForecast)),
                int2str(enum2int(BudgetTransactionType::Project)),
                int2str(enum2int(BudgetTransactionType::FixedAsset)),
                int2Str(enum2int(BudgetTransactionType::FixedAsset_RU))));

        return queryOriginalBudget;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetQueryFilteredByTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a query for budget amounts filtered to a given <c>BudgetTransactionType</c> base enum value
    /// and grouped by fiscal calendar period.
    /// </summary>
    /// <param name = "_budgetTransactionType">
    /// The <c>BudgetTransactionType</c> base enum value for which budget amounts will be retrieved.
    /// </param>
    /// <returns>
    /// The constructed instance of the <c>Query</c> class.
    /// </returns>
    private Query getBudgetQueryFilteredByTransType(BudgetTransactionType _budgetTransactionType)
    {
        Query queryPreliminaryBudget = this.getBaseBudgetQuery();

        QueryBuildDataSource budgetTransactionHeaderDataSource = queryPreliminaryBudget.dataSourceTable(tablenum(BudgetTransactionHeader));

        budgetTransactionHeaderDataSource.addRange(fieldnum(BudgetTransactionHeader, BudgetTransactionType)).value(
            strFmt('(%1 == %2)',
                fieldstr(BudgetTransactionHeader, BudgetTransactionType),
                int2str(enum2int(_budgetTransactionType))));

        return queryPreliminaryBudget;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualLedgerAmountsQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a query for actual ledger amounts grouped by fiscal calendar period.
    /// </summary>
    /// <returns>
    /// The constructed instance of the <c>Query</c> class.
    /// </returns>
    [Wrappable(true)]
    protected final Query getActualLedgerAmountsQuery()
    {
        DimensionProvider dimensionProvider = new DimensionProvider();
        Query queryActuals = BudgetCalculateBalance::getLedgerAmountQuery(this.parmStartDate(), this.parmEndDate(), this.parmLedgerCategory());

        if (this.parmFilterByBudgetType() == NoYes::Yes)
        {
            BudgetCalculateBalance::addMainAccountDebitCreditProposalRange(queryActuals, this.parmBudgetType());
        }

        // Find the dimension filters from the original query.
        List dimensionFilters = dimensionProvider.getDimensionFiltersFromQuery(query);

        if (!dimensionFilters.empty())
        {
            // There are dimension filters in the original query. Copy these dimension filters to the query for ledger transactions.
            ListEnumerator listEnumerator = dimensionFilters.getEnumerator();
            container dimensionCriteria;

            while (listEnumerator.moveNext())
            {
                dimensionCriteria = listEnumerator.current();

                dimensionProvider.addAttributeFilterToQueryFromFilterCon(
                    queryActuals,
                    GeneralJournalAccountEntryDataSourceName,
                    fieldstr(GeneralJournalAccountEntry, LedgerDimension),
                    dimensionCriteria);
            }
        }

        QueryBuildDataSource generalJournalEntryDataSource = queryActuals.dataSourceTable(tableNum(GeneralJournalEntry));
        QueryBuildDataSource generalJournalAccountEntryDataSource = queryActuals.dataSourceTable(tableNum(GeneralJournalAccountEntry));
        QueryBuildDataSource fiscalCalendarPeriodDataSource = generalJournalEntryDataSource.addDataSource(tableNum(FiscalCalendarPeriod));
        fiscalCalendarPeriodDataSource.fetchMode(QueryFetchMode::One2One);
        fiscalCalendarPeriodDataSource.relations(true);

        QueryBuildRange fiscalCalendarPeriodFiscalCalendarQBR = fiscalCalendarPeriodDataSource.addRange(fieldNum(FiscalCalendarPeriod, FiscalCalendar));
        fiscalCalendarPeriodFiscalCalendarQBR.value(queryValue(fiscalCalendarRecId));

        QueryBuildRange fiscalCalendarPeriodTypeQBR = fiscalCalendarPeriodDataSource.addRange(fieldNum(FiscalCalendarPeriod, Type));
        fiscalCalendarPeriodTypeQBR.value(queryValue(FiscalPeriodType::Operating));

        queryActuals.clearAllFields();
        queryActuals.clearGroupBy();

        SysQuery::findOrCreateGroupByField(queryActuals, fiscalCalendarPeriodDataSource, fieldNum(FiscalCalendarPeriod, RecId));

        fiscalCalendarPeriodDataSource.addSelectionField(fieldNum(FiscalCalendarPeriod, RecId));
        fiscalCalendarPeriodDataSource.addSelectionField(fieldNum(FiscalCalendarPeriod, StartDate), SelectionField::Min);
        generalJournalAccountEntryDataSource.addSelectionField(fieldNum(GeneralJournalAccountEntry, AccountingCurrencyAmount), SelectionField::Sum);

        return queryActuals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateDimensionFocusNameTmpWithBudgetLedgerDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Populates the <c>DimensionFocusNameTmp</c> table with ledger dimension values from budget transaction line entries.
    /// </summary>
    private void populateDimensionFocusNameTmpWithBudgetLedgerDimensions()
    {
        Query budgetLedgerDimensionsQuery = this.createBudgetDimensionsQueryWithRanges();

        DimensionFocusNameTmp::generateFocusNames(dimensionFocusNameTmp, budgetLedgerDimensionsQuery, this.parmDimensionFocus());
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateDimensionFocusNameTmp</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Populates the <c>DimensionFocusNameTmp</c> table with ledger dimension values from budget transaction line entries.
    /// </summary>
    private void populateDimensionFocusNameTmp()
    {
        // Clear the dimensionFocusNameTmp table.
        delete_from dimensionFocusNameTmp;

        // Populate the dimensionFocusNameTmp table with ledger dimension values from budget transaction line entries.
        this.populateDimensionFocusNameTmpWithBudgetLedgerDimensions();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetDimensionsQueryWithRanges</Name>
				<Source><![CDATA[
    private Query createBudgetDimensionsQueryWithRanges()
    {
        Query budgetLedgerDimensionsQuery = new Query(queryStr(BudgetCalculateBalanceBudgetDimensions));

        QueryBuildDataSource budgetTransactionHeaderDS = budgetLedgerDimensionsQuery.dataSourceTable(tableNum(BudgetTransactionHeader));
        QueryBuildDataSource budgetTransactionLineDS = budgetLedgerDimensionsQuery.dataSourceTable(tableNum(BudgetTransactionLine));

        if (budgetTransactionHeaderDS)
        {
            // Add range for budget model and include sub-models filters.
            budgetTransactionHeaderDS.clearRange(fieldNum(BudgetTransactionHeader, BudgetModelId));
            QueryBuildRange budgetModelIdQBR = budgetTransactionHeaderDS.addRange(fieldNum(BudgetTransactionHeader, BudgetModelId));

            if (this.parmBudgetModelId())
            {
                if (this.parmIncludeSubModels())
                {
                    str budgetModelValue = BudgetTransactionManager::getAllSubModelsForQueryRange(this.parmBudgetModelId());
                    budgetModelIdQBR.value(budgetModelValue);
                }
                else
                {
                    budgetModelIdQBR.value(SysQuery::value(this.parmBudgetModelId()));
                }
            }

            // Add range for budget transaction status filter.
            budgetTransactionHeaderDS.clearRange(fieldNum(BudgetTransactionHeader, TransactionStatus));
            QueryBuildRange transactionStatusQBR = budgetTransactionHeaderDS.addRange(fieldNum(BudgetTransactionHeader, TransactionStatus));

            // If allDraftCompleted.selection() == All, clearing the range is enough.
            switch (this.parmBudgetTransactionStatusFilterValue())
            {
                case AllDraftCompleted::Completed:
                    transactionStatusQBR.value(SysQuery::value(BudgetTransactionStatus::Completed));
                    break;

                case AllDraftCompleted::Draft:
                    transactionStatusQBR.value(SysQuery::value(BudgetTransactionStatus::Draft));
                    break;
            }

            // Add range for budget transaction types.
            budgetTransactionHeaderDS.clearRange(fieldNum(BudgetTransactionHeader, BudgetTransactionType));
            QueryBuildRange budgetTransactionTypeQBR = budgetTransactionHeaderDS.addRange(fieldNum(BudgetTransactionHeader, BudgetTransactionType));

            // If any of the public sector budgeting option is enabled, include public sector budget transaction types in the query range.
            if (isApportionmentBudgetEnabled || isPreliminaryBudgetEnabled)
            {
                budgetTransactionTypeQBR.value(BudgetCalculateBalance::getBudgetTransactionTypeExpression());
            }
            else
            {
                budgetTransactionTypeQBR.value(BudgetCalculateBalance::getBudgetTransactionTypeExpression(false));
            }

            // Filter the budget transactions based on the current legal entity.
            budgetTransactionHeaderDS.clearRange(fieldnum(BudgetTransactionHeader, PrimaryLedger));
            BudgetTransactionManager::addPrimaryLedgerRangeToQuery(budgetLedgerDimensionsQuery);
        }

        if (budgetTransactionLineDS)
        {
            // Add range for budget transaction line date.
            budgetTransactionLineDS.clearRange(fieldNum(BudgetTransactionLine, Date));
            QueryBuildRange dateQBR = budgetTransactionLineDS.addRange(fieldNum(BudgetTransactionLine, Date));

            if (this.parmStartDate() || this.parmEndDate())
            {
                dateQBR.value(SysQuery::range(this.parmStartDate(), this.parmEndDate()));
            }
        }

        return budgetLedgerDimensionsQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSourceFieldIdToFieldList</Name>
				<Source><![CDATA[
    private void addSourceFieldIdToFieldList(QueryBuildFieldList _fieldList, FieldId _sourceFieldId)
    {
        _fieldList.addField(_sourceFieldId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDestinationFieldToFieldMapping</Name>
				<Source><![CDATA[
    private void addDestinationFieldToFieldMapping(Map _fieldMapping, int _dataSourceUniqueId, FieldName _sourceFieldName, FieldName _destinationFieldName)
    {
        _fieldMapping.insert(_destinationFieldName, [_dataSourceUniqueId, _sourceFieldName]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateDebitDimensionFocusBalances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populate the budgetTmpBalanceActuals table with actual debit expenditure amounts from dimension focus balance calculation view.
    /// </summary>
    /// <param name = "_dimensionFocusRecId">Focus dimension RecId</param>
    /// <returns></returns>
    protected BudgetTmpBalancesActuals calculateDebitDimensionFocusBalances(RecId _dimensionFocusRecId)
    {
        BudgetTmpBalancesActuals budgetTmpBalancesActualsWithNoMainAccount;
        DimensionFocusBalanceCalculationView dimensionFocusBalanceCalculationView;
        DimensionAttributeValueCombination davc;

        // Get the record where main account is not present.
        insert_recordset budgetTmpBalancesActualsWithNoMainAccount(FocusLedgerDimension, DebitLedgerAmount, GeneralJournalEntry, DimensionFocus)
            select FocusLedgerDimension, AccountingCurrencyAmount, GeneralJournalEntry from dimensionFocusBalanceCalculationView
                join DisplayValue from davc
                    where davc.RecId == dimensionFocusBalanceCalculationView.FocusLedgerDimension
                        && dimensionFocusBalanceCalculationView.FocusDimensionHierarchy == _dimensionFocusRecId
                        && dimensionFocusBalanceCalculationView.Ledger == Ledger::current()
                        && dimensionFocusBalanceCalculationView.PostingLayer == ledgerCategory
                        && dimensionFocusBalanceCalculationView.AccountingDate >= startDate
                        && dimensionFocusBalanceCalculationView.AccountingDate <= endDate
                        && dimensionFocusBalanceCalculationView.FocusLedgerDimension != 0
                        && dimensionFocusBalanceCalculationView.IsCredit == NoYes::No
                        && davc.MainAccount == 0;

        BudgetTmpBalancesActuals budgetTmpBalancesActualsWithMainAccount;
        MainAccount mainAccount;

        // Get any record where main account is present for the GeneralJournalEntry.
        insert_recordset budgetTmpBalancesActualsWithMainAccount(FocusLedgerDimension, DebitLedgerAmount, GeneralJournalEntry, BudgetAccountType)
            select maxof(FocusLedgerDimension), maxof(AccountingCurrencyAmount), GeneralJournalEntry from dimensionFocusBalanceCalculationView
                group by dimensionFocusBalanceCalculationView.GeneralJournalEntry, mainAccount.Type
                where dimensionFocusBalanceCalculationView.AccountingDate >= startDate
                    && dimensionFocusBalanceCalculationView.Ledger == Ledger::current()
                    && dimensionFocusBalanceCalculationView.PostingLayer == ledgerCategory
                    && dimensionFocusBalanceCalculationView.AccountingDate <= endDate
                    && dimensionFocusBalanceCalculationView.FocusLedgerDimension != 0
                    && dimensionFocusBalanceCalculationView.IsCredit == NoYes::No
                join davc
                    where davc.RecId == dimensionFocusBalanceCalculationView.FocusLedgerDimension
                        && davc.MainAccount != 0
                join Type from mainAccount
                    where  mainAccount.RecId == davc.MainAccount;

        BudgetTmpBalancesActuals actualsAndBudgetBalances;

        // Insert the debit record with budget account type.
        insert_recordset actualsAndBudgetBalances (DebitLedgerAmount, FocusLedgerDimension, DimensionFocus, BudgetAccountType)
            select sum(DebitLedgerAmount), maxof(FocusLedgerDimension), DimensionFocus from budgetTmpBalancesActualsWithNoMainAccount
                group by budgetTmpBalancesActualsWithNoMainAccount.DimensionFocus, budgetTmpBalancesActualsWithMainAccount.BudgetAccountType
                join BudgetAccountType from budgetTmpBalancesActualsWithMainAccount
                    where budgetTmpBalancesActualsWithMainAccount.GeneralJournalEntry == budgetTmpBalancesActualsWithNoMainAccount.GeneralJournalEntry;

        // Insert the record where dimensionFocus is blank.
        insert_recordset actualsAndBudgetBalances (DebitLedgerAmount, FocusLedgerDimension, BudgetAccountType)
            select sum(DebitLedgerAmount), maxof(FocusLedgerDimension), BudgetAccountType from budgetTmpBalancesActualsWithMainAccount
                group by budgetTmpBalancesActualsWithMainAccount.BudgetAccountType
                notexists join budgetTmpBalancesActualsWithNoMainAccount
                    where budgetTmpBalancesActualsWithNoMainAccount.GeneralJournalEntry == budgetTmpBalancesActualsWithMainAccount.GeneralJournalEntry;

        return actualsAndBudgetBalances;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateDebitDimensionReportingBalances</Name>
				<Source><![CDATA[
    protected BudgetTmpBalancesActuals calculateDebitDimensionReportingBalances(RecId _dimensionFocusRecId)
    {
        BudgetTmpBalancesActuals budgetTmpBalancesActualsWithNoMainAccount = this.generateBudgetTmpBalancesActualsWithNoMainAccount(_dimensionFocusRecId, NoYes::No);
        BudgetTmpBalancesActuals budgetTmpBalancesActualsWithMainAccount = this.generateBudgetTmpBalancesActualsWithMainAccount(_dimensionFocusRecId, NoYes::No);

        BudgetTmpBalancesActuals actualsAndBudgetBalances;

        // Insert the debit record with budget account type.
        insert_recordset actualsAndBudgetBalances (DebitLedgerAmount, ReportingDimension, DimensionFocus, BudgetAccountType)
            select sum(DebitLedgerAmount), maxof(ReportingDimension), DimensionFocus from budgetTmpBalancesActualsWithNoMainAccount
                group by budgetTmpBalancesActualsWithNoMainAccount.DimensionFocus, budgetTmpBalancesActualsWithMainAccount.BudgetAccountType
                join BudgetAccountType from budgetTmpBalancesActualsWithMainAccount
                    where budgetTmpBalancesActualsWithMainAccount.GeneralJournalEntry == budgetTmpBalancesActualsWithNoMainAccount.GeneralJournalEntry;

        // Insert the record where dimensionFocus is blank.
        insert_recordset actualsAndBudgetBalances (DebitLedgerAmount, ReportingDimension, BudgetAccountType)
            select sum(DebitLedgerAmount), maxof(ReportingDimension), BudgetAccountType from budgetTmpBalancesActualsWithMainAccount
                group by budgetTmpBalancesActualsWithMainAccount.BudgetAccountType
                notexists join budgetTmpBalancesActualsWithNoMainAccount
                    where budgetTmpBalancesActualsWithNoMainAccount.GeneralJournalEntry == budgetTmpBalancesActualsWithMainAccount.GeneralJournalEntry;
        
        return actualsAndBudgetBalances;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateActualsAndBudgetBalancesWithLedgerAmountType</Name>
				<Source><![CDATA[
    private void generateActualsAndBudgetBalancesWithLedgerAmountType(
        BudgetTmpBalancesActuals _actualsAndBudgetBalances,
        DimensionFocusRecId _focusDimensionHierarchy,
        LedgerRecId _currentLedger,
        boolean _isStartDateSet,
        boolean _isEndDateSet)
    {
        GeneralLedgerBalanceReportingDimensionReference reportingDimensionReference;
        GeneralLedgerBalanceReportingDimension reportingDimension;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        FiscalCalendarPeriod fiscalCalendarPeriod;
        MainAccount mainAccount;

        insert_recordset _actualsAndBudgetBalances (ReportingDimension, DimensionFocus, LedgerAmountType)
            select ReportingDimension from reportingDimensionReference
                group by ReportingDimension
                where reportingDimensionReference.FocusDimensionHierarchy == _focusDimensionHierarchy
                    && reportingDimensionReference.ReportingDimension != 0
                join DisplayValue from reportingDimension
                    group by DisplayValue
                    where reportingDimension.RecId == reportingDimensionReference.ReportingDimension
                        && reportingDimension.FocusDimensionHierarchy == reportingDimensionReference.FocusDimensionHierarchy
                join generalJournalAccountEntry
                    where generalJournalAccountEntry.LedgerDimension == reportingDimensionReference.AccountEntryLedgerDimension
                join debitCreditProposal from mainAccount
                    group by debitCreditProposal
                    where mainAccount.RecId == generalJournalAccountEntry.MainAccount
                join generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                        && generalJournalEntry.Ledger == _currentLedger
                        && generalJournalEntry.PostingLayer == ledgerCategory
                        && (!_isStartDateSet || generalJournalEntry.AccountingDate >= startDate)
                        && (!_isEndDateSet || generalJournalEntry.AccountingDate <= endDate)
                join fiscalCalendarPeriod
                    where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod
                        && fiscalCalendarPeriod.Type == FiscalPeriodType::Operating;

        update_recordset _actualsAndBudgetBalances
            setting DebitLedgerAmount = generalJournalAccountEntry.AccountingCurrencyAmount
                join sum(AccountingCurrencyAmount) from generalJournalAccountEntry
                    where generalJournalAccountEntry.IsCredit == NoYes::No
                join reportingDimensionReference
                    where reportingDimensionReference.FocusDimensionHierarchy == _focusDimensionHierarchy
                        && reportingDimensionReference.AccountEntryLedgerDimension == generalJournalAccountEntry.LedgerDimension
                        && reportingDimensionReference.ReportingDimension == _actualsAndBudgetBalances.ReportingDimension
                        && reportingDimensionReference.ReportingDimension != 0
                join reportingDimension
                    where reportingDimension.RecId == reportingDimensionReference.ReportingDimension
                        && reportingDimension.FocusDimensionHierarchy == reportingDimensionReference.FocusDimensionHierarchy
                        && reportingDimension.DisplayValue == _actualsAndBudgetBalances.DimensionFocus
                join generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                        && generalJournalEntry.Ledger == _currentLedger
                        && generalJournalEntry.PostingLayer == ledgerCategory
                        && (!_isStartDateSet || generalJournalEntry.AccountingDate >= startDate)
                        && (!_isEndDateSet || generalJournalEntry.AccountingDate <= endDate)
                join fiscalCalendarPeriod
                    where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod
                        && fiscalCalendarPeriod.Type == FiscalPeriodType::Operating
                join mainAccount
                    where mainAccount.RecId == generalJournalAccountEntry.MainAccount
                        && mainAccount.debitCreditProposal == _actualsAndBudgetBalances.LedgerAmountType;

        update_recordset _actualsAndBudgetBalances
            setting CreditLedgerAmount = generalJournalAccountEntry.AccountingCurrencyAmount
                join sum(AccountingCurrencyAmount) from generalJournalAccountEntry
                    where generalJournalAccountEntry.IsCredit == NoYes::Yes
                join reportingDimensionReference
                    where reportingDimensionReference.FocusDimensionHierarchy == _focusDimensionHierarchy
                        && reportingDimensionReference.AccountEntryLedgerDimension == generalJournalAccountEntry.LedgerDimension
                        && reportingDimensionReference.ReportingDimension == _actualsAndBudgetBalances.ReportingDimension
                        && reportingDimensionReference.ReportingDimension != 0
                join reportingDimension
                    where reportingDimension.RecId == reportingDimensionReference.ReportingDimension
                        && reportingDimension.FocusDimensionHierarchy == reportingDimensionReference.FocusDimensionHierarchy
                        && reportingDimension.DisplayValue == _actualsAndBudgetBalances.DimensionFocus
                join generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                        && generalJournalEntry.Ledger == _currentLedger
                        && generalJournalEntry.PostingLayer == ledgerCategory
                        && (!_isStartDateSet || generalJournalEntry.AccountingDate >= startDate)
                        && (!_isEndDateSet || generalJournalEntry.AccountingDate <= endDate)
                join fiscalCalendarPeriod
                    where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod
                        && fiscalCalendarPeriod.Type == FiscalPeriodType::Operating
                join mainAccount
                    where mainAccount.RecId == generalJournalAccountEntry.MainAccount
                        && mainAccount.debitCreditProposal == _actualsAndBudgetBalances.LedgerAmountType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateActualsAndBudgetBalancesWithBudgetAccountType</Name>
				<Source><![CDATA[
    private void generateActualsAndBudgetBalancesWithBudgetAccountType(
        BudgetTmpBalancesActuals _actualsAndBudgetBalances,
        DimensionFocusRecId _focusDimensionHierarchy,
        LedgerRecId _currentLedger,
        boolean _isStartDateSet,
        boolean _isEndDateSet)
    {
        GeneralLedgerBalanceReportingDimensionReference reportingDimensionReference;
        GeneralLedgerBalanceReportingDimension reportingDimension;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        FiscalCalendarPeriod fiscalCalendarPeriod;
        MainAccount mainAccount;

        insert_recordset _actualsAndBudgetBalances (ReportingDimension, DimensionFocus, BudgetAccountType)
            select ReportingDimension from reportingDimensionReference
                group by ReportingDimension
                where reportingDimensionReference.FocusDimensionHierarchy == _focusDimensionHierarchy
                    && reportingDimensionReference.ReportingDimension != 0
                join DisplayValue from reportingDimension
                    group by DisplayValue
                    where reportingDimension.RecId == reportingDimensionReference.ReportingDimension
                        && reportingDimension.FocusDimensionHierarchy == reportingDimensionReference.FocusDimensionHierarchy
                join generalJournalAccountEntry
                    where generalJournalAccountEntry.LedgerDimension == reportingDimensionReference.AccountEntryLedgerDimension
                join Type from mainAccount
                    group by Type
                    where mainAccount.RecId == generalJournalAccountEntry.MainAccount
                join generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                        && generalJournalEntry.Ledger == _currentLedger
                        && generalJournalEntry.PostingLayer == ledgerCategory
                        && (!_isStartDateSet || generalJournalEntry.AccountingDate >= startDate)
                        && (!_isEndDateSet || generalJournalEntry.AccountingDate <= endDate)
                join fiscalCalendarPeriod
                    where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod
                        && fiscalCalendarPeriod.Type == FiscalPeriodType::Operating;

        update_recordset _actualsAndBudgetBalances
            setting DebitLedgerAmount = generalJournalAccountEntry.AccountingCurrencyAmount
                join sum(AccountingCurrencyAmount) from generalJournalAccountEntry
                    where generalJournalAccountEntry.IsCredit == NoYes::No
                join reportingDimensionReference
                    where reportingDimensionReference.FocusDimensionHierarchy == _focusDimensionHierarchy
                        && reportingDimensionReference.AccountEntryLedgerDimension == generalJournalAccountEntry.LedgerDimension
                        && reportingDimensionReference.ReportingDimension == _actualsAndBudgetBalances.ReportingDimension
                        && reportingDimensionReference.ReportingDimension != 0
                join reportingDimension
                    where reportingDimension.RecId == reportingDimensionReference.ReportingDimension
                        && reportingDimension.FocusDimensionHierarchy == reportingDimensionReference.FocusDimensionHierarchy
                        && reportingDimension.DisplayValue == _actualsAndBudgetBalances.DimensionFocus
                join generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                        && generalJournalEntry.Ledger == _currentLedger
                        && generalJournalEntry.PostingLayer == ledgerCategory
                        && (!_isStartDateSet || generalJournalEntry.AccountingDate >= startDate)
                        && (!_isEndDateSet || generalJournalEntry.AccountingDate <= endDate)
                join fiscalCalendarPeriod
                    where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod
                        && fiscalCalendarPeriod.Type == FiscalPeriodType::Operating
                join mainAccount
                    where mainAccount.RecId == generalJournalAccountEntry.MainAccount
                        && mainAccount.Type == _actualsAndBudgetBalances.BudgetAccountType;

        update_recordset _actualsAndBudgetBalances
            setting CreditLedgerAmount = generalJournalAccountEntry.AccountingCurrencyAmount
                join sum(AccountingCurrencyAmount) from generalJournalAccountEntry
                    where generalJournalAccountEntry.IsCredit == NoYes::Yes
                join reportingDimensionReference
                    where reportingDimensionReference.FocusDimensionHierarchy == _focusDimensionHierarchy
                        && reportingDimensionReference.AccountEntryLedgerDimension == generalJournalAccountEntry.LedgerDimension
                        && reportingDimensionReference.ReportingDimension == _actualsAndBudgetBalances.ReportingDimension
                        && reportingDimensionReference.ReportingDimension != 0
                join reportingDimension
                    where reportingDimension.RecId == reportingDimensionReference.ReportingDimension
                        && reportingDimension.FocusDimensionHierarchy == reportingDimensionReference.FocusDimensionHierarchy
                        && reportingDimension.DisplayValue == _actualsAndBudgetBalances.DimensionFocus
                join generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                        && generalJournalEntry.Ledger == _currentLedger
                        && generalJournalEntry.PostingLayer == ledgerCategory
                        && (!_isStartDateSet || generalJournalEntry.AccountingDate >= startDate)
                        && (!_isEndDateSet || generalJournalEntry.AccountingDate <= endDate)
                join fiscalCalendarPeriod
                    where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod
                        && fiscalCalendarPeriod.Type == FiscalPeriodType::Operating
                join mainAccount
                    where mainAccount.RecId == generalJournalAccountEntry.MainAccount
                        && mainAccount.Type == _actualsAndBudgetBalances.BudgetAccountType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateActualsAndBudgetBalancesWithoutMainAccount</Name>
				<Source><![CDATA[
    private void generateActualsAndBudgetBalancesWithoutMainAccount(
        BudgetTmpBalancesActuals _actualsAndBudgetBalances,
        DimensionFocusRecId _focusDimensionHierarchy,
        LedgerRecId _currentLedger,
        boolean _isStartDateSet,
        boolean _isEndDateSet)
    {
        GeneralLedgerBalanceReportingDimensionReference reportingDimensionReference;
        GeneralLedgerBalanceReportingDimension reportingDimension;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        FiscalCalendarPeriod fiscalCalendarPeriod;

        insert_recordset _actualsAndBudgetBalances (ReportingDimension, DimensionFocus)
            select ReportingDimension from reportingDimensionReference
                group by ReportingDimension
                where reportingDimensionReference.FocusDimensionHierarchy == _focusDimensionHierarchy
                    && reportingDimensionReference.ReportingDimension != 0
                join DisplayValue from reportingDimension
                    group by DisplayValue
                    where reportingDimension.RecId == reportingDimensionReference.ReportingDimension
                        && reportingDimension.FocusDimensionHierarchy == reportingDimensionReference.FocusDimensionHierarchy
                join generalJournalAccountEntry
                    where generalJournalAccountEntry.LedgerDimension == reportingDimensionReference.AccountEntryLedgerDimension
                join generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                        && generalJournalEntry.Ledger == _currentLedger
                        && generalJournalEntry.PostingLayer == ledgerCategory
                        && (!_isStartDateSet || generalJournalEntry.AccountingDate >= startDate)
                        && (!_isEndDateSet || generalJournalEntry.AccountingDate <= endDate)
                join fiscalCalendarPeriod
                    where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod
                        && fiscalCalendarPeriod.Type == FiscalPeriodType::Operating;

        update_recordset _actualsAndBudgetBalances
            setting DebitLedgerAmount = generalJournalAccountEntry.AccountingCurrencyAmount
                join sum(AccountingCurrencyAmount) from generalJournalAccountEntry
                where generalJournalAccountEntry.IsCredit == NoYes::No
                    join reportingDimensionReference
                    where reportingDimensionReference.FocusDimensionHierarchy == _focusDimensionHierarchy
                        && reportingDimensionReference.AccountEntryLedgerDimension == generalJournalAccountEntry.LedgerDimension
                        && reportingDimensionReference.ReportingDimension == _actualsAndBudgetBalances.ReportingDimension
                        && reportingDimensionReference.ReportingDimension != 0
                join reportingDimension
                    where reportingDimension.RecId == reportingDimensionReference.ReportingDimension
                        && reportingDimension.FocusDimensionHierarchy == reportingDimensionReference.FocusDimensionHierarchy
                        && reportingDimension.DisplayValue == _actualsAndBudgetBalances.DimensionFocus
                join generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                        && generalJournalEntry.Ledger == _currentLedger
                        && generalJournalEntry.PostingLayer == ledgerCategory
                        && (!_isStartDateSet || generalJournalEntry.AccountingDate >= startDate)
                        && (!_isEndDateSet || generalJournalEntry.AccountingDate <= endDate)
                join fiscalCalendarPeriod
                    where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod
                        && fiscalCalendarPeriod.Type == FiscalPeriodType::Operating;

        update_recordset _actualsAndBudgetBalances
            setting CreditLedgerAmount = generalJournalAccountEntry.AccountingCurrencyAmount
                join sum(AccountingCurrencyAmount) from generalJournalAccountEntry
                    where generalJournalAccountEntry.IsCredit == NoYes::Yes
                join reportingDimensionReference
                    where reportingDimensionReference.FocusDimensionHierarchy == _focusDimensionHierarchy
                        && reportingDimensionReference.AccountEntryLedgerDimension == generalJournalAccountEntry.LedgerDimension
                        && reportingDimensionReference.ReportingDimension == _actualsAndBudgetBalances.ReportingDimension
                        && reportingDimensionReference.ReportingDimension != 0
                join reportingDimension
                    where reportingDimension.RecId == reportingDimensionReference.ReportingDimension
                        && reportingDimension.FocusDimensionHierarchy == reportingDimensionReference.FocusDimensionHierarchy
                        && reportingDimension.DisplayValue == _actualsAndBudgetBalances.DimensionFocus
                join generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                        && generalJournalEntry.Ledger == _currentLedger
                        && generalJournalEntry.PostingLayer == ledgerCategory
                        && (!_isStartDateSet || generalJournalEntry.AccountingDate >= startDate)
                        && (!_isEndDateSet || generalJournalEntry.AccountingDate <= endDate)
                join fiscalCalendarPeriod
                    where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod
                        && fiscalCalendarPeriod.Type == FiscalPeriodType::Operating;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateBudgetTmpBalancesActualsWithNoMainAccount</Name>
				<Source><![CDATA[
    private BudgetTmpBalancesActuals generateBudgetTmpBalancesActualsWithNoMainAccount(DimensionHierarchyId _dimensionHierarchyId, NoYes _isCredit)
    {
        BudgetTmpBalancesActuals budgetTmpBalancesActualsWithNoMainAccount;

        RefRecId mainAccountDimensionAttributeRecId = DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount);
        if (!DimensionHierarchyLevel::findByDimensionHierarchyAndDimAttribute(_dimensionHierarchyId,mainAccountDimensionAttributeRecId))
        {
            GeneralLedgerBalanceReportingDimensionReference reportingDimensionReference;
            GeneralLedgerBalanceReportingDimension reportingDimension;
            GeneralJournalAccountEntry generalJournalAccountEntry;
            GeneralJournalEntry generalJournalEntry;

            // Get the record where main account is not present.
            if (_isCredit == NoYes::No)
            {
                insert_recordset budgetTmpBalancesActualsWithNoMainAccount(ReportingDimension, DimensionFocus, DebitLedgerAmount, GeneralJournalEntry)
                    select ReportingDimension from reportingDimensionReference
                        group by ReportingDimension
                        where reportingDimensionReference.FocusDimensionHierarchy == _dimensionHierarchyId
                        join DisplayValue from reportingDimension
                            group by DisplayValue
                            where reportingDimension.RecId == reportingDimensionReference.ReportingDimension
                                && reportingDimension.FocusDimensionHierarchy == reportingDimensionReference.FocusDimensionHierarchy
                                && reportingDimensionReference.ReportingDimension != 0
                        join sum(AccountingCurrencyAmount), GeneralJournalEntry from generalJournalAccountEntry
                            group by GeneralJournalEntry
                            where generalJournalAccountEntry.LedgerDimension == reportingDimensionReference.AccountEntryLedgerDimension
                                && generalJournalAccountEntry.IsCredit == _isCredit
                        join generalJournalEntry
                            where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                                && generalJournalEntry.Ledger == Ledger::current()
                                && generalJournalEntry.PostingLayer == ledgerCategory
                                && generalJournalEntry.AccountingDate >= startDate
                                && generalJournalEntry.AccountingDate <= endDate;
            }
            else
            {
                insert_recordset budgetTmpBalancesActualsWithNoMainAccount(ReportingDimension, DimensionFocus, CreditLedgerAmount, GeneralJournalEntry)
                    select ReportingDimension from reportingDimensionReference
                        group by ReportingDimension
                        where reportingDimensionReference.FocusDimensionHierarchy == _dimensionHierarchyId
                        join DisplayValue from reportingDimension
                            group by DisplayValue
                            where reportingDimension.RecId == reportingDimensionReference.ReportingDimension
                                && reportingDimension.FocusDimensionHierarchy == reportingDimensionReference.FocusDimensionHierarchy
                                && reportingDimensionReference.ReportingDimension != 0
                        join sum(AccountingCurrencyAmount), GeneralJournalEntry from generalJournalAccountEntry
                            group by GeneralJournalEntry
                            where generalJournalAccountEntry.LedgerDimension == reportingDimensionReference.AccountEntryLedgerDimension
                                && generalJournalAccountEntry.IsCredit == _isCredit
                        join generalJournalEntry
                            where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                                && generalJournalEntry.Ledger == Ledger::current()
                                && generalJournalEntry.PostingLayer == ledgerCategory
                                && generalJournalEntry.AccountingDate >= startDate
                                && generalJournalEntry.AccountingDate <= endDate;
            }
        }

        return budgetTmpBalancesActualsWithNoMainAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateBudgetTmpBalancesActualsWithMainAccount</Name>
				<Source><![CDATA[
    private BudgetTmpBalancesActuals generateBudgetTmpBalancesActualsWithMainAccount(DimensionHierarchyId _dimensionHierarchyId, NoYes _isCredit)
    {
        BudgetTmpBalancesActuals budgetTmpBalancesActualsWithMainAccount;

        DimensionHierarchyRecIdTmp dimensionHierarchyRecIdTmp = this.getDimensionHierarchyWithMainAccount();

        GeneralLedgerBalanceReportingDimensionReference reportingDimensionReference;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        MainAccount mainAccount;

        // Get any record where main account is present for the GeneralJournalEntry.
        if (_isCredit == NoYes::No)
        {
            insert_recordset budgetTmpBalancesActualsWithMainAccount(ReportingDimension, DebitLedgerAmount, GeneralJournalEntry, BudgetAccountType)
                select maxof(ReportingDimension) from reportingDimensionReference
                    //group by ReportingDimension
                    where reportingDimensionReference.ReportingDimension != 0
                    join maxof(AccountingCurrencyAmount), GeneralJournalEntry from generalJournalAccountEntry
                        group by GeneralJournalEntry
                        where generalJournalAccountEntry.LedgerDimension == reportingDimensionReference.AccountEntryLedgerDimension
                            && generalJournalAccountEntry.IsCredit == _isCredit
                            && generalJournalAccountEntry.MainAccount != 0
                    join generalJournalEntry
                        where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                            && generalJournalEntry.Ledger == Ledger::current()
                            && generalJournalEntry.PostingLayer == ledgerCategory
                            && generalJournalEntry.AccountingDate >= startDate
                            && generalJournalEntry.AccountingDate <= endDate
                    join Type from mainAccount
                        group by Type
                        where  mainAccount.RecId == generalJournalAccountEntry.MainAccount
                    exists join dimensionHierarchyRecIdTmp
                        where dimensionHierarchyRecIdTmp.RecordId == reportingDimensionReference.FocusDimensionHierarchy;
        }
        else
        {
            insert_recordset budgetTmpBalancesActualsWithMainAccount(ReportingDimension, CreditLedgerAmount, GeneralJournalEntry, BudgetAccountType)
                select maxof(ReportingDimension) from reportingDimensionReference
                    //group by ReportingDimension
                    where reportingDimensionReference.ReportingDimension != 0
                    join maxof(AccountingCurrencyAmount), GeneralJournalEntry from generalJournalAccountEntry
                        group by GeneralJournalEntry
                        where generalJournalAccountEntry.LedgerDimension == reportingDimensionReference.AccountEntryLedgerDimension
                            && generalJournalAccountEntry.IsCredit == _isCredit
                            && generalJournalAccountEntry.MainAccount != 0
                    join generalJournalEntry
                        where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                            && generalJournalEntry.Ledger == Ledger::current()
                            && generalJournalEntry.PostingLayer == ledgerCategory
                            && generalJournalEntry.AccountingDate >= startDate
                            && generalJournalEntry.AccountingDate <= endDate
                    join Type from mainAccount
                        group by Type
                        where  mainAccount.RecId == generalJournalAccountEntry.MainAccount
                    exists join dimensionHierarchyRecIdTmp
                        where dimensionHierarchyRecIdTmp.RecordId == reportingDimensionReference.FocusDimensionHierarchy;
        }

        return budgetTmpBalancesActualsWithMainAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimensionHierarchyWithMainAccount</Name>
				<Source><![CDATA[
    private DimensionHierarchyRecIdTmp getDimensionHierarchyWithMainAccount()
    {
        RefRecId mainAccountDimensionAttributeRecId = DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount);
        GeneralLedgerBalanceReportingDimension reportingDimension;
        DimensionHierarchyRecIdTmp dimensionHierarchyRecIdTmp;

        while select FocusDimensionHierarchy from reportingDimension
            group by FocusDimensionHierarchy
        {
            if (DimensionHierarchyLevel::findByDimensionHierarchyAndDimAttribute(
                    reportingDimension.FocusDimensionHierarchy,mainAccountDimensionAttributeRecId))
            {
                dimensionHierarchyRecIdTmp.RecordId = reportingDimension.FocusDimensionHierarchy;
                dimensionHierarchyRecIdTmp.insert();
            }
        }

        return dimensionHierarchyRecIdTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateCreditDimensionFocusBalances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populate the budgetTmpBalanceActuals table with actual credit expenditure amounts from dimension focus balance calculation view.
    /// </summary>
    /// <param name = "_dimensionFocusRecId">Focus dimension recid</param>
    /// <returns></returns>
    protected BudgetTmpBalancesActuals calculateCreditDimensionFocusBalances(RecId _dimensionFocusRecId)
    {
        BudgetTmpBalancesActuals budgetTmpBalancesActualsWithNoMainAccount;
        DimensionFocusBalanceCalculationView dimensionFocusBalanceCalculationView;
        DimensionAttributeValueCombination davc;

        // Get the record where main account is not present.
        insert_recordset budgetTmpBalancesActualsWithNoMainAccount(FocusLedgerDimension, CreditLedgerAmount, GeneralJournalEntry, DimensionFocus)
            select FocusLedgerDimension, AccountingCurrencyAmount, GeneralJournalEntry from dimensionFocusBalanceCalculationView
                join DisplayValue from davc
                    where davc.RecId == dimensionFocusBalanceCalculationView.FocusLedgerDimension
                        && dimensionFocusBalanceCalculationView.FocusDimensionHierarchy == _dimensionFocusRecId
                        && dimensionFocusBalanceCalculationView.Ledger == Ledger::current()
                        && dimensionFocusBalanceCalculationView.PostingLayer == ledgerCategory
                        && dimensionFocusBalanceCalculationView.AccountingDate >= startDate
                        && dimensionFocusBalanceCalculationView.AccountingDate <= endDate
                        && dimensionFocusBalanceCalculationView.FocusLedgerDimension != 0
                        && dimensionFocusBalanceCalculationView.IsCredit == NoYes::Yes
                        && davc.MainAccount == 0;

        BudgetTmpBalancesActuals budgetTmpBalancesActualsWithMainAccount;
        MainAccount mainAccount;

        // Get any record where main account is present for the GeneralJournalEntry.
        insert_recordset budgetTmpBalancesActualsWithMainAccount(FocusLedgerDimension, CreditLedgerAmount, GeneralJournalEntry, BudgetAccountType)
            select maxof(FocusLedgerDimension), maxof(AccountingCurrencyAmount), GeneralJournalEntry from dimensionFocusBalanceCalculationView
                group by dimensionFocusBalanceCalculationView.GeneralJournalEntry, mainAccount.Type
                where dimensionFocusBalanceCalculationView.AccountingDate >= startDate
                    && dimensionFocusBalanceCalculationView.Ledger == Ledger::current()
                    && dimensionFocusBalanceCalculationView.PostingLayer == ledgerCategory
                    && dimensionFocusBalanceCalculationView.AccountingDate <= endDate
                    && dimensionFocusBalanceCalculationView.FocusLedgerDimension != 0
                    && dimensionFocusBalanceCalculationView.IsCredit == NoYes::Yes
                join davc
                    where davc.RecId == dimensionFocusBalanceCalculationView.FocusLedgerDimension
                        && davc.MainAccount != 0
                join Type from mainAccount
                    where  mainAccount.RecId == davc.MainAccount;

        BudgetTmpBalancesActuals actualsAndBudgetBalances;

        // Insert the credit record with budget account type.
        insert_recordset actualsAndBudgetBalances (CreditLedgerAmount, FocusLedgerDimension, DimensionFocus, BudgetAccountType)
            select sum(CreditLedgerAmount), maxof(FocusLedgerDimension), DimensionFocus from budgetTmpBalancesActualsWithNoMainAccount
                group by budgetTmpBalancesActualsWithNoMainAccount.DimensionFocus, budgetTmpBalancesActualsWithMainAccount.BudgetAccountType
                join BudgetAccountType from budgetTmpBalancesActualsWithMainAccount
                    where budgetTmpBalancesActualsWithMainAccount.GeneralJournalEntry == budgetTmpBalancesActualsWithNoMainAccount.GeneralJournalEntry;

        // Insert the record where dimensionFocus is blank.
        insert_recordset actualsAndBudgetBalances (CreditLedgerAmount, FocusLedgerDimension, BudgetAccountType)
            select sum(CreditLedgerAmount), maxof(FocusLedgerDimension), BudgetAccountType from budgetTmpBalancesActualsWithMainAccount
                group by budgetTmpBalancesActualsWithMainAccount.BudgetAccountType
                notexists join budgetTmpBalancesActualsWithNoMainAccount
                    where budgetTmpBalancesActualsWithNoMainAccount.GeneralJournalEntry == budgetTmpBalancesActualsWithMainAccount.GeneralJournalEntry;

        return actualsAndBudgetBalances;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateCreditDimensionReportingBalances</Name>
				<Source><![CDATA[
    protected BudgetTmpBalancesActuals calculateCreditDimensionReportingBalances(RecId _dimensionFocusRecId)
    {
        BudgetTmpBalancesActuals budgetTmpBalancesActualsWithNoMainAccount = this.generateBudgetTmpBalancesActualsWithNoMainAccount(_dimensionFocusRecId, NoYes::Yes);
        BudgetTmpBalancesActuals budgetTmpBalancesActualsWithMainAccount = this.generateBudgetTmpBalancesActualsWithMainAccount(_dimensionFocusRecId, NoYes::Yes);

        BudgetTmpBalancesActuals actualsAndBudgetBalances;

        // Insert the credit record with budget account type.
        insert_recordset actualsAndBudgetBalances (CreditLedgerAmount, ReportingDimension, DimensionFocus, BudgetAccountType)
            select sum(CreditLedgerAmount), maxof(ReportingDimension), DimensionFocus from budgetTmpBalancesActualsWithNoMainAccount
                group by budgetTmpBalancesActualsWithNoMainAccount.DimensionFocus, budgetTmpBalancesActualsWithMainAccount.BudgetAccountType
                join BudgetAccountType from budgetTmpBalancesActualsWithMainAccount
                    where budgetTmpBalancesActualsWithMainAccount.GeneralJournalEntry == budgetTmpBalancesActualsWithNoMainAccount.GeneralJournalEntry;

        // Insert the record where dimensionFocus is blank.
        insert_recordset actualsAndBudgetBalances (CreditLedgerAmount, ReportingDimension, BudgetAccountType)
            select sum(CreditLedgerAmount), maxof(ReportingDimension), BudgetAccountType from budgetTmpBalancesActualsWithMainAccount
                group by budgetTmpBalancesActualsWithMainAccount.BudgetAccountType
                notexists join budgetTmpBalancesActualsWithNoMainAccount
                    where budgetTmpBalancesActualsWithNoMainAccount.GeneralJournalEntry == budgetTmpBalancesActualsWithMainAccount.GeneralJournalEntry;

        return actualsAndBudgetBalances;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateDimensionFocusBalances</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the budget and posted ledger amounts by dimension focus.
    /// </summary>
    /// <param name = "_updateEmptyFocusLedgerDimension">
    ///   Update empty focus ledger dimension fields; optional.
    /// </param>
    /// <returns>
    ///    A set of <c>BudgetTmpBalancesActuals</c> records.
    /// </returns>
    /// <remarks>
    ///    This method will create one record per dimension focus value combination.
    /// </remarks>
    public BudgetTmpBalancesActuals calculateDimensionFocusBalances(boolean _updateEmptyFocusLedgerDimension = false)
    {
        if (FeatureStateProvider::IsFeatureEnabled(GeneralLedgerBalanceFeature::instance()))
        {
            return this.calculateDimensionReportingBalances(_updateEmptyFocusLedgerDimension);
        }

        BudgetTmpBalancesActuals           budgetBalances;
        BudgetTmpBalancesActuals           actualsAndBudgetBalances;
        BudgetTmpBalancesActuals           apportionmentBudgetBalances;
        BudgetTmpBalancesActuals           preliminaryBudgetBalances;
        BudgetTransactionLine              budgetTransactionLine;
        BudgetTransactionHeader            budgetTransactionHeader;
        BudgetModel                        budgetModel;
        DimensionFocusBalance              dimensionFocusBalance;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        MainAccount                        mainAccount;
        RefRecId                           mainAccountDimensionAttributeRecId;

        if (this.parmDimensionFocus())
        {
            boolean                    isBudgetModelIdSet      = this.parmBudgetModelId() != '';
            boolean                    isIncludeSubModelsSet   = this.parmIncludeSubModels() == NoYes::Yes;
            boolean                    isStartDateSet          = this.parmStartDate() != dateNull();
            boolean                    isEndDateSet            = this.parmEndDate() != dateNull();

            LedgerRecId                currentLedger           = Ledger::current();

            boolean                    isTransactionStatusSet;
            BudgetTransactionStatus    budgetTransactionStatus;

            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
            {
                this.initializeForPublicSector();
            }

            if (this.parmBudgetTransactionStatusFilterValue())
            {
                switch (this.parmBudgetTransactionStatusFilterValue())
                {
                    case AllDraftCompleted::Completed:
                        isTransactionStatusSet = true;
                        budgetTransactionStatus = BudgetTransactionStatus::Completed;
                        break;

                    case AllDraftCompleted::Draft:
                        isTransactionStatusSet = true;
                        budgetTransactionStatus = BudgetTransactionStatus::Draft;
                        break;
                }
            }

            // Populate the dimensionFocusNameTmp table with ledger dimension values from budget transaction line entries.
            this.populateDimensionFocusNameTmp();

            delete_from dimensionFocusNameDescriptionTmp;

            insert_recordset dimensionFocusNameDescriptionTmp (LedgerDimension, FocusValue)
                select LedgerDimension, FocusValue from dimensionFocusNameTmp;

            DimensionFocusNameTmp::generateFocusDescriptions(
                dimensionFocusNameDescriptionTmp,
                this.parmDimensionFocus(),
                new Connection());

            // Populate the budgetTmpBalanceActuals table with revised budget amount from budget transaction line entries.
            if (budgetBalancesActualsGroupByType == BudgetBalancesActualsGroupByType::AmountType)
            {
                insert_recordset budgetBalances (DimensionFocus, DimensionFocusName, RevisedAmount, BudgetType)
                    select FocusValue from dimensionFocusNameTmp
                        group by dimensionFocusNameTmp.FocusValue, dimensionFocusNameDescriptionTmp.FocusValue
                        join FocusValue from dimensionFocusNameDescriptionTmp
                            where dimensionFocusNameDescriptionTmp.LedgerDimension == dimensionFocusNameTmp.LedgerDimension
                        join sum(AccountingCurrencyAmount), budgetType from budgetTransactionLine
                            group by budgetType
                            where budgetTransactionLine.LedgerDimension == dimensionFocusNameTmp.LedgerDimension
                                && (!isStartDateSet || budgetTransactionLine.Date >= startDate)
                                && (!isEndDateSet || budgetTransactionLine.Date <= endDate)
                        join budgetTransactionHeader
                            where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                                && budgetTransactionHeader.PrimaryLedger == currentLedger
                                && (!isTransactionStatusSet || budgetTransactionHeader.TransactionStatus == budgetTransactionStatus)
                                && (budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::Encumbrance
                                    && budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::PreEncumbrance
                                    && budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::Apportionment
                                    && (isPreliminaryBudgetEnabled || budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::PreliminaryBudget))
                        join budgetModel
                            where budgetModel.SubModelId == budgetTransactionHeader.BudgetModelId
                                && (!isBudgetModelIdSet || budgetModel.ModelId == budgetModelId)
                                && (isIncludeSubModelsSet || budgetModel.Type == HeadingSub::Heading);

                // Retrieve the apportionment or preliminary budget in BudgetTmpBalancesActuals table buffer in the respective columns.
                if (isApportionmentBudgetEnabled)
                {
                    insert_recordset apportionmentBudgetBalances (DimensionFocus, DimensionFocusName, ApportionmentAmount, BudgetType)
                        select FocusValue from dimensionFocusNameTmp
                            group by dimensionFocusNameTmp.FocusValue, dimensionFocusNameDescriptionTmp.FocusValue
                            join FocusValue from dimensionFocusNameDescriptionTmp
                                where dimensionFocusNameDescriptionTmp.LedgerDimension == dimensionFocusNameTmp.LedgerDimension
                            join sum(AccountingCurrencyAmount), budgetType from budgetTransactionLine
                                group by budgetType
                                where budgetTransactionLine.LedgerDimension == dimensionFocusNameTmp.LedgerDimension
                                    && (!isStartDateSet || budgetTransactionLine.Date >= startDate)
                                    && (!isEndDateSet || budgetTransactionLine.Date <= endDate)
                            join budgetTransactionHeader
                                where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                                    && budgetTransactionHeader.PrimaryLedger == currentLedger
                                    && (!isTransactionStatusSet || budgetTransactionHeader.TransactionStatus == budgetTransactionStatus)
                                    && budgetTransactionHeader.BudgetTransactionType == BudgetTransactionType::Apportionment
                            join budgetModel
                                where budgetModel.SubModelId == budgetTransactionHeader.BudgetModelId
                                    && (!isBudgetModelIdSet || budgetModel.ModelId == budgetModelId)
                                    && (isIncludeSubModelsSet || budgetModel.Type == HeadingSub::Heading);
                }
                else if (isPreliminaryBudgetEnabled)
                {
                    insert_recordset preliminaryBudgetBalances (DimensionFocus, DimensionFocusName, PreliminaryAmount, BudgetType)
                        select FocusValue from dimensionFocusNameTmp
                            group by dimensionFocusNameTmp.FocusValue, dimensionFocusNameDescriptionTmp.FocusValue
                            join FocusValue from dimensionFocusNameDescriptionTmp
                                where dimensionFocusNameDescriptionTmp.LedgerDimension == dimensionFocusNameTmp.LedgerDimension
                            join sum(AccountingCurrencyAmount), budgetType from budgetTransactionLine
                                group by budgetType
                                where budgetTransactionLine.LedgerDimension == dimensionFocusNameTmp.LedgerDimension
                                    && (!isStartDateSet || budgetTransactionLine.Date >= startDate)
                                    && (!isEndDateSet || budgetTransactionLine.Date <= endDate)
                            join budgetTransactionHeader
                                where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                                    && budgetTransactionHeader.PrimaryLedger == currentLedger
                                    && (!isTransactionStatusSet || budgetTransactionHeader.TransactionStatus == budgetTransactionStatus)
                                    && budgetTransactionHeader.BudgetTransactionType == BudgetTransactionType::PreliminaryBudget
                            join budgetModel
                                where budgetModel.SubModelId == budgetTransactionHeader.BudgetModelId
                                    && (!isBudgetModelIdSet || budgetModel.ModelId == budgetModelId)
                                    && (isIncludeSubModelsSet || budgetModel.Type == HeadingSub::Heading);
                }
            }
            else
            {
                // Insert budgeted record which doesn't have main account of type Total.
                insert_recordset budgetBalances (DimensionFocus, DimensionFocusName, RevisedAmount, BudgetAccountType)
                    select FocusValue from dimensionFocusNameTmp
                        group by dimensionFocusNameTmp.FocusValue, dimensionFocusNameDescriptionTmp.FocusValue
                        join FocusValue from dimensionFocusNameDescriptionTmp
                            where dimensionFocusNameDescriptionTmp.LedgerDimension == dimensionFocusNameTmp.LedgerDimension
                        join sum(AccountingCurrencyAmount) from budgetTransactionLine
                            group by mainAccount.Type
                            where budgetTransactionLine.LedgerDimension == dimensionFocusNameTmp.LedgerDimension
                                && (!isStartDateSet || budgetTransactionLine.Date >= startDate)
                                && (!isEndDateSet || budgetTransactionLine.Date <= endDate)
                        join budgetTransactionHeader
                            where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                                && budgetTransactionHeader.PrimaryLedger == currentLedger
                                && (!isTransactionStatusSet || budgetTransactionHeader.TransactionStatus == budgetTransactionStatus)
                                && (budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::Encumbrance
                                    && budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::PreEncumbrance
                                    && budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::Apportionment
                                    && (isPreliminaryBudgetEnabled || budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::PreliminaryBudget))
                        join budgetModel
                            where budgetModel.SubModelId == budgetTransactionHeader.BudgetModelId
                                && (!isBudgetModelIdSet || budgetModel.ModelId == budgetModelId)
                                && (isIncludeSubModelsSet || budgetModel.Type == HeadingSub::Heading)
                        join dimensionAttributeValueCombination
                            where dimensionAttributeValueCombination.RecId == budgetTransactionLine.LedgerDimension
                        join Type from mainAccount
                            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                                && mainAccount.Type != DimensionLedgerAccountType::Total;

                BudgetTmpBalancesActuals budgetBalancesForTotalAccountType;

                // This is the view which has mapping of Total account with the account type from the range the total account has.
                // It selects max of type from all accounts in the range. It only skips the those account in the range which has account type 
                // TOTAL, BLANK AND REPORTING (REPORTING is skipped because we can't create budget with reporting account type).
                BudgetBalancesActualsTotalMainAccountDerivedTypeView budgetBalancesActualsTotalMainAccountDerivedTypeView;

                // Insert budgeted account which has main account of type Total.
                insert_recordset budgetBalancesForTotalAccountType (DimensionFocus, DimensionFocusName, RevisedAmount, BudgetAccountType)
                    select FocusValue from dimensionFocusNameTmp
                        group by dimensionFocusNameTmp.FocusValue, dimensionFocusNameDescriptionTmp.FocusValue
                        join FocusValue from dimensionFocusNameDescriptionTmp
                            where dimensionFocusNameDescriptionTmp.LedgerDimension == dimensionFocusNameTmp.LedgerDimension
                        join sum(AccountingCurrencyAmount) from budgetTransactionLine
                            group by budgetBalancesActualsTotalMainAccountDerivedTypeView.Type
                            where budgetTransactionLine.LedgerDimension == dimensionFocusNameTmp.LedgerDimension
                                && (!isStartDateSet || budgetTransactionLine.Date >= startDate)
                                && (!isEndDateSet || budgetTransactionLine.Date <= endDate)
                        join budgetTransactionHeader
                            where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                                && budgetTransactionHeader.PrimaryLedger == currentLedger
                                && (!isTransactionStatusSet || budgetTransactionHeader.TransactionStatus == budgetTransactionStatus)
                                && (budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::Encumbrance
                                    && budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::PreEncumbrance
                                    && budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::Apportionment
                                    && (isPreliminaryBudgetEnabled || budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::PreliminaryBudget))
                        join budgetModel
                            where budgetModel.SubModelId == budgetTransactionHeader.BudgetModelId
                                && (!isBudgetModelIdSet || budgetModel.ModelId == budgetModelId)
                                && (isIncludeSubModelsSet || budgetModel.Type == HeadingSub::Heading)
                        join dimensionAttributeValueCombination
                            where dimensionAttributeValueCombination.RecId == budgetTransactionLine.LedgerDimension
                        join mainAccount
                            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                                && mainAccount.Type == DimensionLedgerAccountType::Total
                        join Type from budgetBalancesActualsTotalMainAccountDerivedTypeView
                            where budgetBalancesActualsTotalMainAccountDerivedTypeView.MainAccountId == mainAccount.MainAccountId;

                // Add the budgetBalancesForTotalAccountType's revised amount to budgetBalances based on budget account type and dimensionFocus.
                update_recordset budgetBalances
                    setting RevisedAmount = budgetBalances.RevisedAmount + budgetBalancesForTotalAccountType.RevisedAmount
                    join RevisedAmount from budgetBalancesForTotalAccountType
                        where budgetBalancesForTotalAccountType.DimensionFocus == budgetBalances.DimensionFocus
                            && budgetBalancesForTotalAccountType.BudgetAccountType == budgetBalances.BudgetAccountType;

                // Insert the record from budgetBalancesForTotalAccountType which has not been a part of update.
                insert_recordset budgetBalances (DimensionFocus, DimensionFocusName, RevisedAmount, BudgetAccountType)
                    select DimensionFocus, DimensionFocusName, RevisedAmount, BudgetAccountType from budgetBalancesForTotalAccountType
                    notexists join budgetBalances
                        where budgetBalancesForTotalAccountType.DimensionFocus == budgetBalances.DimensionFocus
                            && budgetBalancesForTotalAccountType.BudgetAccountType == budgetBalances.BudgetAccountType;

                // Retrieve the apportionment or preliminary budget in BudgetTmpBalancesActuals table buffer in the respective columns.
                if (isApportionmentBudgetEnabled)
                {
                    insert_recordset apportionmentBudgetBalances (DimensionFocus, DimensionFocusName, ApportionmentAmount, BudgetAccountType)
                        select FocusValue from dimensionFocusNameTmp
                            group by dimensionFocusNameTmp.FocusValue, dimensionFocusNameDescriptionTmp.FocusValue
                            join FocusValue from dimensionFocusNameDescriptionTmp
                                where dimensionFocusNameDescriptionTmp.LedgerDimension == dimensionFocusNameTmp.LedgerDimension
                            join sum(AccountingCurrencyAmount) from budgetTransactionLine
                                group by mainAccount.Type
                                where budgetTransactionLine.LedgerDimension == dimensionFocusNameTmp.LedgerDimension
                                    && (!isStartDateSet || budgetTransactionLine.Date >= startDate)
                                    && (!isEndDateSet || budgetTransactionLine.Date <= endDate)
                            join budgetTransactionHeader
                                where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                                    && budgetTransactionHeader.PrimaryLedger == currentLedger
                                    && (!isTransactionStatusSet || budgetTransactionHeader.TransactionStatus == budgetTransactionStatus)
                                    && budgetTransactionHeader.BudgetTransactionType == BudgetTransactionType::Apportionment
                            join budgetModel
                                where budgetModel.SubModelId == budgetTransactionHeader.BudgetModelId
                                    && (!isBudgetModelIdSet || budgetModel.ModelId == budgetModelId)
                                    && (isIncludeSubModelsSet || budgetModel.Type == HeadingSub::Heading)
                            join dimensionAttributeValueCombination
                                where dimensionAttributeValueCombination.RecId == budgetTransactionLine.LedgerDimension
                            join Type from mainAccount
                                where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                                    && mainAccount.Type != DimensionLedgerAccountType::Total;

                    BudgetTmpBalancesActuals apportionmentBudgetBalancesForTotalAccountType;

                    insert_recordset apportionmentBudgetBalancesForTotalAccountType (DimensionFocus, DimensionFocusName, ApportionmentAmount, BudgetAccountType)
                        select FocusValue from dimensionFocusNameTmp
                            group by dimensionFocusNameTmp.FocusValue, dimensionFocusNameDescriptionTmp.FocusValue
                            join FocusValue from dimensionFocusNameDescriptionTmp
                                where dimensionFocusNameDescriptionTmp.LedgerDimension == dimensionFocusNameTmp.LedgerDimension
                            join sum(AccountingCurrencyAmount) from budgetTransactionLine
                                group by budgetBalancesActualsTotalMainAccountDerivedTypeView.Type
                                where budgetTransactionLine.LedgerDimension == dimensionFocusNameTmp.LedgerDimension
                                    && (!isStartDateSet || budgetTransactionLine.Date >= startDate)
                                    && (!isEndDateSet || budgetTransactionLine.Date <= endDate)
                            join budgetTransactionHeader
                                where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                                    && budgetTransactionHeader.PrimaryLedger == currentLedger
                                    && (!isTransactionStatusSet || budgetTransactionHeader.TransactionStatus == budgetTransactionStatus)
                                    && budgetTransactionHeader.BudgetTransactionType == BudgetTransactionType::Apportionment
                            join budgetModel
                                where budgetModel.SubModelId == budgetTransactionHeader.BudgetModelId
                                    && (!isBudgetModelIdSet || budgetModel.ModelId == budgetModelId)
                                    && (isIncludeSubModelsSet || budgetModel.Type == HeadingSub::Heading)
                            join dimensionAttributeValueCombination
                                where dimensionAttributeValueCombination.RecId == budgetTransactionLine.LedgerDimension
                            join mainAccount
                                where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                                    && mainAccount.Type == DimensionLedgerAccountType::Total
                            join Type from budgetBalancesActualsTotalMainAccountDerivedTypeView
                                where budgetBalancesActualsTotalMainAccountDerivedTypeView.MainAccountId == mainAccount.MainAccountId;

                    // Add the apportionmentBudgetBalancesForTotalAccountType's ApportionmentAmount amount to apportionmentBudgetBalances based on budget account type and dimensionFocus.
                    update_recordset apportionmentBudgetBalances
                        setting ApportionmentAmount = apportionmentBudgetBalances.ApportionmentAmount + apportionmentBudgetBalancesForTotalAccountType.ApportionmentAmount
                    join ApportionmentAmount from apportionmentBudgetBalancesForTotalAccountType
                        where apportionmentBudgetBalancesForTotalAccountType.DimensionFocus == apportionmentBudgetBalances.DimensionFocus
                            && apportionmentBudgetBalancesForTotalAccountType.BudgetAccountType == apportionmentBudgetBalances.BudgetAccountType;

                    // Insert the record from apportionmentBudgetBalancesForTotalAccountType which has not been a part of update.
                    insert_recordset apportionmentBudgetBalances (DimensionFocus, DimensionFocusName, ApportionmentAmount, BudgetAccountType)
                        select DimensionFocus, DimensionFocusName, ApportionmentAmount, BudgetAccountType from apportionmentBudgetBalancesForTotalAccountType
                        notexists join apportionmentBudgetBalances
                            where apportionmentBudgetBalancesForTotalAccountType.DimensionFocus == apportionmentBudgetBalances.DimensionFocus
                                && apportionmentBudgetBalancesForTotalAccountType.BudgetAccountType == apportionmentBudgetBalances.BudgetAccountType;
                }
                else if (isPreliminaryBudgetEnabled)
                {
                    insert_recordset preliminaryBudgetBalances (DimensionFocus, DimensionFocusName, PreliminaryAmount, BudgetAccountType)
                        select FocusValue from dimensionFocusNameTmp
                            group by dimensionFocusNameTmp.FocusValue, dimensionFocusNameDescriptionTmp.FocusValue
                            join FocusValue from dimensionFocusNameDescriptionTmp
                                where dimensionFocusNameDescriptionTmp.LedgerDimension == dimensionFocusNameTmp.LedgerDimension
                            join sum(AccountingCurrencyAmount) from budgetTransactionLine
                                group by mainAccount.Type
                                where budgetTransactionLine.LedgerDimension == dimensionFocusNameTmp.LedgerDimension
                                    && (!isStartDateSet || budgetTransactionLine.Date >= startDate)
                                    && (!isEndDateSet || budgetTransactionLine.Date <= endDate)
                            join budgetTransactionHeader
                                where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                                    && budgetTransactionHeader.PrimaryLedger == currentLedger
                                    && (!isTransactionStatusSet || budgetTransactionHeader.TransactionStatus == budgetTransactionStatus)
                                    && budgetTransactionHeader.BudgetTransactionType == BudgetTransactionType::PreliminaryBudget
                            join budgetModel
                                where budgetModel.SubModelId == budgetTransactionHeader.BudgetModelId
                                    && (!isBudgetModelIdSet || budgetModel.ModelId == budgetModelId)
                                    && (isIncludeSubModelsSet || budgetModel.Type == HeadingSub::Heading)
                            join dimensionAttributeValueCombination
                                where dimensionAttributeValueCombination.RecId == budgetTransactionLine.LedgerDimension
                            join Type from mainAccount
                                where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                                    && mainAccount.Type != DimensionLedgerAccountType::Total;

                    BudgetTmpBalancesActuals preliminaryBudgetBalancesForTotalAccountType;

                    insert_recordset preliminaryBudgetBalancesForTotalAccountType (DimensionFocus, DimensionFocusName, PreliminaryAmount, BudgetAccountType)
                        select FocusValue from dimensionFocusNameTmp
                            group by dimensionFocusNameTmp.FocusValue, dimensionFocusNameDescriptionTmp.FocusValue
                            join FocusValue from dimensionFocusNameDescriptionTmp
                                where dimensionFocusNameDescriptionTmp.LedgerDimension == dimensionFocusNameTmp.LedgerDimension
                            join sum(AccountingCurrencyAmount) from budgetTransactionLine
                                group by budgetBalancesActualsTotalMainAccountDerivedTypeView.Type
                                where budgetTransactionLine.LedgerDimension == dimensionFocusNameTmp.LedgerDimension
                                    && (!isStartDateSet || budgetTransactionLine.Date >= startDate)
                                    && (!isEndDateSet || budgetTransactionLine.Date <= endDate)
                            join budgetTransactionHeader
                                where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                                    && budgetTransactionHeader.PrimaryLedger == currentLedger
                                    && (!isTransactionStatusSet || budgetTransactionHeader.TransactionStatus == budgetTransactionStatus)
                                    && budgetTransactionHeader.BudgetTransactionType == BudgetTransactionType::PreliminaryBudget
                            join budgetModel
                                where budgetModel.SubModelId == budgetTransactionHeader.BudgetModelId
                                    && (!isBudgetModelIdSet || budgetModel.ModelId == budgetModelId)
                                    && (isIncludeSubModelsSet || budgetModel.Type == HeadingSub::Heading)
                            join dimensionAttributeValueCombination
                                where dimensionAttributeValueCombination.RecId == budgetTransactionLine.LedgerDimension
                            join mainAccount
                                where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                                    && mainAccount.Type == DimensionLedgerAccountType::Total
                            join Type from budgetBalancesActualsTotalMainAccountDerivedTypeView
                                where budgetBalancesActualsTotalMainAccountDerivedTypeView.MainAccountId == mainAccount.MainAccountId;

                    // Add the preliminaryBudgetBalancesForTotalAccountType's PreliminaryAmount amount to preliminaryBudgetBalances based on budget account type and dimensionFocus.
                    update_recordset preliminaryBudgetBalances
                        setting PreliminaryAmount = preliminaryBudgetBalances.PreliminaryAmount + preliminaryBudgetBalancesForTotalAccountType.PreliminaryAmount
                        join PreliminaryAmount from preliminaryBudgetBalancesForTotalAccountType
                            where preliminaryBudgetBalancesForTotalAccountType.DimensionFocus == preliminaryBudgetBalances.DimensionFocus
                                && preliminaryBudgetBalancesForTotalAccountType.BudgetAccountType == preliminaryBudgetBalances.BudgetAccountType;

                    // Insert the record from preliminaryBudgetBalancesForTotalAccountType which has not been a part of update.
                    insert_recordset preliminaryBudgetBalances (DimensionFocus, DimensionFocusName, PreliminaryAmount, BudgetAccountType)
                        select DimensionFocus, DimensionFocusName, PreliminaryAmount, BudgetAccountType from preliminaryBudgetBalancesForTotalAccountType
                            notexists join preliminaryBudgetBalances
                                where preliminaryBudgetBalancesForTotalAccountType.DimensionFocus == preliminaryBudgetBalances.DimensionFocus
                                    && preliminaryBudgetBalancesForTotalAccountType.BudgetAccountType == preliminaryBudgetBalances.BudgetAccountType;
                }
            }

            // Update the dimension focus balances.
            DimensionHierarchy focusDimensionHierarchy = DimensionHierarchy::findByTypeAndName(
                DimensionHierarchyType::Focus, this.parmDimensionFocus());

            DimensionFocusUpdateBalance::checkForRebuildBalancesInProgress(true);
            DimensionFocusUpdateBalance::updateBalance(focusDimensionHierarchy, true, true, currentLedger);

            // Populate the budgetTmpBalanceActuals table with actual expenditure amounts from dimension focus balance entries.
            mainAccountDimensionAttributeRecId = DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount);

            if (DimensionHierarchyLevel::findByDimensionHierarchyAndDimAttribute(focusDimensionHierarchy.RecId,mainAccountDimensionAttributeRecId))
            {
                // Group by the main account debit credit proposal to align the values with the budget expense and revenue types.
                if (budgetBalancesActualsGroupByType == BudgetBalancesActualsGroupByType::AmountType)
                {
                    insert_recordset actualsAndBudgetBalances (DebitLedgerAmount, CreditLedgerAmount, FocusLedgerDimension, DimensionFocus, LedgerAmountType)
                        select sum(DebitAccountingCurrencyAmount), sum(CreditAccountingCurrencyAmount), minof(FocusLedgerDimension) from dimensionFocusBalance
                            group by dimensionAttributeValueCombination.DisplayValue
                            where dimensionFocusBalance.FocusDimensionHierarchy == focusDimensionHierarchy.RecId
                                && dimensionFocusBalance.Ledger == currentLedger
                                && dimensionFocusBalance.PostingLayer == ledgerCategory
                                && dimensionFocusBalance.FiscalCalendarPeriodType == FiscalPeriodType::Operating
                                && (!isStartDateSet || dimensionFocusBalance.AccountingDate >= startDate)
                                && (!isEndDateSet || dimensionFocusBalance.AccountingDate <= endDate)
                            join DisplayValue from dimensionAttributeValueCombination
                                where dimensionAttributeValueCombination.RecId == dimensionFocusBalance.FocusLedgerDimension
                            join debitCreditProposal from mainAccount
                                group by debitCreditProposal
                                where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount;
                }
                else
                {
                    insert_recordset actualsAndBudgetBalances (DebitLedgerAmount, CreditLedgerAmount, FocusLedgerDimension, DimensionFocus, BudgetAccountType)
                        select sum(DebitAccountingCurrencyAmount), sum(CreditAccountingCurrencyAmount), minof(FocusLedgerDimension) from dimensionFocusBalance
                            group by dimensionAttributeValueCombination.DisplayValue
                            where dimensionFocusBalance.FocusDimensionHierarchy == focusDimensionHierarchy.RecId
                                && dimensionFocusBalance.Ledger == currentLedger
                                && dimensionFocusBalance.PostingLayer == ledgerCategory
                                && dimensionFocusBalance.FiscalCalendarPeriodType == FiscalPeriodType::Operating
                                && (!isStartDateSet || dimensionFocusBalance.AccountingDate >= startDate)
                                && (!isEndDateSet || dimensionFocusBalance.AccountingDate <= endDate)
                            join DisplayValue from dimensionAttributeValueCombination
                                where dimensionAttributeValueCombination.RecId == dimensionFocusBalance.FocusLedgerDimension
                            join Type from mainAccount
                                group by Type
                                where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount;
                }
            }
            else
            {
                if (budgetBalancesActualsGroupByType == BudgetBalancesActualsGroupByType::AmountType)
                {
                    insert_recordset actualsAndBudgetBalances (DebitLedgerAmount, CreditLedgerAmount, FocusLedgerDimension, DimensionFocus)
                        select sum(DebitAccountingCurrencyAmount), sum(CreditAccountingCurrencyAmount), minof(FocusLedgerDimension) from dimensionFocusBalance
                            group by dimensionAttributeValueCombination.DisplayValue
                            where dimensionFocusBalance.FocusDimensionHierarchy == focusDimensionHierarchy.RecId
                                && dimensionFocusBalance.Ledger == currentLedger
                                && dimensionFocusBalance.PostingLayer == ledgerCategory
                                && dimensionFocusBalance.FiscalCalendarPeriodType == FiscalPeriodType::Operating
                                && (!isStartDateSet || dimensionFocusBalance.AccountingDate >= startDate)
                                && (!isEndDateSet || dimensionFocusBalance.AccountingDate <= endDate)
                            join DisplayValue from dimensionAttributeValueCombination
                                where dimensionAttributeValueCombination.RecId == dimensionFocusBalance.FocusLedgerDimension;
                }
                else
                {
                    actualsAndBudgetBalances = this.calculateDebitDimensionFocusBalances(focusDimensionHierarchy.RecId);
                    BudgetTmpBalancesActuals actualsAndBudgetBalancesForCreditAmount = this.calculateCreditDimensionFocusBalances(focusDimensionHierarchy.RecId);

                    update_recordset actualsAndBudgetBalances
                        setting CreditLedgerAmount = actualsAndBudgetBalancesForCreditAmount.CreditLedgerAmount
                        join CreditLedgerAmount from actualsAndBudgetBalancesForCreditAmount
                            where actualsAndBudgetBalancesForCreditAmount.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                && actualsAndBudgetBalancesForCreditAmount.BudgetAccountType == actualsAndBudgetBalances.BudgetAccountType;

                    // Populate the budgetTmpBalanceActuals table with non-existing from actualsAndBudgetBalancesForCreditAmount
                    insert_recordset actualsAndBudgetBalances (CreditLedgerAmount, FocusLedgerDimension, DimensionFocus, BudgetAccountType)
                        select CreditLedgerAmount, FocusLedgerDimension, DimensionFocus, BudgetAccountType from actualsAndBudgetBalancesForCreditAmount
                            notexists join actualsAndBudgetBalances
                            where actualsAndBudgetBalances.DimensionFocus == actualsAndBudgetBalancesForCreditAmount.DimensionFocus
                                && actualsAndBudgetBalances.BudgetAccountType == actualsAndBudgetBalancesForCreditAmount.BudgetAccountType;
                }
            }

            // Update AmountType in actualsAndBudgetBalances based on LedgerAmountType
            update_recordset actualsAndBudgetBalances
                setting BudgetType = BudgetType::Revenue
                where actualsAndBudgetBalances.LedgerAmountType == DebCredProposal::Credit;

            // Populate the budgetTmpBalanceActuals table with non-existing focus values from budget transactions.
            if (budgetBalancesActualsGroupByType == BudgetBalancesActualsGroupByType::AmountType)
            {
                insert_recordset actualsAndBudgetBalances (DimensionFocus, DimensionFocusName, BudgetType)
                    select DimensionFocus, DimensionFocusName, BudgetType from budgetBalances
                        notexists join actualsAndBudgetBalances
                            where actualsAndBudgetBalances.DimensionFocus == budgetBalances.DimensionFocus
                                && actualsAndBudgetBalances.BudgetType == budgetBalances.BudgetType;

                if (isApportionmentBudgetEnabled)
                {
                    insert_recordset actualsAndBudgetBalances (DimensionFocus, DimensionFocusName, BudgetType)
                        select DimensionFocus, DimensionFocusName, BudgetType from apportionmentBudgetBalances
                            notexists join actualsAndBudgetBalances
                                where actualsAndBudgetBalances.DimensionFocus == apportionmentBudgetBalances.DimensionFocus
                                    && actualsAndBudgetBalances.BudgetType == apportionmentBudgetBalances.BudgetType;
                }
                else if (isPreliminaryBudgetEnabled)
                {
                    insert_recordset actualsAndBudgetBalances (DimensionFocus, DimensionFocusName, BudgetType)
                        select DimensionFocus, DimensionFocusName, BudgetType from preliminaryBudgetBalances
                            notexists join actualsAndBudgetBalances
                                where actualsAndBudgetBalances.DimensionFocus == preliminaryBudgetBalances.DimensionFocus
                                    && actualsAndBudgetBalances.BudgetType == preliminaryBudgetBalances.BudgetType;
                }
            }
            else
            {
                insert_recordset actualsAndBudgetBalances (DimensionFocus, DimensionFocusName, BudgetAccountType)
                    select DimensionFocus, DimensionFocusName, BudgetAccountType from budgetBalances
                        notexists join actualsAndBudgetBalances
                            where actualsAndBudgetBalances.DimensionFocus == budgetBalances.DimensionFocus
                                && actualsAndBudgetBalances.BudgetAccountType == budgetBalances.BudgetAccountType;

                if (isApportionmentBudgetEnabled)
                {
                    insert_recordset actualsAndBudgetBalances (DimensionFocus, DimensionFocusName, BudgetAccountType)
                        select DimensionFocus, DimensionFocusName, BudgetAccountType from apportionmentBudgetBalances
                            notexists join actualsAndBudgetBalances
                                where actualsAndBudgetBalances.DimensionFocus == apportionmentBudgetBalances.DimensionFocus
                                    && actualsAndBudgetBalances.BudgetAccountType == apportionmentBudgetBalances.BudgetAccountType;
                }
                else if (isPreliminaryBudgetEnabled)
                {
                    insert_recordset actualsAndBudgetBalances (DimensionFocus, DimensionFocusName, BudgetAccountType)
                        select DimensionFocus, DimensionFocusName, BudgetAccountType from preliminaryBudgetBalances
                            notexists join actualsAndBudgetBalances
                                where actualsAndBudgetBalances.DimensionFocus == preliminaryBudgetBalances.DimensionFocus
                                    && actualsAndBudgetBalances.BudgetAccountType == preliminaryBudgetBalances.BudgetAccountType;
                }
            }

            delete_from dimensionFocusNameDescriptionTmp;
            insert_recordset dimensionFocusNameDescriptionTmp (LedgerDimension, FocusValue)
                select FocusLedgerDimension, DimensionFocus from actualsAndBudgetBalances
                    where actualsAndBudgetBalances.FocusLedgerDimension != 0;

            DimensionFocusNameTmp::generateFocusDescriptions(
                dimensionFocusNameDescriptionTmp,
                this.parmDimensionFocus(),
                new Connection());

            update_recordset actualsAndBudgetBalances
                setting DimensionFocusName = dimensionFocusNameDescriptionTmp.FocusValue
                join FocusValue from dimensionFocusNameDescriptionTmp
                    where dimensionFocusNameDescriptionTmp.LedgerDimension == actualsAndBudgetBalances.FocusLedgerDimension;

            // Update values for ledger amount, revised budget amount and variance in budgetTmpBalance table.
            if (budgetBalancesActualsGroupByType == BudgetBalancesActualsGroupByType::AmountType)
            {
                if (isApportionmentBudgetEnabled)
                {
                    update_recordset actualsAndBudgetBalances
                        setting LedgerAmount = actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount,
                            RevisedAmount = budgetBalances.RevisedAmount,
                            ApportionmentAmount = apportionmentBudgetBalances.ApportionmentAmount,
                            Variance = apportionmentBudgetBalances.ApportionmentAmount - (actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount)
                            outer join budgetBalances
                                where budgetBalances.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                    && budgetBalances.BudgetType == actualsAndBudgetBalances.BudgetType
                            outer join apportionmentBudgetBalances
                                where apportionmentBudgetBalances.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                    && apportionmentBudgetBalances.BudgetType == actualsAndBudgetBalances.BudgetType;

                    update_recordset actualsAndBudgetBalances
                        setting PercentOfBudget = actualsAndBudgetBalances.LedgerAmount * 100 / actualsAndBudgetBalances.ApportionmentAmount
                            where actualsAndBudgetBalances.ApportionmentAmount != 0;
                }
                else if (isPreliminaryBudgetEnabled)
                {
                    update_recordset actualsAndBudgetBalances
                        setting LedgerAmount = actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount,
                            RevisedAmount = budgetBalances.RevisedAmount,
                            PreliminaryAmount = preliminaryBudgetBalances.PreliminaryAmount,
                            Variance = budgetBalances.RevisedAmount - (actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount)
                            outer join budgetBalances
                                where budgetBalances.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                    && budgetBalances.BudgetType == actualsAndBudgetBalances.BudgetType
                            outer join preliminaryBudgetBalances
                                where preliminaryBudgetBalances.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                    && preliminaryBudgetBalances.BudgetType == actualsAndBudgetBalances.BudgetType;
                }
                else
                {
                    update_recordset actualsAndBudgetBalances
                        setting LedgerAmount = actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount,
                            RevisedAmount = budgetBalances.RevisedAmount,
                            Variance = budgetBalances.RevisedAmount - (actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount)
                        outer join budgetBalances
                            where budgetBalances.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                && budgetBalances.BudgetType == actualsAndBudgetBalances.BudgetType;
                }
            }
            else
            {
                if (isApportionmentBudgetEnabled)
                {
                    update_recordset actualsAndBudgetBalances
                        setting LedgerAmount = actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount,
                            RevisedAmount = budgetBalances.RevisedAmount,
                            ApportionmentAmount = apportionmentBudgetBalances.ApportionmentAmount,
                            Variance = apportionmentBudgetBalances.ApportionmentAmount - (actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount)
                            outer join RevisedAmount from budgetBalances
                                where budgetBalances.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                    && budgetBalances.BudgetAccountType == actualsAndBudgetBalances.BudgetAccountType
                            outer join ApportionmentAmount from apportionmentBudgetBalances
                                where apportionmentBudgetBalances.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                    && apportionmentBudgetBalances.BudgetAccountType == actualsAndBudgetBalances.BudgetAccountType;

                    update_recordset actualsAndBudgetBalances
                        setting PercentOfBudget = actualsAndBudgetBalances.LedgerAmount * 100 / actualsAndBudgetBalances.ApportionmentAmount
                            where actualsAndBudgetBalances.ApportionmentAmount != 0;
                }
                else if (isPreliminaryBudgetEnabled)
                {
                    update_recordset actualsAndBudgetBalances
                        setting LedgerAmount = actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount,
                            RevisedAmount = budgetBalances.RevisedAmount,
                            PreliminaryAmount = preliminaryBudgetBalances.PreliminaryAmount,
                            Variance = budgetBalances.RevisedAmount - (actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount)
                            outer join RevisedAmount from budgetBalances
                                where budgetBalances.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                    && budgetBalances.BudgetAccountType == actualsAndBudgetBalances.BudgetAccountType
                            outer join PreliminaryAmount from preliminaryBudgetBalances
                                where preliminaryBudgetBalances.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                    && preliminaryBudgetBalances.BudgetAccountType == actualsAndBudgetBalances.BudgetAccountType;
                }
                else
                {
                    update_recordset actualsAndBudgetBalances
                        setting LedgerAmount = actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount,
                            RevisedAmount = budgetBalances.RevisedAmount,
                            Variance = budgetBalances.RevisedAmount - (actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount)
                        outer join RevisedAmount from budgetBalances
                            where budgetBalances.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                && budgetBalances.BudgetAccountType == actualsAndBudgetBalances.BudgetAccountType;
                }
            }

            if (!isApportionmentBudgetEnabled)
            {
                // Update values for variance percent in budgetTmpBalance table.
                update_recordset actualsAndBudgetBalances
                    setting PercentOfBudget = actualsAndBudgetBalances.LedgerAmount * 100 / actualsAndBudgetBalances.RevisedAmount
                        where actualsAndBudgetBalances.RevisedAmount != 0;
            }

            if (_updateEmptyFocusLedgerDimension)
            {
                this.updateEmptyFocusLedgerDimensions(actualsAndBudgetBalances);
            }

            // Flip the sign of revisedAmount and ledgerAmount values if budget type is revenue.
            update_recordset actualsAndBudgetBalances
                setting RevisedAmount = -1 * actualsAndBudgetBalances.RevisedAmount,
                    LedgerAmount = -1 * actualsAndBudgetBalances.LedgerAmount,
                    Variance = -1 * actualsAndBudgetBalances.Variance
                    where actualsAndBudgetBalances.BudgetType == BudgetType::Revenue;
        }

        return actualsAndBudgetBalances;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateDimensionReportingBalances</Name>
				<Source><![CDATA[
    private BudgetTmpBalancesActuals calculateDimensionReportingBalances(boolean _updateEmptyFocusLedgerDimension = false)
    {
        BudgetTmpBalancesActuals           budgetBalances;
        BudgetTmpBalancesActuals           actualsAndBudgetBalances;
        BudgetTmpBalancesActuals           apportionmentBudgetBalances;
        BudgetTmpBalancesActuals           preliminaryBudgetBalances;
        BudgetTransactionLine              budgetTransactionLine;
        BudgetTransactionHeader            budgetTransactionHeader;
        BudgetModel                        budgetModel;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        MainAccount                        mainAccount;
        RefRecId                           mainAccountDimensionAttributeRecId;
        GeneralLedgerBalanceDimensionDescriptionsTmp balanceDimensionDescriptionsTmp;
  
        if (this.parmDimensionFocus())
        {
            boolean                    isBudgetModelIdSet      = this.parmBudgetModelId() != '';
            boolean                    isIncludeSubModelsSet   = this.parmIncludeSubModels() == NoYes::Yes;
            boolean                    isStartDateSet          = this.parmStartDate() != dateNull();
            boolean                    isEndDateSet            = this.parmEndDate() != dateNull();

            LedgerRecId                currentLedger           = Ledger::current();

            boolean                    isTransactionStatusSet;
            BudgetTransactionStatus    budgetTransactionStatus;

            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
            {
                this.initializeForPublicSector();
            }

            if (this.parmBudgetTransactionStatusFilterValue())
            {
                switch (this.parmBudgetTransactionStatusFilterValue())
                {
                    case AllDraftCompleted::Completed:
                        isTransactionStatusSet = true;
                        budgetTransactionStatus = BudgetTransactionStatus::Completed;
                        break;

                    case AllDraftCompleted::Draft:
                        isTransactionStatusSet = true;
                        budgetTransactionStatus = BudgetTransactionStatus::Draft;
                        break;
                }
            }

            // Update the dimension focus balances.
            DimensionHierarchy focusDimensionHierarchy = DimensionHierarchy::findByTypeAndName(
                DimensionHierarchyType::Focus, this.parmDimensionFocus());

            BudgetBalanceReportingDimensionReference reportingDimensionReference;
            GeneralLedgerBalanceReportingDimension reportingDimension;

            insert_recordset balanceDimensionDescriptionsTmp (ReportingDimension)
                select ReportingDimension from reportingDimensionReference
                    group by ReportingDimension
                    where reportingDimensionReference.FocusDimensionHierarchy == focusDimensionHierarchy.RecId
                    join budgetTransactionLine                        
                        where budgetTransactionLine.LedgerDimension == reportingDimensionReference.BudgetLedgerDimension
                            && (!isStartDateSet || budgetTransactionLine.Date >= startDate)
                            && (!isEndDateSet || budgetTransactionLine.Date <= endDate)
                    join budgetTransactionHeader
                        where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                            && budgetTransactionHeader.PrimaryLedger == currentLedger
                            && (!isTransactionStatusSet || budgetTransactionHeader.TransactionStatus == budgetTransactionStatus)
                            && (budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::Encumbrance
                                && budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::PreEncumbrance
                                && budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::Apportionment
                                && (isPreliminaryBudgetEnabled || budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::PreliminaryBudget))
                    join budgetModel
                        where budgetModel.SubModelId == budgetTransactionHeader.BudgetModelId
                            && (!isBudgetModelIdSet || budgetModel.ModelId == budgetModelId)
                            && (isIncludeSubModelsSet || budgetModel.Type == HeadingSub::Heading);

            GeneralLedgerBalanceDimensionDescriptionsTmp::generateFocusDescriptions(balanceDimensionDescriptionsTmp, focusDimensionHierarchy.Name);
            
            // Populate the budgetTmpBalanceActuals table with revised budget amount from budget transaction line entries.
            if (budgetBalancesActualsGroupByType == BudgetBalancesActualsGroupByType::AmountType)
            {
                insert_recordset budgetBalances (DimensionFocus, DimensionFocusName, RevisedAmount, BudgetType)
                    select DisplayValue from reportingDimension
                        group by reportingDimension.DisplayValue, balanceDimensionDescriptionsTmp.DescriptionDisplayValue
                            where reportingDimension.FocusDimensionHierarchy == focusDimensionHierarchy.RecId
                        join DescriptionDisplayValue from balanceDimensionDescriptionsTmp
                            where balanceDimensionDescriptionsTmp.ReportingDimension == reportingDimension.RecId
                        join reportingDimensionReference
                            where reportingDimensionReference.ReportingDimension == reportingDimension.RecId
                        join sum(AccountingCurrencyAmount), budgetType from budgetTransactionLine
                            group by budgetType
                            where budgetTransactionLine.LedgerDimension == reportingDimensionReference.BudgetLedgerDimension
                                && (!isStartDateSet || budgetTransactionLine.Date >= startDate)
                                && (!isEndDateSet || budgetTransactionLine.Date <= endDate)
                        join budgetTransactionHeader
                            where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                                && budgetTransactionHeader.PrimaryLedger == currentLedger
                                && (!isTransactionStatusSet || budgetTransactionHeader.TransactionStatus == budgetTransactionStatus)
                                && (budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::Encumbrance
                                    && budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::PreEncumbrance
                                    && budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::Apportionment
                                    && (isPreliminaryBudgetEnabled || budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::PreliminaryBudget))
                        join budgetModel
                            where budgetModel.SubModelId == budgetTransactionHeader.BudgetModelId
                                && (!isBudgetModelIdSet || budgetModel.ModelId == budgetModelId)
                                && (isIncludeSubModelsSet || budgetModel.Type == HeadingSub::Heading);

                // Retrieve the apportionment or preliminary budget in BudgetTmpBalancesActuals table buffer in the respective columns.
                if (isApportionmentBudgetEnabled)
                {
                    insert_recordset apportionmentBudgetBalances (DimensionFocus, DimensionFocusName, ApportionmentAmount, BudgetType)
                        select DisplayValue from reportingDimension
                            group by reportingDimension.DisplayValue, balanceDimensionDescriptionsTmp.DescriptionDisplayValue
                                where reportingDimension.FocusDimensionHierarchy == focusDimensionHierarchy.RecId
                            join DescriptionDisplayValue from balanceDimensionDescriptionsTmp
                                where balanceDimensionDescriptionsTmp.ReportingDimension == reportingDimension.RecId
                            join reportingDimensionReference
                                where reportingDimensionReference.ReportingDimension == reportingDimension.RecId
                            join sum(AccountingCurrencyAmount), budgetType from budgetTransactionLine
                                group by budgetType
                                where budgetTransactionLine.LedgerDimension == reportingDimensionReference.BudgetLedgerDimension
                                    && (!isStartDateSet || budgetTransactionLine.Date >= startDate)
                                    && (!isEndDateSet || budgetTransactionLine.Date <= endDate)
                            join budgetTransactionHeader
                                where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                                    && budgetTransactionHeader.PrimaryLedger == currentLedger
                                    && (!isTransactionStatusSet || budgetTransactionHeader.TransactionStatus == budgetTransactionStatus)
                                    && budgetTransactionHeader.BudgetTransactionType == BudgetTransactionType::Apportionment
                            join budgetModel
                                where budgetModel.SubModelId == budgetTransactionHeader.BudgetModelId
                                    && (!isBudgetModelIdSet || budgetModel.ModelId == budgetModelId)
                                    && (isIncludeSubModelsSet || budgetModel.Type == HeadingSub::Heading);
                }
                else if (isPreliminaryBudgetEnabled)
                {
                    insert_recordset preliminaryBudgetBalances (DimensionFocus, DimensionFocusName, PreliminaryAmount, BudgetType)
                        select DisplayValue from reportingDimension
                            group by reportingDimension.DisplayValue, balanceDimensionDescriptionsTmp.DescriptionDisplayValue
                                where reportingDimension.FocusDimensionHierarchy == focusDimensionHierarchy.RecId
                            join DescriptionDisplayValue from balanceDimensionDescriptionsTmp
                                where balanceDimensionDescriptionsTmp.ReportingDimension == reportingDimension.RecId
                            join reportingDimensionReference
                                where reportingDimensionReference.ReportingDimension == reportingDimension.RecId
                            join sum(AccountingCurrencyAmount), budgetType from budgetTransactionLine
                                group by budgetType
                                where budgetTransactionLine.LedgerDimension == reportingDimensionReference.BudgetLedgerDimension
                                    && (!isStartDateSet || budgetTransactionLine.Date >= startDate)
                                    && (!isEndDateSet || budgetTransactionLine.Date <= endDate)
                            join budgetTransactionHeader
                                where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                                    && budgetTransactionHeader.PrimaryLedger == currentLedger
                                    && (!isTransactionStatusSet || budgetTransactionHeader.TransactionStatus == budgetTransactionStatus)
                                    && budgetTransactionHeader.BudgetTransactionType == BudgetTransactionType::PreliminaryBudget
                            join budgetModel
                                where budgetModel.SubModelId == budgetTransactionHeader.BudgetModelId
                                    && (!isBudgetModelIdSet || budgetModel.ModelId == budgetModelId)
                                    && (isIncludeSubModelsSet || budgetModel.Type == HeadingSub::Heading);
                }
            }
            else
            {
                // Insert budgeted record which doesn't have main account of type Total.
                insert_recordset budgetBalances (DimensionFocus, DimensionFocusName, RevisedAmount, BudgetAccountType)
                    select DisplayValue from reportingDimension
                        group by reportingDimension.DisplayValue, balanceDimensionDescriptionsTmp.DescriptionDisplayValue
                            where reportingDimension.FocusDimensionHierarchy == focusDimensionHierarchy.RecId
                        join DescriptionDisplayValue from balanceDimensionDescriptionsTmp
                            where balanceDimensionDescriptionsTmp.ReportingDimension == reportingDimension.RecId
                        join reportingDimensionReference
                            where reportingDimensionReference.ReportingDimension == reportingDimension.RecId
                        join sum(AccountingCurrencyAmount) from budgetTransactionLine
                            where budgetTransactionLine.LedgerDimension == reportingDimensionReference.BudgetLedgerDimension
                                && (!isStartDateSet || budgetTransactionLine.Date >= startDate)
                                && (!isEndDateSet || budgetTransactionLine.Date <= endDate)
                        join budgetTransactionHeader
                            where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                                && budgetTransactionHeader.PrimaryLedger == currentLedger
                                && (!isTransactionStatusSet || budgetTransactionHeader.TransactionStatus == budgetTransactionStatus)
                                && (budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::Encumbrance
                                && budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::PreEncumbrance
                                && budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::Apportionment
                                && (isPreliminaryBudgetEnabled || budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::PreliminaryBudget))
                        join budgetModel
                            where budgetModel.SubModelId == budgetTransactionHeader.BudgetModelId
                                && (!isBudgetModelIdSet || budgetModel.ModelId == budgetModelId)
                                && (isIncludeSubModelsSet || budgetModel.Type == HeadingSub::Heading)
                        join dimensionAttributeValueCombination
                            where dimensionAttributeValueCombination.RecId == budgetTransactionLine.LedgerDimension
                        join Type from mainAccount
                            group by Type
                            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                                && mainAccount.Type != DimensionLedgerAccountType::Total;

                BudgetTmpBalancesActuals budgetBalancesForTotalAccountType;

                // This is the view which has mapping of Total account with the account type from the range the total account has.
                // It selects max of type from all accounts in the range. It only skips the those account in the range which has account type
                // TOTAL, BLANK AND REPORTING (REPORTING is skipped because we can't create budget with reporting account type).
                BudgetBalancesActualsTotalMainAccountDerivedTypeView budgetBalancesActualsTotalMainAccountDerivedTypeView;

                // Insert budgeted account which has main account of type Total.
                insert_recordset budgetBalancesForTotalAccountType (DimensionFocus, DimensionFocusName, RevisedAmount, BudgetAccountType)
                    select DisplayValue from reportingDimension
                        group by reportingDimension.DisplayValue, balanceDimensionDescriptionsTmp.DescriptionDisplayValue
                            where reportingDimension.FocusDimensionHierarchy == focusDimensionHierarchy.RecId
                        join DescriptionDisplayValue from balanceDimensionDescriptionsTmp
                            where balanceDimensionDescriptionsTmp.ReportingDimension == reportingDimension.RecId
                        join reportingDimensionReference
                            where reportingDimensionReference.ReportingDimension == reportingDimension.RecId
                        join sum(AccountingCurrencyAmount) from budgetTransactionLine
                            where budgetTransactionLine.LedgerDimension == reportingDimensionReference.BudgetLedgerDimension
                                && (!isStartDateSet || budgetTransactionLine.Date >= startDate)
                                && (!isEndDateSet || budgetTransactionLine.Date <= endDate)
                        join budgetTransactionHeader
                            where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                                && budgetTransactionHeader.PrimaryLedger == currentLedger
                                && (!isTransactionStatusSet || budgetTransactionHeader.TransactionStatus == budgetTransactionStatus)
                                && (budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::Encumbrance
                                    && budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::PreEncumbrance
                                    && budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::Apportionment
                                    && (isPreliminaryBudgetEnabled || budgetTransactionHeader.BudgetTransactionType != BudgetTransactionType::PreliminaryBudget))
                        join budgetModel
                            where budgetModel.SubModelId == budgetTransactionHeader.BudgetModelId
                                && (!isBudgetModelIdSet || budgetModel.ModelId == budgetModelId)
                                && (isIncludeSubModelsSet || budgetModel.Type == HeadingSub::Heading)
                        join dimensionAttributeValueCombination
                            where dimensionAttributeValueCombination.RecId == budgetTransactionLine.LedgerDimension
                        join mainAccount
                            where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                                && mainAccount.Type == DimensionLedgerAccountType::Total
                        join Type from budgetBalancesActualsTotalMainAccountDerivedTypeView
                            group by Type
                            where budgetBalancesActualsTotalMainAccountDerivedTypeView.MainAccountId == mainAccount.MainAccountId;

                // Add the budgetBalancesForTotalAccountType's revised amount to budgetBalances based on budget account type and dimensionFocus.
                update_recordset budgetBalances
                    setting RevisedAmount = budgetBalances.RevisedAmount + budgetBalancesForTotalAccountType.RevisedAmount
                    join RevisedAmount from budgetBalancesForTotalAccountType
                        where budgetBalancesForTotalAccountType.DimensionFocus == budgetBalances.DimensionFocus
                            && budgetBalancesForTotalAccountType.BudgetAccountType == budgetBalances.BudgetAccountType;

                // Insert the record from budgetBalancesForTotalAccountType which has not been a part of update.
                insert_recordset budgetBalances (DimensionFocus, DimensionFocusName, RevisedAmount, BudgetAccountType)
                    select DimensionFocus, DimensionFocusName, RevisedAmount, BudgetAccountType from budgetBalancesForTotalAccountType
                    notexists join budgetBalances
                        where budgetBalancesForTotalAccountType.DimensionFocus == budgetBalances.DimensionFocus
                            && budgetBalancesForTotalAccountType.BudgetAccountType == budgetBalances.BudgetAccountType;

                // Retrieve the apportionment or preliminary budget in BudgetTmpBalancesActuals table buffer in the respective columns.
                if (isApportionmentBudgetEnabled)
                {
                    insert_recordset apportionmentBudgetBalances (DimensionFocus, DimensionFocusName, ApportionmentAmount, BudgetAccountType)
                        select DisplayValue from reportingDimension
                            group by reportingDimension.DisplayValue, balanceDimensionDescriptionsTmp.DescriptionDisplayValue
                                where reportingDimension.FocusDimensionHierarchy == focusDimensionHierarchy.RecId
                            join DescriptionDisplayValue from balanceDimensionDescriptionsTmp
                                where balanceDimensionDescriptionsTmp.ReportingDimension == reportingDimension.RecId
                            join reportingDimensionReference
                                where reportingDimensionReference.ReportingDimension == reportingDimension.RecId
                            join sum(AccountingCurrencyAmount) from budgetTransactionLine
                                where budgetTransactionLine.LedgerDimension == reportingDimensionReference.BudgetLedgerDimension
                                    && (!isStartDateSet || budgetTransactionLine.Date >= startDate)
                                    && (!isEndDateSet || budgetTransactionLine.Date <= endDate)
                            join budgetTransactionHeader
                                where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                                    && budgetTransactionHeader.PrimaryLedger == currentLedger
                                    && (!isTransactionStatusSet || budgetTransactionHeader.TransactionStatus == budgetTransactionStatus)
                                    && budgetTransactionHeader.BudgetTransactionType == BudgetTransactionType::Apportionment
                            join budgetModel
                                where budgetModel.SubModelId == budgetTransactionHeader.BudgetModelId
                                    && (!isBudgetModelIdSet || budgetModel.ModelId == budgetModelId)
                                    && (isIncludeSubModelsSet || budgetModel.Type == HeadingSub::Heading)
                            join dimensionAttributeValueCombination
                                where dimensionAttributeValueCombination.RecId == budgetTransactionLine.LedgerDimension
                            join Type from mainAccount
                                group by Type
                                where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                                    && mainAccount.Type != DimensionLedgerAccountType::Total;

                    BudgetTmpBalancesActuals apportionmentBudgetBalancesForTotalAccountType;

                    insert_recordset apportionmentBudgetBalancesForTotalAccountType (DimensionFocus, DimensionFocusName, ApportionmentAmount, BudgetAccountType)
                        select DisplayValue from reportingDimension
                            group by reportingDimension.DisplayValue, balanceDimensionDescriptionsTmp.DescriptionDisplayValue
                                where reportingDimension.FocusDimensionHierarchy == focusDimensionHierarchy.RecId
                            join DescriptionDisplayValue from balanceDimensionDescriptionsTmp
                                where balanceDimensionDescriptionsTmp.ReportingDimension == reportingDimension.RecId
                            join reportingDimensionReference
                                where reportingDimensionReference.ReportingDimension == reportingDimension.RecId
                            join sum(AccountingCurrencyAmount) from budgetTransactionLine
                                where budgetTransactionLine.LedgerDimension == reportingDimensionReference.BudgetLedgerDimension
                                    && (!isStartDateSet || budgetTransactionLine.Date >= startDate)
                                    && (!isEndDateSet || budgetTransactionLine.Date <= endDate)
                            join budgetTransactionHeader
                                where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                                    && budgetTransactionHeader.PrimaryLedger == currentLedger
                                    && (!isTransactionStatusSet || budgetTransactionHeader.TransactionStatus == budgetTransactionStatus)
                                    && budgetTransactionHeader.BudgetTransactionType == BudgetTransactionType::Apportionment
                            join budgetModel
                                where budgetModel.SubModelId == budgetTransactionHeader.BudgetModelId
                                    && (!isBudgetModelIdSet || budgetModel.ModelId == budgetModelId)
                                    && (isIncludeSubModelsSet || budgetModel.Type == HeadingSub::Heading)
                            join dimensionAttributeValueCombination
                                where dimensionAttributeValueCombination.RecId == budgetTransactionLine.LedgerDimension
                            join mainAccount
                                where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                                    && mainAccount.Type == DimensionLedgerAccountType::Total
                            join Type from budgetBalancesActualsTotalMainAccountDerivedTypeView
                                group by Type
                                where budgetBalancesActualsTotalMainAccountDerivedTypeView.MainAccountId == mainAccount.MainAccountId;

                    // Add the apportionmentBudgetBalancesForTotalAccountType's ApportionmentAmount amount to apportionmentBudgetBalances based on budget account type and dimensionFocus.
                    update_recordset apportionmentBudgetBalances
                        setting ApportionmentAmount = apportionmentBudgetBalances.ApportionmentAmount + apportionmentBudgetBalancesForTotalAccountType.ApportionmentAmount
                        join ApportionmentAmount from apportionmentBudgetBalancesForTotalAccountType
                            where apportionmentBudgetBalancesForTotalAccountType.DimensionFocus == apportionmentBudgetBalances.DimensionFocus
                                && apportionmentBudgetBalancesForTotalAccountType.BudgetAccountType == apportionmentBudgetBalances.BudgetAccountType;

                    // Insert the record from apportionmentBudgetBalancesForTotalAccountType which has not been a part of update.
                    insert_recordset apportionmentBudgetBalances (DimensionFocus, DimensionFocusName, ApportionmentAmount, BudgetAccountType)
                        select DimensionFocus, DimensionFocusName, ApportionmentAmount, BudgetAccountType from apportionmentBudgetBalancesForTotalAccountType
                            notexists join apportionmentBudgetBalances
                                where apportionmentBudgetBalancesForTotalAccountType.DimensionFocus == apportionmentBudgetBalances.DimensionFocus
                                    && apportionmentBudgetBalancesForTotalAccountType.BudgetAccountType == apportionmentBudgetBalances.BudgetAccountType;
                }
                else if (isPreliminaryBudgetEnabled)
                {
                    insert_recordset preliminaryBudgetBalances (DimensionFocus, DimensionFocusName, PreliminaryAmount, BudgetAccountType)
                        select DisplayValue from reportingDimension
                            group by reportingDimension.DisplayValue, balanceDimensionDescriptionsTmp.DescriptionDisplayValue
                                where reportingDimension.FocusDimensionHierarchy == focusDimensionHierarchy.RecId
                            join DescriptionDisplayValue from balanceDimensionDescriptionsTmp
                                where balanceDimensionDescriptionsTmp.ReportingDimension == reportingDimension.RecId
                            join reportingDimensionReference
                                where reportingDimensionReference.ReportingDimension == reportingDimension.RecId
                            join sum(AccountingCurrencyAmount) from budgetTransactionLine
                                where budgetTransactionLine.LedgerDimension == reportingDimensionReference.BudgetLedgerDimension
                                    && (!isStartDateSet || budgetTransactionLine.Date >= startDate)
                                    && (!isEndDateSet || budgetTransactionLine.Date <= endDate)
                            join budgetTransactionHeader
                                where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                                    && budgetTransactionHeader.PrimaryLedger == currentLedger
                                    && (!isTransactionStatusSet || budgetTransactionHeader.TransactionStatus == budgetTransactionStatus)
                                    && budgetTransactionHeader.BudgetTransactionType == BudgetTransactionType::PreliminaryBudget
                            join budgetModel
                                where budgetModel.SubModelId == budgetTransactionHeader.BudgetModelId
                                    && (!isBudgetModelIdSet || budgetModel.ModelId == budgetModelId)
                                    && (isIncludeSubModelsSet || budgetModel.Type == HeadingSub::Heading)
                            join dimensionAttributeValueCombination
                                where dimensionAttributeValueCombination.RecId == budgetTransactionLine.LedgerDimension
                            join Type from mainAccount
                                group by Type
                                where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                                    && mainAccount.Type != DimensionLedgerAccountType::Total;

                    BudgetTmpBalancesActuals preliminaryBudgetBalancesForTotalAccountType;

                    insert_recordset preliminaryBudgetBalancesForTotalAccountType (DimensionFocus, DimensionFocusName, PreliminaryAmount, BudgetAccountType)
                        select DisplayValue from reportingDimension
                            group by reportingDimension.DisplayValue, balanceDimensionDescriptionsTmp.DescriptionDisplayValue
                                where reportingDimension.FocusDimensionHierarchy == focusDimensionHierarchy.RecId
                            join DescriptionDisplayValue from balanceDimensionDescriptionsTmp
                                where balanceDimensionDescriptionsTmp.ReportingDimension == reportingDimension.RecId
                            join reportingDimensionReference
                                where reportingDimensionReference.ReportingDimension == reportingDimension.RecId
                            join sum(AccountingCurrencyAmount) from budgetTransactionLine
                                where budgetTransactionLine.LedgerDimension == reportingDimensionReference.BudgetLedgerDimension
                                    && (!isStartDateSet || budgetTransactionLine.Date >= startDate)
                                    && (!isEndDateSet || budgetTransactionLine.Date <= endDate)
                            join budgetTransactionHeader
                                where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                                    && budgetTransactionHeader.PrimaryLedger == currentLedger
                                    && (!isTransactionStatusSet || budgetTransactionHeader.TransactionStatus == budgetTransactionStatus)
                                    && budgetTransactionHeader.BudgetTransactionType == BudgetTransactionType::PreliminaryBudget
                            join budgetModel
                                where budgetModel.SubModelId == budgetTransactionHeader.BudgetModelId
                                    && (!isBudgetModelIdSet || budgetModel.ModelId == budgetModelId)
                                    && (isIncludeSubModelsSet || budgetModel.Type == HeadingSub::Heading)
                            join dimensionAttributeValueCombination
                                where dimensionAttributeValueCombination.RecId == budgetTransactionLine.LedgerDimension
                            join mainAccount
                                where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                                    && mainAccount.Type == DimensionLedgerAccountType::Total
                            join Type from budgetBalancesActualsTotalMainAccountDerivedTypeView
                                group by Type
                                where budgetBalancesActualsTotalMainAccountDerivedTypeView.MainAccountId == mainAccount.MainAccountId;

                    // Add the preliminaryBudgetBalancesForTotalAccountType's PreliminaryAmount amount to preliminaryBudgetBalances based on budget account type and dimensionFocus.
                    update_recordset preliminaryBudgetBalances
                        setting PreliminaryAmount = preliminaryBudgetBalances.PreliminaryAmount + preliminaryBudgetBalancesForTotalAccountType.PreliminaryAmount
                        join PreliminaryAmount from preliminaryBudgetBalancesForTotalAccountType
                            where preliminaryBudgetBalancesForTotalAccountType.DimensionFocus == preliminaryBudgetBalances.DimensionFocus
                                && preliminaryBudgetBalancesForTotalAccountType.BudgetAccountType == preliminaryBudgetBalances.BudgetAccountType;

                    // Insert the record from preliminaryBudgetBalancesForTotalAccountType which has not been a part of update.
                    insert_recordset preliminaryBudgetBalances (DimensionFocus, DimensionFocusName, PreliminaryAmount, BudgetAccountType)
                        select DimensionFocus, DimensionFocusName, PreliminaryAmount, BudgetAccountType from preliminaryBudgetBalancesForTotalAccountType
                        notexists join preliminaryBudgetBalances
                            where preliminaryBudgetBalancesForTotalAccountType.DimensionFocus == preliminaryBudgetBalances.DimensionFocus
                                && preliminaryBudgetBalancesForTotalAccountType.BudgetAccountType == preliminaryBudgetBalances.BudgetAccountType;
                }
            }

            // Populate the budgetTmpBalanceActuals table with actual expenditure amounts from dimension focus balance entries.
            mainAccountDimensionAttributeRecId = DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount);

            if (DimensionHierarchyLevel::findByDimensionHierarchyAndDimAttribute(focusDimensionHierarchy.RecId,mainAccountDimensionAttributeRecId))
            {
                // Group by the main account debit credit proposal to align the values with the budget expense and revenue types.
                if (budgetBalancesActualsGroupByType == BudgetBalancesActualsGroupByType::AmountType)
                {
                    this.generateActualsAndBudgetBalancesWithLedgerAmountType(
                        actualsAndBudgetBalances, focusDimensionHierarchy.RecId, currentLedger, isStartDateSet, isEndDateSet);
                }
                else
                {
                    this.generateActualsAndBudgetBalancesWithBudgetAccountType(
                        actualsAndBudgetBalances, focusDimensionHierarchy.RecId, currentLedger, isStartDateSet, isEndDateSet);
                }
            }
            else
            {
                if (budgetBalancesActualsGroupByType == BudgetBalancesActualsGroupByType::AmountType)
                {
                    this.generateActualsAndBudgetBalancesWithoutMainAccount(
                        actualsAndBudgetBalances, focusDimensionHierarchy.RecId, currentLedger, isStartDateSet, isEndDateSet);
                }
                else
                {
                    actualsAndBudgetBalances = this.calculateDebitDimensionReportingBalances(focusDimensionHierarchy.RecId);
                    BudgetTmpBalancesActuals actualsAndBudgetBalancesForCreditAmount = this.calculateCreditDimensionReportingBalances(focusDimensionHierarchy.RecId);

                    update_recordset actualsAndBudgetBalances
                        setting CreditLedgerAmount = actualsAndBudgetBalancesForCreditAmount.CreditLedgerAmount
                        join CreditLedgerAmount from actualsAndBudgetBalancesForCreditAmount
                            where actualsAndBudgetBalancesForCreditAmount.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                && actualsAndBudgetBalancesForCreditAmount.BudgetAccountType == actualsAndBudgetBalances.BudgetAccountType;

                    // Populate the budgetTmpBalanceActuals table with non-existing from actualsAndBudgetBalancesForCreditAmount
                    insert_recordset actualsAndBudgetBalances (CreditLedgerAmount, ReportingDimension, DimensionFocus, BudgetAccountType)
                        select CreditLedgerAmount, ReportingDimension, DimensionFocus, BudgetAccountType from actualsAndBudgetBalancesForCreditAmount
                            notexists join actualsAndBudgetBalances
                            where actualsAndBudgetBalances.DimensionFocus == actualsAndBudgetBalancesForCreditAmount.DimensionFocus
                                && actualsAndBudgetBalances.BudgetAccountType == actualsAndBudgetBalancesForCreditAmount.BudgetAccountType;
                }
            }

            // Update AmountType in actualsAndBudgetBalances based on LedgerAmountType
            update_recordset actualsAndBudgetBalances
                setting BudgetType = BudgetType::Revenue
                where actualsAndBudgetBalances.LedgerAmountType == DebCredProposal::Credit;

            // Populate the budgetTmpBalanceActuals table with non-existing focus values from budget transactions.
            if (budgetBalancesActualsGroupByType == BudgetBalancesActualsGroupByType::AmountType)
            {
                insert_recordset actualsAndBudgetBalances (DimensionFocus, DimensionFocusName, BudgetType)
                    select DimensionFocus, DimensionFocusName, BudgetType from budgetBalances
                        notexists join actualsAndBudgetBalances
                            where actualsAndBudgetBalances.DimensionFocus == budgetBalances.DimensionFocus
                                && actualsAndBudgetBalances.BudgetType == budgetBalances.BudgetType;

                if (isApportionmentBudgetEnabled)
                {
                    insert_recordset actualsAndBudgetBalances (DimensionFocus, DimensionFocusName, BudgetType)
                        select DimensionFocus, DimensionFocusName, BudgetType from apportionmentBudgetBalances
                            notexists join actualsAndBudgetBalances
                                where actualsAndBudgetBalances.DimensionFocus == apportionmentBudgetBalances.DimensionFocus
                                    && actualsAndBudgetBalances.BudgetType == apportionmentBudgetBalances.BudgetType;
                }
                else if (isPreliminaryBudgetEnabled)
                {
                    insert_recordset actualsAndBudgetBalances (DimensionFocus, DimensionFocusName, BudgetType)
                        select DimensionFocus, DimensionFocusName, BudgetType from preliminaryBudgetBalances
                            notexists join actualsAndBudgetBalances
                                where actualsAndBudgetBalances.DimensionFocus == preliminaryBudgetBalances.DimensionFocus
                                    && actualsAndBudgetBalances.BudgetType == preliminaryBudgetBalances.BudgetType;
                }
            }
            else
            {
                insert_recordset actualsAndBudgetBalances (DimensionFocus, DimensionFocusName, BudgetAccountType)
                    select DimensionFocus, DimensionFocusName, BudgetAccountType from budgetBalances
                        notexists join actualsAndBudgetBalances
                            where actualsAndBudgetBalances.DimensionFocus == budgetBalances.DimensionFocus
                                && actualsAndBudgetBalances.BudgetAccountType == budgetBalances.BudgetAccountType;

                if (isApportionmentBudgetEnabled)
                {
                    insert_recordset actualsAndBudgetBalances (DimensionFocus, DimensionFocusName, BudgetAccountType)
                        select DimensionFocus, DimensionFocusName, BudgetAccountType from apportionmentBudgetBalances
                            notexists join actualsAndBudgetBalances
                                where actualsAndBudgetBalances.DimensionFocus == apportionmentBudgetBalances.DimensionFocus
                                    && actualsAndBudgetBalances.BudgetAccountType == apportionmentBudgetBalances.BudgetAccountType;
                }
                else if (isPreliminaryBudgetEnabled)
                {
                    insert_recordset actualsAndBudgetBalances (DimensionFocus, DimensionFocusName, BudgetAccountType)
                        select DimensionFocus, DimensionFocusName, BudgetAccountType from preliminaryBudgetBalances
                            notexists join actualsAndBudgetBalances
                                where actualsAndBudgetBalances.DimensionFocus == preliminaryBudgetBalances.DimensionFocus
                                    && actualsAndBudgetBalances.BudgetAccountType == preliminaryBudgetBalances.BudgetAccountType;
                }
            }
   
            delete_from balanceDimensionDescriptionsTmp;

            insert_recordset balanceDimensionDescriptionsTmp (ReportingDimension)
                select ReportingDimension from actualsAndBudgetBalances
                    group by ReportingDimension;

            GeneralLedgerBalanceDimensionDescriptionsTmp::generateFocusDescriptions(balanceDimensionDescriptionsTmp, focusDimensionHierarchy.Name);

            update_recordset actualsAndBudgetBalances
                setting DimensionFocusName = balanceDimensionDescriptionsTmp.DescriptionDisplayValue
                join DescriptionDisplayValue from balanceDimensionDescriptionsTmp
                    where balanceDimensionDescriptionsTmp.ReportingDimension == actualsAndBudgetBalances.ReportingDimension;

            // Update values for ledger amount, revised budget amount and variance in budgetTmpBalance table.
            if (budgetBalancesActualsGroupByType == BudgetBalancesActualsGroupByType::AmountType)
            {
                if (isApportionmentBudgetEnabled)
                {
                    update_recordset actualsAndBudgetBalances
                        setting LedgerAmount = actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount,
                            RevisedAmount = budgetBalances.RevisedAmount,
                            ApportionmentAmount = apportionmentBudgetBalances.ApportionmentAmount,
                            Variance = apportionmentBudgetBalances.ApportionmentAmount - (actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount)
                            outer join budgetBalances
                                where budgetBalances.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                    && budgetBalances.BudgetType == actualsAndBudgetBalances.BudgetType
                            outer join apportionmentBudgetBalances
                                where apportionmentBudgetBalances.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                    && apportionmentBudgetBalances.BudgetType == actualsAndBudgetBalances.BudgetType;

                    update_recordset actualsAndBudgetBalances
                        setting PercentOfBudget = actualsAndBudgetBalances.LedgerAmount * 100 / actualsAndBudgetBalances.ApportionmentAmount
                            where actualsAndBudgetBalances.ApportionmentAmount != 0;
                }
                else if (isPreliminaryBudgetEnabled)
                {
                    update_recordset actualsAndBudgetBalances
                        setting LedgerAmount = actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount,
                            RevisedAmount = budgetBalances.RevisedAmount,
                            PreliminaryAmount = preliminaryBudgetBalances.PreliminaryAmount,
                            Variance = budgetBalances.RevisedAmount - (actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount)
                            outer join budgetBalances
                                where budgetBalances.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                    && budgetBalances.BudgetType == actualsAndBudgetBalances.BudgetType
                            outer join preliminaryBudgetBalances
                                where preliminaryBudgetBalances.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                    && preliminaryBudgetBalances.BudgetType == actualsAndBudgetBalances.BudgetType;
                }
                else
                {
                    update_recordset actualsAndBudgetBalances
                        setting LedgerAmount = actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount,
                            RevisedAmount = budgetBalances.RevisedAmount,
                            Variance = budgetBalances.RevisedAmount - (actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount)
                        outer join budgetBalances
                                where budgetBalances.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                        && budgetBalances.BudgetType == actualsAndBudgetBalances.BudgetType;
            }
            }
            else
            {
                if (isApportionmentBudgetEnabled)
                {
                    update_recordset actualsAndBudgetBalances
                        setting LedgerAmount = actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount,
                            RevisedAmount = budgetBalances.RevisedAmount,
                            ApportionmentAmount = apportionmentBudgetBalances.ApportionmentAmount,
                            Variance = apportionmentBudgetBalances.ApportionmentAmount - (actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount)
                            outer join RevisedAmount from budgetBalances
                                where budgetBalances.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                    && budgetBalances.BudgetAccountType == actualsAndBudgetBalances.BudgetAccountType
                            outer join ApportionmentAmount from apportionmentBudgetBalances
                                where apportionmentBudgetBalances.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                    && apportionmentBudgetBalances.BudgetAccountType == actualsAndBudgetBalances.BudgetAccountType;

                    update_recordset actualsAndBudgetBalances
                        setting PercentOfBudget = actualsAndBudgetBalances.LedgerAmount * 100 / actualsAndBudgetBalances.ApportionmentAmount
                            where actualsAndBudgetBalances.ApportionmentAmount != 0;
                }
                else if (isPreliminaryBudgetEnabled)
                {
                    update_recordset actualsAndBudgetBalances
                        setting LedgerAmount = actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount,
                            RevisedAmount = budgetBalances.RevisedAmount,
                            PreliminaryAmount = preliminaryBudgetBalances.PreliminaryAmount,
                            Variance = budgetBalances.RevisedAmount - (actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount)
                            outer join RevisedAmount from budgetBalances
                                where budgetBalances.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                    && budgetBalances.BudgetAccountType == actualsAndBudgetBalances.BudgetAccountType
                            outer join PreliminaryAmount from preliminaryBudgetBalances
                                where preliminaryBudgetBalances.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                    && preliminaryBudgetBalances.BudgetAccountType == actualsAndBudgetBalances.BudgetAccountType;
                }
                else
                {
                    update_recordset actualsAndBudgetBalances
                        setting LedgerAmount = actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount,
                            RevisedAmount = budgetBalances.RevisedAmount,
                            Variance = budgetBalances.RevisedAmount - (actualsAndBudgetBalances.DebitLedgerAmount + actualsAndBudgetBalances.CreditLedgerAmount)
                        outer join RevisedAmount from budgetBalances
                                where budgetBalances.DimensionFocus == actualsAndBudgetBalances.DimensionFocus
                                        && budgetBalances.BudgetAccountType == actualsAndBudgetBalances.BudgetAccountType;
                }
            }

            if (!isApportionmentBudgetEnabled)
            {
                // Update values for variance percent in budgetTmpBalance table.
                update_recordset actualsAndBudgetBalances
                    setting PercentOfBudget = actualsAndBudgetBalances.LedgerAmount * 100 / actualsAndBudgetBalances.RevisedAmount
                        where actualsAndBudgetBalances.RevisedAmount != 0;
            }

            if (_updateEmptyFocusLedgerDimension)
            {
                this.updateEmptyReportingDimensions(actualsAndBudgetBalances, focusDimensionHierarchy.RecId);
            }

            // Flip the sign of revisedAmount and ledgerAmount values if budget type is revenue.
            update_recordset actualsAndBudgetBalances
                setting RevisedAmount = -1 * actualsAndBudgetBalances.RevisedAmount,
                    LedgerAmount = -1 * actualsAndBudgetBalances.LedgerAmount,
                    Variance = -1 * actualsAndBudgetBalances.Variance
                    where actualsAndBudgetBalances.BudgetType == BudgetType::Revenue;
        }

        return actualsAndBudgetBalances;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateEmptyFocusLedgerDimensions</Name>
				<Source><![CDATA[
    private void updateEmptyFocusLedgerDimensions(BudgetTmpBalancesActuals _actualsAndBudgetBalances)
    {
        update_recordset _actualsAndBudgetBalances
            setting FocusLedgerDimension = dimensionFocusNameTmp.LedgerDimension
            where _actualsAndBudgetBalances.FocusLedgerDimension == 0
            join LedgerDimension from dimensionFocusNameTmp
                where dimensionFocusNameTmp.FocusValue == _actualsAndBudgetBalances.DimensionFocus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateEmptyReportingDimensions</Name>
				<Source><![CDATA[
    private void updateEmptyReportingDimensions(BudgetTmpBalancesActuals _actualsAndBudgetBalances, DimensionFocusRecId _dimensionFocusRecId)
    {
        GeneralLedgerBalanceReportingDimension balacneReportingDimension;

        update_recordset _actualsAndBudgetBalances
            setting ReportingDimension = balacneReportingDimension.RecId
            where _actualsAndBudgetBalances.ReportingDimension == 0
            join RecId from balacneReportingDimension
                where balacneReportingDimension.FocusDimensionHierarchy == _dimensionFocusRecId
                    && balacneReportingDimension.DisplayValue == _actualsAndBudgetBalances.DimensionFocus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimensionFocusNameTmp</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the <c>DimensionFocusNameTmp</c> record for specified dimension focus value.
    /// </summary>
    /// <param name="_focusValue">
    ///    The focus value to lookup the <c>DimensionFocusNameTmp</c> record.
    /// </param>
    /// <returns>
    ///    The <c>DimensionFocusNameTmp</c> record for specified dimension focus value.
    /// </returns>
    public DimensionFocusNameTmp getDimensionFocusNameTmp(DimensionDisplayValue _focusValue)
    {
        select firstonly dimensionFocusNameTmp
            where dimensionFocusNameTmp.FocusValue == _focusValue;

        return dimensionFocusNameTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        // The ledger fiscal calendar is the default fiscal calendar.
        fiscalCalendarRecId = Ledger::fiscalCalendar();
    }

]]></Source>
			</Method>
			<Method>
				<Name>appendVariableToPack</Name>
				<Source><![CDATA[
    private container appendVariableToPack(container _pack, str _variableName, anytype _value)
    {
        XppPrePostArgs packArgs = this.createXppPrePostArgsWithPack(_pack);
        SysPackExtensions::pack(packArgs, this.getVariablePackKey(_variableName), [_value]);
        return packArgs.getReturnValue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXppPrePostArgsWithPack</Name>
				<Source><![CDATA[
    private XppPrePostArgs createXppPrePostArgsWithPack(container _pack)
    {
        XppPrePostArgs prePostArgs = new XppPrePostArgs(_pack, '',  XppEventHandlerCalledWhen::Post);
        prePostArgs.setReturnValue(_pack);
        return prePostArgs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVariablePackKey</Name>
				<Source><![CDATA[
    private ClassName getVariablePackKey(str _variableName)
    {
        return classStr(BudgetCalculateBalance) + '.' + _variableName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>extractPackedVariable</Name>
				<Source><![CDATA[
    private anytype extractPackedVariable(container _pack, str _variableName)
    {
        anytype value;
        [value] = SysPackExtensions::unpack(this.createXppPrePostArgsWithPack(_pack), this.getVariablePackKey(_variableName));
        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container queryContainer = connull();

        if (query)
        {
            queryContainer = query.pack();
        }

        container packed = [#CurrentVersion, [#CurrentList, queryContainer]];
        packed = this.appendVariableToPack(packed, varStr(budgetBalancesActualsGroupByType), budgetBalancesActualsGroupByType);

        return packed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccumulateAmounts</Name>
				<Source><![CDATA[
    public NoYes parmAccumulateAmounts(NoYes _accumulateAmounts = accumulateAmounts)
    {
        accumulateAmounts = _accumulateAmounts;

        return accumulateAmounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccumulatedApportionmentAmount</Name>
				<Source><![CDATA[
    public ApportionmentAmountMST parmAccumulatedApportionmentAmount()
    {
        return accumulatedApportionmentAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBudgetModelId</Name>
				<Source><![CDATA[
    public BudgetModelId parmBudgetModelId(BudgetModelId _budgetModelId = budgetModelId)
    {
        budgetModelId = _budgetModelId;

        return budgetModelId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBudgetType</Name>
				<Source><![CDATA[
    public BudgetType parmBudgetType(BudgetType _budgetType = budgetType)
    {
        budgetType = _budgetType;

        return budgetType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBudgetTransactionStatusFilterValue</Name>
				<Source><![CDATA[
    public AllDraftCompleted parmBudgetTransactionStatusFilterValue(AllDraftCompleted _budgetTransactionStatusFilterValue = budgetTransactionStatusFilterValue)
    {
        budgetTransactionStatusFilterValue = _budgetTransactionStatusFilterValue;

        return budgetTransactionStatusFilterValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCalculateLedgerAmounts</Name>
				<Source><![CDATA[
    public NoYes parmCalculateLedgerAmounts(NoYes _calculateLedgerAmounts = calculateLedgerAmounts)
    {
        calculateLedgerAmounts = _calculateLedgerAmounts;

        return calculateLedgerAmounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDimensionNamesAndValues</Name>
				<Source><![CDATA[
    public Map parmDimensionNamesAndValues(Map _dimensionNamesAndValues = dimensionNamesAndValues)
    {
        dimensionNamesAndValues = _dimensionNamesAndValues;

        return dimensionNamesAndValues;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDimensionFocus</Name>
				<Source><![CDATA[
    public Name parmDimensionFocus(Name _dimensionFocus = dimensionFocus)
    {
        dimensionFocus = _dimensionFocus;

        return dimensionFocus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEndDate</Name>
				<Source><![CDATA[
    public TransDate parmEndDate(TransDate _endDate = endDate)
    {
        endDate = _endDate;

        return endDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFilterByBudgetType</Name>
				<Source><![CDATA[
    public NoYes parmFilterByBudgetType(NoYes _filterByBudgetType = filterByBudgetType)
    {
        filterByBudgetType = _filterByBudgetType;

        return filterByBudgetType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFiscalCalendarRecId</Name>
				<Source><![CDATA[
    public FiscalCalendarRecId parmFiscalCalendarRecId(FiscalCalendarRecId _fiscalCalendarRecId = fiscalCalendarRecId)
    {
        fiscalCalendarRecId = _fiscalCalendarRecId;

        return fiscalCalendarRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeSubModels</Name>
				<Source><![CDATA[
    public NoYes parmIncludeSubModels(NoYes _includeSubModels = includeSubModels)
    {
        includeSubModels = _includeSubModels;

        return includeSubModels;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerCategory</Name>
				<Source><![CDATA[
    public CurrentOperationsTax parmLedgerCategory(CurrentOperationsTax _ledgerCategory = ledgerCategory)
    {
        ledgerCategory = _ledgerCategory;

        return ledgerCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQuery</Name>
				<Source><![CDATA[
    public Query parmQuery(Query _query = query)
    {
        query = _query;

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStartDate</Name>
				<Source><![CDATA[
    public TransDate parmStartDate(TransDate _startDate = startDate)
    {
        startDate = _startDate;

        return startDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionBase parmLedgerDimension(LedgerDimensionBase _ledgerDimension = ledgerDimension)
    {
        ledgerDimension = _ledgerDimension;

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBudgetBalancesActualsGroupByType</Name>
				<Source><![CDATA[
    public BudgetBalancesActualsGroupByType parmBudgetBalancesActualsGroupByType(BudgetBalancesActualsGroupByType _budgetBalancesActualsGroupByType = budgetBalancesActualsGroupByType)
    {
        budgetBalancesActualsGroupByType = _budgetBalancesActualsGroupByType;

        return budgetBalancesActualsGroupByType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version     version = RunBase::getVersion(_packedClass);
        container   packedClassMembers;
        container   packedQuery;

        switch (version)
        {
            case #CurrentVersion:
                // Extract the packed values.
                [version, packedClassMembers] = _packedClass;

                budgetBalancesActualsGroupByType = this.extractPackedVariable(_packedClass, varStr(budgetBalancesActualsGroupByType));

                // Extract the #CurrentList and packed query.
                [#CurrentList, packedQuery] = packedClassMembers;

                break;

            default:
                return false;
        }

        if (packedQuery != connull())
        {
            // Unpack the packed query.
            query = new Query(packedQuery);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMainAccountTypeRange</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a query range to restrict actual amounts by the type on its Main account.
    /// </summary>
    /// <param name="_query">
    ///    A <c>Query</c> instance for which to add a range for Main account type.
    /// </param>
    /// <param name="_budgetType">
    ///    A <c>BudgetType</c> enumeration value.
    /// </param>
    protected static void addMainAccountTypeRange(Query _query, BudgetType _budgetType)
    {
        QueryBuildDataSource mainAccountDataSource;
        QueryBuildDataSource generalJournalAccountEntryDataSource;
        QueryBuildDataSource dimensionAttributeValueCombinationDataSource;

        generalJournalAccountEntryDataSource = _query.dataSourceTable(tablenum(GeneralJournalAccountEntry));

        if (!generalJournalAccountEntryDataSource)
        {
            return;
        }

        dimensionAttributeValueCombinationDataSource = generalJournalAccountEntryDataSource.addDataSource(tablenum(DimensionAttributeValueCombination));
        dimensionAttributeValueCombinationDataSource.addSelectionField(fieldnum(DimensionAttributeValueCombination, RecId));
        dimensionAttributeValueCombinationDataSource.joinMode(JoinMode::InnerJoin);
        dimensionAttributeValueCombinationDataSource.fetchMode(QueryFetchMode::One2One);
        dimensionAttributeValueCombinationDataSource.addLink(fieldnum(GeneralJournalAccountEntry, LedgerDimension), fieldnum(DimensionAttributeValueCombination, RecId));

        mainAccountDataSource = dimensionAttributeValueCombinationDataSource.addDataSource(tablenum(MainAccount));
        mainAccountDataSource.addSelectionField(fieldnum(MainAccount, RecId));
        mainAccountDataSource.joinMode(JoinMode::InnerJoin);
        mainAccountDataSource.fetchMode(QueryFetchMode::One2One);
        mainAccountDataSource.addLink(fieldnum(DimensionAttributeValueCombination, MainAccount), fieldnum(MainAccount, RecId));

        if (_budgetType == BudgetType::Expense)
        {
            mainAccountDataSource.addRange(fieldnum(MainAccount, Type)).value(int2str(enum2int(DimensionLedgerAccountType::Expense)));
        }
        else
        {
            mainAccountDataSource.addRange(fieldnum(MainAccount, Type)).value(int2str(enum2int(DimensionLedgerAccountType::Revenue)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMainAccountDebitCreditProposalRange</Name>
				<Source><![CDATA[
    protected static void addMainAccountDebitCreditProposalRange(Query _query, BudgetType _budgetType)
    {
        QueryBuildDataSource mainAccountDataSource;
        QueryBuildDataSource generalJournalAccountEntryDataSource;
        QueryBuildDataSource dimensionAttributeValueCombinationDataSource;

        generalJournalAccountEntryDataSource = _query.dataSourceTable(tablenum(GeneralJournalAccountEntry));

        if (!generalJournalAccountEntryDataSource)
        {
            return;
        }

        dimensionAttributeValueCombinationDataSource = generalJournalAccountEntryDataSource.addDataSource(tablenum(DimensionAttributeValueCombination));
        dimensionAttributeValueCombinationDataSource.addSelectionField(fieldnum(DimensionAttributeValueCombination, RecId));
        dimensionAttributeValueCombinationDataSource.joinMode(JoinMode::InnerJoin);
        dimensionAttributeValueCombinationDataSource.fetchMode(QueryFetchMode::One2One);
        dimensionAttributeValueCombinationDataSource.addLink(fieldnum(GeneralJournalAccountEntry, LedgerDimension), fieldnum(DimensionAttributeValueCombination, RecId));

        mainAccountDataSource = dimensionAttributeValueCombinationDataSource.addDataSource(tablenum(MainAccount));
        mainAccountDataSource.addSelectionField(fieldnum(MainAccount, RecId));
        mainAccountDataSource.joinMode(JoinMode::InnerJoin);
        mainAccountDataSource.fetchMode(QueryFetchMode::One2One);
        mainAccountDataSource.addLink(fieldnum(DimensionAttributeValueCombination, MainAccount), fieldnum(MainAccount, RecId));

        if (_budgetType == BudgetType::Expense)
        {
            mainAccountDataSource.addRange(fieldnum(MainAccount, DebitCreditProposal)).value(int2str(enum2int(DebCredProposal::Debit)));
            mainAccountDataSource.addRange(fieldnum(MainAccount, DebitCreditProposal)).value(int2str(enum2int(DebCredProposal::None)));
        }
        else
        {
            mainAccountDataSource.addRange(fieldnum(MainAccount, DebitCreditProposal)).value(int2str(enum2int(DebCredProposal::Credit)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>create</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>BudgetCalculateBalance</c> class from a packed copy.
    /// </summary>
    /// <param name="_packedBudgetCalculateBalance">
    ///    The packed instance of the <c>BudgetCalculateBalance</c> class.
    /// </param>
    /// <returns>
    ///    An instance of the <c>BudgetCalculateBalance</c> class.
    /// </returns>
    public static BudgetCalculateBalance create(container _packedBudgetCalculateBalance)
    {
        BudgetCalculateBalance budgetCalculateBalance = new BudgetCalculateBalance();

        budgetCalculateBalance.unpack(_packedBudgetCalculateBalance);

        return budgetCalculateBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetTransactionTypeExpression</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds a string that will be used in a query range that contains the budget transaction type
    ///    expression to be included in the query for budget amounts.
    /// </summary>
    /// <param name="_includePublicSectorTypes">
    ///    A Boolean value indication whether to include public sector budget transaction types.
    /// </param>
    /// <returns>
    ///    A string that contains the budget transaction type expression.
    /// </returns>
    protected static str getBudgetTransactionTypeExpression(boolean _includePublicSectorTypes = true)
    {
        str budgetTransactionTypeExpressions;

        if (_includePublicSectorTypes)
        {
            budgetTransactionTypeExpressions = strfmt('(%1 != %2) && (%1 != %3)',
                fieldstr(BudgetTransactionHeader, BudgetTransactionType),
                int2str(enum2int(BudgetTransactionType::Encumbrance)),
                int2str(enum2int(BudgetTransactionType::PreEncumbrance)));
        }
        else
        {
            budgetTransactionTypeExpressions = strfmt('(%1 != %2) && (%1 != %3) && (%1 != %4) && (%1 != %5)',
                fieldstr(BudgetTransactionHeader, BudgetTransactionType),
                int2str(enum2int(BudgetTransactionType::Encumbrance)),
                int2str(enum2int(BudgetTransactionType::PreEncumbrance)),
                int2str(enum2int(BudgetTransactionType::Apportionment)),
                int2str(enum2int(BudgetTransactionType::PreliminaryBudget)));
        }

        return budgetTransactionTypeExpressions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerAmountQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the total amount posted for the specifed ledger dimension and date range.
    /// </summary>
    /// <param name="_startDate">
    ///    The starting date of the query range for which to inquire for ledger amounts.
    /// </param>
    /// <param name="_endDate">
    ///    The end date of the query range for which to inquire for ledger amounts.
    /// </param>
    /// <param name="_operationsTax">
    ///    The posting layer in which to inquire for ledger amounts.
    /// </param>
    /// <returns>
    ///    The total amount posted for the specified ledger dimension and date range.
    /// </returns>
    protected static Query getLedgerAmountQuery(TransDate _startDate, TransDate _endDate, CurrentOperationsTax _operationsTax)
    {
        Query                   query;
        QueryBuildDataSource    generalJournalEntryDataSource;
        QueryBuildDataSource    generalJournalAccountEntryDataSource;

        query = new Query();
        generalJournalEntryDataSource = query.addDataSource(tablenum(GeneralJournalEntry));
        generalJournalEntryDataSource.addRange(fieldnum(GeneralJournalEntry, Ledger)).value(SysQuery::value(Ledger::current()));
        generalJournalEntryDataSource.addRange(fieldnum(GeneralJournalEntry, PostingLayer)).value(int2str(enum2int(_operationsTax)));
        generalJournalEntryDataSource.addRange(fieldnum(GeneralJournalEntry, AccountingDate)).value(SysQuery::range(_startDate, _endDate));

        generalJournalAccountEntryDataSource = generalJournalEntryDataSource.addDataSource(tablenum(GeneralJournalAccountEntry), GeneralJournalAccountEntryDataSourceName);
        generalJournalAccountEntryDataSource.joinMode(JoinMode::InnerJoin);
        generalJournalAccountEntryDataSource.fetchMode(QueryFetchMode::One2One);
        generalJournalAccountEntryDataSource.addLink(fieldnum(GeneralJournalEntry, RecId), fieldnum(GeneralJournalAccountEntry, GeneralJournalEntry));
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeForPublicSector</Name>
				<Source><![CDATA[
    private void initializeForPublicSector()
    {
        LedgerRecId  primaryLedgerRecId = Ledger::current();

        isApportionmentBudgetEnabled    = BudgetControlConfiguration::isApportionmentBudgetEnabled(primaryLedgerRecId);

        if (isApportionmentBudgetEnabled)
        {
            isPreliminaryBudgetEnabled = false;
        }
        else
        {
            isPreliminaryBudgetEnabled = BudgetControlConfiguration::isPreliminaryBudgetEnabled(primaryLedgerRecId);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>