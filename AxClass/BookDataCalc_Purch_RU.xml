<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BookDataCalc_Purch_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
class BookDataCalc_Purch_RU extends BookDataCalc_RU implements BatchRetryable
{
    PurchBookVATProcessLogTrans_RU processLogTrans;

    TmpPurchBookVATProcessLogTransOper_RU tmpProcessLogTransOper;
    PurchBookVATProcessCancelType_RU processMode;

    NoYes processAmountAdj;
    Set setAmountAdjTrans;
    boolean checkTransForProcess;

    private const int LineQtyValueNum = 1;
    private const int LineAmountValueNum = 2;
    private const int LineIsCalcValueNum = 3;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>begin</Name>
				<Source><![CDATA[
    protected void begin()
    {
        PurchBookTrans_RU purchBookTrans;

        if (!this.checkForExistsTrans())
        {
            throw error("@GLS101992");
        }

        delete_from purchBookTrans
            where purchBookTrans.PurchBookTable_RU == bookTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcHeaderRevisions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates data for header revisions.
    /// </summary>
    protected void calcHeaderRevisions()
    {
        FactureJour_RU      factureJour;
        FactureJour_RU      factureJourOrig;
        PurchBookTrans_RU   purchBookTrans;
        PurchBookTrans_RU   revisedTrans;
        PurchBookTrans_RU   annulment;
        RevisionNum_RU      revisionNum;
        PurchBookTrans_RU   revision;

        while select factureJour
            order by RevisionNum
            where (factureJour.Module       == FactureModule_RU::Vend
               ||  factureJour.Module       == FactureModule_RU::TaxCorrectionPurch
               ||  factureJour.Module       == FactureModule_RU::TaxCorrectionPurch_Cust)
               && (factureJour.FactureType  == FactureType_RU::Invoice
               ||  factureJour.FactureType  == FactureType_RU::TaxCorrection
               ||  factureJour.FactureType  == FactureType_RU::Prepayment)
               &&  factureJour.FactureDate  >= fromDate
               &&  factureJour.FactureDate  <= toDate
               &&  factureJour.HeaderRevision
        notexists join purchBookTrans
            where purchBookTrans.FactureId          == factureJour.FactureId
               && purchBookTrans.FactureExternalId  == factureJour.FactureExternalId
               && purchBookTrans.FactureDate        == factureJour.FactureDate
               && purchBookTrans.RevisionSeqNumber  == factureJour.RevisionNum
        {
            select firstonly RevisionSeqNumber, RecId from revisedTrans
                order by RevisionSeqNumber desc
                where  revisedTrans.FactureExternalId    == factureJour.FactureExternalId
                   &&  revisedTrans.FactureExternalId    == factureJour.CorrectedFactureExternalId
                   && (revisedTrans.CorrectedFactureDate == factureJour.CorrectedFactureDate
                   ||  revisedTrans.FactureDate          == factureJour.CorrectedFactureDate)
                   &&  revisedTrans.RevisionSeqNumber     < factureJour.RevisionNum
                   &&  revisedTrans.Annulment            == NoYes::No
                   && !revisedTrans.ReverseTrans;

            if (! revisedTrans.RecId)
            {
                continue;
            }

            revisionNum = revisedTrans.RevisionSeqNumber;

            while select revisedTrans
                where  revisedTrans.FactureExternalId    == factureJour.FactureExternalId
                   &&  revisedTrans.FactureExternalId    == factureJour.CorrectedFactureExternalId
                   && (revisedTrans.CorrectedFactureDate == factureJour.CorrectedFactureDate
                   ||  revisedTrans.FactureDate          == factureJour.CorrectedFactureDate)
                   &&  revisedTrans.RevisionSeqNumber    == revisionNum
                   &&  revisedTrans.Annulment            == NoYes::No
                   && !revisedTrans.ReverseTrans
            {
                annulment = revisedTrans.data();

                annulment.Annulment             = NoYes::Yes;
                annulment.AmountInclVAT         = -revisedTrans.AmountInclVAT;
                annulment.AmountLiableToVAT0    = -revisedTrans.AmountLiableToVAT0;
                annulment.AmountLiableToVAT10   = -revisedTrans.AmountLiableToVAT10;
                annulment.AmountLiableToVAT20   = -revisedTrans.AmountLiableToVAT20;
                annulment.AmountNotLiableToVAT  = -revisedTrans.AmountNotLiableToVAT;
                annulment.TaxAmountVAT10        = -revisedTrans.TaxAmountVAT10;
                annulment.TaxAmountVAT20        = -revisedTrans.TaxAmountVAT20;

                revision = revisedTrans.data();

                if (factureJour.Module == FactureModule_RU::TaxCorrectionPurch_Cust)
                {
                    revision.AccountName = conPeek(BookTransCalc_RU::getContragentData(factureJour), 1);
                }
                else
                {
                    revision.AccountName = conPeek(BookTransCalc_RU::getCompanyData(factureJour), 1);
                }

                revision.FactureId                  = factureJour.FactureId;
                revision.FactureExternalId          = factureJour.FactureExternalId;
                revision.FactureDate                = factureJour.FactureDate;
                revision.FactureDate_External       = factureJour.FactureDate_External ?
                                                      factureJour.FactureDate_External :
                                                      factureJour.FactureDate;
                revision.CorrectedFactureExternalId = factureJour.CorrectedFactureExternalId;
                revision.CorrectedFactureDate       = factureJour.CorrectedFactureDate;
                revision.RevisionSeqNumber          = factureJour.RevisionNum;

                revision.PurchBookTable_RU          = bookTable.RecId;

                revision.SalesPurchBookDataMap_RU::initRefOriginalFacture(factureJour);

                factureJourOrig = FactureJour_RU::findRecId(factureJour.RefRevisedFacture);

                if (factureJourOrig.CorrectedFactureExternalId)
                {
                    revision.RevisionType = PurchBookTable_RU::getFactureRevisionType(revision.CorrectedFactureExternalId,
                                                                                        revision.CorrectedFactureDate,
                                                                                          factureJourOrig.FactureId);
                }

                annulment.PurchBookTable_RU          = revision.PurchBookTable_RU;
                annulment.CorrectionType             = revision.CorrectionType;
                annulment.RevisionType               = revision.RevisionType;
                annulment.RefRevisedFacture          = revision.RefRevisedFacture;
                annulment.RefOriginalFacture         = revision.RefOriginalFacture;
                annulment.FactureId                  = revision.FactureId;
                annulment.FactureExternalId          = revision.FactureExternalId;
                annulment.FactureDate                = revision.FactureDate;
                annulment.CorrectedFactureExternalId = revision.CorrectedFactureExternalId;
                annulment.CorrectedFactureDate       = revision.CorrectedFactureDate;

                annulment.SalesPurchBookDataMap_RU::initRefOriginalFacture(factureJour);
                annulment.doInsert();

                revision.doInsert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcLineData</Name>
				<Source><![CDATA[
    protected void calcLineData()
    {
        PurchBookVATProcessLogTransOper_RU  processLogTransOper;
        PurchBookVATProcessLogTrans_RU      logTrans;
        PurchBookVATProcessParameters_RU    processParameters;
        BookStructVATAmounts_RU             amounts;
        TransDate                           paymentDate;
        TransDate                           transDate;

        if (! bookTableMode)
        {
            super();
            return;
        }

        progress.setText(strFmt("@GLS111360", processLogTrans.AccountNum, processLogTrans.FactureExternalId));

        select firstonly processLogTransOper
        order by TransDate desc
        where processLogTransOper.RefRecId         == processLogTrans.RecId             &&
              processLogTransOper.Blocked          == NoYes::No                         &&
              processLogTransOper.CanceledRefRecId == 0                                 &&
              processLogTransOper.TransDate        >= fromDate                          &&
              processLogTransOper.TransDate        <= toDate
        exists join processParameters
            where processParameters.RecId          == processLogTransOper.PurchBookVATProcessParameters_RU &&
                  processParameters.IncludeInBook  == NoYes::Yes;

        transDate = processLogTransOper.TransDate;

        amounts = new BookStructVATAmounts_RU();

        while select sum(AmountLiableToVAT), sum(TaxAmount), TaxCode from  processLogTransOper
        group by TaxCode
        where processLogTransOper.RefRecId         == processLogTrans.RecId             &&
              processLogTransOper.Blocked          == NoYes::No                         &&
              processLogTransOper.CanceledRefRecId == 0                                 &&
              processLogTransOper.TransDate        >= fromDate                          &&
              processLogTransOper.TransDate        <= toDate
        exists join processParameters
            where processParameters.RecId          == processLogTransOper.PurchBookVATProcessParameters_RU &&
                  processParameters.IncludeInBook  == NoYes::Yes
        {
            amounts.addSmallAmounts(processLogTransOper.TaxCode,
                                processLogTransOper.AmountLiableToVAT + processLogTransOper.TaxAmount,
                                processLogTransOper.AmountLiableToVAT,
                                processLogTransOper.TaxAmount);

            if (processLogTrans.TransType != SalesPurchBookTransType_RU::SumDiff && processLogTrans.CorrectedPeriod)
            {
                if (amounts.amountInclVAT())
                {
                    this.insertLine(transDate, amounts);
                }

                amounts = new BookStructVATAmounts_RU();
            }
        }

        if (VendParameters::find().AmountDiffBookCorrection_RU)
        {
            if (processLogTrans.TransType       == SalesPurchBookTransType_RU::SumDiff &&
            processLogTrans.CorrectedPeriod >= fromDate                            &&
            processLogTrans.CorrectedPeriod <= toDate)
            {
                select firstonly processLogTransOper
                where processLogTransOper.RefRecId         == processLogTrans.RecId &&
                      processLogTransOper.Blocked          == NoYes::No             &&
                      processLogTransOper.CanceledRefRecId == 0                     &&
                      processLogTransOper.TransDate        >= fromDate              &&
                      processLogTransOper.TransDate        <= toDate;

                if (processLogTransOper)
                {
                    return;
                }
            }

            if (processLogTrans.TransType == SalesPurchBookTransType_RU::Invoice ||
            processLogTrans.TransType == SalesPurchBookTransType_RU::CreditNote)
            {
                paymentDate = dateNull();

                while select AmountLiableToVAT, TaxAmount, TaxCode from processLogTransOper
                where processLogTransOper.Blocked          == NoYes::No &&
                      processLogTransOper.CanceledRefRecId == 0         &&
                      processLogTransOper.TransDate        >= fromDate  &&
                      processLogTransOper.TransDate        <= toDate
                join ReverseDate, PaymentDate from logTrans
                    order by PaymentDate, ReverseDate
                    where logTrans.RecId              == processLogTransOper.RefRecId        &&
                          logTrans.CorrectedFactureId == processLogTrans.FactureId           &&
                          logTrans.InvoiceRecIdRef    == processLogTrans.InvoiceRecIdRef     &&
                          logTrans.TransType          == SalesPurchBookTransType_RU::SumDiff &&
                          logTrans.CorrectedPeriod    >= fromDate                            &&
                          logTrans.CorrectedPeriod    <= toDate                              &&
                         (! processLogTrans.PaymentDate || logTrans.PaymentDate == processLogTrans.PaymentDate)
                exists join processParameters
                    where processParameters.RecId          == processLogTransOper.PurchBookVATProcessParameters_RU &&
                          processParameters.IncludeInBook  == NoYes::Yes
                {
                    amounts.addSmallAmounts(processLogTransOper.TaxCode,
                                        processLogTransOper.AmountLiableToVAT + processLogTransOper.TaxAmount,
                                        processLogTransOper.AmountLiableToVAT,
                                        processLogTransOper.TaxAmount);

                    paymentDate = logTrans.ReverseDate ? processLogTrans.PaymentDate : logTrans.PaymentDate;
                }

                if (paymentDate)
                {
                    processLogTrans.PaymentDate = paymentDate;
                }
            }
        }

        if (amounts.amountInclVAT())
        {
            this.insertLine(transDate, amounts);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    public boolean check()
    {
        VendInvoiceJour vendInvoiceJour;
        VendTransOpen   vendTransOpenInvoice;
        VendTrans       vendTransInvoice;
        boolean         ret = true;
        
        setPrefix(this.getInfologPrefix());

        if (! PurchBookVATProcessParameters_RU::existsIncludeInBookRecord())
        {
            ret = false;
            error("@GLS104954",
                  '',
                  SysInfoAction_Formrun::newFormnameControlnameDesc(formStr(PurchBookVATProcessParameters_RU),
                                                                    fieldStr(PurchBookVATProcessParameters_RU, IncludeInBook),
                                                                    "@GLS104955"));
        }

        if (PurchBookTable_RU::findByClosingDate(toDate))
        {
            ret = checkFailed(strFmt("@GLS101156", toDate));
        }

        if (fullCheck)
        {
            while select vendInvoiceJour
                where vendInvoiceJour.InvoiceId &&
                     (vendInvoiceJour.InventProfileType_RU == InventProfileType_RU::General ||
                      vendInvoiceJour.InventProfileType_RU == InventProfileType_RU::NotSpecified)
            exists join vendTransInvoice
                where vendTransInvoice.AccountNum == vendInvoiceJour.InvoiceAccount &&
                      vendTransInvoice.Invoice    == vendInvoiceJour.InvoiceId      &&
                      vendTransInvoice.TransDate  == vendInvoiceJour.InvoiceDate    &&
                      vendTransInvoice.Voucher    == vendInvoiceJour.LedgerVoucher
            exists join vendTransOpenInvoice
                where vendTransOpenInvoice.RefRecId  == vendTransInvoice.RecId  &&
                      vendTransOpenInvoice.TransDate <= toDate
            {
                setPrefix("@GLS3800145");
                info(strFmt("@GLS104918", vendInvoiceJour.InvoiceId, vendInvoiceJour.InvoiceDate),
                     '',
                     new SysInfoAction_FormName_RU(vendInvoiceJour, formStr(VendInvoiceJournal)));
            }
        }

        if (closeBook)
        {
            if ( RestoredVATLogTable_RU::exist(toDate) &&
                !RestoredVATLogTable_RU::checkApproved(toDate))
            {
                ret = checkFailed(strFmt("@GLS114225", fromDate, toDate));
            }
        }

        if (! RestoredVATLogTable_RU::exist(toDate))
        {
            warning("@GLS114574");
        }

        if ( ! ret)
        {
            throw error("@GLS101992");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForExistsTrans</Name>
				<Source><![CDATA[
    public boolean checkForExistsTrans()
    {
        boolean ret = true;

        if (this.existsTransForProces())
        {
            ret = checkFailed(strFmt("@GLS104895", fromDate, toDate));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>end</Name>
				<Source><![CDATA[
    protected void end()
    {
        FactureJour_RU      factureJour;
        PurchBookTrans_RU   purchBookTrans;
        boolean             invoiceOnPaym;

        lineNum = 1;

        this.calcHeaderRevisions();

        while select forupdate salesPurchBookData
            where salesPurchBookData.SalesPurchBookTable_RU == bookTable.RecId &&
                  salesPurchBookData.Annulment              == NoYes::No
        {
            purchBookTrans = salesPurchBookData;
            purchBookTrans.SalesPurchBookDataMap_RU::initSalesPurchBookDataFields();
            invoiceOnPaym  = purchBookTrans.SettlementDate                                   &&
                            (purchBookTrans.TransType == SalesPurchBookTransType_RU::Invoice ||
                             purchBookTrans.TransType == SalesPurchBookTransType_RU::CreditNote);

            if (purchBookTrans.CorrectionType == FactureCorrectionType_RU::Revision)
            {
                factureJour = FactureJour_RU::findRecId(FactureJour_RU::findRecId(purchBookTrans.FactureJour_RU).RefRevisedFacture);

                if (! FactureJour_RU::findRecId(purchBookTrans.FactureJour_RU).HeaderRevision)
                {
                    if (factureJour.CorrectedFactureExternalId)
                    {
                        purchBookTrans.RevisionType = PurchBookTable_RU::getFactureRevisionType(purchBookTrans.CorrectedFactureExternalId,
                                                                                                purchBookTrans.CorrectedFactureDate,
                                                                                                factureJour.FactureId);
                    }

                    if (! invoiceOnPaym)
                    {
                        purchBookTrans.SalesPurchBookDataMap_RU::createAnnulment();
                    }
                }
            }
            else if (invoiceOnPaym)
            {
                this.initRevisionOnPaym(purchBookTrans);
            }

            purchBookTrans.update();
        }

        delete_from purchBookTrans
            where   purchBookTrans.AmountInclVAT == 0 &&
                    purchBookTrans.AmountLiableToVAT0 == 0 &&
                    purchBookTrans.AmountLiableToVAT10 == 0 &&
                    purchBookTrans.AmountLiableToVAT20 == 0 &&
                    purchBookTrans.AmountNotLiableToVAT == 0 &&
                    purchBookTrans.TaxAmountVAT10 == 0 &&
                    purchBookTrans.TaxAmountVAT20 == 0 &&
                    purchBookTrans.AmountCurInclVAT == 0;

        while select forupdate salesPurchBookData
            order by PaymentDate, FactureDate, FactureExternalId, RevisionSeqNumber, Annulment
            where salesPurchBookData.SalesPurchBookTable_RU == bookTable.RecId
        {
            purchBookTrans         = salesPurchBookData;
            purchBookTrans.LineNum = lineNum;
            purchBookTrans.update();
            lineNum++;
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>existPrevBook</Name>
				<Source><![CDATA[
    protected boolean existPrevBook()
    {
        boolean ret = false;
        PurchBookTable_RU prevBook = bookTable.getPreviousBook();

        if (prevBook && prevBook.ClosingDate != dateNull())
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsTransForProces</Name>
				<Source><![CDATA[
    protected boolean existsTransForProces()
    {
        BookDataCalc_Purch_Process_RU         bookDataCalc_Purch_Process;
        TmpPurchBookVATProcessLogTransOper_RU tmpTransOper;
        boolean                               ret;

        void selectForProcess(boolean _check)
        {
            bookDataCalc_Purch_Process = BookDataCalc_Purch_Process_RU::newFromBookTable(fromDate, toDate);
            bookDataCalc_Purch_Process.initParmDefault();
            bookDataCalc_Purch_Process.parmCheckTransForProcess(_check);
            bookDataCalc_Purch_Process.parmCloseBookCheck(true);
            bookDataCalc_Purch_Process.runOperation();

            tmpTransOper = bookDataCalc_Purch_Process.parmProcessLogTransOper();

            select firstonly tmpTransOper
                where tmpTransOper.Blocked == NoYes::No;
        }

        bookDataCalc_Purch_Process = BookDataCalc_Purch_Process_RU::newFromBookTable(fromDate, toDate);
        bookDataCalc_Purch_Process.initParmDefault();

        if (bookDataCalc_Purch_Process.validate(null))
        {
            selectForProcess(true);
            ret = tmpTransOper ? true : false;

            if (! ret)
            {
                selectForProcess(false);
                ret = tmpTransOper ? true : false;
            }
        }
        else
        {
            return true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fetchNextRecord</Name>
				<Source><![CDATA[
    protected boolean fetchNextRecord()
    {
        return recordSortedList.next(processLogTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDate</Name>
				<Source><![CDATA[
    protected FromDate getFromDate()
    {
        PurchBookTable_RU prevBook = bookTable.getPreviousBook();

        return prevBook ? prevBook.ClosingDate+1 : dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInfologPrefix</Name>
				<Source><![CDATA[
    protected InfologText getInfologPrefix()
    {
        return BookDataCalc_Purch_RU::description();
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    public boolean init()
    {
        PurchBookTrans_RU  purchBookTrans;

        salesPurchBookData = purchBookTrans;
        setAmountAdjTrans = new Set(Types::Int64);

        this.initRecordSortedList();

        GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceRU00022, funcName());

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBookTable</Name>
				<Source><![CDATA[
    protected void initBookTable()
    {
        bookTable = PurchBookTable_RU::find(bookRecId, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    public void initParmDefault()
    {
        super();

        fullCheck = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRecordSortedList</Name>
				<Source><![CDATA[
    protected void initRecordSortedList()
    {
        PurchBookVATProcessLogTrans_RU      processLogTransLocal;
        PurchBookVATProcessLogTransOper_RU  processLogTransOper;
        PurchBookVATProcessParameters_RU    processParameters;

        recordSortedList = new RecordSortedList(tableNum(PurchBookVATProcessLogTrans_RU));

        recordSortedList.sortOrder(fieldNum(PurchBookVATProcessLogTrans_RU, RecId));

        while select processLogTransLocal
            exists join RecId from processLogTransOper
                where processLogTransOper.RefRecId  == processLogTransLocal.RecId &&
                      processLogTransOper.TransDate >= fromDate                   &&
                      processLogTransOper.TransDate <= toDate                     &&
                      ! processLogTransOper.CanceledRefRecId
            exists join RecId from processParameters
                where processParameters.RecId         == processLogTransOper.PurchBookVATProcessParameters_RU &&
                      processParameters.IncludeInBook == NoYes::Yes
        {
            if ( ! recordSortedList.find(processLogTransLocal))
            {
                recordSortedList.ins(processLogTransLocal);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRevisionOnPaym</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes revision fields on <c>PurchBookTrans_RU</c>
    /// </summary>
    /// <param name="_purchBookTrans">
    /// <c>PurchBookTrans_RU</c> record.
    /// </param>
    protected void initRevisionOnPaym(PurchBookTrans_RU _purchBookTrans)
    {
        FactureJour_RU factureJourRev;
        FactureJour_RU factureJour = _purchBookTrans.FactureJour_RU                            ?
                                     FactureJour_RU::findRecId(_purchBookTrans.FactureJour_RU) :
                                     FactureJour_RU::find(_purchBookTrans.FactureId, _purchBookTrans.factureModule());

        if (! factureJour)
        {
            return;
        }

        select maxof(RevisionNum) from factureJourRev
            where factureJourRev.RefRevisedFacture == factureJour.RecId
               && factureJourRev.FactureDate       < (_purchBookTrans.ReverseTrans ? fromDate : toDate + 1);

        _purchBookTrans.RevisionSeqNumber = factureJourRev.RevisionNum;

        select firstonly factureJourRev
            order by RevisionNum desc
            where factureJourRev.RefRevisedFacture == factureJour.RecId
               && factureJourRev.FactureDate       < (_purchBookTrans.ReverseTrans ? fromDate : toDate + 1)
               && factureJourRev.HeaderRevision;

        if (factureJourRev)
        {
            _purchBookTrans.AccountName = conPeek(BookTransCalc_RU::getCompanyData(factureJourRev), 1);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLine</Name>
				<Source><![CDATA[
    private void insertLine(TransDate  _transDate, BookStructVATAmounts_RU _amounts)
    {
        PurchBookVATProcessLogTrans_RU      logTrans;
        PurchBookVATProcessLogTransOper_RU  logTransOper;
        PurchBookVATProcessParameters_RU    processParameters;
        TransDate                           periodStart, periodEnd;
        TransDate                           paymentDate, newPaymentDate;
        TransDate                           invoicePaymentDate;
        BookStructVATAmounts_RU             amounts, amountsAdj;
        FactureJour_RU                      factureJour;
        SalesPurchBookTransType_RU          transType;
        FactureTrans_RU                     factureTrans;

        salesPurchBookData.clear();

        salesPurchBookData.data(processLogTrans);

        salesPurchBookData.SalesPurchBookTable_RU = bookTable.RecId;
        salesPurchBookData.TransDate              = _transDate;
        salesPurchBookData.FactureDate_External   = processLogTrans.factureDate_External();
        salesPurchBookData.OperationTypeCodes     = processLogTrans.SalesPurchBookDataMap_RU::factureOperationTypeCodes();

        if (processLogTrans.ReverseDate)
        {
            salesPurchBookData.Reversed         = ! processLogTrans.Reversed;
        }

        salesPurchBookData.AmountInclVAT        = _amounts.amountInclVAT();
        salesPurchBookData.AmountLiableToVAT20  = _amounts.amountLiableToVAT20();
        salesPurchBookData.AmountLiableToVAT10  = _amounts.amountLiableToVAT10();
        salesPurchBookData.AmountLiableToVAT0   = _amounts.amountLiableToVAT0();
        salesPurchBookData.AmountNotLiableToVAT = _amounts.amountNotLiableToVAT();
        salesPurchBookData.TaxAmountVAT20       = _amounts.taxAmountVAT20();
        salesPurchBookData.TaxAmountVAT10       = _amounts.taxAmountVAT10();

        factureJour = FactureJour_RU::find(salesPurchBookData.FactureID, processLogTrans.factureModule());

        if ((salesPurchBookData.TransType == SalesPurchBookTransType_RU::CreditNote ||
             salesPurchBookData.TransType == SalesPurchBookTransType_RU::Invoice)   &&
           ! factureJour.vatOnPayment                                               &&
           ! salesPurchBookData.Reversed)
        {
            [salesPurchBookData.PaymentDate, salesPurchBookData.PaymDocumentNum] = BookDataCalc_RU::getLastPaymDateNum(factureJour, toDate);
        }

        if (salesPurchBookData.TransType == SalesPurchBookTransType_RU::Prepayment)
        {
            this.initPaymentInfo(
                salesPurchBookData,
                VendTrans::find(processLogTrans.PaymentRecIdRef));
        }

        if (factureJour.PrepaymTaxCorrection == NoYes::Yes)
        {
            salesPurchBookData.PaymentDate = factureJour.PaymentTransDate;
            salesPurchBookData.PaymDocumentNum = factureJour.PaymentOrderNum;
        }

        if (salesPurchBookData.TransType == SalesPurchBookTransType_RU::PrepaymentStorno)
        {
            this.initPaymentInfo(
                salesPurchBookData,
                CustTrans::find(processLogTrans.PaymentRecIdRef));
        }

        if (toDate >= #BookCorrectionDate)
        {
            if (salesPurchBookData.TransType == SalesPurchBookTransType_RU::AdvanceAdjustment)
            {
                salesPurchBookData.CorrectedFactureExternalId = factureJour.CorrectedFactureExternalId;
                salesPurchBookData.CorrectedFactureDate       = factureJour.CorrectedFactureDate;
                if (factureJour.CorrectedPeriod)
                {
                    salesPurchBookData.CorrectedSalesPurchBookTable_RU = PurchBookTable_RU::findFirstByClosingDate(factureJour.CorrectedPeriod).RecId;
                }
            }

            if (salesPurchBookData.Reversed && factureJour.FactureType != FactureType_RU::AdvanceAdjustment)
            {
                salesPurchBookData.CorrectedFactureExternalId = salesPurchBookData.FactureExternalId;
                salesPurchBookData.CorrectedFactureDate       = salesPurchBookData.FactureDate_External;
                if (salesPurchBookData.ReverseDate &&
                    (salesPurchBookData.TransType == SalesPurchBookTransType_RU::PrepaymentStorno ||
                     ! BookDataCalc_Purch_RU::existFactureBlock(processLogTrans.FactureId,processLogTrans.TransType,bookTable.getFromDate())
                    )
                   )
                {
                    salesPurchBookData.CorrectedSalesPurchBookTable_RU = PurchBookTable_RU::findFirstByClosingDate(salesPurchBookData.ReverseDate).RecId;
                }
            }

            if ((salesPurchBookData.TransType == SalesPurchBookTransType_RU::TaxCorrection     ||
                 salesPurchBookData.TransType == SalesPurchBookTransType_RU::CreditNote        ||
                 salesPurchBookData.TransType == SalesPurchBookTransType_RU::Invoice           ||
                 salesPurchBookData.TransType == SalesPurchBookTransType_RU::CustomCorrection) &&
                 ! salesPurchBookData.Reversed)
            {
                salesPurchBookData.CorrectedFactureExternalId = factureJour.CorrectedFactureExternalId;
                salesPurchBookData.CorrectedFactureDate       = factureJour.CorrectedFactureDate;
                if (factureJour.CorrectedPeriod)
                {
                    salesPurchBookData.CorrectedSalesPurchBookTable_RU = PurchBookTable_RU::findFirstByClosingDate(factureJour.CorrectedPeriod).RecId;
                }
            }

            if (processLogTrans.CorrectedPeriod && salesPurchBookData.TransType != SalesPurchBookTransType_RU::SumDiff &&
                BookDataCalc_RU::datePeriodBook(salesPurchBookData.TransDate)   != BookDataCalc_RU::datePeriodBook(processLogTrans.CorrectedPeriod))
            {
                salesPurchBookData.CorrectedFactureExternalId       = salesPurchBookData.FactureExternalId;
                salesPurchBookData.CorrectedFactureDate             = salesPurchBookData.FactureDate_External;
                salesPurchBookData.CorrectedSalesPurchBookTable_RU  = PurchBookTable_RU::findFirstByClosingDate(processLogTrans.CorrectedPeriod).RecId;
            }

            if (salesPurchBookData.TransType == SalesPurchBookTransType_RU::VATStandardCancellation)
            {
                salesPurchBookData.CorrectedFactureExternalId = factureJour.CorrectedFactureExternalId;
                salesPurchBookData.CorrectedFactureDate       = factureJour.CorrectedFactureDate;
            }

            if (processLogTrans.CorrectedPeriod             &&
                processLogTrans.CorrectedPeriod <  fromDate &&
                salesPurchBookData.TransType == SalesPurchBookTransType_RU::SumDiff)
            {
                if (setAmountAdjTrans.in(processLogTrans.RecId))
                {
                    return;
                }

                [periodStart, periodEnd] = BookDataCalc_RU::datePeriodBook(processLogTrans.CorrectedPeriod);
                transType                = SalesPurchBookTransType_RU::SumDiff;

                amounts = new BookStructVATAmounts_RU();

                while select AmountLiableToVAT, TaxAmount, TaxCode from logTransOper
                    where logTransOper.Blocked          == NoYes::No   &&
                          logTransOper.CanceledRefRecId == 0           &&
                          logTransOper.TransDate        >= periodStart &&
                          logTransOper.TransDate        <= periodEnd
                    join TransType, PaymentDate from logTrans
                        where logTrans.RecId            == logTransOper.RefRecId                   &&
                              logTrans.FactureId        == processLogTrans.CorrectedFactureId      &&
                              logTrans.InvoiceRecIdRef  == processLogTrans.InvoiceRecIdRef         &&
                              logTrans.InvoiceCompany   == processLogTrans.InvoiceCompany          &&
                             (logTrans.TransType        == SalesPurchBookTransType_RU::Invoice     ||
                              logTrans.TransType        == SalesPurchBookTransType_RU::CreditNote) &&
                             (! logTrans.PaymentDate || logTrans.PaymentDate == processLogTrans.PaymentDate)
                    exists join processParameters
                        where processParameters.RecId         == logTransOper.PurchBookVATProcessParameters_RU &&
                              processParameters.IncludeInBook == NoYes::Yes
                {
                    amounts.addSmallAmounts(logTransOper.TaxCode,
                                            logTransOper.AmountLiableToVAT + logTransOper.TaxAmount,
                                            logTransOper.AmountLiableToVAT,
                                            logTransOper.TaxAmount);

                    transType          = logTrans.TransType;
                    invoicePaymentDate = logTrans.PaymentDate;
                }

                while select AmountLiableToVAT, TaxAmount, TaxCode from logTransOper
                    where logTransOper.Blocked          == NoYes::No   &&
                          logTransOper.CanceledRefRecId == 0           &&
                          logTransOper.TransDate        <  fromDate
                    join ReverseDate, PaymentDate from logTrans
                        order by PaymentDate, ReverseDate
                        where logTrans.RecId              == logTransOper.RefRecId                 &&
                              logTrans.CorrectedFactureId == processLogTrans.CorrectedFactureId    &&
                              logTrans.InvoiceRecIdRef    == processLogTrans.InvoiceRecIdRef       &&
                              logTrans.InvoiceCompany     == processLogTrans.InvoiceCompany        &&
                              logTrans.TransType          == SalesPurchBookTransType_RU::SumDiff   &&
                              logTrans.CorrectedPeriod    >= periodStart                           &&
                              logTrans.CorrectedPeriod    <= periodEnd                             &&
                             (! invoicePaymentDate || logTrans.PaymentDate == invoicePaymentDate)
                    exists join processParameters
                        where processParameters.RecId         == logTransOper.PurchBookVATProcessParameters_RU &&
                              processParameters.IncludeInBook == NoYes::Yes
                {
                    amounts.addSmallAmounts(logTransOper.TaxCode,
                                            logTransOper.AmountLiableToVAT + logTransOper.TaxAmount,
                                            logTransOper.AmountLiableToVAT,
                                            logTransOper.TaxAmount);

                    paymentDate = logTrans.ReverseDate ? invoicePaymentDate : logTrans.PaymentDate;
                }

                amountsAdj = new BookStructVATAmounts_RU();

                while select AmountLiableToVAT, TaxAmount, TaxCode, TransDate from logTransOper
                    order by TransDate
                    where logTransOper.Blocked          == NoYes::No &&
                          logTransOper.CanceledRefRecId == 0         &&
                          logTransOper.TransDate        >= fromDate  &&
                          logTransOper.TransDate        <= toDate
                    join ReverseDate, PaymentDate, RecId from logTrans
                        order by PaymentDate, ReverseDate
                        where logTrans.RecId              == logTransOper.RefRecId                 &&
                              logTrans.CorrectedFactureId == processLogTrans.CorrectedFactureId    &&
                              logTrans.InvoiceRecIdRef    == processLogTrans.InvoiceRecIdRef       &&
                              logTrans.InvoiceCompany     == processLogTrans.InvoiceCompany        &&
                              logTrans.TransType          == SalesPurchBookTransType_RU::SumDiff   &&
                              logTrans.CorrectedPeriod    == processLogTrans.CorrectedPeriod       &&
                             (! invoicePaymentDate || logTrans.PaymentDate == invoicePaymentDate)
                    exists join processParameters
                        where processParameters.RecId         == logTransOper.PurchBookVATProcessParameters_RU &&
                              processParameters.IncludeInBook == NoYes::Yes
                {
                    amountsAdj.addSmallAmounts(logTransOper.TaxCode,
                                               logTransOper.AmountLiableToVAT + logTransOper.TaxAmount,
                                               logTransOper.AmountLiableToVAT,
                                               logTransOper.TaxAmount);

                    salesPurchBookData.TransDate = logTransOper.TransDate;
                    newPaymentDate = logTrans.ReverseDate ? invoicePaymentDate : logTrans.PaymentDate;
                    setAmountAdjTrans.add(logTrans.RecId);
                }

                salesPurchBookData.FactureID            = processLogTrans.CorrectedFactureId;
                salesPurchBookData.TransType            = transType;
                salesPurchBookData.PaymentDate          = max(invoicePaymentDate, paymentDate);
                salesPurchBookData.AmountInclVAT        = - amounts.amountInclVAT();
                salesPurchBookData.AmountLiableToVAT20  = - amounts.amountLiableToVAT20();
                salesPurchBookData.AmountLiableToVAT10  = - amounts.amountLiableToVAT10();
                salesPurchBookData.AmountLiableToVAT0   = - amounts.amountLiableToVAT0();
                salesPurchBookData.AmountNotLiableToVAT = - amounts.amountNotLiableToVAT();
                salesPurchBookData.TaxAmountVAT20       = - amounts.taxAmountVAT20();
                salesPurchBookData.TaxAmountVAT10       = - amounts.taxAmountVAT10();

                if (transType == SalesPurchBookTransType_RU::CreditNote)
                {
                    factureJour = FactureJour_RU::find(salesPurchBookData.FactureID, processLogTrans.factureModule());

                    salesPurchBookData.CorrectedFactureExternalId = factureJour.CorrectedFactureExternalId;
                    salesPurchBookData.CorrectedFactureDate       = factureJour.CorrectedFactureDate;
                    if (factureJour.CorrectedPeriod)
                    {
                        salesPurchBookData.CorrectedSalesPurchBookTable_RU = PurchBookTable_RU::findFirstByClosingDate(factureJour.CorrectedPeriod).RecId;
                    }
                }
                else
                {
                    salesPurchBookData.CorrectedFactureExternalId      = salesPurchBookData.FactureExternalId;
                    salesPurchBookData.CorrectedFactureDate            = salesPurchBookData.FactureDate_External;
                    salesPurchBookData.CorrectedSalesPurchBookTable_RU = PurchBookTable_RU::findFirstByClosingDate(processLogTrans.CorrectedPeriod).RecId;
                }

                salesPurchBookData.FactureJour_RU       = FactureJour_RU::find(salesPurchBookData.FactureID, salesPurchBookData.factureModule()).RecId;
                salesPurchBookData.insert();

                salesPurchBookData.PaymentDate          = newPaymentDate;
                salesPurchBookData.AmountInclVAT        = amounts.amountInclVAT()        + amountsAdj.amountInclVAT();
                salesPurchBookData.AmountLiableToVAT20  = amounts.amountLiableToVAT20()  + amountsAdj.amountLiableToVAT20();
                salesPurchBookData.AmountLiableToVAT10  = amounts.amountLiableToVAT10()  + amountsAdj.amountLiableToVAT10();
                salesPurchBookData.AmountLiableToVAT0   = amounts.amountLiableToVAT0()   + amountsAdj.amountLiableToVAT0();
                salesPurchBookData.AmountNotLiableToVAT = amounts.amountNotLiableToVAT() + amountsAdj.amountNotLiableToVAT();
                salesPurchBookData.TaxAmountVAT20       = amounts.taxAmountVAT20()       + amountsAdj.taxAmountVAT20();
                salesPurchBookData.TaxAmountVAT10       = amounts.taxAmountVAT10()       + amountsAdj.taxAmountVAT10();
            }

            if (salesPurchBookData.CorrectedSalesPurchBookTable_RU && salesPurchBookData.CorrectedSalesPurchBookTable_RU == bookTable.RecId)
            {
                salesPurchBookData.CorrectedSalesPurchBookTable_RU = 0;
            }
        }

        salesPurchBookData.FactureJour_RU       = FactureJour_RU::find(salesPurchBookData.FactureID, salesPurchBookData.factureModule()).RecId;
        salesPurchBookData.SalesPurchBookDataMap_RU::initRefOriginalFacture(factureJour);
        salesPurchBookData.doInsert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransForProcess</Name>
				<Source><![CDATA[
    protected boolean isTransForProcess()
    {
        if (tmpProcessLogTransOper)
        {
            select firstonly tmpProcessLogTransOper
                where tmpProcessLogTransOper.Blocked == NoYes::No;
        }

        return tmpProcessLogTransOper.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckTransForProcess</Name>
				<Source><![CDATA[
    public boolean parmCheckTransForProcess(boolean _checkTransForProcess = checkTransForProcess)
    {
        checkTransForProcess = _checkTransForProcess;
        return checkTransForProcess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProcessAmountAdj</Name>
				<Source><![CDATA[
    public NoYes parmProcessAmountAdj(NoYes _processAmountAdj = processAmountAdj)
    {
        processAmountAdj = _processAmountAdj;

        return processAmountAdj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProcessLogTrans</Name>
				<Source><![CDATA[
    public TmpPurchBookVATProcessLogTrans_RU parmProcessLogTrans(TmpPurchBookVATProcessLogTrans_RU _processLogTrans = salesPurchBookData)
    {
        salesPurchBookData = _processLogTrans;
        return salesPurchBookData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProcessLogTransOper</Name>
				<Source><![CDATA[
    public TmpPurchBookVATProcessLogTransOper_RU parmProcessLogTransOper(TmpPurchBookVATProcessLogTransOper_RU _processLogTransOper = tmpProcessLogTransOper)
    {
        tmpProcessLogTransOper = _processLogTransOper;
        return tmpProcessLogTransOper;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInfologPrefix</Name>
				<Source><![CDATA[
    protected void setInfologPrefix()
    {
        setPrefix(BookDataCalc_Purch_RU::description());
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@GLS101149";
    }

]]></Source>
			</Method>
			<Method>
				<Name>existFactureBlock</Name>
				<Source><![CDATA[
    public static boolean existFactureBlock(FactureId_RU                   _factureId,
                                            SalesPurchBookTransType_RU     _transType,
                                            TransDate                      _toDate
                                           )
    {
        PurchBookVATProcessLogTrans_RU      processLogTransLocal;
        PurchBookVATProcessLogTable_RU      processLogTableLocal;
        PurchBookVATProcessLogTransOper_RU  processLogTransOperBlocked;
        
        select firstonly RecId from processLogTransLocal
            where processLogTransLocal.FactureId        == _factureId &&
                  processLogTransLocal.TransType        == _transType
        join TableId from processLogTransOperBlocked
            where processLogTransOperBlocked.RefRecId   == processLogTransLocal.RecId  &&
                  processLogTransOperBlocked.Blocked
        join TableId from processLogTableLocal
            where processLogTableLocal.RecId            == processLogTransOperBlocked.LogTableRefRecId &&
                  processLogTableLocal.TransDate        <  _toDate;
        return processLogTransLocal.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromVATProcess</Name>
				<Source><![CDATA[
    public static BookDataCalc_Purch_RU newFromVATProcess(PurchBookVATProcessCancelType_RU _processMode, NoYes _processAmountAdj = NoYes::No)
    {
        BookDataCalc_Purch_RU bookDataCalc;

        switch (_processMode)
        {
            case PurchBookVATProcessCancelType_RU::Process :
                bookDataCalc = new BookDataCalc_Purch_Process_RU();
                break;

            case PurchBookVATProcessCancelType_RU::Cancel  :
                bookDataCalc = new BookDataCalc_Purch_Cancel_RU();
                break;

            default :
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        bookDataCalc.parmFromDate(dateNull());
        bookDataCalc.parmToDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        bookDataCalc.parmBookTableMode(false);
        bookDataCalc.parmProcessAmountAdj(_processAmountAdj);

        return bookDataCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        boolean ret;

        ret = super(packedClass);

        fullCheck = true;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls whether the batch task should be retried in case of transient errors.
    /// </summary>
    /// <returns>
    /// Always returns false.
    /// </returns>
    [Hookable(false)]
    public boolean isRetryable()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcGTDTraceableInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Completes a table with traceability information for the lines of the Purchase book.
    /// </summary>
    protected void calcGTDTraceableInfo()
    {
        if (bookTableMode)
        {
            Query purchBookLinesNoRevisions = this.factureTransQueryConstruct();
            BookDataCalc_Purch_RU::factureTransQueryRun(purchBookLinesNoRevisions);

            Query purchBookLinesRevisions = this.factureTransQueryConstruct(true);
            BookDataCalc_Purch_RU::factureTransQueryRun(purchBookLinesRevisions);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>factureTransQueryConstruct</Name>
				<Source><![CDATA[
    private Query factureTransQueryConstruct(boolean _isRevision = false)
    {
        Query queryPurchBook = new Query();

        QueryBuildDataSource qbdsPurchBook = queryPurchBook.addDataSource(tableNum(PurchBookTable_RU));
        qbdsPurchBook.addRange(fieldNum(PurchBookTable_RU, BookId)).value(queryValue(bookTable.BookId));

        QueryBuildDataSource qbdsPurchBookTrans = qbdsPurchBook.addDataSource(tableNum(PurchBookTrans_RU));
        qbdsPurchBookTrans.fields().addField(fieldNum(PurchBookTrans_RU, PurchBookTable_RU));
        qbdsPurchBookTrans.fields().addField(fieldNum(PurchBookTrans_RU, LineNum));
        qbdsPurchBookTrans.fields().addField(fieldNum(PurchBookTrans_RU, FactureId));
        qbdsPurchBookTrans.fields().addField(fieldNum(PurchBookTrans_RU, FactureExternalId));
        qbdsPurchBookTrans.fields().addField(fieldNum(PurchBookTrans_RU, FactureDate));
        qbdsPurchBookTrans.fields().addField(fieldNum(PurchBookTrans_RU, PaymentDate));
        qbdsPurchBookTrans.fields().addField(fieldNum(PurchBookTrans_RU, Annulment));
        qbdsPurchBookTrans.fields().addField(fieldNum(PurchBookTrans_RU, RevisionSeqNumber));
        qbdsPurchBookTrans.fields().addField(fieldNum(PurchBookTrans_RU, CountryGTD));
        qbdsPurchBookTrans.fetchMode(QueryFetchMode::One2Many);
        qbdsPurchBookTrans.joinMode(JoinMode::InnerJoin);
        qbdsPurchBookTrans.addLink(fieldNum(PurchBookTable_RU, RecId), fieldNum(PurchBookTrans_RU, PurchBookTable_RU), qbdsPurchBook.name());
        if (_isRevision)
        {
            qbdsPurchBookTrans.addRange(fieldNum(PurchBookTrans_RU, CorrectionType)).value(queryValue(enum2Int(FactureCorrectionType_RU::Revision)));
        }
        else
        {
            qbdsPurchBookTrans.addRange(fieldNum(PurchBookTrans_RU, RevisionType)).value(queryValue(enum2Int(FactureRevisionType_RU::Unknown)));
        }

        QueryBuildDataSource qbdsFactureJour = qbdsPurchBookTrans.addDataSource(tableNum(FactureJour_RU));
        qbdsFactureJour.fetchMode(QueryFetchMode::One2One);
        qbdsFactureJour.joinMode(JoinMode::InnerJoin);
        if (_isRevision)
        {
            qbdsFactureJour.addRange(fieldNum(FactureJour_RU, RefRevisedFacture)).value(
                strFmt(
                    '((%1.%2 != 0) && (%1.%2 == %3.%4) && (%1.%5 <= %3.%6))',
                    qbdsFactureJour.name(),
                    fieldStr(FactureJour_RU, RefRevisedFacture),
                    qbdsPurchBookTrans.name(),
                    fieldStr(PurchBookTrans_RU, RefRevisedFacture),
                    fieldStr(FactureJour_RU, RevisionNum),
                    fieldStr(PurchBookTrans_RU, RevisionSeqNumber)
                ));
            qbdsFactureJour.addRange(fieldNum(FactureJour_RU, RefRevisedFacture)).value(
                strFmt(
                    '((%1.%2 == 0) && (%1.%3 == %4.%5))',
                    qbdsFactureJour.name(),
                    fieldStr(FactureJour_RU, RefRevisedFacture),
                    fieldStr(FactureJour_RU, RecId),
                    qbdsPurchBookTrans.name(),
                    fieldStr(PurchBookTrans_RU, RefRevisedFacture)
                ));
        }
        else
        {
            qbdsFactureJour.addLink(fieldNum(PurchBookTrans_RU, FactureJour_RU), fieldNum(FactureJour_RU, RecId), qbdsPurchBookTrans.name());
            qbdsFactureJour.addLink(fieldNum(PurchBookTrans_RU, FactureId), fieldNum(FactureJour_RU, FactureId), qbdsPurchBookTrans.name());
        }

        QueryBuildDataSource qbdsFactureTrans = qbdsFactureJour.addDataSource(tableNum(FactureTrans_RU));
        qbdsFactureTrans.addLink(fieldNum(FactureJour_RU, FactureId), fieldNum(FactureTrans_RU, FactureId), qbdsFactureJour.name());
        qbdsFactureTrans.addLink(fieldNum(FactureJour_RU, Module), fieldNum(FactureTrans_RU, Module), qbdsFactureJour.name());
        qbdsFactureTrans.fields().addField(fieldNum(FactureTrans_RU, Unit));
        qbdsFactureTrans.fields().addField(fieldNum(FactureTrans_RU, Qty));
        qbdsFactureTrans.fields().addField(fieldNum(FactureTrans_RU, InventDimId));
        qbdsFactureTrans.fields().addField(fieldNum(FactureTrans_RU, LineAmountMST));
        qbdsFactureTrans.joinMode(JoinMode::InnerJoin);
        qbdsFactureTrans.fetchMode(QueryFetchMode::One2One);

        QueryBuildDataSource qbdsInventGTD = qbdsFactureTrans.addDataSource(tableNum(InventGTD_RU));
        qbdsInventGTD.fields().addField(fieldNum(InventGTD_RU, InventGTDId));
        qbdsInventGTD.joinMode(JoinMode::InnerJoin);
        qbdsInventGTD.fetchMode(QueryFetchMode::One2One);
        qbdsInventGTD.addLink(fieldNum(FactureTrans_RU, ItemId), fieldNum(InventGTD_RU, ItemId), qbdsFactureTrans.name());
        qbdsInventGTD.addLink(fieldNum(FactureTrans_RU, InventGTDId), fieldNum(InventGTD_RU, InventGTDId), qbdsFactureTrans.name());

        QueryBuildDataSource qbdsInventTable = qbdsInventGTD.addDataSource(tableNum(InventTable));
        qbdsInventTable.fields().addField(fieldNum(InventTable, ItemId));
        qbdsInventTable.fields().addField(fieldNum(InventTable, Product));
        qbdsInventTable.joinMode(JoinMode::InnerJoin);
        qbdsInventTable.fetchMode(QueryFetchMode::One2One);
        qbdsInventTable.addLink(fieldNum(InventGTD_RU, ItemId), fieldNum(InventTable, ItemId), qbdsInventGTD.name());

        QueryBuildDataSource qbdsInventTableModule = qbdsInventTable.addDataSource(tableNum(InventTableModule));
        qbdsInventTableModule.fields().addField(fieldNum(InventTableModule, UnitId));
        qbdsInventTableModule.joinMode(JoinMode::InnerJoin);
        qbdsInventTableModule.fetchMode(QueryFetchMode::One2One);
        qbdsInventTableModule.addRange(fieldNum(InventTableModule, ModuleType)).value(queryValue(ModuleInventPurchSales::Invent));
        qbdsInventTableModule.addLink(fieldNum(InventTable, ItemId), fieldNum(InventTableModule, ItemId), qbdsInventTable.name());

        QueryBuildDataSource qbdsUnitOfMeasure = qbdsInventTableModule.addDataSource(tableNum(UnitOfMeasure));
        qbdsUnitOfMeasure.fields().addField(fieldNum(UnitOfMeasure, RecId));
        qbdsUnitOfMeasure.joinMode(JoinMode::InnerJoin);
        qbdsUnitOfMeasure.fetchMode(QueryFetchMode::One2One);
        qbdsUnitOfMeasure.addLink(fieldNum(InventTableModule, UnitId), fieldNum(UnitOfMeasure, Symbol), qbdsInventTableModule.name());

        QueryBuildDataSource qbdsUnitOfMeasure_W = qbdsUnitOfMeasure.addDataSource(tableNum(UnitOfMeasure_W));
        qbdsUnitOfMeasure_W.fields().addField(fieldNum(UnitOfMeasure_W, NationalCode));
        qbdsUnitOfMeasure_W.joinMode(JoinMode::OuterJoin);
        qbdsUnitOfMeasure_W.fetchMode(QueryFetchMode::One2One);
        qbdsUnitOfMeasure_W.addLink(fieldNum(UnitOfMeasure, RecId), fieldNum(UnitOfMeasure_W, UnitOfMeasure), qbdsUnitOfMeasure.name());

        return queryPurchBook;
    }

]]></Source>
			</Method>
			<Method>
				<Name>factureTransQueryRun</Name>
				<Source><![CDATA[
    static private void factureTransQueryRun(Query _query)
    {
        PurchBookTrans_RU purchBookTrans;
        FactureTrans_RU factureTrans;
        InventGTD_RU inventGTD_RU;
        InventTable inventTable;
        EcoResProductCategory ecoResProductCategory;
        InventTableModule invTableModule;
        UnitOfMeasure_W inventUnitOfMeasureW;
        container curKey, curValue;
        Map factureGTDMap = new Map(Types::Container, Types::Container);

        QueryRun queryRun = new QueryRun(_query);
        while (queryRun.next())
        {
            UnitOfMeasureSymbol inventUnit;
            UnitOKEI unitOKEICode;
            UnitQty lineQty;
            boolean isCalculated = false;

            purchBookTrans = queryRun.get(tableNum(PurchBookTrans_RU));
            factureTrans = queryRun.get(tableNum(FactureTrans_RU));
            inventGTD_RU = queryRun.get(tableNum(InventGTD_RU));
            inventTable = queryRun.get(tableNum(InventTable));

            ecoResProductCategory = EcoResProductCategory::findByProductIdCategoryHierarchyRole(inventTable.Product, EcoResCategoryNamedHierarchyRole::Traceability);

            if (!ecoResProductCategory)
            {
                inventUnit = '';
                unitOKEICode = '';
            }
            else
            {
                invTableModule = queryRun.get(tableNum(InventTableModule));
                inventUnit = invTableModule.UnitId;
                inventUnitOfMeasureW = queryRun.get(tableNum(UnitOfMeasure_W));
                unitOKEICode = inventUnitOfMeasureW.NationalCode;
            }

            if (inventUnit != '' && factureTrans.Unit != inventUnit)
            {
                lineQty = InventTable::unitConvertValue(
                        inventTable.ItemId,
                        factureTrans.Unit,
                        inventUnit,
                        inventUnit,
                        factureTrans.Qty,
                        factureTrans.InventDimId);
            }
            else
            {
                lineQty = factureTrans.Qty;
            }

            AmountMST lineAmount = factureTrans.LineAmountMST;

            if (purchBookTrans.Annulment)
            {
                lineQty = -lineQty;
                lineAmount = -lineAmount;
            }

            curKey = [
                purchBookTrans.PurchBookTable_RU,
                purchBookTrans.LineNum,
                purchBookTrans.FactureId,
                purchBookTrans.FactureExternalId,
                inventGTD_RU.InventGTDId,
                inventUnit,
                unitOKEICode];

            if (factureGTDMap.exists(curKey))
            {
                curValue = factureGTDMap.lookup(curKey);
                isCalculated = true;
            }
            else
            {
                curValue = [0, 0];
            }

            factureGTDMap.insert(curKey, [lineQty + conPeek(curValue, LineQtyValueNum), lineAmount + conPeek(curValue, LineAmountValueNum), isCalculated]);
        }

        ttsbegin;

        BookDataCalc_Purch_RU::insertGTDLine(factureGTDMap);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertGTDLine</Name>
				<Source><![CDATA[
    private static void insertGTDLine(Map _factureGTDMap)
    {
        PurchBookTransTraceableInfo_RU transGTDInfo;
        RecordInsertList transGTDInfoList = new RecordInsertList(tableNum(PurchBookTransTraceableInfo_RU));
        container curKey, curValue;
        MapEnumerator factureGTDEnumerator = _factureGTDMap.getEnumerator();

        const int LinePurchBookTable = 1;
        const int LinePurchbookTransLineNum = 2;
        const int LineFactureCode = 3;
        const int LineFactureExternalCode = 4;
        const int LineGTDTraceabilityNumber = 5;
        const int LineInventoryUnit = 6;
        const int LineInventoryUnitOKEI = 7;

        while (factureGTDEnumerator.moveNext())
        {
            curKey = factureGTDEnumerator.currentKey();
            curValue = _factureGTDMap.lookup(curKey);

            if (!(conPeek(curValue, LineQtyValueNum) == 0 &&
                conPeek(curValue, LineAmountValueNum) == 0 &&
                conPeek(curValue, LineIsCalcValueNum)))
            {
                transGTDInfo.clear();

                transGTDInfo.PurchBookTable_RU = conPeek(curKey, LinePurchBookTable);
                transGTDInfo.PurchbookTransLineNum = conPeek(curKey, LinePurchbookTransLineNum);
                transGTDInfo.FactureCode = conPeek(curKey, LineFactureCode);
                transGTDInfo.FactureExternalCode = conPeek(curKey, LineFactureExternalCode);
                transGTDInfo.GTDTraceabilityNumber = conPeek(curKey, LineGTDTraceabilityNumber);
                transGTDInfo.InventoryUnit = conPeek(curKey, LineInventoryUnit);
                transGTDInfo.InventoryUnitOKEI = conPeek(curKey, LineInventoryUnitOKEI);

                if (transGTDInfo.InventoryUnit == '')
                {
                    transGTDInfo.InventoryUnitQty = 0;
                    transGTDInfo.PurchAmount = 0;
                }
                else
                {
                    transGTDInfo.InventoryUnitQty = conPeek(curValue, LineQtyValueNum);
                    transGTDInfo.PurchAmount = conPeek(curValue, LineAmountValueNum);
                }

                transGTDInfoList.add(transGTDInfo);
            }
        }

        transGTDInfoList.insertDatabase();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>