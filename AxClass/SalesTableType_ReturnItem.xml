<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesTableType_ReturnItem</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;
[SalesLineTypeFactoryAttribute(SalesType::ReturnItem, NoYes::No)]
class SalesTableType_ReturnItem extends SalesTableType
{
    #Retail
    NumberSeqFormHandler        numberSeqFormHandlerReturnItem;
    SalesTable                  salesTableExchange;
    SalesTable                  salesTableOriginal;
    MCRReturnSalesOrderRefund   mcrReturnSalesOrderRefund;
    SalesParameters             salesParameters;
    MCRSalesOrderTotals         mcrSalesOrderTotalsReturn;
    MCRSalesOrderTotals         rcmSalesOrderTotalsExchange;
    Set                         parentLotsValidated;
    boolean                     validatedComplete;
    private static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canAgreementBeLinked</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether an agreement can be linked to an order.
    /// </summary>
    /// <returns>
    ///    true if an agreement can be linked; otherwise, false.
    /// </returns>
    public boolean canAgreementBeLinked()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreatePurchOrder</Name>
				<Source><![CDATA[
    boolean canCreatePurchOrder()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchaseType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the corresponding <c>PurchaseType</c> value.
    /// </summary>
    /// <returns>Purchase order type value 'Return order'.</returns>
    public PurchaseType purchaseType()
    {
        return PurchaseType::ReturnItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPackingslipBeUpdated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether a sales order with the type return order can be packing slip updated.
    /// </summary>
    /// <param name="_documentStatus">
    ///    The current document status that indicates the latest sales order document updated.
    /// </param>
    /// <returns>
    ///    true if the sales order with the type return order can be packing slip updated; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    If the sales order contains a sales line with a return disposition code that does enable packing
    ///    slip update the <c>super</c> method will determine whether it is ok to update; otherwise, the
    ///    return value is false.
    /// </remarks>
    public boolean canPackingslipBeUpdated(DocumentStatus _documentStatus = DocumentStatus::None)
    {
        SalesLine               localSalesLine;
        ReturnDispositionCode   returnDispositionCode;
        boolean                 ret;

        select firstonly RecId from localSalesLine
            where localSalesLine.SalesId == salesTable.SalesId
            exists join returnDispositionCode
                where returnDispositionCode.DispositionCodeId == localSalesLine.ReturnDispositionCodeId &&
                      returnDispositionCode.DispositionAction != DispositionAction::CreditOnly;

        if (localSalesLine.RecId)
        {
            ret = super(_documentStatus);
        }
        else
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDelete</Name>
				<Source><![CDATA[
    boolean checkDelete(
        boolean _useWarning = false,
        boolean _treatInvoicedOrderUpdateWarningAsError = false)
    {
        boolean ret;

        if (salesTable.ReturnStatus == ReturnStatusHeader::Open)
        {
            ret = false;
        }
        else
        {
            ret = super(_useWarning, _treatInvoicedOrderUpdateWarningAsError);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkShipCarrierAddress</Name>
				<Source><![CDATA[
    public boolean checkShipCarrierAddress()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether a return order can be updated.
    /// </summary>
    /// <param name="_useWarning">
    ///    A Boolean value that specifies whether update of the invoiced return order can only be done after a
    ///    warning is displayed and accepted by the user.
    /// </param>
    /// <param name="_interCompanyCheck">
    ///    A Boolean value that specifies the intercompany that will be included in the check to see whether
    ///    it is ok to update.
    /// </param>
    /// <param name = "_treatInvoicedOrderUpdateWarningAsError">
    /// A boolean value that indicates whether the "Warning" access level to invoiced orders must be treated as "Locked".
    /// </param>
    /// <returns>
    ///    true if it is ok to modify the order; otherwise, false.
    /// </returns>
    public boolean checkUpdate(
        boolean _useWarning = true,
        boolean _interCompanyCheck = true,
        boolean _treatInvoicedOrderUpdateWarningAsError = false)
    {
        boolean     ret;

        if (salesTable.ReturnStatus == ReturnStatusHeader::Canceled ||
            salesTable.ReturnStatus == ReturnStatusHeader::None)
        {
            ret = false;
        }
        else
        {
            ret = super(_useWarning, _interCompanyCheck, _treatInvoicedOrderUpdateWarningAsError);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleted</Name>
				<Source><![CDATA[
    public void deleted()
    {
        super();

        if(!salesTable.returnItem() || salesTable.ReturnReplacementId)
        {
            EGAISWaybillJour_RU waybillJour, waybillJourUpd;

            select firstOnly waybillJour
                where waybillJour.ReturnOrderSalesId == salesTable.SalesId;

            if (waybillJour)
            {
                waybillJourUpd = EGAISWaybillJour_RU::findRecId(waybillJour.RecId, true);
                waybillJourUpd.ReturnOrderSalesId = '';
                waybillJourUpd.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dlvModeMandatory</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the sales order is COD.
    /// </summary>
    /// <returns>
    ///    true if sales order is COD; otherwise, false.
    /// </returns>
    boolean dlvModeMandatory()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editCustAccount</Name>
				<Source><![CDATA[
    boolean editCustAccount()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editDisc</Name>
				<Source><![CDATA[
    // Can discount fields be edited
    boolean editDisc()
    {
        // If doing a CallCenter/Retail Order return, we must be able to calculate discounts to match the same behavior that we have in POS.
        // The behavior of non-CallCenter/non-Retail Order returns will remain the same, since this method will always return false for non-CallCenter/non-Retail Orders.
        return RetailPricingEngine::useRetailPricingEngineForSalesOrder(salesTable.SalesId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodClose</Name>
				<Source><![CDATA[
    public void formMethodClose()
    {
        super();

        if (numberSeqFormHandlerReturnItem)
        {
            numberSeqFormHandlerReturnItem.formMethodClose();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceCreate</Name>
				<Source><![CDATA[
    public void formMethodDataSourceCreate(FormRun _element, FormDataSource _salestable_ds)
    {
        super(_element, _salestable_ds);
        this.numberSeqFormHandlerReturnItem(_element, _salestable_ds).formMethodDataSourceCreate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceDelete</Name>
				<Source><![CDATA[
    public void formMethodDataSourceDelete(FormRun _element, FormDataSource _salestable_ds, boolean _forced = false)
    {
        super(_element, _salestable_ds);
        this.numberSeqFormHandlerReturnItem(_element, _salestable_ds).formMethodDataSourceDelete(_forced);
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceLinkActive</Name>
				<Source><![CDATA[
    public void formMethodDataSourceLinkActive(FormRun _element, FormDataSource _salestable_ds)
    {
        super(_element, _salestable_ds);
        this.numberSeqFormHandlerReturnItem(_element, _salestable_ds).formMethodDataSourceLinkActive();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceValidateWrite</Name>
				<Source><![CDATA[
    public boolean formMethodDataSourceValidateWrite(FormRun _element, FormDataSource _salestable_ds)
    {
        boolean ret = super(_element, _salestable_ds);

        if (ret)
        {
            if (!this.numberSeqFormHandlerReturnItem(_element, _salestable_ds).formMethodDataSourceValidateWrite())
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceWrite</Name>
				<Source><![CDATA[
    public void formMethodDataSourceWrite(FormRun _element, FormDataSource _salestable_ds)
    {
        super(_element, _salestable_ds);
        this.numberSeqFormHandlerReturnItem(_element, _salestable_ds).formMethodDataSourceWrite();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodSalesTypeModifiedPostChange</Name>
				<Source><![CDATA[
    public void formMethodSalesTypeModifiedPostChange(FormRun         _element,
                                                      FormDataSource  _salestable_ds,
                                                      boolean         _forced = false
                                                     )
    {
        super(_element, _salestable_ds, _forced);
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodSalesTypeModifiedPreChange</Name>
				<Source><![CDATA[
    public void formMethodSalesTypeModifiedPreChange(FormRun          _element,
                                                     FormDataSource   _salestable_ds,
                                                     boolean          _forced = false
                                                    )
    {
        super(_element, _salestable_ds, _forced);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    public void  initValue()
    {
        super();
        
        salesTable.TransactionCode = IntrastatParameters::find().DefaultCreditNote;
        
        if (salesTable.returnItem())
        {
            salesTable.ReturnDeadline = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()) + SalesParameters::find().ReturnPeriodOfValidity;
        }

        salesTable.InterCompanyAutoCreateOrders = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inserted</Name>
				<Source><![CDATA[
    public void inserted()
    {
        super();

        this.MCRLinkReturnToOriginal();
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyCreateAllowed</Name>
				<Source><![CDATA[
    boolean interCompanyCreateAllowed()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventReservationInvoke</Name>
				<Source><![CDATA[
    boolean inventReservationInvoke()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lowestSalesStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the lowest status on the sales lines.
    /// </summary>
    /// <returns>
    /// The lowest status on the sales lines.
    /// </returns>
    public SalesStatus lowestSalesStatus()
    {
        SalesLine               salesLine;
        ReturnDispositionCode   returnDispositionCode;
        Set                     salesOrderStatusesSet = new Set(Types::Enum);

        while select SalesStatus from salesLine
            group by SalesStatus
            where   salesLine.SalesId       == salesTable.SalesId
            &&      salesLine.SalesStatus   !=  SalesStatus::None
            notexists join returnDispositionCode
                where returnDispositionCode.DispositionCodeId == salesLine.ReturnDispositionCodeId
                &&    (returnDispositionCode.DispositionAction == DispositionAction::Scrap || returnDispositionCode.DispositionAction == DispositionAction::ReplaceScrap)
                &&    salesLine.QtyOrdered > 0
        {
            salesOrderStatusesSet.add(salesLine.SalesStatus);
        }

        SalesStatusOrderedList salesStatusOrderedList = SalesStatusOrderedList::newFromOrder(SortOrder::Ascending);
        ListEnumerator salesStatusEnumerator = salesStatusOrderedList.getEnumerator();
        while (salesStatusEnumerator.moveNext())
        {
            if (salesOrderStatusesSet.in(salesStatusEnumerator.current()))
            {
                return salesStatusEnumerator.current();
            }
        }

        return SalesStatus::Backorder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayConfirmationBeUpdated</Name>
				<Source><![CDATA[
    boolean mayConfirmationBeUpdated()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayPackingSlipBeUpdated</Name>
				<Source><![CDATA[
    boolean mayPackingSlipBeUpdated()
    {
        return salesTable.returnItem();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayPickingListBeRegistered</Name>
				<Source><![CDATA[
    boolean mayPickingListBeRegistered()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayPickingListBeRegistrated</Name>
				<Source><![CDATA[
    public boolean mayPickingListBeRegistrated()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayPickingListBeUpdated</Name>
				<Source><![CDATA[
    boolean mayPickingListBeUpdated()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrComplete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs the order complete logic for this return order.
    /// </summary>
    /// <returns>
    /// The <c>MCROderRecapStatus</c> for the return order.
    /// </returns>
    public MCROrderRecapStatus mcrComplete()
    {
        MCROrderRecapStatus mcrOrderRecapStatus;

        try
        {
            mcrOrderRecapStatus = this.mcrCompleteReturn();
        }
        catch (Exception::Error)
        {
            throw error("@SYS93835");
        }

        return mcrOrderRecapStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCompleteReturn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Completes the return order.
    /// </summary>
    /// <returns>
    /// The new status of the return order.
    /// </returns>
    protected MCROrderRecapStatus mcrCompleteReturn()
    {
        MCROrderRecapStatus     recapStatus = MCROrderRecapStatus::Close;
        MCRHoldCodeTrans        mcrHoldCodeTrans;

        if (salesTableExchange.RecId == 0)
        {
            // Exchange order doesn't exist. Proceed with completion if return order is in open order state.
            if (salesTable.SalesStatus != SalesStatus::Backorder || !validatedComplete)
            {
                return recapStatus;
            }
        }
        else
        {
            // Exchange order exist. Proceed with completion if exchange order is in open order state.
            if (salesTableExchange.SalesStatus != SalesStatus::Backorder || !validatedComplete)
            {
                return recapStatus;
            }
        }

        if (!salesTable.selectForUpdate())
        {
            salesTable.selectForUpdate(true);
            salesTable.reread();
        }

        this.mcrRemoveUnselectedLines();

        // validate user has not credited/costed the customer more
        // adjustments on the return then allowed and that they
        // have created a payment method that is not allowed.
        this.mcrValidatePermissions();

        // Initialize totals
        mcrSalesOrderTotalsReturn = new MCRSalesOrderTotals(salesTable);
        if (salesTableExchange)
        {
            rcmSalesOrderTotalsExchange = new MCRSalesOrderTotals(salesTableExchange);
        }

        // Complete exchange order.
        if (salesTable.ReturnReplacementId
            && recapStatus != MCROrderRecapStatus::OpenNoAuth
            && recapStatus != MCROrderRecapStatus::OpenError
            && salesTableExchange.SalesStatus == SalesStatus::Backorder)
        {
            recapStatus = this.completeExchangeOrder();
        }
        // Get missing hold codes or do not submit data or close
        else if (!mcrHoldCodeTrans.getMissingHoldCodes(salesTableExchange))
        {
            mcrHoldCodeTrans.deleteExchangeHoldsForOrder(salesTableExchange.SalesId);
            return MCROrderRecapStatus::OpenError;
        }

        // Complete return order if its open.
        if (salesTable.SalesStatus == SalesStatus::Backorder
            && recapStatus != MCROrderRecapStatus::OpenError)
        {
            recapStatus = MCREndOrder::orderRecap(salesTable, mcrSalesOrderTotalsReturn);
            salesTable.reread();
        }

        this.mcrInterCompanyAutoCreateOrders();

        return recapStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>completeExchangeOrder</Name>
				<Source><![CDATA[
    protected MCROrderRecapStatus completeExchangeOrder()
    {
        MCRCustPaymTotals       mcrCustPaymTotals;
        MCROrderRecapStatus     recapStatus;

        if (this.shouldCheckPayment(salesTable))
        {
            mcrCustPaymTotals = MCRCustPaymTotals::construct(salesTableExchange.TableId,
                                                                salesTableExchange.RecId,
                                                                rcmSalesOrderTotalsExchange);

            if (!mcrCustPaymTotals.promptOverUnderPaym())
            {
                return MCROrderRecapStatus::OpenError;
            }
        }

        if (!this.mcrSetExchangeHolds())
        {
            if (!salesTableExchange.selectForUpdate())
            {
                salesTableExchange.selectForUpdate(true);
                salesTableExchange.reread();
            }

            recapStatus = MCREndOrder::orderRecap(salesTableExchange, rcmSalesOrderTotalsExchange);
            salesTableExchange.reread();
        }
        else
        {
            warning("@MCR10322");
            Box::warning("@MCR10322");
            recapStatus = MCROrderRecapStatus::OpenError;
        }

        return recapStatus;

    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCheckPayment</Name>
				<Source><![CDATA[
    protected boolean shouldCheckPayment(SalesTable _salesTable)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCreatePayments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates relevant payment records for the return order.
    /// </summary>
    public void mcrCreatePayments()
    {
        if (!mcrReturnSalesOrderRefund)
        {
            mcrReturnSalesOrderRefund = new MCRReturnSalesOrderRefund(salesTableOriginal, salesTable);
        }

        MCRSalesOrderTotals mcrSalesOrderReturnTotals = new MCRSalesOrderTotals(salesTable);
        AmountCur refundAmount = mcrSalesOrderReturnTotals.getTotalOrder();

        // If an exchange order has been created and the user has choosen
        // to apply the return credit to the exchange order then create an
        // on credit on the return that amount as long as the exchange order
        // total is not greater then the refund amount.  If it is greater,
        // then create the credit for the amount of the return.
        if (salesTableExchange && salesTable.mcrReturnSalesTable().ApplyCreditToExchange)
        {
            MCRSalesOrderTotals mcrSalesOrderExchangeTotals = new MCRSalesOrderTotals(salesTableExchange);
            AmountCur creditAmount = -mcrSalesOrderExchangeTotals.getTotalOrder();

            if (creditAmount < refundAmount)
            {
                creditAmount = refundAmount;
            }

            if (RetailPaymentsExchangeOrderCreditFlight::instance().isEnabled())
            {
                mcrReturnSalesOrderRefund.createCredit(refundAmount, NoYes::No);

                // Create offsetting record for exchange order because this happens 
                // if the return replacement id is passed to createCredit()
                mcrReturnSalesOrderRefund::createExchangeCredit(abs(creditAmount), salesTable.ReturnReplacementId);
            }
            else
            {
                mcrReturnSalesOrderRefund.createCredit(creditAmount, NoYes::No, salesTable.ReturnReplacementId);
            }

            // reduce the credit by the amount used to pay for the exchange order.
            refundAmount -= creditAmount;
        }

        // If there is a remaining amount after creating the credit for the exchange
        // refund it to additional pay methods.
        if (refundAmount < 0)
        {
            mcrReturnSalesOrderRefund.createRefund(refundAmount);
        }
        else
        {
            eventSource.EventWritePaymentsRefundAmountNotAvailable(salesTable.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCreateReturnArrival</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a return arrival journal.
    /// </summary>
    protected void mcrCreateReturnArrival()
    {
        WMSJournalTable     wmsJournalTable;
        InventDim           inventDim;

        WMSJournalNameId    wmsJournalNameId = WMSParameters::find().ReceptionJournalNameId;
        wmsJournalTable.initFromWMSJournalName(WMSJournalName::find(wmsJournalNameId));
        wmsJournalTable.InventTransType = InventTransType::Sales;
        wmsJournalTable.InventTransRefId = salesTable.SalesId;
        wmsJournalTable.ReturnItemNum = salesTable.ReturnItemNum;
        wmsJournalTable.VendAccount = salesTable.CustAccount;
        wmsJournalTable.InventDimId     = InventDim::findOrCreate(inventDim).InventDimId;

        if (wmsJournalTable.validateWrite())
        {
            wmsJournalTable.insert();
        }
        else
        {
            throw error("@SYS104318");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrDeleteExchange</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Deletes the corresponding exchange order for this return.
    /// </summary>
    /// <param name="clearExchAttributes">
    ///     The flag indicating if the link to the exchange order should be removed.
    /// </param>
    /// <remarks>
    ///     The clear exchange parameter should be set to true when deleting only the exchange.
    ///     If also deleting the return record then there's no need to update these attributes.
    /// </remarks>
    public void mcrDeleteExchange(boolean clearExchAttributes)
    {
        SalesTable      salesTableExch;

        try
        {
            ttsBegin;

            // If return is tied to an exchange order
            if (salesTable.ReturnReplacementId)
            {
                salesTable.mcrDeleteExchange();

                if (clearExchAttributes)
                {
                    if (!salesTable.selectForUpdate())
                    {
                        salesTable.selectForUpdate(true);
                        salesTable.reread();
                    }

                    salesTable.ReturnReplacementId = '';
                    salesTable.ReturnReplacementCreated = NoYes::No;
                    salesTable.doUpdate();
                }
            }

            ttsCommit;
        }
        catch (Exception::Error)
        {
            ttsabort;
            throw error("@SYS93835");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrHasKitReturnBeenValidated</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if the class has already validated
    ///     the parent lot id.
    /// </summary>
    /// <param name="_parentLotId">
    ///     The parent lot ID of the kit being checked for validation.
    /// </param>
    /// <returns>
    ///     true if the parent lot ID has been validated; otherwise, false.
    /// </returns>
    protected boolean mcrHasKitReturnBeenValidated(InventTransId _parentLotId)
    {
        boolean         kitValidated = false;

        SetEnumerator setEnum = parentLotsValidated.getEnumerator();

        while (setEnum.moveNext())
        {
            if (setEnum.current() == _parentLotId)
            {
                kitValidated = true;
                break;
            }
        }

        return kitValidated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrHasQtyReturned</Name>
				<Source><![CDATA[
    private boolean mcrHasQtyReturned()
    {
        boolean     ret;
        SalesLine   salesLine;
        InventTrans inventTrans;
        InventTransOrigin inventTransOrigin;
        select firstonly RecId from salesLine
            where   salesLine.SalesId == salesTable.SalesId
            exists join inventTransOrigin
            where inventTransOrigin.InventTransId == salesLine.InventTransId
            exists join inventTrans
            where   inventTrans.InventTransOrigin == inventTransOrigin.RecId
                && inventTrans.StatusReceipt == StatusReceipt::Purchased
                && inventTrans.StatusIssue == StatusIssue::None;
        if (salesLine)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrHasQtyToBeReturned</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the sales order has quantity eligible for return.
    /// </summary>
    /// <returns>
    /// true if the sales order has quantity eligible for return; otherwise, false.
    /// </returns>
    public boolean mcrHasQtyToBeReturned()
    {
        boolean     ret;
        if ((select firstonly RecId from salesLine
                where   salesLine.SalesDeliverNow
                    && salesLine.SalesId == salesTable.SalesId).RecId)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrInterCompanyAutoCreateOrders</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates corresponding intercompany orders after returns and exchanges have
    ///     been completed.
    /// </summary>
    private void mcrInterCompanyAutoCreateOrders()
    {
        if (salesTable.ReturnStatus == ReturnStatusHeader::Created)
        {
            salesTable.mcrInterCompanyAutoCreateOrders();
        }

        if (salesTableExchange.MCROrderStopped == NoYes::No)
        {
            salesTableExchange.mcrInterCompanyAutoCreateOrders();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrInvoiceReturnOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes invoicing logic for the return order.
    /// </summary>
    /// <param name="_specQty">
    /// The <c>SalesUpdate</c> enumeration value used in update the <c>SalesFormLetter</c> class.
    /// </param>
    public void mcrInvoiceReturnOrder(SalesUpdate _specQty = SalesUpdate::PackingSlip)
    {
        if (salesTable.ReturnStatus == ReturnStatusHeader::Open)
        {
            // Don't worry about catch weights
            // at invoicing time - they will be recorded during packing.
            // Invoice Order
            SalesFormLetter salesFormLetter = SalesFormLetter::construct(DocumentStatus::Invoice);

            salesFormLetter.allowEmptyTable(salesFormLetter.initAllowEmptyTable(true));
            salesFormLetter.multiForm(true);
            salesFormLetter.getLast();
            salesFormLetter.update(salesTable,
                                   DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                                   _specQty,
                                   AccountOrder::None,
                                   NoYes::No, // Proforma
                                   NoYes::No, // print form letter
                                   NoYes::No, // use print management
                                   NoYes::No);      // credit remaining

            salesTable.reread();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrIsEnoughCreditPostedForExchange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether enough credit has been posted to satisfy the exchange order.
    /// </summary>
    /// <returns>
    /// true if enough credit has been posted to satisfy the exchange order; otherwise, false.
    /// </returns>
    protected boolean mcrIsEnoughCreditPostedForExchange()
    {
        MCRCustPaymTable    mcrCustPaymTable;
        AmountCur           postedAmount = 0;
        boolean             ret;
        // Get the return credit.
        select mcrCustPaymTable
                where   mcrCustPaymTable.RefRecId == salesTable.RecId &&
                        mcrCustPaymTable.RefTableId == salesTable.TableId &&
                        mcrCustPaymTable.CustPaymType == MCRCustPaymType::OnAccount;

        // Get the posted amount of the return credit.
        postedAmount = mcrCustPaymTable.getPostedAmount();

        // Get the credit applied to the exchange.
        select firstOnly Amount from mcrCustPaymTable    // NOTE:  selective fields
                where   mcrCustPaymTable.RefRecId == salesTableExchange.RecId &&
                        mcrCustPaymTable.RefTableId == salesTableExchange.TableId &&
                        mcrCustPaymTable.CustPaymType == MCRCustPaymType::OnAccount;

        // Check the amount posted on the return and if it will cover the
        // on account amount on the exchange then return true;
        if (abs(postedAmount) >= mcrCustPaymTable.Amount)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrLinkReturnToOriginal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a link between the return order and the original sales order.
    /// </summary>
    protected void mcrLinkReturnToOriginal()
    {
        SalesTableLinks     salesTableLinks;
        SalesId origSalesId = salesTable.mcrReturnSalesTable().OriginalSalesId;
        if (salesTable.SalesId
            && origSalesId)
        {
            salesTableLinks.MainSalesId = origSalesId;
            salesTableLinks.SubSalesId = salesTable.SalesId;

            if (salesTableLinks.validateWrite())
            {
                salesTableLinks.insert();
            }
            else
            {
                throw error("@SYS104318");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPackReturnOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs packing logic for the return order.
    /// </summary>
    public void mcrPackReturnOrder()
    {
        if (salesTable.ReturnStatus == ReturnStatusHeader::Open)
        {
            // Pack Order
            SalesFormLetter salesFormLetter = SalesFormLetter::construct(DocumentStatus::PackingSlip);

            salesFormLetter.allowEmptyTable(salesFormLetter.initAllowEmptyTable(true));
            salesFormLetter.multiForm(true);
            salesFormLetter.getLast();
            salesFormLetter.update(salesTable,
                                    DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                                    SalesUpdate::DeliverNow,
                                    AccountOrder::None,
                                    NoYes::No, // Proforma
                                    NoYes::No, // print form letter
                                    NoYes::No, // use print management
                                    NoYes::No);      // credit remaining

            salesTable.reread();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPostReturnArrival</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the return arrival journal.
    /// </summary>
    protected void mcrPostReturnArrival()
    {
        WMSJournalId wmsJournalId = WMSJournalTable::MCRFindWHArrivalJournal(salesTable.SalesId).JournalId;

        if (wmsJournalId)
        {
            WMSJournalCheckPostReception wmsJournalCheckPostRect = WMSJournalCheckPostReception::construct();
            wmsJournalCheckPostRect.parmJournalId(wmsJournalId);
            wmsJournalCheckPostRect.parmJournalTableId(tableNum(WMSJournalTable));
            wmsJournalCheckPostRect.parmJournalCheckPostType(JournalCheckPostType::Post);
            // Ccharge creation, it's already been done
            wmsJournalCheckPostRect.parmMCRSkipMiscCharges(true);
            wmsJournalCheckPostRect.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrRemoveUnselectedLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes return lines that have no quantity being returned.
    /// </summary>
    protected void mcrRemoveUnselectedLines()
    {
        SalesLine           salesLine;
        ttsBegin;
        SalesStatus salesStatus = salesTable.SalesStatus;
        ReturnStatusHeader returnStatus = salesTable.ReturnStatus;

        delete_from salesLine
            where   salesLine.SalesId == salesTable.SalesId &&
                salesLine.ExpectedRetQty == 0;

        // prevent system from changing
        // the status of the return due to the delete.
        salesTable.reread();
        if (salesTable.SalesStatus != salesStatus ||
           salesTable.ReturnStatus != returnStatus)
        {
            salesTable.SalesStatus = salesStatus;
            salesTable.ReturnStatus = returnStatus;

            salesTable.doUpdate();
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrSetExchangeHolds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Puts the exchange order on hold until the original products have been returned if the
    /// user determines as such is needed.
    /// </summary>
    /// <returns>
    /// true if the return order is put on hold; otherwise, false.
    /// </returns>
    public boolean mcrSetExchangeHolds()
    {
        MCRHoldCodeTrans        holdCodeTrans;
        boolean                 onAccountExists;
        boolean                 holdCreated;
        MCRReturnSalesTable     mcrReturnSalesTable = salesTable.mcrReturnSalesTable();

        if (this.shouldSkipSetExchangeHolds(salesTable))
        {
            // exchange for return does not exist
            return holdCreated;
        }

        if (MCRCustPaymTable::findOnAcct(salesTableExchange.RecId, salesTableExchange.TableId))
        {
            onAccountExists = true;
        }

        // If the exchange has an on account pay method and the user has signified
        // that the exchange should be held until the return product is received then put the
        // exchange on hold until return product is receive.
        // We will put the Replacement order on Hold only if the Return order is in Backorder state.
        // For other statuses such as Delivered and Invoiced, the return order should not impact the Replacement order.
        if (onAccountExists
            && salesTable.SalesStatus == SalesStatus::Backorder
            && mcrReturnSalesTable.AdvanceExchange == MCRAdvanceExchange::DoNotRelease
            && ! this.mcrIsEnoughCreditPostedForExchange())
        {
            // Put exchange on pending return hold.
            holdCodeTrans.insertExchangePendingCreditHold(salesTableExchange.SalesId);
            holdCreated = true;
        }
        else if (!RetailNotRemoveReplacementManualOrderHolds::instance().isEnabled() || !MCRHoldCodeTrans::existsManualHolds(salesTableExchange.SalesId))
        {
            // Remove the pending hold
            MCRHoldCodeTrans::deletePendingReturnHold(salesTableExchange.SalesId);
        }

        if (!rcmSalesOrderTotalsExchange)
        {
            rcmSalesOrderTotalsExchange = new MCRSalesOrderTotals(salesTableExchange);
        }

        // Check if the payments balance
        // Call accessor instead of using container
        AmountCur exchangeTotal = rcmSalesOrderTotalsExchange.getTotalOrder();
        AmountCur paymTotal = salesTableExchange.mcrGetTotalPaymAmount();

        if (exchangeTotal > paymTotal)
        {
            // Put exchange on pending return hold.
            holdCodeTrans.insertExchangePaymBalanceHold(salesTableExchange.SalesId);
            holdCreated = true;
        }

        return holdCreated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipSetExchangeHolds</Name>
				<Source><![CDATA[
    protected boolean shouldSkipSetExchangeHolds(SalesTable _salesTable)
    {
        return !_salesTable.ReturnReplacementId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrUpdateExchangeReturnHold</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs end order logic if there are no holds for the return order.
    /// </summary>
    public void mcrUpdateExchangeReturnHold()
    {
        if (MCRHoldCodeTrans::isOrderOnPendingReturnHold(salesTableExchange.SalesId))
        {
            if (salesTable.mcrReturnSalesTable().ApplyCreditToExchange
                && (salesTable.ReturnStatus == ReturnStatusHeader::Closed
                || this.mcrIsEnoughCreditPostedForExchange()))
            {
                // Clear the pending return hold.
                MCRHoldCodeTrans::clearPendingReturnHold(salesTableExchange.SalesId);

                if (MCRHoldCodeTrans::getNumActiveHolds(salesTableExchange.SalesId) == 0)
                {
                    // Call End Order for exchange if there are no active holds.
                    if (!salesTableExchange.selectForUpdate())
                    {
                        salesTableExchange.selectForUpdate(true);
                        salesTableExchange.reread();
                    }

                    MCREndOrder::orderRecap(salesTableExchange, rcmSalesOrderTotalsExchange);
                    salesTableExchange.reread();

                    // Generate the IC exchange order (if set up to be  an IC
                    // transaction) when the exchange is released from all holds.
                    if (salesTableExchange.SalesStatus == SalesStatus::Backorder
                        && salesTableExchange.MCROrderStopped == NoYes::No)
                    {
                        salesTableExchange.mcrInterCompanyAutoCreateOrders();
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrValidateAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the user is allowed to create total miscellaneous
    ///     charges for the return sales order.
    /// </summary>
    /// <returns>
    /// true if the user is allowed to create total miscellaneous charges; otherwise, false.
    /// </returns>
    protected boolean mcrValidateAdjustments()
    {
        if (#MCRPriceOverrideEnabled)
        {
            MCRReturnOverride_MiscCharge     mcrReturnOverride_MiscCharge;
            mcrReturnOverride_MiscCharge = new MCRReturnOverride_MiscCharge();
            mcrReturnOverride_MiscCharge.suppressErrors(true);

            return mcrReturnOverride_MiscCharge.isUserAllowed(curUserId(), salesTable);
        }
        else
        {
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrValidateComplete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the completion of the return order.
    /// </summary>
    /// <returns>
    /// true if the return order is valid; otherwise, false.
    /// </returns>
    public boolean mcrValidateComplete()
    {
        SalesLine           salesLineReturn;

        WMSJournalTrans     wmsJournalTrans;
        MCRReturnSalesTable    mcrReturnSalesTable = salesTable.mcrReturnSalesTable();

        validatedComplete   = true;
        parentLotsValidated = new Set(Types::String);

        while select InventTransIdReturn from salesLineReturn
            where  salesLineReturn.SalesId == salesTable.SalesId
                && salesLineReturn.ExpectedRetQty
        {
            SalesLine salesLineOriginal = SalesLine::findInventTransId(salesLineReturn.InventTransIdReturn);
            InventTable inventTable = InventTable::find(salesLineOriginal.ItemId);

            if (wmsJournalTrans.quarantineControl() == NoYes::Yes)
            {
                InventDim inventDimWMSTrans = wmsJournalTrans.inventDim();
                if (InventLocation::find(inventDimWMSTrans.InventLocationId).InventLocationType != InventLocationType::Quarantine)
                {
                    validatedComplete = checkFailed("@MCR30677");
                }
            }
        }

        return validatedComplete;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrValidatePaymentMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the user is allowed to override payment methods on the return order.
    /// </summary>
    /// <returns>
    /// true if the user is allowed to override payment methods on a return; otherwise, false.
    /// </returns>
    protected boolean mcrValidatePaymentMethod()
    {
        if (#MCRPriceOverrideEnabled)
        {
            MCRReturnOverride_PaymentMethod  returnOverride_PaymentMethod;

            returnOverride_PaymentMethod = new MCRReturnOverride_PaymentMethod();
            returnOverride_PaymentMethod.suppressErrors(true);

            return returnOverride_PaymentMethod.IsUserAllowed(curUserId(), SalesTable);
        }
        else
        {
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrValidatePermissions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the permissions on the return order.
    /// </summary>
    protected void mcrValidatePermissions()
    {
        boolean                         userValidForPaymMethod;
        boolean                         userValidForMiscCharge;
        #define.UserValid('UserValid')
        #define.Cancel('Cancel')

        if (#MCRPriceOverrideEnabled)
        {
            userValidForMiscCharge = this.mcrValidateAdjustments();
            userValidForPaymMethod = this.mcrValidatePaymentMethod();

            if (!userValidForPaymMethod || !userValidForMiscCharge)
            {
                Args args = MCRReturnOverride::launchReturnOverrideLogin(salesTable);
                if (args.parm() == #UserValid)
                {
                    userValidForMiscCharge = true;
                    userValidForPaymMethod = true;
                }
                else if (args.parm() == #Cancel)
                {
                    throw Exception::Error;
                }
            }
        }
        else
        {
            userValidForMiscCharge = true;
            userValidForPaymMethod = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrValidateUpdatePhysical</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates the any payment authrization required for a physical update to take place.
    /// </summary>
    /// <param name="_salesLineReturn">
    ///     The sales line being validated for update.
    /// </param>
    /// <returns>
    ///     true if the physical update can be executed without error; otherwise, false.
    /// </returns>
    /// <remarks>
    ///     This method is intended to be called for returns (not an RMA).
    ///     When the user completes a return the system will immediately try
    ///     to invoice it if all payment methods have been authorized.  This
    ///     same validation runs through the call to invoicing, therefore, rather
    ///     then let the user submit a return that will fail half way through
    ///     the process make them go back and resolve their errors.  Also
    ///     beneficial to pre-validate in the case where the refund payment
    ///     method needs to be authorized.  When the authorization takes
    ///     place the return will automatically be invoiced, however, the user
    ///     authorizing it may not have access to the return or know how to
    ///     resolve the issue.
    /// </remarks>
    protected boolean mcrValidateUpdatePhysical(SalesLine _salesLineReturn)
    {
        InventTrans     inventTrans;
        InventTransOrigin   inventTransOrigin;
        StatusReceipt   fromStatusReceipt;
        StatusReceipt   toStatusReceipt;
        boolean         ok = true;
        InventMovement movement = InventMovement::construct(_salesLineReturn);

        if (movement.mustBeRegistered())
        {
            fromStatusReceipt = StatusReceipt::Registered;
            toStatusReceipt   = StatusReceipt::Registered;
        }
        else
        {
            fromStatusReceipt = StatusReceipt::Registered;
            toStatusReceipt   = StatusReceipt::Ordered;
        }

        while select inventTrans
            order by StatusReceipt, InventDimId
            where inventTrans.StatusIssue     == StatusIssue::None
                && inventTrans.StatusReceipt   >= fromStatusReceipt
                && inventTrans.StatusReceipt   <= toStatusReceipt
                && inventTrans.TransChildType  == movement.transChildType()
                && inventTrans.TransChildRefId == movement.transChildRefId()
            exists join inventTransOrigin
            where inventTransOrigin.InventTransId == movement.transId()
                && inventTrans.InventTransOrigin == inventTransOrigin.RecId
        {
            if (!movement.checkDimPhysical(inventTrans.Qty, inventTrans.inventDim(), true))
                ok = checkFailed("@SYS18447");
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    public void modifiedField(FieldId _fieldId
        , TableId _tableId = tableNum(SalesTable)
        , boolean _uiEnabled = true
        )
    {
        super(_fieldId
            // <GEERU>
            , _tableId
            // </GEERU>
            );

        // <GEERU>
        if (_tableId == tableNum(SalesTable))
        {
            // </GEERU>
            switch (_fieldId)
            {
                case fieldNum(SalesTable, ReturnReasonCodeId):
                    salesTable.createReturnMarkupTrans();
                    break;

                case fieldNum(SalesTable, InterCompanyDirectDelivery):
                    salesTable.interCompanyDirectDeliveryReturn();
                    break;

                case fieldNum(SalesTable, CustAccount):
                case fieldNum(SalesTable, InventLocationId):
                case fieldNum(SalesTable, InventSiteId):
                    salesTable.setReturnAddressFromInventLocationId(salesTable.InventLocationId);
                    break;

                default: break;
            }
            // <GEERU>
        }
        // </GEERU>
        else if (_tableId == tableNum(MCRReturnSalesTable)
                    && isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            MCRReturnSalesTable mcrReturnSalesTable = salesTable.mcrReturnSalesTable();
            switch (_fieldId)
            {
                case(fieldNum(MCRReturnSalesTable, AdvanceExchange)):
                    // If credit has to be applied to an exchange, set the value.
                    if (salesTable.ReturnItemNum
                        && (mcrReturnSalesTable.AdvanceExchange == MCRAdvanceExchange::ReleaseExchangeOrder
                        || mcrReturnSalesTable.AdvanceExchange == MCRAdvanceExchange::DoNotRelease) )
                    {
                        mcrReturnSalesTable.ApplyCreditToExchange = NoYes::Yes;
                    }
                    else if (salesTable.ReturnItemNum
                        && mcrReturnSalesTable.AdvanceExchange == MCRAdvanceExchange::BLANK)
                    {
                        mcrReturnSalesTable.ApplyCreditToExchange = NoYes::No;
                    }
                    break;

                case(fieldNum(MCRReturnSalesTable,ApplyCreditToExchange)):
                    // Set the advance exchange to do not release if the return type is an RMA.
                    if (salesTable.ReturnItemNum)
                    {
                        if (mcrReturnSalesTable.ApplyCreditToExchange == NoYes::Yes)
                        {
                            mcrReturnSalesTable.AdvanceExchange = MCRAdvanceExchange::DoNotRelease;
                        }
                        else
                        {
                            mcrReturnSalesTable.AdvanceExchange = MCRAdvanceExchange::BLANK;
                        }
                    }
                    break;
            }
            salesTable.mcrPackMCRReturnSalesTable(mcrReturnSalesTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates a new instance of the <c>SalesTableType_ReturnItem</c> class.
    /// </summary>
    /// <param name="_salesTable">
    /// The <c>SalesTable</c> record used for the initialization.
    /// </param>
    public void new(SalesTable _salesTable)
    {
        super(_salesTable);

        salesTableOriginal = SalesTable::find(_salesTable.mcrReturnSalesTable().OriginalSalesId);

        if (_salesTable.ReturnReplacementId)
        {
            salesTableExchange = SalesTable::find(_salesTable.ReturnReplacementId);
        }

        salesParameters = SalesParameters::find();
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberSeqFormHandlerReturnItem</Name>
				<Source><![CDATA[
    protected NumberSeqFormHandler numberSeqFormHandlerReturnItem(FormRun _element, FormDataSource _salestable_ds)
    {
        if (!numberSeqFormHandlerReturnItem)
        {
            numberSeqFormHandlerReturnItem = NumberSeqFormHandler::newForm(SalesParameters::numRefReturnItemNum().NumberSequenceId,
                                                                 _element,
                                                                 _salestable_ds,
                                                                 fieldNum(SalesTable, ReturnItemNum)
                                                                );
        }
        return numberSeqFormHandlerReturnItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether this is the return item.
    /// </summary>
    /// <returns>
    ///    true if it is the return item; otherwise, false.
    /// </returns>
    boolean returnItem()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showProductionMenu</Name>
				<Source><![CDATA[
    boolean  showProductionMenu()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the related deletion criteria of the sales return order.
    /// </summary>
    /// <param name="_mcrCancel">
    /// Indicates the order was cancelled.
    /// </param>
    /// <returns>
    /// true if the sales return order in question can be deleted; otherwise, false.
    /// </returns>
    public boolean validateDelete(boolean _mcrCancel = false)
    {
        boolean ret = true;

        if (FormDataUtil::isFormDataSource(salesTable))
        {
            ret = salesTable.returnValidateDeleteReplaceId();
        }

        if (ret)
        {
            if (salesTable.ReturnStatus == ReturnStatusHeader::Open)
            {
                if (SalesLine::find(salesTable.SalesId))
                {
                    // Open return orders cannot be deleted
                    ret = checkFailed("@SYS106097");
                }
            }
            else
            {
                ret = super(_mcrCancel);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates a field in the <c>SalesTable</c> table.
    /// </summary>
    /// <param name="_fieldIdToCheck">
    ///    The field ID of the field to validate.
    /// </param>
    /// <param name="_tableId">
    ///    The table ID of the field.
    /// </param>
    /// <returns>
    ///    true if the value in the field is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The <c>ReturnDeadline</c> field is checked to make sure that it is not before the created date and
    ///    that the created date is not specified before system date.
    /// </remarks>
    public boolean validateField(FieldId _fieldIdToCheck
        , TableId _tableId = tableNum(SalesTable)
        )
    {
        boolean ok = true;
        date    testDate;

        // <GEERU>
        if (_tableId == tableNum(SalesTable))
        {
            // </GEERU>
            switch (_fieldIdToCheck)
            {
                case fieldNum(SalesTable, ReturnDeadline) :
                    if (salesTable.ReturnDeadline)
                    {
                        if (salesTable.CreatedDateTime)
                        {
                            testDate = DateTimeUtil::date(salesTable.CreatedDateTime);
                        }
                        else
                        {
                            testDate = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone());
                        }

                        if (salesTable.ReturnDeadline < testDate)
                        {
                            // Return deadline date must be greater than the created date.
                            ok = checkFailed("@SYS104092");
                        }
                    }
                    break;

                case fieldNum(SalesTable, SettleVoucher):
                    if (salesTable.orig().SettleVoucher == SettlementType::SelectedTransact
                        && salesTable.SettleVoucher == SettlementType::None)
                    {
                        info("@SalesAndMarketing:MarkedTransactionsExist");
                    }
                    break;

                case(fieldNum(SalesTable, SalesType)):
                    ok = this.blockManualTypeChange();
                    break;

                case fieldNum(SalesTable, InterCompanyAutoCreateOrders):
            
                    if (salesTable.InterCompanyAutoCreateOrders && !salesTable.InterCompanyDirectDelivery)
                    {
                        ok = checkFailed(strFmt("@SalesAndMarketing:IntercompanySalesReturnDirectDeliveryCheckInterCompanyAutoCreateOrders", fieldId2pname(tableNum(SalesTable), fieldNum(SalesTable,InterCompanyAutoCreateOrders)), fieldId2pname(tableNum(SalesTable),fieldNum(SalesTable, InterCompanyDirectDelivery))));
                    }

                    if (!salesTable.InterCompanyAutoCreateOrders && salesTable.InterCompanyDirectDelivery)
                    {
                        ok = checkFailed(strFmt("@SalesAndMarketing:IntercompanySalesReturnDirectDeliveryUnCheckInterCompanyAutoCreateOrders", fieldId2pname(tableNum(SalesTable), fieldNum(SalesTable,InterCompanyAutoCreateOrders)), fieldId2pname(tableNum(SalesTable), fieldNum(SalesTable,InterCompanyDirectDelivery))));
                    }
                    break;
            }
            // <GEERU>
        }
        // </GEERU>
        else if (_tableId == tableNum(MCRReturnSalesTable)
                && isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            MCRReturnSalesTable mcrReturnSalesTable = salesTable.mcrReturnSalesTable();
            switch (_fieldIdToCheck)
            {
                case(fieldNum(MCRReturnSalesTable, AdvanceExchange)):
                    // If return is an RMA w/ an exchange and the user has designated to apply the return
                    // credit to the exchange then if a release type hasn't been entered error.
                    if (salesTable.ReturnItemNum
                        && !mcrReturnSalesTable.AdvanceExchange
                        && salesTable.ReturnReplacementId
                        && mcrReturnSalesTable.ApplyCreditToExchange
                        && RetailMCRChannelTable::mcrEnableOrderCompletion(salesTable))
                    {
                        ok = checkFailed("@MCR23090");
                    }
                    break;
            }
        }

        if (ok)
        {
            ok = super(_fieldIdToCheck
                // <GEERU>
                , _tableId
                // </GEERU>
                );
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    boolean  validateWrite()
    {
        boolean     ok = true;
        MCRReturnSalesTable     mcrReturnSalesTable = salesTable.mcrReturnSalesTable();

        ok = super();
        ok = ok && this.validateReturnItemNum();

        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            // If return is an RMA w/ an exchange and the user has designated to apply the return
            // credit to the exchange then if a release type hasn't been entered error.
            if (salesTable.ReturnItemNum &&
               !mcrReturnSalesTable.AdvanceExchange &&
               salesTable.ReturnReplacementId &&
               mcrReturnSalesTable.ApplyCreditToExchange)
            {
                ok = checkFailed("@MCR23090");
            }

            // User cannot advance the credit when there is an exchage order.
            if (mcrReturnSalesTable.AdvanceCredit && salesTable.ReturnReplacementId)
            {
                ok = checkFailed("@MCR23366");
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateReturnItemNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the entered RMA number is valid.
    /// </summary>
    /// <returns>A boolean value indicating whether the entered RMA number is valid.</returns>
    private boolean validateReturnItemNum()
    {
        boolean ok = true;
        if (!salesTable.ReturnItemNum)
        {
            // RMA number is not filled in
            ok = checkFailed("@SYS24805");
        }
        else
        {
            SalesTable salesTableDuplicate = SalesTable::findReturnItemNum(salesTable.ReturnItemNum);
            if (salesTableDuplicate && salesTableDuplicate.RecId != salesTable.RecId)
            {
                // A return order with RMA number '%1' already exists.
                ok = checkFailed(strFmt("@SYS125500", salesTable.ReturnItemNum));
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesLineDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Makes <c>SalesLine</c> table deletion-related updates to the <c>SalesTable</c> table.
    /// </summary>
    public void updateSalesLineDelete()
    {
        super();

        // Deleting the last SalesLine record of a return order, the settlement is deleted too.
        if (!salesTable.existSalesLine())
        {
            SpecTransManager::newFromSpec(salesTable).deleteAll();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    [SysObsolete('Use SalesTableType::construct() instead.', false, 31\05\2017)]
    static SalesTableType  construct(SalesTable salesTable)
    {
        if (salesTable.ProjId)
            return new SalesTableType_ProjectReturnItem(salesTable);

        return new SalesTableType_ReturnItem(salesTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrAdjustReturnCredit</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adjusts return credit when disposition code with a
    ///     misc. charge has caused the sales total to change.
    /// </summary>
    /// <param name="_salesTableReturn">
    ///     The sales table whose return credit is being adjusted.
    /// </param>
    public static void mcrAdjustReturnCredit(SalesTable _salesTableReturn)
    {
        if (!_salesTableReturn.selectForUpdate())
        {
            _salesTableReturn.selectForUpdate(true);
            _salesTableReturn.reread();
        }

        SalesTable salesTableOrig = SalesTable::find(_salesTableReturn.mcrReturnSalesTable().OriginalSalesId);

        MCRReturnSalesOrderRefund_Adj mcrReturnSalesOrderRefund_Adj = new MCRReturnSalesOrderRefund_Adj(salesTableOrig, _salesTableReturn);
        mcrReturnSalesOrderRefund_Adj.adjustReturnCredit();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldAdjustReturnCredit</Name>
				<Source><![CDATA[
    public static boolean shouldAdjustReturnCredit(SalesTable _salesTable)
    {
        return RetailMCRChannelTable::mcrEnableOrderCompletion(_salesTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCancelExchange</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Cancels only the exchange order associated with the return table, and re-adjusts the payments.
    /// </summary>
    /// <param name="_salesTableReturn">
    ///     The sales order whose exchange is being canceled.
    /// </param>
    /// <returns>
    ///     true if the exhcange is canceled successfully; otherwise, false.
    /// </returns>
    public static boolean mcrCancelExchange(SalesTable _salesTableReturn)
    {
        boolean ret = true;
        AmountCur           totalBefore = 0;
        // look at SalesTable instead of ReturnTable
        if (_salesTableReturn.ReturnReplacementId)
        {
            // Needed for processing.
            SalesTable exchangeSalesTable = SalesTable::find(_salesTableReturn.ReturnReplacementId, true);
            ret = MCRSalesOrderCancellation::cancelOrder(exchangeSalesTable, false);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCancelReturn</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Cancels only the return order associated with the sales order, and re-adjusts the payments.
    /// </summary>
    /// <param name="_salesTableReturn">
    ///     The sales order whose return order is being canceled.
    /// </param>
    /// <returns>
    ///     true if the return order is canceled successfully; otherwise, false.
    /// </returns>
    public static boolean mcrCancelReturn(SalesTable _salesTableReturn)
    {
        boolean ret = true;
        AmountCur           totalBefore = 0;

        // look at SalesTable instead of ReturnTable
        if (_salesTableReturn.RecId)
        {
            MCRSalesOrderCancellation::cancelOrder(_salesTableReturn, false);

            if (FormDataUtil::getFormDataSource(_salesTableReturn))
            {
                SalesTable::changeReturnStatus(FormDataUtil::getFormDataSource(_salesTableReturn), ReturnUpdateAction::Cancel);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCancelRMA</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Cancels the returnd material authorization, which includes the return order and the exchange order if it exists.
    /// </summary>
    /// <param name="_salesTableReturn">
    ///     The sales order whose returnd material authorizationr is being canceled.
    /// </param>
    /// <returns>
    ///     true if the returnd material authorization is canceled successfully; otherwise, false.
    /// </returns>
    public static boolean mcrCancelRMA(SalesTable _salesTableReturn)
    {
        boolean ret = SalesTableType_ReturnItem::MCRCancelReturn(_salesTableReturn);

        // Cancel the exchange if the return was canceled and
        // the the credit from the return was applied to the
        // exchange.
        if (ret && _salesTableReturn.mcrReturnSalesTable().ApplyCreditToExchange)
        {
            ret = SalesTableType_ReturnItem::mcrCancelExchange(_salesTableReturn);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrGetRemainingUserAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>MarkupTrans</c> remaining amount for the return order if it was created by a user.
    /// </summary>
    /// <param name="_salesTableReturn">
    /// The <c>SalesTable</c> buffer of the return order.
    /// </param>
    /// <returns>
    /// The <c>MarkupTrans</c> amount remaining for the return order if it was created by a user.
    /// </returns>
    public static AmountCur mcrGetRemainingUserAdjustments(SalesTable _salesTableReturn)
    {
        MarkupTrans markupTransSalesTable;
        MarkupTrans markupTransSalesLine;
        SalesLine   salesLine;
        MarkupValue retValue = 0;
        select sum(Value) from markupTransSalesTable
            where markupTransSalesTable.TransTableId      == _salesTableReturn.TableId
                && markupTransSalesTable.TransRecId        == _salesTableReturn.RecId
                && markupTransSalesTable.MCRMarkupTransCreatedBy   == MCRMarkupTransCreatedBy::User;

        retValue += markupTransSalesTable.Value;

        select sum(Value) from markupTransSalesLine
            where markupTransSalesLine.TransTableId      == tableNum(SalesLine)
                && markupTransSalesLine.MCRMarkupTransCreatedBy == MCRMarkupTransCreatedBy::User
                exists join salesLine
                    where markupTransSalesLine.TransRecId == salesLine.RecId
                        &&  salesLine.SalesId               == _salesTableReturn.SalesId;

        retValue += markupTransSalesLine.Value;

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrGetRetMiscCharge</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the return misc charges against
    ///     the return order ID passed.
    /// </summary>
    /// <param name="_returnSalesId">
    ///     The return order ID whose misc. charges are being retrieved.
    /// </param>
    /// <param name="_markupCode">
    ///     The markup code to be retrieved.
    /// </param>
    /// <returns>
    ///     The return misc charges for the return order with the specified makrup code.
    /// </returns>
    public static AmountCur mcrGetRetMiscCharge(SalesId _returnSalesId, MarkupCode _markupCode)
    {
        SalesTable          salesTable;
        MarkupTable         retMarkupTable;
        MarkupTrans         retMarkupTrans;
        MCRReturnSalesTable    mcrReturnSalesTable;

        select sum(Value) from retMarkupTrans
            group by MarkupCode
            where retMarkupTrans.MarkupCode == _markupCode
                && retMarkupTrans.MarkupCategory == MarkupCategory::Fixed
            exists join retMarkupTable
                where retMarkupTable.MarkupCode == retMarkupTrans.MarkupCode
                    && retMarkupTable.CustType == MarkupType::CustVend
                    && retMarkupTable.MCRProRate
            exists join salesTable
                where salesTable.RecId == retMarkupTrans.TransRecId
                && salesTable.TableId == retMarkupTrans.TransTableId
            exists join mcrReturnSalesTable
            where mcrReturnSalesTable.SalesTable == salesTable.RecId
                && mcrReturnSalesTable.OriginalSalesId == _returnSalesId;

        return retMarkupTrans.Value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrGetRetProduct</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the return product amount against
    ///     the order id passed.
    /// </summary>
    /// <param name="_returnSalesId">
    ///     The return ID whose product return amount is to be calculated.
    /// </param>
    /// <returns>
    ///     The return product amount against
    ///     the order id passed.
    /// </returns>
    public static AmountCur mcrGetRetProduct(SalesId _returnSalesId)
    {
        SalesTable          salesTable;
        AmountCur           productRetAmt;
        MCRReturnSalesTable    mcrReturnSalesTable;

        while select salesTable
        exists join mcrReturnSalesTable
        where mcrReturnSalesTable.SalesTable == salesTable.RecId
            && mcrReturnSalesTable.OriginalSalesId == _returnSalesId
        {
            // get product total for return sales order.
            MCRSalesOrderTotals mcrSalesOrderTotalsReturn = new MCRSalesOrderTotals(salesTable);
            productRetAmt += mcrSalesOrderTotalsReturn.getTotalProduct();
        }

        return productRetAmt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrGetReturnableSalesOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a <c>Query</c> to retrieve sales orders that are eligible for returns for
    /// a specific customer if one is specified; otherwise, any eligible order.
    /// </summary>
    /// <param name="_custAccount">
    /// The account number of a customer for which this method builds a <c>Query</c> to find
    /// eligible orders for return; optional.
    /// </param>
    /// <returns>
    /// The <c>Query</c> object built to find eligible return orders.
    /// </returns>
    public static Query mcrGetReturnableSalesOrders(CustAccount _custAccount = '')
    {
        Query query = new Query();

        QueryBuildDataSource qbdsSalesTable = query.addDataSource(tableNum(SalesTable));

        if (_custAccount)
        {
            qbdsSalesTable.addRange(fieldNum(SalesTable, CustAccount)).value(_custAccount);
        }

        qbdsSalesTable.addRange(fieldNum(SalesTable, SalesType)).value(queryValue(SalesType::Sales));

        // Join valid sales lines
        QueryBuildDataSource qbdsSalesLine = qbdsSalesTable.addDataSource(tableNum(SalesLine));
        qbdsSalesLine.joinMode(JoinMode::ExistsJoin);
        qbdsSalesLine.addLink(fieldNum(SalesTable, SalesId), fieldNum(SalesLine, SalesId));
        qbdsSalesLine.addRange(fieldNum(SalesLine, SalesQty)).value('> 0');

        // Join cust invoice trans
        QueryBuildDataSource qbdsCustInvoiceTrans = qbdsSalesLine.addDataSource(tableNum(CustInvoiceTrans));
        qbdsCustInvoiceTrans.joinMode(JoinMode::InnerJoin);
        qbdsCustInvoiceTrans.addLink(fieldNum(SalesLine, InventTransId), fieldNum(CustInvoiceTrans, InventTransId));

        // Return the query.
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrGetReturnSalesOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a <c>Query</c> object to find return orders for a specific customer
    /// if one is specified; otherwise, all return orders.
    /// </summary>
    /// <param name="_custAccount">
    /// The account number for which this method builds a <c>Query</c> to find return orders; optional.
    /// </param>
    /// <returns>
    /// A <c>Query</c> object to retrieve return orders for a specific customer if one is specified;
    /// otherwise, all return orders.
    /// </returns>
    public static Query mcrGetReturnSalesOrders(CustAccount _custAccount = '')
    {
        Query query = new Query();

        QueryBuildDataSource qbdsSalesTable = query.addDataSource(tableNum(SalesTable));

        if (_custAccount)
        {
            qbdsSalesTable.addRange(fieldNum(SalesTable, CustAccount)).value(_custAccount);
        }

        // any more (instead just see if it's type returnItem)
        qbdsSalesTable.addRange(fieldNum(SalesTable, SalesType)).value(queryValue(SalesType::ReturnItem));

        // Return the query.
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrGetUserEnteredAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>MarkupTrans</c> remaining amount for the return order if it was created by a user.
    /// </summary>
    /// <param name="_salesTableReturn">
    /// The <c>SalesTable</c> buffer of the return order.
    /// </param>
    /// <returns>
    /// The <c>MarkupTrans</c> amount remaining for the return order if it was created by a user.
    /// </returns>
    public static AmountCur  mcrGetUserEnteredAdjustments(SalesTable _salesTableReturn)
    {
        return SalesTableType_ReturnItem::MCRGetRemainingUserAdjustments(_salesTableReturn);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrLookupValidReturnSalesOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a <c>Query</c> object to find valid return ordres.
    /// </summary>
    /// <param name="_callingControl">
    /// The control for which this method builds a <c>Query</c> to find valid return orders.
    /// </param>
    /// <param name="_custAccount">
    /// The customer for which this method finds valid return orders; optional.
    /// </param>
    public static void mcrLookupValidReturnSalesOrders(FormControl _callingControl, CustAccount _custAccount = '')
    {
        Query query = new Query();

        SysTableLookup sysTableLookup = SysTableLookup::newParameters(tableNum(SalesTable), _callingControl);
        sysTableLookup.addLookupfield(fieldNum(SalesTable, SalesId));
        sysTableLookup.addLookupfield(fieldNum(SalesTable, SalesName));
        sysTableLookup.addLookupfield(fieldNum(SalesTable, CustAccount));
        sysTableLookup.addLookupfield(fieldNum(SalesTable, InvoiceAccount));
        sysTableLookup.addLookupfield(fieldNum(SalesTable, SalesStatus));

        query = SalesTableType_ReturnItem::MCRGetReturnSalesOrders(_custAccount);

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrLookupValidSalesOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a <c>Query</c> object to find valid sales ordres.
    /// </summary>
    /// <param name="_callingControl">
    /// The control for which this method builds a <c>Query</c> to find valid sales orders.
    /// </param>
    /// <param name="_custAccount">
    /// The customer for which this method finds valid sales orders; optional.
    /// </param>
    public static void mcrLookupValidSalesOrders(FormControl _callingControl, CustAccount _custAccount = '')
    {
        Query query = new Query();

        SysTableLookup sysTableLookup = SysTableLookup::newParameters(tableNum(SalesTable), _callingControl);
        sysTableLookup.addLookupfield(fieldNum(SalesTable, SalesId));
        sysTableLookup.addLookupfield(fieldNum(SalesTable, SalesName));
        sysTableLookup.addLookupfield(fieldNum(SalesTable, CustAccount));
        sysTableLookup.addLookupfield(fieldNum(SalesTable, InvoiceAccount));
        sysTableLookup.addLookupfield(fieldNum(SalesTable, SalesStatus));

        query = SalesTableType_ReturnItem::MCRGetReturnableSalesOrders(_custAccount);

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrRemoveOldReturnReasonMiscCharge</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Removes misc charges related to a specific return reason code.
    /// </summary>
    /// <param name="_salesId">
    ///     The sales ID whose misc charges are to be removed.
    /// </param>
    /// <param name="_reasonCode">
    ///     The reason code whose misc charges are to be removed.
    /// </param>
    public static void mcrRemoveOldReturnReasonMiscCharge(SalesId _salesId, ReturnReasonCodeId _reasonCode)
    {
        MarkupTrans markupTrans;
        SalesTable  salesTable = SalesTable::find(_salesId);
        MarkupAutoTable markupAutoTable;
        MarkupAutoLine  markupAutoLine;

        if (_reasonCode)
        {
            ttsBegin;
            // Select all the markup auto lines for the return reason code
            while select ModuleType, ModuleCategory, MarkupCode, Txt, Value, MarkupCurrencyCode from markupAutoLine
                exists join markupAutoTable
                    where markupAutoLine.TableRecId == markupAutoTable.RecId
                        && markupAutoLine.TableTableId == markupAutoTable.TableId
                        && markupAutoTable.ModuleCategory == HeadingLine::Heading
                        && markupAutoTable.MarkupReturn == ReturnCodeType::Reason
                        && markupAutoTable.ModuleType == MarkupModuleType::Cust
                        && markupAutoTable.ReturnRelation == _reasonCode
            {
                // Find the markupTrans record that match the auto line data
                select forupdate firstonly markupTrans
                    where markupTrans.TransTableId == salesTable.TableId
                        && markupTrans.TransRecId == salesTable.RecId
                        && markupTrans.ModuleType == markupAutoLine.ModuleType
                        && markupTrans.ModuleCategory == markupAutoLine.ModuleCategory
                        && markupTrans.MarkupCode == markupAutoLine.MarkupCode
                        && markupTrans.Txt == markupAutoLine.Txt
                        && markupTrans.Value == markupAutoLine.Value
                        && markupTrans.CurrencyCode == markupAutoLine.MarkupCurrencyCode;
                if (markupTrans)
                {
                    if (markupTrans.validateDelete())
                    {
                        markupTrans.delete();
                    }
                    else
                    {
                        throw error("@SYS104318");
                    }
                }
                else
                {
                    // If the user changed something, find one similar and hope it's the right one
                    select forupdate firstonly markupTrans
                        where markupTrans.TransTableId == salesTable.TableId
                            && markupTrans.TransRecId == salesTable.RecId
                            && markupTrans.ModuleType == markupAutoLine.ModuleType
                            && markupTrans.ModuleCategory == markupAutoLine.ModuleCategory
                            && markupTrans.MarkupCode == markupAutoLine.MarkupCode
                            // The text may have been changed, so don't look for that
                            && (markupTrans.Value == markupAutoLine.Value
                            // The value might have been overridden
                            || (markupTrans.Value != markupAutoLine.Value
                                && markupTrans.MCRMiscChargeOverride))
                            && markupTrans.CurrencyCode == markupAutoLine.MarkupCurrencyCode;
                    if (markupTrans)
                    {
                        if (markupTrans.validateDelete())
                        {
                            markupTrans.delete();
                        }
                        else
                        {
                            throw error("@SYS104318");
                        }
                    }
                }
            }
            ttsCommit;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>