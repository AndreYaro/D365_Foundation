<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxWithhold</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>TaxWithhold</c> class is the tax calculation class for Withhold.
/// </summary>
class TaxWithhold
{
    LedgerJournalTrans ledgerJournalTrans;
    RecordSortedList   tmpTaxWithholdList;

    boolean                     overrideWithholding;
    boolean                     finalPayment;
    // <GTH>
    boolean                     isTaxWithholdEnabledTH;
    // </GTH>

    #ISOCountryRegionCodes

    // <GJP>
    boolean                     isJPCountryRegion;
    // </GJP>

    // <GBR>
    boolean                     isTaxWithholdUK;

    AmountMST                   accumPayment;
    AmountMST                   accumBaseAmountFromPreviousPayment;
    AmountCur                   taxWithholdAmount;
    TaxWithholdData             taxWithholdData1;
    AmountCur                   paymentAmt;
    AmountCur                   invoiceamt;
    AmountCur                   sumAccumpayment;
    AmountCur                   limitMax;
    AmountCur                   custVendTransAmountCur;

    RecordSortedList            selectedTaxWithholdTrans;

    CustVendTrans               custVendTrans;

    private CurrencyCode accountingCurrency;
    private boolean isEnabledWHTCurrencyExchRateFeature;
    private boolean isEnableGlobalWHTFeatureAndParam;

    protected CustVendTable custVendTableForJournalTrans;
    protected boolean enableWHTOnCharges;
    protected boolean skipMarkupTransOnLines;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accumulatedPaymentQueryRun_BR</Name>
				<Source><![CDATA[
    protected QueryRun accumulatedPaymentQueryRun_BR(TaxWithholdTable _taxWithholdTable, TransDate _periodStart, TransDate _periodEnd)
    {
        Query query             = new Query();
        QueryBuildDataSource    qb;

        qb = query.addDataSource(tableNum(TaxWithholdTrans));
        qb.update(true);
        qb.addRange(fieldNum(TaxWithholdTrans,PartyId_BR))              .value(this.partyId_BR());
        qb.addRange(fieldNum(TaxWithholdTrans,TaxWithholdCode))         .value(_taxWithholdTable.TaxWithholdCode);
        qb.addRange(fieldNum(TaxWithholdTrans,TransDate))               .value(queryRange(_periodStart,_periodEnd));
        qb.addRange(fieldNum(TaxWithholdTrans,InvoiceAmount))           .value(SysQuery::valueNot(0));
        qb.addRange(fieldNum(TaxWithholdTrans,CanBeReversed_BR))        .value(queryValue(NoYes::Yes));
        qb.addRange(fieldNum(TaxWithholdTrans,TaxWithholdIsSelected_BR)).value(strfmt('((%1 == %2) || ((%1 == %3) && (%4 != %5)))',
                fieldStr(TaxWithholdTrans, TaxWithholdIsSelected_BR),
                any2int(NoYes::No),
                any2int(NoYes::Yes),
                fieldStr(TaxWithholdTrans, TaxWithholdAccumulatedBaseAmount),
                0));

        return new QueryRun(query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustWhtAmountPaymLimit_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method adjust the WHT transactions amount up to the payment amount.
    /// </summary>
    /// <param name="_specTrans">
    ///     A <c>SpecTrans</c> table buffer that referencing the payment record for which the calculation will be done.
    /// </param>
    /// <param name="_taxWithholdTransTotalAmount">
    ///     The current WHT total amount of the payment
    /// </param>
    /// <param name="_paymAmount">
    ///     The payment amount to settle
    /// </param>
    /// <remarks>
    ///     if the withholding tax amount is higher than the payment amount, the withholding tax amount should be limited up to payment amount.
    /// </remarks>
    protected void adjustWhtAmountPaymLimit_BR(SpecTrans _specTrans, AmountCur _taxWithholdTransTotalAmount, AmountCur _paymAmount)
    {
        TaxWithholdTrans    taxWithholdTrans;
        AmountCur           taxWithholdTransAmount;
        AmountCur           invoiceAmountSettle = abs(_paymAmount) - abs(_specTrans.CashDiscToTake);

        while select forupdate taxWithholdTrans
            where taxWithholdTrans.SpecTransId == _specTrans.RecId
                && taxWithholdTrans.InvoiceTaxWithholdAmount != 0
        {
            // Calc the new tax amount
            taxWithholdTransAmount = ((_paymAmount - _specTrans.CashDiscToTake) * taxWithholdTrans.InvoiceTaxWithholdAmount) / _taxWithholdTransTotalAmount;
            // Calc the accumulated base amount
            taxWithholdTrans.TaxWithholdAccumulatedBaseAmount = CurrencyExchangeHelper::amount((taxWithholdTrans.InvoiceTaxWithholdAmount - taxWithholdTransAmount) * (taxWithholdTrans.InvoiceWithholdBaseAmount + abs(accumPayment + accumBaseAmountFromPreviousPayment)) / taxWithholdTrans.InvoiceTaxWithholdAmount, taxWithholdTrans.InvoiceCurrency);
            // Calc the new Base amount
            taxWithholdTrans.InvoiceWithholdBaseAmount = CurrencyExchangeHelper::amount(taxWithholdTransAmount * (taxWithholdTrans.InvoiceWithholdBaseAmount + abs(accumPayment + accumBaseAmountFromPreviousPayment)) / taxWithholdTrans.InvoiceTaxWithholdAmount, taxWithholdTrans.InvoiceCurrency) ;

            taxWithholdTrans.PaymWithholdBaseAmount = taxWithholdTrans.InvoiceWithholdBaseAmount;
            taxWithholdTrans.WithholdBaseAmount = taxWithholdTrans.InvoiceWithholdBaseAmount;
            taxWithholdTrans.TaxWithholdBaseAmount = taxWithholdTrans.InvoiceWithholdBaseAmount;
            taxWithholdTrans.IntersectionWithholdBaseAmount_BR =  taxWithholdTrans.InvoiceWithholdBaseAmount;

            taxWithholdTransAmount = CurrencyExchangeHelper::amount(taxWithholdTransAmount > invoiceAmountSettle ? invoiceAmountSettle : taxWithholdTransAmount, taxWithholdTrans.InvoiceCurrency);
            invoiceAmountSettle -= taxWithholdTransAmount;
            taxWithholdTrans.InvoiceTaxWithholdAmount = taxWithholdTransAmount;
            taxWithholdTrans.TaxTaxWithholdAmount = taxWithholdTransAmount;
            taxWithholdTrans.TaxWithholdAmount = taxWithholdTransAmount;
            taxWithholdTrans.PaymTaxWithholdAmount = taxWithholdTransAmount;
            taxWithholdTrans.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInvoiceExemptedAmountCurByInterval_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate exempted invoice amount by interval
    /// </summary>
    /// <param name="_taxWithholdTrans">
    /// A <c>TaxWithholdTrans</c> table buffer.
    /// </param>
    /// <returns>
    /// Calculated exempted invoice amount in transaction currency
    /// </returns>
    private TaxWithholdAmount calcInvoiceExemptedAmountCurByInterval_JP(TaxWithholdTrans  _taxWithholdTrans)
    {
        TaxWithholdAmountCur    invoiceExemptedAmountCur;
        TaxWithholdAmount       invoiceExemptedAmountMST;
        TaxWithholdData         taxWithholdData;
        AmountMST               netInvoiceBaseAmountMST;
        AmountCur               netInvoiceBaseAmountCur = _taxWithholdTrans.InvoiceBaseAmount - _taxWithholdTrans.InvoiceNotTaxableByTreaty - _taxWithholdTrans.InvoiceNotTaxableExpenses;

        if (netInvoiceBaseAmountCur)
        {
            netInvoiceBaseAmountMST = CurrencyExchangeHelper::mstAmount(netInvoiceBaseAmountCur, _taxWithholdTrans.InvoiceCurrency, _taxWithholdTrans.TransDate);

            while select TaxWithholdLimitMax, TaxWithholdLimitMin, TaxWithholdExclude from taxWithholdData
                where taxWithholdData.TaxWithholdCode       == _taxWithholdTrans.TaxWithholdCode
                    && taxWithholdData.TaxWithholdExclude   != 0
                    && taxWithholdData.TaxWithholdLimitMin  < netInvoiceBaseAmountMST
                    && (!taxWithholdData.TaxWithholdFromDate
                        || taxWithholdData.TaxWithholdFromDate  <= _taxWithholdTrans.TransDate)
                    && (!taxWithholdData.TaxWithholdToDate
                        || taxWithholdData.TaxWithholdToDate    >= _taxWithholdTrans.TransDate)
            {
                if (taxWithholdData.TaxWithholdLimitMax     == 0
                    || taxWithholdData.TaxWithholdLimitMax  >= netInvoiceBaseAmountMST)
                {
                    invoiceExemptedAmountMST += (netInvoiceBaseAmountMST - taxWithholdData.TaxWithholdLimitMin) * taxWithholdData.TaxWithholdExclude / 100;
                }
                else
                {
                    invoiceExemptedAmountMST += (taxWithholdData.TaxWithholdLimitMax - taxWithholdData.TaxWithholdLimitMin) * taxWithholdData.TaxWithholdExclude / 100;
                }
            }
        }

        invoiceExemptedAmountCur = CurrencyExchangeHelper::curAmount(invoiceExemptedAmountMST, _taxWithholdTrans.InvoiceCurrency, _taxWithholdTrans.TransDate);
        return CurrencyExchangeHelper::amount(invoiceExemptedAmountCur, _taxWithholdTrans.InvoiceCurrency);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInvoiceTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the tax amount for invocie.
    /// </summary>
    /// <param name = "_taxWithholdTrans">The buffer of <c>TaxWithholdTrans</c>.</param>
    /// <param name = "_custVendTrans">The buffer of <c>CustVendTrans</c>.</param>
    /// <returns></returns>
    AmountCur calcInvoiceTaxAmount(TaxWithholdTrans _taxWithholdTrans,
                                   CustVendTrans    _custVendTrans)
    {
        AmountCur  invoiceTaxAmount;
        TaxTrans   taxTrans;

        select sum(SourceRegulateAmountCur) from taxTrans
            where taxTrans.Voucher   == _custVendTrans.Voucher &&
                  taxTrans.TransDate == _custVendTrans.TransDate &&
                  taxTrans.TaxDirection != TaxDirection::UseTax;

        if (_custVendTrans.AmountCur)
        {
            invoiceTaxAmount = CurrencyExchangeHelper::amount(-taxTrans.SourceRegulateAmountCur * _taxWithholdTrans.InvoiceAmount / _custVendTrans.AmountCur, _taxWithholdTrans.InvoiceCurrency);
        }
        return invoiceTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceTaxAmountForGWHTaxMarkupTrans</Name>
				<Source><![CDATA[
    private TaxAmount getInvoiceTaxAmountForGWHTaxMarkupTrans(
        AmountCur _paymentAmount,
        CustVendTrans _custVendTransLoc,
        TaxAmount _taxAmount)
    {
        return _custVendTransLoc.AmountCur ? 
            (_paymentAmount / abs(_custVendTransLoc.AmountCur)) * _taxAmount : 
            0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInvoiceTaxAmount_TH</Name>
				<Source><![CDATA[
    [SysObsolete('This method is obsoleted. Use calcInvoiceTaxAmountWithMarkupTrans_TH() instead', false, 03\08\2021)]
    protected AmountCur calcInvoiceTaxAmount_TH(TaxWithholdTrans _taxWithholdTrans,
        SpecTrans           _specTrans,
        CustVendTrans      _custVendTrans,
        InventTransId      _inventTransId,
        Voucher            _voucher,
        boolean            _inclTax,
        AmountCur          _invoiceAmountSettleTotal = 0,
        RefRecId           _sourceDocumentLineRecId = 0,
        RefRecId           _invoiceLineRecId = 0)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInvoiceTaxAmountWithMarkupTrans_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method will calculate the tax amount per invoice.
    /// </summary>
    /// <param name="_taxWithholdTrans">
    ///    A <c>TaxWithholdTrans</c> table buffer that referencing the tax withhold record for which the calculation will
    ///    be done.
    /// </param>
    /// <param name="_specTrans">
    ///    A <c>SpecTrans</c> table buffer that referencing the payment record for which the calculation will
    ///    be done.
    /// </param>
    /// <param name="_custVendTrans">
    ///    A <c>CustVendTrans</c> table buffer that referencing the invoice record for which the calculation will
    ///    be done.
    /// </param>
    /// <param name="_inventTransId">
    ///    A <c>InventTransId</c> value that references the ID of the inventory record.
    /// </param>
    /// <param name="_voucher">
    ///    A given voucher.
    /// </param>
    /// <param name="_inclTax">
    ///    A Boolean value that indicates whether included taxes are included in the sales tax amounts.
    /// </param>
    /// <param name="_invoiceAmountSettleTotal">
    ///    The invoice amount to be settled.
    /// </param>
    /// <param name="_sourceDocumentLineRecId">
    ///    Source line
    /// </param>
    /// <param name="_invoiceLineRecId">
    ///    The <c>VendInvoiceTrans</c> RecId.
    /// </param>
    /// <param name="_createWHTransForMarkupTrans">
    ///    Indicates that we are calculating taxAmount for the GWHT charge code.
    /// </param>
    /// <param name="_gwhtMarkupTransTaxAmount">
    ///    GWHTax trans record tax amount. Without adjustment.
    /// </param>
    /// <returns>
    ///    The tax amount per invoice.
    /// </returns>
    protected AmountCur calcInvoiceTaxAmountWithMarkupTrans_TH(
        TaxWithholdTrans _taxWithholdTrans,
        SpecTrans           _specTrans,
        CustVendTrans      _custVendTrans,
        InventTransId      _inventTransId,
        Voucher            _voucher,
        boolean            _inclTax,
        AmountCur          _invoiceAmountSettleTotal = 0,
        RefRecId           _sourceDocumentLineRecId = 0,
        RefRecId           _invoiceLineRecId = 0,
        boolean _createWHTransForMarkupTrans = false,
        TaxAmount _gwhtMarkupTransTaxAmount = 0)
    {
        AmountCur       invoiceTaxAmount;
        AmountCur       totalTaxAmountCur;
        AmountCur       applicableCashDiscount;
        AmountCur       invoiceCashDiscount;

        // By default, we are considered to be in VendTrans scenario (isCustomer = false)
        boolean         isCustomer;

        this.calcInvoiceTaxAmount_TH(
            _taxWithholdTrans,
            _specTrans,
            _custVendTrans,
            _inventTransId,
            _voucher,
            _inclTax,
            _invoiceAmountSettleTotal,
            _sourceDocumentLineRecId,
            _invoiceLineRecId);

        if (_custVendTrans.TableId == tableNum(CustTrans))
        {
            isCustomer = true;
        }

        // Calculate the applicable cash discount for the invoice.
        invoiceCashDiscount = this.getCashdisc_TH(_specTrans);

        if (_custVendTrans.AmountCur - invoiceCashDiscount != 0)
        {
            applicableCashDiscount = (_specTrans.Balance01 / (_custVendTrans.AmountCur - invoiceCashDiscount)) * invoiceCashDiscount;
        }

        if (_createWHTransForMarkupTrans)
        {
            totalTaxAmountCur = this.getInvoiceTaxAmountForGWHTaxMarkupTrans(
                _invoiceAmountSettleTotal + applicableCashDiscount,
                _custVendTrans,
                _gwhtMarkupTransTaxAmount);
        }
        else
        {
            totalTaxAmountCur = TaxTrans::partialUnrealisedTaxSettled(_inventTransId,
                _invoiceAmountSettleTotal + applicableCashDiscount,
                isCustomer,
                false,
                _inclTax,
                _voucher,
                _sourceDocumentLineRecId,
                _invoiceLineRecId,
                isTaxWithholdUK);
        }

        if (_custVendTrans.AmountCur)
        {
            invoiceTaxAmount = CurrencyExchangeHelper::amount(-totalTaxAmountCur, _taxWithholdTrans.InvoiceCurrency);
        }

        if (isTaxWithholdEnabledTH || isEnableGlobalWHTFeatureAndParam)
        {
            if (isCustomer)
            {
                return invoiceTaxAmount;
            }
            else
            {
                return -1 * invoiceTaxAmount;
            }
        }

        return  abs(invoiceTaxAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcNotTaxableByTreaty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates not taxable by treaty.
    /// </summary>
    /// <param name = "_taxWithholdTrans">The buffer of <c>TaxWithholdTrans</c>.</param>
    /// <param name = "_settleExchRate">The settle exchange rate.</param>
    /// <returns>The buffer of <c>TaxWithholdTrans</c>.</returns>
    public TaxWithholdTrans calcNotTaxableByTreaty(TaxWithholdTrans _taxWithholdTrans,
                                                   CrossExchRate    _settleExchRate)
    {
        TaxWithholdTrans  taxWithholdTrans = _taxWithholdTrans;

        taxWithholdTrans.PaymNotTaxableByTreaty = this.invoice2Payment(taxWithholdTrans.InvoiceNotTaxableByTreaty,
                                                                       taxWithholdTrans.InvoiceCurrency,
                                                                       taxWithholdTrans.PaymCurrency,
                                                                       _settleExchRate,
                                                                       taxWithholdTrans.DataAreaId,
                                                                       taxWithholdTrans.PaymCompany);
        taxWithholdTrans.NotTaxableByTreaty     = CurrencyExchangeHelper::mstAmount(taxWithholdTrans.InvoiceNotTaxableByTreaty, taxWithholdTrans.InvoiceCurrency, taxWithholdTrans.TransDate);
        taxWithholdTrans.TaxNotTaxableByTreaty  = CurrencyExchangeHelper::curAmount(taxWithholdTrans.NotTaxableByTreaty, taxWithholdTrans.TaxWithholdCurrency, taxWithholdTrans.TransDate);

        return taxWithholdTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcNotTaxableExpenses</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates not taxable expenses.
    /// </summary>
    /// <param name = "_taxWithholdTrans">The buffer of <c>TaxWithholdTrans</c>.</param>
    /// <param name = "_settleExchRate">The settle exchange rate.</param>
    /// <returns>The buffer of <c>TaxWithholdTrans</c>.</returns>
    public TaxWithholdTrans calcNotTaxableExpenses(TaxWithholdTrans _taxWithholdTrans,
                                                    CrossExchRate    _settleExchRate)
    {
        TaxWithholdTrans  taxWithholdTrans = _taxWithholdTrans;

        taxWithholdTrans.PaymNotTaxableExpenses  = this.invoice2Payment(taxWithholdTrans.InvoiceNotTaxableExpenses,
                                                                        taxWithholdTrans.InvoiceCurrency,
                                                                        taxWithholdTrans.PaymCurrency,
                                                                        _settleExchRate,
                                                                        taxWithholdTrans.DataAreaId,
                                                                        taxWithholdTrans.PaymCompany);
        taxWithholdTrans.NotTaxableExpenses      = CurrencyExchangeHelper::mstAmount(taxWithholdTrans.InvoiceNotTaxableExpenses, taxWithholdTrans.InvoiceCurrency, taxWithholdTrans.TransDate);
        taxWithholdTrans.TaxNotTaxableExpenses  = CurrencyExchangeHelper::curAmount(taxWithholdTrans.NotTaxableExpenses, taxWithholdTrans.TaxWithholdCurrency, taxWithholdTrans.TransDate);

        return taxWithholdTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPaymentAmtPerLine_TH</Name>
				<Source><![CDATA[
    [SysObsolete('This method is obsoleted. Use calcPaymentAmtPerLineWithMarkupTrans_TH() instead', false, 03\08\2021)]
    protected AmountCur calcPaymentAmtPerLine_TH(SpecTrans _specTrans,
        InventTransId _inventTransId,
        boolean _isCorrection,
        AmountCur _invoiceAmountLine,
        AmountCur _invoiceAmountAll,
        boolean _isInclTax,
        RefRecId _sourceDocumentLineRecId = 0,
        RefRecId _invoiceLineRecId = 0)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPaymentAmtPerLineWithMarkupTrans_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method will calculate the amount to calculate the WHT tax. This amount will be adjusted based
    ///    on discounts and taxes applied to the invoice line.
    /// </summary>
    /// <param name="_specTrans">
    ///    A <c>SpecTrans</c> table buffer that referencing the payment record for which the calculation will
    ///    be done.
    /// </param>
    /// <param name="_inventTransId">
    ///    A <c>InventTransId</c> value that references the ID of the inventory record.
    /// </param>
    /// <param name="_isCorrection">
    ///    A Boolean value that specifies whether the base amount has to be adjusted.
    /// </param>
    /// <param name="_invoiceAmountLine">
    ///    The <c>BaseInvoice</c> value that represents total base amount.
    /// </param>
    /// <param name="_invoiceAmountAll">
    ///    An invoice value mount that represents total base amount.
    /// </param>
    /// <param name="_isInclTax">
    ///    A Boolean value that indicates whether included taxes are included in the sales tax amounts.
    /// </param>
    /// <param name="_sourceDocumentLineRecId">
    ///    A <c>SourceDocumentLine</c> record ID.
    /// </param>
    /// <param name="_invoiceLineRecId">
    ///    The <c>VendInvoiceTrans</c> RecId.
    /// </param>
    /// <param name="_calculateForMarkupTrans">
    ///    Indicates do we calculate payment amount for the charge codes.
    /// </param>
    /// <param name="_invoiceAmountLineWithoutTax">
    ///    GWHTax transaction amount. Without tax.
    /// </param>
    /// <param name="_taxValue">
    ///    GWHTax transaction tax value.
    /// </param>
    /// <returns>
    ///    The amount that will be used to calculate the WHT tax.
    /// </returns>
    protected AmountCur calcPaymentAmtPerLineWithMarkupTrans_TH(SpecTrans _specTrans,
        InventTransId _inventTransId,
        boolean _isCorrection,
        AmountCur _invoiceAmountLine,
        AmountCur _invoiceAmountAll,
        boolean _isInclTax,
        RefRecId _sourceDocumentLineRecId = 0,
        RefRecId _invoiceLineRecId = 0,
        boolean _calculateForMarkupTrans = false,
        AmountCur _invoiceAmountLineWithoutTax = 0,
        TaxValue _taxValue = 0)
    {
        VendInvoiceTransRef vendInvoiceTransRef;
        VendTransOpen       vendTransOpen;
        VendTransCashDisc   vendTransCashDisc;
        VendInvoiceTrans    vendInvoiceTrans;
        CashDiscAmount      cashDiscAmount;
        TaxTrans            taxTrans;

        AmountCur           paymentAmtPerLine;
        AmountCur           settleInvoiceTotalAmt;
        boolean             taxWhtAdjustment;
        SourceDocumentLine  sourceDocumentLine;

        AmountCur           lineCashDiscount;
        AmountCur           lineCashDiscountToApply;
        AmountCur           totalInvoiceCashDiscount;
        AmountCur           totalinvoiceAmountTax;

        this.calcPaymentAmtPerLine_TH(
            _specTrans,
            _inventTransId,
            _isCorrection,
            _invoiceAmountLine,
            _invoiceAmountAll,
            _isInclTax,
            _sourceDocumentLineRecId,
            _invoiceLineRecId);

        if (isTaxWithholdUK && !_sourceDocumentLineRecId && !_inventTransId)
        {
            vendInvoiceTrans = VendInvoiceTrans::findRecId(_invoiceLineRecId);
        }
        else
        {
            // A user can overwrite what the base for the whithholding tax specified in TaxWithholdBaseCur_TH.
            if (_sourceDocumentLineRecId)
            {
                select firstonly LineAmount, TaxWithholdBaseCur_TH from vendInvoiceTrans
                    where vendInvoiceTrans.SourceDocumentLine == _sourceDocumentLineRecId;
            }
            else
            {
                select firstonly LineAmount, TaxWithholdBaseCur_TH from vendInvoiceTrans
                    where vendInvoiceTrans.RecId == _invoiceLineRecId;
            }
        }

        if (vendInvoiceTrans.TaxWithholdBaseCur_TH && !_calculateForMarkupTrans)
        {
            taxWhtAdjustment = true;
            settleInvoiceTotalAmt = vendInvoiceTrans.TaxWithholdBaseCur_TH;
        }
        else
        {
            settleInvoiceTotalAmt = -_specTrans.Balance01;
        }

        if (_isCorrection)
        {
            if (_invoiceAmountAll)
            {
                totalInvoiceCashDiscount = abs(this.getCashdisc_TH(_specTrans));

                if (totalinvoiceAmountTax == 0)
                {
                    select sum (SourceRegulateAmountCur) from taxTrans
                        where taxTrans.TransDate == _specTrans.vendTrans().TransDate
                        && taxTrans.Voucher == _specTrans.vendTrans().Voucher;

                    totalinvoiceAmountTax = taxTrans.SourceRegulateAmountCur;

                    if(_calculateForMarkupTrans)
                    {
                        lineCashDiscount = (abs(_invoiceAmountLineWithoutTax) / (abs(_specTrans.vendTrans().AmountCur) - abs(totalinvoiceAmountTax))) * totalInvoiceCashDiscount;
                    }
                    else
                    {
                        lineCashDiscount = (abs(vendInvoiceTrans.LineAmount) / (abs(_specTrans.vendTrans().AmountCur) - abs(totalinvoiceAmountTax))) * totalInvoiceCashDiscount;
                    }
                }

                // Checks for full settlement invoice amount
                if (abs(_specTrans.vendTrans().AmountCur) - totalInvoiceCashDiscount == abs(settleInvoiceTotalAmt))
                {
                    paymentAmtPerLine = _invoiceAmountLine - lineCashDiscount;
                }
                else
                {
                    if (VendParameters::find().CashDiscForPartialPaym == NoYes::Yes)
                    {
                        lineCashDiscountToApply = settleInvoiceTotalAmt/ (abs(_specTrans.vendTrans().AmountCur) - totalInvoiceCashDiscount) * lineCashDiscount;
                    }

                    paymentAmtPerLine = (_invoiceAmountLine * settleInvoiceTotalAmt / (_invoiceAmountAll - totalInvoiceCashDiscount)) - lineCashDiscountToApply;
                }
            }
        }
        else
        {
            paymentAmtPerLine = _invoiceAmountLine;
        }

        if (finalPayment)
        {
            cashDiscAmount = this.getCashdisc_TH(_specTrans);

            if (cashDiscAmount && !taxWhtAdjustment)
            {
                vendTransOpen = _specTrans.vendTransOpen();
                vendTransCashDisc = VendTransCashDisc::findCashDisc(vendTransOpen.TableId,
                                                                    vendTransOpen.RecId);
                if (CashDisc::find(vendTransCashDisc.CashDiscCode).Percent)
                {
                    if (!_isInclTax)
                    {
                        TaxValue taxValue;

                        if(!_calculateForMarkupTrans)
                        {
                            if (isTaxWithholdUK && !_sourceDocumentLineRecId && !_inventTransId)
                            {
                                select firstonly TaxValue from taxTrans
                                        where taxTrans.SourceTableId == tableNum(LedgerJournalTrans)
                                    exists join vendInvoiceTransRef
                                        where taxTrans.SourceRecId == vendInvoiceTransRef.LedgerJournalTransRecId
                                            && vendInvoiceTransRef.VendInvoiceTransRecId == _invoiceLineRecId;
                            }
                            else
                            {
                                if (_sourceDocumentLineRecId)
                                {
                                    select firstonly TaxValue from taxTrans
                                        exists join ParentSourceDocumentLine, RecId from sourceDocumentLine
                                            where taxTrans.SourceDocumentLine == sourceDocumentLine.RecId
                                                && sourceDocumentLine.ParentSourceDocumentLine == _sourceDocumentLineRecId;
                                }
                                else
                                {
                                    select firstonly TaxValue from taxTrans
                                        where taxTrans.InventTransId == _inventTransId
                                         && (!enableWHTOnCharges || taxTrans.SourceTableId != tableNum(MarkupTrans));
                                }
                            }

                            taxValue = taxTrans.TaxValue;
                        }
                        else
                        {
                            taxValue = _taxValue;
                        }

                        if (100 + taxValue)
                        {
                            cashDiscAmount = (_invoiceAmountLine * 100 / ( 100 + taxValue)) *
                                                (CashDisc::find(vendTransCashDisc.CashDiscCode).Percent / 100);
                        }
                        else
                        {
                            cashDiscAmount = 0;
                        }
                        paymentAmtPerLine -= abs(cashDiscAmount);
                    }
                }
                else
                {
                    if (_invoiceAmountAll - abs(cashDiscAmount))
                    {
                        paymentAmtPerLine += cashDiscAmount * (_invoiceAmountLine / (_invoiceAmountAll - abs(cashDiscAmount)));
                    }
                }
            }
        }

        return paymentAmtPerLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcWithholdAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method will calculate the withholding tax amount for specified tax withholding trans.
    /// </summary>
    /// <param name="_taxWithholdTrans">
    ///    A <c>TaxWithholdTrans</c> table buffer.
    /// </param>
    /// <param name="_settleExchRate">
    ///    The exchange rate which is used in settlement.
    /// </param>
    /// <param name="_calcTaxWithholdExempt">
    ///    Indicates whether exempt percentage is considered when calculating withholding tax amount. Optional, default is false.
    /// </param>
    /// <param name="_invoiceExemptedChanged">
    ///    Indicates whether exempt percentage is changed between invoice and payment. Optional, default is false.
    /// </param>
    /// <returns>
    ///    The withholding tax amount.
    /// </returns>
    public TaxWithholdTrans calcWithholdAmounts(TaxWithholdTrans _taxWithholdTrans,
                                                CrossExchRate    _settleExchRate,
                                                boolean          _calcTaxWithholdExempt = false,
                                                boolean          _invoiceExemptedChanged = false)
    {
        TaxWithholdTrans  taxWithholdTrans = _taxWithholdTrans;
        // <GTH>
        TaxWithholdTransExtensionTH taxWithholdTransExtensionTH;
        // </GTH>
        TmpTaxWithhold    tmpTaxWithhold;
        AmountCur         tmpAmount;
        //<GBR>
        TaxWithholdTable      taxWithholdTable;
        //</GBR>

        // <GJP>
        TaxCalcMode withholdTaxCalculationMethod_JP;
        // </GJP>

        ExchRate exchRate;
        ExchrateSecondary exchRateSecond;
        EUROTriangulation triangulation;

        if ((isEnabledWHTCurrencyExchRateFeature && ledgerJournalTrans.CurrencyCode != accountingCurrency)
            || taxWithholdTrans.InvoiceCurrency == ledgerJournalTrans.CurrencyCode)
        {
            exchRate =  ledgerJournalTrans.ExchRate;
            exchRateSecond = ledgerJournalTrans.ExchRateSecond;
            triangulation = ledgerJournalTrans.Triangulation;
        }
        else
        {
            exchRate =  0;
            exchRateSecond = 0;
            triangulation = false;
        }

        if (taxWithholdTrans.TaxWithholdCode)
        {
            tmpTaxWithhold = this.findTmpTaxWithhold(taxWithholdTrans);

            // <GJP>
            if (isJPCountryRegion)
            {
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceJP00030, funcName());

                withholdTaxCalculationMethod_JP = TaxWithholdTable::find(taxWithholdTrans.TaxWithholdCode).TaxCalcMethod_JP;
                // Clear these fields for withholding tax recalculation of partial payment
                taxWithholdTrans.TaxTaxWithholdAmount       = 0;
                taxWithholdTrans.InvoiceTaxWithholdAmount   = 0;
                taxWithholdTrans.PaymTaxWithholdAmount      = 0;
            }
            // </GJP>

            //<GBR>
            if (BrazilParameters::isEnabled())
            {
                taxWithholdTable = TaxWithholdTable::find(taxWithholdTrans.TaxWithholdCode);

                if (taxWithholdTable.TaxWithholdBaseType == TaxWithholdBaseType::PctGrsAmtMonth)
                {
                    if (taxWithholdData1.TaxWithholdLimitMax != 0)
                    {
                        if (taxWithholdTrans.InvoiceAmount  > taxWithholdData1.TaxWithholdLimitMax)
                        {
                            taxWithholdTrans.InvoiceAmount = taxWithholdData1.TaxWithholdLimitMax;
                            limitMax = taxWithholdData1.TaxWithholdLimitMax;
                        }
                        if (sumAccumpayment >= taxWithholdData1.TaxWithholdLimitMax)
                        {
                            tmpTaxWithhold.TaxWithholdValue = 0;
                        }
                    }
                }
            }
            // </GBR>

            if (tmpTaxWithhold.WithholdOriginGross
                // <GBR>
                || (BrazilParameters::isEnabled() && taxWithholdTable.TaxWithholdBaseType == TaxWithholdBaseType::PctGrsAmtMonth)
                //</GBR>
                )
            {
                AmountCur retainedTaxAmount;
                if (TaxWithholdIncludeRetainedTaxOnBaseAmount_BRFlight::instance().isEnabled())
                {
                    PaymSchedTaxDistribution taxDistribution, taxDistributionPaymSched;
                    boolean hasPaymentSched;

                    if (this.onlyHasRetainedTax(_taxWithholdTrans))
                    {
                        taxDistribution = this.getTaxDistributionFromCustVendTransOpen(_taxWithholdTrans);
                        [hasPaymentSched, taxDistributionPaymSched] = this.getPaymentSched(_taxWithholdTrans);

                        if (!hasPaymentSched || (hasPaymentSched && (taxDistribution == PaymSchedTaxDistribution::FirstRate || taxDistribution == PaymSchedTaxDistribution::LastRate)))
                        {
                            retainedTaxAmount = this.getActualRetainedTaxAmount(_taxWithholdTrans);
                        }
                        else if (taxDistributionPaymSched == PaymSchedTaxDistribution::Proportional)
                        {
                            retainedTaxAmount = this.getActualRetainedTaxAmount(_taxWithholdTrans);
                            retainedTaxAmount = this.calculateProportionalRetainedTaxAmount(retainedTaxAmount, _taxWithholdTrans);
                        }
                    }
                }

                taxWithholdTrans.InvoiceBaseAmount = taxWithholdTrans.InvoiceAmount - retainedTaxAmount;
            }
            else
            {
                taxWithholdTrans.InvoiceBaseAmount = taxWithholdTrans.invoiceAmountExclTax();
            }

            if (! _calcTaxWithholdExempt)
            {
                if (!_invoiceExemptedChanged)
                {
                    // <GJP>
                    if (isJPCountryRegion
                        && withholdTaxCalculationMethod_JP == TaxCalcMode::Interval)
                    {
                        taxWithholdTrans.InvoiceExemptedAmount = this.calcInvoiceExemptedAmountCurByInterval_JP(taxWithholdTrans);
                    }
                    else
                    {
                        // </GJP>
                        taxWithholdTrans.InvoiceExemptedAmount = CurrencyExchangeHelper::amount(this.calcInvoiceWithholdBase(taxWithholdTrans, 0, 0, 0, false) * tmpTaxWithhold.TaxWithholdExclude / 100, taxWithholdTrans.InvoiceCurrency);
                        // <GJP>
                    }
                    // </GJP>
                }
                taxWithholdTrans.PaymExemptedAmount    = this.invoice2Payment(taxWithholdTrans.InvoiceExemptedAmount,
                                                                              taxWithholdTrans.InvoiceCurrency,
                                                                              taxWithholdTrans.PaymCurrency,
                                                                              _settleExchRate,
                                                                              taxWithholdTrans.DataAreaId,
                                                                              taxWithholdTrans.PaymCompany);
                taxWithholdTrans.ExemptedAmount        = CurrencyExchangeHelper::mstAmount(taxWithholdTrans.InvoiceExemptedAmount, taxWithholdTrans.InvoiceCurrency, taxWithholdTrans.TransDate);

                if (isEnabledWHTCurrencyExchRateFeature)
                {
                    taxWithholdTrans.TaxExemptedAmount = this.payment2TaxWithhold(
                        taxWithholdTrans.PaymExemptedAmount,
                        taxWithholdTrans.PaymCurrency,
                        taxWithholdTrans.TaxWithholdCurrency,
                        taxWithholdTrans.TaxWithholdExchRate,
                        taxWithholdTrans.TaxWithholdExchRateDate,
                        true);
                }
                else
                {
                   taxWithholdTrans.TaxExemptedAmount     = CurrencyExchangeHelper::curAmount(taxWithholdTrans.ExemptedAmount, taxWithholdTrans.TaxWithholdCurrency, taxWithholdTrans.TransDate);
                }
            }

            tmpAmount = this.calcInvoiceWithholdBase(taxWithholdTrans, 0, 0, 0, false);
            if (tmpAmount)
            {
                tmpTaxWithhold.TaxWithholdExclude = taxWithholdTrans.InvoiceExemptedAmount * 100 / tmpAmount;
            }
            tmpTaxWithholdList.ins(tmpTaxWithhold, true);

            taxWithholdTrans.InvoiceWithholdBaseAmount = this.calcInvoiceWithholdBaseAmount(taxWithholdTrans,
                                                                                            custVendTransAmountCur,
                                                                                            accumPayment,
                                                                                            accumBaseAmountFromPreviousPayment);
            //<GBR>
            if (BrazilParameters::isEnabled())
            {
                if (accumBaseAmountFromPreviousPayment)
                {
                    taxWithholdTrans.InvoiceWithholdBaseAmount = abs(taxWithholdTrans.InvoiceWithholdBaseAmount);
                }

                if (taxWithholdTrans.InvoiceExemptedAmount)
                {
                    if (taxWithholdTrans.PaymWithholdBaseAmount < taxWithholdData1.TaxWithholdLimitMin)
                    {
                        tmpTaxWithhold.TaxWithholdValue = 0;
                    }
                }
            }
            //</GBR>

            taxWithholdTrans.PaymWithholdBaseAmount    = this.invoice2Payment(taxWithholdTrans.InvoiceWithholdBaseAmount,
                                                                              taxWithholdTrans.InvoiceCurrency,
                                                                              taxWithholdTrans.PaymCurrency,
                                                                              _settleExchRate,
                                                                              taxWithholdTrans.DataAreaId,
                                                                              taxWithholdTrans.PaymCompany);
            taxWithholdTrans.WithholdBaseAmount        = CurrencyExchangeHelper::mstAmount(
                taxWithholdTrans.InvoiceWithholdBaseAmount,
                taxWithholdTrans.InvoiceCurrency,
                taxWithholdTrans.TransDate,
                UnknownNoYes::Unknown,
                exchRate,
                exchRateSecond,
                triangulation);

            if (isEnabledWHTCurrencyExchRateFeature)
            {
                taxWithholdTrans.TaxWithholdBaseAmount = this.payment2TaxWithhold(
                    taxWithholdTrans.PaymWithholdBaseAmount,
                    taxWithholdTrans.PaymCurrency,
                    taxWithholdTrans.TaxWithholdCurrency,
                    taxWithholdTrans.TaxWithholdExchRate,
                    taxWithholdTrans.TaxWithholdExchRateDate);
            }
            else
            {
                taxWithholdTrans.TaxWithholdBaseAmount = CurrencyExchangeHelper::curAmount(taxWithholdTrans.WithholdBaseAmount, taxWithholdTrans.TaxWithholdCurrency, taxWithholdTrans.TransDate);
            }

            // <GTH>
            if (isTaxWithholdEnabledTH)
            {
                if (TaxWithholdExemptChange_THFlight::instance().isEnabled())
                {
                    if (_invoiceExemptedChanged)
                    {
                        taxWithholdTransExtensionTH = taxWithholdTrans.taxWithholdTransExtensionTH();
                        taxWithholdTransExtensionTH.InvoiceCurUpdatedWithholdBaseAmount = 0;
                        taxWithholdTrans.SysExtensionSerializerMap::packExtensionTable(taxWithholdTransExtensionTH);
                    }
                }

                TaxWithhold::calcTaxWithholdAmount(
                    taxWithholdTrans,
                    tmpTaxWithhold.TaxWithholdValue,
                    LedgerJournalTransExtensionTH::findByLedgerJournalTrans(ledgerJournalTrans.RecId).PaymentGrossUpType,
                    false);
            }
            else
            {
                // </GTH>
                // <GJP>
                if (isJPCountryRegion
                    && withholdTaxCalculationMethod_JP == TaxCalcMode::Interval)
                {
                    taxWithholdTrans.TaxWithholdAmount = this.calcWithholdTaxAmountMSTByInterval_JP(taxWithholdTrans);
                }
                else
                {
                    // </GJP>
                    taxWithholdTrans.TaxWithholdAmount = this.getTaxWithholdAmountFromTaxWithholdTrans(taxWithholdTrans, tmpTaxWithhold);
                    // <GJP>
                }
                // </GJP>

                taxWithholdTrans.WithholdBaseAmount = CurrencyExchangeHelper::amount(taxWithholdTrans.WithholdBaseAmount);
                // <GTH>
            }
            // </GTH>

            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                taxWithholdAmount = taxWithholdTrans.TaxWithholdAmount;

                if (abs(taxWithholdTrans.InvoiceWithholdBaseAmount) < abs(taxWithholdTrans.TaxWithholdAmount))
                {
                    taxWithholdAmount = taxWithholdTrans.TaxWithholdAmount;
                    taxWithholdTrans.WithholdBaseAmount = taxWithholdTrans.WithholdBaseAmount - accumPayment;
                    taxWithholdTrans.TaxWithholdAmount = CurrencyExchangeHelper::amount(taxWithholdTrans.WithholdBaseAmount * tmpTaxWithhold.TaxWithholdValue / 100);
                }
            }
            // </GBR>

            if (tmpTaxWithhold.TaxWithholdAmountMin != 0   &&
                abs(taxWithholdTrans.TaxWithholdAmount)   < tmpTaxWithhold.TaxWithholdAmountMin)
            {
                taxWithholdTrans.TaxWithholdAmount        = 0;
                taxWithholdTrans.TaxTaxWithholdAmount     = 0;
                taxWithholdTrans.PaymTaxWithholdAmount    = 0;
                taxWithholdTrans.InvoiceTaxWithholdAmount = 0;

                // <GTH>
                if (isTaxWithholdEnabledTH)
                {
                    taxWithholdTransExtensionTH = taxWithholdTrans.taxWithholdTransExtensionTH();
                    taxWithholdTransExtensionTH.AccountingCurExpenseAmount  = 0;
                    taxWithholdTransExtensionTH.TransCurExpenseAmount       = 0;
                    taxWithholdTransExtensionTH.InvoiceCurExpenseAmount     = 0;
                    taxWithholdTrans.SysExtensionSerializerMap::packExtensionTable(taxWithholdTransExtensionTH);
                }
                // </GTH>
            }
            else
            {
                if (tmpTaxWithhold.TaxWithholdAmountMax != 0   &&
                    taxWithholdTrans.TaxWithholdAmount   > tmpTaxWithhold.TaxWithholdAmountMax)
                {
                    // <GTH>
                    if (isTaxWithholdEnabledTH)
                    {
                        taxWithholdTransExtensionTH = taxWithholdTrans.taxWithholdTransExtensionTH();
                        // Reduce the expense when withhold tax amount is reduced as it is greater than the max amount.
                        taxWithholdTransExtensionTH.AccountingCurExpenseAmount -= taxWithholdTrans.TaxWithholdAmount - tmpTaxWithhold.TaxWithholdAmountMax;
                        taxWithholdTrans.SysExtensionSerializerMap::packExtensionTable(taxWithholdTransExtensionTH);
                    }
                    // </GTH>

                    taxWithholdTrans.TaxWithholdAmount    = tmpTaxWithhold.TaxWithholdAmountMax;
                }

                if (isEnabledWHTCurrencyExchRateFeature)
                {
                    taxWithholdTrans.InvoiceTaxWithholdAmount = CurrencyExchangeHelper::curAmount(
                        taxWithholdTrans.TaxWithholdAmount,
                        taxWithholdTrans.InvoiceCurrency,
                        taxWithholdTrans.TransDate,
                        UnknownNoYes::Unknown,
                        exchRate,
                        exchRateSecond,
                        triangulation);

                    taxWithholdTrans.PaymTaxWithholdAmount = this.invoice2Payment(
                        taxWithholdTrans.InvoiceTaxWithholdAmount,
                        taxWithholdTrans.InvoiceCurrency,
                        taxWithholdTrans.PaymCurrency,
                        _settleExchRate,
                        taxWithholdTrans.DataAreaId,
                        taxWithholdTrans.PaymCompany);

                    taxWithholdTrans.TaxTaxWithholdAmount = this.payment2TaxWithhold(
                        taxWithholdTrans.PaymTaxWithholdAmount,
                        taxWithholdTrans.PaymCurrency,
                        taxWithholdTrans.TaxWithholdCurrency,
                        taxWithholdTrans.TaxWithholdExchRate,
                        taxWithholdTrans.TaxWithholdExchRateDate);
                }
                else
                {
                    taxWithholdTrans.TaxTaxWithholdAmount = CurrencyExchangeHelper::curAmount(
                        taxWithholdTrans.TaxWithholdAmount,
                        taxWithholdTrans.TaxWithholdCurrency,
                        taxWithholdTrans.TransDate,
                        UnknownNoYes::Unknown,
                        exchRate,
                        exchRateSecond,
                        triangulation);
                }

                // <GTH>
                if (isTaxWithholdEnabledTH)
                {
                    taxWithholdTransExtensionTH = taxWithholdTrans.taxWithholdTransExtensionTH();

                    taxWithholdTransExtensionTH.TransCurExpenseAmount = CurrencyExchangeHelper::curAmount(taxWithholdTransExtensionTH.AccountingCurExpenseAmount, taxWithholdTrans.TaxWithholdCurrency, taxWithholdTrans.TransDate);

                    taxWithholdTransExtensionTH.InvoiceCurExpenseAmount = CurrencyExchangeHelper::curAmount(taxWithholdTransExtensionTH.AccountingCurExpenseAmount, taxWithholdTrans.InvoiceCurrency, taxWithholdTrans.TransDate);

                    taxWithholdTrans.SysExtensionSerializerMap::packExtensionTable(taxWithholdTransExtensionTH);
                }
                // </GTH>
            }

            taxWithholdTrans = this.roundOffTaxWithholdAmount(taxWithholdTrans,
                                                              tmpTaxWithhold,
                                                              _settleExchRate);

            taxWithholdTable = taxWithholdTable.RecId ? taxWithholdTable : TaxWithholdTable::find(taxWithholdTrans.TaxWithholdCode);
            taxWithholdTrans.InvoiceAmountInTaxWithholdCur = CurrencyExchangeHelper::curAmount2CurAmount(
                taxWithholdTrans.InvoiceAmount, 
                taxWithholdTrans.InvoiceCurrency, 
                taxWithholdTable.CurrencyCode, 
                taxWithholdTrans.TransDate, 
                false);
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            taxWithholdTrans.TaxWithholdIsSelected_BR  = taxWithholdTrans.InvoiceTaxWithholdAmount ? NoYes::Yes : NoYes::No;
            this.resetWhTaxAmountIfPaymAmountIsLess_BR(taxWithholdTrans, _settleExchRate);
            this.updateSelectedTaxWithholdTrans_BR();
            taxWithholdTrans.TaxWithholdIsSelected_BR  = taxWithholdTrans.InvoiceTaxWithholdAmount ? NoYes::Yes : NoYes::No;

            taxWithholdTrans.RefCustVendTransRecId_BR = taxWithholdTrans.TaxWithholdIsSelected_BR ? custVendTrans.RecId : 0;

            if (limitMax)
            {
                this.setWhBaseAmt4PayAmtInMonth_BR(taxWithholdTrans,_settleExchRate);
            }
        }
        // </GBR>

        return taxWithholdTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcWithholdTaxAmountMSTByInterval_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate withholding tax amount by interval
    /// </summary>
    /// <param name="_taxWithholdTrans">
    /// A <c>TaxWithholdTrans</c> table buffer.
    /// </param>
    /// <returns>
    /// Calculated withholding tax amount in accounting currency
    /// </returns>
    private TaxWithholdAmount calcWithholdTaxAmountMSTByInterval_JP(TaxWithholdTrans  _taxWithholdTrans)
    {
        TaxWithholdAmount   withholdTaxAmount;
        TaxWithholdData     taxWithholdData;

        if (_taxWithholdTrans.WithholdBaseAmount)
        {
            while select TaxWithholdLimitMax, TaxWithholdLimitMin, TaxWithholdValue from taxWithholdData
                where taxWithholdData.TaxWithholdCode       == _taxWithholdTrans.TaxWithholdCode
                    && taxWithholdData.TaxWithholdLimitMin  < _taxWithholdTrans.WithholdBaseAmount
                    && (!taxWithholdData.TaxWithholdFromDate
                        || taxWithholdData.TaxWithholdFromDate  <= _taxWithholdTrans.TransDate)
                    && (!taxWithholdData.TaxWithholdToDate
                        || taxWithholdData.TaxWithholdToDate    >= _taxWithholdTrans.TransDate)
            {
                if (taxWithholdData.TaxWithholdLimitMax     == 0
                    || taxWithholdData.TaxWithholdLimitMax  >= _taxWithholdTrans.WithholdBaseAmount)
                {
                    withholdTaxAmount += (_taxWithholdTrans.WithholdBaseAmount - taxWithholdData.TaxWithholdLimitMin) * taxWithholdData.TaxWithholdValue / 100;
                }
                else
                {
                    withholdTaxAmount += (taxWithholdData.TaxWithholdLimitMax - taxWithholdData.TaxWithholdLimitMin) * taxWithholdData.TaxWithholdValue / 100;
                }
            }
            
            if (!TaxWHTSkipRounding_JPFlight::instance().isEnabled())
            {
                withholdTaxAmount = CurrencyExchangeHelper::amount(withholdTaxAmount);
            }
        }

        return withholdTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeInvoiceAmountSettle</Name>
				<Source><![CDATA[
    /// <summary>
    /// Changes the invoice amount for settlement.
    /// </summary>
    /// <param name = "_taxWithholdTrans">The buffer of <c>TaxWithholdTrans</c>.</param>
    /// <param name = "_vendTrans">The buffer of <c>CustVendTrans</c>.</param>
    /// <param name = "_invoiceAmountSettle">The settlement invoice amount.</param>
    /// <param name = "_settleExchRate">The settlement exchange rate.</param>
    /// <returns>The buffer of <c>TaxWithholdTrans</c>.</returns>
    public TaxWithholdTrans changeInvoiceAmountSettle(TaxWithholdTrans _taxWithholdTrans,
                                                      CustVendTrans    _vendTrans,
                                                      AmountCur        _invoiceAmountSettle,
                                                      CrossExchRate    _settleExchRate)
    {
        TaxWithholdTrans  taxWithholdTrans = _taxWithholdTrans;

        taxWithholdTrans.InvoiceAmount    = - _invoiceAmountSettle;
        taxWithholdTrans.InvoiceTaxAmount = this.calcInvoiceTaxAmount(taxWithholdTrans, _vendTrans);

        taxWithholdTrans = this.calcWithholdAmounts(taxWithholdTrans, _settleExchRate);

        return taxWithholdTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeTaxWithholdAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method will update withholding tax amount for specified withholding tax transaction.
    /// </summary>
    /// <param name="_taxWithholdTrans">
    ///    A <c>TaxWithholdTrans</c> table buffer that to be updated.
    /// </param>
    /// <param name="_settleExchRate">
    ///    The exchange rate for settlement.
    /// </param>
    /// <returns>
    ///    The updated <c>TaxWithholdTrans</c> table buffer.
    /// </returns>
    public TaxWithholdTrans changeTaxWithholdAmount(TaxWithholdTrans _taxWithholdTrans,
                                                    CrossExchRate    _settleExchRate)
    {
        TaxWithholdTrans  taxWithholdTrans = _taxWithholdTrans;
        // <GTH>
        TaxWithholdTransExtensionTH taxWithholdTransExtensionTH;
        // </GTH>
        TmpTaxWithhold    tmpTaxWithhold;

        if (taxWithholdTrans.TaxWithholdCode)
        {
            taxWithholdTrans.PaymTaxWithholdAmount = this.invoice2Payment(taxWithholdTrans.InvoiceTaxWithholdAmount,
                                                                          taxWithholdTrans.InvoiceCurrency,
                                                                          taxWithholdTrans.PaymCurrency,
                                                                          _settleExchRate,
                                                                          taxWithholdTrans.DataAreaId,
                                                                          taxWithholdTrans.PaymCompany);
            taxWithholdTrans.TaxWithholdAmount     = CurrencyExchangeHelper::mstAmount(taxWithholdTrans.InvoiceTaxWithholdAmount, taxWithholdTrans.InvoiceCurrency, taxWithholdTrans.TransDate);

            if (isEnabledWHTCurrencyExchRateFeature)
            {
                taxWithholdTrans.TaxTaxWithholdAmount = this.payment2TaxWithhold(
                    taxWithholdTrans.PaymTaxWithholdAmount,
                    taxWithholdTrans.PaymCurrency,
                    taxWithholdTrans.TaxWithholdCurrency,
                    taxWithholdTrans.TaxWithholdExchRate,
                    taxWithholdTrans.TaxWithholdExchRateDate);
            }
            else
            {
                taxWithholdTrans.TaxTaxWithholdAmount  = CurrencyExchangeHelper::curAmount(taxWithholdTrans.TaxWithholdAmount, taxWithholdTrans.TaxWithholdCurrency, taxWithholdTrans.TransDate);
            }

            tmpTaxWithhold = this.findTmpTaxWithhold(taxWithholdTrans);

            if (tmpTaxWithhold.TaxWithholdAmountMin != 0   &&
                taxWithholdTrans.TaxWithholdAmount   < tmpTaxWithhold.TaxWithholdAmountMin)
            {
                taxWithholdTrans.TaxWithholdAmount        = 0;
                taxWithholdTrans.TaxTaxWithholdAmount     = 0;
                taxWithholdTrans.PaymTaxWithholdAmount    = 0;
                taxWithholdTrans.InvoiceTaxWithholdAmount = 0;
            }

            if (tmpTaxWithhold.TaxWithholdAmountMax != 0   &&
                taxWithholdTrans.TaxWithholdAmount   > tmpTaxWithhold.TaxWithholdAmountMax)
            {
                taxWithholdTrans.TaxWithholdAmount        = tmpTaxWithhold.TaxWithholdAmountMax;

                taxWithholdTrans.InvoiceTaxWithholdAmount    = CurrencyExchangeHelper::curAmount(taxWithholdTrans.TaxWithholdAmount, taxWithholdTrans.InvoiceCurrency, taxWithholdTrans.TransDate);
                taxWithholdTrans.PaymTaxWithholdAmount = this.invoice2Payment(taxWithholdTrans.InvoiceTaxWithholdAmount,
                                                                                 taxWithholdTrans.InvoiceCurrency,
                                                                                 taxWithholdTrans.PaymCurrency,
                                                                                 _settleExchRate,
                                                                                 taxWithholdTrans.DataAreaId,
                                                                                 taxWithholdTrans.PaymCompany);

                if (isEnabledWHTCurrencyExchRateFeature)
                {
                    taxWithholdTrans.TaxTaxWithholdAmount = this.payment2TaxWithhold(
                        taxWithholdTrans.PaymTaxWithholdAmount,
                        taxWithholdTrans.PaymCurrency,
                        taxWithholdTrans.TaxWithholdCurrency,
                        taxWithholdTrans.TaxWithholdExchRate,
                        taxWithholdTrans.TaxWithholdExchRateDate);
                }
                else
                {
                    taxWithholdTrans.TaxTaxWithholdAmount = CurrencyExchangeHelper::curAmount(taxWithholdTrans.TaxWithholdAmount, taxWithholdTrans.TaxWithholdCurrency, taxWithholdTrans.TransDate);
                }
            }

            // <GTH>
            if (isTaxWithholdEnabledTH)
            {
                taxWithholdTransExtensionTH = taxWithholdTrans.taxWithholdTransExtensionTH();
                if (abs(taxWithholdTransExtensionTH.AccountingCurExpenseAmount) > abs(taxWithholdTrans.TaxWithholdAmount))
                {
                    // Reduce the expense when withhold tax amount is reduced as it is greater than the max amount.
                    taxWithholdTransExtensionTH.AccountingCurExpenseAmount = taxWithholdTrans.TaxWithholdAmount;

                    taxWithholdTransExtensionTH.TransCurExpenseAmount = CurrencyExchangeHelper::curAmount(taxWithholdTransExtensionTH.AccountingCurExpenseAmount, taxWithholdTrans.TaxWithholdCurrency, taxWithholdTrans.TransDate);

                    taxWithholdTransExtensionTH.InvoiceCurExpenseAmount = CurrencyExchangeHelper::curAmount(taxWithholdTransExtensionTH.AccountingCurExpenseAmount, taxWithholdTrans.InvoiceCurrency, taxWithholdTrans.TransDate);

                    taxWithholdTrans.SysExtensionSerializerMap::packExtensionTable(taxWithholdTransExtensionTH);
                }
            }
            // </GTH>

            taxWithholdTrans = this.roundOffTaxWithholdAmount(taxWithholdTrans,
                                                              tmpTaxWithhold,
                                                              _settleExchRate);
        }

        return taxWithholdTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeTaxWithholdExchangeRate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method will update withholding tax exchange rate for specified withholding tax transaction.
    /// </summary>
    /// <param name="_taxWithholdTrans">
    ///    A <c>TaxWithholdTrans</c> table buffer that to be updated.
    /// </param>
    /// <param name="_settleExchRate">
    ///    The exchange rate for settlement.
    /// </param>
    /// <returns>
    ///    The updated <c>TaxWithholdTrans</c> table buffer.
    /// </returns>
    internal TaxWithholdTrans changeTaxWithholdExchangeRate(TaxWithholdTrans _taxWithholdTrans, CrossExchRate _settleExchRate)
    {
        TaxWithholdTrans taxWithholdTrans = _taxWithholdTrans;

        if (isEnabledWHTCurrencyExchRateFeature)
        {
            taxWithholdTrans.TaxExemptedAmount = this.payment2TaxWithhold(
                    taxWithholdTrans.PaymExemptedAmount,
                    taxWithholdTrans.PaymCurrency,
                    taxWithholdTrans.TaxWithholdCurrency,
                    taxWithholdTrans.TaxWithholdExchRate,
                    taxWithholdTrans.TaxWithholdExchRateDate,
                    true);

            taxWithholdTrans.TaxWithholdBaseAmount = this.payment2TaxWithhold(
                taxWithholdTrans.PaymWithholdBaseAmount,
                taxWithholdTrans.PaymCurrency,
                taxWithholdTrans.TaxWithholdCurrency,
                taxWithholdTrans.TaxWithholdExchRate,
                taxWithholdTrans.TaxWithholdExchRateDate);

            taxWithholdTrans = this.changeTaxWithholdAmount(_taxWithholdTrans, _settleExchRate);
        }

        return taxWithholdTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxLimitBaseAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return if its necessary check tax base amount when fetching withholding tax data percentage.
    /// </summary>
    /// <param name="_taxWithholdCode">
    /// withholding tax code used to select withholding tax transactions
    /// </param>
    /// <param name="_periodStart">
    /// Start of the month for a given date.
    /// </param>
    /// <param name="_periodEnd">
    /// End of the month for a given date.
    /// </param>
    /// <returns>
    /// true if any withhold tax already calculated(accumulated base amount more than the minimum limit), otherwise false.
    /// </returns>
    /// <remarks>
    /// Used in connection TaxData::find method.
    /// return true if taxData has to check base
    /// </remarks>

    protected boolean checkTaxLimitBaseAmount_BR(TaxWithholdCode _taxWithholdCode,
                                              TransDate _periodStart = dateStartMth(ledgerJournalTrans.TransDate),
                                              TransDate _periodEnd   = dateEndMth(_periodStart))
    {
        TaxWithholdTrans    taxWithholdTrans;
        container           dataAreaIdList = this.crossCompanyList_BR();

        select crosscompany:dataAreaIdList count(RecId)
            from    taxWithholdTrans
            where   taxWithholdTrans.PartyId_BR                 == this.partyId_BR()
                &&  taxWithholdTrans.Source_BR                  == this.taxWithholdSource_BR()
                &&  taxWithholdTrans.TaxWithholdCode            == _taxWithholdCode
                &&  taxWithholdTrans.TransDate                  >= _periodStart
                &&  taxWithholdTrans.TransDate                  <= _periodEnd
                &&  taxWithholdTrans.TaxWithholdIsSelected_BR   == NoYes::Yes
                &&  taxWithholdTrans.CanBeReversed_BR           == NoYes::Yes
                &&  taxWithholdTrans.InvoiceTaxWithholdAmount   != 0;

        return !taxWithholdTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAllTaxWithholdTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Calculates tax withholding information.
    /// </summary>
    /// <remarks>
    ///   This method uses caching.  If adding a new call to this method please be
    ///   sure to clear the cache after the call.  See the method <c>clearCache</c> on this class.
    /// </remarks>
    public void createAllTaxWithholdTrans()
    {
        SpecTrans           specTrans;
        TaxWithholdTrans    taxWithholdTrans;
        boolean             printMessageHeader = true;
        RefTableId          taxWithholdRefTableId = 0;
        CustVendTrans       localCustVendTrans;
        AmountCur           invoiceSettleAmount;

        if (ledgerJournalTrans.parmLedgerDimension()
            && !ledgerJournalTrans.Invoice)
        {
            if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
            {
                taxWithholdRefTableId = tableNum(VendTransOpen);
            }
            else if (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
            {
                taxWithholdRefTableId = tableNum(CustTransOpen);
            }

            if (taxWithholdRefTableId)
            {
                boolean isTaxWithholdCreated_BR;
                ttsbegin;
                while select crossCompany specTrans
                    where specTrans.SpecCompany == ledgerJournalTrans.DataAreaId
                       && specTrans.SpecTableId == ledgerJournalTrans.TableId
                       && specTrans.SpecRecId   == ledgerJournalTrans.RecId
                       && specTrans.RefTableId  == taxWithholdRefTableId
                {
                    taxWithholdTrans = null;

                    changecompany(specTrans.RefCompany)
                    {
                        delete_from  taxWithholdTrans
                            where  taxWithholdTrans.SpecTransId == specTrans.RecId;

                        if (TaxWithhold::enableAdvancedTaxWithhold())
                        {
                            this.createTaxWithholdTrans_TH(specTrans,
                                                        specTrans.CrossRate,
                                                        printMessageHeader);
                        }
                        else
                        {
                            // <GBR>
                            if (BrazilParameters::isEnabled())
                            {
                                isTaxWithholdCreated_BR = true;
                                if (taxWithholdRefTableId == tableNum(VendTransOpen))
                                {
                                    localCustVendTrans  = specTrans.vendTrans();
                                    if (TaxWithholdBaseAmtForPaymProposalWithDiscount_BRFlight::instance().isEnabled())
                                    {
                                        invoiceSettleAmount = specTrans.Balance01
                                            - (specTrans.vendTransOpen().InterestAmount_BR + specTrans.vendTransOpen().FineAmount_BR)
                                            + this.getCashdisc_TH(specTrans);
                                    }
                                    else
                                    {
                                        invoiceSettleAmount = specTrans.Balance01 - (specTrans.vendTransOpen().InterestAmount_BR + specTrans.vendTransOpen().FineAmount_BR);
                                    }
                                }
                                else
                                {
                                    localCustVendTrans  = specTrans.custTrans();
                                    if (TaxWithholdBaseAmtForPaymProposalWithDiscount_BRFlight::instance().isEnabled())
                                    {
                                        invoiceSettleAmount = specTrans.Balance01
                                            - (specTrans.custTransOpen().InterestAmount_BR + specTrans.custTransOpen().FineAmount_BR)
                                            + this.getCashdisc_TH(specTrans);;
                                    }
                                    else
                                    {
                                        invoiceSettleAmount = specTrans.Balance01 - (specTrans.custTransOpen().InterestAmount_BR + specTrans.custTransOpen().FineAmount_BR);
                                    }
                                }
                                this.createTaxWithholdTrans(localCustVendTrans,
                                                        specTrans,
                                                        invoiceSettleAmount,
                                                        specTrans.CrossRate,
                                                        printMessageHeader);
                            }
                            else
                            {
                                // </GBR>
                                localCustVendTrans = specTrans.vendTrans();
                                this.createTaxWithholdTrans(localCustVendTrans,
                                                        specTrans,
                                                        specTrans.Balance01,
                                                        specTrans.CrossRate,
                                                        printMessageHeader);
                                // <GBR>
                            }
                            // </GBR>
                        }
                        printMessageHeader = false;
                    }
                }
                ttscommit;
                if (isTaxWithholdCreated_BR)
                {
                    GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceBR00009, funcName());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendTableForJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds CustTable or VendTable record for the PO or SO.
    /// </summary>
    /// <returns>
    /// CustTable or VendTable record for the PO or SO.
    /// </returns>
    /// <remarks>
    /// CustVendTableForJournalTrans should be recalculated only once.
    /// </remarks>
    internal CustVendTable getCustVendTableForJournalTrans()
    {
        if (!custVendTableForJournalTrans)
        {
            if (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
            {
                custVendTableForJournalTrans = CustTable::find(ledgerJournalTrans.parmAccount());
            }
            else if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
            {
                custVendTableForJournalTrans = VendTable::find(ledgerJournalTrans.parmAccount());
            }
        }

        return custVendTableForJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxTransForGWHTaxTMarkupTrans</Name>
				<Source><![CDATA[
    private TaxTrans getTaxTransForGWHTaxTMarkupTrans(MarkupTrans _markupTrans)
    {
        TaxTrans taxTransCur;

        if (_markupTrans.TaxGroup && _markupTrans.TaxItemGroup)
        {
            select sum(SourceTaxAmountCur) from taxTransCur
                where taxTransCur.SourceTableId == _markupTrans.TableId
                   && taxTransCur.SourceRecId == _markupTrans.RecId;
        }

        return taxTransCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateGWHTaxTransForChargeCodes</Name>
				<Source><![CDATA[
    private boolean canCreateGWHTaxTransForChargeCodes()
    {
        return this.getCustVendTableForJournalTrans().TaxWithholdCalculate
            && this.getCustVendTableForJournalTrans().TaxWithholdGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateTaxWithholdRecordForGWHTChargesCodes</Name>
				<Source><![CDATA[
    private void generateTaxWithholdRecordForGWHTChargesCodes(
        MarkupTrans _markupTrans,
        SpecTrans _specTransLoc,
        CustVendTrans _custVendTrans,
        CustVendInvoiceTrans _custVendInvoiceTrans,
        AmountCur _currentInvoiceAmountSettle,
        CrossExchRate _settleExchRate,
        boolean _isCorrection,
        boolean _inclTax)
    {
        TaxWithholdGroup taxWithholdGroup = _markupTrans.TaxWithholdGroup ? _markupTrans.TaxWithholdGroup : this.getCustVendTableForJournalTrans().TaxWithholdGroup;
        TaxTrans taxTransCur = this.getTaxTransForGWHTaxTMarkupTrans(_markupTrans);
        TaxAmount taxAmount = abs(taxTransCur.SourceTaxAmountCur);

        AmountCur markupAmountInclTax = _markupTrans.CalculatedAmount + taxAmount;

        this.generateTaxWithholdRecordWithMarkupTrans(_specTransLoc,
            _custVendTrans,
            _custVendInvoiceTrans,
            _currentInvoiceAmountSettle,
            _markupTrans.TaxWithholdItemGroup,
            _settleExchRate,
            _isCorrection,
            _inclTax,
            true, // creating of GWHTaxTrans for charge codes
            taxWithholdGroup,
            taxAmount,
            markupAmountInclTax);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createItemTaxWithholdTransForChargeCodeHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the withholding taxes for the each charge code (MarkupTrans) for the order or invoice headers.
    /// </summary>
    /// <param name="_specTransLoc">
    /// A <c>SpecTrans</c> table buffer that references the payment record for which the calculation will be done.
    /// </param>
    /// <param name="_custVendTrans">
    /// A <c>CustVendTrans</c> table buffer that references the payment record for which the calculation will
    /// be done.
    /// </param>
    /// <param name="_custVendInvoiceJour">
    /// A <c>CustVendInvoiceJour</c> table buffer.
    /// </param>
    /// <param name="_currentInvoiceAmountSettle">
    /// An invoice amount which is used in settlement.
    /// </param>
    /// <param name="_settleExchRate">
    /// The exchange rate which is used in settlement.
    /// </param>
    /// <param name="_isCorrection">
    /// A Boolean value that specifies whether the base amount has to be adjusted.
    /// </param>
    /// <param name="_inclTax">
    ///    Indicates whether including tax.
    /// </param>
    /// <param name="_printMessageHeader">
    /// A Boolean value that specifies whether the vendor or customer name has to be printed on the
    /// withholding dialog box.
    /// </param>
    /// <returns>
    /// If there was withholding transaction creation, function returns true.
    /// Otherwise, the return value is false.
    /// </returns>
    internal boolean createItemTaxWithholdTransForChargeCodeHeader(
        SpecTrans _specTransLoc,
        CustVendTrans _custVendTrans,
        CustVendInvoiceJour _custVendInvoiceJour,
        AmountCur _currentInvoiceAmountSettle,
        CrossExchRate _settleExchRate,
        boolean _isCorrection,
        boolean _inclTax,
        boolean _printMessageHeader)
    {
        boolean wasWHTChargeCodesCalculation;

        if (this.canCreateGWHTaxTransForChargeCodes())
        {
            this.printTaxWithholdHeaderInfo(_printMessageHeader, _custVendTrans.AccountNum);

            MarkupTrans markupTransCur;

            while select markupTransCur
                where markupTransCur.TransTableId == _custVendInvoiceJour.TableId &&
                      markupTransCur.TransRecId == _custVendInvoiceJour.RecId &&
                      markupTransCur.CalculatedAmount &&
                      markupTransCur.TaxWithholdItemGroup
            {
                this.generateTaxWithholdRecordForGWHTChargesCodes(
                    markupTransCur,
                    _specTransLoc,
                    _custVendTrans,
                    null,
                    _currentInvoiceAmountSettle,
                    _settleExchRate,
                    _isCorrection,
                    _inclTax);

                wasWHTChargeCodesCalculation = true;
            }
        }

        return wasWHTChargeCodesCalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createItemTaxWithholdTransForChargeCodeLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the withholding taxes for the each charge code (MarkupTrans) for the order or invoice lines.
    /// </summary>
    /// <param name="_specTransLoc">
    /// A <c>SpecTrans</c> table buffer that references the payment record for which the calculation will be done.
    /// </param>
    /// <param name="_custVendTrans">
    /// A <c>CustVendTrans</c> table buffer that references the payment record for which the calculation will
    /// be done.
    /// </param>
    /// <param name="_custVendInvoiceTrans">
    ///    A <c>CustVendInvoiceTrans</c> table buffer.
    /// </param>
    /// <param name="_currentInvoiceAmountSettle">
    /// An invoice amount which is used in settlement.
    /// </param>
    /// <param name="_settleExchRate">
    /// The exchange rate which is used in settlement.
    /// </param>
    /// <param name="_isCorrection">
    /// A Boolean value that specifies whether the base amount has to be adjusted.
    /// </param>
    /// <param name="_inclTax">
    ///    Indicates whether including tax.
    /// </param>
    /// <param name="_printMessageHeader">
    /// A Boolean value that specifies whether the vendor or customer name has to be printed on the
    /// withholding dialog box.
    /// </param>
    /// <returns>
    /// If there was withholding transaction creation, function returns true.
    /// Otherwise, the return value is false.
    /// </returns>
    internal boolean createItemTaxWithholdTransForChargeCodeLines(
        SpecTrans _specTransLoc,
        CustVendTrans _custVendTrans,
        CustVendInvoiceTrans _custVendInvoiceTrans,
        AmountCur _currentInvoiceAmountSettle,
        CrossExchRate _settleExchRate,
        boolean _isCorrection,
        boolean _inclTax,
        boolean _printMessageHeader)
    {
        boolean wasWHTChargeCodesCalculation;

        if (this.canCreateGWHTaxTransForChargeCodes())
        {
            this.printTaxWithholdHeaderInfo(_printMessageHeader, _custVendTrans.AccountNum);

            MarkupTrans markupTransCur;

            while select markupTransCur
                where markupTransCur.TransTableId == _custVendInvoiceTrans.TableId &&
                      markupTransCur.TransRecId == _custVendInvoiceTrans.RecId &&
                      markupTransCur.CalculatedAmount &&
                      markupTransCur.TaxWithholdItemGroup
            {
                this.generateTaxWithholdRecordForGWHTChargesCodes(
                    markupTransCur,
                    _specTransLoc,
                    _custVendTrans,
                    _custVendInvoiceTrans,
                    _currentInvoiceAmountSettle,
                    _settleExchRate,
                    _isCorrection,
                    _inclTax);

                wasWHTChargeCodesCalculation = true;
            }
        }

        return wasWHTChargeCodesCalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createItemTaxWithholdTrans_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the withholding taxes based on each invoice and tax withholding group and tax
    /// withholding item group that is specified on each invoice line.
    /// </summary>
    /// <param name="_specTransLoc">
    /// A <c>SpecTrans</c> table buffer that references the payment record for which the calculation will be done.
    /// </param>
    /// <param name="_custVendTrans">
    /// A <c>CustVendTrans</c> table buffer that references the payment record for which the calculation will
    /// be done.
    /// </param>
    /// <param name="_currentInvoiceAmountSettle">
    /// An invoice amount which is used in settlement.
    /// </param>
    /// <param name="_settleExchRate">
    /// The exchange rate which is used in settlement.
    /// </param>
    /// <param name="_isCorrection">
    /// A Boolean value that specifies whether the base amount has to be adjusted.
    /// </param>
    /// <param name="_printMessageHeader">
    /// A Boolean value that specifies whether the vendor or customer name has to be printed on the
    /// withholding dialog box.
    /// </param>
    protected void createItemTaxWithholdTrans_TH(
        SpecTrans               _specTransLoc,
        CustVendTrans           _custVendTrans,
        AmountCur               _currentInvoiceAmountSettle,
        CrossExchRate           _settleExchRate,
        boolean                 _isCorrection,
        boolean                 _printMessageHeader)
    {
        VendInvoiceJour         vendInvoiceJour;
        VendInvoiceTrans        vendInvoiceTrans;
        boolean                 inclTax;
        boolean wasWHTChargeCodesCalculation;

        changecompany(_specTransLoc.RefCompany)
        {
            vendInvoiceJour = this.findVendInvoiceJourFromVendTrans(_custVendTrans.Invoice, 
                                                                    _custVendTrans.TransDate, 
                                                                    _custVendTrans.AccountNum, 
                                                                    _custVendTrans.Voucher);
            inclTax = vendInvoiceJour.InclTax;

            if (TaxWithholdDetermineTaxInclusiveByPurchTableFirstFlight::instance().isEnabled())
            {
                if (!vendInvoiceJour.isNonPO())
                {
                    PurchTable purchTable = PurchTable::find(vendInvoiceJour.PurchID);
                    if (purchTable)
                    {
                        inclTax = purchTable.InclTax;
                    }
                }
            }

            if (enableWHTOnCharges)
            {
                // Generate TaxWithholdTrans record for GWHT for charge codes for the order or invoice headers.
                wasWHTChargeCodesCalculation = this.createItemTaxWithholdTransForChargeCodeHeader(_specTransLoc,
                    _custVendTrans,
                    vendInvoiceJour,
                    _currentInvoiceAmountSettle,
                    _settleExchRate,
                    _isCorrection,
                    inclTax,
                    _printMessageHeader);

                _printMessageHeader = !wasWHTChargeCodesCalculation;
            }

            // Loop through each line of the invoice and calculate the WHT amount.
            while select vendInvoiceTrans
                    where vendInvoiceTrans.PurchID == vendInvoiceJour.PurchId
                        && vendInvoiceTrans.InvoiceDate == vendInvoiceJour.InvoiceDate
                        && vendInvoiceTrans.InvoiceId == vendInvoiceJour.InvoiceId
                        && vendInvoiceTrans.NumberSequenceGroup == vendInvoiceJour.NumberSequenceGroup
                        && vendInvoiceTrans.InternalInvoiceId == vendInvoiceJour.InternalInvoiceId
            {
                // Determine if each line has all the WHT info.
                if (this.isCalculateTaxWithholdingNeeded_TH(
                            vendInvoiceTrans.TaxWithholdGroup_TH,
                            vendInvoiceTrans.TaxWithholdItemGroupHeading_TH,
                            vendInvoiceTrans))
                {
                    //  Determine if Vendor number needs to printed.
                    this.printTaxWithholdHeaderInfo(_printMessageHeader, _custVendTrans.AccountNum);

                    // Generate TaxWithholdTrans record that will have WHT info.
                    this.generateTaxWithholdRecordWithMarkupTrans(_specTransLoc,
                        _custVendTrans,
                        vendInvoiceTrans,
                        _currentInvoiceAmountSettle,
                        vendInvoiceTrans.TaxWithholdItemGroupHeading_TH,
                        _settleExchRate,
                        _isCorrection,
                        inclTax);

                    _printMessageHeader = false;
                }

                if (enableWHTOnCharges)
                {
                    // Generate TaxWithholdTrans record for GWHT for charge codes for the order or invoice line.
                    wasWHTChargeCodesCalculation = this.createItemTaxWithholdTransForChargeCodeLines(_specTransLoc,
                        _custVendTrans,
                        vendInvoiceTrans,
                        _currentInvoiceAmountSettle,
                        _settleExchRate,
                        _isCorrection,
                        inclTax,
                        _printMessageHeader);

                    _printMessageHeader = !wasWHTChargeCodesCalculation;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parentTypeForGHWTTelemetry</Name>
				<Source><![CDATA[
    protected str parentTypeForGHWTTelemetry()
    {
        return enum2Str(this.taxWithholdSource_BR() == TaxWithholdSource::VendPayment ? SalesPurch::Purch : SalesPurch::Sales);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxWithholdTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates tax withhold transctions.
    /// </summary>
    /// <param name = "_vendTrans">The buffer of <c>CustVendTrans</c>.</param>
    /// <param name = "_specTrans">The buffer of <c>SpecTrans</c>.</param>
    /// <param name = "_invoiceAmountSettle">The settlement invoice amount.</param>
    /// <param name = "_settleExchRate">The settlement exchange rate.</param>
    /// <param name = "_printMessageHeader">Whether print message in header.</param>
    public void createTaxWithholdTrans(CustVendTrans    _vendTrans,
                                    SpecTrans           _specTrans,
                                    AmountCur           _invoiceAmountSettle,
                                    CrossExchRate       _settleExchRate,
                                    boolean             _printMessageHeader = true)
    {
        TaxWithholdTrans      taxWithholdTrans;
        TaxWithholdGroupData  taxWithholdGroupData;
        TmpTaxWithhold        tmpTaxWithhold;
        boolean               printMessageHeader = _printMessageHeader;
        // <GBR>
        Map                   mapOfTaxesToBeCalculated;
        MapEnumerator         enumerator;
        AmountCur             invoiceAmountSettle = _invoiceAmountSettle;
        AmountCur             taxWithholdTotalAmount;
        // </GBR>

        // <GIN>
        int taxLines;
        // </GIN>

        if(!this.canCreateTaxWithholdTrans(_vendTrans))
        {
            TaxWithHoldInstrumentationTelemetry::logGWHTTelemetry(
                GlobalizationConstants::FeatureReferenceTAX00037,
                funcName(),
                TaxWithHoldInstrumentationTelemetry::SettleTransactions,
                this.parentTypeForGHWTTelemetry(),
                false,
                0,
                0);

            return;
        }

        Debug::assert(curext() == _vendTrans.company());

        System.Diagnostics.Stopwatch stopWatch;

        try
        {
            stopWatch = new System.Diagnostics.Stopwatch();

            stopWatch.Start();

            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                mapOfTaxesToBeCalculated = TaxWithhold::getInvoiceTaxWithholdIntersection_BR(_vendTrans);

                if (!mapOfTaxesToBeCalculated.elements())
                {
                    return;
                }
            }
            else
            {
                mapOfTaxesToBeCalculated = new Map(Types::Container, Types::Real);

                while select TaxWithholdGroup, TaxWithholdCode from taxWithholdGroupData
                     where taxWithholdGroupData.TaxWithholdGroup == ledgerJournalTrans.TaxWithholdGroup
                {
                    mapOfTaxesToBeCalculated.insert([taxWithholdGroupData.TaxWithholdGroup, taxWithholdGroupData.TaxWithholdCode], _invoiceAmountSettle);
                }
            }
            enumerator = mapOfTaxesToBeCalculated.getEnumerator();
            // </GBR>

            ttsbegin;

            while (enumerator.moveNext())
            {
                // <GBR>
                taxWithholdGroupData.TaxWithholdCode = conPeek(enumerator.currentKey(), 2);

                taxWithholdTrans.clear();

                if (BrazilParameters::isEnabled())
                {
                    taxWithholdTrans.IntersectionWithholdBaseAmount_BR = enumerator.currentValue();
                }

                selectedTaxWithholdTrans = new RecordSortedList(tableNum(TaxWithholdTrans));
                selectedTaxWithholdTrans.sortOrder(fieldNum(TaxWithholdTrans, RecId));
                // </GBR>

                this.initTaxWithholdTrans(taxWithholdTrans,
                                          _vendTrans,
                                          _specTrans,
                                          _invoiceAmountSettle,
                                          ledgerJournalTrans.TaxWithholdGroup);
                taxWithholdTrans.insert();
                this.findTmpTaxWithhold(taxWithholdTrans); // creates a new TmpTaxWithhold in TmpTaxWithholdList
                taxWithholdTrans.TaxWithholdCode = taxWithholdGroupData.TaxWithholdCode;
                taxWithholdTrans = this.initFromTaxWithholdCode(taxWithholdTrans, _settleExchRate);
                taxWithholdTrans.update();
                // <GBR>
                if (BrazilParameters::isEnabled() &&
                    !taxWithholdTrans.InvoiceTaxWithholdAmount)
                {
                    printMessageHeader = false;
                }
                // </GBR>
                if (printMessageHeader)
                {
                    this.printTaxWithholdHeaderInfo(printMessageHeader, taxWithholdTrans.VendAccount);
                }

                tmpTaxWithhold = this.findTmpTaxWithhold(taxWithholdTrans);
                // <GBR>
                if (taxWithholdTrans.InvoiceTaxWithholdAmount && !BrazilParameters::isEnabled())
                {
                    // </GBR>
                    info (strFmt("@SYS81769",taxWithholdTrans.Invoice,
                                       taxWithholdTrans.InvoiceCurrency,
                                       - _invoiceAmountSettle,
                                       tmpTaxWithhold.TaxWithholdCode,
                                       taxWithholdTrans.InvoiceTaxWithholdAmount));
                    //  <GBR>
                }

                taxWithholdTotalAmount += -taxWithholdTrans.InvoiceTaxWithholdAmount;
                // </GBR>

                printMessageHeader = false;

                taxLines++;
            }

            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                // if the withholding tax amount is higher than the payment amount, the withholding tax amount should be limited up to payment amount.
                if (taxWithholdTotalAmount && abs(taxWithholdTotalAmount) > abs(_invoiceAmountSettle))
                {
                    this.adjustWhtAmountPaymLimit_BR(_specTrans, taxWithholdTotalAmount, _invoiceAmountSettle);
                }

                this.printWhtTransAmount_BR(_specTrans);
            }
            // </GBR>
        }
        catch (Exception::Error)
        {
            stopWatch.Stop();

            TaxWithHoldInstrumentationTelemetry::logGWHTTelemetry(
                GlobalizationConstants::FeatureReferenceTAX00037,
                funcName(),
                TaxWithHoldInstrumentationTelemetry::SettleTransactions,
                this.parentTypeForGHWTTelemetry(),
                false,
                0,
                0);

            throw Exception::Error;
        }
        finally
        {
            stopWatch.Stop();

            TaxWithHoldInstrumentationTelemetry::logGWHTTelemetry(
                GlobalizationConstants::FeatureReferenceTAX00037,
                funcName(),
                TaxWithHoldInstrumentationTelemetry::SettleTransactions,
                this.parentTypeForGHWTTelemetry(),
                true,
                taxLines,
                stopWatch.ElapsedMilliseconds);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findVendInvoiceJourFromVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find <c>VendInvoiceJour</c> by specific information from <c>VendTrans</c>.
    /// Add logic to handle the scenario with Invoice Register, that the voucher and transaction date can be modified.
    /// </summary>
    /// <param name = "_invoiceId">Specific InvoiceId.</param>
    /// <param name = "_transDate">Specific TransDate.</param>
    /// <param name = "_invoiceAccount">Specific VendInvoiceAccount.</param>
    /// <param name = "_voucher">Specific Voucher.</param>
    /// <returns><c>VendInvoiceJour</c> record found.</returns>
    private VendInvoiceJour findVendInvoiceJourFromVendTrans(InvoiceId _invoiceId, TransDate _transDate, VendInvoiceAccount _invoiceAccount, Voucher _voucher)
    {
        VendInvoiceJour vendInvoiceJour = VendInvoiceJour::findFromVendTransVoucher(_invoiceId, _voucher, _transDate, _invoiceAccount, false);

        if (!vendInvoiceJour)
        {
            LedgerJournalVoucherChanged ledgerJournalVoucherChanged;

            select firstonly ledgerJournalVoucherChanged
                where ledgerJournalVoucherChanged.FromDate == _transDate
                    && ledgerJournalVoucherChanged.FromVoucher == _voucher;

            if (ledgerJournalVoucherChanged)
            {
                vendInvoiceJour = VendInvoiceJour::findFromVendTransVoucher(_invoiceId, ledgerJournalVoucherChanged.ToVoucher, ledgerJournalVoucherChanged.ToDate, _invoiceAccount, false);
            }
        }
                
        return vendInvoiceJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxWithholdTrans_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the withholding taxes based on each invoice and tax withholding group and tax
    /// withholding item group that is specified on each invoice line.
    /// </summary>
    /// <param name="_specTrans">
    ///  A <c>SpecTrans</c> table buffer that references the payment record for which the calculation will
    ///  be done.
    /// </param>
    /// <param name="_settleExchRate">
    ///  The exchange rate to use during calculation.
    /// </param>
    /// <param name="_printMessageHeader">
    ///  A Boolean value that specifies whether the vendor or customer name has to be printed on the
    ///  withholding dialog box.
    /// </param>
    /// <remarks>
    ///  This withholding calculation checks whether the amount is a based amount.
    ///  This method uses caching. If adding a new call to this method please be sure to clear the cache
    ///  after the call.  See the method <c>clearCache</c> on this class.
    /// </remarks>
    public void createTaxWithholdTrans_TH(SpecTrans               _specTrans,
                                       CrossExchRate           _settleExchRate,
                                       boolean                 _printMessageHeader = true)
    {
        boolean                 printMessageHeader = _printMessageHeader;

        AmountCur               adjustedAllInvoicesAmountSettleTotal;
        AmountCur               currentInvoiceAmountSettle;

        boolean                 isCorrection = false;
        boolean                 isAllInvoiceAmountSettleTotalCalculated = false;

        TaxWithholdBase         taxWithholdMinAmount;
        VendTrans               vendTrans;
        SpecTrans               specTransLoc;
        TaxWithholdTrans		taxWithholdTrans;

        VendInvoiceJour         vendInvoiceJour;
        QueryRun                queryRun = new QueryRun(queryStr(TaxWithholdVendQuery_TH));

        overrideWithholding     = false;
        taxWithholdMinAmount = abs(LedgerParameters::find().TaxWithholdMinInvoice_TH);

        // Loop through all the settlement records for the given payment record.
        ttsbegin;

        queryRun.query().dataSourceTable(tableNum(SpecTrans)).addRange(fieldNum(SpecTrans, SpecRecId)).value(queryValue(_specTrans.SpecRecId));
        queryRun.query().dataSourceTable(tableNum(SpecTrans)).addRange(fieldNum(SpecTrans, SpecCompany)).value(queryValue(_specTrans.SpecCompany));
        queryRun.query().dataSourceTable(tableNum(SpecTrans)).addRange(fieldNum(SpecTrans, SpecTableId)).value(queryValue(_specTrans.SpecTableId));

        queryRun.query().dataSourceTable(tableNum(TaxWithholdTrans)).enabled(false);
        queryRun.query().dataSourceTable(tableNum(VendInvoiceJour)).enabled(false);

        while (queryRun.next())
        {
            specTransLoc         = queryRun.get(tableNum(SpecTrans));

            select firstOnly RecId from taxWithholdTrans
                where taxWithholdTrans.dataAreaId == specTransLoc.RefCompany
                   && taxWithholdTrans.SpecTransId == specTransLoc.RecId;

            if (taxWithholdTrans)
            {
                continue;
            }

            vendTrans = queryRun.get(tableNum(VendTrans));

            if (this.shouldSkipForCreatingWithholdingTax(vendTrans))
            {
                continue;
            }

            vendInvoiceJour = this.findVendInvoiceJourFromVendTrans(vendTrans.Invoice, 
                                                                    vendTrans.TransDate, 
                                                                    vendTrans.AccountNum, 
                                                                    vendTrans.Voucher);

            if (!vendInvoiceJour)
            {
                continue;
            }

            // Determine the total amount of all the invoice lines that will be used to dermine WHT tax.
            currentInvoiceAmountSettle = this.totalInvoiceAmountSettled_TH(specTransLoc
                                                                            , vendTrans
                                                                            , vendInvoiceJour
                                                                            );

            // If total base amount is different that the one specified on the settlement record,
            // additional calculation will be done WHT taxes.
            isCorrection = (-currentInvoiceAmountSettle != specTransLoc.Balance01);

            // Make sure that the base amount is higher that the minimum amount specified on GL Parameter form.
            if (abs(currentInvoiceAmountSettle) >= taxWithholdMinAmount)
            {
                this.createItemTaxWithholdTrans_TH(
                    specTransLoc,
                    vendTrans,
                    currentInvoiceAmountSettle,
                    _settleExchRate,
                    isCorrection,
                    _printMessageHeader);
            }
            else
            {
                // If current invoice does not meet the minium amount for the WHT,
                // verify that sum of all the invoices base amount is higher then the min withholding amount.

                // Determine the total base amount for all the invoices marked for settlement.
                if (!isAllInvoiceAmountSettleTotalCalculated)
                {
                    adjustedAllInvoicesAmountSettleTotal = this.totalAllInvoicesAmountSettled_TH(specTransLoc);
                    isAllInvoiceAmountSettleTotalCalculated = true;
                }

                if (abs(adjustedAllInvoicesAmountSettleTotal) >= taxWithholdMinAmount)
                {
                    this.createItemTaxWithholdTrans_TH(
                        specTransLoc,
                        vendTrans,
                        currentInvoiceAmountSettle,
                        _settleExchRate,
                        isCorrection,
                        _printMessageHeader);
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTmpTaxWithhold</Name>
				<Source><![CDATA[
    private TmpTaxWithhold createTmpTaxWithhold(TaxWithholdTrans  _taxWithholdTrans)
    {
        TmpTaxWithhold  tmpTaxWithhold;

        tmpTaxWithhold.TaxWithholdTransId = _taxWithholdTrans.RecId;
        tmpTaxWithhold = this.fillTmpTaxWithhold(tmpTaxWithhold,  _taxWithholdTrans);
        tmpTaxWithholdList.ins(tmpTaxWithhold);

        return  tmpTaxWithhold;
    }

]]></Source>
			</Method>
			<Method>
				<Name>crossCompanyList_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return company list to be used in crosscompany selects
    /// </summary>
    /// <returns>
    /// Return shared companies if cross company base accumulation is used, otherwise, ledgerJournalTrans.company
    /// </returns>

    protected container crossCompanyList_BR()
    {
        boolean taxWithholdCalculateCrossCompany;//TaxWithholdCalculateCrossCompany_BR taxWithholdCalculateCrossCompany;
        container           dataAreaIdList;

        switch (ledgerJournalTrans.AccountType)
        {
            case LedgerJournalACType::Cust :
                taxWithholdCalculateCrossCompany = SalesParameters::find().TaxWithholdCalculateCrossCompany_BR ? NoYes::Yes : NoYes::No;
                break;

            case LedgerJournalACType::Vend :
                taxWithholdCalculateCrossCompany = PurchParameters::find().TaxWithholdCalculateCrossCompany_BR ? NoYes::Yes : NoYes::No;
                break;

            default :
        }

        if (taxWithholdCalculateCrossCompany)
        {
            dataAreaIdList = CustVendOpenTransManager::findSharedServiceCompanies(ledgerJournalTrans.Company);
        }
        else
        {
            // TaxWithhold only runs in RefCompany
            dataAreaIdList = [curext()];
        }
        return dataAreaIdList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existCalculatedWithholdTax_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether exist the tax withhold transaction with given parameters.
    /// </summary>
    /// <param name = "_taxCode">The tax withhold code.</param>
    /// <param name = "_ledger">The buffer of <c>LedgerJournalTrans</c>.</param>
    /// <param name = "periodStart">The period start date.</param>
    /// <param name = "periodEnd">The period end date.</param>
    /// <returns>true if exist record; otherwise false.</returns>
    protected boolean existCalculatedWithholdTax_BR(TaxWithholdCode _taxCode, LedgerJournalTrans _ledger, date periodStart, date periodEnd)
    {
        TaxWithholdTrans    taxWithholdTrans;
        container           dataAreaIdList = this.crossCompanyList_BR();

        select crosscompany : dataAreaIdList count(RecId)
            from    taxWithholdTrans
            where   taxWithholdTrans.LedgerJourTransRecId_BR    != _ledger.RecId
                &&  taxWithholdTrans.TransDate                  >= periodStart
                &&  taxWithholdTrans.TransDate                  <= periodEnd
                &&  taxWithholdTrans.PartyId_BR                 == this.partyId_BR()
                &&  taxWithholdTrans.TaxWithholdCode            == _taxCode
                &&  taxWithholdTrans.TaxWithholdAmount          != 0
                &&  taxWithholdTrans.CanBeReversed_BR           == NoYes::Yes;

        return taxWithholdTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillTmpTaxWithhold</Name>
				<Source><![CDATA[
    private TmpTaxWithhold fillTmpTaxWithhold(TmpTaxWithhold    _tmpTaxWithhold,
                                              TaxWithholdTrans  _taxWithholdTrans)
    {
        TmpTaxWithhold    tmpTaxWithhold = _tmpTaxWithhold;
        TaxWithholdTable  taxWithholdTable;
        TaxWithholdData   taxWithholdData;
        TaxWithholdLimit  taxWithholdLimit;
        TaxWithholdAmount baseAmount;
        SpecTrans         specTrans;
        // <GBR>
        boolean           brazilIsEnabled = BrazilParameters::isEnabled();
        // </GBR>

        Debug::assert(_taxWithholdTrans.company() == curext());

        if (_taxWithholdTrans.TaxWithholdCode)
        {
            // ensure record level security is used
            taxWithholdTable.recordLevelSecurity(true);
            taxWithholdData.recordLevelSecurity(true);
            taxWithholdLimit.recordLevelSecurity(true);

            taxWithholdTable = TaxWithholdTable::find(_taxWithholdTrans.TaxWithholdCode);

            // <GBR>
            if (brazilIsEnabled && !custVendTransAmountCur)
            {
                custVendTransAmountCur = _taxWithholdTrans.invoiceTotalAmount_BR();
            }
            // </GBR>

            // calculation of the base amount to find the correct TaxWithholdData record
            if (taxWithholdTable.TaxWithholdBaseType == TaxWithholdBaseType::PctPerGross)
            {
                // <GBR>
                if (brazilIsEnabled)
                {
                    baseAmount = (_taxWithholdTrans.InvoiceAmount *
                                  _taxWithholdTrans.IntersectionWithholdBaseAmount_BR / custVendTransAmountCur) ;
                }
                else
                {
                    // </GBR>
                    baseAmount = _taxWithholdTrans.InvoiceAmount;
                    // <GBR>
                }
                // </GBR>
            }
            // <GBR>
            else if (brazilIsEnabled
                && taxWithholdTable.TaxWithholdBaseType == TaxWithholdBaseType::PctGrsAmtMonth)
            {
                baseAmount = this.getBaseAmount(_taxWithholdTrans);
            }
            // </GBR>
            else
            {
                baseAmount = _taxWithholdTrans.invoiceAmountExclTax();
            }

            // This doesn't need to be cross company because we are already in shared service boundary
            // and this is checked by the assert at beginning of method.
            select firstonly RecId from specTrans
                where specTrans.RecId == _taxWithholdTrans.SpecTransId;

            // Calculate the baseAmount in Invoice company Mst currency
            baseAmount  = CurrencyExchangeHelper::mstAmount(baseAmount, _taxWithholdTrans.InvoiceCurrency, _taxWithholdTrans.TransDate);

            // <GBR>
            if (brazilIsEnabled)
            {
                this.getAccumulatedPaymentAmount_BR(taxWithholdTable);
                accumPayment  = CurrencyExchangeHelper::mstAmount(accumPayment, _taxWithholdTrans.InvoiceCurrency, _taxWithholdTrans.TransDate);

                // base amount already is service amount
                baseAmount += accumPayment + accumBaseAmountFromPreviousPayment;
                if (this.checkTaxLimitBaseAmount_BR(_taxWithholdTrans.TaxWithholdCode))
                {
                    taxWithholdData = TaxWithholdData::find(_taxWithholdTrans.TaxWithholdCode,
                                                            _taxWithholdTrans.TransDate,
                                                            baseAmount);
                }
                else
                {
                    taxWithholdData = TaxWithholdData::findWithoutCheckLimit_BR(_taxWithholdTrans.TaxWithholdCode,
                                                                                _taxWithholdTrans.TransDate);
                }
            }
            else
            {
                // </GBR>
                taxWithholdData = TaxWithholdData::find(_taxWithholdTrans.TaxWithholdCode,
                                                    _taxWithholdTrans.TransDate,
                                                    baseAmount);
                // <GBR>
            }

            if (brazilIsEnabled)
            {
                taxWithholdData1.TaxWithholdLimitMax = taxWithholdData.TaxWithholdLimitMax;
                taxWithholdData1.TaxWithholdLimitMin = taxWithholdData.TaxWithholdLimitMin;

                if (this.checkTaxLimitBaseAmount_BR(_taxWithholdTrans.TaxWithholdCode))
                {
                    if (taxWithholdData.TaxWithholdLimitMin)
                    {
                        if (taxWithholdData.TaxWithholdLimitMin > abs(baseAmount))
                        {
                            taxWithholdData.doClear();
                        }
                    }
                }
            }
            // </GBR>

            taxWithholdLimit = TaxWithholdLimit::find(_taxWithholdTrans.TaxWithholdCode,
                                                      _taxWithholdTrans.TransDate);

            tmpTaxWithhold.TaxWithholdCode         = _taxWithholdTrans.TaxWithholdCode;
            if (taxWithholdTable.TaxWithholdBaseType == TaxWithholdBaseType::PctPerGross)
            {
                tmpTaxWithhold.WithholdOriginGross = NoYes::Yes;
            }
            else
            {
                tmpTaxWithhold.WithholdOriginGross = NoYes::No;
            }
            tmpTaxWithhold.TaxWithholdValue        = taxWithholdData.TaxWithholdValue;
            tmpTaxWithhold.TaxWithholdRoundOff     = taxWithholdTable.TaxWithholdRoundOff;
            tmpTaxWithhold.TaxWithholdRoundOffType = taxWithholdTable.TaxWithholdRoundOffType;
            tmpTaxWithhold.TaxWithholdAmountMin    = taxWithholdLimit.TaxWithholdAmountMin;
            tmpTaxWithhold.TaxWithholdAmountMax    = taxWithholdLimit.TaxWithholdAmountMax;
            tmpTaxWithhold.TaxWithholdExclude      = taxWithholdData.TaxWithholdExclude;
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            tmpTaxWithhold.TaxWithholdBase  =  CurrencyExchangeHelper::curAmount(baseAmount, _taxWithholdTrans.InvoiceCurrency, _taxWithholdTrans.TransDate);
        }
        // </GBR>

        return  tmpTaxWithhold;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustVendOpenTrans_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the open transaction fro vendor or customer.
    /// </summary>
    /// <param name = "_specTrans">The buffer of <c>SpecTrans</c>.</param>
    /// <returns>The buffer of <c>CustVendTransOpen</c>.</returns>
    protected CustVendTransOpen findCustVendOpenTrans_BR(SpecTrans _specTrans)
    {
        return _specTrans.vendTransOpen();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findMarkupValue_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method will determine the miscellaneous amount that is associated with the invoice that is
    ///    used during the WHT calculation.
    /// </summary>
    /// <param name="_tableId">
    ///    The ID of the vendor- or customer-based invoice.
    /// </param>
    /// <param name="_recId">
    ///    An invoice record ID.
    /// </param>
    /// <returns>
    ///    The miscellaneous amount that is associated with the invoice.
    /// </returns>
    protected MarkupAmount findMarkupValue_TH(
        TableId _tableId,
        RecId _recId)
    {
        MarkupAmount totalValue;

        if (_tableId && _recId)
        {
            MarkupTrans  markupTrans;
            MarkupTable markupTable;

            while select CalculatedAmount, TableId, RecId, TaxGroup, TaxItemGroup from markupTrans
                where markupTrans.TransTableId == _tableId &&
                        markupTrans.TransRecId   == _recId
                exists join markupTable
                    where markupTable.ModuleType == markupTrans.ModuleType
                        && markupTable.MarkupCode == markupTrans.MarkupCode
                        && (((_tableId == tableNum(VendInvoiceJour) || _tableId ==  tableNum(VendInvoiceTrans))
                            && markupTable.VendType == MarkupType::CustVend)
                            ||
                            ((_tableId == tableNum(CustInvoiceJour) || _tableId ==  tableNum(CustInvoiceTrans))
                            && markupTable.CustType == MarkupType::CustVend))
            {
                totalValue += markupTrans.CalculatedAmount;

                if (enableWHTOnCharges)
                {
                    totalValue += abs(this.getTaxTransForGWHTaxTMarkupTrans(markupTrans).SourceTaxAmountCur);
                }
            }
        }

        return abs(totalValue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTmpTaxWithhold</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds record for <c>TmpTaxWithhold</c>.
    /// </summary>
    /// <param name = "_taxWithholdTrans">The buffer of <c>TaxWithholdTrans</c>.</param>
    /// <returns>The buffer of <c>TmpTaxWithhold</c>.</returns>
    public TmpTaxWithhold findTmpTaxWithhold(TaxWithholdTrans  _taxWithholdTrans)
    {
        TmpTaxWithhold  tmpTaxWithhold;

        tmpTaxWithhold.TaxWithholdTransId = _taxWithholdTrans.RecId;
        if (! tmpTaxWithholdList.find(tmpTaxWithhold))
        {
            tmpTaxWithhold = this.createTmpTaxWithhold(_taxWithholdTrans);
        }
        return  tmpTaxWithhold;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateTaxWithholdRecord</Name>
				<Source><![CDATA[
    [SysObsolete('This method is obsoleted. Use generateTaxWithholdRecordWithMarkupTrans() instead', false, 03\08\2021)]
    protected void generateTaxWithholdRecord(
        SpecTrans _specTrans,
        CustVendTrans _custVendTrans,
        CustVendInvoiceTrans _custVendInvoiceTrans,
        AmountCur _invoiceAmountSettleTotal,
        RefRecId _taxWithholdItemGroupHeading_TH,
        CrossExchRate _settleExchRate,
        boolean _isCorrection,
        boolean _inclTax)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateTaxWithholdRecordWithMarkupTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method will generate withholding tax transaction when doing settlement based on specified transaction.
    /// </summary>
    /// <param name="_specTrans">
    ///    A <c>SpecTrans</c> table buffer.
    /// </param>
    /// <param name="_custVendTrans">
    ///    A <c>CustVendTrans</c> table buffer.
    /// </param>
    /// <param name="_custVendInvoiceTrans">
    ///    A <c>CustVendInvoiceTrans</c> table buffer.
    /// </param>
    /// <param name="_invoiceAmountSettleTotal">
    ///    The total settlement amount.
    /// </param>
    /// <param name="_taxWithholdItemGroupHeading_TH">
    ///    The reference record Id for <c>TaxWithholdItemGroupHeading_TH</c> table.
    /// </param>
    /// <param name="_settleExchRate">
    ///    The exchange rate when doing settlement.
    /// </param>
    /// <param name="_isCorrection">
    ///    Indiciates whether it is a correction transaction.
    /// </param>
    /// <param name="_inclTax">
    ///    Indicates whether including tax.
    /// </param>
    /// <param name="_createGWHTransForMarkupTrans">
    ///    Indicates that we are creating withholding trans for the charge codes (MarkupTrans).
    ///    True when GlobalWithholding tax logic is on and EnableChargeCodes = Yes and we have GWHT charge code.
    /// </param>
    ///  <param name="_markupTransGWHTaxGroup">
    ///    Global withholding tax group - from the charge code (MarkupTrans). 
    ///    Not empty when _createGWHTransForMarkupTrans = true.
    /// </param>
    /// <param name="_markupTransGWHTaxAmount">
    ///    Withholding trans line tax amount.
    ///    Not zero when _createGWHTransForMarkupTrans = true.
    /// </param>
    /// <param name="_markupTransGWHTAmountInclTax">
    ///    Withholding trans line amount. Includes taxes.
    ///    Not zero when _createGWHTransForMarkupTrans = true.
    /// </param>
    /// <param name="_markupTransGWHTaxValue">
    ///    Withholding trans tax value.
    ///    Not zero when _createGWHTransForMarkupTrans = true.
    /// </param>
    protected void generateTaxWithholdRecordWithMarkupTrans(
        SpecTrans _specTrans,
        CustVendTrans _custVendTrans,
        CustVendInvoiceTrans _custVendInvoiceTrans,
        AmountCur _invoiceAmountSettleTotal,
        RefRecId _taxWithholdItemGroupHeading_TH,
        CrossExchRate _settleExchRate,
        boolean _isCorrection,
        boolean _inclTax,
        boolean _createGWHTransForMarkupTrans = false,
        TaxWithholdGroup _markupTransGWHTaxGroup = '',
        AmountCur _markupTransGWHTaxAmount = 0,
        AmountCur _markupTransGWHTAmountInclTax = 0,
        TaxValue _markupTransGWHTaxValue = 0)
    {
        TaxWithholdOnItem_TH taxWithholdOnItem_TH;
        TaxWithholdGroupData taxWithholdGroupData;
        TaxWithholdTrans taxWithholdTrans;
        AmountCur tmpinvoiceAmountSettle = 0;
        AmountCur paymentAmtPerLine;
        AmountCur invoiceAmountLine;
        TaxWithholdGroup taxWithholdGroup;
        // <GTH>
        LedgerJournalTransExtensionTH    ledgerJournalTransExtensionTH;
        // </GTH>

        //GWHT telemetry
        TradeInstrumentationStopwatch stopWatch = TradeInstrumentationStopwatch::newStopwatch();
        int64 createdWithholdingTaxTransCount; 

        this.generateTaxWithholdRecord(
            _specTrans,
            _custVendTrans,
            _custVendInvoiceTrans,
            _invoiceAmountSettleTotal,
            _taxWithholdItemGroupHeading_TH,
            _settleExchRate,
            _isCorrection,
            _inclTax);

        // Retrieve the Tax withholding group based on the invoice info or from charge codes
        taxWithholdGroup = _createGWHTransForMarkupTrans ? _markupTransGWHTaxGroup : this.getTaxWithholdGroup(_custVendTrans);

        while select TaxWithholdCode
            from taxWithholdOnItem_TH
            where taxWithholdOnItem_TH.TaxWithholdItemGroupHeading_TH == _taxWithholdItemGroupHeading_TH
                exists join taxWithholdGroupData
                    where taxWithholdGroupData.TaxWithholdGroup == taxWithholdGroup
                       && taxWithholdOnItem_TH.TaxWithholdCode == taxWithholdGroupData.TaxWithholdCode
        {
            taxWithholdTrans.clear();

            if (_createGWHTransForMarkupTrans)
            {
                invoiceAmountLine = _markupTransGWHTAmountInclTax;
            }
            else
            {
                skipMarkupTransOnLines = enableWHTOnCharges;
                invoiceAmountLine = this.totalInvoiceLineAmountSettled_TH(_custVendInvoiceTrans, _inclTax);
                skipMarkupTransOnLines = false;
            }

            if (_inclTax)
            {
                this.getInvoiceAmountInclDisc_TH(_specTrans, _custVendTrans, _invoiceAmountSettleTotal);
            }

            paymentAmtPerLine = this.calcPaymentAmtPerLineWithMarkupTrans_TH(_specTrans,
                _custVendInvoiceTrans.InventTransId,
                _isCorrection,
                invoiceAmountLine,
                _invoiceAmountSettleTotal,
                _inclTax,
                _custVendInvoiceTrans.SourceDocumentLine,
                _custVendInvoiceTrans.RecId,
                _createGWHTransForMarkupTrans,
                _markupTransGWHTAmountInclTax - _markupTransGWHTaxAmount,
                _markupTransGWHTaxValue);

            this.initTaxWithholdTransWithMarkupTrans_TH(taxWithholdTrans,
                _custVendTrans,
                _specTrans,
                paymentAmtPerLine,
                _custVendInvoiceTrans.InventTransId,
                _custVendTrans.Voucher,
                _inclTax,
                taxWithholdGroup,
                _specTrans.Balance01,
                _custVendInvoiceTrans.SourceDocumentLine,
                _custVendInvoiceTrans.RecId,
                _createGWHTransForMarkupTrans,
                _markupTransGWHTaxAmount);

            taxWithholdTrans.TaxWithholdCode         = taxWithholdOnItem_TH.TaxWithholdCode;
            taxWithholdTrans.TaxWithholdItemGroupHeading_TH = _taxWithholdItemGroupHeading_TH;

            if (isEnabledWHTCurrencyExchRateFeature)
            {
                taxWithholdTrans.initTaxWithholdExchRateDate(_custVendTrans, ledgerJournalTrans);
            }

            taxWithholdTrans = this.initFromTaxWithholdCode(taxWithholdTrans, _settleExchRate);
            taxWithholdTrans.TaxWithholdPeriodHead_TH = this.getTaxWithholdPeriodHead_TH(taxWithholdTrans.TaxWithholdCode);

            if (_custVendTrans.TableId == tableNum(VendTrans))
            {
                taxWithholdTrans.VendorType_TH = VendTable::find(_custVendTrans.AccountNum).TaxWithholdVendorType_TH;
            }
            else if (_custVendTrans.TableId == tableNum(CustTrans))
            {
                taxWithholdTrans.VendorType_TH = TaxWithholdVendorType_TH::Blank;
            }

            // <GTH>
            if (isTaxWithholdEnabledTH)
            {
                // Allocate the certification number
                if (_custVendTrans.TableId == tableNum(VendTrans))
                {
                    ttsbegin;
                    ledgerJournalTransExtensionTH = LedgerJournalTransExtensionTH::findByLedgerJournalTrans(ledgerJournalTrans.RecId, true);

                    if (ledgerJournalTransExtensionTH
                        && ledgerJournalTransExtensionTH.RecId
                        && ledgerJournalTransExtensionTH.CertificateNumber == '')
                    {
                        if (DirPartyTable::findRec(VendTable::find(ledgerJournalTrans.parmAccount()).Party).baseType() == DirPartyBaseType::Person)
                        {
                            ledgerJournalTransExtensionTH.CertificateNumber = NumberSeq::newGetNum(VendParameters::numRefTaxWithholdPND3Number()).num();
                        }
                        else
                        {
                            ledgerJournalTransExtensionTH.CertificateNumber = NumberSeq::newGetNum(VendParameters::numRefTaxWithholdPND53Number()).num();
                        }
                        ledgerJournalTransExtensionTH.CertificateDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                        ledgerJournalTransExtensionTH.update();
                    }
                    ttscommit;
                }
            }
            // </GTH>
            taxWithholdTrans.insert();

            createdWithholdingTaxTransCount++;

            info (strFmt("@SYS81769", taxWithholdTrans.Invoice,
                taxWithholdTrans.InvoiceCurrency,
                taxWithholdTrans.InvoiceBaseAmount,
                taxWithholdTrans.TaxWithholdCode,
                taxWithholdTrans.InvoiceTaxWithholdAmount));
        }

        TaxWithHoldInstrumentationTelemetry::logGWHTTelemetry(
            _createGWHTransForMarkupTrans ? GlobalizationConstants::FeatureReferenceTAX00043 
                                          : GlobalizationConstants::FeatureReferenceTAX00037,
            funcName(),
            TaxWithHoldInstrumentationTelemetry::SettleTransactions,
            this.parentTypeForGHWTTelemetry(),
            true,
            createdWithholdingTaxTransCount,
            stopwatch.elapsedMilliseconds());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccumulatedPaymentAmount_BR</Name>
				<Source><![CDATA[
    protected void getAccumulatedPaymentAmount_BR(TaxWithholdTable _taxWithholdTable)
    {
        LedgerJournalTrans              localLedgerJournalTrans;
        LedgerJournalTransPayment_BR    localLedgerJournalTransPayment;
        TaxWithholdTrans                taxWithholdTrans;
        QueryRun                        qr;

        date                        periodStart;
        date                        periodEnd;

        container                   dataAreaIdList = this.crossCompanyList_BR();
        DataAreaId                  taxWithholdCompany = PurchParameters::find().TaxWithholdCompany_BR;

        accumPayment    = 0;
        sumAccumpayment = 0;
        accumBaseAmountFromPreviousPayment = 0;

        if (_taxWithholdTable.TaxWithholdBaseType != TaxWithholdBaseType::PctGrsAmtMonth)
        {
            return;
        }

        periodStart = dateStartMth(ledgerJournalTrans.TransDate);
        periodEnd   = dateEndMth(periodStart);

        // accumulated base amount on closed transactions
        select crosscompany : dataAreaIdList sum(InvoiceBaseAmount)
            from taxWithholdTrans
            exists join localLedgerJournalTrans
            where   localLedgerJournalTrans.RecId                       == taxWithholdTrans.LedgerJourTransRecId_BR
                &&  taxWithholdTrans.VendAccount                        == ledgerJournalTrans.parmAccount()
                &&  taxWithholdTrans.TaxWithholdCode                    == _taxWithholdTable.TaxWithholdCode
                &&  taxWithholdTrans.TransDate                          >= periodStart
                &&  taxWithholdTrans.TransDate                          <= periodEnd
                &&  taxWithholdTrans.TaxWithholdIsSelected_BR           == NoYes::Yes
                &&  taxWithholdTrans.CanBeReversed_BR                   == NoYes::Yes
            exists join localLedgerJournalTransPayment
                where localLedgerJournalTransPayment.RefRecId == localLedgerJournalTrans.RecId
                    && localLedgerJournalTransPayment.TaxWithholdEditStatus_BR    == LedgerTransTaxWithholdEditStatus_BR::Closed;

        sumAccumpayment = taxWithholdTrans.InvoiceBaseAmount;

        qr = this.accumulatedPaymentQueryRun_BR(_taxWithholdTable, periodStart, periodEnd);
        qr.allowCrossCompany(PurchParameters::find().TaxWithholdCalculateCrossCompany_BR);

        while (qr.next())
        {
            taxWithholdTrans = qr.get(tableNum(TaxWithholdTrans));

            changecompany(taxWithholdTrans.DataAreaId)
            {
                // do not sum payment if withholding company is different
                if (qr.allowCrossCompany()
                    && PurchParameters::find().TaxWithholdCompany_BR != taxWithholdCompany)
                {
                    continue;
                }
            }

            accumPayment +=   taxWithholdTrans.TaxWithholdAccumulatedBaseAmount ? 0 : taxWithholdTrans.InvoiceWithholdBaseAmount
                            - taxWithholdTrans.TaxNotTaxableByTreaty
                            - taxWithholdTrans.TaxNotTaxableExpenses;

            accumBaseAmountFromPreviousPayment += taxWithholdTrans.TaxWithholdAccumulatedBaseAmount;

            selectedTaxWithholdTrans.ins(taxWithholdTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashdisc_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the cash discount amount for a vendor transaction.
    /// </summary>
    /// <param name="_specTrans">
    /// A <c>SpecTrans</c> table buffer that references the payment record for which the calculation will
    ///    be done.
    /// </param>
    /// <returns>
    /// A cash discount amount for a vendor transaction.
    /// </returns>
    protected AmountCur getCashdisc_TH(SpecTrans   _specTrans)
    {
        VendTransOpen      vendTransOpen;
        VendTransCashDisc  vendTransCashDisc;

        vendTransOpen = VendTransOpen::find(_specTrans.RefRecId);
        vendTransCashDisc = VendTransCashDisc::findCashDisc(tableNum(VendTransOpen),
                                                            vendTransOpen.RecId,
                                                            ledgerJournalTrans.TransDate,
                                                            VendPaymModeTable::discGraceDays(ledgerJournalTrans.PaymMode));

        return vendTransCashDisc.CashDiscAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceAmountInclDisc_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Final Payment when the WitholdBase amount is specified.
    /// </summary>
    /// <param name="_specTrans">
    /// A <c>SpecTrans</c> table buffer that references the payment record for which the calculation will
    ///    be done.
    /// </param>
    /// <param name="_custVendTrans">
    /// A <c>CustVendTrans</c> table buffer that references the payment record for which the calculation will
    ///    be done.
    /// </param>
    /// <param name="_invoiceAmountSettle">
    /// A invoice amount which is used in settlement.
    /// </param>
    /// <returns>
    /// The final payment amount when the WitholdBase amount is specified.
    /// </returns>
    protected AmountCur getInvoiceAmountInclDisc_TH(SpecTrans _specTrans, CustVendTrans _custVendTrans, AmountCur _invoiceAmountSettle)
    {
        AmountCur   cashDiscAmt;
        AmountCur   finalPaymentAmount;

        finalPayment = false;
        finalPaymentAmount = _custVendTrans.AmountCur - _custVendTrans.SettleAmountCur;
        cashDiscAmt = this.getCashdisc_TH(_specTrans);

        if ((_specTrans.Balance01 + cashDiscAmt) == finalPaymentAmount)
        {
            finalPayment = true;
            return - finalPaymentAmount;
        }

        return _invoiceAmountSettle;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceAmountSettle_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the invoice amount which is used in settlement.
    /// </summary>
    /// <param name="_specTrans">
    /// A <c>SpecTrans</c> table buffer that references the payment record for which the calculation will
    ///    be done.
    /// </param>
    /// <param name="_custVendTrans">
    /// A <c>CustVendTrans</c> table buffer that references the payment record for which the calculation will
    ///    be done.
    /// </param>
    /// <param name="_invoiceAmountSettle">
    /// A invoice amount which is used in settlement.
    /// </param>
    /// <returns>
    /// The invoice amount which is used in settlement.
    /// </returns>
    protected AmountCur getInvoiceAmountSettle_TH(SpecTrans _specTrans, CustVendTrans _custVendTrans, AmountCur _invoiceAmountSettle)
    {
        AmountCur   cashDiscAmt;
        AmountCur   finalPaymentAmount;
        AmountCur   invoiceAmountSettleLoc;

        finalPaymentAmount = _custVendTrans.AmountCur - _custVendTrans.SettleAmountCur;

        cashDiscAmt = this.getCashdisc_TH(_specTrans);

        if (cashDiscAmt)
        {
            if ( (_specTrans.Balance01 + cashDiscAmt) == finalPaymentAmount && overrideWithholding)
            {
                invoiceAmountSettleLoc = _invoiceAmountSettle + cashDiscAmt;
                return invoiceAmountSettleLoc;
            }
        }

        return _invoiceAmountSettle;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSumOf</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the sum of selected taxes for accumulated base in other payment journals that has the tax withhold line edit edit status closed
    /// </summary>
    /// <param name="_dataAreaIdList">
    ///     List of dataArea to be seelected
    /// </param>
    /// <param name="_taxWithholdCode">
    ///     The tax withholding code
    /// </param>
    /// <param name="_transDate">
    ///     The payment date
    /// </param>
    /// <returns>
    ///     The sum of selected taxes in other journals
    /// </returns>

    protected TaxWithholdBase getSumOf(container _dataAreaIdList, TaxWithholdCode _taxWithholdCode, TransDate _transDate)
    {
        LedgerJournalTrans              localLedgerJournalTrans;
        LedgerJournalTransPayment_BR    ledgerJournalTransPayment;
        TaxWithholdTrans        taxWithholdTrans;

        date                    periodStart;
        date                    periodEnd;

        periodStart = dateStartMth(_transDate);
        periodEnd   = dateEndMth(periodStart);

        // accumulated base amoun on closed/posted transactions
        select crosscompany : _dataAreaIdList sum(InvoiceBaseAmount)
            from taxWithholdTrans
            exists join localLedgerJournalTrans
            where   localLedgerJournalTrans.RecId                       == taxWithholdTrans.LedgerJourTransRecId_BR
                &&  taxWithholdTrans.VendAccount                        == ledgerJournalTrans.parmAccount()
                &&  taxWithholdTrans.TaxWithholdCode                    == _taxWithholdCode
                &&  taxWithholdTrans.TransDate                          >= periodStart
                &&  taxWithholdTrans.TransDate                          <= periodEnd
                &&  taxWithholdTrans.TaxWithholdIsSelected_BR           == NoYes::Yes
            exists join ledgerJournalTransPayment
            where ledgerJournalTransPayment.RefRecId == localLedgerJournalTrans.RecId
                && ledgerJournalTransPayment.TaxWithholdEditStatus_BR == LedgerTransTaxWithholdEditStatus_BR::Closed;

        return taxWithholdTrans.InvoiceBaseAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxWithholdGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method will get the withholding tax group for specified customer or vendor transaction.
    /// </summary>
    /// <param name="_custVendTrans">
    ///    A <c>CustVendTrans</c> table buffer.
    /// </param>
    /// <returns>
    ///    The withholding tax group.
    /// </returns>
    protected TaxWithholdGroup getTaxWithholdGroup(CustVendTrans _custVendTrans)
    {
        // <GTH>
        if (isTaxWithholdEnabledTH)
        {
            if (ledgerJournalTrans.TaxWithholdGroup)
            {
                return ledgerJournalTrans.TaxWithholdGroup;
            }
        }
        // </GTH>

        return VendTable::findByCompany(_custVendTrans.company(), _custVendTrans.AccountNum).TaxWithholdGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxWithholdPeriodHead_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method will retrieve the surrogate key of the <c>TaxWithholdPeriodHead_TH</c> table for a
    ///    specified <c>TaxWithholdCode</c> value.
    /// </summary>
    /// <param name="_taxWithholdCode">
    ///    The <c>TaxWithholdCode</c> to use to search.
    /// </param>
    /// <returns>
    ///    If the search was successful, the <c>RecId</c> value of the <c>TaxWithholdPeriodHead_TH</c> table;
    ///    otherwise, zero.
    /// </returns>
    protected TaxWithholdPeriodId_TH getTaxWithholdPeriodHead_TH(TaxWithholdCode _taxWithholdCode)
    {
        TaxWithholdPeriodId_TH returnValue;

        if (!_taxWithholdCode)
        {
            returnValue = TaxWithholdTable::find(_taxWithholdCode).TaxWithholdPeriodHead_TH;
        }
        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasTaxWithholdCalculated_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns whether exist the tax withhold transaction with the spec transaction id.
    /// </summary>
    /// <param name="_specId">
    /// A spec transaction recid.
    /// </param>
    /// <returns>
    /// Returns true if exist the tax withhold transaction with the spec transaction id.
    /// </returns>
    protected boolean hasTaxWithholdCalculated_TH(RefRecId _specId)
    {
        TaxWithholdTrans tmpTaxWithholdTrans;

        select count(RecId) from tmpTaxWithholdTrans
            where tmpTaxWithholdTrans.SpecTransId == _specId;

        return tmpTaxWithholdTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromTaxWithholdCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes opposite withholding tax transaction from specified withholding tax transaction.
    /// </summary>
    /// <param name="_taxWithholdTrans">
    ///    A <c>TaxWithholdTrans</c> table buffer.
    /// </param>
    /// <param name="_settleExchRate">
    ///    The exchange rate when doing settlement.
    /// </param>
    /// <returns>
    ///    Withholding tax transaction.
    /// </returns>
    public TaxWithholdTrans initFromTaxWithholdCode(
        TaxWithholdTrans  _taxWithholdTrans,
        CrossExchRate     _settleExchRate)
    {
        TaxWithholdTrans  taxWithholdTrans = _taxWithholdTrans;
        TmpTaxWithhold    tmpTaxWithhold;

        taxWithholdTrans.initFromTaxWithholdTable();

        tmpTaxWithhold = this.findTmpTaxWithhold(taxWithholdTrans);
        tmpTaxWithhold = this.fillTmpTaxWithhold(tmpTaxWithhold, taxWithholdTrans);
        tmpTaxWithholdList.ins(tmpTaxWithhold, true);

        taxWithholdTrans = this.calcWithholdAmounts(taxWithholdTrans, _settleExchRate, false, false);

        if (taxWithholdTrans.VendAccount)
        {
            taxWithholdTrans.VendorType_TH = VendTable::find(taxWithholdTrans.VendAccount).TaxWithholdVendorType_TH;
        }
        else if (taxWithholdTrans.CustAccount)
        {
            taxWithholdTrans.VendorType_TH            = TaxWithholdVendorType_TH::Blank;

            // <GTH>
            if (!isTaxWithholdEnabledTH 
                && !isEnableGlobalWHTFeatureAndParam
                && (!BrazilParameters::isEnabled() || !accumBaseAmountFromPreviousPayment))
            {
                // </GTH>
                taxWithholdTrans.TaxWithholdAmount        = - taxWithholdTrans.TaxWithholdAmount;
                taxWithholdTrans.TaxTaxWithholdAmount     = - taxWithholdTrans.TaxTaxWithholdAmount;
                taxWithholdTrans.InvoiceTaxWithholdAmount = - taxWithholdTrans.InvoiceTaxWithholdAmount;
                taxWithholdTrans.PaymTaxWithholdAmount    = - taxWithholdTrans.PaymTaxWithholdAmount;
                // <GTH>
            }
            // </GTH>
        }

        return  taxWithholdTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxWithholdTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes another withholding tax transaction from specified withholding tax transaction.
    /// </summary>
    /// <param name="_taxWithholdTrans">
    ///    A <c>TaxWithholdTrans</c> table buffer.
    /// </param>
    /// <param name="_custVendTrans">
    ///    A <c>CustVendTrans</c> table buffer.
    /// </param>
    /// <param name="_specTrans">
    ///    A <c>SpecTrans</c> table buffer.
    /// </param>
    /// <param name="_invoiceAmountSettle">
    ///    The invoice amount to be settled.
    /// </param>
    /// <param name="_taxWithholdGroup">
    ///    The given withholding tax group.
    /// </param>
    /// <returns>
    ///    Withholding tax transaction.
    /// </returns>
    public TaxWithholdTrans initTaxWithholdTrans(TaxWithholdTrans  _taxWithholdTrans,
                                                 CustVendTrans     _custVendTrans,
                                                 SpecTrans         _specTrans,
                                                 AmountCur         _invoiceAmountSettle,
                                                 TaxWithholdGroup  _taxWithholdGroup)
    {
        TaxWithholdTrans  taxWithholdTrans = _taxWithholdTrans;

        taxWithholdTrans.SpecTransId = _specTrans.RecId;

        taxWithholdTrans.TaxWithholdGroup = _taxWithholdGroup;

        taxWithholdTrans.initFromLedgerJournalTrans(ledgerJournalTrans);
        taxWithholdTrans.initFromCustVendTrans(_custVendTrans);

        if (isEnabledWHTCurrencyExchRateFeature)
        {
            taxWithholdTrans.initTaxWithholdExchRateDate(_custVendTrans, ledgerJournalTrans);
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            taxWithholdTrans.PartyId_BR = this.partyId_BR();

            invoiceamt = this.invoiceAmount_BR(_invoiceAmountSettle, _custVendTrans, _taxWithholdTrans.IntersectionWithholdBaseAmount_BR);

            accumPayment    = 0;
            sumAccumpayment = 0;
            accumBaseAmountFromPreviousPayment = 0;

            taxWithholdTrans.LedgerJourTransRecId_BR        = ledgerJournalTrans.RecId;
            if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
            {
                taxWithholdTrans.CustVendTransOpenRecId_BR   = _specTrans.vendTransOpen().RecId;
            }
            else if (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
            {
                taxWithholdTrans.CustVendTransOpenRecId_BR   = _specTrans.custTransOpen().RecId;
            }
            taxWithholdTrans.Source_BR                      = this.taxWithholdSource_BR();
            taxWithholdTrans.CanBeReversed_BR               = NoYes::Yes;

            custVendTransAmountCur = -_custVendTrans.AmountCur;
            custVendTrans = _custVendTrans;
        }
        // </GBR>

        if (_custVendTrans.TableId == tableNum(VendTrans))
        {
            taxWithholdTrans.InvoiceAmount = - _invoiceAmountSettle;
        }
        else
        {
            taxWithholdTrans.InvoiceAmount = _invoiceAmountSettle;
        }

        if (isTaxWithholdEnabledTH 
            || (TaxWTHCustPayBaseAmountNegativeFlight::instance().isEnabled()
                && isEnableGlobalWHTFeatureAndParam))
        {
            taxWithholdTrans.InvoiceAmount = -1 * sign(_invoiceAmountSettle) * abs(taxWithholdTrans.InvoiceAmount);
        }

        taxWithholdTrans.InvoiceTaxAmount = this.calcInvoiceTaxAmount(taxWithholdTrans, _custVendTrans);

        return taxWithholdTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxWithholdTrans_TH</Name>
				<Source><![CDATA[
    [SysObsolete('This method is obsoleted. Use initTaxWithholdTransWithMarkupTrans_TH() instead.', false, 03\08\2021)]
    public TaxWithholdTrans initTaxWithholdTrans_TH(TaxWithholdTrans    _taxWithholdTrans,
                                                    CustVendTrans       _custVendTrans,
                                                    SpecTrans           _specTrans,
                                                    AmountCur           _invoiceAmountSettle,
                                                    InventTransId       _inventTransId,
                                                    Voucher             _voucher,
                                                    boolean             _inclTax,
                                                    TaxWithholdGroup    _taxWithholdGroup,
                                                    AmountCur           _invoiceAmountSettleTotal = 0,
                                                    RefRecId            _sourceDocumentLineRecId = 0,
                                                    RefRecId            _invoiceLineRecId = 0)
    {
        return _taxWithholdTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxWithholdTransWithMarkupTrans_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes another withholding tax transaction from specified withholding tax transaction.
    /// </summary>
    /// <param name="_taxWithholdTrans">
    ///    A <c>TaxWithholdTrans</c> table buffer.
    /// </param>
    /// <param name="_custVendTrans">
    ///    A <c>CustVendTrans</c> table buffer.
    /// </param>
    /// <param name="_specTrans">
    ///    A <c>SpecTrans</c> table buffer.
    /// </param>
    /// <param name="_invoiceAmountSettle">
    ///    The invoice amount to be settled.
    /// </param>
    /// <param name="_inventTransId">
    ///    The inventory transaction Id.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher number.
    /// </param>
    /// <param name="_inclTax">
    ///    Indicates whether including tax.
    /// </param>
    /// <param name="_taxWithholdGroup">
    ///    The given withholding tax group.
    /// </param>
    /// <param name="_invoiceAmountSettleTotal">
    ///    The total invoice amount to be settled; Optional, default is zero.
    /// </param>
    /// <param name="_sourceDocumentLineRecId">
    ///    The source document line RecId
    /// </param>
    /// <param name="_invoiceLineRecId">
    ///    The VendInvoiceTrans RecId
    /// </param>
    /// <param name="_createWHTransForMarkupTrans">
    ///    Indicates that we are calculating taxAmount for the GWHT charge code.
    /// </param>
    /// <param name="_gwhtMarkupTransTaxAmount">
    ///    GWHTax trans record tax amount. Without adjustment.
    /// </param>
    /// <returns>
    ///    Withholding tax transaction.
    /// </returns>
    public TaxWithholdTrans initTaxWithholdTransWithMarkupTrans_TH(TaxWithholdTrans    _taxWithholdTrans,
                                                    CustVendTrans       _custVendTrans,
                                                    SpecTrans           _specTrans,
                                                    AmountCur           _invoiceAmountSettle,
                                                    InventTransId       _inventTransId,
                                                    Voucher             _voucher,
                                                    boolean             _inclTax,
                                                    TaxWithholdGroup    _taxWithholdGroup,
                                                    AmountCur           _invoiceAmountSettleTotal = 0,
                                                    RefRecId            _sourceDocumentLineRecId = 0,
                                                    RefRecId            _invoiceLineRecId = 0,
                                                    boolean _createWHTransForMarkupTrans = false,
                                                    TaxAmount _gwhtMarkupTransTaxAmount = 0)
    {
        TaxWithholdTrans taxWithholdTrans = this.initTaxWithholdTrans_TH(
            _taxWithholdTrans,
            _custVendTrans,
            _specTrans,
            _invoiceAmountSettle,
            _inventTransId,
            _voucher,
            _inclTax,
            _taxWithholdGroup,
            _invoiceAmountSettleTotal,
            _sourceDocumentLineRecId,
            _invoiceLineRecId);

        taxWithholdTrans.SpecTransId = _specTrans.RecId;

        taxWithholdTrans.TaxWithholdGroup = _taxWithholdGroup;

        taxWithholdTrans.initFromLedgerJournalTrans(ledgerJournalTrans);
        taxWithholdTrans.initFromCustVendTrans(_custVendTrans);

        // <GTH>
        if (isTaxWithholdEnabledTH || isEnableGlobalWHTFeatureAndParam)
        {
            if (_specTrans.RefTableId == tableNum(VendTransOpen))
            {
                // AP: The sign should equals to the sign of the amount to settle
                taxWithholdTrans.InvoiceAmount = _invoiceAmountSettle;
            }
            else
            {
                // AR: The sign should be opposite to the sign of the amount to settle
                taxWithholdTrans.InvoiceAmount = -1 * _invoiceAmountSettle;
            }
        }
        else
        {
            // </GTH>
            taxWithholdTrans.InvoiceAmount = _invoiceAmountSettle;
            // <GTH>
        }
        // </GTH>

        taxWithholdTrans.InvoiceTaxAmount = this.calcInvoiceTaxAmountWithMarkupTrans_TH(taxWithholdTrans,
            _specTrans,
            _custVendTrans,
            _inventTransId,
            _voucher,
            _inclTax,
            _invoiceAmountSettleTotal,
            _sourceDocumentLineRecId,
            _invoiceLineRecId,
            _createWHTransForMarkupTrans,
            _gwhtMarkupTransTaxAmount);

        return taxWithholdTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoice2Payment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the invoice amount to an amount in the payment currency.
    /// </summary>
    /// <param name="_invoiceAmount">
    /// The amount to convert.
    /// </param>
    /// <param name="_invoiceCurrency">
    /// The currency of the amount that is being converted.
    /// </param>
    /// <param name="_paymCurrency">
    /// The currency that the amount will be converted to.
    /// </param>
    /// <param name="_settleExchRate">
    /// The cross rate to use in the conversion.
    /// </param>
    /// <param name="_invoiceCompany">
    /// The company of the invoice.
    /// </param>
    /// <param name="_paymCompany">
    /// The company of the payment.
    /// </param>
    /// <returns>
    /// The amount in payment currency of the payment company.
    /// </returns>
    private AmountCur invoice2Payment(AmountCur      _invoiceAmount,
                                      CurrencyCode   _invoiceCurrency,
                                      CurrencyCode   _paymCurrency,
                                      CrossExchRate  _settleExchRate,
                                      CompanyId      _invoiceCompany,
                                      CompanyId      _paymCompany)
    {
        AmountCur paymAmount;
        AmountMST invoiceMstAmount;
        AmountMST paymMstAmount;
        CurrencyCode paymCompanyCurrency;
        CurrencyExchangeHelper currencyHelper;
        ;

        if (_invoiceAmount == 0)
        {
            return 0;
        }

        currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(_invoiceCompany).RecId), ledgerJournalTrans.TransDate);

        if (_invoiceCurrency == _paymCurrency)
        {
            // If currencies are the same the payment amount is the same as invoice amount
            paymAmount = _invoiceAmount;
        }
        else if (_settleExchRate != 0)
        {
            // if cross rate calculate the payment amount using the cross rate
            paymAmount = CurrencyExchange::round(CurrencyExchange::calculateAmount(_invoiceAmount, _settleExchRate), _paymCurrency);
        }
        else
        {
            // First convert invoice trans amount to invoice mst amount using ledgerJournalTrans TransDate
            invoiceMstAmount = currencyHelper.calculateTransactionToAccounting(_invoiceCurrency, _invoiceAmount, false);

            if (_invoiceCompany == _paymCompany)
            {
                // companies are the same paym mst amount is same as invoice mst amount
                paymMstAmount = invoiceMstAmount;
            }
            else
            {
                // Companies have different currency, convert invoice mst amount to payment mst amount
                // using the exchange rate from the invoice company and ledgerJournalTrans TransDate
                changecompany(_paymCompany)
                {
                    // get standard currency from payment company
                    paymCompanyCurrency = CompanyInfoHelper::standardCurrency();
                }

                paymMstAmount = currencyHelper.calculateAccountingToTransaction(paymCompanyCurrency, invoiceMstAmount, false);
            }

            // Lastly convert payment mst amount to payment trans amount, use exchange rate in payment trans
            currencyHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(_paymCompany).RecId));
            currencyHelper.parmExchangeRate1(ledgerJournalTrans.ExchRate);
            currencyHelper.parmExchangeRate2(ledgerJournalTrans.ExchRateSecond);

            paymAmount = currencyHelper.calculateAccountingToTransaction(_paymCurrency, paymMstAmount, true);
        }

        return paymAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the invoice amount.
    /// </summary>
    /// <param name = "_invoiceAmountSettle">The settlement invoice amount.</param>
    /// <param name = "_vendTrans">The buffer of <c>CustVendTrans</c>.</param>
    /// <param name = "_intersectionWithholdBaseAmount_BR">The tax withold base.</param>
    /// <returns>The invoice amount.</returns>
    protected AmountCur invoiceAmount_BR(AmountCur _invoiceAmountSettle, CustVendTrans _vendTrans, TaxWithholdBase _intersectionWithholdBaseAmount_BR)
    {
        return CurrencyExchangeHelper::amount(-_invoiceAmountSettle * _intersectionWithholdBaseAmount_BR / -_vendTrans.AmountCur);
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceHasReturnedTax</Name>
				<Source><![CDATA[
    private boolean invoiceHasReturnedTax(CustVendTrans _custVendTrans)
    {
        TaxTrans taxTrans;
        TaxTable taxTable;

        select RetainedTax_BR from taxTable
            where taxTable.RetainedTax_BR == true
            exists join taxTrans
                where taxTrans.TaxCode == taxTable.TaxCode
                    && taxTrans.Voucher == _custVendTrans.Voucher
                    && taxTrans.TransDate == _custVendTrans.TransDate;

        return taxTable != null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCalculateTaxWithholdingNeeded_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method will determine if the withholding tax needs to be calculated.
    /// </summary>
    /// <param name="_taxWithholdGroup">
    /// The id of the Tax withholding group specified for the transaction.
    /// </param>
    /// <param name="_taxWithholdItemGroupId_TH">
    /// The id of the Tax withholding item group specified for the transaction.
    /// </param>
    /// <param name="_custVendInvoiceTrans">
    /// CustVendInvoiceTrans record used to determine the item type.
    /// </param>
    /// <returns>
    /// If the tax withholding group, tax withholding Item group, and the item is service type, function returns true.
    /// Otherwise, the return value is false.
    /// </returns>
    protected boolean isCalculateTaxWithholdingNeeded_TH(
        TaxWithholdGroup            _taxWithholdGroup,
        TaxWithholdItemGroupId_TH   _taxWithholdItemGroupId_TH,
        CustVendInvoiceTrans        _custVendInvoiceTrans)
    {
        #ISOCountryRegionCodes
        boolean isNeeded = false;

        if (_taxWithholdGroup != ''
            && _taxWithholdItemGroupId_TH != 0
        )
        {
            if (isTaxWithholdEnabledTH)
            {
                isNeeded = ledgerJournalTrans.TaxWithholdCalculate_TH;
            }
            else
            {
                isNeeded = this.getCustVendTableForJournalTrans().TaxWithholdCalculate;

                if (TaxWithhold::IsWithholdTaxOnlyNeededForService())
                {
                    isNeeded = isNeeded && InventTable::find(_custVendInvoiceTrans.ItemId).ItemType == ItemType::Service;
                }
            }
        }

        return isNeeded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreditPayment_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether it is credit payment.
    /// </summary>
    /// <param name = "_vendTrans">The buffer of <c>CustVendTrans</c>.</param>
    /// <returns>true if it is credit payment; otherwise false.</returns>
    protected boolean isCreditPayment_BR(CustVendTrans _vendTrans)
    {
        return _vendTrans.AmountCur >= 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupTaxWithholdCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Lookup method to look up tax withhold code with given tax withhold group.
    /// </summary>
    /// <param name = "_ctrl">The form string control.</param>
    /// <param name = "_taxTransWithholdGroup">The tax withhold group.</param>
    public void lookupTaxWithholdCode(FormStringControl _ctrl, TaxWithholdGroup _taxTransWithholdGroup)
    {
        SysTableLookup          sysTableLookup = SysTableLookup::newParameters(tableNum(TaxWithholdGroupData), _ctrl);
        Query                   query;
        QueryBuildDataSource    queryBuildDataSource;
        QueryBuildRange         queryBuildRange;

        if (_taxTransWithholdGroup)
        {
            query = new Query();
            queryBuildDataSource = query.addDataSource(tableNum(TaxWithholdGroupData));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(TaxWithholdGroupData, TaxWithholdGroup));
            queryBuildRange.value(_taxTransWithholdGroup);
            sysTableLookup.parmQuery(query);

            sysTableLookup.addLookupfield(fieldNum(TaxWithholdGroupData, TaxWithholdCode));
            sysTableLookup.performFormLookup();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>needsToUnselectAll_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether need to unselect all.
    /// </summary>
    /// <param name = "_transaction">The buffer of <c>CustVendTransOpen</c>.</param>
    /// <param name = "_ledgerJournalTrans">The buffer of <c>LedgerJournalTrans</c>.</param>
    /// <returns>true if need to unselect all; otherwise false.</returns>
    public boolean needsToUnselectAll_BR(CustVendTransOpen _transaction, LedgerJournalTrans _ledgerJournalTrans)
    {
        date                periodStart;
        date                periodEnd;

        TaxWithholdTrans    taxWithholdTrans;
        TaxWithholdTrans    taxCurrent;

        container           dataAreaIdList = this.crossCompanyList_BR();
        ;

        periodStart = dateStartMth(_ledgerJournalTrans.TransDate);
        periodEnd   = dateEndMth(periodStart);

        while select crosscompany : dataAreaIdList TaxWithholdCode from taxWithholdTrans
            where       taxWithholdTrans.CustVendTransOpenRecId_BR  == _transaction.RecId
                        && taxWithholdTrans.LedgerJourTransRecId_BR == _ledgerJournalTrans.RecId
                        && taxWithholdTrans.CanBeReversed_BR        == NoYes::Yes
        {
            if (!this.existCalculatedWithholdTax_BR(taxWithholdTrans.TaxWithholdCode, _ledgerJournalTrans, periodStart, periodEnd))
            {
                select crosscompany : dataAreaIdList count(RecId)
                    from    taxCurrent
                    where   taxCurrent.LedgerJourTransRecId_BR  == _ledgerJournalTrans.RecId
                        &&  taxCurrent.TaxWithholdCode          == taxWithholdTrans.TaxWithholdCode
                        &&  taxCurrent.TaxWithholdIsSelected_BR == NoYes::Yes
                        &&  taxCurrent.CanBeReversed_BR    == NoYes::Yes;

                if (taxCurrent.RecId > 1)
                {
                    return true;
                }
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new(LedgerJournalTrans _ledgerJournalTrans)
    {
        ledgerJournalTrans = _ledgerJournalTrans;

        tmpTaxWithholdList = new RecordSortedList(tableNum(TmpTaxWithhold));
        tmpTaxWithholdList.sortOrder(fieldNum(TmpTaxWithhold, TaxWithholdTransId));

        // <GTH>
        isTaxWithholdEnabledTH = TaxThaiGovCertificationFeatureChecker::isTaxWithholdEnabled();
        // </GTH>

        // <GBR>
        selectedTaxWithholdTrans = new RecordSortedList(tableNum(TaxWithholdTrans));
        selectedTaxWithholdTrans.sortOrder(fieldNum(TaxWithholdTrans, RecId));

        isTaxWithholdUK = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoGB, #isoIE]);
        // </GBR>

        // <GJP>
        isJPCountryRegion = SysCountryRegionCode::isLegalEntityInCountryRegion([#ISOJP]);
        // </GJP>

        enableWHTOnCharges = LedgerParameters::find().EnableWHTOnCharges == NoYes::Yes;

        isEnabledWHTCurrencyExchRateFeature = TaxWithholdSetupWithholdingTaxCurrencyExchRateHelper::isEnabledWHTCurrencyExchRateParam();
        isEnableGlobalWHTFeatureAndParam = TaxWithholdingGlobalFeature::isFeatureAndParamEnabled();

        accountingCurrency = Ledger::accountingCurrency();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalTrans</Name>
				<Source><![CDATA[
    public LedgerJournalTrans parmLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans  = ledgerJournalTrans)
    {
        ledgerJournalTrans  = _ledgerJournalTrans;

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>partyId_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the party number.
    /// </summary>
    /// <returns>The party number.</returns>
    protected DirPartyNumber partyId_BR()
    {
        VendTable vendTable;

        changecompany(ledgerJournalTrans.Company)
        {
            vendTable = VendTable::find(ledgerJournalTrans.parmAccount());
        }

        return DirPartyTable::findRec(vendTable.Party).PartyNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printTaxWithholdHeaderInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prints tax withhold hearder information.
    /// </summary>
    /// <param name = "_printMessageHeader">Whehter print header message.</param>
    /// <param name = "_custVendAccount">The customer or vendor account number.</param>
    protected void printTaxWithholdHeaderInfo(boolean _printMessageHeader, CustVendAC _custVendAccount)
    {
        if (_printMessageHeader)
        {
            info (strFmt("@SYS81768", _custVendAccount));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>printWhtTransAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method print the Calculated WHT amounts
    /// </summary>
    /// <param name="_specTrans">
    ///     A <c>SpecTrans</c> table buffer that references the payment record for which the calculation will be done
    /// </param>
    protected void printWhtTransAmount_BR(SpecTrans _specTrans)
    {
        TaxWithholdTrans taxWithholdTrans;
        TmpTaxWithhold   tmpTaxWithhold;

        while select
                Invoice, InvoiceCurrency, InvoiceWithholdBaseAmount,
                TaxWithholdCode, TaxWithholdBaseAmount, InvoiceTaxWithholdAmount
            from taxWithholdTrans
            where taxWithholdTrans.SpecTransId == _specTrans.RecId
                && taxWithholdTrans.InvoiceTaxWithholdAmount != 0
        {
            tmpTaxWithhold = this.findTmpTaxWithhold(taxWithholdTrans);

            info (strFmt("@GLS615", taxWithholdTrans.Invoice,
                taxWithholdTrans.InvoiceCurrency,
                abs(taxWithholdTrans.InvoiceWithholdBaseAmount),
                tmpTaxWithhold.TaxWithholdCode,
                abs(tmpTaxWithhold.TaxWithholdBase),
                abs(taxWithholdTrans.InvoiceTaxWithholdAmount)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetWhTaxAmountIfPaymAmountIsLess_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the tax withhold amount if payment amount is less than tax withhold amount.
    /// </summary>
    /// <param name = "_taxWithholdTrans">The buffer of <c>TaxWithholdTrans</c>.</param>
    /// <param name = "_settleExchRate">The settlement exchange rate.</param>
    protected void resetWhTaxAmountIfPaymAmountIsLess_BR( TaxWithholdTrans _taxWithholdTrans,
                                                          CrossExchRate    _settleExchRate)
    {
        if (invoiceamt < taxWithholdAmount || accumPayment)
        {
            _taxWithholdTrans.InvoiceWithholdBaseAmount = invoiceamt;
            _taxWithholdTrans.PaymWithholdBaseAmount = this.invoice2Payment(_taxWithholdTrans.InvoiceWithholdBaseAmount,
                                                                            _taxWithholdTrans.InvoiceCurrency,
                                                                            _taxWithholdTrans.PaymCurrency,
                                                                            _settleExchRate,
                                                                            _taxWithholdTrans.DataAreaId,
                                                                            _taxWithholdTrans.PaymCompany);

            _taxWithholdTrans.WithholdBaseAmount = CurrencyExchangeHelper::mstAmount(_taxWithholdTrans.PaymWithholdBaseAmount, _taxWithholdTrans.PaymCurrency, _taxWithholdTrans.TransDate, Currency::noYes2UnknownNoYes(ledgerJournalTrans.Triangulation), ledgerJournalTrans.ExchRate, ledgerJournalTrans.ExchRateSecond);
            _taxWithholdTrans.TaxWithholdBaseAmount     = CurrencyExchangeHelper::curAmount(_taxWithholdTrans.WithholdBaseAmount, _taxWithholdTrans.TaxWithholdCurrency, _taxWithholdTrans.TransDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundOffTaxWithholdAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method will round off withholding tax amount for specified withholding tax transaction.
    /// </summary>
    /// <param name="_taxWithholdTrans">
    /// A <c>TaxWithholdTrans</c> table buffer to be rounded off.
    /// </param>
    /// <param name="_tmpTaxWithhold">
    /// A <c>TmpTaxWithhold</c> table buffer.
    /// </param>
    /// <param name="_settleExchRate">
    /// The exchange rate when doing settlement.
    /// </param>
    /// <returns>
    /// The withholding tax transaction which withholding tax amount is rounded off.
    /// </returns>
    private TaxWithholdTrans roundOffTaxWithholdAmount(TaxWithholdTrans  _taxWithholdTrans,
                                                       TmpTaxWithhold    _tmpTaxWithhold,
                                                       CrossExchRate     _settleExchRate)
    {
        TaxWithholdTrans        taxWithholdTrans = _taxWithholdTrans;
        // <GTH>
        TaxWithholdTransExtensionTH taxWithholdTransExtensionTH;
        // </GTH>

        ExchRate exchRate;
        ExchrateSecondary exchRateSecond;
        EUROTriangulation triangulation;

        if ((isEnabledWHTCurrencyExchRateFeature && ledgerJournalTrans.CurrencyCode != accountingCurrency)
            || taxWithholdTrans.InvoiceCurrency == ledgerJournalTrans.CurrencyCode)
        {
            exchRate =  ledgerJournalTrans.ExchRate;
            exchRateSecond = ledgerJournalTrans.ExchRateSecond;
            triangulation = ledgerJournalTrans.Triangulation;
        }
        else
        {
            exchRate =  0;
            exchRateSecond = 0;
            triangulation = false;
        }

        // Convert currencies
        if (!isEnabledWHTCurrencyExchRateFeature)
        {
            taxWithholdTrans.TaxWithholdAmount = CurrencyExchangeHelper::mstAmount(
                taxWithholdTrans.TaxTaxWithholdAmount,
                taxWithholdTrans.TaxWithholdCurrency,
                taxWithholdTrans.TransDate,
                UnknownNoYes::Unknown,
                exchRate,
                exchRateSecond,
                triangulation);
            taxWithholdTrans.InvoiceTaxWithholdAmount = CurrencyExchangeHelper::curAmount(
                taxWithholdTrans.TaxWithholdAmount,
                taxWithholdTrans.InvoiceCurrency,
                taxWithholdTrans.TransDate,
                UnknownNoYes::Unknown,
                exchRate,
                exchRateSecond,
                triangulation);
        }

        if (taxWithholdTrans.TaxWithholdCurrency == taxWithholdTrans.InvoiceCurrency)
        {
            taxWithholdTrans.TaxTaxWithholdAmount = CurrencyExchange::roundWithRule(
                taxWithholdTrans.TaxTaxWithholdAmount,
                _tmpTaxWithhold.TaxWithholdRoundOff,
                _tmpTaxWithhold.TaxWithholdRoundOffType);

            taxWithholdTrans.TaxWithholdAmount = CurrencyExchange::roundWithRule(
                taxWithholdTrans.TaxWithholdAmount,
                _tmpTaxWithhold.TaxWithholdRoundOff,
                _tmpTaxWithhold.TaxWithholdRoundOffType);

            taxWithholdTrans.InvoiceTaxWithholdAmount = CurrencyExchange::roundWithRule(
                taxWithholdTrans.InvoiceTaxWithholdAmount,
                _tmpTaxWithhold.TaxWithholdRoundOff,
                _tmpTaxWithhold.TaxWithholdRoundOffType);
        }

        taxWithholdTrans.TaxTaxWithholdAmount = CurrencyExchange::round(
            taxWithholdTrans.TaxTaxWithholdAmount,
            taxWithholdTrans.TaxWithholdCurrency);


        taxWithholdTrans.TaxWithholdAmount = CurrencyExchangeHelper::amount(taxWithholdTrans.TaxWithholdAmount);

        taxWithholdTrans.InvoiceTaxWithholdAmount = CurrencyExchange::round(
            taxWithholdTrans.InvoiceTaxWithholdAmount,
            taxWithholdTrans.InvoiceCurrency);

        taxWithholdTrans.PaymTaxWithholdAmount = this.invoice2Payment(
            taxWithholdTrans.InvoiceTaxWithholdAmount,
            taxWithholdTrans.InvoiceCurrency,
            taxWithholdTrans.PaymCurrency,
            _settleExchRate,
            taxWithholdTrans.DataAreaId,
            taxWithholdTrans.PaymCompany);

        // <GTH>
        if (isTaxWithholdEnabledTH)
        {
            taxWithholdTransExtensionTH = taxWithholdTrans.taxWithholdTransExtensionTH();
            // After rounding, the withholding tax amount may be less then withholding expense amount.
            if (abs(taxWithholdTransExtensionTH.AccountingCurExpenseAmount) > abs(taxWithholdTrans.TaxWithholdAmount))
            {
                taxWithholdTransExtensionTH.AccountingCurExpenseAmount          = taxWithholdTrans.TaxWithholdAmount;
            }

            taxWithholdTransExtensionTH.TransCurExpenseAmount = CurrencyExchangeHelper::curAmount(taxWithholdTransExtensionTH.AccountingCurExpenseAmount, taxWithholdTrans.TaxWithholdCurrency, taxWithholdTrans.TransDate);

            taxWithholdTransExtensionTH.InvoiceCurExpenseAmount = CurrencyExchangeHelper::curAmount(taxWithholdTransExtensionTH.AccountingCurExpenseAmount, taxWithholdTrans.InvoiceCurrency, taxWithholdTrans.TransDate);

            taxWithholdTrans.SysExtensionSerializerMap::packExtensionTable(taxWithholdTransExtensionTH);
        }
        // </GTH>

        return taxWithholdTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWhBaseAmt4PayAmtInMonth_BR</Name>
				<Source><![CDATA[
    protected TaxWithholdTrans setWhBaseAmt4PayAmtInMonth_BR(TaxWithholdTrans _taxWithholdTrans, CrossExchRate _settleExchRate)
    {
        _taxWithholdTrans.InvoiceAmount = invoiceamt;
        _taxWithholdTrans.InvoiceBaseAmount = _taxWithholdTrans.InvoiceAmount;

        _taxWithholdTrans.InvoiceWithholdBaseAmount = CurrencyExchangeHelper::amount(_taxWithholdTrans.InvoiceBaseAmount - _taxWithholdTrans.InvoiceNotTaxableByTreaty - _taxWithholdTrans.InvoiceNotTaxableExpenses - _taxWithholdTrans.InvoiceExemptedAmount, _taxWithholdTrans.InvoiceCurrency);

        _taxWithholdTrans.PaymWithholdBaseAmount    = this.invoice2Payment(_taxWithholdTrans.InvoiceWithholdBaseAmount,
                                                                           _taxWithholdTrans.InvoiceCurrency,
                                                                           _taxWithholdTrans.PaymCurrency,
                                                                           _settleExchRate,
                                                                           _taxWithholdTrans.DataAreaId,
                                                                           _taxWithholdTrans.PaymCompany);

        _taxWithholdTrans.WithholdBaseAmount        = CurrencyExchangeHelper::mstAmount(_taxWithholdTrans.PaymWithholdBaseAmount, _taxWithholdTrans.PaymCurrency, _taxWithholdTrans.TransDate, Currency::noYes2UnknownNoYes(ledgerJournalTrans.Triangulation), ledgerJournalTrans.ExchRate, ledgerJournalTrans.ExchRateSecond);

        _taxWithholdTrans.TaxWithholdBaseAmount     = CurrencyExchangeHelper::curAmount(_taxWithholdTrans.WithholdBaseAmount, _taxWithholdTrans.TaxWithholdCurrency, _taxWithholdTrans.TransDate);
        return _taxWithholdTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdSource_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax withhold source.
    /// </summary>
    /// <returns>The tax withhold source.</returns>
    protected TaxWithholdSource taxWithholdSource_BR()
    {
        return TaxWithholdSource::VendPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalAllInvoicesAmountSettled_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total based amount for all the invoices that are used during the settlement process.
    /// </summary>
    /// <param name="_specTrans">
    ///    The <c>SpecTrans</c> table buffer that contains the reference to the payment record.
    /// </param>
    /// <returns>
    ///    A currency amount that represents the sum of each invoice total base amount.
    /// </returns>
    protected AmountCur totalAllInvoicesAmountSettled_TH(SpecTrans   _specTrans)
    {
        AmountCur           totalLineamount;
        SpecTrans           specTransLoc;

        while select specTransLoc
            where specTransLoc.SpecRecId == _specTrans.SpecRecId
                && specTransLoc.SpecCompany == _specTrans.SpecCompany
                && specTransLoc.SpecTableId == _specTrans.SpecTableId
        {
            totalLineamount += this.totalInvoiceAmountSettled_TH(specTransLoc);
        }
        totalLineamount = totalLineamount;

        return totalLineamount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalInvoiceAmountSettled_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the sum of all invoices base amount that will be used to determine the WHT tax.
    /// </summary>
    /// <param name="_specTrans">
    ///    The <c>SpecTrans</c> value that references the settlement record and related to the invoices.
    /// </param>
    /// <param name="_vendTrans">
    ///    The <c>VendTrans</c> table buffer; optional.
    /// </param>
    /// <param name="_vendInvoiceJour">
    ///    The <c>VendInvoiceJour</c> table buffer; optional.
    /// </param>
    /// <returns>
    ///    The total base amount of all invoices that are marked as settlement.
    /// </returns>
    protected AmountCur totalInvoiceAmountSettled_TH(SpecTrans       _specTrans,
                                                     VendTrans       _vendTrans = null,
                                                     VendInvoiceJour _vendInvoiceJour = null)
    {
        #Tax
        AmountCur   totalInvoiceAmount;
        VendInvoiceJour vendInvoiceJourLoc;
        VendInvoiceTrans vendInvoiceTransLoc;
        VendTrans    vendTransLoc;

        SysGlobalCache          cache = classfactory.globalCache();
      
        if (cache.isSet(#TaxWithholdVendPaymCacheKey, _specTrans.RecId) == true)
        {
            return cache.get(#TaxWithholdVendPaymCacheKey, _specTrans.RecId);
        }

        if (_vendTrans)
        {
            vendTransLoc = _vendTrans;
        }
        else
        {
            vendTransLoc = _specTrans.vendTrans();
        }

        if (vendTransLoc.Invoice == '')
        {
            //only calculate tax withholding if VendTrans has an invoice number
            cache.set(#TaxWithholdVendPaymCacheKey, _specTrans.RecId, 0);
            return 0;
        }

        changecompany(_specTrans.RefCompany)
        {
            if (_vendInvoiceJour)
            {
                vendInvoiceJourLoc = _vendInvoiceJour;
            }
            else
            {
                vendInvoiceJourLoc = VendInvoiceJour::findFromVendTrans(vendTransLoc.Invoice,
                                                            vendTransLoc.TransDate,
                                                            vendTransLoc.AccountNum);
            }

            if (enableWHTOnCharges) // including markupTrans for header
            {
                totalInvoiceAmount += this.findMarkupValue_TH(tableNum(VendInvoiceJour), vendInvoiceJourLoc.RecId);
            }

            while select vendInvoiceTransLoc
                where vendInvoiceTransLoc.PurchID == vendInvoiceJourLoc.PurchId
                    && vendInvoiceTransLoc.InvoiceDate == vendInvoiceJourLoc.InvoiceDate
                    && vendInvoiceTransLoc.InvoiceId == vendInvoiceJourLoc.InvoiceId
                    && vendInvoiceTransLoc.NumberSequenceGroup == vendInvoiceJourLoc.NumberSequenceGroup

            {
                boolean isIncludeTax = vendInvoiceJourLoc.InclTax;
                if (TaxWithholdDetermineTaxInclusiveByPurchTableFirstFlight::instance().isEnabled())
                {
                    if (!vendInvoiceJourLoc.isNonPO())
                    {
                        PurchTable purchTable = PurchTable::find(vendInvoiceJourLoc.PurchID);
                        if (purchTable)
                        {
                            isIncludeTax = purchTable.InclTax;
                        }
                    }
                }

                totalInvoiceAmount += this.totalInvoiceLineAmountSettled_TH(vendInvoiceTransLoc, isIncludeTax);
            }
        }

        cache.set(#TaxWithholdVendPaymCacheKey, _specTrans.RecId, totalInvoiceAmount);

        return totalInvoiceAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalInvoiceLineAmountSettled_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method will determine the sum of an invoice base amount that will be used to determine WHT tax.
    /// </summary>
    /// <param name="_custVendInvoiceTrans">
    /// The <c>CustVendInvoiceTrans</c> value that references the invoices.
    /// </param>
    /// <param name="_inclTax">
    /// A Boolean value that indicates whether the invoice has taxes included.
    /// </param>
    /// <returns>
    /// The total base amount of an invoice that is marked as settlement.
    /// </returns>
    protected AmountCur totalInvoiceLineAmountSettled_TH(
        CustVendInvoiceTrans _custVendInvoiceTrans, 
        boolean _inclTax)
    {
        TaxTrans            taxTransLoc;
        AmountCur           totalInvoiceAmount;
        AmountCur           costAmountPosted;
        SourceDocumentLine  sourceDocumentLine;

        VendInvoiceTransRef vendInvoiceTransRef;

        VendInvoiceTrans vendInvoiceTransLoc = _custVendInvoiceTrans;

        if (_inclTax)
        {
            costAmountPosted = vendInvoiceTransLoc.LineAmount + vendInvoiceTransLoc.LineAmountTax;
        }
        else
        {
            costAmountPosted = vendInvoiceTransLoc.LineAmount;
        }

        if (Project::Enabled())
        {
            costAmountPosted = costAmountPosted - vendInvoiceTransLoc.PSARetainageAmount;
        }

        if (costAmountPosted && vendInvoiceTransLoc.TaxWithholdBaseCur_TH == 0)
        {
            if (_inclTax)
            {
                if (!vendInvoiceTransLoc.sourceDocumentLine && !vendInvoiceTransLoc.InventTransId)
                {
                    select firstonly taxTransLoc
                        exists join vendInvoiceTransRef
                        where taxTransLoc.SourceTableId == tableNum(LedgerJournalTrans)
                            && taxTransLoc.SourceRecId == vendInvoiceTransRef.LedgerJournalTransRecId
                            && vendInvoiceTransRef.VendInvoiceTransRecId == vendInvoiceTransLoc.RecId;
                }
                else if (vendInvoiceTransLoc.sourceDocumentLine)
                {
                    select firstonly taxTransLoc
                        exists join SourceDocumentLine
                        where taxTransLoc.SourceDocumentLine == sourceDocumentLine.RecId
                            && sourceDocumentLine.ParentSourceDocumentLine == vendInvoiceTransLoc.sourceDocumentLine;
                }
                else
                {
                    select firstonly taxTransLoc
                        where taxTransLoc.InventTransId == vendInvoiceTransLoc.InventTransId
                          && (!enableWHTOnCharges || taxTransLoc.SourceTableId != tableNum(MarkupTrans));
                }

                if (taxTransLoc.TaxDirection == TaxDirection::UseTax)
                {
                    costAmountPosted = taxTransLoc.SourceBaseAmountCurRegulated ? taxTransLoc.SourceBaseAmountCurRegulated : taxTransLoc.SourceBaseAmountCur;
                }
                else
                {
                    if (!Project::Enabled() || (Project::Enabled() && !vendInvoiceTransLoc.PSARetainageAmount))
                    {
                        costAmountPosted = vendInvoiceTransLoc.LineAmount;
                    }
                    else
                    {
                        costAmountPosted = costAmountPosted * 100 / (100 + taxTransLoc.TaxValue);
                    }
                }
            }
            if (sign(costAmountPosted) != sign(vendInvoiceTransLoc.LineAmountTax))
            {
                totalInvoiceAmount = costAmountPosted + vendInvoiceTransLoc.LineAmountTax * -1;
            }
            else
            {
                totalInvoiceAmount = costAmountPosted + vendInvoiceTransLoc.LineAmountTax;
            }

            if (!skipMarkupTransOnLines)
            {
                totalInvoiceAmount += this.findMarkupValue_TH(tableNum(VendInvoiceTrans), vendInvoiceTransLoc.RecId);
            }
        }
        else if (vendInvoiceTransLoc.TaxWithholdBaseCur_TH)
        {
            totalInvoiceAmount = totalInvoiceAmount + vendInvoiceTransLoc.TaxWithholdBaseCur_TH;
        }

        if (!_inclTax || (_inclTax && vendInvoiceTransLoc.TaxWithholdBaseCur_TH))
        {
            AmountCur sourceTaxAmountCur ;
            boolean isIsoGB = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoGB]);
            if (isEnableGlobalWHTFeatureAndParam)
            {
                // For global withholding tax, the gross amount should exclude the use tax.
                sourceTaxAmountCur = this.getSalesTaxAmountExcludedUseTax(vendInvoiceTransLoc);
            }
            else
            {
                if (!vendInvoiceTransLoc.SourceDocumentLine && !vendInvoiceTransLoc.InventTransId)
                {
                    boolean isGWHTEnabledByDefaut = TaxWithholdingGlobalFeature::isExtendedWHTSupportedInCountryRegionByDefault();
                    select sum(SourceRegulateAmountCur) from taxTransLoc
                        exists join vendInvoiceTransRef
                            where taxTransLoc.SourceTableId == tableNum(LedgerJournalTrans)
                                && taxTransLoc.SourceRecId == vendInvoiceTransRef.LedgerJournalTransRecId
                                && vendInvoiceTransRef.VendInvoiceTransRecId == vendInvoiceTransLoc.RecId
                                && (isGWHTEnabledByDefaut && taxTransLoc.TaxDirection != TaxDirection::UseTax || !isGWHTEnabledByDefaut);           
                }
                else if (vendInvoiceTransLoc.SourceDocumentLine)
                {
                    if (isTaxWithholdUK)
                    {
                        boolean ignoreTaxDirectionCheck = TaxWithhold::ignoreTaxDirectionCheck_TH();
                        select sum(SourceRegulateAmountCur) from taxTransLoc
                            exists join ParentSourceDocumentLine, RecId from SourceDocumentLine
                            where taxTransLoc.SourceDocumentLine == sourceDocumentLine.RecId
                                &&(taxTransLoc.TaxDirection != TaxDirection::UseTax || ignoreTaxDirectionCheck)
                                && sourceDocumentLine.ParentSourceDocumentLine == vendInvoiceTransLoc.SourceDocumentLine;
                    }
                    else
                    {
                        select sum(SourceRegulateAmountCur) from taxTransLoc
                            exists join ParentSourceDocumentLine, RecId from SourceDocumentLine
                            where taxTransLoc.SourceDocumentLine == sourceDocumentLine.RecId
                                && sourceDocumentLine.ParentSourceDocumentLine == vendInvoiceTransLoc.SourceDocumentLine;
                    }
                }
                else
                {
                    select sum(SourceRegulateAmountCur) from taxTransLoc
                        where taxTransLoc.InventTransId == vendInvoiceTransLoc.InventTransId
                            && (!enableWHTOnCharges || taxTransLoc.SourceTableId != tableNum(MarkupTrans));
                }

                sourceTaxAmountCur = taxTransLoc.SourceRegulateAmountCur;
            }

            if (isTaxWithholdEnabledTH || isIsoGB || isEnableGlobalWHTFeatureAndParam)
            {
                totalInvoiceAmount += sourceTaxAmountCur;
            }
            else
            {
                totalInvoiceAmount += abs(sourceTaxAmountCur);
            }
        }

        return CurrencyExchangeHelper::amount(totalInvoiceAmount, vendInvoiceTransLoc.CurrencyCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesTaxAmountExcludedUseTax</Name>
				<Source><![CDATA[
    private AmountCur getSalesTaxAmountExcludedUseTax(VendInvoiceTrans _vendInvoiceTransLoc)
    {
        SourceDocumentLine sourceDocumentLine;
        TaxTrans taxTransLoc;
        VendInvoiceTransRef vendInvoiceTransRef;

        if (!_vendInvoiceTransLoc.SourceDocumentLine && !_vendInvoiceTransLoc.InventTransId)
        {
            select sum(SourceRegulateAmountCur) from taxTransLoc
                exists join vendInvoiceTransRef
                where taxTransLoc.SourceTableId == tableNum(LedgerJournalTrans)
                    && taxTransLoc.SourceRecId == vendInvoiceTransRef.LedgerJournalTransRecId
                    && vendInvoiceTransRef.VendInvoiceTransRecId == _vendInvoiceTransLoc.RecId
                    && taxTransLoc.TaxDirection != TaxDirection::UseTax;
        }
        else if (_vendInvoiceTransLoc.SourceDocumentLine)
        {
            select sum(SourceRegulateAmountCur) from taxTransLoc
                exists join SourceDocumentLine
                where taxTransLoc.SourceDocumentLine == sourceDocumentLine.RecId
                    && taxTransLoc.TaxDirection != TaxDirection::UseTax
                    && sourceDocumentLine.ParentSourceDocumentLine == _vendInvoiceTransLoc.SourceDocumentLine;
        }
        else
        {
            select sum(SourceRegulateAmountCur) from taxTransLoc
                where taxTransLoc.InventTransId == _vendInvoiceTransLoc.InventTransId
                    && (!enableWHTOnCharges || taxTransLoc.SourceTableId != tableNum(MarkupTrans));
        }

        return taxTransLoc.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAllTaxWithholdTransJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates all tax withhold transaction journals.
    /// </summary>
    public void updateAllTaxWithholdTransJournal()
    {
        SpecTrans  specTrans;

        if (ledgerJournalTrans.TaxWithholdGroup)
        {
            while select crossCompany * from specTrans
                where specTrans.SpecCompany == ledgerJournalTrans.DataAreaId &&
                      specTrans.SpecTableId == ledgerJournalTrans.TableId &&
                      specTrans.SpecRecId   == ledgerJournalTrans.RecId
            {
                changecompany(specTrans.RefCompany)
                {
                    this.updateAllTaxWithholdTransSpec(specTrans);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAllTaxWithholdTransSpec</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates all tax withhold transactions for given spec transaction.
    /// </summary>
    /// <param name = "_specTrans">The buffer of <c>SpecTrans</c>.</param>
    public void updateAllTaxWithholdTransSpec(SpecTrans  _specTrans)
    {
        TaxWithholdTrans   taxWithholdTrans;
        TmpTaxWithhold     tmpTaxWithhold;

        if (ledgerJournalTrans.TaxWithholdGroup)
        {
            ttsbegin;
            while select forupdate taxWithholdTrans
                where taxWithholdTrans.SpecTransId == _specTrans.RecId
            {
                ExchRate exchRate;
                ExchrateSecondary exchRateSecond;
                EUROTriangulation triangulation;

                if ((isEnabledWHTCurrencyExchRateFeature && ledgerJournalTrans.CurrencyCode != accountingCurrency)
                    || taxWithholdTrans.InvoiceCurrency == ledgerJournalTrans.CurrencyCode)
                {
                    exchRate =  ledgerJournalTrans.ExchRate;
                    exchRateSecond = ledgerJournalTrans.ExchRateSecond;
                    triangulation = ledgerJournalTrans.Triangulation;
                }
                else
                {
                    exchRate =  0;
                    exchRateSecond = 0;
                    triangulation = false;
                }

                taxWithholdTrans.TransDate = ledgerJournalTrans.TransDate;
                taxWithholdTrans.PaymCurrency = ledgerJournalTrans.CurrencyCode;
                tmpTaxWithhold = this.findTmpTaxWithhold(taxWithholdTrans);
                this.calcNotTaxableByTreaty(taxWithholdTrans, _specTrans.CrossRate);
                this.calcNotTaxableExpenses(taxWithholdTrans, _specTrans.CrossRate);

                taxWithholdTrans.PaymExemptedAmount = this.invoice2Payment(taxWithholdTrans.InvoiceExemptedAmount,
                                                                           taxWithholdTrans.InvoiceCurrency,
                                                                           taxWithholdTrans.PaymCurrency,
                                                                           _specTrans.CrossRate,
                                                                           taxWithholdTrans.DataAreaId,
                                                                           taxWithholdTrans.PaymCompany);
                taxWithholdTrans.ExemptedAmount     = CurrencyExchangeHelper::mstAmount(taxWithholdTrans.InvoiceExemptedAmount, taxWithholdTrans.InvoiceCurrency, taxWithholdTrans.TransDate);

                if (isEnabledWHTCurrencyExchRateFeature)
                {
                    taxWithholdTrans.TaxExemptedAmount = this.payment2TaxWithhold(
                        taxWithholdTrans.PaymExemptedAmount,
                        taxWithholdTrans.PaymCurrency,
                        taxWithholdTrans.TaxWithholdCurrency,
                        taxWithholdTrans.TaxWithholdExchRate,
                        taxWithholdTrans.TaxWithholdExchRateDate,
                        true);
                }
                else
                {
                    taxWithholdTrans.TaxExemptedAmount = CurrencyExchangeHelper::curAmount(taxWithholdTrans.ExemptedAmount, taxWithholdTrans.TaxWithholdCurrency, taxWithholdTrans.TransDate);
                }

                taxWithholdTrans.PaymWithholdBaseAmount = this.invoice2Payment(taxWithholdTrans.InvoiceWithholdBaseAmount,
                                                                               taxWithholdTrans.InvoiceCurrency,
                                                                               taxWithholdTrans.PaymCurrency,
                                                                               _specTrans.CrossRate,
                                                                               taxWithholdTrans.DataAreaId,
                                                                               taxWithholdTrans.PaymCompany);
                taxWithholdTrans.WithholdBaseAmount = CurrencyExchangeHelper::mstAmount(taxWithholdTrans.InvoiceWithholdBaseAmount,
                                                                                        taxWithholdTrans.InvoiceCurrency,
                                                                                        taxWithholdTrans.TransDate,
                                                                                        UnknownNoYes::Unknown,
                                                                                        exchRate,
                                                                                        exchRateSecond,
                                                                                        triangulation);

                if (isEnabledWHTCurrencyExchRateFeature)
                {
                    taxWithholdTrans.TaxWithholdBaseAmount  = this.payment2TaxWithhold(
                        taxWithholdTrans.PaymWithholdBaseAmount,
                        taxWithholdTrans.PaymCurrency,
                        taxWithholdTrans.TaxWithholdCurrency,
                        taxWithholdTrans.TaxWithholdExchRate,
                        taxWithholdTrans.TaxWithholdExchRateDate);
                }
                else
                {
                    taxWithholdTrans.TaxWithholdBaseAmount  = CurrencyExchangeHelper::curAmount(taxWithholdTrans.WithholdBaseAmount, taxWithholdTrans.TaxWithholdCurrency, taxWithholdTrans.TransDate);
                }

                taxWithholdTrans.PaymTaxWithholdAmount = this.invoice2Payment(taxWithholdTrans.InvoiceTaxWithholdAmount,
                                                                              taxWithholdTrans.InvoiceCurrency,
                                                                              taxWithholdTrans.PaymCurrency,
                                                                              _specTrans.CrossRate,
                                                                              taxWithholdTrans.DataAreaId,
                                                                              taxWithholdTrans.PaymCompany);
                taxWithholdTrans.TaxWithholdAmount = CurrencyExchangeHelper::mstAmount(taxWithholdTrans.InvoiceTaxWithholdAmount,
                                                                                       taxWithholdTrans.InvoiceCurrency,
                                                                                       taxWithholdTrans.TransDate,
                                                                                       UnknownNoYes::Unknown,
                                                                                       exchRate,
                                                                                       exchRateSecond,
                                                                                       triangulation);

                if (isEnabledWHTCurrencyExchRateFeature)
                {
                    taxWithholdTrans.TaxTaxWithholdAmount = this.payment2TaxWithhold(
                        taxWithholdTrans.PaymTaxWithholdAmount,
                        taxWithholdTrans.PaymCurrency,
                        taxWithholdTrans.TaxWithholdCurrency,
                        taxWithholdTrans.TaxWithholdExchRate,
                        taxWithholdTrans.TaxWithholdExchRateDate);
                }
                else
                {
                    taxWithholdTrans.TaxTaxWithholdAmount = CurrencyExchangeHelper::curAmount(
                        taxWithholdTrans.TaxWithholdAmount,
                        taxWithholdTrans.TaxWithholdCurrency,
                        taxWithholdTrans.TransDate,
                        UnknownNoYes::Unknown,
                        exchRate,
                        exchRateSecond,
                        triangulation);
                }

                taxWithholdTrans = this.roundOffTaxWithholdAmount(taxWithholdTrans,
                                                                  tmpTaxWithhold,
                                                                  _specTrans.CrossRate);
                taxWithholdTrans.update();
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSelectedTaxWithholdTrans_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update TaxWithholdIsSelected = true for all selected transactions when
    /// taxWithholdAmount != 0, otherwise TaxWithholdIsSelected = false
    /// making transactions selectable in another tax calculation
    /// </summary>

    protected void updateSelectedTaxWithholdTrans_BR()
    {
        TaxWithholdTrans       taxWithholdTrans;
        boolean more;

        ttsbegin;
        for (more = selectedTaxWithholdTrans.first(taxWithholdTrans);
        more;
        more = selectedTaxWithholdTrans.next(taxWithholdTrans))
        {
            changecompany(taxWithholdTrans.DataAreaId)
            {
                TaxWithholdTrans taxWithholdTransToBeUpdate = TaxWithholdTrans::findByRecId(taxWithholdTrans.RecId, true);
                if (taxWithholdTransToBeUpdate)
                {
                    taxWithholdTransToBeUpdate.TaxWithholdIsSelected_BR = taxWithholdAmount != 0;
                    taxWithholdTransToBeUpdate.RefCustVendTransRecId_BR = custVendTrans.RecId;
                    taxWithholdTransToBeUpdate.doUpdate();
                }
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowedReverseTaxWithHold_BR</Name>
				<Source><![CDATA[
    public static boolean allowedReverseTaxWithHold_BR(TaxWithholdTrans _taxWithholdTrans,
                                                       TransDate        _paymentDate)
    {
        TaxWithholdTrans            rschtaxWithholdTrans;
        date                        periodStart;
        date                        periodEnd;

        periodStart = Global::dateStartMth(_paymentDate);
        periodEnd   = Global::dateEndMth(periodStart);

        // See if any WHT records exist created after this taxWithholdTrans record, is for the same vendor,
        // is for the same month, uses the same code, has WHT calculated, and has not been previously reversed.  If a record
        // is found, then this taxWithholdTrans record was included in WHT of some other payment.  Therefore,
        // this record cannot be reversed.  You must first reverse other WHT trans that occurred after
        // this taxWithholdTrans record.
        select firstonly rschtaxWithholdTrans
        order by RecId asc
        where (rschtaxWithholdTrans.VendAccount                 == _taxWithholdTrans.VendAccount        // Same vendor
              && rschtaxWithholdTrans.TransDate                 >= periodStart                          // Within same month
              && rschtaxWithholdTrans.TransDate                 <= periodEnd
              && rschtaxWithholdTrans.TaxWithholdCode           == _taxWithholdTrans.TaxWithholdCode    // Using same code
              && rschtaxWithholdTrans.RecId                     >  _taxWithholdTrans.RecId              // Record created after taxWithholdTrans
              && rschtaxWithholdTrans.Voucher                   != _taxWithholdTrans.Voucher            // Not posted on the same voucher
              && (rschtaxWithholdTrans.InvoiceTaxWithholdAmount != 0 || rschtaxWithholdTrans.TaxWithholdBaseAmount != 0) // Has WHT calculated
              && rschtaxWithholdTrans.CanBeReversed_BR          == NoYes::Yes);                         // Has not been prviously reversed
        if (rschtaxWithholdTrans)
        {
            throw error("@GLS2210");
            //This record was already considered into the tax withHold amount
            //calculation for the current period
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTaxWithholdAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the Thailand related all kinds of withholding tax amounts.
    /// </summary>
    /// <param name="_taxWithholdTrans">
    /// A <c>TaxWithholdTrans</c> record.
    /// </param>
    /// <param name="_taxWitholdValue">
    /// The tax rate of withholding tax code. It is the percentage * 100.
    /// </param>
    /// <param name="_taxWHTPaymentGrossUpType">
    /// The gross up type of withholding tax payment.
    /// </param>
    protected static void calcTaxWithholdAmount(
        TaxWithholdTrans                    _taxWithholdTrans,
        TaxWithholdValue                    _taxWitholdValue,
        TaxWithholdPaymentGrossUpType       _taxWHTPaymentGrossUpType = TaxWithholdPaymentGrossUpType::TaxDeductible,
        boolean                             _roundOffTaxWithholdAmount = true)
    {
        TaxWithholdTransExtensionTH taxWithholdTransExtensionTH = _taxWithholdTrans.taxWithholdTransExtensionTH();;

        if (TaxWithholdTransExtensionTH.InvoiceCurUpdatedWithholdBaseAmount == 0)
        {
            switch (_taxWHTPaymentGrossUpType)
            {
                case TaxWithholdPaymentGrossUpType::TaxDeductible:
                case TaxWithholdPaymentGrossUpType::Other:
                    TaxWithholdTransExtensionTH.AccountingCurUpdatedWithholdBaseAmt = _taxWithholdTrans.WithholdBaseAmount;
                    break;

                case TaxWithholdPaymentGrossUpType::SingleIteration:
                    TaxWithholdTransExtensionTH.AccountingCurUpdatedWithholdBaseAmt  = CurrencyExchangeHelper::amount(_taxWithholdTrans.WithholdBaseAmount * (1 + _taxWitholdValue / 100));
                    break;

                case TaxWithholdPaymentGrossUpType::Perpetual:
                    if (_taxWitholdValue < 100)
                    {
                        TaxWithholdTransExtensionTH.AccountingCurUpdatedWithholdBaseAmt  = CurrencyExchangeHelper::amount(_taxWithholdTrans.WithholdBaseAmount / (1 - _taxWitholdValue / 100));
                    }
                    else
                    {
                        // The value of withholding tax must be less than 100.
                        throw error("@SYS4082548");
                    }
                    break;

                default:
                    throw error(Error::wrongUseOfFunction(funcName()));
            }

            TaxWithholdTransExtensionTH.InvoiceCurUpdatedWithholdBaseAmount = CurrencyExchangeHelper::curAmount(TaxWithholdTransExtensionTH.AccountingCurUpdatedWithholdBaseAmt, _taxWithholdTrans.InvoiceCurrency, _taxWithholdTrans.TransDate);
        }
        else
        {
            TaxWithholdTransExtensionTH.AccountingCurUpdatedWithholdBaseAmt = CurrencyExchangeHelper::mstAmount(TaxWithholdTransExtensionTH.InvoiceCurUpdatedWithholdBaseAmount, _taxWithholdTrans.InvoiceCurrency, _taxWithholdTrans.TransDate);
        }

        _taxWithholdTrans.TaxWithholdAmount = CurrencyExchangeHelper::amount(TaxWithholdTransExtensionTH.AccountingCurUpdatedWithholdBaseAmt * _taxWitholdValue / 100);

        switch (_taxWHTPaymentGrossUpType)
        {
            case TaxWithholdPaymentGrossUpType::TaxDeductible:
            case TaxWithholdPaymentGrossUpType::Other:
                TaxWithholdTransExtensionTH.AccountingCurExpenseAmount = 0;
                break;

            case TaxWithholdPaymentGrossUpType::SingleIteration:
                TaxWithholdTransExtensionTH.AccountingCurExpenseAmount = (_taxWitholdValue != -100)
                    ? CurrencyExchangeHelper::amount(_taxWithholdTrans.TaxWithholdAmount / (1 + _taxWitholdValue / 100))
                    : 0;
                break;

            case TaxWithholdPaymentGrossUpType::Perpetual:
                TaxWithholdTransExtensionTH.AccountingCurExpenseAmount = _taxWithholdTrans.TaxWithholdAmount;
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        _taxWithholdTrans.SysExtensionSerializerMap::packExtensionTable(taxWithholdTransExtensionTH);

        if (!_roundOffTaxWithholdAmount)
        {
            _taxWithholdTrans.TaxWithholdAmount = TaxWithholdTransExtensionTH.AccountingCurUpdatedWithholdBaseAmt * _taxWitholdValue / 100;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTmpTaxWithhold</Name>
				<Source><![CDATA[
    static TmpTaxWithhold calculateTmpTaxWithhold(CustVendTrans          _custVendTrans,
                                                         TransDate              _taxCalculationDate)
    {
        TaxWithholdCode         taxWithholdCode;
        TaxWithholdTable        taxWithholdTable;
        TaxWithholdData         taxWithholdData;
        TmpTaxWithhold          tmpTaxWithhold;
        AmountMST               taxBaseAmount;
        Map                     mapOfTaxesToCalculate = TaxWithhold::getInvoiceTaxWithholdIntersection_BR(_custVendTrans);
        MapEnumerator           mapEnumerator = mapOfTaxesToCalculate.getEnumerator();

        while (mapEnumerator.moveNext())
        {
            taxWithholdCode = conPeek(mapEnumerator.currentKey(), 2);
            taxBaseAmount   = mapEnumerator.currentValue();

            taxWithholdTable = TaxWithholdTable::find(taxWithholdCode);

            taxWithholdData = TaxWithholdData::find(taxWithholdTable.TaxWithholdCode,
                                                    _taxCalculationDate,
                                                    taxBaseAmount);
            if (taxWithholdData)
            {
                tmpTaxWithhold.TaxWithholdCode     = taxWithholdTable.TaxWithholdCode;
                tmpTaxWithhold.TaxWithholdValue    = taxWithholdData.TaxWithholdValue;
                tmpTaxWithhold.TaxWithholdBase     = taxBaseAmount;
                tmpTaxWithhold.TaxWithholdAmount   = taxBaseAmount * tmpTaxWithhold.TaxWithholdValue / 100;
                tmpTaxWithhold.TaxWithholdTransId  = _custVendTrans.RecId;

                tmpTaxWithhold.insert();
            }
        }
        return tmpTaxWithhold;
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeTaxWithholdExpenseAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates withholding expense amount for specified withholding tax transaction.
    /// </summary>
    /// <param name="_taxWithholdTrans">
    /// A <c>TaxWithholdTrans</c> record.
    /// </param>
    /// <param name="_expenseAmountFieldId">
    /// The field name of expense amount field.
    /// </param>
    public static void changeTaxWithholdExpenseAmount(
        TaxWithholdTrans _taxWithholdTrans,
        FieldName        _expenseAmountFieldId)
    {
        TaxWithholdTransExtensionTH     taxWithholdTransExtensionTH;

        if (_taxWithholdTrans.TaxWithholdCode)
        {
            taxWithholdTransExtensionTH = _taxWithholdTrans.taxWithholdTransExtensionTH();
            switch (_expenseAmountFieldId)
            {
                case fieldStr(TaxWithholdTransExtensionTH, AccountingCurExpenseAmount):
                    taxWithholdTransExtensionTH.TransCurExpenseAmount = CurrencyExchangeHelper::curAmount(taxWithholdTransExtensionTH.AccountingCurExpenseAmount, _taxWithholdTrans.TaxWithholdCurrency, _taxWithholdTrans.TransDate);

                    taxWithholdTransExtensionTH.InvoiceCurExpenseAmount = CurrencyExchangeHelper::curAmount(taxWithholdTransExtensionTH.AccountingCurExpenseAmount, _taxWithholdTrans.InvoiceCurrency, _taxWithholdTrans.TransDate);
                    break;

                case fieldStr(TaxWithholdTransExtensionTH, InvoiceCurExpenseAmount):
                    taxWithholdTransExtensionTH.AccountingCurExpenseAmount = CurrencyExchangeHelper::mstAmount(taxWithholdTransExtensionTH.InvoiceCurExpenseAmount, _taxWithholdTrans.InvoiceCurrency, _taxWithholdTrans.TransDate);

                    taxWithholdTransExtensionTH.TransCurExpenseAmount = CurrencyExchangeHelper::curAmount(taxWithholdTransExtensionTH.AccountingCurExpenseAmount, _taxWithholdTrans.TaxWithholdCurrency, _taxWithholdTrans.TransDate);
                    break;

                case fieldStr(TaxWithholdTransExtensionTH, TransCurExpenseAmount):
                    taxWithholdTransExtensionTH.AccountingCurExpenseAmount = CurrencyExchangeHelper::mstAmount(taxWithholdTransExtensionTH.TransCurExpenseAmount, _taxWithholdTrans.TaxWithholdCurrency, _taxWithholdTrans.TransDate);

                    taxWithholdTransExtensionTH.InvoiceCurExpenseAmount = CurrencyExchangeHelper::curAmount(taxWithholdTransExtensionTH.AccountingCurExpenseAmount, _taxWithholdTrans.InvoiceCurrency, _taxWithholdTrans.TransDate);
                    break;
            }
            _taxWithholdTrans.SysExtensionSerializerMap::packExtensionTable(taxWithholdTransExtensionTH);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeWhtTransAccumBaseAmountToZero_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method change the value of the accumulated WHT transaction used in calculation to zero
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///     The ledgerJournalTrans related to the current WHT Trans
    /// </param>
    /// <param name="_taxWithholdTrans">
    ///     The taxwithhold trans that is being posted
    /// </param>

    protected static void changeWhtTransAccumBaseAmountToZero_BR(LedgerJournalTrans _ledgerJournalTrans, TaxWithholdTrans _taxWithholdTrans)
    {
        TaxWithholdTrans            taxWithholdTrans;
        date                        periodStart;
        date                        periodEnd;

        periodStart = dateStartMth(_ledgerJournalTrans.TransDate);
        periodEnd   = dateEndMth(periodStart);

        while select forupdate taxWithholdTrans
        where (( _ledgerJournalTrans.AccountType == LedgerJournalACType::Cust && taxWithholdTrans.CustAccount == _ledgerJournalTrans.parmAccount())
              || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend && taxWithholdTrans.VendAccount == _ledgerJournalTrans.parmAccount()))
            &&  taxWithholdTrans.TaxWithholdCode                    == _taxWithholdTrans.TaxWithholdCode
            &&  taxWithholdTrans.TransDate                          >= periodStart
            &&  taxWithholdTrans.TransDate                          <= periodEnd
            &&  taxWithholdTrans.TaxWithholdIsSelected_BR           == NoYes::Yes
            &&  taxWithholdTrans.CanBeReversed_BR                   == NoYes::Yes
            &&  taxWithholdTrans.TaxWithholdAccumulatedBaseAmount   != 0
            &&  taxWithholdTrans.InvoiceAmount                      != 0
            &&  taxWithholdTrans.Posted                             == NoYes::Yes
            &&  taxWithholdTrans.RecId                              != _taxWithholdTrans.RecId
        {
            taxWithholdTrans.TaxWithholdAccumulatedBaseAmount = 0;
            taxWithholdTrans.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUniquewithholdrecord_BR</Name>
				<Source><![CDATA[
    static TaxWithholdTrans checkUniquewithholdrecord_BR(TaxWithholdTrans _withholdTransData_BR)
    {
        TaxWithholdTrans withholdTransDataLoc;
        ;

        select withholdTransDataLoc
                where withholdTransDataLoc.LedgerJourTransRecId_BR  == _withholdTransData_BR.LedgerJourTransRecId_BR  &&
                      withholdTransDataLoc.SpecTransId              == _withholdTransData_BR.SpecTransId              &&
                      withholdTransDataLoc.TaxWithholdCode          == _withholdTransData_BR.TaxWithholdCode;

        return withholdTransDataLoc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clear cache used by tax withholding calculations.
    /// </summary>
    public static void clearCache()
    {
        #Tax
        SysGlobalCache cache;

        // clear withholding cache
        cache = SysGlobalCache::construct();
        cache.clear(#TaxWithholdCustPaymCacheKey);
        cache.clear(#TaxWithholdVendPaymCacheKey);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static TaxWithhold construct(LedgerJournalTrans _ledgerJournalTrans)
    {
        switch (_ledgerJournalTrans.AccountType)
        {
            case LedgerJournalACType::Vend : return new TaxWithhold(_ledgerJournalTrans);
            case LedgerJournalACType::Cust : return new TaxWithhold_CustPaym(_ledgerJournalTrans);
        }

        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustTransForReverseTaxWithhold</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates <c>CustTrans</c> records and <c>VendSettlement</c> records to reverse the settled tax
    ///    withholding transaction.
    /// </summary>
    /// <param name="_existingCustTransTaxWithhold">
    ///    The <c>CustTrans</c> record that will be reversed.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher number of the reversal transaction.
    /// </param>
    /// <param name="_reversalTransDate">
    ///    The date of the reversal transaction.
    /// </param>
    public static void createCustTransForReverseTaxWithhold(
        CustTrans _existingCustTransTaxWithhold,
        Voucher _voucher,
        TransDate _reversalTransDate)
    {
        CustTrans       offsetCustTransReversed;
        CustSettlement  custSettlement;
        CustTransOpen   custTransOpen;
        RecId           settlementGroup;

        // create a new vend trans that reverse the vend trans for tax withholding
        offsetCustTransReversed.data(_existingCustTransTaxWithhold);

        offsetCustTransReversed.Voucher = _voucher;
        offsetCustTransReversed.TransDate = _reversalTransDate;

        offsetCustTransReversed.AmountCur = -_existingCustTransTaxWithhold.AmountCur;
        offsetCustTransReversed.AmountMST = -_existingCustTransTaxWithhold.AmountMST;
        offsetCustTransReversed.SettleAmountCur = offsetCustTransReversed.AmountCur;
        offsetCustTransReversed.SettleAmountMST = offsetCustTransReversed.AmountMST;
        offsetCustTransReversed.ExchAdjustment = -_existingCustTransTaxWithhold.ExchAdjustment;
        offsetCustTransReversed.CustExchAdjustmentRealized = -_existingCustTransTaxWithhold.CustExchAdjustmentRealized;
        offsetCustTransReversed.CustExchAdjustmentUnrealized = -_existingCustTransTaxWithhold.CustExchAdjustmentUnrealized;

        offsetCustTransReversed.ReportingCurrencyAmount = -_existingCustTransTaxWithhold.ReportingCurrencyAmount;
        offsetCustTransReversed.SettleAmountReporting = -_existingCustTransTaxWithhold.SettleAmountReporting;
        offsetCustTransReversed.ReportingExchAdjustmentRealized = -_existingCustTransTaxWithhold.ReportingExchAdjustmentRealized;
        offsetCustTransReversed.ReportingExchAdjustmentUnrealized = -_existingCustTransTaxWithhold.ReportingExchAdjustmentUnrealized;
        offsetCustTransReversed.ExchAdjustmentReporting = -_existingCustTransTaxWithhold.ExchAdjustmentReporting;

        offsetCustTransReversed.LastSettleDate = _reversalTransDate;
        offsetCustTransReversed.LastSettleVoucher = _existingCustTransTaxWithhold.Voucher;
        offsetCustTransReversed.LastSettleAccountNum = _existingCustTransTaxWithhold.AccountNum;
        offsetCustTransReversed.LastSettleCompany = _existingCustTransTaxWithhold.DataAreaId;
        offsetCustTransReversed.OffsetRecid = _existingCustTransTaxWithhold.RecId;

        offsetCustTransReversed.Closed = _reversalTransDate;

        offsetCustTransReversed.Txt = strFmt('%1 %2', "@SYS110624", _existingCustTransTaxWithhold.Txt);

        offsetCustTransReversed.insert();

        // update the existing tax withhold vend trans record
        _existingCustTransTaxWithhold.SettleAmountMST = _existingCustTransTaxWithhold.AmountMST;
        _existingCustTransTaxWithhold.SettleAmountCur = _existingCustTransTaxWithhold.AmountCur;
        _existingCustTransTaxWithhold.SettleAmountReporting = _existingCustTransTaxWithhold.ReportingCurrencyAmount;

        _existingCustTransTaxWithhold.LastSettleDate = _reversalTransDate;
        _existingCustTransTaxWithhold.LastSettleVoucher = offsetCustTransReversed.Voucher;
        _existingCustTransTaxWithhold.LastSettleAccountNum = offsetCustTransReversed.AccountNum;
        _existingCustTransTaxWithhold.LastSettleCompany = offsetCustTransReversed.DataAreaId;

        _existingCustTransTaxWithhold.Closed = _reversalTransDate;
        _existingCustTransTaxWithhold.OffsetRecid = offsetCustTransReversed.RecId;
        _existingCustTransTaxWithhold.update();

        delete_from custTransOpen
            where custTransOpen.RefRecId == _existingCustTransTaxWithhold.RecId;

        // create settlement records
        custSettlement.initFromCustTrans(_existingCustTransTaxWithhold);
        custSettlement.CanBeReversed = NoYes::No;
        custSettlement.SettlementVoucher = _voucher;
        custSettlement.insert();

        // update the settlement group
        settlementGroup = custSettlement.RecId;
        custSettlement.SettlementGroup = settlementGroup;
        custSettlement.update();

        custSettlement.initFromCustTrans(offsetCustTransReversed);
        custSettlement.CanBeReversed = NoYes::No;
        custSettlement.SettlementVoucher = _voucher;
        custSettlement.SettlementGroup = settlementGroup;
        custSettlement.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustVendTransForReverse</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates <c>CustVendTrans</c> records and <c>CustVendSettlement</c> records to reverse the settled tax
    ///    withholding transaction.
    /// </summary>
    /// <param name="_existingCustVendTransTaxWithhold">
    ///    The <c>CustVendTrans</c> record that will be reversed.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher number of the reversal transaction.
    /// </param>
    /// <param name="_reversalTransDate">
    ///    The date of the reversal transaction.
    /// </param>
    public static void createCustVendTransForReverse(
        CustVendTrans   _existingCustVendTransTaxWithhold,
        Voucher         _voucher,
        TransDate       _reversalTransDate)
    {
        CustVendTrans       offsetCustVendTransReversed;
        CustVendSettlement  custVendSettlement;
        CustVendTransOpen   custVendTransOpen;
        RecId               settlementGroup;
        ModuleCustVend      moduleCustVend;

        // Init the map buffer
        moduleCustVend              = (_existingCustVendTransTaxWithhold.TableId == tableNum(VendTrans)) ? ModuleCustVend::Vend : ModuleCustVend::Cust;
        offsetCustVendTransReversed = CustVendTrans::getEmptyTableBuffer(moduleCustVend);
        custVendSettlement          = CustVendSettlement::getEmptyTableBuffer(moduleCustVend);
        custVendTransOpen           = CustVendTransOpen::getEmptyTableBuffer(moduleCustVend);

        // create a new cust/vend trans that reverse the vend trans for tax withholding
        offsetCustVendTransReversed.data(_existingCustVendTransTaxWithhold);

        offsetCustVendTransReversed.Voucher = _voucher;
        offsetCustVendTransReversed.TransDate = _reversalTransDate;

        offsetCustVendTransReversed.AmountCur                   = -_existingCustVendTransTaxWithhold.AmountCur;
        offsetCustVendTransReversed.AmountMST                   = -_existingCustVendTransTaxWithhold.AmountMST;
        offsetCustVendTransReversed.SettleAmountCur             = offsetCustVendTransReversed.AmountCur;
        offsetCustVendTransReversed.SettleAmountMST             = offsetCustVendTransReversed.AmountMST;
        offsetCustVendTransReversed.ExchAdjustment              = -_existingCustVendTransTaxWithhold.ExchAdjustment;
        offsetCustVendTransReversed.ExchAdjustmentRealized      = -_existingCustVendTransTaxWithhold.ExchAdjustmentRealized;
        offsetCustVendTransReversed.ExchAdjustmentUnrealized    = -_existingCustVendTransTaxWithhold.ExchAdjustmentUnrealized;

        offsetCustVendTransReversed.ReportingCurrencyAmount             = -_existingCustVendTransTaxWithhold.ReportingCurrencyAmount;
        offsetCustVendTransReversed.SettleAmountReporting               = offsetCustVendTransReversed.ReportingCurrencyAmount;
        offsetCustVendTransReversed.ReportingExchAdjustmentRealized     = -_existingCustVendTransTaxWithhold.ReportingExchAdjustmentRealized;
        offsetCustVendTransReversed.ReportingExchAdjustmentUnrealized   = -_existingCustVendTransTaxWithhold.ReportingExchAdjustmentUnrealized;
        offsetCustVendTransReversed.ExchAdjustmentReporting             = -_existingCustVendTransTaxWithhold.ExchAdjustmentReporting;

        offsetCustVendTransReversed.LastSettleDate          = _reversalTransDate;
        offsetCustVendTransReversed.LastSettleVoucher       = _existingCustVendTransTaxWithhold.Voucher;
        offsetCustVendTransReversed.LastSettleAccountNum    = _existingCustVendTransTaxWithhold.AccountNum;
        offsetCustVendTransReversed.LastSettleCompany       = _existingCustVendTransTaxWithhold.DataAreaId;
        offsetCustVendTransReversed.OffsetRecId             = _existingCustVendTransTaxWithhold.RecId;

        offsetCustVendTransReversed.Closed = _reversalTransDate;

        offsetCustVendTransReversed.Txt = strFmt('%1 %2', "@SYS110624", _existingCustVendTransTaxWithhold.Txt);

        offsetCustVendTransReversed.insert();

        // update the existing tax withhold vend trans record
        _existingCustVendTransTaxWithhold.SettleAmountMST       = _existingCustVendTransTaxWithhold.AmountMST;
        _existingCustVendTransTaxWithhold.SettleAmountCur       = _existingCustVendTransTaxWithhold.AmountCur;
        _existingCustVendTransTaxWithhold.SettleAmountReporting = _existingCustVendTransTaxWithhold.ReportingCurrencyAmount;

        _existingCustVendTransTaxWithhold.LastSettleDate        = _reversalTransDate;
        _existingCustVendTransTaxWithhold.LastSettleVoucher     = offsetCustVendTransReversed.Voucher;
        _existingCustVendTransTaxWithhold.LastSettleAccountNum  = offsetCustVendTransReversed.AccountNum;
        _existingCustVendTransTaxWithhold.LastSettleCompany     = offsetCustVendTransReversed.DataAreaId;

        _existingCustVendTransTaxWithhold.Closed = _reversalTransDate;
        _existingCustVendTransTaxWithhold.OffsetRecId = offsetCustVendTransReversed.RecId;
        _existingCustVendTransTaxWithhold.update();

        delete_from custVendTransOpen
            where custVendTransOpen.RefRecId == _existingCustVendTransTaxWithhold.RecId;

        // create settlement records
        custVendSettlement.CustVendSettlement::initFromCustVendTrans(_existingCustVendTransTaxWithhold);
        custVendSettlement.CanBeReversed        = NoYes::No;
        custVendSettlement.SettlementVoucher    = _voucher;
        custVendSettlement.insert();

        // update the settlement group
        settlementGroup = custVendSettlement.RecId;
        custVendSettlement.SettlementGroup = settlementGroup;
        custVendSettlement.update();

        custVendSettlement.CustVendSettlement::initFromCustVendTrans(offsetCustVendTransReversed);
        custVendSettlement.CanBeReversed        = NoYes::No;
        custVendSettlement.SettlementVoucher    = _voucher;
        custVendSettlement.SettlementGroup      = settlementGroup;
        custVendSettlement.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createVendTransForReverseTaxWithhold</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates <c>VendTrans</c> records and <c>VendSettlement</c> records to reverse the settled tax
    ///    withholding transaction.
    /// </summary>
    /// <param name="_existingVendTransTaxWithhold">
    ///    The <c>VendTrans</c> record that will be reversed.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher number of the reversal transaction.
    /// </param>
    /// <param name="_reversalTransDate">
    ///    The date of the reversal transaction.
    /// </param>
    public static void createVendTransForReverseTaxWithhold(
        VendTrans _existingVendTransTaxWithhold,
        Voucher _voucher,
        TransDate _reversalTransDate)
    {
        VendTrans offsetVendTransReversed;
        VendSettlement  vendSettlement;
        VendTransOpen   vendTransOpen;
        RecId           settlementGroup;

        // create a new vend trans that reverse the vend trans for tax withholding
        offsetVendTransReversed.data(_existingVendTransTaxWithhold);

        offsetVendTransReversed.Voucher = _voucher;
        offsetVendTransReversed.TransDate = _reversalTransDate;

        offsetVendTransReversed.AmountCur = -_existingVendTransTaxWithhold.AmountCur;
        offsetVendTransReversed.AmountMST = -_existingVendTransTaxWithhold.AmountMST;
        offsetVendTransReversed.SettleAmountCur = offsetVendTransReversed.AmountCur;
        offsetVendTransReversed.SettleAmountMST = offsetVendTransReversed.AmountMST;
        offsetVendTransReversed.ExchAdjustment = -_existingVendTransTaxWithhold.ExchAdjustment;
        offsetVendTransReversed.VendExchAdjustmentRealized = -_existingVendTransTaxWithhold.VendExchAdjustmentRealized;
        offsetVendTransReversed.VendExchAdjustmentUnrealized = -_existingVendTransTaxWithhold.VendExchAdjustmentUnrealized;

        offsetVendTransReversed.ReportingCurrencyAmount = -_existingVendTransTaxWithhold.ReportingCurrencyAmount;
        offsetVendTransReversed.SettleAmountReporting = offsetVendTransReversed.ReportingCurrencyAmount;
        offsetVendTransReversed.ReportingExchAdjustmentRealized = -_existingVendTransTaxWithhold.ReportingExchAdjustmentRealized;
        offsetVendTransReversed.ReportingExchAdjustmentUnrealized = -_existingVendTransTaxWithhold.ReportingExchAdjustmentUnrealized;
        offsetVendTransReversed.ExchAdjustmentReporting = -_existingVendTransTaxWithhold.ExchAdjustmentReporting;

        offsetVendTransReversed.LastSettleDate = _reversalTransDate;
        offsetVendTransReversed.LastSettleVoucher = _existingVendTransTaxWithhold.Voucher;
        offsetVendTransReversed.LastSettleAccountNum = _existingVendTransTaxWithhold.AccountNum;
        offsetVendTransReversed.LastSettleCompany = _existingVendTransTaxWithhold.DataAreaId;
        offsetVendTransReversed.OffsetRecid = _existingVendTransTaxWithhold.RecId;

        offsetVendTransReversed.Closed = _reversalTransDate;

        offsetVendTransReversed.Txt = strFmt('%1 %2', "@SYS110624", _existingVendTransTaxWithhold.Txt);

        offsetVendTransReversed.insert();

        // update the existing tax withhold vend trans record
        _existingVendTransTaxWithhold.SettleAmountMST = _existingVendTransTaxWithhold.AmountMST;
        _existingVendTransTaxWithhold.SettleAmountCur = _existingVendTransTaxWithhold.AmountCur;
        _existingVendTransTaxWithhold.SettleAmountReporting = _existingVendTransTaxWithhold.ReportingCurrencyAmount;

        _existingVendTransTaxWithhold.LastSettleDate = _reversalTransDate;
        _existingVendTransTaxWithhold.LastSettleVoucher = offsetVendTransReversed.Voucher;
        _existingVendTransTaxWithhold.LastSettleAccountNum = offsetVendTransReversed.AccountNum;
        _existingVendTransTaxWithhold.LastSettleCompany = offsetVendTransReversed.DataAreaId;

        _existingVendTransTaxWithhold.Closed = _reversalTransDate;
        _existingVendTransTaxWithhold.OffsetRecid = offsetVendTransReversed.RecId;
        _existingVendTransTaxWithhold.update();

        delete_from vendTransOpen
            where vendTransOpen.RefRecId == _existingVendTransTaxWithhold.RecId;

        // create settlement records
        vendSettlement.initFromVendTrans(_existingVendTransTaxWithhold);
        vendSettlement.CanBeReversed = NoYes::No;
        vendSettlement.SettlementVoucher = _voucher;
        vendSettlement.insert();

        // update the settlement group
        settlementGroup = vendSettlement.RecId;
        vendSettlement.SettlementGroup = settlementGroup;
        vendSettlement.update();

        vendSettlement.initFromVendTrans(offsetVendTransReversed);
        vendSettlement.CanBeReversed = NoYes::No;
        vendSettlement.SettlementVoucher = _voucher;
        vendSettlement.SettlementGroup = settlementGroup;
        vendSettlement.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustInvoiceTaxWithholdIntersection_BR</Name>
				<Source><![CDATA[
    private static Map getCustInvoiceTaxWithholdIntersection_BR(CustTrans _custTrans)
    {
        CustInvoiceTrans        custInvoiceTrans;
        CustInvoiceJour         custInvoiceJour;

        ProjInvoiceTransTaxWithholdGroups_BR projInvoiceTransTaxWithholdGroups;
        ProjInvoiceJour                      projInvoiceJour;

        Map                     mapOfTaxesToCalculate = new Map(Types::Container, Types::Real);

        if (_custTrans.TransType != LedgerTransType::Project)
        {
            custInvoiceJour = CustInvoiceJour::findFromCustTrans(_custTrans.Invoice,
                                                                 _custTrans.TransDate,
                                                                 _custTrans.AccountNum);

            while select TaxWithholdGroup_TH, TaxWithholdItemGroupHeading_TH, LineAmount from custInvoiceTrans
                where custInvoiceTrans.SalesId              == custInvoiceJour.SalesId
                    && custInvoiceTrans.InvoiceDate         == custInvoiceJour.InvoiceDate
                    && custInvoiceTrans.InvoiceId           == custInvoiceJour.InvoiceId
                    && custInvoiceTrans.NumberSequenceGroup == custInvoiceJour.NumberSequenceGroup
            {
                TaxWithhold::getTaxWithholdIntersection_BR(mapOfTaxesToCalculate, custInvoiceTrans.TaxWithholdGroup_TH, custInvoiceTrans.TaxWithholdItemGroupHeading_TH, custInvoiceTrans.LineAmount);
            }
        }
        else
        {
            projInvoiceJour = ProjInvoiceJour::find(_custTrans.Invoice, _custTrans.TransDate);

            while select projInvoiceTransTaxWithholdGroups
                    where projInvoiceTransTaxWithholdGroups.ProjInvoiceJour == projInvoiceJour.RecId
            {
                TaxWithhold::getTaxWithholdIntersection_BR(mapOfTaxesToCalculate, projInvoiceTransTaxWithholdGroups.TaxWithholdGroup, projInvoiceTransTaxWithholdGroups.TaxWithholdItemGroupHeading_TH, projInvoiceTransTaxWithholdGroups.LineAmountCur);
            }
        }

        TaxWithhold::excludeICMSOrISSFromTaxWithholdBase(_custTrans, mapOfTaxesToCalculate);

        return mapOfTaxesToCalculate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalInvoiceTaxWithholdBaseAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total invoice line amount for withholding tax base.
    /// </summary>
    /// <param name = "_custVendTrans">The customer or vendor transaction.</param>
    /// <returns>The total invoice amount.</returns>
    public static Amount getTotalInvoiceTaxWithholdBaseAmount_BR(CustVendTrans _custVendTrans)
    {
        Amount withholdBaseAmount;
        if (_custVendTrans.TableId == tableNum(CustTrans))
        {
            CustTrans custTrans = _custVendTrans;
            if (custTrans.TransType != LedgerTransType::Project)
            {
                CustInvoiceJour custInvoiceJour = CustInvoiceJour::findFromCustTrans(custTrans.Invoice, custTrans.TransDate, custTrans.AccountNum);

                CustInvoiceTrans custInvoiceTrans;
                select sum(LineAmount) from custInvoiceTrans
                    where custInvoiceTrans.SalesId  == custInvoiceJour.SalesId
                        && custInvoiceTrans.InvoiceDate == custInvoiceJour.InvoiceDate
                        && custInvoiceTrans.InvoiceId == custInvoiceJour.InvoiceId
                        && custInvoiceTrans.NumberSequenceGroup == custInvoiceJour.NumberSequenceGroup;
               
                withholdBaseAmount = custInvoiceTrans.LineAmount;
            }
            else
            {
                ProjInvoiceJour projInvoiceJour = ProjInvoiceJour::find(custTrans.Invoice, custTrans.TransDate);

                ProjInvoiceTransTaxWithholdGroups_BR projInvoiceTransTaxWithholdGroups;
                select sum(LineAmountCur) from projInvoiceTransTaxWithholdGroups
                    where projInvoiceTransTaxWithholdGroups.ProjInvoiceJour == projInvoiceJour.RecId;

                withholdBaseAmount = projInvoiceTransTaxWithholdGroups.LineAmountCur;
            }
        }
        else if (_custVendTrans.TableId == tableNum(VendTrans))
        {
            VendTrans vendTrans = _custVendTrans;
            VendInvoiceJour vendInvoiceJour = VendInvoiceJour::findFromVendTrans(vendTrans.Invoice, vendTrans.TransDate, vendTrans.AccountNum);

            VendInvoiceTrans vendInvoiceTrans;
            select sum(LineAmount) from vendInvoiceTrans
                where vendInvoiceTrans.PurchID  == vendInvoiceJour.PurchId
                    && vendInvoiceTrans.InvoiceDate == vendInvoiceJour.InvoiceDate
                    && vendInvoiceTrans.InvoiceId == vendInvoiceJour.InvoiceId
                    && vendInvoiceTrans.NumberSequenceGroup == vendInvoiceJour.NumberSequenceGroup;

            withholdBaseAmount = vendInvoiceTrans.LineAmount;
        }

        return withholdBaseAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceTaxWithholdIntersection_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns a map of withhold tax code and realted base amount
    /// </summary>
    /// <param name="_custVendTrans">
    ///     The <c>CustVendTrans</c> recors.
    /// </param>
    /// <returns>
    ///  Map of withhold tax code and realted base amount
    /// </returns>

    public static Map getInvoiceTaxWithholdIntersection_BR(CustVendTrans _custVendTrans)
    {
        if (_custVendTrans.TableId == tableNum(CustTrans))
        {
            return TaxWithhold::getCustInvoiceTaxWithholdIntersection_BR(_custVendTrans);
        }
        else if (_custVendTrans.TableId == tableNum(VendTrans))
        {
            return TaxWithhold::getVendInvoiceTaxWithholdIntersection_BR(_custVendTrans);
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxWithholdIntersection_BR</Name>
				<Source><![CDATA[
    private static void getTaxWithholdIntersection_BR(Map _mapOfTaxesToCalculate, TaxWithholdGroup _taxWithholdGroup, RecId _taxWithholdItemGroup, TaxWithholdBase _baseAmount)
    {
        TaxWithholdOnItem_TH    taxWithholdOnItem_TH;
        TaxWithholdGroupData    taxWithholdGroupData;
        TaxWithholdBase         taxWithholdBase;
        container               key;

        while select TaxWithholdCode
            from taxWithholdOnItem_TH
            where taxWithholdOnItem_TH.TaxWithholdItemGroupHeading_TH == _taxWithholdItemGroup
                     join TaxWithholdGroup from taxWithholdGroupData
                        where taxWithholdGroupData.TaxWithholdGroup == _taxWithholdGroup
                            && taxWithholdOnItem_TH.TaxWithholdCode == taxWithholdGroupData.TaxWithholdCode
        {
            key = [taxWithholdGroupData.TaxWithholdGroup, taxWithholdOnItem_TH.TaxWithholdCode];

            if (!_mapOfTaxesToCalculate.exists(key))
            {
                _mapOfTaxesToCalculate.insert(key, _baseAmount);
            }
            else
            {
                taxWithholdBase = _mapOfTaxesToCalculate.lookup(key);
                taxWithholdBase += _baseAmount;

                _mapOfTaxesToCalculate.insert(key, taxWithholdBase);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceTaxAmountByTaxType_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets total sales tax amount for a given Cust/Vend transaction and specific Brazilian tax type,
    /// will be used for Brazilian withholding calculation, return will exclude MarkUpTrans as Brazilian doesn't support WHT on Charges.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The <c>VendTrans</c> or <c>CustTrans</c> record to get total sales tax amount.
    /// </param>
    /// <param name="_taxType">
    /// The specific Brazilian tax type.
    /// </param>
    /// <returns>
    /// Total sales tax amount for a given Cust/Vend transaction and specific Brazilian tax type.
    /// </returns>
    private static AmountCur getInvoiceTaxAmountByTaxType_BR(CustVendTrans _custVendTrans, TaxType_BR _taxType)
    {
        TaxTrans taxTrans;
        TaxTable taxTable;
        boolean isCustomer;

        if (_custVendTrans.TableId == TableNum(CustTrans))
        {
            isCustomer = true;
        }

        select sum(SourceRegulateAmountCur) from taxTrans
            exists join taxTable
                where taxTable.TaxType_BR == _taxType
                    && taxTable.IncludedTax_BR == NoYes::Yes
                    && taxTrans.TaxCode == taxTable.TaxCode
                    && taxTrans.Voucher == _custVendTrans.Voucher
                    && taxTrans.TransDate == _custVendTrans.TransDate
                    && taxTrans.SourceTableId != tableNum(MarkupTrans)
                    && (isCustomer || taxTrans.TaxDirection != TaxDirection::UseTax);

        return isCustomer ? -1 * taxTrans.SourceRegulateAmountCur : taxTrans.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>excludeICMSOrISSFromTaxWithholdBase</Name>
				<Source><![CDATA[
    /// <summary>
    /// For withholding tax base type per gross/gross of month, deduct the total ICMS/ISS tax amount of an invoice from PIS/COFINS withholding basis.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The <c>VendTrans</c> or <c>CustTrans</c> record to get total ICMS/ISS tax amount.
    /// </param>
    /// <param name="_mapOfTaxesToCalculate">
    /// Map buffer of withhold tax code and related base amount.
    /// </param>
    private static void excludeICMSOrISSFromTaxWithholdBase(CustVendTrans _custVendTrans, Map _mapOfTaxesToCalculate)
    {
        TaxWithholdTable taxWithholdTable;
        TaxWithholdCode taxWithholdCode;
        TaxWithholdBase taxWithholdBase;
        MapEnumerator mapEnumerator = _mapOfTaxesToCalculate.getEnumerator();

        while (mapEnumerator.moveNext())
        {
            taxWithholdBase = mapEnumerator.currentValue();
            taxWithholdCode = conPeek(mapEnumerator.currentKey(), 2);
            taxWithholdTable = TaxWithholdTable::find(taxWithholdCode);

            if (taxWithholdTable.TaxWithholdBaseType != TaxWithholdBaseType::PctPerNet
                && (taxWithholdTable.TaxWithholdType_BR == TaxWithholdType_BR::PIS
                    || taxWithholdTable.TaxWithholdType_BR == TaxWithholdType_BR::COFINS))
            {
                if (taxWithholdTable.ExcludeICMS_BR)
                {
                    taxWithholdBase -= TaxWithhold::getInvoiceTaxAmountByTaxType_BR(_custVendTrans, TaxType_BR::ICMS);
                }

                if (taxWithholdTable.ExcludeISS_BR)
                {
                    taxWithholdBase -= TaxWithhold::getInvoiceTaxAmountByTaxType_BR(_custVendTrans, TaxType_BR::ISS);
                }

                _mapOfTaxesToCalculate.insert(mapEnumerator.currentKey(), taxWithholdBase);
            }
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>getVendInvoiceTaxWithholdIntersection_BR</Name>
				<Source><![CDATA[
    private static Map getVendInvoiceTaxWithholdIntersection_BR(VendTrans _vendTrans)
    {
        VendInvoiceTrans        vendInvoiceTrans;
        VendInvoiceJour         vendInvoiceJour;
        Map                     mapOfTaxesToCalculate = new Map(Types::Container, Types::Real);

        vendInvoiceJour = VendInvoiceJour::findFromVendTrans(_vendTrans.Invoice,
                                                            _vendTrans.TransDate,
                                                            _vendTrans.AccountNum);

        while select TaxWithholdGroup_TH, TaxWithholdItemGroupHeading_TH, LineAmount from vendInvoiceTrans
            where vendInvoiceTrans.PurchID              == vendInvoiceJour.PurchId
                && vendInvoiceTrans.InvoiceDate         == vendInvoiceJour.InvoiceDate
                && vendInvoiceTrans.InvoiceId           == vendInvoiceJour.InvoiceId
                && vendInvoiceTrans.NumberSequenceGroup == vendInvoiceJour.NumberSequenceGroup
        {
            TaxWithhold::getTaxWithholdIntersection_BR(mapOfTaxesToCalculate, vendInvoiceTrans.TaxWithholdGroup_TH, vendInvoiceTrans.TaxWithholdItemGroupHeading_TH, vendInvoiceTrans.LineAmount);
        }

        TaxWithhold::excludeICMSOrISSFromTaxWithholdBase(_vendTrans, mapOfTaxesToCalculate);

        return mapOfTaxesToCalculate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasWithhold_BR</Name>
				<Source><![CDATA[
    public static boolean hasWithhold_BR(CustVendTransOpen _transaction, LedgerJournalTrans _ledgerJournalTrans)
    {
        container               dataAreaIdList = new TaxWithhold(_ledgerJournalTrans).crossCompanyList_BR();

        return ( select firstonly crosscompany : dataAreaIdList count(RecId) from taxWithholdTrans
                        where   taxWithholdTrans.LedgerJourTransRecId_BR    == _ledgerJournalTrans.RecId
                            &&  taxWithholdTrans.CustVendTransOpenRecId_BR  == _transaction.RecId).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hideReversedTaxWithholdTransInPair</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the offset of reversed <c>TaxWithholdTrans</c> of the specified one to make them
    /// have the same status about "Hide in reports".
    /// </summary>
    /// <param name="_taxWithholdTrans">
    /// The specified <c>TaxWithholdTrans</c> record that has a new status of "Hide in reports"
    /// </param>
    /// <returns>
    /// true if success to find and update the offset record; otherwise, return false.
    /// </returns>
    public static boolean hideReversedTaxWithholdTransInPair(TaxWithholdTrans _taxWithholdTrans)
    {
        TaxWithholdTrans                taxWithholdTransOffset;
        TaxWithholdTransExtensionTH     taxWithholdTransExtensionTHOffset;
        FieldId                         taxWithholdCustVendTransPaymFieldId;
        TaxWithholdTransHideInReports   newHideValue;

        if (_taxWithholdTrans.RecId && _taxWithholdTrans.Posted == NoYes::Yes)
        {
            // The pair of revered TaxWithholdTrans should have same *TransPaymId.
            // And there should be no more than 2 records have same *TransPaymId.

            // Find the field id of *TransPaymId field.
            if (_taxWithholdTrans.VendAccount)
            {
                taxWithholdCustVendTransPaymFieldId = fieldNum(TaxWithholdTrans, VendTransPaymId);
            }
            else if (_taxWithholdTrans.CustAccount)
            {
                taxWithholdCustVendTransPaymFieldId = fieldNum(TaxWithholdTrans, CustTransPaymId);
            }

            if (taxWithholdCustVendTransPaymFieldId)
            {
                newHideValue = _taxWithholdTrans.taxWithholdTransExtensionTH().HideInReports;

                select forupdate firstonly HideInReports
                    from taxWithholdTransExtensionTHOffset
                        where taxWithholdTransExtensionTHOffset.HideInReports != newHideValue
                    exists join taxWithholdTransOffset
                        where taxWithholdTransOffset.RecId                                  == taxWithholdTransExtensionTHOffset.TaxWithholdTrans
                            && taxWithholdTransOffset.(taxWithholdCustVendTransPaymFieldId) == _taxWithholdTrans.(taxWithholdCustVendTransPaymFieldId)
                            && taxWithholdTransOffset.RecId                                 != _taxWithholdTrans.RecId;

                if (taxWithholdTransExtensionTHOffset.RecId)
                {
                    ttsbegin;
                    taxWithholdTransExtensionTHOffset.HideInReports = newHideValue;
                    taxWithholdTransExtensionTHOffset.update();
                    ttscommit;

                    return true;
                }
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupTaxWithholdCodeBasedOnGroups</Name>
				<Source><![CDATA[
    /// <summary>
    /// Looks up the withholding tax code based on given withholding tax group and item group.
    /// </summary>
    /// <param name="_ctrl">
    /// The form control to be looked up.
    /// </param>
    /// <param name="_taxWithholdGroup">
    /// The withholding tax group.
    /// </param>
    /// <param name="_taxWithholdItemGroup">
    /// The withholding tax item group.
    /// </param>
    public static void lookupTaxWithholdCodeBasedOnGroups(
        FormStringControl           _ctrl,
        TaxWithholdGroup            _taxWithholdGroup,
        TaxWithholdItemGroupId_TH   _taxWithholdItemGroup)
    {
        SysTableLookup          sysTableLookup = SysTableLookup::newParameters(tableNum(TaxWithholdTable), _ctrl);
        Query                   query;
        QueryBuildDataSource    rootQueryBuildDataSource;
        QueryBuildDataSource    queryBuildDataSource;

        query = new Query();
        rootQueryBuildDataSource = query.addDataSource(tableNum(TaxWithholdTable));

        queryBuildDataSource = rootQueryBuildDataSource.addDataSource(tableNum(TaxWithholdGroupData));
        queryBuildDataSource.relations(true);
        queryBuildDataSource.joinMode(JoinMode::ExistsJoin);
        queryBuildDataSource.addRange(fieldNum(TaxWithholdGroupData, TaxWithholdGroup)).value(SysQuery::value(_taxWithholdGroup));

        queryBuildDataSource = rootQueryBuildDataSource.addDataSource(tableNum(TaxWithholdOnItem_TH));
        queryBuildDataSource.relations(true);
        queryBuildDataSource.joinMode(JoinMode::ExistsJoin);
        queryBuildDataSource.addRange(fieldNum(TaxWithholdOnItem_TH, TaxWithholdItemGroupHeading_TH)).value(SysQuery::value(_taxWithholdItemGroup));

        sysTableLookup.parmQuery(query);
        sysTableLookup.addLookupfield(fieldNum(TaxWithholdTable, TaxWithholdCode), true);
        sysTableLookup.addLookupfield(fieldNum(TaxWithholdTable, TaxWithholdName));
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>markRelatedTaxWithholdSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// For all already been marked transactions, mark related withholding tax voucher transactions.
    /// </summary>
    /// <param name="_specReference">
    /// The reference buffer which transactions are marked for.
    /// </param>
    public static void markRelatedTaxWithholdSettlement(Common _specReference)
    {
        SpecTrans           specTrans;
        CustVendSettlement  custVendSettlement;
        CustVendTrans       custVendTrans;
        SpecTransManager    specTransManager;
        boolean             isMapBufferDetermined = false;

        if (_specReference && _specReference.RecId)
        {
            specTransManager = SpecTransManager::newFromSpec(_specReference);

            switch (_specReference.TableId)
            {
                case tableNum(VendTable):
                    custVendSettlement      = CustVendSettlement::getEmptyTableBuffer(ModuleCustVend::Vend);
                    isMapBufferDetermined   = true;
                    break;

                case tableNum(CustTable):
                    custVendSettlement      = CustVendSettlement::getEmptyTableBuffer(ModuleCustVend::Cust);
                    isMapBufferDetermined   = true;
                    break;
            }

            if (isMapBufferDetermined)
            {
                custVendTrans = custVendSettlement.CustVendSettlement::custVendTrans();

                ttsbegin;

                // For each already marked voucher, mark all other possible lines for related WHT voucher
                while select crosscompany Voucher, TransDate
                    from custVendTrans
                    exists join custVendSettlement
                        where custVendSettlement.TransRecId     == custVendTrans.RecId
                            && custVendSettlement.AccountNum    == custVendTrans.AccountNum
                            && custVendSettlement.TransCompany  == custVendTrans.DataAreaId
                            && custVendSettlement.CanBeReversed == NoYes::Yes
                        exists join specTrans
                            where specTrans.SpecTableId     == _specReference.TableId
                                && specTrans.SpecRecId      == _specReference.RecId
                                && specTrans.SpecCompany    == _specReference.company()
                                && specTrans.RefRecId       == custVendSettlement.RecId
                                && specTrans.RefCompany     == custVendSettlement.DataAreaId
                {
                    custVendSettlement.CustVendSettlement::markRelatedTaxWithholdVoucher(
                        specTransManager,
                        custVendTrans.Voucher,
                        custVendTrans.TransDate);
                }

                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markRelatedVouchers_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks releated tax withold settlement records when the payment
    /// transaction is marked.
    /// </summary>
    /// <param name="_currencyCode">
    /// The currency for the settlement record.
    /// </param>
    /// <param name="_vendSettlement">
    /// The VendSettlement record that is being marked.
    /// </param>
    /// <param name="_specification">
    /// The current <c>SpecTransManager</c> instance containing marked settlements for reversal.
    /// </param>
    /// <remarks>
    /// Method is called any time a payment settlement records is marked
    /// for reversal since tax withhold transactions should always be reversed
    /// when reversing the payment.
    /// </remarks>
    static void markRelatedVouchers_BR(
        CurrencyCode        _currencyCode,
        CustVendSettlement  _vendSettlement,
        SpecTransManager    _specification)
    {
        CustTrans               custTrans;
        CustSettlement          custSettlement;
        VendTrans               vendTrans;
        VendSettlement          vendSettlement;

        CustVendSettlement      custVendSettlement;
        boolean                 payment = false;
        CustVendTrans           custVendTrans;

        if (_vendSettlement.TableId == tableNum(CustSettlement))
        {
            custVendSettlement = custSettlement;
            custVendTrans = custTrans;

            if (_vendSettlement.SettleAmountCur > 0)
            {
                payment = true;
            }
        }
        else if (_vendSettlement.TableId == tableNum(VendSettlement))
        {
            custVendSettlement = vendSettlement;
            custVendTrans = vendTrans;

            if (_vendSettlement.SettleAmountCur < 0)
            {
                payment = true;
            }
        }

        if (payment)
        {
            while select crosscompany custVendSettlement where
                custVendSettlement.TransRecId    == _vendSettlement.TransRecId &&
                custVendSettlement.TransCompany  == _vendSettlement.TransCompany &&
                custVendSettlement.CanBeReversed == true &&
                custVendSettlement.TransDate     == _vendSettlement.TransDate &&
                custVendSettlement.AccountNum    == _vendSettlement.AccountNum &&
                custVendSettlement.RecId         != _vendSettlement.RecId
            {
                custVendTrans = custVendSettlement.custVendTrans();

                // Only want payments, invoices, or withholding tax  Vend type is used for withholding tax.
                if (custVendTrans.TransType == LedgerTransType::Vend     ||
                    custVendTrans.TransType == LedgerTransType::None    ||
                    custVendTrans.TransType == LedgerTransType::Payment ||
                    custVendTrans.TransType == LedgerTransType::Purch   ||
                    custVendTrans.TransType == LedgerTransType::Cust    ||
                    custVendTrans.TransType == LedgerTransType::Sales)
                {
                    if ( custVendSettlement && _specification.existForOtherSpec(_vendSettlement.DataAreaId, _vendSettlement.TableId, _vendSettlement.RecId) == false)
                    {
                        custVendSettlement.CustVendSettlement::markThisAndRelatedOffsets(_specification, _currencyCode);
                    }
                }
            }
        }
        else
        {
            while select crosscompany custVendSettlement where
                custVendSettlement.OffsetRecid   == _vendSettlement.OffsetRecid &&
                custVendSettlement.OffsetCompany == _vendSettlement.OffsetCompany &&
                custVendSettlement.CanBeReversed == true &&
                custVendSettlement.TransDate     == _vendSettlement.TransDate &&
                custVendSettlement.AccountNum    == _vendSettlement.AccountNum &&
                custVendSettlement.RecId         != _vendSettlement.RecId
            {
                custVendTrans = custVendSettlement.custVendTrans();

                // Only want payments, invoices, or withholding tax  Vend type is used for withholding tax.
                if (custVendTrans.TransType == LedgerTransType::Vend     ||
                    custVendTrans.TransType == LedgerTransType::None    ||
                    custVendTrans.TransType == LedgerTransType::Payment ||
                    custVendTrans.TransType == LedgerTransType::Purch   ||
                    custVendTrans.TransType == LedgerTransType::Cust    ||
                    custVendTrans.TransType == LedgerTransType::Sales)
                {
                    if (_specification.existForOtherSpec(_vendSettlement.DataAreaId, _vendSettlement.TableId, _vendSettlement.RecId) == false)
                    {
                        custVendSettlement.CustVendSettlement::markThisAndRelatedOffsets(_specification, _currencyCode);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxWithhold</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts and settles the tax withholding transaction.
    /// </summary>
    /// <param name="_paymTransLedgerVoucher">
    ///    The <c>LedgerVoucher</c> object of the payment transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record that is associated with the tax withholding.
    /// </param>
    public static void postTaxWithhold(LedgerVoucher       _paymTransLedgerVoucher,
                                       LedgerJournalTrans  _ledgerJournalTrans)
    {
        SpecTrans                       specTrans;
        TaxWithholdTrans                taxWithholdTrans;
        // <GTH>
        TaxWithholdTransExtensionTH     taxWithholdTransExtensionTH;
        boolean                         isTaxWithholdFeatureEnabled_TH = TaxThaiGovCertificationFeatureChecker::isTaxWithholdEnabled();
        // </GTH>
        VendVoucherTaxWithhold          vendVoucherTaxWithhold;
        VendTrans                       vendTrans;
        VendTrans                       invoiceVendTrans;
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        LedgerVoucherGroup              ledgerVoucherGroup;
        LedgerVoucher                   taxWithholdTransLedgerVoucher;
        CompanyId                       currentCompany;
        NumberSequenceReference         numberSeqRef;
        NumberSeq                       numberSeq;
        ExchRate                        exchRate;
        ExchRate                        exchRateSecond;
        ExchangeRateHelper              exchRateHelper;
        LedgerDimensionAccount          ledgerDimensionMerged;
        LedgerDimensionDefaultAccount   ledgerDimensionDefaultAccount;
        CurrencyExchangeHelper          currencyExchangeHelper;
        LedgerVoucherObject             ledgerVoucherObject;
        LedgerDimensionDefaultAccount   whtClearingPDC;
        CustVendPDCRegister             custVendPDCRegister;
        // <GBR>
        AmountCur                       paymentAmount;
        CurrencyCode                    currencyCode;
        // </GBR>   

        // GWHT telemetry
        int64 updatedTaxWithholdingTransCount;
        System.Diagnostics.Stopwatch stopWatch;

        stopWatch = new System.Diagnostics.Stopwatch();

        stopWatch.Start();

        if (_ledgerJournalTrans.TaxWithholdGroup)
        {
            ttsbegin;

            ledgerVoucherGroup = LedgerVoucherGroup::construct();

            while select forupdate crossCompany * from specTrans
                order RefCompany
                where specTrans.SpecCompany == _ledgerJournalTrans.DataAreaId &&
                      specTrans.SpecTableId == _ledgerJournalTrans.TableId &&
                      specTrans.SpecRecId   == _ledgerJournalTrans.RecId
            {
                taxWithholdTrans = null;
                vendTrans = null;
                invoiceVendTrans = null;

                changecompany(specTrans.RefCompany)
                {
                    while select forupdate taxWithholdTrans
                        where taxWithholdTrans.SpecTransId == specTrans.RecId
                            && (TaxWithhold::shouldCreateTaxWithholdTransForZeroAmount()
                                || taxWithholdTrans.InvoiceTaxWithholdAmount != 0)
                    {
                        updatedTaxWithholdingTransCount++;

                        // <GBR>
                        if (!taxWithholdTrans.InvoiceTaxWithholdAmount)
                        {
                            taxWithholdTrans.TransDate          = _ledgerJournalTrans.TransDate;
                            taxWithholdTrans.Posted             = NoYes::Yes;
                            taxWithholdTrans.VendTransPaymId    = vendTrans.RecId;
                            taxWithholdTrans.Voucher            = _ledgerJournalTrans.Voucher;
                            taxWithholdTrans.update();
                        }
                        // </GBR>
                        else
                        {
                            if (currentCompany != specTrans.RefCompany)
                            {
                                // get a new ledger voucher and add to ledger voucher group
                                currentCompany = specTrans.RefCompany;

                                numberSeqRef = VendParameters::numRefVendPaymentVoucher();
                                numberSeq = NumberSeq::newGetVoucher(numberSeqRef);

                                taxWithholdTransLedgerVoucher = LedgerVoucher::newLedgerPost(
                                                                    DetailSummary::Detail,
                                                                    SysModule::Vend,
                                                                    numberSeqRef.numberSequenceTable().NumberSequence);
                                taxWithholdTransLedgerVoucher.parmCompanyId(currentCompany);
                                taxWithholdTransLedgerVoucher.parmCheckBlockedDimensions(_paymTransLedgerVoucher.parmCheckBlockedDimensions());

                                ledgerVoucherGroup.addLedgerVoucher(taxWithholdTransLedgerVoucher);
                            }

                            // If a PDC record is associated with the payment, post the WHT into a temporary clearing account
                            whtClearingPDC = BankParameters::find().whtClearingPDC;
                            custVendPDCRegister = CustVendPDCRegister::findByReference(_ledgerJournalTrans.RecId);
                            if (custVendPDCRegister && custVendPDCRegister.AccountType == CustVendACType::Vend && whtClearingPDC)
                            {
                                taxWithholdTrans.LedgerDimension = whtClearingPDC;
                            }
                            // get the next voucher number
                            taxWithholdTransLedgerVoucher.addVoucher(LedgerVoucherObject::newVoucher(numberSeq.voucher(),
                                                                     _paymTransLedgerVoucher.lastTransDate(),
                                                                     SysModule::Vend,
                                                                     LedgerTransType::Vend));

                            select DefaultDimension, PostingProfile from invoiceVendTrans
                                where taxWithholdTrans.VendTransInvoiceId == invoiceVendTrans.RecId;

                            // Find the exchange rate for the taxWithholdTrans transaction date and invoice currency
                            exchRateHelper = ExchangeRateHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(currentCompany).RecId), taxWithholdTrans.InvoiceCurrency, taxWithholdTrans.TransDate);
                            if ((TaxWithholdSetupWithholdingTaxCurrencyExchRateHelper::isEnabledWHTCurrencyExchRateParam() && _ledgerJournalTrans.CurrencyCode != Ledger::accountingCurrency())
                                || taxWithholdTrans.InvoiceCurrency == _ledgerJournalTrans.CurrencyCode)
                            {
                                exchRate = _ledgerJournalTrans.ExchRate;
                                exchRateSecond = _ledgerJournalTrans.ExchRateSecond;
                            }
                            else
                            {
                                exchRate = exchRateHelper.getExchangeRate1();
                                exchRateSecond = exchRateHelper.getExchangeRate2();
                            }

                            // Posting of the withholding tax on the withholding tax account
                            ledgerVoucherObject = taxWithholdTransLedgerVoucher.findLedgerVoucherObject();
                            currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(currentCompany).RecId), ledgerVoucherObject.parmAccountingDate());
                            currencyExchangeHelper.parmExchangeRate1(exchRate);
                            currencyExchangeHelper.parmExchangeRate2(exchRateSecond);

                            if (taxWithholdTrans.InvoiceCurrency == _ledgerJournalTrans.CurrencyCode)
                            {
                                currencyExchangeHelper.parmReportingExchangeRate1(_ledgerJournalTrans.ReportingCurrencyExchRate);
                                currencyExchangeHelper.parmReportingExchangeRate2(_ledgerJournalTrans.ReportingCurrencyExchRateSecondary);
                            }
                            ledgerDimensionDefaultAccount = taxWithholdTrans.LedgerDimension;

                            ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionDefaultAccount, invoiceVendTrans.DefaultDimension);

                            // <GBR>
                            if (BrazilParameters::isEnabled())
                            {
                                taxWithholdTrans.TransDate = _ledgerJournalTrans.TransDate;
                                taxWithholdTrans.CustVendTransOpenRecId_BR = specTrans.RefRecId;
                            }
                            // </GBR>

                            // Posting of the withholding tax on the vendor account and on the summary account
                            vendVoucherTaxWithhold = VendVoucher::newVendVoucherTaxWithhold(taxWithholdTrans,
                                                                                            invoiceVendTrans.DefaultDimension,
                                                                                            invoiceVendTrans.PostingProfile,
                                                                                            exchRate,
                                                                                            exchRateSecond);

                            // The related witholding tax voucher is based on invoice currency, the reporting currency is converted from invoice currency,
                            // when payment currency is equals to invoice currency, fixed exchange rate should be applied for reporting currency amount.
                            if (taxWithholdTrans.InvoiceCurrency == _ledgerJournalTrans.CurrencyCode)
                            {
                                vendVoucherTaxWithhold.parmReportingCurrencyExchRate(_ledgerJournalTrans.ReportingCurrencyExchRate);
                                vendVoucherTaxWithhold.parmReportingCurrencyExchRateSecondary(_ledgerJournalTrans.ReportingCurrencyExchRateSecondary);
                            }

                            ledgerVoucherTransObject = TaxWithhold::initLedgerVoucherTransObject(taxWithholdTrans, ledgerVoucherObject, ledgerDimensionMerged, currencyExchangeHelper, _ledgerJournalTrans, vendVoucherTaxWithhold, taxWithholdTransLedgerVoucher, invoiceVendTrans);

                            taxWithholdTransLedgerVoucher.addTrans(ledgerVoucherTransObject);

                            // <GTH>
                            if (isTaxWithholdFeatureEnabled_TH)
                            {
                                taxWithholdTransExtensionTH = taxWithholdTrans.taxWithholdTransExtensionTH();
                                if (taxWithholdTransExtensionTH.AccountingCurExpenseAmount != 0.0)
                                {
                                    if (taxWithholdTransExtensionTH.ExpenseLedgerDimension == 0)
                                    {
                                        // Try to get the expense account from posting profile again as it is not able to get before.
                                        taxWithholdTransExtensionTH.ExpenseLedgerDimension = TaxWithholdLedgerAccountGroup_TH::find(
                                            TaxWithholdTable::find(taxWithholdTrans.TaxWithholdCode).TaxWithholdLedgerAccountGroup_TH).ExpenseLedgerDimension;

                                        taxWithholdTrans.SysExtensionSerializerMap::packExtensionTable(taxWithholdTransExtensionTH);
                                    }

                                    if (taxWithholdTransExtensionTH.ExpenseLedgerDimension == 0)
                                    {
                                        stopWatch.stop();

                                        TaxWithHoldInstrumentationTelemetry::logGWHTTelemetry(
                                            GlobalizationConstants::FeatureReferenceTAX00037,
                                            funcName(),
                                            TaxWithHoldInstrumentationTelemetry::Posting,
                                            enum2Str(SalesPurch::Purch),
                                            false,
                                            0,
                                            0);

                                        // The "Expense account" is not specified for tax code "%2"
                                        throw error(
                                            strFmt("@SYS4082503", "@SYS4082501", taxWithholdTrans.TaxWithholdCode),
                                            '',
                                            SysInfoAction_Formrun::newFormnameControlnameDesc(
                                                formStr(TaxWithholdAccountGroup_TH),
                                                formControlStr(TaxWithholdAccountGroup_TH, LedgerPosting_ExpenseLedgerDimension),
                                                "@SYS23299"));
                                    }

                                    // Add the withholding tax expense trans
                                    ledgerDimensionDefaultAccount = taxWithholdTransExtensionTH.ExpenseLedgerDimension;
                                    ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionDefaultAccount, invoiceVendTrans.DefaultDimension);

                                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAccountingAmountsDefault(
                                        ledgerVoucherObject,
                                        LedgerPostingType::TaxWithhold,
                                        ledgerDimensionMerged,
                                        taxWithholdTrans.InvoiceCurrency,
                                        taxWithholdTransExtensionTH.InvoiceCurExpenseAmount,
                                        taxWithholdTransExtensionTH.AccountingCurExpenseAmount,
                                        currencyExchangeHelper);
                                    ledgerVoucherTransObject.parmSourceTableId(taxWithholdTrans.TableId);
                                    ledgerVoucherTransObject.parmSourceRecId(taxWithholdTrans.RecId);
                                    // Expense
                                    ledgerVoucherTransObject.parmTransTxt("@SYS78349");
                                    taxWithholdTransLedgerVoucher.addTrans(ledgerVoucherTransObject);

                                    // Expense description.
                                    ledgerVoucherObject.lastTransTxt('');
                                }
                            }
                            // </GTH>

                            taxWithholdTrans.SettlementVoucher = taxWithholdTransLedgerVoucher.lastVoucher();

                            TaxWithhold::postVendVoucherTaxWithhold(_ledgerJournalTrans, vendVoucherTaxWithhold, taxWithholdTransLedgerVoucher, vendTrans, invoiceVendTrans, taxWithholdTrans);

                            // <GEERU>
                            taxWithholdTransLedgerVoucher.bondLast2_RU();
                            // </GEERU>
                            vendVoucherTaxWithhold.settleTaxWithhold(vendTrans, taxWithholdTransLedgerVoucher.lastTransDate());

                            taxWithholdTrans.Posted = NoYes::Yes;
                            taxWithholdTrans.VendTransPaymId = vendTrans.RecId;
                            // The voucher field on the taxWithholdTrans contains the payment voucher.  When this is an intercompany
                            // posting will need to set this to the intercompany voucher which is the value from
                            // _ledgerJournalTrans.Voucher.
                            taxWithholdTrans.Voucher = _ledgerJournalTrans.Voucher;
                            taxWithholdTrans.update();

                            // <GBR>
                            if (BrazilParameters::isEnabled())
                            {
                                paymentAmount = taxWithholdTrans.TaxWithholdBaseAmount;
                                currencyCode  = taxWithholdTrans.InvoiceCurrency;
                                TaxWithhold::changeWhtTransAccumBaseAmountToZero_BR(_ledgerJournalTrans, taxWithholdTrans);
                            }
                            // </GBR>

                            // Update specTrans.Balance01 field with withhold tax amount
                            // <GTH>
                            if (isTaxWithholdFeatureEnabled_TH)
                            {
                                specTrans.Balance01 += taxWithholdTrans.displayInvoiceCurDeductableAmount();
                            }
                            else
                            {
                                // </GTH>
                                specTrans.Balance01 += taxWithholdTrans.InvoiceTaxWithholdAmount;
                                // <GTH>
                            }
                            // </GTH>
                            specTrans.update();
                        }
                    }
                }
            }

            ledgerVoucherGroup.end();

            // create related vouchers, may need to change processing to check for duplicate parent voucher
            if (_paymTransLedgerVoucher != null)
            {
                taxWithholdTransLedgerVoucher = ledgerVoucherGroup.findLedgerVoucher(curext(),
                    VendParameters::numRefVendPaymentVoucher().numberSequenceTable().NumberSequence);
                if (taxWithholdTransLedgerVoucher != null)
                {
                    taxWithholdTransLedgerVoucher.createVoucherLinks(_paymTransLedgerVoucher.lastVoucher(), _paymTransLedgerVoucher.lastTransDate());
                }
            }

            TaxWithhold::setTaxWithholdSlipNum(_ledgerJournalTrans.JournalNum);

            ttscommit;
        }

        stopWatch.Stop();

        TaxWithHoldInstrumentationTelemetry::logGWHTTelemetry(
            GlobalizationConstants::FeatureReferenceTAX00037,
            funcName(),
            TaxWithHoldInstrumentationTelemetry::Posting,
            enum2Str(SalesPurch::Purch),
            true,
            updatedTaxWithholdingTransCount,
            stopwatch.elapsedMilliseconds);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTaxWithhold</Name>
				<Source><![CDATA[
    public static void reverseTaxWithhold(LedgerVoucher  _ledgerVoucher,
                                                 VendTrans      _vendTrans)
    {
        TaxWithholdTrans                taxWithholdTrans;
        TaxWithholdTrans                taxWithholdTransReverse;
        VendVoucherTaxWithhold          vendVoucherTaxWithhold;
        VendTrans                       vendTrans;
        ExchRate                        exchRate;
        ExchrateSecondary               exchRateSecond;
        UnknownNoYes                    triangulation;
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        TransactionTextLarge            transTxt;
        LedgerDimensionAccount          ledgerDimensionMerged;
        LedgerDimensionDefaultAccount   ledgerDimensionDefaultAccount;
        CurrencyExchangeHelper          currencyExchangeHelper;
        LedgerVoucherObject             ledgerVoucherObject;

        taxWithholdTrans = TaxWithholdTrans::findVendTransPaym(_vendTrans);

        if (taxWithholdTrans.RecId)
        {
            ttsbegin;

            // Creation of the reversed TaxWithholdTrans record
            taxWithholdTransReverse.copyTaxWithholdTrans(taxWithholdTrans,
                                                         _ledgerVoucher.lastVoucher(),
                                                         _ledgerVoucher.lastTransDate(),
                                                         -1);
            taxWithholdTransReverse.insert();

            if (_vendTrans.euroTriangulation)
            {
                triangulation = UnknownNoYes::Yes;
                exchRate = ExchangeRateHelper::exchRate(taxWithholdTransReverse.InvoiceCurrency, taxWithholdTransReverse.TransDate, triangulation);
                exchRateSecond = ExchangeRateHelper::exchRateSecond(taxWithholdTransReverse.InvoiceCurrency, taxWithholdTransReverse.TransDate, triangulation);
            }
            else
            {
                triangulation = UnknownNoYes::No;
                exchRate = taxWithholdTransReverse.InvoiceTaxWithholdAmount ?
                                 taxWithholdTransReverse.TaxWithholdAmount / taxWithholdTransReverse.InvoiceTaxWithholdAmount * 100 : 0;
                exchRateSecond = 0;
            }

            // Posting of the withholding tax on the withholding tax account
            ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
            currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
            currencyExchangeHelper.parmExchangeRate1(exchRate);
            currencyExchangeHelper.parmExchangeRate2(exchRateSecond);

            ledgerDimensionDefaultAccount = taxWithholdTransReverse.LedgerDimension;

            ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionDefaultAccount, _vendTrans.DefaultDimension);

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                        ledgerVoucherObject,
                    LedgerPostingType::TaxWithhold,
                                        ledgerDimensionMerged,
                    taxWithholdTransReverse.InvoiceCurrency,
                    - taxWithholdTransReverse.InvoiceTaxWithholdAmount,
                                        currencyExchangeHelper);
            ledgerVoucherTransObject.parmSourceTableId(taxWithholdTransReverse.TableId);
            ledgerVoucherTransObject.parmSourceRecId(taxWithholdTransReverse.RecId);
            transTxt = _ledgerVoucher.findLedgerVoucherObject().lastTransTxt();
            ledgerVoucherTransObject.parmTransTxt(transTxt);
            _ledgerVoucher.addTrans(ledgerVoucherTransObject);

            // Posting of the withholding tax on the vendor account and on the summary account
            vendVoucherTaxWithhold = VendVoucher::newVendVoucherTaxWithhold(taxWithholdTransReverse,
                                                                            _vendTrans.DefaultDimension,
                                                                            _vendTrans.PostingProfile,
                                                                            exchRate,
                                                                            exchRateSecond);

            vendVoucherTaxWithhold.parmTransTxt(transTxt);
            vendVoucherTaxWithhold.post(_ledgerVoucher, vendTrans);
            // <GEERU>
            _ledgerVoucher.bondLast2_RU();
            // </GEERU>

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTaxWithhold_BR</Name>
				<Source><![CDATA[
    static void reverseTaxWithhold_BR(LedgerVoucher  _ledgerVoucher,
                                      VendTrans      _vendTrans,
                                      Voucher        _voucher,
                                      RecId          _vendTransOpenRecid,
                                      TransDate      paymentDate)
    {
        TaxWithholdTrans                taxWithholdTrans;
        TaxWithholdTrans                reverseTaxWithholdTrans;
        ExchRate                        exchRate;
        ExchrateSecondary               exchRateSecond;
        UnknownNoYes                    triangulation;
        VendVoucherTaxWithhold          vendVoucherTaxWithhold;
        VendTrans                       vendTransLoc;
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        TransactionTextLarge            transTxt;
        LedgerDimensionAccount          ledgerDimensionMerged;
        LedgerDimensionDefaultAccount   ledgerDimensionDefaultAccount;
        CurrencyExchangeHelper          currencyExchangeHelper;
        LedgerVoucherObject             ledgerVoucherObject;

        ttsbegin;

        transTxt = VendTrans::findVoucherDate(_ledgerVoucher.lastVoucher(),_ledgerVoucher.lastTransDate()).Txt;

        while select  forupdate taxWithholdTrans
            where taxWithholdTrans.VendAccount          == _vendTrans.AccountNum
               && taxWithholdTrans.VendTransInvoiceId   == _vendTrans.RecId
               && taxWithholdTrans.Voucher              == _voucher
               && taxWithholdTrans.TransDate            == paymentDate
               && taxWithholdTrans.CanBeReversed_BR     == NoYes::Yes
        {
            select forupdate vendTransLoc
                where vendTransLoc.RecId == taxWithholdTrans.VendTransPaymId;

            reverseTaxWithholdTrans = TaxWithholdTrans::copyTaxWithholdTrans_BR(taxWithholdTrans,_ledgerVoucher.lastVoucher(),_ledgerVoucher.lastTransDate());

            reverseTaxWithholdTrans.VoucherInvoice              = '';
            reverseTaxWithholdTrans.CustVendTransOpenRecId_BR   = _vendTransOpenRecid;
            reverseTaxWithholdTrans.Posted                      = NoYes::Yes;
            reverseTaxWithholdTrans.CanBeReversed_BR            = NoYes::No;

            if (TaxWithhold::checkUniquewithholdrecord_BR(reverseTaxWithholdTrans))
            {
                reverseTaxWithholdTrans.insert();
            }
            else
            {
                continue;
            }

            reverseTaxWithholdTrans.update();

            if (_vendTrans.euroTriangulation)
            {
                triangulation = UnknownNoYes::Yes;
                exchRate = ExchangeRateHelper::exchRate(reverseTaxWithholdTrans.PaymCurrency, reverseTaxWithholdTrans.TransDate, triangulation);
                exchRateSecond = ExchangeRateHelper::exchRateSecond(reverseTaxWithholdTrans.PaymCurrency, reverseTaxWithholdTrans.TransDate, triangulation);
            }
            else
            {
                triangulation = UnknownNoYes::No;
                exchRate = reverseTaxWithholdTrans.PaymTaxWithholdAmount ?
                                 reverseTaxWithholdTrans.TaxWithholdAmount / reverseTaxWithholdTrans.PaymTaxWithholdAmount * 100 : 0;
                exchRateSecond = 0;
            }

            if (reverseTaxWithholdTrans.InvoiceTaxWithholdAmount)
            {
                // Posting of the withholding tax on the withholding tax account
                ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
                currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
                currencyExchangeHelper.parmExchangeRate1(exchRate);
                currencyExchangeHelper.parmExchangeRate2(exchRateSecond);

                ledgerDimensionDefaultAccount = reverseTaxWithholdTrans.LedgerDimension;

                ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionDefaultAccount, _vendTrans.DefaultDimension);

                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                            ledgerVoucherObject,
                                                                            LedgerPostingType::TaxWithhold,
                                                                            ledgerDimensionMerged,
                                                                            reverseTaxWithholdTrans.InvoiceCurrency,
                                                                            -reverseTaxWithholdTrans.InvoiceTaxWithholdAmount,
                                                                            currencyExchangeHelper);

                ledgerVoucherTransObject.parmSourceTableId(reverseTaxWithholdTrans.TableId);
                ledgerVoucherTransObject.parmSourceRecId(reverseTaxWithholdTrans.RecId);
                transTxt = _ledgerVoucher.findLedgerVoucherObject().lastTransTxt();
                ledgerVoucherTransObject.parmTransTxt(transTxt);
                _ledgerVoucher.addTrans(ledgerVoucherTransObject);

                vendVoucherTaxWithhold = VendVoucher::newVendVoucherTaxWithhold(reverseTaxWithholdTrans,
                                                                                vendTransLoc.DefaultDimension,
                                                                                vendTransLoc.PostingProfile,
                                                                                exchRate,
                                                                                exchRateSecond);
                vendVoucherTaxWithhold.post(_ledgerVoucher, vendTransLoc);

                TaxWithhold::settleReverseTaxWithhold_BR(reverseTaxWithholdTrans, vendTransLoc.RecId, taxWithholdTrans.Voucher, _ledgerVoucher, transTxt, _vendTransOpenRecid);
            }

            taxWithholdTrans.CanBeReversed_BR = NoYes::No;
            taxWithholdTrans.doUpdate();
        }

        update_recordSet taxWithholdTrans
            setting RefCustVendTransRecId_BR = 0, TaxWithholdIsSelected_BR = false
                where taxWithholdTrans.RefCustVendTransRecId_BR == _vendTrans.RecId
                    && taxWithholdTrans.VendTransInvoiceId != _vendTrans.RecId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxWithholdSlipNum</Name>
				<Source><![CDATA[
    public static void setTaxWithholdSlipNum(LedgerJournalId  _journalId)
    {
        TaxWithholdTrans        taxWithholdTrans;
        TaxWithholdSlipNum_TH   taxWithholdSlipNum;
        VendAccount             vendAccount;
        NumberSequenceReference numberSequenceReference;
        
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoTH]))
        {
            ttsbegin;

            if (_journalId)
            {
                while select forupdate taxWithholdTrans
                    order by VendAccount
                    where taxWithholdTrans.TaxWithholdSlipNum_TH == "" &&
                          taxWithholdTrans.JournalNum == _journalId
                {
                    numberSequenceReference = LedgerParameters::numRefTaxWithholdSlipNum_TH();
                    if (numberSequenceReference.numberSequenceTable().Continuous == NoYes::No)
                    {
                        throw error(strFmt(
                            "@SYS78707",
                            numberSequenceReference.referenceLabel(),
                            numberSequenceReference.referenceModuleLabel()));
                    }

                    if (vendAccount != taxWithholdTrans.VendAccount)
                    {
                        vendAccount        = taxWithholdTrans.VendAccount;
                        taxWithholdSlipNum = NumberSeq::newGetNum(numberSequenceReference).num();
                    }
                    taxWithholdTrans.TaxWithholdSlipNum_TH = taxWithholdSlipNum;
                    taxWithholdTrans.update();
                }
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleReverseTaxWithhold_BR</Name>
				<Source><![CDATA[
    static void settleReverseTaxWithhold_BR(TaxWithholdTrans   _reverseWithholdTransData,
                                         RecId                  _vendTransRecid,
                                         Voucher                _lastSettledVoucher,
                                         LedgerVoucher          _ledgerVoucher,
                                         TransTxt               _txt,
                                         RecId                  _vendTransOpenRecid)
    {
        VendTrans                   vendTransInvoice;
        VendTrans                   vendTrans;
        VendSettlement              vendSettlementCre;
        VendSettlement              reverseVendSettlementCre;
        VendSettlement              vendSettlementDeb;
        VendSettlement              reverseVendSettlementDeb;
        VendTransOpen               vendTransOpen;
        ;

        ttsbegin;

        vendTransInvoice = VendTrans::find(_reverseWithholdTransData.VendTransInvoiceId, true);
        vendTrans        = VendTrans::find(_vendTransRecid,true);

        delete_from vendTransOpen where vendTransOpen.RefRecId == _vendTransRecid;

        vendTransInvoice.SettleAmountMST   -= _reverseWithholdTransData.TaxWithholdAmount;
        vendTransInvoice.SettleAmountCur   -= _reverseWithholdTransData.InvoiceTaxWithholdAmount;
        vendTransInvoice.update();

        vendTrans.TransDate         = _ledgerVoucher.lastTransDate();
        vendTrans.Txt               =  _txt;
        vendTrans.AmountCur         = _reverseWithholdTransData.PaymTaxWithholdAmount;
        vendTrans.AmountMST         = _reverseWithholdTransData.InvoiceTaxWithholdAmount;
        vendTrans.SettleAmountCur   = vendTrans.AmountCur;
        vendTrans.SettleAmountMST   = vendTrans.AmountMST;
        vendTrans.CurrencyCode      = _reverseWithholdTransData.PaymCurrency;
        vendTrans.LastSettleVoucher = _lastSettledVoucher;
        vendTrans.LastSettleDate    = _reverseWithholdTransData.TransDate;
        vendTrans.OffsetRecid       = _reverseWithholdTransData.VendTransPaymId;
        vendTrans.update();

        select forupdate vendTransOpen where vendTransOpen.RecId == _vendTransOpenRecid;
        vendTransOpen.AmountMST   += _reverseWithholdTransData.TaxWithholdAmount;
        vendTransOpen.AmountCur   += _reverseWithholdTransData.InvoiceTaxWithholdAmount;
        vendTransOpen.update();

        select forupdate vendSettlementDeb where vendSettlementDeb.TransRecId == _reverseWithholdTransData.VendTransPaymId;
        vendSettlementDeb.CanBeReversed = NoYes::No;
        vendSettlementDeb.update();

        reverseVendSettlementDeb = vendSettlementDeb.data();
        reverseVendSettlementDeb.SettleAmountCur = -reverseVendSettlementDeb.SettleAmountCur;
        reverseVendSettlementDeb.SettleAmountMST = -reverseVendSettlementDeb.SettleAmountMST;
        reverseVendSettlementDeb.insert();

        select forupdate vendSettlementCre where vendSettlementCre.OffsetRecid == _reverseWithholdTransData.VendTransPaymId;
        vendSettlementCre.CanBeReversed = NoYes::No;
        vendSettlementCre.update();

        reverseVendSettlementCre = vendSettlementCre.data();
        reverseVendSettlementCre.SettleAmountCur = -reverseVendSettlementCre.SettleAmountCur;
        reverseVendSettlementCre.SettleAmountMST = -reverseVendSettlementCre.SettleAmountMST;
        reverseVendSettlementCre.insert();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>uncheckWithholdTrans_BR</Name>
				<Source><![CDATA[
    static void uncheckWithholdTrans_BR(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTrans              ledgerJournalTrans;
        LedgerJournalTransPayment_BR    ledgerJournalTransPaym;
        date                periodStart;
        date                periodEnd;
        TaxWithholdTrans    taxWithholdTrans;

        DirPartyNumber      partyId = TaxWithhold::construct(_ledgerJournalTrans).partyId_BR();
        container           dataAreaIdList = TaxWithhold::construct(_ledgerJournalTrans).crossCompanyList_BR();

        periodStart = dateStartMth(_ledgerJournalTrans.TransDate);
        periodEnd   = dateEndMth(periodStart);

        ttsbegin;

        while select crosscompany : dataAreaIdList LedgerJourTransRecId_BR from taxWithholdTrans
            where taxWithholdTrans.PartyId_BR                   == partyId
                &&  taxWithholdTrans.TransDate                  >= periodStart
                &&  taxWithholdTrans.TransDate                  <= periodEnd
                &&  taxWithholdTrans.TaxWithholdIsSelected_BR   == NoYes::Yes
                &&  taxWithholdTrans.InvoiceTaxWithholdAmount   != 0
                &&  taxWithholdTrans.CanBeReversed_BR           == NoYes::Yes
        {
            select crosscompany count(RecId) from ledgerJournalTrans
                where ledgerJournalTrans.RecId                    == taxWithholdTrans.LedgerJourTransRecId_BR
                exists join ledgerJournalTransPaym
                    where ledgerJournalTransPaym.RefRecId == ledgerJournalTrans.RecId
                        &&  ledgerJournalTransPaym.TaxWithholdEditStatus_BR   == LedgerTransTaxWithholdEditStatus_BR::Closed;

            if (ledgerJournalTrans.RecId)
            {
                break;
            }
        }

        if (!ledgerJournalTrans.RecId)
        {
            // A posted TaxWithholdTrans may not have reached the threshold when it starts withholding
            // These are marked with TaxWithholdIsSelected too, and in order to uncheck them, it's
            // necessary to skip the validations in the table.update()
            while select forupdate crosscompany : dataAreaIdList taxWithholdTrans
                where taxWithholdTrans.PartyId_BR               == partyId
                && taxWithholdTrans.TransDate                  >= periodStart
                && taxWithholdTrans.TransDate                  <= periodEnd
                && taxWithholdTrans.TaxWithholdIsSelected_BR   == NoYes::Yes
                && taxWithholdTrans.CanBeReversed_BR           == NoYes::Yes
            {
                changecompany(taxWithholdTrans.DataAreaId)
                {
                    taxWithholdTrans.TaxWithholdIsSelected_BR = NoYes::No;
                    taxWithholdTrans.RefCustVendTransRecId_BR = 0;
                    taxWithholdTrans.doUpdate();
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateExpenseAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether expense amount of specified withholding tax transaction is valid.
    /// </summary>
    /// <param name="_taxWithholdTrans">
    /// A <c>TaxWithholdTrans</c> table buffer to be validated.
    /// </param>
    /// <param name="_taxWithholdTransExtensionTH">
    /// A <c>TaxWithholdTransExtension_TH</c> table buffer.
    /// </param>
    /// <param name="_expenseAmountFieldId">
    /// The field name of expense field.
    /// </param>
    /// <returns>
    /// Returns false if the expense amount is greater than withhold tax amount or less than 0; Otherwise, returns true.
    /// </returns>
    public static boolean validateExpenseAmount(
        TaxWithholdTrans            _taxWithholdTrans,
        TaxWithholdTransExtensionTH _taxWithholdTransExtensionTH,
        FieldName                   _expenseAmountFieldId)
    {
        boolean                                 ret = true;
        TaxWithholdAccountingCurExpenseAmt      newAccountingCurExpenseAmount;

        if (_taxWithholdTrans.TaxWithholdCode)
        {
            switch (_expenseAmountFieldId)
            {
                case fieldStr(TaxWithholdTransExtensionTH, AccountingCurExpenseAmount):
                    newAccountingCurExpenseAmount = _taxWithholdTransExtensionTH.AccountingCurExpenseAmount;
                    break;

                case fieldStr(TaxWithholdTransExtensionTH, InvoiceCurExpenseAmount):
                    newAccountingCurExpenseAmount = CurrencyExchangeHelper::mstAmount(_taxWithholdTransExtensionTH.InvoiceCurExpenseAmount, _taxWithholdTrans.InvoiceCurrency, _taxWithholdTrans.TransDate);
                    break;

                case fieldStr(TaxWithholdTransExtensionTH, TransCurExpenseAmount):
                    newAccountingCurExpenseAmount = CurrencyExchangeHelper::mstAmount(_taxWithholdTransExtensionTH.TransCurExpenseAmount, _taxWithholdTrans.TaxWithholdCurrency, _taxWithholdTrans.TransDate);
                    break;

                default:
                    throw error(Error::wrongUseOfFunction(funcName()));
            }

            if (abs(newAccountingCurExpenseAmount) > abs(_taxWithholdTrans.TaxWithholdAmount))
            {
                // The expense amount cannot be greater than withholding tax amount.
                ret = checkFailed("@SYS4082499");
            }
            else if (newAccountingCurExpenseAmount * sign(_taxWithholdTrans.TaxWithholdAmount) < 0)
            {
                // The expense amount cannot be less than 0.
                ret = checkFailed("@SYS4082500");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateTaxWithholdTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether skip from creating tax withhold transactions.
    /// </summary>
    /// <param name = "_vendTrans">
    /// The buffer of <c>CustVendTrans</c>.
    /// </param>
    /// <returns>
    /// True if can create tax withhold transactions; otherwise, false.
    /// </returns>
    public boolean canCreateTaxWithholdTrans(CustVendTrans _vendTrans)
    {
        VendTable                        vendor;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt;

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            ledgerJournalTransTaxExt = ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
        }
        // </GIN>

        if (_vendTrans.Invoice == '')
        {
            //only calculate tax withholding if VendTrans has an invoice number
            return false;
        }

        // Find the vendor of the account number and company from the vendTrans
        vendor = VendTable::findByCompany(_vendTrans.company(), _vendTrans.AccountNum);

        if (vendor.TaxWithholdCalculate == false && ledgerJournalTrans.TaxWithholdGroup == '')
        {
            // neither the payment of invoice vendor have tax withholding no calculation needed.
            return false;
        }
        // <GIN>
        else if (TaxWithholdParameters_IN::checkTaxParameters() && (ledgerJournalTransTaxExt.tdsGroup || ledgerJournalTransTaxExt.tcsGroup))
        {
            return false;
        }
        // </GIN>
        else if ((vendor.TaxWithholdCalculate == false && ledgerJournalTrans.TaxWithholdGroup != '')
            || (vendor.TaxWithholdCalculate == true && ledgerJournalTrans.TaxWithholdGroup == ''))
        {
            // give worning message that tax won't be calculated
            info("@SYS120362");
            return false;
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            //only calculate tax withholding if VendTrans has an withholding tax calculation and is not credit payment
            if (this.isCreditPayment_BR(_vendTrans))
            {
                warning("@GLS50773");
                return false;
            }
        }
        // </GBR>
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucherTransObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the buffer of <c>LedgerVoucherTransObject</c>.
    /// </summary>
    /// <param name = "_taxWithholdTrans">
    /// The buffer of <c>TaxWithholdTrans</c>.
    /// </param>
    /// <param name = "_ledgerVoucherObject">
    /// The buffer of <c>LedgerVoucherObject</c>.
    /// </param>
    /// <param name = "_ledgerDimensionMerged">
    /// The buffer of Ledger dimension account of <c>LedgerDimensionAccount</c>.
    /// </param>
    /// <param name = "_currencyExchangeHelper">
    /// The buffer of <c>CurrencyExchangeHelper</c>.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The buffer of <c>LedgerJournalTrans</c>.
    /// </param>
    /// <param name = "_vendVoucherTaxWithhold">
    ///  The buffer of <c>VendVoucherTaxWithhold</c>.
    /// </param>
    /// <param name = "_taxWithholdTransLedgerVoucher">
    /// The buffer of <c>LedgerVoucher</c>.
    /// </param>
    /// <param name = "_invoiceVendTrans">
    /// The vend invoice trans.
    /// </param>
    /// <returns>
    /// Return the buffer of ledger voucher transaction.
    /// </returns>
    public static LedgerVoucherTransObject initLedgerVoucherTransObject(
        TaxWithholdTrans         _taxWithholdTrans,
        LedgerVoucherObject      _ledgerVoucherObject,
        LedgerDimensionAccount   _ledgerDimensionMerged,
        CurrencyExchangeHelper   _currencyExchangeHelper,
        LedgerJournalTrans       _ledgerJournalTrans,
        VendVoucherTaxWithhold   _vendVoucherTaxWithhold,
        LedgerVoucher            _taxWithholdTransLedgerVoucher,
        VendTrans                _invoiceVendTrans)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAccountingAmountsDefault(
                                                        _ledgerVoucherObject,
                                                        LedgerPostingType::TaxWithhold,
                                                        _ledgerDimensionMerged,
                                                        _taxWithholdTrans.InvoiceCurrency,
                                                        -_taxWithholdTrans.InvoiceTaxWithholdAmount,
                                                        -_taxWithholdTrans.TaxWithholdAmount,
                                                        _currencyExchangeHelper);
        ledgerVoucherTransObject.parmSourceTableId(_taxWithholdTrans.TableId);
        ledgerVoucherTransObject.parmSourceRecId(_taxWithholdTrans.RecId);

        TaxWithhold::setTransTxt(_taxWithholdTrans, ledgerVoucherTransObject, _ledgerJournalTrans, _vendVoucherTaxWithhold, _taxWithholdTransLedgerVoucher, _invoiceVendTrans);

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes Txt for <c>LedgerVoucherTransObject</c>.
    /// </summary>
    /// <param name = "_taxWithholdTrans">
    /// The buffer of <c>TaxWithholdTrans</c>.
    /// </param>
    /// <param name = "_ledgerVoucherTransObject">
    /// The buffer of <c>LedgerVoucherTransObject</c>.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The buffer of <c>LedgerJournalTrans</c>.
    /// </param>
    /// <param name = "_vendVoucherTaxWithhold">
    ///  The buffer of <c>VendVoucherTaxWithhold</c>.
    /// </param>
    /// <param name = "_taxWithholdTransLedgerVoucher">
    /// The buffer of <c>LedgerVoucher</c>.
    /// </param>
    /// <param name = "_invoiceVendTrans">
    /// The vend invoice trans.
    /// </param>
    public static void setTransTxt(
        TaxWithholdTrans         _taxWithholdTrans,
        LedgerVoucherTransObject _ledgerVoucherTransObject,
        LedgerJournalTrans       _ledgerJournalTrans,
        VendVoucherTaxWithhold   _vendVoucherTaxWithhold,
        LedgerVoucher            _taxWithholdTransLedgerVoucher,
        VendTrans                _invoiceVendTrans)
    {
        _ledgerVoucherTransObject.parmTransTxt(_ledgerJournalTrans.Txt);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postVendVoucherTaxWithhold</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the parm for <c>VendVoucherTaxWithhold</c>.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The buffer of <c>LedgerJournalTrans</c>.
    /// </param>
    /// <param name = "_vendVoucherTaxWithhold">
    /// The buffer of <c>VendVoucherTaxWithhold</c>.
    /// </param>
    /// <param name = "_taxWithholdTransLedgerVoucher">
    /// The buffer of <c>LedgerVoucher</c>.
    /// </param>
    /// <param name = "_vendTrans">
    /// The buffer of <c>VendTrans</c>.
    /// </param>
    /// <param name = "_invoiceVendTrans">
    /// The vend invoice trans.
    /// </param>
    /// <param name = "_taxWithholdTrans">
    /// The buffer of <c>TaxWithholdTrans</c>.
    /// </param>
    public static void postVendVoucherTaxWithhold(
        LedgerJournalTrans       _ledgerJournalTrans,
        VendVoucherTaxWithhold   _vendVoucherTaxWithhold,
        LedgerVoucher            _taxWithholdTransLedgerVoucher,
        VendTrans                _vendTrans,
        VendTrans                _invoiceVendTrans,
        TaxWithholdTrans         _taxWithholdTrans)
    {
        TaxWithhold::initVendVoucherTaxWithhold(_ledgerJournalTrans, _vendVoucherTaxWithhold, _taxWithholdTransLedgerVoucher, _vendTrans, _invoiceVendTrans, _taxWithholdTrans);
        
        _vendVoucherTaxWithhold.post(_taxWithholdTransLedgerVoucher, _vendTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initVendVoucherTaxWithhold</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the parm for <c>VendVoucherTaxWithhold</c>.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The buffer of <c>LedgerJournalTrans</c>.
    /// </param>
    /// <param name = "_vendVoucherTaxWithhold">
    /// The buffer of <c>VendVoucherTaxWithhold</c>.
    /// </param>
    /// <param name = "_taxWithholdTransLedgerVoucher">
    /// The buffer of <c>LedgerVoucher</c>.
    /// </param>
    /// <param name = "_vendTrans">
    /// The buffer of <c>VendTrans</c>.
    /// </param>
    /// <param name = "_invoiceVendTrans">
    /// The vend invoice trans.
    /// </param>
    /// <param name = "_taxWithholdTrans">
    /// The buffer of <c>TaxWithholdTrans</c>.
    /// </param>
    public static void initVendVoucherTaxWithhold(
        LedgerJournalTrans       _ledgerJournalTrans,
        VendVoucherTaxWithhold   _vendVoucherTaxWithhold,
        LedgerVoucher            _taxWithholdTransLedgerVoucher,
        VendTrans                _vendTrans,
        VendTrans                _invoiceVendTrans,
        TaxWithholdTrans         _taxWithholdTrans)
    {
        TaxWithhold::setAmountMST(_vendVoucherTaxWithhold, _taxWithholdTrans);

        _vendVoucherTaxWithhold.parmInvoiceVendTrans(_invoiceVendTrans);
        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank)
            {
                _vendVoucherTaxWithhold.parmCompanyBankAccountId(_ledgerJournalTrans.BankAccountId);
            }
            _vendVoucherTaxWithhold.parmPaymMode(_ledgerJournalTrans.PaymMode);
            _vendVoucherTaxWithhold.parmBankTransactionTypes(JournalizingDefinitionManagerBank::convertLedgerJourTypeToBankTransTypes(_ledgerJournalTrans.ledgerJournalTable().JournalType));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes amountMST for <c>VendVoucherTaxWithhold</c>.
    /// </summary>
    /// <param name = "_vendVoucherTaxWithhold">
    /// The buffer of <c>VendVoucherTaxWithhold</c>.
    /// </param>
    /// <param name = "_taxWithholdTrans">
    /// The buffer of <c>TaxWithholdTrans</c>.
    /// </param>
    public static void setAmountMST(VendVoucherTaxWithhold _vendVoucherTaxWithhold, TaxWithholdTrans _taxWithholdTrans)
    {
        _vendVoucherTaxWithhold.parmAmountMST(_taxWithholdTrans.TaxWithholdAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableAdvancedTaxWithhold</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines these country whether can use tax withhold
    /// </summary>
    /// <returns>
    /// True if can use tax withhold, otherwise, false
    /// </returns>
    public static boolean enableAdvancedTaxWithhold()
    {
        return TaxWithholdingGlobalFeature::isExtendedWHTSupportedInCountryRegionOrParamEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>IsWithholdTaxOnlyNeededForService</Name>
				<Source><![CDATA[
    /// <summary>
    /// Judges whether the item type should be service
    /// </summary>
    /// <returns>
    /// True is not, otherwise, false
    /// </returns>
    public static boolean IsWithholdTaxOnlyNeededForService()
    {
        return !SysCountryRegionCode::isLegalEntityInCountryRegion([#isoGB, #isoIE, #isoSA]) && !TaxWithholdingGlobalFeature::isFeatureAndParamEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreateTaxWithholdTransForZeroAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether should create withhold tax trans for zero amount
    /// </summary>
    /// <returns>
    /// True if create, otherwise, false
    /// </returns>
    public static boolean shouldCreateTaxWithholdTransForZeroAmount()
    {
        return BrazilParameters::isEnabled()
            || SysCountryRegionCode::isLegalEntityInCountryRegion([#isoGB, #isoIT])
            || (TaxWithholdingGlobalFeature::isExtendedWHTSupportedInCountryRegionOrParamEnabled()
                && LedgerParameters::find().IsPostZeroRatedWHT);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ignoreTaxDirectionCheck_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add the ignored tax direction check condition
    /// </summary>
    /// <returns>True if the condition satisfied; otherwise, false</returns>
    public static boolean ignoreTaxDirectionCheck_TH()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInvoiceWithholdBaseAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the value of field <c>InvoiceWithholdBaseAmount</c> on <c>TaxWithholdTrans</c> table.
    /// </summary>
    /// <param name = "_taxWithholdTrans">The buffer of <c>TaxWithholdTrans</c>.</param>
    /// <param name = "_custVendTransAmountCur">Customer or vendor transaction currency amount.</param>
    /// <param name = "_accumPayment">The accounting payment amount.</param>
    /// <param name = "_accumBaseAmountFromPreviousPayment">The accounting base amount from previous payment amount.</param>
    /// <returns>The value of field <c>InvoiceWithholdBaseAmount</c>.</returns>
    protected Amount calcInvoiceWithholdBaseAmount(TaxWithholdTrans _taxWithholdTrans,
                                                   AmountCur        _custVendTransAmountCur,
                                                   AmountMST        _accumPayment,
                                                   AmountMST        _accumBaseAmountFromPreviousPayment)
    {
        return CurrencyExchangeHelper::amount(
            this.calcInvoiceWithholdBase(_taxWithholdTrans, _custVendTransAmountCur, _accumPayment, _accumBaseAmountFromPreviousPayment, true) - _taxWithholdTrans.InvoiceExemptedAmount,
            _taxWithholdTrans.InvoiceCurrency);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInvoiceWithholdBase</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the withhold base amount before applying the invoice currency rounding.
    /// </summary>
    /// <param name = "_taxWithholdTrans">The buffer of <c>TaxWithholdTrans</c>.</param>
    /// <param name = "_custVendTransAmountCur">Customer or vendor transaction currency amount.</param>
    /// <param name = "_accumPayment">The accounting payment amount.</param>
    /// <param name = "_accumBaseAmountFromPreviousPayment">The accounting base amount which from previous payment amount.</param>
    /// <param name = "_useBrazilCalculation">The flag set True if we need to do the Brazil specific calculations.</param>
    /// <returns>The value of field <c>InvoiceWithholdBaseAmount</c> before the invoice currency rounding.</returns>
    protected Amount calcInvoiceWithholdBase(
        TaxWithholdTrans _taxWithholdTrans,
        AmountCur _custVendTransAmountCur,
        AmountMST _accumPayment,
        AmountMST _accumBaseAmountFromPreviousPayment,
        boolean _useBrazilCalculation)
    {
        AmountCur retainedTaxAmount;
        boolean useBrazilCalculation = BrazilParameters::isEnabled() && _useBrazilCalculation;

        if (useBrazilCalculation)
        {
            retainedTaxAmount = this.getActualRetainedTaxAmount(_taxWithholdTrans);
        }

        return (_taxWithholdTrans.InvoiceBaseAmount
            * (!useBrazilCalculation ? 1 : _taxWithholdTrans.IntersectionWithholdBaseAmount_BR / (_custVendTransAmountCur - retainedTaxAmount)))
            + (!useBrazilCalculation ? 0 : _accumPayment + _accumBaseAmountFromPreviousPayment)
            - _taxWithholdTrans.InvoiceNotTaxableByTreaty
            - _taxWithholdTrans.InvoiceNotTaxableExpenses;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualRetainedTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the taxAmount of the current transaction when check retained tax.
    /// </summary>
    /// <param name = "taxWithholdTrans">The buffer of <c>TaxWithholdTrans</c>.</param>
    /// <returns>The value of field <c>SourceRegulateAmountCur</c>.</returns>
    private AmountCur getActualRetainedTaxAmount(TaxWithholdTrans taxWithholdTrans)
    {
        TaxTrans taxTrans;
        TaxTable taxTable;

        if (this.onlyHasRetainedTax(taxWithholdTrans))
        {
            select sum(SourceRegulateAmountCur) from taxTrans
                join RecId from taxTable
                    where taxTable.RetainedTax_BR == NoYes::Yes
                        && taxTable.TaxCode == taxTrans.TaxCode
                        && taxTrans.Voucher == taxWithholdTrans.VoucherInvoice;
        }
        
        return taxTrans.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentSched</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the setting of the payment schedule on the PO header or SO header.
    /// </summary>
    /// <param name = "taxWithholdTrans">The buffer of <c>TaxWithholdTrans</c>.</param>
    /// <returns>The value of hasTaxDistribution and taxDistribution.</returns>
    private container getPaymentSched(TaxWithholdTrans taxWithholdTrans)
    {
        PurchTable purchTable;
        SalesTable salesTable;
        SpecTrans specTrans;
        VendTransOpen vendTransOpen;
        CustTransOpen custTransOpen;
        VendInvoiceJour vendInvoiceJour;
        CustInvoiceJour custInvoiceJour;
        VendTrans vendTrans;
        CustTrans custTrans;
        PaymSched paymSched;
        boolean hasTaxDistribution = false;

        select firstonly RefCompany, RefTableId, RefRecId from specTrans
            where specTrans.RecId == taxWithholdTrans.SpecTransId;

        if (tableNum(VendTransOpen) == specTrans.RefTableId)
        {
            select firstonly RecId, TaxDistribution from paymSched
                join RecId from purchTable
                    where purchTable.PaymentSched == paymSched.Name
                join RecId from vendInvoiceJour
                    where vendInvoiceJour.PurchId == purchTable.PurchId
                join RecId from vendTrans
                    where vendTrans.Voucher == vendInvoiceJour.LedgerVoucher
                        && vendTrans.AccountNum == vendInvoiceJour.InvoiceAccount
                        && vendTrans.TransDate == vendInvoiceJour.InvoiceDate
                join RecId from vendTransOpen
                    where vendTransOpen.AccountNum == vendTrans.AccountNum
                        && vendTransOpen.RefRecId == vendTrans.RecId
                        && vendTransOpen.dataAreaId == specTrans.RefCompany
                        && vendTransOpen.TableId == specTrans.RefTableId
                        && vendTransOpen.RecId == specTrans.RefRecId;

            if (paymSched.RecId)
            {
                hasTaxDistribution = true;
            }
        }
        else if (tableNum(CustTransOpen) == specTrans.RefTableId)
        {
            select firstonly TaxDistribution from paymSched
                join RecId from salesTable
                    where salesTable.PaymentSched == paymSched.Name
                join RecId from custInvoiceJour
                    where custInvoiceJour.SalesId == salesTable.SalesId
                join RecId from custTrans
                    where custTrans.Voucher == custInvoiceJour.LedgerVoucher
                        && custTrans.AccountNum == custInvoiceJour.InvoiceAccount
                        && custTrans.TransDate == custInvoiceJour.InvoiceDate
                join RecId from custTransOpen
                    where custTransOpen.AccountNum == custTrans.AccountNum
                        && custTransOpen.RefRecId == custTrans.RecId
                        && custTransOpen.dataAreaId == specTrans.RefCompany
                        && custTransOpen.TableId == specTrans.RefTableId
                        && custTransOpen.RecId == specTrans.RefRecId;

            if (paymSched.RecId)
            {
                hasTaxDistribution = true;
            }
        }

        return [hasTaxDistribution, paymSched.TaxDistribution];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxDistributionFromCustVendTransOpen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the installment record on vendTransOpen or custTransOpen table.
    /// </summary>
    /// <param name = "taxWithholdTrans">The buffer of <c>TaxWithholdTrans</c>.</param>
    /// <returns>The value of field <c>TaxDistribution</c>.</returns>
    private PaymSchedTaxDistribution getTaxDistributionFromCustVendTransOpen(TaxWithholdTrans taxWithholdTrans)
    {
        SpecTrans specTrans;
        VendTransOpen vendTransOpen;
        CustTransOpen custTransOpen;
        PaymSchedTaxDistribution taxDistribution;

        select firstonly RefCompany, RefTableId, RefRecId from specTrans
            where specTrans.RecId == taxWithholdTrans.SpecTransId;

        if (tableNum(VendTransOpen) == specTrans.RefTableId)
        {
            select firstonly TaxDistribution from vendTransOpen
                where vendTransOpen.dataAreaId == specTrans.RefCompany
                    && vendTransOpen.TableId == specTrans.RefTableId
                    && vendTransOpen.RecId == specTrans.RefRecId;

            taxDistribution = vendTransOpen.TaxDistribution;
        }
        else if (tableNum(CustTransOpen) == specTrans.RefTableId)
        {
            select firstonly TaxDistribution from custTransOpen
                where custTransOpen.dataAreaId == specTrans.RefCompany
                    && custTransOpen.TableId == specTrans.RefTableId
                    && custTransOpen.RecId == specTrans.RefRecId;

            taxDistribution = custTransOpen.TaxDistribution;
        }

        return taxDistribution;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onlyHasRetainedTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if the current Tax code contains non-retained tax.
    /// </summary>
    /// <param name = "taxWithholdTrans">The buffer of <c>TaxWithholdTrans</c>.</param>
    /// <returns>True if has only retained tax, otherwise, false.</returns>
    private boolean onlyHasRetainedTax(TaxWithholdTrans taxWithholdTrans)
    {
        TaxTrans taxTrans;
        TaxTable taxTable;
        boolean onlyHasRetainedTax = true;

        select firstonly RecId from taxTable
            join RecId from taxTrans
                where taxTable.RetainedTax_BR == NoYes::No
                    && taxTable.TaxCode == taxTrans.TaxCode
                    && taxTrans.Voucher == taxWithholdTrans.VoucherInvoice;
            
        if (taxtable.recid)
        {
            onlyHasRetainedTax = false;
        }

        return onlyHasRetainedTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onlyHasRetainedAndIncludedTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current Tax code contains only retained tax and include tax.
    /// </summary>
    /// <param name = "taxWithholdTrans">The buffer of <c>TaxWithholdTrans</c>.</param>
    /// <returns>True if has only retained tax and include tax, otherwise, false.</returns>
    private boolean onlyHasRetainedAndIncludedTax(TaxWithholdTrans taxWithholdTrans)
    {
        TaxTrans taxTrans;
        TaxTable taxTable;
        boolean onlyHasRetainedTaxAndIncludedTax = true;

        select firstonly RecId from taxTable
            join RecId from taxTrans
                where taxTable.RetainedTax_BR == NoYes::No
                    && taxTable.IncludedTax_BR == NoYes::No
                    && taxTable.TaxCode == taxTrans.TaxCode
                    && taxTrans.Voucher == taxWithholdTrans.VoucherInvoice;
            
        if (taxtable.RecId)
        {
            onlyHasRetainedTaxAndIncludedTax = false;
        }

        return onlyHasRetainedTaxAndIncludedTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBaseAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get withholdBaseAmount.
    /// </summary>
    /// <param name = "_taxWithholdTrans">The buffer of <c>TaxWithholdTrans</c>.</param>
    /// <returns>The value of baseAmount.</returns>
    private TaxWithholdAmount getBaseAmount(TaxWithholdTrans _taxWithholdTrans)
    {
        TaxWithholdAmount baseAmount;
        PaymSchedTaxDistribution taxDistribution, taxDistributionPaymSched;
        boolean hasPaymentSched;
        AmountCur retainedTaxAmount, invoiceRetainedTaxAmount;

        if (this.onlyHasRetainedAndIncludedTax(_taxWithholdTrans))
        {
            taxDistribution = this.getTaxDistributionFromCustVendTransOpen(_taxWithholdTrans);
            retainedTaxAmount = this.getActualRetainedTaxAmount(_taxWithholdTrans);
            [hasPaymentSched, taxDistributionPaymSched] = this.getPaymentSched(_taxWithholdTrans);

            if (!hasPaymentSched || (hasPaymentSched && (taxDistribution == PaymSchedTaxDistribution::FirstRate || taxDistribution == PaymSchedTaxDistribution::LastRate)))
            {
                baseAmount = ((_taxWithholdTrans.InvoiceAmount + abs(retainedTaxAmount)) *
                               _taxWithholdTrans.IntersectionWithholdBaseAmount_BR  / (custVendTransAmountCur - retainedTaxAmount));
            }
            else if (taxDistributionPaymSched == PaymSchedTaxDistribution::Proportional)
            {
                TaxWithholdAmount taxInvoiceAmount = this.calculateProportionalRetainedTaxAmount(retainedTaxAmount, _taxWithholdTrans);
                baseAmount = ((_taxWithholdTrans.InvoiceAmount - taxInvoiceAmount) *
                               _taxWithholdTrans.IntersectionWithholdBaseAmount_BR  / (custVendTransAmountCur - retainedTaxAmount));
            }
            else
            {
                baseAmount = (_taxWithholdTrans.InvoiceAmount *
                              _taxWithholdTrans.IntersectionWithholdBaseAmount_BR  / (custVendTransAmountCur - retainedTaxAmount));
            }
        }
        else
        {
            baseAmount = (_taxWithholdTrans.InvoiceAmount *
                          _taxWithholdTrans.IntersectionWithholdBaseAmount_BR  / custVendTransAmountCur);
        }

        return baseAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateProportionalRetainedTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates proportional retained tax amount.
    /// </summary>
    /// <param name = "_retainedTaxAmount">The whole retained tax amount.</param>
    /// <param name = "_taxWithholdTrans">The buffer of <c>TaxWithholdTrans</c>.</param>
    /// <returns>The proportional retained tax amount.</returns>
    private TaxWithholdAmount calculateProportionalRetainedTaxAmount(AmountCur _retainedTaxAmount, TaxWithholdTrans _taxWithholdTrans)
    {
        AmountCur retainedTaxAmount;
        if (custVendTransAmountCur)
        {
            retainedTaxAmount =  CurrencyExchangeHelper::amount(_retainedTaxAmount * _taxWithholdTrans.InvoiceAmount / custVendTransAmountCur, _taxWithholdTrans.InvoiceCurrency);
        }
        return retainedTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxWithholdAmountFromTaxWithholdTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get taxWithholdAmount from taxWithholdTrans.
    /// </summary>
    /// <param name = "taxWithholdTrans">The buffer of <c>TaxWithholdTrans</c>.</param>
    /// <param name = "tmpTaxWithhold">The buffer of <c>TmpTaxWithhold</c>.</param>
    /// <returns>The value of field <c>TaxWithholdAmount</c>.</returns>
    private TaxWithholdAmount getTaxWithholdAmountFromTaxWithholdTrans(TaxWithholdTrans taxWithholdTrans, TmpTaxWithhold tmpTaxWithhold)
    {
        PaymSchedTaxDistribution taxDistribution, taxDistributionPaymSched;
        boolean hasPaymentSched;
        AmountCur retainedTaxAmount, invoiceRetainedTaxAmount;

        if (BrazilParameters::isEnabled() && this.onlyHasRetainedAndIncludedTax(taxWithholdTrans))
        {
            taxDistribution = this.getTaxDistributionFromCustVendTransOpen(taxWithholdTrans);
            [hasPaymentSched, taxDistributionPaymSched] = this.getPaymentSched(taxWithholdTrans);
            if (!TaxWithholdIncludeRetainedTaxOnBaseAmount_BRFlight::instance().isEnabled())
            {
                retainedTaxAmount = this.getActualRetainedTaxAmount(taxWithholdTrans);
            }

            if ((!hasPaymentSched) || (hasPaymentSched && (taxDistribution == PaymSchedTaxDistribution::FirstRate || taxDistribution == PaymSchedTaxDistribution::LastRate)))
            {
                taxWithholdTrans.TaxWithholdAmount = (taxWithholdTrans.WithholdBaseAmount - retainedTaxAmount) * tmpTaxWithhold.TaxWithholdValue / 100;
            }
            else if (taxDistributionPaymSched == PaymSchedTaxDistribution::Proportional)
            {
                int sign = sign(taxWithholdTrans.WithholdBaseAmount);
                TaxWithholdAmount taxInvoiceAmount = this.calculateProportionalRetainedTaxAmount(retainedTaxAmount, taxWithholdTrans);
                taxWithholdTrans.TaxWithholdAmount = (abs(taxWithholdTrans.WithholdBaseAmount) - taxInvoiceAmount) * sign * tmpTaxWithhold.TaxWithholdValue / 100;
            }
            else
            {
                taxWithholdTrans.TaxWithholdAmount = taxWithholdTrans.WithholdBaseAmount * tmpTaxWithhold.TaxWithholdValue / 100;
            }
        }
        else
        {
            taxWithholdTrans.TaxWithholdAmount = taxWithholdTrans.WithholdBaseAmount * tmpTaxWithhold.TaxWithholdValue / 100;
        }

        return taxWithholdTrans.TaxWithholdAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcWithholdingTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method calculates withholding tax amount.
    /// </summary>
    /// <param name="_taxWithholdGroup">
    ///     A tax withholding group.
    /// </param>
    /// <param name="_taxWithholdItemGroupHeading_TH">
    ///     A tax item withholding group RecId.
    /// </param>
    /// <param name="_lineAmount">
    ///     Line amount without tax.
    /// </param>
    /// <param name="_transDate">
    ///     Date of withholding transaction.
    /// </param>
    /// <param name="_taxAmount">
    ///     Line tax amount.
    /// </param>
    /// <returns>
    /// Withholding tax amount.
    /// </returns>
    internal static AmountCur calcWithholdingTax(
        TaxWithholdGroup _taxWithholdGroup,
        TaxWithholdAccountGroupId_TH _taxWithholdItemGroupHeading_TH,
        Amount _lineAmount,
        TransDate _transDate,
        TaxAmount _taxAmount = 0)
    {
        AmountCur               tempAmount;

        if (_taxWithholdGroup && _taxWithholdItemGroupHeading_TH && _lineAmount > 0)
        {
            TaxWithholdGroupData taxWithholdGroupData;
            TaxWithholdOnItem_TH taxWithholdOnItem_TH;

            while select TaxWithholdCode from taxWithholdOnItem_TH
                where taxWithholdOnItem_TH.TaxWithholdItemGroupHeading_TH == _taxWithholdItemGroupHeading_TH
                exists join taxWithholdGroupData
                    where taxWithholdGroupData.TaxWithholdGroup == _taxWithholdGroup &&
                        taxWithholdOnItem_TH.TaxWithholdCode == taxWithholdGroupData.TaxWithholdCode
            {
                TaxWithholdData taxWithholdData = TaxWithholdData::find(taxWithholdOnItem_TH.TaxWithholdCode, _transDate, _lineAmount);

                if (taxWithholdData)
                {
                    TaxWithholdTable taxWithholdTable = TaxWithholdTable::find(taxWithholdOnItem_TH.TaxWithholdCode);

                    if (taxWithholdTable.TaxWithholdBaseType == TaxWithholdBaseType::PctPerGross)
                    {
                        tempAmount += (_lineAmount + _taxAmount) * (taxWithholdData.TaxWithholdValue / 100);
                    }
                    else
                    {
                        tempAmount += _lineAmount * (taxWithholdData.TaxWithholdValue / 100);
                    }
                }
            }
        }
        return tempAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>payment2TaxWithhold</Name>
				<Source><![CDATA[
    private AmountCur payment2TaxWithhold(
        AmountCur _paymentAmount,
        CurrencyCode _paymentCurrency,
        CurrencyCode _taxWithholdCurrency,
        ExchRate _taxWithholdExchRate,
        TransDate _taxWithholdExchRateDate,
        boolean _roundResult = false)
    {
        AmountCur withholdAmountInTaxCurrency;

        if (_paymentAmount == 0)
        {
            return 0;
        }

        CurrencyExchangeHelper exchangeRateHelper = CurrencyExchangeHelper::newLedger(Ledger::current());
        exchangeRateHelper.parmExchangeRate1(_taxWithholdExchRate);
        exchangeRateHelper.parmExchangeDate(_taxWithholdExchRateDate);

        if (_paymentCurrency == _taxWithholdCurrency)
        {
            withholdAmountInTaxCurrency = _paymentAmount;
        }
        else
        {
            CurrencyCalculationResults calculationResults = exchangeRateHelper.calculateCurrencyToCurrencyAmounts(_paymentCurrency, _taxWithholdCurrency, _paymentAmount);
            withholdAmountInTaxCurrency = _roundResult ? calculationResults.getRoundedAmount() : calculationResults.getUnroundedAmount();
        }

        return withholdAmountInTaxCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipForCreatingWithholdingTax</Name>
				<Source><![CDATA[
    protected boolean shouldSkipForCreatingWithholdingTax(CustVendTrans _custVendTrans)
    {
        boolean shouldSkip;
        if (isEnableGlobalWHTFeatureAndParam
            && TaxWHTSkipWhenCustVendTaxWithholdCalculateDisabledFlight::instance().isEnabled())
        {
            ModuleCustVend moduleCustVend = _custVendTrans.tableId == tableNum(VendTrans) ? ModuleCustVend::Vend : ModuleCustVend::Cust;
            shouldSkip = !CustVendTable::findModule(moduleCustVend, _custVendTrans.AccountNum).TaxWithholdCalculate;
        }
        return shouldSkip;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>