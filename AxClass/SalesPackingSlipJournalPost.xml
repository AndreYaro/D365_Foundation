<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesPackingSlipJournalPost</Name>
	<SourceCode>
		<Declaration><![CDATA[
[DocumentStatusFactoryAttribute(DocumentStatus::PackingSlip)]
class SalesPackingSlipJournalPost
extends FormletterJournalPost
{
    SalesParmTable          salesParmTable;
    SalesParmLine           salesParmLine;

    CustPackingSlipVersion      previousCustPackingSlipVersion;
    CustPackingSlipTransHistory previousCustPackingSlipTransHistory;

    CustPackingSlipVersion  custPackingSlipVersion;
    CustPackingSlipJour     custPackingSlipJour;
    CustPackingSlipTrans    custPackingSlipTrans;
    SalesLine               salesLine;
    SalesTable              salesTable;

    SalesTotals             salesTotals;

    SalesQty                updateNow;

    RecordInsertList        recordInsertListCustPackingSlipBackorderLine;

    AmountCur               cashDiscountAmount;
    AmountCur               totalAmountCashDiscOnInvoice;

    InventMovement          inventMovement;
    boolean                 mrcPostingErr;
    boolean                 mrcPrintOnPack;
    PDSMRCParameters        pdsMRCParameters;

    // <GBR>
    List                    journalLines_BR;
    DeliverySlipTotals_BR   deliverySlipTotals;
    boolean                 isCountryRegion_BR;
    // </GBR>
    // <GEERU>
    boolean                 isCountryRegion_RU;
    // </GEERU>
    SalesParameters         salesParameters;
    TaxParameters           taxParameters;

    boolean                 needUpdateSiblingLinesInSameJournal;

    protected boolean       isPostingTransportLoads;
    private SalesInstrumentationLogger instrumentationLogger;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addToInventReportDimHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a record to the <c>InventReportDimHistory</c> table.
    /// </summary>
    /// <param name="_journalline">
    /// A journal line record.
    /// </param>
    protected void addToInventReportDimHistory(Common _journalline)
    {
        InventTrackingRegisterTransDimIterator  trackingDimIterator;
        CustPackingSlipTrans                    localCustPackingSlipTrans = _journalline as CustPackingSlipTrans;
        InventQty                               qtyRemain                 = localCustPackingSlipTrans.InventQty;
     
        void createInventReportDimHistory(InventQty _qty, InventDimId _inventDimId)
        {
            qtyRemain = this.createInventReportDimHistory(localCustPackingSlipTrans.InventTransId,
                                                        _inventDimId,
                                                        custPackingSlipVersion.InternalPackingSlipId,
                                                        _qty, qtyRemain);
        }

        if (salesLine.isStocked())
        {
            boolean isSalesProcessEnabled = localCustPackingSlipTrans.inventTable().isActiveInSalesProcess();
            if (isSalesProcessEnabled)
            {
                trackingDimIterator = InventTrackingRegisterTransDimIterator::newFromPhysicalJournalLine(localCustPackingSlipTrans);
            }

            Query query = this.buildInventReportDimHistoryCreationQuery(localCustPackingSlipTrans);
            QueryRun queryRun = new QueryRun(query);

            while (queryRun.next())
            {
                InventTransOrigin inventTransOrigin = queryRun.get(tableNum(InventTransOrigin));
                InventTrans inventTrans = queryRun.get(tableNum(InventTrans));
                InventDim transInventDim = queryRun.get(tableNum(InventDim));

                if (qtyRemain)
                {
                    if (!isSalesProcessEnabled)
                    {
                        createInventReportDimHistory(inventTrans.Qty, inventTrans.InventDimId);
                    }
                    else
                    {
                        InventDim newInventDim = trackingDimIterator.nextTrackingDim(transInventDim);
                        InventQty remainingInventTransQty = inventTrans.Qty;

                        // we need to split inventTrans to several lines with qty=-1 to include tracking dimensions
                        while (newInventDim && remainingInventTransQty != 0)
                        {
                            InventQty currentQty = trackingDimIterator.currentQty();
                            createInventReportDimHistory(currentQty, newInventDim.InventDimId);
                            remainingInventTransQty -= currentQty;

                        if (remainingInventTransQty != 0)
                        {
                            newInventDim = trackingDimIterator.nextTrackingDim(transInventDim);
                        }
                    }

                        if (remainingInventTransQty)
                        {
                            createInventReportDimHistory(remainingInventTransQty, inventTrans.InventDimId);
                        }
                    }
                }
                else
                    break;
            }
        }
        else
        {
            this.createInventReportDimHistory(localCustPackingSlipTrans.InventTransId,
                                              localCustPackingSlipTrans.InventDimId,
                                              custPackingSlipVersion.InternalPackingSlipId,
                                              localCustPackingSlipTrans.Qty,
                                              localCustPackingSlipTrans.Qty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildInventReportDimHistoryCreationQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the <c>Query</c> object used in the creation of the <c>InventReportDimHistory</c> records.
    /// </summary>
    /// <param name = "_custPackingSlipTrans">
    /// The <c>CustPackingSlipTrans</c> record to filter on.
    /// </param>
    /// <returns>
    /// A <c>Query</c> object used in the creation of the <c>InventReportDimHistory</c> records.
    /// </returns>
    protected Query buildInventReportDimHistoryCreationQuery(CustPackingSlipTrans _custPackingSlipTrans)
    {
        Query query = new Query();

        QueryBuildDataSource qbdsInventTransOrigin = query.addDataSource(tableNum(InventTransOrigin));
        qbdsInventTransOrigin.addSelectionField(fieldNum(InventTransOrigin, TableId));
        qbdsInventTransOrigin.addRange(fieldNum(InventTransOrigin, InventTransId)).value(queryValue(_custPackingSlipTrans.InventTransId));
        qbdsInventTransOrigin.addRange(fieldNum(InventTransOrigin, ReferenceCategory)).value(queryValue(InventTransType::Sales));

        QueryBuildDataSource qbdsInventTrans = qbdsInventTransOrigin.addDataSource(tableNum(InventTrans));
        qbdsInventTrans.addSelectionField(fieldNum(InventTrans, InventDimId));
        qbdsInventTrans.addSelectionField(fieldNum(InventTrans, Qty));
        qbdsInventTrans.addLink(fieldNum(InventTransOrigin, RecId), fieldNum(InventTrans, InventTransOrigin));
        qbdsInventTrans.addRange(fieldNum(InventTrans, DatePhysical)).value(queryValue(_custPackingSlipTrans.DeliveryDate));
        qbdsInventTrans.addRange(fieldNum(InventTrans, PackingSlipReturned)).value(queryValue(NoYes::No));
        if (salesLine.SalesType == SalesType::ItemReq)
        {
            qbdsInventTrans.addRange(fieldNum(InventTrans, InvoiceId)).value(queryValue(_custPackingSlipTrans.PackingSlipId));
        }
        else
        {
            qbdsInventTrans.addRange(fieldNum(InventTrans, PackingSlipId)).value(queryValue(_custPackingSlipTrans.PackingSlipId));
        }

        QueryBuildDataSource qbdsInventDim = qbdsInventTrans.addDataSource(tableNum(InventDim));
        qbdsInventDim.addLink(fieldNum(InventTrans, InventDimId), fieldNum(InventDim, InventDimId));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether ledger postings can occur.
    /// </summary>
    /// <returns>
    /// true if ledger postings can occur; otherwise, false.
    /// </returns>
    protected boolean canPostLedger()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBeforePostingLine</Name>
				<Source><![CDATA[
    protected void checkBeforePostingLine()
    {
        super();

        if (isConfigurationkeyEnabled(configurationKeyNum(PdsMRC)))
        {
            List psdsDocuRefRecIdList = PdsMRCRegulated_Sales_PackingSlip::checkRegulatedWarnBreakAndPrint(
                mrcPostingErr,
                this.pdsMRCParameters().RegulationWarningOnPack,
                mrcPrintOnPack,
                salesLine);
            if (mrcPrintOnPack)
            {
                if(psdsDocuRefRecIdList && !psdsDocuRefRecIdList.empty())
                {
                    ListEnumerator listEnumerator = psdsDocuRefRecIdList.getEnumerator();

                    while (listEnumerator.moveNext())
                    {
                        docuRefRecIdList.addEnd(listEnumerator.current());
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBackorderLines</Name>
				<Source><![CDATA[
    protected void createBackorderLines()
    {
        SalesLine       localSalesLine;
        LogisticsPostalAddress postalAddress;

        if (!previousCustPackingSlipVersion)
        {
            ttsbegin;

            while select localSalesLine
                  exists join postalAddress
                    where localSalesLine.DeliveryPostalAddress  == postalAddress.RecId
                       && localSalesLine.SalesId                == salesTable.SalesId
                       && localSalesLine.SalesStatus            == SalesStatus::Backorder
                       && localSalesLine.RemainInventPhysical   != 0
                       && (localSalesLine.SalesType             != SalesType::Subscription  ||  // Only create backorders for subscriptions
                           localSalesLine.RemainInventPhysical  != localSalesLine.QtyOrdered)   // if the remaining quantity is different from the ordered quantity
                       && (salesParameters.SplitDeliveryPackingSlip == NoYes::No            ||  // Only check the address if there is a split per address
                           (postalAddress.RecId                 == custPackingSlipJour.DeliveryPostalAddress &&
                            localSalesLine.DeliveryName         == custPackingSlipJour.DeliveryName      &&
                            localSalesLine.DlvMode              == custPackingSlipJour.DlvMode))
            {
                if (salesParameters.splitSite(this.documentStatus())) // if split on site
                {
                    if (localSalesLine.inventDim().InventSiteId == salesParmTable.InventSiteId) // check for same site
                    {
                        this.insertBackorderLine(localSalesLine);
                    }
                }
                else
                {
                    this.insertBackorderLine(localSalesLine);
                }
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBackorderLinesHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates <c>CustPackingSlipBackorderLineHistory</c> records for the current packing slip version.
    /// </summary>
    protected void createBackorderLinesHistory()
    {
        CustPackingSlipBackorderLine custPackingSlipBackorderLine;
        CustPackingSlipBackorderLineHistory custPackingSlipBackorderLineHistory;
        CustPackingSlipBackorderLineHistory previousCustPackingSlipBackorderLineHistory;
        VersioningTimeStamp         validFrom, validTo;

        validFrom = custPackingSlipVersion.VersionDateTime;
        validTo = DateTimeUtil::maxValue();

        ttsbegin;
        if (!previousCustPackingSlipVersion.RecId)
        {
            insert_recordset custPackingSlipBackorderLineHistory(CustPackingSlipBackorderLine,  ValidFrom, ValidTo, QtyBackorderSales, QtyBackorderInvent
                , PdsCWQtyBackorder
                )
                select RecId, validFrom, validTo, QtyBackorderSales, QtyBackorderInvent
                    , PdsCWQtyBackorder
                    from custPackingSlipBackorderLine
                    where custPackingSlipBackorderLine.SalesId == custPackingSlipJour.SalesId
                       && custPackingSlipBackorderLine.PackingSlipId == custPackingSlipJour.PackingSlipId
                       && custPackingSlipBackorderLine.DeliveryDate == custPackingSlipJour.DeliveryDate;
        }
        else
        {
            insert_recordset custPackingSlipBackorderLineHistory(CustPackingSlipBackorderLine,  ValidFrom, ValidTo, QtyBackorderSales, QtyBackorderInvent
                , PdsCWQtyBackorder
                )
                select RecId, validFrom, validTo, QtyBackorderSales, QtyBackorderInvent
                    , PdsCWQtyBackorder
                    from custPackingSlipBackorderLine
                    where custPackingSlipBackorderLine.SalesId == custPackingSlipJour.SalesId
                       && custPackingSlipBackorderLine.PackingSlipId == custPackingSlipJour.PackingSlipId
                       && custPackingSlipBackorderLine.DeliveryDate == custPackingSlipJour.DeliveryDate
                notexists join previousCustPackingSlipBackorderLineHistory
                    where previousCustPackingSlipBackorderLineHistory.CustPackingSlipBackorderLine == custPackingSlipBackorderLine.RecId
                       && previousCustPackingSlipBackorderLineHistory.QtyBackorderSales == custPackingSlipBackorderLine.QtyBackorderSales
                       && previousCustPackingSlipBackorderLineHistory.QtyBackorderInvent == custPackingSlipBackorderLine.QtyBackorderInvent;
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNotStockedPostCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a <c>TradeNotStockedPostCheck</c> object that is used to verify order lines during
    /// posting.
    /// </summary>
    /// <returns>
    /// A <c>TradeNotStockedPostCheck</c> object that is used to verify order lines during posting.
    /// </returns>
    /// <remarks>
    /// This method can return null if no verification should be performed.
    /// </remarks>
    protected TradeNotStockedPostCheck createNotStockedPostCheck()
    {
        return TradeNotStockedPostCheck::newSalesLine(salesLine, custPackingSlipTrans.Qty, custPackingSlipTrans.Remain, salesParmLine.RemainBefore);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReportData</Name>
				<Source><![CDATA[
    public boolean createReportData(FormletterJournalPrint _formletterJournalPrint)
    {
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU])
         || BrazilParameters::isEnabled())
        {
			//other reports are printed in this case. they do not support new way of printing proforma yet.
            return false;
        }

        CustPackingSlipVersion localCustPackingSlipVersion = CustPackingSlipVersion::findLatest(formletterJournal.RecId);
        if (localCustPackingSlipVersion)
        {
            SalesPackingSlipContract salesPackingSlipContract = new SalesPackingSlipContract();
            salesPackingSlipContract.parmRecordId(localCustPackingSlipVersion.RecId);

            this.createSalesPackingSlipDataProvider(salesPackingSlipContract);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateSalesPackingSlipDataProvider</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates a <c>SalesPackingSlipDP</c> report data provider class.
    /// </summary>
    /// <param name = "_salesPackingSlipContract">
    /// An instance of <c>SalesPackingSlipContract</c> report contract class.
    /// </param>
    /// <returns>
    /// The <c>SalesPackingSlipDP</c> report data provider class.
    /// </returns>
    protected SalesPackingSlipDP instantiateSalesPackingSlipDataProvider(SalesPackingSlipContract _salesPackingSlipContract)
    {
        return new SalesPackingSlipDP();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSalesPackingSlipDataProvider</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates data for the <c>SalesPackingSlipDP</c> report data provider class.
    /// </summary>
    /// <param name="_salesPackingSlipContract">
    /// An instance of <c>SalesPackingSlipContract</c> report contract class.
    /// </param>
    protected void createSalesPackingSlipDataProvider(SalesPackingSlipContract _salesPackingSlipContract)
    {
        SalesPackingSlipDP salesPackingSlipDP = this.instantiateSalesPackingSlipDataProvider(_salesPackingSlipContract);
        salesPackingSlipDP.createData(_salesPackingSlipContract);
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditNote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the posting is for a credit note.
    /// </summary>
    /// <returns>
    /// true if the posting is for a credit note; otherwise, false.
    /// </returns>
    protected NoYes creditNote()
    {
        NoYes creditNote;

        if (taxParameters.CashDiscOnInvoice)
        {
            if (totalAmountCashDiscOnInvoice < 0)
                creditNote = NoYes::Yes;
            else
                creditNote = NoYes::No;
        }
        else
        {
            if (salesTotals.isCreditNote())
                creditNote = NoYes::Yes;
            else
                creditNote = NoYes::No;
        }
        return creditNote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the type of document
    /// </summary>
    /// <returns>
    /// An element of <c>DocumentStatus</c> enumeration
    /// </returns>
    protected DocumentStatus  documentStatus()
    {
        // <GBR>
        if (isCountryRegion_BR)
        {
            return salesParmTable.Ordering;
        }
        // </GBR>

        return DocumentStatus::PackingSlip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>endLines</Name>
				<Source><![CDATA[
    protected void endLines()
    {
        if (!this.postMarkupLineBeforeInventory())
        {
            this.postMarkupOnSalesLine();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postJournalPost</Name>
				<Source><![CDATA[
	/// <summary>
    /// Insert the tracking number information in the packing slip.
    /// </summary>
	public void postJournalPost()
    {
        super();
        custPackingSlipJour.initTrackingNumbers(salesParmTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>endPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ends the posting.
    /// </summary>
    protected void endPost()
    {
        this.updateWMSShipment();
        this.updateWHSLoadTable();
        this.updateSalesShippingStat();
        this.updateBankLC();
        this.createBackorderLinesHistory();
        this.createWHSTransportLoadCustPackingSlipJourRecords();

        // <GBR>
        if (isCountryRegion_BR)
        {
            this.postEndPost_BR();
        }
        // </GBR>

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX])
            && salesParmTable.CFDIEnabled_MX
            && chainFormletterContract.parmVersioningUpdateType() != VersioningUpdateType::Cancel)
        {
            this.postEndPost_MX();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endPostLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ends the posting of a journal line.
    /// </summary>
    protected void endPostLine()
    {
        if (WHSPopulatePackingSlipIdFromShipmentFlight::instance().isEnabled()
            && this.mustUpdateNonPostedParmLines())
        {
            this.updateNonPostedParmLines(salesParmLine);
        }

        inventMovement = null; //Ensures that the internal recordViewCache in inventMovement is deactivated again.
        previousCustPackingSlipTransHistory = null;

        if (needUpdateSiblingLinesInSameJournal)
        {
            this.updateSiblingLinesInSameJournal();
        }

        super();

        // <GBR>
        if (isCountryRegion_BR)
        {
            this.postEndPostLine_BR();
        }
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNonPostedParmLines</Name>
				<Source><![CDATA[
    private void updateNonPostedParmLines(SalesParmLine _salesParmLine)
    {
        SalesParmLine localSalesParmLine;
        // if the same lot id is posted in two different parms in the same posting
        // quantities on parm lines may need to be re-adjusted, since the remain has changed
        while select RecId from localSalesParmLine
            where localSalesParmLine.ParmId == _salesParmLine.ParmId &&
                  localSalesParmLine.OrigSalesId == _salesParmLine.OrigSalesId &&
                  localSalesParmLine.InventTransId == _salesParmLine.InventTransId &&
                  // <GEERU>
                  (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) ||
                  localSalesParmLine.InventOwnerId_RU == _salesParmLine.InventOwnerId_RU)
             // </GEERU>
             && localSalesParmLine.TableRefId != _salesParmLine.TableRefId

        {
            SalesParmLine updateSalesParmLine = SalesParmLine::findRecId(localSalesParmLine.RecId, true);
            updateSalesParmLine.RemainBefore -= updateNow;
            updateSalesParmLine.RemainBeforeInvent -= updateNowInvent;
            updateSalesParmLine.PdsCWRemainBefore -= cwUpdateNow;
            updateSalesParmLine.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateNonPostedParmLines</Name>
				<Source><![CDATA[
    private boolean mustUpdateNonPostedParmLines()
    {
        //there is a performance overhead from trying to adjust parmlines so we limit this to currently known scenarios which is posting from loads with preallocated packingslips
        return (this.parmWHSLoadId() && salesParmTable.PreallocatedPackingSlipId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>endUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ends the update of selected records.
    /// </summary>
    /// <remarks>
    /// The <c>endUpdate</c> method in the derived classes contains the code for ending the posting of the
    /// selected records posted by the derived <c>FormLetter</c> class. For example the <c>endUpdate</c>
    /// method in the <c>SalesFormLetter</c> class ends the update for the selected sales orders. The
    /// <c>endUpdate</c> method is added to the <c>FormLetter</c> class so that you can run the
    /// <c>endUpdate</c> method when you post in batch. The <c>endUpdate</c> method is called from the
    /// <c>run</c> method in the abstract classes derived from the <c>FormLetter</c> class, and from the
    /// <c>run</c> method in the <c>FormLetterEndMultiThread</c> class.
    /// </remarks>
    protected void endUpdate()
    {
        super();
        this.interCompanyPost();
        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            this.mcrValidateGiftCardSerialNumber();
        }
        
        this.validateRetailPackingSlip();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formletterType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the form letter type.
    /// </summary>
    /// <returns>
    /// A <c>FormletterType</c> enumeration value.
    /// </returns>
    protected FormletterType formletterType()
    {
        return FormletterType::Sales;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a voucher number.
    /// </summary>
    /// <returns>
    /// A voucher number.
    /// </returns>
    protected Num getVoucher()
    {
        return custPackingSlipVersion.LedgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the class.
    /// </summary>
    public void init()
    {
        custPackingSlipVersion = CustPackingSlipVersion::findLatest(custPackingSlipJour.RecId);
        salesParameters        = SalesParameters::find();
        taxParameters          = TaxParameters::find();
        // <GBR>
        isCountryRegion_BR     = BrazilParameters::isEnabled();
        // </GBR>
        // <GEERU>
        isCountryRegion_RU     = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        super();
        salesTable = custPackingSlipJour.salesTable();

        if (this.parmTotals())
        {
            salesTotals = this.parmTotals() as SalesTotals;
        }
        else
        {
            salesTotals = SalesTotals::construct(salesParmTable, any2Enum(this.parmSpecQty()), this.parmSumBy(), custPackingSlipJour.ParmId, this.parmSumOrderId(), this.documentStatus());
        }

        this.tax(salesTotals.tax());
        cashDiscountAmount = salesTotals.cashDiscAmount();
        totalAmountCashDiscOnInvoice = salesTotals.totalAmountCashDiscOnInvoice(true);

        this.initPreviousVersionDateTime();

        // <GBR>
        if (isCountryRegion_BR)
        {
            this.postInit_BR();
        }
        // </GBR>

        needUpdateSiblingLinesInSameJournal = salesParmTable.needUpdateSiblingLinesInSameJournal();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a <c>LedgerVoucherObject</c> object.
    /// </summary>
    protected void initLedgerVoucher()
    {
        super();

        if (isCountryRegion_RU)
        {
            ledgerVoucher.findLedgerVoucherObject(voucher).parmCorrection(this.creditNote() ? salesParmTable.salesParmUpdate().StornoPhysical_RU : NoYes::No);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPreviousVersionDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the previous packing slip version.
    /// </summary>
    protected void initPreviousVersionDateTime()
    {
        select previousCustPackingSlipVersion
            order by VersionDateTime desc
            where previousCustPackingSlipVersion.CustPackingSlipJour == custPackingSlipJour.RecId
               && previousCustPackingSlipVersion.RecId != custPackingSlipVersion.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRecordLists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the record lists.
    /// </summary>
    protected void initRecordLists()
    {
        super();
        recordInsertListCustPackingSlipBackorderLine = new RecordInsertList(tableNum(CustPackingSlipBackorderLine));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRelatedLineTables</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the records that are related to the current journal line.
    /// </summary>
    protected void initRelatedLineTables()
    {
        super();

        salesLine = custPackingSlipTrans.salesLine(true);
        this.initRelatedParmLine();

        if (previousCustPackingSlipVersion)
        {
            previousCustPackingSlipTransHistory = CustPackingSlipTransHistory::find(
                custPackingSlipTrans.RecId,
                false,
                previousCustPackingSlipVersion.VersionDateTime);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRelatedParmLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an instance of the <c>SalesParmLine</c> class.
    /// </summary>
    protected void initRelatedParmLine()
    {
        if (custPackingSlipTrans.ParmLine)
        {
            salesParmLine = SalesParmLine::findRecId(custPackingSlipTrans.ParmLine, true);
        }
        else
        {
            select firstonly forupdate salesParmLine
                where salesParmLine.ParmId          == custPackingSlipVersion.ParmId
                   && salesParmLine.TableRefId      == salesParmTable.TableRefId
                   && salesParmLine.OrigSalesId     == salesLine.SalesId
                   && salesParmLine.LineNum         == salesLine.LineNum
                   && salesParmLine.SalesLineRecId  == salesLine.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTransactionTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>TransactionTxt</c> object.
    /// </summary>
    /// <param name="_ledgerTransTxt">
    /// A ledger transaction text.
    /// </param>
    /// <returns>
    /// An instance of the <c>TransactionTxt</c> object.
    /// </returns>
    protected  TransactionTxt initTransactionTxt(LedgerTransTxt  _ledgerTransTxt)
    {
        transactionTxt = TransactionTxt::construct();
        transactionTxt.setType          (LedgerTransTxt::SalesPackingSlipLedger);
        transactionTxt.setLanguage      (custPackingSlipJour.LanguageId);
        transactionTxt.setVoucher       (voucher);
        transactionTxt.setFormLetter    (custPackingSlipVersion.InternalPackingSlipId);
        transactionTxt.setKey1          (custPackingSlipJour.SalesId);
        transactionTxt.setKey2          (custPackingSlipJour.OrderAccount);
        transactionTxt.setKey3          (CustTable::groupId(custPackingSlipJour.OrderAccount));

        if (TransactionTextContext::isTypeSupported(LedgerTransTxt::SalesPackingSlipLedger))
        {
            TransactionTextContext transactionTextContext = TransactionTextContext::newForTransactionType(LedgerTransTxt::SalesPackingSlipLedger);
            transactionTextContext.setTableBuffer(custPackingSlipJour);
            transactionTextContext.setTableBuffer(custPackingSlipJour.salesTable());
            transactionTxt.setTransactionTextContext(transactionTextContext);
        }

        // <GBR>
        if (isCountryRegion_BR)
        {
            transactionTxt.setCustVendName(CustTable::find(custPackingSlipJour.OrderAccount).name());
        }
        // </GBR>

        return transactionTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromFormLetterContract</Name>
				<Source><![CDATA[
    protected void initFromFormLetterContract(SalesFormLetterContract _formletterContract)
    {
        SalesFormLetterPackingSlipContract salesFormLetterPackingSlipContract = _formletterContract as SalesFormLetterPackingSlipContract;
        this.parmMrcPostingErr(salesFormLetterPackingSlipContract.parmMrcPostingErr());
        this.parmMrcPrintOnPack(salesFormLetterPackingSlipContract.parmMrcPrintOnPack());
        this.parmIsPostingTransportLoads(salesFormLetterPackingSlipContract.parmIsPostingTransportLoads());
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertBackorderLine</Name>
				<Source><![CDATA[
    protected void insertBackorderLine(SalesLine _salesLine)
    {
        CustPackingSlipBackorderLine custPackingSlipBackorderLine = this.initializeBackorderLine(_salesLine);

        recordInsertListCustPackingSlipBackorderLine.add(custPackingSlipBackorderLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeBackorderLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the backorder packing slip line.
    /// </summary>
    /// <param name = "_salesLine">The <c>SalesLine</c> record used to initialize the backorder packing slip line.</param>
    /// <returns>The initialized backorder packing slip line.</returns>
    protected CustPackingSlipBackorderLine initializeBackorderLine(SalesLine _salesLine)
    {
        CustPackingSlipBackorderLine custPackingSlipBackorderLine;

        custPackingSlipBackorderLine.initValue();
        custPackingSlipBackorderLine.initFromSalesLine(_salesLine);
        custPackingSlipBackorderLine.initFromCustPackingSlipJour(custPackingSlipJour);

        return custPackingSlipBackorderLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertRecordList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records in the record lists into the database.
    /// </summary>
    protected void insertRecordList()
    {
        super();
        recordInsertListCustPackingSlipBackorderLine.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyPost</Name>
				<Source><![CDATA[
    protected void interCompanyPost()
    {
        if (!this.isProforma())
        {
            if (this.mustPostInterCompany())
            {
                SalesPackingSlipJournalPrint journalPrint = SalesPackingSlipJournalPrint::construct();
                RecordSortedList journalList = journalPrint.newJournalList();
                journalList.ins(custPackingSlipJour);

                if (InterCompanyPostStackOverflowPreventionFlight::instance().isEnabled())
                {
                    InterCompanyPost::postContextQueue(
                        IntercompanyPostContractPurch_PackingSlip::newFromJournal(this.parmChainFormletterContract(), custPackingSlipJour, journalList));
                }
                else
                {
                    InterCompanyPostPurch::post(this.parmChainFormletterContract(), custPackingSlipJour, journalList);
                }
            }
            else
            {
                if (custPackingSlipJour.InterCompanyCompanyId)
                {
                    // If we are not posting down the IC chain, we need to update the deliver remainder of any closed lines
                    InterCompanyPost::syncDlvRemainderCloseLinesFromICSOToICPO(salesParmTable);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustPostInterCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the inter company order must be posted.
    /// </summary>
    /// <returns>true if the order must be posted; otherwise, false.</returns>
    protected boolean mustPostInterCompany()
    {
        return custPackingSlipJour.interCompanyDoInternalPosting()
              || (custPackingSlipJour.InterCompanyCompanyId && custPackingSlipJour.interCompanyDoExternalPosting());
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventReportDimHistoryLogType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the inventory report dimension history type.
    /// </summary>
    /// <returns>
    /// A <c>InventReportDimHistoryLogType</c> enumeration value.
    /// </returns>
    protected InventReportDimHistoryLogType inventReportDimHistoryLogType()
    {
        return InventReportDimHistoryLogType::SalesPackingSlip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isConfigkeyEnabledShipCarrier</Name>
				<Source><![CDATA[
    protected boolean isConfigkeyEnabledShipCarrier()
    {
        return Global::isConfigurationkeyEnabled(configurationKeyNum(ShipCarrier));
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the current journal line record.
    /// </summary>
    /// <param name="_journalLine">
    /// A journal line record.
    /// </param>
    /// <returns>
    /// A journal line record.
    /// </returns>
    protected Common journalLine(Common _journalLine = custPackingSlipTrans)
    {
        custPackingSlipTrans = _journalLine as CustPackingSlipTrans;
        return custPackingSlipTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalLineTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the table ID for the journal line table.
    /// </summary>
    /// <returns>
    /// A table ID.
    /// </returns>
    protected TableId journalLineTableId()
    {
        return tableNum(CustPackingSlipTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerVoucherObjectDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the document values from the <c>LedgervoucherObject</c> object.
    /// </summary>
    /// <param name="_ledgerVoucherObject">
    /// A <c>LedgerVoucherObject</c> object.
    /// </param>
    /// <returns>
    /// A container that contains document values.
    /// </returns>
    protected container ledgerVoucherObjectDocument(LedgerVoucherObject _ledgerVoucherObject)
    {
        return custPackingSlipJour.DocumentDate ? [custPackingSlipJour.DocumentDate] : [custPackingSlipJour.DeliveryDate, custPackingSlipJour.PackingSlipId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrValidateGiftCardSerialNumber</Name>
				<Source><![CDATA[
    private void mcrValidateGiftCardSerialNumber()
    {
        SalesLine                   localSalesLine;
        MCRSalesLine                localMCRSalesLine;
        RetailGiftCardTransactions  retailGiftCardTransactions;

        RetailParameters retailParameters = RetailParameters::find();

        if (retailParameters.GiftCardItem &&
            !(RetailStoreTable::findRecId(salesTable.RetailSalesTable().RetailChannel)))
        {
            select firstOnly localSalesLine
                where localSalesLine.SalesId == salesTable.SalesId
                    && localSalesLine.ItemId == retailParameters.GiftCardItem
                    && localSalesLine.SalesStatus == SalesStatus::Delivered
                    && localSalesLine.RemainInventPhysical == 0
                exists join localMCRSalesLine
                where localMCRSalesLine.SalesLine == localSalesLine.RecId
                    && !localMCRSalesLine.GiftCardNumber
                    && localMCRSalesLine.GiftCardType == MCRGiftCardType::Physical
                notExists join retailGiftCardTransactions
                where retailGiftCardTransactions.MCRInventTransId == localSalesLine.InventTransId;
            if (localSalesLine)
            {
                throw error("@MCR40294");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateRetailPackingSlip</Name>
				<Source><![CDATA[
    private void validateRetailPackingSlip()
    {
        if (RetailParameters::isRetailEnabledAndInUse()
            && this.salesTable.isRetailSale()
            && RetailValidateSingleWarehouseForPickupOrderPackingSlipToggle::instance().isEnabled())
        {
            SalesLine localSalesLine;
            InventDim localInventDim;
            CustPackingSlipTrans localCustPackingSlipTrans;
            RetailDlvModeTmp retailDlvMode = RetailDlvMode::getPickupDeliveryModes();

            InventLocationId inventLocationId;
            while select RecId from localCustPackingSlipTrans
                    where localCustPackingSlipTrans.SalesId == custPackingSlipJour.SalesId
                    && localCustPackingSlipTrans.DeliveryDate == custPackingSlipJour.DeliveryDate
                    && localCustPackingSlipTrans.PackingSlipId == custPackingSlipJour.PackingSlipId
                join RecId from localSalesLine
                    where localSalesLine.SalesId == localCustPackingSlipTrans.SalesId
                    && localSalesLine.LineNum == localCustPackingSlipTrans.LineNum
                join InventLocationId from localInventDim
                    where localInventDim.InventDimId == localSalesLine.InventDimId
                exists join retailDlvMode
                    where localSalesLine.DlvMode == retailDlvMode.Code
            {
                if (!inventLocationId)
                {
                    inventLocationId = localInventDim.InventLocationId;
                }

                if (inventLocationId != localInventDim.InventLocationId)
                {
                    throw error("@Retail:RetailPickupPackingSlipSpansMultipleWarehouses");
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveFiscalDataToPackingSlip_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves fiscal references and legal texts from <c>SalesParmTable</c> table record to <c>CustPackingSlipJour</c> table record.
    /// </summary>
    protected void moveFiscalDataToPackingSlip_BR()
    {
        // Move legal texts to CustPackigSlipJour
        CFOPTable_BR deliveryCFOP = CFOPTable_BR::find(salesTable.deliveryCFOPTable_BR());
        if (deliveryCFOP)
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceBR00007, funcName());

            // Delivery CFOP legal texts
            FiscalDocumentTextUpdate_BR fiscalDocumentTextUpdate = FiscalDocumentTextUpdate_BR::newFromRecord(custPackingSlipJour);
            fiscalDocumentTextUpdate.updateTexts(FiscalDocumentTextType_BR::CFOP);

            // Fiscal references legal texts
            fiscalDocumentTextUpdate = FiscalDocumentTextUpdate_BR::newFromRecord(custPackingSlipJour);
            fiscalDocumentTextUpdate.copy(salesParmTable);
        }

        // Move fiscal references from SalesParmTable to custPackingSlipJour
        FiscalReferenceParm_BR::move(salesParmTable, custPackingSlipJour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalTable</Name>
				<Source><![CDATA[
    public Common parmJournalTable(Common _journalTable = custPackingSlipJour)
    {
        custPackingSlipJour = _journalTable as CustPackingSlipJour;
        return custPackingSlipJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMrcPostingErr</Name>
				<Source><![CDATA[
    public boolean parmMrcPostingErr(boolean _mrcPostingErr = mrcPostingErr)
    {
        mrcPostingErr = _mrcPostingErr;

        return mrcPostingErr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMrcPrintOnPack</Name>
				<Source><![CDATA[
    public boolean parmMrcPrintOnPack(boolean _mrcPrintOnPack = mrcPrintOnPack)
    {
        mrcPrintOnPack = _mrcPrintOnPack;

        return mrcPrintOnPack;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmTable</Name>
				<Source><![CDATA[
    public Common parmParmTable(Common _parmTable = salesParmTable)
    {
        salesParmTable = _parmTable as SalesParmTable;
        return salesParmTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShipmentId</Name>
				<Source><![CDATA[
    public WMSShipmentId parmShipmentId(WMSShipmentId _shipmentId = shipmentId)
    {
        shipmentId = _shipmentId;
        return shipmentId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsPostingTransportLoads</Name>
				<Source><![CDATA[
    public boolean parmIsPostingTransportLoads(boolean _isPostingTransportLoads = isPostingTransportLoads)
    {
        isPostingTransportLoads = _isPostingTransportLoads;

        return isPostingTransportLoads;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsMRCParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>PdsMCRParameters</c> record.
    /// </summary>
    /// <returns>
    /// The <c>PdsMCRParameters</c> record.
    /// </returns>
    protected PdsMRCParameters pdsMRCParameters()
    {
        if (!pdsMRCParameters.RecId)
        {
            pdsMRCParameters = PdsMRCParameters::find();
        }

        return pdsMRCParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postDeliverySlip_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Starts delivery slip post process
    /// </summary>
    protected void postDeliverySlip_BR()
    {
        deliverySlipTotals.calc();
        TmpTaxWorkTrans tmpTaxWorkTrans = deliverySlipTotals.tax().tmpTaxWorkTrans();

        while select salesLine
            where salesLine.SalesId == custPackingSlipJour.SalesId
        {
            TaxDeliverySlip_BR::moveFromDeliverySlip(tmpTaxWorkTrans, custPackingSlipJour, salesLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postEndPost_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes Brazilian localization logic after the <c>endPost</c> method.
    /// </summary>
    protected void postEndPost_BR()
    {
        SalesParmUpdate         salesParmUpdate;

        // Only creates Fiscal Documents for delivery slips. Regular packing slips don't generate Fiscal Documents
        if (custPackingSlipJour.canDeliverySlipBeUpdatedBR())
        {
            this.moveFiscalDataToPackingSlip_BR();

            select salesParmUpdate
                    where salesParmUpdate.ParmId == salesParmTable.ParmId;

            deliverySlipTotals = DeliverySlipTotals_BR::construct(salesParmTable, any2Enum(this.parmSpecQty()), this.parmSumBy(),
                                                                  custPackingSlipJour.ParmId, this.parmSumOrderId(), this.documentStatus());
            this.postDeliverySlip_BR();

            FiscalDocument_BR fiscalDocument = FiscalDocument_BR::findByRef(custPackingSlipJour.TableId, custPackingSlipJour.RecId, true);
            if (fiscalDocument)
            {
                FiscalDocumentPost_BR::cancelFiscalDocument(fiscalDocument,
                                                            custPackingSlipJour.LedgerVoucher,
                                                            custPackingSlipJour.DeliveryDate,
                                                            '',
                                                            ReasonTableRef::find(custPackingSlipJour.ReasonTableRef_BR).ReasonComment);
            }
            else
            {
                FiscalDocumentPost_BR fiscalDocumentPost = new FiscalDocumentPost_BR(
                        FiscalDocumentParmDataCreator_BR::fromPackingSlip(custPackingSlipJour,
                                                                          salesParmTable,
                                                                          deliverySlipTotals,
                                                                          salesParmUpdate,
                                                                          salesTable,
                                                                          journalLines_BR));
                fiscalDocumentPost.run();

                if (this.parmWHSLoadId())
                {
                    WHSLoadLineFiscalDocument_BR::insertLoadLinesForCustPackingSlipJour(this.parmWHSLoadId(), custPackingSlipJour, fiscalDocumentPost.getFiscalDocument().RecId);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postEndPostLine_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes Brazilian localization logic after the <c>endPostLine</c> method.
    /// </summary>
    protected void postEndPostLine_BR()
    {
        journalLines_BR.addEnd(custPackingSlipTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInit_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create new list of journal lines.
    /// </summary>
    public void postInit_BR()
    {
        journalLines_BR = new List(Types::Record);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts to inventory.
    /// </summary>
    protected void postInventory()
    {
        LedgerVoucherObject ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject(voucher);

        if (InventoryReportingCurrencyTriangulationFeature::instance().IsEnabled())
        {
            ledgerVoucherObject.parmTransactionCurrencyCode(salesParmTable.CurrencyCode);
            if (salesTable.FixedExchRate)
            {
                ledgerVoucherObject.parmFixedRateCurrencyExchangeHelper(InventoryReportingCurrencyTriangulationHelper::createFixedRateCurrencyExchangeHelper(ledgerVoucher,  salesTable.FixedExchRate, salesTable.ReportingCurrencyFixedExchRate));
            }
        }
        // <GEERU>

        if (salesLine.AssetId_RU)
        {
            InventMov_AssetSale_ru assetMovement = new InventMov_AssetSale_ru(salesLine);

            if (assetMovement.canDisposal())
            {
                InventUpd_Estimated estimated = InventUpd_Estimated::newInventMovement(assetMovement);
                estimated.updateNow();

                InventUpd_Financial financial = InventUpd_Financial::newPostAsset_RU(assetMovement, ledgerVoucher);
                financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
                financial.updateNow();
            }
        }
        // </GEERU>

        inventMovement = InventMovement::construct(salesLine);

        // <GEERU>
        inventMovement.parmStorno_RU(this.creditNote() && this.parmStorno());
        inventMovement.parmStornoPhysical_RU(salesParmTable.salesParmUpdate().StornoPhysical_RU);
        // </GEERU>
        this.updateInventory(inventMovement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupOnJour</Name>
				<Source><![CDATA[
    protected void postMarkupOnJour(SalesTable _salesTableMarkup)
    {
        Markup::updateMarkupAsPosted(_salesTableMarkup,this.documentStatus());
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupOnSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the markup for the journal lines.
    /// </summary>
    protected void postMarkupOnSalesLine()
    {
        MarkupTrans     markupTrans;
        SalesLine       localSalesLine;
        SalesParmLine   localSalesParmLine;

        if (salesTotals.lineMarkupTransExist())
        {
            ttsbegin;
            markupTrans.skipDataMethods(true);

            update_recordset markupTrans
                setting DocumentStatus = DocumentStatus::PackingSlip
                where  markupTrans.TransTableId      == tableNum(SalesLine)
                    && markupTrans.Keep              == NoYes::No
                    && markupTrans.DocumentStatus    != DocumentStatus::PackingSlip
            exists join localSalesLine
                where localSalesLine.RecId              == markupTrans.TransRecId
            exists join localSalesParmLine
                where  localSalesParmLine.ParmId        == salesParmTable.ParmId
                    && localSalesParmLine.TableRefId    == salesParmTable.TableRefId
                    && localSalesParmLine.OrigSalesId   == localSalesLine.SalesId
                    && localSalesParmLine.InventTransId == localSalesLine.InventTransId
                    && localSalesParmLine.DeliverNow    != 0;

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the markup for the journal header.
    /// </summary>
    protected void postMarkupTable()
    {
        SalesTable          salesTableMarkup;
        SalesParmSubTable   localSalesParmSubTable;

        while select RecId from localSalesParmSubTable
            where localSalesParmSubTable.ParmId     == salesParmTable.ParmId
               && localSalesParmSubTable.TableRefId == salesParmTable.TableRefId
        join salesTableMarkup
            where salesTableMarkup.SalesId == localSalesParmSubTable.OrigSalesId
        {
            this.postMarkupOnJour(salesTableMarkup);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postNotStocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs posting routines for order lines that cannot be posted to inventory.
    /// </summary>
    protected void postNotStocked()
    {
        if (salesLine.SalesQty < 0)
        {
            if (!previousCustPackingSlipVersion) // SalesParmLine is already selected on corrections
            {
                this.initRelatedParmLine();
            }
            SalesQty varianceSalesQty = salesParmLine.DeliverNow + salesParmLine.RemainAfter - salesParmLine.RemainBefore;
            SalesQty registerQty = custPackingSlipTrans.Qty - previousCustPackingSlipTransHistory.Qty - varianceSalesQty;

            TradeNonStockedRegistrationHelper tradeNonStockedRegistrationHelper = TradeNonStockedRegistrationHelper::newFromSalesPurchLine(salesLine);
            if (registerQty < 0)
            {
                //Delete the pending receipt and pending registration records for the quantity being posted.
                tradeNonStockedRegistrationHelper.updatePendingQuantityOnPosting(-registerQty);
            }
            else
            {
                tradeNonStockedRegistrationHelper.synchronizePendingRegistration(registerQty,false);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxOnProforma</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the tax should be considered when a proforma journal is posted.
    /// </summary>
    /// <returns>
    /// true if tax should be considered on the proforma journals; otherwise, false.
    /// </returns>
    #ISOCountryRegionCodes
    protected boolean postTaxOnProforma()
    {
        boolean ret;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU ]))
        {
            ret = true;
        }
        else
        {
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalcTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Recalculates the totals.
    /// </summary>
    /// <remarks>
    /// If the quantity is reduced by inventory, use this method.
    /// </remarks>
    protected void recalcTotals()
    {
        salesTotals = SalesTotals::construct(salesTable, any2Enum(this.parmSpecQty()), this.parmSumBy(), custPackingSlipJour.ParmId, this.parmSumOrderId(), this.documentStatus());
        salesTotals.calc();
        this.tax(salesTotals.tax());
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectFormletterJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Selects a journal line.
    /// </summary>
    protected void selectFormletterJournalTrans()
    {
        CustPackingSlipTransHistory custPackingSlipTransHistory;
        CustPackingSlipTrans        localCustPackingSlipTrans;

        if (!previousCustPackingSlipVersion)
        {
            super();
        }
        else
        {
            formletterJournalTrans = localCustPackingSlipTrans;
            select forupdate localCustPackingSlipTrans
                where localCustPackingSlipTrans.PackingSlipId   == custPackingSlipJour.PackingSlipId
                   && localCustPackingSlipTrans.SalesId         == custPackingSlipJour.SalesId
                   && localCustPackingSlipTrans.DeliveryDate    == custPackingSlipJour.DeliveryDate
                exists join custPackingSlipTransHistory
                    where custPackingSlipTransHistory.CustPackingSlipTrans  == localCustPackingSlipTrans.RecId
                       && custPackingSlipTransHistory.Qty                   != localCustPackingSlipTrans.Qty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the source line record for the current journal line.
    /// </summary>
    /// <returns>
    /// A source line record.
    /// </returns>
    protected Common sourceLine()
    {
        return salesLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the source header record for the journal header.
    /// </summary>
    /// <returns>
    /// A source header record.
    /// </returns>
    protected Common sourceTable()
    {
        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>startLines</Name>
				<Source><![CDATA[
    protected void startLines()
    {
        if (this.postMarkupLineBeforeInventory())
        {
            this.postMarkupOnSalesLine();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an instance of the <c>TransTxt</c> object.
    /// </summary>
    /// <returns>
    /// An instance of the <c>TransTxt</c> object.
    /// </returns>
    protected TransTxt  transactionLogTxt()
    {
        return "@SYS2094";
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the transaction log type.
    /// </summary>
    /// <returns>
    /// A <c>TransactionLogType</c> enumeration value.
    /// </returns>
    protected TransactionLogType  transactionLogType()
    {
        return TransactionLogType::SalesPckSlp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postEndPost_MX</Name>
				<Source><![CDATA[
     /// <summary>
    /// Executes Mexico localization logic after the <c>endPost</c> method.
    /// </summary>
    protected void postEndPost_MX()
    {
        EInvoicePost_MX eInvoicePost = EInvoicePost_MX::construct(custPackingSlipJour, this.parmNumberSeq().parmNumberSequenceId(), this.parmParmTable());
        eInvoicePost.parmParmTable(this.parmParmTable());
        eInvoicePost.createElectronicInvoiceJour();

        if (this.parmSendByMail_MX())
        {
            eInvoicePost.createXMLFileAndPopulateSysMailTable();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBankLC</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Letter of Credit after the journal is posted.
    /// </summary>
    private void updateBankLC()
    {
        if (BankLCExportFeatureChecker::checkBankLCExportEnabled()
            && salesParmTable.BankLCExportLine != 0)
        {
            BankLCExportType bankLCExportType = BankLCExportType::constructBySalesId(salesParmTable.SalesId, true, true);

            if (this.parmChainFormletterContract())
            {
                bankLCExportType.parmVersioningUpdateType(this.parmChainFormletterContract().parmVersioningUpdateType());
            }

            bankLCExportType.updatePackingSlipPosted(salesParmTable.BankLCExportLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the transaction date.
    /// </summary>
    /// <returns>
    /// A transaction date.
    /// </returns>
    TransDate  updateDate()
    {
        return custPackingSlipVersion.AccountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializedInventUpd_Physical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Extension point to update the initialized <c>InventUpd_Physical</c> instance.
    /// </summary>
    /// <param name = "_inventUpd_Physical">An <c>InventUpd_Physical</c> instance.</param>
    protected void initializedInventUpd_Physical(InventUpd_Physical _inventUpd_Physical)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventLocationIdForLine</Name>
				<Source><![CDATA[
    private InventLocationId getInventLocationIdForLine(InventTransOriginId _inventTransOriginId)
    {
        InventLocationId inventLocationId = InventDim::find(salesParmLine.InventDimId).InventLocationId;
        boolean shouldLocationBeFoundForIntercompanySO = chainFormletterContract.parmVersioningUpdateType() == VersioningUpdateType::Cancel;
        
        if (!inventLocationId            
            && !salesParmLine.salesLine().isInterCompanyOrder()
            || shouldLocationBeFoundForIntercompanySO)
        {
            inventLocationId = this.getInventLocationIdFromInventTransOrigin(_inventTransOriginId);
        }

        return inventLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventLocationIdFromInventTransOrigin</Name>
				<Source><![CDATA[
    protected InventLocationId getInventLocationIdFromInventTransOrigin(InventTransOriginId _inventTransOriginId)
    {
        InventDim   inventDim;
        InventTrans inventTrans;

        select firstonly InventLocationId from inventDim
            exists join inventTrans
                where inventTrans.inventDimId         == inventDim.inventDimId
                    &&  inventTrans.InventTransOrigin   == _inventTransOriginId
                    &&  inventTrans.StatusIssue         == StatusIssue::Deducted
                    &&  inventTrans.StatusReceipt       == StatusReceipt::None
                    &&  inventTrans.PackingSlipReturned == 0
                    && !inventTrans.ReturnInventTransOrigin
                    &&  inventTrans.PackingSlipId       == custPackingSlipJour.PackingSlipId
                    &&  inventTrans.VoucherPhysical     == custPackingSlipJour.LedgerVoucher
                    &&  inventTrans.DatePhysical        == custPackingSlipJour.DeliveryDate;

        return inventDim.InventLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWHSCancel</Name>
				<Source><![CDATA[
    protected boolean isWHSCancel(SalesPackingSlipJournalPostUpdateInventoryLineParameters _parameters)
    {
        return _parameters.inventMovement.isItemWHSEnabled()
            && chainFormletterContract.parmVersioningUpdateType() == VersioningUpdateType::Cancel
            && _parameters.custPackingSlipTrans.DeliveryType != TradeLineDlvType::DropShip
            && (InventLocation::find(this.getInventLocationIdForLine(_parameters.inventMovement.inventTransOriginId())).WHSEnabled == NoYes::Yes)
            && WHSLoadLine::existsForInventTransId(salesParmLine.InventTransId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventoryForLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates inventory for the line.
    /// </summary>
    /// <param name = "_parameters">The parameters for the inventory update for the sales order line - the sales parm line/sub line.</param>
    /// <param name = "_postInventoryState">The state for the inventory posting of the line.</param>
    protected void updateInventoryForLine(SalesPackingSlipJournalPostUpdateInventoryLineParameters _parameters, SalesPackingSlipJournalPostPostInventoryState _postInventoryState)
    {
        InventUpd_Physical  inventUpd_Physical;
        boolean             whsCancel;

        if (this.isWHSCancel(_parameters))
        {
            whsCancel = true;
            inventUpd_Physical = InventUpd_Physical::newSalesPackingSlipCancel(_parameters.inventMovement,
                                                                        _parameters.custPackingSlipTrans,
                                                                        custPackingSlipJour.PackingSlipId,
                                                                        previousCustPackingSlipTransHistory,
                                                                        custPackingSlipJour.LedgerVoucher,
                                                                        salesParmLine.InventDimId);
        }
        else
        {
            inventUpd_Physical = InventUpd_Physical::newSalesPackingSlip(_parameters.inventMovement,
                                                                        _parameters.custPackingSlipTrans,
                                                                        CustPackingSlipJour.PackingSlipId,
                                                                        salesParmLine.physicalReduction(this.parmReduceOnHand()),
                                                                        previousCustPackingSlipTransHistory,
                                                                        custPackingSlipJour.LedgerVoucher,
                                                                        salesParmLine.InventDimId);
        }

        if (this.allowSalesLineNegativeInventory())
        {
            inventUpd_Physical.parmAllowNegativePhysical(true);
        }

        if (_parameters.salesParmSubLine.InventDimId)
        {
            InventDimParm inventDimParm;
            InventDim subLineDim = InventDim::find(_parameters.salesParmSubLine.inventDimId);
            inventUpd_Physical.parmInventDim(subLineDim);
            inventDimParm.initFromInventDim(subLineDim);
            inventUpd_Physical.parmInventDimParm(inventDimParm);
            inventUpd_Physical.parmUpdateForSubParmLine(true);
        }

        inventUpd_Physical.parmPickingRouteId(_parameters.wmsRouteId);

        InventPhysicalOnhandChangingHandler inventPhysicalOnhandChangingHandler;
        if (whsCancel)
        {
            // If cancelling a WHS related packing slip we want to prevent the update from auto reserving the new open transaction.
            // Also want to avoid reservedOrdered transactions updating to use the inventory
            inventUpd_Physical.parmPreventAutoReservation(true);
            inventUpd_Physical.parmAllowAutoReserveDim(false);
            inventPhysicalOnhandChangingHandler = InventPhysicalOnhandChangingHandler::construct();
            inventUpd_Physical.physicalOnHandChanging += eventhandler(inventPhysicalOnhandChangingHandler.trackPhysicalOnHandChanges);
        }

        if (_postInventoryState.hasSubLines > 0)
        {
            inventUpd_Physical.parmTrackingRegisterTransPhysicalQty(salesParmLine.InventNow);
        }

        

        this.initializedInventUpd_Physical(inventUpd_Physical);

        inventUpd_Physical.updateNow(ledgerVoucher);

        _postInventoryState.updateNow -= inventUpd_Physical.updPhysicalUnit();
        _postInventoryState.inventUpdateNow -= inventUpd_Physical.updPhysical();
        _postInventoryState.cwUpdateNow -= inventUpd_Physical.pdsCWUpdPhysical();

        if (_parameters.inventMovement.projId() &&
            (!ProjLineProperty::find(salesLine.ProjLinePropertyId).ToBeInvoiced)
                && _parameters.inventMovement.mustBeCostControlled()
                && _parameters.inventMovement.canCommittedCostBeReversed())
        {
            CostControlPostingItem  costControlPostingItem = CostControlPosting::newCostControlPostingItem(_parameters.inventMovement);
            costControlPostingItem.run(ProjCommittedCostUpdateAction::Delete);
        }

        // We only want to perform picking in case of the outbound sales orders.        
        if (whsCancel && this.canPickCancelledTransactions())
        {
            this.pickCancelledTransactions(_parameters.inventMovement,
                                               inventPhysicalOnhandChangingHandler.getInventPhysicalOnhandDeltaAllQty(),
                                               _parameters.custPackingSlipTrans.InventRefType,
                                               _parameters.custPackingSlipTrans.InventRefId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowSalesLineNegativeInventory</Name>
				<Source><![CDATA[
    private boolean allowSalesLineNegativeInventory()
    {
        return previousCustPackingSlipTransHistory
            && previousCustPackingSlipTransHistory.Qty < 0
            && salesLine.isDropShipment()
            && (chainFormletterContract.parmVersioningUpdateType() == VersioningUpdateType::Cancel
                || chainFormletterContract.parmVersioningUpdateType() == VersioningUpdateType::Correction);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPickCancelledTransactions</Name>
				<Source><![CDATA[
    protected boolean canPickCancelledTransactions()
    {
        return salesLine.SalesQty > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the inventory update for the posting.
    /// </summary>
    /// <param name = "_inventMovement">The invent movement instance for the update.</param>
    [Replaceable(true)]
    protected void updateInventory(InventMovement _inventMovement)
    {
        boolean useChildRefForPosting = false;

        SalesPackingSlipJournalPostPostInventoryState  postInventoryState = SalesPackingSlipJournalPostPostInventoryState::construct();
        CustPackingSlipTrans                           localCustPackingSlipTrans = this.journalLine().data();

        List list = SalesParmSubLine::buildSalesParmSubLineList(salesParmLine.RecId);
        Counter subLines = list.elements();
        if (subLines > 0)
        {
            ListEnumerator le = list.getEnumerator();
            SalesQty       salesQtyTotalRemain    = localCustPackingSlipTrans.Qty + localCustPackingSlipTrans.Remain;
            InventQty      inventQtyTotalRemain   = localCustPackingSlipTrans.inventQty + localCustPackingSlipTrans.RemainInvent;
            PdsCWInventQty cwInventQtyTotalRemain = localCustPackingSlipTrans.PdsCWQty + localCustPackingSlipTrans.PdsCWRemain;
                            
            // Only use child references in known cases where failures occur
            useChildRefForPosting = this.shouldUseChildReferencesForPosting(localCustPackingSlipTrans, list);

            if (useChildRefForPosting)
            {
                InventMov_Sales inventMovementSales = _inventMovement as InventMov_Sales;

                if (!inventMovementSales)
                {
                    throw error(error::wrongUseOfFunction(funcName()));
                }

                inventMovementSales.parmWHSPostingChildRef(int642Str(salesParmLine.RecId));

                if (salesQtyTotalRemain == 0 || inventQtyTotalRemain == 0
                    || (salesQtyTotalRemain * inventQtyTotalRemain < 0))
                {
                    localCustPackingSlipTrans.Remain       = 0;
                    localCustPackingSlipTrans.RemainInvent = 0;
                }
            }            

            while (le.moveNext())
            {
                SalesParmSubLine salesParmSubLine = le.current();
                
                if (useChildRefForPosting)
                {
                    // Instead of directly updating the lines, only mark the child references based on sublines with dimensions                                        
                    InventUpd_WHSPickedChildReference::newParameters(_inventMovement,
                                                                     - salesParmSubLine.InventNow, 
                                                                     - salesParmSubLine.DeliverNow, 
                                                                     salesParmSubLine.InventDimId, 
                                                                     - salesParmSubLine.PdsCWDeliverNow).updateNow();
                }
                else
                {
                    localCustPackingSlipTrans.Qty          = salesParmSubLine.DeliverNow;
                    localCustPackingSlipTrans.InventQty    = salesParmSubLine.InventNow;
                    localCustPackingSlipTrans.PdsCWQty     = salesParmSubLine.PdsCWDeliverNow;
                    salesQtyTotalRemain                   -= salesParmSubLine.DeliverNow;
                    inventQtyTotalRemain                  -= salesParmSubLine.InventNow;
                    cwInventQtyTotalRemain                -= salesParmSubLine.PdsCWDeliverNow;
                    // Handle non-zero or different signs because of rounding from unit conversion.
                    if (salesQtyTotalRemain == 0 || inventQtyTotalRemain == 0
                    || (salesQtyTotalRemain * inventQtyTotalRemain < 0))
                    {
                        localCustPackingSlipTrans.Remain       = 0;
                        localCustPackingSlipTrans.RemainInvent = 0;
                    }
                    else
                    {
                        localCustPackingSlipTrans.Remain       = salesQtyTotalRemain;
                        localCustPackingSlipTrans.RemainInvent = inventQtyTotalRemain;
                    }
                    localCustPackingSlipTrans.PdsCWRemain  = cwInventQtyTotalRemain;

                    SalesPackingSlipJournalPostUpdateInventoryLineParameters updateInventoryLineParameters = SalesPackingSlipJournalPostUpdateInventoryLineParameters::construct();
                    updateInventoryLineParameters.inventMovement = _inventMovement;
                    updateInventoryLineParameters.custPackingSlipTrans = localCustPackingSlipTrans;
                    updateInventoryLineParameters.salesParmSubLine  = salesParmSubLine;
                    updateInventoryLineParameters.wmsRouteId = salesParmSubLine.WMSRouteId;

                    postInventoryState.hasSubLines = true;
                    this.updateInventoryForLine(updateInventoryLineParameters, postInventoryState);
                }
            }

            if (!useChildRefForPosting)
            {
                if (salesLine.Complete && abs(_inventMovement.transQtyUnit()) != abs(postInventoryState.updateNow))
                {
                    throw error("@SYS25384");
                }
            }            
        }
        
        if (useChildRefForPosting || subLines == 0)
        {
            SalesPackingSlipJournalPostUpdateInventoryLineParameters updateInventoryLineParameters = SalesPackingSlipJournalPostUpdateInventoryLineParameters::construct();
            updateInventoryLineParameters.inventMovement = _inventMovement;
            updateInventoryLineParameters.custPackingSlipTrans  = localCustPackingSlipTrans;

            postInventoryState.hasSubLines  = false;
            this.updateInventoryForLine(updateInventoryLineParameters, postInventoryState);

            if (salesLine.Complete
                && this.parmReduceOnHand()
                && abs(_inventMovement.transQtyUnit()) != abs(postInventoryState.updateNow))
            {
                throw error("@SYS25384");
            }
        }

        updateNow           = postInventoryState.updateNow;
        updateNowInvent     = postInventoryState.inventUpdateNow;
        cwUpdateNow         = postInventoryState.cwUpdateNow;

        if (this.parmReduceOnHand()
            && updateNow == 0
            && _inventMovement.transQtyUnit() != 0)
        {            
            warning(strFmt("@SYS26397", updateNow));
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
        {
            RetailTransactionServiceFulfillment::updateFulfillmentStatus(this.salesLine.RecId);
        }

        if (useChildRefForPosting
            && _inventMovement.transChildType() == InventTransChildType::SalesWHSPosting
            && WHSThrowErrorOnPackingSlipPostingWhenTransChildRefNotClearedFlight::instance().isEnabled())
        {
            this.checkSalesWHSPostingChildRef(_inventMovement);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSalesWHSPostingChildRef</Name>
				<Source><![CDATA[
    private void checkSalesWHSPostingChildRef(InventMovement _movement)
    {
        InventTrans inventTrans;

        select firstonly RecId from inventTrans
            where inventTrans.InventTransOrigin == _movement.inventTransOriginId()
                && inventTrans.TransChildType   == _movement.transChildType()
                && inventTrans.TransChildRefId  == _movement.transChildRefId();

        if (inventTrans.RecId)
        {
            throw error("@WAX:ChildRefNotClearedError");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUseChildReferencesForPosting</Name>
				<Source><![CDATA[
    private boolean shouldUseChildReferencesForPosting(CustPackingSlipTrans _custPackingSlipTrans, List _subLinesList)
    {
        // Only use child references for posting in known cases of failure, since child references are more expensive
        // The most commonly reported issue is when the sales unit is different from inventory unit (i.e. box/PL) with decimal precision of 0 (only sell full boxes)
        // in connection with batch or serial managed non-CW items. Explicitly excluding CW items here, as we don't have good repro steps for CW items yet.

        return this.parmWHSLoadId() 
               && _subLinesList.elements() > 1
               && !PdsGlobal::pdsIsCWItem(_custPackingSlipTrans.ItemId)
               && _custPackingSlipTrans.SalesUnit != InventTableModule::find(_custPackingSlipTrans.ItemId, ModuleInventPurchSales::Invent).UnitId
               && UnitOfMeasure::findBySymbol(_custPackingSlipTrans.SalesUnit).DecimalPrecision == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickCancelledTransactions</Name>
				<Source><![CDATA[
    protected void pickCancelledTransactions(
        InventMovement  _inventMovement, 
        Map             _inventDimQtyMap,
        InventRefType   _inventRefType,
        InventRefId     _inventRefId)
    {
        MapEnumerator me = _inventDimQtyMap.getEnumerator();
        while (me.moveNext())
        {
            InventDimId         inventDimId;
            WMSPickingRouteID   wmsPickingRouteID;

            [inventDimId, wmsPickingRouteID] = me.currentKey();

            InventQty      inventQty;
            PdsCWInventQty cwInventQty;

            [inventQty, cwInventQty] = me.currentValue();

            InventDim pickDim = InventDim::find(inventDimId);
            InventDimParm  pickDimParm;
            pickDimParm.initFromInventDim(pickDim);

            // Pick new open transaction
            InventUpd_Picked picked = this.initializeInventUpdPicked(_inventRefType, _inventRefId, _inventMovement, pickDim, pickDimParm, -inventQty, wmsPickingRouteID, -cwInventQty);
            
            picked.updateNow();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventUpdPicked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize a new <c>InventUpd_Picked</c> instance to pick new open transaction.
    /// </summary>
    /// <param name = "_inventRefType">Inventory reference type.</param>
    /// <param name = "_inventRefId">Inventory reference ID.</param>
    /// <param name = "_movement">The <c>InventMovement</c> instance.</param>
    /// <param name = "_pickInventDimCriteria">The <c>InventDim</c> criteria record.</param>
    /// <param name = "_pickInventDimParm">The <c>InventDimParm</c> record.</param>
    /// <param name = "_picked">An inventory quantity to pick.</param>
    /// <param name = "_pickingRouteId">A picking route.</param>
    /// <param name = "_cwPicked">A CW inventory quantity to pick.</param>
    /// <returns>
    /// A new <c>InventUpd_Picked</c> instance with forcing pick on Production, Purchase and Transfer order only.
    /// </returns>
    protected InventUpd_Picked initializeInventUpdPicked(
        InventRefType           _inventRefType,
        InventRefId             _inventRefId,
        InventMovement          _movement,
        InventDim               _pickInventDimCriteria,
        InventDimParm           _pickInventDimParm,
        InventQtyPicked         _picked,
        WMSPickingRouteID       _pickingRouteId = '',
        InventQtyPicked         _cwPicked = 0)
    {
        InventUpd_Picked picked = InventUpd_Picked::newParameters(_movement, _pickInventDimCriteria, _pickInventDimParm, null, null, _picked, _pickingRouteId, _cwPicked);
        
        if (!((_inventRefType == InventRefType::Production && ProdTable::exist(_inventRefId))
                || (_inventRefType == InventRefType::InventTransfer && InventTransferTable::exist(_inventRefId))
                || (_inventRefType == InventRefType::Purch && PurchTable::exist(_inventRefId))))
        {
            picked.parmForcePickOnOrderOnly(true);
        }
        
        return picked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the customer packing slip journal line.
    /// </summary>
    /// <remarks>
    ///    The update of the journal line is only for stocked order lines because inventory can reduce
    ///    updated quantity to on-hand quantity for the item.
    /// </remarks>
    protected void updateJournalLine()
    {
        if (!previousCustPackingSlipVersion
            && salesLine.isStocked() && (custPackingSlipTrans.Qty != updateNow || custPackingSlipTrans.InventQty != updateNowInvent))
        {
            this.initRelatedParmLine();
            info(strFmt("@SYS26397",updateNow));
            this.setRecalcTotals();
            this.updateSalesParmLineQty();
            this.updateCustPackingSlipTrans();
        }
        else if (custPackingSlipTrans.FullyMatched && custPackingSlipTrans.isStocked())
        {
            custPackingSlipTrans.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustPackingSlipTrans</Name>
				<Source><![CDATA[
    private void updateCustPackingSlipTrans()
    {
        custPackingSlipTrans.Qty             = updateNow;
        custPackingSlipTrans.InventQty       = updateNowInvent;
        custPackingSlipTrans.Remain          = salesParmLine.RemainAfter;
        custPackingSlipTrans.Ordered         = salesParmLine.RemainBefore;
        custPackingSlipTrans.PdsCWQty        = cwUpdateNow;
        custPackingSlipTrans.PdsCWRemain     = salesParmLine.PdsCWRemainAfterInvent;
        custPackingSlipTrans.ValueMST        = salesParmLine.lineAmountExclTax(custPackingSlipJour.DeliveryDate, salesTotals.tax());

        if (salesTable.CurrencyCode)
        {
            custPackingSlipTrans.ValueMST = CurrencyExchangeHelper::mstAmount(custPackingSlipTrans.ValueMST, salesTable.CurrencyCode, custPackingSlipJour.DeliveryDate, Currency::noYes2UnknownNoYes(salesTable.euroTriangulation(custPackingSlipJour.DeliveryDate)), salesTable.exchRate(custPackingSlipJour.DeliveryDate), salesTable.exchRateSecondary(custPackingSlipJour.DeliveryDate));
            custPackingSlipTrans.StatValueMST = CurrencyExchangeHelper::mstAmount(custPackingSlipTrans.StatValueMST, salesTable.CurrencyCode, custPackingSlipJour.DeliveryDate, Currency::noYes2UnknownNoYes(salesTable.euroTriangulation(custPackingSlipJour.DeliveryDate)), salesTable.exchRate(custPackingSlipJour.DeliveryDate), salesTable.exchRateSecondary(custPackingSlipJour.DeliveryDate));
        }

        custPackingSlipTrans.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesParmLineQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>SalesParmLine</c> record.
    /// </summary>
    protected void updateSalesParmLineQty()
    {
        salesParmLine.RemainAfter += salesParmLine.DeliverNow - updateNow;
        salesParmLine.setRemainAfterInvent();
        salesParmLine.PdsCWRemainAfterInvent += salesParmLine.PdsCWDeliverNow - cwUpdateNow;

        salesParmLine.DeliverNow      = updateNow;
        salesParmLine.InventNow       = updateNowInvent;
        salesParmLine.PdsCWDeliverNow = cwUpdateNow;
        salesParmLine.setLineAmount(salesLine);

        salesParmLine.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the journal header.
    /// </summary>
    protected void updateJournalTable()
    {
        WMSBillOfLading wmsBillOfLading;

        super();

        if (this.useBillOfLading())
        {
            SalesParmUpdate localSalesParmUpdate = salesParmTable.salesParmUpdate();
            if (this.parmShipmentId()
                && Set::create(this.parmPackedLineIdSet()).elements() == 1)
            {
                wmsBillOfLading = WMSBillOfLading::constructFromPackingSlipShipmentId(custPackingSlipJour, localSalesParmUpdate, salesParmTable, this.parmShipmentId());
            }
            else
            {
                wmsBillOfLading = WMSBillOfLading::constructFromPackingSlip(custPackingSlipJour, localSalesParmUpdate, salesParmTable);
            }

            custPackingSlipJour.OffSessionId_RU      = salesParmTable.OffSessionId_RU;
            custPackingSlipJour.BillOfLadingId       = wmsBillOfLading.BillOfLadingId;
            custPackingSlipJour.bolPackageAppearance = localSalesParmUpdate.bolPackageAppearance;
            custPackingSlipJour.bolCarrierName       = localSalesParmUpdate.bolCarrierName;
            custPackingSlipJour.bolAddress           = LogisticsLocationEntity::location2PostalAddress(SalesCarrier::find(localSalesParmUpdate.bolCarrierName).Location).Address;
            custPackingSlipJour.bolFreightedBy       = localSalesParmUpdate.bolFreightedBy;
        }

        custPackingSlipJour.update();

        if (   CustParameters::find().EntryCertificateIssuingEnabled_W
            && salesParmTable.IssueOwnEntryCertificate_W
            && ! this.isProforma())
        {
            CustEntryCertificateJour_W::constructFromPackingSlip(custPackingSlipJour);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesShippingStat</Name>
				<Source><![CDATA[
    protected void updateSalesShippingStat()
    {
        #OCCRetryCount

        if (salesParameters.useShippingStatOnPackingSlip() && !previousCustPackingSlipVersion.RecId)
        {
            try
            {
                SalesShippingStat salesShippingStat;

                ttsbegin;
                delete_from salesShippingStat
                    where salesShippingStat.TableRefId  == salesParmTable.TableRefId   &&
                          salesShippingStat.ParmId      == salesParmTable.ParmId       &&
                          salesShippingStat.Quantity    == 0;

                Microsoft.Dynamics.Ax.Xpp.PlatformExtensions.CommonExtensions::SetSqlUpdateIndexHint(salesShippingStat, indexStr(SalesShippingStat, ParmIdx));

                update_recordset salesShippingStat
                        setting PackingSlipId = custPackingSlipJour.PackingSlipId,
                                DeliveryDate  = salesParmTable.Transdate,
                                ParmId        = ''
                        where salesShippingStat.TableRefId  == salesParmTable.TableRefId   &&
                              salesShippingStat.ParmId      == salesParmTable.ParmId;
                ttscommit;
            }
            catch (Exception::Deadlock)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::Deadlock;
                }
                else
                {
                    retry;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the source line for the current journal line.
    /// </summary>
    protected void updateSourceLine()
    {
        if (!salesLine.isStocked()) //Values are set by the invenposting for inventtoried sales lines (InventMov_sales).
        {
            salesLine.RemainSalesPhysical  = custPackingSlipTrans.Remain;
            salesLine.RemainSalesFinancial += custPackingSlipTrans.Qty - previousCustPackingSlipTransHistory.Qty;
        }

        SalesLineType salesLineType = SalesLineType::construct(salesLine);
        salesLineType.updateSalesLine(inventMovement ? inventMovement.transIdSum() : null);

        this.updateReturnItem(salesLine);

        if (salesTable.InterCompanyCompanyId)
        {
            this.transferInventoryDimensionToIntercompanyLine(salesLineType);
        }

        if (salesLine.LineDeliveryType == LineDeliveryType::DeliveryLine)
        {
            SalesLine salesLineOrderLine = SalesDeliverySchedule::findOrderLineForDeliveryLine(salesLine.InventTransId, true);
            salesLineOrderLine.setSalesStatus();
            salesLineOrderLine.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferInventoryDimensionToIntercompanyLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transfers the inventory dimensions from sales line.
    /// </summary>
    /// <param name="_salesLineType">
    /// An instance of the <c>SalesLineType</c> class which constructed from the sales order line record.
    /// </param>
    protected void transferInventoryDimensionToIntercompanyLine(SalesLineType _salesLineType)
    {
        _salesLineType.interCompanyResetDeliverNow();
        if (this.canTransferInventoryDimensionToIntercompanyLine())
        {
            InterCompanyTransferInventDim::doTransferWithVersioningTypeAndVoucher(salesLine.DataAreaId,
                                                           salesLine.InventTransId,
                                                           salesTable.InterCompanyCompanyId,
                                                           salesLine.InterCompanyInventTransId,
                                                           salesTable.interCompanyEndpointActionPolicy().getOrCreateInterCompanyPolicyTransfer(InterCompanyFieldTransferType::External),
                                                           StatusIssue::Deducted,
                                                           custPackingSlipJour.PackingSlipId,
                                                           false,
                                                           false,
                                                           false,
                                                           chainFormletterContract.parmVersioningUpdateType(),
                                                           custPackingSlipVersion.LedgerVoucher);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canTransferInventoryDimensionToIntercompanyLine</Name>
				<Source><![CDATA[
    protected boolean canTransferInventoryDimensionToIntercompanyLine()
    {
        return !salesTable.InterCompanyDirectDeliveryOrig;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceLineBeforePosting</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Overridden to perform packing slip related pre-posting updates of the source line.
    /// </summary>
    protected void updateSourceLineBeforePosting()
    {
        super();

        if (salesLine.returnItem())
        {
            if (salesLine.returnUpdateLinePrePosting(this.documentStatus()))
            {
                salesLine = SalesLine::findInventTransId(salesLine.InventTransId, true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the source table for the journal header.
    /// </summary>
    protected void updateSourceTable()
    {
        SetEnumerator se = ordersPosted.getEnumerator();
        boolean setEstimate = CustParameters::find().CreditMaxCheck == TypeOfCreditmaxCheck::BalanceDelivered;
        EGAISWaybillJour_RU waybillJour;

        ttsbegin;
        while (se.moveNext())
        {
            salesTable = SalesTable::find(se.current(),true);
            if (salesTable)
            {
                salesTable.updateDocumentStatus(this.documentStatus());
                salesTable.updateBackStatus();
                salesTable.updateSalesType();
                this.createBackorderLines();
                if (setEstimate)
                {
                    salesTable.reread();

                    if (salesTable.setEstimate())
                    {
                        salesTable.doUpdate();
                    }
                }
                sourceTableRecIdSet.add(salesTable.RecId);

                if (isCountryRegion_RU
                    && salesTable.SalesType == SalesType::ReturnItem)
                {
                    select firstOnly forUpdate waybillJour
                        where waybillJour.ReturnOrderSalesId == salesTable.SalesId;

                    if (waybillJour)
                    {
                        waybillJour.StatusIssue = EGAISWaybillStatusIssue_RU::ReturnPackingSlipPosted;
                        waybillJour.ReturnCustPackingSlipJour = custPackingSlipJour.RecId;
                        waybillJour.update();
                    }
                }


            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWHSLoadTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the warehouse load record relating to the packing slip.
    /// </summary>
    protected void updateWHSLoadTable()
    {
        WHSLoadTableCustPackingSlipJour whsLoadTableCustPackingSlipJour;

        void insert_whsLoadTableCustPackingSlipJour(WHSLoadId _loadId)
        {
            boolean isLoadPackingSlipBackgroundPostingStatusFlightEnabled = WHSLoadPackingSlipBackgroundPostingStatusFlight::instance().isEnabled();
            WHSLoadTable whsLoadTable = WHSLoadTable::find(_loadId, isLoadPackingSlipBackgroundPostingStatusFlightEnabled);

            if (whsLoadTable && this.isLoadLinkedToPackingSlipJour(whsLoadTable, custPackingSlipJour))
            {
                whsLoadTableCustPackingSlipJour.clear();
                whsLoadTableCustPackingSlipJour.whsLoadTableLoadId       = whsLoadTable.LoadId;
                whsLoadTableCustPackingSlipJour.whsLoadTableDataAreaId   = whsLoadTable.DataAreaId;
                whsLoadTableCustPackingSlipJour.CustPackingSlipJourRecId = custPackingSlipJour.RecId;
                whsLoadTableCustPackingSlipJour.insert();

                if (isLoadPackingSlipBackgroundPostingStatusFlightEnabled)
                {
                    whsLoadTable.PackingSlipBackgroundPostingStatus = WHSLoadPackingSlipBackgroundPostingStatus::None;
                    whsLoadTable.update();
                }
            }
        }

        if (!previousCustPackingSlipVersion && this.parmWHSLoadId())
        {
            if (this.parmPackedLineIdSet())
            {
                SetEnumerator se = Set::create(this.parmPackedLineIdSet()).getEnumerator();
                while (se.moveNext())
                {
                    insert_whsLoadTableCustPackingSlipJour(se.current());
                }
            }
            else
            {
                insert_whsLoadTableCustPackingSlipJour(this.parmWHSLoadId());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWHSTransportLoadCustPackingSlipJourRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates <c>WHSTransportLoadCustPackingSlipJour</c> records for the current packing slip.
    /// </summary>
    protected void createWHSTransportLoadCustPackingSlipJourRecords()
    {
        if (!previousCustPackingSlipVersion && this.parmIsPostingTransportLoads())
        {
            SetEnumerator se = Set::create(this.parmPackedLineIdSet()).getEnumerator();

            while (se.moveNext())
            {
                WHSTransportLoadCustPackingSlipJour::insertFromSalesPackingSlipJournalPost(se.current(), custPackingSlipJour);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWMSShipment</Name>
				<Source><![CDATA[
    protected void updateWMSShipment()
    {
        ShipCarrierShipmentPackingSlip  shipCarrierShipmentPackingSlip;

        if (!this.parmPackedLineIdSet() || previousCustPackingSlipVersion)
            return ;

        SetEnumerator se = Set::create(this.parmPackedLineIdSet()).getEnumerator();
        while (se.moveNext())
        {
            WMSShipmentId wmsShipmentId = se.current();
            if (!ShipCarrierShipmentPackingSlip::exist(wmsShipmentId, custPackingSlipJour.PackingSlipId))
            {
                shipCarrierShipmentPackingSlip.clear();
                shipCarrierShipmentPackingSlip.wmsShipmentId = wmsShipmentId;
                shipCarrierShipmentPackingSlip.SalesPackingSlipId = custPackingSlipJour.PackingSlipId;
                shipCarrierShipmentPackingSlip.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>useBillOfLading</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the bill of lading can be created and populated.
    /// </summary>
    /// <returns>
    /// true if bill of lading can be used; Otherwise, false.
    /// </returns>
    protected boolean useBillOfLading()
    {
        return !this.isProforma() && salesParameters.useBillOfLadingOnPackingSlip();
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static SalesPackingSlipJournalPost construct()
    {
        return new SalesPackingSlipJournalPost();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransLink_RU</Name>
				<Source><![CDATA[
    private void createTransLink_RU()
    {
        CustPackingSlipTrans    packingSlipTrans;
        InventTrans             inventTrans;
        InventTransOrigin       inventTransOrigin;
        TransLink_RU            transLink;

        while select inventTrans
            join RefPri from transLink
                where transLink.RefTableId  == tablenum(InventTrans)
                   && transLink.RefSec      == inventTrans.RecId
            exists join inventTransOrigin
                where inventTransOrigin.RecId == inventTrans.InventTransOrigin
            exists join packingSlipTrans
                where packingSlipTrans.InventTransId    == inventTransOrigin.InventTransId
                   && packingSlipTrans.SalesId          == custPackingSlipJour.SalesId
                   && packingSlipTrans.PackingSlipId    == custPackingSlipJour.PackingSlipId
                   && packingSlipTrans.DeliveryDate     == custPackingSlipJour.DeliveryDate
        {
            InventTrans inventTransOrig = InventTrans::findRecId(transLink.RefPri);
            LedgerTransLink_RU ledgerTransLink = LedgerTransLink_RU::newTrans(inventTrans, inventTransOrig);
            ledgerTransLink.parmVoucherField(fieldnum(InventTrans, VoucherPhysical));
            ledgerTransLink.parmAccountingDateField(fieldnum(InventTrans, DatePhysical));
            ledgerTransLink.parmReportingDate(inventTransOrig.DatePhysical);
            ledgerTransLink.run();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endLedgerVoucher</Name>
				<Source><![CDATA[
    protected void endLedgerVoucher()
    {
        super();

        if (isCountryRegion_RU)
        {
            this.createTransLink_RU();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>nextFormletterJournalTrans</Name>
				<Source><![CDATA[
    protected void nextFormletterJournalTrans()
    {
        super();

        if (needUpdateSiblingLinesInSameJournal)
        {
            custPackingSlipTrans.reread();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxableDocumentDescriptor</Name>
				<Source><![CDATA[
    public TaxableDocumentDescriptor parmTaxableDocumentDescriptor()
    {
        return TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(custPackingSlipJour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSiblingLinesInSameJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the siblings decrementing by the appropriate qty value for sales order and Inventory.
    /// </summary>
    /// <remarks>
    /// If more than one line in a sales packing slip journal posts quantities for same sales order line we need to update the sibling lines
    /// so the next line posts based on updated remaining Before and After quantities.
    /// </remarks>
    protected void updateSiblingLinesInSameJournal()
    {
        CustPackingSlipTrans custPackingSlipTransSibling;

        SalesQty setQtyToZeroIfNegative(SalesQty _qty)
        {
            if (_qty * salesLine.SalesQty < 0)
            {
                return 0;
            }

            return _qty;
        }

        ttsbegin;

        while select forUpdate custPackingSlipTransSibling
            where custPackingSlipTransSibling.RecId                != custPackingSlipTrans.RecId
                && custPackingSlipTransSibling.PackingSlipId       == custPackingSlipTrans.PackingSlipId
                && custPackingSlipTransSibling.InventTransId       == custPackingSlipTrans.InventTransId
                && custPackingSlipTransSibling.SalesId             == custPackingSlipTrans.SalesId
                && custPackingSlipTransSibling.DeliveryDate        == custPackingSlipTrans.DeliveryDate
                && custPackingSlipTransSibling.NumberSequenceGroup == custPackingSlipTrans.NumberSequenceGroup
        {
            if (!this.getLinesPosted().in(custPackingSlipTransSibling.RecId))
            {
                custPackingSlipTransSibling.Remain -= custPackingSlipTrans.Qty;
                custPackingSlipTransSibling.Remain = setQtyToZeroIfNegative(custPackingSlipTransSibling.Remain);
                custPackingSlipTransSibling.RemainInvent -= custPackingSlipTrans.InventQty;
                custPackingSlipTransSibling.RemainInvent = setQtyToZeroIfNegative(custPackingSlipTransSibling.RemainInvent);
                custPackingSlipTransSibling.doUpdate();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post current tax doucment.
    /// </summary>
    /// <param name="_checkLedgerVoucher">
    /// A Boolean value that indicates whether checking the LedgerVoucher; optional.
    /// </param>
    public void postTaxDocument(boolean _checkLedgerVoucher = true)
    {
        super(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>docuRefFindAndCopyMultiple</Name>
				<Source><![CDATA[
    protected void docuRefFindAndCopyMultiple(Common _to)
    {
        SetEnumerator se = ordersPosted.getEnumerator();
        while (se.moveNext())
        {
            this.docuRefCopy(SalesTable::find(se.current()), _to);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCopyMultipleDocuRef</Name>
				<Source><![CDATA[
    protected boolean shouldCopyMultipleDocuRef()
    {
        return !ordersPosted.empty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSingleLine</Name>
				<Source><![CDATA[
    protected void postSingleLine(boolean _countryRegion_RU,
                                  boolean _hasQualityOrder,
                                  boolean _isExciseEnableIN,
                                  boolean _isVATEnableIN,
                                  boolean _isCustomsEnableIN,
                                  boolean _isConfigurationkeyRetailEnabled)
    {
        using (var activityContext = instrumentationLogger.salesFormLetterActivities().postPackingSlipSingleLine())
        {
            super(_countryRegion_RU,
                  _hasQualityOrder,
                  _isExciseEnableIN,
                  _isVATEnableIN,
                  _isCustomsEnableIN,
                  _isConfigurationkeyRetailEnabled);

            activityContext.addCustomProperty(SalesOrderInstrumentationActivities::SalesTableRecId, any2Str(this.salesTable.RecId));
            activityContext.addCustomProperty(SalesOrderInstrumentationActivities::SourceDocumentLine, any2Str(this.salesLine.SourceDocumentLine));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        using (var activityContext = instrumentationLogger.salesFormLetterActivities().postPackingSlipSingleOrder())
        {
            super();

            activityContext.addCustomProperty(SalesOrderInstrumentationActivities::SalesTableRecId, any2Str(this.salesTable.RecId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new ()
    {
        super();
        instrumentationLogger = SalesInstrumentationLogger::createLogger(classStr(SalesPackingSlipJournalPost));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLoadLinkedToPackingSlipJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if load for sales order can be linked to the customer packing slip journal.
    /// </summary>
    /// <param name = "_loadTable">A load record.</param>
    /// <param name = "_custPackingSlipJour">A customer packing slip record.</param>
    /// <returns>True if load for sales order can be linked to the customer packing slip journal; otherwise, false.</returns>
    private boolean isLoadLinkedToPackingSlipJour(WHSLoadTable _loadTable, CustPackingSlipJour _custPackingSlipJour)
    {
        if (this.parmPackedLineIdSet())
        {
            WHSLoadLine             loadLine;
            CustPackingSlipTrans    packingSlipTrans;

            select firstonly RecId from loadLine
                exists join packingSlipTrans
                where packingSlipTrans.InventTransId    == loadLine.InventTransId
                    && loadLine.LoadId                  == _loadTable.LoadId
                    && packingSlipTrans.SalesId         == _custPackingSlipJour.SalesId
                    && packingSlipTrans.PackingSlipId   == _custPackingSlipJour.PackingSlipId
                    && packingSlipTrans.DeliveryDate    == _custPackingSlipJour.DeliveryDate;

            return loadLine.RecId != 0;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateParmTableJobStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called when updating JobStatus is required outside journal posting scope- Simulation scenario
    /// </summary>
    /// <param name="_startDateTime">
    /// The start date time of the posting
    /// </param>
    internal void updateParmTableJobStatus(StartDateTime _startDateTime = this.getDateTimeNow())
    {
        salesParmTable.StartDateTime = _startDateTime;
        salesParmTable.EndDateTime   = this.getDateTimeNow();
        salesParmTable.ParmJobStatus = ParmJobStatus::Executed;
        salesParmTable.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReturnItem</Name>
				<Source><![CDATA[
    protected void updateReturnItem(SalesLine _salesLine)
    {
        if (_salesLine.returnItem())
        {
            _salesLine = _salesLine.returnLineUpdate(this.documentStatus());
        }
        else
        {
            if (FeatureStateProvider::isFeatureEnabled(SalesUpdateFromJournalPostFlight::instance()))
            {
                using (var salesLineSkipBusinessLogicContext = SalesLineSkipBusinessLogicContext::construct())
                {
                    salesLineSkipBusinessLogicContext.parmSkipUpdate(true);
                    _salesLine.update();
                }
            }
            else
            {
                _salesLine.doUpdate();
            }
        }

    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>