<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>FiasGARImportToGAB_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>FiasGARImportToGAB_RU</c> class imports data from FiasGAR* tables to GAB LogisticsAddress* tables.
/// </summary>
internal class FiasGARImportToGAB_RU
{
    private const str ParamIFNSFL = '1';
    private const str ParamTerrIfnsfl = '3';
    private const str ParamPostalCode = '5';
    private const str ParamOKATO = '6';
    private const str ParamDistrictStreetCode = '15';

    private str countryRegionCode;
    private LogisticsAddressImportVersionId_RU versionId;
    private date versionDate;
    private int updatedRecordsCounter;
    private int insertedRecordsCounter;
    private Set propertyUniqueKeySet;

    private FiasGARParams paramsIFNSFL;
    private FiasGARParams paramsTerrIfnsfl;
    private FiasGARParams paramsOKATO;
    private LogisticsAddressProperties_RU propertiesTable;
    private FiasGARLogisticsAddressHierarchy addressHierarchy;
    private FiasGARAddressTypes currentlyImportAddressType;

    #LOCALMACRO.ParamsWhereClause
        outer join Value from paramsIFNSFL
            where paramsIFNSFL.ObjectId == addressHierarchy.FiasObjectId
                && paramsIFNSFL.AddressType == enum2Str(currentlyImportAddressType)
                && paramsIFNSFL.TypeId == ParamIFNSFL
                && paramsIFNSFL.EndDate >= versionDate
        outer join Value from paramsTerrIfnsfl
            where paramsTerrIfnsfl.ObjectId == addressHierarchy.FiasObjectId
                && paramsTerrIfnsfl.AddressType == enum2Str(currentlyImportAddressType)
                && paramsTerrIfnsfl.TypeId == ParamTerrIfnsfl
                && paramsTerrIfnsfl.EndDate >= versionDate
        outer join Value from paramsOKATO
            where paramsOKATO.ObjectId == addressHierarchy.FiasObjectId
                && paramsOKATO.AddressType == enum2Str(currentlyImportAddressType)
                && paramsOKATO.TypeId == ParamOKATO
                && paramsOKATO.EndDate >= versionDate
    #ENDMACRO

    #LOCALMACRO.PropertiesWhereClause
        propertiesTable.AddressTypeTable_RU == 0
            && propertiesTable.ZipCode == addressHierarchy.ZipCode
            && (propertiesTable.GniCode == paramsIFNSFL.Value || propertiesTable.GniCode == '')
            && (propertiesTable.IMNSDistrict == paramsTerrIfnsfl.Value || propertiesTable.IMNSDistrict == '')
            && (propertiesTable.OKATO == paramsOKATO.Value  ||propertiesTable.OKATO == '')
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    internal static FiasGARImportToGAB_RU construct(LogisticsAddressImportVersionId_RU _versionId)
    {
        FiasGARImportToGAB_RU importer = new FiasGARImportToGAB_RU();
        importer.countryRegionCode = LogisticsAddressCountryRegion::findByISOCode(SysCountryRegionCode::countryInfo(curext())).CountryRegionId;
        importer.versionId = _versionId;
        importer.propertyUniqueKeySet = new Set(Types::String);
        return importer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>importFromFiasGARToGAB</Name>
				<Source><![CDATA[
    internal void importFromFiasGARToGAB(str _regionId, NoYes _importHouseSteads, NoYes _importRoom)
    {
        this.initImporter();
        this.processAddressObject(_regionId);
        if (_importHouseSteads)
        {
            this.processHouse(_regionId);
            this.processSteads(_regionId);
        }
        if (_importRoom)
        {
            this.processRoomAparts(_regionId);
        }

        LogisticsAddressUpdater_RU::updateAll(_regionId);
        this.createLogs(_regionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLogs</Name>
				<Source><![CDATA[
    private void createLogs(str _stateId)
    {
        LogisticsAddressImportLog_RU logisticsAddressImportLog;

        if( insertedRecordsCounter != 0 || updatedRecordsCounter != 0 )
        {
            Info(strFmt("@FIAS:GARImportRecorsInfo", insertedRecordsCounter, updatedRecordsCounter, _stateId));
            ttsbegin;
            logisticsAddressImportLog.InsertedRecords = insertedRecordsCounter;
            logisticsAddressImportLog.UpdatedRecords = updatedRecordsCounter;
            logisticsAddressImportLog.LogDateTime = DateTimeUtil::utcNow();
            logisticsAddressImportLog.VersionId = versionId;
            logisticsAddressImportLog.StateId = _stateId;
            logisticsAddressImportLog.insert();
            ttscommit;
        }
        else
        {
            info(strFmt("@FIAS:NoChangesInRegion", _stateId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initImporter</Name>
				<Source><![CDATA[
    private void initImporter()
    {
        str version2DateStr = strIns(int642Str(versionId), '/', 5);
        version2DateStr = strIns(version2DateStr, '/', 8);
        versionDate = str2Date(version2DateStr, 321);

        updatedRecordsCounter = 0;
        insertedRecordsCounter = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAddressObject</Name>
				<Source><![CDATA[
    private void processAddressObject(str _regionId)
    {
        FiasGARAddrObjTypes::updateAddressTypeFromGARToGAB(versionDate);

        FiasGARImportUtils::removeActiveAddressFromNotFoundRecords(
            tableNum(FiasGARAddressObject),
            fieldNum(FiasGARAddressObject, IsActive),
            fieldNum(FiasGARAddressObject, IsActual),
            fieldNum(FiasGARAddressObject, OperTypeId),
            fieldNum(FiasGARAddressObject, ObjectGuid));

        container addressObjectImportOrder = [FiasGARImportUtils::AddressObjectLevelState,
            FiasGARImportUtils::AddressObjectLevelCounty,
            FiasGARImportUtils::AddressObjectLevelUrbanRuralSettlement,
            FiasGARImportUtils::AddressObjectLevelCityWithLevelNumTwo,
            FiasGARImportUtils::AddressObjectLevelCityWithLevelNumFive,
            FiasGARImportUtils::AddressObjectLevelLocality,
            FiasGARImportUtils::AddressObjectLevelDistrict,
            FiasGARImportUtils::AddressObjectLevelStreet];

        LogisticsAddressElement addressElement;
        for (int i = 1; i <= conLen(addressObjectImportOrder); i++)
        {
            str importLevel = conPeek(addressObjectImportOrder, i);
            addressElement = FiasGARImportUtils::garLevelToLogisticsAddressElement(importLevel);

            FiasGARAddressObject addressObjects;
            LogisticsAddressFiasGuidCodes_RU logisticsAddressFiasGuidCodes;
            LogisticsAddressNotFoundRecords_RU logisticsAddressNotFoundRecords;
            FIASOperationStatuses_RU operStatus;
            LogisticsAddressNotFoundReason_RU notFoundReason = LogisticsAddressNotFoundReason_RU::Deleted;

            insert_recordset logisticsAddressNotFoundRecords(
                RefRecId,
                RefTableId,
                versionId,
                LogisticsAddressElement,
                LogisticsAddressNotFoundReason_RU)
            select RefRecId,
               RefTableId,
               versionId,
               addressElement,
               notFoundReason from logisticsAddressFiasGuidCodes
               join addressObjects
                   where addressObjects.ObjectGuid == logisticsAddressFiasGuidCodes.FiasGuidId
                       && addressObjects.Level == importLevel
               join operStatus
                   where operStatus.OperationStatus == addressObjects.OperTypeId
                       && operStatus.FiasOperationType_RU == FiasOperationType_RU::DeleteOperation;

            switch (addressElement)
            {
                case LogisticsAddressElement::State:
                    this.importState(_regionId, importLevel);
                    break;

                case LogisticsAddressElement::County:
                    this.importCounty(_regionId, importLevel);
                    break;

                case LogisticsAddressElement::Settlement_RU:
                case LogisticsAddressElement::City:
                case LogisticsAddressElement::Locality_RU:
                    this.importSettlementCityLocality(_regionId, importLevel, addressElement);
                    break;

                case LogisticsAddressElement::District:
                    this.importDistrict(_regionId, importLevel);
                    break;

                case LogisticsAddressElement::StreetName:
                    this.importStreet(_regionId, importLevel);
                    break;

                default:
                    break;
            }

        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>importState</Name>
				<Source><![CDATA[
    private void importState(str _regionId, str _importLevel)
    {
        FiasGARAddressObject addressObjects;
        FIASOperationStatuses_RU operStatus;

        ttsbegin;
        while select addressObjects
            where addressObjects.Level == _importLevel
            join FiasOperationType_RU from operStatus
                where operStatus.OperationStatus == addressObjects.OperTypeId
                    && operStatus.FiasOperationType_RU != FiasOperationType_RU::DeleteOperation
                    && addressObjects.IsActive == '1'
                    && addressObjects.IsActual == '1'
                    && (addressObjects.NextId == '0' || addressObjects.NextId == '')
        {
            LogisticsAddressState stateTable;
            LogisticsAddressFiasGuidCodes_RU logisticsAddressFiasGuidCodes_RU;

            select firstOnly forupdate crosscompany logisticsAddressFiasGuidCodes_RU
                where logisticsAddressFiasGuidCodes_RU.FiasGuidId == addressObjects.ObjectGuid
                join forupdate stateTable
                    where stateTable.RecId == logisticsAddressFiasGuidCodes_RU.RefRecId
                        && stateTable.TableId == logisticsAddressFiasGuidCodes_RU.RefTableId;

            LogisticsAddressPropertiesId_RU propertyRecId = this.initOrUpdateProperties_RU(
                addressObjects.ObjectId,
                FiasGARAddressTypes::AddressObj,
                addressObjects.TypeName,
                0);

            if (!stateTable.RecId)
            {
                stateTable = LogisticsAddressState::find(countryRegionCode, _regionId, true);
            }
            stateTable.CountryRegionId = countryRegionCode;
            stateTable.Name = addressObjects.Name;
            stateTable.StateId = _regionId;
            stateTable.Properties_RU = propertyRecId;

            if (!stateTable.RecId || FiasGARImportUtils::isTableChanged(stateTable, stateTable.orig()))
            {
                this.updateInsertUpdateCounter(stateTable);
                stateTable.write();

                FiasGARImportUtils::resubordinationOperationForAddressObjects(stateTable, addressObjects, operStatus.FiasOperationType_RU);
                FiasGARMUNHierarchy hierarchy = FiasGARMUNHierarchy::findHierarchy(addressObjects.ObjectId, versionDate);
                LogisticsAddressFiasGuidCodes_RU::createOrUpdateAddressGuidAndHierarchy(
                    stateTable,
                    addressObjects,
                    addressObjects.ObjectId,
                    addressObjects.ObjectGuid,
                    hierarchy,
                    logisticsAddressFiasGuidCodes_RU,
                    versionId);
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInsertUpdateCounter</Name>
				<Source><![CDATA[
    private void updateInsertUpdateCounter(Common _addressRecord)
    {
        if (_addressRecord.RecId)
        {
            updatedRecordsCounter++;
        }
        else
        {
            insertedRecordsCounter++;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>importCounty</Name>
				<Source><![CDATA[
    private void importCounty(str _regionId, str _importLevel)
    {
        FiasGARAddressObject addressObjects;
        FIASOperationStatuses_RU operStatus;

        ttsbegin;
        while select addressObjects
            where addressObjects.Level == _importLevel
                && addressObjects.IsActive == '1'
                && addressObjects.IsActual == '1'
                && (addressObjects.NextId == '0' || addressObjects.NextId == '')
            join FiasOperationType_RU from operStatus
                where operStatus.OperationStatus == addressObjects.OperTypeId
                    && operStatus.FiasOperationType_RU != FiasOperationType_RU::DeleteOperation
        {
            FiasGARMUNHierarchy hierarchy;
            LogisticsAddressFiasGuidCodes_RU parentAddressGuid;

            select firstonly crosscompany hierarchy
                where hierarchy.ObjectId == addressObjects.ObjectId
                    && hierarchy.IsActive == '1'
                    && hierarchy.StartDate <= versionDate
                    && hierarchy.EndDate >= versionDate
                join forupdate parentAddressGuid
                    where parentAddressGuid.FiasObjectId == hierarchy.ParentObjId;

            if (parentAddressGuid.RecId)
            {
                LogisticsAddressCounty countyTable;
                LogisticsAddressFiasGuidCodes_RU logisticsAddressFiasGuidCodes_RU;

                select forupdate crosscompany logisticsAddressFiasGuidCodes_RU
                    where logisticsAddressFiasGuidCodes_RU.FiasGuidId == addressObjects.ObjectGuid
                    join forUpdate countyTable
                        where countyTable.RecId == logisticsAddressFiasGuidCodes_RU.RefRecId
                            && countyTable.TableId == logisticsAddressFiasGuidCodes_RU.RefTableId;

                if (!countyTable.RecId)
                {
                    int maxChildNumInParent = parentAddressGuid.ChildAddressSequenceNum;
                    do
                    {
                        maxChildNumInParent += 1;
                        str countyId = strRFix(int2Str(maxChildNumInParent), 3, '0');
                        countyTable = LogisticsAddressCounty::find(countryRegionCode, _regionId, countyId, true);
                        countyTable.CountyId = countyId;
                    }
                    while(countyTable);

                    parentAddressGuid.ChildAddressSequenceNum = maxChildNumInParent;
                    parentAddressGuid.update();
                }

                try
                {
                    LogisticsAddressPropertiesId_RU propertyRecId = this.initOrUpdateProperties_RU(
                        addressObjects.ObjectId,
                        FiasGARAddressTypes::AddressObj,
                        addressObjects.TypeName,
                        0);
                    countyTable.selectForUpdate(true);
                    countyTable.Name = addressObjects.Name;
                    countyTable.CountryRegionId = countryRegionCode;
                    countyTable.StateId = _regionId;
                    countyTable.Properties_RU = propertyRecId;

                    if (!countyTable.RecId || FiasGARImportUtils::isTableChanged(countyTable, countyTable.orig()))
                    {
                        this.updateInsertUpdateCounter(countyTable);
                        countyTable.write();

                        FiasGARImportUtils::resubordinationOperationForAddressObjects(countyTable, addressObjects, operStatus.FiasOperationType_RU);
                        LogisticsAddressFiasGuidCodes_RU::createOrUpdateAddressGuidAndHierarchy(
                            countyTable,
                            addressObjects,
                            addressObjects.ObjectId,
                            addressObjects.ObjectGuid,
                            hierarchy,
                            logisticsAddressFiasGuidCodes_RU,
                            versionId);
                    }
                }
                catch(Exception::DuplicateKeyException)
                {
                    warning(strFmt("@FIAS:GARDuplicateAddressWarning", addressObjects.Name, addressObjects.Id));
                    continue;
                }
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>importSettlementCityLocality</Name>
				<Source><![CDATA[
    private void importSettlementCityLocality(str _regionId, str _importLevel, LogisticsAddressElement _addressElement)
    {
        FiasGARAddressObject addressObjects;
        FIASOperationStatuses_RU operStatus;

        ttsbegin;
        while select addressObjects
            where addressObjects.Level == _importLevel
                && addressObjects.IsActive == '1'
                && addressObjects.IsActual == '1'
                && (addressObjects.NextId == '0' || addressObjects.NextId == '')
            join FiasOperationType_RU from operStatus
                where operStatus.OperationStatus == addressObjects.OperTypeId
                    && operStatus.FiasOperationType_RU != FiasOperationType_RU::DeleteOperation
        {
            LogisticsAddressFiasGuidCodes_RU parentAddressGuid;
            FiasGARMUNHierarchy hierarchy;
            select firstonly crosscompany hierarchy
                where hierarchy.ObjectId == addressObjects.ObjectId
                    && hierarchy.IsActive == '1'
                    && hierarchy.StartDate <= versionDate
                    && hierarchy.EndDate >= versionDate
                join forupdate parentAddressGuid
                    where parentAddressGuid.FiasObjectId == hierarchy.ParentObjId;

            Common parentAddrress = FiasGARImportUtils::getParentAddressRecId(parentAddressGuid);
            if (parentAddrress.RecId)
            {
                LogisticsAddressCity cityTable;
                LogisticsAddressFiasGuidCodes_RU logisticsAddressFiasGuidCodes;
                RecId cityRecId, districtRecId, streetRecId;
                str stateId, countyId;
                [cityRecId, districtRecId, streetRecId, stateId, countyId] = FiasGARImportUtils::getCityDistrictStreetFromAddress(parentAddrress);

                select firstOnly crosscompany logisticsAddressFiasGuidCodes
                    where logisticsAddressFiasGuidCodes.FiasGuidId == addressObjects.ObjectGuid
                    join forupdate cityTable
                        where cityTable.RecId == logisticsAddressFiasGuidCodes.RefRecId
                            && cityTable.TableId == logisticsAddressFiasGuidCodes.RefTableId;

                cityTable.selectForUpdate(true);
                cityTable.Description = addressObjects.Name;
                cityTable.CountryRegionId = countryRegionCode;
                cityTable.CountyId = countyId;
                cityTable.StateId = _regionId;

                if (_addressElement == LogisticsAddressElement::Settlement_RU)
                {
                    cityTable.AddressLevel_RU = LogisticsCityAddressLevel_RU::Settlement;
                }
                else if (_addressElement == LogisticsAddressElement::Locality_RU)
                {
                    cityTable.AddressLevel_RU = LogisticsCityAddressLevel_RU::Locality;
                }
                else
                {
                    cityTable.AddressLevel_RU = LogisticsCityAddressLevel_RU::City;
                }

                if (parentAddrress.TableId == tableNum(LogisticsAddressCity))
                {
                    LogisticsAddressCity parentCity = parentAddrress as LogisticsAddressCity;
                    if (parentCity.AddressLevel_RU == LogisticsCityAddressLevel_RU::Settlement)
                    {
                        cityTable.SettlementRecId = parentCity.RecId;
                    }
                    else if (parentCity.AddressLevel_RU == LogisticsCityAddressLevel_RU::City)
                    {
                        cityTable.SettlementRecId = parentCity.SettlementRecId;
                        cityTable.CityRecId = parentCity.RecId;
                    }
                }

                LogisticsAddressLocalization_RU localizationBase = new LogisticsAddressLocalization_RU();
                if (!cityTable.RecId)
                {
                    int maxChildNumInParent = parentAddressGuid.ChildAddressSequenceNum;
                    boolean existDuplicateKey = true;
                    do
                    {
                        maxChildNumInParent += 1;
                        cityTable.Name = strRFix(int2Str(maxChildNumInParent), 4, '0');
                        LogisticsAddressCityKey cityKey = localizationBase.calculateDefaultCityKey(cityTable);
                        existDuplicateKey = LogisticsAddressCity::existsCityKey(cityKey);
                    }
                    while(existDuplicateKey);
                    parentAddressGuid.ChildAddressSequenceNum = maxChildNumInParent;
                }
                parentAddressGuid.update();
                cityTable.CityKey = localizationBase.calculateDefaultCityKey(cityTable);
                cityTable.Properties_RU = this.initOrUpdateProperties_RU(
                    addressObjects.ObjectId,
                    FiasGARAddressTypes::AddressObj,
                    addressObjects.TypeName,
                    0);

                try
                {
                    if (!cityTable.RecId || FiasGARImportUtils::isTableChanged(cityTable, cityTable.orig()))
                    {
                        this.updateInsertUpdateCounter(cityTable);
                        cityTable.write();

                        FiasGARImportUtils::resubordinationOperationForAddressObjects(cityTable, addressObjects, operStatus.FiasOperationType_RU);
                        LogisticsAddressFiasGuidCodes_RU::createOrUpdateAddressGuidAndHierarchy(
                            cityTable,
                            addressObjects,
                            addressObjects.ObjectId,
                            addressObjects.ObjectGuid,
                            hierarchy,
                            logisticsAddressFiasGuidCodes,
                            versionId);
                    }
                }
                catch(Exception::DuplicateKeyException)
                {
                    warning(strFmt("@FIAS:GARDuplicateAddressWarning", addressObjects.Name, addressObjects.Id));
                    continue;
                }
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>importDistrict</Name>
				<Source><![CDATA[
    private void importDistrict(str _regionId, str _importLevel)
    {
        FiasGARAddressObject addressObjects;
        FIASOperationStatuses_RU operStatus;

        ttsbegin;
        while select addressObjects
            where addressObjects.Level == _importLevel
                && addressObjects.IsActive == '1'
                && addressObjects.IsActual == '1'
                && (addressObjects.NextId == '0' || addressObjects.NextId == '')
            join FiasOperationType_RU from operStatus
                where operStatus.OperationStatus == addressObjects.OperTypeId
                    && operStatus.FiasOperationType_RU != FiasOperationType_RU::DeleteOperation
        {
            FiasGARMUNHierarchy hierarchy;
            LogisticsAddressFiasGuidCodes_RU parentAddressGuid;
            select firstonly crosscompany hierarchy
                where hierarchy.ObjectId == addressObjects.ObjectId
                    && hierarchy.IsActive == '1'
                    && hierarchy.StartDate <= versionDate
                    && hierarchy.EndDate >= versionDate
                join forupdate parentAddressGuid
                    where parentAddressGuid.FiasObjectId == hierarchy.ParentObjId;

            Common parentAddress = FiasGARImportUtils::getParentAddressRecId(parentAddressGuid);
            if (parentAddress.RecId)
            {
                LogisticsAddressDistrict districtTable;
                LogisticsAddressFiasGuidCodes_RU logisticsAddressFiasGuidCodes_RU;
                select firstOnly crosscompany logisticsAddressFiasGuidCodes_RU
                    where logisticsAddressFiasGuidCodes_RU.FiasGuidId == addressObjects.ObjectGuid
                    join forupdate districtTable
                        where districtTable.RecId == logisticsAddressFiasGuidCodes_RU.RefRecId
                           && districtTable.TableId == logisticsAddressFiasGuidCodes_RU.RefTableId;

                str districtCode, stateId, countyCode;
                FiasGARParams districtCodeParam = FiasGARParams::getParamForAddress(addressObjects.ObjectId, FiasGARAddressTypes::AddressObj, ParamDistrictStreetCode, versionDate);
                if (districtCodeParam.RecId)
                {
                    districtCode = districtCodeParam.Value;
                }

                RecId cityRecId, districtRecId, streetRecId;
                [cityRecId, districtRecId, streetRecId, stateId, countyCode] = FiasGARImportUtils::getCityDistrictStreetFromAddress(parentAddress);
                if (!districtTable.RecId && districtCode == '')
                {
                    int maxChildNumInParent = parentAddressGuid.ChildAddressSequenceNum;
                    LogisticsAddressDistrict districtByKey;
                    do
                    {
                        maxChildNumInParent = maxChildNumInParent + 1;
                        districtCode = strRFix(int2Str(maxChildNumInParent), 4, '0');
                        select firstOnly RecId from districtByKey
                            where districtByKey.Name == districtCode
                                && districtByKey.CountryRegionId_RU == countryRegionCode
                                && districtByKey.CountyId_RU == countyCode
                                && districtByKey.StateId_RU == _regionId
                                && districtByKey.City == cityRecId;
                    }
                    while(districtByKey);
                    parentAddressGuid.ChildAddressSequenceNum = maxChildNumInParent;
                }
                parentAddressGuid.update();

                try
                {
                    districtTable.Name = districtCode == '' ? districtTable.Name : districtCode;
                    districtTable.City = cityRecId;
                    districtTable.Description = addressObjects.Name;
                    districtTable.CountryRegionId_RU = countryRegionCode;
                    districtTable.CountyId_RU = countyCode;
                    districtTable.StateId_RU = _regionId;
                    districtTable.Properties_RU = this.initOrUpdateProperties_RU(
                        addressObjects.ObjectId,
                        FiasGARAddressTypes::AddressObj,
                        addressObjects.TypeName,
                        0);

                    if (!districtTable.RecId || FiasGARImportUtils::isTableChanged(districtTable, districtTable.orig()))
                    {
                        this.updateInsertUpdateCounter(districtTable);
                        districtTable.write();

                        FiasGARImportUtils::resubordinationOperationForAddressObjects(districtTable, addressObjects, operStatus.FiasOperationType_RU);
                        LogisticsAddressFiasGuidCodes_RU::createOrUpdateAddressGuidAndHierarchy(
                            districtTable,
                            addressObjects,
                            addressObjects.ObjectId,
                            addressObjects.ObjectGuid,
                            hierarchy,
                            logisticsAddressFiasGuidCodes_RU,
                            versionId);
                    }
                }
                catch(Exception::DuplicateKeyException)
                {
                    warning(strFmt("@FIAS:GARDuplicateAddressWarning", addressObjects.Name, addressObjects.Id));
                    continue;
                }
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStreetUniqueKeyStr</Name>
				<Source><![CDATA[
    private str getStreetUniqueKeyStr(LogisticsAddressStreet_RU _streetTable)
    {
        const str uniqueKeyFormat = '%1,%2,%3,%4,%5,%6';
        return strFmt(uniqueKeyFormat, _streetTable.State, _streetTable.County, _streetTable.City, _streetTable.District, _streetTable.Name, _streetTable.Description);
    }

]]></Source>
			</Method>
			<Method>
				<Name>importStreet</Name>
				<Source><![CDATA[
    private void importStreet(str _regionId, str _importLevel)
    {
        LogisticsAddressStreet_RU streetTable;
        Set uniqueKeySet = new Set(Types::String);
        currentlyImportAddressType = FiasGARAddressTypes::AddressObj;

        while select streetTable
            where streetTable.CountryRegion == countryRegionCode
                && streetTable.State == _regionId
        {
            uniqueKeySet.add(this.getStreetUniqueKeyStr(streetTable));
        }

        LogisticsAddressFiasGuidCodes_RU logisticsAddressFiasGuidCodes;
        FiasGARAddressObject addressObjects;
        FIASOperationStatuses_RU operStatus;
        FiasGARMUNHierarchy hierarchy;
        LogisticsAddressFiasGuidCodes_RU parentAddressGuid;
        FiasGARParams paramsStreetCode;
        RecordInsertList streetInsertList = new RecordInsertList(tableNum(LogisticsAddressStreet_RU));
        RecordInsertList hierarchyInsertList = new RecordInsertList(tableNum(FiasGARLogisticsAddressHierarchy));

        while select crosscompany addressObjects
            where addressObjects.Level == _importLevel
                && addressObjects.IsActive == '1'
                && addressObjects.IsActual == '1'
                && (addressObjects.NextId == '0' || addressObjects.NextId == '')
            join FiasOperationType_RU from operStatus
                where operStatus.OperationStatus == addressObjects.OperTypeId
                    && operStatus.FiasOperationType_RU != FiasOperationType_RU::DeleteOperation
            join hierarchy
                where hierarchy.ObjectId == addressObjects.ObjectId
                    && hierarchy.IsActive == '1'
                    && hierarchy.StartDate <= versionDate
                    && hierarchy.EndDate >= versionDate
            join forupdate parentAddressGuid
                where parentAddressGuid.FiasObjectId == hierarchy.ParentObjId
            join Value from paramsStreetCode
                where paramsStreetCode.ObjectId == addressObjects.ObjectId
                    && paramsStreetCode.AddressType == enum2Str(FiasGARAddressTypes::AddressObj)
                    && paramsStreetCode.TypeId == ParamDistrictStreetCode
                    && paramsStreetCode.StartDate <= versionDate
                    && paramsStreetCode.EndDate >= versionDate
        {
            Common parentAddrress = FiasGARImportUtils::getParentAddressRecId(parentAddressGuid, tableNum(LogisticsAddressStreet_RU));
            if (parentAddrress.RecId)
            {
                RecId cityRecId = 0, districtRecId = 0, streetRecId = 0;
                str streetCode, stateId, countyCode;
                [cityRecId, districtRecId, streetRecId, stateId, countyCode] = FiasGARImportUtils::getCityDistrictStreetFromAddress(parentAddrress);

                select firstOnly crosscompany logisticsAddressFiasGuidCodes
                    where logisticsAddressFiasGuidCodes.FiasGuidId == addressObjects.ObjectGuid
                join forUpdate streetTable
                    where streetTable.RecId == logisticsAddressFiasGuidCodes.RefRecId
                        && streetTable.TableId == logisticsAddressFiasGuidCodes.RefTableId;

                if (paramsStreetCode.RecId && paramsStreetCode.Value != '')
                {
                    streetTable.Name = paramsStreetCode.Value;
                    streetTable.City = cityRecId;
                    streetTable.District = districtRecId;
                    streetTable.Description = addressObjects.Name;
                    streetTable.CountryRegion = countryRegionCode;
                    streetTable.County = countyCode;
                    streetTable.State = _regionId;

                    str uniqueKey = this.getStreetUniqueKeyStr(streetTable);
                    if (!streetTable.RecId && !uniqueKeySet.in(uniqueKey))
                    {
                        uniqueKeySet.add(uniqueKey);
                        this.updateInsertUpdateCounter(streetTable);
                        streetInsertList.add(streetTable);

                        FiasGARLogisticsAddressHierarchy addressHierarchyTmp;
                        addressHierarchyTmp.AddressObjectGuidId = addressObjects.ObjectGuid;
                        addressHierarchyTmp.FiasObjectId = addressObjects.ObjectId;
                        addressHierarchyTmp.FiasParentObjectId = hierarchy.ParentObjId;
                        addressHierarchyTmp.FiasGARRecordId = addressObjects.Id;
                        addressHierarchyTmp.OKTMO = hierarchy.OKTMO;
                        addressHierarchyTmp.CountryRegion = countryRegionCode;
                        addressHierarchyTmp.State = streetTable.State;
                        addressHierarchyTmp.County = streetTable.County;
                        addressHierarchyTmp.City = streetTable.City;
                        addressHierarchyTmp.District = streetTable.District;
                        addressHierarchyTmp.Name = streetTable.Name;
                        addressHierarchyTmp.Description = streetTable.Description;
                        addressHierarchyTmp.AddrTypeName = addressObjects.TypeName;
                        addressHierarchyTmp.RefTableId = tableNum(LogisticsAddressStreet_RU);
                        hierarchyInsertList.add(addressHierarchyTmp);
                    }
                    else if (streetTable.RecId)
                    {
                        ttsbegin;
                        streetTable.Properties = this.initOrUpdateProperties_RU(
                            addressObjects.ObjectId,
                            FiasGARAddressTypes::AddressObj,
                            addressObjects.TypeName,
                            0);

                        if (FiasGARImportUtils::isTableChanged(streetTable, streetTable.orig()))
                        {
                            streetTable.update();
                            this.updateInsertUpdateCounter(streetTable);
                        }
                        ttscommit;
                    }
                }
            }
        }

        try
        {
            streetInsertList.insertDatabase();
            hierarchyInsertList.insertDatabase();
        }
        catch
        {
            warning(strFmt("@FIAS:DuplicateKeyWhenInsertList", "@GlobalAddressBook:Streets"));
        }
        finally
        {
            // 1. Executes resubordination operation and inserts params to properties table for new added street.
            RecordInsertList propertyInsertList = new RecordInsertList(tableNum(LogisticsAddressProperties_RU));
            AddressTypeTable_RU addressTypeTable_RU;
            while select streetTable
                where streetTable.CountryRegion == countryRegionCode
                join FiasObjectId, FiasGARRecordId, AddrTypeName from addressHierarchy
                    where addressHierarchy.CountryRegion == streetTable.CountryRegion
                        && addressHierarchy.State == streetTable.State
                        && addressHierarchy.County == streetTable.County
                        && addressHierarchy.City == streetTable.City
                        && addressHierarchy.District == streetTable.District
                        && addressHierarchy.Description == streetTable.Description
                        && addressHierarchy.Name == streetTable.Name
                        && addressHierarchy.RefTableId == streetTable.TableId
                join RecId from addressTypeTable_RU
                    where addressTypeTable_RU.AddrTypeName == addressHierarchy.AddrTypeName
                #ParamsWhereClause
            {
                FiasGARImportUtils::resubordinationOperationForAddressObjects(streetTable, FiasGARAddressObject::findById(addressHierarchy.FiasGARRecordId), FiasOperationType_RU::ResubordinationOperation);
                this.addPropertiesInsertList(propertyInsertList, paramsIFNSFL.Value, paramsTerrIfnsfl.Value, paramsOKATO.Value, 0, addressTypeTable_RU.RecId);
            }
            propertyInsertList.insertDatabase();

            // 2. Updates <c>LogisticsAddressFiasGuidCodes_RU</c> for existed address, inserts new <c>LogisticsAddressFiasGuidCodes_RU</c> records for new added street addresses.
            FiasGARImportUtils::updatesExistingFiasGuid(
                tableNum(FiasGARAddressObject),
                fieldNum(FiasGARAddressObject, IsActive),
                fieldNum(FiasGARAddressObject, IsActual),
                fieldNum(FiasGARAddressObject, ObjectGuid),
                fieldNum(FiasGARAddressObject, OperTypeId),
                fieldNum(FiasGARAddressObject, ObjectId),
                versionDate,
                versionId);

            ttsbegin;
            // In case some re-subordinated address caused insert operation failed. e.g. An address used to be Level 7, but now it's level 8 but guid not change.
            FiasGARLogisticsAddressHierarchy fiasLogisticsAddressHierarchy;
            delete_from logisticsAddressFiasGuidCodes
                exists join fiasLogisticsAddressHierarchy
                    where fiasLogisticsAddressHierarchy.AddressObjectGuidId == logisticsAddressFiasGuidCodes.FiasGuidId;

            insert_recordset logisticsAddressFiasGuidCodes(
                FiasGuidId,
                FiasObjectId,
                FiasParentObjectId,
                OKTMO,
                RefTableId,
                RefRecId,
                versionId)
                select AddressObjectGuidId, FiasObjectId, FiasParentObjectId, OKTMO, RefTableId from fiasLogisticsAddressHierarchy
                    join RecId, versionId from streetTable
                        where streetTable.CountryRegion == fiasLogisticsAddressHierarchy.CountryRegion
                            && streetTable.State == fiasLogisticsAddressHierarchy.State
                            && streetTable.County == fiasLogisticsAddressHierarchy.County
                            && streetTable.City == fiasLogisticsAddressHierarchy.City
                            && streetTable.District == fiasLogisticsAddressHierarchy.District
                            && streetTable.Description == fiasLogisticsAddressHierarchy.Description
                            && streetTable.Name == fiasLogisticsAddressHierarchy.Name;
            ttscommit;

            // 3. Updates Properties for new added <c>LogisticsAddressStreet_RU</c> records.
            ttsbegin;
            update_recordset streetTable
                setting Properties = propertiesTable.RecId
                    where streetTable.CountryRegion == countryRegionCode
                join FiasObjectId, ZipCode, AddrTypeName from addressHierarchy
                    where addressHierarchy.CountryRegion == streetTable.CountryRegion
                        && addressHierarchy.State == streetTable.State
                        && addressHierarchy.County == streetTable.County
                        && addressHierarchy.City == streetTable.City
                        && addressHierarchy.District == streetTable.District
                        && addressHierarchy.Description == streetTable.Description
                        && addressHierarchy.Name == streetTable.Name
                        && addressHierarchy.RefTableId == streetTable.TableId
                join addressTypeTable_RU
                    where addressTypeTable_RU.AddrTypeName == addressHierarchy.AddrTypeName
                #ParamsWhereClause
                join propertiesTable
                    where propertiesTable.AddressTypeTable_RU == addressTypeTable_RU.RecId
                        && propertiesTable.ZipCode == addressHierarchy.ZipCode
                        && (propertiesTable.GniCode == paramsIFNSFL.Value || propertiesTable.GniCode == '')
                        && (propertiesTable.IMNSDistrict == paramsTerrIfnsfl.Value || propertiesTable.IMNSDistrict == '')
                        && (propertiesTable.OKATO == paramsOKATO.Value  ||propertiesTable.OKATO == '');
            ttscommit;

            FiasGARLogisticsAddressHierarchy::deleteAll();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getHouseUniqueKeyStr</Name>
				<Source><![CDATA[
    private str getHouseUniqueKeyStr(LogisticsAddressHouseNumber_RU _houseNumberTable)
    {
        const str uniqueKeyFormat = '%1,%2,%3,%4,%5,%6';
        return strFmt(uniqueKeyFormat,
            _houseNumberTable.State,
            _houseNumberTable.County,
            _houseNumberTable.City,
            _houseNumberTable.District,
            _houseNumberTable.Street,
            _houseNumberTable.Name);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processHouse</Name>
				<Source><![CDATA[
    private void processHouse(str _stateId)
    {
        const str descriptionFormat = '%1 %2', space = ' ', hyphen = '-';
        currentlyImportAddressType = FiasGARAddressTypes::House;
        FiasGARImportUtils::removeActiveAddressFromNotFoundRecords(
            tableNum(FiasGARHouse),
            fieldNum(FiasGARHouse, IsActive),
            fieldNum(FiasGARHouse, IsActual),
            fieldNum(FiasGARHouse, OperTypeId),
            fieldNum(FiasGARHouse, ObjectGuid));

        LogisticsAddressFiasGuidCodes_RU logisticsAddressFiasGuidCodes;
        LogisticsAddressNotFoundRecords_RU logisticsAddressNotFoundRecords;
        FiasGARHouse fiasGarHouse;
        FIASOperationStatuses_RU operStatus;
        LogisticsAddressElement elementHouse = LogisticsAddressElement::House_RU;
        LogisticsAddressNotFoundReason_RU notFoundReason = LogisticsAddressNotFoundReason_RU::Deleted;
        insert_recordset logisticsAddressNotFoundRecords(
           RefRecId,
           RefTableId,
           versionId,
           LogisticsAddressElement,
           LogisticsAddressNotFoundReason_RU)
        select RefRecId,
           RefTableId,
           versionId,
           elementHouse,
           notFoundReason from logisticsAddressFiasGuidCodes
           join fiasGarHouse
               where fiasGarHouse.ObjectGuid == logisticsAddressFiasGuidCodes.FiasGuidId
           join operStatus
               where operStatus.OperationStatus == fiasGarHouse.OperTypeId
                   && operStatus.FiasOperationType_RU == FiasOperationType_RU::DeleteOperation;

        Set uniqueKeySet = new Set(Types::String);
        RecordInsertList houseInsertList = new RecordInsertList(tableNum(LogisticsAddressHouseNumber_RU));
        LogisticsAddressHouseNumber_RU houseNumberTable;
        FiasGARMUNHierarchy hierarchy;
        LogisticsAddressFiasGuidCodes_RU logisticsAddressFiasGuidCodesParent;
        RecordInsertList hierarchyInsertList = new RecordInsertList(tableNum(FiasGARLogisticsAddressHierarchy));

        while select houseNumberTable
            where houseNumberTable.CountryRegion == countryRegionCode
                && houseNumberTable.State == _stateId
        {
            uniqueKeySet.add(this.getHouseUniqueKeyStr(houseNumberTable));
        }

        while select crosscompany fiasGarHouse
            where fiasGarHouse.IsActive == '1'
                && fiasGarHouse.IsActual == '1'
                && (fiasGarHouse.NextId == '0' || fiasGarHouse.NextId == '')
            join operStatus
                where operStatus.OperationStatus == fiasGarHouse.OperTypeId
                    && operStatus.FiasOperationType_RU != FiasOperationType_RU::DeleteOperation
            join hierarchy
                where hierarchy.ObjectId == fiasGarHouse.ObjectId
                    && hierarchy.IsActive == '1'
                    && hierarchy.StartDate <= versionDate
                    && hierarchy.EndDate >= versionDate
            join logisticsAddressFiasGuidCodesParent
                where logisticsAddressFiasGuidCodesParent.FiasObjectId == hierarchy.ParentObjId
        {
            FiasGARHouseTypes houseType = FiasGARHouseTypes::findById(fiasGarHouse.HouseType, enum2Str(NoYes::No));
            FiasGARHouseTypes addHouseType1 = FiasGARHouseTypes::findById(fiasGarHouse.AddType1, enum2Str(NoYes::Yes));
            FiasGARHouseTypes addHouseType2 = FiasGARHouseTypes::findById(fiasGarHouse.AddType2, enum2Str(NoYes::Yes));
            str houseName = fiasGarHouse.HouseNum;
            str houseDescriptionString = strFmt(descriptionFormat, houseType.ShortName, fiasGarHouse.HouseNum);
            str buildDescriptionString;
            if (fiasGarHouse.AddNum1 != '' && addHouseType1.RecId)
            {
                houseName += (hyphen + fiasGarHouse.AddNum1);
                str addHouseName1 = strFmt(descriptionFormat, addHouseType1.ShortName, fiasGarHouse.AddNum1);
                houseDescriptionString += (space + addHouseName1);
                buildDescriptionString = addHouseName1;
            }
            if(fiasGarHouse.AddNum2 && addHouseType2.RecId)
            {
                houseName += (hyphen + fiasGarHouse.AddNum2);
                str addHouseName2 = strFmt(descriptionFormat, addHouseType2.ShortName, fiasGarHouse.AddNum2);
                houseDescriptionString += (space + addHouseName2);
                buildDescriptionString += (space + addHouseName2);
            }

            Common parentTable = FiasGARImportUtils::getParentAddressRecId(logisticsAddressFiasGuidCodesParent);
            if (parentTable)
            {
                RecId cityRecId, districtRecId, streetRecId;
                str stateId, countyId;
                [cityRecId, districtRecId, streetRecId, stateId, countyId] = FiasGARImportUtils::getCityDistrictStreetFromAddress(parentTable);

                select firstOnly crosscompany houseNumberTable
                    join logisticsAddressFiasGuidCodes
                        where logisticsAddressFiasGuidCodes.FiasGuidId == fiasGarHouse.ObjectGuid
                            && houseNumberTable.RecId == logisticsAddressFiasGuidCodes.RefRecId
                            && houseNumberTable.TableId == logisticsAddressFiasGuidCodes.RefTableId;

                houseNumberTable.selectForUpdate(true);
                houseNumberTable.State = stateId;
                houseNumberTable.County = countyId;
                houseNumberTable.City = cityRecId;
                houseNumberTable.District = districtRecId;
                houseNumberTable.Street = streetRecId;
                houseNumberTable.CountryRegion = countryRegionCode;
                houseNumberTable.Name = houseName;
                houseNumberTable.HouseDescription = houseDescriptionString;
                houseNumberTable.BuildingDescription = buildDescriptionString;

                FiasGARParams params = FiasGARParams::getParamForAddress(fiasGarHouse.ObjectId, FiasGARAddressTypes::House, ParamPostalCode, versionDate);
                LogisticsAddressZipCode zipCodeTable;
                if (params.RecId)
                {
                    zipCodeTable = this.getOrCreateZipCode(houseNumberTable, params.Value, stateId, countyId, cityRecId, districtRecId, streetRecId, '', houseNumberTable.RecId);
                }

                str uniqueKey = this.getHouseUniqueKeyStr(houseNumberTable);
                if (!houseNumberTable.RecId && !uniqueKeySet.in(uniqueKey))
                {
                    this.updateInsertUpdateCounter(houseNumberTable);
                    uniqueKeySet.add(uniqueKey);
                    houseInsertList.add(houseNumberTable);

                    FiasGARLogisticsAddressHierarchy addressHierarchyTmp;
                    addressHierarchyTmp.AddressObjectGuidId = fiasGarHouse.ObjectGuid;
                    addressHierarchyTmp.FiasParentObjectId = hierarchy.ParentObjId;
                    addressHierarchyTmp.CountryRegion = countryRegionCode;
                    addressHierarchyTmp.State = houseNumberTable.State;
                    addressHierarchyTmp.County = houseNumberTable.County;
                    addressHierarchyTmp.City = houseNumberTable.City;
                    addressHierarchyTmp.District = houseNumberTable.District;
                    addressHierarchyTmp.Street = houseNumberTable.Street;
                    addressHierarchyTmp.Name = houseNumberTable.Name;
                    addressHierarchyTmp.FiasObjectId = fiasGarHouse.ObjectId;
                    addressHierarchyTmp.OKTMO = hierarchy.OKTMO;
                    addressHierarchyTmp.RefTableId = tableNum(LogisticsAddressHouseNumber_RU);
                    addressHierarchyTmp.ZipCode = zipCodeTable.RecId;
                    hierarchyInsertList.add(addressHierarchyTmp);
                }
                else if (houseNumberTable.RecId)
                {
                    ttsbegin;
                    houseNumberTable.Properties = this.initOrUpdateProperties_RU(
                        fiasGarHouse.ObjectId,
                        FiasGARAddressTypes::House,
                        '',
                        zipCodeTable.RecId);

                    if (FiasGARImportUtils::isTableChanged(houseNumberTable, houseNumberTable.orig()))
                    {
                        houseNumberTable.update();
                        this.updateInsertUpdateCounter(houseNumberTable);
                    }
                    ttscommit;
                }
            }
        }

        try
        {
            hierarchyInsertList.insertDatabase();
            houseInsertList.insertDatabase();
        }
        catch
        {
            warning(strFmt("@FIAS:DuplicateKeyWhenInsertList", "@GlobalAddressBook:GroupOfHouses"));
        }
        finally
        {
            // 1. Updates and inserts address Guid with referenced records for house addresses.
            FiasGARImportUtils::updatesExistingFiasGuid(
                tableNum(FiasGARHouse),
                fieldNum(FiasGARHouse, IsActive),
                fieldNum(FiasGARHouse, IsActual),
                fieldNum(FiasGARHouse, ObjectGuid),
                fieldNum(FiasGARHouse, OperTypeId),
                fieldNum(FiasGARHouse, ObjectId),
                versionDate,
                versionId);

            ttsbegin;
            FiasGARLogisticsAddressHierarchy fiasLogisticsAddressHierarchy;
            insert_recordset logisticsAddressFiasGuidCodes(
                FiasGuidId,
                FiasObjectId,
                FiasParentObjectId,
                OKTMO,
                RefTableId,
                RefRecId,
                versionId) 
                select AddressObjectGuidId, FiasObjectId, FiasParentObjectId, OKTMO, RefTableId from fiasLogisticsAddressHierarchy
                    join RecId, versionId from houseNumberTable
                        where houseNumberTable.CountryRegion == fiasLogisticsAddressHierarchy.CountryRegion
                            && houseNumberTable.State == fiasLogisticsAddressHierarchy.State
                            && houseNumberTable.County == fiasLogisticsAddressHierarchy.County
                            && houseNumberTable.City == fiasLogisticsAddressHierarchy.City
                            && houseNumberTable.District == fiasLogisticsAddressHierarchy.District
                            && houseNumberTable.Street == fiasLogisticsAddressHierarchy.Street
                            && houseNumberTable.Name == fiasLogisticsAddressHierarchy.Name;
            ttscommit;

            // 2. Inserts params into properties table for new added houses.
            RecordInsertList propertyInsertList = new RecordInsertList(tableNum(LogisticsAddressProperties_RU));
            while select houseNumberTable
                where houseNumberTable.CountryRegion == countryRegionCode
                join FiasObjectId, ZipCode from addressHierarchy
                    where addressHierarchy.CountryRegion == houseNumberTable.CountryRegion
                        && addressHierarchy.State == houseNumberTable.State
                        && addressHierarchy.County == houseNumberTable.County
                        && addressHierarchy.City == houseNumberTable.City
                        && addressHierarchy.District == houseNumberTable.District
                        && addressHierarchy.Street == houseNumberTable.Street
                        && addressHierarchy.Name == houseNumberTable.Name
                        && addressHierarchy.RefTableId == houseNumberTable.TableId
                #ParamsWhereClause
            {
                this.addPropertiesInsertList(propertyInsertList, paramsIFNSFL.Value, paramsTerrIfnsfl.Value, paramsOKATO.Value, addressHierarchy.ZipCode);
            }
            propertyInsertList.insertDatabase();

            // 3. Updates Properties for new added <c>LogisticsAddressHouseNumber_RU</c> records.
            ttsbegin;
            update_recordset houseNumberTable
                setting Properties = propertiesTable.RecId
                    where houseNumberTable.CountryRegion == countryRegionCode
                join FiasObjectId, ZipCode from addressHierarchy
                    where addressHierarchy.CountryRegion == houseNumberTable.CountryRegion
                        && addressHierarchy.State == houseNumberTable.State
                        && addressHierarchy.County == houseNumberTable.County
                        && addressHierarchy.City == houseNumberTable.City
                        && addressHierarchy.District == houseNumberTable.District
                        && addressHierarchy.Street == houseNumberTable.Street
                        && addressHierarchy.Name == houseNumberTable.Name
                        && addressHierarchy.RefTableId == houseNumberTable.TableId
                #ParamsWhereClause
                join propertiesTable
                    where #PropertiesWhereClause;
            ttscommit;

            FiasGARLogisticsAddressHierarchy::deleteAll();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSteadsUniqueKeyStr</Name>
				<Source><![CDATA[
    private str getSteadsUniqueKeyStr(LogisticsAddressSteadNumber_RU steadsTable)
    {
        const str uniqueKeyFormat = '%1,%2,%3,%4,%5,%6';
        return strFmt(uniqueKeyFormat, steadsTable.State, steadsTable.County, steadsTable.City, steadsTable.District, steadsTable.Street, steadsTable.Name);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSteads</Name>
				<Source><![CDATA[
    private void processSteads(str _stateId)
    {
        currentlyImportAddressType = FiasGARAddressTypes::Steads;

        FiasGARImportUtils::removeActiveAddressFromNotFoundRecords(
            tableNum(FiasGARSteads),
            fieldNum(FiasGARSteads, IsActive),
            fieldNum(FiasGARSteads, IsActual),
            fieldNum(FiasGARSteads, OperTypeId),
            fieldNum(FiasGARSteads, ObjectGuid));

        LogisticsAddressNotFoundRecords_RU logisticsAddressNotFoundRecords;
        FiasGARSteads fiasGARSteads;
        FIASOperationStatuses_RU operStatus;
        LogisticsAddressFiasGuidCodes_RU logisticsAddressFiasGuidCodes;
        LogisticsAddressElement elementSteads = LogisticsAddressElement::Stead_RU;
        LogisticsAddressNotFoundReason_RU notFoundReason = LogisticsAddressNotFoundReason_RU::Deleted;
        insert_recordset logisticsAddressNotFoundRecords(
           RefRecId,
           RefTableId,
           versionId,
           LogisticsAddressElement,
           LogisticsAddressNotFoundReason_RU)
        select RefRecId,
           RefTableId,
           versionId,
           elementSteads,
           notFoundReason from logisticsAddressFiasGuidCodes
           join fiasGARSteads
               where fiasGARSteads.ObjectGuid == logisticsAddressFiasGuidCodes.FiasGuidId
           join operStatus
               where operStatus.OperationStatus == fiasGARSteads.OperTypeId
                   && operStatus.FiasOperationType_RU == FiasOperationType_RU::DeleteOperation;

        LogisticsAddressFiasGuidCodes_RU parentAddressGuid;
        LogisticsAddressSteadNumber_RU steadsTable;
        FiasGARMUNHierarchy hierarchy;
        RecordInsertList steadsInsertList = new RecordInsertList(tableNum(LogisticsAddressSteadNumber_RU));
        RecordInsertList hierarchyInsertList = new RecordInsertList(tableNum(FiasGARLogisticsAddressHierarchy));
        Set uniqueKeySet = new Set(Types::String);
        while select steadsTable
            where steadsTable.CountryRegion == countryRegionCode
                && steadsTable.State == _stateId
        {
            uniqueKeySet.add(this.getSteadsUniqueKeyStr(steadsTable));
        }

        while select crosscompany fiasGARSteads
            where fiasGARSteads.IsActive == '1'
                && fiasGARSteads.IsActual == '1'
                && (fiasGARSteads.NextId == '0' || fiasGARSteads.NextId == '')
            join operStatus
                where operStatus.OperationStatus == fiasGARSteads.OperTypeId
                    && operStatus.FiasOperationType_RU != FiasOperationType_RU::DeleteOperation
            join hierarchy
                where hierarchy.ObjectId == fiasGARSteads.ObjectId
                    && hierarchy.IsActive == '1'
                    && hierarchy.StartDate <= versionDate
                    && hierarchy.EndDate >= versionDate
            join forupdate parentAddressGuid
                where parentAddressGuid.FiasObjectId == hierarchy.ParentObjId
        {
            Common parentTable = FiasGARImportUtils::getParentAddressRecId(parentAddressGuid);
            if (parentTable.RecId)
            {
                RecId cityRecId, districtRecId, streetRecId;
                str stateId, countyId;
                [cityRecId, districtRecId, streetRecId, stateId, countyId] = FiasGARImportUtils::getCityDistrictStreetFromAddress(parentTable);

                select firstOnly crosscompany logisticsAddressFiasGuidCodes
                        where logisticsAddressFiasGuidCodes.FiasGuidId == fiasGARSteads.objectGuid
                    join forUpdate steadsTable
                        where steadsTable.REcId == logisticsAddressFiasGuidCodes.RefRecId
                            && steadsTable.TableId == logisticsAddressFiasGuidCodes.RefTableId;

                steadsTable.selectForUpdate(true);
                steadsTable.City = cityRecId;
                steadsTable.District = districtRecId;
                steadsTable.Name = fiasGARSteads.Number;
                steadsTable.SteadDescription = fiasGARSteads.Number;
                steadsTable.Street = streetRecId;
                steadsTable.State = stateId;
                steadsTable.County = countyId;
                steadsTable.CountryRegion = countryRegionCode;

                FiasGARParams params = FiasGARParams::getParamForAddress(fiasGARSteads.ObjectId, FiasGARAddressTypes::Steads, ParamPostalCode, versionDate);
                LogisticsAddressZipCode zipCodeTable;
                if (params.RecId)
                {
                    zipCodeTable = this.getOrCreateZipCode(steadsTable, params.Value, stateId, countyId, cityRecId, districtRecId, streetRecId);
                }

                str uniqueKey = this.getSteadsUniqueKeyStr(steadsTable);
                if (!steadsTable.RecId && !uniqueKeySet.in(uniqueKey))
                {
                    steadsInsertList.add(steadsTable);
                    uniqueKeySet.add(uniqueKey);

                    FiasGARLogisticsAddressHierarchy addressHierarchyTmp;
                    addressHierarchyTmp.AddressObjectGuidId = fiasGARSteads.ObjectGuid;
                    addressHierarchyTmp.CountryRegion = countryRegionCode;
                    addressHierarchyTmp.State = steadsTable.State;
                    addressHierarchyTmp.County = steadsTable.County;
                    addressHierarchyTmp.City = steadsTable.City;
                    addressHierarchyTmp.District = steadsTable.District;
                    addressHierarchyTmp.Street = steadsTable.Street;
                    addressHierarchyTmp.Name = steadsTable.Name;
                    addressHierarchyTmp.FiasObjectId = fiasGARSteads.ObjectId;
                    addressHierarchyTmp.FiasParentObjectId = hierarchy.ParentObjId;
                    addressHierarchyTmp.OKTMO = hierarchy.OKTMO;
                    addressHierarchyTmp.RefTableId = tableNum(LogisticsAddressSteadNumber_RU);
                    addressHierarchyTmp.ZipCode = zipCodeTable.RecId;
                    hierarchyInsertList.add(addressHierarchyTmp);

                    this.updateInsertUpdateCounter(steadsTable);
                }
                else if (steadsTable.RecId)
                {
                    ttsbegin;
                    steadsTable.Properties = this.initOrUpdateProperties_RU(fiasGARSteads.ObjectId,
                        FiasGARAddressTypes::Steads,
                        '',
                        zipCodeTable.RecId);
                    if (FiasGARImportUtils::isTableChanged(steadsTable, steadsTable.orig()))
                    {
                        steadsTable.update();
                        this.updateInsertUpdateCounter(steadsTable);
                    }
                    ttscommit;
                }
            }
        }

        try
        {
            hierarchyInsertList.insertDatabase();
            steadsInsertList.insertDatabase();
        }
        catch
        {
            warning(strFmt("@FIAS:DuplicateKeyWhenInsertList", "@FIAS:SteadsInParam"));
        }
        finally
        {
            // 1. Updates and inserts Guid with referenced record for new added steads.
            FiasGARImportUtils::updatesExistingFiasGuid(
                tableNum(FiasGARSteads),
                fieldNum(FiasGARSteads, IsActive),
                fieldNum(FiasGARSteads, IsActual),
                fieldNum(FiasGARSteads, ObjectGuid),
                fieldNum(FiasGARSteads, OperTypeId),
                fieldNum(FiasGARSteads, ObjectId),
                versionDate,
                versionId);

            ttsbegin;
            FiasGARLogisticsAddressHierarchy fiasLogisticsAddressHierarchy;
            insert_recordset logisticsAddressFiasGuidCodes(FiasGuidId,
                FiasObjectId,
                FiasParentObjectId,
                OKTMO,
                RefTableId,
                RefRecId,
                versionId)
                select AddressObjectGuidId, FiasObjectId, FiasParentObjectId, OKTMO, RefTableId from fiasLogisticsAddressHierarchy
                    join RecId, versionId from steadsTable
                        where steadsTable.CountryRegion == fiasLogisticsAddressHierarchy.CountryRegion
                            && steadsTable.State == fiasLogisticsAddressHierarchy.State
                            && steadsTable.County == fiasLogisticsAddressHierarchy.County
                            && steadsTable.City == fiasLogisticsAddressHierarchy.City
                            && steadsTable.District == fiasLogisticsAddressHierarchy.District
                            && steadsTable.Street == fiasLogisticsAddressHierarchy.Street
                            && steadsTable.Name == fiasLogisticsAddressHierarchy.Name;
           ttscommit;

            // 2. Insert params into <c>LogisticsAddressProperties_RU</c> table for new added steds.
           RecordInsertList propertyInsertList = new RecordInsertList(tableNum(LogisticsAddressProperties_RU));
            while select steadsTable
                where steadsTable.CountryRegion == countryRegionCode
                join * from addressHierarchy
                    where addressHierarchy.CountryRegion == steadsTable.CountryRegion
                        && addressHierarchy.State == steadsTable.State
                        && addressHierarchy.County == steadsTable.County
                        && addressHierarchy.City == steadsTable.City
                        && addressHierarchy.District == steadsTable.District
                        && addressHierarchy.Street == steadsTable.Street
                        && addressHierarchy.Name == steadsTable.Name
                        && addressHierarchy.RefTableId == steadsTable.TableId
                #ParamsWhereClause
            {
               this.addPropertiesInsertList(propertyInsertList, paramsIFNSFL.Value, paramsTerrIfnsfl.Value, paramsOKATO.Value, addressHierarchy.ZipCode);
            }
            propertyInsertList.insertDatabase();

            // 3. Update Properties for new added <c>LogisticsAddressSteadNumber_RU</c> records.
            ttsbegin;
            update_recordset steadsTable
                setting Properties = propertiesTable.RecId
                    where steadsTable.CountryRegion == countryRegionCode
                join FiasObjectId, ZipCode from addressHierarchy
                    where addressHierarchy.CountryRegion == steadsTable.CountryRegion
                        && addressHierarchy.State == steadsTable.State
                        && addressHierarchy.County == steadsTable.County
                        && addressHierarchy.City == steadsTable.City
                        && addressHierarchy.District == steadsTable.District
                        && addressHierarchy.Street == steadsTable.Street
                        && addressHierarchy.Name == steadsTable.Name
                        && addressHierarchy.RefTableId == steadsTable.TableId
                #ParamsWhereClause
                join propertiesTable
                    where #PropertiesWhereClause;
            ttscommit;

            FiasGARLogisticsAddressHierarchy::deleteAll();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFlatsUniqueKeyStr</Name>
				<Source><![CDATA[
    private str getFlatsUniqueKeyStr(LogisticsAddressFlatNumber_RU _flatTable)
    {
        const str flatUniqueKey = '%1,%2';
        return strFmt(flatUniqueKey, _flatTable.House, _flatTable.Name);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPropertiesInsertList</Name>
				<Source><![CDATA[
    private void addPropertiesInsertList(
        RecordInsertList _propertyInsertList,
        str _paramsIFNSFL,
        str _paramsTerrIfnsfl,
        str _paramsOKATO,
        RecId _paramsZipCode,
        RecId _addressTypeTable = 0)
    {
        LogisticsAddressProperties_RU logisticsAddressProperty;
        logisticsAddressProperty.GniCode = _paramsIFNSFL;
        logisticsAddressProperty.imnsDistrict = _paramsTerrIfnsfl;
        logisticsAddressProperty.OKATO = _paramsOKATO;
        logisticsAddressProperty.ZipCode = _paramsZipCode;
        logisticsAddressProperty.AddressTypeTable_RU = _addressTypeTable;

        if (logisticsAddressProperty.GniCode != ''
            || logisticsAddressProperty.imnsDistrict != ''
            || logisticsAddressProperty.OKATO != ''
            || logisticsAddressProperty.ZipCode != 0
            || logisticsAddressProperty.AddressTypeTable_RU != 0)
        {
            str uniqueKey = strFmt('%1,%2,%3,%4,%5', logisticsAddressProperty.GniCode, logisticsAddressProperty.imnsDistrict, logisticsAddressProperty.OKATO, logisticsAddressProperty.ZipCode, logisticsAddressProperty.AddressTypeTable_RU);
            LogisticsAddressProperties_RU addressProperties = LogisticsAddressProperties_RU::findProperties(logisticsAddressProperty);

            if (!propertyUniqueKeySet.in(uniqueKey) && !addressProperties)
            {
                _propertyInsertList.add(logisticsAddressProperty);
                propertyUniqueKeySet.add(uniqueKey);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processRoomAparts</Name>
				<Source><![CDATA[
    private void processRoomAparts(str _stateId)
    {
        LogisticsAddressFlatNumber_RU flatTable;
        LogisticsAddressHouseNumber_RU houseTable;
        Set uniqueKeySet = new Set(Types::String);

        while select flatTable
            join houseTable
                where houseTable.CountryRegion == countryRegionCode
                    && houseTable.State == _stateId
                    && houseTable.RecId == flatTable.House
        {
            uniqueKeySet.add(this.getFlatsUniqueKeyStr(flatTable));
        }

        this.processAparts(_stateId, uniqueKeySet);
        this.processRoom(_stateId, uniqueKeySet);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAparts</Name>
				<Source><![CDATA[
    private void processAparts(str _stateId, Set _uniqueKeySet)
    {
        currentlyImportAddressType = FiasGARAddressTypes::Apartment;
        FiasGARImportUtils::removeActiveAddressFromNotFoundRecords(tableNum(FiasGARApartment),
            fieldNum(FiasGARApartment, IsActive),
            fieldNum(FiasGARApartment, IsActual),
            fieldNum(FiasGARApartment, OperTypeId),
            fieldNum(FiasGARApartment, ObjectGuid));

        LogisticsAddressNotFoundRecords_RU logisticsAddressNotFoundRecords;
        FiasGARApartment fiasGARApart;
        FIASOperationStatuses_RU operStatus;
        LogisticsAddressFiasGuidCodes_RU logisticsAddressFiasGuidCodes;
        LogisticsAddressElement elementFlat= LogisticsAddressElement::Flat_RU;
        LogisticsAddressNotFoundReason_RU notFoundReason = LogisticsAddressNotFoundReason_RU::Deleted;
        insert_recordset logisticsAddressNotFoundRecords(
           RefRecId,
           RefTableId,
           versionId,
           LogisticsAddressElement,
           LogisticsAddressNotFoundReason_RU)
        select RefRecId,
           RefTableId,
           versionId,
           elementFlat,
           notFoundReason from logisticsAddressFiasGuidCodes
           join fiasGARApart
               where fiasGARApart.ObjectGuid == logisticsAddressFiasGuidCodes.FiasGuidId
           join operStatus
               where operStatus.OperationStatus == fiasGARApart.OperTypeId
                   && operStatus.FiasOperationType_RU == FiasOperationType_RU::DeleteOperation;

        FiasGARApartmentTypes fiasGARApartTypes;
        FiasGARMUNHierarchy hierarchy;
        LogisticsAddressFiasGuidCodes_RU parentAddressGuid;
        RecordInsertList flatInsertList = new RecordInsertList(tableNum(LogisticsAddressFlatNumber_RU));
        RecordInsertList hierarchyInsertList = new RecordInsertList(tableNum(FiasGARLogisticsAddressHierarchy));

        while select crosscompany fiasGARApart
            where fiasGARApart.IsActive == '1' && fiasGARApart.IsActual == '1' && (fiasGARApart.NextId == '0' || fiasGARApart.NextId == '')
            join operStatus
                where operStatus.OperationStatus == fiasGARApart.OperTypeId && operStatus.FiasOperationType_RU != FiasOperationType_RU::DeleteOperation
            join  fiasGARApartTypes
                where fiasGARApartTypes.Id == fiasGARApart.ApartType
            join hierarchy
                where hierarchy.ObjectId == fiasGARApart.ObjectId
                    && hierarchy.IsActive == '1'
                    && hierarchy.StartDate <= versionDate
                    && hierarchy.EndDate >= versionDate
            join forupdate parentAddressGuid
                where parentAddressGuid.FiasObjectId == hierarchy.ParentObjId
        {
            str apartTypeName = fiasGARApartTypes.ShortName != '' ? fiasGARApartTypes.ShortName : fiasGARApartTypes.Name;
            str apartName = strFmt('%1 %2', apartTypeName, fiasGARApart.Number);
            this.importRoomAparts(
                hierarchy,
                fiasGARApart.ObjectGuid,
                apartName,
                FiasGARAddressTypes::Apartment,
                parentAddressGuid,
                _uniqueKeySet,
                flatInsertList,
                hierarchyInsertList);
        }

        try
        {
            flatInsertList.insertDatabase();
            hierarchyInsertList.insertDatabase();
        }
        catch
        {
            warning(strFmt("@FIAS:DuplicateKeyWhenInsertList", "@FIAS:Apartment"));
        }
        finally
        {
            FiasGARImportUtils::updatesExistingFiasGuid(
                tableNum(FiasGARApartment),
                fieldNum(FiasGARApartment, IsActive),
                fieldNum(FiasGARApartment, IsActual),
                fieldNum(FiasGARApartment, ObjectGuid),
                fieldNum(FiasGARApartment, OperTypeId),
                fieldNum(FiasGARApartment, ObjectId),
                versionDate,
                versionId);
            this.updatesGuidPropertiesForApartRoom();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processRoom</Name>
				<Source><![CDATA[
    private void processRoom(str _stateId, Set _uniqueKeySet)
    {
        currentlyImportAddressType = FiasGARAddressTypes::Room;
        FiasGARImportUtils::removeActiveAddressFromNotFoundRecords(tableNum(FiasGARRoom), fieldNum(FiasGARRoom, IsActive), fieldNum(FiasGARRoom, IsActual), fieldNum(FiasGARRoom, OperTypeId), fieldNum(FiasGARRoom, ObjectGuid));

        LogisticsAddressNotFoundRecords_RU logisticsAddressNotFoundRecords;
        FiasGARRoom fiasGARRoom;
        FIASOperationStatuses_RU operStatus;
        LogisticsAddressFiasGuidCodes_RU logisticsAddressFiasGuidCodes;
        LogisticsAddressElement elementFlat= LogisticsAddressElement::Flat_RU;
        LogisticsAddressNotFoundReason_RU notFoundReason = LogisticsAddressNotFoundReason_RU::Deleted;
        insert_recordset logisticsAddressNotFoundRecords(
           RefRecId,
           RefTableId,
           versionId,
           LogisticsAddressElement,
           LogisticsAddressNotFoundReason_RU)
        select RefRecId,
           RefTableId,
           versionId,
           elementFlat,
           notFoundReason from logisticsAddressFiasGuidCodes
           join fiasGARRoom
               where fiasGARRoom.ObjectGuid == logisticsAddressFiasGuidCodes.FiasGuidId
           join operStatus
               where operStatus.OperationStatus == fiasGARRoom.OperTypeId
                   && operStatus.FiasOperationType_RU == FiasOperationType_RU::DeleteOperation;

        FiasGARRoomTypes fiasGARRoomTypes;
        FiasGARMUNHierarchy hierarchy;
        LogisticsAddressFiasGuidCodes_RU parentApartAddressGuid, parentHouseAddressGuid;
        RecordInsertList flatInsertList = new RecordInsertList(tableNum(LogisticsAddressFlatNumber_RU));
        RecordInsertList hierarchyInsertList = new RecordInsertList(tableNum(FiasGARLogisticsAddressHierarchy));
        LogisticsAddressFlatNumber_RU logsitcsApartAddress;

        while select crosscompany fiasGARRoom
                where fiasGARRoom.IsActive == '1' && fiasGARRoom.IsActual == '1' && (fiasGARRoom.NextId == '0' || fiasGARRoom.NextId == '')
            join operStatus
                where operStatus.OperationStatus == fiasGARRoom.OperTypeId
                    && operStatus.FiasOperationType_RU != FiasOperationType_RU::DeleteOperation
            join fiasGARRoomTypes
                where fiasGARRoomTypes.Id == fiasGARRoom.RoomType
            join hierarchy
                where hierarchy.ObjectId == fiasGARRoom.ObjectId
                    && hierarchy.IsActive == '1'
                    && hierarchy.StartDate <= versionDate
                    && hierarchy.EndDate >= versionDate
            join parentApartAddressGuid
                where parentApartAddressGuid.FiasObjectId == hierarchy.ParentObjId
            join logsitcsApartAddress
                where logsitcsApartAddress.RecId == parentApartAddressGuid.RefRecId
                    && logsitcsApartAddress.TableId == parentApartAddressGuid.RefTableId
            join parentHouseAddressGuid
                where parentHouseAddressGuid.FiasObjectId == parentApartAddressGuid.FiasParentObjectId
        {
            str roomTypeName = fiasGARRoomTypes.ShortName != '' ? fiasGARRoomTypes.ShortName : fiasGARRoomTypes.Name;
            str roomName = logsitcsApartAddress.Name + ' ' + strFmt('%1 %2', roomTypeName, fiasGARRoom.Number);

            this.importRoomAparts(
                hierarchy,
                fiasGARRoom.ObjectGuid,
                roomName,
                FiasGARAddressTypes::Room,
                parentHouseAddressGuid,
                _uniqueKeySet,
                flatInsertList,
                hierarchyInsertList);
        }

        try
        {
            flatInsertList.insertDatabase();
            hierarchyInsertList.insertDatabase();
        }
        catch
        {
            warning(strFmt("@FIAS:DuplicateKeyWhenInsertList", "@FIAS:Room"));
        }
        finally
        {
            FiasGARImportUtils::updatesExistingFiasGuid(
                tableNum(FiasGARRoom),
                fieldNum(FiasGARRoom, IsActive),
                fieldNum(FiasGARRoom, IsActual),
                fieldNum(FiasGARRoom, ObjectGuid),
                fieldNum(FiasGARRoom, OperTypeId),
                fieldNum(FiasGARRoom, ObjectId),
                versionDate,
                versionId);
            this.updatesGuidPropertiesForApartRoom();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>importRoomAparts</Name>
				<Source><![CDATA[
    private void importRoomAparts(
        FiasGARMUNHierarchy _hierarchy,
        str _objectGuid,
        str _roomApartName,
        FiasGARAddressTypes _addressType,
        LogisticsAddressFiasGuidCodes_RU _parentAddressGuid,
        Set _uniqueKeySet,
        RecordInsertList _flatInsertList,
        RecordInsertList _hierarchyInsertList)
    {
        Common parentTable = FiasGARImportUtils::getParentAddressRecId(_parentAddressGuid);
        if (parentTable.RecId && parentTable.TableId == tableNum(LogisticsAddressHouseNumber_RU))
        {
            LogisticsAddressHouseNumber_RU houseTable = parentTable as LogisticsAddressHouseNumber_RU;
            LogisticsAddressFlatNumber_RU flatTable;
            LogisticsAddressFiasGuidCodes_RU fiasFlatGuidCodes;

            select firstOnly crosscompany fiasFlatGuidCodes
                where fiasFlatGuidCodes.FiasGuidId == _objectGuid
                join forUpdate flatTable
                    where flatTable.RecId == fiasFlatGuidCodes.RefRecId
                        && flatTable.TableId == fiasFlatGuidCodes.RefTableId;

            flatTable.Name = _roomApartName;
            flatTable.Description = _roomApartName;
            flatTable.House = houseTable.RecId;

            FiasGARParams paramsZipCode = FiasGARParams::getParamForAddress(_hierarchy.ObjectId, _addressType, ParamPostalCode, versionDate);
            LogisticsAddressZipCode zipCodeTable;
            if (paramsZipCode.RecId)
            {
                zipCodeTable = this.getOrCreateZipCode(flatTable, paramsZipCode.Value, houseTable.County, houseTable.State, houseTable.City, houseTable.District, houseTable.Street, '', houseTable.RecId, flatTable.RecId);
            }

            if (!flatTable && !_uniqueKeySet.in(this.getFlatsUniqueKeyStr(flatTable)))
            {
                _uniqueKeySet.add(this.getFlatsUniqueKeyStr(flatTable));
                _flatInsertList.add(flatTable);

                FiasGARLogisticsAddressHierarchy logisticsHierarchy;
                logisticsHierarchy.FiasObjectId = _hierarchy.ObjectId;
                logisticsHierarchy.AddressObjectGuidId = _objectGuid;
                logisticsHierarchy.FiasParentObjectId = _hierarchy.ParentObjId;
                logisticsHierarchy.OKTMO = _hierarchy.OKTMO;
                logisticsHierarchy.RefTableId = tableNum(LogisticsAddressFlatNumber_RU);
                logisticsHierarchy.House = flatTable.House;
                logisticsHierarchy.Name = flatTable.Name;
                logisticsHierarchy.ZipCode = zipCodeTable.RecId;
                _hierarchyInsertList.add(logisticsHierarchy);

                this.updateInsertUpdateCounter(flatTable);
            }
            else if (flatTable.RecId)
            {
                flatTable.Properties = this.initOrUpdateProperties_RU(_hierarchy.ObjectId, _addressType, '', zipCodeTable.RecId);
                if (FiasGARImportUtils::isTableChanged(flatTable, flatTable.orig()))
                {
                    ttsbegin;
                    flatTable.update();
                    this.updateInsertUpdateCounter(flatTable);
                    ttscommit;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatesGuidPropertiesForApartRoom</Name>
				<Source><![CDATA[
    private void updatesGuidPropertiesForApartRoom()
    {
        LogisticsAddressFlatNumber_RU flatTable;

        // 1. Inserts Guid for new added Aparts/Rooms
        ttsbegin;
        LogisticsAddressFiasGuidCodes_RU logisticsAddressFiasGuidCodes;
        insert_recordset logisticsAddressFiasGuidCodes(FiasGuidId,
            FiasObjectId,
            FiasParentObjectId,
            OKTMO,
            RefTableId,
            RefRecId,
            versionId)
            select AddressObjectGuidId, FiasObjectId, FiasParentObjectId, OKTMO, RefTableId from addressHierarchy
                join RecId, versionId from flatTable
                    where flatTable.House == addressHierarchy.House
                        && flatTable.Name == addressHierarchy.Name;
        ttscommit;

        // 2. Inserts params into <c>LogisticsAddressProperties_RU</c> for new added Aparts/Rooms.
        RecordInsertList propertyInsertList = new RecordInsertList(tableNum(LogisticsAddressProperties_RU));
        while select flatTable
            join * from addressHierarchy
                where addressHierarchy.House == flatTable.House
                    && addressHierarchy.Name == flatTable.Name
            #ParamsWhereClause
        {
            this.addPropertiesInsertList(propertyInsertList, paramsIFNSFL.Value, paramsTerrIfnsfl.Value, paramsOKATO.Value, addressHierarchy.ZipCode);
        }
        propertyInsertList.insertDatabase();

        // 3. Updates Properties for new added Aparts/Rooms.
        ttsbegin;
        update_recordset flatTable
            setting Properties = propertiesTable.RecId
            join FiasObjectId from addressHierarchy
                where addressHierarchy.House == flatTable.House
                    && addressHierarchy.Name == flatTable.Name
            #ParamsWhereClause
        join propertiesTable
            where #PropertiesWhereClause;
        ttscommit;

        FiasGARLogisticsAddressHierarchy::deleteAll();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrCreateZipCode</Name>
				<Source><![CDATA[
    private LogisticsAddressZipCode getOrCreateZipCode(
        Common _addressRecord,
        str _zipCode,
        str _regionId,
        str _countyId,
        RecId _CityRecId,
        RecId _districtRecId,
        RecId _streetRecId = 0,
        str _streetName = '',
        RecId _houseRecId = 0,
        RecId _flatRecId = 0,
        boolean _isFindZipcode = true)
    {
        LogisticsAddressZipCode logisticsAddressZipCode;

        if (_zipCode != '')
        {
            if (_isFindZipcode)
            {
                logisticsAddressZipCode = logisticsAddressZipCode::findZipCode_RU(_zipCode,
                    countryRegionCode,
                    _regionId,
                    _countyId,
                    _CityRecId,
                    _districtRecId,
                    _streetRecId,
                    _houseRecId,
                    _flatRecId);
            }

            if (_addressRecord.TableId == tableNum(logisticsAddressHouseNumber_RU)
                || _addressRecord.TableId == tableNum(logisticsAddressSteadNumber_RU))
            {
                _streetName = LogisticsAddressStreet_RU::getStreetName(_streetRecId);
            }
            if (!logisticsAddressZipCode.RecId)
            {
                ttsbegin;
                logisticsAddressZipCode.CountryRegionId = countryRegionCode;
                logisticsAddressZipCode.State = _regionId;
                logisticsAddressZipCode.County = _countyId;
                logisticsAddressZipCode.CityRecId = _CityRecId;
                logisticsAddressZipCode.District = _districtRecId;
                logisticsAddressZipCode.StreetName = _streetName;
                logisticsAddressZipCode.ZipCode = _zipCode;
                logisticsAddressZipCode.insert();
                ttscommit;
            }
        }
        return logisticsAddressZipCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOrUpdateProperties_RU</Name>
				<Source><![CDATA[
    private RecId initOrUpdateProperties_RU(
        str _objectId,
        FiasGARAddressTypes _fiasGARAddressTypes,
        str _typeName,
        RecId _zipCodeRecId)
    {
        AddressTypeTable_RU addressTypeTable_RU;
        if (_typeName != '')
        {
            select firstOnly RecId from addressTypeTable_RU
                where addressTypeTable_RU.AddrTypeName == _typeName;
        }
        paramsIFNSFL = FiasGARParams::getParamForAddress(_objectId, _fiasGARAddressTypes, ParamIFNSFL, versionDate);
        paramsTerrIfnsfl = FiasGARParams::getParamForAddress(_objectId, _fiasGARAddressTypes, ParamTerrIfnsfl, versionDate);
        paramsOKATO = FiasGARParams::getParamForAddress(_objectId, _fiasGARAddressTypes, ParamOKATO, versionDate);

        LogisticsAddressProperties_RU logisticsAddressPropertiesTable;
        logisticsAddressPropertiesTable.AddressTypeTable_RU = addressTypeTable_RU.RecId;
        logisticsAddressPropertiesTable.GniCode = paramsIFNSFL.Value;
        logisticsAddressPropertiesTable.IMNSDistrict = paramsTerrIfnsfl.Value;
        logisticsAddressPropertiesTable.OKATO = paramsOKATO.Value;
        logisticsAddressPropertiesTable.ZipCode = _zipCodeRecId;
        logisticsAddressPropertiesTable = LogisticsAddressProperties_RU::findOrCreate(logisticsAddressPropertiesTable);
        return logisticsAddressPropertiesTable.RecId;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>