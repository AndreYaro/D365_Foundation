<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LeanRulesEngine</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>LeanRulesEngine</c> class is the entry point for all external or dependent functionality.
/// </summary>
/// <remarks>
///    The <c>LeanRulesEngine</c> class provides static methods, which results in the creating,
///    initializating, composing, and executing an appropriate command (or pipeline of commands).
/// </remarks>
public class LeanRulesEngine
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>autoPlan</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Forces automatic planning for the specified instance of the <c>KanbanRule</c> class.
    /// </summary>
    /// <param name="_leanRuleData">
    ///    An object that contains the rule information.
    /// </param>
    /// <returns>
    ///    true if the operation was successful; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static boolean autoPlan(LeanRuleData _leanRuleData)
    {
        KanbanRule  kanbanRule = _leanRuleData.parmKanbanRule();
        boolean     result;

        if (LeanRuleKanban::newLeanRuleData(_leanRuleData).requiresAutoPlanning())
        {
            result = LeanRulesEngine::executePipeline(LeanCommandAutoPlan::newStandard(kanbanRule));
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCardsForRule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates circulating cards and triggers automatic assignment.
    /// </summary>
    /// <param name="_leanRuleData">
    ///    The object that contains the rule information.
    /// </param>
    /// <param name="_printCards">
    ///    A Boolean value that indicates whether to print the newly created cards.
    /// </param>
    /// <param name="_newCardsCount">
    ///    The number of cards to create.
    /// </param>
    /// <returns>
    ///    true if the operation was successful; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static boolean createCardsForRule(
        LeanRuleData _leanRuleData,
        boolean      _printCards,
        int          _newCardsCount)
    {
        KanbanRule kanbanRule = _leanRuleData.parmKanbanRule();
        LeanCommandCreateCards leanCommandCreateCards = LeanCommandCreateCards::newStandard(_leanRuleData, _printCards, _newCardsCount);

        if (kanbanRule.CardAssignmentType == KanbanCardAssignmentType::Automatic)
        {
            LeanCommandAutoAssign leanCommandAutoAssign = LeanCommandAutoAssign::newStandard(_leanRuleData);
            leanCommandCreateCards.linkToCommand(leanCommandAutoAssign);
        }

        if (kanbanRule.type().requiresAutoPlanning())
        {
            LeanCommandAutoPlan leanCommandAutoPlan = LeanCommandAutoPlan::newStandard(kanbanRule);
            leanCommandCreateCards.lastInChain().linkToCommand(leanCommandAutoPlan);
        }

        boolean result = LeanRulesEngine::executePipeline(leanCommandCreateCards);

        if (   result
            && _printCards)
        {
            leanCommandCreateCards.printNewCards();
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCardsForRuleForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Shows a form for kanban card creation parameters and then creates the needed cards.
    /// </summary>
    /// <param name="_args">
    /// The arguments, that contain the caller and the kanban rule record.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static void createCardsForRuleForm(Args _args)
    {
        _args.name(formStr(KanbanCirculatingCardsCreate));
        FormRun formRun = classfactory.formRunClass(_args);
        formRun.init();
        formRun.run();
        formRun.wait(true);

        if (formRun.closedOk())
        {
            Object objectFormRun = formRun;
            int newCardsCount = objectFormRun.getNewCardsCount();

            if (LeanRulesEngine::createCardsForRule(LeanRuleData::newKanbanRuleRecId(_args.record().RecId),
                                                objectFormRun.getPrintCards(),
                                                newCardsCount))
            {
                // %1 cards have been successfully created.
                info(strFmt("@SYS137075", newCardsCount));
                formRun.refreshCaller();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a KanbanRule and all its related entities from the given parameters.
    /// </summary>
    /// <param name="_creationParams">
    /// An object that contains all the required data to create all rule-related entities.
    /// </param>
    /// <returns>
    /// true if the operation was successful; otherwise false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static boolean createRule(LeanRuleData _creationParams)
    {
        // create and initialize the command to be performed
        LeanCommandCreateRule leanCommandCreateRule = LeanCommandCreateRule::newStandard(_creationParams);

        return LeanRulesEngine::executePipeline(leanCommandCreateRule);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes a kanban rule and all of the entities associated with the kanban rule.
    /// </summary>
    /// <param name="_leanRuleData">
    ///    The rule to delete.
    /// </param>
    /// <returns>
    ///    true if the operation was successful; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method provides extensive handling of replacement chains.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static boolean deleteRule(LeanRuleData _leanRuleData)
    {
        #define.emptyRuleId('')

        LeanCommandDeleteRule   leanCommandDeleteRule   = LeanCommandDeleteRule::newStandard(_leanRuleData);
        LeanCommandBase         firstCommand            = leanCommandDeleteRule;

        // if the rule being deleted is in the middle of a replacement chain,
        // we need to take care of preserving the chain after it with a different LeanCoverage record
        if (LeanCoverageKanbanRule::isRulePartOfReplacementChain(_leanRuleData.parmKanbanRule().RecId, false))
        {
            firstCommand = LeanCommandSetReplacedRule::newStandard(LeanRuleDataUpdate::newStandard(_leanRuleData, #emptyRuleId));
            firstCommand.linkToCommand(leanCommandDeleteRule);
        }

        // execute the commands
        return LeanRulesEngine::executePipeline(firstCommand);
    }

]]></Source>
			</Method>
			<Method>
				<Name>duplicateRule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Duplicates a kanban rule and all its related entities.
    /// </summary>
    /// <param name="_origParams">
    ///    The original parameters of the kanban rule.
    /// </param>
    /// <param name="_creationParams">
    ///    The new (duplicated) parameters of the kanban rule.
    /// </param>
    /// <param name="_duplicationMode">
    ///    Indicates whether the new rule replaces the old one.
    /// </param>
    /// <returns>
    ///    true if the execution was successful; otherwise false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static boolean duplicateRule(
        LeanRuleData                _origParams,
        LeanRuleData                _creationParams,
        KanbanRuleDuplicateFormMode _duplicationMode)
    {
        // create a rule creation command for the new rule (the one being duplicated)
        LeanCommandCreateRule leanCommandCreateRule = LeanCommandCreateRule::newStandard(_creationParams);

        // ensure policies are copied to the new rule
        LeanCommandCopyPoliciesToRule leanCommandCopyPoliciesToRule = LeanCommandCopyPoliciesToRule::newStandard(_origParams,_creationParams);
        leanCommandCreateRule.linkToCommand(leanCommandCopyPoliciesToRule);

        // if we're in replacing mode, we need to create and append a replacing command
        if (_duplicationMode == KanbanRuleDuplicateFormMode::Replace)
        {
            LeanCommandReplaceRule leanCommandReplaceRule = LeanCommandReplaceRule::newStandard(_origParams, _creationParams);
            leanCommandCopyPoliciesToRule.linkToCommand(leanCommandReplaceRule);
        }

        // execute the command(s)
        return LeanRulesEngine::executePipeline(leanCommandCreateRule);
    }

]]></Source>
			</Method>
			<Method>
				<Name>executePipeline</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes a pipeline of commands.
    /// </summary>
    /// <param name="_firstCommand">
    ///    The first command that is in the chain.
    /// </param>
    /// <param name="_secondCommand">
    ///    A secondary (chain of) commands to be executed once the first chain and its primary sub commands has finished.
    /// </param>
    /// <returns>
    ///    true if execution was successful; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method does not control how the execution is performed. It provides a common transaction scope.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected static boolean executePipeline(
        LeanCommandBase _firstCommand,
        LeanCommandBase _secondCommand = null
        )
    {
        boolean result = true;
        boolean             executeCachePostRun = false;
        LeanCommandQueue    commandQueue;

        // check input params
        if (!_firstCommand)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        // provide scope
        ttsbegin;

        if (_secondCommand)
        {
            commandQueue = LeanCommandQueue::getInstance();

            // If the queue is currently empty it means that the current process
            // is the highest in the chain that has a secondary command and therefore
            // all secondary commands must be run after the main command
            executeCachePostRun = commandQueue.isEmpty();

            // Insert the command to be run later
            commandQueue.addCommand(_secondCommand);
        }

        // start executing the chain
        result = _firstCommand.run();

        if (result && executeCachePostRun)
        {
            // Refresh queue and run any secondary commands cached during run of the main command
            commandQueue = LeanCommandQueue::getInstance();
            result = commandQueue.runQueuedCommands();
        }

        if (!result)
        {
            // 'Operation failed'
            throw error("@SYS138340");
        }

        ttscommit;

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides an entry point for the <c>LeanRulesEngine</c> class when it is called from a menu item.
    /// </summary>
    /// <param name="_args">
    /// The arguments for the <c>LeanRulesEngine</c> class.
    /// </param>
    public static void main(Args _args)
    {
        // verify input params
        if (   !_args
            || _args.parmEnumType() != enumNum(KanbanRuleEngineCommandType)
            || !_args.record() )
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        KanbanRuleEngineCommandType kanbanRuleEngineCommandType = _args.parmEnum();

        using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContext(_args))
        {
            // dispatch the call
            switch (kanbanRuleEngineCommandType)
            {
                case KanbanRuleEngineCommandType::CreateCards:
                    LeanRulesEngine::createCardsForRuleForm(_args);
                    break;
                case KanbanRuleEngineCommandType::CreateKanbans:
                    LeanRulesEngine::triggerRuleFormOrEvent(_args);
                    break;
                default:
                    throw error("@SYS133275");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>onKanbanDeleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the deletion of a record in the <c>Kanban</c> table.
    /// </summary>
    /// <param name="_kanban">
    /// The <c>Kanban</c> record in which to delete.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static void onKanbanDeleted(Kanban _kanban)
    {
        // check to see if the kanban has an assigned card to remove it (and maybe reassign it)
        if (_kanban.KanbanCardId)
        {
            KanbanCard::removeCard(_kanban);

            KanbanRule kanbanRule = _kanban.kanbanRule();
            if (kanbanRule)
            {
                LeanCommandAutoAssign::newStandard(kanbanRule.ruleData()).run();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>onKanbanJobDeleted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles the deletion of a <c>KanbanJob</c> record.
    /// </summary>
    /// <param name="_kanbanJob">
    ///    The <c>KanbanJob</c> record being deleted.
    /// </param>
    /// <remarks>
    ///    Does nothing in M1
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static void onKanbanJobDeleted(KanbanJob _kanbanJob)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>onKanbanJobStatusChange</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles the status change of a kanban job.
    /// </summary>
    /// <param name="_kanbanJob">
    ///    The kanban job that has the status changed.
    /// </param>
    /// <param name="_oldStatus">
    ///    The previous job status.
    /// </param>
    /// <param name="_requiresUndo">
    ///    A Boolean value that indicates whether the status change is status reset or not; optional.
    /// </param>
    /// <param name="_isNewKanbanJob">
    ///    A Boolean value that indicates whether the kanban job is new; optional.
    /// </param>
    /// <param name="_kanban">
    ///    The kanban to which the specified job belongs; optional.
    /// </param>
    /// <remarks>
    ///    The Undo Status operation means a reverse status transition. An example is when a job is canceled.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static void onKanbanJobStatusChange(
        KanbanJob           _kanbanJob,
        LeanKanbanJobStatus _oldStatus,
        boolean             _requiresUndo   = false,
        boolean             _isNewKanbanJob = false,
        Kanban              _kanban         = null)
    {
        LeanCommandBase             leanCommandBase;
        boolean                     kanbanCreated = false;

        LeanCommandJobStatusChange leanCommandJobStatusChange = LeanCommandJobStatusChange::newStandard(_kanbanJob, _oldStatus, _requiresUndo, _isNewKanbanJob);

        // do this check for performance reasons, because retrieving the kanban's status and active
        // rule isn't needed for most of the status transitions. given the frequency this method is
        // called, the db operations should be kept to minimum
        if (   leanCommandJobStatusChange.isKanbanInFinalStatus()
            || leanCommandJobStatusChange.isKanbanCancelled())
        {
            // Execute LeanCommandJobStatusChange -> LeanCommandCreateKanbans -> LeanCommandAutoAssign -> LeanCommandAutoPlan
            Kanban     kanban             = _kanban ? _kanban : _kanbanJob.kanban();
            KanbanRule kanbanRule         = KanbanRule::find(kanban.KanbanRule);
            RefRecId   activeRuleRefRecId = kanbanRule.status().getActiveRule();

            // if there's no currently active rule, we have nothing to do
            if (activeRuleRefRecId != 0)
            {
                // get the active rule data
                LeanRuleData activeRuleData = LeanRuleData::newKanbanRuleRecId(activeRuleRefRecId);
                kanbanRule = activeRuleData.parmKanbanRule();

                if (kanbanRule.ReplenishmentStrategy == LeanReplenishmentStrategy::Fixed)
                {
                    // a new kanban is created only if the kanban is emptied and was not a manual kanban.
                    // the current number of active kanbans must be less than the defined fixed level.
                    if (   kanban.Manual == NoYes::No
                        && leanCommandJobStatusChange.isKanbanInFinalStatus())
                    {
                        KanbanRuleFixed kanbanRuleFixed = activeRuleData.parmKanbanRuleFixed();

                        if (kanbanRuleFixed.Level > kanbanRule.activeKanbans())
                        {
                            leanCommandBase = LeanCommandCreateKanbans::newStandard(kanbanRule,1,false,false);
                            leanCommandJobStatusChange.lastInChain().linkToCommand(leanCommandBase);

                            kanbanCreated = true;
                        }
                    }

                    // check if auto-assignment needs to be triggered
                    if (   kanbanCreated
                        || leanCommandJobStatusChange.isKanbanCardReleased())
                    {
                        leanCommandBase = LeanCommandAutoAssign::newStandard(activeRuleData);
                        leanCommandJobStatusChange.lastInChain().linkToCommand(leanCommandBase);
                    }

                    // autoplanning should be done only when reaching final status otherwise
                    // potential issues with the job status reset can occur which lead to inconsistent
                    // results and user experience
                    if (leanCommandJobStatusChange.isKanbanInFinalStatus())
                    {
                        leanCommandBase = LeanCommandAutoPlan::newStandard(kanbanRule);
                        leanCommandJobStatusChange.lastInChain().linkToCommand(leanCommandBase);
                    }
                }
            }
        }

        // execute the command(s)
        LeanRulesEngine::executePipeline(leanCommandJobStatusChange);
    }

]]></Source>
			</Method>
			<Method>
				<Name>onKanbanStatusChange</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles the status change of a kanban.
    /// </summary>
    /// <param name="_kanban">
    ///    The kanban that changed its status.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static void onKanbanStatusChange(Kanban _kanban)
    {
        KanbanJob   kanbanJob = _kanban.lastKanbanJob();

        LeanRulesEngine::onKanbanJobStatusChange(kanbanJob,kanbanJob.Status,false,false,_kanban);
    }

]]></Source>
			</Method>
			<Method>
				<Name>onPlanDeactivated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles the deactivation of a <c>Plan</c> record.
    /// </summary>
    /// <param name="_plan">
    ///    The plan being deactivated.
    /// </param>
    /// <returns>
    ///    true if the operation was successful; otherwise false.
    /// </returns>
    /// <remarks>
    ///    Expires all rules that belong to the version.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static boolean onPlanDeactivated(Plan _plan)
    {
        LeanCommandExpireRules leanCommandExpireRules = LeanCommandExpireRules::newStandard(_plan);

        return LeanRulesEngine::executePipeline(leanCommandExpireRules);
    }

]]></Source>
			</Method>
			<Method>
				<Name>onPlanDuplication</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles the duplication of a <c>Plan</c> record.
    /// </summary>
    /// <param name="_fromPlan">
    ///    The old plan.
    /// </param>
    /// <param name="_toPlan">
    ///    The new plan.
    /// </param>
    /// <param name="_changedPlanPlanActivities">
    ///    A map that contains the transition between old and new record IDs for the <c>PlanPlanActivity</c>
    ///    table, which must have already been duplicated before the method is called.
    /// </param>
    /// <returns>
    ///    true if all duplication was successful; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Duplicates all rule related objects for rules with their first or last activity that belong to the
    ///    old plan. The new rules are set as replacing for the old ones.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static boolean onPlanDuplication(
        Plan _fromPlan,
        Plan _toPlan,
        Map  _changedPlanPlanActivities)
    {
        LeanCommandDuplicateRules leanCommandDuplicateRules = LeanCommandDuplicateRules::newStandard(_fromPlan, _toPlan, _changedPlanPlanActivities);

        return LeanRulesEngine::executePipeline(leanCommandDuplicateRules);
    }

]]></Source>
			</Method>
			<Method>
				<Name>onPlanUpdated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles the change in validity period of a <c>Plan</c> record.
    /// </summary>
    /// <param name="_plan">
    ///    The plan that contains rules which rules should be validated.
    /// </param>
    /// <returns>
    ///    true if all rules were updated successfully; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static boolean onPlanUpdated(Plan _plan)
    {
        Plan previousPlan = _plan.previous();

        LeanCommandUpdatePlanRules leanCommandUpdatePlanRules = LeanCommandUpdatePlanRules::newStandard(previousPlan.RecId ? previousPlan: _plan, _plan);

        return LeanRulesEngine::executePipeline(leanCommandUpdatePlanRules);
    }

]]></Source>
			</Method>
			<Method>
				<Name>onPlanValidation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles the validation of a <c>Plan</c> record.
    /// </summary>
    /// <param name="_plan">
    ///    The plan which rules we must check.
    /// </param>
    /// <returns>
    ///    true if all rules were valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Checks the validity periods for all instances of the <c>KanbanRule</c> class that have their first
    ///    or last activity bound to a specific plan.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static boolean onPlanValidation(Plan _plan)
    {
        LeanCommandValidateRules leanCommandValidateRules = LeanCommandValidateRules::newStandard(_plan);

        return LeanRulesEngine::executePipeline(leanCommandValidateRules);
    }

]]></Source>
			</Method>
			<Method>
				<Name>triggerCreateAssignPlan</Name>
				<Source><![CDATA[
    /// <summary>
    /// Triggers the creation of Kanbans for a specific <c>KanbanRule</c> rule.
    /// </summary>
    /// <param name="_kanbanRule">
    /// A <c>KanbanRule</c> record.
    /// </param>
    /// <param name="_leanCommandCreateKanbans">
    /// An initialized instance of <c>LeanCommandCreateKanbans</c> with the required creation parameters.
    /// </param>
    /// <param name="_silent">
    /// A Boolean value that defines if commands should be called in silent mode where applicable; optional.
    /// </param>
    private static void triggerCreateAssignPlan(
        KanbanRule                  _kanbanRule,
        LeanCommandCreateKanbans    _leanCommandCreateKanbans,
        boolean                     _silent = false)
    {
        // Execute LeanCommandCreateKanbans -> LeanCommandAutoAssign -> LeanCommandAutoPlan
        LeanCommandAutoAssign leanCommandAutoAssign = LeanCommandAutoAssign::newStandard(_kanbanRule.ruleData());

        LeanCommandAutoPlan leanCommandAutoPlan = LeanCommandAutoPlan::newStandard(_kanbanRule,_silent);
        leanCommandAutoAssign.linkToCommand(leanCommandAutoPlan);

        LeanRulesEngine::executePipeline(_leanCommandCreateKanbans
                                        , leanCommandAutoAssign
        );

        if (   _leanCommandCreateKanbans.listCreatedKanbans()
            && _leanCommandCreateKanbans.parmPrintKanbans())
        {
            _leanCommandCreateKanbans.printNewKanbans();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>triggerRule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Triggers creating kanbans for a specific <c>KanbanRule</c> record.
    /// </summary>
    /// <param name="_kanbanRule">
    ///    A <c>KanbanRule</c> record.
    /// </param>
    /// <param name="_kanbanCount">
    ///    The number of kanbans to be created.
    /// </param>
    /// <param name="_print">
    ///    Indicates whether the newly created kanbans should be printed.
    /// </param>
    /// <param name="_manual">
    ///    Indicates whether the newly created kanbans should be set as manual.
    /// </param>
    /// <remarks>
    ///    If the <paramref name="_kanbanCount" /> is -1, the number of kanbans is determined by the rule.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static void triggerRule(
        KanbanRule      _kanbanRule,
        int             _kanbanCount = -1,
        boolean         _print       = false,
        boolean         _manual      = false)
    {
        LeanCommandCreateKanbans leanCommandCreateKanbans = LeanCommandCreateKanbans::newStandard(_kanbanRule, _kanbanCount, _print, _manual);

        LeanRulesEngine::triggerCreateAssignPlan(_kanbanRule, leanCommandCreateKanbans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>triggerRuleForm</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows a dialog box for kanban creation parameters and then triggers the <c>KanbanRule</c> rule
    ///    passing the settings.
    /// </summary>
    /// <param name="_args">
    ///    The arguments that contain the caller and the kanban rule record.
    /// </param>
    /// <returns>
    ///    true if triggering happened and was successful; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static boolean triggerRuleForm(Args _args)
    {
        KanbanRule kanbanRule = _args.record();

        _args.name(kanbanRule.type().getKanbanCreationForm());
        FormRun formRun = classfactory.formRunClass(_args);
        formRun.init();
        formRun.run();
        formRun.wait(true);

        if (formRun.closedOk())
        {
            LeanRulesEngine::createKanbanFromForm(kanbanRule, formRun);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createKanbanFromForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a kanbans for a specific kanban rule from a form
    /// </summary>
    /// <param name="_kanbanRule">
    /// A <c>KanbanRule</c> record that represents a kanban rule.
    /// </param>
    /// <param name="_formRun">
    /// A dialog box with kanban creation parameters.
    /// </param>
    internal static void createKanbanFromForm(KanbanRule _kanbanRule, FormRun _formRun)
    {
        if (!_formRun)
        {
            return;
        }

        Object objectFormRun = _formRun;
        if (_formRun.name() == identifierStr(KanbanCreateScheduled))
        {
            LeanCommandCreateKanbans leanCommandCreateKanbans = LeanCommandCreateKanbans::newItemId(objectFormRun.parmItemId(),
                                                                                                    objectFormRun.parmInventDimId(),
                                                                                                    _kanbanRule,
                                                                                                    objectFormRun.parmProductQuantity(),
                                                                                                    objectFormRun.parmNewKanbansCount(),
                                                                                                    objectFormRun.parmDueDateTime());
            leanCommandCreateKanbans.parmPrintKanbans(objectFormRun.parmPrintKanbans());
            leanCommandCreateKanbans.parmBomId(objectFormRun.parmBomId());

            LeanRulesEngine::triggerCreateAssignPlan(_kanbanRule, leanCommandCreateKanbans);
        }
        else
        {
            LeanRulesEngine::triggerRule(_kanbanRule,
                                             objectFormRun.parmNewKanbansCount(),
                                             objectFormRun.parmPrintKanbans(),
                                             objectFormRun.parmCreateManualKanbans());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>triggerRuleFormOrEvent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates stock replenishment kanbans by using the <c>ReqEventProcessKanban</c> class, if applicable;
    ///    otherwise, passes the call to the form.
    /// </summary>
    /// <param name="_args">
    ///    The arguments that contain the caller and the kanban rule record.
    /// </param>
    /// <returns>
    ///    true if triggering occurred and was successful; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static boolean triggerRuleFormOrEvent(Args _args)
    {
        boolean             result = true;

        KanbanRule kanbanRule = _args.record();
        KanbanRuleEvent kanbanRuleEvent = KanbanRuleEvent::findKanbanRule(kanbanRule.RecId);

        if (   kanbanRuleEvent
            && kanbanRuleEvent.StockReplenishmentEvent != KanbanStockReplenishmentEventType::NotActive)
        {
            ReqEventProcessKanban::newStandard(kanbanRule, true).runOperation();
        }
        else
        {
            result = LeanRulesEngine::triggerRuleForm(_args);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>triggerRuleParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates one or more kanbans for a specific kanban rule specified parameters.
    /// </summary>
    /// <param name="_kanbanRule">
    /// A <c>KanbanRule</c> record that represents a kanban rule.
    /// </param>
    /// <param name="_itemId">
    /// The item to create kanbans for.
    /// </param>
    /// <param name="_inventDimId">
    /// The inventory dimension for created kanbans.
    /// </param>
    /// <param name="_listKanbanQuantities">
    /// A <c>List</c> object of quantities.
    /// </param>
    /// <param name="_dueDateTime">
    /// The due date and time of the created kanbans.
    /// </param>
    /// <param name="_manual">
    /// true if manual kanbans should be created; otherwise, false.
    /// </param>
    /// <param name="_priority">
    /// A <c>KanbanExpress</c> kanban priority value.
    /// </param>
    /// <param name="_bomId">
    /// A <c>BOMId</c> string value; optional.
    /// </param>
    /// <param name="_silent">
    /// A Boolean value that defines if commands should be called in silent mode where applicable; optional.
    /// </param>
    /// <param name="_kanbanSourceRequirementParm">
    /// The source requirement parameters for the kanbans to be created; optional.
    /// </param>
    /// <returns>
    /// A <c>List</c> object that holds <c>Kanban</c> records.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static List triggerRuleParameters(
        KanbanRule                  _kanbanRule,
        ItemId                      _itemId,
        InventDimId                 _inventDimId,
        List                        _listKanbanQuantities,
        KanbanDueDateTime           _dueDateTime,
        boolean                     _manual,
        KanbanExpress               _priority,
        BOMId                       _bomId                       = '',
        boolean                     _silent                      = false,
        KanbanSourceRequirementParm _kanbanSourceRequirementParm = null)
    {
        LeanCommandCreateKanbans leanCommandCreateKanbans = LeanCommandCreateKanbans::newItemIdVariableQuantity(
                                                                                                         _itemId,
                                                                                                         _inventDimId,
                                                                                                         _kanbanRule,
                                                                                                         _listKanbanQuantities,
                                                                                                         _dueDateTime,
                                                                                                         _manual,
                                                                                                         _priority,
                                                                                                         _bomId,
                                                                                                         _kanbanSourceRequirementParm);

        LeanRulesEngine::triggerCreateAssignPlan(_kanbanRule,leanCommandCreateKanbans,_silent);

        return leanCommandCreateKanbans.listCreatedKanbans();
    }

]]></Source>
			</Method>
			<Method>
				<Name>triggerRuleReqPO</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates one or more kanbans for a specific kanban rule and planned order.
    /// </summary>
    /// <param name="_kanbanRule">
    ///    An instance of the <c>KanbanRule</c> class that represents a kanban rule.
    /// </param>
    /// <param name="_reqPO">
    ///    A <c>ReqPO</c> record that represents a planned order.
    /// </param>
    /// <returns>
    ///    A list that contains the <c>Kanban</c> records.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static List triggerRuleReqPO(
        KanbanRule      _kanbanRule,
        ReqPO           _reqPO)
    {
        ReqSplitQuantities          reqSplitQuantities;

        LeanRuleData leanRuleData = LeanRuleData::newKanbanRuleRecId(_kanbanRule.RecId);
        LeanRuleKanban leanRuleKanban = leanRuleData.type();

        // Determine the number of kanbans and the quantities distribution
        if (_kanbanRule.Quantity)
        {
            // Split in fixed sizes
            reqSplitQuantities = ReqSplitQuantities::newMinimumMaximum(
                                                                _reqPO.Qty,
                                                                _kanbanRule.Quantity,
                                                                _kanbanRule.Quantity);
        }
        else
        {
            // Split in variable sizes
            reqSplitQuantities = ReqSplitQuantities::newMinimumMaximum(
                                                                _reqPO.Qty,
                                                                leanRuleKanban.getMinKanbanQty(),
                                                                leanRuleKanban.getMaxKanbanQty());
        }

        LeanCommandCreateKanbans leanCommandCreateKanbans = LeanCommandCreateKanbans::newItemIdVariableQuantity(
                                                                                                         _reqPO.ItemId,
                                                                                                         _reqPO.CovInventDimId,
                                                                                                         _kanbanRule,
                                                                                                         reqSplitQuantities.parmQuantityDistribution(),
                                                                                                         _reqPO.reqDateTime(),
                                                                                                         false,
                                                                                                         NoYes::No);

        LeanRulesEngine::triggerCreateAssignPlan(_kanbanRule, leanCommandCreateKanbans);

        return leanCommandCreateKanbans.listCreatedKanbans();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates a <c>KanbanRule</c> rule from the given parameters.
    /// </summary>
    /// <param name="_updateParams">
    ///    An object that contains all the required data to update all rule-related entities.
    /// </param>
    /// <returns>
    ///    true if the operation was successful; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static boolean updateRule(LeanRuleData _updateParams)
    {
        LeanCommandBase             leanCommandBase;

        LeanCommandUpdateRule leanCommandUpdateRule = LeanCommandUpdateRule::newStandard(_updateParams);

        // if a replacement is necessary -> generate necessary commands
        if (LeanCommandUpdateRule::requiresReplacement(_updateParams))
        {
            // step 1: maintain the LeanCoverage records of the rules (or chains)
            //         that will get merged or disjoint

            // take care of maintaining the LeanCoverage records for the updated rule
            // and eventually the chain after it, if such exists
            leanCommandBase = LeanCommandSetReplacedRule::newStandard(_updateParams, true);
            leanCommandUpdateRule.lastInChain().linkToCommand(leanCommandBase);

            KanbanRule kanbanRule = _updateParams.parmKanbanRule().replacedRule();

            // step 2: if there's an old replaced rule, this one should be updated so
            //         it doesn't refer to the current rule
            if (kanbanRule)
            {
                LeanRuleData leanRuleData = kanbanRule.ruleData();
                kanbanRule = leanRuleData.parmKanbanRule();
                kanbanRule.ReplacingKanbanRule = 0;

                leanCommandBase = LeanCommandUpdateRule::newStandard(leanRuleData);
                leanCommandUpdateRule.lastInChain().linkToCommand(leanCommandBase);
            }

            kanbanRule = _updateParams.selectedReplacedKanbanRule();

            // step 3: if the new replaced rule is existing -> we need to get it updated too
            //         (the ReplacingKanbanRule link + the validity dates)
            if (kanbanRule.RecId != 0)
            {
                // we set the reread param to true, because the LeanCoverage might be changed
                // by other commands before that one is executed, so the LeanRuleData object
                // might be already invalid at the execution method
                leanCommandBase = LeanCommandReplaceRule::newStandard(kanbanRule.ruleData(), _updateParams, true);
                leanCommandUpdateRule.lastInChain().linkToCommand(leanCommandBase);
            }
        }

        // check if auto-assignment of cards is necessary
        if (LeanCommandUpdateRule::requiresAutoAssignment(_updateParams))
        {
            leanCommandBase = LeanCommandAutoAssign::newStandard(_updateParams);
            leanCommandUpdateRule.lastInChain().linkToCommand(leanCommandBase);
        }

        // check if auto-planning is necessary
        if (LeanCommandUpdateRule::requiresAutoPlanning(_updateParams))
        {
            leanCommandBase = LeanCommandAutoPlan::newStandard(_updateParams.parmKanbanRule());
            leanCommandUpdateRule.lastInChain().linkToCommand(leanCommandBase);
        }

        return LeanRulesEngine::executePipeline(leanCommandUpdateRule);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>