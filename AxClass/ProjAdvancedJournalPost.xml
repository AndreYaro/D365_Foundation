<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjAdvancedJournalPost</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///     Contains the logic for posting a single project advanced journal.
/// </summary>
public class ProjAdvancedJournalPost extends RunBase
{
    ProjAdvancedJournal projAdvancedJournal;

    Counter progressCounter;
    Counter numOfLinesProcessed;

    private boolean isEnhancedPostingEnabled = FeatureStateProvider::isFeatureEnabled(ProjAdvancedJournalPostingEnhancementFeature::instance());
    private boolean enableProjAdvancedJournalErrorTransferFeature = FeatureStateProvider::isFeatureEnabled(ProjEnableAdvancedJournalErrorTransferFeature::instance());
    private const real MaximumFloatingPointDelta = 1.0e-6;
    private ProjOpsIntegrationLogger logger = ProjOpsIntegrationLogger::createLogger(classStr(ProjAdvancedJournalPost));

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>displayProgress</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the progress of the post operation using the specified line number and transaction date.
    /// </summary>
    /// <param name="_lineNum">
    ///     The line number of the project advanced journal line.
    /// </param>
    /// <param name="_transDate">
    ///     The transaction date of a project advanced journal.
    /// </param>
    private void displayProgress(LineNum _lineNum, TransDate _transDate)
    {
        progressCounter++;

        progress.setCount(progressCounter);

        progress.setText(strFmt("@SYS97556", real2int(_lineNum), _transDate));

        progress.update(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjAdvancedJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates the project advanced journal that is selected for posting.
    /// </summary>
    /// <param name="_projAdvancedJournal">The <c>ProjAdvancedJournal</c> table buffer to be checked.The table buffer to be checked.</param>
    /// <returns>
    ///     true if the project advanced journal is valid for processing; otherwise, false.
    /// </returns>
    public boolean checkProjAdvancedJournal(ProjAdvancedJournal _projAdvancedJournal = null)
    {
        boolean isValid = true;

        if (_projAdvancedJournal)
        {
            projAdvancedJournal = _projAdvancedJournal;
        }

        if (projAdvancedJournal.RecId == 0)
        {
            isValid = checkFailed(strFmt("@SYS127812", projAdvancedJournal.ProjAdvancedJournalId));
        }
        else
        {
            if (projAdvancedJournal.Status != ProjAdvancedJournalStatus::Draft)
            {
                logger.logCritical(strFmt("@Proj:JournalPostingErrorTelemetry", projAdvancedJournal.RecId, 'Journal status not in Draft state.'));
                isValid = checkFailed(strFmt("@Proj:JournalNotEligibleForPosting", projAdvancedJournal.ProjAdvancedJournalId, projAdvancedJournal.DataAreaId));
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjAdvancedJournalLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates all the project advanced journal lines that are selected for posting.
    /// </summary>
    /// <param name="_projAdvancedJournal">The <c>ProjAdvancedJournal</c> table buffer to be checked.</param>
    /// <returns>
    ///     true if the project advanced journal lines are valid for processing; otherwise, false.
    /// </returns>
    public boolean checkProjAdvancedJournalLines(ProjAdvancedJournal _projAdvancedJournal = null)
    {
        boolean isValid = true;

        if (_projAdvancedJournal)
        {
            projAdvancedJournal = _projAdvancedJournal;
        }

        if (projAdvancedJournal)
        {
            ProjAdvancedJournalLine line;

            while select line
                where line.ProjAdvancedJournal == projAdvancedJournal.RecId
            {
                // showing current line progress
                this.displayProgress(line.LineNumber, line.AccountingDate);

                if (!this.checkProjAdvancedJournalLineV2(line))
                {
                    isValid = false;
                    if (isEnhancedPostingEnabled)
                    {
                        warning(strFmt("@Proj:JournalLineNotEligibleForPosting", line.RecId, line.Voucher, projAdvancedJournal.ProjAdvancedJournalId));
                    }
                    break;
                }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjAdvancedJournalLineV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Public method to allow external class which need to submite project advanced journal able to perform validation the the journal line first.
    /// </summary>
    /// <param name="_projAdvancedJournalLine">The <c>ProjAdvancedJournalLine</c>table buffer to be checked.</param>
    /// <returns>
    /// true if the line is valid for posting; otherwise, false.
    /// </returns>
    public boolean checkProjAdvancedJournalLineV2(ProjAdvancedJournalLine _projAdvancedJournalLine)
    {
        boolean isValid = true;

        // Fee types should not have a cost
        if ((_projAdvancedJournalLine.ExtendedCost != 0 && _projAdvancedJournalLine.TransType == ProjTransType::Revenue))
        {
            logger.logError(strFmt("@Proj:JournalLinePostingErrorTelemetry",
                _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal, 'Fee lines can not have cost'));
            isValid = checkFailed(strFmt("@Proj:FeeCannotHaveCost", _projAdvancedJournalLine.Voucher));
        }

        // Check currency
        if (_projAdvancedJournalLine.CostCurrency
            && !AdvancedLedgerEntryManager::validateCurrency(_projAdvancedJournalLine.CostCurrency))
        {
            logger.logError(strFmt("@Proj:JournalLinePostingErrorTelemetry",
                _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal, 'Invalid cost currency.'));

            isValid = false;
        }

        if (_projAdvancedJournalLine.PriceCurrency
            && !AdvancedLedgerEntryManager::validateCurrency(_projAdvancedJournalLine.PriceCurrency))
        {
            logger.logError(strFmt("@Proj:JournalLinePostingErrorTelemetry",
                _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal, 'Invalid price currency.'));

            isValid = false;
        }

        // Check project status
        changecompany(_projAdvancedJournalLine.ProjDataAreaId)
        {
            ProjTable projTable = ProjTable::find(_projAdvancedJournalLine.ProjId);
            if (isValid && !projTable.status().journalCheckStatus())
            {
                ProjStage projStage = projTable.Stage();

                logger.logError(strFmt("@Proj:JournalLinePostingErrorTelemetry",
                    _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal, strFmt('Invalid project status %1', projStage)));

                isValid = isValid && checkFailed(strFmt("@Proj:LineCannotBePostedDueToProjectStageError", _projAdvancedJournalLine.Voucher, _projAdvancedJournalLine.ProjId, projStage));
            }
        }

        // Ensure offset information is provided for expense type lines
        if (!_projAdvancedJournalLine.validateOffsetInformation())
        {
            logger.logError(strFmt("@Proj:JournalLinePostingErrorTelemetry",
                _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal, 'Offset dimension invalid for expense line.'));
            isValid = false;
        }

        // Check taxes
        if (!_projAdvancedJournalLine.validateTaxInformation())
        {
            logger.logError(strFmt("@Proj:JournalLinePostingErrorTelemetry",
                _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal, 'Invalid tax information.'));
            isValid = false;
        }

        // Check project category
        if (_projAdvancedJournalLine.ProjId && _projAdvancedJournalLine.ProjCategoryId && !this.checkLineDistributionsProjectCategory(_projAdvancedJournalLine))
        {
            logger.logError(strFmt("@Proj:JournalLinePostingErrorTelemetry",
                _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal, 'Invalid project category line distributions.'));
            isValid = false;
        }

        if (!LedgerFiscalCalendar::checkLedgerPeriodDateModule(CompanyInfoHelper::fiscalCalendarRecId(), _projAdvancedJournalLine.AccountingDate, SysModule::Project, false))
        {
            if (ProjParameters::canUpdateAccountingDate(_projAdvancedJournalLine.ProjDataAreaId))
            {
                TransDate origAccDate = _projAdvancedJournalLine.AccountingDate;
                TransDate newAccDate = ProjPost::findNextAvailableAccountingDate(_projAdvancedJournalLine.AccountingDate);

                if (newAccDate == dateNull())
                {
                    logger.logError(strFmt("@Proj:JournalLinePostingErrorTelemetry",
                        _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal, 'No available accounting date.'));
 
                    isValid = isValid && checkFailed(strFmt("@Proj:ProjAdvancedJournalLineEmptyAccountingDate", _projAdvancedJournalLine.Voucher));
                }

                if (isValid && origAccDate != newAccDate)
                {
                    ttsbegin;
                    _projAdvancedJournalLine.reread();
                    _projAdvancedJournalLine.selectForUpdate(true);
                    _projAdvancedJournalLine.AccountingDate = newAccDate;
                    _projAdvancedJournalLine.update();
                    ttscommit;
                }
            }
            else
            {
                logger.logError(strFmt("@Proj:JournalLinePostingErrorTelemetry",
                    _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal, 'Update accounting date is not enabled in parameters.'));

                isValid = isValid && checkFailed("@SPS1716");
            }
        }

        // if line pass the validation then increase the number of pass lines
        if (isValid)
        {
            numOfLinesProcessed++;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLineDistributionsProjectCategory</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether a Project category of <c>AccountingDistribution</c> record of given <c>AdvancedLedgerEntryLine</c> is valid.
    /// </summary>
    /// <param name="_projAdvancedJournalLine">
    ///     The table buffer to be checked.
    /// </param>
    /// <returns>
    ///     true if Project category of <c>AccountingDistribution</c> record of given <c>ProjAdvancedJournalLine</c> is valid; otherwise, false.
    /// </returns>
    protected boolean checkLineDistributionsProjectCategory(ProjAdvancedJournalLine _projAdvancedJournalLine)
    {
        boolean isValid = true;

        AccountingDistribution accountingDistribution;
        ProjectAccountingDistribution projectAccountingDistribution;

        while select projectAccountingDistribution
            exists join accountingDistribution
                where accountingDistribution.RecId == projectAccountingDistribution.AccountingDistribution
                    && accountingDistribution.SourceDocumentLine == _projAdvancedJournalLine.SourceDocumentLine
        {
            if (!AdvancedLedgerEntryManager::checkProjCategoryId(projectAccountingDistribution.editProjectCategoryId(false, '')))
            {
                isValid = false;
                break;
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldProcessTaxes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Base method for checking whether taxes should be processed for
    /// a <c>ProjAdvancedJournalLine</c> record.
    /// </summary>
    /// <param name = "_projAdvancedJournalLine">A <c>ProjAdvancedJournalLine</c> buffer.</param>
    /// <returns>true, if taxes should be processed. Otherwise, false.</returns>
    /// <remarks>
    /// This method must be extended.
    /// </remarks>
    public static boolean shouldProcessTaxes(ProjAdvancedJournalLine _projAdvancedJournalLine)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTaxes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate and post taxes for all the transactions in the project advanced journal.
    /// </summary>
    /// <param name = "_projAdvancedJournal">A <c>ProjAdvancedJournal</c> buffer.</param>
    public static void processTaxes(ProjAdvancedJournal _projAdvancedJournal)
    {
        ttsbegin;

        if (_projAdvancedJournal)
        {
            ProjAdvancedJournalLine projAdvancedJournalLine;

            while select projAdvancedJournalLine
                where projAdvancedJournalLine.ProjAdvancedJournal == _projAdvancedJournal.RecId
            {
                ProjAdvancedJournalPost::processTaxesForLine(projAdvancedJournalLine);
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTaxesForLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates and posts taxes for a project advanced journal line.
    /// </summary>
    /// <param name = "_projAdvancedJournalLine">A <c>ProjAdvancedJournalLine</c> buffer.</param>
    public static void processTaxesForLine(ProjAdvancedJournalLine _projAdvancedJournalLine)
    {
        NumberSequenceCode voucherSeriesCode;
        LedgerVoucher ledgerVoucher;
        LedgerVoucherObject ledgerVoucherObject;

        ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail, SysModule::Ledger, voucherSeriesCode);

        ledgerVoucherObject = LedgerVoucherObject::newVoucher(
            _projAdvancedJournalLine.Voucher,
            _projAdvancedJournalLine.AccountingDate,
            SysModule::Ledger);

        ledgerVoucher.addVoucher(ledgerVoucherObject);

        LedgerPostingController ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher);
        boolean isPost = ProjAdvancedJournalPost::shouldProcessTaxes(_projAdvancedJournalLine);

        if (FeatureStateProvider::isFeatureEnabled(TaxProjOpsIntegrationJournal_INFeature::instance())
            && _projAdvancedJournalLine.checkTaxWithholdExpense_IN())
        {
            ProjAdvancedJournalLineTaxWithholdDocument_IN projAdvancedJournalLineTaxWithholdDocument = ProjAdvancedJournalLineTaxWithholdDocument_IN::construct(_projAdvancedJournalLine);
            projAdvancedJournalLineTaxWithholdDocument.post(ledgerPostingController, isPost);
        }
        else
        {
            ProjAdvancedJournalLineTaxDocument projAdvancedJournalLineTaxDocument = ProjAdvancedJournalLineTaxDocument::construct(_projAdvancedJournalLine);
            projAdvancedJournalLineTaxDocument.post(ledgerPostingController, isPost);
        }

        if (FeatureStateProvider::isFeatureEnabled(TaxProjOpsIntegrationJournal_INFeature::instance())
            && TaxSolutionScopeIntegrationUtil::isCompanyEnabled()
            && isPost)
        {
            TaxEngineProjAdvancedJournalLineHeader taxEngineProjAdvJournalLineHeader = _projAdvancedJournalLine.salesPurchJournalTable();
            TaxableDocumentDescriptor taxableDocDescriptor = TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(taxEngineProjAdvJournalLineHeader);
            ITaxableDocument taxableDocument = TaxableDocumentObject::construct(taxableDocDescriptor);
            TaxBusinessService::postTax(ledgerVoucher, taxableDocument);
            // Tax document should be posted when it is async tasks.
            TaxBusinessService::postTaxDocument(taxableDocument, ledgerVoucher);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingProcessAfterSourceDocumentSubmit</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method wrap all of the logics need to be execute after source document submission
    /// </summary>
    /// <param name="_projAdvancedJournalPostBatchTask">
    /// A boolean value to indicate if the method is called from batch task
    /// </param>
    protected void postingProcessAfterSourceDocumentSubmit(boolean _projAdvancedJournalPostBatchTask=false)
    {
        using (SysInstrumentationActivityContext activityContext = logger.integrationJournalActivity().afterGLPostAdvancedJournalPostingContext())
        {
            boolean enableProjAdvancedJournalMultipleBatchTaskFeature = FeatureStateProvider::isFeatureEnabled(ProjEnableAdvancedJournalMultipleBatchTaskFeature::instance());

            // Transfer error journal lines when journal is posted using batch tasks and error transfer feature is ON
            if (enableProjAdvancedJournalErrorTransferFeature)
            {
                ProjAdvancedJournalPostTransfer transfer = new ProjAdvancedJournalPostTransfer();
                transfer.transferErrorJournalLines(projAdvancedJournal);

                if (projAdvancedJournal.Status == ProjAdvancedJournalStatus::Error)
                {
                    // Stop processing if the journal is in error state
                    return;
                }
            }

            // All lines present in the journal should have their status set to Posted and Journal must not be empty for posting to proceed.
            if (isEnhancedPostingEnabled 
                && (!projAdvancedJournal.checkIfAllJournalLineHasSameStatus(ProjAdvancedJournalLineStatus::Posted) || projAdvancedJournal.numOfLines() == 0))
            {
                logger.logError(strFmt("@Proj:JournalPostingErrorTelemetry",
                    projAdvancedJournal.RecId, 'Not all journal lines are marked as posted.'));

                throw error(strFmt("@Proj:MismatchedStatusOfLinesInJournal",
                        projAdvancedJournal.ProjAdvancedJournalId, projAdvancedJournal.DataAreaId, ProjAdvancedJournalLineStatus::Posted));
            }
            
            // Process No/never ledger transactions
            ProjAdvancedJournalPost::processNoNeverLedgerTrx(projAdvancedJournal);

            if (!ProjAdvancedJournalPostingSourceDocumentRetryFlight::instance().isEnabled())
            {
                // Do not throw exceptions for source document issues, as it will roll back the error journal transfer done above

                SourceDocument sourceDocument = SourceDocument::newFromSourceDocumentImplementation(projAdvancedJournal);
                SourceDocumentHeader sourceDocumentHeader = sourceDocument.parmSourceDocumentHeader();
        
                if (sourceDocumentHeader && (_projAdvancedJournalPostBatchTask || isEnhancedPostingEnabled))
                {
                    SourceDocumentLine sourceDocumentLine;
                    select count(RecId) from sourceDocumentLine
                        where sourceDocumentLine.SourceDocumentHeader == sourceDocumentHeader.RecId
                            && sourceDocumentLine.AccountingStatus !=  SourceDocumentLineAccountingStatus::Completed;

                    if (sourceDocumentLine.RecId > 0)
                    {
                        logger.logError(strFmt("@Proj:JournalPostingErrorTelemetry",
                            projAdvancedJournal.RecId, strFmt('Not all Source Doument lines are marked Complete. SourceDoc RecId: %1', sourceDocumentHeader.RecId)));

                        throw error(strFmt("@Proj:SourceDocumentLinePostingError", sourceDocumentHeader.RecId));
                    }
                }
                else if (sourceDocumentHeader && sourceDocumentHeader.AccountingStatus != SourceDocumentAccountingStatus::Completed)
                {
                    logger.logError(strFmt("@Proj:JournalPostingErrorTelemetry",
                        projAdvancedJournal.RecId, strFmt('Source Doument not marked Complete. SourceDoc RecId: %1', sourceDocumentHeader.RecId)));

                    throw error(strFmt("@Proj:SourceDocumentHeaderPostingError", sourceDocumentHeader.RecId));
                }
            }

            // Process indirect components
            ProjAdvancedJournalPost::processIndirectComponentTrans(projAdvancedJournal.RecId);
            
            // Create customer, vendor, or bank transactions
            ProjAdvancedJournalPost::processSubLedger(projAdvancedJournal.RecId);

            // Update resource periods
            ProjAdvancedJournalPost::updateResourcePeriod(projAdvancedJournal.RecId);

            // Update project advanced journal record
            if (_projAdvancedJournalPostBatchTask)
            {
                projAdvancedJournal.reread();
            }

            // Update project advanced journal record status as per new update logic
            projAdvancedJournal.selectForUpdate(true);
            if (isEnhancedPostingEnabled)
            {
                projAdvancedJournal.updateJournalStatus(ProjAdvancedJournalStatus::Processing, ProjAdvancedJournalStatus::Posted);
            }
            else
            {
                projAdvancedJournal.Status = ProjAdvancedJournalStatus::Posted;
            }
            projAdvancedJournal.PostedDateTime = DateTimeUtil::getSystemDateTime();
            projAdvancedJournal.PostedUserId = curUserId();
            projAdvancedJournal.update();

            TransactionLog::create(TransactionLogType::ProjJournal, "@Proj:ProjectAdvancedJournal");

            this.onAdvancedJournalPost(projAdvancedJournal.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postToLedger</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Posts the project advanced journal into the general ledger.
    /// </summary>
    /// <param name="_projAdvancedJournalPostBatchTask">
    /// Boolean that indicates whether this method is called from <c>ProjAdvancedJournalPostBatchTask</c>.
    /// </param>
    private void postToLedger(boolean _projAdvancedJournalPostBatchTask=false)
    {
        if (!_projAdvancedJournalPostBatchTask)
        {
            if (enableProjAdvancedJournalErrorTransferFeature)
            {
                // Process each journal lines in their own transaction scope and lastly process header in another transaction scope.
                this.processJournalWhenTranferErrorFeatureIsEnabled();
            }
            else // !enableProjAdvancedJournalErrorTransferFeature
            {
                this.processJournalWhenTranferErrorFeatureIsNotEnabled();
            }
        }
        else // _projAdvancedJournalPostBatchTask = true
        {
            ttsbegin;
            this.postingProcessAfterSourceDocumentSubmit();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processJournalWhenTranferErrorFeatureIsEnabled</Name>
				<Source><![CDATA[
    private void processJournalWhenTranferErrorFeatureIsEnabled()
    {
        using (SysInstrumentationActivityContext activityContext = logger.integrationJournalActivity().postAdvancedJournalContext())
        {
            activityContext.addCustomProperty(ProjOpsIntegrationJournalInstrumentationActivites::AdvancedJournalId, int642Str(projAdvancedJournal.RecId));
            activityContext.addCustomProperty(ProjOpsInstrumentationBaseActitivies::ActionProperty, 'Posting advanced journal with error lines transferred');
            activityContext.addCustomProperty(ProjOpsInstrumentationBaseActitivies::IsBatch, 'False');
            activityContext.addCustomProperty(ProjOpsIntegrationJournalInstrumentationActivites::NumOfJournalLines, int2Str(projAdvancedJournal.numOfLines()));
            activityContext.addCustomProperty(ProjOpsIntegrationJournalInstrumentationActivites::EnhancedPosting, any2Str(isEnhancedPostingEnabled));

            if (isEnhancedPostingEnabled)
            {
                // Update journal line with None Status to draft or Posted; if applicable. Mark PostError field on Unrecoverable lines.
                this.preprocessJournalLines(projAdvancedJournal, true);

                this.processJournalEnhanced();
            }
            else
            {
                ProjAdvancedJournalLine projAdvancedJournalLine;

                while select forupdate projAdvancedJournalLine
                    order by projAdvancedJournalLine.LineNumber asc
                    where projAdvancedJournalLine.ProjAdvancedJournal == projAdvancedJournal.RecId
                {
                    try
                    {
                        this.processJournalLine(projAdvancedJournalLine);
                    }
                    catch (Exception::Error)
                    {
                        ttsbegin;
                        projAdvancedJournalLine.PostError = NoYes::Yes;
                        projAdvancedJournalLine.doUpdate();
                        ttscommit;
                            
                        logger.logError(strFmt("@Proj:JournalLinePostingErrorTelemetry", 
                            projAdvancedJournalLine.RecId, projAdvancedJournalLine.ProjAdvancedJournal, Exception::Error));
                    }
                }

                activityContext.addCustomProperty(ProjOpsIntegrationJournalInstrumentationActivites::NumOfErrorJournalLines, int2Str(projAdvancedJournal.numOfErrorLines()));

                ttsbegin;
                this.postingProcessAfterSourceDocumentSubmit();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processJournalWhenTranferErrorFeatureIsNotEnabled</Name>
				<Source><![CDATA[
    private void processJournalWhenTranferErrorFeatureIsNotEnabled()
    {
        using (SysInstrumentationActivityContext activityContext = logger.integrationJournalActivity().postAdvancedJournalContext())
        {
            activityContext.addCustomProperty(ProjOpsIntegrationJournalInstrumentationActivites::AdvancedJournalId, int642Str(projAdvancedJournal.RecId));
            activityContext.addCustomProperty(ProjOpsInstrumentationBaseActitivies::ActionProperty, 'Posting advanced journal without error lines transfer');
            activityContext.addCustomProperty(ProjOpsInstrumentationBaseActitivies::IsBatch, 'False');
            activityContext.addCustomProperty(ProjOpsIntegrationJournalInstrumentationActivites::NumOfJournalLines, int2Str(projAdvancedJournal.numOfLines()));
            activityContext.addCustomProperty(ProjOpsIntegrationJournalInstrumentationActivites::EnhancedPosting, any2Str(isEnhancedPostingEnabled));

            if (isEnhancedPostingEnabled)
            {
                // Ensure lines with None Status is updated to reflect correct status.
                this.preprocessJournalLines(projAdvancedJournal, true);
                
                this.processJournalEnhanced();
            }
            else
            {
                ttsbegin;
                // Process taxes
                ProjAdvancedJournalPost::processTaxes(projAdvancedJournal);
      
                SourceDocumentProcessorFacade::submitSourceDocumentImplementation(
                        projAdvancedJournal,
                        false,
                        SourceDocumentAccountingStatus::Completed);

                this.postingProcessAfterSourceDocumentSubmit();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processJournalEnhanced</Name>
				<Source><![CDATA[
    private void processJournalEnhanced()
    {
        using (SysInstrumentationActivityContext activityContext = logger.integrationJournalActivity().postAdvancedJournalContext())
        {
            Set linesInDraft = this.getJournalLinesWithMatchingStatus(projAdvancedJournal, ProjAdvancedJournalLineStatus::Draft);
            SetIterator lines = new SetIterator(linesInDraft);

            while (lines.more())
            {
                ProjAdvancedJournalLine projAdvancedJournalLine = ProjAdvancedJournalLine::findNoCache(lines.value());

                this.processJournalLineEnhanced(projAdvancedJournalLine);

                lines.next();
            }
        
            if (enableProjAdvancedJournalErrorTransferFeature)
            {
                activityContext.addCustomProperty(ProjOpsIntegrationJournalInstrumentationActivites::NumOfErrorJournalLines, int2Str(projAdvancedJournal.numOfErrorLines()));
            }   
  
            ttsbegin;
            this.postingProcessAfterSourceDocumentSubmit();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processJournalLineEnhanced</Name>
				<Source><![CDATA[
    internal void processJournalLineEnhanced(ProjAdvancedJournalLine _projAdvancedJournalLine)
    {
        Microsoft.Dynamics.Ax.Xpp.ErrorException xppEx;
        int currentExecutionCount = 1;
        const int MaxSourceDocRetry = 3;

        try
        {
            // This works as a pessimisic lock on line in order to process it (Without locking any record or table in database).
            // In case several process tries to process the line, only one would be successful in updating it from Draft to Processing
            // and all others would fail.
            // The failed processes should skip processing of the line.
            _projAdvancedJournalLine.updateJournalLineStatus(ProjAdvancedJournalLineStatus::Draft, ProjAdvancedJournalLineStatus::Processing);
        }
        catch
        {
            info(strFmt("@Proj:JournalLineProcessingSkipped",
                projAdvancedJournal.ProjAdvancedJournalId, any2Str(_projAdvancedJournalLine.RecId), _projAdvancedJournalLine.Voucher));

            return;
        }

        try
        {
            this.processJournalLineEnhancedHelper(_projAdvancedJournalLine);
        }
        catch (xppEx)
        {
            logger.logCritical(strFmt("@Proj:JournalLinePostingErrorTelemetry",
                _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal, xppEx.Message));

            boolean sourceDocumentRetryFlightEnabled = ProjAdvancedJournalPostingSourceDocumentRetryFlight::instance().isEnabled();

            if (sourceDocumentRetryFlightEnabled && this.isActualsMissingException(xppEx, _projAdvancedJournalLine))
            {
                // Dual write processing failed to update the integration journal actuals in CE. Update the line status but do not throw so other lines can be posted.
                ttsbegin;
                _projAdvancedJournalLine.reread();
                _projAdvancedJournalLine.selectForUpdate(true);
                _projAdvancedJournalLine.Status = ProjAdvancedJournalLineStatus::ActualsMissing;

                if (enableProjAdvancedJournalErrorTransferFeature)
                {
                    _projAdvancedJournalLine.PostError = NoYes::Yes;
                }

                _projAdvancedJournalLine.doUpdate();
                ttscommit;
            }
            else if (sourceDocumentRetryFlightEnabled && (strScan(xppEx.Message, strFmt("@Proj:JournalLinePostingAccountingEventNotFound", projAdvancedJournal.ProjAdvancedJournalId), 1, strLen(xppEx.Message)) != 0))
            {
                // Accounting event records are missing, attempt to process the line again
                if (currentExecutionCount < MaxSourceDocRetry)
                {
                    currentExecutionCount++;
                    retry;
                }
                else
                {
                    this.handleJournalLinePostingFailure(_projAdvancedJournalLine, xppEx.Message);
                }
            }
            else
            {
                this.handleJournalLinePostingFailure(_projAdvancedJournalLine, xppEx.Message);
            }
        }
        catch
        {
            this.handleJournalLinePostingFailure(_projAdvancedJournalLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isActualsMissingException</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the provided exception matches an error from the Dual Write framework indicating that it was unable to update the project actuals record in CE.
    /// </summary>
    /// <param name = "_xppEx">The exception to check.</param>
    /// <param name = "_projAdvancedJournalLine">The current integration journal line being posted.</param>
    /// <returns>true if the exception message indicates the project actuals record could not be found; otherwise, false.</returns>
    /// <remarks>The logic here is dependent on the error messages used in the <c>DualWriteErrorNotifierForCDSUpsertSync</c> class.</remarks>
    protected boolean isActualsMissingException(Microsoft.Dynamics.Ax.Xpp.ErrorException _xppEx, ProjAdvancedJournalLine _projAdvancedJournalLine)
    {
        // Look for string "Unable to write data to entity msdyn_actuals." as well as the string prior to the left curly brace in "Unable to lookup msdyn_actuals with values {%2}."
        str unableToWriteString = strFmt("@DualWriteLabels:WritingEntityDataFailed", ProjCDSConstants::ActualsDataEntityName);
        str unableToLookupString = strFmt("@DualWriteLabels:LookupError", ProjCDSConstants::ActualsDataEntityName);
        int endOfComparisonStringPosition = strFind(unableToLookupString, '{', 1, strLen(unableToLookupString)) - 1;
        unableToLookupString = subStr(unableToLookupString, 1, endOfComparisonStringPosition);

        if (strScan(_xppEx.Message, unableToWriteString, 1, strLen(_xppEx.Message)) != 0 &&
            endOfComparisonStringPosition > 0 && strScan(_xppEx.Message, unableToLookupString, 1, strLen(_xppEx.Message)) != 0)
        {
            return true;
        }

        // Look for the CDS error code "0x80040265" as well as the exception string "Attribute msdyn_transactiontypecode not found in the record of type msdyn_actual."
        str attributeNotFoundString = strFmt('Attribute msdyn_transactiontypecode not found in the record of type %1.', ProjCDSConstants::TransactionTypeString_Actual);

        if (strScan(_xppEx.Message, ProjCDSConstants::ErrorCode_RequiredAttributeNotFound, 1, strLen(_xppEx.Message)) != 0 &&
            strScan(_xppEx.Message, attributeNotFoundString, 1, strLen(_xppEx.Message)) != 0)
        {
            return true;
        }
        
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleJournalLinePostingFailure</Name>
				<Source><![CDATA[
    private void handleJournalLinePostingFailure(ProjAdvancedJournalLine _projAdvancedJournalLine, str _errorMessage = "@Proj:Exceptions")
    {
        #OCCRetryCount

        System.Exception ex;
        Microsoft.Dynamics.Ax.Xpp.ErrorException xppEx;

        // Log exception and update line status to Error. Suppress exception to allow other lines to be processed.
        logger.logCritical(strFmt("@Proj:JournalLinePostingErrorTelemetry",
            _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal, _errorMessage));
        error(strFmt("@Proj:JournalLinePostingFailed",
            projAdvancedJournal.ProjAdvancedJournalId, _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.Voucher, _errorMessage));

        // Enclosing status update to Error in a try-catch and retry once in case of update conflict.
        try
        {
            ttsbegin;
            // Mark journal status as Error in case of failure.
            _projAdvancedJournalLine.reread();
            _projAdvancedJournalLine.selectForUpdate(true);
            _projAdvancedJournalLine.Status = ProjAdvancedJournalLineStatus::Error;

            if (enableProjAdvancedJournalErrorTransferFeature)
            {
                // Backward compatibility for transfer error line
                _projAdvancedJournalLine.PostError = NoYes::Yes;
            }
            _projAdvancedJournalLine.doUpdate();
            ttscommit;
        }
        catch (Exception::Deadlock) // In case of deadlock, retry for couple of times. Otherwise throw exception up the call stack and let process terminate.
        {
            int currentRetryCount = xSession::currentRetryCount();
            if (currentRetryCount < #RetryNum)
            {
                logger.logWarning(strFmt("@Proj:JournalLineStatusUpdateFailedRetryTelemetry",
                    _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal,
                    ProjAdvancedJournalLineStatus::Processing, ProjAdvancedJournalLineStatus::Error,
                    Exception::Deadlock, currentRetryCount));

                sleep(ProjConstants::DeadLockRetryInterval + (xGlobal::randomPositiveInt32() mod 1000)); // Sleep to prevent disk/network throttle
                retry;
            }
            else
            {
                logger.logCritical(strFmt("@Proj:JournalLineStatusUpdateFailedRetryTelemetry",
                    _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal,
                    ProjAdvancedJournalLineStatus::Processing, ProjAdvancedJournalLineStatus::Error,
                    Exception::Deadlock, currentRetryCount));

                throw error(strFmt("@Proj:JournalLineStatusUpdateFailed",
                    _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.Voucher,
                    ProjAdvancedJournalLineStatus::Processing, ProjAdvancedJournalLineStatus::Error, _projAdvancedJournalLine.Status));
            }
        }
        catch (Exception::TransientSqlConnectionError)  // In case of error with sql connection, db can't be updated to reflect error status. Log data to telemetry.
        {
            int currentRetryCount = xSession::currentRetryCount();
            if (ProjTransientSQLConnectionRetryProvider::retryTransientSqlConnectionError())
            {
                logger.logWarning(strFmt("@Proj:JournalLineStatusUpdateFailedRetryTelemetry",
                    _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal,
                    ProjAdvancedJournalLineStatus::Processing, ProjAdvancedJournalLineStatus::Error,
                    Exception::TransientSqlConnectionError, currentRetryCount));

                retry;
            }
            else
            {
                logger.logCritical(strFmt("@Proj:JournalLineStatusUpdateFailedRetryTelemetry",
                    _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal,
                    ProjAdvancedJournalLineStatus::Processing, ProjAdvancedJournalLineStatus::Error,
                    Exception::TransientSqlConnectionError, currentRetryCount));

                throw error(strFmt("@Proj:JournalLineStatusUpdateFailed",
                    projAdvancedJournal.ProjAdvancedJournalId, _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.Voucher,
                    ProjAdvancedJournalLineStatus::Processing, ProjAdvancedJournalLineStatus::Error, _projAdvancedJournalLine.Status));
            }
        }
        catch (Exception::UpdateConflict) // Fetch latest data and try to update its status to Error.
        {
            int currentRetryCount = xSession::currentRetryCount();
            if (appl.ttsLevel() == 0 && currentRetryCount < #RetryNum)
            {
                logger.logWarning(strFmt("@Proj:JournalLineStatusUpdateFailedRetryTelemetry",
                    _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal,
                    ProjAdvancedJournalLineStatus::Processing, ProjAdvancedJournalLineStatus::Error,
                    Exception::UpdateConflict, currentRetryCount));

                _projAdvancedJournalLine.reread();
                retry;
            }
            else
            {
                logger.logCritical(strFmt("@Proj:JournalLineStatusUpdateFailedRetryTelemetry",
                    _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal,
                    ProjAdvancedJournalLineStatus::Processing, ProjAdvancedJournalLineStatus::Error,
                    Exception::UpdateConflict, currentRetryCount));

                throw error(strFmt("@Proj:JournalLineStatusUpdateFailed",
                    projAdvancedJournal.ProjAdvancedJournalId, _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.Voucher,
                    ProjAdvancedJournalLineStatus::Processing, ProjAdvancedJournalLineStatus::Error, _projAdvancedJournalLine.Status));
            }
        }
        catch (Exception::CLRError)
        {
            ex = CLRInterop::getLastException();
            logger.logError(strFmt("@Proj:JournalLineStatusUpdateFailedTelemetry",
                _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal,
                ProjAdvancedJournalLineStatus::Processing, ProjAdvancedJournalLineStatus::Error, ex.Message));

            throw ex;
        }
        catch(xppEx)
        {
            logger.logError(strFmt("@Proj:JournalLineStatusUpdateFailedTelemetry",
                _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal,
                ProjAdvancedJournalLineStatus::Processing, ProjAdvancedJournalLineStatus::Error, xppEx.Message));

            throw xppEx;
        }
        catch
        {
            logger.logError(strFmt("@Proj:JournalLineStatusUpdateFailedTelemetry",
                _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal,
                ProjAdvancedJournalLineStatus::Processing, ProjAdvancedJournalLineStatus::Error, _projAdvancedJournalLine.Status, 'Unknown'));

            throw error(strFmt("@Proj:JournalLineStatusUpdateFailed",
                projAdvancedJournal.ProjAdvancedJournalId, _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.Voucher,
                ProjAdvancedJournalLineStatus::Processing, ProjAdvancedJournalLineStatus::Error, _projAdvancedJournalLine.Status));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processJournalLineEnhancedHelper</Name>
				<Source><![CDATA[
    private void processJournalLineEnhancedHelper(ProjAdvancedJournalLine _projAdvancedJournalLine)
    {
        #OCCRetryCount

        try
        {
            this.processJournalLine(_projAdvancedJournalLine);
        }
        catch (Exception::Deadlock)  // Catching deadlock exception to handle deadlock errors thrown during SourceDocumentProcessing.
        {
            int currentRetryCount = xSession::currentRetryCount();
            if (currentRetryCount < #RetryNum)
            {
                logger.logWarning(strFmt("@Proj:@Proj:JournalLinePostingErrorWithRetryTelemetry",
                    _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal, Exception::Deadlock, currentRetryCount));

                sleep(ProjConstants::DeadLockRetryInterval + (xGlobal::randomPositiveInt32() mod 1000));
                retry;
            }
            else
            {
                logger.logError(strFmt("@Proj:@Proj:JournalLinePostingErrorWithRetryTelemetry",
                    _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal, Exception::Deadlock, currentRetryCount));

                throw error(strFmt("@Proj:JournalLinePostingFailed",
                    projAdvancedJournal.ProjAdvancedJournalId, any2Str(_projAdvancedJournalLine.RecId), _projAdvancedJournalLine.Voucher, Exception::Deadlock));
            }
        }
        catch (Exception::TransientSqlConnectionError)  // In case of error with sql connection, db can't be updated to reflect error status. Log data to telemetry.
        {
            if (ProjTransientSQLConnectionRetryProvider::retryTransientSqlConnectionError())
            {
                logger.logWarning(strFmt("@Proj:@Proj:JournalLinePostingErrorWithRetryTelemetry",
                    _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal, Exception::TransientSqlConnectionError, xSession::currentRetryCount()));

                retry;
            }
            else
            {
                logger.logError(strFmt("@Proj:@Proj:JournalLinePostingErrorWithRetryTelemetry",
                    _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal, Exception::TransientSqlConnectionError, xSession::currentRetryCount()));

                throw error(strFmt("@Proj:JournalLinePostingFailed",
                    projAdvancedJournal.ProjAdvancedJournalId, any2Str(_projAdvancedJournalLine.RecId), _projAdvancedJournalLine.Voucher, Exception::TransientSqlConnectionError));
            }
        }
        catch (Exception::UpdateConflict) // Fetch latest data and try to update its status to Error.
        {
            int currentRetryCount = xSession::currentRetryCount();
            if (appl.ttsLevel() == 0 && currentRetryCount < #RetryNum)
            {
                logger.logWarning(strFmt("@Proj:@Proj:JournalLinePostingErrorWithRetryTelemetry",
                    _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal, Exception::UpdateConflict, currentRetryCount));

                _projAdvancedJournalLine.reread();
                retry;
            }
            else
            {
                logger.logError(strFmt("@Proj:@Proj:JournalLinePostingErrorWithRetryTelemetry",
                    _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal, Exception::UpdateConflict, currentRetryCount));

                throw error(strFmt("@Proj:JournalLinePostingFailed",
                    projAdvancedJournal.ProjAdvancedJournalId, any2Str(_projAdvancedJournalLine.RecId), _projAdvancedJournalLine.Voucher, Exception::UpdateConflict));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSubLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates the necessary vendor transaction, customer transaction, or bank transaction for a given
    /// posted project advanced journal.
    /// </summary>
    /// <param name="_projAdvancedJournalRecId">
    /// The <c>RecId</c>for a posted project advanced journal.
    /// </param>
    /// <remarks>
    /// The source document framework does not generate <c>VendTrans</c>, <c>CustTrans</c>, or
    /// <c>BankTrans</c> records.This is handled explicitly by walking through the generated
    /// <c>SubledgerJournalAccountEntry</c> record after posting to the general ledger by using source
    /// document framework.
    /// </remarks>
    public static void processSubLedger(ProjAdvancedJournalRecId _projAdvancedJournalRecId)
    {
        ProjAdvancedJournal projAdvancedJournal;
        SubledgerJournalEntry subledgerJournalEntry;
        SubledgerJournalAccountEntry subledgerJournalAccountEntry;
        AccountingEvent accountingEvent;

        NumberSequenceCode voucherSeriesCode = ProjParameters::numRefProjAdvancedJournalVoucher().numberSequenceTable().NumberSequence;

        while select subledgerJournalAccountEntry
            exists join subledgerJournalEntry
                where subledgerJournalAccountEntry.SubledgerJournalEntry == subledgerJournalEntry.RecId
            exists join accountingEvent
                where subledgerJournalEntry.AccountingEvent == accountingEvent.RecId
            exists join projAdvancedJournal
                where accountingEvent.SourceDocumentHeader == projAdvancedJournal.SourceDocumentHeader
                    && projAdvancedJournal.RecId == _projAdvancedJournalRecId
        {
            ProjAdvancedJournalPost::processSubLedgerTransactions(subledgerJournalAccountEntry, voucherSeriesCode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSubLedgerTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the sub ledger transactions for each related accounting distribution.
    /// </summary>
    /// <param name="_subledgerJournalAccountEntry">
    /// SubledgerJournalAccountEntry table instance.
    /// </param>
    /// <param name="_voucherSeriesCode">
    /// The number sequence used for project advanced journal posting.
    /// </param>
    public static void processSubLedgerTransactions(SubledgerJournalAccountEntry _subledgerJournalAccountEntry, NumberSequenceCode _voucherSeriesCode)
    {
        AccountingDistribution accountingDistribution;
        SubledgerJournalAccountEntryDistribution subledgerJournalAccountEntryDistribution;

        if (_subledgerJournalAccountEntry.PostingType == LedgerPostingType::VendBalance
            || _subledgerJournalAccountEntry.PostingType == LedgerPostingType::CustBalance
            || _subledgerJournalAccountEntry.PostingType == LedgerPostingType::Bank)
        {
            // select and process distributions
            while select accountingDistribution
                exists join subledgerJournalAccountEntryDistribution
                    where subledgerJournalAccountEntryDistribution.AccountingDistribution == accountingDistribution.RecId
                        && subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry == _subledgerJournalAccountEntry.RecId
                        && accountingDistribution.MonetaryAmount != MonetaryAmount::WorkInProcess // do not include Work in process distributions
                        && accountingDistribution.MonetaryAmount != MonetaryAmount::Tax
                        && accountingDistribution.MonetaryAmount != MonetaryAmount::TaxNonRecoverable
            {
                ProjAdvancedJournalPost::postSubLedgerTransactions(_subledgerJournalAccountEntry, accountingDistribution, _voucherSeriesCode);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSubLedgerTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate necessary vendor transaction, customer transaction and/or bank transaction for a given SubledgerJournalAccountEntry
    /// </summary>
    /// <param name="_subledgerJournalAccountEntry">
    /// A SubledgerJournalAccountEntry
    /// </param>
    /// <param name="_accountingDistribution">
    /// An accounting distribution record
    /// </param>
    /// <param name="_voucherSeriesCode">
    /// The number sequence used to generate voucher number
    /// </param>
    public static void postSubLedgerTransactions(SubledgerJournalAccountEntry _subledgerJournalAccountEntry, AccountingDistribution _accountingDistribution, NumberSequenceCode _voucherSeriesCode)
    {
        ProjOpsIntegrationLogger logger = ProjOpsIntegrationLogger::createLogger(strFmt('%1::%2', classStr(ProjAdvancedJournalPost), staticMethodStr(ProjAdvancedJournalPost, postSubLedgerTransactions)));

        using (SysInstrumentationActivityContext activityContext = logger.integrationJournalActivity().postSubLedgerTransactionsContext())
        {
            SubledgerJournalAccountEntry subledgerJournalAccountEntry  = _subledgerJournalAccountEntry;
            activityContext.addCustomProperty('ProcessSubLedgerJournalAccountEntryRecId', int642Str(subledgerJournalAccountEntry.RecId));

            AccountingDistribution accountingDistribution = _accountingDistribution;

            if (!subledgerJournalAccountEntry || !accountingDistribution || _voucherSeriesCode == '')
            {
                return;
            }

            if (subledgerJournalAccountEntry.PostingType != LedgerPostingType::VendBalance
                && subledgerJournalAccountEntry.PostingType != LedgerPostingType::CustBalance
                && subledgerJournalAccountEntry.PostingType != LedgerPostingType::Bank)
            {
                return;
            }

            // Find corresponding sourceDocumentLine for given accountingDistribution
            SourceDocumentLine sourceDocumentLine;
            select firstonly RecId, SourceRelationType from sourceDocumentLine
                where sourceDocumentLine.RecId == accountingDistribution.SourceDocumentLine;

            Debug::assert(sourceDocumentLine.RecId != 0);

            // Find journal line from sourceDocumentLine
            ProjAdvancedJournalLine projAdvancedJournalLine;
            if (sourceDocumentLine.SourceRelationType == tableNum(ProjAdvancedJournalLine))
            {
                projAdvancedJournalLine = ProjAdvancedJournalLine::findBySourceDocumentLine(sourceDocumentLine.RecId);
            }
            else if (sourceDocumentLine.SourceRelationType == tableNum(TaxTrans))
            {
                TaxTrans taxTrans = TaxTrans::findBySourceDocumentLine(sourceDocumentLine.RecId);
                Debug::assert(taxTrans.SourceTableId == tableNum(ProjAdvancedJournalLine));
                projAdvancedJournalLine = ProjAdvancedJournalLine::find(taxTrans.SourceRecId);
            }
            else if (sourceDocumentLine.SourceRelationType == tableNum(TaxUncommitted))
            {
                TaxUncommitted taxUncommitted = TaxUncommitted::findBySourceDocumentLine(sourceDocumentLine.RecId);
                Debug::assert(taxUncommitted.SourceTableId == tableNum(ProjAdvancedJournalLine));
                projAdvancedJournalLine = ProjAdvancedJournalLine::find(taxUncommitted.SourceRecId);
            }
            else if (sourceDocumentLine.SourceRelationType == tableNum(TaxDocumentMeasureSourceDocumentLine))
            {
                SourceDocumentLine origSourceDocumentLine = SourceDocumentLine::findTopParentSourceDocumentLine(sourceDocumentLine.RecId);
                projAdvancedJournalLine = ProjAdvancedJournalLine::findBySourceDocumentLine(origSourceDocumentLine.RecId);
            }
            else if (SourceDocumentLine.SourceRelationType == tableNum(TaxWithholdTrans_IN))
            {
                TaxWithholdTrans_IN taxWithholdTrans = TaxWithholdTrans_IN::findBySourceDocumentLine(sourceDocumentLine.RecId);
                projAdvancedJournalLine = ProjAdvancedJournalLine::find(taxWithholdTrans.SourceRecId);
            }

            activityContext.addCustomProperty('ProcessSubLedgerJournalLineAdvancedJournalLineRecId', int642Str(projAdvancedJournalLine.RecId));
            Debug::assert(projAdvancedJournalLine.RecId != 0);
            Debug::assert(projAdvancedJournalLine.TransType == ProjTransType::Cost);

            Voucher voucherNumber = projAdvancedJournalLine.Voucher;
        
            // Getting Amount Currency based on the isSameSign
            boolean isSameSign = ProjAdvancedJournalPost::isSameSign(accountingDistribution.TransactionCurrencyAmount, subledgerJournalAccountEntry.TransactionCurrencyAmount);
            AmountCur amountCur = isSameSign ? accountingDistribution.TransactionCurrencyAmount : -accountingDistribution.TransactionCurrencyAmount;

            TransactionTextLarge transTxt = ProjAdvancedJournalPost::getTransactionTxt(projAdvancedJournalLine);

            // Process in the company currency
            AmountCur transactionAmount = CurrencyExchangeHelper::amountCur2MST(amountCur, projAdvancedJournalLine.CostCurrency, projAdvancedJournalLine.CostExchangeRate);
            CurrencyCode transactionCurrency = Ledger::accountingCurrency();
            ExchRate transactionExchangeRate = 100;

            // Create ledgerVoucher, to be used by custVendVoucher
            // ledgerVoucher is the old interface to post to GL. We do not really post to GL here, i.e. not calling ledgerVoucher.end
            LedgerVoucher ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail, SysModule::Ledger, _voucherSeriesCode);

            LedgerVoucherObject ledgerVoucherObject = LedgerVoucherObject::newVoucher(voucherNumber,
                                                            accountingDistribution.AccountingDate,
                                                            SysModule::Ledger);
            ledgerVoucher.addVoucher(ledgerVoucherObject);

            // Get dimensions from primary account
            List dimensionSources = new List(Types::Class);
            dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getLedgerDimensionSpecifiers(subledgerJournalAccountEntry.LedgerDimension, true));

            LedgerJournalAC postAccount = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(projAdvancedJournalLine.OffsetLedgerDimension);

            // find taxes and include in transaction amount
            AccountingDistribution taxAccountingDistribution;
            select sum(TransactionCurrencyAmount) from taxAccountingDistribution
                where taxAccountingDistribution.ParentDistribution == accountingDistribution.RecId
                    && (taxAccountingDistribution.MonetaryAmount == MonetaryAmount::Tax
                        || taxAccountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable);

            if (taxAccountingDistribution)
            {
                activityContext.addCustomProperty('ProcessSubLedgerJournalLineTaxAccountingDistributionRecId', int642Str(taxAccountingDistribution.RecId));
                if (transactionAmount >= 0)
                {
                    transactionAmount += taxAccountingDistribution.TransactionCurrencyAmount;
                }
                else
                {
                    transactionAmount -= taxAccountingDistribution.TransactionCurrencyAmount;
                }
            }

            activityContext.addCustomProperty('ProcessSubLedgerJournalLinePostingType', enum2Str(subledgerJournalAccountEntry.PostingType));
            // posting vendTrans or custTrans using custVendVoucher
            if (subledgerJournalAccountEntry.PostingType == LedgerPostingType::VendBalance ||
            subledgerJournalAccountEntry.PostingType == LedgerPostingType::CustBalance)
            {
                ProjAdvancedJournalPost::postCustVendTransactions(projAdvancedJournalLine,
                                                            subledgerJournalAccountEntry.PostingType,
                                                            dimensionSources,
                                                            postAccount,
                                                            transactionAmount,
                                                            transactionCurrency,
                                                            accountingDistribution.AccountingDate,
                                                            transactionExchangeRate,
                                                            voucherNumber,
                                                            transTxt,
                                                            ledgerVoucher);
            }
            // posting bankTrans using bankVoucher
            else if (subledgerJournalAccountEntry.PostingType == LedgerPostingType::Bank)
            {
                ProjAdvancedJournalPost::postBankTransactions(dimensionSources,
                                                        postAccount,
                                                        transactionAmount,
                                                        transactionCurrency,
                                                        transTxt,
                                                        accountingDistribution.AccountingDate,
                                                        transactionExchangeRate,
                                                        projAdvancedJournalLine.RecId,
                                                        ledgerVoucher);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates transaction text to use when generating <c>VendTrans</c>, <c>CustTrans</c>, or
    /// <c>BankTrans</c> records from a given transaction.
    /// </summary>
    /// <param name="_projAdvancedJournalLine">
    /// A project advanced journal transaction.
    /// </param>
    /// <returns>
    /// The transaction text.
    /// </returns>
    public static TransactionTextLarge getTransactionTxt(ProjAdvancedJournalLine _projAdvancedJournalLine)
    {
        TransactionTxt transactionTxt = TransactionTxt::construct();
        transactionTxt.setDate(_projAdvancedJournalLine.AccountingDate);
        transactionTxt.setFormLetter("@Proj:ProjectAdvancedJournalLine");
        transactionTxt.setKey1(_projAdvancedJournalLine.Voucher);
        transactionTxt.setKey2(_projAdvancedJournalLine.ProjId);
        transactionTxt.setKey3(_projAdvancedJournalLine.Text);
        transactionTxt.setType(LedgerTransTxt::ProjectPostingLedger);

        TransactionTextLarge transTxt = transactionTxt.txt();

        return transTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSameSign</Name>
				<Source><![CDATA[
    static private boolean isSameSign(real r1, real r2)
    {
        if ((r1<0 && r2<0) || (r1>0 && r2>0))
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCustVendTransactions</Name>
				<Source><![CDATA[
    /// <summary>Post customer and vendor related transactions.</summary>
    /// <param name="_projAdvancedJournalLine"><c>ProjAdvancedJournalLine</c> table instance.</param>
    /// <param name="_ledgerPostingType">Ledger posting type of distribution.</param>
    /// <param name="_dimensionSources">List of dimension sources.</param>
    /// <param name="_custVendAccount">Customer or vendor account id.</param>
    /// <param name="_transactionAmount">Transaction amount of distribution.</param>
    /// <param name="_transactionCurrency">Transaction currency of distribution.</param>
    /// <param name="_transDate">Transaction date of distribution.</param>
    /// <param name="_exchRate">Exchange rate of distribution.</param>
    /// <param name="_voucherNum">Voucher number of distribution.</param>
    /// <param name="_transTxt">Transaction text of distribution.</param>
    /// <param name="_ledgerVoucher">Ledger voucher instance.</param>
    public static void postCustVendTransactions(ProjAdvancedJournalLine _projAdvancedJournalLine,
                                                LedgerPostingType _ledgerPostingType,
                                                List _dimensionSources,
                                                CustVendAC _custVendAccount,
                                                AmountCur _transactionAmount,
                                                CurrencyCode _transactionCurrency,
                                                TrvDateStd _transDate,
                                                ExchRate _exchRate,
                                                Voucher _voucherNum,
                                                TransactionTextLarge _transTxt,
                                                LedgerVoucher _ledgerVoucher)
    {
        SysModule module;
        DimensionDefault defaultDimension;

        if (_ledgerPostingType == LedgerPostingType::VendBalance)
        {
            module = SysModule::Vend;
            // Get dimensions based from vendor account
            _dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(VendTable::find(_custVendAccount).DefaultDimension));
            defaultDimension = LedgerDimensionDefaultingEngine::getDefaultDimension(_dimensionSources);
        }
        else
        {
            module = SysModule::Cust;
        }

        // Initialize custVendVoucher
        CustVendVoucher custVendVoucher = ProjAdvancedJournalPost::initCustVendVoucher(_projAdvancedJournalLine,
                                                                                       module,
                                                                                       _custVendAccount,
                                                                                       _transactionAmount,
                                                                                       _transactionCurrency,
                                                                                       defaultDimension,
                                                                                       _ledgerPostingType,
                                                                                       _transDate,
                                                                                       _exchRate,
                                                                                       _voucherNum,
                                                                                       _transTxt);

        // Post custVendVoucher
        if (custVendVoucher.validate())
        {
            if (module == SysModule::Vend)
            {
                VendTrans vendTrans;
                custVendVoucher.post(_ledgerVoucher, vendTrans);
            }
            else
            {
                CustTrans custTrans;
                custVendVoucher.post(_ledgerVoucher, custTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>CustVendVoucher</c>.
    /// </summary>
    /// <param name = "_projAdvancedJournalLine"><c>ProjAdvancedJournalLine</c> table instance.</param>
    /// <param name = "_module">Module type.</param>
    /// <param name = "_custVendAccount">Customer or vendor account.</param>
    /// <param name = "_transactionAmount">Transaction amount of distribution.</param>
    /// <param name = "_transactionCurrency">Transaction currency of distribution.</param>
    /// <param name = "_defaultDimension">Default dimension.</param>
    /// <param name = "_ledgerPostingType">Ledger posting type of distribution.</param>
    /// <param name = "_transDate">Transaction date of distribution.</param>
    /// <param name = "_exchRate">Exchange rate of distribution.</param>
    /// <param name = "_voucherNum">Voucher number of distribution.</param>
    /// <param name = "_transTxt">Transaction text of distribution.</param>
    /// <returns>
    /// Initialized <c>CustVendVoucher</c> instance.
    /// </returns>
    protected static CustVendVoucher initCustVendVoucher(
        ProjAdvancedJournalLine _projAdvancedJournalLine,
        SysModule _module,
        CustVendAC _custVendAccount,
        AmountCur _transactionAmount,
        CurrencyCode _transactionCurrency,
        DimensionDefault _defaultDimension,
        LedgerPostingType _ledgerPostingType,
        TrvDateStd _transDate,
        ExchRate _exchRate,
        Voucher _voucherNum,
        TransactionTextLarge _transTxt)
    {
        CustVendVoucher custVendVoucher = CustVendVoucher::construct(_module,
                                        _custVendAccount,
                                        _transactionAmount,
                                        _transactionCurrency,
                                        LedgerTransTxt::None,
                                        _defaultDimension,
                                        '',
                                        _ledgerPostingType);

        custVendVoucher.parmTransDate(_transDate);
        custVendVoucher.parmExchRate(_exchRate);
        custVendVoucher.parmTransVoucher(_voucherNum);
        custVendVoucher.parmTransTxt(_transTxt);
        custVendVoucher.parmDocumentDate(_projAdvancedJournalLine.AccountingDate);
        custVendVoucher.parmDocumentNum(_projAdvancedJournalLine.Voucher);
        custVendVoucher.parmCustVendNegInstStatus(CustVendNegInstStatus::Invoiced);
        custVendVoucher.parmApproved(NoYes::Yes);
        custVendVoucher.parmApprover(HcmWorkerLookup::currentWorker());

        if (_module == SysModule::Vend)
        {
            VendTable vendTable = VendTable::find(_custVendAccount);
            if (vendTable)
            {
                custVendVoucher.parmPaymId(vendTable.PaymId);
                custVendVoucher.parmPaymMode(vendTable.PaymMode);
                custVendVoucher.parmPaymTermId(vendTable.PaymTermId);
                custVendVoucher.parmPaymSpec(vendTable.PaymSpec);
                custVendVoucher.parmThirdPartyBankAccountId(vendtable.BankAccount);
                custVendVoucher.parmTransType(LedgerTransType::Vend);
            }
        }

        return custVendVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postBankTransactions</Name>
				<Source><![CDATA[
    /// <summary>Post bank related transactions.</summary>
    /// <param name="_dimensionSources">List of dimension sources.</param>
    /// <param name="_bankAccountId">Bank account id.</param>
    /// <param name="_transactionAmount">Transaction amount of distribution.</param>
    /// <param name="_transactionCurrency">Transaction currency of distribution.</param>
    /// <param name="_transTxt">Transaction text of distribution.</param>
    /// <param name="_transDate">Transaction date of distribution.</param>
    /// <param name="_exchRate">Exchange rate of distribution.</param>
    /// <param name="_projAdvancedJournalLineRecId">Project advanced journal line RecId.</param>
    /// <param name="_ledgerVoucher">Ledger voucher instance.</param>
    public static void postBankTransactions(List _dimensionSources,
        CompanyBankAccountId _bankAccountId,
        AmountCur _transactionAmount,
        CurrencyCode _transactionCurrency,
        TransactionTextLarge _transTxt,
        TrvDateStd _transDate,
        ExchRate _exchRate,
        ProjAdvancedJournalLineRecId _projAdvancedJournalLineRecId,
        LedgerVoucher _ledgerVoucher)
    {
        Debug::assert(_bankAccountId != '');

        // Get dimensions based from bank account
        _dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(BankAccountTable::find(_bankAccountId).DefaultDimension));
        DimensionDefault defaultDimension = LedgerDimensionDefaultingEngine::getDefaultDimension(_dimensionSources);

        // Create new BankAccountTrans
        BankVoucher bankVoucher = BankVoucher::newBankVoucher(
            _transactionAmount,
            _transactionCurrency,
            _bankAccountId,
            '',
            '',
            '',
            _transTxt,
            LedgerPostingType::Bank,
            defaultDimension,
            BankAccountTable::findLedgerDimension(_bankAccountId),
            '',
            _exchRate,
            0,
            UnknownNoYes::Unknown,
            0,
            0,
            '');

        bankVoucher.parmTransDate(_transDate);
        bankVoucher.parmReasonRefRecID(0);
        bankVoucher.parmJournalType(LedgerJournalType::Daily);
        bankVoucher.parmReconcile(NoYes::No);
        bankVoucher.parmSourceTableId(tableNum(ProjAdvancedJournalLine));
        bankVoucher.parmSourceRecId(_projAdvancedJournalLineRecId);

        bankVoucher.post(_ledgerVoucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateResourcePeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the period information for the project resources associated with a project advanced journal on Hours lines.
    /// </summary>
    /// <param name="_projAdvancedJournalRecId">
    /// A record id for a <c>ProjAdvancedJournal</c> record.
    /// </param>
    public static void updateResourcePeriod(ProjAdvancedJournalRecId _projAdvancedJournalRecId)
    {
        ProjAdvancedJournalLine projAdvancedJournalLine;
        ProjCategory projCategory;

        while select ResourceId, ProjTransDate from projAdvancedJournalLine
            where projAdvancedJournalLine.ProjAdvancedJournal == _projAdvancedJournalRecId
                && projAdvancedJournalLine.ResourceId != 0
            exists join ProjCategory
                where projCategory.CategoryId == projAdvancedJournalLine.ProjCategoryId
                    && projCategory.CategoryType == ProjCategoryType::Hour
        {
            ResourcePeriodFacade::updatePeriod(projAdvancedJournalLine.ResourceId, projAdvancedJournalLine.ProjTransDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processIndirectComponentTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes all <c>ProjAdvancedJournalLine</c> records that have indirect cost components.
    /// </summary>
    /// <param name="_projAdvancedJournalRecId">
    /// A record id for a <c>ProjAdvancedJournal</c> record.
    /// </param>
    public static void processIndirectComponentTrans(ProjAdvancedJournalRecId _projAdvancedJournalRecId)
    {
        ProjAdvancedJournalLine projAdvancedJournalLine;

        while select forupdate projAdvancedJournalLine
            where projAdvancedJournalLine.ProjAdvancedJournal == _projAdvancedJournalRecId
                && projAdvancedJournalLine.Voucher != ''
                && (projAdvancedJournalLine.PSAIndirectComponentGroup != '' || projAdvancedJournalLine.ProjDataAreaId != curext())
        {
            if (ProjCategory::find(projAdvancedJournalLine.ProjCategoryId).CategoryType == ProjCategoryType::Hour)
            {
                // Non-intercompany records have the indirect cost component group processed as part of the actuals posting
                // by project extension to source document framework. For the intercompany ones we need to check it here since
                // we don't generate actuals for them during posting, but by vendor invoice posting by the borrowing LE.
                if (projAdvancedJournalLine.ProjDataAreaId != curext())
                {
                    projAdvancedJournalLine.PSAIndirectComponentGroup = PSAComponentGroupAssignment::findAssignment('',
                                                                                    projAdvancedJournalLine.ResourceId,
                                                                                    projAdvancedJournalLine.ProjCategoryId,
                                                                                    projAdvancedJournalLine.ProjTransDate).IndirectComponentGroup;
                    if (projAdvancedJournalLine.PSAIndirectComponentGroup)
                    {
                        projAdvancedJournalLine.update();
                    }
                    
                }

                if (projAdvancedJournalLine.PSAIndirectComponentGroup)
                {
                    NumberSequenceCode voucherSeriesCode = ProjParameters::numRefProjJournalId().numberSequenceTable().NumberSequence;
                    ProjAdvancedJournalPost::postIndirectCostComponentLedgerUpdates(projAdvancedJournalLine, voucherSeriesCode, projAdvancedJournalLine.ProjDataAreaId != curext());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postIndirectCostComponentLedgerUpdates</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates ledger updates for indirect cost components.
    /// </summary>
    /// <param name="_projAdvancedJournalLine">
    ///     A <c>ProjAdvancedJournalLine</c> record.
    /// </param>
    /// <param name="_voucherSeriesCode">
    ///     A <c>NumberSequenceCode</c> value that specifies the voucher series code that is used to post hour
    ///     journals.
    /// </param>
    /// <param name="_isIntercompany">
    ///     A Boolean value that indicates whether the transaction is intercompany; optional.
    /// </param>
    /// <param name="_dueToCompany">
    ///     The record ID of the lending legal entity; optional.
    /// </param>
    public static void postIndirectCostComponentLedgerUpdates(
        ProjAdvancedJournalLine _projAdvancedJournalLine,
        NumberSequenceCode _voucherSeriesCode,
        boolean _isIntercompany = false,
        RefRecId _dueToCompany = CompanyInfo::current())
    {
        ProjOpsIntegrationLogger logger = ProjOpsIntegrationLogger::createLogger(strFmt('%1::%2', classStr(ProjAdvancedJournalPost), staticMethodStr(ProjAdvancedJournalPost, postIndirectCostComponentLedgerUpdates)));

        using (SysInstrumentationActivityContext activityContext = logger.integrationJournalActivity().postAdvancedJournalContext())
        {
            activityContext.addCustomProperty('AdvancedJournalLine', int642Str(_projAdvancedJournalLine.RecId));

            AccountingDate accountingDate;

            // If the accounting date can be updated to next open fiscal period
            if (ProjParameters::canUpdateAccountingDate())
            {
                accountingDate = ProjPost::findNextAvailableAccountingDate(_projAdvancedJournalLine.AccountingDate);
            }
            else
            {
                accountingDate = _projAdvancedJournalLine.AccountingDate;
            }

            LedgerVoucher ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail, SysModule::Project, _voucherSeriesCode);
            LedgerVoucherObject ledgerVoucherObject = LedgerVoucherObject::newVoucher(
                NumberSeq::newGetVoucherFromCode(_voucherSeriesCode, NumberSeqScopeFactory::createDataAreaScope(), true).voucher(),
                accountingDate,
                SysModule::Project,
                LedgerTransType::Project,
                NoYes::No);

            ledgerVoucher.addVoucher(ledgerVoucherObject);

            if (_projAdvancedJournalLine.PSAIndirectComponentGroup && isConfigurationkeyEnabled(configurationKeyNum(Project)))
            {
                logger.logInformation('Begin posting indirect cost component');
                ProjJournalTrans projJournalTrans = ProjAdvancedJournalPost::createDummyProjJournalTrans(_projAdvancedJournalLine);
                ProjPost projPost = ProjPost::psaNewCreateProjIndirectCostAndRevenue(projJournalTrans, ledgerVoucher);

                if (_isIntercompany)
                {
                    PSAProjPostEmplIndirectJournal psaProjPostEmplIndirectJournal = projPost as PSAProjPostEmplIndirectJournal;
                    psaProjPostEmplIndirectJournal.setIntercompany();
                }

                //use this funding source to split indirect costs
                projPost.createFundingAllocationListBasedOnTrx(ProjTransType::Hour);

                projPost.postTrans();

                ledgerVoucher.end();
                logger.logInformation('End posting indirect cost component');
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processNoNeverLedgerTrx</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Processes all Project advanced journal line records that are marked as no or never ledger.
    /// </summary>
    /// <param name="_projAdvancedJournal">A <c>ProjAdvancedJournal</c> record.</param>
    public static void processNoNeverLedgerTrx(ProjAdvancedJournal _projAdvancedJournal)
    {
        ProjAdvancedJournalLine projAdvancedJournalLine;
        boolean accountingWasNotProcessed = _projAdvancedJournal.isAllNeverNoLedger();
        NumberSequenceCode voucherSeriesCode = ProjParameters::numRefProjAdvancedJournalVoucher().numberSequenceTable().NumberSequence;
        
        boolean isProjOperationsIntegrationEnabled = ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled();
        while select crosscompany * from projAdvancedJournalLine
            where projAdvancedJournalLine.ProjAdvancedJournal == _projAdvancedJournal.RecId
               && (projAdvancedJournalLine.TransType == ProjTransType::Hour
                    || (projAdvancedJournalLine.SubcontractLine 
                        && (projAdvancedJournalLine.TransType == ProjTransType::Cost || projAdvancedJournalLine.TransType == ProjTransType::Item)))
        {
            boolean isNeverNoLedger = projAdvancedJournalLine.isNeverNoLedger();
            
            if (isNeverNoLedger)
            {
                if (accountingWasNotProcessed)
                {
                    // delete commitments manually for Never/No Ledger since journalization was never done
                    ProjectCommitmentFacade::deleteProjectCommitments(projAdvancedJournalLine.SourceDocumentLine);
                    ProjFundingLimitTrackingManager::updateUsingSourceDocumentLine(projAdvancedJournalLine.SourceDocumentLine, ProjFundingLimitTrackingAction::Release);
                }

                if (!isProjOperationsIntegrationEnabled
                    || FeatureStateProvider::isFeatureEnabled(ProjEnableAdvancedJournalErrorTransferFeature::instance())
                    || FeatureStateProvider::isFeatureEnabled(ProjAdvancedJournalPostingEnhancementFeature::instance())
                    || accountingWasNotProcessed)
                {
                    ProjAdvancedJournalPost::postNoNeverLedgerTrx(projAdvancedJournalLine, voucherSeriesCode);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postNoNeverLedgerTrx</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates project ledger updates for no or never ledger transactions.
    /// </summary>
    /// <param name="_projAdvancedJournalLine">
    ///     A <c>ProjAdvancedJournalLine</c> record.
    /// </param>
    /// <param name="_voucherSeriesCode">
    ///     A <c>NumberSequenceCode</c> value that specifies the voucher series code that is used to post journals.
    /// </param>
    public static void postNoNeverLedgerTrx(ProjAdvancedJournalLine _projAdvancedJournalLine, NumberSequenceCode _voucherSeriesCode)
    {
        AccountingDate accountingDate;

        // If the accounting date can be updated to next open fiscal period
        if (ProjParameters::canUpdateAccountingDate())
        {
            accountingDate = ProjPost::findNextAvailableAccountingDate(_projAdvancedJournalLine.AccountingDate);
        }
        else
        {
            accountingDate = _projAdvancedJournalLine.AccountingDate;
        }

        LedgerVoucher ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail, SysModule::Project, _voucherSeriesCode);

        LedgerVoucherObject ledgerVoucherObject = LedgerVoucherObject::newVoucher(_projAdvancedJournalLine.Voucher,
                                                        accountingDate,
                                                        SysModule::Project,
                                                        LedgerTransType::Project,
                                                        NoYes::No);

        ledgerVoucher.addVoucher(ledgerVoucherObject);

        ProjPost projPost;

        switch (_projAdvancedJournalLine.TransType)
        {
            case ProjTransType::Hour:
                if (_projAdvancedJournalLine.shouldProcessSubcontractLineAsNeverLedger())
                {
                    projPost = ProjPost::newCreateProjAdvancedJournalNeverLedger(_projAdvancedJournalLine, ledgerVoucher);
                }
                else
                {
                    ProjJournalTrans projJournalTrans = ProjAdvancedJournalPost::createDummyProjJournalTrans(_projAdvancedJournalLine);
                    projPost = ProjPost::newCreateProjTransAndLedger(projJournalTrans, ledgerVoucher);
                    projPost.parmLedgerOrigin(ProjOrigin::ProjAdvancedJournal);
                    projPost.parmTransactionOrigin(ProjOrigin::ProjAdvancedJournal);
                    projPost.parmTransactionOriginOrig(ProjOrigin::ProjAdvancedJournal);
                    if (ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
                    {
                        projPost.parmTransIdRef(_projAdvancedJournalLine.ProjTransId);
                    }
                }
                break;
            case ProjTransType::Cost:
            case ProjTransType::Item:
                if (_projAdvancedJournalLine.shouldProcessSubcontractLineAsNeverLedger())
                {
                    projPost = ProjPost::newCreateProjAdvancedJournalNeverLedger(_projAdvancedJournalLine, ledgerVoucher);
                }
                break;
            default:
                throw error("@SYS50155");
        }

        projPost.postTrans();

        ledgerVoucher.end();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDummyProjJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a <c>ProjJournalTrans</c> record that will be used in indirect cost component posting value.
    /// </summary>
    /// <param name="_projAdvancedJournalLine">
    ///     A <c>ProjAdvancedJournalLine</c> record.
    /// </param>
    /// <returns>
    ///     A <c>ProjJournalTrans</c> record.
    /// </returns>
    public static ProjJournalTrans createDummyProjJournalTrans(ProjAdvancedJournalLine _projAdvancedJournalLine)
    {
        ProjJournalTrans projJournalTrans;

        projJournalTrans.ProjId = _projAdvancedJournalLine.ProjId;
        projJournalTrans.ActivityNumber = _projAdvancedJournalLine.ActivityNumber;
        projJournalTrans.CategoryId = _projAdvancedJournalLine.ProjCategoryId;
        projJournalTrans.CostPrice = _projAdvancedJournalLine.UnitCost;
        projJournalTrans.TransId = ProjParameters::newTransId();
        projJournalTrans.ProjTransDate = _projAdvancedJournalLine.ProjTransDate;
        projJournalTrans.Resource = _projAdvancedJournalLine.ResourceId;
        projJournalTrans.setResourceCategory();
        projJournalTrans.CurrencyId = _projAdvancedJournalLine.PriceCurrency;
        projJournalTrans.DefaultDimension= _projAdvancedJournalLine.DefaultDimension;
        projJournalTrans.Qty = _projAdvancedJournalLine.Quantity;
        projJournalTrans.LinePropertyId = _projAdvancedJournalLine.LinePropertyId;
        projJournalTrans.TransDate = _projAdvancedJournalLine.ProjTransDate;
        projJournalTrans.TaxGroupId = _projAdvancedJournalLine.ProjectSalesTaxGroup;
        projJournalTrans.TaxItemGroupId  = _projAdvancedJournalLine.ProjectSalesTaxItemGroup;
        projJournalTrans.SalesPrice = _projAdvancedJournalLine.UnitPrice;
        projJournalTrans.Worker = _projAdvancedJournalLine.Worker;
        projJournalTrans.Voucher = _projAdvancedJournalLine.Voucher;
        projJournalTrans.Txt = _projAdvancedJournalLine.Text;
        projJournalTrans.PSAIndirectComponentGroup = _projAdvancedJournalLine.PSAIndirectComponentGroup;

        return projJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        Counter progressTotal;

        #OCCRetryCount

        try
        {
            using (SysInstrumentationActivityContext activityContext = logger.integrationJournalActivity().postAdvancedJournalContext())
            {
                if (isEnhancedPostingEnabled)
                {
                    // Reread required to use latest data instead of cached data containing incorrect status.
                    projAdvancedJournal.reread();
                }

                // Check that the advanced ledger entry can be posted.
                if (!this.checkProjAdvancedJournal())
                {
                    throw error(strFmt("@Proj:ProjAdvancedJournalPostingCancelled", projAdvancedJournal.ProjAdvancedJournalId));
                }

                numOfLinesProcessed = 0;
                progressTotal = projAdvancedJournal.numOfLines();

                activityContext.addCustomProperty(ProjOpsIntegrationJournalInstrumentationActivites::ProductReceiptParmStatus, any2Str(VendParameters::find().PostPackingSlip));
                activityContext.addCustomProperty(ProjOpsIntegrationJournalInstrumentationActivites::AdvancedJournalId, int642Str(projAdvancedJournal.RecId));
                activityContext.addCustomProperty(ProjOpsIntegrationJournalInstrumentationActivites::NumOfJournalLines, any2Str(progressTotal));
                if (isEnhancedPostingEnabled)
                {
                    activityContext.addCustomProperty(ProjOpsIntegrationJournalInstrumentationActivites::CurrentStatusOfJournal, any2Str(projAdvancedJournal.Status));
                }

                // if header has lines to post
                if (progressTotal)
                {
                    this.progressInit("@Proj:ProjectAdvancedJournal", progressTotal, #AviFormLetter);
                    progress.setText("@SPS1711");
                    progress.update(true);

                    if (isEnhancedPostingEnabled)
                    {
                        // This method works in a manner similar to accquiring a pessimistic lock to process journal without locking any table or records on database.
                        // When multiple process tries to process same journal,
                        // it is expected that only one of processes should be able to successfully update the status to processing and thus obtain the lock
                        // and all other processes should skip processing.
                        // Exception is thrown if status fails to update. By not handling this exception, journal processing is skipped and error is delegated to parent.
                        projAdvancedJournal.updateJournalStatus(ProjAdvancedJournalStatus::Draft, ProjAdvancedJournalStatus::Processing);
                        try
                        {
                            // Execute the journal posting process.
                            this.processJournalPost();
                        }
                        catch
                        {
                            // Inform the user about failure by logging the error.
                            logger.logCritical(strFmt("@Proj:JournalPostingErrorTelemetry", projAdvancedJournal.RecId, "processJournalPost threw error."));

                            error(strFmt("@Proj:JournalPostingTerminated", projAdvancedJournal.ProjAdvancedJournalId, projAdvancedJournal.DataAreaId));

                            // Enclosing status update to Error in a try-catch and retry once in case of update conflict.
                            try
                            {
                                projAdvancedJournal.reread();
                                if (projAdvancedJournal.Status != ProjAdvancedJournalStatus::Error)
                                {
                                    // Mark journal status as Error in case of failure.
                                    projAdvancedJournal.updateJournalStatus(ProjAdvancedJournalStatus::Processing, ProjAdvancedJournalStatus::Error);
                                }
                            }
                            catch (Exception::TransientSqlConnectionError)  // In case of error with sql connection, db can't be updated to reflect error status. Log data to telemetry.
                            {
                                int currentRetryCount = xSession::currentRetryCount();
                                if (ProjTransientSQLConnectionRetryProvider::retryTransientSqlConnectionError())
                                {
                                    logger.logWarning(strFmt("@Proj:AdvancedJournalStatusUpdateFailedRetryTelemetry", projAdvancedJournal.RecId,
                                        ProjAdvancedJournalStatus::Processing, ProjAdvancedJournalStatus::Error, Exception::TransientSqlConnectionError, currentRetryCount));

                                    retry;
                                }
                                else
                                {
                                    logger.logError(strFmt("@Proj:AdvancedJournalStatusUpdateFailedTelemetry", projAdvancedJournal.RecId, 
                                        ProjAdvancedJournalStatus::Processing, ProjAdvancedJournalStatus::Error, Exception::TransientSqlConnectionError));

                                    throw error(strFmt("@Proj:JournalStatusUpdateFailed", projAdvancedJournal.ProjAdvancedJournalId, projAdvancedJournal.DataAreaId,
                                        ProjAdvancedJournalStatus::Processing, ProjAdvancedJournalStatus::Error, projAdvancedJournal.Status));
                                }
                            }
                            catch (Exception::UpdateConflict) // Fetch latest data and try to update its status to Error.
                            {
                                int currentRetryCount = xSession::currentRetryCount();
                                if (appl.ttsLevel() == 0 && currentRetryCount < #RetryNum)
                                {
                                    logger.logWarning(strFmt("@Proj:AdvancedJournalStatusUpdateFailedRetryTelemetry", projAdvancedJournal.RecId,
                                        ProjAdvancedJournalStatus::Processing, ProjAdvancedJournalStatus::Error, Exception::UpdateConflict, currentRetryCount));

                                    projAdvancedJournal.reread();

                                    retry;
                                }
                                else
                                {
                                    logger.logError(strFmt("@Proj:AdvancedJournalStatusUpdateFailedTelemetry", projAdvancedJournal.RecId,
                                        ProjAdvancedJournalStatus::Processing, ProjAdvancedJournalStatus::Error, Exception::UpdateConflict));

                                    throw error(strFmt("@Proj:JournalStatusUpdateFailed", projAdvancedJournal.ProjAdvancedJournalId, projAdvancedJournal.DataAreaId,
                                        ProjAdvancedJournalStatus::Processing, ProjAdvancedJournalStatus::Error, projAdvancedJournal.Status));
                                }
                            }
                            catch // Catches Deadlock as well as any other exceptions. Deadlock is not handled as we don't want to add any further contention on database and have required mechanism to recover from processing state.
                            {
                                logger.logError(strFmt("@Proj:AdvancedJournalStatusUpdateFailedTelemetry", projAdvancedJournal.RecId,
                                        ProjAdvancedJournalStatus::Processing, ProjAdvancedJournalStatus::Error, 'Generic catch'));

                                throw error(strFmt("@Proj:JournalStatusUpdateFailed", projAdvancedJournal.ProjAdvancedJournalId, projAdvancedJournal.DataAreaId,
                                    ProjAdvancedJournalStatus::Processing, ProjAdvancedJournalStatus::Error, projAdvancedJournal.Status));
                            }

                            // Throw the original exception, despite updating status to Error.
                            throw;
                         }
                    }
                    else
                    {
                        this.processJournalPost();
                    }
                }
                else
                {
                    // No lines available for posting.
                    logger.logError(strFmt("@Proj:ProjAdvancedJournalNoLinesToPostError", projAdvancedJournal.RecId));
                    throw error(strFmt("@Proj:ProjAdvancedJournalNoLinesToPostError", projAdvancedJournal.ProjAdvancedJournalId));
                }

                progress = null;
            }
        }
        catch (Exception::Deadlock)
        {
            int currRetryCount = xSession::currentRetryCount();
            if (currRetryCount >= #RetryNum)
            {
                logger.logError(strFmt("@Proj:ProjAdvancedJournalPostingErrorProjAdvancedJournalPost", projAdvancedJournal.RecId, progressTotal, Exception::Deadlock, currRetryCount));

                throw Exception::Deadlock;
            }
            else
            {
                logger.logWarning(strFmt("@Proj:ProjAdvancedJournalPostingErrorProjAdvancedJournalPost", projAdvancedJournal.RecId, progressTotal, Exception::Deadlock, currRetryCount));

                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            int currRetryCount = xSession::currentRetryCount();
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    logger.logError(strFmt("@Proj:ProjAdvancedJournalPostingErrorProjAdvancedJournalPost", projAdvancedJournal.RecId, progressTotal, Exception::UpdateConflictNotRecovered, currRetryCount));

                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    logger.logWarning(strFmt("@Proj:ProjAdvancedJournalPostingErrorProjAdvancedJournalPost", projAdvancedJournal.RecId, progressTotal, Exception::UpdateConflict, currRetryCount));

                    retry;
                }
            }
            else
            {
                logger.logError(strFmt("@Proj:ProjAdvancedJournalPostingErrorProjAdvancedJournalPost", projAdvancedJournal.RecId, progressTotal, Exception::UpdateConflict, currRetryCount));

                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::TransientSqlConnectionError)
        {
            int currRetryCount = xSession::currentRetryCount();
            if (ProjTransientSQLConnectionRetryProvider::retryTransientSqlConnectionError())
            {
                logger.logWarning(strFmt("@Proj:ProjAdvancedJournalPostingErrorProjAdvancedJournalPost", projAdvancedJournal.RecId, progressTotal, Exception::TransientSqlConnectionError, currRetryCount));

                retry;
            }
            else
            {
                logger.logError(strFmt("@Proj:ProjAdvancedJournalPostingErrorProjAdvancedJournalPost", projAdvancedJournal.RecId, progressTotal, Exception::TransientSqlConnectionError, currRetryCount));

                throw Exception::TransientSqlConnectionError;
            }
        }
        catch (Exception::Error)
        {
            int currRetryCount = xSession::currentRetryCount();
            logger.logError(strFmt("@Proj:ProjAdvancedJournalPostingErrorProjAdvancedJournalPost", projAdvancedJournal.RecId, progressTotal, Exception::Error, currRetryCount));

            throw Exception::Error;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates new instance of the <c>ProjAdvancedJournalPost</c> class and initalizes values.
    /// </summary>
    /// <param name="_projAdvancedJournal">The <c>ProjAdvancedJournal</c> record to post.</param>
    /// <returns>
    ///     A new instance of the <c>ProjAdvancedJournal</c> class.
    /// </returns>
    public static ProjAdvancedJournalPost construct(ProjAdvancedJournal _projAdvancedJournal)
    {
        ProjAdvancedJournalPost projAdvancedJournalPost = new ProjAdvancedJournalPost();
        projAdvancedJournalPost.parmProjAdvancedJournal(_projAdvancedJournal);

        return projAdvancedJournalPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        if (!_args)
        {
            throw error(strFmt("@SPS1272", funcName()));
        }

        ProjAdvancedJournal projAdvancedJournalHeaderLocal = _args.record() as ProjAdvancedJournal;
        ProjAdvancedJournalPost document = ProjAdvancedJournalPost::construct(projAdvancedJournalHeaderLocal);

        document.runOperation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjAdvancedJournal</Name>
				<Source><![CDATA[
    public ProjAdvancedJournal parmProjAdvancedJournal(ProjAdvancedJournal _projAdvancedJournal = projAdvancedJournal)
    {
        projAdvancedJournal = _projAdvancedJournal;
        return projAdvancedJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onAdvancedJournalPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Event gets raised within the posting transaction after posting has completed.
    /// </summary>
    /// <param name="_advancedJournalRecId">A record id for a <c>ProjAdvancedJournal</c> record.</param>
    delegate void onAdvancedJournalPost(ProjAdvancedJournalRecId _advancedJournalRecId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>processProjAdvancedJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes and posts the project advanced journal header in a separate batch task after the lines are journalized.
    /// </summary>
    public void processProjAdvancedJournal()
    {
        this.postToLedger(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postAdvancedJournalInBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes and journalizes advanced journal lines in multiple batch tasks to improve performance. The total number of
    /// lines in the project advanced journal is distributed evenly across multiple tasks. Once all the lines have been
    /// journalized, a dependent batch task is spawned to process and post the <c>ProjAdvancedJournal</c> header. The number
    /// of tasks run parallelly is determined by the configuration in Project parameters.
    /// </summary>
    /// <param name="_projAdvancedJournal">An instance of <c>ProjAdvancedJournal</c>.</param>
    internal void postAdvancedJournalInBatch(ProjAdvancedJournal _projAdvancedJournal)
    {
        using (SysInstrumentationActivityContext activityContext = logger.integrationJournalActivity().createPostAdvancedJournalBatchContext())
        {
            int numOfLines = _projAdvancedJournal.numOfLines();
            if (numOfLines == 0)
            {
                return;
            }

            ProjParameters projParameters = ProjParameters::find();
            int totalNumOfTasks = projParameters.getMaxTasksForAdvancedJournalLineBatch();
            int configuredMaxLinesPerTask;

            if (totalNumOfTasks > 0)
            {
                if (numOfLines > totalNumOfTasks)
                {
                    // Set number of lines per task, if greater than 0.
                    configuredMaxLinesPerTask = numOfLines div totalNumOfTasks;

                    // Add remaining lines to new task.
                    int remainingLines = (numofLines mod totalNumOfTasks);
                    if (remainingLines > 0)
                    {
                        totalNumOfTasks += 1;
                    }
                }
                else
                {
                    // Set total num of tasks to 1, if number of lines is less than total number of tasks.
                    totalNumOfTasks = 1;
                    configuredMaxLinesPerTask = numOfLines;
                }
            }
            else
            {
                return;
            }

            activityContext.addCustomProperty(ProjOpsIntegrationJournalInstrumentationActivites::AdvancedJournalId, int642str(_projAdvancedJournal.RecId));
            activityContext.addCustomProperty(ProjOpsIntegrationJournalInstrumentationActivites::NumOfJournalLines, int2Str(numOfLines));
            activityContext.addCustomProperty(ProjOpsIntegrationJournalInstrumentationActivites::NumOfJournalLineTasks, int2Str(totalNumOfTasks));

            BatchHeader batchHeader = BatchHeader::getCurrentBatchHeader();

            ProjAdvancedJournalPostBatchTask projAdvancedJournalBatchTask = ProjAdvancedJournalPostBatchTask::construct(_projAdvancedJournal.RecId);
            batchHeader.addTask(projAdvancedJournalBatchTask);

            ProjAdvancedJournalLinePostBatchTask projAdvancedJournalLineBatchTask = ProjAdvancedJournalLinePostBatchTask::construct(configuredMaxLinesPerTask, _projAdvancedJournal);

            ProjAdvancedJournalLine projAdvancedJournalLine;
            while select projAdvancedJournalLine
                where projAdvancedJournalLine.ProjAdvancedJournal == _projAdvancedJournal.RecId
            {
                projAdvancedJournalLineBatchTask.addLine(projAdvancedJournalLine);

                if (projAdvancedJournalLineBatchTask.taskIsFull())
                {
                    batchHeader.addTask(projAdvancedJournalLineBatchTask);
                    batchHeader.addDependency(projAdvancedJournalBatchTask, projAdvancedJournalLineBatchTask, BatchDependencyStatus::Finished);

                    totalNumOfTasks -= 1;
                    if (totalNumOfTasks > 0)
                    {
                        projAdvancedJournalLineBatchTask = ProjAdvancedJournalLinePostBatchTask::construct(configuredMaxLinesPerTask, _projAdvancedJournal);
                    }
                }
            }

            if (totalNumOfTasks > 0)
            {
                batchHeader.addTask(projAdvancedJournalLineBatchTask);
                batchHeader.addDependency(projAdvancedJournalBatchTask, projAdvancedJournalLineBatchTask, BatchDependencyStatus::Finished);
            }

            batchHeader.save();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processJournalPost</Name>
				<Source><![CDATA[
    private void processJournalPost()
    {
        // When transfer error line feature or enhanced posting is not enabled and any line has invalid data,
        // throw an exception as all lines present in the journal cannot be processed.
        if (!enableProjAdvancedJournalErrorTransferFeature && !isEnhancedPostingEnabled && this.checkProjAdvancedJournalLines() == false)
        {
            // Errors found in the lines
            throw error(strFmt("@Proj:ProjAdvancedJournalPostingCancelled", projAdvancedJournal.ProjAdvancedJournalId));
        }
        else
        {
            // No errors on any lines
            progress.setText("@SPS1712");
            progress.update(true);

            if (enableProjAdvancedJournalErrorTransferFeature || isEnhancedPostingEnabled || numOfLinesProcessed)
            {
                this.postToLedger();
            }
                        
            info(strFmt("@Proj:ProjAdvancedJournalPostingSucceeded", projAdvancedJournal.ProjAdvancedJournalId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preprocessJournalLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// This code is meant to support lines created via old process.
    /// It updates line with None status to a valid status. 
    /// It also ensure Unrecoverable lines are eligible for transfer to another journal to allow posting of current journal. 
    /// All new lines are created in Draft State and don't require this preprocessing.
    /// This code should be removed in later version as it adds additional overhead on Posting process.
    /// This code is intentionally set to protected visibility to allow CoC creation by PG team to identify corrupted lines and should not be extended without correspondence.
    /// </summary>
    /// <param name = "_projAdvancedJournal">The advanced journal which contains lines with None Status and required preprocessing to update </param>
    /// <param name = "_allowedStatusUpdateToPosted">true; to allow update line status as Posted and false otherwise.</param>
    protected void preprocessJournalLines(ProjAdvancedJournal _projAdvancedJournal, boolean _allowedStatusUpdateToPosted = false)
    {
        if (enableProjAdvancedJournalErrorTransferFeature)
        {
            // Mark unrecoverable journal for transfer
            ProjAdvancedJournal::markJournalLineForTransfer(_projAdvancedJournal, ProjAdvancedJournalLineStatus::Unrecoverable);
        }

        Set noneStateLines = this.getJournalLinesWithMatchingStatus(_projAdvancedJournal, ProjAdvancedJournalLineStatus::None);
        SetIterator recordsIterator = new SetIterator(noneStateLines);
        this.updateMultipleJournalLinesStatusToCorrectState(recordsIterator, _allowedStatusUpdateToPosted);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMultipleJournalLinesStatusToCorrectState</Name>
				<Source><![CDATA[
    private void updateMultipleJournalLinesStatusToCorrectState(SetIterator _projAdvancedJournalLinesIterator, boolean _allowedStatusUpdateToPosted = false)
    {
        while (_projAdvancedJournalLinesIterator.more())
        {
            ProjAdvancedJournalLine projAdvancedJournalLine = ProjAdvancedJournalLine::find(_projAdvancedJournalLinesIterator.value(), true);

            ProjAdvancedJournalPost::updateJournalLineStatusToCorrectState(projAdvancedJournalLine, _allowedStatusUpdateToPosted);

            // Check to see if the line is set to Unrecoverable, so that if it is we can throw a warning
            projAdvancedJournalLine.reread();
            
            if (projAdvancedJournalLine.Status == ProjAdvancedJournalLineStatus::Unrecoverable)
            {
                warning(strFmt("@Proj:JournalLineEntryPresentInGLOrProjTable", projAdvancedJournalLine.RecId, projAdvancedJournalLine.Voucher));
            }

            _projAdvancedJournalLinesIterator.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalLineStatusToCorrectState</Name>
				<Source><![CDATA[
    public static void updateJournalLineStatusToCorrectState(ProjAdvancedJournalLine _projAdvancedJournalLine, boolean _allowedStatusUpdateToPosted = false)
    {
        ProjOpsIntegrationLogger logger = ProjOpsIntegrationLogger::createLogger(strFmt('%1::%2', classStr(ProjAdvancedJournalPost), staticMethodStr(ProjAdvancedJournalPost, updateJournalLineStatusToCorrectState)));

        using (SysInstrumentationActivityContext activityContext = logger.integrationJournalActivity().updateJournalLineStatusToCorrectStateContext())
        {
            activityContext.addCustomProperty('ProjAdvancedJournal', int642Str(_projAdvancedJournalLine.ProjAdvancedJournal));
            activityContext.addCustomProperty('ProjAdvancedJournalLine', int642Str(_projAdvancedJournalLine.RecId));

            int recordCountInGL = ProjAdvancedJournalExistingDataCalc::getRecordCountInGL(_projAdvancedJournalLine);
            int recordCountInProj = ProjAdvancedJournalExistingDataCalc::getRecordCountInProjectTransTable(_projAdvancedJournalLine);

            ttsbegin;
            _projAdvancedJournalLine.selectForUpdate(true);

            boolean isIntercompany = _projAdvancedJournalLine.ProjDataAreaId != _projAdvancedJournalLine.DataAreaId;
            boolean considerIntercompanyBilled = !ProjAdvJournalInterCompanyUpdStatusFlight::instance().isEnabled();
            boolean glPostingNoProjTxnIntercompanyTxn = considerIntercompanyBilled? _projAdvancedJournalLine.IntercompanyBilled: isIntercompany;

            if (recordCountInGL == 0 && recordCountInProj == 0)
            {
                boolean isPosted = considerIntercompanyBilled?
                    isIntercompany && !_projAdvancedJournalLine.IntercompanyBilled:
                    isIntercompany;

                if (isPosted)
                {
                    // InterOrg Sales
                    _projAdvancedJournalLine.Status = ProjAdvancedJournalLineStatus::Posted;
                }
                else
                {
                    // Default draft state
                    _projAdvancedJournalLine.Status = ProjAdvancedJournalLineStatus::Draft;
                }
            }
            else if (_allowedStatusUpdateToPosted
                    // Default case of journal posted to GL and Proj
                    && ((recordCountInGL == 1 && recordCountInProj == 1)
                    // No GL Posting, but postings in Project with 0.00 ExtendedCost or is NeverNoLedger
                    || (recordCountInGL == 0 && recordCountInProj == 1
                        && (abs(_projAdvancedJournalLine.ExtendedCost) < MaximumFloatingPointDelta
                            || _projAdvancedJournalLine.isNeverNoLedger()))
                    // GL Posting, but no Project postings and marked as Intercompany transaction (ResourcingUnitCost)
                    || (recordCountInGL == 1 && recordCountInProj == 0
                         && glPostingNoProjTxnIntercompanyTxn)))
            {
                _projAdvancedJournalLine.Status = ProjAdvancedJournalLineStatus::Posted;
            }
            else
            {
                // Mark line as unrecoverable and set it transfer to another journal
                _projAdvancedJournalLine.Status = ProjAdvancedJournalLineStatus::Unrecoverable;
                _projAdvancedJournalLine.PostError = NoYes::Yes;
            }

            activityContext.addCustomProperty('ProjAdvancedJournalLineUpdatedStatus', enum2Str(_projAdvancedJournalLine.Status));
            _projAdvancedJournalLine.doUpdate();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalLinesWithMatchingStatus</Name>
				<Source><![CDATA[
    private Set getJournalLinesWithMatchingStatus(ProjAdvancedJournal _projAdvancedJournal, ProjAdvancedJournalLineStatus _status)
    {
        Set linesForPreprocessing = new Set(Types::Int64);

        ProjAdvancedJournalLine projAdvancedJournalLine;

        while select RecId from projAdvancedJournalLine
            where projAdvancedJournalLine.ProjAdvancedJournal == _projAdvancedJournal.RecId
                && projAdvancedJournalLine.Status == _status
        {
            linesForPreprocessing.add(projAdvancedJournalLine.RecId);
        }

        return linesForPreprocessing;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processJournalLine</Name>
				<Source><![CDATA[
    private void processJournalLine(ProjAdvancedJournalLine _projAdvancedJournalLine)
    {
        using (SysInstrumentationActivityContext activityContext = logger.integrationJournalActivity().postAdvancedJournalLinesContext())
        {
            activityContext.addCustomProperty(ProjOpsIntegrationJournalInstrumentationActivites::AdvancedJournalId, int642Str(projAdvancedJournal.RecId));
            activityContext.addCustomProperty(ProjOpsIntegrationJournalInstrumentationActivites::AdvancedJournalLineId, int642Str(_projAdvancedJournalLine.RecId));

            if (!this.checkProjAdvancedJournalLineV2(_projAdvancedJournalLine))
            {
                // Log the validation failure to telemetry
                logger.logError(strFmt(ProjOpsIntegrationJournalInstrumentationActivites::LinePostingCheckValidationFailed, _projAdvancedJournalLine.RecId, _projAdvancedJournalLine.ProjAdvancedJournal));
                throw error(strFmt("@Proj:ProjAdvancedJournalLineInvalid", _projAdvancedJournalLine.Voucher));
            }

            SourceDocumentLineImplementationList sourceDocumentLineImplementationList = SourceDocumentLineImplementationList::construct();
            sourceDocumentLineImplementationList.addEnd(_projAdvancedJournalLine);

            ttsbegin;
            // Process tax
            activityContext.addCustomProperty(ProjOpsInstrumentationBaseActitivies::ActionProperty, ProjOpsIntegrationJournalInstrumentationActivites::LinePostingProcessTaxes);
            ProjAdvancedJournalPost::processTaxesForLine(_projAdvancedJournalLine);

            if (isEnhancedPostingEnabled)
            {
                // Reread required as tax details were updated
                _projAdvancedJournalLine.reread();
            }

            // Submit source document with lines to be processed
            logger.logInformation('SubmitToSourceDocumentBegin');
            SourceDocumentProcessorFacade::submitSourceDocumentImplementation(
                projAdvancedJournal, false, SourceDocumentAccountingStatus::Completed, null, curUserId(), true, sourceDocumentLineImplementationList);
            logger.logInformation('SubmitToSourceDocumentComplete');

            if (isEnhancedPostingEnabled)
            {
                _projAdvancedJournalLine.updateJournalLineStatus(ProjAdvancedJournalLineStatus::Processing, ProjAdvancedJournalLineStatus::Posted);
                activityContext.addCustomProperty(ProjOpsInstrumentationBaseActitivies::ActionProperty, ProjOpsIntegrationJournalInstrumentationActivites::LineMarkedPosted);
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>