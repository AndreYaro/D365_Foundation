<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjProjectTransListPageInteraction</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class ProjProjectTransListPageInteraction extends ListPageInteraction
{
    QueryBuildDataSource    queryBuildDataSource;
    QueryBuildRange         criteriaTransType;
    QueryBuildRange         criteriaTransStatus;
    QueryBuildRange         criteriaToBeInvoiced;
    ProjPostTransView       projPostTransView;

    private FormRun formRunObject;
    private FormDataSource projPostedTransViewDataSource;
    private int64 recordsSelectedForAdjustment;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canAccrueRevenue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the transaction held in member variable <c>projPostTransView</c> can accrue revenue.
    /// </summary>
    /// <returns>true if the transaction can accrue revenue, otherwise false.</returns>
    protected boolean canAccrueRevenue()
    {
        ProjTransType projTransType = projPostTransView.projTransType;

        return (projTransType == ProjTransType::None ||
                projTransType == ProjTransType::Revenue ||
                projTransType == ProjTransType::Hour ||
                projTransType == ProjTransType::Cost ||
                projTransType == ProjTransType::Item);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostCosts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the transaction held in member variable <c>projPostTransView</c> can post costs.
    /// </summary>
    /// <returns>true if the transaction can post costs, otherwise false.</returns>
    protected boolean canPostCosts()
    {
        ProjTransType projTransType = projPostTransView.projTransType;

        return (projTransType == ProjTransType::None);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkButtonAccess</Name>
				<Source><![CDATA[
    public container checkButtonAccess()
    {
        // These variables are the return values in the container.
        boolean projSelectForCreditMemoEnabled = false; 
        boolean projAdjustmentEnabled = false;
        boolean projCommittedCostEnabled = false;

        // This is the last activated record, it may not be the currently selected record
        ProjTransIdBase transId = projPostTransView.TransId;
        ProjTransType projTransType = projPostTransView.ProjTransType;

        if (FeatureStateProvider::isFeatureEnabled(ProjPostedTransMultiSelectFeature::instance()))
        {
            //
            // When the flight is enabled this code takes advantage of the MultiSelectionHeler class to define button
            // state using the marked for selection attribute of the data source or singleton record highlighted 
            //

            // Initialize MultiSelectionHelper
            MultiSelectionHelper multiSelectionHelper = MultiSelectionHelper::construct();
            multiSelectionHelper.parmDatasource(projPostedTransViewDataSource);

            boolean multipleRecordsSelected = this.isMultipleRecordsSelected();

            if (!multipleRecordsSelected
                && !MultiSelectionHelper::currentRecordOnlySelected(formRunObject.findFirstFormDataSource(tableNum(ProjPostTransView))))
            {
                // This can occure when multiple records are select/deselected leaving a single record select, but was not the last one accessed.
                // Or multi-select has occurred.
                // Reset the variables to the first selected record values
                ProjPostTransView projPostTransViewLocal = multiSelectionHelper.getFirst();
                transId = projPostTransViewLocal.TransId;
                projTransType = projPostTransViewLocal.ProjTransType;
            }

            // Set commitment flag
            if (!multipleRecordsSelected)
            {
                if (this.isCommittedCostTrackingSupportedByTransactionType(projTransType))
                {
                    projCommittedCostEnabled = true;
                }
            }
            else
            {
                if (this.isCommittedCostTrackingSupportMultipleRecordsSelected())
                {
                    projCommittedCostEnabled = true;
                }
            }

            // Set Credit Memo flag
            if (!multipleRecordsSelected)
            {
                if (this.isCreditMemoSupportedForTransaction(transId, projTransType))
                {
                    projSelectForCreditMemoEnabled = true;
                }
            }
            else
            {
                if (this.isCreditMemoSupportedMultipleRecordsSelected())
                {
                    projSelectForCreditMemoEnabled = true;
                }
            }

            // Set Adjustment flag
            if (!multipleRecordsSelected)
            {
                if (this.isAdjustmentSupportedForTransaction(transId, projTransType))
                {
                    projAdjustmentEnabled = true;
                    recordsSelectedForAdjustment = 1;
                }
            }
            else
            {
                if (this.isAdjustmentSupportedMultipleRecordsSelected())
                {
                    projAdjustmentEnabled = true;
                }
            }

            //Set the local variable on the calling form. Validate the method exists as this is not compiler checked
            if (SysFormRun::hasMethod(formRunObject, identifierStr(parmRecordsSelected)))
            {
                formRunObject.parmRecordsSelected(recordsSelectedForAdjustment);
            }

        }
        else
        {
            //
            // This code has a problem in that it validates button states based on the last record selected/deselected
            //
            switch (projTransType)
            {
                case ProjTransType::Item: //Item

                    ProjItemTrans projItemTransSelected = ProjItemTrans::find(transId);

                    if (!projAdjustmentEnabled)
                    {
                        projAdjustmentEnabled = this.validateProjStatusForAdjustment(ProjTable::find(projPostTransView.ProjId))
                            && ProjTrans::newProjItemTrans(projItemTransSelected).adjustable();
                    }

                    if (!projCommittedCostEnabled)
                    {
                        projCommittedCostEnabled = true;
                    }

                    ProjItemTransSale projItemTransSaleCheck;
                    while select projItemTransSaleCheck
                        where projItemTransSaleCheck.ProjTransId == projItemTransSelected.ProjTransId
                    {
                        if (!projSelectForCreditMemoEnabled)
                        {
                            projSelectForCreditMemoEnabled = projItemTransSaleCheck.canBeMarkedForCreditNote();
                        }
                    }
                    break;
               

                case ProjTransType::Hour: //Hour

                    ProjEmplTrans projEmplTransSelected = ProjEmplTrans::find(transId);

                    if (!projAdjustmentEnabled)
                    {
                        projAdjustmentEnabled = this.validateProjStatusForAdjustment(ProjTable::find(projPostTransView.ProjId))
                            && ProjTrans::newProjEmplTrans(projEmplTransSelected).adjustable();
                    }

                    if (!projCommittedCostEnabled)
                    {
                        projCommittedCostEnabled = true;
                    }

                    ProjEmplTransSale projEmplTransSaleCheck;
                    while select projEmplTransSaleCheck
                        where projEmplTransSaleCheck.TransId == projEmplTransSelected.TransId
                    {
                        if (!projSelectForCreditMemoEnabled)
                        {
                            projSelectForCreditMemoEnabled = projEmplTransSaleCheck.canBeMarkedForCreditNote();
                        }
                    }
                    break;

                case ProjTransType::Cost: //Cost

                    ProjCostTrans projCostTransSelected = ProjCostTrans::find(transId);

                    if (!projAdjustmentEnabled)
                    {
                        projAdjustmentEnabled = this.validateProjStatusForAdjustment(ProjTable::find(projPostTransView.ProjId))
                            && ProjTrans::newProjCostTrans(projCostTransSelected).adjustable();
                    }

                    if (!projCommittedCostEnabled)
                    {
                        projCommittedCostEnabled = true;
                    }

                    ProjCostTransSale projCostTransSaleCheck;
                    while select projCostTransSaleCheck
                        where projCostTransSaleCheck.TransId == projCostTransSelected.TransId
                    {
                        if (!projSelectForCreditMemoEnabled)
                        {
                            projSelectForCreditMemoEnabled = projCostTransSaleCheck.canBeMarkedForCreditNote();
                        }
                    }
                    break;

                case ProjTransType::Revenue: // Revenue

                    ProjRevenueTrans projRevenueTransSelected = ProjRevenueTrans::find(transId);

                    if (!projAdjustmentEnabled)
                    {
                        projAdjustmentEnabled = this.validateProjStatusForAdjustment(ProjTable::find(projPostTransView.ProjId))
                            && ProjTrans::newProjRevenueTrans(projRevenueTransSelected).adjustable();
                    }

                    if (!projCommittedCostEnabled)
                    {
                        projCommittedCostEnabled = true;
                    }

                    ProjRevenueTransSale projRevenueTransSaleCheck;
                    while select projRevenueTransSaleCheck
                        where projRevenueTransSaleCheck.TransId == projRevenueTransSelected.TransId
                    {
                        if (!projSelectForCreditMemoEnabled)
                        {
                            projSelectForCreditMemoEnabled = projRevenueTransSaleCheck.canBeMarkedForCreditNote();
                        }
                    }
                    break;

                case ProjTransType::OnAccount: //OnAccount

                    ProjOnAccTrans projOnAccTransSelected = ProjOnAccTrans::find(transId);

                    projAdjustmentEnabled = false;

                    if (!projCommittedCostEnabled)
                    {
                        projCommittedCostEnabled = true;
                    }

                    ProjOnAccTransSale projOnAccTransSaleCheck;
                    while select projOnAccTransSaleCheck
                        where projOnAccTransSaleCheck.TransId == projOnAccTransSelected.TransId
                    {
                        if (!projSelectForCreditMemoEnabled)
                        {
                            projSelectForCreditMemoEnabled = projOnAccTransSaleCheck.canBeMarkedForCreditNote();
                        }
                    }
                    break;
            }
        }

        return [projSelectForCreditMemoEnabled, projAdjustmentEnabled, projCommittedCostEnabled];
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProjStatusForAdjustment</Name>
				<Source><![CDATA[
    protected boolean validateProjStatusForAdjustment(ProjTable _projTable)
    {
        boolean ret = _projTable.Status != ProjStatus::Completed;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initialized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called after the list page is initialized.
    /// </summary>
    /// <remarks>
    /// Overridden to hide service industries specific field when the services industries configuration key
    /// is off.
    /// </remarks>
    public void initialized()
    {
        super();

        this.listPage().listPageFieldVisible(formControlStr(projProjectTransactionsListPage, TotalSalesAmount), false);
        if (this.listPage().listPageArgs().menuItemName() == menuItemDisplayStr(ProjUnbudgetedCosts))
        {
            this.listPage().actionPaneControlVisible(formControlStr(projProjectTransactionsListPage, NewGroup), false);
            this.listPage().actionPaneControlVisible(formControlStr(projProjectTransactionsListPage, ProcessGroup), false);
            this.listPage().actionPaneControlVisible(formControlStr(projProjectTransactionsListPage, ViewGroup), false);
            this.listPage().actionPaneControlVisible(formControlStr(projProjectTransactionsListPage, BillGroup), false);
        }

        if (ProjOpenProjectTransListPageWhenNoSubcontractLineFlight::instance().isEnabled())
        {
            if (ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
            {
                this.updateProjSubcontractLine();
            }
        }
        else
        {
            this.updateProjSubcontractLine();
        }
        
        if (FeatureStateProvider::isFeatureEnabled(ProjPostedTransMultiSelectFeature::instance()))
        {
            // Set form level variables to reduce code duplication
            formRunObject = this.listPage().formRun();
            projPostedTransViewDataSource = formRunObject.findFirstFormDataSource(tableNum(ProjPostTransView));

            //Set the local variable on the form. Validate the method exists as this is not compiler checked
            if (SysFormRun::hasMethod(formRunObject, identifierStr(parmAdjustmentMessageThreshold)))
            {
                formRunObject.parmAdjustmentMessageThreshold(this.getAdjustmentMessageThresholdCount());
            }
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjSubcontractLine</Name>
				<Source><![CDATA[
    private void updateProjSubcontractLine()
    {
        if (FeatureStateProvider::isFeatureEnabled(ProjEnableSubcontractActualsPostingFeature::instance()))
        {
            Common currentRecord = this.listPage().activeRecord('ProjPostTransView_1');
            FormDataSource frmDs = currentRecord.dataSource();
            FormRun formRun = frmDs.formRun();
            FormStringControl subcontractLineCtrl = formRun.control(formRun.controlId("ProjPostTransView_1_SubcontractLine"));

            if (ProjOpenProjectTransListPageWhenNoSubcontractLineFlight::instance().isEnabled())
            {
                if (subcontractLineCtrl)
                {
                    subcontractLineCtrl.visible(true);
                    subcontractLineCtrl.registerOverrideMethod(methodStr(FormStringControl, jumpRef), methodStr(ProjProjectTransListPageInteraction, jumpRefSubcontractLine), this);
                }
            }
            else
            {
                subcontractLineCtrl.visible(true);
                subcontractLineCtrl.registerOverrideMethod(methodStr(FormStringControl, jumpRef), methodStr(ProjProjectTransListPageInteraction, jumpRefSubcontractLine), this);
            }

            
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>jumpRefSubcontractLine</Name>
				<Source><![CDATA[
    private void jumpRefSubcontractLine(FormControl _formControl)
    {
        ProjectOperationsDWHelper dw = ProjectOperationsDWHelper::construct();
        dw.openProjectSubcontractLineDetailsInCE(_formControl.valueStr(), curExt());
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeQuery</Name>
				<Source><![CDATA[
    public void initializeQuery(Query _query)
    {
        void updateDateControl(IdentifierName _control, TransDate _dateValue)
        {
            FormDateControl dateControl = this.listPage().formRun().design().controlName(_control);

            if (dateControl)
            {
                dateControl.dateValue(_dateValue);
            }
        }

        // Perf Change - Set start date to 30 days prior to today's date and end date to null
        TransDate transStartDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()) - 30;
        TransDate transEndDate   = dateNull();

        queryBuildDataSource = _query.dataSourceTable(tableNum(ProjPostTransView));
        QueryBuildRange transDateRange = SysQuery::findOrCreateRange(queryBuildDataSource, fieldNum(ProjPostTransView, TransDate));
        transDateRange.value(SysQuery::range(transStartDate, transEndDate));

        updateDateControl(formControlStr(projProjectTransactionsListPage, TransStartDate), transStartDate);
        updateDateControl(formControlStr(projProjectTransactionsListPage, TransEndDate), transEndDate);

        this.linkActive(_query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>linkActive</Name>
				<Source><![CDATA[
    protected void linkActive(Query _query)
    {
        QueryBuildRange         projGrantCriteria;
        ProjGrant               projGrant;
        Common                  externalRecord;
        ProjWIPTable            projWIPTable;
        ProjInvoiceTable        projInvoiceTable;
        ProjTable               projTable;

        externalRecord = this.listPage().listPageArgs().externalRecord();

        if (externalRecord)
        {
            if (externalRecord.TableId == tableNum(ProjGrant))
            {
                queryBuildDataSource =  _query.dataSourceTable(tableNum(ProjFundingSource));
                projGrantCriteria  = SysQuery::findOrCreateRange(queryBuildDataSource, fieldNum(ProjFundingSource, ProjGrant));

                projGrant = externalRecord as ProjGrant;
                projGrantCriteria.value(int642str(projGrant.RecId));

                this.listPage().listPageFieldVisible(formControlStr(projProjectTransactionsListPage,projPostTransView_1_ProjId),true);
                this.listPage().listPageFieldVisible(formControlStr(projProjectTransactionsListPage, TotalSalesAmount),false);
                this.listPage().listPageFieldVisible(formControlStr(projProjectTransactionsListPage, TotalCostAmount),false);
            }
            else if (externalRecord.TableId == tableNum(ProjWIPTable))
            {
                projWIPTable = externalRecord as ProjWIPTable;
                queryBuildDataSource = _query.dataSourceTable(tableNum(ProjPostTransView));
                queryBuildDataSource.addRange(fieldNum(ProjPostTransView,ProjId)).value(projWIPTable.ProjId);
            }
            else if (externalRecord.TableId == tableNum(ProjInvoiceTable))
            {
                projInvoiceTable = externalRecord as ProjInvoiceTable;
                queryBuildDataSource = _query.dataSourceTable(tableNum(ProjTable));
                queryBuildDataSource.addRange(fieldNum(ProjTable,ProjInvoiceProjId)).value(queryValue(projInvoiceTable.ProjInvoiceProjId));
            }
            else if (externalRecord.TableId == tableNum(ProjTable))
            {
                projTable = externalRecord as ProjTable;
                queryBuildDataSource = _query.dataSourceTable(tableNum(ProjPostTransView));
                queryBuildDataSource.clearDynalinks();
                SysQuery::findOrCreateRange(queryBuildDataSource, fieldNum(ProjPostTransView,ProjId)).value(SysQuery::value(projTable.ProjId));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVoucherEntry</Name>
				<Source><![CDATA[
    private boolean checkVoucherEntry(ProjPostTransView _projPostTransView)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        ProjTransPosting projTransPosting;

        if (ProjProjectTransListPageVoucherQueryPerformanceFlight::instance().isEnabled())
        {
            select firstonly RecId from projTransPosting
                where projTransPosting.TransId == _projPostTransView.TransId
                exists join generalJournalEntry
                    where generalJournalEntry.SubledgerVoucher == projTransPosting.Voucher
                    && generalJournalEntry.SubledgerVoucherDataAreaId == projTransPosting.DataAreaId
                join RecId from generalJournalAccountEntry
                    where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId;

            return projTransPosting.RecId != 0;
        }
        else
        {
            select firstonly RecId from generalJournalAccountEntry
                exists join generalJournalEntry
                exists join projTransPosting
                where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && generalJournalEntry.SubledgerVoucher == projTransPosting.Voucher
                && generalJournalEntry.SubledgerVoucherDataAreaId == projTransPosting.DataAreaId
                && projTransPosting.TransId == _projPostTransView.TransId;

            return generalJournalAccountEntry.RecId != 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFullyInvoiced</Name>
				<Source><![CDATA[
    private boolean isFullyInvoiced(ProjPostTransView _projPostTransView)
    {
        return _projPostTransView.projInvoiceStatus(_projPostTransView) == ProjInvoiceStatus::FullyInvoiced;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isIncludedInInvoiceProposal</Name>
				<Source><![CDATA[
    private boolean isIncludedInInvoiceProposal(ProjPostTransView _projPostTransView)
    {
        boolean isIncludedInInvoiceProposal = false;

        // Disable ProjAdjustAccounting if invoice proposal line was generated for the transaction
        switch (_projPostTransView.ProjTransType)
        {
            case ProjTransType::Hour:
                ProjProposalEmpl projProposalEmpl;
                select firstonly RecId from projProposalEmpl where projProposalEmpl.TransId == _projPostTransView.TransId;
                if (projProposalEmpl)
                {
                    isIncludedInInvoiceProposal = true;
                }
                break;

            case ProjTransType::Cost:
                ProjProposalCost projProposalCost;
                select firstonly RecId from projProposalCost where projProposalCost.TransId == _projPostTransView.TransId;
                if (projProposalCost)
                {
                    isIncludedInInvoiceProposal = true;
                }
                break;

            case ProjTransType::Item:
                ProjProposalItem projProposalItem;
                select firstonly RecId from projProposalItem where projProposalItem.ProjTransId == _projPostTransView.TransId;
                if (projProposalItem)
                {
                    isIncludedInInvoiceProposal = true;
                }
                break;

            default:
                break;
        }

        return isIncludedInInvoiceProposal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectionChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables or disables the action pane button according to the selection of the project transaction
    /// type.
    /// </summary>
    public void selectionChanged()
    {
        ProjInvoiceTable    projInvoiceTable;

        boolean projReverseTransEnabled;
        boolean projAdjustmentEnabled;
        boolean projCommittedCostEnabled;
        boolean hasBillingRules;

        projPostTransView = this.listPage().activeRecord(queryDataSourceStr(ProjTransQuery_NoFilter, ProjPostTransView_1));

        switch (this.listPage().name())
        {
            case formStr(projProjectTransactionsListPage):
                projInvoiceTable = ProjInvoiceTable::find(ProjTable::find(projPostTransView.ProjId).ProjInvoiceProjId);

                if (!projPostTransView)
                {
                    this.listPage().actionPaneControlEnabled(formControlStr(projProjectTransactionsListPage, ProjAdjustment),false);
                    this.listPage().actionPaneControlEnabled(formControlStr(projProjectTransactionsListPage, PostCosts),false);
                    this.listPage().actionPaneControlEnabled(formControlStr(projProjectTransactionsListPage, AccrueRevenue),false);
                    this.listPage().actionPaneControlEnabled(formControlStr(projProjectTransactionsListPage, Lines),false);
                    this.listPage().actionPaneControlEnabled(formControlStr(projProjectTransactionsListPage, Dimensions),false);
                    this.listPage().actionPaneControlEnabled(formControlStr(projProjectTransactionsListPage, Inventory),false);
                    this.listPage().actionPaneControlEnabled(formControlStr(projProjectTransactionsListPage, SelectForCreditNote),false);
                    this.listPage().actionPaneControlEnabled(formControlStr(projProjectTransactionsListPage, CommittedCost),false);
                    this.listPage().actionPaneControlEnabled(formControlStr(projProjectTransactionsListPage, ProjAdjustAccounting),false);
                }
                else
                {
                    this.listPage().actionPaneControlEnabled(formControlStr(projProjectTransactionsListPage, PostCosts),
                        this.canPostCosts());
                    this.listPage().actionPaneControlEnabled(formControlStr(projProjectTransactionsListPage, AccrueRevenue),
                        this.canAccrueRevenue());
                    this.listPage().actionPaneControlEnabled(formControlStr(projProjectTransactionsListPage, Lines),
                        (projPostTransView.ProjTransType == ProjTransType::Item));
                    this.listPage().actionPaneControlEnabled(formControlStr(projProjectTransactionsListPage, Dimensions),
                        (projPostTransView.ProjTransType == ProjTransType::Item));
                    this.listPage().actionPaneControlEnabled(formControlStr(projProjectTransactionsListPage, Inventory),
                        (projPostTransView.ProjTransType == ProjTransType::Item));

                    boolean isRecordExternallyManaged   = Project::isProjectExternallyManaged(projPostTransView.ProjId);
                    boolean lockFieldsForAdjustments    = ProjCDSLockingOptionTable::get(ProjCDSLockingOption::Adjustments) && isRecordExternallyManaged;

                    [projReverseTransEnabled, projAdjustmentEnabled, projCommittedCostEnabled] = this.checkButtonAccess();
                    this.listPage().actionPaneControlEnabled(formControlStr(projProjectTransactionsListPage, SelectForCreditNote), projReverseTransEnabled);
                    this.listPage().actionPaneControlEnabled(formControlStr(projProjectTransactionsListPage, ProjAdjustment), projAdjustmentEnabled && !lockFieldsForAdjustments);
                    this.listPage().actionPaneControlEnabled(formControlStr(projProjectTransactionsListPage, CommittedCost), projCommittedCostEnabled);
                    
                    boolean adjustAccountingEnabled = this.checkVoucherEntry(projPostTransView)
                                                    && !this.isFullyInvoiced(projPostTransView)
                                                    && !this.isIncludedInInvoiceProposal(projPostTransView);

                    this.listPage().actionPaneControlEnabled(formControlStr(projProjectTransactionsListPage, ProjAdjustAccounting), adjustAccountingEnabled);
                }

                if (FeatureStateProvider::isFeatureEnabled(ProjCreationOfInvoiceProposalBasedOnBillingRuleAvailabilityFeature::instance()))
                {
                    hasBillingRules = ProjInvoiceTable::hasBillingRulesForSelectedProject(projInvoiceTable.ProjInvoiceProjId, projPostTransView.ProjId);
                }
                else
                {
                    hasBillingRules = PSAContractLineItems::hasBillingRules(projInvoiceTable.ProjInvoiceProjId);
                }

                if (hasBillingRules)
                {
                    this.listPage().actionPaneControlVisible(formControlStr(ProjGrantTransListPage, PSAProjProposalSelection),false);
                    this.listPage().actionPaneControlVisible(formControlStr(ProjGrantTransListPage, psaProjProposalSelectionCLIN),true);
                }
                else
                {
                    this.listPage().actionPaneControlVisible(formControlStr(ProjGrantTransListPage, PSAProjProposalSelection),true);
                    this.listPage().actionPaneControlVisible(formControlStr(ProjGrantTransListPage, psaProjProposalSelectionCLIN),false);
                }

                break;

            case formStr(ProjGrantTransListPage):
                if (!projPostTransView)
                {
                    this.listPage().actionPaneControlEnabled(formControlStr(ProjGrantTransListPage, ProjAdjustment), false);
                    this.listPage().actionPaneControlEnabled(formControlStr(ProjGrantTransListPage, PostCosts), false);
                    this.listPage().actionPaneControlEnabled(formControlStr(ProjGrantTransListPage, AccrueRevenue), false);
                    this.listPage().actionPaneControlEnabled(formControlStr(ProjGrantTransListPage, Lines), false);
                    this.listPage().actionPaneControlEnabled(formControlStr(ProjGrantTransListPage, Dimensions), false);
                    this.listPage().actionPaneControlEnabled(formControlStr(ProjGrantTransListPage, Inventory), false);
                    this.listPage().actionPaneControlEnabled(formControlStr(ProjGrantTransListPage, SelectForCreditNote),false);
                    this.listPage().actionPaneControlEnabled(formControlStr(ProjGrantTransListPage, CommittedCost),false);
                }
                else
                {
                    this.listPage().actionPaneControlEnabled(formControlStr(ProjGrantTransListPage, PostCosts),
                        this.canPostCosts());
                    this.listPage().actionPaneControlEnabled(formControlStr(ProjGrantTransListPage, AccrueRevenue),
                        this.canAccrueRevenue());
                    this.listPage().actionPaneControlEnabled(formControlStr(ProjGrantTransListPage, Lines),
                        (projPostTransView.ProjTransType == ProjTransType::Item));
                    this.listPage().actionPaneControlEnabled(formControlStr(ProjGrantTransListPage, Dimensions),
                        (projPostTransView.ProjTransType == ProjTransType::Item));
                    this.listPage().actionPaneControlEnabled(formControlStr(ProjGrantTransListPage, Inventory),
                        (projPostTransView.ProjTransType == ProjTransType::Item));

                    [projReverseTransEnabled, projAdjustmentEnabled, projCommittedCostEnabled] = this.checkButtonAccess();
                    this.listPage().actionPaneControlEnabled(formControlStr(ProjGrantTransListPage, SelectForCreditNote), projReverseTransEnabled);
                    this.listPage().actionPaneControlEnabled(formControlStr(ProjGrantTransListPage, ProjAdjustment), projAdjustmentEnabled);
                    this.listPage().actionPaneControlEnabled(formControlStr(ProjGrantTransListPage, CommittedCost), projCommittedCostEnabled);
                }

                projInvoiceTable  = this.listPage().activeRecord(identifierStr(ProjInvoiceTable));

                if (FeatureStateProvider::isFeatureEnabled(ProjCreationOfInvoiceProposalBasedOnBillingRuleAvailabilityFeature::instance()))
                {
                    hasBillingRules = ProjInvoiceTable::hasBillingRulesForSelectedProject(projInvoiceTable.ProjInvoiceProjId, projPostTransView.ProjId);
                }
                else
                {
                    hasBillingRules = PSAContractLineItems::hasBillingRules(projInvoiceTable.ProjInvoiceProjId);
                }

                if (hasBillingRules)
                {
                    this.listPage().actionPaneControlVisible(formControlStr(ProjGrantTransListPage, PSAProjProposalSelection),false);
                    this.listPage().actionPaneControlVisible(formControlStr(ProjGrantTransListPage, psaProjProposalSelectionCLIN),true);
                }
                else
                {
                    this.listPage().actionPaneControlVisible(formControlStr(ProjGrantTransListPage, PSAProjProposalSelection),true);
                    this.listPage().actionPaneControlVisible(formControlStr(ProjGrantTransListPage, psaProjProposalSelectionCLIN),false);
                }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupArgForMenuCall</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the respective transaction type form by passing the arguments in the respective menu items.
    /// </summary>
    /// <param name="_callerElement">
    /// The form that called this method.
    /// </param>
    /// <param name="_projPostTransView">
    /// A <c>ProjPostTransView</c> value that indicates whether the transaction type must be open.
    /// </param>
    /// <returns>
    /// An object that contains the arguments.
    /// </returns>
    public static Args setupArgForMenuCall(FormRun _callerElement, ProjPostTransView _projPostTransView)
    {
        ProjEmplTrans           projEmplTrans;
        ProjRevenueTrans        projRevenueTrans;
        ProjOnAccTrans          projOnAccTrans;
        ProjCostTrans           projCostTrans;
        ProjItemTrans           projItemTrans;
        ProjTransIdBase         transId;
        Args                    args = new Args();

        args.caller(_callerElement);
        transId = _projPostTransView.TransId;

        switch (_projPostTransView.ProjTransType)
        {
            case ProjTransType::Item:
                projItemTrans = ProjItemTrans::find(transId);
                args.record(projItemTrans);
                break;

            case ProjTransType::Hour:
                projEmplTrans = ProjEmplTrans::find(transId);
                args.record(projEmplTrans);
                break;

            case ProjTransType::Cost:
                projCostTrans = ProjCostTrans::find(transId);
                args.record(projCostTrans);
                break;

            case ProjTransType::Revenue:
                projRevenueTrans = ProjRevenueTrans::find(transId);
                args.record(projRevenueTrans);
                break;

            case ProjTransType::OnAccount:
                projOnAccTrans = ProjOnAccTrans::find(transId);
                args.record(projOnAccTrans);
                break;
        }

        return args;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMultipleRecordsSelected</Name>
				<Source><![CDATA[
    private boolean isMultipleRecordsSelected()
    {
        boolean multipleSelected = false;

        MultiSelectionHelper multiSelectionHelper = MultiSelectionHelper::construct();
        multiSelectionHelper.parmDatasource(projPostedTransViewDataSource);

        // Get the first selected record
        ProjPostTransView projPostTransViewLocal = multiSelectionHelper.getFirst();

        // Attempt to get the next record
        projPostTransViewLocal = multiSelectionHelper.getNext();
        if (projPostTransViewLocal)
        {
            multipleSelected = true;
        }

        return multipleSelected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCommittedCostTrackingSupportedByTransactionType</Name>
				<Source><![CDATA[
    protected boolean isCommittedCostTrackingSupportedByTransactionType(ProjTransType _projTransType)
    {
        boolean committedCostTrackingSupported = false;

        // ProjTransType enumeration is extensible. Need to handle partner/customer extensions
        if (_projTransType == ProjTransType::Cost
            || _projTransType == ProjTransType::Hour
            || _projTransType == ProjTransType::Item
            || _projTransType == ProjTransType::OnAccount
            || _projTransType == ProjTransType::Revenue)
        {
            committedCostTrackingSupported = true;
        }

        return committedCostTrackingSupported;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCommittedCostTrackingSupportMultipleRecordsSelected</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine the state of the commitment button based on the records selected.
    /// </summary>
    /// <remarks>
    /// UX guidance concerning the enable/disable of the button is that it should be disabled if
    /// any record cannot be actioned upon.
    /// </remarks>
    /// <returns>true commitment button should be enable, otherwise false.</returns>
    private boolean isCommittedCostTrackingSupportMultipleRecordsSelected()
    {
        boolean isCommittedCostTrackingSupported = true;

        MultiSelectionHelper multiSelectionHelper = MultiSelectionHelper::construct();
        multiSelectionHelper.parmDatasource(projPostedTransViewDataSource);

        // Get the first selected record
        ProjPostTransView projPostTransViewLocal = multiSelectionHelper.getFirst();
        while (projPostTransViewLocal && isCommittedCostTrackingSupported == true)
        {
            if (!this.isCommittedCostTrackingSupportedByTransactionType(projPostTransViewLocal.ProjTransType))
            {
                isCommittedCostTrackingSupported = false;
            }
            // Attempt to get the next record
           projPostTransViewLocal = multiSelectionHelper.getNext();
        } 

        return isCommittedCostTrackingSupported;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAdjustmentSupportedForTransaction</Name>
				<Source><![CDATA[
    private boolean isAdjustmentSupportedForTransaction(ProjTransIdBase _transId, ProjTransType _projTransType = ProjTransType::None)
    {
        boolean adjustmentAllowed = false;
        ProjTransType projTransTypeLocal = _projTransType;

        if (_transId == '')
        {
            throw error(strFmt("@SYS22828",funcName()));
        }

        if (_projTransType == ProjTransType::None)
        {
            // Lookup the transaction type based on the TransId. It may have been provided by the caller to avoid
            // extra lookup cost when the value is already known.
            ProjPostedTransTable projPostedTransTable;
            select firstonly ProjTransType from projPostedTransTable where projPostedTransTable.TransId == _transId;
            if (projPostedTransTable)
            {
                projTransTypeLocal = projPostedTransTable.ProjTransType;
            }

        }

        switch (projTransTypeLocal)
        {
            case ProjTransType::Item: //Item
                ProjItemTrans projItemTransSelected = ProjItemTrans::find(_transId);
                adjustmentAllowed = ProjTrans::newProjItemTrans(projItemTransSelected).adjustable();
                break;
               
            case ProjTransType::Hour: //Hour
                ProjEmplTrans projEmplTransSelected = ProjEmplTrans::find(_transId);
                adjustmentAllowed = ProjTrans::newProjEmplTrans(projEmplTransSelected).adjustable();
                break;

            case ProjTransType::Cost: //Cost
                ProjCostTrans projCostTransSelected = ProjCostTrans::find(_transId);
                adjustmentAllowed = ProjTrans::newProjCostTrans(projCostTransSelected).adjustable();
                break;

            case ProjTransType::Revenue: // Revenue
                ProjRevenueTrans projRevenueTransSelected = ProjRevenueTrans::find(_transId);
                adjustmentAllowed = ProjTrans::newProjRevenueTrans(projRevenueTransSelected).adjustable();
                break;

            case ProjTransType::OnAccount: //OnAccount
                ProjOnAccTrans projOnAccTransSelected = ProjOnAccTrans::find(_transId);
                adjustmentAllowed = false;
                break;
        }

        return adjustmentAllowed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAdjustmentSupportedMultipleRecordsSelected</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine the state of the adjustment button based on the records selected.
    /// </summary>
    /// <remarks>
    /// UX guidance concerning the enable/disable of the button is that it should be disabled if
    /// any record cannot be actioned upon.
    /// </remarks>
    /// <returns>true adjustment button should be enable, otherwise false.</returns>
    private boolean isAdjustmentSupportedMultipleRecordsSelected()
    {
        boolean isAdjustmentSupported = true;

        recordsSelectedForAdjustment = 0;

        MultiSelectionHelper multiSelectionHelper = MultiSelectionHelper::construct();
        multiSelectionHelper.parmDatasource(projPostedTransViewDataSource);

        // Get the first selected record
        ProjPostTransView projPostTransViewLocal = multiSelectionHelper.getFirst();
        while (projPostTransViewLocal && isAdjustmentSupported == true)
        {
            if (!this.isAdjustmentSupportedForTransaction(projPostTransViewLocal.TransId, projPostTransViewLocal.ProjTransType))
            {
                isAdjustmentSupported = false;
                break;
            }

            recordsSelectedForAdjustment +=1;
            // Attempt to get the next record
             projPostTransViewLocal = multiSelectionHelper.getNext();
       }

        return isAdjustmentSupported;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreditMemoSupportedForTransaction</Name>
				<Source><![CDATA[
    private boolean isCreditMemoSupportedForTransaction(ProjTransIdBase _transId, ProjTransType _projTransType = ProjTransType::None)
    {
        boolean creditMemoAllowed = false;
        ProjTransType projTransTypeLocal = _projTransType;

        if (_transId == '')
        {
            throw error(strFmt("@SYS22828",funcName()));
        }

        if (_projTransType == ProjTransType::None)
        {
            // Lookup the transaction type based on the TransId. I may have been provided by the caller to avoid
            // extra lookup cost when the value is already known.
            ProjPostedTransTable projPostedTransTable;
            select firstonly ProjTransType from projPostedTransTable where projPostedTransTable.TransId == _transId;
            if (projPostedTransTable)
            {
                projTransTypeLocal = projPostedTransTable.ProjTransType;
            }

        }

        switch (projTransTypeLocal)
        {
            case ProjTransType::Item: //Item
                ProjItemTransSale projItemTransSaleCheck;
                while select projItemTransSaleCheck
                    where projItemTransSaleCheck.ProjTransId == _transId
                {
                    creditMemoAllowed = projItemTransSaleCheck.canBeMarkedForCreditNote();
                    if (creditMemoAllowed)
                    {
                        break;
                    }
                }
                break;
               
            case ProjTransType::Hour: //Hour
                ProjEmplTransSale projEmplTransSaleCheck;
                while select projEmplTransSaleCheck
                        where projEmplTransSaleCheck.TransId == _transId
                {
                    creditMemoAllowed = projEmplTransSaleCheck.canBeMarkedForCreditNote();
                    if (creditMemoAllowed)
                    {
                        break;
                    }
                }
                break;

            case ProjTransType::Cost: //Cost
                ProjCostTransSale projCostTransSaleCheck;
                while select projCostTransSaleCheck
                    where projCostTransSaleCheck.TransId == _transId
                {
                    creditMemoAllowed = projCostTransSaleCheck.canBeMarkedForCreditNote();
                    if (creditMemoAllowed)
                    {
                        break;
                    }
                }
                break;

            case ProjTransType::Revenue: // Revenue
                ProjRevenueTransSale projRevenueTransSaleCheck;
                while select projRevenueTransSaleCheck
                    where projRevenueTransSaleCheck.TransId == _transId
                {
                    creditMemoAllowed = projRevenueTransSaleCheck.canBeMarkedForCreditNote();
                    if (creditMemoAllowed)
                    {
                        break;
                    }
                }
                break;

            case ProjTransType::OnAccount: //OnAccount
                ProjOnAccTransSale projOnAccTransSaleCheck;
                while select projOnAccTransSaleCheck
                    where projOnAccTransSaleCheck.TransId == _transId
                {
                    creditMemoAllowed = projOnAccTransSaleCheck.canBeMarkedForCreditNote();
                    if (creditMemoAllowed)
                    {
                        break;
                    }
                }
                break;
        }

        return creditMemoAllowed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreditMemoSupportedMultipleRecordsSelected</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine the state of the credit memo button based on the records selected.
    /// </summary>
    /// <remarks>
    /// UX guidance concerning the enable/disable of the button is that it should be disabled if
    /// any record cannot be actioned upon.
    /// </remarks>
    /// <returns>true credit memo button should be enable, otherwise false.</returns>
    private boolean isCreditMemoSupportedMultipleRecordsSelected()
    {
        boolean isCreditMemoSupported = true;

        MultiSelectionHelper multiSelectionHelper = MultiSelectionHelper::construct();
        multiSelectionHelper.parmDatasource(projPostedTransViewDataSource);

        // Get the first selected record
        ProjPostTransView projPostTransViewLocal = multiSelectionHelper.getFirst();
        while (projPostTransViewLocal && isCreditMemoSupported == true)
        {
            if (!this.isCreditMemoSupportedForTransaction(projPostTransViewLocal.TransId, projPostTransViewLocal.ProjTransType))
            {
                isCreditMemoSupported = false;
                break;
            }
            // Attempt to get the next record
            projPostTransViewLocal = multiSelectionHelper.getNext();
        }

        return isCreditMemoSupported;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdjustmentMessageThresholdCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method returns the threshold for when a user is prompted that the process to open the adjustment form is going
    /// to take a long time to process.
    /// 
    /// Chain of command can be used to modify when the prompt is presented to the user.
    /// </summary>
    /// <returns>
    /// The threshold for when a user is prompted that the process to open the adjustment form is going to take a long time to process.
    /// </returns>
    protected int64 getAdjustmentMessageThresholdCount()
    {
        const int64 thesholdValue = ProjConstants::AdjustmentMessageThresholdCount;

        return thesholdValue;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>