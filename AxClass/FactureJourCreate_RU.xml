<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>FactureJourCreate_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
abstract class FactureJourCreate_RU extends RunBaseBatch implements IFactureHeaderCaller_RU
{
    Map                     mapInvoiceTrans;
    LineNum                 lineNum;
    NumberSeq               numberSeq;
    NumberSeq               externalNumberSeq;

    NoYes                   mustBeUpdated;
    NoYes                   showPreview;
    Printout                printout;
    NoYes                   printMST;
    NoYes                   recalcTaxes;

    FactureExternalId_RU        factureExtId;
    TransDate                   factureDate, factureDateExternal;
    CustVendAC                  custVendAC;
    CurrencyCode                currencyCode;
    CustVendAC                  consignee;
    CustVendAC                  consignor;
    OffSessionId_RU             offsessionId;
    AttorneyId_RU               attorneyId;
    AttorneyIssuedName_RU       attorneyIssuedName;
    AttorneyDate_RU             attorneyDate;
    FactureType_RU              factureType;
    LogisticsPostalAddressRecId deliveryAddress;
    NumberSequenceGroupId       factureExtIdNumSeq;

    FactureJour_RU          factureJour;
    FactureTrans_RU         factureTrans;
    FactureJourHeader_RU    factureJourHeader;

    DialogField             printUpdateRadioButton;
    FactureAction_RU        action;
    boolean                 unpackMap;

    FactureHolder_RU        holder;

    container               printerSettings;

    Map                     vatCodeCache;

    FactureExternalId_RU    correctedFactureExtId;
    FactureDate_RU          correctedFactureDate;
    TransDate               correctedPeriod;

    VATOnPayment_RU                         vatOnPayment;
    Correct_RU                              correct;
    FacturePostProcessVAT                   processVAT;
    PurchBookVATProcessParametersRecId_RU   purchBookVATProcessParametersRecId;
    boolean                                 calledFromEditLines;

    SalesExportDate_RU                  exportDate;
    SalesConfirmationDate_RU            confirmationDate;
    SalesBookFactureProcessingType_RU   processingType;
    SalesPackageDate_RU                 packageDate;
    NoYesId                             exportProcessing;

    InventProfileType_RU                inventProfileType;
    InventOwnerId_RU                    inventOwnerId;
    DeliveryInfoNoPrint_RU              deliveryInfoNoPrint;
    RecId                               exchAdjInvoiceRecId;
    FactureCorrectionType_RU            correctionType;
    FactureAmountAdjustment_RU          amountAdjustment;
    Common                              buffer;
    TaxTransGeneralJournalAccountEntry  tmpTaxTransGeneralJournalAccountEntry;
    GeneralJournalAccountEntry          tmpGeneralJournalAccountEntry;
    LedgerVoucherObject                 ledgerVoucherObject;
    boolean                             mustBeUpdatedOrig;
    boolean                             printCorrProforma;
    boolean                             headerRevision;
    FactureCorrectionReference_RU       correctionReference;

    CustVendAC                          commPartner;
    FactureReportDate_RU                factureReportDate;    
    UseOriginalDocumentAsFacture_RU     useOriginalDocumentAsFacture_RU;

    protected const int currentVersionAll = 1;    
    protected const int currentVersion = 4;
    
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>appendTrans</Name>
				<Source><![CDATA[
    public boolean appendTrans(container _key,
                               Qty       _qty)
    {
        return mapInvoiceTrans.insert(_key, _qty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs check of facture journal creation.
    /// </summary>
    /// <returns>
    /// True if check succeed, otherwise false.
    /// </returns>
    protected boolean check()
    {
        int                 idx;
        container           origFactureCon;
        RecordSortedList    invoiceJourSortedList;
        CustVendInvoiceJour custVendInvoiceJour;
        CustVendTrans       custVendTrans;
        FactureJour_RU      factureJourOrig;
        boolean             ret = true;
        UnknownNoYes        useOriginalDocumentAsFactureLoc;

        if (correctedFactureExtId && correctedFactureDate)
        {
            if (correctionType != FactureCorrectionType_RU::Revision && ! exportProcessing)
            {
                ret = FactureJour_RU::checkCorrectionOrder(correctedFactureExtId,
                                                           correctedFactureDate,
                                                           this.module(),
                                                           custVendAC);
            }

            while select correctionReference
            {
                factureJourOrig = FactureJour_RU::findRecId(correctionReference.RefCorrectedFacture);
                if (factureJourOrig)
                {
                    origFactureCon += [factureJourOrig];
                }

                if (useOriginalDocumentAsFactureLoc)
                {
                    if (useOriginalDocumentAsFactureLoc != correctionReference.OriginalDocumentAsFacture)
                    {
                        ret = checkFailed("@SalesPurchBook:CombinedFactureRefDiffOrigDocument");
                    }
                }
                else if (correctionReference.OriginalDocumentAsFacture)
                {
                    useOriginalDocumentAsFactureLoc = correctionReference.OriginalDocumentAsFacture;
                }
            }

            if (origFactureCon == conNull())
            {
                factureJourOrig = FactureJour_RU::findCorrectedFacture(this.module(),
                                                                       custVendAC,
                                                                       correctedFactureExtId,
                                                                       correctedFactureDate);
                if (factureJourOrig)
                {
                    origFactureCon += [factureJourOrig];
                }
            }

            for (idx = 1; idx <= conlen(origFactureCon); idx++)
            {
                factureJourOrig = conpeek(origFactureCon, idx);

                if (factureJourOrig.CurrencyCode != currencyCode)
                {
                    ret = checkFailed("@SYS4081842");
                }

                if (! exportProcessing                                  &&
                    (factureJourOrig.FactureDate          > factureDate ||
                     factureJourOrig.FactureDate_External > factureDateExternal))
                {
                    ret = checkFailed("@SYS4081847");
                }

                if (correctionType == FactureCorrectionType_RU::Revision)
                {
                    if (factureJourOrig.isExportFacture())
                    {
                        ret = checkFailed("@SYS4081848");
                    }

                    if (factureJourOrig.vatOnPayment                           &&
                        factureJourOrig.FactureType == FactureType_RU::Invoice &&
                        ! headerRevision)
                    {
                        custVendTrans = new DictTable(factureJourOrig.Module == FactureModule_RU::Cust ?
                                                      tableNum(CustTrans)                              :
                                                      tableNum(VendTrans)).makeRecord();

                        custVendInvoiceJour = new DictTable(factureJourOrig.Module == FactureModule_RU::Cust ?
                                                            tableNum(CustInvoiceJour)                        :
                                                            tableNum(VendInvoiceJour)).makeRecord();

                        invoiceJourSortedList = factureJourOrig.invoiceJourSortedList();
                        while (invoiceJourSortedList.next(custVendInvoiceJour))
                        {
                            custVendTrans = custVendInvoiceJour.CustVendInvoiceJour::custVendTrans(custVendTrans);
                            if (custVendTrans.SettleAmountMST)
                            {
                                ret = checkFailed("@GLS107073");
                                break;
                            }
                        }
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMap</Name>
				<Source><![CDATA[
    // overloaded in FactureJourCreateAmountDiff_Ru
    protected boolean checkMap()
    {
        boolean                 ret = mapInvoiceTrans.empty();
        RefTableId              tableId;
        RefRecId                recId;
        MapEnumerator           mapInvoiceTransEnumerator = mapInvoiceTrans.getEnumerator();
        CustVendInvoiceJour     custVendInvoiceJour;
        CustVendInvoiceTrans    custVendInvoiceTrans;
        MarkupTrans             markupTrans;
        CustVendTransOpen       custVendTransOpen;
        CustVendTrans           custVendTrans;
        CustVendTransStatic     custVendTransStatic;
        ModuleCustVend          moduleCustVend;
        Set                     custVendTransRecIdSet;
        container               invoiceIdCon;
        const str sep = ', ';

        if (! ret                                                                                &&
            calledFromEditLines                                                                  &&
            (this.module() == FactureModule_RU::Cust || this.module() == FactureModule_RU::Vend) &&
            LedgerParameters::find().AdvanceAdjustment_W)
        {
            moduleCustVend = this.module() == FactureModule_RU::Cust ? ModuleCustVend::Cust : ModuleCustVend::Vend;

            custVendTransStatic = CustVendTransStatic::newModuleCustVend(moduleCustVend);
            custVendTrans     = custVendTransStatic.custVendTrans();
            custVendTransOpen = custVendTransStatic.custVendTransOpen();

            while (mapInvoiceTransEnumerator.moveNext())
            {
                custVendInvoiceJour.clear();
                custVendTransRecIdSet = new Set(typeName2Type(extendedTypeStr(RecId)));

                [tableId, recId] = mapInvoiceTransEnumerator.currentKey();

                switch (tableId)
                {
                    case tableNum(CustInvoiceTrans) :
                    case tableNum(VendInvoiceTrans) :
                        custVendInvoiceTrans = this.findCustVendInvoiceTransByRecId(recId);
                        break;

                    case tableNum(MarkupTrans) :
                        markupTrans = MarkupTrans::findRecId_W(recId);
                        if (markupTrans.TransTableId == tableNum(CustInvoiceTrans) || markupTrans.TransTableId == tableNum(VendInvoiceTrans))
                        {
                            custVendInvoiceTrans = this.findCustVendInvoiceTransByRecId(markupTrans.TransRecId);
                        }
                        else
                        {
                            custVendInvoiceJour = this.findCustVendInvoiceJourByRecId(markupTrans.TransRecId);
                        }
                        break;
                }

                if (! custVendInvoiceJour)
                {
                    custVendInvoiceJour = this.findInvoiceJourByTrans(custVendInvoiceTrans);
                }

                select firstonly custVendTrans
                    where custVendTrans.Invoice    == custVendInvoiceJour.InvoiceId      &&
                          custVendTrans.TransDate  == custVendInvoiceJour.InvoiceDate    &&
                          custVendTrans.AccountNum == custVendInvoiceJour.InvoiceAccount &&
                          custVendTrans.Voucher    == custVendInvoiceJour.LedgerVoucher
                exists join custVendTransOpen
                    where custVendTransOpen.RefRecId == custVendTrans.RecId;

                if (custVendTrans)
                {
                    if (! custVendTransRecIdSet.in(custVendTrans.RecId) &&
                        CustVendExchAdjustment_W::existsPrepayments(moduleCustVend, custVendTrans.AccountNum, custVendTrans.TransDate))
                    {
                        custVendTransRecIdSet.add(custVendTrans.RecId);
                        invoiceIdCon += custVendTrans.Invoice;
                    }
                }
            }
            if (! custVendTransRecIdSet.empty())
            {
                ret = Box::okCancel(strFmt("@GLS112744", con2Str(invoiceIdCon, sep)), DialogButton::Cancel) == DialogButton::Cancel;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkParameters</Name>
				<Source><![CDATA[
    protected boolean checkParameters()
    {
        boolean   ret = true;

        if (! factureDate)
        {
            ret = checkFailed("@GLS104567");
        }
        if (! custVendAC)
        {
            ret = checkFailed("@SYS24085");
        }
        if (! currencyCode)
        {
            ret = checkFailed("@GLS104568");
        }

        ret = ret && FactureJour_RU::checkCorrectionParameters(correctedFactureExtId,
                                                               correctedFactureDate,
                                                               correct,
                                                               correctionType);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels number sequence generation.
    /// </summary>
    protected void cleanup()
    {
        if (numberSeq)
        {
            numberSeq.abort();
        }

        if (externalNumberSeq)
        {
            externalNumberSeq.abort();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearTrans</Name>
				<Source><![CDATA[
    public void clearTrans()
    {
        mapInvoiceTrans = new Map(Types::Container, Types::Real);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournal</Name>
				<Source><![CDATA[
    private void createJournal()
    {
        TableId               tableId, tableIdLast;
        RecId                 recId;
        RefRecId              refCommReportTrans;
        FactureLineType_RU    lineType, lineTypeLast;
        FactureTransCreate_RU factureTransCreator;
        FactureDelete_RU      factureDelete;
        MapIterator           it;
        boolean               first = true;

        GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceRU00019, funcName());

        if (correctionType == FactureCorrectionType_RU::Correction || correctionType == FactureCorrectionType_RU::Revision)
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceRU00024, funcName());
        }

        if (! headerRevision && this.checkMap())
        {
            return;
        }

        ttsbegin;

        it = new MapIterator(mapInvoiceTrans);

        if (! this.checkParameters())
        {
            this.cleanup();
            throw error("@SYS18447");
        }

        holder = new FactureHolder_RU(showPreview || ! mustBeUpdated);

        this.initJournal();

        if (! this.check())
        {
            this.cleanup();
            throw error("@SYS18447");
        }

        while (it.more())
        {
            progress.incCount();

            [ tableId, recId, refCommReportTrans, lineType ]    = it.key();
            if (first || tableId != tableIdLast || lineType != lineTypeLast)
            {
                factureTransCreator = FactureTransCreate_RU::construct(this, tableId, recId, lineType, it.value(), recalcTaxes);
                first = false;
            }
            else
            {
                factureTransCreator.setParameters(recId, it.value(), recalcTaxes);
            }
            factureTransCreator.parmRefCommReportTrans(refCommReportTrans);
            factureTransCreator.createTrans();
            it.next();
            tableIdLast = tableId;
            lineTypeLast = lineType;
        }

        if (mustBeUpdated && correctionType == FactureCorrectionType_RU::Revision)
        {
            this.updateRevisedFacture();
        }

        this.initTotals();
        this.insertJournal();
        this.populateCorrectionInfo();

        if (mustBeUpdatedOrig)
        {
            this.updateFullyFacturedInvoices();
        }

        ttscommit;

        this.printJournal();

        if (printCorrProforma)
        {
            factureDelete = FactureDelete_RU::construct(factureJour);
            factureDelete.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    public Object dialog()
    {
        DialogRunbase ret;

        ret = super();
        ret.caption("@GLS104543");

        printUpdateRadioButton = ret.addField(enumStr(FactureAction_RU));
        printUpdateRadioButton.value(action);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustVendInvoiceJourByRecId</Name>
				<Source><![CDATA[
    protected CustVendInvoiceJour findCustVendInvoiceJourByRecId(RefRecId _recId)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustVendInvoiceTransByRecId</Name>
				<Source><![CDATA[
    protected CustVendInvoiceTrans findCustVendInvoiceTransByRecId(RefRecId _recId)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>findInvoiceJourByTrans</Name>
				<Source><![CDATA[
    abstract protected Common findInvoiceJourByTrans(Common _trans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>findInvoiceTransByFacture</Name>
				<Source><![CDATA[
    abstract protected Common findInvoiceTransByFacture()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFactureJour</Name>
				<Source><![CDATA[
    public FactureJour_RU getFactureJour()
    {
        if (! holder)
        {
            holder = new FactureHolder_RU(showPreview || ! mustBeUpdated);
        }
        return holder.factureJour();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFactureTrans</Name>
				<Source><![CDATA[
    public FactureTrans_RU getFactureTrans()
    {
        if (! holder)
        {
            holder = new FactureHolder_RU(showPreview || ! mustBeUpdated);
        }
        return holder.factureTrans();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        boolean ret;

        ret    = super();
        if (ret)
        {
            action = printUpdateRadioButton.value();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initJournal</Name>
				<Source><![CDATA[
    protected void initJournal()
    {
        FactureJour_RU revisedFacture;

        factureJour = holder.factureJour();
        factureJour.initValue();

        factureJour.PrintInMST                          = printMST;
        factureJour.FactureExternalId                   = factureExtId;
        factureJour.FactureDate                         = factureDate;
        factureJour.CustVendInvoiceAccount              = custVendAC;
        factureJour.CurrencyCode                        = currencyCode;
        factureJour.FactureType                         = factureType;
        factureJour.Consignee                           = consignee;
        factureJour.Consignor                           = consignor;
        factureJour.OffSessionId                        = offsessionId;
        factureJour.Module                              = this.module();
        factureJour.LanguageId                          = this.parmLanguageId();
        factureJour.DeliveryPostalAddress               = deliveryAddress;
        factureJour.FactureDate_External                = factureDateExternal;
        factureJour.CorrectedFactureExternalId          = correctedFactureExtId;
        factureJour.CorrectedFactureDate                = correctedFactureDate;
        factureJour.CorrectedPeriod                     = correctedPeriod;
        factureJour.vatOnPayment                        = vatOnPayment;
        factureJour.InventProfileType                   = inventProfileType;
        factureJour.InventOwnerId                       = inventOwnerId;
        factureJour.DeliveryInfoNoPrint                 = deliveryInfoNoPrint;
        factureJour.AmountAdjustment                    = amountAdjustment;
        factureJour.ExchAdjInvoiceRecId                 = exchAdjInvoiceRecId;
        factureJour.ProcessVAT                          = processVAT;
        factureJour.PurchBookVATProcessParametersRecId  = purchBookVATProcessParametersRecId;
        factureJour.CorrectionType                      = correctionType;
        factureJour.HeaderRevision                      = headerRevision;
        factureJour.FactureReportDate                   = factureReportDate;
        factureJour.UseOriginalDocumentAsFacture        = useOriginalDocumentAsFacture_RU;

        if (inventProfileType == InventProfileType_RU::CommissionAgent ||
            inventProfileType == InventProfileType_RU::CommissionPrincipalAgent)
        {
            factureJour.CommPartner = commPartner;
        }
  
 
        if (correctionType == FactureCorrectionType_RU::Revision)
        {
            revisedFacture = FactureJour_RU::findCorrectedFacture(factureJour.Module,
                                                                  custVendAC,
                                                                  correctedFactureExtId,
                                                                  correctedFactureDate);

            factureJour.RefRevisedFacture  = revisedFacture.RecId;
            if (revisedFacture.CorrectionType == FactureCorrectionType_RU::Unknown &&
              ! revisedFacture.CorrectedFactureExternalId)
            {
                factureJour.RefOriginalFacture = revisedFacture.RecId;
            }
            else
            {
                factureJour.RefOriginalFacture = revisedFacture.RefOriginalFacture;
            }
            factureJour.RefLastCorrFacture = revisedFacture.RefLastCorrFacture;
            factureJour.JointCorrection    = revisedFacture.JointCorrection;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParameters</Name>
				<Source><![CDATA[
    public void initParameters(NoYes                            _mustBeUpdated,
                               NoYes                            _showPreview,
                               Printout                         _printout,
                               NoYes                            _printMST,
                               FactureExternalId_RU             _factureExtId,
                               TransDate                        _factureDate,
                               CustVendAC                       _custVendAC,
                               CurrencyCode                     _currencyCode,
                               FactureType_RU                   _factureType,
                               CustVendAC                       _consignee             = '',
                               CustVendAC                       _consignor             = '',
                               OffSessionId_RU                  _offsessionId          = '',
                               AttorneyId_RU                    _attorneyId            = '',
                               AttorneyIssuedName_RU            _attorneyIssuedName    = '',
                               AttorneyDate_RU                  _attorneyDate          = dateNull(),
                               LogisticsPostalAddressRecId      _deliveryAddress       = 0,
                               TransDate                        _factureDateExternal   = _factureDate,
                               NumberSequenceGroupId            _factureExtIdNumSeq    = '',
                               FactureExternalId_RU             _correctedFactureExtId = '',
                               FactureDate_RU                   _correctedFactureDate  = dateNull(),
                               TransDate                        _correctedPeriod       = dateNull(),
                               FactureCorrectionType_RU         _correctionType        = FactureCorrectionType_RU::Unknown,
                               FactureCorrectionReference_RU    _correctionReference   = null,
                               FactureReportDate_RU             _factureReportDate     = dateNull())
    {
        mustBeUpdated         = _mustBeUpdated;
        showPreview           = _showPreview;
        printout              = _printout;
        printMST              = _printMST;
        factureExtId          = _factureExtId;
        factureDate           = _factureDate;
        custVendAC            = _custVendAC;
        currencyCode          = _currencyCode;
        factureType           = _factureType;
        consignee             = _consignee;
        consignor             = _consignor;
        offsessionId          = _offsessionId;
        attorneyId            = _attorneyId;
        attorneyIssuedName    = _attorneyIssuedName;
        attorneyDate          = _attorneyDate;
        deliveryAddress       = _deliveryAddress;
        factureDateExternal   = min(_factureDateExternal, _factureDate);
        factureExtIdNumSeq    = _factureExtIdNumSeq;
        correctedFactureExtId = _correctedFactureExtId;
        correctedFactureDate  = _correctedFactureDate;
        correctedPeriod       = _correctedPeriod;
        correctionType        = _correctionType;
        factureReportDate     = _factureReportDate ?
                                _factureReportDate :
                                factureDate;
        
        lineNum             = 0;
        printCorrProforma   = ! showPreview         &&
                              ! mustBeUpdated       &&
                              correctedFactureExtId &&
                              printout == Printout::Current;

        mustBeUpdatedOrig   = mustBeUpdated;
        if (printCorrProforma)
        {
            mustBeUpdated   = true;
        }

        if (_correctionReference)
        {
            correctionReference.setTmpData(_correctionReference);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTotals</Name>
				<Source><![CDATA[
    protected void initTotals()
    {
        factureTrans = holder.factureTrans();

        select sum(LineAmount),
               sum(TaxAmount)
            from  factureTrans
            where factureTrans.FactureId == factureJour.FactureId &&
                  factureTrans.Module    == factureJour.Module;

        factureJour.FactureAmount = factureTrans.LineAmount;
        factureJour.FactureTax    = factureTrans.TaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertJournal</Name>
				<Source><![CDATA[
    #VATTransitionPeriod_RU
    protected void insertJournal(boolean  _checkBooks = true)
    {
        FactureTrans_RU factureTransOld, factureTransNew;

        select count(RecId)
            from  factureTrans
            where factureTrans.FactureId == factureJour.FactureId   &&
                  factureTrans.Module    == factureJour.Module;

        if (headerRevision || factureTrans.RecId)
        {
            if (factureJour.FactureDate >= #TransitionStartDate             &&
            (factureJour.Module == FactureModule_RU::Vend               ||
             factureJour.Module == FactureModule_RU::TaxCorrectionPurch ||
             factureJour.Module == FactureModule_RU::TaxCorrectionPurch_Cust))
            {
                if (factureTrans.isTmp())
                {
                    factureTransOld.setTmp();
                    factureTransNew.setTmp();
                    factureTransOld.setTmpData(factureTrans);
                    factureTransNew.setTmpData(factureTrans);
                }

                select firstonly factureTransOld
                    where factureTransOld.FactureId   == factureJour.FactureId &&
                          factureTransOld.Module      == factureJour.Module    &&
                          factureTransOld.InvoiceDate <  #TransitionStartDate  &&
                          factureTransOld.InvoiceDate;

                select firstonly factureTransNew
                    where factureTransNew.FactureId   == factureJour.FactureId &&
                          factureTransNew.Module      == factureJour.Module    &&
                          factureTransNew.InvoiceDate >= #TransitionStartDate;

                if (factureTransOld && factureTransNew)
                {
                    throw error("@GLS110995");
                }
            }

            [factureJour.DocumentNum, factureJour.DocumentDate] = factureJour.document();

            factureJour.insert(_checkBooks);
        }
        else
        {
            throw error(headerRevision ? "@SYS4081847" : "@SYS25907");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProforma</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if facture journal is proforma.
    /// </summary>
    /// <returns>
    ///     true if facture journal is proforma; otherwise, false.
    /// </returns>
    public boolean isProforma()
    {
        return !mustBeUpdated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineNum</Name>
				<Source><![CDATA[
    public LineNum lineNum(LineNum _lineNum = lineNum)
    {
        ;
        lineNum = _lineNum;
        return lineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupTrans</Name>
				<Source><![CDATA[
    public Qty lookupTrans(container _key)
    {
        if (mapInvoiceTrans.exists(_key))
            return mapInvoiceTrans.lookup(_key);

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>module</Name>
				<Source><![CDATA[
    abstract public FactureModule_RU module()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        super();

        mapInvoiceTrans = new Map(Types::Container, Types::Real);
        vatCodeCache    = new Map(Types::Container, Types::String);
        unpackMap       = true;
        recalcTaxes     = true;

        correctionReference.setTmp();
    }

]]></Source>
			</Method>
			<Method>
				<Name>notEmpty</Name>
				<Source><![CDATA[
    public boolean notEmpty()
    {
        return ! mapInvoiceTrans.empty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        MapIterator it = new MapIterator(mapInvoiceTrans);
        container   packedMap;

        while (it.more())
        {
            packedMap = conIns(packedMap, conLen(packedMap) + 1, it.key());
            packedMap = conIns(packedMap, conLen(packedMap) + 1, it.value());
            it.next();
        }

        return [    currentVersion, 
                    action,
                    mustBeUpdated,
                    printOut,
                    printMST,
                    factureExtId,
                    factureDate,
                    custVendAC,
                    currencyCode,
                    consignee,
                    consignor,
                    offsessionId,
                    attorneyId,
                    attorneyIssuedName,
                    attorneyDate,
                    deliveryAddress,
                    factureDateExternal,
                    factureExtIdNumSeq,
                    UseOriginalDocumentAsFacture_RU, 
                    packedMap];
    }

]]></Source>
			</Method>
			<Method>
				<Name>packAll</Name>
				<Source><![CDATA[
    /// <summary>
    /// Serializes current instance of the <c>FactureJourCreate_RU</c> class including temporary tables.
    /// </summary>
    /// <returns>
    /// A container that contains the current instance of the <c>FactureJourCreate_RU</c> class.
    /// </returns>
    public container packAll()
    {
        if (factureJour.isTmp())
        {
            return [currentVersionAll,
                this.pack(),
                showPreview,
                true,
                XMLExcelReport_RU::packTmpTableList(factureJour),
                XMLExcelReport_RU::packTmpTableList(factureTrans)];
        }
        else
        {
            return [currentVersionAll,
                this.pack(),
                showPreview,
                false,
                factureJour.RecId,
                factureTrans.RecId];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>packMapInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs the map of invoice transactions.
    /// </summary>
    /// <returns>
    /// Container of the packed map.
    /// </returns>
    public container packMapInvoiceTrans()
    {
        return mapInvoiceTrans.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAmountAdjustment</Name>
				<Source><![CDATA[
    public FactureAmountAdjustment_RU parmAmountAdjustment(FactureAmountAdjustment_RU _amountAdjustment = amountAdjustment)
    {
        amountAdjustment = _amountAdjustment;
        return amountAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBuffer</Name>
				<Source><![CDATA[
    public Common parmBuffer(Common _buffer = buffer)
    {
        buffer = _buffer;
        return buffer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCalledFromEditLines</Name>
				<Source><![CDATA[
    public boolean parmCalledFromEditLines(boolean _calledFromEditLines = calledFromEditLines)
    {
        ;
        calledFromEditLines = _calledFromEditLines;
        return calledFromEditLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCommPartner</Name>
				<Source><![CDATA[
    public CustVendAC parmCommPartner(CustVendAC _commPartner = commPartner)
    {
        commPartner = _commPartner;
        return commPartner;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmConfirmationDate</Name>
				<Source><![CDATA[
    SalesConfirmationDate_RU parmConfirmationDate(SalesConfirmationDate_RU _confirmationDate = confirmationDate)
    {
        confirmationDate = _confirmationDate;
        return confirmationDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCorrect</Name>
				<Source><![CDATA[
    public Correct_RU parmCorrect(Correct_RU _correct = correct)
    {
        ;
        correct = _correct;
        return correct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDlvInfoNoPrint</Name>
				<Source><![CDATA[
    public DeliveryInfoNoPrint_RU parmDlvInfoNoPrint(DeliveryInfoNoPrint_RU _deliveryInfoNoPrint = deliveryInfoNoPrint)
    {
        deliveryInfoNoPrint = _deliveryInfoNoPrint;

        return deliveryInfoNoPrint;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchAdjInvoiceRecId</Name>
				<Source><![CDATA[
    public RecId parmExchAdjInvoiceRecId(RecId _exchAdjInvoiceRecId = exchAdjInvoiceRecId)
    {
        exchAdjInvoiceRecId = _exchAdjInvoiceRecId;
        return exchAdjInvoiceRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExportDate</Name>
				<Source><![CDATA[
    SalesExportDate_RU parmExportDate(SalesExportDate_RU _exportDate = exportDate)
    {
        exportDate = _exportDate;
        return exportDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExportProcessing</Name>
				<Source><![CDATA[
    NoYesId parmExportProcessing(NoYesId _exportProcessing = exportProcessing)
    {
        exportProcessing = _exportProcessing;
        return exportProcessing;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFindOfficials</Name>
				<Source><![CDATA[
    public boolean parmFindOfficials(boolean _findOfficials = false)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGeneralJournalAccountEntry</Name>
				<Source><![CDATA[
    public GeneralJournalAccountEntry parmGeneralJournalAccountEntry(GeneralJournalAccountEntry _buffer = tmpGeneralJournalAccountEntry)
    {
        tmpGeneralJournalAccountEntry = _buffer;
        return tmpGeneralJournalAccountEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHeaderRevision</Name>
				<Source><![CDATA[
    public boolean parmHeaderRevision(boolean _headerRevision = headerRevision)
    {
        ;
        headerRevision = _headerRevision;

        return headerRevision;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventOwnerId</Name>
				<Source><![CDATA[
    InventOwnerId_RU parmInventOwnerId(InventOwnerId_RU _inventOwnerId = inventOwnerId)
    {
        inventOwnerId = _inventOwnerId;
        return inventOwnerId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventProfileType</Name>
				<Source><![CDATA[
    InventProfileType_RU parmInventProfileType(InventProfileType_RU _inventProfileType = inventProfileType)
    {
        inventProfileType = _inventProfileType;
        return inventProfileType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLanguageId</Name>
				<Source><![CDATA[
    public LanguageId parmLanguageId(LanguageId _languageId = CompanyInfo::languageId())
    {
        return _languageId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerVoucherObject</Name>
				<Source><![CDATA[
    public LedgerVoucherObject parmLedgerVoucherObject(LedgerVoucherObject _ledgerVoucherObject = ledgerVoucherObject)
    {
        ledgerVoucherObject = _ledgerVoucherObject;
        return ledgerVoucherObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPackageDate</Name>
				<Source><![CDATA[
    SalesPackageDate_RU parmPackageDate(SalesPackageDate_RU _packageDate = packageDate)
    {
        packageDate = _packageDate;
        return packageDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrinterSettings</Name>
				<Source><![CDATA[
    public container parmPrinterSettings(container _settings = printerSettings)
    {
        printerSettings = _settings;
        return printerSettings;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProcessingType</Name>
				<Source><![CDATA[
    SalesBookFactureProcessingType_RU parmProcessingType(SalesBookFactureProcessingType_RU _processingType = processingType)
    {
        processingType = _processingType;
        return processingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProcessVAT</Name>
				<Source><![CDATA[
    public FacturePostProcessVAT parmProcessVAT(FacturePostProcessVAT _processVAT = processVAT)
    {
        processVAT = _processVAT;

        return processVAT;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPurchBookVATProcessParametersRecId</Name>
				<Source><![CDATA[
    public PurchBookVATProcessParametersRecId_RU parmPurchBookVATProcessParametersRecId(PurchBookVATProcessParametersRecId_RU _purchBookVATProcessParametersRecId = purchBookVATProcessParametersRecId)
    {
        purchBookVATProcessParametersRecId = _purchBookVATProcessParametersRecId;

        return purchBookVATProcessParametersRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRecalcTaxes</Name>
				<Source><![CDATA[
    // used in main
    public NoYes parmRecalcTaxes(NoYes _recalcTaxes = recalcTaxes)
    {
        recalcTaxes = _recalcTaxes;
        return recalcTaxes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxTransGeneralJournalAccountEntry</Name>
				<Source><![CDATA[
    public TaxTransGeneralJournalAccountEntry parmTaxTransGeneralJournalAccountEntry(TaxTransGeneralJournalAccountEntry _buffer = tmpTaxTransGeneralJournalAccountEntry)
    {
        tmpTaxTransGeneralJournalAccountEntry = _buffer;
        return tmpTaxTransGeneralJournalAccountEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseOriginalDocumentAsFacture</Name>
				<Source><![CDATA[
    public UseOriginalDocumentAsFacture_RU parmUseOriginalDocumentAsFacture(UseOriginalDocumentAsFacture_RU _useOriginalDocumentAsFacture_RU = useOriginalDocumentAsFacture_RU)
    {
        useOriginalDocumentAsFacture_RU = _useOriginalDocumentAsFacture_RU;

        return UseOriginalDocumentAsFacture_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVATOnPayment</Name>
				<Source><![CDATA[
    public VATOnPayment_RU parmVATOnPayment(VATOnPayment_RU _vatOnPayment = vatOnPayment)
    {
        vatOnPayment = _vatOnPayment;
        return vatOnPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateCorrectionInfo</Name>
				<Source><![CDATA[
    private void populateCorrectionInfo()
    {
        FactureJour_RU                  correctedFacture,
                                        origFacture;
        FactureCorrectionReference_RU   corrReference;
        FactureOriginalReference_RU     origReference;
        int                             origCount;

        if (! factureJour.CorrectedFactureExternalId || factureJour.isTmp())
        {
            return;
        }

        if (factureJour.CorrectionType == FactureCorrectionType_RU::Correction)
        {
            select count(RecId) from correctionReference;
            if (correctionReference.RecId > 1)
            {
                factureJour.JointCorrection = NoYes::Yes;

                while select correctionReference
                {
                    buf2Buf(correctionReference, corrReference);
                    corrReference.FactureJour_RU = factureJour.RecId;
                    corrReference.insert();
                }
            }

            factureJour.RefLastCorrFacture = factureJour.RecId;

            correctedFacture = factureJour.getCorrectedFacture();
            while (correctedFacture)
            {
                origFacture = correctedFacture.getCorrectedFacture(true);
                while (origFacture)
                {
                    if (origCount < 1)
                    {
                        factureJour.RefOriginalFacture = origFacture.RecId;
                        origCount++;
                    }
                    else
                    {
                        factureJour.RefOriginalFacture = 0;
                    }

                    origReference.FactureJour_RU     = factureJour.RecId;
                    origReference.RefOriginalFacture = origFacture.RecId;
                    origReference.FactureExternalId  = origFacture.FactureExternalId;
                    origReference.FactureDate        = origFacture.FactureDate;
                    origReference.insert();

                    FactureJour_RU::updateFactureLinks(origFacture.RecId, false, factureJour.RecId);
                    next origFacture;
                }
                next correctedFacture;
            }
        }

        factureJour.allocateSeqNumber();

        factureJour.recalcTotalsDisplay(false);
        factureJour.CorrectedPeriod                = factureJour.correctedPeriod();
        factureJour.RevisionNum                    = factureJour.revisionNumDisplay();
        factureJour.OrigFactureExternalIdDisplay   = factureJour.factureIdOriginal();
        factureJour.OrigRevisionNumDisplay         = factureJour.factureRevNumOriginal();
        factureJour.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>printJournal</Name>
				<Source><![CDATA[
    public void printJournal(boolean _printNow = false)
    {
        MenuFunction func;
        Args         args = new Args();
        ;
        if (showPreview)
        {
            FactureHolder_RU::showPreview(this);
        }
        else
        {
            if (printout == Printout::After && ! _printNow)
                return;

            if (factureJour.isCorrection())
            {
                func = new MenuFunction(menuitemOutputStr(CustVendCorrFactureToExcel_RU), MenuItemType::Output);
                args.caller(this);
            }
            else
            {
                func = new MenuFunction(menuitemOutputStr(Facture_RU), MenuItemType::Output);

                args.caller(this);
                args.record(factureJour);
                func.run(args);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processIncomingVAT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Incoming VAT process.
    /// </summary>
    /// <param name="_factureJour">
    /// The record of <c>FactureJour_RU</c> table.
    /// </param>
    protected void processIncomingVAT(FactureJour_RU _factureJour)
    {
        TmpPurchBookVATProcessLogTrans_RU       logTrans;
        TmpPurchBookVATProcessLogTransOper_RU   logTransOper;
        TmpRestoredVATLogTrans_RU               restoredLogTrans;
        BookPost_Purch_RU                       bookPost;
        BookTransCalc_Purch_RU                  bookTransCalc;

        if (_factureJour.ProcessVAT == NoYes::Yes)
        {
            setPrefix("@GLS101145");

            bookTransCalc = BookTransCalc_Purch_RU::newTransCalc(_factureJour,
                                                        _factureJour.FactureDate,
                                                        _factureJour.FactureDate,
                                                        logTrans,
                                                        logTransOper,
                                                        restoredLogTrans,
                                                        _factureJour.PurchBookVATProcessParametersRecId,
                                                        false,
                                                        false,
                                                        false,
                                                        0,
                                                        PurchBookTable_RU::getLastClosedBook().ClosingDate,
                                                        false,
                                                        true);
            bookTransCalc.calc();

            while select logTrans
            {
                logTrans.Marked = NoYes::Yes;
                logTrans.update();

                BookAmountsEngine_RU::processFacture(NoYes::Yes, logTrans.Marked, logTransOper, logTrans, null, false);
            }

            bookPost = BookPost_Purch_RU::newFromVATProcess(PurchBookVATProcessCancelType_RU::Process, logTrans, logTransOper);
            bookPost.parmTransDate(_factureJour.FactureDate);
            bookPost.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeTrans</Name>
				<Source><![CDATA[
    public boolean removeTrans(container _key)
    {
        return mapInvoiceTrans.remove(_key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        #AviFiles
        this.progressInit("@GLS104579", mapInvoiceTrans.elements(), #AviFormLetter);

        this.createJournal();

        this.processIncomingVAT(factureJour);

        this.progressHide();
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUnpack</Name>
				<Source><![CDATA[
    public void setUnpack(boolean _unpackMap = true)
    {
        unpackMap = _unpackMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        const int fetchPerLoop = 2;
        int         version = RunBase::getVersion(packedClass);
        container   packedMap,
                    key;
        real        value;
        int         idx;

        switch (version)
        {
            case currentVersion:
                if (unpackMap)
                {
                    [   version, 
                        action,
                        mustBeUpdated,
                        printOut,
                        printMST,
                        factureExtId,
                        factureDate,
                        custVendAC,
                        currencyCode,
                        consignee,
                        consignor,
                        offsessionId,
                        attorneyId,
                        attorneyIssuedName,
                        attorneyDate,
                        deliveryAddress,
                        factureDateExternal,
                        factureExtIdNumSeq,
                        UseOriginalDocumentAsFacture_RU, 
                        packedMap ] = packedClass;

                    mapInvoiceTrans = new Map(Types::Container, Types::Real);

                    for (idx = 1; idx <= conLen(packedMap); idx += fetchPerLoop)
                    {
                        key   = conPeek(packedMap, idx);
                        value = conPeek(packedMap, idx + 1);
                        mapInvoiceTrans.insert(key, value);
                    }
                }

                return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpackAll</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deserializes the container parameter value to an inctance of the
    /// <c>FactureJourCreate_RU</c> class including temporary tables.
    /// </summary>
    /// <param name="_packedAllClass">
    /// The container from which to deserialize the instance.
    /// </param>
    /// <returns>
    /// true if deserialization was successful; otherwise, false.
    /// </returns>
    public boolean unpackAll(container _packedAllClass)
    {
        int         version = RunBase::getVersion(_packedAllClass);
        boolean     ret = true, isTmp;
        container   packedClass, packedJour, packedTrans;
        RefRecId    packedJourRecId, packedTransRecId;

        switch (version)
        {
            case currentVersionAll:
                [version, packedClass, showPreview, isTmp] = _packedAllClass;

                ret = this.unpack(packedClass);

                holder = new FactureHolder_RU(isTmp);
                factureJour = holder.factureJour();
                factureTrans = holder.factureTrans();

                if (isTmp)
                {
                    [version, packedClass, showPreview, isTmp, packedJour, packedTrans] = _packedAllClass;
                    factureJour = XMLExcelReport_RU::unpackTmpTableList(factureJour, packedJour);
                    factureTrans = XMLExcelReport_RU::unpackTmpTableList(factureTrans, packedTrans);
                }
                else
                {
                    [version, packedClass, showPreview, isTmp, packedJourRecId, packedTransRecId] = _packedAllClass;

                    select factureJour where factureJour.RecId == packedJourRecId;
                    select factureTrans where factureTrans.RecId == packedTransRecId;
                }

                break;
            default:
                ret = false;
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpackMapInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the map of invoice transactions from packed container.
    /// </summary>
    /// <param name="_mapInvoiceTransPack">
    /// Packed map of invoice transactions.
    /// </param>
    public void unpackMapInvoiceTrans(container _mapInvoiceTransPack)
    {
        mapInvoiceTrans = Map::create(_mapInvoiceTransPack);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFullyFacturedInvoices</Name>
				<Source><![CDATA[
    protected void updateFullyFacturedInvoices()
    {
        CustVendInvoiceJour     invoiceJour;
        CustVendInvoiceTrans    invoiceTrans;
        MarkupTrans             markupTrans;
        Set                     joursProcessed = new Set(typeName2Type(extendedTypeStr(RecId)));

        FactureEditLinesEngine_RU   engine = FactureEditLinesEngine_RU::construct(this, this.module());

        while select factureTrans
            where  factureTrans.FactureId           == factureJour.FactureId            &&
                   factureTrans.Module              == factureJour.Module
        {
            invoiceJour = null;
            switch (factureTrans.FactureLineType)
            {
                case FactureLineType_RU::AdvanceReport  :
                case FactureLineType_RU::InvoiceLine    :
                case FactureLineType_RU::TaxCorrection  :
                    invoiceTrans = this.findInvoiceTransByFacture();
                    break;
                case FactureLineType_RU::Markup      :
                    markupTrans  = MarkupTrans::findRecId_W(factureTrans.MarkupRefRecId);
                    switch (markupTrans.TransTableId)
                    {
                        case tableNum(VendInvoiceJour)  :
                            invoiceJour  = VendInvoiceJour::findRecId(markupTrans.TransRecId, true);
                            break;
                        case tableNum(VendInvoiceTrans) :
                            invoiceTrans = VendInvoiceTrans::findRecId(markupTrans.TransRecId);
                            break;
                        case tableNum(CustInvoiceJour)  :
                            invoiceJour  = CustInvoiceJour::findRecId(markupTrans.TransRecId, true);
                            break;
                        case tableNum(CustInvoiceTrans) :
                            invoiceTrans = CustInvoiceTrans::findRecId(markupTrans.TransRecId);
                            break;
                    }
                    break;
                case FactureLineType_RU::InvoiceRoundOff    :
                case FactureLineType_RU::InvoiceEndDisc     :
                    switch (factureJour.Module)
                    {
                        case FactureModule_RU::Cust :
                            invoiceJour  = CustInvoiceJour::findFromCustInvoiceTrans(factureTrans.SalesPurchId,
                                                                                     factureTrans.InvoiceId,
                                                                                     factureTrans.InvoiceDate,
                                                                                     factureTrans.NumberSequenceGroup,
                                                                                     true);
                            break;
                        case FactureModule_RU::Vend :
                            invoiceJour  = VendInvoiceJour::findFromVendInvoiceTrans(factureTrans.SalesPurchId,
                                                                                     factureTrans.InvoiceId,
                                                                                     factureTrans.InvoiceDate,
                                                                                     factureTrans.NumberSequenceGroup,
                                                                                     factureTrans.InternalInvoiceId,
                                                                                     true);
                            break;
                    }
                    break;
                case FactureLineType_RU::Prepayment  :
                    continue;
                default                              :
                    throw error(Error::wrongUseOfFunction(funcName()));
            }
            if (! invoiceJour && invoiceTrans)
            {
                invoiceJour = this.findInvoiceJourByTrans(invoiceTrans);
            }

            if (joursProcessed.in(invoiceJour.RecId))
                continue;

            joursProcessed.add(invoiceJour.RecId);

            invoiceJour.setFacturedFully_RU(engine.jourFullyFactured(invoiceJour.RecId, false));
            invoiceJour.update();

            this.updateSourceOrder(invoiceJour);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRevisedFacture</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates revised facture Revised field.
    /// </summary>
    protected void updateRevisedFacture()
    {
        FactureJour_RU revisedFacture;

        update_recordset revisedFacture
            setting Revised = NoYes::Yes
            where (revisedFacture.RecId             == factureJour.RefRevisedFacture
                || revisedFacture.RefRevisedFacture == factureJour.RefRevisedFacture)
                && revisedFacture.Revised           == NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceOrder</Name>
				<Source><![CDATA[
    // overloaded in FactureJourCreateCust_RU, FactureJourCreateVend_Ru
    protected void updateSourceOrder(CustVendInvoiceJour _jour)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTrans</Name>
				<Source><![CDATA[
    public boolean updateTrans(container _key,
                               Qty       _qty)
    {
        mapInvoiceTrans.remove(_key);
        return _qty ? mapInvoiceTrans.insert(_key, _qty) : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatCode</Name>
				<Source><![CDATA[
    final public TaxCode vatCode(TaxGroup     _taxGroup,
                                 TaxItemGroup _taxItemGroup)
    {
        TaxCode   ret;
        container key = [ _taxGroup, _taxItemGroup ];

        if (vatCodeCache.exists(key))
        {
            ret = vatCodeCache.lookup(key);
        }
        else
        {
            ret = TaxTable::vatCode_RU(_taxGroup, _taxItemGroup);

            vatCodeCache.insert(key, ret);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static FactureJourCreate_RU construct(FactureModule_RU _moduleType, NoYes _exportProcessing = NoYes::No)
    {
        FactureJourCreate_RU    jourCreate;

        switch (_moduleType)
        {
            case FactureModule_RU::Cust :
                if (_exportProcessing == NoYes::No)
                {
                    jourCreate = new FactureJourCreateCust_RU();
                }
                else
                {
                    jourCreate = new FactureJourCreateExportVAT_RU();
                }
                break;
            case FactureModule_RU::Vend :
                jourCreate = new FactureJourCreateVend_RU();
                break;
            case FactureModule_RU::Empl :
                jourCreate = new FactureJourCreateEmpl_RU();
                break;
            case FactureModule_RU::TaxCorrectionPurch      :
            case FactureModule_RU::TaxCorrectionPurch_Cust :
                jourCreate = new FactureJourCreateTaxCorrection_Purch_RU();
                break;
            case FactureModule_RU::TaxCorrectionSales      :
            case FactureModule_RU::TaxCorrectionSales_Vend :
                jourCreate = new FactureJourCreateTaxCorrection_Sales_RU();
                break;
            default                     :
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        jourCreate.setUnpack(false);
        return jourCreate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>module2book</Name>
				<Source><![CDATA[
    public static FactureBook_RU module2book(FactureModule_RU _module)
    {
        FactureBook_RU book;

        switch (_module)
        {
            case FactureModule_RU::Vend                    :
            case FactureModule_RU::Empl                    :
            case FactureModule_RU::TaxCorrectionPurch      :
            case FactureModule_RU::TaxCorrectionPurch_Cust :
                book = FactureBook_RU::Purch;
                break;
            case FactureModule_RU::Cust      :
            case FactureModule_RU::TaxCorrectionSales      :
            case FactureModule_RU::TaxCorrectionSales_Vend :
                book = FactureBook_RU::Sales;
                break;
            default                                        :
                book = FactureBook_RU::Any;
        }

        return book;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newAmountDiffFactureCustVendTrans</Name>
				<Source><![CDATA[
    public static FactureJour_RU newAmountDiffFactureCustVendTrans(
        LedgerVoucher         _ledgerVoucher,
        CustVendTrans         _custVendTrans,
        RecId                 _transDebetRecId,
        RecId                 _transCreditRecId,
        TransDate             _factureDateExternal   = _custVendTrans.TransDate,
        FactureType_RU        _factureType           = FactureType_RU::AmoutDifference,
        AmountMST             _totalFactureAmountMST = 0,
        RecId                 _invoiceRecId          = 0,
        NoYes                 _amountAdjustment      = NoYes::No,
        FactureId_RU          _factureId             = '',
        FactureExternalId_RU  _factureExtId          = '')
    {
        FactureJourCreateAmountDiff_RU  jourCreate = FactureJourCreateAmountDiff_RU::construct(_custVendTrans);
        FactureJour_RU                  tmpJour;
        FactureModule_RU                custVend;
        CustVendTrans                   invoiceTrans;
        TaxTable                        taxTable;
        TaxTrans                        taxTrans, taxTransVATAdjustment;
        CustVendTransPostingLog_RU      tmpLog;
        CustVendTransPostingLogType_RU  postingLogType;
        FactureLineType_RU              factureLineType;
        FactureCalcAmountAdjustments_RU factureCalcAmountAdj;

        if (_custVendTrans.TableId == tableNum(CustTrans))
        {
            custVend     = FactureModule_RU::Cust;
            invoiceTrans = CustTrans::find(_invoiceRecId);
        }
        else
        {
            custVend     = FactureModule_RU::Vend;
            invoiceTrans = VendTrans::find(_invoiceRecId);
        }

        switch (_factureType)
        {
            case FactureType_RU::AmoutDifference   :
                postingLogType  = CustVendTransPostingLogType_RU::ExchAmountDiff;
                factureLineType = FactureLineType_RU::AmountDifference;
                break;

            case FactureType_RU::ExchAdj           :
                postingLogType  = CustVendTransPostingLogType_RU::ExchAdjustment;
                factureLineType = FactureLineType_RU::ExchAdj;
                break;

            case FactureType_RU::AdvanceAdjustment :
                postingLogType  = CustVendTransPostingLogType_RU::AdvanceAdjustment;
                factureLineType = FactureLineType_RU::AdvanceAdjustment;
                break;

            case FactureType_RU::VATAdjustment :
                postingLogType  = CustVendTransPostingLogType_RU::AdvanceAdjustment;
                factureLineType = FactureLineType_RU::VATAdjustment;
                break;
        }

        select firstonly tmpJour
            exists join tmpLog
                where tmpLog.RecId          == tmpJour.PostingLogRecId  &&
                      tmpLog.PostingLogType == postingLogType           &&
                      tmpLog.TransDate      == _custVendTrans.TransDate &&
                      tmpLog.Reversed       == NoYes::No                &&
                      ((tmpLog.TransRecId   == _transDebetRecId         &&
                        tmpLog.OffSetRecId  == _transCreditRecId)       ||
                       (tmpLog.TransRecId   == _transCreditRecId        &&
                        tmpLog.OffSetRecId  == _transDebetRecId));

        if (tmpJour)
        {
            return null;
        }

        jourCreate.initParameters(NoYes::Yes,
                                  NoYes::No,
                                  Printout::After,
                                  NoYes::Yes,
                                  '',
                                  _custVendTrans.TransDate,
                                  _custVendTrans.AccountNum,
                                  _custVendTrans.CurrencyCode,
                                  _factureType,
                                  '',
                                  '',
                                  '',
                                  '',
                                  '',
                                  dateNull(),
                                  0,
                                  _factureDateExternal);

        jourCreate.parmAmountAdjustment(_amountAdjustment);
        jourCreate.parmExchAdjInvoiceRecId(_invoiceRecId);
        jourCreate.parmTotalFactureAmountMST(_totalFactureAmountMST);
        jourCreate.parmFactureId(_factureId);
        jourCreate.parmFactureExtId(_factureExtId);
        jourCreate.parmLedgerVoucherObject(_ledgerVoucher.findLedgerVoucherObject());

        if (_amountAdjustment)
        {
            factureCalcAmountAdj = FactureCalcAmountAdjustments_RU::newCustVendTrans(invoiceTrans);
            factureCalcAmountAdj.calcTaxTrans(_custVendTrans, _totalFactureAmountMST, _ledgerVoucher);

            taxTrans.setTmp();
            taxTrans.setTmpData(factureCalcAmountAdj.getTaxTrans());

            while select taxTrans
            {
                jourCreate.appendTrans([tableNum(TaxTrans), taxTrans.RecId, 0, factureLineType], 0);
            }

            jourCreate.parmBuffer(factureCalcAmountAdj.getTaxTrans());
            jourCreate.parmGeneralJournalAccountEntry(factureCalcAmountAdj.getGeneralJournalAccountEntry());
            jourCreate.parmTaxTransGeneralJournalAccountEntry(factureCalcAmountAdj.getTaxTransGeneralJournalAccountEntry());
        }
        else
        {
            while select taxTrans
                where taxTrans.TransDate     == _custVendTrans.TransDate &&
                      taxTrans.Voucher       == _custVendTrans.Voucher   &&
                      taxTrans.SourceRecId   == _custVendTrans.RecId     &&
                      taxTrans.SourceTableId == _custVendTrans.TableId
            join TaxType_W from taxTable
                where taxTable.TaxCode == taxTrans.TaxCode &&
                      (taxTable.TaxType_W == TaxType_W::VAT        ||
                       taxTable.TaxType_W == TaxType_W::VATReduced ||
                       taxTable.TaxType_W == TaxType_W::VATZero)
            {
                if (_factureType == FactureType_RU::VATAdjustment)
                {
                    select firstonly RecId from taxTransVATAdjustment
                        where taxTransVATAdjustment.Voucher       == taxTrans.Voucher   &&
                              taxTransVATAdjustment.TransDate     == taxTrans.TransDate &&
                              taxTransVATAdjustment.SourceRecId   == taxTrans.RecId     &&
                              taxTransVATAdjustment.SourceTableId == taxTrans.TableId;

                    jourCreate.appendTrans([tableNum(TaxTrans), taxTransVATAdjustment.RecId, 0, factureLineType], 0);
                }
                else
                {
                    jourCreate.appendTrans([tableNum(TaxTrans), taxTrans.RecId, 0, factureLineType], 0);

                }
            }
        }

        ttsbegin;

        jourCreate.runOperation();

        tmpJour = jourCreate.getFactureJour();

        if (tmpJour)
        {
            select firstonly RecId from tmpLog
                where tmpLog.PostingLogType == postingLogType           &&
                      tmpLog.TransDate      == _custVendTrans.TransDate &&
                      tmpLog.Reversed       == NoYes::No                &&
                      ((tmpLog.TransRecId   == _transDebetRecId         &&
                        tmpLog.OffSetRecId  == _transCreditRecId)       ||
                       (tmpLog.TransRecId   == _transCreditRecId        &&
                        tmpLog.OffSetRecId  == _transDebetRecId))       &&
                      tmpLog.RefTableId     == _custVendTrans.TableId;

            tmpJour.PostingLogRecId = tmpLog.RecId;
            tmpJour.update();
        }

        ttscommit;

        return tmpJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPrepaymentFactureCustTrans</Name>
				<Source><![CDATA[
    public static FactureJour_RU newPrepaymentFactureCustTrans(CustTrans _custTrans,
                                                                      ExchRate  _exchRate            = 0,
                                                                      TransDate _factureDate         = _custTrans.TransDate,
                                                                      AmountCur _factureAmount       = _custTrans.remainAmountCur(),
                                                                      UseOriginalDocumentAsFacture_RU _useOriginalDocumentAsFacture_RU = NoYes::No)
    {
        FactureJour_RU       jour;
        FactureTrans_RU      trans;
        NumberSeq            factureNumberSeq,
                             invoiceNumberSeq;
        DictType             dictType;
        CalcPostedTaxes_RU   calcPostedTaxes;
        TaxTable             taxTable;
        TaxTrans             taxTrans;
        int                  sign;

        FactureId_RU         newFactureId;
        FactureExternalId_RU newExternalFactureId;

        VATType_RU           vatType;

        FactureItemName_RU transTxt()
        {
            SalesAgreementHeaderExt_RU salesAgreementHeaderExt;
            SalesAgreementHeader salesAgreementHeader;
            FactureItemName_RU ret;

            ret = SysLabel::labelId2String(literalStr("@SYS50745"),
                                           jour.LanguageId);

            salesAgreementHeaderExt = AgreementHeaderExt_RU::findByDefaultDimension(_custTrans.DefaultDimension) as SalesAgreementHeaderExt_RU;
            salesAgreementHeader    = SalesAgreementHeader::find(salesAgreementHeaderExt.AgreementHeader);

            if (salesAgreementHeader)
            {
                ret += ' ' + strFmt(SysLabel::labelId2String(literalStr("@GLS113549"), jour.LanguageId),
                                    salesAgreementHeader.DocumentTitle,
                                    salesAgreementHeaderExt.AgreementDate);
            }
            return ret;
        }
        ;

        select sum(SourceBaseAmountCur),
               sum(SourceTaxAmountCur),
               sum(SourceRegulateAmountCur),
               sum(TaxBaseAmount),
               sum(TaxAmount) from taxTrans
        group by TaxCode, TaxAutogenerated, TaxGroup, TaxItemGroup, TransDate
        where taxTrans.TransDate   == _custTrans.TransDate &&
              taxTrans.Voucher     == _custTrans.Voucher   &&
              taxTrans.TaxOrigin   == TaxOrigin::Tax       &&
              taxTrans.SourceRecId == _custTrans.RecId;
        calcPostedTaxes = new CalcPostedTaxes_RU(taxTrans);
        calcPostedTaxes.calc();

        if (! calcPostedTaxes.taxBaseAmountCur_VAT()        &&
            ! calcPostedTaxes.taxBaseAmountCur_VATReduced() &&
            ! calcPostedTaxes.taxBaseAmountCur_VATZero()    &&
            ! calcPostedTaxes.taxAmountCur_VAT()            &&
            ! calcPostedTaxes.taxAmountCur_VATReduced()     &&
            ! calcPostedTaxes.taxAmountCur_VATZero())
        {
            return jour;
        }

        ttsbegin;

        factureNumberSeq = NumberSeq::newGetNum(CustParameters::numRefCustFactureId_RU(),false,true);

        if (! factureNumberSeq)
            throw error(strFmt("@SYS53911", "@GLS106861", "@SYS25196"));

        newFactureId         = factureNumberSeq.num();

        jour.Module                 =  FactureModule_RU::Cust;
        jour.FactureType            =  FactureType_RU::Prepayment;
        jour.FactureId              =  newFactureId;
        jour.Voucher                =  _custTrans.Voucher;
        jour.FactureDate            =  _factureDate;
        jour.FactureDate_External   =  _custTrans.TransDate;
        jour.FactureAmount          = -_factureAmount;

        sign                        = (jour.FactureAmount >= 0 ? 1 : -1);

        jour.FactureAmount         -= abs(calcPostedTaxes.taxAmountCur_VAT()        +
                                          calcPostedTaxes.taxAmountCur_VATReduced() +
                                          calcPostedTaxes.taxAmountCur_VATZero())   * sign;
        jour.FactureTax             =  abs(calcPostedTaxes.totalTaxAmountCur())     * sign;
        jour.CurrencyCode           =  _custTrans.CurrencyCode;
        jour.CustVendInvoiceAccount =  _custTrans.AccountNum;
        jour.InventProfileType      = CustVendTrans::inventProfileType_RU(_custTrans.custTrans_W().CommProfileType_RU);
        jour.Consignee              =  "";
        jour.Consignor              =  "";
        jour.NumberSequenceGroupId  =  "";
        jour.OffSessionId           =  "";
        jour.PrintInMST             =  NoYes::No;

        jour.DocumentNum            =  _custTrans.PaymReference ? _custTrans.PaymReference : _custTrans.DocumentNum;
        if (_useOriginalDocumentAsFacture_RU)
        {
            newExternalFactureId = jour.DocumentNum;
        }
        else
        {
            invoiceNumberSeq = NumberSeq::newGetNum(LedgerParameters::numRefPrepaymentFactureId_RU());

            if (! invoiceNumberSeq)
            {
                dictType = new DictType(extendedTypeNum(PrepaymentFactureId_W));
                throw error(strFmt("@SYS53911", dictType.label(), "@SYS24097"));
            }
            newExternalFactureId = invoiceNumberSeq.num();
        }

        jour.FactureExternalId      =  newExternalFactureId;

        if (jour.DocumentNum)
        {
            jour.DocumentDate       =  _custTrans.PaymReference ?
                                       (_custTrans.DocumentDate ? _custTrans.DocumentDate : _custTrans.TransDate) :
                                        _custTrans.DocumentDate;
        }
        jour.LanguageId             =  _custTrans.languageId();
        jour.LanguageId             = jour.LanguageId ? jour.LanguageId : infolog.language();
        jour.insert(true);

        while select sum(SourceBaseAmountCur),
                     sum(SourceTaxAmountCur),
                     sum(SourceRegulateAmountCur),
                     sum(TaxBaseAmount),
                     sum(TaxAmount) from taxTrans
            group by TaxCode, TaxAutogenerated, TaxGroup, TaxItemGroup
            where taxTrans.TransDate   == _custTrans.TransDate &&
                  taxTrans.Voucher     == _custTrans.Voucher   &&
                  taxTrans.TaxOrigin   == TaxOrigin::Tax       &&
                  taxTrans.SourceRecId == _custTrans.RecId
        {
            if (! taxTrans.SourceBaseAmountCur)
                continue;

            taxTable = TaxTable::find(taxTrans.TaxCode);

            switch (taxTable.TaxType_W)
            {
                case TaxType_W::VAT        :
                    vatType = VATType_RU::Full;
                    break;
                case TaxType_W::VATReduced :
                    vatType = VATType_RU::Reduced;
                    break;
                case TaxType_W::VATZero    :
                    vatType = VATType_RU::Zero;
                    break;
                default                    :
                    vatType = VATType_RU::NonLiable;
                    break;
            }

            trans = jour.newTrans(-taxTrans.SourceBaseAmountCur,
                                  -taxTrans.taxAmountCur_W(),
                                  taxTable.TaxType_W == TaxType_W::Excise ? -taxTrans.taxAmountCur_W(): 0,
                                  FactureLineType_RU::Prepayment,
                                  _exchRate ? _exchRate : ExchangeRateHelper::exchRate(_custTrans.CurrencyCode, _custTrans.TransDate),
                                  TaxData::percent(taxTable.TaxCode, _custTrans.TransDate, taxTable.TaxBase),
                                  taxTable.TaxType_W == TaxType_W::VATZero    ? -taxTrans.taxAmountCur_W() : 0,
                                  taxTable.TaxType_W == TaxType_W::VATReduced ? -taxTrans.taxAmountCur_W() : 0,
                                  taxTable.TaxType_W == TaxType_W::VAT        ? -taxTrans.taxAmountCur_W() : 0,
                                  vatType,
                                  transTxt(),
                                  _custTrans.DefaultDimension,
                                  -taxTrans.TaxBaseAmount,
                                  -taxTrans.TaxAmount,
                                  taxTable.TaxType_W == TaxType_W::Excise     ? -taxTrans.TaxAmount : 0,
                                  taxTable.TaxType_W == TaxType_W::VATZero    ? -taxTrans.TaxAmount : 0,
                                  taxTable.TaxType_W == TaxType_W::VATReduced ? -taxTrans.TaxAmount : 0,
                                  taxTable.TaxType_W == TaxType_W::VAT        ? -taxTrans.TaxAmount : 0);

            trans.ExciseValue  = taxTable.TaxType_W == TaxType_W::Excise                                  ?
                                 TaxData::percent(taxTable.TaxCode, taxTrans.TransDate, taxTable.TaxBase) :
                                 0;
            trans.TaxGroup     = taxTrans.TaxGroup;
            trans.TaxItemGroup = taxTrans.TaxItemGroup;
            trans.TaxCode      = trans.vatType == VATType_RU::NonLiable ? "" : taxTrans.TaxCode;
            trans.TransNotes   = transTxt();
            trans.update();
        }

        ttscommit;

        return jour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPrepaymentFactureLedgerJournalTrans</Name>
				<Source><![CDATA[
    public static FactureJour_RU newPrepaymentFactureLedgerJournalTrans(LedgerJournalTrans       _ledgerJournalTrans,
                                                                               boolean                  _checkBooks     = true,
                                                                               NoYes                    _autoCreate     = _ledgerJournalTrans.CustFactureAutoCreate_RU,
                                                                               FactureDate_RU           _factureDate    = _ledgerJournalTrans.TransDate)
    {
        FactureJour_RU      jour;
        FactureTrans_RU     trans;
        NumberSeq           factureNumberSeq,
                            invoiceNumberSeq;
        DictType            dictType;
        CalcTaxes_RU        calcPostedTaxes;
        TaxTrans            taxTrans;
        int                 sign;

        TaxGroup            taxGroup;
        TaxItemGroup        taxItemGroup;
        TaxCode             taxCode;
        TmpTaxWorkTrans     tmpTaxWorkTrans;
        Tax                 tax;

        CommReportTransPrepayment_RU commReportTrans;
  
        FactureItemName_RU transTxt()
        {
            AgreementHeaderExt_RU agreementHeaderExt;
            AgreementHeader       agreementHeader;
            FactureItemName_RU    ret;

            ret = SysLabel::labelId2String(literalStr("@SYS50745"),
                                        jour.LanguageId);

            agreementHeaderExt = AgreementHeaderExt_RU::findByAgreementId(_ledgerJournalTrans.AccountAgreementId_RU);
            agreementHeader    = AgreementHeader::find(agreementHeaderExt.AgreementHeader);

            if (agreementHeader)
            {
                ret += ' ' + strFmt(SysLabel::labelId2String(literalStr("@GLS113549"), jour.LanguageId),
                                    agreementHeader.DocumentTitle, agreementHeaderExt.AgreementDate);
            }

            return ret;
        }

        ;

        if (_ledgerJournalTrans.AccountType != LedgerJournalACType::Cust)
            throw error(Error::wrongUseOfFunction(funcName()));

        if (_autoCreate == NoYes::No)
        {
            return jour;
        }

        ttsbegin;

        factureNumberSeq = NumberSeq::newGetNum(CustParameters::numRefCustFactureId_RU(),false,true);

        if (! factureNumberSeq)
        {
            dictType = new DictType(extendedTypeNum(FactureId_RU));
            throw error(strFmt("@SYS53911", dictType.label(), "@SYS25196"));
        }

        if (!_ledgerJournalTrans.UseOriginalDocumentAsFacture_RU)
        {
            invoiceNumberSeq = NumberSeq::newGetNum(LedgerParameters::numRefPrepaymentFactureId_RU());

            if (! invoiceNumberSeq)
            {
                dictType = new DictType(extendedTypeNum(PrepaymentFactureId_W));
                throw error(strFmt("@SYS53911", dictType.label(), "@SYS25196"));
            }
        }

        select firstonly taxTrans
            where taxTrans.TransDate == _ledgerJournalTrans.TransDate &&
                  taxTrans.Voucher   == _ledgerJournalTrans.Voucher   &&
                  taxTrans.TaxOrigin == TaxOrigin::Tax;

        taxGroup        = taxTrans.TaxGroup;
        taxItemGroup    = taxTrans.TaxItemGroup;

        if (_ledgerJournalTrans.isTmp() && _ledgerJournalTrans.ReasonRefRecID)
        {
            commReportTrans = CommReportTransPrepayment_RU::find(_ledgerJournalTrans.ReasonRefRecID);
        }

        if (commReportTrans)
        {
            tax = Tax::construct();
            if (taxTrans)
            {
                tax.taxCalcWithoutSource(taxGroup,
                                     taxItemGroup,
                                     _ledgerJournalTrans.TransDate,
                                     _ledgerJournalTrans.CurrencyCode,
                                     commReportTrans.LineAmountMST -
                                     commReportTrans.VATAmountMST,
                                     TaxModuleType::Sales);
            }
            else
            {
                select firstonly trans
                exists join jour
                where jour.RecId == commReportTrans.RefFactureJour;

                tax.taxCalcWithoutSource_RU(trans.TaxCode,
                                        _ledgerJournalTrans.TransDate,
                                        _ledgerJournalTrans.CurrencyCode,
                                        commReportTrans.LineAmountMST -
                                        commReportTrans.VATAmountMST,
                                        TaxModuleType::Sales);
            }

            tmpTaxWorkTrans = tax.tmpTaxWorkTrans();
            select tmpTaxWorkTrans;
  
            calcPostedTaxes = CalcTaxes_RU::construct(tmpTaxWorkTrans);
            calcPostedTaxes.calc();
        }
        else
        {
            calcPostedTaxes = new CalcPostedTaxes_RU(taxTrans);
            calcPostedTaxes.calc();
        }

        sign                        = _ledgerJournalTrans.amount() < 0 ? 1 : -1;

        jour.Module                 =  FactureModule_RU::Cust;
        jour.FactureType            =  FactureType_RU::Prepayment;
        jour.FactureId              =  factureNumberSeq.num();
        jour.Voucher                =  _ledgerJournalTrans.Voucher;
        jour.FactureDate            =  _factureDate;
        jour.FactureDate_External   =  _ledgerJournalTrans.TransDate;
        jour.FactureAmount          = -_ledgerJournalTrans.amount() - abs(calcPostedTaxes.taxAmountCur_VAT()        +
                                                                          calcPostedTaxes.taxAmountCur_VATReduced() +
                                                                          calcPostedTaxes.taxAmountCur_VATZero())   * sign;
        jour.FactureTax             =  abs(calcPostedTaxes.totalTaxAmountCur()) * sign;
        jour.CurrencyCode           =  _ledgerJournalTrans.CurrencyCode;
        jour.CustVendInvoiceAccount =  _ledgerJournalTrans.parmAccount();
        jour.InventProfileType      =  _ledgerJournalTrans.inventProfileType_RU();
        jour.RefCommReportTrans     =  commReportTrans.RecId;         jour.Consignee              =  "";
        jour.Consignor              =  "";
        jour.NumberSequenceGroupId  =  "";
        jour.OffSessionId           =  "";
        jour.PrintInMST             =  NoYes::No;

        jour.DocumentNum            =  _ledgerJournalTrans.PaymReference ? _ledgerJournalTrans.PaymReference : _ledgerJournalTrans.DocumentNum;
        if (_ledgerJournalTrans.UseOriginalDocumentAsFacture_RU)
        {
            jour.FactureExternalId = jour.DocumentNum;
            jour.UseOriginalDocumentAsFacture = _ledgerJournalTrans.UseOriginalDocumentAsFacture_RU;
        }
        else
        {
            jour.FactureExternalId = invoiceNumberSeq.num();
        }

        if (jour.DocumentNum)
        {
            jour.DocumentDate       =  _ledgerJournalTrans.PaymReference ?
                                       (_ledgerJournalTrans.DocumentDate ? _ledgerJournalTrans.DocumentDate : _ledgerJournalTrans.TransDate) :
                                        _ledgerJournalTrans.DocumentDate;
        }
        jour.DocumentDate           =  _ledgerJournalTrans.DocumentDate;
        jour.LanguageId             = CustTable::find(jour.CustVendInvoiceAccount).languageId();
        jour.LanguageId             = jour.LanguageId ? jour.LanguageId : infolog.language();

        if (commReportTrans)
        {
            jour.CommPartner = commReportTrans.VendAccount;
        }

        jour.insert(_checkBooks);

        trans = jour.newTrans(jour.FactureAmount,
                              abs(calcPostedTaxes.totalTaxAmountCur())   * sign,
                              abs(calcPostedTaxes.taxAmountCur_Excise()) * sign,
                              FactureLineType_RU::Prepayment,
                              _ledgerJournalTrans.ExchRate,
                              abs(calcPostedTaxes.taxValue_VAT()),
                              abs(calcPostedTaxes.taxAmountCur_VATZero())    * sign,
                              abs(calcPostedTaxes.taxAmountCur_VATReduced()) * sign,
                              abs(calcPostedTaxes.taxAmountCur_VAT())        * sign,
                              calcPostedTaxes.taxBaseAmountCur_VAT()          ? VATType_RU::Full    :
                               (calcPostedTaxes.taxBaseAmountCur_VATReduced() ? VATType_RU::Reduced :
                                 (calcPostedTaxes.taxBaseAmountCur_VATZero()  ? VATType_RU::Zero    :
                                                                                VATType_RU::NonLiable)),
                              transTxt(),
                              _ledgerJournalTrans.DefaultDimension,
                              -_ledgerJournalTrans.amountMST_RU() -
                              abs(calcPostedTaxes.taxAmount_VAT()        +
                                  calcPostedTaxes.taxAmount_VATReduced() +
                                  calcPostedTaxes.taxAmount_VATZero())    * sign,
                              abs(calcPostedTaxes.totalTaxAmount())       * sign,
                              abs(calcPostedTaxes.taxAmount_Excise())     * sign,
                              abs(calcPostedTaxes.taxAmount_VATZero())    * sign,
                              abs(calcPostedTaxes.taxAmount_VATReduced()) * sign,
                              abs(calcPostedTaxes.taxAmount_VAT())        * sign);

        trans.ExciseValue  = abs(calcPostedTaxes.taxValue_Excise());
        trans.TaxGroup     = taxGroup;
        trans.TaxItemGroup = taxItemGroup;

        switch (trans.vatType)
        {
            case VATType_RU::Full      :
                taxCode = new SetIterator(calcPostedTaxes.taxCodes_VATFull()).value();
                break;
            case VATType_RU::Reduced   :
                taxCode = new SetIterator(calcPostedTaxes.taxCodes_VATReduced()).value();
                break;
            case VATType_RU::Zero      :
                taxCode = new SetIterator(calcPostedTaxes.taxCodes_VATZero()).value();
                break;
            case VATType_RU::NonLiable :
            default                    :
                taxCode = "";
                break;
        }

        trans.TaxCode      = taxCode;
        trans.TransNotes   = transTxt();

        trans.update();

        ttscommit;

        return jour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newVATPaymentFactureLedgerJournalTrans</Name>
				<Source><![CDATA[
    public static FactureJour_RU newVATPaymentFactureLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans,
                                                                               boolean            _checkBooks = true)
    {
        FactureJour_RU              jour;
        FactureJour_RU              jourTaxAgent;
        FactureTrans_RU             trans;
        NumberSeq                   factureNumberSeq,
                                    invoiceNumberSeq;
        DictType                    dictType;
        VATType_RU                  vatType;
        VendTrans                   vendPayment;
        VendTrans_W                 vendTransW;
        CustVendTransPostingLog_RU  postingLog;

        if (_ledgerJournalTrans.AccountType != LedgerJournalACType::Vend)
            throw error(Error::wrongUseOfFunction(funcName()));

        ttsbegin;

        factureNumberSeq = NumberSeq::newGetNum(VendParameters::numRefVendFactureId_RU(), false, true);

        if (! factureNumberSeq)
            throw error(strFmt("@SYS53911", "@GLS106861", "@SYS25194"));

        invoiceNumberSeq = NumberSeq::newGetNum(LedgerParameters::numRefTaxCorrectionFacture_RU());

        if (! invoiceNumberSeq)
        {
            dictType = new DictType(extendedTypeNum(FactureExternalId_TaxCorrection_RU));
            throw error(strFmt("@SYS53911", dictType.label(), "@SYS24097"));
        }

        select firstonly vendPayment
            exists join vendTransW
            where vendTransW.VendTrans          == vendPayment.RecId
               && vendTransW.VATPaymRefRecId_RU == _ledgerJournalTrans.VATPaymRefRecId_RU;

        if (vendPayment)
        {
            select firstonly FactureExternalId, RecId from jourTaxAgent
                where jourTaxAgent.Module                 == FactureModule_RU::TaxCorrectionSales_Vend
                   && jourTaxAgent.FactureType            == FactureType_RU::TaxCorrection
                   && jourTaxAgent.CustVendInvoiceAccount == vendPayment.AccountNum
                   && jourTaxAgent.VATTaxAgent
            exists join postingLog
                where postingLog.RecId          == jourTaxAgent.PostingLogRecId
                   && postingLog.Voucher        == jourTaxAgent.Voucher
                   && postingLog.TransDate      == jourTaxAgent.FactureDate
                   && postingLog.OffSetRecId    == vendPayment.RecId
                   && postingLog.PostingLogType == CustVendTransPostingLogType_RU::VATTaxAgent
                   && ! postingLog.Reversed;
        }

        jour.Module                 = FactureModule_RU::TaxCorrectionPurch;
        jour.FactureType            = FactureType_RU::TaxCorrection;
        jour.FactureId              = factureNumberSeq.num();
        jour.FactureExternalId      = jourTaxAgent.RecId             ?
                                      jourTaxAgent.FactureExternalId :
                                      invoiceNumberSeq.num();        
        jour.Voucher                = _ledgerJournalTrans.Voucher;
        jour.FactureDate            = _ledgerJournalTrans.TransDate;
        jour.FactureDate_External   = _ledgerJournalTrans.TransDate;
        jour.FactureTax             = _ledgerJournalTrans.amount();

        if (_ledgerJournalTrans.TaxBase_W)
        {
            jour.FactureAmount          = _ledgerJournalTrans.TaxBase_W;
        }
        else
        {
            jour.FactureAmount = CurrencyExchangeHelper::amount(conPeek(TaxData::amount2base_RU(_ledgerJournalTrans.TaxCode, _ledgerJournalTrans.TransDate, jour.FactureTax), 1), _ledgerJournalTrans.CurrencyCode);
        }
        jour.CurrencyCode           = _ledgerJournalTrans.CurrencyCode;
        jour.CustVendInvoiceAccount = _ledgerJournalTrans.vatTaxAgentVendAccount_RU;
        jour.Consignee              = "";
        jour.Consignor              = "";
        jour.NumberSequenceGroupId  = "";
        jour.OffSessionId           = "";
        jour.PrintInMST             = NoYes::No;
        jour.DocumentNum            = _ledgerJournalTrans.DocumentNum;
        jour.DocumentDate           = _ledgerJournalTrans.DocumentDate;
        jour.LanguageId             = VendTable::find(jour.CustVendInvoiceAccount).languageId();
        jour.LanguageId             = jour.LanguageId ? jour.LanguageId : infolog.language();
        jour.vatTaxAgent            = NoYes::Yes;

        jour.insert(_checkBooks);

        switch (TaxTable::find(_ledgerJournalTrans.TaxCode).TaxType_W)
        {
            case TaxType_W::VAT        :
                vatType = VATType_RU::Full;
                break;
            case TaxType_W::VATReduced :
                vatType = VATType_RU::Reduced;
                break;
            case TaxType_W::VATZero    :
                vatType = VATType_RU::Zero;
                break;
            default                    :
                vatType = VATType_RU::NonLiable;
                break;
        }

        trans = jour.newTrans(jour.FactureAmount,
                              jour.FactureTax,
                              0,
                              FactureLineType_RU::TaxCorrection,
                              _ledgerJournalTrans.ExchRate,
                              TaxData::percent(_ledgerJournalTrans.TaxCode, jour.FactureDate, jour.FactureAmount),
                              jour.FactureTax,
                              jour.FactureTax,
                              jour.FactureTax,
                              vatType,
                              SysLabel::labelId2String(literalStr("@GLS112885"),
                                                       jour.LanguageId),
                              _ledgerJournalTrans.DefaultDimension);

        trans.TaxGroup     = _ledgerJournalTrans.TaxGroup;
        trans.TaxItemGroup = _ledgerJournalTrans.TaxItemGroup;
        trans.TaxCode      = _ledgerJournalTrans.TaxCode;

        trans.InvoiceLineNum   = _ledgerJournalTrans.LineNum;
        trans.InvoiceId        = _ledgerJournalTrans.JournalNum;
        trans.MarkupRefRecId   = _ledgerJournalTrans.RecId;
        trans.MarkupRefTableId = _ledgerJournalTrans.TableId;
        trans.TransNotes       = trans.ItemName;
        trans.update();

        ttscommit;

        return jour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newVATPaymentFactureSettlement</Name>
				<Source><![CDATA[
    public static FactureJour_RU newVATPaymentFactureSettlement(CustVendTransPostingLog_RU   _postingLog,
                                                                       VendTrans                    _vendTrans,
                                                                       CustVendTransPostingLog_RU   _correctedFactureLog = null,
                                                                       boolean                      _checkBooks = true)
    {
        FactureJour_RU      jour, correctedJour;
        FactureJour_RU      jourTaxAgentPayment;        
        FactureTrans_RU     trans;
        NumberSeq           factureNumberSeq,
                            invoiceNumberSeq;
        DictType            dictType;
        TaxTrans            taxTrans;
        TaxTable            taxTable;
        VATType_RU          vatType;
        LedgerJournalTrans  ledgerJournalTrans;
        VendTrans           vendTransPayment;
        VendTrans_W         vendTransW;

        ttsbegin;

        factureNumberSeq = NumberSeq::newGetNum(VendParameters::numRefVendFactureId_RU(), false, true);

        if (! factureNumberSeq)
            throw error(strFmt("@SYS53911", "@GLS106861", "@SYS25194"));

        invoiceNumberSeq = NumberSeq::newGetNum(LedgerParameters::numRefTaxCorrectionFacture_RU());

        if (! invoiceNumberSeq)
        {
            dictType = new DictType(extendedTypeNum(FactureExternalId_TaxCorrection_RU));
            throw error(strFmt("@SYS53911", dictType.label(), "@SYS24097"));
        }

        vendTransPayment = VendTrans::find(_postingLog.OffSetRecId);

        vendTransW = vendTransPayment.vendTrans_W();
        if (vendTransW.VATPaymRefRecId_RU)
        {
            select firstonly ledgerJournalTrans
                where ledgerJournalTrans.VATPaymRefRecId_RU         == vendTransW.VATPaymRefRecId_RU
                   && ledgerJournalTrans.VATTaxAgentVendAccount_RU  == vendTransPayment.AccountNum;

            if (ledgerJournalTrans)
            {
                select firstonly FactureExternalId, RecId from jourTaxAgentPayment
                    where jourTaxAgentPayment.Module                 == FactureModule_RU::TaxCorrectionPurch
                       && jourTaxAgentPayment.FactureType            == FactureType_RU::TaxCorrection
                       && jourTaxAgentPayment.FactureDate            == ledgerJournalTrans.TransDate
                       && jourTaxAgentPayment.Voucher                == ledgerJournalTrans.Voucher
                       && jourTaxAgentPayment.CustVendInvoiceAccount == ledgerJournalTrans.vatTaxAgentVendAccount_RU
                       && jourTaxAgentPayment.VATTaxAgent
                exists join trans
                    where trans.FactureId       == jourTaxAgentPayment.FactureId
                       && trans.Module          == jourTaxAgentPayment.Module
                       && trans.MarkupRefRecId  == ledgerJournalTrans.RecId;
            }
        }

        jour.Module                 = FactureModule_RU::TaxCorrectionSales_Vend;
        jour.FactureType            = FactureType_RU::TaxCorrection;
        jour.FactureId              = factureNumberSeq.num();
        jour.FactureExternalId      = jourTaxAgentPayment.RecId             ?
                                      jourTaxAgentPayment.FactureExternalId :
                                      invoiceNumberSeq.num();
        jour.Voucher                = _postingLog.Voucher;
        jour.FactureDate            = _postingLog.TransDate;
        jour.FactureDate_External   = _postingLog.TransDate;
        jour.FactureAmount          = _postingLog.TaxBaseAmountCur;
        jour.FactureTax             = _postingLog.AmountCur;
        jour.CurrencyCode           = _vendTrans.CurrencyCode;
        jour.CustVendInvoiceAccount = _vendTrans.AccountNum;
        jour.Consignee              = "";
        jour.Consignor              = "";
        jour.NumberSequenceGroupId  = "";
        jour.OffSessionId           = "";
        jour.PrintInMST             = NoYes::No;
        jour.DocumentNum            = _vendTrans.DocumentNum;
        jour.DocumentDate           = _vendTrans.DocumentDate;
        jour.LanguageId             = VendTable::find(jour.CustVendInvoiceAccount).languageId();

        jour.LanguageId             = jour.LanguageId ? jour.LanguageId : infolog.language();

        jour.PostingLogRecId        = _postingLog.RecId;
        jour.vatTaxAgent            = NoYes::Yes;

        if (_postingLog.Correct && _correctedFactureLog.RecId)
        {
            select FactureDate, FactureExternalId from correctedJour
                where correctedJour.PostingLogRecId == _correctedFactureLog.RecId;

            jour.CorrectedFactureExternalId = correctedJour.FactureExternalId;
            jour.CorrectedFactureDate       = correctedJour.FactureDate;
            jour.CorrectedPeriod            = _postingLog.TransDate;
        }

        jour.insert(_checkBooks);

        select firstonly taxTrans
            where taxTrans.SourceTableId == _postingLog.TableId     &&
                  taxTrans.SourceRecId   == _postingLog.RecId       &&
                  taxTrans.TaxOrigin     != TaxOrigin::TaxReversed;

        taxTable = TaxTable::find(taxTrans.TaxCode);

        switch (taxTable.TaxType_W)
        {
            case TaxType_W::VAT        :
                vatType = VATType_RU::Full;
                break;
            case TaxType_W::VATReduced :
                vatType = VATType_RU::Reduced;
                break;
            case TaxType_W::VATZero    :
                vatType = VATType_RU::Zero;
                break;
            default                    :
                vatType = VATType_RU::NonLiable;
                break;
        }

        trans = jour.newTrans(taxTrans.SourceBaseAmountCur,
                              taxTrans.taxAmountCur_W(),
                              taxTable.TaxType_W == TaxType_W::Excise ? taxTrans.taxAmountCur_W(): 0,
                              FactureLineType_RU::TaxCorrection,
                              taxTrans.TaxAmountCur ? taxTrans.TaxAmount / taxTrans.TaxAmountCur * 100 : 0,
                              TaxData::percent(taxTable.TaxCode, _vendTrans.TransDate, taxTable.TaxBase),
                              taxTable.TaxType_W == TaxType_W::VATZero    ? taxTrans.taxAmountCur_W() : 0,
                              taxTable.TaxType_W == TaxType_W::VATReduced ? taxTrans.taxAmountCur_W() : 0,
                              taxTable.TaxType_W == TaxType_W::VAT        ? taxTrans.taxAmountCur_W() : 0,
                              vatType,
                              SysLabel::labelId2String(literalStr("@GLS112872"),
                                                       jour.LanguageId),
                              _vendTrans.DefaultDimension,
                              taxTrans.TaxBaseAmount,
                              taxTrans.TaxAmount,
                              taxTable.TaxType_W == TaxType_W::Excise     ? taxTrans.TaxAmount : 0,
                              taxTable.TaxType_W == TaxType_W::VATZero    ? taxTrans.TaxAmount : 0,
                              taxTable.TaxType_W == TaxType_W::VATReduced ? taxTrans.TaxAmount : 0,
                              taxTable.TaxType_W == TaxType_W::VAT        ? taxTrans.TaxAmount : 0);

        trans.ExciseValue  = taxTable.TaxType_W == TaxType_W::Excise                                  ?
                             TaxData::percent(taxTable.TaxCode, taxTrans.TransDate, taxTable.TaxBase) :
                             0;
        trans.TaxGroup     = taxTrans.TaxGroup;
        trans.TaxItemGroup = taxTrans.TaxItemGroup;
        trans.TaxCode      = trans.vatType == VATType_RU::NonLiable ? "" : taxTrans.TaxCode;

        select firstonly LineNum, JournalNum, RecId from ledgerJournalTrans
            where ledgerJournalTrans.Voucher   == vendTransPayment.Voucher   &&
                  ledgerJournalTrans.TransDate == vendTransPayment.TransDate &&
                  ! ledgerJournalTrans.vatPaymRefRecId_RU;

        trans.InvoiceLineNum   = ledgerJournalTrans.LineNum;
        trans.InvoiceId        = ledgerJournalTrans.JournalNum;
        trans.MarkupRefRecId   = ledgerJournalTrans.RecId;
        trans.MarkupRefTableId = ledgerJournalTrans.TableId;
        trans.TransNotes     = trans.ItemName;

        trans.update();

        ttscommit;

        return jour;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>