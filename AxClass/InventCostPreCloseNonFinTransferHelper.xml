<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventCostPreCloseNonFinTransferHelper</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>InventPreCloseNonFinTransferHelper</c> class manages the creation of a stored procedure
/// for inventory pre-closing of non-financial transfers.
/// </summary>
public class InventCostPreCloseNonFinTransferHelper
{
    protected const str PreCloseNonFinTransferSPName = 'sp_PreCloseNonFinTransfer';
    protected const str PreCloseNonFinTransferSPLockName = 'PreCloseNonFinTransferSPLock';

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>buildCreateOrAlterSPStmt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the stored procedure statement.
    /// </summary>
    /// <returns>
    /// The stored procedure statement as a string.
    /// </returns>
    private str buildCreateOrAlterSPStmt()
    {
        /*
    CREATE OR ALTER PROCEDURE [dbo].[sp_PreCloseNonFinTransfer]
        -- Output parameters
        @ErrorCode INT OUTPUT,
        @Partition BIGINT,
        @DataAreaId NVARCHAR (4),
        @EcoResProduct BIGINT,
        @ItemId NVARCHAR (20),
        @InventClosing BIGINT,
        @InventClosingTransDate DATE,
        @IsInventLocationIdFinancial INT,
        @IsWMSLocationIdFinancial INT,
        @IsWMSPalletIdFinancial INT,
        @IsInventStatusFinancial INT,
        @IsLicencePlateIdFinancial INT,
        @IsInventBatchIdFinancial INT,
        @IsInventSerialIdFinancial INT,
        @IsInventProfileId_RUFinancial INT,
        @IsInventOwnerId_RUFinancial INT,
        @IsInventGtdId_RUFinancial INT,
        @IsConfigIdFinancial INT,
        @IsInventSizeIdFinancial INT,
        @IsInventColorIdFinancial INT,
        @IsInventStyleIdFinancial INT,
        @IsInventVersionIdFinancial INT
    AS

    -- Without nocount on the procedure will return number of affected rows in the result set which is
    -- harmful to performance and requires us to adjust field retrieval when calling the stored procedure
    SET NOCOUNT ON;

    DECLARE @DeadLockRetries INT;
    DECLARE @ProcessedRows BIGINT;

    SET @DeadLockRetries = 5

    WHILE ( @DeadLockRetries > 0 )
    BEGIN
        BEGIN TRY
            CREATE TABLE
                #InventNonFinancialTransfers
            (
                InventTransOrigin BIGINT
            );

            CREATE CLUSTERED INDEX IX_1 ON #InventNonFinancialTransfers
            (
                InventTransOrigin
            );

            BEGIN TRAN;

            WITH
                InventTransOriginTransfersCTE
                (
                    InventTransOriginTransfer,
                    InventTransOrigin,
                    IssueInventTransOrigin,
                    ReceiptInventTransOrigin,
                    ReferenceCategory
                )
                AS
                (
                    SELECT
                        InventTransOriginTransfersPivoted.InventTransOriginTransfer,
                        InventTransOriginTransfersPivoted.InventTransOrigin,
                        InventTransOriginTransfersPivoted.IssueInventTransOrigin,
                        InventTransOriginTransfersPivoted.ReceiptInventTransOrigin,
                        InventTransOriginTransfersPivoted.ReferenceCategory
                    FROM
                        INVENTTRANSORIGINTRANSFER InventTransOriginTransfer
                        CROSS APPLY
                        (
                            VALUES
                                (InventTransOriginTransfer.RECID, InventTransOriginTransfer.ISSUEINVENTTRANSORIGIN, InventTransOriginTransfer.ISSUEINVENTTRANSORIGIN, 0, InventTransOriginTransfer.REFERENCECATEGORY),
                                (InventTransOriginTransfer.RECID, InventTransOriginTransfer.RECEIPTINVENTTRANSORIGIN, 0, InventTransOriginTransfer.RECEIPTINVENTTRANSORIGIN, InventTransOriginTransfer.REFERENCECATEGORY)
                        )
                        InventTransOriginTransfersPivoted (InventTransOriginTransfer, InventTransOrigin, IssueInventTransOrigin, ReceiptInventTransOrigin, ReferenceCategory)
                    WHERE
                        InventTransOriginTransfer.PARTITION = @Partition AND
                        InventTransOriginTransfer.ECORESPRODUCT = @EcoResProduct AND
                        InventTransOriginTransfer.NONFINANCIALTRANSFINVENTCLOSINGRECID = 0
                ),
                InventTransBalanceCTE
                (
                    InventTransOriginTransfer,
                    IssueInventTransOrigin,
                    ReceiptInventTransOrigin,
                    Qty,
                    CostAmountPosted,
                    QtySettled,
                    CostAmountSettled,
                    CostAmountAdjustment,
                    VoucherPhysical,
                    InventSiteId,
                    InventLocationId,
                    WMSLocationId,
                    WMSPalletId,
                    InventStatusId,
                    LicensePlateId,
                    InventBatchId,
                    InventSerialId,
                    InventProfileId_RU,
                    InventOwnerId_RU,
                    InventGTDId_RU,
                    ConfigId,
                    InventSizeId,
                    InventColorId,
                    InventStyleId,
                    InventVersionId
                )
                AS
                (
                    SELECT
                        InventTransOriginTransfersCTE.InventTransOriginTransfer,
                        InventTransOriginTransfersCTE.IssueInventTransOrigin,
                        InventTransOriginTransfersCTE.ReceiptInventTransOrigin,
                        inventTrans.QTY,
                        inventTrans.COSTAMOUNTPOSTED,
                        inventTrans.QTYSETTLED,
                        inventTrans.COSTAMOUNTSETTLED,
                        inventTrans.COSTAMOUNTADJUSTMENT,
                        inventTrans.VOUCHERPHYSICAL,
                        CASE
                            WHEN @IsInventLocationIdFinancial = 1 THEN inventDim.INVENTLOCATIONID ELSE ''
                        END,
                        CASE
                            WHEN @IsWMSLocationIdFinancial = 1 THEN inventDim.WMSLOCATIONID ELSE ''
                        END,
                        CASE
                            WHEN @IsWMSPalletIdFinancial = 1 THEN inventDim.WMSPALLETID ELSE ''
                        END,
                        CASE
                            WHEN @IsInventStatusFinancial = 1 THEN inventDim.INVENTSTATUSID ELSE ''
                        END,
                        CASE
                            WHEN @IsLicencePlateIdFinancial = 1 THEN inventDim.LICENSEPLATEID ELSE ''
                        END,
                        CASE
                            WHEN @IsInventBatchIdFinancial = 1 THEN inventDim.INVENTBATCHID ELSE ''
                        END,
                        CASE
                            WHEN @IsInventSerialIdFinancial = 1 THEN inventDim.INVENTSERIALID ELSE ''
                        END,
                        CASE
                            WHEN @IsInventProfileId_RUFinancial = 1 THEN inventDim.INVENTPROFILEID_RU ELSE ''
                        END,
                        CASE
                            WHEN @IsInventOwnerId_RUFinancial = 1 THEN inventDim.INVENTOWNERID_RU ELSE ''
                        END,
                        CASE
                            WHEN @IsInventGtdId_RUFinancial = 1 THEN inventDim.INVENTGTDID_RU ELSE ''
                        END,
                        CASE
                            WHEN @IsConfigIdFinancial = 1 THEN inventDim.CONFIGID ELSE ''
                        END,
                        CASE
                            WHEN @IsInventSizeIdFinancial = 1 THEN inventDim.INVENTSIZEID ELSE ''
                        END,
                        CASE
                            WHEN @IsInventColorIdFinancial = 1 THEN inventDim.INVENTCOLORID ELSE ''
                        END,
                        CASE
                            WHEN @IsInventStyleIdFinancial = 1 THEN inventDim.INVENTSTYLEID ELSE ''
                        END,
                        CASE
                            WHEN @IsInventVersionIdFinancial = 1 THEN inventDim.INVENTVERSIONID ELSE ''
                        END
                    FROM
                        INVENTTRANS inventTrans WITH (INDEX([I_177OPENITEMIDX])),
                        INVENTDIM inventDim,
                        InventTransOriginTransfersCTE InventTransOriginTransfersCTE
                    WHERE
                        inventTrans.PARTITION = @Partition AND
                        inventTrans.DATAAREAID = @DataAreaId AND
                        inventTrans.VALUEOPEN = 1 AND
                        inventTrans.ITEMID = @ItemId AND
                        inventTrans.RETURNINVENTTRANSORIGIN = 0 AND
                        inventTrans.INVENTTRANSORIGIN = InventTransOriginTransfersCTE.InventTransOrigin AND
                        (
                            (
                                (((InventTransOriginTransfersCTE.ReferenceCategory = 21 AND inventTrans.QTY > 0) OR
                                  (InventTransOriginTransfersCTE.ReferenceCategory = 22 AND inventTrans.QTY < 0)) AND
                                inventTrans.MARKINGREFINVENTTRANSORIGIN <> 0)
                            ) OR
                            (
                                ((InventTransOriginTransfersCTE.ReferenceCategory = 201 OR
                                  InventTransOriginTransfersCTE.ReferenceCategory = 6 OR
                                  InventTransOriginTransfersCTE.ReferenceCategory = 14 OR
                                  (InventTransOriginTransfersCTE.ReferenceCategory = 21 AND inventTrans.QTY < 0) OR
                                  (InventTransOriginTransfersCTE.ReferenceCategory = 22 AND inventTrans.QTY > 0)) AND
                                inventTrans.MARKINGREFINVENTTRANSORIGIN = 0)
                            )
                        ) AND
                        inventTrans.PARTITION = inventDim.PARTITION AND
                        inventTrans.DATAAREAID = inventDim.DATAAREAID AND
                        inventTrans.INVENTDIMID = inventDim.INVENTDIMID
                ),
                InventTransOriginTransfersBalancedCTE
                (
                    IssueInventTransOrigin,
                    ReceiptInventTransOrigin
                )
                AS
                (
                    SELECT
                        MAX(InventTransBalanceCTE.IssueInventTransOrigin),
                        MAX(InventTransBalanceCTE.ReceiptInventTransOrigin)
                    FROM
                        InventTransBalanceCTE     InventTransBalanceCTE
                    GROUP BY
                        InventTransBalanceCTE.InventTransOriginTransfer,
                        InventTransBalanceCTE.VoucherPhysical,
                        CASE
                            WHEN @isCONFIGIDFinancial = 1 THEN InventTransBalanceCTE.CONFIGID
                        END,
                        CASE
                            WHEN @isINVENTSIZEIDFinancial = 1 THEN InventTransBalanceCTE.INVENTSIZEID
                        END,
                        CASE
                            WHEN @isINVENTCOLORIDFinancial = 1 THEN InventTransBalanceCTE.INVENTCOLORID
                        END,
                        CASE
                            WHEN @isINVENTSTYLEIDFinancial = 1 THEN InventTransBalanceCTE.INVENTSTYLEID
                        END,
                        CASE
                            WHEN @isINVENTVERSIONIDFinancial = 1 THEN InventTransBalanceCTE.INVENTVERSIONID
                        END,
                        CASE
                            WHEN @isINVENTSITEIDFinancial = 1 THEN InventTransBalanceCTE.INVENTSITEID
                        END,
                        CASE
                            WHEN @isINVENTLOCATIONIDFinancial = 1 THEN InventTransBalanceCTE.INVENTLOCATIONID
                        END,
                        CASE
                            WHEN @isWMSLOCATIONIDFinancial = 1 THEN InventTransBalanceCTE.WMSLOCATIONID
                        END,
                        CASE
                            WHEN @isWMSPALLETIDFinancial = 1 THEN InventTransBalanceCTE.WMSPALLETID
                        END,
                        CASE
                            WHEN @isINVENTSTATUSIDFinancial = 1 THEN InventTransBalanceCTE.INVENTSTATUSID
                        END,
                        CASE
                            WHEN @isLICENSEPLATEIDFinancial = 1 THEN InventTransBalanceCTE.LICENSEPLATEID
                        END,
                        CASE
                            WHEN @isINVENTBATCHIDFinancial = 1 THEN InventTransBalanceCTE.INVENTBATCHID
                        END,
                        CASE
                            WHEN @isINVENTSERIALIDFinancial = 1 THEN InventTransBalanceCTE.INVENTSERIALID
                        END,
                        CASE
                            WHEN @isINVENTPROFILEID_RUFinancial = 1 THEN InventTransBalanceCTE.INVENTPROFILEID_RU
                        END,
                        CASE
                            WHEN @isINVENTOWNERID_RUFinancial = 1 THEN InventTransBalanceCTE.INVENTOWNERID_RU
                        END,
                        CASE
                            WHEN @isINVENTGTDID_RUFinancial = 1 THEN InventTransBalanceCTE.INVENTGTDID_RU
                        END
                    HAVING
                        SUM(InventTransBalanceCTE.Qty) = 0 AND
                        SUM(InventTransBalanceCTE.CostAmountPosted) = 0 AND
                        SUM(ABS(InventTransBalanceCTE.QtySettled)) = 0 AND
                        SUM(ABS(InventTransBalanceCTE.CostAmountSettled)) = 0 AND
                        SUM(ABS(InventTransBalanceCTE.CostAmountAdjustment)) = 0
                )
                UPDATE
                    INVENTTRANS
                SET
                    VALUEOPEN = 0,
                    DATECLOSED = @InventClosingTransDate,
                    NONFINANCIALTRANSFERINVENTCLOSING = @InventClosing,
                    MARKINGREFINVENTTRANSORIGIN = 0
                OUTPUT
                    inserted.InventTransOrigin
                INTO
                    #InventNonFinancialTransfers
                WHERE
                    PARTITION = @Partition AND
                    DATAAREAID = @DataAreaId AND
                    VALUEOPEN = 1 AND
                    ITEMID = @ItemId AND
                    RETURNINVENTTRANSORIGIN = 0 AND
                    COSTAMOUNTADJUSTMENT = 0 AND
                    STATUSRECEIPT >= 0 AND
                    STATUSRECEIPT <= 1 AND
                    STATUSISSUE >= 0 AND
                    STATUSISSUE <= 1 AND
                    DATEFINANCIAL <= @InventClosingTransDate AND
                    INVENTTRANSORIGIN IN
                    (
                        SELECT
                            InventTransOriginTransfersBalancedPivoted.InventTransOrigin
                        FROM
                            InventTransOriginTransfersBalancedCTE InventTransOriginTransfersBalancedCTE
                            CROSS APPLY
                            (
                                VALUES
                                (InventTransOriginTransfersBalancedCTE.IssueInventTransOrigin),
                                (InventTransOriginTransfersBalancedCTE.ReceiptInventTransOrigin)
                            ) InventTransOriginTransfersBalancedPivoted (InventTransOrigin)
                    )
                OPTION (MAXDOP 1)

            SET @processedRows = @@ROWCOUNT

            IF (@processedRows <> 0)
            BEGIN

                UPDATE
                    INVENTTRANSORIGINTRANSFER
                SET
                    NONFINANCIALTRANSFINVENTCLOSINGRECID = @InventClosing
                WHERE
                    PARTITION = @Partition AND
                    ECORESPRODUCT = @EcoResProduct AND
                    NONFINANCIALTRANSFINVENTCLOSINGRECID = 0 AND
                    ISSUEINVENTTRANSORIGIN IN
                    (
                        SELECT
                            DISTINCT(InventTransOrigin)
                        FROM
                            #InventNonFinancialTransfers
                    ) -- Feature toggle start
                    AND
                    NOT EXISTS
                    (
                        SELECT
                            1
                        FROM
                            INVENTTRANS
                        WHERE
                            (
                                (
                                    INVENTTRANS.INVENTTRANSORIGIN = ISSUEINVENTTRANSORIGIN AND
                                    INVENTTRANS.STATUSISSUE > 0
                                ) OR
                                (
                                    INVENTTRANS.INVENTTRANSORIGIN = RECEIPTINVENTTRANSORIGIN AND
                                    INVENTTRANS.STATUSRECEIPT > 0
                                )
                            ) AND

                            INVENTTRANS.VALUEOPEN = 1 AND
                            INVENTTRANS.PARTITION = @Partition AND
                            INVENTTRANS.DATAAREAID = @DataAreaId
                    )
                    -- Feature toggle end
                OPTION (MAXDOP 1)

            END

        COMMIT TRAN

        SET @ErrorCode = 0
        SET @DeadlockRetries = 0

        END TRY
        BEGIN CATCH
            SET @ErrorCode = 1

            IF ( ERROR_NUMBER() = 1205 )
            BEGIN
                SET @DeadlockRetries = @DeadlockRetries - 1
            END
            ELSE
            BEGIN
                SET @DeadlockRetries = 0
            END
        END CATCH
    END

    -- See the beginning of the procedure for rationale of nocount.
    SET NOCOUNT OFF;
    */

        // Input parameter
        const str Partition = '@Partition';
        const str DataAreaId = '@DataAreaId';
        const str EcoResProduct = '@EcoResProduct';
        const str ItemId = '@ItemId';
        const str InventClosing = '@InventClosing';
        const str InventClosingTransDate = '@InventClosingTransDate';

        // Output parameters
        const str ErrorCode = '@ErrorCode';

        // Temp Table
        const str InventNonFinancialTransfersTableName = '#INVENTNONFINANCIALTRANSFERS';
        const str InventNonFinancialTransfers = 'INVENTNONFINANCIALTRANSFERS';
        const str InventTransOriginFieldName = 'INVENTTRANSORIGIN';

        // Common table expressions
        const str InventTransOriginTransferCTEName = 'INVENTTRANSORIGINTRANSFERSCTE';
        const str InventTransOriginTransferFieldName = 'INVENTTRANSORIGINTRANSFER';
        const str IssueInventTransOriginFieldName = 'ISSUEINVENTTRANSORIGIN';
        const str ReceiptInventTransOriginFieldName = 'RECEIPTINVENTTRANSORIGIN';
        const str ReferenceCategoryFieldName = 'REFERENCECATEGORY';
        const str InventTransOriginTransfer = 'INVENTTRANSORIGINTRANSFER';
        const str InventTransOriginTransferPivoted = 'INVENTTRANSORIGINTRANSFERSPIVOTED';

        const str InventTransBalanceCTEName = 'INVENTTRANSBALANCECTE';
        const str QtyFieldName = 'QTY';
        const str CostAmountPostedFieldName = 'COSTAMOUNTPOSTED';
        const str QtySettledFieldName = 'QTYSETTLED';
        const str CostAmountSettledFieldName = 'COSTAMOUNTSETTLED';
        const str CostAmountAdjustmentFieldName = 'COSTAMOUNTADJUSTMENT';
        const str InventTrans = 'INVENTTRANS';
        const str InventDim = 'INVENTDIM';
        const str VoucherPhysical = 'VOUCHERPHYSICAL';

        const str InventTransOriginTransfersBalancedCTEName = 'INVENTTRANSORIGINTRANSFERSBALANCEDCTE';
        const str InventTransOriginTransfersBalancedPivoted = 'INVENTTRANSORIGINTRANSFERSBALANCEDPIVOTED';

        SysSqlSystem    sqlSystem = new SysSqlSystem();

        SysDictTable    dictInventTrans = new SysDictTable(tableNum(InventTrans));
        SysDictTable    dictInventTransOrigin = new SysDictTable(tableNum(InventTransOrigin));
        SysDictTable    dictInventTransOriginTransfer = new SysDictTable(tableNum(InventTransOriginTransfer));
        SysDictTable    dictInventDim = new SysDictTable(tableNum(InventDim));
        SysDictTable    dictSystemSequences = new SysDictTable(tableNum(SystemSequences));
        SysDictTable    dictInventClosingNonFinancialInventTrans = new SysDictTable(tableNum(InventClosingNonFinancialInventTrans));
        SysDictType     dictDataAreaId = new SysDictType(extendedTypeNum(DataAreaId));
        SysDictType     dictItemId = new SysDictType(extendedTypeNum(ItemId));

        ListEnumerator  enabledDimsEnumerator = this.enabledDimensions().getEnumerator();
        FieldId         dimFieldId;
        str             dimFieldName;

        InventDimMetaDataCache::clearCache(); //in some cases the cache is not updated before sync making below SP

        str ret = strFmt('CREATE OR ALTER PROCEDURE [dbo].[%1]\n', PreCloseNonFinTransferSPName);
        ret += '\t-- Output parameters\n';
        ret += strFmt('\t%1 INT OUTPUT\n,',             ErrorCode);
        ret += strFmt('\t%1 BIGINT,\n',                 Partition);
        ret += strFmt('\t%1 NVARCHAR (%2),\n',          DataAreaId, dictDataAreaId.stringLen());
        ret += strFmt('\t%1 BIGINT,\n',                 EcoResProduct);
        ret += strFmt('\t%1 NVARCHAR (%2),\n',          ItemId, dictItemId.stringLen());
        ret += strFmt('\t%1 BIGINT,\n',                 InventClosing);
        ret += strFmt('\t%1 DATE',                      InventClosingTransDate);

        // Generate parameters for supported dimensions
        enabledDimsEnumerator.reset();
        while (enabledDimsEnumerator.moveNext())
        {
            ret += ',\n';
            [dimFieldId, dimFieldName] = enabledDimsEnumerator.current();
            ret += strFmt('\t%1 INT = 0', this.dimensionParm(dimFieldName));
        }

        ret += '\n ';
        ret += @'AS

    -- Without nocount on the procedure will return number of affected rows in the result set which is
    -- harmful to performance and requires us to adjust field retrieval when calling the stored procedure
    SET NOCOUNT ON;

    DECLARE @DeadLockRetries INT;
    DECLARE @ProcessedRows BIGINT;

    SET @DeadLockRetries = 5

    WHILE ( @DeadLockRetries > 0 )
    BEGIN

        BEGIN TRAN;

        BEGIN TRY
        ';

        ret += '\tCREATE TABLE\n';
        ret += strFmt('\t\t\t%1',InventNonFinancialTransfersTableName);
        ret += strFmt(@'
            (
                %1 BIGINT
            );', InventTransOriginFieldName);

        ret += strFmt(@'

            CREATE CLUSTERED INDEX IX_1 ON %1
            (
                %2
            );', InventNonFinancialTransfersTableName, InventTransOriginFieldName);

        ret += strFmt(@'

            WITH
                %1
                (
                    %2,
                    %3,
                    %4,
                    %5,
                    %6
                )',
                InventTransOriginTransferCTEName,
                InventTransOriginTransferFieldName,
                InventTransOriginFieldName,
                IssueInventTransOriginFieldName,
                ReceiptInventTransOriginFieldName,
                ReferenceCategoryFieldName);

        ret += strFmt(@'
                AS
                (
                    SELECT
                        %1.%2,
                        %1.%3,
                        %1.%4,
                        %1.%5,
                        %1.%6
                    FROM
                        %7 %8
                        CROSS APPLY
                        (
                            VALUES
                                (%8.%9, %8.%10, %8.%10, 0, %8.%11),
                                (%8.%9, %8.%12, 0, %8.%12, %8.%11)
                        )
                        %1 (%2, %3, %4, %5, %6)
                    WHERE
                        %8.%13 = %14 AND
                        %8.%15 = %16 AND
                        %8.%17 = 0
                ),',
            InventTransOriginTransferPivoted,
            InventTransOriginTransferFieldName,
            InventTransOriginFieldName,
            IssueInventTransOriginFieldName,
            ReceiptInventTransOriginFieldName,
            ReferenceCategoryFieldName,
            dictInventTransOriginTransfer.name(DbBackend::Sql),
            InventTransOriginTransfer,
            dictInventTransOriginTransfer.fieldName(fieldnum(InventTransOriginTransfer, RecId), DbBackend::Sql),
            dictInventTransOriginTransfer.fieldName(fieldnum(InventTransOriginTransfer, IssueInventTransOrigin), DbBackend::Sql),
            dictInventTransOriginTransfer.fieldName(fieldnum(InventTransOriginTransfer, ReferenceCategory), DbBackend::Sql),
            dictInventTransOriginTransfer.fieldName(fieldnum(InventTransOriginTransfer, ReceiptInventTransOrigin), DbBackend::Sql),
            dictInventTransOriginTransfer.fieldName(fieldnum(InventTransOriginTransfer, Partition), DbBackend::Sql),
            Partition,
            dictInventTransOriginTransfer.fieldName(fieldnum(InventTransOriginTransfer, Product), DbBackend::Sql),
            EcoResProduct,
            dictInventTransOriginTransfer.fieldName(fieldnum(InventTransOriginTransfer, NonFinancialTransfInventClosingRecId), DbBackend::Sql));

        ret += strFmt(@'
                %1
                (
                    %2,
                    %3,
                    %4,
                    %5,
                    %6,
                    %7,
                    %8,
                    %9,
                    %10',
            InventTransBalanceCTEName,
            InventTransOriginTransferFieldName,
            IssueInventTransOriginFieldName,
            ReceiptInventTransOriginFieldName,
            QtyFieldName,
            CostAmountPostedFieldName,
            QtySettledFieldName,
            CostAmountSettledFieldName,
            CostAmountAdjustmentFieldName,
            VoucherPhysical);

        // Generate fieldlist for supported dimensions
        enabledDimsEnumerator.reset();
        while (enabledDimsEnumerator.moveNext())
        {
            ret += ', \n';
            [dimFieldId, dimFieldName] = enabledDimsEnumerator.current();
            ret += strFmt('\t\t\t\t%1', this.dimensionField(dimFieldName));
        }

        ret += strFmt(@"
                )
                AS
                (
                    SELECT
                        %1.%3,
                        %1.%4,
                        %1.%5,
                        %2.%6,
                        %2.%7,
                        %2.%8,
                        %2.%9,
                        %2.%10,
                        %2.%11",
                InventTransOriginTransferCTEName,
                InventTrans,
                InventTransOriginTransferFieldName,
                IssueInventTransOriginFieldName,
                ReceiptInventTransOriginFieldName,
                dictInventTrans.fieldName(fieldnum(InventTrans, Qty), DbBackend::Sql),
                dictInventTrans.fieldName(fieldnum(InventTrans, CostAmountPosted), DbBackend::Sql),
                dictInventTrans.fieldName(fieldnum(InventTrans, QtySettled), DbBackend::Sql),
                dictInventTrans.fieldName(fieldnum(InventTrans, CostAmountSettled), DbBackend::Sql),
                dictInventTrans.fieldName(fieldnum(InventTrans, CostAmountAdjustment), DbBackend::Sql),
                dictInventTrans.fieldName(fieldNum(InventTrans, VoucherPhysical), DbBackend::Sql));

        // Generate selectlist for supported dimensions
        enabledDimsEnumerator.reset();
        while (enabledDimsEnumerator.moveNext())
        {
            ret += ', \n';
            [dimFieldId, dimFieldName] = enabledDimsEnumerator.current();
            ret += strFmt(@"
                        CASE
                            WHEN %1 = 1 THEN %2.%3 ELSE ''
                        END",
                        this.dimensionParm(dimFieldName),
                        InventDim,
                        this.dimensionField(dimFieldName));
        }

        ret += strFmt(@"
                    FROM
                        %1 %2 WITH (INDEX([%3])),
                        %4 %5,
                        %6 %6",
                dictInventTrans.name(DbBackend::Sql),
                InventTrans,
                dictInventTrans.indexName(indexNum(InventTrans, OpenItemIdx), DbBackend::Sql),
                dictInventDim.name(DbBackend::Sql),
                InventDim,
                InventTransOriginTransferCTEName);

        ret += strFmt(@'
                    WHERE
                        %1.%2 = %3 AND
                        %1.%4 = %5 AND
                        %1.%6 = 1 AND
                        %1.%7 = %8 AND
                        %1.%9 = 0 AND
                        %1.%10 = %11.%12 AND
                        (
                            (
                                (((%11.%13 = %14 AND %1.%15 > 0) OR
                                  (%11.%13 = %16 AND %1.%15 < 0)) AND
                                %1.%17 <> 0)
                            ) OR
                            (
                                ((%11.%13 = %18 OR
                                  %11.%13 = %19 OR
                                  %11.%13 = %20 OR
                                  (%11.%13 = %14 AND %1.%15 < 0) OR
                                  (%11.%13 = %16 AND %1.%15 > 0)) AND
                                %1.%17 = 0)
                            )
                        ) AND
                        %1.%2 = %21.%22 AND
                        %1.%4 = %21.%23 AND
                        %1.%24 = %21.%25
                ),',
                InventTrans,
                dictInventTrans.fieldName(fieldnum(InventTrans, Partition), DbBackend::Sql),
                Partition,
                dictInventTrans.fieldName(fieldnum(InventTrans, DataAreaId), DbBackend::Sql),
                DataAreaId,
                dictInventTrans.fieldName(fieldnum(InventTrans, ValueOpen), DbBackend::Sql),
                dictInventTrans.fieldName(fieldnum(InventTrans, ItemId), DbBackend::Sql),
                ItemId,
                dictInventTrans.fieldName(fieldnum(InventTrans, ReturnInventTransOrigin), DbBackend::Sql),
                dictInventTrans.fieldName(fieldnum(InventTrans, InventTransOrigin), DbBackend::Sql),
                InventTransOriginTransferCTEName,
                InventTransOriginFieldName,
                ReferenceCategoryFieldName,
                int2str(enum2int(InventTransType::TransferOrderShip)),
                dictInventTrans.fieldName(fieldnum(InventTrans, Qty), DbBackend::Sql),
                int2str(enum2int(InventTransType::TransferOrderReceive)),
                dictInventTrans.fieldName(fieldnum(InventTrans, MarkingRefInventTransOrigin), DbBackend::Sql),
                int2str(enum2int(InventTransType::WHSWork)),
                int2str(enum2int(InventTransType::InventTransfer)),
                int2str(enum2int(InventTransType::WMSTransport)),
                InventDim,
                dictInventDim.fieldName(fieldnum(InventDim, Partition), DbBackend::Sql),
                dictInventDim.fieldName(fieldnum(InventDim, DataAreaId), DbBackend::Sql),
                dictInventTrans.fieldName(fieldnum(InventTrans, InventDimId), DbBackend::Sql),
                dictInventDim.fieldName(fieldnum(InventDim, InventDimId), DbBackend::Sql));

        ret += strFmt(@'
                %1
                (
                    %2,
                    %3
                )
                AS
                (
                    SELECT
                        MAX(%4.%2),
                        MAX(%4.%3)
                    FROM
                        %4     %4
                    GROUP BY
                        %4.%5,
                        %4.%6',
                InventTransOriginTransfersBalancedCTEName,
                IssueInventTransOriginFieldName,
                ReceiptInventTransOriginFieldName,
                InventTransBalanceCTEName,
                InventTransOriginTransferFieldName,
                VoucherPhysical);

        // Generate groupby list for supported dimensions
        enabledDimsEnumerator.reset();
        while (enabledDimsEnumerator.moveNext())
        {
            [dimFieldId, dimFieldName] = enabledDimsEnumerator.current();
            ret += strFmt(@",
                        CASE
                            WHEN %1 = 1 THEN %2.%3
                        END",
                        this.dimensionParm(dimFieldName),
                        InventTransBalanceCTEName,
                        this.dimensionField(dimFieldName));
        }

        ret += strFmt(@'
                    HAVING
                        SUM(%1.%2) = 0 AND
                        SUM(%1.%3) = 0 AND
                        SUM(ABS(%1.%4)) = 0 AND
                        SUM(ABS(%1.%5)) = 0 AND
                        SUM(ABS(%1.%6)) = 0
                )',
            InventTransBalanceCTEName,
            QtyFieldName,
            CostAmountPostedFieldName,
            QtySettledFieldName,
            CostAmountSettledFieldName,
            CostAmountAdjustmentFieldName);

        ret += strFmt(@'
                UPDATE
                    %1
                SET
                    %2 = 0,
                    %3 = %4,
                    %5 = %6,
                    %29 = 0
                OUTPUT
                    inserted.%24
                INTO
                    %28
                WHERE
                    %7 = %8 AND
                    %9 = %10 AND
                    %2 = 1 AND
                    %11 = %12 AND
                    %13 = 0 AND
                    %14 = 0 AND
                    %15 >= %16 AND
                    %15 <= %17 AND
                    %18 >= %19 AND
                    %18 <= %20 AND
                    %21 <= %4 AND
                    %22 IN
                    (
                        SELECT
                            %23.%24
                        FROM
                            %25 %25
                            CROSS APPLY
                            (
                                VALUES
                                (%25.%26),
                                (%25.%27)
                            ) %23 (%24)
                    )
                OPTION (MAXDOP 1)',
            dictInventTrans.name(DbBackend::Sql),
            dictInventTrans.fieldName(fieldnum(InventTrans, ValueOpen), DbBackend::Sql),
            dictInventTrans.fieldName(fieldnum(InventTrans, DateClosed), DbBackend::Sql),
            InventClosingTransDate,
            dictInventTrans.fieldName(fieldnum(InventTrans, NonFinancialTransferInventClosing), DbBackend::Sql),
            InventClosing,
            dictInventTrans.fieldName(fieldnum(InventTrans, Partition), DbBackend::Sql),
            Partition,
            dictInventTrans.fieldName(fieldnum(InventTrans, DataAreaId), DbBackend::Sql),
            DataAreaId,
            dictInventTrans.fieldName(fieldnum(InventTrans, ItemId), DbBackend::Sql),
            ItemId,
            dictInventTrans.fieldName(fieldnum(InventTrans, ReturnInventTransOrigin), DbBackend::Sql),
            dictInventTrans.fieldName(fieldnum(InventTrans, CostAmountAdjustment), DbBackend::Sql),
            dictInventTrans.fieldName(fieldnum(InventTrans, StatusReceipt), DbBackend::Sql),
            int2str(enum2int(StatusReceipt::None)),
            int2str(enum2int(StatusReceipt::Purchased)),
            dictInventTrans.fieldName(fieldnum(InventTrans, StatusIssue), DbBackend::Sql),
            int2str(enum2int(StatusIssue::None)),
            int2str(enum2int(StatusIssue::Sold)),
            dictInventTrans.fieldName(fieldnum(InventTrans, DateFinancial), DbBackend::Sql),
            dictInventTrans.fieldName(fieldnum(InventTrans, InventTransOrigin), DbBackend::Sql),
            InventTransOriginTransfersBalancedPivoted,
            InventTransOriginFieldName,
            InventTransOriginTransfersBalancedCTEName,
            IssueInventTransOriginFieldName,
            ReceiptInventTransOriginFieldName,
            InventNonFinancialTransfersTableName,
            dictInventTrans.fieldName(fieldNum(InventTrans, MarkingRefInventTransOrigin), DbBackend::Sql));

        ret += @'

            SET @processedRows = @@ROWCOUNT

            IF (@processedRows <> 0)
            BEGIN
        ';

        if (FeatureStateProvider::isFeatureEnabled(InventCostPreCloseNonFinSkipPartialTransferFlight::instance()))
        {
            ret += strFmt(@'
                UPDATE
                    %1
                SET
                    %2 = %3
                WHERE
                    %4 = %5 AND
                    %6 = %7 AND
                    %8 = 0 AND
                    %9 IN
                    (
                        SELECT
                            DISTINCT(%10)
                        FROM
                            %11
                    ) AND
                    NOT EXISTS
                    (
                        SELECT
                            1
                        FROM
                            %12
                        WHERE
                            (
                                (
                                    %12.%13 = %9 AND
                                    %12.%18 > 0
                                ) OR
                                (
                                    %12.%13 = %19 AND
                                    %12.%20 > 0
                                )
                            ) AND
                            %12.%14 = 1 AND
                            %12.%15 = %5 AND
                            %12.%16 = %17
                    )
                OPTION (MAXDOP 1)',
            dictInventTransOriginTransfer.name(DbBackend::Sql),
            dictInventTransOriginTransfer.fieldName(fieldnum(InventTransOriginTransfer, NonFinancialTransfInventClosingRecId), DbBackend::Sql),
            InventClosing,
            dictInventTransOriginTransfer.fieldName(fieldnum(InventTransOriginTransfer, Partition), DbBackend::Sql),
            Partition,
            dictInventTransOriginTransfer.fieldName(fieldnum(InventTransOriginTransfer, Product), DbBackend::Sql),
            EcoResProduct,
            dictInventTransOriginTransfer.fieldName(fieldnum(InventTransOriginTransfer, NonFinancialTransfInventClosingRecId), DbBackend::Sql),
            dictInventTransOriginTransfer.fieldName(fieldnum(InventTransOriginTransfer, IssueInventTransOrigin), DbBackend::Sql),
            InventTransOriginFieldName,
            InventNonFinancialTransfersTableName,
            InventTrans,
            dictInventTrans.fieldName(fieldNum(InventTrans, InventTransOrigin), DbBackend::Sql),
            dictInventTrans.fieldName(fieldNum(InventTrans, ValueOpen), DbBackend::Sql),
            dictInventTrans.fieldName(fieldNum(InventTrans, Partition), DbBackend::Sql),
            dictInventTrans.fieldName(fieldNum(InventTrans, DataAreaId), DbBackend::Sql),
            DataAreaId,
            dictInventTrans.fieldName(fieldNum(InventTrans, StatusIssue), DbBackend::Sql),
            dictInventTransOriginTransfer.fieldName(fieldnum(InventTransOriginTransfer, ReceiptInventTransOrigin), DbBackend::Sql),
            dictInventTrans.fieldName(fieldNum(InventTrans, StatusReceipt), DbBackend::Sql));
        }
        else
        {
            ret += strFmt(@'
                UPDATE
                    %1
                SET
                    %2 = %3
                WHERE
                    %4 = %5 AND
                    %6 = %7 AND
                    %8 = 0 AND
                    %9 IN
                    (
                        SELECT
                            DISTINCT(%10)
                        FROM
                            %11
                    )
                OPTION (MAXDOP 1)',
            dictInventTransOriginTransfer.name(DbBackend::Sql),
            dictInventTransOriginTransfer.fieldName(fieldnum(InventTransOriginTransfer, NonFinancialTransfInventClosingRecId), DbBackend::Sql),
            InventClosing,
            dictInventTransOriginTransfer.fieldName(fieldnum(InventTransOriginTransfer, Partition), DbBackend::Sql),
            Partition,
            dictInventTransOriginTransfer.fieldName(fieldnum(InventTransOriginTransfer, Product), DbBackend::Sql),
            EcoResProduct,
            dictInventTransOriginTransfer.fieldName(fieldnum(InventTransOriginTransfer, NonFinancialTransfInventClosingRecId), DbBackend::Sql),
            dictInventTransOriginTransfer.fieldName(fieldnum(InventTransOriginTransfer, IssueInventTransOrigin), DbBackend::Sql),
            InventTransOriginFieldName,
            InventNonFinancialTransfersTableName);
        }

        ret += strFmt(@'

            END

        SET %1 = 0
        SET @DeadlockRetries = 0

        END TRY
        BEGIN CATCH
            SET %1 = 1

            IF ( ERROR_NUMBER() = 1205 )
            BEGIN
                SET @DeadlockRetries = @DeadlockRetries - 1
            END
            ELSE
            BEGIN
                SET @DeadlockRetries = 0
            END

            IF @@TRANCOUNT > 0
                ROLLBACK TRAN

        END CATCH

        IF @@TRANCOUNT > 0
            COMMIT TRAN

    END

    -- See the beginning of the procedure for rationale of nocount.
    SET NOCOUNT OFF;', ErrorCode);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSPCallParameters</Name>
				<Source><![CDATA[
    private str buildSPCallParameters(
        InventTable     _inventTable,
        InventDimParm   _inventDimParm,
        InventClosing   _inventClosing
        )
    {
        const str ErrorOutputParmName = '@ERROROUTPUT';

        str             ret = '';
        SysSqlSystem    sqlSystem = new SysSqlSystem();
        ListEnumerator  enabledDimsEnumerator = this.enabledDimensions().getEnumerator();
        FieldId         dimFieldId;
        str             dimFieldName;

        if (!_inventTable)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        ret += strFmt('DECLARE %1 int;\n', ErrorOutputParmName);
        ret += strFmt('EXECUTE %1 ', PreCloseNonFinTransferSPName);
        ret += strFmt('%1 OUTPUT', ErrorOutputParmName);
        ret += strFmt(', %1', sqlSystem.sqlLiteral(_inventTable.Partition));
        ret += strFmt(', %1', sqlSystem.sqlLiteral(_inventTable.dataAreaId));
        ret += strFmt(', %1', sqlSystem.sqlLiteral(_inventTable.Product));
        ret += strFmt(', %1', sqlSystem.sqlLiteral(_inventTable.ItemId));
        ret += strFmt(', %1', sqlSystem.sqlLiteral(_inventClosing.RecId));
        ret += strFmt(', %1', sqlSystem.sqlLiteral(_inventClosing.TransDate));

        enabledDimsEnumerator.reset();
        while (enabledDimsEnumerator.moveNext())
        {
            [dimFieldId, dimFieldName] = enabledDimsEnumerator.current();
            ret += strFmt(', %1', sqlSystem.sqlLiteral(_inventDimParm.(InventDim::dim2dimParm(dimFieldId))));
        }

        ret += ';\n';

        ret += strFmt('SELECT %1;', ErrorOutputParmName);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dimensionField</Name>
				<Source><![CDATA[
    private str dimensionField(str _name)
    {
        return strFmt('%1', _name);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dimensionParm</Name>
				<Source><![CDATA[
    private str dimensionParm(str _name)
    {
        return strFmt('@is%1Financial', _name);
    }

]]></Source>
			</Method>
			<Method>
				<Name>enabledDimensions</Name>
				<Source><![CDATA[
    private List enabledDimensions()
    {
        List            ret = new List(Types::Container);
        List            enabledDimensions = new List(Types::Integer);

        enabledDimensions.appendList(InventDimMetaDataCache::dimProductDimEnabledFieldList());
        enabledDimensions.appendList(InventDimMetaDataCache::dimStorageDimEnabledFieldList());
        enabledDimensions.appendList(InventDimMetaDataCache::dimTrackingDimEnabledFieldList());

        ListEnumerator le = enabledDimensions.getEnumerator();
        while (le.moveNext())
        {
            FieldId fieldId = le.current();

            ret.addEnd([
                        fieldId,
                        SysDictTable::fieldnameSQL(tableNum(InventDim), fieldId, FieldNameGenerationMode::FieldList)
                       ]);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSPCallStmt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the SQL statement to call the pre-close stored procedure.
    /// </summary>
    /// <param name="_inventTable">
    /// The <c>InventTable</c> record to use.
    /// </param>
    /// <param name="_inventDimParm">
    /// The <c>InventDimParm</c> criteria for the calculations.
    /// </param>
    /// <param name="_inventClosing">
    /// The current <c>InventClosing</c> record.
    /// </param>
    /// <returns>
    /// A string containing the SQL statement.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws an error if the <c>InventTable</c> record is not specified.
    /// </exception>
    public static str buildSPCallStmt(
        InventTable     _inventTable,
        InventDimParm   _inventDimParm,
        InventClosing   _inventClosing)
    {
        InventCostPreCloseNonFinTransferHelper   helper = InventCostPreCloseNonFinTransferHelper::construct();
        str                                      ret = '';

        ret += helper.buildSPCallParameters(_inventTable, _inventDimParm, _inventClosing);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    private static InventCostPreCloseNonFinTransferHelper construct()
    {
        return new InventCostPreCloseNonFinTransferHelper();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrAlterDBStoredProcedure</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or alters the stored procedure.
    /// </summary>
    private static void createOrAlterDBStoredProcedure()
    {
        Statement                               statement;
        str                                     sqlStmt;
        InventCostPreCloseNonFinTransferHelper  helper = InventCostPreCloseNonFinTransferHelper::construct();

        try
        {
            statement = new Connection().createStatement();

            sqlStmt = helper.buildCreateOrAlterSPStmt();

            new SqlStatementExecutePermission(sqlStmt).assert();

            statement.executeUpdateWithParameters(sqlStmt, SqlParams::create());
        }
        catch (Exception::Error)
        {
            throw error(strFmt("@SYS340516", PreCloseNonFinTransferSPName));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPreCloseNonFinTransferSP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds synchronization of the stored procedure to the database.
    /// </summary>
    internal static void buildPreCloseNonFinTransferSP()
    {
        #OccRetryCount
        if (isPhysicallyExistingInDB(tableNum(InventTransOriginTransfer))
            && isPhysicallyExistingInDB(tableNum(InventClosingNonFinancialInventTrans))
            && isPhysicallyExistingInDB(tableNum(InventTrans))
            && isPhysicallyExistingInDB(tableNum(InventDim))
            && isPhysicallyExistingInDB(tableNum(InventTransOrigin)))
        {
            try
            {
                InventCostPreCloseNonFinTransferHelper::syncDBStoredProcedure();
            }
            catch (Exception::Deadlock)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::Deadlock;
                }
                else
                {
                    retry;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncDBStoredProcedure</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or alters the stored procedure that allow to pre-close the non financial transfers.
    /// </summary>
    public static void syncDBStoredProcedure()
    {
        // Serialize access to manipulating of the stored procedure
        using (var reqReaderWriterLock = ReqReaderWriterLock::construct())
        {
            reqReaderWriterLock.enterUpdateLock(PreCloseNonFinTransferSPLockName);

            InventCostPreCloseNonFinTransferHelper::createOrAlterDBStoredProcedure();

            reqReaderWriterLock.exit(PreCloseNonFinTransferSPLockName);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>