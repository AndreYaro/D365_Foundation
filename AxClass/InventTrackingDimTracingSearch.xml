<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventTrackingDimTracingSearch</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    Base class for forward and backward tracing searching of transactions
/// </summary>
abstract class InventTrackingDimTracingSearch
{
    InventTrackingDimTracingCriteria    inventTrackingDimTracingCriteria;

    InventDimParm                       inventDimParmAll;
    InventDimParm                       inventDimParmNotStorage;

    InventTrackingDimTracingRelations   inventTrackingDimTracingRelations;

    Set                                 transactionsToExpand;

    // When calling method 'InventTrackingDimTracingSearchForward.expandReceiptTransaction()' or 'InventTrackingDimTracingSearchBackward.expandIssueTransaction()'
    // the system will check the results of delegates. This variable is used, for extensibility purposes, to pass this result of delegates to subsequent methods
    // to avoid re-calculating them for performance reasons if they were already calculated.
    internal EventHandlerResult         globalEventResult;

    internal static boolean includeWarehouseSpecificInventoryTransactions = WHSInventoryTransactionConfigurationProvider::isWarehouseInventoryTransactionStackEnabled();

    internal boolean isInventTrackingDimTracingCorrectJoinOrderEnabled = InventTrackingDimTracingCorrectJoinOrderFlight::instance().isEnabled();
    protected boolean isProdAsBuiltBOMFeatureEnabled = BOMParameters::find().EnableTrackedComponents;
    protected Map     productComponentLotSettleMap;    // KV = {product tracking dimensions hashKey => Map {component tracking dimensions hashKey, settle qty}}

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>isEventResultEvaluated</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean isEventResultEvaluated()
    {
        return globalEventResult != null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFirstLevelInventTransNode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Marks the specified inventory transaction as a first level node relative to the search criteria.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The inventory transaction.
    /// </param>
    /// <param name="_inventTransOrigin">
    ///    The <c>InventTransOrigin</c> record related to the inventory transaction.
    /// </param>
    /// <returns>
    ///    A transaction tracing node for the inventory transaction.
    /// </returns>
    protected InventDimTrackingInventTransNode addFirstLevelInventTransNode(
        InventTrans         _inventTrans,
        InventTransOrigin   _inventTransOrigin)
    {
        InventDimTrackingInventTransNode inventDimTrackingInventTransNode = inventTrackingDimTracingRelations.addFirstLevelInventTransNode(_inventTrans, _inventTransOrigin);

        return inventDimTrackingInventTransNode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addChildInventTrans2List</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the <c>InventTrans</c> record to the specified record list, 
    /// if the specified transaction can be considered a child under the specified transaction.
    /// </summary>
    /// <param name="_currentNode">
    /// The transaction node to check.
    /// </param>
    /// <param name="_inventTransList">
    /// The <c>SysRecordSortedList</c> list where the record is added.
    /// </param>
    /// <param name="_inventTrans">
    /// The record to add.
    /// </param>
    /// <param name="_inventTransOrigin">
    /// The <c>InventTransOrigin</c> record related to the <c>InventTrans</c> record.
    /// </param>
    public final void addChildInventTrans2List(InventDimTrackingInventTransNode _currentNode, SysRecordSortedList _inventTransList, InventTrans _inventTrans, InventTransOrigin _inventTransOrigin)
    {
        if (this.isTransChild(_currentNode, _inventTrans, _inventTransOrigin))
        {
            this.addInventTrans2List(_inventTransList, _inventTrans, _inventTransOrigin);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInventTrans2List</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the <c>InventTrans</c> record to the specified record list.
    /// </summary>
    /// <param name="_inventTransList">
    ///    The <c>SysRecordSortedList</c> list where the record is added.
    /// </param>
    /// <param name="_inventTrans">
    ///    The record to add.
    /// </param>
    /// <param name="_inventTransOrigin">
    ///    The <c>InventTransOrigin</c> record related to the <c>InventTrans</c> record.
    /// </param>
    protected void addInventTrans2List(SysRecordSortedList _inventTransList, InventTrans _inventTrans, InventTransOrigin _inventTransOrigin)
    {
        //  Filter out SummedUp type transactions. SummedUp transactions represent other transactions,
        //  but as these original transactions will also be found, the SummedUp transactions are redundant here.
        if (_inventTransOrigin.ReferenceCategory == InventTransType::SummedUp)
        {
            return;
        }

        _inventTrans.DatePhysical = this.inventTransDate(_inventTrans);

        _inventTransList.ins(_inventTrans, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInventTransList2AsSubnodes</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the specified list of <c>InvnetTrans</c> records as sub nodes to the specified node.
    /// </summary>
    /// <param name="_currentNode">
    ///    The parent tracking node.
    /// </param>
    /// <param name="_inventTransList">
    ///    The records to add.
    /// </param>
    protected void addInventTransList2AsSubnodes(InventDimTrackingInventTransNode _currentNode, SysRecordSortedList _inventTransList)
    {
        InventTrans         inventTrans;
        boolean             cont                = _inventTransList.first(inventTrans);
        boolean             anyChildren         = false;

        while (cont)
        {
            if (inventTrans.RecId)
            {
                this.createSubNode(_currentNode, inventTrans);
                anyChildren = true;
            }
            cont = _inventTransList.next(inventTrans);
        }

        if (anyChildren == false)
        {
            this.markNodeWithNoSubnodes(_currentNode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildInitialQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Build the initial query for finding nodes under the top node.
    /// </summary>
    /// <returns>
    ///    A <c>QueryRun</c> object.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///    Search has been canceled
    /// </exception>
    protected QueryRun buildInitialQuery()
    {
        Query                   query                       = new Query();
        QueryBuildDataSource    queryBuildDataSourceOrigin  = query.addDataSource(tableNum(InventTransOrigin));
        QueryBuildDataSource    queryBuildDataSourceTrans   = queryBuildDataSourceOrigin.addDataSource(tableNum(InventTrans));
        QueryBuildDataSource    queryBuildDataSourceDim     = queryBuildDataSourceTrans.addDataSource(tableNum(InventDim), 'DimTrans');
        List                    dimFields                   = InventDim::dimProductDimFieldList();
        ListEnumerator          enumerator                  = dimFields ? dimFields.getEnumerator() : null;
        InventDimParm           inventDimParmCriteria;

        InventDim               inventDimCriteria;

        InventDim               inventDimCriteriaSalesActive;
        InventDimParm           inventDimParmCriteriaSalesActive;

        if (!inventTrackingDimTracingCriteria.validate())
        {
            throw error("@SYS24847");
        }

        inventDimCriteria.data(inventTrackingDimTracingCriteria.parmInventDimCriteria());

        // Move values for sales process active dimensions to a new InventDim buffer
        boolean hasSalesActiveDimCriteria = inventDimCriteria.moveDimParmDim(inventTrackingDimTracingCriteria.inventTable().inventDimParmSalesProcessActiveDim(), inventDimCriteriaSalesActive);

        queryBuildDataSourceOrigin.fetchMode(QueryFetchMode::One2One);
        queryBuildDataSourceTrans.fetchMode(QueryFetchMode::One2One);
        queryBuildDataSourceDim.fetchMode(QueryFetchMode::One2One);

        inventDimParmCriteria.initFromInventDim(inventDimCriteria);

        queryBuildDataSourceTrans.joinMode(JoinMode::InnerJoin);
        queryBuildDataSourceTrans.addLink(fieldNum(InventTransOrigin, RecId), fieldNum(InventTrans, InventTransOrigin));

        QueryBuildRange range = queryBuildDataSourceOrigin.addRange(fieldNum(InventTransOrigin, ItemId));
        range.value(queryValue(inventTrackingDimTracingCriteria.parmItemIdCriteria()));

        queryBuildDataSourceDim.joinMode(JoinMode::InnerJoin);
        queryBuildDataSourceDim.addLink(fieldNum(InventTrans, InventDimId), fieldNum(InventDim, InventDimId));

        InventDim::queryDatasourceAddRangeSortFromParms(queryBuildDataSourceDim, false, inventDimCriteria, inventDimParmCriteria, null);

        if (inventTrackingDimTracingCriteria.parmPdsVendBatchIdCriteria())
        {
            QueryBuildDataSource queryBuildDataSourceBatch = queryBuildDataSourceDim.addDataSource(tableNum(InventBatch));
            queryBuildDataSourceBatch.joinMode(JoinMode::InnerJoin);
            queryBuildDataSourceBatch.addLink(fieldNum(InventDim, InventBatchId), fieldNum(InventBatch, InventBatchId));
            range = queryBuildDataSourceBatch.addRange(fieldNum(InventBatch, ItemId));
            range.value(queryValue(inventTrackingDimTracingCriteria.parmItemIdCriteria()));
            range = queryBuildDataSourceBatch.addRange(fieldNum(InventBatch, PdsVendBatchId));
            range.value(queryValue(inventTrackingDimTracingCriteria.parmPdsVendBatchIdCriteria()));
        }

        if (hasSalesActiveDimCriteria)
        {
            QueryBuildDataSource queryBuildDataSourceRegisterTrans = queryBuildDataSourceOrigin.addDataSource(tableNum(InventTrackingRegisterTrans));
            queryBuildDataSourceRegisterTrans.joinMode(JoinMode::ExistsJoin);
            queryBuildDataSourceRegisterTrans.fetchMode(QueryFetchMode::One2One);
            queryBuildDataSourceRegisterTrans.relations(true);

            QueryBuildDataSource queryBuildDataSourceRegisterTransDim = queryBuildDataSourceRegisterTrans.addDataSource(tableNum(InventDim), 'DimRegTrans');
            queryBuildDataSourceRegisterTransDim.joinMode(JoinMode::ExistsJoin);
            queryBuildDataSourceRegisterTransDim.relations(true);

            inventDimParmCriteriaSalesActive.initFromInventDim(inventDimCriteriaSalesActive);
            InventDim::queryDatasourceAddRangeSortFromParms(queryBuildDataSourceRegisterTransDim, false, inventDimCriteriaSalesActive, inventDimParmCriteriaSalesActive, null);
        }

        QueryRun initialQueryRun = new QueryRun(query);

        return initialQueryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildItemHierachy</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Build the search hierarchy for items.
    /// </summary>
    protected void buildItemHierachy()
    {
        transactionsToExpand = new Set(Types::String);

        SysRecordSortedList inventTransList = this.initInventTransList();

        QueryRun initialQueryRun = this.buildInitialQuery();
        while (initialQueryRun.next())
        {
            var inventTrans = initialQueryRun.get(tableNum(InventTrans)) as InventTrans;
            var inventTransOrigin = initialQueryRun.get(tableNum(InventTransOrigin)) as InventTransOrigin;

            if (this.canUseInventransAsInitialTransaction(inventTransOrigin, inventTrans))
            {
                if (this.checkDateCriteria(inventTrans))
                {
                    var inventDimTrackingInventTransNode = this.addFirstLevelInventTransNode(inventTrans, inventTransOrigin);
                    if (!this.isTransactionExpanded(inventDimTrackingInventTransNode))
                    {
                        transactionsToExpand.add(inventDimTrackingInventTransNode.tracingNodeKey());
                    }
                }
            }
        }

        if (includeWarehouseSpecificInventoryTransactions)
        {
            QueryRun initialQueryWHSInventoryTransaction = this.buildInitialQueryWHSInventoryTransaction();

            while (initialQueryWHSInventoryTransaction.next())
            {
                WHSInventoryTransactionView inventoryTransactionView = initialQueryWHSInventoryTransaction.get(tableNum(WHSInventoryTransactionView)) as WHSInventoryTransactionView;

                WHSInventoryTrackingTransaction whsInventoryTransaction =
                    WHSInventoryTrackingTransaction::newFromInventoryTransactionView(inventoryTransactionView);

                InventDimTrackingInventTransNode inventDimTrackingInventTransNode = inventTrackingDimTracingRelations.addFirstLevelNode(whsInventoryTransaction);

                if (!this.isTransactionExpanded(inventDimTrackingInventTransNode))
                {
                    transactionsToExpand.add(inventDimTrackingInventTransNode.tracingNodeKey());
                }
            }
        }

        this.expandAllTransactions();
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildInitialQueryWHSInventoryTransaction</Name>
				<Source><![CDATA[
    private QueryRun buildInitialQueryWHSInventoryTransaction()
    {
        Query                   query = new Query();
        QueryBuildDataSource    queryBuildDataSourceWHSTransaction  = query.addDataSource(tableNum(WHSInventoryTransactionView));
        InventDim               inventDimCriteria;
       
        inventDimCriteria.data(inventTrackingDimTracingCriteria.parmInventDimCriteria());

        queryBuildDataSourceWHSTransaction.fetchMode(QueryFetchMode::One2One);

        QueryBuildRange range = queryBuildDataSourceWHSTransaction.addRange(fieldNum(WHSInventoryTransactionView, ItemId));
        range.value(queryValue(inventTrackingDimTracingCriteria.parmItemIdCriteria()));

        queryBuildDataSourceWHSTransaction.addRange(fieldNum(WHSInventoryTransactionView, Type))
            .value(queryValue(WHSInventoryTransactionTypeEnum::RegisteredIssue));
        queryBuildDataSourceWHSTransaction.addRange(fieldNum(WHSInventoryTransactionView, Type))
            .value(queryValue(WHSInventoryTransactionTypeEnum::RegisteredReceipt));

        if (WHSTracingFormsQueryOnlyArchivedTransactionsFlight::instance().isEnabled())
        {
            queryBuildDataSourceWHSTransaction.addRange(fieldNum(WHSInventoryTransactionView, Archived))
                .value(queryValue(NoYes::Yes));
        }
        
        WHSInventoryProductTrackingDimensions::newFromInventDim(inventDimCriteria)
            .addProductTrackingDimensionsFilterForDataSource(queryBuildDataSourceWHSTransaction);

        WHSInventoryStorageDimensions::newFromInventDim(inventDimCriteria)
            .addInventoryStorageDimensionsFilterForDataSource(queryBuildDataSourceWHSTransaction);

        if (inventTrackingDimTracingCriteria.parmPdsVendBatchIdCriteria())
        {
            QueryBuildDataSource queryBuildDataSourceBatch = queryBuildDataSourceWHSTransaction.addDataSource(tableNum(InventBatch));
            queryBuildDataSourceBatch.joinMode(JoinMode::InnerJoin);
            queryBuildDataSourceBatch.addLink(fieldNum(WHSInventoryTransactionView, InventBatchId), fieldNum(InventBatch, InventBatchId));
            range = queryBuildDataSourceBatch.addRange(fieldNum(InventBatch, ItemId));
            range.value(queryValue(inventTrackingDimTracingCriteria.parmItemIdCriteria()));
            range = queryBuildDataSourceBatch.addRange(fieldNum(InventBatch, PdsVendBatchId));
            range.value(queryValue(inventTrackingDimTracingCriteria.parmPdsVendBatchIdCriteria()));
        }        

        QueryRun initialQueryRun = new QueryRun(query);

        return initialQueryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUseInventransAsInitialTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if the specified transaction can be used as a starting point for item hierarchy tracing.
    /// </summary>
    /// <param name="_inventTransOrigin">
    ///    The inventory transaction origin to check.
    /// </param>
    /// <param name="_inventTrans">
    ///    The inventory transaction to check.
    /// </param>
    /// <returns>
    ///    true if the record can be used; otherwise, false.
    /// </returns>
    protected boolean canUseInventransAsInitialTransaction(
        InventTransOrigin   _inventTransOrigin,
        InventTrans         _inventTrans)
    {
        if (_inventTransOrigin.ReferenceCategory == InventTransType::TransferOrderShip
         || _inventTransOrigin.ReferenceCategory == InventTransType::TransferOrderReceive)
        {
            if (_inventTrans.inventDim().inventLocation().InventLocationType == InventLocationType::Transit)
            {
                return false;
            }
        }

        if (_inventTransOrigin.ReferenceCategory == InventTransType::QuarantineOrder)
        {
            if (_inventTrans.inventDim().inventLocation().InventLocationType == InventLocationType::Quarantine)
            {
                return false;
            }
        }

        if (_inventTrans.ReturnInventTransOrigin != 0)
        {
            if (_inventTransOrigin.ReferenceCategory != InventTransType::Purch
             && _inventTransOrigin.ReferenceCategory != InventTransType::Sales)
            {
                // Only include returned transactions for sales and purchase orders
                return false;
            }
        }

        if (this.isByProductProduction(_inventTransOrigin))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDateCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if the specified inventory transaction date information is within criteria range
    /// </summary>
    /// <param name="_inventTrans">
    ///    The transaction to examine.
    /// </param>
    /// <returns>
    ///    true if the transaction can be used; otherwise, false.
    /// </returns>
    protected boolean checkDateCriteria(
        InventTrans     _inventTrans)
    {
        boolean         ret = true;

        date dateChild = this.inventTransDate(_inventTrans);
        if (!dateChild)
        {
            return false;
        }

        if (inventTrackingDimTracingCriteria.parmFromDateCriteria() && dateChild < inventTrackingDimTracingCriteria.parmFromDateCriteria())
        {
            return false;
        }

        if (inventTrackingDimTracingCriteria.parmToDateCriteria() && dateChild > inventTrackingDimTracingCriteria.parmToDateCriteria())
        {
            return false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDateOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if the specified inventory transaction date information allows it to be used as a sub node
    ///    for the specified node.
    /// </summary>
    /// <param name="_currentNode">
    ///    The transaction node to examine the transaction with.
    /// </param>
    /// <param name="_inventTrans">
    ///    The transaction to examine.
    /// </param>
    /// <param name="_inventTransOrigin">
    ///    The <c>InventTransOrigin</c> record for the transaction.
    /// </param>
    /// <returns>
    ///    true if the transaction can be used; otherwise, false.
    /// </returns>
    protected boolean checkDateOrder(
        InventDimTrackingInventTransNode    _currentNode,
        InventTrans                         _inventTrans,
        InventTransOrigin                   _inventTransOrigin)
    {
        if (includeWarehouseSpecificInventoryTransactions)
        {
            InventTransTrackingTransaction inventTransTrackingTransaction =
                InventTransTrackingTransaction::newFromInventTransAndInventTransOrigin(_inventTrans, _inventTransOrigin);

            return this.dateAllowsTrackingTransactionToBeUsedAsSubNodeOfCurrentNode(_currentNode, inventTransTrackingTransaction);
        }
        else
        {
            return this.checkDateCriteria(_inventTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dateAllowsTrackingTransactionToBeUsedAsSubNodeOfCurrentNode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if the specified tracking transaction date information allows it to be used as a sub node
    ///    for the specified node.
    /// </summary>
    /// <param name="_currentNode">
    ///    The current transaction node.
    /// </param>
    /// <param name="_trackingTransaction">
    ///    The <c>InventTrackingTransaction</c> record for the transaction.
    /// </param>
    /// <returns>
    ///    True if the specified tracking transaction date information allows it to be used as a sub node
    ///    for the specified node.
    /// </returns>
    [Hookable(false)]
    internal boolean dateAllowsTrackingTransactionToBeUsedAsSubNodeOfCurrentNode(InventDimTrackingInventTransNode _currentNode, InventTrackingTransaction _trackingTransaction)
    {
        date dateChild = _trackingTransaction.stockQtyChangeDate();
        if (!dateChild)
        {
            return false;
        }

        if (inventTrackingDimTracingCriteria.parmFromDateCriteria() && dateChild < inventTrackingDimTracingCriteria.parmFromDateCriteria())
        {
            return false;
        }

        if (inventTrackingDimTracingCriteria.parmToDateCriteria() && dateChild > inventTrackingDimTracingCriteria.parmToDateCriteria())
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isChildTrackingTransactionWithSameInventDimId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean isChildTrackingTransactionWithSameInventDimId(InventDimTrackingInventTransNode _currentNode, InventTrackingTransaction _trackingTransaction)
    {
        return _currentNode.getInventDimId() == _trackingTransaction.inventDimId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkQuarantineOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if the specified transactions can be considered quarantine related children of the specified transaction.
    /// </summary>
    /// <param name="_currentNode">
    ///    The current transaction node.
    /// </param>
    /// <param name="_inventTrans">
    ///    The <c>InventTrans</c> record for the transaction.
    /// </param>
    /// <param name="_inventTransOrigin">
    ///    The <c>InventTransOrigin</c> record for the transaction.
    /// </param>
    /// <returns>
    ///    true if the transactions can be considered child nodes; otherwise, false.
    /// </returns>
    abstract protected boolean checkQuarantineOrder(
        InventDimTrackingInventTransNode    _currentNode,
        InventTrans                         _inventTrans,
        InventTransOrigin                   _inventTransOrigin)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransOriginIds</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if the specified transactions can be considered related children
    ///    of the specified hierarchy node based on transaction dates and other transaction information.
    /// </summary>
    /// <param name="_currentNode">
    ///    The current transaction node.
    /// </param>
    /// <param name="_inventTrans">
    ///    The <c>InventTrans</c> record for the transaction.
    /// </param>
    /// <param name="_inventTransOrigin">
    ///    The <c>InventTransOrigin</c> record for the transaction.
    /// </param>
    /// <returns>
    ///    true if the transactions can be considered child nodes; otherwise, false.
    /// </returns>
    abstract protected boolean checkTransOriginIds(
        InventDimTrackingInventTransNode    _currentNode,
        InventTrans                         _inventTrans,
        InventTransOrigin                   _inventTransOrigin)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSubNode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Create a transaction node with the specified transaction information under the specified node.
    /// </summary>
    /// <param name="_currentNode">
    ///    The current transaction node.
    /// </param>
    /// <param name="_inventTrans">
    ///    The <c>InventTrans</c> record for the inventory transaction.
    /// </param>
    /// <param name="_inventTransOrigin">
    ///    The <c>InventTransOrigin</c> record for the inventory transaction; optional.
    /// </param>
    abstract protected void createSubNode(
        InventDimTrackingInventTransNode    _currentNode,
        InventTrans                         _inventTrans,
        InventTransOrigin                   _inventTransOrigin = null)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandAllTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Expand all transactions.
    /// </summary>
    protected void expandAllTransactions()
    {
        while (transactionsToExpand.elements() > 0)
        {
            SetEnumerator se = transactionsToExpand.getEnumerator();
            if (se.moveNext())
            {
                str transactionToExpand = se.current();
                this.expandTransaction(transactionToExpand);
                transactionsToExpand.remove(transactionToExpand);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandIssueTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Expand the specified issue transaction with the related receipts.
    /// </summary>
    /// <param name="_inventTransList">
    ///    The list of transactions where transactions related to child nodes will be added.
    /// </param>
    /// <param name="_currentNode">
    ///    The transaction node to expand.
    /// </param>
    abstract protected void expandIssueTransaction(
        SysRecordSortedList                 _inventTransList,
        InventDimTrackingInventTransNode    _currentNode)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandReceiptTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Expand the specified node for a receipt with the related issues.
    /// </summary>
    /// <param name="_inventTransList">
    ///    The list of transactions where transactions related to the key transaction will be added.
    /// </param>
    /// <param name="_currentNode">
    ///    The transaction node to expand.
    /// </param>
    abstract protected void expandReceiptTransaction(
        SysRecordSortedList                 _inventTransList,
        InventDimTrackingInventTransNode    _currentNode)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Expand the specified node if not already expanded.
    /// </summary>
    /// <param name="_transactionKey">
    ///    The transaction to expand.
    /// </param>
    protected void expandTransaction(str _transactionKey)
    {
        InventDimTrackingInventTransNode inventDimTrackingInventTransNode = inventTrackingDimTracingRelations.nodeFromKey(_transactionKey);

        if (this.isTransactionExpanded(inventDimTrackingInventTransNode))
        {
            // Already expanded
            return;
        }

        this.markNodeAsExpanded(inventDimTrackingInventTransNode);

        if (includeWarehouseSpecificInventoryTransactions)
        {
            InventDim inventDim = inventDimTrackingInventTransNode.getInventDim();

            if (!inventDim.anyTrackingDimensionSpecified())
            {
                return;
            }

            SysRecordSortedList inventTransAndWHSInventoryTransactionList = this.initInventoryTransactionList();
            Map allTransactionMap = new Map(Types::String, Types::Record);

            if (inventDimTrackingInventTransNode.isNodeForIssueTransaction())
            {
                this.expandIssueTransactionIncludingWHSInventoryTransaction(inventTransAndWHSInventoryTransactionList, inventDimTrackingInventTransNode, allTransactionMap);
            }
            else
            {
                this.expandReceiptTransactionIncludingWHSInventoryTransaction(inventTransAndWHSInventoryTransactionList, inventDimTrackingInventTransNode, allTransactionMap);
            }

            if (inventTransAndWHSInventoryTransactionList)
            {
                this.addInventTransAndWHSInventoryTransactionList2AsSubnodes(inventDimTrackingInventTransNode, inventTransAndWHSInventoryTransactionList, allTransactionMap);
            }
        }
        else
        {
            InventTrackingDimTracingInventTransDTO inventTransParentDTO = inventDimTrackingInventTransNode.parmInventTransDTO();
            InventDim inventDim = inventTransParentDTO.inventDim();
            if (!inventDim.anyTrackingDimensionSpecified())
            {
                return;
            }

            SysRecordSortedList inventTransList = this.initInventTransList();
            if (inventTransParentDTO.inventQty() < 0)
            {
                this.expandIssueTransaction(inventTransList, inventDimTrackingInventTransNode);
            }
            else
            {
                this.expandReceiptTransaction(inventTransList, inventDimTrackingInventTransNode);
            }

            if (inventTransList)
            {
                this.addInventTransList2AsSubnodes(inventDimTrackingInventTransNode, inventTransList);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInventTransAndWHSInventoryTransactionList2AsSubnodes</Name>
				<Source><![CDATA[
    private void addInventTransAndWHSInventoryTransactionList2AsSubnodes(
        InventDimTrackingInventTransNode    _currentNode,
        SysRecordSortedList                 _list,
        Map                                 _allTransactionMap)
    {
        InventTrackingTransactionInMemoryTable transaction;
        boolean             cont                = _list.first(transaction);
        boolean             anyChildren         = false;

        while (cont)
        {
            if (transaction.UniqueKey)
            {
                if (transaction.TransactionType == InventTrackingTransactionType::InventTrans)
                {
                    InventTrans inventTrans = _allTransactionMap.lookup(transaction.UniqueKey);

                    this.createSubNode(_currentNode, inventTrans);
                }
                else if (transaction.TransactionType == InventTrackingTransactionType::WHSInventoryTransaction)
                {
                    WHSInventoryTransactionView transactionView = _allTransactionMap.lookup(transaction.UniqueKey);
                    
                    InventDimTrackingInventTransNode childNode = inventTrackingDimTracingRelations.transactionNode(
                        WHSInventoryTrackingTransaction::newFromInventoryTransactionView(transactionView));

                    this.linkSubNode(_currentNode, childNode);
                }
                                
                anyChildren = true;
            }
            cont = _list.next(transaction);
        }
                
        if (anyChildren == false)
        {
            this.markNodeWithNoSubnodes(_currentNode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventoryTransactionList</Name>
				<Source><![CDATA[
    private SysRecordSortedList initInventoryTransactionList()
    {
        // The list can contain both InventTrans and transactions related to the new WHS warehouse stack(WHSInventoryTransaction joined with WHSInventoryItemSetElement or the corresponding archived data)
        SysRecordSortedList inventTrackingTransactionList = new SysRecordSortedList(tableNum(InventTrackingTransactionInMemoryTable));

        inventTrackingTransactionList.sortOrder(
            fieldNum(InventTrackingTransactionInMemoryTable, ItemId),
            fieldNum(InventTrackingTransactionInMemoryTable, DatePhysical),
            fieldNum(InventTrackingTransactionInMemoryTable, InventTransOrigin),
            fieldNum(InventTrackingTransactionInMemoryTable, UniqueKey));

        return inventTrackingTransactionList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initialize the record sorted list for holding child transactions.
    /// </summary>
    /// <returns>
    ///    A <c>SysRecordSortedList</c> instance.
    /// </returns>
    protected SysRecordSortedList initInventTransList()
    {
        SysRecordSortedList     inventTransList = new SysRecordSortedList(tableNum(InventTrans));

        inventTransList.sortOrder(  fieldNum(InventTrans, ItemId),
                                    fieldNum(InventTrans, DatePhysical),
                                    fieldNum(InventTrans, InventTransOrigin),
                                    fieldNum(InventTrans, RecId));
        return inventTransList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTrackingDimTracingRelations</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the current tracing relations.
    /// </summary>
    /// <returns>
    ///    An <c>InventTrackingDimTracingRelations</c> instance.
    /// </returns>
    protected InventTrackingDimTracingRelations inventTrackingDimTracingRelations()
    {
        return inventTrackingDimTracingRelations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the inventory date for the specified transaction.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The inventory transaction.
    /// </param>
    /// <returns>
    ///    A date.
    /// </returns>
    protected date inventTransDate(InventTrans _inventTrans)
    {
        return _inventTrans.stockQtyChangeDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isByProductProduction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets a value indicating if the transaction is for a by-product in a production order.
    /// </summary>
    /// <param name="_inventTransOrigin">
    ///    The inventory transaction origin for the transaction.
    /// </param>
    /// <returns>
    ///    true if the transaction is used as a by-product on a production; otherwise, false.
    /// </returns>
    protected boolean isByProductProduction(InventTransOrigin _inventTransOrigin)
    {
        boolean                 ret = false;

        if (_inventTransOrigin.ReferenceCategory == InventTransType::PmfProdCoBy)
        {
            ret = PmfProdCoBy::findTransId(_inventTransOrigin.InventTransId).ProductType == PmfProductType::By_Product;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isChildInProdBOM</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets a value indicating if an inventory transaction is a child of the current node
    ///    based on a production order BOM/Formula relationship.
    /// </summary>
    /// <param name="_currentNode">
    ///    The current node.
    /// </param>
    /// <param name="_inventTransOrigin">
    ///    The record buffer for the <c>InvenTransOrigin</c> table for the potential child transaction.
    /// </param>
    /// <returns>
    ///    true if the inventory transaction is a child of <paramref name="_currentNode"/> based on a production
    ///    order BOM/Formula relationship.
    /// </returns>
    protected abstract boolean isChildInProdBOM(InventDimTrackingInventTransNode _currentNode, InventTransOrigin _inventTransOrigin)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isChildWithSameInventDimId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current node and the potential child node have the same inventDimId.
    /// </summary>
    /// <param name = "_currentNode"> The current node. </param>
    /// <param name = "_inventTransOrigin"> The record buffer for the <c>InvenTransOrigin</c> table for the potential child transaction. </param>
    /// <param name = "_inventTrans"> The <c>InvenTrans</c> record of the potential child transaction.</param>
    /// <returns> returns true if the current node and the potential child node have the same inventDimId; otherwise false. </returns>
    protected boolean isChildWithSameInventDimId(InventDimTrackingInventTransNode _currentNode, InventTransOrigin _inventTransOrigin, InventTrans _inventTrans)
    {
        InventTrackingDimTracingInventTransDTO currentTrans = _currentNode.parmInventTransDTO();
            
        return (_inventTrans.inventDimId == currentTrans.inventDimId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventTransWithParametersFirst</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the parameters of the first inventory transaction guarantee that it preceeds the second transaction.
    /// </summary>
    /// <param name="_dateFinancial1">The date of the financial update of the first transaction.</param>
    /// <param name="_dateFinancial2">The date of the financial update of the second transaction.</param>
    /// <param name="_voucher1">The ledger voucher number associated with the first transaction.</param>
    /// <param name="_voucher2">The ledger voucher number associated with the second transaction.</param>
    /// <param name="_inventTransOriginRecId1">The RecId of the inventory originator of the first transaction.</param>
    /// <param name="_inventTransOriginRecId2">The RecId of the inventory originator of the second transaction.</param>
    /// <returns>
    /// true, if the first transaction preceeds the second; otherwise, false.
    /// </returns>
    protected boolean isInventTransWithParametersFirst(
        DateFinancial       _dateFinancial1,
        DateFinancial       _dateFinancial2, 
        Voucher             _voucher1,
        Voucher             _voucher2,
        InventTransOriginId _inventTransOriginRecId1,
        InventTransOriginId _inventTransOriginRecId2)
    {
        if (_dateFinancial1 && _dateFinancial2)
        {
            if (_dateFinancial1 < _dateFinancial2)
            {
                return true;
            }
            if (_dateFinancial1 > _dateFinancial2)
            {
                return false;
            }
            // both have same date
            if (_voucher1 < _voucher2)
            {
                return true;
            }
            return false;
        }
        if (_dateFinancial1 && !_dateFinancial2)
        {
            return true;
        }
        if (_dateFinancial2 && !_dateFinancial1)
        {
            return false;
        }
        // no dates
        if (_inventTransOriginRecId1 < _inventTransOriginRecId2)
        {
            // last resort, which isn't completely safe if inventTransOrigin is created on different AOSs
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemTracingByInventDimFlightingEnabled</Name>
				<Source><![CDATA[
    private final static boolean isItemTracingByInventDimFlightingEnabled()
    {
        return isFlightEnabled(InventFlighting::ItemTracingByInventDimFlightingName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransactionExpanded</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if the specified transaction tracing node already has been expanded in the current direction.
    /// </summary>
    /// <param name="_transactionNode">
    ///    The transaction tracing node.
    /// </param>
    /// <returns>
    ///    true if the node is already expanded; otherwise, false.
    /// </returns>
    abstract protected boolean isTransactionExpanded(InventDimTrackingInventTransNode _transactionNode)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransChild</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if the specified transaction should be considered a child under the specified transaction.
    /// </summary>
    /// <param name="_currentNode">
    ///     The transaction node to check.
    /// </param>
    /// <param name="_inventTrans">
    ///    The <c>InventTrans</c> record for the transaction.
    /// </param>
    /// <param name="_inventTransOrigin">
    ///    The <c>InventTransOrigin</c> record for the transaction.
    /// </param>
    /// <returns>
    ///    true if the transaction is a child; otherwise, false.
    /// </returns>
    protected boolean isTransChild(
        InventDimTrackingInventTransNode    _currentNode,
        InventTrans                         _inventTrans,
        InventTransOrigin                   _inventTransOrigin)
    {
        if (_inventTrans.ReturnInventTransOrigin != 0
         && (_inventTransOrigin.ReferenceCategory != InventTransType::Purch
          && _inventTransOrigin.ReferenceCategory != InventTransType::Sales))
        {
            // Only include returned transactions for sales and purchase orders.
            return false;
        }

        if (!this.inventTransDate(_inventTrans))
        {
            return false;
        }

        if (includeWarehouseSpecificInventoryTransactions)
        {
            InventTransTrackingTransaction inventTransTrackingTransaction =
                InventTransTrackingTransaction::newFromInventTransAndInventTransOrigin(_inventTrans, _inventTransOrigin);

            return this.isTrackingTransactionChild(_currentNode, inventTransTrackingTransaction);
        }
        else
        {
            return this.checkTransOriginIds(_currentNode, _inventTrans, _inventTransOrigin)
                && (this.checkDateOrder(_currentNode, _inventTrans, _inventTransOrigin)
                    || this.isChildInProdBOM(_currentNode, _inventTransOrigin)
                    || (InventTrackingDimTracingSearch::isItemTracingByInventDimFlightingEnabled()
                        && this.isChildWithSameInventDimId(_currentNode, _inventTransOrigin, _inventTrans)))
                && this.checkQuarantineOrder(_currentNode, _inventTrans, _inventTransOrigin)
                && !this.isByProductProduction(_inventTransOrigin);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTrackingTransactionChild</Name>
				<Source><![CDATA[
    private boolean isTrackingTransactionChild(
        InventDimTrackingInventTransNode    _currentNode,
        InventTrackingTransaction           _trackingTransaction)
    {
        if (_currentNode.getTransactionType() == InventTrackingTransactionType::InventTrans
            && _trackingTransaction.getTransactionType() == InventTrackingTransactionType::InventTrans)
        {
            InventTransTrackingTransaction inventTransTrackingTransaction = _trackingTransaction as InventTransTrackingTransaction;
            InventTrans inventTrans = inventTransTrackingTransaction.getInventTrans();
            InventTransOrigin inventTransOrigin = inventTransTrackingTransaction.getInventTransOrigin();

            return this.checkTransOriginIds(_currentNode, inventTrans, inventTransOrigin)
                && (this.checkDateOrder(_currentNode, inventTrans, inventTransOrigin)
                    || this.isChildInProdBOM(_currentNode, inventTransOrigin)
                    || (InventTrackingDimTracingSearch::isItemTracingByInventDimFlightingEnabled()
                        && this.isChildWithSameInventDimId(_currentNode, inventTransOrigin, inventTrans)))
                && this.checkQuarantineOrder(_currentNode, inventTrans, inventTransOrigin)
                && !this.isByProductProduction(inventTransOrigin);
        }
        else
        {
            return (this.dateAllowsTrackingTransactionToBeUsedAsSubNodeOfCurrentNode(_currentNode, _trackingTransaction)
                    || (InventTrackingDimTracingSearch::isItemTracingByInventDimFlightingEnabled()
                        && this.isChildTrackingTransactionWithSameInventDimId(_currentNode, _trackingTransaction))
                && !_trackingTransaction.isByProductProductionTransaction());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransReferenceProdBOMForProduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether an origin is for a production BOM line that is
    /// part of the production order represented by the other origin.
    /// </summary>
    /// <param name="_possibleProdReferenceCategory">The reference type of the possible production order transaction.</param>
    /// <param name="_possibleProdBOMReferenceCategory">The reference type of the possible production line transaction.</param>
    /// <param name="_possibleProdReferenceId">The reference number of the possible production order transaction.</param>
    /// <param name="_possibleProdBOMReferenceId">The reference number of the possible production line transaction.</param>
    /// <returns>
    /// true if the transactions actually represent a production order and a production line; otherwise, false.
    /// </returns>
    protected boolean isTransReferenceProdBOMForProduction(
        InventTransType     _possibleProdReferenceCategory,
        InventTransType     _possibleProdBOMReferenceCategory,
        InventTransRefId    _possibleProdReferenceId,
        InventTransRefId    _possibleProdBOMReferenceId)
    {
        if ((_possibleProdReferenceCategory != InventTransType::Production
            && _possibleProdReferenceCategory != InventTransType::PmfProdCoBy)
            || _possibleProdBOMReferenceCategory != InventTransType::ProdLine)
        {
            return false;
        }

        return _possibleProdBOMReferenceId == _possibleProdReferenceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markNodeAsExpanded</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Mark the tracing node as fully expanded in the current tracing direction.
    /// </summary>
    /// <param name="_currentNode">
    ///    The tracing node.
    /// </param>
    abstract protected void markNodeAsExpanded(
        InventDimTrackingInventTransNode    _currentNode)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>markNodeWithNoSubnodes</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Mark the tracing node as a root node in the current tracing direction.
    /// </summary>
    /// <param name="_currentNode">
    ///    The tracing node.
    /// </param>
    abstract protected void markNodeWithNoSubnodes(
        InventDimTrackingInventTransNode    _currentNode)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        List            list        = InventDim::dimFieldsList();
        ListEnumerator  enumerator  = (list) ? list.getEnumerator() : null;

        // initialize inventDimParmNotStorage with all dimensions which aren't storage dimensions
        if (enumerator)
        {
            while (enumerator.moveNext())
            {
                FieldId dimFieldId = enumerator.current();
                if (!InventDim::isFieldIdStorageDimension(dimFieldId))
                {
                    FieldId dimParmFieldId = InventDim::dim2dimParm(dimFieldId);
                    inventDimParmNotStorage.(dimParmFieldId) = NoYes::Yes;
                }
            }
        }

        inventDimParmAll.setAllInventDim();
        inventDimParmAll.ItemIdFlag    = NoYes::Yes;

        if (isProdAsBuiltBOMFeatureEnabled)
        {
            productComponentLotSettleMap = new Map(Types::String, Types::Class);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventTrackingDimTracingCriteria</Name>
				<Source><![CDATA[
    protected InventTrackingDimTracingCriteria parmInventTrackingDimTracingCriteria(InventTrackingDimTracingCriteria _inventTrackingDimTracingCriteria = inventTrackingDimTracingCriteria)
    {
        inventTrackingDimTracingCriteria = _inventTrackingDimTracingCriteria;

        return inventTrackingDimTracingCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchFromCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Do the actual search based on criteria passed in earlier.
    /// </summary>
    /// <returns>
    ///    true
    /// </returns>
    protected boolean searchFromCriteria()
    {
        inventTrackingDimTracingRelations = InventTrackingDimTracingRelations::construct();

        this.buildItemHierachy();

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needQueryTransWithoutSpecifiedTrackingDim</Name>
				<Source><![CDATA[
    [Hookable(false), Wrappable(false)]
    protected boolean needQueryTransWithoutSpecifiedTrackingDim(InventDim _inventDimParent, InventTransType _inventTransType)
    {
        // No need to query again if there is tracking dimension specified, and current transaction origin is
        // not belong to transfer journal because transfer journal can have different tracking dimension between from and to
        return _inventTransType == InventTransType::InventTransfer || !_inventDimParent.anyTrackingDimensionSpecified();   
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchFromExistingRelations</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Do the actual search based on criteria passed in earlier.
    /// </summary>
    /// <param name="_existingRelations">
    ///    The existing relations to extend.
    /// </param>
    /// <returns>
    ///    true
    /// </returns>
    public boolean searchFromExistingRelations(InventTrackingDimTracingRelations _existingRelations)
    {
        Set    rootTransactions = _existingRelations.parmFirstLevelNodes();

        inventTrackingDimTracingRelations = _existingRelations;
        if (rootTransactions && rootTransactions.elements() > 0)
        {
            transactionsToExpand = Set::create(rootTransactions.pack());
            this.expandAllTransactions();
        }

        return  true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>search</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes a full trace search on the server.
    /// </summary>
    /// <param name="_packedTrackingCriteria">
    ///    A packed version of the search criteria to use.
    /// </param>
    /// <returns>
    ///    A container with search result and packed hierarchy information.
    /// </returns>
    static public container search(container _packedTrackingCriteria)
    {
        boolean                                     res = false;
        container                                   packedResults;

        InventTrackingDimTracingCriteria inventTrackingDimTracingCriteria = InventTrackingDimTracingCriteria::newFromPacked(_packedTrackingCriteria);
        InventTrackingDimTracingRelations inventTrackingDimTracingRelations = InventTrackingDimTracingSearch::searchNoPack(inventTrackingDimTracingCriteria);

        if (inventTrackingDimTracingRelations)
        {
            res = true;
            packedResults = inventTrackingDimTracingRelations.pack();
        }
        else
        {
            packedResults = conNull();
        }

        return [res, packedResults];
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchFromForm</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Do a full search from the tracing form.
    /// </summary>
    /// <param name="_inventTrackingDimTracingCriteria">
    ///    The search criteria to use.
    /// </param>
    /// <returns>
    ///    A container with search result and packed hierarchy information.
    /// </returns>
    public static container searchFromForm(
        InventTrackingDimTracingCriteria        _inventTrackingDimTracingCriteria)
    {
        container result = InventTrackingDimTracingSearch::search(_inventTrackingDimTracingCriteria.pack());
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchNoPack</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes a full trace search without packing the results.
    /// </summary>
    /// <param name="_inventTrackingDimTracingCriteria">
    ///    The search criteria to use.
    /// </param>
    /// <returns>
    ///    The tracing hierarchy relations or <c>null</c> if there are no results.
    /// </returns>
    /// <remarks>
    ///    This version of the search method should only be used for performance sensitive callers that are already executing
    ///    on the server.
    /// </remarks>
    public static InventTrackingDimTracingRelations searchNoPack(InventTrackingDimTracingCriteria _inventTrackingDimTracingCriteria)
    {
        // Find the starting nodes and do a forward trace
        var inventTrackingDimTracingSearchForward = InventTrackingDimTracingSearchForward::newParameters(_inventTrackingDimTracingCriteria);
        inventTrackingDimTracingSearchForward.searchFromCriteria();
        var inventTrackingDimTracingRelations = inventTrackingDimTracingSearchForward.inventTrackingDimTracingRelations();

        // Do a backward trace from the starting nodes.
        var inventTrackingDimTracingSearchBackward = InventTrackingDimTracingSearchBackward::newParameters(_inventTrackingDimTracingCriteria);
        inventTrackingDimTracingSearchBackward.searchFromExistingRelations(inventTrackingDimTracingRelations);

        Set startingNodes = inventTrackingDimTracingRelations.parmFirstLevelNodes();
        if (startingNodes && startingNodes.elements() > 0)
        {
            InventQty       currentOnHand;
            PdsCWInventQty  currentOnHandCW;
            [currentOnHand, currentOnHandCW] = _inventTrackingDimTracingCriteria.currentOnHand();
            inventTrackingDimTracingRelations.parmCurrentOnHand(currentOnHand);
            inventTrackingDimTracingRelations.parmCurrentOnHandCW(currentOnHandCW);

            return inventTrackingDimTracingRelations;
        }
        else
        {
            return null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>linkSubNode</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void linkSubNode(
        InventDimTrackingInventTransNode _currentNode,
        InventDimTrackingInventTransNode _subNode)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandIssueTransactionIncludingWHSInventoryTransaction</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void expandIssueTransactionIncludingWHSInventoryTransaction(
        SysRecordSortedList                 _inventTransAndWHSInventoryTransactionList,
        InventDimTrackingInventTransNode    _currentNode,
        Map                                 _allTransactionMap)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandReceiptTransactionIncludingWHSInventoryTransaction</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void expandReceiptTransactionIncludingWHSInventoryTransaction(
        SysRecordSortedList                 _inventTransAndWHSInventoryTransactionList,
        InventDimTrackingInventTransNode    _currentNode,
        Map                                 _allTransactionMap)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInventTransListToInventTrackingTransactionList</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static void addInventTransListToInventTrackingTransactionList(
        SysRecordSortedList _inventTrackingTransactionList,
        SysRecordSortedList _inventTransList,
        Map                 _allTransactionMap)
    {
        InventTrans         inventTrans;
        boolean             cont                = _inventTransList.first(inventTrans);
        boolean             anyChildren         = false;

        while (cont)
        {
            if (inventTrans.RecId)
            {
                str inventTransKey = InventTrackingDimTracingRelations::tracingNodeKey(inventTrans.TableId, inventTrans.RecId);

                InventTrackingTransactionInMemoryTable inventTrackingTransaction =
                    InventTrackingDimTracingSearch::convertInventTransToInventTrackingTransactionInMemoryTable(inventTrans, inventTransKey);

                _inventTrackingTransactionList.ins(inventTrackingTransaction, false);

                _allTransactionMap.insert(inventTransKey, inventTrans);
            }
            cont = _inventTransList.next(inventTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertInventTransToInventTrackingTransactionInMemoryTable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static InventTrackingTransactionInMemoryTable convertInventTransToInventTrackingTransactionInMemoryTable(InventTrans _inventTrans, str _inventTransKey)
    {
        InventTrackingTransactionInMemoryTable buffer;

        buffer.ItemId = _inventTrans.ItemId;
        buffer.DatePhysical = _inventTrans.DatePhysical;
        buffer.InventTransOrigin = _inventTrans.inventTransOrigin;
        buffer.UniqueKey = _inventTransKey;
        buffer.TransactionType = InventTrackingTransactionType::InventTrans;

        return buffer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addChildWHSInventoryTransaction2List</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static void addChildWHSInventoryTransaction2List(
        SysRecordSortedList _list,
        WHSInventoryTransactionView _transactionView)
    {
        InventTrackingTransactionInMemoryTable buffer;

        buffer.ItemId = _transactionView.ItemId;
        buffer.DatePhysical = DateTimeUtil::applyTimeZoneOffset(_transactionView.CreatedDateTimeWHSTransaction, DateTimeUtil::getUserPreferredTimeZone());
        buffer.InventTransOrigin = 0;
        buffer.UniqueKey = _transactionView.UniqueKey;
        buffer.TransactionType = InventTrackingTransactionType::WHSInventoryTransaction;

        _list.ins(buffer, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTransactionViewRecordsToListAndMap</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void addTransactionViewRecordsToListAndMap(
        InventDimTrackingInventTransNode    _currentNode,
        WHSInventoryTransactionView         _transactionView,
        SysRecordSortedList                 _inventTransAndWHSInventoryTransactionList,
        Map                                 _allTransactionMap)
    {
        while(_transactionView)
        {
            WHSInventoryTrackingTransaction whsInventoryTrackingTransaction =
                WHSInventoryTrackingTransaction::newFromInventoryTransactionView(_transactionView);

            if (this.isTrackingTransactionChild(_currentNode, whsInventoryTrackingTransaction))
            {
                InventTrackingDimTracingSearch::addChildWHSInventoryTransaction2List(_inventTransAndWHSInventoryTransactionList, _transactionView);
                _allTransactionMap.add(_transactionView.UniqueKey, _transactionView);
            }

            next _transactionView;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findWHSInventoryTransactions</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal WHSInventoryTransactionView findWHSInventoryTransactions(
        WHSInventoryTransactionTypeEnum     _transactionType,
        InventDimTrackingInventTransNode    _currentNode)
    {
        InventDim parentInventDim               = _currentNode.getInventDim();
        InventDimParm inventDimParmNonStorage   = parentInventDim.toDimParm();
        inventDimParmNonStorage.clearStorageDimensions();

        InventDimTrackingWHSInventoryTransactionNode whsInventoryTransactionNode = _currentNode as InventDimTrackingWHSInventoryTransactionNode;

        WHSInventoryTransactionView transactionView = new WHSWarehouseTransactionItemTracingQuery().findRelatedTransactions(
            _transactionType,
            parentInventDim,
            inventDimParmNonStorage,
            whsInventoryTransactionNode.parmWHSInventoryTransactionDTO());
        
        return transactionView;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>