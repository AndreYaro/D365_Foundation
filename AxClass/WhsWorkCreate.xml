<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WhsWorkCreate</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WhsWorkCreate</c> class is used to create work for different work order types.
/// </summary>
public abstract class WhsWorkCreate
{
    #WHSBuildQty
    #WHSStatusUpdateFrequency

    WHSWorkTemplateCode                     workTemplateCode;
    WHSDispositionCode                      dispositionCode;
    WHSLicensePlateId                       targetLicensePlateId;
    WHSLocDirHintCode                       locDirHintCode;
    WHSInventStatusId                       inventStatusId;
    WHSWorkTransType                        workTransType;
    WHSOriginRefId                          originRefId;
    WHSTmpWorkLine                          tmpWorkLine;
    WHSOriginType                           originType;
    WHSCreatedBy                            createdBy;
    InventLocationId                        inventLocationId;
    WMSLocationId                           startLocationId;
    container                               oldFilledValues;
    WHSWaveId                               waveId;
    InventBatchId                           inventBatchId;
    InventSerialId                          inventSerialId;
    InventQty                               workCreatedQty;
    boolean                                 unallocatedLine;
    WHSWaveId                               parmWaveId;
    WHSWaveExecutionID                      waveExecutionId;
    WHSReleaseToWarehouseId                 releaseToWarehouseId;
    boolean                                 hasReplen;
    UnitOfMeasureSymbol                     replenUOM;
    WHSReplenishmentTemplateLine            replenishmentTemplateLine;
    InventDim                               workInventDim;
    WMSLocationId                           locationId;
    WMSLocationId							finalPutLocation;
    UnitOfMeasureSymbol                     pickUnitId;
    Qty                                     pickQty;
    InventQty                               inventPickQty;
    WHSReceiptId                            receiptId;
    Map                                     dimQty;
    Map                                     dimQty2receiptDetails;
    Map                                     batchMix;
    Set                                     workTemplateTableWithNoReleatedGroup;
    WHSWaveProgressLog                      createWaveProgressLog;
    protected WHSWaveMethodStatusHandler    waveMethodStatusHandler;
    WHSParameters                           whsParameters;
    boolean                                 createWorkInventTransWithTargetLP;
    
    Map                                     fullyAllocatedLocationsMap;
    WHSContainerTypeCode                    containerTypeCode;
    boolean                                 usedLocateByLP;
    WMSLocationId                           saveLocationId;
    Set								        tmpWorkLinesExceedingMaximums;
    private WMSLocationId                   lastImmediateReplenLocationId;
    private Qty                             immediateReplenAvailQty;

    [SysObsolete('Use WhsWorkMaximumChecker instead.', false, 30\06\2020)]
    Weight                                  runningWeight;
    [SysObsolete('Use WhsWorkMaximumChecker instead.', false, 30\06\2020)]
    Volume                                  runningVolume;
    [SysObsolete('Use WhsWorkMaximumChecker instead.', false, 30\06\2020)]
    WHSEstimatedTime                        runningEstTime;
    [SysObsolete('Use WhsWorkMaximumChecker instead.', false, 30\06\2020)]
    Qty                                     runningMaxQty;
    [SysObsolete('Use WhsWorkMaximumChecker instead.', false, 30\06\2020)]
    int                                     runningPickLines;
    [SysObsolete('Use WhsWorkMaximumChecker instead.', false, 30\06\2020)]
    Qty                                     prevRunningMaxQty;
    [SysObsolete('Use WhsWorkMaximumChecker instead.', false, 30\06\2020)]
    int                                     prevRunningPickLines;
    [SysObsolete('Use WhsWorkMaximumChecker instead.', false, 30\06\2020)]
    Weight                                  prevRunningWeight;
    [SysObsolete('Use WhsWorkMaximumChecker instead.', false, 30\06\2020)]
    Volume                                  prevRunningVolume;
    [SysObsolete('Use WhsWorkMaximumChecker instead.', false, 30\06\2020)]
    WHSEstimatedTime                        prevRunningEstTime;

    WhsWorkMaximumChecker                   maximumChecker = WhsWorkMaximumChecker::construct();

    boolean                                 isImmedReplen;
    WHSInventStatusId                       fromInventStatusId;
    public WHSTmpWorkLineProcessingPriority processingPriority;
    protected EcoResReleasedProductUnitConverter unitConverter = EcoResReleasedProductUnitConverter::construct();
    WHSLoadLineWorkCreatedQuantityTracker   loadLineWorkCreatedQuantityTracker;
    private Set                             workTemplateCodesSet = new Set(Types::String);

    private WHSInstrumentationLogger        instrumentationLogger;
    private WHSWorkCreateWorkOrderType      workCreateWorkOrderType = WHSWorkCreateWorkOrderType::WorkOrder;

    private boolean                         allowMixedBatches = true;
    private InventBatchId                   replenishmentBatchId;

    private WHSTmpWorkLine                  lastInsertedSplitTmpWorkLine;

    private Map                             crossDockedQuantities; // [item, LP, inventDimId] -> remaining invent qty on cross docking work that matches these conditions

    private WHSInstrumentationLogger        logger;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmWaveMethodStatusHandler</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal WHSWaveMethodStatusHandler parmWaveMethodStatusHandler(WHSWaveMethodStatusHandler _waveMethodStatusHandler = waveMethodStatusHandler)
    {
        waveMethodStatusHandler = _waveMethodStatusHandler;

        return waveMethodStatusHandler;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFinalPutLocation</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal WMSLocationId parmFinalPutLocation(WMSLocationId _finalPutLocation = finalPutLocation)
    {
        finalPutLocation = _finalPutLocation;

        return finalPutLocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowMixedBatches</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean parmAllowMixedBatches(boolean _allowMixedBatches = allowMixedBatches)
    {
        allowMixedBatches = _allowMixedBatches;
        return allowMixedBatches;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReplenishmentBatchId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal InventBatchId parmReplenishmentBatchId(InventBatchId _replenishmentBatchId = replenishmentBatchId)
    {
        replenishmentBatchId = _replenishmentBatchId;
        return replenishmentBatchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreateWorkInventTransWithTargetLP</Name>
				<Source><![CDATA[
    public boolean parmCreateWorkInventTransWithTargetLP(boolean _createWorkInventTransWithTargetLP = createWorkInventTransWithTargetLP)
    {
        createWorkInventTransWithTargetLP = _createWorkInventTransWithTargetLP;
        return createWorkInventTransWithTargetLP;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmContainerTypeCode</Name>
				<Source><![CDATA[
    public WHSContainerTypeCode parmContainerTypeCode(WHSContainerTypeCode _containerTypeCode = containerTypeCode)
    {
        containerTypeCode = _containerTypeCode;

        return containerTypeCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFromInventStatusId</Name>
				<Source><![CDATA[
    public WHSInventStatusId parmFromInventStatusId(WHSInventStatusId _fromInventStatusId = fromInventStatusId)
    {
        fromInventStatusId = _fromInventStatusId;

        return fromInventStatusId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRangesToWorkTemplateQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds needed ranges to the work template query prior to running.
    /// </summary>
    /// <param name="_workTemplateTable">
    /// The work template being run.
    /// </param>
    /// <returns>
    /// An instance of QueryRun for the work template query.
    /// </returns>
    protected QueryRun addRangesToWorkTemplateQuery(WHSWorkTemplateTable _workTemplateTable)
    {
        QueryBuildDataSource    tmpDataSource;
        QueryRun                queryRun = new QueryRun(_workTemplateTable.WorkTemplateQuery);
        Counter                 occurance = 1;

        tmpDataSource = queryRun.query().dataSourceTable(tableNum(WHSTmpWorkLine));
        tmpDataSource.update(true);

        SysQuery::findOrCreateRange(tmpDataSource, fieldNum(WHSTmpWorkLine, WorkCreateId)).value(queryValue(this.parmWorkCreateId()));
        SysQuery::findOrCreateRange(tmpDataSource, fieldNum(WHSTmpWorkLine, WorkTemplateCode)).value(SysQuery::valueEmptyString());

        if (parmWaveId)
        {
            SysQuery::findOrCreateRange(tmpDataSource, fieldNum(WHSTmpWorkLine, WaveId)).value(parmWaveId);
        }

        if (this.mustDisableWMSLocationQueryDataSource(_workTemplateTable))
        {
            do
            {
                tmpDataSource = queryRun.query().dataSourceTable(tableNum(WMSLocation), occurance);
                ++occurance;
                if (tmpDataSource)
                {
                    tmpDataSource.enabled(false);
                }
            }
            while (tmpDataSource);
        }

        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDisableWMSLocationQueryDataSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Skips join of <c>WMSLocation</c> if we do not fail on empty location (location directive failures)
    /// and the query on the work template is not location specific.
    /// </summary>
    /// <param name = "_workTemplateTable">The work template record. </param>
    /// <returns>true if the validation succeeded; otherwise false.</returns>
    [Replaceable]
    protected boolean mustDisableWMSLocationQueryDataSource(WHSWorkTemplateTable _workTemplateTable)
    {
        return !WHSLocDirFailure::find(_workTemplateTable.WorkTransType).LocDirFailWork
            && !_workTemplateTable.queryIsLocationSpecific();
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignLocToDemandLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns warehouse location to demand lines.
    /// </summary>
    /// <param name="_wmsLocationId">
    /// Location id to be assigned.
    /// </param>
    /// <param name="_replenQty">
    /// Replenishment quantity.
    /// </param>
    /// <param name="_availQty">
    /// Available quantity.
    /// </param>
    /// <param name="_itemId">
    /// Item id.
    /// </param>
    /// <param name="_inventDimId">
    /// Item dimension id.
    /// </param>
    /// <param name="_workBuildid">
    /// Work build id.
    /// </param>
    public void assignLocToDemandLines(WMSLocationId _wmsLocationId, InventQty _replenQty, InventQty _availQty, ItemId _itemId, InventDimId _inventDimId, WHSWorkBuildId _workBuildid)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustPickPutQuantitiesForLocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Provides an extensibility point, to allow for manipulation of the quantities
    ///  returned by findPickPutLocation when creating temporary work lines.
    /// </summary>
    /// <param name = "_parameters">
    /// An object with all the necessary parameters to calculate the adjusted quantities.
    /// For more details on the different parameters, look at the <c>WHSWorkCreateAdjustQuantitiesForLocationParameters</c>.
    /// </param>
    /// <returns>
    /// A <c>WHSWorkCreateAdjustQuantitiesForLocationParameters</c> object with the updated parameters.
    /// </returns>
    [Hookable(false)]
    internal WHSWorkCreateAdjustQuantitiesForLocationParameters adjustPickPutQuantitiesForLocation(WHSWorkCreateAdjustQuantitiesForLocationParameters _parameters)
    {
        return _parameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ignoreLocationDirectiveFailureForWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if we should ignore the location directive failure setting.
    /// </summary>
    /// <returns>
    /// returns false to ignore Location Directive Failure for work.
    /// </returns>
    protected boolean ignoreLocationDirectiveFailureForWork()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>callIgnoreLocationDirectiveFailureForWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows the ignoreLocationDirectiveFailureForWork to be called outside of this class.
    /// The purpose of the method is to allow for refactoring without breaking anyone.
    /// </summary>
    /// <returns>
    /// Result of ignoreLocationDirectiveFailureForWork call.
    /// </returns>
    [Hookable(false)]
    internal final boolean callIgnoreLocationDirectiveFailureForWork()
    {
        return this.ignoreLocationDirectiveFailureForWork();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOldFilledValuesForField</Name>
				<Source><![CDATA[
    private boolean updateOldFilledValuesForField(Common _table, FieldId _fieldId, int _sequence)
    {
        boolean ret = false;

        if (oldFilledValues == conNull()
            || typeOf(_table.(_fieldId)) != typeOf(conPeek(oldFilledValues, _sequence))
            || _table.(_fieldId)         != conPeek(oldFilledValues, _sequence))
        {
            //The value must be updated
            oldFilledValues = conPoke(oldFilledValues, _sequence, _table.(_fieldId));
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildWorkTransTypeList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populate list with the <c>WHSWorkTransTypes</c> within a wave.
    /// </summary>
    /// <param name="_workCreateId">
    /// The work create id being run.
    /// </param>
    /// <returns>
    /// This method returns a list of work transaction types for a wave.
    /// </returns>
    /// <remarks>
    /// This method addresses the scenario where sales order and transfer order shipments exists on the same wave.
    /// </remarks>
    protected List buildWorkTransTypeList(WHSWorkCreateId _workCreateId)
    {
        WHSTmpWorkLine  locTmpWorkLine;
        List workTransTypeList = new List(Types::Enum);

        while select WorkTransType from locTmpWorkLine
            group by locTmpWorkLine.WorkTransType
                where locTmpWorkLine.WorkCreateId == _workCreateId
        {
            workTransTypeList.addEnd(locTmpWorkLine.WorkTransType);
        }

        return workTransTypeList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForBreak</Name>
				<Source><![CDATA[
    private boolean checkForBreak(RefRecId _refRecId, QueryRun _queryRun)
    {
        WHSWorkTemplateGroup    workTemplateGroup;
        Common                  table;
        boolean                 ret;
        int                     i = 1;

        // If it has already been determined that no template exist there is no need to query the DB again
        if (workTemplateTableWithNoReleatedGroup == null || !workTemplateTableWithNoReleatedGroup.in(_refRecId))
        {
            while select GroupFieldId, GroupTableId from workTemplateGroup
                order by workTemplateGroup.LineNum
                where workTemplateGroup.RefRecId        == _refRecId    &&
                      workTemplateGroup.WorkGroupBy     == NoYes::Yes
            {
                table = _queryRun.get(workTemplateGroup.GroupTableId);

                if (this.updateOldFilledValuesForField(table, workTemplateGroup.GroupFieldId, i))
                {
                    ret = true;
                }

                i++;
            }

            if (i==1)
            {
                // Save that no workTemplateGroup records were found for the RefRecId to avoid looking up in db next time this method is invoked
                if (workTemplateTableWithNoReleatedGroup == null)
                {
                    workTemplateTableWithNoReleatedGroup = new Set(Types::Int64);
                }
                workTemplateTableWithNoReleatedGroup.add(_refRecId);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMaximums</Name>
				<Source><![CDATA[
    private void checkMaximums(
        WHSWorkTemplateTable _workTemplateTable,
        WHSTmpWorkLine       _tmpWorkLine,
        WHSTmpWorkLine       _previousTmpWorkLine)
    {
        if (_workTemplateTable.maximumsAreSetup())
        {
            if (_previousTmpWorkLine.WorkBreak)
            {
                this.resetHeaderMaxFields(0, _workTemplateTable, _previousTmpWorkLine);
            }

            WhsWorkMaximumCheckerResult result = maximumChecker.run(_workTemplateTable, _tmpWorkLine, this.parmWorkCreateId());
            
            if (result.maximumsExceed)
            {
                this.tmpWorkLineExceedMaximums(_tmpWorkLine);
            }
            else
            {
                this.syncHeaderMaxFieldsForCompatibility();
            }

            // Split if we need to
            if (result.split || result.setWorkBreak)
            {
                LineNum lineNum;
                boolean resetMaxHeaderFields;

                [result.excessQty, lineNum, resetMaxHeaderFields] = this.processSplitHandlingQty(_workTemplateTable, _tmpWorkLine, result.minLineQty, result.maxHeaderQty, result.excessQty, result.allowMultipleSplits);

                // Reset header maximum counter fields if the line was split.
                if (lineNum != tmpWorkLine.LineNum || resetMaxHeaderFields)
                {
                    this.resetHeaderMaxFields(result.excessQty, _workTemplateTable, _tmpWorkLine);
                }
            }
            else
            {
                // If the temporary work line is not being split it still needs to have its processing priority
                // assigned and incremented to ensure temporary work lines will be processed in the correct order.
                ttsbegin;

                this.assignProcessingPriority(tmpWorkLine);
                tmpWorkLine.write();

                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleans up temporarily created work lines.
    /// </summary>
    public void cleanupTempTable()
    {
        WHSTmpWorkLine::cleanupTmpWorkLines(this.parmWorkCreateId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReceiptDimQtyMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates map tracking above location dimensions and qty to be used for work creation.
    /// </summary>
    /// <param name="_itemId">
    /// The item we are creating work for. Used to obtain above location dimensions.
    /// </param>
    protected void createReceiptDimQtyMap(ItemId _itemId)
    {
        WHSReceiptDetails   receiptDetails;
        InventDim           inventDim;
        InventDim           tmpInventDim;
        InventBatchId       tmpInventBatchId;
        boolean             batchBelow;
        Map                 inventDims;

        dimQty      = new Map(Types::String, Types::Real);
        dimQty2receiptDetails   = new Map(Types::String, Types::Class);

        // If item is batch active and batch is below location in reservation hierarchy we must track separately.
        if (WHSReservationHierarchyInventDimUtil::isBatchBelowLocation(InventTable::find(_itemId)))
        {
            batchMix    = new Map(Types::String, Types::String);
            batchBelow  = true;
        }

        // Create map to track above location dimensions and qty, based off registered inventory.
        while select InventDimId, InventQty from receiptDetails
            where receiptDetails.ReceiptId == receiptId
            exists join inventDim
                where inventDim.InventDimId     == receiptDetails.InventDimId
                &&    inventDim.LicensePlateId  == targetLicensePlateId
        {
            tmpInventDim = InventDim::find(receiptDetails.InventDimId);
            tmpInventBatchId = tmpInventDim.InventBatchId;
            tmpInventDim.clearBelowLocationDim(_itemId);
            tmpInventDim = InventDim::findOrCreate(tmpInventDim);

            if (tmpInventDim.InventDimId != InventDim::inventDimIdBlank())
            {
                if (dimQty.exists(tmpInventDim.InventDimId))
                {
                    dimQty.insert(tmpInventDim.InventDimId, (dimQty.lookup(tmpInventDim.InventDimId) + receiptDetails.InventQty));

                    inventDims = dimQty2receiptDetails.lookup(tmpInventDim.InventDimId);
                    inventDims.insert(receiptDetails.InventDimId, receiptDetails.InventQty);

                    // Blank out tracked batch below value if multiple values per above location dimension set.
                    if (batchBelow && batchMix.lookup(tmpInventDim.InventDimId) != tmpInventBatchId)
                    {
                        batchMix.insert(tmpInventDim.InventDimId, '');
                    }
                }
                else
                {
                    dimQty.insert(tmpInventDim.InventDimId, receiptDetails.InventQty);

                    inventDims = new Map(Types::String, Types::Real);
                    inventDims.insert(receiptDetails.InventDimId, receiptDetails.InventQty);
                    dimQty2receiptDetails.insert(tmpInventDim.InventDimId, inventDims);

                    if (batchBelow)
                    {
                        batchMix.insert(tmpInventDim.InventDimId, tmpInventBatchId);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingWorkLineInventDimId</Name>
				<Source><![CDATA[
    protected InventDimId getRemainingWorkLineInventDimId(InventDimId _inventDimId)
    {
        return _inventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRemainingWorkLines</Name>
				<Source><![CDATA[
    protected LineNum createRemainingWorkLines(WHSWorkId              _workId,
                                             LineNum                _lineNum,
                                             InventDimId            _inventDimId,
                                             InventTransId          _inventTransId,
                                             ItemId                 _itemId,
                                             UnitOfMeasureSymbol    _unitId,
                                             InventBatchId          _inventBatchId,
                                             InventSerialId         _inventSerialId,
                                             WHSOrderNum            _orderNum,
                                             WHSShipmentId          _shipmentId,
                                             WHSLoadId              _loadId,
                                             Qty                    _qtyWork,
                                             Qty                    _inventQtyWork,
                                             WHSTmpWorkLine         _tmpWorkLine,
                                             InventLocationId       _inventLocationId = '',
                                             WMSLocationId          _replenLocationId = '',
                                             OprNum                 _oprNum           = 0)
    {
        WHSWorkOrderLineInterface   workOrderLineInterface = this.createWorkOrderLineInterface();

        LineNum lineNum = _tmpWorkLine.WorkType == WHSWorkType::Pick ? _lineNum : 1;

        ttsbegin;

        workOrderLineInterface.parmWorkId(_workId);
        workOrderLineInterface.parmItemId(_itemId);
        workOrderLineInterface.parmInventTransId(_inventTransId);
        workOrderLineInterface.parmInventDimId(this.getRemainingWorkLineInventDimId(_inventDimId));

        real numLines = WHSWorkTemplateTable::getNumLines(_tmpWorkLine.WorkTemplateCode, _tmpWorkLine.WorkTransType);

        LineNum lineCounter;
        boolean firstLoop = true;
        
        WHSWorkTemplateLine workTemplateLine;
        boolean isWHSWorkCreatePickWorkLineInitLocationRelatedFieldsFlightEnabled = WHSWorkCreatePickWorkLineInitLocationRelatedFieldsFlight::instance().isEnabled();

        using (var orderNumProvider = WHSLocationDirectiveOrderNumProvider::create(_orderNum))
        using (var appInsightsActivity = WHSWorkCreationCreateRemainingWorkLinesApplicationInsightsActivity::newFromParameters(
            _workId,
            _itemId,
            _orderNum,
            _loadId,
            _shipmentId,
            _tmpWorkLine.WorkTransType,
            _tmpWorkLine.WorkTemplateCode))
        {
            while select workTemplateLine
            order by workTemplateLine.LineNum
            where workTemplateLine.WorkTemplateCode == _tmpWorkLine.WorkTemplateCode  &&
                  workTemplateLine.WorkTransType    == _tmpWorkLine.WorkTransType
            {
                locationId = '';
                ++lineCounter;

                // Skip first for Pick's and skip last for Put's.
                if ((_tmpWorkLine.WorkType == WHSWorkType::Pick && firstLoop) ||
                (_tmpWorkLine.WorkType == WHSWorkType::Put && lineCounter == numLines))
                {
                    firstLoop = false;
                    continue;
                }

                // Special locating for Puts on raw materials picking and replenishment work.
                WhsWorkCreateLocationQtyResult uniqueLocationResult = this.getUniqueLocatingPickQtyAndLocation(workTemplateLine, _tmpWorkLine, _replenLocationId, _inventTransId, _itemId, _inventQtyWork, _unitId, _qtyWork, _oprNum);
                if (uniqueLocationResult)
                {
                    locationId = uniqueLocationResult.locationId;
                    inventPickQty = uniqueLocationResult.inventPickQty;
                    pickUnitId = uniqueLocationResult.pickUnitId;
                    pickQty = uniqueLocationResult.pickQty;
                }

                // Potentially set location and quantity if outbound sorting process is used.
                if (!locationId)
                {
                    this.getSortingPickQtyAdLocation(_tmpWorkLine, workTemplateLine, _unitId, _qtyWork, _inventQtyWork);
                }

                // If we did not set a location using the unique logic around raw material picking and replenishment, use standard operations
                // Avoid for the final put for replenishments as it was already determined by location directives and synched with demand pick lines,
                // the final put on replenishment work template can not have a directive code so directives would not change here.
                if (!locationId
                && (_tmpWorkLine.WorkTransType  != WHSWorkTransType::Replenishment
                ||  lineCounter                 != numLines))
                {
                    this.getStandardLocatingPickQtyAndLocation(workTemplateLine, _tmpWorkLine, workOrderLineInterface, _inventLocationId, _unitId, _qtyWork, _inventQtyWork, _itemId, _inventTransId);
                }

                workOrderLineInterface.parmLineNum(lineNum);

                UnitOfMeasureSymbol unitId;
                WHSQtyWork          qtyWork;

                if (workOrderLineInterface.parmItemId())
                {
                    [qtyWork, unitId] = WHSInventTable::getHighestUnitQtyByUOMSeqGroup(workOrderLineInterface.parmItemId(), pickQty, pickUnitId, workOrderLineInterface.parmInventDimId());
                }
                else
                {
                    unitId  = pickUnitId;
                    qtyWork = pickQty;
                }

                workOrderLineInterface.parmQtyWork(qtyWork);
                workOrderLineInterface.parmUnitId(unitId);

                workOrderLineInterface = this.initRemainingWorkOrderLineLoadLineReference(lineCounter, _tmpWorkLine, workOrderLineInterface);
            
                workOrderLineInterface.initializeFromWorkTemplate(workTemplateLine);
                workOrderLineInterface.parmInventQtyWork(inventPickQty);
                workOrderLineInterface.parmwmsLocationId(locationId);
                
                if (isWHSWorkCreatePickWorkLineInitLocationRelatedFieldsFlightEnabled
                    && workOrderLineInterface.parmWorkType() == WHSWorkType::Pick)
                {
                    WMSLocation wmsLocation = WMSLocation::find(locationId, workOrderLineInterface.parmInventLocationId());

                    if (wmsLocation)
                    {
                        workOrderLineInterface.parmSortCode(wmsLocation.SortCode);
                        workOrderLineInterface.parmZoneId(wmsLocation.ZoneId);
                    }
                }

                workOrderLineInterface.parmQtyRemain(workOrderLineInterface.parmQtyWork());
                workOrderLineInterface.parmInventQtyRemain(workOrderLineInterface.parmInventQtyWork());
                workOrderLineInterface.parmOrderNum(_orderNum);
                workOrderLineInterface.parmLoadId(_loadId);
                workOrderLineInterface.parmShipmentId(_shipmentId);
                workOrderLineInterface.insert();

                firstLoop = false;

                ++lineNum;

                // After the first work line we want to use the original dimension ID if there is a status change,
                // it will happen on the user after the first pick, so remaining work lines should have the new invent status.
                workOrderLineInterface.parmInventDimId(_inventDimId);
            }

            ttscommit;
        }

        return lineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRemainingWorkOrderLineLoadLineReference</Name>
				<Source><![CDATA[
    protected WHSWorkOrderLineInterface initRemainingWorkOrderLineLoadLineReference(
        LineNum			            _lineCounter,
        WHSTmpWorkLine	            _tmpWorkLine,
        WHSWorkOrderLineInterface   _workOrderLineInterface)
    {
        if (this.shouldInitWorkOrderAbstractionWithObsoleteCode())
        {
            return WHSWorkOrderLineInterface::createInstanceFromBuffer(this.initRemainingWorkLineLoadLineReference(_lineCounter, _tmpWorkLine, _workOrderLineInterface.buffer()));
        }

        return _workOrderLineInterface;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRemainingWorkLineLoadLineReference</Name>
				<Source><![CDATA[
    [Hookable(false), SysObsolete("The method has been deprecated use initRemainingWorkOrderLineLoadLineReference instead", false, 07\12\2020)]
    protected WHSWorkLine initRemainingWorkLineLoadLineReference(
        LineNum			_lineCounter,
        WHSTmpWorkLine	_tmpWorkLine,
        WHSWorkLine		_workLine)
    {
        return _workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLocationDirective</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a location directive instance.
    /// </summary>
    /// <param name="_tmpWorkLine">Temporary work line buffer that contains the record data.</param>
    /// <returns>A new instance of the <c>WHSLocationDirective</c> class.</returns>
    protected WHSLocationDirective createLocationDirective(WHSTmpWorkLine _tmpWorkLine)
    {
        WHSLocationDirective    locationDirective = new WHSLocationDirective();

        locationDirective.setGlobals(_tmpWorkLine.WorkCreateId, _tmpWorkLine.OriginType, _tmpWorkLine.OriginRefId, _tmpWorkLine, waveExecutionId);
        locationDirective.parmUnitizeQty(_tmpWorkLine.InventUnitizeQty);
        locationDirective.parmFullyAllocatedLocationsMap(fullyAllocatedLocationsMap);

        // Set location directive global variables for replenishment.
        locationDirective.parmReplenRoundingUOM(replenUOM);
        locationDirective.parmReplenishmentTemplateLine(replenishmentTemplateLine);
        locationDirective.parmShipmentId(_tmpWorkLine.ShipmentId);
        locationDirective.parmReleaseToWarehouseId(releaseToWarehouseId);

        return locationDirective;
    }

]]></Source>
			</Method>
			<Method>
				<Name>callCreateLocationDirective</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows the createLocationDirective to be called outside of this class.
    /// The purpose of the method is to allow for refactoring without breaking anyone.
    /// </summary>
    /// <param name="_tmpWorkLine">Temporary work line buffer that contains the record data.</param>
    /// <returns>A new instance of the <c>WHSLocationDirective</c> class.</returns>
    [Hookable(false)]
    internal final WhsLocationDirective callCreateLocationDirective(WHSTmpWorkLine _tmpWorkLine)
    {
        return this.createLocationDirective(_tmpWorkLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTempLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates temporary work line record.
    /// </summary>
    /// <param name="_tmpWorkLine">
    /// Temporary work line buffer that will contain the record data.
    /// </param>
    /// <param name="_inventFindQty">
    /// Quantity of the work.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when item allocation is failed for specific order types.
    /// </exception>
    public void createTempLine(
        WHSTmpWorkLine _tmpWorkLine,
        WHSInventQty   _inventFindQty)
    {
        WHSTmpWorkLineCreator::createTmpWorkLine(this, _tmpWorkLine, _inventFindQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>locationDirectiveFailuresAllowCreatingTmpWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the location directive failures allows creating tmp work line.
    /// </summary>
    /// <param name = "_tmpWorkLine">The tmp work line.</param>
    /// <returns>A new instance with the result whether the location directive failures allow creating work.</returns>
    protected internal WHSLocationDirectiveFailuresAllowCreatingWorkResult locationDirectiveFailuresAllowCreatingTmpWorkLine(WHSTmpWorkLine _tmpWorkLine)
    {
        if (WHSLocDirFailure::find(_tmpWorkLine.WorkTransType).LocDirFailWork)
        {
            return WHSLocationDirectiveFailuresAllowCreatingWorkResult::newFailureWithMessage(strFmt("@WAX:WHSLocationDirectiveFailureDoesNotAllowCreatingWorkWithoutLocation", _tmpWorkLine.WorkTransType, _tmpWorkLine.WorkType));
        }

        return WHSLocationDirectiveFailuresAllowCreatingWorkResult::newSuccessWithMessage(strFmt("@WAX:WHSLocationDirectiveFailureAllowsCreatingWorkWithoutLocation", _tmpWorkLine.WorkTransType, _tmpWorkLine.WorkType));
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTmpWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts temporary work line into WHSTmpWorkLine table.
    /// </summary>
    /// <param name="_locTmpWorkLine">
    /// Temporary work line buffer.
    /// </param>
    /// <param name="_conn">
    /// The user connection we use to independently commit the temp table if this is wave.
    /// </param>
    protected void insertTmpWorkLine(
        WHSTmpWorkLine _locTmpWorkLine,
        UserConnection _conn)
    {
        // If this is wave then we need to independently commit the temp table so all waves can access it.
        if (parmWaveId)
        {
            _locTmpWorkLine.setConnection(_conn);
            _conn.ttsbegin();
            _locTmpWorkLine.insert();
            _conn.ttscommit();
        }
        else
        {
            _locTmpWorkLine.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>callInsertTmpWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows the insertTmpWorkLine to be called outside of this class.
    /// The purpose of the method is to allow for refactoring without breaking anyone.
    /// </summary>
    /// <param name="_locTmpWorkLine">Temporary work line buffer.</param>
    /// <param name="_conn">The user connection we use to independently commit the temp table if this is wave.</param>
    [Hookable(false)]
    internal final void callInsertTmpWorkLine(
        WHSTmpWorkLine _locTmpWorkLine,
        UserConnection _conn)
    {
        this.insertTmpWorkLine(_locTmpWorkLine, _conn);
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowCreateWorkLineOnPut</Name>
				<Source><![CDATA[
    [Hookable, SysObsolete("Please call WHSTmpWorkLineCreator::allowCreateWorkLineOnPut instead.", false, 21\2\2020)]
    private boolean allowCreateWorkLineOnPut(WHSWorkTransType _whsWorkTransType)
    {
        return WHSTmpWorkLineCreator::allowCreateWorkLineOnPut(_whsWorkTransType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>callAllowCreateWorkLineOnPut</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal final boolean callAllowCreateWorkLineOnPut(WHSWorkTransType _whsWorkTransType)
    {
        return this.allowCreateWorkLineOnPut(_whsWorkTransType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates temporary records.
    /// </summary>
    public abstract void createTempTable()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates temporary work line record and processes them to create actual work lines.
    /// </summary>
    /// <returns>
    /// Work build id of the created work.
    /// </returns>
    WHSWorkBuildId createWork()
    {
        WHSWorkBuildId  workBuildId;

        #OCCRetryCount

        try
        {
            ttsbegin;

            this.createTempTable();

            workBuildId = this.processTempTable();

            this.cleanupTempTable();

            ttscommit;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() ==0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    ttsBegin;
                    this.cleanupTempTable();
                    ttsCommit;
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        return workBuildId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeWorkInventTransFromWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the work inventory transaction from the work line.
    /// </summary>
    /// <param name = "_workLine">The work line.</param>
    /// <returns>The initialized work inventory transaction.</returns>
    protected WHSWorkInventTrans initializeWorkInventTransFromWorkLine(WHSWorkLine _workLine)
    {
        WHSWorkInventTrans workInventTrans;

        workInventTrans.initFromWorkLine(_workLine);

        return workInventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>callInitializeWorkInventTransFromWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows the initializeWorkInventTransFromWorkLine to be called outside of this class.
    /// The purpose of the method is to allow for refactoring without breaking anyone.
    /// </summary>
    /// <param name = "_workLine">The work line based on which the <c>WHSWorkInventTrans</c> is going to be initialized.</param>
    /// <returns>The initialized <c>WHSWorkInventTrans</c> record.</returns>
    [Hookable(false)]
    internal WHSWorkInventTrans callInitializeWorkInventTransFromWorkLine(WHSWorkLine _workLine)
    {
        return this.initializeWorkInventTransFromWorkLine(_workLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates the <c>WHSWorkInventTrans</c> records for a given work line.
    /// </summary>
    /// <param name="_workType">
    /// The type of work.
    /// </param>
    /// <param name="_workLine">
    /// The <c>WHSWorkLine</c> record.
    /// </param>
    private void createWorkInventTrans(WHSWorkType _workType, WHSWorkLine _workLine)
    {
        WHSWorkOrderLineInterface workOrderLineInterface = WHSWorkOrderLineInterface::createInstanceFromBuffer(_workLine);
        this.createWorkInventTransForWorkOrderLine(_workType, workOrderLineInterface);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkInventTransForWorkOrderLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates the <c>WHSWorkInventTrans</c> records for a given work line.
    /// </summary>
    /// <param name="_workType">
    /// The type of work.
    /// </param>
    /// <param name="_workOrderLineInterface">
    /// The <c>WHSWorkOrderLineInterface</c> instance.
    /// </param>
    private void createWorkInventTransForWorkOrderLine(WHSWorkType _workType, WHSWorkOrderLineInterface _workOrderLineInterface)
    {
        WHSWorkInventTransCreationParameters witParameters = WHSWorkInventTransCreationParameters::construct();
        
        witParameters.parmWorktype(_workType);
        witParameters.parmFromInventStatusId(fromInventStatusId);
        witParameters.parmTargetLicensePlateId(targetLicensePlateId);
        witParameters.parmCreateWorkInventTransWithTargetLP(this.parmCreateWorkInventTransWithTargetLP());
        witParameters.parmWorkCreateInstance(this);

        using (var context = new WHSWorkCreateReservationContext())
        {
            context.IsEnabled =
                parmWaveId &&
                _workOrderLineInterface.canMarkWorkOrderLineAsFailedDueToReservation() &&
                WHSWaveTemplateTable::find(WHSWaveTable::find(parmWaveId).WaveTemplateName).WorkCreateOnReservationFailure;
            
            _workOrderLineInterface.createWorkInventTrans(witParameters);

            if (context.IsEnabled &&
                context.ReservationFailed)
            {
                _workOrderLineInterface.markWorkOrderLineAsFailedDueToReservation();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldInitWorkOrderAbstractionWithObsoleteCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the initialization of work order line interfaces and work order interfaces
    /// should be done using obsolete code.
    /// </summary>
    /// <returns>true if the initialization should use obsolete code; false otherwise.</returns>
    [Replaceable(true), SysObsolete("This method is indented for temporary internal use only.", false, 07\12\2020)]
    protected boolean shouldInitWorkOrderAbstractionWithObsoleteCode()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initWorkOrderLineInterface</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new <c>WHSWorkOrderLineInterface</c>.
    /// </summary>
    /// <param name = "_workId">Work ID of the line.</param>
    /// <param name = "_lineNum">The line number.</param>
    /// <param name = "_whsWorkTemplateLine">A work template line that the line will be initialized from.</param>
    /// <returns>An initialized instance of <c>WHSWorkOrderLineInterface</c>.</returns>
    protected WHSWorkOrderLineInterface initWorkOrderLineInterface(
        WHSWorkId _workId,
        LineNum   _lineNum,
        WHSWorkTemplateLine _whsWorkTemplateLine)
    {
        if (this.shouldInitWorkOrderAbstractionWithObsoleteCode())
        {
            return WHSWorkOrderLineInterface::createInstanceFromBuffer(this.initWorkLine(_workId, _lineNum, _whsWorkTemplateLine));
        }

        WHSWorkOrderLineInterface workOrderLineInterface = this.createWorkOrderLineInterface();

        if (this.validateLoadLine(WHSLoadLine::findbyRecId(tmpWorkLine.LoadLineRefRecId)))
        {

            UnitOfMeasureSymbol handlingUnitId = WHSCatchWeightHelper::inventHandlingUnitId(tmpWorkLine.ItemId);

            WHSInventQtyWork inventQtyWork = unitConverter.convert(tmpWorkLine.HighestQty,
                                                                UnitOfMeasure::unitOfMeasureIdBySymbol(tmpWorkLine.HighestUnitId),
                                                                UnitOfMeasure::unitOfMeasureIdBySymbol(handlingUnitId),
                                                                NoYes::No,
                                                                tmpWorkLine.ItemId,
                                                                tmpWorkLine.InventDimId,
                                                                NoYes::No);

            workOrderLineInterface.initializeWorkLineFromTmpWorkLineAndTemplate(tmpWorkLine, inventQtyWork, _whsWorkTemplateLine);

            workOrderLineInterface.parmWorkId(_workId);
            workOrderLineInterface.parmLineNum(_lineNum);
        }

        return workOrderLineInterface;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new work line.
    /// </summary>
    /// <param name = "_workId">Work ID of the line.</param>
    /// <param name = "_lineNum">The line number.</param>
    /// <param name = "_whsWorkTemplateLine">A work template line that the line will be initialized from.</param>
    /// <returns>A new work line buffer.</returns>
    [SysObsolete("The method has been deprecated use initWorkOrderLineInterface instead", false, 07\12\2020)]
    protected WHSWorkLine initWorkLine(
        WHSWorkId _workId,
        LineNum   _lineNum,
        WHSWorkTemplateLine _whsWorkTemplateLine)
    {
        WHSWorkLine workLine;
        
        if (this.validateLoadLine(WHSLoadLine::findbyRecId(tmpWorkLine.LoadLineRefRecId)))
        {
            UnitOfMeasureSymbol handlingUnitId = WHSCatchWeightHelper::inventHandlingUnitId(tmpWorkLine.ItemId);

            // Set all of the values on the WHSWorkLine record, but do not insert it.
            workLine.initValue();
            workLine.initFromWorkTemplateLineRecord(_whsWorkTemplateLine);
            workLine.WorkId						= _workId;
            workLine.LineNum					= _lineNum;
            workLine.WorkType					= tmpWorkLine.WorkType;
            workLine.WmsLocationId				= tmpWorkLine.wmsLocationId;
            workLine.AllocatedWMSLocationId	    = tmpWorkLine.wmsLocationId;
            workLine.SortCode					= tmpWorkLine.SortCode;
            workLine.ZoneId						= tmpWorkLine.ZoneId;
            workLine.ItemId						= tmpWorkLine.ItemId;
            workLine.InventDimId				= tmpWorkLine.InventDimId;
            workLine.UnitId						= tmpWorkLine.HighestUnitId;
            workLine.QtyWork					= tmpWorkLine.HighestQty;
            workLine.InventQtyWork				= unitConverter.convert(workLine.QtyWork,
                                                                        UnitOfMeasure::unitOfMeasureIdBySymbol(workLine.UnitId),
                                                                        UnitOfMeasure::unitOfMeasureIdBySymbol(handlingUnitId),
                                                                        NoYes::No,
                                                                        tmpWorkLine.ItemId,
                                                                        tmpWorkLine.InventDimId,
                                                                        NoYes::No);
            workLine.QtyRemain					= workLine.QtyWork;
            workLine.InventQtyRemain			= workLine.InventQtyWork;
            workLine.InventTransId				= tmpWorkLine.InventTransId;
            workLine.OrderNum					= tmpWorkLine.OrderNum;
            workLine.LoadId						= tmpWorkLine.LoadId;
            workLine.ShipmentId					= tmpWorkLine.ShipmentId;
            workLine.ContainerId				= tmpWorkLine.ContainerId;
            workLine.LoadLineRefRecId			= tmpWorkLine.LoadLineRefRecId;
            workLine.ReplenDemand				= tmpWorkLine.ReplenDemand;
            workLine.AvailPhysical				= tmpWorkLine.AvailPhysical;
            workLine.FefoBatchId				= tmpWorkLine.fefoBatchId;
            workLine.LocatedLPId				= tmpWorkLine.LocatedLPId;
            workLine.ExtraInventHandlingQty		= tmpWorkLine.ExtraInventHandlingQty;
            workLine.OutboundSortPosition		= tmpWorkLine.OutboundSortPosition;
            workLine.OrderCommittedInventDimId	= tmpWorkLine.OrderCommittedInventDimId;
        }

        return workLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a <c>WHSWorkTable</c> record.
    /// </summary>
    /// <param name="_buildId">
    /// The work build Id for the work header being created.
    /// </param>
    /// <param name="_workTemplateTable">
    /// The work template being used for the work header being created.
    /// </param>
    /// <param name="_licensePlateId">
    /// The target license plate of the work header being created; optional.
    /// </param>
    /// <returns>
    /// The Work Id of the work header created.
    /// </returns>
    protected WHSWorkId createWorkTable(
        WHSWorkBuildId        _buildId,
        WHSWorkTemplateTable  _workTemplateTable,
        WHSLicensePlateId     _licensePlateId = '')
    {
        WHSWorkOrderInterface workOrderInterface;

        ttsbegin;

        workOrderInterface = this.initializeWorkOrderInterfaceFromTmpWorkLine(_workTemplateTable);

        workOrderInterface.parmTargetLicensePlateId(_licensePlateId ? _licensePlateId : targetLicensePlateId);

        workOrderInterface.assignNewWorkId();
        workOrderInterface.parmWorkBuildId(_buildId);
        workOrderInterface.parmInventQualityOrderId(tmpWorkLine.InventQualityOrderId);

        workOrderInterface.insert();

        ttscommit;

        return workOrderInterface.parmWorkId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeWorkOrderInterfaceFromTmpWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>WHSWorkOrderInterface</c> record.
    /// </summary>
    /// <param name="_workTemplateTable">
    /// The work template being used for the work header being created.
    /// </param>
    /// <returns>
    /// An initialized <c>WHSWorkOrderInterface</c> record.
    /// </returns>
    protected WHSWorkOrderInterface initializeWorkOrderInterfaceFromTmpWorkLine(WHSWorkTemplateTable _workTemplateTable)
    {
        if (this.shouldInitWorkOrderAbstractionWithObsoleteCode())
        {
            return WHSWorkOrderInterface::createInstanceFromBuffer(this.initializeWorkTableFromTmpWorkLine(_workTemplateTable));
        }

        WHSWorkOrderInterface workOrderInterface = this.createWorkOrderInterface();

        workOrderInterface.initializeWorkTableFromTmpWorkLineAndTemplate(tmpWorkLine, inventLocationId, _workTemplateTable);

        workOrderInterface.parmWorkCreatedBy(createdBy);
        workOrderInterface.parmDispositionCode(dispositionCode);

        return workOrderInterface;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeWorkTableFromTmpWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>WHSWorkTable</c> record.
    /// </summary>
    /// <param name="_workTemplateTable">
    /// The work template being used for the work header being created.
    /// </param>
    /// <returns>
    /// An initialized <c>WHSWorkTable</c> record.
    /// </returns>
    [SysObsolete("The method has been deprecated use initializeWorkOrderInterfaceFromTmpWorkLine instead", false, 07\12\2020)]
    protected WHSWorkTable initializeWorkTableFromTmpWorkLine(
        WHSWorkTemplateTable  _workTemplateTable)
    {
        WHSWorkTable workTable;

        workTable.WorkTransType                = tmpWorkLine.WorkTransType;

        InventDim inventDim                    = InventDim::find(tmpWorkLine.InventDimId);
        workTable.InventSiteId                 = inventDim.InventSiteId;
        workTable.InventLocationId             = inventLocationId ? inventLocationId : inventDim.InventLocationId;

        workTable.WaveId                       = tmpWorkLine.WaveId;
        workTable.OrderNum                     = tmpWorkLine.OrderNum;
        workTable.LoadId                       = tmpWorkLine.LoadId;
        workTable.ShipmentId                   = tmpWorkLine.ShipmentId;
        workTable.ImmediateReplenishmentUnitId = tmpWorkLine.ImmediateReplenishmentUnitId;
        // The work table container ID should be the based on how the work is being grouped.
        if (WHSWorkTemplateGroup::isGroupedBy(_workTemplateTable.RecId, tableNum(WHSTmpWorkLine), fieldNum(WHSTmpWorkLine, ContainerId)))
        {
            workTable.ContainerId = tmpWorkLine.ContainerId;
        }
        else if (WHSWorkTemplateGroup::isGroupedBy(_workTemplateTable.RecId, tableNum(WHSTmpWorkLine), fieldNum(WHSTmpWorkLine, HighestContainerId)))
        {
            workTable.ContainerId = tmpWorkLine.HighestContainerId;
        }

        workTable.AutoExecute                               = _workTemplateTable.AutoExecute;
        workTable.WorkPriority                              = _workTemplateTable.DefaultWorkPriority;
        workTable.WorkCreatedBy                             = createdBy;
        workTable.TransTxt                                  = tmpWorkLine.TransTxt;
        workTable.WorkTemplateCode                          = _workTemplateTable.WorkTemplateCode;
        workTable.WorkPoolId                                = _workTemplateTable.WorkPoolId;
        workTable.UseWorkForWaveReplen                      = tmpWorkLine.UseWorkForWaveReplen;
        workTable.CancelReplenWhenDemandCanceled            = tmpWorkLine.CancelReplenWhenDemandCanceled;
        workTable.ReplenishmentDependentWorkBlockingPolicy  = _workTemplateTable.ReplenishmentDependentWorkBlockingPolicy;
        workTable.DispositionCode       	                = dispositionCode;
        
        return workTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteShipmentTmpWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes temporary work lines created for a shipment.
    /// </summary>
    /// <param name="_shipmentId">
    /// Shipment id.
    /// </param>
    void deleteShipmentTmpWorkLines(WHSShipmentId _shipmentId)
    {
        WHSTmpWorkLine      shipmentTmpWorkLine;
        WHSWorkCreateId     workCreateId;

        workCreateId = this.parmWorkCreateId();

        ttsbegin;

        if (_shipmentId)
        {
            while select sum(InventQty) from shipmentTmpWorkLine
                group by LoadLineRefRecId
                where shipmentTmpWorkLine.ShipmentId        == _shipmentId
                    && shipmentTmpWorkLine.WorkCreateId     == workCreateId
                    && shipmentTmpWorkLine.LoadLineRefRecId != 0
            {
                WHSLoadLine::decrementWaveUpdatedLoadLineWorkCreatedQty(shipmentTmpWorkLine.LoadLineRefRecId, shipmentTmpWorkLine.InventQty, waveId);
            }

            delete_from shipmentTmpWorkLine
                where shipmentTmpWorkLine.ShipmentId        == _shipmentId
                    && shipmentTmpWorkLine.WorkCreateId     == workCreateId;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getHigherWorkTemplateLineRecId</Name>
				<Source><![CDATA[
    private RecId getHigherWorkTemplateLineRecId(WHSWorkTemplateLine _workTemplateLine)
    {
        WHSWorkTemplateLine higherTemplateLine;

        select firstonly RecId from higherTemplateLine
            where higherTemplateLine.WorkTemplateCode   == _workTemplateLine.WorkTemplateCode   &&
                    higherTemplateLine.WorkTransType    == _workTemplateLine.WorkTransType      &&
                    higherTemplateLine.LineNum           > _workTemplateLine.LineNum;

        return higherTemplateLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventDimDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for finding the inventory dimension.
    /// </summary>
    /// <param name = "_originType">The origin of the transaction.</param>
    /// <param name = "_inventTransId">The id of the transaction.</param>
    /// <param name = "_transType">The type of the transaction.</param>
    /// <param name = "_result">A <c>EventHandlerResult</c> object where an InventDimId can be returned.</param>
    [SysObsolete("Please use CoC on getInventDim from WHSTmpWorkLineCreator", false, 21\2\2020)]
    delegate void getInventDimDelegate(
        WHSOriginType    _originType,
        InventTransId    _inventTransId,
        WHSWorkTransType _transType,
        EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>callGetInventDimDelegate</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void callGetInventDimDelegate(
        WHSOriginType    _originType,
        InventTransId    _inventTransId,
        WHSWorkTransType _transType,
        EventHandlerResult _result)
    {
        this.getInventDimDelegate(_originType, _inventTransId, _transType, _result);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItemIdMergeDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for finding the item id to use when merging with the <c>WorkInventDim</c> member.
    /// </summary>
    /// <param name = "_originType">The origin of the transaction.</param>
    /// <param name = "_inventTransId">The id of the transaction.</param>
    /// <param name = "_transType">The type of the transaction.</param>
    /// <param name = "_result">A <c>EventHandlerResult</c> object where an ItemId can be returned.</param>
    [SysObsolete("Please use CoC on getInventDim from WHSTmpWorkLineCreator", false, 21\2\2020)]
    delegate void getItemIdMergeDelegate(
        WHSOriginType    _originType,
        InventTransId    _inventTransId,
        WHSWorkTransType _transType,
        EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>callGetItemIdMergeDelegate</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void callGetItemIdMergeDelegate(
        WHSOriginType    _originType,
        InventTransId    _inventTransId,
        WHSWorkTransType _transType,
        EventHandlerResult _result)
    {
        this.getItemIdMergeDelegate(_originType, _inventTransId, _transType, _result);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCrossDockQuantityAllocation</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected final void initializeCrossDockQuantityAllocation()
    {
        crossDockedQuantities = new Map(Types::Container, Types::Real);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkCreateQuantityAfterCrossDock</Name>
				<Source><![CDATA[
    protected final InventQty getWorkCreateQuantityAfterCrossDock(
        InventQty			_locInventQty,
        WHSWorkBuildId		_crossDockWorkBuildId,
        ItemId				_itemId,
        WHSLicensePlateId	_licensePlateId,
        InventDim			_inventDim)
    {
        InventQty qtyToCreateWork = _locInventQty;

        if (_crossDockWorkBuildId)
        {
            this.parmWorkCreateId(_crossDockWorkBuildId);

            if (crossDockedQuantities)
            {
                container crossDockedQuantitiesKey = [_itemId, _licensePlateId, _inventDim.InventDimId];
                InventQty crossDockedQtyForItemLPAndDim;
                InventQty allocatedCrossDockedQty;
                    
                if (!crossDockedQuantities.exists(crossDockedQuantitiesKey))
                {
                    crossDockedQtyForItemLPAndDim  = this.getCrossDockedQuantity(_licensePlateId, _crossDockWorkBuildId, _itemId, _inventDim);
                    crossDockedQuantities.insert(crossDockedQuantitiesKey, crossDockedQtyForItemLPAndDim);
                }
                else
                {
                    crossDockedQtyForItemLPAndDim = crossDockedQuantities.lookup(crossDockedQuantitiesKey);
                }

                allocatedCrossDockedQty = min(qtyToCreateWork, crossDockedQtyForItemLPAndDim);
                qtyToCreateWork = qtyToCreateWork - allocatedCrossDockedQty;
                crossDockedQtyForItemLPAndDim = crossDockedQtyForItemLPAndDim - allocatedCrossDockedQty;

                crossDockedQuantities.insert(crossDockedQuantitiesKey, crossDockedQtyForItemLPAndDim);
            }
            else
            {
                // Reduce the qty for work creation if cross docking work hass been created already.
                qtyToCreateWork = this.adjustQuantityForCrossDock(qtyToCreateWork, _licensePlateId, _crossDockWorkBuildId, _itemId, _inventDim);
            }
        }

        return qtyToCreateWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStandardLocatingPickQtyAndLocation</Name>
				<Source><![CDATA[
    private void getStandardLocatingPickQtyAndLocation(
        WHSWorkTemplateLine         _workTemplateLine,
        WHSTmpWorkLine              _tmpWorkLine,
        WHSWorkOrderLineInterface   _workOrderLineInterface,
        InventLocationId            _inventLocationId,
        UnitOfMeasureSymbol         _unitId,
        Qty                         _qtyWork,
        InventQty                   _inventQtyWork,
        ItemId                      _itemId,
        InventTransId               _inventTransId)
    {
        switch (_workTemplateLine.WorkType)
        {
            case WHSWorkType::Pick, WHSWorkType::Put:
                if (_workTemplateLine.WorkType == WHSWorkType::Pick)
                {
                    WHSWorkOrderLineInterface finalPutWorkOrderLine = _workOrderLineInterface.getLastPutWorkOrderLineForWork();

                    if (startLocationId || finalPutWorkOrderLine)
                    {
                        locationId = finalPutWorkOrderLine ? finalPutWorkOrderLine.parmWMSLocationId() : startLocationId;

                        if (_tmpWorkLine.WorkType == WHSWorkType::Pick)
                        {
                            pickUnitId      = _workOrderLineInterface.parmUnitId();
                            pickQty         = _workOrderLineInterface.parmQtyWork();
                            inventPickQty   = _workOrderLineInterface.parmInventQtyWork();
                        }
                        else
                        {
                            pickUnitId      = _unitId;
                            pickQty         = _qtyWork;
                            inventPickQty   = _inventQtyWork;
                        }

                        break;
                    }
                }

                WHSLocationDirective locationDirective = new WHSLocationDirective();
                locationDirective.setGlobals(_tmpWorkLine.WorkCreateId, _tmpWorkLine.OriginType, _tmpWorkLine.OriginRefId, _tmpWorkLine);
                locationDirective.parmIsStagingWorkLine(_workTemplateLine.isStagingLine());

                boolean finalPutLine = _workTemplateLine.isFinalPutLine();
                locationDirective.parmIsFinalPutWorkLine(finalPutLine);

                if (finalPutLine
                &&  finalPutLocation)
                {
                    locationId      = finalPutLocation;
                    pickUnitId      = _unitId;
                    pickQty         = _qtyWork;
                    inventPickQty   = _inventQtyWork;
                }
                else if (_workOrderLineInterface.parmItemId())
                {
                    this.findPickPutLocationAndQuantitiesForItem(_workOrderLineInterface, locationDirective, _tmpWorkLine, _inventQtyWork, _workTemplateLine, _unitId, _qtyWork);
                }
                else
                {
                    this.findPickPutLocationAndQuantitiesForItemMultiSKU(locationDirective, _tmpWorkLine, _inventQtyWork, _workTemplateLine, _unitId, _qtyWork, _inventLocationId);
                }

                this.locationFromMimicWork(_tmpWorkLine);

                break;

            default:
                WhsWorkTypeHandler handler = WhsWorkTypeHandler::singletonFromType(_workTemplateLine.WorkType);
                if (handler)
                {
                    WhsWorkCreateLocationQtyParameters parameters = this.createLocationQtyParameters(
                       _workTemplateLine,
                       _tmpWorkLine,
                       _inventQtyWork,
                       _unitId,
                       _qtyWork,
                       _itemId,
                       _inventTransId);

                    WhsWorkCreateLocationQtyResult result = handler.findWorkCreateLocationQty(parameters);
                    
                    if (result)
                    {
                        locationId      = result.locationId;
                        pickUnitId      = result.pickUnitId;
                        pickQty         = result.pickQty;
                        inventPickQty   = result.inventPickQty;
                    }
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPickPutLocationAndQuantitiesForItemMultiSKU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds pick, put location and quantities for the item, that have multiple SKU enabled.
    /// </summary>
    /// <param name = "_locationDirective">Location directive.</param>
    /// <param name = "_tmpWorkLine">Instance of <c>WHSTmpWorkLine</c>.</param>
    /// <param name = "_inventQtyWork">Inventory quantity.</param>
    /// <param name = "_workTemplateLine">Instance of <c>WHSWorkTemplateLine</c>.</param>
    /// <param name = "_unitId">Unit of measure.</param>
    /// <param name = "_qtyWork">Work quantity.</param>
    /// <param name = "_inventLocationId">Inventory location id.</param>
    protected void findPickPutLocationAndQuantitiesForItemMultiSKU(
        WHSLocationDirective      _locationDirective,
        WHSTmpWorkLine            _tmpWorkLine,
        InventQty                 _inventQtyWork,
        WHSWorkTemplateLine       _workTemplateLine,
        UnitOfMeasureSymbol       _unitId,
        Qty                       _qtyWork,
        InventLocationId          _inventLocationId)
    {
        [locationId, pickQty, pickUnitId, inventPickQty] = _locationDirective.findPickPutLocationMultiSKU(
                                                                                _inventLocationId,
                                                                                _tmpWorkLine.WorkTransType,
                                                                                _workTemplateLine.WorkType,
                                                                                _workTemplateLine.LocDirHintCode);

        pickUnitId      = _unitId;
        pickQty         = _qtyWork;
        inventPickQty   = _inventQtyWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPickPutLocationAndQuantitiesForItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds pick, put location and quantities for the item.
    /// </summary>
    /// <param name = "_workOrderLineInterface">Instane of <c>WHSWorkOrderLineInterface</c>.</param>
    /// <param name = "_locationDirective">Location directive.</param>
    /// <param name = "_tmpWorkLine">Instance of <c>WHSTmpWorkLine</c>.</param>
    /// <param name = "_inventQtyWork">Inventory quantity.</param>
    /// <param name = "_workTemplateLine">Instance of <c>WHSWorkTemplateLine</c>.</param>
    /// <param name = "_unitId">Unit of measure.</param>
    /// <param name = "_qtyWork">Work quantity.</param>
    protected void findPickPutLocationAndQuantitiesForItem(
        WHSWorkOrderLineInterface _workOrderLineInterface,
        WHSLocationDirective      _locationDirective,
        WHSTmpWorkLine            _tmpWorkLine,
        InventQty                 _inventQtyWork,
        WHSWorkTemplateLine       _workTemplateLine,
        UnitOfMeasureSymbol       _unitId,
        Qty                       _qtyWork)
    {
        WHSWorkOrderInterface workOrderInterface = WHSWorkOrderInterface::createInstanceFromWorkOrderLine(_workOrderLineInterface);

        [locationId, pickQty, pickUnitId, inventPickQty] = _locationDirective.findPickPutLocation(
                                                                                _workOrderLineInterface.parmInventDimId(),
                                                                                _tmpWorkLine.InventTransId,
                                                                                _workOrderLineInterface.parmItemId(),
                                                                                _inventQtyWork,
                                                                                _tmpWorkLine.WorkTransType,
                                                                                _workTemplateLine.WorkType,
                                                                                _workTemplateLine.LocDirHintCode,
                                                                                _tmpWorkLine.PackingQty,
                                                                                null,
                                                                                '',
                                                                                '',
                                                                                dispositionCode,
                                                                                null,
                                                                                '',
                                                                                workOrderInterface.parmInventSiteId(),
                                                                                workOrderInterface.parmInventLocationId());

        if (inventPickQty != _inventQtyWork)
        {
            if (this.shouldLocationIdBeClearedOnTheRemainingWorkLines(_tmpWorkLine.WorkTransType))
            {
                locationId = '';
            }

            pickUnitId      = _unitId;
            pickQty         = _qtyWork;
            inventPickQty   = _inventQtyWork;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>locationFromMimicWork</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected void locationFromMimicWork(WHSTmpWorkLine _tmpWorkLine)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStartingLineNum</Name>
				<Source><![CDATA[
    private LineNum getStartingLineNum(WHSWorkTemplateCode _workTemplateCode)
    {
        WHSWorkTemplateLine     workTemplateLine;

        select count(LineNum) from workTemplateLine
            where workTemplateLine.WorkTemplateCode == _workTemplateCode;

        return workTemplateLine.LineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUniqueLocatingLocationId</Name>
				<Source><![CDATA[
    private WMSLocationId getUniqueLocatingLocationId(
        WHSTmpWorkLine  _tmpWorkLine,
        WMSLocationId   _replenLocationId,
        InventTransId   _inventTransId,
        OprNum          _oprNum = 0)
    {
        WMSLocationId wmsLocationId;
        InventTransId inventTransId = _inventTransId;
        if (!inventTransId && !_oprNum)
        {
            inventTransId = _tmpWorkLine.InventTransId;
        }

        switch (_tmpWorkLine.WorkTransType)
        {
            case WHSWorkTransType::ProdPick:
                using (var context = new WHSProdWorkUseWorkInventLocationIdForInputLocationContext())
                {
                    context.workInventLocationId = this.getWorkInventLocationId();
                    wmsLocationId  = WHSWorkCreateWaveProd::getLocationByWorkCenter(inventTransId, _tmpWorkLine.OrderNum, _oprNum);
                }
                break;
            case WHSWorkTransType::KanbanPick:
                wmsLocationId  = WHSWorkCreateWaveKanban::getLocationByWorkCell(inventTransId, _tmpWorkLine.OrderNum);
                break;
            default:
                wmsLocationId  = _replenLocationId;
                break;
        }

        return wmsLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkInventLocationId</Name>
				<Source><![CDATA[
    protected InventLocationId getWorkInventLocationId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUniqueLocatingPickQtyAndLocationForProdAndReplenishment</Name>
				<Source><![CDATA[
    private WhsWorkCreateLocationQtyResult getUniqueLocatingPickQtyAndLocationForProdAndReplenishment(WhsWorkCreateLocationQtyParameters _parameters)
    {
        WhsWorkCreateLocationQtyResult result;
        
        if (!_parameters.workTemplateLine.LocDirHintCode
            && (_parameters.tmpWorkLine.WorkTransType == WHSWorkTransType::ProdPick
            ||  _parameters.tmpWorkLine.WorkTransType == WHSWorkTransType::KanbanPick
            ||  _parameters.tmpWorkLine.WorkTransType == WHSWorkTransType::Replenishment))
        {
            RecId higherTemplateLineRecId = this.getHigherWorkTemplateLineRecId(_parameters.workTemplateLine);
         
            if (higherTemplateLineRecId == 0)
            {
                result = WhsWorkCreateLocationQtyResult::construct();

                result.locationId = this.getUniqueLocatingLocationId(_parameters.tmpWorkLine, _parameters.replenLocationId, _parameters.inventTransId, _parameters.oprNum);
                result.inventPickQty = _parameters.inventQtyWork;

                if (_parameters.itemId)
                {
                    result.pickUnitId = WHSCatchWeightHelper::inventHandlingUnitId(_parameters.itemId);
                    result.pickQty = _parameters.inventQtyWork;
                }
                else
                {
                    result.pickUnitId = _parameters.unitId;
                    result.pickQty = _parameters.qtyWork;
                }
            }
        }
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUniqueLocatingPickQtyAndLocationDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for finding a unique picking quantity and location.
    /// </summary>
    /// <param name = "_parameters">The parameters for the finding the result.</param>
    /// <param name = "_eventHandlerResult">A <c>EventHandlerResult</c> class where a result can be returned.</param>
    delegate void getUniqueLocatingPickQtyAndLocationDelegate(WhsWorkCreateLocationQtyParameters _parameters, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLocationQtyParameters</Name>
				<Source><![CDATA[
    private WhsWorkCreateLocationQtyParameters createLocationQtyParameters(
        WHSWorkTemplateLine _workTemplateLine,
        WHSTmpWorkLine      _tmpWorkLine,
        InventQty           _inventQtyWork,
        UnitOfMeasureSymbol _unitId,
        Qty                 _qtyWork,
        ItemId              _itemId,
        InventTransId       _inventTransId,
        WMSLocationId       _replenLocationId = '',
        OprNum              _oprNum = 0)
    {
        WhsWorkCreateLocationQtyParameters parameters = WhsWorkCreateLocationQtyParameters::construct();

        parameters.workTemplateLine       = _workTemplateLine;
        parameters.tmpWorkLine            = _tmpWorkLine;
        parameters.replenLocationId       = _replenLocationId;
        parameters.inventTransId          = _inventTransId;
        parameters.itemId                 = _itemId;
        parameters.inventQtyWork          = _inventQtyWork;
        parameters.unitId                 = _unitId;
        parameters.qtyWork                = _qtyWork;
        parameters.oprNum                 = _oprNum;
        parameters.whsWorkCreate          = this;

        return parameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUniqueLocatingPickQtyAndLocation</Name>
				<Source><![CDATA[
    private WhsWorkCreateLocationQtyResult getUniqueLocatingPickQtyAndLocation(
        WHSWorkTemplateLine _workTemplateLine,
        WHSTmpWorkLine      _tmpWorkLine,
        WMSLocationId       _replenLocationId,
        InventTransId       _inventTransId,
        ItemId              _itemId,
        InventQty           _inventQtyWork,
        UnitOfMeasureSymbol _unitId,
        Qty                 _qtyWork,
        OprNum              _oprNum)
    {
        WhsWorkCreateLocationQtyParameters parameters = this.createLocationQtyParameters(
           _workTemplateLine,
           _tmpWorkLine,
           _inventQtyWork,
           _unitId,
           _qtyWork,
           _itemId,
           _inventTransId,
           _replenLocationId,
           _oprNum);

        WhsWorkCreateLocationQtyResult locationQtyResult = this.getUniqueLocatingPickQtyAndLocationForProdAndReplenishment(parameters);

        if (!locationQtyResult)
        {
            EventHandlerResult eventHandlerResult = EventHandlerResult::newSingleResponse();
            this.getUniqueLocatingPickQtyAndLocationDelegate(parameters, eventHandlerResult);

            if (eventHandlerResult.hasResult())
            {
                locationQtyResult = eventHandlerResult.result() as WhsWorkCreateLocationQtyResult;
            }
        }

        return locationQtyResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>killFailedShipments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loops over shipments that failed location directives and determines if any work should be created or not.
    /// If no work is to be created then it deleted tmpWorkLines for the shipment.
    /// </summary>
    public void killFailedShipments()
    {
        boolean hasFailedShipments = false;

        WHSWaveFailedShipment   failedShipment;
        WHSShipmentTable        shipment;
        str removedShipmentErrorMessage;
        WHSWaveFailureErrorTypes failedShipmentErrorType;
        
        boolean autoAddShipmentToWaveEnabledFlight = WHSAutoAddShipmentToWaveEnabledFlight::instance().isEnabled();
        boolean logWaveLineDeleteUnprocessedPendingAllocationFlight = WHSWaveUnprocessedPendingAllocationWaveLineDeleteLoggingFlight::instance().isEnabled();
        
        while select shipment
            exists join failedShipment
            where shipment.ShipmentId   == failedShipment.ShipmentId
            &&    failedShipment.WaveId == waveId
        {
            hasFailedShipments = true;
            warning(strFmt("@WAX3237", shipment.ShipmentId));
            removedShipmentErrorMessage  = strFmt("@WAX3237", shipment.ShipmentId);

            using (var logWaveLineDeleteData = WHSWaveUnprocessedPendingAllocationWaveLineDeleteLoggingContext::newFromParameter(logWaveLineDeleteUnprocessedPendingAllocationFlight))
            {
                // If entire order must be filled delete the tmpWorkLines created.
                if (this.shouldShipmentFillEntireOrder(shipment))
                {
                    using (var workCreateActivityContext = logger.workCreateActivities().workCreateKillFailedShipmentsFillEntireOrder())
                    {
                        logger.logRecordInformation(shipment);

                        this.deleteShipmentTmpWorkLines(shipment.ShipmentId);
                        WHSWorkCreateHistory::createWorkHistoryLine(this.parmWorkCreateId(), strFmt("@WAX3046", shipment.ShipmentId), true);
                        WHSPostEngine::createWaveExecutionHistoryLine(shipment.WaveId, waveExecutionId, strFmt("@WAX3046", shipment.ShipmentId), true, null, this.parmWorkCreateId());
                        warning(strFmt("@WAX3046", shipment.ShipmentId));
                        WHSShipmentTable::reverseShipment(shipment.ShipmentId);
                        removedShipmentErrorMessage  = removedShipmentErrorMessage + ' ' + strFmt("@WAX3046", shipment.ShipmentId);
                        failedShipmentErrorType = WHSWaveFailureErrorTypes::LocationDirectiveFailure;
                    }
                }
                else if (!shipment.hasWorkOrTemporaryWorkLines())
                {
                    WHSPostEngine::createWaveExecutionHistoryLine(shipment.WaveId, waveExecutionId, strFmt("@WAX1972", shipment.ShipmentId, shipment.WaveId), true, null, this.parmWorkCreateId());
                    warning(strFmt("@WAX1972", shipment.ShipmentId, shipment.WaveId));
                    WHSShipmentTable::reverseShipment(shipment.ShipmentId);
                    removedShipmentErrorMessage  = removedShipmentErrorMessage + ' ' + strFmt("@WAX1972", shipment.ShipmentId);
                    failedShipmentErrorType = WHSWaveFailureErrorTypes::WorkIsNotCreated;
                }
            }

            if(autoAddShipmentToWaveEnabledFlight)
            {
                WHSWaveProcessingRemovedShipment::updateOrCreateRemovedShipment(shipment.shipmentId, waveId, shipment.ShipmentStatus, failedShipmentErrorType, removedShipmentErrorMessage);
            }
        }

        if (hasFailedShipments)
        {
            this.deleteFailedShipments();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldShipmentFillEntireOrder</Name>
				<Source><![CDATA[
    protected boolean shouldShipmentFillEntireOrder(WHSShipmentTable _shipment)
    {
        if (WHSFillEntireShipmentOnShipmentProcessingPolicyFlight::instance().isEnabled())
        {
            return _shipment.shouldFillEntireShipment();
        }
        else
        {
            return WHSCustTable::find(_shipment.AccountNum).FillEntireOrder;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteFailedShipments</Name>
				<Source><![CDATA[
    private void deleteFailedShipments()
    {
        WHSWaveFailedShipment failedShipment;
        
        Microsoft.Dynamics.Ax.Xpp.PlatformExtensions.CommonExtensions::SetSqlDeleteIndexHint(failedShipment, indexStr(WHSWaveFailedShipment, WaveIdShipmentIdIdx));

        delete_from failedShipment
            where failedShipment.WaveId == waveId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new(Common _common, WHSWorkCreateId _workCreateId = '')
    {
        whsParameters = WHSParameters::find();

        createWaveProgressLog   = whsParameters.WaveProgressLog;

        fullyAllocatedLocationsMap  = new Map(Types::String, Types::Class);

        logger = WHSInstrumentationLogger::instance(classStr(WhsWorkCreate));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreatedBy</Name>
				<Source><![CDATA[
    public WHSCreatedBy parmCreatedBy(WHSCreatedBy _createdBy = createdBy)
    {
        createdBy = _createdBy;

        return createdBy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDispositionCode</Name>
				<Source><![CDATA[
    public WHSDispositionCode parmDispositionCode(WHSDispositionCode _dispositionCode = dispositionCode)
    {
        boolean isDispositionCodeUpdated = dispositionCode != _dispositionCode;
        dispositionCode = _dispositionCode;

        if (isDispositionCodeUpdated && dispositionCode)
        {
            WHSDispositionTable dispositionTable = WHSDispositionTable::find(dispositionCode);
            if (dispositionTable.WorkTemplateCode)
            {
                workTemplateCode = dispositionTable.WorkTemplateCode;
            }
            inventStatusId = dispositionTable.InventStatusId;
        }

        return dispositionCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHasReplen</Name>
				<Source><![CDATA[
    public boolean parmHasReplen(boolean _hasReplen = hasReplen)
    {
        hasReplen = _hasReplen;

        return hasReplen;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWorkInventDim</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal InventDim parmWorkInventDim(InventDim _workInventDim = workInventDim)
    {
        workInventDim = _workInventDim;

        return workInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsImmedReplen</Name>
				<Source><![CDATA[
    public boolean parmIsImmedReplen(boolean _isImmedReplen = isImmedReplen)
    {
        isImmedReplen = _isImmedReplen;

        return isImmedReplen;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventBatchId</Name>
				<Source><![CDATA[
    public InventBatchId parmInventBatchId(InventBatchId _inventBatch = inventBatchId)
    {
        inventBatchId = _inventBatch;

        return inventBatchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventSerialId</Name>
				<Source><![CDATA[
    public InventBatchId parmInventSerialId(InventSerialId _inventSerial = inventSerialId)
    {
        inventSerialId = _inventSerial;

        return inventSerialId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventLocationId</Name>
				<Source><![CDATA[
    public InventLocationId parmInventLocationId(InventLocationId  _inventLocationId = inventLocationId)
    {
        inventLocationId = _inventLocationId;

        return inventLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventStatusId</Name>
				<Source><![CDATA[
    public WHSInventStatusId parmInventStatusId(WHSInventStatusId _inventStatusId = inventStatusId)
    {
        inventStatusId = _inventStatusId;

        return inventStatusId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLocDirHintCode</Name>
				<Source><![CDATA[
    public WHSLocDirHintCode parmLocDirHintCode(WHSLocDirHintCode _locDirHintCode = locDirHintCode)
    {
        locDirHintCode = _locDirHintCode;

        return locDirHintCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOrginType</Name>
				<Source><![CDATA[
    public WHSOriginType parmOrginType(WHSOriginType _originType = originType)
    {
        originType = _originType;

        return originType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmWaveId</Name>
				<Source><![CDATA[
    public WHSWaveId parmParmWaveId(WHSWaveId _waveId = parmWaveId)
    {
        parmWaveId = _waveId;

        return parmWaveId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReceiptId</Name>
				<Source><![CDATA[
    public WHSReceiptId parmReceiptId(WHSReceiptId _receiptId = receiptId)
    {
        receiptId = _receiptId;

        return receiptId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReleaseToWarehouseId</Name>
				<Source><![CDATA[
    public WHSReleaseToWarehouseId parmReleaseToWarehouseId(WHSReleaseToWarehouseId _releaseToWarehouseId = releaseToWarehouseId)
    {
        releaseToWarehouseId = _releaseToWarehouseId;

        return releaseToWarehouseId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReplenishmentTemplateLine</Name>
				<Source><![CDATA[
    public WHSReplenishmentTemplateLine parmReplenishmentTemplateLine(WHSReplenishmentTemplateLine _replenishmentTemplateLine = replenishmentTemplateLine)
    {
        replenishmentTemplateLine = _replenishmentTemplateLine;

        return replenishmentTemplateLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReplenUOM</Name>
				<Source><![CDATA[
    public UnitOfMeasureSymbol parmReplenUOM(UnitOfMeasureSymbol _replenUOM = replenUOM)
    {
        replenUOM = _replenUOM;

        return replenUOM;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStartLocationId</Name>
				<Source><![CDATA[
    public WMSLocationId parmStartLocationId(WMSLocationId _startLocationId = startLocationId)
    {
        startLocationId = _startLocationId;

        return startLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTargetLicensePlateId</Name>
				<Source><![CDATA[
    public WHSLicensePlateId parmTargetLicensePlateId(WHSLicensePlateId _targetLicensePlateId = targetLicensePlateId)
    {
        targetLicensePlateId = _targetLicensePlateId;

        return targetLicensePlateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTmpWorkLine</Name>
				<Source><![CDATA[
    public WHSTmpWorkLine parmTmpWorkLine(WHSTmpWorkLine _tmpWorkLine = tmpWorkLine)
    {
        tmpWorkLine = _tmpWorkLine;

        return tmpWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUsedLocateByLP</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean parmUsedLocateByLP(boolean _usedLocateByLP = usedLocateByLP)
    {
        usedLocateByLP = _usedLocateByLP;

        return usedLocateByLP;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveLocationId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal WMSLocationId parmSaveLocationId(WMSLocationId _saveLocationId = saveLocationId)
    {
        saveLocationId = _saveLocationId;

        return saveLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLastImmediateReplenLocationId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal WMSLocationId parmLastImmediateReplenLocationId(WMSLocationId _lastImmediateReplenLocationId = lastImmediateReplenLocationId)
    {
        lastImmediateReplenLocationId = _lastImmediateReplenLocationId;

        return lastImmediateReplenLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmImmediateReplenAvailQty</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal Qty parmImmediateReplenAvailQty(Qty _immediateReplenAvailQty = immediatereplenAvailQty)
    {
        immediateReplenAvailQty = _immediateReplenAvailQty;

        return immediateReplenAvailQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUnallocatedLine</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean parmUnallocatedLine(boolean _unallocatedLine = unallocatedLine)
    {
        unallocatedLine = _unallocatedLine;

        return unallocatedLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFullyAllocatedLocationsMap</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal Map parmFullyAllocatedLocationsMap(Map _fullyAllocatedLocationsMap = fullyAllocatedLocationsMap)
    {
        fullyAllocatedLocationsMap = _fullyAllocatedLocationsMap;

        return fullyAllocatedLocationsMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWaveExecutionId</Name>
				<Source><![CDATA[
    public WHSWaveExecutionID parmWaveExecutionId(WHSWaveExecutionID _waveExecutionId = waveExecutionId)
    {
        waveExecutionId = _waveExecutionId;

        return waveExecutionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWorkCreatedQty</Name>
				<Source><![CDATA[
    public InventQty parmWorkCreatedQty(InventQty _workCreatedQty = workCreatedQty)
    {
        workCreatedQty = _workCreatedQty;

        return workCreatedQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWorkCreateId</Name>
				<Source><![CDATA[
    public abstract WHSWorkCreateId parmWorkCreateId(WHSWorkCreateId _workCreateId = '')
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWorkTemplateCode</Name>
				<Source><![CDATA[
    public WHSWorkTemplateCode parmWorkTemplateCode(WHSWorkTemplateCode _workTemplateCode = workTemplateCode)
    {
        workTemplateCode = _workTemplateCode;

        return workTemplateCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWorkTransType</Name>
				<Source><![CDATA[
    public WHSWorkTransType parmWorkTransType(WHSWorkTransType _workTransType = workTransType)
    {
        workTransType = _workTransType;

        return workTransType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moreTmpWorkLinesToProcess</Name>
				<Source><![CDATA[
    private boolean moreTmpWorkLinesToProcess(WHSWorkCreateId _workCreateId)
    {
        WHSTmpWorkLine countTmpWorkLine;

        if (_workCreateId)
        {
            select firstonly RecId from countTmpWorkLine
                where countTmpWorkLine.WorkCreateId == _workCreateId
                    && countTmpWorkLine.WorkId == '';
        }

        return (countTmpWorkLine.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>numTmpWorkLineToCreateWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns count of temporary work lines available to create works.
    /// </summary>
    /// <returns>
    /// The count of temporary work lines available for creation of works.
    ///</returns>
    final int64 numTmpWorkLineToCreateWork()
    {
        WHSTmpWorkLine  locTmpWorkLine;

        select count(RecId) from locTmpWorkLine
            where locTmpWorkLine.WorkCreateId == this.parmWorkCreateId();

        return locTmpWorkLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process temporary records and creates work lines to be executed.
    /// </summary>
    /// <returns>
    /// Work creation id.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when some work are not created successfully.
    /// </exception>
    public WHSWorkBuildId processTempTable()
    {
        WHSWorkCreateId workCreateId = this.parmWorkCreateId();

        // Create a list of the work transaction types within a wave and assign an enumerator to traverse the list.
        ListEnumerator enumerator = this.buildWorkTransTypeList(workCreateId).getEnumerator();

        // Loop over the list of work transaction types.
        while (enumerator.moveNext())
        {
            select firstonly tmpWorkLine
                where tmpWorkLine.WorkCreateId == workCreateId
                &&    tmpWorkLine.WorkTransType == enumerator.current();

            WHSWorkType workType = tmpWorkLine.WorkType;
            workTransType = tmpWorkLine.WorkTransType;
            originRefId   = tmpWorkLine.OriginRefId;

            ttsbegin;

            WHSWorkTemplateTable workTemplateTable;

            QueryRun workTemplateTableQueryRun = this.createWorkTemplateTableQueryRun(workTransType);

            while (workTemplateTableQueryRun.next())
            {
                workTemplateTable = workTemplateTableQueryRun.get(tableNum(WHSWorkTemplateTable));

                if (!this.moreTmpWorkLinesToProcess(workCreateId))
                {
                    break;
                }

                QueryRun queryRun = this.addRangesToWorkTemplateQuery(workTemplateTable);

                tmpWorkLinesExceedingMaximums = new Set(Types::Int64);
                
                boolean areWorkTemplateTableMaximumsSet                         = workTemplateTable.maximumsAreSetup();
                boolean shouldCheckForBreakDuringCompleteTempTableProcessing    = !areWorkTemplateTableMaximumsSet;

                this.addMissingSelectionFieldsToGroupWorkBy(workTemplateTable.RecId, queryRun);

                if (areWorkTemplateTableMaximumsSet)
                {
                    this.processWorkTemplateMaximumsAndWorkBreaks(queryRun, workTemplateTable);

                    queryRun.reset();
                    queryRun.query().dataSourceTable(tableNum(WHSTmpWorkLine)).addOrderByField(fieldNum(WHSTmpWorkLine, ProcessingPriority), SortOrder::Ascending);
                }

                if (waveMethodStatusHandler)
                {
                    waveMethodStatusHandler.setTotalSteps(this.numTmpWorkLineToCreateWork());
                }

                WHSTmpWorkLine                     locTmpWorkLine;
                WHSWorkTemplateLine                workTemplateLine;
                WHSWorkOrderLineInterface          workOrderLineInterface;
                WHSWorkId                          workId;
                WHSRecordSortedListWorkTypeWrapper workLineListWrapper;
                LineNum                            lineNum;
                UnitOfMeasureSymbol                highestUOM;
                Qty                                runningQtyWork;
                Qty                                runningInventQtyWork;
                boolean                            hasBreak;
                WMSLocationId                      replenLocationId;
                WhsWorkOrderLineComparer           lineComparer = WhsWorkOrderLineComparer::construct();
                boolean                            isOprNumDiff;
                OprNum                             prevOprNum;

                // Process the complete temp table.
                while (queryRun.next())
                {
                    tmpWorkLine = queryRun.get(tableNum(WHSTmpWorkLine));
                    using (var appInsightsActivity = WHSWorkCreationProcessTempWorkLineApplicationInsightsActivity::newFromParameters(tmpWorkLine, workTemplateTable.WorkTemplateCode))
                    {                   
                        WHSWaveMethodStatusHandler::makeOneStepForward(waveMethodStatusHandler);
     
                        if (tmpWorkLinesExceedingMaximums.in(tmpWorkLine.RecId))
                        {
                            continue;
                        }

                        if (tmpWorkLine.WorkTemplateCode)
                        {
                            continue;
                        }

                        if (tmpWorkLine.WorkTransType == WHSWorkTransType::Replenishment)
                        {
                            if (tmpWorkLine.RefTableId == tableNum(WHSReplenishmentTemplateLine)
                            && this.parmReplenishmentTemplateLine().RecId != tmpWorkLine.RefRecId)
                            {
                                WHSReplenishmentTemplateLine replTmpLine = WHSReplenishmentTemplateLine::findByRecId(tmpWorkLine.RefRecId);
                        
                                if (replTmpLine)
                                {
                                    if (replTmpLine.WorkTemplateCode
                                    && workTemplateTable.WorkTemplateCode != replTmpLine.WorkTemplateCode)
                                    {
                                        continue;
                                    }
                                    else
                                    {
                                        this.parmReplenishmentTemplateLine(replTmpLine);
                                    }
                                }
                            }

                            this.parmWorkTemplateCode(this.parmReplenishmentTemplateLine().WorkTemplateCode);
                        }

                        tmpWorkLine.WorkTemplateCode = workTemplateTable.WorkTemplateCode;
                        tmpWorkLine.update();

                        if ((shouldCheckForBreakDuringCompleteTempTableProcessing
                            && this.checkForBreak(workTemplateTable.RecId, queryRun))
                            || !workId
                            || hasBreak)
                        {
                            if (workId)
                            {
                                LineNum startingLineNum = this.createRemainingWorkLines(workId,
                                                                        lineNum,
                                                                        lineComparer.isInventDimDiff         ? lineComparer.isProductDimDiff ? InventDim::inventDimIdBlank() : InventDim::findOrCreateProductInventDimId(workOrderLineInterface.parmItemId(), workOrderLineInterface.inventDim()) : workOrderLineInterface.parmInventDimId(),
                                                                        lineComparer.isInventTransDiff       ? '' : workOrderLineInterface.parmInventTransId(),
                                                                        lineComparer.isItemIdDiff            ? '' : lineComparer.isProductDimDiff ? '' : workOrderLineInterface.parmItemId(),
                                                                        lineComparer.isItemIdDiff            ? '' : highestUOM ? highestUOM : workOrderLineInterface.parmUnitId(),
                                                                        lineComparer.isInventBatchIdDiff     ? '' : workOrderLineInterface.inventDim().InventBatchId,
                                                                        lineComparer.isInventSerialIdDiff    ? '' : workOrderLineInterface.inventDim().InventSerialId,
                                                                        lineComparer.isOrderNumDiff          ? '' : workOrderLineInterface.parmOrderNum(),
                                                                        lineComparer.isShipmentDiff          ? '' : workOrderLineInterface.parmShipmentId(),
                                                                        lineComparer.isLoadDiff              ? '' : workOrderLineInterface.parmLoadId(),
                                                                        runningQtyWork,
                                                                        runningInventQtyWork,
                                                                        locTmpWorkLine,
                                                                        workOrderLineInterface.parmInventLocationId(),
                                                                        replenLocationId,
                                                                        isOprNumDiff                        ? 0 : prevOprNum);

                                this.insertWorkLineList(workLineListWrapper.parmRecordSortedList(), workLineListWrapper.parmWorkType(), startingLineNum);
                                this.createWorkInventTransRecordsForWorkLineList(workLineListWrapper.parmRecordSortedList(), workLineListWrapper.parmWorkType());
                            }

                            workId = this.createWorkTable(workCreateId,
                                                  workTemplateTable,
                                                  tmpWorkLine.LicensePlateId);

                            replenLocationId        = tmpWorkLine.ReplenLocationId;
                            workLineListWrapper     = null;
                            lineComparer.reset();

                            isOprNumDiff            = false;
                            prevOprNum              = 0;
                            highestUOM              = '';
                            runningQtyWork          = 0;
                            runningInventQtyWork    = 0;

                            workTemplateLine = WHSWorkTemplateLine::findForFirstPickOrLastPut(tmpWorkLine.WorkTemplateCode,
                                                                                            tmpWorkLine.WorkType,
                                                                                            tmpWorkLine.WorkTransType);
                        
                            lineNum = workTemplateLine.LineNum;
                            workLineListWrapper = this.createRecordSortedListForWorkOrderLines(workType);
                        }

                        buf2Buf(tmpWorkLine, locTmpWorkLine);

                        workOrderLineInterface = this.initWorkOrderLineInterface(workId, lineNum, workTemplateLine);
                        workLineListWrapper.ins(workOrderLineInterface);

                        if (loadLineWorkCreatedQuantityTracker != null)
                        {
                            loadLineWorkCreatedQuantityTracker.trackWorkCreatedQuantity(workOrderLineInterface.parmInventQtyWork(), workOrderLineInterface.parmLoadLineRefRecId());
                        }

                        tmpWorkLine.WorkCreated = NoYes::Yes;
                        tmpWorkLine.WorkId = workId;
                        tmpWorkLine.update();
                        WHSWorkCreationProcessTempWorkLineApplicationInsightsActivity::addWorkIdAsSharedProperty(workId);

                        WHSWorkOrderInterface cleanupWorkOrderInterface = this.initializeCleanupWorkOrderInterfaceFromTmpWorkLine();
                        cleanupWorkOrderInterface.update();

                        lineComparer.compare(workOrderLineInterface);
                    
                        isOprNumDiff            = lineComparer.isOrderNumDiff || isOprNumDiff || (prevOprNum && prevOprNum != tmpWorkLine.ProdBOMOprNum);
                        prevOprNum              = tmpWorkLine.ProdBOMOprNum;

                        runningInventQtyWork    += workOrderLineInterface.parmInventQtyWork();
                        if (!lineComparer.isItemIdDiff)
                        {
                            [runningQtyWork, highestUOM] = WHSInventTable::getHighestUnitQtyByUOMSeqGroup(workOrderLineInterface.parmItemId(),
                                                                                                    runningInventQtyWork,
                                                                                                    WHSCatchWeightHelper::inventHandlingUnitId(workOrderLineInterface.parmItemId()),
                                                                                                    workOrderLineInterface.parmInventDimId());
                        }
                        else
                        {
                            runningQtyWork = runningInventQtyWork;
                            highestUOM = '';
                        }

                        hasBreak = tmpWorkLine.WorkBreak;

                        ++lineNum;
                    }
                }

                if (!workId)
                {
                    WHSWorkCreateHistory::createWorkHistoryLineFromTmpWorkLine(
                                                                this.parmWorkCreateId(),
                                                                strFmt("@WAX1740", workTemplateTable.WorkTemplateCode),
                                                                true,
                                                                tmpWorkLine);

                    continue;
                }

                InventDim batchDiffInventDim;

                if (lineComparer.isInventDimBatchDiff)
                {
                    batchDiffInventDim = workOrderLineInterface.inventDim();
                    batchDiffInventDim.InventBatchId        = '';
                    batchDiffInventDim.LicensePlateId       = '';
                    batchDiffInventDim.wmsLocationId        = '';
                    batchDiffInventDim = InventDim::findOrCreate(batchDiffInventDim);
                }
            
                LineNum startingLineNum;

                using (WHSCreateRemainingLinesCommonDimensionsContext context = WHSCreateRemainingLinesCommonDimensionsContext::construct())
                using (WHSLocationDirectiveWorkIdProvider workIdProvider = WHSLocationDirectiveWorkIdProvider::create(workId))
                {
                    InventDimId inventDimIdForRemainingLines = lineComparer.isInventDimDiff
                        ? lineComparer.isProductDimDiff 
                            ? InventDim::inventDimIdBlank() 
                            : InventDim::findOrCreateProductInventDimId(workOrderLineInterface.parmItemId(), workOrderLineInterface.inventDim())
                        : lineComparer.isInventDimBatchDiff 
                            ? batchDiffInventDim.InventDimId 
                            : workOrderLineInterface.parmInventDimId();
                    
                    if (context && !lineComparer.isInventStatusIdDiff)
                    {
                        context.parmInventStatusId(workOrderLineInterface.inventDim().InventStatusId);
                    }


                    startingLineNum = this.createRemainingWorkLines(workId,
                                                                lineNum,
                                                                inventDimIdForRemainingLines,
                                                                lineComparer.isInventTransDiff       ? '' : workOrderLineInterface.parmInventTransId(),
                                                                lineComparer.isItemIdDiff            ? '' : lineComparer.isProductDimDiff ? '' : workOrderLineInterface.parmItemId(),
                                                                lineComparer.isItemIdDiff            ? '' : highestUOM ? highestUOM : workOrderLineInterface.parmUnitId(),
                                                                lineComparer.isInventBatchIdDiff     ? '' : workOrderLineInterface.inventDim().InventBatchId,
                                                                lineComparer.isInventSerialIdDiff    ? '' : workOrderLineInterface.inventDim().InventSerialId,
                                                                lineComparer.isOrderNumDiff          ? '' : workOrderLineInterface.parmOrderNum(),
                                                                lineComparer.isShipmentDiff          ? '' : workOrderLineInterface.parmShipmentId(),
                                                                lineComparer.isLoadDiff              ? '' : workOrderLineInterface.parmLoadId(),
                                                                runningQtyWork,
                                                                runningInventQtyWork,
                                                                locTmpWorkLine,
                                                                workOrderLineInterface.parmInventLocationId(),
                                                                replenLocationId,
                                                                isOprNumDiff                         ? 0 : prevOprNum);
                }

                this.insertWorkLineList(workLineListWrapper.parmRecordSortedList(), workLineListWrapper.parmWorkType(), startingLineNum);
                this.createWorkInventTransRecordsForWorkLineList(workLineListWrapper.parmRecordSortedList(), workLineListWrapper.parmWorkType());

                WHSWorkCreateHistory::createWorkHistoryLineFromTmpWorkLine(
                                                            this.parmWorkCreateId(),
                                                            strFmt("@WAX1752", workTemplateTable.WorkTemplateCode),
                                                            false,
                                                            locTmpWorkLine);
            }

            this.updateProdBOMPoolWavedQty(workCreateId);

            this.createWaveAndWorkExecutionHistory(workCreateId);

            ttscommit;
        }

        if (this.shouldEstimatedLaborStandardsTime())
        {
            // Estimate the labor standards time once for the workCreateId.
            WHSLaborStandards laborStandards = new WHSLaborStandards(workCreateId);
            laborStandards.computeEstimatedTime();
        }

        return workCreateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWaveAndWorkExecutionHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates wave and work execution history.
    /// </summary>
    /// <param name = "_workCreateId">The work create ID.</param>
    protected void createWaveAndWorkExecutionHistory(WHSWorkCreateId _workCreateId)
    {
        // Validate that we created Work for each line.

        WHSTmpWorkLine locTmpWorkLine;

        select firstonly locTmpWorkLine
            where locTmpWorkLine.WorkCreateId   == _workCreateId		&&
                    locTmpWorkLine.WorkCreated    == NoYes::No      &&
                    locTmpWorkLine.WorkTransType  == workTransType  &&
                    (parmWaveId == '' || locTmpWorkLine.WaveId == parmWaveId);

        if (locTmpWorkLine.RecId != 0)
        {
            WHSWorkCreateHistory::createWorkHistoryLineFromTmpWorkLine(this.parmWorkCreateId(), "@WAX1969", true, locTmpWorkLine);

            if (workTransType != WHSWorkTransType::QualityInQualityCheck
                    && workTransType != WHSWorkTransType::QualityItemSampling
                    && workTransType != WHSWorkTransType::QualityOrder)
            {
                WHSPostEngine::createWaveExecutionHistoryLine(locTmpWorkLine.WaveId, waveExecutionId, "@WAX1969", true, locTmpWorkLine, this.parmWorkCreateId());

                // Special handling was added to production wave work creation (in updateProdBOMPoolWavedQty) to not require an exception here
                container waveTypesWithNoException = [WhsWaveTemplateType::Shipping, WhsWaveTemplateType::Production];

                if (!waveId || conFind(waveTypesWithNoException, WHSWaveTemplateTable::find(WHSWaveTable::find(parmWaveId).WaveTemplateName).WaveTemplateType) == 0)
                {                    
                    Message::AddAction(MessageSeverity::Error, "@WAX4687", "@WAX1710", MessageActionType::DisplayMenuItem,
                            MenuItemMessageActionProvider::createMenuItemActionData(MenuItemType::Display, menuitemDisplayStr(WHSWorkCreateHistory)));
                    
                    throw Exception::Error;
                }
                else
                {

                    this.handleFailedTmpWorkLines(locTmpWorkLine);
                }
            }
        }
        else if (unallocatedLine)
        {
            Message::AddAction(MessageSeverity::Warning, "@WAX4687", "@WAX1710", MessageActionType::DisplayMenuItem,
                MenuItemMessageActionProvider::createMenuItemActionData(MenuItemType::Display, menuitemDisplayStr(WHSWorkCreateHistory)));

            WHSPostEngine::createWaveExecutionHistoryLine(waveId, waveExecutionId, "@WAX1969", true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProdBOMPoolWavedQty</Name>
				<Source><![CDATA[
    private void updateProdBOMPoolWavedQty(WHSWorkCreateId _workCreateId)
    {
        WHSTmpWorkLine locTmpWorkLine;
        WHSProdBOMPool prodBOMPool;
        
        while select locTmpWorkLine
            where locTmpWorkLine.WorkCreateId  == _workCreateId
            &&    locTmpWorkLine.WorkCreated   == NoYes::No
            &&    locTmpWorkLine.WorkTransType == workTransType
        {
            prodBOMPool = WHSProdBOMPool::find(locTmpWorkLine.InventTransId, true);

            if (prodBOMPool.RecId && prodBOMPool.WavedQty >= locTmpWorkLine.InventQty)
            {
                prodBOMPool.WavedQty -= locTmpWorkLine.InventQty;
                prodBOMPool.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertWorkLineList</Name>
				<Source><![CDATA[
    private void insertWorkLineList(RecordSortedList _workLineList, WHSWorkType _workType, LineNum _startingLineNum)
    {
        WHSWorkOrderLineInterface workOrderLineInterface = this.createWorkOrderLineInterface();

        if (_workType == WHSWorkType::Pick)
        {
            _workLineList.insertDatabase();
            if (loadLineWorkCreatedQuantityTracker != null && this.shouldUpdateLoadLineWorkCreateQty())
            {
                loadLineWorkCreatedQuantityTracker.updateLoadLinesWorkCreatedQuantities();
            }
        }
        else
        {
            boolean moreWorkLines = workOrderLineInterface.setFromFirstInRecordSortedList(_workLineList);
            while (moreWorkLines)
            {
                workOrderLineInterface.parmLineNum(_startingLineNum);
                workOrderLineInterface.insert();
                ++_startingLineNum;
                moreWorkLines = workOrderLineInterface.setFromNextInRecordSortedList(_workLineList);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleFailedTmpWorkLines</Name>
				<Source><![CDATA[
    private void handleFailedTmpWorkLines(WHSTmpWorkLine _workLine)
    {
        Message::AddAction(MessageSeverity::Warning, "@WAX4687", "@WAX1710", MessageActionType::DisplayMenuItem, MenuItemMessageActionProvider::createMenuItemActionData(MenuItemType::Display, menuitemDisplayStr(WHSWorkCreateHistory)));

        WHSShipmentId prevShipmentId = '';
        WHSTmpWorkLine failTmpWorkLine;

        while select LoadLineRefRecId, InventQty, ShipmentId from failTmpWorkLine
            order by ShipmentId
            where failTmpWorkLine.WorkId       == '' &&
                  failTmpWorkLine.WorkCreateId == _workLine.WorkCreateId
        {
            WHSLoadLine::decrementWaveUpdatedLoadLineWorkCreatedQty(failTmpWorkLine.LoadLineRefRecId, failTmpWorkLine.InventQty, waveId);

            if (prevShipmentId != failTmpWorkLine.ShipmentId)
            {
                this.handleShipmentWithFailedWork(failTmpWorkLine.ShipmentId, _workLine);
                prevShipmentId = failTmpWorkLine.ShipmentId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkInventTransRecordsForWorkLineList</Name>
				<Source><![CDATA[
    private void createWorkInventTransRecordsForWorkLineList(RecordSortedList _workLineList, WHSWorkType _workType)
    {
        WHSWorkOrderLineInterface workOrderLineInterface = this.createWorkOrderLineInterface();

        boolean moreWorkLines = workOrderLineInterface.setFromFirstInRecordSortedList(_workLineList);
        while (moreWorkLines)
        {
            this.createWorkInventTransForWorkOrderLine(_workType, workOrderLineInterface);
            moreWorkLines = workOrderLineInterface.setFromNextInRecordSortedList(_workLineList);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleShipmentWithFailedWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles a shipment where work failed to be created.
    /// </summary>
    /// <param name = "_shipmentId">The ID of the shipment.</param>
    /// <param name = "_workLine">The temporary work line for which no work was created.</param>
    protected void handleShipmentWithFailedWork(WHSShipmentId _shipmentId, WHSTmpWorkLine _workLine)
    {
        WHSTmpWorkLine cleanupGoodTmpWorkLine;

        while select WorkId, ShipmentId, InventTransId, LoadLineRefRecId from cleanupGoodTmpWorkLine
            where cleanupGoodTmpWorkLine.ShipmentId == _shipmentId  &&
                  cleanupGoodTmpWorkLine.WorkId     != ''
        {
            this.cleanUpWorkOrderOnMissingAllocation(cleanupGoodTmpWorkLine, _workLine, this.parmWorkCreateId(), waveId, parmWaveId, waveExecutionId);
        }

        WHSShipmentTable::reverseShipment(_shipmentId);
        WHSWaveFailedShipment::findOrCreate(waveId, _shipmentId);
        
        str failureMessageOfShipmentWithFailedWork = strFmt("@WAX1972", _shipmentId, waveId);
        
        if(WHSAutoAddShipmentToWaveEnabledFlight::instance().isEnabled())
        {
            WHSWaveProcessingRemovedShipment::updateOrCreateRemovedShipment(_shipmentId, waveId, WHSShipmentStatus::Open, WHSWaveFailureErrorTypes::WorkIsNotCreated, failureMessageOfShipmentWithFailedWork);
        }

        warning(failureMessageOfShipmentWithFailedWork);
        WHSWorkCreateHistory::createWorkHistoryLineFromTmpWorkLine(
                                            this.parmWorkCreateId(),
                                            failureMessageOfShipmentWithFailedWork,
                                            true,
                                            _workLine);

        WHSPostEngine::createWaveExecutionHistoryLine(waveId,
                                                    waveExecutionId,
                                                    failureMessageOfShipmentWithFailedWork,
                                                    true,
                                                    _workLine,
                                                    this.parmWorkCreateId());
        }

]]></Source>
			</Method>
			<Method>
				<Name>addProcessingPriorityRange</Name>
				<Source><![CDATA[
    private QueryRun addProcessingPriorityRange(QueryRun _queryRun)
    {
        if (!WHSWorkCreateProcessWorkTemplateMaximumsAvoidReprocessingSplittedWorksFlight::instance().isEnabled())
        {
            return _queryRun;
        }

        Query queryLocal = new Query(_queryRun.query());
        QueryBuildDataSource whsTmpWorkLineDataSource = queryLocal.dataSourceTable(tableNum(WHSTmpWorkLine));
        
        if (whsTmpWorkLineDataSource)
        {
            SysQuery::findOrCreateRange(whsTmpWorkLineDataSource, fieldNum(WHSTmpWorkLine, ProcessingPriority)).value(SysQuery::valueEmptyString());
        }

        return new QueryRun(queryLocal);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processWorkTemplateMaximumsAndWorkBreaks</Name>
				<Source><![CDATA[
    private void processWorkTemplateMaximumsAndWorkBreaks(QueryRun _queryRun, WHSWorkTemplateTable _workTemplateTable)
    {
        // Instantiate the processing priority since the work template has maximums set up.
        processingPriority = 1;

        WHSTmpWorkLine previousTmpWorkLine;
        this.resetHeaderMaxFields(0, _workTemplateTable, previousTmpWorkLine);

        QueryRun queryRunLocal = this.addProcessingPriorityRange(_queryRun);

        // Check to see if we exceed any maximums.
        while (queryRunLocal.next())
        {
            tmpWorkLine = queryRunLocal.get(tableNum(WHSTmpWorkLine));

            if (this.checkForBreak(_workTemplateTable.RecId, queryRunLocal))
            {
                if (previousTmpWorkLine)
                {
                    previousTmpWorkLine.setWorkBreakWithReread(NoYes::Yes);
                }
            }

            this.checkMaximums(_workTemplateTable, tmpWorkLine, previousTmpWorkLine);

            if (lastInsertedSplitTmpWorkLine)
            {
                previousTmpWorkLine.data(lastInsertedSplitTmpWorkLine);
            }
            else
            {
                previousTmpWorkLine.data(tmpWorkLine);
            }

            lastInsertedSplitTmpWorkLine.clear();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpWorkOrderOnMissingAllocation</Name>
				<Source><![CDATA[
    private void cleanUpWorkOrderOnMissingAllocation(
        WHSTmpWorkLine      _cleanupGoodTmpWorkLine,
        WHSTmpWorkLine      _locTmpWorkLine,
        WHSWorkCreateId     _workCreateId,
        WHSWaveId           _waveId,
        WHSWaveId           _parmWaveId,
        WHSWaveExecutionId  _waveExecutionId)
    {
        WHSWorkOrderInterface workOrderInterface = this.createWorkOrderInterface();

        if ((select firstonly RecId from whsTmpWorkLine
                where whsTmpWorkLine.WorkId      == _cleanupGoodTmpWorkLine.WorkId
                    && whsTmpWorkLine.ShipmentId  != _cleanupGoodTmpWorkLine.ShipmentId).RecId == 0)
        {
            // Delete the entire Work.
            if (workOrderInterface.exist(_cleanupGoodTmpWorkLine.WorkId))
            {
                const boolean       ThrowErrorOnFailure = false;
                const boolean       AllowCancelClosed = false;
                const UnknownNoYes  CancelReplenWorkWithDependentWork = UnknownNoYes::Unknown;
                const boolean       CancellingProductReceipt = false;
                const boolean       DecrementLoadLineWorkCreatedQty = false;
                
                // Decrement the load line WorkCreatedQty and, more importantly, the WHSWaveUpdatedLoadLine DeltaQty here instead of within work cancellation
                // so as to not end up in the situation where we cancel an existing work, where a load line is also currently being processed on another wave (remainder).
                WHSWorkLineLoadLineDetailsEnumerator loadLineEnumerator = workOrderInterface.getWorkLineLoadLineDetailsEnumerator(_cleanupGoodTmpWorkLine.WorkId);
                while (loadLineEnumerator.moveNext())
                {
                    workOrderInterface.decrementWorkCreatedQty(loadLineEnumerator.currentLoadLineRefRecId(), loadLineEnumerator.currentInventQtyWork(), _parmWaveId);
                }

                workOrderInterface.cancelWork(_cleanupGoodTmpWorkLine.WorkId, ThrowErrorOnFailure, AllowCancelClosed, CancelReplenWorkWithDependentWork, CancellingProductReceipt, DecrementLoadLineWorkCreatedQty);
            }

            workOrderInterface.deleteWork(_cleanupGoodTmpWorkLine.WorkId);
                                
            warning(strFmt("@WAX1970", _cleanupGoodTmpWorkLine.WorkId, _cleanupGoodTmpWorkLine.ShipmentId));
            WHSWorkCreateHistory::createWorkHistoryLineFromTmpWorkLine(
                                                        _workCreateId,
                                                        strFmt("@WAX1970", _cleanupGoodTmpWorkLine.WorkId, _cleanupGoodTmpWorkLine.ShipmentId),
                                                        true,
                                                        _locTmpWorkLine);

            WHSPostEngine::createWaveExecutionHistoryLine(_waveId,
                                                        _waveExecutionId,
                                                        strFmt("@WAX1970", _cleanupGoodTmpWorkLine.WorkId, _cleanupGoodTmpWorkLine.ShipmentId),
                                                        true,
                                                        _locTmpWorkLine,
                                                        _workCreateId);
        }
        else
        {
            WHSWorkOrderLineInterface workOrderLineInterface = workOrderInterface.deleteSingleWorkLine(_cleanupGoodTmpWorkLine.WorkId, _cleanupGoodTmpWorkLine.InventTransId);

            warning(strFmt("@WAX1971", workOrderLineInterface.parmLineNum(), _cleanupGoodTmpWorkLine.WorkId, _cleanupGoodTmpWorkLine.ShipmentId));

            WHSWorkCreateHistory::createWorkHistoryLineFromTmpWorkLine(
                                                       _workCreateId,
                                                       strFmt("@WAX1978", _cleanupGoodTmpWorkLine.WorkId, _cleanupGoodTmpWorkLine.ShipmentId),
                                                       true,
                                                       _locTmpWorkLine);

            WHSPostEngine::createWaveExecutionHistoryLine(waveId,
                                                            _waveExecutionId,
                                                            strFmt("@WAX1978", _cleanupGoodTmpWorkLine.WorkId, _cleanupGoodTmpWorkLine.ShipmentId),
                                                            true,
                                                            _locTmpWorkLine,
                                                            _workCreateId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMissingSelectionFieldsToGroupWorkBy</Name>
				<Source><![CDATA[
    private void addMissingSelectionFieldsToGroupWorkBy(RefRecId _refRecId, QueryRun _queryRun)
    {
        WHSWorkTemplateGroup workTemplateGroup;

        while select GroupTableId, GroupFieldId from workTemplateGroup
            order by workTemplateGroup.LineNum
                where workTemplateGroup.RefRecId        == _refRecId    &&
                      workTemplateGroup.WorkGroupBy     == NoYes::Yes
        {
            QueryBuildDataSource qbds = _queryRun.query().dataSourceTable(workTemplateGroup.GroupTableId);

            if (qbds.fields().dynamic() != QueryFieldListDynamic::Yes)
            {
                qbds.addSelectionField(workTemplateGroup.GroupFieldId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCleanupWorkTableFromTmpWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the cleanup work from the temporary work line.
    /// </summary>
    /// <returns>The initialized cleanup work.</returns>
    [SysObsolete("The method has been deprecated use initializeCleanupWorkOrderInterfaceFromTmpWorkLine instead", false, 07\12\2020)]
    protected WHSWorkTable initializeCleanupWorkTableFromTmpWorkLine()
    {
        WHSWorkTable cleanupWorkTable   = WHSWorkTable::find(tmpWorkLine.WorkId, true);
        cleanupWorkTable.WaveId         = tmpWorkLine.WaveId == cleanupWorkTable.WaveId ? cleanupWorkTable.WaveId : '';
        cleanupWorkTable.LoadId         = tmpWorkLine.LoadId == cleanupWorkTable.LoadId ? cleanupWorkTable.LoadId : '';
        cleanupWorkTable.ShipmentId     = tmpWorkLine.ShipmentId == cleanupWorkTable.ShipmentId ? cleanupWorkTable.ShipmentId : '';
        cleanupWorkTable.OrderNum       = tmpWorkLine.OrderNum == cleanupWorkTable.OrderNum ? cleanupWorkTable.OrderNum : '';

        return cleanupWorkTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCleanupWorkOrderInterfaceFromTmpWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the cleanup <c>WHSWorkOrderInterface</c> from the temporary work line.
    /// </summary>
    /// <returns>The initialized cleanup <c>WHSWorkOrderInterface</c> .</returns>
    protected WHSWorkOrderInterface initializeCleanupWorkOrderInterfaceFromTmpWorkLine()
    {
        if (this.shouldInitWorkOrderAbstractionWithObsoleteCode())
        {
            return WHSWorkOrderInterface::createInstanceFromBuffer(this.initializeCleanupWorkTableFromTmpWorkLine());
        }

        WHSWorkOrderInterface workOrderInterface = this.createWorkOrderInterface();

        workOrderInterface.clearFieldsOnWorkOrderOnTmpWorkLineChange(tmpWorkLine);

        return workOrderInterface;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetHeaderMaxFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reset the variables that track header maximums.
    /// </summary>
    /// <param name="_excessQty">
    /// The new quantity to be accounted for by the header maximums.
    /// </param>
    /// <param name="_workTemplateTable">
    /// The current work template.
    /// </param>
    /// <param name="_tmpWorkLine">
    /// The work line just processed.
    /// </param>
    private void resetHeaderMaxFields(
        Qty                  _excessQty,
        WHSWorkTemplateTable _workTemplateTable,
        WHSTmpWorkLine       _tmpWorkLine)
    {
        maximumChecker.resetHeaderMaxFields(_excessQty, _workTemplateTable, _tmpWorkLine);
        this.syncHeaderMaxFieldsForCompatibility();
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncHeaderMaxFieldsForCompatibility</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronizes obsolete members on this class to the values from maximum checker.
    /// </summary>
    /// <remarks>
    /// This avoids breaking any extensions reading these obsolete member variables.
    /// </remarks>
    private void syncHeaderMaxFieldsForCompatibility()
    {
        runningMaxQty = maximumChecker.runningMaxQty;
        runningPickLines = maximumChecker.runningPickLines;
        runningWeight = maximumChecker.runningWeight;
        runningVolume = maximumChecker.runningVolume;
        runningEstTime = maximumChecker.runningEstTime;
        
        prevRunningMaxQty = maximumChecker.prevRunningMaxQty;
        prevRunningPickLines = maximumChecker.prevRunningPickLines;
        prevRunningWeight = maximumChecker.prevRunningWeight;
        prevRunningVolume = maximumChecker.prevRunningVolume;
        prevRunningEstTime = maximumChecker.prevRunningEstTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setGlobals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets values to variables that are used by different methods.
    /// </summary>
    void setGlobals()
    {
        originType  = tmpWorkLine.OriginType;
        originRefId = tmpWorkLine.OriginRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitTmpWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Takes the quantity to leave on the current line, then splits the remaining quantity off onto its own line.
    /// </summary>
    /// <param name="_tmpWorkLine">
    /// The <c>WHSTmpWorkLine</c> to be split
    /// </param>
    /// <param name="_maxInventQty">
    /// Maximum inventory quantity
    /// </param>
    /// <param name="_remInventQty">
    /// Remaining inventory quantity
    /// </param>
    /// <param name="_lineNum">
    /// The associated line number.
    /// </param>
    /// <param name="_skipBreakValidation">
    /// true if work break validation should be skipped; otherwise, false.
    /// </param>
    /// <param name="_forceWorkBreak">
    /// Determines if work break should be set on the split line; if true, overrides <c>_skipBreakValidation</c>.
    /// </param>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the splitTmpWorkLineHandlingQty method. Please file an extensibility request if other access is required.', false, 30\9\2019)]
    public void splitTmpWorkLine(WHSTmpWorkLine _tmpWorkLine,
                                 InventQty      _maxInventQty,
                                 InventQty      _remInventQty,
                                 LineNum        _lineNum,
                                 boolean        _skipBreakValidation = false,
                                 boolean        _forceWorkBreak = false)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _tmpWorkLine.ItemId);

        this.splitTmpWorkLineQuantities(_tmpWorkLine, _maxInventQty, _remInventQty, _lineNum, _skipBreakValidation, _forceWorkBreak);
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitTmpWorkLineHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Takes the quantity to leave on the current line, then splits the remaining quantity off onto its own line.
    /// </summary>
    /// <param name="_tmpWorkLine">
    /// The <c>WHSTmpWorkLine</c> to be split.
    /// </param>
    /// <param name="_maxInventQty">
    /// Maximum handling quantity.
    /// </param>
    /// <param name="_remInventQty">
    /// Remaining handling quantity.
    /// </param>
    /// <param name="_lineNum">
    /// The associated line number.
    /// </param>
    /// <param name="_skipBreakValidation">
    /// true if work break validation should be skipped; otherwise, false.
    /// </param>
    /// <param name="_forceWorkBreak">
    /// Determines if work break should be set on the split line; if true, overrides <c>_skipBreakValidation</c>.
    /// </param>
    final protected void splitTmpWorkLineHandlingQty(
        WHSTmpWorkLine      _tmpWorkLine,
        InventHandlingQty   _maxInventQty,
        InventHandlingQty   _remInventQty,
        LineNum             _lineNum,
        boolean             _skipBreakValidation = false,
        boolean             _forceWorkBreak = false)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _tmpWorkLine.ItemId))
        {
            this.splitTmpWorkLineQuantities(_tmpWorkLine, _maxInventQty, _remInventQty, _lineNum, _skipBreakValidation, _forceWorkBreak);
        }
        else
        {
            this.splitTmpWorkLine(_tmpWorkLine, _maxInventQty, _remInventQty, _lineNum, _skipBreakValidation, _forceWorkBreak);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitTmpWorkLineQuantities</Name>
				<Source><![CDATA[
    private void splitTmpWorkLineQuantities(
        WHSTmpWorkLine      _tmpWorkLine,
        InventHandlingQty   _maxInventQty,
        InventHandlingQty   _remInventQty,
        LineNum             _lineNum,
        boolean             _skipBreakValidation = false,
        boolean             _forceWorkBreak = false)
    {
        WHSTmpWorkLine          locTmpWorkLine;
        WHSTmpWorkLine          newTmpWorkLine;

        ttsbegin;

        UnitOfMeasureSymbol handlingUnitId = WHSCatchWeightHelper::inventHandlingUnitId(_tmpWorkLine.ItemId);

        locTmpWorkLine = _tmpWorkLine;

        WHSExtraInventHandlingQty extraInventQty = locTmpWorkLine.ExtraInventHandlingQty;

        // Assign and increment the processing priority to ensure temporary work lines will be processed in the correct order.
        if (!locTmpWorkLine.ProcessingPriority)
        {
            this.assignProcessingPriority(locTmpWorkLine);
        }

        if (this.shouldWorkBreakValueForSplitTmpWorkLineQuantitiesBeSet())
        {
            locTmpWorkLine.WorkBreak    = NoYes::Yes;
        }
        locTmpWorkLine.InventQty        = _maxInventQty;
        locTmpWorkLine.DirectiveQty     = unitConverter.convert(locTmpWorkLine.InventQty,
                                                                UnitOfMeasure::unitOfMeasureIdBySymbol(handlingUnitId),
                                                                UnitOfMeasure::unitOfMeasureIdBySymbol(locTmpWorkLine.DirectiveUOM),
                                                                NoYes::No,
                                                                locTmpWorkLine.ItemId,
                                                                locTmpWorkLine.InventDimId,
                                                                NoYes::No);

        if (extraInventQty)
        {
            // move extra quantity to the new work line as much as possible
            locTmpWorkLine.ExtraInventHandlingQty = max(extraInventQty - _remInventQty, 0);
            extraInventQty -= locTmpWorkLine.ExtraInventHandlingQty;
        }


        locTmpWorkLine.setPackQtyCompare();

        [locTmpWorkLine.HighestQty,
         locTmpWorkLine.HighestUnitId]  = WHSInventTable::getHighestUnitQtyByUOMSeqGroup(locTmpWorkLine.ItemId,
                                                                                         locTmpWorkLine.InventQty,
                                                                                         handlingUnitId,
                                                                                         locTmpWorkLine.InventDimId);

        InventQtyAvailPhysical availPhysical = locTmpWorkLine.AvailPhysical;
        locTmpWorkLine.AvailPhysical = availPhysical < locTmpWorkLine.InventQty ? availPhysical : locTmpWorkLine.InventQty;

        locTmpWorkLine.write();

        if (_remInventQty)
        {
            buf2Buf(locTmpWorkLine, newTmpWorkLine);

            newTmpWorkLine.LineNum          = _lineNum;
            newTmpWorkLine.InventQty        = _remInventQty;
            newTmpWorkLine.DirectiveQty     = unitConverter.convert(newTmpWorkLine.InventQty,
                                                                    UnitOfMeasure::unitOfMeasureIdBySymbol(handlingUnitId),
                                                                    UnitOfMeasure::unitOfMeasureIdBySymbol(newTmpWorkLine.DirectiveUOM),
                                                                    NoYes::No,
                                                                    newTmpWorkLine.ItemId,
                                                                    newTmpWorkLine.InventDimId,
                                                                    NoYes::No);

            newTmpWorkLine.AvailPhysical    = availPhysical <= locTmpWorkLine.InventQty ? 0 : availPhysical - locTmpWorkLine.InventQty;

            if (extraInventQty)
            {
                newTmpWorkLine.ExtraInventHandlingQty = extraInventQty;
            }


            newTmpWorkLine.setPackQtyCompare();

            [newTmpWorkLine.HighestQty,
             newTmpWorkLine.HighestUnitId]  = WHSInventTable::getHighestUnitQtyByUOMSeqGroup(newTmpWorkLine.ItemId,
                                                                                             newTmpWorkLine.InventQty,
                                                                                             handlingUnitId,
                                                                                             newTmpWorkLine.InventDimId);

            // Assign and increment the processing priority to ensure temporary work lines will be processed in the correct order.
            this.assignProcessingPriority(newTmpWorkLine);

            if (this.shouldWorkBreakValueForSplitTmpWorkLineQuantitiesBeCleared(_tmpWorkLine, newTmpWorkLine, _maxInventQty, _remInventQty, _skipBreakValidation, _forceWorkBreak))
            {
                newTmpWorkLine.WorkBreak = NoYes::No;
            }

            newTmpWorkLine.insert();
            lastInsertedSplitTmpWorkLine.data(newTmpWorkLine);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldWorkBreakValueForSplitTmpWorkLineQuantitiesBeSet</Name>
				<Source><![CDATA[
    private boolean shouldWorkBreakValueForSplitTmpWorkLineQuantitiesBeSet()
    {
        WHSWorkCreateReplenishmentSplitTmpWorkLineWorkBreakContext context = WHSWorkCreateReplenishmentSplitTmpWorkLineWorkBreakContext::current();

        if (context)
        {
            return context.parmShouldWorkBreakBeSet();
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldWorkBreakValueForSplitTmpWorkLineQuantitiesBeCleared</Name>
				<Source><![CDATA[
    protected boolean shouldWorkBreakValueForSplitTmpWorkLineQuantitiesBeCleared(
        WHSTmpWorkLine      _tmpWorkLine,
        WHSTmpWorkLine      _newTmpWorkLine,
        InventHandlingQty   _maxInventQty,
        InventHandlingQty   _remInventQty,
        boolean             _skipBreakValidation,
        boolean             _forceWorkBreak)
    {
        return !_forceWorkBreak && (_skipBreakValidation || _remInventQty < _maxInventQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLoadLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates a given load line.
    /// </summary>
    /// <param name="_whsLoadLine">
    ///    The load line to validate.
    /// </param>
    /// <returns>
    ///    true if the load line is valid; otherwise, false.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///    work cannot be created, because the line is invalid.
    /// </exception>
    public boolean validateLoadLine(WHSLoadLine _whsLoadLine)
    {
        boolean result;

        result =    !_whsLoadLine
                 || !_whsLoadLine.Invalid;

        if (!result)
        {
            WHSWorkCreateHistory::createWorkHistoryLine(
                            this.parmWorkCreateId(),
                            strFmt("@WAX5524",_whsLoadLine.LoadId,_whsLoadLine.ItemId,_whsLoadLine.InventTransId),
                            true);
            throw error(strFmt("@WAX5524",_whsLoadLine.LoadId,_whsLoadLine.ItemId,_whsLoadLine.InventTransId));
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs <c>WHSWorkCreate</c> instance by common record.
    /// </summary>
    /// <param name="_common">
    /// Common record.
    /// </param>
    /// <returns>
    /// <c>WHSWorkCreate</c> instance.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when common record table is invalid.
    /// </exception>
    static WHSWorkCreate construct(Common _common)
    {
        switch (_common.TableId)
        {
            case tableNum(WHSWaveTable)                 : return WHSWorkCreateWave::construct(_common);
            case tableNum(WHSUOMStructure)              : return WHSWorkCreateLP::construct(_common);
            case tableNum(PurchLine)                    : return WHSWorkCreatePurchLine::construct(_common);
            case tableNum(WHSTmpMovementWork)           : return WHSWorkCreateMovement::construct(_common);
            case tableNum(WHSReplenishmentTemplateLine) : throw Error(error::wrongUseOfFunction(funcName()));  // Must ensure Dispose() is called, so the generic construct cannot be used.
            case tableNum(SalesLine)                    : return WHSWorkCreateReturnOrder::construct(_common);
            case tableNum(Kanban)                       : return WHSWorkCreateKanbanPut::construct(_common);
            default                                     : throw error("@WAX678");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultReceiptLocationId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default receipt location, depending on whether we want to use the warehouse, where the work user is logged in,
    /// or the order line warehouse.
    /// </summary>
    /// <param name="_inventDimId">
    /// InventDimID of the order line to be received.
    /// </param>
    /// <returns>
    /// Default receipt location for the selected warehouse.
    /// </returns>
    protected WMSLocationId defaultReceiptLocationId(InventDimId _inventDimId)
    {
        // Get the first Pick location based on the receiving warehouse.
        if (this.parmInventLocationId())
        {
            return InventLocation::find(this.parmInventLocationId()).wmsLocationIdDefaultReceipt;
        }
        else
        {
            return InventLocation::find(InventDim::find(_inventDimId).InventLocationId).wmsLocationIdDefaultReceipt;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextTmpWorkLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the next temporary work line number for splitting a work line.
    /// </summary>
    /// <param name="_workCreateId">
    /// The work creation number.
    /// </param>
    /// <param name="_curLineNum">
    /// The line number to be split.
    /// </param>
    /// <returns>
    /// The next valid temporary work line number.
    /// </returns>
    protected LineNum getNextTmpWorkLineNum(WHSWorkCreateId _workCreateId, LineNum _curLineNum)
    {
        #WHSLineNumSplit

        WHSTmpWorkLine	whsTmpWorkLine;
        LineNum			nextWholeLineNumber = trunc(_curLineNum) + 1;

        select maxOf(LineNum) from whsTmpWorkLine
        where whsTmpWorkLine.WorkCreateId == _workCreateId
            && whsTmpWorkLine.LineNum >= _curLineNum
            && whsTmpWorkLine.LineNum < nextWholeLineNumber;

        LineNum nextTmpWorkLineNum = whsTmpWorkLine.LineNum + #SplitTmpWorkLine;

        if (nextTmpWorkLineNum == nextWholeLineNumber)
        {
            throw error("@WAX:ErrorMaximumNumberOfWorkLinesInWorkExceeded");
        }

        return nextTmpWorkLineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSplit</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Processes the logic that handles splitting tmpWorkLines.
    /// </summary>
    /// <param name="_workTemplateTable">
    ///     The current <c>WHSWorkTemplateTable</c> record.
    /// </param>
    /// <param name="_tmpWorkLine">
    ///     The current <c>WHSTmpWorkLine</c> record.
    /// </param>
    /// <param name="_minLineQty">
    ///     The quantity allowed on the tmpWorkline based on work template line maximums.
    /// </param>
    /// <param name="_maxHeaderQty">
    ///     The maximum quantity allowed based on work template header maximums.
    /// </param>
    /// <param name="_excessQty">
    ///     The quantity on the current <c>WHSTmpWorkLine</c> in excess of the current work headers maximum limits.
    /// </param>
    /// <param name="_allowMultipleSplits">
    ///     If more than a single split is required then this should be true.
    /// </param>
    /// <returns>
    ///    [remainingExcessInventQty, lineNum, resetMaxHeaderFields]
    ///    If the last work header is at its header maximum it returns 0; otherwise, the remaining excess quantity that
    ///    still needs to be split is returned [1], along with the current line number[2] and a Boolean signaling if the header max fields
    ///    should be reset[3].
    /// </returns>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the processSplitHandlingQty method. Please file an extensibility request if other access is required.', false, 30\9\2019)]
    public container processSplit(
        WHSWorkTemplateTable    _workTemplateTable,
        WHSTmpWorkLine          _tmpWorkLine,
        InventQty               _minLineQty,
        InventQty               _maxHeaderQty,
        InventQty               _excessQty,
        boolean                 _allowMultipleSplits)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _tmpWorkLine.ItemId);

        return this.processSplitQuantities(_workTemplateTable, _tmpWorkLine, _minLineQty, _maxHeaderQty, _excessQty, _allowMultipleSplits);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSplitHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Processes the logic that handles splitting tmpWorkLines.
    /// </summary>
    /// <param name="_workTemplateTable">
    ///     The current <c>WHSWorkTemplateTable</c> record.
    /// </param>
    /// <param name="_tmpWorkLine">
    ///     The current <c>WHSTmpWorkLine</c> record.
    /// </param>
    /// <param name="_minLineQty">
    ///     The quantity allowed on the tmpWorkline based on work template line maximums.
    /// </param>
    /// <param name="_maxHeaderQty">
    ///     The maximum quantity allowed based on work template header maximums.
    /// </param>
    /// <param name="_excessQty">
    ///     The quantity on the current <c>WHSTmpWorkLine</c> in excess of the current work headers maximum limits.
    /// </param>
    /// <param name="_allowMultipleSplits">
    ///     If more than a single split is required then this should be true.
    /// </param>
    /// <returns>
    ///    [remainingExcessHandlingQty, lineNum, resetMaxHeaderFields]
    ///    If the last work header is at its header maximum it returns 0; otherwise, the remaining excess quantity that
    ///    still needs to be split is returned [1], along with the current line number[2] and a Boolean signaling if the header max fields
    ///    should be reset[3].
    /// </returns>
    [Hookable(false)]
    final public container processSplitHandlingQty(
        WHSWorkTemplateTable    _workTemplateTable,
        WHSTmpWorkLine          _tmpWorkLine,
        InventHandlingQty       _minLineQty,
        InventHandlingQty       _maxHeaderQty,
        InventHandlingQty       _excessQty,
        boolean                 _allowMultipleSplits)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _tmpWorkLine.ItemId))
        {
            return this.processSplitQuantities(_workTemplateTable, _tmpWorkLine, _minLineQty, _maxHeaderQty, _excessQty, _allowMultipleSplits);
        }

        return this.processSplit(_workTemplateTable, _tmpWorkLine, _minLineQty, _maxHeaderQty, _excessQty, _allowMultipleSplits);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSplitQuantities</Name>
				<Source><![CDATA[
    private container processSplitQuantities(
        WHSWorkTemplateTable    _workTemplateTable,
        WHSTmpWorkLine          _tmpWorkLine,
        InventHandlingQty       _minLineQty,
        InventHandlingQty       _maxHeaderQty,
        InventHandlingQty       _excessQty,
        boolean                 _allowMultipleSplits)
    {
        UnitOfMeasureSymbol handlingUnitId = WHSCatchWeightHelper::inventHandlingUnitId(_tmpWorkLine.ItemId);
        InventHandlingQty   maxHeaderQty = _maxHeaderQty;
        LineNum             lineNum = _tmpWorkLine.LineNum;
        InventHandlingQty   remainingExcessHandlingQty = _excessQty;
        boolean             allowMultipleSplits = _allowMultipleSplits;
        WHSTmpWorkLine      locTmpWorkLine = _tmpWorkLine;
        boolean             resetMaxHeaderFields;

        if (handlingUnitId != _tmpWorkLine.DirectiveUOM && maxHeaderQty > 0)
        {
            [maxHeaderQty, remainingExcessHandlingQty, allowMultipleSplits] = this.enforceLocationDirectiveUOMRestriction(_workTemplateTable,
                                                                                                                        _tmpWorkLine,
                                                                                                                        maxHeaderQty,
                                                                                                                        remainingExcessHandlingQty,
                                                                                                                        handlingUnitId,
                                                                                                                        _allowMultipleSplits);
        }

        InventHandlingQty handlingQtyToSplit = _tmpWorkLine.InventQty - remainingExcessHandlingQty;

        // If there is no inventyQty to split, then the current temporary work line will not fit on the same work header as the previous temporary work line.
        if (handlingQtyToSplit == 0 && maxHeaderQty > 0)
        {
            WHSTmpWorkLine prevLocTmpWorkLine;

            select forupdate prevLocTmpWorkLine
                where prevLocTmpWorkLine.ProcessingPriority == processingPriority - 1
                &&    prevLocTmpWorkLine.WorkCreateId       == locTmpWorkLine.WorkCreateId
                &&    prevLocTmpWorkLine.WorkTemplateCode   == '';

            // Set the previous temporary work line to be a work break, putting the current temporary work line on it's own header.
            if (prevLocTmpWorkLine.RecId != 0)
            {
                prevLocTmpWorkLine.WorkBreak = true;
                prevLocTmpWorkLine.update();
            }

            this.assignProcessingPriority(locTmpWorkLine);
            locTmpWorkLine.update();

            // If the remainingExcessInventQty is greater than the header maximum, then we still need to split this line.
            if (remainingExcessHandlingQty > maxHeaderQty)
            {
                remainingExcessHandlingQty -= maxHeaderQty;

                // This tmpWorkLine should only get qty equal to the header maximum.
                handlingQtyToSplit = maxHeaderQty;

                // If the excess after the split would still be too big for the header then we need to allow multiple splits.
                allowMultipleSplits = remainingExcessHandlingQty > maxHeaderQty;
            }
            else
            {
                // If the line does not need to be split, then the maximum header quantities must be forced to reset as the line number will not have been incremented.
                resetMaxHeaderFields = true;
            }
        }

        if (maxHeaderQty
        && allowMultipleSplits
        && (maxHeaderQty != handlingQtyToSplit
        || _minLineQty < remainingExcessHandlingQty))
        {
            // first split will be different than subsequent splits.
            lineNum = this.getNextTmpWorkLineNum(_tmpWorkLine.WorkCreateId, lineNum);
            this.splitTmpWorkLineHandlingQty(_tmpWorkLine, handlingQtyToSplit, remainingExcessHandlingQty, lineNum);
            handlingQtyToSplit = _minLineQty && _minLineQty < remainingExcessHandlingQty ? _minLineQty : maxHeaderQty;
            remainingExcessHandlingQty = max(0, remainingExcessHandlingQty - handlingQtyToSplit);

            // Get the new temp work line since it will need to be split.
            locTmpWorkLine = WHSTmpWorkLine::find(_tmpWorkLine.WorkCreateId, lineNum, true);
        }

        // Check if work break validation in the split line method should be ran.
        boolean skipWorkBreakValidation = maxHeaderQty != 0 && maxHeaderQty != handlingQtyToSplit;

        if (!remainingExcessHandlingQty)
        {
            // Last split. Make sure we don't go over the max pick lines limit. If no work break is set on the split line,
            // the next temp work line would be added to the same work. Cases where limit is greater than one are caught
            // in maximum checks above.
            lineNum = this.getNextTmpWorkLineNum(_tmpWorkLine.WorkCreateId, lineNum);
            this.splitTmpWorkLineHandlingQty(locTmpWorkLine, handlingQtyToSplit, remainingExcessHandlingQty, lineNum, skipWorkBreakValidation, _workTemplateTable.MaxPickLines == 1);
        }
        else if (handlingQtyToSplit)
        {
            while (allowMultipleSplits && remainingExcessHandlingQty > handlingQtyToSplit)
            {
                lineNum = this.getNextTmpWorkLineNum(_tmpWorkLine.WorkCreateId, lineNum);
                this.splitTmpWorkLineHandlingQty(locTmpWorkLine, handlingQtyToSplit, remainingExcessHandlingQty, lineNum);
                remainingExcessHandlingQty = max(0, remainingExcessHandlingQty - handlingQtyToSplit);

                locTmpWorkLine = WHSTmpWorkLine::find(_tmpWorkLine.WorkCreateId, lineNum, true);
            }

            if (remainingExcessHandlingQty)
            {
                lineNum = this.getNextTmpWorkLineNum(_tmpWorkLine.WorkCreateId, lineNum);
                // Last split. Make sure we don't go over the max pick lines limit. If no work break is set on the split line,
                // the next temp work line would be added to the same work. Cases where limit is greater than one are caught
                // in maximum checks above.
                this.splitTmpWorkLineHandlingQty(locTmpWorkLine, handlingQtyToSplit, remainingExcessHandlingQty, lineNum, skipWorkBreakValidation, _workTemplateTable.MaxPickLines == 1);
            }

            // Set excessQty variable so header max variable can be reset correctly.
            if (lineNum == _tmpWorkLine.LineNum
                || (lastInsertedSplitTmpWorkLine && lineNum == lastInsertedSplitTmpWorkLine.LineNum && lastInsertedSplitTmpWorkLine.WorkBreak))
            {
                remainingExcessHandlingQty = remainingExcessHandlingQty == handlingQtyToSplit ? 0 : remainingExcessHandlingQty;
            }
        }

        return [remainingExcessHandlingQty, lineNum, resetMaxHeaderFields];
    }

]]></Source>
			</Method>
			<Method>
				<Name>enforceLocationDirectiveUOMRestriction</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Enforces the unit of measure restriction specified on the location directive.
    /// </summary>
    /// <param name="_workTemplateTable">
    ///     The current <c>WHSWorkTemplateTable</c> record.
    /// </param>
    /// <param name="_tmpWorkLine">
    ///     The current <c>WHSTmpWorkLine</c> record to be split.
    /// </param>
    /// <param name="_maxHeaderQty">
    ///     The max quantity that could be allowed based on work template header maximums.
    /// </param>
    /// <param name="_remainingExcessInventQty">
    ///     The remaining quantity on the current <c>WHSTmpWorkLine</c> in excess of the current work headers maximum limits.
    /// </param>
    /// <param name="_inventUnitId">
    ///     The inventory unit of measure for the item on the <c>WHSTmpWorkLine</c>.
    /// </param>
    /// <param name="_allowMultipleSplits">
    ///     Determines if multiple splits are allowed.
    /// </param>
    /// <returns>
    ///     [maxHeaderInventQty, remainingExcessInventQty, allowMultipleSplits]
    ///     After rounding to the nearest whole directive unit, returns a container holding the current work header's maximum[1],
    ///     excess quantities in inventory units[2], and a flag signaling whether or not it should be split multiple times[3].
    /// </returns>
    private container enforceLocationDirectiveUOMRestriction(
        WHSWorkTemplateTable    _workTemplateTable,
        WHSTmpWorkLine          _tmpWorkLine,
        InventQty               _maxHeaderQty,
        InventQty               _remainingExcessInventQty,
        UnitOfMeasureSymbol     _inventUnitId,
        boolean                 _allowMultipleSplits)
    {
        UnitOfMeasureFromRecId inventUOMRecId = UnitOfMeasure::findBySymbol(_inventUnitId).RecId;
        UnitOfMeasureToRecId directiveUOMRecId = UnitOfMeasure::findBySymbol(_tmpWorkLine.DirectiveUOM).RecId;
        
        WHSDirectiveQty maxHeaderDirectiveQty = roundDown(unitConverter.convert(_maxHeaderQty,
                                                                                inventUOMRecId,
                                                                                directiveUOMRecId,
                                                                                NoYes::No,
                                                                                _tmpWorkLine.ItemId,
                                                                                _tmpWorkLine.InventDimId,
                                                                                NoYes::No),
                                                                                1);

        WHSDirectiveQty remainingExcessDirectiveQty = roundUp(unitConverter.convert(_remainingExcessInventQty,
                                                                                    inventUOMRecId,
                                                                                    directiveUOMRecId,
                                                                                    NoYes::No,
                                                                                    _tmpWorkLine.ItemId,
                                                                                    _tmpWorkLine.InventDimId,
                                                                                    NoYes::No),
                                                                                    1);

        InventQty maxHeaderInventQty = unitConverter.convert(maxHeaderDirectiveQty,
                                                             directiveUOMRecId,
                                                             inventUOMRecId,
                                                             NoYes::No,
                                                             _tmpWorkLine.ItemId,
                                                             _tmpWorkLine.InventDimId,
                                                             NoYes::Yes);

        InventQty remainingExcessInventQty = unitConverter.convert(remainingExcessDirectiveQty,
                                                                   directiveUOMRecId,
                                                                   inventUOMRecId,
                                                                   NoYes::No,
                                                                   _tmpWorkLine.ItemId,
                                                                   _tmpWorkLine.InventDimId,
                                                                   NoYes::Yes);
  
        // if the max header quantity is zero after being converted to the directive uom, then this location directive & work template combination will not work and need to be skipped.
        if (!maxHeaderDirectiveQty)
        {
            WHSWorkCreateHistory::createWorkHistoryLineFromTmpWorkLine(
                                        this.parmWorkCreateId(),
                                        strFmt("@WAX:TmpWorkLineExceedsWorkHeaderMaximum", _workTemplateTable.workTemplateCode),
                                        true,
                                        _tmpWorkLine);

            this.tmpWorkLineExceedMaximums(_tmpWorkLine);
        }

        boolean allowMultipleSplits = _allowMultipleSplits;

        if (maxHeaderInventQty < remainingExcessInventQty)
        {
            allowMultipleSplits = true;
        }

        return [maxHeaderInventQty, remainingExcessInventQty, allowMultipleSplits];
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignProcessingPriority</Name>
				<Source><![CDATA[
    protected void assignProcessingPriority(WHSTmpWorkLine _tmpWorkLine)
    {
        if (processingPriority)
        {
            _tmpWorkLine.ProcessingPriority = processingPriority;
            processingPriority++;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustQuantityForCrossDock</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected InventQty adjustQuantityForCrossDock(
        InventQty           _findQty,
        WHSLicensePlateId   _licensePlateId,
        WHSWorkBuildId      _workBuildId,
        ItemId              _itemId,
        InventDim           _inventDimCriteria)
    {               
        return max(0, _findQty - this.getCrossDockedQuantity(_licensePlateId, _workBuildId, _itemId, _inventDimCriteria));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCrossDockedQuantity</Name>
				<Source><![CDATA[
    private InventQty getCrossDockedQuantity(
        WHSLicensePlateId   _licensePlateId,
        WHSWorkBuildId      _workBuildId,
        ItemId              _itemId,
        InventDim           _inventDimCriteria)
    {
        WHSWorkTable        workTable;
        WHSWorkLine         workLine;
        WHSWorkInventTrans  workInventTrans;
        InventQty           qty;
        InventDim           inventDim;
        
        InventDimParm aboveLocInventDimParm = WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(InventTable::find(_itemId));
        
        while select WorkId, LineNum, Qty from workInventTrans
            where workInventTrans.ItemId == _itemId
                exists join workLine
                    where workLine.WorkId       == workInventTrans.WorkId
                    &&    workLine.LineNum      == workInventTrans.LineNum
                    &&    workLine.WorkStatus   != WHSWorkStatus::Cancelled
                    &&    workLine.WorkType     == WHSWorkType::Pick
                exists join workTable
                    where workTable.WorkId               == workLine.WorkId
                    &&    workTable.TargetLicensePlateId == _licensePlateId
                    &&    workTable.WorkBuildId          == _workBuildId
                    &&    workTable.WorkTransType        == WHSWorkTransType::CrossDocking
                    &&    workTable.WorkStatus           != WHSWorkStatus::Cancelled
                    &&    workTable.WorkStatus           != WHSWorkStatus::Combined
                #InventDimExistsJoin(workInventTrans.InventDimIdFrom, inventDim, _inventDimCriteria, aboveLocInventDimParm)
        {
            if (!WHSWorkLine::isPutBefore(workInventTrans.WorkId, workInventTrans.LineNum))
            {
                qty += workInventTrans.Qty;
            }
        }

        return Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    final internal WHSInstrumentationLogger instrumentationLogger()
    {
        if (!instrumentationLogger)
        {
            instrumentationLogger = WHSInstrumentationLogger::createLogger(classId2Name(classIdGet(this)));
        }

        return instrumentationLogger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSortingPickQtyAdLocation</Name>
				<Source><![CDATA[
    private void getSortingPickQtyAdLocation(
        WHSTmpWorkLine      _tmpWorkLine,
        WHSWorkTemplateLine _workTemplateLine,
        UnitOfMeasureSymbol _unitId,
        Qty                 _qtyWork,
        InventQty           _inventQtyWork)
    {
        if (_tmpWorkLine.OutboundSortLocationId || _tmpWorkLine.OutboundSortPosition)
        {
            // Only use sort location for the final work step.
            RecId higherTemplateLineRecId = this.getHigherWorkTemplateLineRecId(_workTemplateLine);

            if (higherTemplateLineRecId == 0)
            {
                if (_tmpWorkLine.OutboundSortLocationId)
                {
                    locationId = _tmpWorkLine.OutboundSortLocationId;
                }
                else
                {
                    locationId = WHSOutboundSortPosition::find(_tmpWorkLine.OutboundSortPosition).WMSLocationId;
                }

                if (locationId)
                {
                    pickUnitId      = _unitId;
                    pickQty         = _qtyWork;
                    inventPickQty   = _inventQtyWork;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkCreateQuantityAfterQualityItemSampling</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the quantity for the remaining put-away work based on the corresponding quality item sampling work.
    /// </summary>
    /// <param name = "_locInventQty">Original quantity on the quality order</param>
    /// <param name = "_qualityItemSamplingWorkBuildId">Work build ID corresponding to the work created for the quality order work</param>
    /// <param name = "_inventTransId">Source documente reference</param>
    /// <param name = "_licensePlateId">License plate id</param>
    /// <param name = "_inventDim"><c>InventDim</c> buffer</param>
    /// <returns>Quantity for the remaining work.</returns>
    protected internal InventQty getWorkCreateQuantityAfterQualityItemSampling(
        InventQty			_locInventQty,
        WHSWorkBuildId		_qualityItemSamplingWorkBuildId,
        InventTransId	    _inventTransId,
        WHSLicensePlateId	_licensePlateId,
        InventDim			_inventDim)
    {
        InventQty qtyToCreateWork = _locInventQty;

        if (_qualityItemSamplingWorkBuildId)
        {
            this.parmWorkCreateId(_qualityItemSamplingWorkBuildId);

            // Reduce the qty for work creation if quality in item sampling work has been created already.
            qtyToCreateWork = this.adjustQuantityForQualityItemSamplingWork(qtyToCreateWork, _licensePlateId, _qualityItemSamplingWorkBuildId, _inventTransId, _inventDim);
        }

        return qtyToCreateWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustQuantityForQualityItemSamplingWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the quantity for the remaining work which needs to be created after the quality order work has been created.
    /// </summary>
    /// <param name = "_totalQty">Total quantity on the source document being processed</param>
    /// <param name = "_licensePlateId">License plate ID</param>
    /// <param name = "_workBuildId">Work build ID corresponding to the quality order work already created</param>
    /// <param name = "_inventTransId">Source document reference</param>
    /// <param name = "_inventDimCriteria">Inventory dimension</param>
    /// <returns>Quantity for the remaining work.</returns>
    private InventQty adjustQuantityForQualityItemSamplingWork(
        InventQty           _totalQty,
        WHSLicensePlateId   _licensePlateId,
        WHSWorkBuildId      _workBuildId,
        InventTransId       _inventTransId,
        InventDim           _inventDimCriteria)
    {
        WHSWorkTable        workTable;
        WHSWorkLine         workLine;
        WHSWorkInventTrans  workInventTrans;
        InventQty           qty;
        InventDim           inventDim;
        
        InventDimParm   aboveLocInventDimParm = WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(InventTransOrigin::findByInventTransId(_inventTransId).inventTable());
        
        while select WorkId, LineNum, Qty from workInventTrans
            where workInventTrans.InventTransIdParent == _inventTransId
                exists join workLine
                    where workLine.WorkId == workInventTrans.WorkId
                        && workLine.LineNum == workInventTrans.LineNum
                        && workLine.WorkStatus != WHSWorkStatus::Cancelled
                        && workLine.WorkType == WHSWorkType::Pick
                    exists join workTable
                        where workTable.WorkId == workLine.WorkId
                            && workTable.TargetLicensePlateId == _licensePlateId
                            && workTable.WorkBuildId == _workBuildId
                            && workTable.WorkTransType == WHSWorkTransType::QualityItemSampling
                            && workTable.WorkStatus != WHSWorkStatus::Cancelled
                            && workTable.WorkStatus != WHSWorkStatus::Combined
                        #InventDimExistsJoin(workInventTrans.InventDimIdFrom, inventDim, _inventDimCriteria, aboveLocInventDimParm)
        {
            if (!WHSWorkLine::isPutBefore(workInventTrans.WorkId, workInventTrans.LineNum))
            {
                qty += workInventTrans.Qty;
            }
        }
        
        return max(0, _totalQty - qty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldLocationIdBeClearedOnTheRemainingWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the Location Id should be cleared.
    /// </summary>
    /// <param name = "_workTransType">Work order type.</param>
    /// <returns>true if the Location Id should be cleared; otherwise false.</returns>
    private boolean shouldLocationIdBeClearedOnTheRemainingWorkLines(WHSWorkTransType _workTransType)
    {
        return _workTransType != WHSWorkTransType::Replenishment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addWorkTemplateCodeToSet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add work template code to set for filtering.
    /// </summary>
    /// <param name = "_workTemplateCode">Work template code.</param>
    [Hookable(false)]
    internal void addWorkTemplateCodeToSet(WHSWorkTemplateCode _workTemplateCode)
    {
        workTemplateCodesSet.add(_workTemplateCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWorkCreateWorkOrderType</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal final WHSWorkCreateWorkOrderType parmWorkCreateWorkOrderType(WHSWorkCreateWorkOrderType _workCreateWorkOrderType = workCreateWorkOrderType)
    {
        workCreateWorkOrderType = _workCreateWorkOrderType;
        return workCreateWorkOrderType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkTemplateTableQueryRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates query run object for selecting work templates.
    /// </summary>
    /// <param name = "_workTransType">Work type.</param>
    /// <returns>Query run object for selecting work templates.</returns>
    protected QueryRun createWorkTemplateTableQueryRun(WHSWorkTransType _workTransType)
    {
        Query                   query = new Query();
        QueryBuildDataSource    dataSource = query.addDataSource(tableNum(WHSWorkTemplateTable));

        dataSource.addOrderByField(fieldNum(WHSWorkTemplateTable, WorkTemplatePriority));
        dataSource.addRange(fieldNum(WHSWorkTemplateTable, WorkTransType)).value(queryValue(_workTransType));
        dataSource.addRange(fieldNum(WHSWorkTemplateTable, WorkTemplateValid)).value(queryValue(NoYes::Yes));

        if (workTemplateCode)
        {
            dataSource.addRange(fieldNum(WHSWorkTemplateTable, WorkTemplateCode)).value(workTemplateCode);
        }
        else if (!workTemplateCodesSet.empty() && !workTemplateCodesSet.in(''))
        {
            SetEnumerator setEnum = workTemplateCodesSet.getEnumerator();

            while (setEnum.moveNext())
            {
                dataSource.addRange(fieldNum(WHSWorkTemplateTable, WorkTemplateCode)).value(queryValue(setEnum.current()));
            }
        }

        return new QueryRun(query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkOrderFactory</Name>
				<Source><![CDATA[
    private final WHSWorkCreateWorkOrderAbstractFactory getWorkOrderFactory()
    {
        return WHSWorkCreateWorkOrderAbstractFactory::createInstanceFromWorkOrderType(workCreateWorkOrderType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkOrderInterface</Name>
				<Source><![CDATA[
    private WHSWorkOrderInterface createWorkOrderInterface()
    {
        return this.getWorkOrderFactory().createWorkOrderInterface();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkOrderLineInterface</Name>
				<Source><![CDATA[
    private WHSWorkOrderLineInterface createWorkOrderLineInterface()
    {
        return this.getWorkOrderFactory().createWorkOrderLineInterface();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRecordSortedListForWorkOrderLines</Name>
				<Source><![CDATA[
    private WHSRecordSortedListWorkTypeWrapper createRecordSortedListForWorkOrderLines(WHSWorkType _workType)
    {
        return WHSRecordSortedListWorkTypeWrapper::construct(this.getWorkOrderFactory().createRecordSortedListForWorkOrderLines(), _workType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkOrderTypeWorkOrder</Name>
				<Source><![CDATA[
    private boolean isWorkOrderTypeWorkOrder()
    {
        return workCreateWorkOrderType == WHSWorkCreateWorkOrderType::WorkOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldEstimatedLaborStandardsTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Based on the work order type, determines whether the labor standards time
    /// should be estimated for the created work.
    /// </summary>
    /// <returns>true if the labor standards time should be estimated; otherwise, false.</returns>
    private boolean shouldEstimatedLaborStandardsTime()
    {
        return this.isWorkOrderTypeWorkOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateLoadLineWorkCreateQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Based on the work order type, determines whether the WorkCreatedQty field, of <c>WHSLoadLine</c>,
    /// should be updated during work creation.
    /// </summary>
    /// <returns>true if the work created qty should be updated; otherwise, false.</returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute, Wrappable(true)]
    internal boolean shouldUpdateLoadLineWorkCreateQty()
    {
        return this.isWorkOrderTypeWorkOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpWorkLineExceedMaximums</Name>
				<Source><![CDATA[
    private void tmpWorkLineExceedMaximums(WHSTmpWorkLine _tmpWorkLine)
    {
        if (!tmpWorkLinesExceedingMaximums)
        {
            tmpWorkLinesExceedingMaximums = new Set(Types::Int64);
        }

        tmpWorkLinesExceedingMaximums.add(_tmpWorkLine.RecId);
        // resetting the global running values to their previous values since we will be skipping these tmpWorkLines while processing the tmpTable.
        maximumChecker.resetRunningValuesToPreviousValues();
        this.syncHeaderMaxFieldsForCompatibility();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>