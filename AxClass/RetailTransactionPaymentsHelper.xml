<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailTransactionPaymentsHelper</Name>
	<SourceCode>
		<Declaration><![CDATA[
using System.Collections.Specialized;
using System.Reflection;
using Microsoft.Dynamics.Commerce.Runtime.Services.CustomerOrder;
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;

/// <summary>
/// The class <c>RetailTransactionPaymentsHelper</c> contains the helpers for transactions paymemts integration
/// </summary>
public class RetailTransactionPaymentsHelper
{
    private static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;

    #ISOCountryRegionCodes

    #EECountryRegionCodes

    private const str TrueStr = 'true';
    private const str FalseStr = 'false';
    private const str CodeStr = 'Code';
    private const str AmountStr = 'Amount';

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>isOmniChannelPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verify if a payment info object has Omni channel properties, and retrieve them.
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c> instance.</param>
    /// <param name = "_paymentInfo">The <c>PaymentInfo</c> instance.</param>
    /// <returns>A boolean informing if the payment is a Omni channel payment.</returns>
    internal static boolean isOmniChannelPayment(SalesTable _salesTable, PaymentInfo _paymentInfo)
    {
        boolean                     isOmniChannelPaymentsEnabled = RetailSharedParameters::find().EnableOmniChannelPayments;
        boolean                     isOmniChannelPayment = false;

        try
        {
            // Implicit marshaling of PaymentInfo.PaymentStatusValue from System.Int32 to x++ native Int type...
            RetailTenderLineStatus paymentStatus = _paymentInfo.PaymentStatusValue;

            if (isOmniChannelPaymentsEnabled && paymentStatus != RetailTenderLineStatus::None)
            {
                isOmniChannelPayment = true;
            }
            else
            {
                isOmniChannelPayment = false;
            }
        }
        catch
        {
            // When Omni-channel properties are not present, the exception will be caught
            // and the process will fall back to Backward compatibility mode.
            isOmniChannelPayment = false;

        }

        // Log isOmniChannelPayment state
        eventSource.EventWritePaymentsIsOmniChannelPayment( _paymentInfo.PaymentRefRecId, isOmniChannelPayment);
        return isOmniChannelPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentInfoLogDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a string with PaymentInfo details.
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c> instance.</param>
    /// <param name = "_paymentInfo">The paymentInfo instance.</param>
    /// <returns>A string with PaymentInfo details.</returns>
    internal static str getPaymentInfoLogDetails(SalesTable _salesTable, PaymentInfo _paymentInfo)
    {
        return strFmt(
            '[Sales ID = %1]\n '+
            '[Customer = %2]\n ' +
            'Creation of Payment Info:\n'+
            '[_tenderLineStatus = %3]\n' +
            '[_processorStatus  = %4]\n' +
            '[_paymentType      = %5]\n' +
            '[_cardType         = %6]\n' +
            '[_LineNum          = %7]\n' +
            '[_currency         = %8]\n' +
            '[_isPrepayment     = %9]\n' +
            '[_paymentCaptured  = %10]\n' +
            '[_paymentRefRecId  = %11]\n' +
            '[_serviceAccountId = %12]\n',
            _salesTable.SalesId,
            _salesTable.InvoiceAccount,
            _paymentInfo.PaymentStatusValue,
            _paymentInfo.CreditCardProcessorStatusValue,
            _paymentInfo.PaymentType,
            _paymentInfo.CardType,
            _paymentInfo.LineNum,
            _paymentInfo.Currency,
            _paymentInfo.Prepayment,
            _paymentInfo.PaymentCaptured,
            _paymentInfo.PaymentRefRecId,
            _paymentInfo.CardPaymentAccountId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCreditCardForCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a card token to the list of customer credit cards.
    /// </summary>
    /// <param name = "_custAccount">The customer account.</param>
    /// <param name = "_paymentProperties">The payment properties collection containing the card token property.</param>
    /// <returns>The <c>CreditCardCust</c> table buffer created.</returns>
    private static CreditCardCust createCreditCardForCustomer(CustAccount _custAccount, SalesTable _salesTable, str _paymentProperties)
    {
        CreditCardPaymentProperties properties = CreditCardPaymentProperties::fromXmlString(_paymentProperties);

        // Save CreditCard token (if it was sent), and attach to SalesTable record.
        CreditCardPaymentProperty creditCardPaymentProperty = properties.find(
            Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
            Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_UniqueCardId());

        CreditCardPaymentProperty isNonRecurringProperty = properties.find(
            Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
            Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.TransactionDataProperties::get_IsNonRecurring());

        str uniqueCardId = '';

        if (creditCardPaymentProperty != null)
        {
            uniqueCardId = creditCardPaymentProperty.parmStringValue();
        }

        CreditCardCust ccCust = CreditCardCust::findByUniqueCardId(uniqueCardId);

        if (!ccCust)
        {
            boolean isNonRecurring;
            if (isNonRecurringProperty != null)
            {
                str propertyValue = strLwr(isNonRecurringProperty.parmStringValue());
                isNonRecurring = ('true' == propertyValue);
            }

            RetailTokenScope tokenScope = isNonRecurring ? RetailTokenScope::NonRecurring : RetailTokenScope::SalesOrder;
            
            // This will attach the credit card blob to the customer.
            ccCust = CreditCard::addCreditCardWithTokenScope(
                _paymentProperties,
                _custAccount,
                _salesTable,
                CreditCard::FindBestMatchCreditCardProcessorId(properties),
                tokenScope);

            if (ccCust)
            {
                // Log Card token after API call
                eventSource.EventWritePaymentsAddCreditCardTokenToCustomerSucessfully(ccCust.RecId, CustTable::find(_custAccount).RecId);
            }
            else
            {
                // Log Card token after API call
                eventSource.EventWritePaymentsAddCreditCardTokenToCustomerFailed(ccCust.RecId, CustTable::find(_custAccount).RecId);
            }
        }

        return ccCust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>attachCreditCardTokenToSalesOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Attach a credit card token to a given sales order.
    /// </summary>
    /// <param name = "_channelRecId">The channel recid.</param>
    /// <param name = "_salesTable">The sales order.</param>
    /// <param name = "_cCust">The credit card token.</param>
    /// <param name = "_paymentInfo">The payment information.</param>
    private static void attachCreditCardTokenToSalesOrder(RefRecId _channelRecId, SalesTable _salesTable, CreditCardCust _cCust, PaymentInfo _paymentInfo)
    {
        RetailChannelTable retailChannelTable = RetailChannelTable::findByRecId(_channelRecId);
        RetailParameters retailParameters = RetailParameters::find();

        ttsbegin;

        // Select for update
        _salesTable.reread();
        _salesTable.selectForUpdate();

        // Override the current Default Credit card for the Sales order,
        _salesTable.CreditCardCustRefId = _cCust.RecId;

        // Use retailChannelTable payment options if they exist, otherwise fall back on global RetailParameters.
        if (retailChannelTable.PaymMode)
        {
            _salesTable.PaymMode = retailChannelTable.PaymMode;
        }
        else if (retailParameters.PaymMode)
        {
            _salesTable.PaymMode = retailParameters.PaymMode;
        }

        if (retailChannelTable.Payment)
        {
            _salesTable.Payment = retailChannelTable.Payment;
        }
        else if (retailParameters.Payment)
        {
            _salesTable.Payment = retailParameters.Payment;
        }

        // Update settlement type
        _salesTable.SettleVoucher = SettlementType::SelectedTransact;
        _salesTable.update();
        ttscommit;

        // Update Credit card type and tender type
        RetailSalesTable retailSalesTable = RetailSalesTable::findSalesTable(_salesTable, true);
        if (retailSalesTable)
        {
            ttsbegin;
            retailSalesTable.CreditCardTenderTypeId = _paymentInfo.PaymentType;
            retailSalesTable.CreditCardTypeId = _paymentInfo.CardType;
            retailSalesTable.update();
            ttscommit;

            // Log TenderTYpe/CardType update
            eventSource.EventWritePaymentsUpdateTenderTypeCardTypeOnCard(_cCust.RecId, _salesTable.RecId);
        }

        // Refresh dataset
        _salesTable.reread();

        // Log attachment of Card token to Sales Order after execution
        if (_salesTable.CreditCardCustRefId == _cCust.RecId)
        {
            // Log successful attachment of credit card
            // Card Number should be masked at this point, but we get only the first 4 digits as an extra caution to not expose PII data
            eventSource.EventWritePaymentsAttachNewCardtoSalesOrderSuccessfully(_cCust.RecId, _salesTable.RecId);
        }
        else
        {
            // Log Failed attachment of credit card
            // Card Number should be masked at this point, but we get only the first 4 digits as an extra caution to not expose PII data
            eventSource.EventWritePaymentsAttachNewCardtoSalesOrderFailed(_cCust.RecId, _salesTable.RecId);
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>voidAllSalesOrderAuthorizations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Void previous authorizations for a credit card attached to a Sales Order (Used only in backward compatibility flow
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c> table buffer.</param>
    /// <param name = "_deleteAuth">delete authorization after void. Default to false.</param>
    internal static void voidAllSalesOrderAuthorizations(SalesTable _salesTable, boolean _deleteAuth = false)
    {
        // [Bug 862042] If flight is enabled, skip this check.
        // Based on the comments in the code, this was used for backward compatibility and may now cause performance issues.
        if (RetailPaymentDisableVoidAllSalesOrderAuthFlight::instance().isEnabled())
        {
            return;
        }

        // Search for open authorizations on the credit card used as default a the given Sales Order
        CreditCardAuthTrans creditCardAuthTrans;

        ttsbegin;

        while select RecId from creditCardAuthTrans
            where creditCardAuthTrans.SalesId == _salesTable.SalesId &&
                creditCardAuthTrans.UniqueCardId == CreditCardCust::find(_salesTable.CreditCardCustRefId).UniqueCardId &&
                creditCardAuthTrans.ApprovalType == CreditCardOperation::Authorize &&
                !creditCardAuthTrans.ApprovalExpired &&
                !creditCardAuthTrans.ApprovalVoid &&
                creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved
        {
            CreditCardAuthTrans creditCardAuthTransRecord = CreditCardAuthTrans::find(creditCardAuthTrans.RecId, true);
            // Void  Credit Card Pre-Authorization with Payment Service
            boolean isVoidSuccessfull = CreditCardProcess::doVoidAuth(creditCardAuthTransRecord);
            if (isVoidSuccessfull)
            {
                // Log SUCCESS
                eventSource.EventWritePaymentsAuthVoidSuccessful(creditCardAuthTransRecord.RecId , _salesTable.RecId);
            }
            else
            {
                // Log FAILURE
                eventSource.EventWritePaymentsAuthVoidFailed(creditCardAuthTransRecord.RecId , _salesTable.RecId);
            }

            if ( _deleteAuth)
            {
                creditCardAuthTransRecord.delete();
            }

        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordExistingSalesOrderPaymentAuthorization</Name>
				<Source><![CDATA[
    /// <summary>
    /// Record an EXISTING Sales Order payment authorization.
    /// Updates an original CreditCardAuthTrans AUTH record by a new one, and expires original authorization
    /// </summary>
    /// <param name = "_channelRecId">The channel.</param>
    /// <param name = "_salesTable">The <c>SalesTable</c> buffer.</param>
    /// <param name = "_originalAuthTrans">The original CreditCArdAuthTrans to be expired.</param>
    /// <param name = "_paymentInfo">The payment Info instance with details of the new authorization.</param>
    /// <param name = "_succeeded">Record authorization as succeeded? (Y/N).</param>
    /// <param name = "_existingDeclinedPayments">The declined payments list.</param>
    /// <param name = "_newPayments">The New payments list.</param>
    /// <param name = "_originalMCRCustPaymTable">The <c>MCRCustPaymTable</c> buffer. Default is 0.</param>
    /// <returns>The <c>CreditCardAuthTrans</c> record.</returns>
    private static CreditCardAuthTrans recordExistingSalesOrderPaymentAuthorization(
        RefRecId            _channelRecId,
        SalesTable          _salesTable,
        CreditCardAuthTrans _originalAuthTrans,
        PaymentInfo         _paymentInfo,
        boolean             _succeeded,
        container           _existingDeclinedPayments,
        container           _newPayments,
        MCRCustpaymTable    _originalMCRCustPaymTable = null)
    {
        // Original Auth is still valid
        boolean isOriginalAuthExpired = false;

        // Buffer for new authorization details
        CreditCardAuthTrans newAuthTrans;

        // Find new authorization UniqueCardId
        CreditCardPaymentProperties newProperties = CreditCardPaymentProperties::fromXmlString(_paymentInfo.CreditCardToken);
        str newUniqueCardId = newProperties.find(
                        Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                        Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_UniqueCardId()).parmStringValue();

        // If new authorization differs from the original in UniqueCardId, CurrencyCode, AuthorizedAmount or CreditCardAuthorization
        // update original authorization as expired and record new authorization.
        if (_originalAuthTrans.UniqueCardId      != newUniqueCardId ||
            _originalAuthTrans.CurrencyCode      != _paymentInfo.Currency ||
            _originalAuthTrans.ApprovalAmountCur != _paymentInfo.AuthorizedAmount)
        {
            // IF payment Info contains Card Authorization XML, Record new authorization after expiring the original one.
            if (_paymentInfo.CreditCardAuthorization)
            {
                try
                {
                    if (_succeeded)
                    {
                        //-------------------------------------------
                        // Expire Original Credit Card Authorization
                        //-------------------------------------------

                        isOriginalAuthExpired = CreditCardAuthTrans::setAuthorizationExpired(_originalAuthTrans.RecId);

                        // Update remaining balance,
                    }
                    else
                    {
                        // Log payment expiration FAILURE details
                        eventSource.EventWritePaymentsOriginalAuthTransNotFound(_originalMCRCustPaymTable ? _originalMCRCustPaymTable.RecId : _originalAuthTrans.RecId, _salesTable.RecId);
                    }

                    // Record new authorization success when Auth is approved and the original auth is successfully expired or
                    // Record new authorization failure when Auth is declined
                    // Link new authorization to MCRCustPaymTable (when specified)
                    if (_succeeded && isOriginalAuthExpired || !_succeeded)
                    {
                        //-------------------------------------------
                        // Record new Credit Card Authorization
                        //-------------------------------------------
                        try
                        {
                            // Extract Credit card authorization properties
                            CreditCardPaymentProperties properties = CreditCardPaymentProperties::fromXmlString(_paymentInfo.CreditCardAuthorization);

                            // Verify if the channel where the Sales order was created is a Call center, and retrieve it.
                            RetailMCRChannelTable callCenterUsedForOrderCreation = RetailMCRChannelTable::findRecId(_channelRecId);

                            boolean isCommercePaymentsOrder = RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName());

                            if ((callCenterUsedForOrderCreation && _salesTable.mcrIsCallCenter() && callCenterUsedForOrderCreation.MCREnableOrderCompletion) ||
                                isCommercePaymentsOrder)
                            {
                                // Update original MCRCustPaymTable record (Call center payment)
                                [
                                    _originalMCRCustPaymTable,
                                    _existingDeclinedPayments,
                                    _newPayments
                                ]
                                = RetailTransactionPaymentsHelper::updateCallCenterPaymentAuthorization(
                                    _salesTable,
                                    _originalAuthTrans,
                                    _paymentInfo,
                                    _succeeded,
                                    _originalMCRCustPaymTable,
                                    _existingDeclinedPayments,
                                    _newPayments);

                                // POS and E-Commerce card payments are not linked to the CreditCardProcessor, so we should clear this field.
                                RecId bestMatchForCreditCardProcessor =  isCommercePaymentsOrder ? 0 : CreditCard::FindBestMatchCreditCardProcessorId(properties);

                                // Call Center or Commerce Payment Orders: Record NEW Authorization and link it to the _originalMCRCustPaymTable
                                CreditCard::recordAuthorization(
                                CreditCardProviderAuthorizationResult::constructFromXmlString(_paymentInfo.CreditCardAuthorization),
                                _salesTable,
                                bestMatchForCreditCardProcessor,
                                _succeeded,
                                strFmt("@SYS327114", _salesTable.SalesId),
                                _paymentInfo.CreditCardAuthorization,
                                true,
                                _originalMCRCustPaymTable);

                                // Find the newly created authorization
                                newAuthTrans = CreditCardAuthTrans::mcrFindCharge(_originalMCRCustPaymTable.RecId);
                            }
                            else
                            {
                                // Retail Orders: Record the credit card authorization transaction details in CreditCardAuthTrans
                                CreditCard::recordAuthorization(CreditCardProviderAuthorizationResult::constructFromXmlString(_paymentInfo.CreditCardAuthorization),
                                    _salesTable,
                                    CreditCard::FindBestMatchCreditCardProcessorId(properties),
                                    _succeeded,
                                    strFmt("@SYS327114", _salesTable.SalesId),
                                    _paymentInfo.CreditCardAuthorization,
                                    false);

                                // Find the newly created authorization
                                newAuthTrans = CreditCardAuthTrans::findLatest(_salesTable.SalesId);
                            }

                            // Log payment new authorization SUCCESS details
                            // Note: The new authorization is always the latest one for the given SalesId or call center payment (MCRCustPaymTable)
                            eventSource.EventWritePaymentsCreditCardAuthRecorded_V2(_salesTable.RecId, _originalAuthTrans.RecId);
                        }
                        catch
                        {
                            // Log payment new authorization FAILURE details
                            // Note: The new authorization is always the latest one for the given SalesId or call center payment (MCRCustPaymTable)
                            eventSource.EventWritePaymentsCreditCardAuthRecordFailed_V2(_salesTable.RecId, _originalAuthTrans.RecId);

                        }
                        // Log payment expiration SUCCESS details
                        eventSource.EventWritePaymentsOriginalAuthExpiredSuccessfully(_salesTable.RecId, _originalAuthTrans.RecId);
                    }
                }
                catch
                {
                    // Log payment expiration FAILURE details
                    eventSource.EventWritePaymentsOriginalAuthExpirationFailed(_salesTable.RecId, _originalAuthTrans.RecId);
                }
            }
        }
        else
        {
            // Log payment authorization unchanged
            // Note: The new authorization is always the latest one for the given SalesId or call center payment (MCRCustPaymTable)
            eventSource.EventWritePaymentsNoChangesDetected(_salesTable.RecId, _originalAuthTrans.RecId);
        }

        return newAuthTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordNewSalesOrderPaymentAuthorization</Name>
				<Source><![CDATA[
    /// <summary>
    /// Record a NEW Sales Order payment authorization.
    /// </summary>
    /// <param name = "_channelRecId">The channel RecId.</param>
    /// <param name = "_salesTable">The <c>SalesTable</c> buffer.</param>
    /// <param name = "_paymentInfo">The paymentInfo instance.</param>
    /// <param name = "_voidAuth">Whether the authorization should be voided.</param>
    /// <param name = "_mcrCustPaymTable">The <c>MCRCustPaymTable</c> table buffer.</param>
    internal static void recordNewSalesOrderPaymentAuthorization(
        RefRecId _channelRecId,
        SalesTable _salesTable,
        PaymentInfo _paymentInfo,
        boolean _voidAuth = true,
        MCRCustPaymTable _mcrCustPaymTable = null)
    {
        // Log before process
        eventSource.EventWritePaymentsRecordingPaymentAuthorization(_salesTable.RecId);

        // Process credit card payment authorizations (AUTH).
        if (_paymentInfo.CreditCardToken)
        {
            boolean isCommerceEnabledPaymentsOrder = RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName());
            // Add the credit card token to the customer
            CreditCardCust creditCardCust = RetailTransactionPaymentsHelper::createCreditCardForCustomer(_salesTable.InvoiceAccount, _salesTable, _paymentInfo.CreditCardToken);

            // [Backward compatibility]
            // If the Original Credit Card for the Sales Order is already authorized, void all previous authorizations
            if (_voidAuth)
            {
                RetailTransactionPaymentsHelper::voidAllSalesOrderAuthorizations(_salesTable);
            }

            if (isCommerceEnabledPaymentsOrder && _mcrCustPaymTable && _mcrCustPaymTable.RecId != 0)
            {
                ttsbegin;
                _mcrCustPaymTable.reread();
                _mcrCustPaymTable.selectForUpdate();
                _mcrCustPaymTable.PaymInfoTableId = tableNum(CreditCardCust);
                _mcrCustPaymTable.PaymInfoRecId = creditCardCust.RecId;
                _mcrCustPaymTable.update();
                ttscommit;

                eventSource.EventWritePaymentsLinkedCreditCardCustDuringPaymentAuthorizationForCommerceEnabledOrder(
                    _salesTable.RecId,
                    _mcrCustPaymTable.RecId,
                    creditCardCust.RecId);
            }
            else
            {
                // Replace original Credit card from the Order with the newly created credit card token
                RetailTransactionPaymentsHelper::attachCreditCardTokenToSalesOrder(_channelRecId, _salesTable, creditCardCust, _paymentInfo);
            }

            // IF payment Info contains Card Authorization XML
            // Record the credit card AUTH transaction details in CreditCardAuthTrans
            if (_paymentInfo.CreditCardAuthorization)
            {
                // Extract authorization properties
                CreditCardPaymentProperties properties = CreditCardPaymentProperties::fromXmlString(_paymentInfo.CreditCardAuthorization);

                // Verify if the Channel where the order was created is a Call center and retrieve it
                RetailMCRChannelTable callCenterUsedForOrderCreation = RetailMCRChannelTable::findRecId(_channelRecId);

                // Select for update
                _salesTable.reread();
                _salesTable.selectForUpdate();

                ttsbegin;

                CreditCardProviderResult ccProviderAuthResult = CreditCardProviderAuthorizationResult::constructFromXmlString(_paymentInfo.CreditCardAuthorization);

                // If the unique card id is not set then attempt to retrieve it from the payment card namespace.
                if (isCommerceEnabledPaymentsOrder && !ccProviderAuthResult.parmCreditCardUniqueCardId())
                {
                    ccProviderAuthResult = RetailTransactionPaymentsHelper::setUniqueCardIdFromPaymentCardNamespace(ccProviderAuthResult, properties);
                }

                // If feature flag is turned on, we no longer associate CreditCardProcessor to the authorization.
                if (isCommerceEnabledPaymentsOrder)
                {

                    CreditCard::recordAuthorization(ccProviderAuthResult,
                                                    _salesTable,
                                                    0,
                                                    true,
                                                    strFmt("@SYS327114", _salesTable.SalesId),
                                                    _paymentInfo.CreditCardToken,
                                                    true,
                                                    _mcrCustPaymTable);

                    eventSource.EventWritePaymentsAddedNewPaymentAuthorizationForCommerceEnabledOrder(_salesTable.RecId, _mcrCustPaymTable.RecId);

                }
                else
                {
                    if (callCenterUsedForOrderCreation && _salesTable.mcrIsCallCenter() && callCenterUsedForOrderCreation.MCREnableOrderCompletion)
                    {
                        CreditCard::recordAuthorization(ccProviderAuthResult,
                                                    _salesTable,
                                                    CreditCard::FindBestMatchCreditCardProcessorId(properties),
                                                    true,
                                                    strFmt("@SYS327114", _salesTable.SalesId),
                                                    _paymentInfo.CreditCardToken,
                                                    true,
                                                    MCRCustPaymTable::findByRecID(_paymentInfo.PaymentRefRecId));

                        eventSource.EventWritePaymentsAddedNewPaymentAuthorizationForCallCenterOrder(_salesTable.RecId, _paymentInfo.PaymentRefRecId);
                    }
                    else
                    {
                        CreditCard::recordAuthorization(ccProviderAuthResult,
                                                    _salesTable,
                                                    CreditCard::FindBestMatchCreditCardProcessorId(properties),
                                                    true,
                                                    strFmt("@SYS327114", _salesTable.SalesId),
                                                    _paymentInfo.CreditCardToken,
                                                    false);

                        eventSource.EventWritePaymentsAddedNewPaymentAuthorizationForNonCallCenterOrder(_salesTable.RecId);
                    }
                }

                ttscommit;

                // Log Credit card authorization recorded
                eventSource.EventWritePaymentsPaymentAuthRecordingSuccessful(_salesTable.RecId);
            }
            else
            {
                // Log Credit Card Authorization not present
                eventSource.EventWritePaymentsPaymentAuthNotPresent(_salesTable.RecId);
            }
        }
        else
        {
            // Log Card Token not present
            eventSource.EventWritePaymentsPaymentCreditCardTokenNotPresent(_salesTable.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUniqueCardIdFromPaymentCardNamespace</Name>
				<Source><![CDATA[
    private static CreditCardProviderResult setUniqueCardIdFromPaymentCardNamespace(CreditCardProviderResult _result, CreditCardPaymentProperties _properties)
    {
        str paymentCardNamespace = Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard();
        CreditCardPaymentProperty property = _properties.find(paymentCardNamespace, Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_UniqueCardId());

        _result.parmCreditCardUniqueCardId(property ? property.parmStringValue() : '');
        return _result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCallCenterPaymentAuthorization</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Update AUTHORIZATION of an EXISTING Call Center Sales Order payment authorization.
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c> buffer.</param>
    /// <param name = "_originalAuthTrans">The original CreditCArdAuthTrans to be expired.</param>
    /// <param name = "_paymentInfo">The payment Info instance with details of the new authorization.</param>
    /// <param name = "_succeeded">Record authorization as succeeded? (Y/N).</param>
    /// <param name = "_mcrCustPaymTable">The <c>MCRCustPaymTable</c> buffer. Default is 0.</param>
    /// <param name = "_existingDeclinedPayments">The declined payments list.</param>
    /// <param name = "_newPayments">The new payments list</param>
    /// <returns>A container with <c>MCRCustPaymTable</c> buffer for the resulting call center payment, the new and declined payment lists</returns>
    private static container updateCallCenterPaymentAuthorization(
        SalesTable          _salesTable,
        CreditCardAuthTrans _originalAuthTrans,
        PaymentInfo         _paymentInfo,
        boolean             _succeeded,
        MCRCustPaymTable    _mcrCustPaymTable,
        container           _existingDeclinedPayments,
        container           _newPayments)
    {
        // Find new authorization UniqueCardId
        CreditCardPaymentProperties newProperties = CreditCardPaymentProperties::fromXmlString(_paymentInfo.CreditCardToken);
        str newUniqueCardId = newProperties.find(
                        Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                        Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_UniqueCardId()).parmStringValue();

        // If new authorization differs from the original in UniqueCardId, CurrencyCode, AuthorizedAmount or CreditCardAuthorization
        // update original authorization as expired and record new authorization.
        if (_originalAuthTrans.UniqueCardId != newUniqueCardId ||
            _originalAuthTrans.CurrencyCode != _paymentInfo.Currency ||
            _originalAuthTrans.ApprovalAmountCur != _paymentInfo.AuthorizedAmount ||
            _originalAuthTrans.CardTokenResult != _paymentInfo.CreditCardAuthorization)
        {
            RetailMCRChannelTable callCenterUsedForOrderCreation = RetailMCRChannelTable::findChannelBySalesTable(_salesTable);
            boolean isCommercePaymentsOrder = RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName());

            if ((callCenterUsedForOrderCreation && _salesTable.mcrIsCallCenter() && callCenterUsedForOrderCreation.MCREnableOrderCompletion)
                || isCommercePaymentsOrder)
            {
                if (_mcrCustPaymTable)
                {
                    try
                    {
                        ttsbegin;

                        if (_succeeded)
                        {
                            // Mark Credit card as processed
                            _mcrCustPaymTable.isCreditCardProcessed = true;

                            // Set original Call center payment Status to APPROVED
                            _mcrCustPaymTable.Status = MCRCustPaymStatus::Authorized;

                            if (RetailIncrementalCaptureFeatureExposure::isEnabled() &&
                                _paymentInfo.AuthorizedAmount > 0 &&
                                _mcrCustPaymTable.Amount != _paymentInfo.AuthorizedAmount)
                            {
                                // Reset amount for Reauthorized and partial void when amounts are different from the original authorization amount.
                                _mcrCustPaymTable.Amount = _paymentInfo.AuthorizedAmount;
                            }

                            _mcrCustPaymTable.update();

                            eventSource.EventWritePaymentsUpdatedPaymentLineStatusForCallCenterAuthorization(
                                _salesTable.RecId,
                                isCommercePaymentsOrder,
                                _mcrCustPaymTable.RecId,
                                enum2Str(MCRCustPaymStatus::Authorized),
                                _succeeded);
                        }
                        else
                        {
                            // If the received declined authorization is from a call center payment that is partly consumed already.
                            MCRCustPaymTable declinedMcrCustPaymTable;
                            if (_mcrCustPaymTable.PostedAmount > 0)
                            {
                                // Split the Posted and unposted parts of the payments of existing MCRCustPaymTable into 2 payment lines.
                                // Bad/Declined Payment: Create new payment line with amount = unposted amount and status DECLINED.
                                declinedMCRCustPaymTable =
                                    RetailTransactionPaymentsHelper::splitCallCenterPayment(
                                    _salesTable,
                                    _mcrCustPaymTable,
                                    MCRCustPaymStatus::Declined);

                                // Good/Already Captured Payment: update the original mcrCustPaymTable with amount = posted amount and status as PAID.
                                _mcrCustPaymTable.reread();
                                _mcrCustPaymTable.selectForUpdate();
                                _mcrCustPaymTable.Amount = _mcrCustPaymTable.PostedAmount;
                                _mcrCustPaymTable.Status = MCRCustPaymStatus::Paid;
                                _mcrCustPaymTable.update();

                                eventSource.EventWritePaymentsUpdatedPaymentLineStatusForCallCenterAuthorization(
                                _salesTable.RecId,
                                isCommercePaymentsOrder,
                                _mcrCustPaymTable.RecId,
                                enum2Str(MCRCustPaymStatus::Paid),
                                _succeeded);
                            }
                            else
                            {
                                declinedMCRCustPaymTable = _mcrCustPaymTable;
                                declinedMcrCustPaymTable.reread();
                                declinedMcrCustPaymTable.selectForUpdate();
                                declinedMcrCustPaymTable.Status = MCRCustPaymStatus::Declined;
                                declinedMcrCustPaymTable.update();

                                eventSource.EventWritePaymentsUpdatedPaymentLineStatusForCallCenterAuthorization(
                                _salesTable.RecId,
                                isCommercePaymentsOrder,
                                declinedMcrCustPaymTable.RecId,
                                enum2Str(MCRCustPaymStatus::Declined),
                                _succeeded);
                            }

                            // Add it to the existingDeclinedPayments container.
                            // Add split payment into declined payments list
                            _existingDeclinedPayments = conIns(_existingDeclinedPayments, conLen(_existingDeclinedPayments) + 1, declinedMCRCustPaymTable.RecId);

                        }

                        ttscommit;

                        // Log MCRCustPaymTable update SUCCESS
                        eventSource.EventWritePaymentsPaymentUpdateSuccessful_V2(_salesTable.RecId, _mcrCustPaymTable.RecId);
                    }
                    catch
                    {
                        // Log  update MCRCustPaymTable ERROR
                        eventSource.EventWritePaymentsPaymentUpdateFailed_V2(_salesTable.RecId,_mcrCustPaymTable.RecId);
                    }
                }
                else
                {
                    // Log error: Original MCRCustPaymTable (Call center payment) was not found
                    eventSource.EventWritePaymentsPaymentNotFound_V2(_salesTable.RecId, _mcrCustPaymTable.RecId);
                }
            }
        }
        else
        {
            // Log SKIP due to Authorization not changed.
            eventSource.EventWritePaymentsOriginalAmountNotChanged_V2(_salesTable.RecId, _mcrCustPaymTable.RecId);
        }

        return [_mcrCustPaymTable, _existingDeclinedPayments, _newPayments];

    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCallCenterPaymentCapture</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Update CAPTURE of an EXISTING Call Center Sales Order payment authorization.
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c> buffer.</param>
    /// <param name = "_originalAuthTrans">The original CreditCArdAuthTrans to be expired.</param>
    /// <param name = "_paymentInfo">The payment Info instance with details of the new authorization.</param>
    /// <param name = "_succeeded">Record capture as succeeded? (Y/N).</param>
    /// <param name = "_mcrCustPaymTable">The <c>MCRCustPaymTable</c> buffer. Default is 0.</param>
    /// <returns>Updated <c>MCRCustPaymTable</c> buffer for the resulting call center payment.</returns>
    private static MCRCustPaymTable updateCallCenterPaymentCapture(
        SalesTable          _salesTable,
        CreditCardAuthTrans _originalAuthTrans,
        PaymentInfo         _paymentInfo,
        boolean             _succeeded,
        MCRCustPaymTable    _mcrCustPaymTable)
    {
        MCRCustPaymTable declinedMCRCustPaymTable;

        // Find new authorization UniqueCardId
        CreditCardPaymentProperties newProperties = CreditCardPaymentProperties::fromXmlString(_paymentInfo.CreditCardToken);
        str newUniqueCardId = newProperties.find(
                        Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                        Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_UniqueCardId()).parmStringValue();

        // If capture details are the same as the original authorization
        // (same UniqueCardId, currency and new authorized amount less or equal to original approved amount),
        // then record the CAPTURE.
        if (_originalAuthTrans.UniqueCardId == newUniqueCardId ||
            _originalAuthTrans.CurrencyCode == _paymentInfo.Currency ||
            _originalAuthTrans.ApprovalAmountCur >= _paymentInfo.AuthorizedAmount)
        {
            RetailMCRChannelTable callCenterUsedForOrderCreation = RetailMCRChannelTable::findChannelBySalesTable(_salesTable);
            boolean isCommercePaymentsOrder = RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName());

            if ((callCenterUsedForOrderCreation && _salesTable.mcrIsCallCenter() && callCenterUsedForOrderCreation.MCREnableOrderCompletion) ||
                isCommercePaymentsOrder)
            {
                if (_mcrCustPaymTable)
                {
                    try
                    {
                        ttsbegin;
                        // Select call center payment for update
                        _mcrCustPaymTable.reread();
                        _mcrCustPaymTable.selectForUpdate();

                        // Mark Credit card as processed
                        _mcrCustPaymTable.isCreditCardProcessed = true;

                        // Payment Capture is APPROVED
                        if (_succeeded)
                        {
                            // Add captured amount to Call center payment Posted amount
                            _mcrCustPaymTable.PostedAmount += _paymentInfo.Amount;
                            _mcrCustPaymTable.CurrencyCode = _paymentInfo.Currency;

                            if (isCommercePaymentsOrder)
                            {
                                _mcrCustPaymTable.Status = MCRCustPaymStatus::Paid;

                                eventSource.EventWritePaymentsUpdatedPaymentLineStatusForCallCenterCapture(
                                    _salesTable.RecId,
                                    isCommercePaymentsOrder,
                                    _mcrCustPaymTable.RecId,
                                    enum2Str(MCRCustPaymStatus::Paid),
                                    _succeeded);
                            }
                            else
                            {
                                // Set original Call center payment Status to Paid or Posted
                                _mcrCustPaymTable.Status = _mcrCustPaymTable.PostedAmount < _mcrCustPaymTable.Amount ? MCRCustPaymStatus::Paid : MCRCustPaymStatus::Posted;
                            }
                            _mcrCustPaymTable.update();

                            // Authorize any remaining balance for this payment
                            _mcrCustPaymTable.reread();
                            _mcrCustPaymTable.selectForUpdate();

                            if ( _mcrCustPaymTable.getUnpostedAmount() > 0.00)
                            {
                                if (CreditCardProcess::mcrDoPreAuth(_mcrCustPaymTable))
                                {
                                    // Log MCRCustPaymTable authorization SUCCESS
                                    eventSource.EventWritePaymentsReAuthUnpostedAmount(_mcrCustPaymTable.RecId);
                                }
                                else
                                {
                                    // Log MCRCustPaymTable authorization Failure
                                    eventSource.EventWritePaymentsReAuthUnpostedAmountFailed(_mcrCustPaymTable.RecId);
                                }
                            }
                        }
                        // Payment Capture is DECLINED
                        else
                        {
                            if (_mcrCustPaymTable.PostedAmount > 0)
                            {
                                // Split the Posted and unposted parts of the payments of existing MCRCustPaymTable into 2 payment lines.
                                // Bad/Declined Payment: Create new payment line with amount = unposted amount and status DECLINED.
                                declinedMCRCustPaymTable =
                                    RetailTransactionPaymentsHelper::splitCallCenterPayment(
                                    _salesTable,
                                    _mcrCustPaymTable,
                                    MCRCustPaymStatus::Declined);

                                // Good/Already Captured Payment: update the original mcrCustPaymTable with amount = posted amount and status as POSTED.
                                _mcrCustPaymTable.reread();
                                _mcrCustPaymTable.selectForUpdate();
                                _mcrCustPaymTable.Amount = _mcrCustPaymTable.PostedAmount;
                                _mcrCustPaymTable.Status = MCRCustPaymStatus::Paid;
                                _mcrCustPaymTable.update();

                                eventSource.EventWritePaymentsUpdatedPaymentLineStatusForCallCenterCapture(
                                    _salesTable.RecId,
                                    isCommercePaymentsOrder,
                                    _mcrCustPaymTable.RecId,
                                    enum2Str(MCRCustPaymStatus::Paid),
                                    _succeeded);
                            }
                            else
                            {
                                declinedMCRCustPaymTable = _mcrCustPaymTable;
                                declinedMCRCustPaymTable.Status = MCRCustPaymStatus::Declined;
                                declinedMCRCustPaymTable.update();

                                eventSource.EventWritePaymentsUpdatedPaymentLineStatusForCallCenterCapture(
                                    _salesTable.RecId,
                                    isCommercePaymentsOrder,
                                    _mcrCustPaymTable.RecId,
                                    enum2Str(MCRCustPaymStatus::Declined),
                                    _succeeded);
                            }

                            if (declinedMCRCustPaymTable.Amount != _paymentInfo.RefundableAmount)
                            {
                                // Take the declined payment, and split into Declined/Non Declined call center payments
                                // Note: temporarily setting the PostedAmount to split the payment, and then rolling back afterwards.
                                declinedMCRCustPaymTable.reread();
                                declinedMCRCustPaymTable.selectForUpdate();
                                declinedMCRCustPaymTable.PostedAmount = _paymentInfo.RefundableAmount;
                                declinedMCRCustPaymTable.update();

                                // Now split current declined amount and from overall declined amount of declinedMCRCustPaymTable into 2 payment lines.
                                // This is done to take into account intermittent failures which could result in authorization capture failures.
                                // unconsumedDeclinedMCRCustPaymTable - unconsumed part of unposted payment which is supposed to be for fulfullment later.
                                McrCustPaymTable unconsumedDeclinedMCRCustPaymTable =
                                RetailTransactionPaymentsHelper::splitCallCenterPayment(
                                    _salesTable,
                                    declinedMCRCustPaymTable,
                                    MCRCustPaymStatus::Authorized);


                                eventSource.EventWritePaymentsCreatedPaymentForUnconsumedDeclinedAmount(
                                    _salesTable.RecId,
                                    isCommercePaymentsOrder,
                                    unconsumedDeclinedMCRCustPaymTable.RecId,
                                    enum2Str(MCRCustPaymStatus::Authorized),
                                    _succeeded);


                                // roll back posted amount, Adjust status of Non Declined call center payment
                                // set status of declined call center payment
                                declinedMCRCustPaymTable.reread();
                                declinedMCRCustPaymTable.selectForUpdate();
                                declinedMCRCustPaymTable.Amount = declinedMCRCustPaymTable.PostedAmount;
                                declinedMCRCustPaymTable.PostedAmount =  0.00;
                                declinedMCRCustPaymTable.update();
                            }

                            // Log MCRCustPaymTable update SUCCESS
                            eventSource.EventWritePaymentsCallCenterPaymentUpdateSuccessful_V2(_salesTable.RecId, _mcrCustPaymTable.RecId);
                        }
                        ttscommit;
                    }
                    catch
                    {
                        // Log  update MCRCustPaymTable ERROR
                        eventSource.EventWritePaymentsCallCenterPaymentUpdateFailed_V2(_salesTable.RecId, _mcrCustPaymTable.RecId);
                    }
                }
                else
                {
                    // Log error: Original MCRCustPaymTable (Call center payment) was not found
                    eventSource.EventWritePaymentsCallCenterPaymentNotFound_V2(_salesTable.RecId, _mcrCustPaymTable.RecId);
                }
            }
        }
        else
        {
            // Log Captured amount is higher than original approved amount.
            eventSource.EventWritePaymentsCallCenterPaymentAmountsUnmatched(_mcrCustPaymTable.RecId);
        }

        return declinedMCRCustPaymTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCallCenterPaymentVoid_ForCommercePaymentOrders</Name>
				<Source><![CDATA[
    /// <summary>
    ///  update VOID of an EXISTING  Commerce Payments Order Order payment authorization.
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c> buffer.</param>
    /// <param name = "_originalAuthTrans">The original CreditCArdAuthTrans to be expired.</param>
    /// <param name = "_paymentInfo">The payment Info instance with details of the new authorization.</param>
    /// <param name = "_succeeded">Record authorization as succeeded? (Y/N).</param>
    /// <param name = "_mcrCustPaymTable">The <c>MCRCustPaymTable</c> buffer. Default is 0.</param>
    private static void updateCallCenterPaymentVoid_ForCommercePaymentOrders(
        SalesTable          _salesTable,
        CreditCardAuthTrans _originalAuthTrans,
        PaymentInfo         _paymentInfo,
        boolean             _succeeded,
        MCRCustPaymTable    _mcrCustPaymTable)
    {
        // Void Retry successful?
        boolean isReTryVoidSuccessful = false;

        // Find new authorization UniqueCardId
        CreditCardPaymentProperties newProperties = CreditCardPaymentProperties::fromXmlString(_paymentInfo.CreditCardToken);
        str newUniqueCardId = newProperties.find(
                        Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                        Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_UniqueCardId()).parmStringValue();

        // If VOID details are the same as the original authorization
        // (same UniqueCardId, currency and new authorized amount less or equal to original approved amount),
        // then record the CAPTURE.
        if (_originalAuthTrans.UniqueCardId == newUniqueCardId ||
            _originalAuthTrans.CurrencyCode == _paymentInfo.Currency ||
            _originalAuthTrans.ApprovalAmountCur >= _paymentInfo.AuthorizedAmount)
        {
            if (_mcrCustPaymTable)
            {
                try
                {
                    ttsbegin;

                    // POS and E-Commerce card payments are not linked to the CreditCardProcessor, so we should clear this field.
                    // record new VOID APPROVED and link it to MCRCustPaymTable
                    CreditCard::recordVoid(CreditCardProviderVoidResult::constructFromXmlString(_paymentInfo.CreditCardAuthorization),
                                _salesTable,
                                0,
                                _succeeded,
                                strFmt("@SYS327114", _salesTable.SalesId),
                                _paymentInfo.CreditCardToken,
                                false,
                                _mcrCustPaymTable);

                    // In case of a VOID - DECLINED/ERROR, try to void again...
                    if (!_succeeded)
                    {
                        // Retry to VOID the authorization
                        isReTryVoidSuccessful = CreditCardProcess::mcrDoVoidPreAuth(_mcrCustPaymTable);
                    }

                    if (_succeeded || isReTryVoidSuccessful)
                    {
                        _mcrCustPaymTable.reread();
                        _mcrCustPaymTable.selectForUpdate();

                        // Set the call center payment status
                        _mcrCustPaymTable.isCreditCardProcessed = true;

                        // Decrease Call center payment amount by the amount voided on the channel
                        _mcrCustPaymTable.Amount = _mcrCustPaymTable.Amount - _paymentInfo.Amount;

                        // Set new status accordingly
                        if ( _mcrCustPaymTable.Amount == 0.00)
                        {
                            //if Amount is 0, decline the payment to delete it later
                            _mcrCustPaymTable.Status = MCRCustPaymStatus::Declined;
                        }
                        else if (_mcrCustPaymTable.PostedAmount == 0.00)
                        {
                            // If Amount != 0 and PostedAmount = 0, set as NotSubmitted and re-auth remaining balance later
                            _mcrCustPaymTable.Status = MCRCustPaymStatus::NotSubmitted;
                        }
                        else
                        {
                            // If Posted Amount is not equal to 0, set as Posted and reduce amount to be equal to posted amount
                            // so that order completion continues to work.
                            _mcrCustPaymTable.Amount = _mcrCustPaymTable.PostedAmount;
                            _mcrCustPaymTable.Status = MCRCustPaymStatus::Paid;
                        }

                        _mcrCustPaymTable.update();
                    }

                    if (_mcrCustPaymTable.Status == MCRCustPaymStatus::NotSubmitted || _mcrCustPaymTable.Status == MCRCustPaymStatus::Declined)
                    {
                        // If posted amount is 0 i.e. payment line is fully unconsumed then delete the payment lines
                        // for invoicing to succeed.
                        _mcrCustPaymTable.delete();
                    }
                    ttscommit;

                    // Log MCRCustPaymTable update SUCCESS
                    eventSource.EventWritePaymentsCallCenterPaymentVoidSuccessful_V2(_salesTable.RecId, _mcrCustPaymTable.RecId);
                }
                catch
                {
                    // Log  update MCRCustPaymTable ERROR
                    eventSource.EventWritePaymentsCallCenterPaymentVoidFailed_V2(_salesTable.RecId, _mcrCustPaymTable.RecId);
                }
            }
            else
            {
                // Log error: Original MCRCustPaymTable (Call center payment) was not found
                eventSource.EventWritePaymentsCallCenterVoidPaymentNotFound_V2(_salesTable.RecId, _mcrCustPaymTable.RecId);
            }
        }
        else
        {
            // Log Captured amount is higher than original approved amount.
            eventSource.EventWritePaymentsCallCenterVoidPaymentAmountsUnmatched_V2(_salesTable.RecId, _mcrCustPaymTable.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCallCenterPaymentVoid</Name>
				<Source><![CDATA[
    /// <summary>
    ///  update VOID of an EXISTING Call Center Sales Order payment authorization.
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c> buffer.</param>
    /// <param name = "_originalAuthTrans">The original CreditCArdAuthTrans to be expired.</param>
    /// <param name = "_paymentInfo">The payment Info instance with details of the new authorization.</param>
    /// <param name = "_succeeded">Record authorization as succeeded? (Y/N).</param>
    /// <param name = "_mcrCustPaymTable">The <c>MCRCustPaymTable</c> buffer. Default is 0.</param>
    private static void updateCallCenterPaymentVoid(
        SalesTable          _salesTable,
        CreditCardAuthTrans _originalAuthTrans,
        PaymentInfo         _paymentInfo,
        boolean             _succeeded,
        MCRCustPaymTable    _mcrCustPaymTable
        )
    {
        // Void Retry successful?
        boolean isReTryVoidSuccessful = false;

        // Find new authorization UniqueCardId
        CreditCardPaymentProperties newProperties = CreditCardPaymentProperties::fromXmlString(_paymentInfo.CreditCardToken);
        str newUniqueCardId = newProperties.find(
                        Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                        Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_UniqueCardId()).parmStringValue();

        // If VOID details are the same as the original authorization
        // (same UniqueCardId, currency and new authorized amount less or equal to original approved amount),
        // then record the CAPTURE.
        if (_originalAuthTrans.UniqueCardId == newUniqueCardId ||
            _originalAuthTrans.CurrencyCode == _paymentInfo.Currency ||
            _originalAuthTrans.ApprovalAmountCur >= _paymentInfo.AuthorizedAmount)
        {
            RetailMCRChannelTable callCenterUsedForOrderCreation = RetailMCRChannelTable::findChannelBySalesTable(_salesTable);
            if (callCenterUsedForOrderCreation && _salesTable.mcrIsCallCenter() && callCenterUsedForOrderCreation.MCREnableOrderCompletion)
            {
                if (_mcrCustPaymTable)
                {
                    try
                    {
                        ttsbegin;

                        // record new VOID APPROVED and link it to MCRCustPaymTable
                        CreditCard::recordVoid(CreditCardProviderVoidResult::constructFromXmlString(_paymentInfo.CreditCardAuthorization),
                                    _salesTable,
                                    CreditCard::FindBestMatchCreditCardProcessorId(newProperties),
                                    _succeeded,
                                    strFmt("@SYS327114", _salesTable.SalesId),
                                    _paymentInfo.CreditCardToken,
                                    false,
                                    _mcrCustPaymTable);

                        // In case of a VOID - DECLINED/ERROR, try to void again...
                        if (!_succeeded)
                        {
                            // Retry to VOID the authorization
                            isReTryVoidSuccessful = CreditCardProcess::mcrDoVoidPreAuth(_mcrCustPaymTable);
                        }

                        if (_succeeded || isReTryVoidSuccessful)
                        {
                            // Set the call center payment status
                            ttsbegin;
                            _mcrCustPaymTable.reread();
                            _mcrCustPaymTable.selectForUpdate();
                            _mcrCustPaymTable.isCreditCardProcessed = (_mcrCustPaymTable.CustPaymType == MCRCustPaymType::CreditCard ? true: false);

                            // Decrease Call center payment amount by the amount voided on the channel
                            _mcrCustPaymTable.Amount = _mcrCustPaymTable.Amount - _paymentInfo.Amount;

                            // Set new status accordingly
                            if ( _mcrCustPaymTable.Amount == 0.00)
                            {
                                //if Amount is 0, decline the payment to delete it later
                                _mcrCustPaymTable.Status = MCRCustPaymStatus::Declined;
                            }
                            else if (_mcrCustPaymTable.PostedAmount == 0.00)
                            {
                                // If Amount != 0 and PostedAmount = 0, set as NotSubmitted and re-auth remaining balance later
                                _mcrCustPaymTable.Status = MCRCustPaymStatus::NotSubmitted;
                            }
                            else if (_mcrCustPaymTable.Amount != _mcrCustPaymTable.PostedAmount)
                            {
                                // If Amount and Posted Amount are different, and both are different from 0, set as Paid and re-auth remaining balance later
                                _mcrCustPaymTable.Status = MCRCustPaymStatus::Paid;
                            }
                            else
                            {
                                // If Amount and Posted Amount are the same, and both are different from 0, set as Posted
                                _mcrCustPaymTable.Status = MCRCustPaymStatus::Posted;
                            }

                            _mcrCustPaymTable.update();
                            ttscommit;
                        }

                        _mcrCustPaymTable.reread();
                        _mcrCustPaymTable.selectForUpdate();

                        // The only statuses which accepts re-auths are NotSubmitted and Paid, which represents, respectively:
                        // - NotSubmitted: A payment that was never captured
                        // - Paid: A payment that was partially captured, but has a remaining balance to authorize
                        if (_mcrCustPaymTable.Status == MCRCustPaymStatus::NotSubmitted ||
                        _mcrCustPaymTable.Status == MCRCustPaymStatus::Paid)
                        {
                            // As the payment is still not fully voided, re-auth the remaining balance
                            if ( _mcrCustPaymTable.getUnpostedAmount() > 0.00)
                            {
                                if (!CreditCardProcess::mcrDoPreAuth(_mcrCustPaymTable))
                                {
                                    // Log authorization failure
                                    eventSource.EventWritePaymentsCallCenterPaymentAuthFailed(_mcrCustPaymTable.RecId);
                                }
                                else
                                {
                                    ttsbegin;
                                    _mcrCustPaymTable.reread();
                                    _mcrCustPaymTable.selectForUpdate();
                                    _mcrCustPaymTable.Status = _mcrCustPaymTable.Status == MCRCustPaymStatus::NotSubmitted ? MCRCustPaymStatus::Authorized : _mcrCustPaymTable.Status;
                                    _mcrCustPaymTable.update();
                                    ttscommit;
                                }
                            }
                        }
                        else if (_mcrCustPaymTable.Status == MCRCustPaymStatus::Declined)
                        {
                            // If the payment was fully voided, delete the payment
                            ttsbegin;
                            _mcrCustPaymTable.delete();
                            ttscommit;
                        }

                        ttscommit;

                        // Log MCRCustPaymTable update SUCCESS
                        eventSource.EventWritePaymentsCallCenterPaymentVoidSuccessful_V2(_salesTable.RecId, _mcrCustPaymTable.RecId);
                    }
                    catch
                    {
                        // Log  update MCRCustPaymTable ERROR
                        eventSource.EventWritePaymentsCallCenterPaymentVoidFailed_V2(_salesTable.RecId, _mcrCustPaymTable.RecId);
                    }
                }
                else
                {
                    // Log error: Original MCRCustPaymTable (Call center payment) was not found
                    eventSource.EventWritePaymentsCallCenterVoidPaymentNotFound_V2(_salesTable.RecId, _mcrCustPaymTable.RecId);
                }
            }
        }
        else
        {
            // Log Captured amount is higher than original approved amount.
            eventSource.EventWritePaymentsCallCenterVoidPaymentAmountsUnmatched_V2(_salesTable.RecId, _mcrCustPaymTable.RecId);
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>recordNewSalesOrderPaymentCapture</Name>
				<Source><![CDATA[
    /// <summary>
    /// Record NEW Sales Order captured payment (Payment Journals)
    /// </summary>
    /// <param name = "_channelRecId">The channel RecId.</param>
    /// <param name = "_salesTable">The <c>SalesTable</c> buffer.</param>
    /// <param name = "_custOrderInfo">The customerOrderInfo instance.</param>
    /// <param name = "_paymentInfo">The payment info intance from the payment info collection to be processed.</param>
    /// <param name = "_ledgerJournalTable">The <c>LedgerJournalTable</c> buffer.</param>
    /// <param name = "_rCashJournalTable">The <c>LedgerJournalTable</c> buffer for RCash.</param>
    /// <param name = "_custPaymJournalTable">The <c>LedgerJournalTable</c> buffer for Customer payment.</param>
    /// <param name = "_voucher">The voucher number.</param>
    /// <param name = "_rCashVoucher">The Cash voucher number.</param>
    /// <param name = "_custPaymVoucher">The customer payment voucher number.</param>
    /// <param name = "_isRCash">Is this a RCash payment journal? (Y/N).</param>
    /// <param name = "_isReturnOrder">is this a return order? (Y/N).</param>
    /// <param name = "_creditCardOperation">The credit card operation.</param>
    /// <param name = "_mcrCustPaymTable">The <c>MCRCustPaymTable</c> buffer associated with the payment (For call center orders).</param>
    /// <param name = "_advanceInvoiceContract">The Advance Invoice contract.</param>
    /// <returns>a container with ledgerJournalTable, LedgerJournalTrans, , voucher, rCashVoucher, custPaymVoucher.</returns>
    internal static container recordNewSalesOrderPaymentCapture(
        RefRecId _channelRecId,
        SalesTable _salesTable,
        CustomerOrderInfo _custOrderInfo,
        PaymentInfo _paymentInfo,
        LedgerJournalTable _ledgerJournalTable,
        LedgerJournalTable _rCashJournalTable,
        LedgerJournalTable _custPaymJournalTable,
        Voucher _voucher,
        Voucher _rCashVoucher,
        Voucher _custPaymVoucher,
        boolean _isRCash,
        boolean _isReturnOrder,
        CreditCardOperation _creditCardOperation,
        MCRCustPaymTable _mcrCustPaymTable = null,
        AdvanceInvoiceContract_W _advanceInvoiceContract = null)
    {
        LedgerJournalTrans ledgerJournalTrans;

        // Create a Payment Journal for the payments (if not yet created)
        [
            _ledgerJournalTable,
            _rCashJournalTable,
            _custPaymJournalTable,
            _voucher,
            _rCashVoucher,
            _custPaymVoucher
        ] = RetailTransactionPaymentsHelper::createPaymentJournalHeaderForStore
        (
            _salesTable,
            _custOrderInfo,
            _paymentInfo,
            _isRCash,
            _ledgerJournalTable,
            _rCashJournalTable,
            _custPaymJournalTable,
            _voucher,
            _rCashVoucher,
            _custPaymVoucher,
            _isReturnOrder
        );

        // Log ledger journal creation
        if (_ledgerJournalTable)
        {
            // Log journal header created
            eventSource.EventWritePaymentsLedgerJournalCreated(_ledgerJournalTable.RecId, _paymentInfo.PaymentRefRecId, _salesTable.RecId);

            // Create a payment journal line for each committed-approved (former captured) payments
            [
                _ledgerJournalTable,
                ledgerJournalTrans,
                _rCashJournalTable,
                _custPaymJournalTable,
                _voucher,
                _rCashVoucher,
                _custPaymVoucher
            ] = RetailTransactionPaymentsHelper::createPaymentJournalLineForStore(
                _salesTable,
                _custOrderInfo,
                _paymentInfo,
                _ledgerJournalTable,
                _rCashJournalTable,
                _custPaymJournalTable,
                _voucher,
                _rCashVoucher,
                _custPaymVoucher,
                _isRCash,
                _isReturnOrder,
                _mcrCustPaymTable,
                _advanceInvoiceContract);

            // Save Retail Info codes for the payment
            if (ledgerJournalTrans)
            {
                // Log journal line creation success
                eventSource.EventWritePaymentsLedgerJournalLineCreated_V2(_ledgerJournalTable.RecId, _paymentInfo.PaymentRefRecId, _salesTable.RecId, RetailTransactionPaymentsHelper::prepareJsonForLedgerJournalTransactionData(ledgerJournalTrans));

                // Create reason code lines
                RetailTransactionPaymentsHelper::createOrUpdateReasonCodeLines(_salesTable.RecId, ledgerJournalTrans.RecId, ReflectionHelper::getObjectProperty(_paymentInfo, 'ReasonCodeLines'), RetailInfoCodeLineRelatedTableType::Sales);
            }
            else
            {
                // Log Journal line creation failure.
                eventSource.EventWritePaymentsLedgerJournalCreatedFailed(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
            }

            // If feature flag is turned on, associate mcrcustpaymtable.
            if (RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName())
                && _mcrCustPaymTable)
            {
                int paymentOperationId = RetailStoreTenderTypeTable::find(_channelRecId, _mcrCustPaymTable.TenderTypeId).posOperation;
                RetailTransactionPaymentsHelper::setPaymReference(paymentOperationId, _mcrCustPaymTable, _paymentInfo);

                eventSource.EventWritePaymentsLinkedPaymentReferencesForCommerceEnabledOrder(_salesTable.RecId, _mcrCustPaymTable.RecId, _channelRecId, paymentOperationId);
            }

            // Record the credit card CAPTURE transaction details in CreditCardAuthTrans if payment Info contains Card Authorization XML.
            RetailTransactionPaymentsHelper::recordCreditCardAuthorizationCapture(_salesTable, _paymentInfo, _mcrCustPaymTable, _creditCardOperation, ledgerJournalTrans);

            eventSource.EventWritePaymentsAddedNewPaymentCaptureForCommerceEnabledOrder(
                    _salesTable.RecId,
                    _mcrCustPaymTable.RecId);
        }
        else
        {
            eventSource.EventWritePaymentsLedgerJournalCreatedFailed(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
        }

        return [
                    _ledgerJournalTable,
                    LedgerJournalTrans,
                    _rCashJournalTable,
                    _custPaymJournalTable,
                    _voucher,
                    _rCashVoucher,
                    _custPaymVoucher
               ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordExistingSalesOrderPaymentVoid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Records a void of an existing CreditCardAuthTrans authorization record.
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c> buffer.</param>
    /// <param name = "_originalAuthTrans">The original CreditCArdAuthTrans to be expired.</param>
    /// <param name = "_paymentInfo">The payment Info instance with details of the new authorization.</param>
    /// <param name = "_succeeded">Record authorization as succeeded? (Y/N).</param>
    /// <param name = "_mcrCustPaymTable">The <c>MCRCustPaymTable</c> buffer. Default is null.</param>
    /// <param name = "_existingDeclinedPayments">A container of declined payments for this sales order. Optional.</param>
    /// <param name = "_newPayments">A container with new payments added to this sales order.</param>
    /// <returns>A collection of declined and new payments.</returns>
    private static container recordExistingSalesOrderPaymentVoid(
        SalesTable _salesTable,
        CreditCardAuthTrans _originalAuthTrans,
        PaymentInfo _paymentInfo,
        boolean _succeeded,
        McrCustPaymTable _mcrCustPaymTable = null,
        container _existingDeclinedPayments = conNull(),
        container _newPayments = conNull())
    {
        // Find new authorization UniqueCardId
        CreditCardPaymentProperties newProperties = CreditCardPaymentProperties::fromXmlString(_paymentInfo.CreditCardToken);
        str newUniqueCardId = newProperties.find(
                        Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_PaymentCard(),
                        Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.PaymentCardProperties::get_UniqueCardId()).parmStringValue();

        // If void details are the same as the original authorization (same UniqueCardId),
        // record the VOID.
        if (_originalAuthTrans.UniqueCardId == newUniqueCardId ||
            _originalAuthTrans.CurrencyCode == _paymentInfo.Currency ||
            _originalAuthTrans.ApprovalAmountCur == _paymentInfo.AuthorizedAmount)
        {
            // IF payment Info contains Card Authorization XML, Record new VOID and update call center payment.
            if (_paymentInfo.CreditCardAuthorization)
            {
                RetailMCRChannelTable callCenterUsedForOrderCreation = RetailMCRChannelTable::findChannelBySalesTable(_salesTable);
                boolean isCommercePaymentsOrder = RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName());

                if (callCenterUsedForOrderCreation && _salesTable.mcrIsCallCenter() && callCenterUsedForOrderCreation.MCREnableOrderCompletion)
                {
                    // update mcr payment for Call center orders
                    RetailTransactionPaymentsHelper::updateCallCenterPaymentVoid(
                        _salesTable,
                        _originalAuthTrans,
                         _paymentInfo,
                        _succeeded,
                        _mcrCustPaymTable);
                }
                else if(isCommercePaymentsOrder)
                {
                    // update mcr payment for Commerce payment orders
                    RetailTransactionPaymentsHelper::updateCallCenterPaymentVoid_ForCommercePaymentOrders(
                        _salesTable,
                        _originalAuthTrans,
                         _paymentInfo,
                        _succeeded,
                        _mcrCustPaymTable);
                }
                else
                {
                    ttsbegin;
                    // Retail orders: Record the credit card VOID transaction details in CreditCardAuthTrans
                    CreditCardPaymentProperties properties = CreditCardPaymentProperties::fromXmlString(_paymentInfo.CreditCardAuthorization);
                    CreditCard::recordVoid(CreditCardProviderVoidResult::constructFromXmlString(_paymentInfo.CreditCardAuthorization),
                                                _salesTable,
                                                CreditCard::FindBestMatchCreditCardProcessorId(properties),
                                                _succeeded,
                                                strFmt("@SYS327114", _salesTable.SalesId),
                                                _paymentInfo.CreditCardToken,
                                                false);
                    ttscommit;
                }
            }

        }

        return [_existingDeclinedPayments, _newPayments];

    }

]]></Source>
			</Method>
			<Method>
				<Name>processNewCallCenterPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process Call center order payments created on the channel.
    /// </summary>
    /// <param name = "_channelRecId">The channel RecId.</param>
    /// <param name = "_salesTable">The <c>SalesTable</c> buffer.</param>
    /// <param name = "_custOrderInfo">The customerOrderInfo instance.</param>
    /// <param name = "_paymentInfo">The payment info intance from the payment info collection to be processed.</param>
    /// <param name = "_ledgerJournalTable">The <c>LedgerJournalTable</c> buffer.</param>
    /// <param name = "_rCashJournalTable">The <c>LedgerJournalTable</c> buffer for RCash.</param>
    /// <param name = "_custPaymJournalTable">The <c>LedgerJournalTable</c> buffer for customer payments.</param>
    /// <param name = "_voucher">The voucher number.</param>
    /// <param name = "_rCashVoucher">The Cash voucher number.</param>
    /// <param name = "_custPaymVoucher">The customer payment voucher number.</param>
    /// <param name = "_isRCash">Is this a RCash payment journal? (Y/N).</param>
    /// <param name = "_isReturnOrder">is this a return order? (Y/N).</param>
    /// <param name = "_existingDeclinedPayments">The declined payments list.</param>
    /// <param name = "_newPayments">The new payments list.</param>
    /// <param name = "_advanceInvoiceContract">The Advance Invoice contract.</param>
    /// <returns>a container with ledgerJournalTable, LedgerJournalTrans, voucher, rCashVoucher, custPaymVoucher, declinedPaymentsContainer, newPaymentsContainer.</returns>
    internal static container processNewCallCenterPayment(
        RefRecId _channelRecId,
        SalesTable _salesTable,
        CustomerOrderInfo _custOrderInfo,
        PaymentInfo _paymentInfo,
        LedgerJournalTable _ledgerJournalTable,
        LedgerJournalTable _rCashJournalTable,
        LedgerJournalTable _custPaymJournalTable,
        Voucher _voucher,
        Voucher _rCashVoucher,
        Voucher _custPaymVoucher,
        boolean _isRCash,
        boolean _isReturnOrder,
        container _existingDeclinedPayments,
        container _newPayments,
        AdvanceInvoiceContract_W _advanceInvoiceContract = null)
    {
        LedgerJournalTrans ledgerJournalTrans;
        MCRCustPaymTable newCallCenterPayment;

        switch (_paymentInfo.PaymentStatusValue)
        {
            case RetailTenderLineStatus::PendingCommit:
                switch (_paymentInfo.CreditCardProcessorStatusValue)
                {
                    // Received a new authorization from the channel with undefined processor status (Backward compatible)
                    case CreditCardProcessorStatus::NA:

                        // Invalid payment type: Log payment details
                        eventSource.EventWritePaymentsCallCenterPaymentPendingCommitNANotSupported(0, _salesTable.RecId);
                        break;

                    // Received a new authorization with processor status successful from channel
                    case CreditCardProcessorStatus::Approved:

                        // Log payment details
                        eventSource.EventWritePaymentsPendingCommitPaymentAuthorizationUnsupported(0, _salesTable.RecId);
                        break;

                    // Received a new authorization with Processor status failure from channel
                    // Note: This is a capture declined
                    case CreditCardProcessorStatus::Declined:
                    case CreditCardProcessorStatus::Error:

                        // Log payment details
                        eventSource.EventWritePaymentsCallCenterPaymentPendingCommitApprovedNotSupported(0, _salesTable.RecId);
                        break;

                    default:

                        // Skip invalid payments and log payment details
                        eventSource.EventWritePaymentsCallCenterPaymentPendingCommitErrorNotSupported(0, _salesTable.RecId);
                        break;
                }

                break;

            case RetailTenderLineStatus::Committed:

                switch (_paymentInfo.CreditCardProcessorStatusValue)
                {
                    // Received a new captured payment with a non credit card payment type
                    case CreditCardProcessorStatus::NA:
                    // Received a new captured payment with successful processor status from channel
                    case CreditCardProcessorStatus::Approved:

                        // Create Call center payment for new captured amount
                        [
                            newCallCenterPayment,
                            _existingDeclinedPayments,
                            _newPayments
                        ]
                        = RetailTransactionPaymentsHelper::createCallCenterPayment(
                            _salesTable,
                            _paymentInfo,
                            _isReturnOrder,
                            MCRCustPaymStatus::Paid,
                            _existingDeclinedPayments,
                            _newPayments);

                        // Create Sales Order payment History (Payment Journal)
                        [
                            _ledgerJournalTable,
                            ledgerJournalTrans,
                            _rCashJournalTable,
                            _custPaymJournalTable,
                            _voucher,
                            _rCashVoucher,
                            _custPaymVoucher
                        ] /* Authorize and Capture: CreditCardOperation 1 */
                        = RetailTransactionPaymentsHelper::recordNewSalesOrderPaymentCapture(
                            _channelRecId,
                            _salesTable,
                            _custOrderInfo,
                            _paymentInfo,
                            _ledgerJournalTable,
                            _rCashJournalTable,
                            _custPaymJournalTable,
                            _voucher,
                            _rCashVoucher,
                            _custPaymVoucher,
                            _isRCash,
                            _isReturnOrder,
                            CreditCardOperation::AuthorizeAndCapture,
                            newCallCenterPayment,
                            _advanceInvoiceContract);

                        // Log payment details
                        eventSource.EventWritePaymentsCallCenterPaymentCommittedApprovedSuccessfully(0, _salesTable.RecId);
                        break;

                    // record Capture failure
                    case CreditCardProcessorStatus::Declined:
                    case CreditCardProcessorStatus::Error:

                        // Skip new declined capture and log payment details
                        eventSource.EventWritePaymentsCallCenterPaymentCommittedErrorNotSupported(0, _salesTable.RecId);
                        break;

                    // Invalid status should skip payment
                    default:

                        // Skip invalid payment and log error
                        eventSource.EventWritePaymentsCallCenterPaymentCommittedUnsupportedStatus(0, _salesTable.RecId);
                        break;
                }

                break;

            case RetailTenderLineStatus::Voided:

                // New Voided authorizations should be ignored
                // Log payment details
                eventSource.EventWritePaymentsCallCenterPaymentVoidedUnsupported(0, _salesTable.RecId);
                break;

            // all other status should skip payment
            case RetailTenderLineStatus::Historical:
            case RetailTenderLineStatus::None:
            case RetailTenderLineStatus::NotProcessed:
            default:

                // If the payment is legacy, we allow attaching of card token to the sales order header
                if (_salesTable.retailSalesTable().PaymentsType == RetailPaymentsType::Legacy)
                {
                    // If a new credit card token is passed, add it to the customer
                    if (_paymentInfo.CreditCardToken)
                    {
                        // Log payment details
                        eventSource.EventWritePaymentsCallCenterPaymentNotProcessedUnsupported(0, _salesTable.RecId);

                        // Add the credit card token to the customer
                        CreditCardCust creditCardCust = RetailTransactionPaymentsHelper::createCreditCardForCustomer(_salesTable.InvoiceAccount, _salesTable, _paymentInfo.CreditCardToken);

                        // Replace original Credit card from the Order with the newly created credit card token
                        RetailTransactionPaymentsHelper::attachCreditCardTokenToSalesOrder(
                        _channelRecId,
                        _salesTable,
                        creditCardCust,
                        _paymentInfo);
                    }
                }

                break;

        }

        return  [
                    _ledgerJournalTable,
                    ledgerJournalTrans,
                    _rCashJournalTable,
                    _custPaymJournalTable,
                    _voucher,
                    _rCashVoucher,
                    _custPaymVoucher,
                    _existingDeclinedPayments,
                    _newPayments
                ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>processNewRetailPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process retail order payments created on the channel.
    /// </summary>
    /// <param name = "_channelRecId">The channel RecId.</param>
    /// <param name = "_salesTable">The <c>SalesTable</c> buffer.</param>
    /// <param name = "_custOrderInfo">The customerOrderInfo instance.</param>
    /// <param name = "_paymentInfo">The payment info intance from the payment info collection to be processed.</param>
    /// <param name = "_ledgerJournalTable">The <c>LedgerJournalTable</c> buffer.</param>
    /// <param name = "_rCashJournalTable">The <c>LedgerJournalTable</c> buffer for RCash.</param>
    /// <param name = "_custPaymJournalTable">The <c>LedgerJournalTable</c> buffer for CUstomer payment.</param>
    /// <param name = "_voucher">The voucher number.</param>
    /// <param name = "_rCashVoucher">The Cash voucher number.</param>
    /// <param name = "_custPaymVoucher">The customer payment voucher number.</param>
    /// <param name = "_isRCash">Is this a RCash payment journal? (Y/N).</param>
    /// <param name = "_isReturnOrder">is this a return order? (Y/N).</param>
    /// <param name = "_existingDeclinedPayments">The declined payments list.</param>
    /// <param name = "_newPayments">The new payments list.</param>
    /// <param name = "_advanceInvoiceContract">The Advance Invoice contract.</param>
    /// <returns>a container with ledgerJournalTable, LedgerJournalTrans, voucher, rCashVoucher, custPaymVoucher, existingDeclinedPaymentsContainer, newPaymentsContainer.</returns>
    internal static container processNewRetailPayment(
        RefRecId _channelRecId,
        SalesTable _salesTable,
        CustomerOrderInfo _custOrderInfo,
        PaymentInfo _paymentInfo,
        LedgerJournalTable _ledgerJournalTable,
        LedgerJournalTable _rCashJournalTable,
        LedgerJournalTable _custPaymJournalTable,
        Voucher _voucher,
        Voucher _rCashVoucher,
        Voucher _custPaymVoucher,
        boolean _isRCash,
        boolean _isReturnOrder,
        container  _existingDeclinedPayments,
        container _newPayments,
        AdvanceInvoiceContract_W _advanceInvoiceContract = null)
    {
        LedgerJournalTrans ledgerJournalTrans;
        MCRCustPaymTable   mcrCustPaymTable;

        switch (_paymentInfo.PaymentStatusValue)
        {
            case RetailTenderLineStatus::PendingCommit:
                switch (_paymentInfo.CreditCardProcessorStatusValue)
                {
                    // record Auth success for Pending Commit payments with Credit Card Processor status NA
                    case CreditCardProcessorStatus::NA:
                    // record Auth success for Pending Commit payments with Credit Card Processor status APPROVED
                    case CreditCardProcessorStatus::Approved:

                        // If feature flag is turned on, we will create mcrcustpaymtable.
                        if (RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName()))
                        {
                            // Create MCR CustPaymTable corresponding to the authorization
                            [
                             mcrCustPaymTable,
                             _existingDeclinedPayments,
                             _newPayments
                            ]
                                = RetailTransactionPaymentsHelper::createCallCenterPayment(
                                _salesTable,
                                _paymentInfo,
                                _isReturnOrder,
                                 MCRCustPaymStatus::Authorized,
                                 _existingDeclinedPayments,
                                 _newPayments);
                        }

                        // Create Sales Order credit card authorization and credit card token (Without voiding original auths, as they are individually managed)
                        RetailTransactionPaymentsHelper::recordNewSalesOrderPaymentAuthorization(_channelRecId, _salesTable, _paymentInfo, false, mcrCustPaymTable);
                        // Log payment details
                        eventSource.EventWritePaymentsRetailPaymentPendingCommitApprovedSuccessfully(_paymentInfo.CreditCardAuthorization ? CreditCardAuthTrans::findLatest(_salesTable.SalesId).RecId : 0, _salesTable.RecId);
                        break;

                    // received a payment that was created in the Channel and failed to capture (no action)
                    case CreditCardProcessorStatus::Declined:
                    case CreditCardProcessorStatus::Error:
                    default:

                        // Skip invalid payments and log payment details
                        eventSource.EventWritePaymentsRetailPaymentCommitErrorNotSupported(_paymentInfo.CreditCardAuthorization ? CreditCardAuthTrans::findLatest(_salesTable.SalesId).RecId : 0, _salesTable.RecId);
                        break;
                }
                break;

            case RetailTenderLineStatus::Committed:
                switch (_paymentInfo.CreditCardProcessorStatusValue)
                {
                    // record Capture success
                    case CreditCardProcessorStatus::NA:
                    case CreditCardProcessorStatus::Approved:

                        // If feature flag is turned on, we will create mcrcustpaymtable.
                        if (RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName()))
                        {
                            // Create MCR CustPaymTable corresponding to the capture
                            [
                             mcrCustPaymTable,
                             _existingDeclinedPayments,
                             _newPayments
                            ]
                                = RetailTransactionPaymentsHelper::createCallCenterPayment(
                                _salesTable,
                                _paymentInfo,
                                _isReturnOrder,
                                 MCRCustPaymStatus::Paid,
                                 _existingDeclinedPayments,
                                 _newPayments);
                        }

                        // Create Sales Order payment History (Payment Journal)
                        [
                            _ledgerJournalTable,
                            ledgerJournalTrans,
                            _rCashJournalTable,
                            _custPaymJournalTable,
                            _voucher,
                            _rCashVoucher,
                            _custPaymVoucher
                        ]
                        = RetailTransactionPaymentsHelper::recordNewSalesOrderPaymentCapture(
                            _channelRecId,
                            _salesTable,
                            _custOrderInfo,
                            _paymentInfo,
                            _ledgerJournalTable,
                            _rCashJournalTable,
                            _custPaymJournalTable,
                            _voucher,
                            _rCashVoucher,
                            _custPaymVoucher,
                            _isRCash,
                            _isReturnOrder,
                            CreditCardOperation::AuthorizeAndCapture,
                            mcrCustPaymTable,
                            _advanceInvoiceContract);

                        // Log payment details
                        eventSource.EventWritePaymentsRetailPaymentCommittedApprovedSuccessfully(_paymentInfo.CreditCardAuthorization ? CreditCardAuthTrans::findLatest(_salesTable.SalesId).RecId : 0, _salesTable.RecId);
                        break;

                    // log (re)Capture failure
                    case CreditCardProcessorStatus::Declined:
                    case CreditCardProcessorStatus::Error:

                        // Log payment details
                        eventSource.EventWritePaymentsRetailPaymentCommittedErrorCapturedAlready(_paymentInfo.CreditCardAuthorization ? CreditCardAuthTrans::findLatest(_salesTable.SalesId).RecId : 0, _salesTable.RecId);
                        break;

                    default:
                        // Skip invalid payment and log error
                        eventSource.EventWritePaymentsRetailPaymentCommittedUnsupportedStatus(_paymentInfo.CreditCardAuthorization ? CreditCardAuthTrans::findLatest(_salesTable.SalesId).RecId : 0, _salesTable.RecId);
                        break;
                }
                break;

            case RetailTenderLineStatus::Voided:

                // New Voided authorizations should be all ignored
                // Log payment details
                eventSource.EventWritePaymentsRetailPaymentVoidedUnsupported(_paymentInfo.CreditCardAuthorization ? CreditCardAuthTrans::findLatest(_salesTable.SalesId).RecId : 0, _salesTable.RecId);
                break;

            // all other status should skip payment
            case RetailTenderLineStatus::Historical:
            case RetailTenderLineStatus::None:
            case RetailTenderLineStatus::NotProcessed:
            default:

                if (_salesTable.retailSalesTable().PaymentsType == RetailPaymentsType::Legacy)
                {
                    // If a NEW credit card token is passed, add it to the customer. If creditCardAUthorization is available,
                    if (_paymentInfo.CreditCardToken)
                    {
                        // Log payment details
                        eventSource.EventWritePaymentsRetailPaymentNotProcessedUnsupported(_paymentInfo.CreditCardAuthorization ? CreditCardAuthTrans::findLatest(_salesTable.SalesId).RecId : 0, _salesTable.RecId);

                        // Add the credit card token to the customer
                        CreditCardCust creditCardCust = RetailTransactionPaymentsHelper::createCreditCardForCustomer(_salesTable.InvoiceAccount, _salesTable, _paymentInfo.CreditCardToken);

                        // Replace original Credit card from the Order with the newly created credit card token
                        RetailTransactionPaymentsHelper::attachCreditCardTokenToSalesOrder(_channelRecId, _salesTable, creditCardCust, _paymentInfo);
                    }
                }

                break;
        }

        return  [
                    _ledgerJournalTable,
                    ledgerJournalTrans,
                    _rCashJournalTable,
                    _custPaymJournalTable,
                    _voucher,
                    _rCashVoucher,
                    _custPaymVoucher,
                    _existingDeclinedPayments,
                    _newPayments
                ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>processExistingCallCenterPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process Call center order payments modified on the channel.
    /// </summary>
    /// <param name = "_channelRecId">The channel RecId.</param>
    /// <param name = "_salesTable">The <c>SalesTable</c> buffer.</param>
    /// <param name = "_custOrderInfo">The customerOrderInfo instance.</param>
    /// <param name = "_paymentInfo">The payment info intance from the payment info collection to be processed.</param>
    /// <param name = "_ledgerJournalTable">The <c>LedgerJournalTable</c> buffer.</param>
    /// <param name = "_rCashJournalTable">The <c>LedgerJournalTable</c> buffer for RCash.</param>
    /// <param name = "_custPaymJournalTable">The <c>LedgerJournalTable</c> buffer for customer payment.</param>
    /// <param name = "_voucher">The voucher number.</param>
    /// <param name = "_rCashVoucher">The Cash voucher number.</param>
    /// <param name = "_custPaymVoucher">The customer payment voucher number.</param>
    /// <param name = "_isRCash">Is this a RCash payment journal? (Y/N).</param>
    /// <param name = "_isReturnOrder">is this a return order? (Y/N).</param>
    /// <param name = "_existingDeclinedPayments">The declined payments liste.</param>
    /// <param name = "_newPayments">The New payments liste.</param>
    /// <param name = "_advanceInvoiceContract">The Advance Invoice contract.</param>
    /// <returns>a container with ledgerJournalTable, LedgerJournalTrans, voucher, rCashVoucher, custPaymVoucher.</returns>
    internal static container processExistingCallCenterPayment(
        RefRecId _channelRecId,
        SalesTable _salesTable,
        CustomerOrderInfo _custOrderInfo,
        PaymentInfo _paymentInfo,
        LedgerJournalTable _ledgerJournalTable,
        LedgerJournalTable _rCashJournalTable,
        LedgerJournalTable _custPaymJournalTable,
        Voucher _voucher,
        Voucher _rCashVoucher,
        Voucher _custPaymVoucher,
        boolean _isRCash,
        boolean _isReturnOrder,
        container  _existingDeclinedPayments,
        container _newPayments,
        AdvanceInvoiceContract_W _advanceInvoiceContract = null)
    {
        LedgerJournalTrans  ledgerJournalTrans;
        CreditCardAuthTrans creditCardAuthTrans;
        MCRCustPaymTable    mcrCustPaymTable;

        // Search for original payment (mcrCustPaymTable)  and original authorization (CreditCArdAuthTrans)
        mcrCustPaymTable = MCRCustPaymTable::findByRecID(_paymentInfo.PaymentRefRecId, true);
        select firstonly forupdate creditCardAuthTrans
                            order by creditCardAuthTrans.ApprovedDateTime desc
                            where creditCardAuthTrans.MCRPaymRecId == mcrCustPaymTable.RecId &&
                                creditCardAuthTrans.SalesId == _salesTable.SalesId &&
                                creditCardAuthTrans.ApprovalType == CreditCardOperation::Authorize &&
                                creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved &&
                                creditCardAuthTrans.ApprovalVoid == NoYes::No &&
                                creditCardAuthTrans.ApprovalExpired == NoYes::No;

        switch (_paymentInfo.PaymentStatusValue)
        {
            case RetailTenderLineStatus::PendingCommit:

                switch (_paymentInfo.CreditCardProcessorStatusValue)
                {
                    // Received an existing authorization back from channel with Processor status undefined (Backward compatibility)
                    case CreditCardProcessorStatus::NA:
                    // Received an existing authorization back from channel with Processor status successful (Backward compatibility)
                    case CreditCardProcessorStatus::Approved:

                        // If Authorization returning from channel is different from the original one:
                        // - Find original CreditCardAuthTrans and record as EXPIRED
                        // - Create new CreditCardAuthTrans and record as APPROVED
                        RetailTransactionPaymentsHelper::recordExistingSalesOrderPaymentAuthorization(
                            _channelRecId,
                            _salesTable,
                            creditCardAuthTrans,
                            _paymentInfo,
                            true,
                            _existingDeclinedPayments,
                            _newPayments,
                            mcrCustPaymTable);

                        // Log payment details
                        eventSource.EventWritePaymentsPendingCommitPaymentAuthorizationSuccess(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
                        break;

                    // Received an existing authorization back from channel with Capture Failure
                    case CreditCardProcessorStatus::Declined:
                    case CreditCardProcessorStatus::Error:

                        [_existingDeclinedPayments] =
                                    RetailTransactionPaymentsHelper::processExistingCallCenterPaymentAuthorizationDecline(_salesTable, creditCardAuthTrans, _paymentInfo, _existingDeclinedPayments, mcrCustPaymtable);

                        // Log payment details
                        eventSource.EventWritePaymentsPendingCommitPaymentAuthorizationFailed(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
                        break;

                    // Invalid status should skip payment
                    default:

                        // Skip invalid payments and log payment details
                        eventSource.EventWritePaymentsPendingCommitPaymentAuthorizationUnsupported(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
                        break;
                }

                break;

            // record CAPTURE
            case RetailTenderLineStatus::Committed:

                switch (_paymentInfo.CreditCardProcessorStatusValue)
                {
                    // record Capture Not Applicable - All non credit card payments
                    case CreditCardProcessorStatus::NA:
                    // record Capture success
                    case CreditCardProcessorStatus::Approved:

                        // Create Sales Order payment History (Payment Journal)
                        // record CAPTURE APPROVAL and settle against original Authorization
                        [
                                _ledgerJournalTable,
                                ledgerJournalTrans,
                                _rCashJournalTable,
                                _custPaymJournalTable,
                                _voucher,
                                _rCashVoucher,
                                _custPaymVoucher
                        ]
                        = RetailTransactionPaymentsHelper::recordNewSalesOrderPaymentCapture(
                            _channelRecId,
                            _salesTable,
                            _custOrderInfo,
                            _paymentInfo,
                            _ledgerJournalTable,
                            _rCashJournalTable,
                            _custPaymJournalTable,
                            _voucher,
                            _rCashVoucher,
                            _custPaymVoucher,
                            _isRCash,
                            _isReturnOrder,
                            CreditCardOperation::CaptureAfterAuthorize,
                            mcrCustPaymTable,
                            _advanceInvoiceContract);

                        // Update Call center payment
                        RetailTransactionPaymentsHelper::updateCallCenterPaymentCapture(
                            _salesTable,
                            creditCardAuthTrans,
                            _paymentInfo,
                            true,
                            mcrCustPaymTable);

                        // Log payment details
                        eventSource.EventWritePaymentsCommittedPaymentCaptureSuccess(_paymentInfo.PaymentRefRecId, _salesTable.RecId);

                        break;

                    // record Capture failure
                    case CreditCardProcessorStatus::Declined:
                    case CreditCardProcessorStatus::Error:

                        // Log payment details
                        eventSource.EventWritePaymentsCommittedPaymentCaptureFailed(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
                        break;

                    // Invalid status should skip payment
                    default:
                        // Skip invalid payment and log error
                        eventSource.EventWritePaymentsCommittedPaymentCaptureUnsupported(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
                        break;
                }

                break;

            // record VOID
            case RetailTenderLineStatus::Voided:
                switch (_paymentInfo.CreditCardProcessorStatusValue)
                {
                    // record Void success
                    case CreditCardProcessorStatus::NA:
                    case CreditCardProcessorStatus::Approved:

                        // record VOID APPROVAL and add card token if unique card id or authorized amount is the same.
                        [
                            _existingDeclinedPayments,
                            _newPayments
                        ]
                        = RetailTransactionPaymentsHelper::recordExistingSalesOrderPaymentVoid(
                            _salesTable,
                            creditCardAuthTrans,
                            _paymentInfo,
                            true,
                            mcrCustPaymTable,
                            _existingDeclinedPayments,
                            _newPayments);

                        // Log payment details
                        eventSource.EventWritePaymentsVoidedPaymentSuccessful(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
                        break;

                    // record Void failure
                    case CreditCardProcessorStatus::Declined:
                    case CreditCardProcessorStatus::Error:

                        // record the original VOID DECLINED and add card token if unique card id or authorized amount is the same.
                        // Authorize any remaining balance
                        [
                            _existingDeclinedPayments,
                            _newPayments
                        ]
                        = RetailTransactionPaymentsHelper::recordExistingSalesOrderPaymentVoid(
                            _salesTable,
                            creditCardAuthTrans,
                            _paymentInfo,
                            false,
                            mcrCustPaymTable,
                            _existingDeclinedPayments,
                            _newPayments);

                        // Log payment details
                        eventSource.EventWritePaymentsPaymentVoidedErrorSuccessful(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
                        break;

                    // Invalid status should skip payment
                    default:

                        // Skip invalid payment
                        eventSource.EventWritePaymentsPaymentVoidedUnsupportedOperation(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
                        break;
                }

                break;

            // all other status should skip payment
            case RetailTenderLineStatus::Historical:
            case RetailTenderLineStatus::None:
            case RetailTenderLineStatus::NotProcessed:
            default:

                // Log unsupported operation
                eventSource.EventWritePaymentsNotProcessedNonePaymentOperation(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
                break;
        }

        return  [
                    _ledgerJournalTable,
                    ledgerJournalTrans,
                    _rCashJournalTable,
                    _custPaymJournalTable,
                    _voucher,
                    _rCashVoucher,
                    _custPaymVoucher,
                    _existingDeclinedPayments,
                    _newPayments
                ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>processExistingRetailPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process Call center order payments modified on the channel.
    /// </summary>
    /// <param name = "_channelRecId">The channel RecId.</param>
    /// <param name = "_salesTable">The <c>SalesTable</c> buffer.</param>
    /// <param name = "_custOrderInfo">The customerOrderInfo instance.</param>
    /// <param name = "_paymentInfo">The payment info intance from the payment info collection to be processed.</param>
    /// <param name = "_ledgerJournalTable">The <c>LedgerJournalTable</c> buffer.</param>
    /// <param name = "_rCashJournalTable">The <c>LedgerJournalTable</c> buffer for RCash.</param>
    /// <param name = "_custPaymJournalTable">The <c>LedgerJournalTable</c> buffer for customer payment.</param>
    /// <param name = "_voucher">The voucher number.</param>
    /// <param name = "_rCashVoucher">The Cash voucher number.</param>
    /// <param name = "_custPaymVoucher">The customer payment voucher number.</param>
    /// <param name = "_isRCash">Is this a RCash payment journal? (Y/N).</param>
    /// <param name = "_isReturnOrder">is this a return order? (Y/N).</param>
    /// <param name = "_existingDeclinedPayments">The declined payments list.</param>
    /// <param name = "_newPayments">The New payments list.</param>
    /// <param name = "_advanceInvoiceContract">The Advance Invoice contract.</param>
    /// <returns>a container with ledgerJournalTable, LedgerJournalTrans, voucher, rCashVoucher, custPaymVoucher.</returns>
    internal static container processExistingRetailPayment(
        RefRecId _channelRecId,
        SalesTable _salesTable,
        CustomerOrderInfo _custOrderInfo,
        PaymentInfo _paymentInfo,
        LedgerJournalTable _ledgerJournalTable,
        LedgerJournalTable _rCashJournalTable,
        LedgerJournalTable _custPaymJournalTable,
        Voucher _voucher,
        Voucher _rCashVoucher,
        Voucher _custPaymVoucher,
        boolean _isRCash,
        boolean _isReturnOrder,
        container  _existingDeclinedPayments = conNull(),
        container _newPayments = conNull(),
        AdvanceInvoiceContract_W _advanceInvoiceContract = null)
    {
        LedgerJournalTrans ledgerJournalTrans;
        CreditCardAuthTrans creditCardAuthTrans;
        MCRCustPaymTable mcrCustPaymtable = null;
        boolean isCommerceEnabledOrder = RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName());

        if  (isCommerceEnabledOrder)
        {
            select firstonly forupdate mcrCustPaymtable
                                where mcrCustPaymtable.RecId == _paymentInfo.PaymentRefRecId;

            // Search for original authorization (CreditCardAuthTrans)
            select firstonly forupdate creditCardAuthTrans
                            order by creditCardAuthTrans.ApprovedDateTime desc
                            where creditCardAuthTrans.MCRPaymRecId == mcrCustPaymTable.RecId &&
                                creditCardAuthTrans.SalesId == _salesTable.SalesId &&
                                creditCardAuthTrans.ApprovalType == CreditCardOperation::Authorize &&
                                creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved &&
                                creditCardAuthTrans.ApprovalVoid == NoYes::No &&
                                creditCardAuthTrans.ApprovalExpired == NoYes::No;

            eventSource.EventWritePaymentsLocatedOriginalPaymentAuthorization(_salesTable.RecId, creditCardAuthTrans.RecId, isCommerceEnabledOrder);
        }
        else
        {
            // Search for original authorization (CreditCardAuthTrans)
            select firstonly forupdate creditCardAuthTrans
                where creditCardAuthTrans.Recid == _paymentInfo.PaymentRefRecId;

            eventSource.EventWritePaymentsUnableToLocatedOriginalPaymentAuthorization(_salesTable.RecId, creditCardAuthTrans.RecId, isCommerceEnabledOrder);
        }

        if (creditCardAuthTrans)
        {
            switch (_paymentInfo.PaymentStatusValue)
            {
                case RetailTenderLineStatus::PendingCommit:
                    switch (_paymentInfo.CreditCardProcessorStatusValue)
                    {
                        // received existing Authorization back with undefined Processor Status
                        case CreditCardProcessorStatus::NA:
                        // Received the existing authorization back from Channel without using it.
                        case CreditCardProcessorStatus::Approved:

                            // If Authorization returning from channel is different from the original one:
                            //      - Expire original CreditCardAuthTrans
                            //      - Create new CreditCardAuthTrans and record as Approved
                            RetailTransactionPaymentsHelper::recordExistingSalesOrderPaymentAuthorization(
                                    _channelRecId,
                                    _salesTable,
                                    creditCardAuthTrans,
                                    _paymentInfo,
                                    true,
                                    _existingDeclinedPayments,
                                    _newPayments,
                                    mcrCustPaymtable);

                            // Log payment details
                            eventSource.EventWritePaymentsPendingCommitPaymentAuthorizationSuccess(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
                            break;

                        // record Auth failure
                        // When an authorized payment is sent to Channel and fails to capture, it returns PendingCommit Declined.
                        case CreditCardProcessorStatus::Declined:
                        case CreditCardProcessorStatus::Error:

                            if (RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName()))
                            {
                                [_existingDeclinedPayments] =
                                    RetailTransactionPaymentsHelper::processExistingCallCenterPaymentAuthorizationDecline(_salesTable, creditCardAuthTrans, _paymentInfo, _existingDeclinedPayments, mcrCustPaymtable);
                            }
                            else
                            {
                                if (_paymentInfo.CreditCardAuthorization)
                                {
                                    // Expire Original Credit Card Authorization
                                    if (!CreditCardAuthTrans::setAuthorizationExpired(creditCardAuthTrans.RecId))
                                    {
                                        eventSource.EventWritePaymentsExpireAuthFailed(creditCardAuthTrans.RecId);
                                    }

                                    // Record the credit card CAPTURE DECLINED transaction details in CreditCardAuthTrans
                                    CreditCardPaymentProperties properties = CreditCardPaymentProperties::fromXmlString(_paymentInfo.CreditCardAuthorization);
                                    CreditCard::recordCapture(
                                            CreditCardProviderAuthorizationResult::constructFromXmlString(_paymentInfo.CreditCardAuthorization),
                                            _salesTable,
                                            '',
                                            CreditCard::FindBestMatchCreditCardProcessorId(properties),
                                            false,
                                            false,
                                            strFmt("@SYS327114", _salesTable.SalesId),
                                            _paymentInfo.CreditCardAuthorization,
                                            false);
                                }
                            }

                            // log payment details
                            eventSource.EventWritePaymentsPendingCommitPaymentAuthorizationFailed(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
                            break;

                        // Invalid status should skip payment
                        default:

                            // Skip invalid payments and log payment details
                            eventSource.EventWritePaymentsPendingCommitPaymentAuthorizationUnsupported(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
                            break;
                    }
                    break;

                case RetailTenderLineStatus::Committed:
                    switch (_paymentInfo.CreditCardProcessorStatusValue)
                    {
                        // Received a capture of an existing authorization with status undefined from channel
                        case CreditCardProcessorStatus::NA:
                        // Received a capture of an existing authorization with status successful from channel
                        case CreditCardProcessorStatus::Approved:

                            // Create Sales Order payment History (Payment Journal)
                            [
                                _ledgerJournalTable,
                                ledgerJournalTrans,
                                _rCashJournalTable,
                                _custPaymJournalTable,
                                _voucher,
                                _rCashVoucher,
                                _custPaymVoucher
                            ]
                            = RetailTransactionPaymentsHelper::recordNewSalesOrderPaymentCapture(
                                _channelRecId,
                                _salesTable,
                                _custOrderInfo,
                                _paymentInfo,
                                _ledgerJournalTable,
                                _rCashJournalTable,
                                _custPaymJournalTable,
                                _voucher,
                                _rCashVoucher,
                                _custPaymVoucher,
                                _isRCash,
                                _isReturnOrder,
                                CreditCardOperation::CaptureAfterAuthorize,
                                mcrCustPaymtable,
                                _advanceInvoiceContract);

                            if (RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName()))
                            {
                                // Update Call center payment
                                RetailTransactionPaymentsHelper::updateCallCenterPaymentCapture(
                                _salesTable,
                                creditCardAuthTrans,
                                _paymentInfo,
                                true,
                                mcrCustPaymTable);
                            }

                            // Log payment details
                            eventSource.EventWritePaymentsCommittedPaymentCaptureSuccess(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
                            break;

                        // Received an existing Captured payment back from channel that failed to (re)capture
                        case CreditCardProcessorStatus::Declined:
                        case CreditCardProcessorStatus::Error:

                            // Log payment details
                            eventSource.EventWritePaymentsCommittedPaymentCaptureFailed(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
                            break;

                        // Invalid status should skip payment
                        default:

                            // Skip invalid payment and log error
                            eventSource.EventWritePaymentsCommittedPaymentCaptureUnsupported(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
                            break;
                    }
                    break;

                case RetailTenderLineStatus::Voided:
                    switch (_paymentInfo.CreditCardProcessorStatusValue)
                    {
                        // Received an existing authorization that was voided in the channel but has the Processor Status undefined
                        case CreditCardProcessorStatus::NA:
                        // Received an existing authorization that was voided in the channel but has the Processor Status Success
                        case CreditCardProcessorStatus::Approved:

                            // record VOID APPROVAL in CrediCardAuthTrans
                            RetailTransactionPaymentsHelper::recordExistingSalesOrderPaymentVoid(
                                    _salesTable,
                                    creditCardAuthTrans,
                                    _paymentInfo,
                                    true,
                                    mcrCustPaymtable,
                                    _existingDeclinedPayments,
                                    _newPayments);

                            // Log payment details
                            eventSource.EventWritePaymentsVoidedPaymentSuccessful(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
                            break;

                        // Received an existing authorization that failed to void in the channel
                        case CreditCardProcessorStatus::Declined:
                        case CreditCardProcessorStatus::Error:

                            // record VOID DECLINED in creditCardAuthTrans
                            RetailTransactionPaymentsHelper::recordExistingSalesOrderPaymentVoid(
                                    _salesTable,
                                    creditCardAuthTrans,
                                    _paymentInfo,
                                    false,
                                    mcrCustPaymtable,
                                    _existingDeclinedPayments,
                                    _newPayments);

                            if (!RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName()))
                            {
                                // For Non-Commerce Payments Orders
                                // Call processor and try to void the authorization again
                                // as voiding of the authorization has already been re-tried.
                                try
                                {
                                    CreditCardProcess::doVoidAuth(creditCardAuthTrans);

                                    // Log payment void success
                                    eventSource.EventWritePaymentsPaymentVoidedErrorSuccessful(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
                                }
                                catch
                                {
                                    // Log payment void failure
                                    eventSource.EventWritePaymentsExistingAuthVoidFailed(_paymentInfo.PaymentRefRecId);
                                }
                            }

                            break;

                        // Invalid status should skip payment
                        default:

                            // Skip invalid payment
                            // Log payment details
                            eventSource.EventWritePaymentsPaymentVoidedUnsupportedOperation(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
                            break;
                    }
                    break;

                // all other status should skip payment
                case RetailTenderLineStatus::Historical:
                case RetailTenderLineStatus::None:
                case RetailTenderLineStatus::NotProcessed:
                default:

                    // Skip payment
                    // Log payment details
                    eventSource.EventWritePaymentsNotProcessedNonePaymentOperation(_paymentInfo.PaymentRefRecId, _salesTable.RecId);
                    break;
            }
        }
        else
        {
            // Log original authorization not found
            eventSource.EventWritePaymentsOriginalAuthNotFound(_paymentInfo.PaymentRefRecId, _salesTable.RecId);

            // When original authorization is not found, process the payment as a new payment...
            [
                _ledgerJournalTable,
                ledgerJournalTrans,
                _rCashJournalTable,
                _custPaymJournalTable,
                _voucher,
                _rCashVoucher,
                _custPaymVoucher,
                _existingDeclinedPayments,
                _newPayments
            ]
            = RetailTransactionPaymentsHelper::processNewRetailPayment(
                _channelrecId,
                _salesTable,
                _custOrderInfo,
                _paymentInfo,
                _ledgerJournalTable,
                _rCashJournalTable,
                _custPaymJournalTable,
                _voucher,
                _rCashVoucher,
                _custPaymVoucher,
                _isRCash,
                _isReturnOrder,
                _existingDeclinedPayments,
                _newPayments,
                _advanceInvoiceContract);
        }

        return  [
                    _ledgerJournalTable,
                    ledgerJournalTrans,
                    _rCashJournalTable,
                    _custPaymJournalTable,
                    _voucher,
                    _rCashVoucher,
                    _custPaymVoucher,
                    _existingDeclinedPayments,
                    _newPayments
                ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPaymentJournalHeaderForStore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a Payment journal to store all payments for the customer order checkout operation (Create/Edit/Settle/Return).
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c> buffer.</param>
    /// <param name = "_custOrderInfo">The customerOrderInfo instance.</param>
    /// <param name = "_paymentInfo">The paymentInfo instance.</param>
    /// <param name = "_isRCash">Is this a RCash payment Journal? (Y/N).</param>
    /// <param name = "_ledgerJournalTable">The current paymwent journal.</param>
    /// <param name = "_rCashJournalTable">The RCash payment journal.</param>
    /// <param name = "_custPaymJournalTable">The customer payment journal.</param>
    /// <param name = "_voucher">The current voucher number.</param>
    /// <param name = "_rCashVoucher">The RCash voucher.</param>
    /// <param name = "_custPaymVoucher">The customer payment journal.</param>
    /// <param name = "_isReturnOrder">is this a return order? (Y/N).</param>
    /// <returns>A container with the <c>LedgerJournalTable</c> buffer, the voucher number and country specific headers .</returns>
    private static container createPaymentJournalHeaderForStore(
        SalesTable _salesTable,
        CustomerOrderInfo _custOrderInfo,
        PaymentInfo _paymentInfo,
        boolean _isRCash,
        LedgerJournalTable _ledgerJournalTable,
        LedgerJournalTable _rCashJournalTable,
        LedgerJournalTable _custPaymJournalTable,
        Voucher _voucher,
        Voucher _rCashVoucher,
        Voucher _custPaymVoucher,
        boolean _isReturnOrder)
    {
        RefRecId channelRecId = str2Int64(_custOrderInfo.ChannelRecordId);
        boolean  countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);
        if (countryRegion_W)
        {
            boolean isRCash = RetailStoreTenderTypeTable::find(RetailStoreTable::find(_custOrderInfo.StoreId).RecId, _paymentInfo.PaymentType).accountType == RetailLedgerBank::RCash;
            _ledgerJournalTable = _isRCash ? _rCashJournalTable : _custPaymJournalTable;

            if (!_ledgerJournalTable)
            {
                RetailParameters                rboParameters = RetailParameters::find();
                RetailStoreTable                retailStoreTable = RetailStoreTable::find(_custOrderInfo.StoreId);

                _ledgerJournalTable.data(
                                RetailTransactionPaymentsHelper::createLedgerJournalTable_RU(
                                    _isRCash ? rboParameters.DefaultRCashJournalName : rboParameters.DefaultCustPaymentJournalName_RU,
                                    _isRCash ? LedgerJournalType::RCash : LedgerJournalType::CustPayment,
                                    _salesTable.SalesId,
                                    retailStoreTable.DefaultDimension,
                                    _custOrderInfo.CurrencyCode));
            }

            [_voucher, _rCashVoucher, _custPaymVoucher] = RetailTransactionPaymentsHelper::createVoucherForLedgerJournalTrans_RU(isRCash, _ledgerJournalTable, _voucher, _rCashVoucher, _custPaymVoucher);
        }
        else
        {
            // the payment is captured on client side, post to journal.
            if (!_ledgerJournalTable)
            {
                // Create the header for the journal entry for each non credit payments
                _ledgerJournalTable = RetailTransactionPaymentsHelper::CreateLedgerJournalForStore(
                                                                                            _salesTable.SalesId,
                                                                                            _custOrderInfo.CurrencyCode,
                                                                                            RetailChannelTable::findByRecId(channelRecId),
                                                                                            _isReturnOrder);
                _ledgerJournalTable.insert();
            }

            RetailPaymentVoucherParameters voucherParameters = new RetailPaymentVoucherParameters();
            voucherParameters.initFromParameters(_salesTable, _custOrderInfo, _paymentInfo, _ledgerJournalTable, _custPaymJournalTable);
            _voucher = RetailTransactionPaymentsHelper::getNewPaymentVoucherFromParameters(CustParameters::numRefCustPaymVoucher(), voucherParameters);
        }

        return [_ledgerJournalTable, _rCashJournalTable, _custPaymJournalTable, _voucher, _rCashVoucher, _custPaymVoucher];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewPaymentVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a unique payment voucher.
    /// </summary>
    /// <param name = "_numberSequenceReference">Value for voucher number sequence.</param>
    /// <returns>A new payment voucher.</returns>
    protected static Voucher getNewPaymentVoucher(NumberSequenceReference _numberSequenceReference = CustParameters::numRefCustPaymVoucher())
    {
        return NumberSeq::newGetNum(_numberSequenceReference).num();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewPaymentVoucherFromParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a unique payment voucher from specified parameters.
    /// </summary>
    /// <param name = "_numberSequenceReference">Value for voucher number sequence.</param>
    /// <param name = "_voucherParameters">Additional parameters for voucher number generation</param>
    /// <returns>A new payment voucher.</returns>
    protected static Voucher getNewPaymentVoucherFromParameters(
        NumberSequenceReference _numberSequenceReference = CustParameters::numRefCustPaymVoucher(),
        RetailPaymentVoucherParameters _voucherParameters = null)
    {
        return RetailTransactionPaymentsHelper::getNewPaymentVoucher(_numberSequenceReference);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerJournalForStore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a ledger journal for payments against a sales order from a given store.
    /// </summary>
    /// <param name="_salesId">
    /// Sales order id the payments are for.
    /// </param>
    /// <param name="_currencyCode">
    /// Currency code of the payments.
    /// </param>
    /// <param name="_retailChannelTable">
    /// Channel the payments were collected at.
    /// </param>
    /// <param name = "_isReturnOrder">
    /// Is this a return order? (Y/N).
    /// </param>
    /// <returns>
    /// Ledger Journal Table record.
    /// </returns>
    /// <remarks>
    /// Creates and initializes a Ledger Journal for payments against a given sales order, with defaults for the given store and currency.
    /// </remarks>
    internal static LedgerJournalTable createLedgerJournalForStore(SalesId _salesId, CurrencyCode _currencyCode, RetailChannelTable _retailChannelTable, boolean _isReturnOrder = false)
    {
        LedgerJournalName  ledgerJournalName;
        LedgerJournalTable ledgerJournalTable;

        if (RetailCommerceUnifiedPaymentJournalFeatureExposure::isEnabled() && _isReturnOrder)
        {
            LedgerJournalNameId refundJournalName = MCROrderParameters::find().LedgerJournalNameId;

            select firstonly JournalType, JournalName, OffsetLedgerDimension, OffsetAccountType
            from ledgerJournalName
            where ledgerJournalName.JournalType == LedgerJournalType::CustPayment
                && (!refundJournalName || ledgerJournalName.JournalName == refundJournalName);
        }
        else
        {
            RetailPrePaymentLedgerJournalNameId retailJournalName = RetailParameters::find().PrePaymentLedgerJournalName;

            select firstonly JournalType, JournalName, OffsetLedgerDimension, OffsetAccountType
            from ledgerJournalName
            where ledgerJournalName.JournalType == LedgerJournalType::CustPayment
                && (!retailJournalName || ledgerJournalName.JournalName == retailJournalName);
        }

        ledgerJournalTable.clear();
        ledgerJournalTable.JournalNum = JournalTableData::newTable(ledgerJournalTable).nextJournalId();  //Set the journalNum to prevent DefaultDimensions from being reset on .Insert().
        ledgerJournalTable.JournalName = ledgerJournalName.JournalName;
        ledgerJournalTable.initFromLedgerJournalName(ledgerJournalName.JournalName);
        ledgerJournalTable.Name = strFmt("@RET4505", _SalesId);
        ledgerJournalTable.OffsetLedgerDimension = ledgerJournalName.OffsetLedgerDimension;
        ledgerJournalTable.OffsetAccountType = ledgerJournalName.OffsetAccountType;
        ledgerJournalTable.CurrencyCode = _currencyCode;
        ledgerJournalTable.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(ledgerJournalTable.DefaultDimension, _retailChannelTable.DefaultDimension);

        return LedgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPaymentJournalLineForStore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a payment journal line for a given payment Info object instance.
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c> buffer.</param>
    /// <param name = "_custOrderInfo">The customerOrderInfo object instance.</param>
    /// <param name = "_paymentInfo">The current paymentInfo object Instance inside the Payment Info collection.</param>
    /// <param name = "_ledgerJournalTable">The <c>LedgerJournalTable</c> buffer.</param>
    /// <param name = "_rCashJournalTable">The <c>LedgerJournalTable</c> buffer for RCash.</param>
    /// <param name = "_custPaymJournalTable">The <c>LedgerJournalTable</c> buffer for customer payments.</param>
    /// <param name = "_voucher">The voucher number for the payment journal.</param>
    /// <param name = "_rCashVoucher">The voucher number for the RCash payment journal.</param>
    /// <param name = "_custPaymVoucher">The voucher number for the Customer payment journal.</param>
    /// <param name = "_isRCash">is this a RCash payment journal? (Y/N).</param>
    /// <param name = "_isReturnOrder">is this a return order? (Y/N).</param>
    /// <param name = "_mcrCustPaymTable">The <c>MCRCustPaymTable</c> table buffer.</param>
    /// <param name = "_advanceInvoiceContract">The Advance Invoice contract. Default to null.</param>
    /// <returns>A container with the <c>LedgerJournalTable</c> and <c>LedgerJournalTrans</c> table buffers.</returns>
    private static container createPaymentJournalLineForStore(
        SalesTable _salesTable,
        CustomerOrderInfo _custOrderInfo,
        PaymentInfo _paymentInfo,
        LedgerJournalTable _ledgerJournalTable,
        LedgerJournalTable _rCashJournalTable,
        LedgerJournalTable _custPaymJournalTable,
        Voucher _voucher,
        Voucher _rCashVoucher,
        Voucher _custPaymVoucher,
        boolean _isRCash,
        boolean _isReturnOrder,
        MCRCustPaymTable _mcrCustPaymTable = null,
        AdvanceInvoiceContract_W _advanceInvoiceContract = null)
    {
        LedgerJournalTrans ledgerJournalTrans;

        // Check if the payment line is valid to post.
        if (!RetailTransactionPaymentsHelper::canPostToLedgerJournal(_paymentInfo))
        {
            // Skip posting the payment line.
            return [_ledgerJournalTable, ledgerJournalTrans, _rCashJournalTable, _custPaymJournalTable, _voucher, _rCashVoucher, _custPaymVoucher];
        }

        boolean countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        boolean taxOnPrepaymentEnabled_W = countryRegion_W && FeatureStateProvider::isFeatureEnabled(RetailPostingSalesTaxOnPrepaymentFeature_W::instance());
        date businessDate = str2Date(_custOrderInfo.BusinessDateString, 321);

        // Create one entry for each the payment trans
        ledgerJournalTrans = RetailTransactionPaymentsHelper::createLedgerJournalTransForPayment(
                                                                                        _ledgerJournalTable,
                                                                                        _salesTable,
                                                                                        _paymentInfo.Currency,
                                                                                        _voucher,
                                                                                        _paymentInfo.Prepayment,
                                                                                        _mcrCustPaymTable,
                                                                                        businessDate);
        if (_isRCash)
        {
            _paymentInfo.Amount = -_paymentInfo.Amount;
            ledgerJournalTrans.PostingProfile   = RCashParameters::find().PostingProfile;
            if (_paymentInfo.Prepayment)
            {
                ledgerJournalTrans.OffsetPostingProfile_RU = CustParameters::find().PrepaymentPostingProfile;
            }
        }

        if (countryRegion_RU)
        {
            if (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust ||
                ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
            {
                ledgerJournalTrans.CustFactureAutoCreate_RU = CustParameters::find().PrepaymentFactureAutoCreate_RU;
                ledgerJournalTrans.UseOriginalDocumentAsFacture_RU = _salesTable.custTable_CustAccount().UseOriginalDocumentAsFacture_RU;
                if (_paymentInfo.Prepayment)
                {
                    GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceRURET00002, funcName());

                    ledgerJournalTrans.TaxGroup = CustParameters::find().TaxGroup_RU;
                    ledgerJournalTrans.TaxItemGroup = CustParameters::find().TaxItemGroup_RU;
                }
            }
        }

        if (!_isReturnOrder)
        {
            ledgerJournalTrans.Prepayment = _paymentInfo.Prepayment ? NoYes::Yes : NoYes::No;
            if (_ledgerJournalTable.LedgerJournalInclTax == NoYes::No)
            {
                RetailTransactionPaymentsHelper::updateLedgerJournalInclTax(_ledgerJournalTable);
            }
        }
        AmountCur amount = CurrencyExchange::round(_paymentInfo.Amount, _paymentInfo.Currency);
        if (_paymentInfo.Amount >= 0)
        {
            ledgerJournalTrans.AmountCurCredit      = amount;
        }
        else
        {
            ledgerJournalTrans.AmountCurDebit      =  abs(amount);
        }
        ledgerJournalTrans.Txt                  = strFmt("@RET4506", _salesTable.SalesId);
        
        if (RetailPaymentsTerminalDimensionFromRegisterFlight::instance().isEnabled() &&
            RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(SalesTable::find(ledgerJournalTrans.SalesOrderId), funcName()))
        {
            ledgerJournalTrans.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(ledgerJournalTrans.DefaultDimension, RetailTerminalTable::find(_custOrderInfo.TerminalId).DefaultDimension);
        }

        // Find and get the store for which selected payment method is configured.
        RetailChannelRecId channel = RetailTransactionPaymentsHelper::getChannel(_custOrderInfo, _mcrCustPaymTable, _paymentInfo.PaymentType, _paymentInfo.cardType);
        
        RetailTransactionServiceOrders::setCustomerOrderJournal(
            channel,
            _paymentInfo.PaymentType, ledgerJournalTrans,
            _paymentInfo.cardType);

        if (countryRegion_RU)
        {
            if (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust ||
                ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
            {
                ledgerJournalTrans.CustFactureAutoCreate_RU = CustParameters::find().PrepaymentFactureAutoCreate_RU;
                ledgerJournalTrans.UseOriginalDocumentAsFacture_RU = _salesTable.custTable_CustAccount().UseOriginalDocumentAsFacture_RU;
                if (_paymentInfo.Prepayment)
                {
                    ledgerJournalTrans.TaxGroup = CustParameters::find().TaxGroup_RU;
                    ledgerJournalTrans.TaxItemGroup = CustParameters::find().TaxItemGroup_RU;
                }
            }
        }

        // <GEEU>
        if (taxOnPrepaymentEnabled_W && _paymentInfo.Prepayment)
        {
            RetailPostingSalesTaxOnPrepayment_W::fillTaxGroups(ledgerJournalTrans, _isRCash);
        }
        // </GEEU>

        // If the payment is a prepayment and tax on prepayment property is set to true, set the tax group and item tax group.
        if (_paymentInfo.Prepayment && CustParameters::find().TaxOnPrepayment && _custOrderInfo.Items.Count > 0 && !countryRegion_W)
        {
            ItemInfo itemInfo = _custOrderInfo.Items.get_Item(0) as ItemInfo;

            ledgerJournalTrans.TaxGroup = itemInfo.SalesTaxGroup; // each sales line duplicates sales tax group.
            ledgerJournalTrans.TaxItemGroup = TaxParameters::find().TaxItemGroup; // default ITG value for the company.
        }

        if (_paymentInfo.LineNum && _paymentInfo.LineNum != ledgerJournalTrans.LineNum)
        {
            ledgerJournalTrans.LineNum = _paymentInfo.LineNum;
        }

        ledgerJournalTrans.insert();

        if (_isRCash)
        {
            RetailTransactionPaymentsHelper::createLedgerJournalTransRCash(ledgerJournalTrans);
        }

        if (_advanceInvoiceContract != null && ledgerJournalTrans.Prepayment )
        {
            _advanceInvoiceContract.addPrePayment([ledgerJournalTrans.Voucher, ledgerJournalTrans.TransDate, (_isRCash ? 1 : -1) * ledgerJournalTrans.calcAmountMST()]);
        }

        return  [
                    _ledgerJournalTable,
                    ledgerJournalTrans,
                    _rCashJournalTable,
                    _custPaymJournalTable,
                    _voucher,
                    _rCashVoucher,
                    _custPaymVoucher
                ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChannelRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the store identifier.
    /// </summary>
    /// <param name = "_custOrderInfo">The customer order.</param>
    /// <param name = "_mcrCustPaymTable">The customer payment. Optional.</param>
    /// <returns>The channel record identifier.</returns>
    internal static RefRecId getChannelRecId(CustomerOrderInfo _custOrderInfo, MCRCustPaymTable _mcrCustPaymTable = nullValueBaseType(Types::Record))
    {
        return _mcrCustPaymTable.RecId == 0 ? str2Int64(_custOrderInfo.ChannelRecordId) : _mcrCustPaymTable.Channel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRoundingDifferencePaymentJournalLineForStore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a rounding difference payment line for the sales order, to account for
    /// penny differences between Sales Total and payments total.
    /// </summary>
    /// <param name = "_salesTable">The sales record.</param>
    /// <param name = "_ledgerJournalTable">The ledger record.</param>
    /// <param name = "_custOrderInfo">The customer information.</param>
    /// <returns>The <c>LedgerJournalTrans</c> buffer for the penny difference.</returns>
    internal static LedgerJournalTrans createRoundingDifferencePaymentJournalLineForStore(
        SalesTable _salesTable,
        LedgerJournalTable _ledgerJournalTable,
        CustomerOrderInfo _custOrderInfo)
    {
        LedgerJournalTrans ledgerJournalTrans;
        RefRecId channelRecId = str2Int64(_custOrderInfo.ChannelRecordId);

        // post rounding difference if any
        if (_custOrderInfo.RoundingDifference != 0)
        {
            RetailStoreTable storeTable = RetailStoreTable::findRecId(channelRecId);

            if (storeTable)
            {
                // create one entry for each the payment trans
                ledgerJournalTrans = RetailTransactionPaymentsHelper::createLedgerJournalTransForPayment(
                                                                                        _ledgerJournalTable,
                                                                                        _salesTable,
                                                                                        _custOrderInfo.CurrencyCode,
                                                                                        NumberSeq::newGetNum(CustParameters::numRefCustPaymVoucher()).num());
                AmountCur differenceAmount = CurrencyExchange::round(_custOrderInfo.RoundingDifference, _custOrderInfo.CurrencyCode);
                if (differenceAmount > 0)
                {
                    ledgerJournalTrans.AmountCurCredit = differenceAmount;
                }
                else
                {
                    ledgerJournalTrans.AmountCurDebit = abs(differenceAmount);
                }

                ledgerJournalTrans.Txt = strFmt("@RET4506", _salesTable.SalesId);
                ledgerJournalTrans.OffsetAccountType = LedgerJournalACType::Ledger;
                ledgerJournalTrans.OffsetLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(storeTable.RoundingAccountLedgerDimension, storeTable.DefaultDimension);

                ledgerJournalTrans.insert();
            }
        }

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerJournalInclTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the ledger journal table and ledger journal name to include tax
    /// </summary>
    /// <param name="_ledgerJournalTable">
    /// The ledger journal table to set the include tax.
    /// </param>
    /// <remarks>
    /// Used to default the prepayment journal to include tax.
    /// </remarks>
    private static void updateLedgerJournalInclTax(LedgerJournalTable _ledgerJournalTable)
    {
        LedgerJournalName  localLedgerJournalName;
        LedgerJournalTable localLedgerJournalTable;
        var connection = new UserConnection();

        try
        {
            localLedgerJournalTable.setConnection(connection);
            localLedgerJournalName.setConnection(connection);

            connection.ttsbegin();
            localLedgerJournalTable = LedgerJournalTable::findByRecId(_ledgerJournalTable.RecId, true);

            if (localLedgerJournalTable)
            {
                localLedgerJournalTable.LedgerJournalInclTax = NoYes::Yes;
                localLedgerJournalTable.update();
            }

            select firstonly forUpdate LedgerJournalInclTax
                from localLedgerJournalName
                where localLedgerJournalName.JournalType == LedgerJournalType::CustPayment
                   && localLedgerJournalName.JournalName == _ledgerJournalTable.JournalName;

            if (localLedgerJournalName)
            {
                localLedgerJournalName.LedgerJournalInclTax = NoYes::Yes;
                localLedgerJournalName.update();
            }

            connection.ttscommit();
        }
        catch
        {
            eventSource.EventWritePaymentsLedgerJournalUpdateFailed(_ledgerJournalTable.RecId);
        }
        finally
        {
            connection.finalize();
            eventSource.EventWritePaymentsLedgerJournalUpdateSuccessful(_ledgerJournalTable.RecId);
        }

        _ledgerJournalTable.reread();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerJournalTransForPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a Ledger Journal Trans record for a payment associated with a retail sales order.
    /// </summary>
    /// <param name="_ledgerJournalTable">
    /// Parent Ledger Journal for the payment.
    /// </param>
    /// <param name="_salesTable">
    /// Sales order the payemnt is associated with.
    /// </param>
    /// <param name="_currencyCode">
    /// Currency of the payment.
    /// </param>
    /// <param name="_voucher">
    /// Voucher for the payment.
    /// </param>
    /// <param name="_prePayment">
    /// Generate Accounts Receivable Prepayment Journal? (true/false). Default to false.
    /// </param>
    /// <param name="_mcrCustPaymTable">
    /// The <c>MCRCustPaymTable</c> table buffer.
    /// </param>
    /// <returns>
    /// Ledger Journal Trans record initialized with defaults for retail sales order payment.
    /// </returns>
    internal static LedgerJournalTrans createLedgerJournalTransForPayment(
        LedgerJournalTable _ledgerJournalTable,
        SalesTable _salesTable,
        CurrencyCode _currencyCode,
        Voucher _voucher,
        boolean _prePayment = false,
        MCRCustPaymTable _mcrCustPaymTable = null,
        TransDate _transDate = dateNull())
    {
        LedgerJournalTrans ledgerJournalTrans;

        ledgerJournalTrans.clear();
        ledgerJournalTrans.initValue();
        ledgerJournalTrans.JournalNum           = _ledgerJournalTable.JournalNum;
        ledgerJournalTrans.LineNum              = LedgerJournalTrans::lastLineNum(ledgerJournalTrans.JournalNum) + 1;
        ledgerJournalTrans.AccountType          = LedgerJournalACType::Cust;
        ledgerJournalTrans.parmAccount(_salesTable.InvoiceAccount);

        if (RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName()) && _mcrCustPaymTable)
        {
            // For commerce Payments Orders pull in the financial dimensions from the channel where the authorization was made.
            ledgerJournalTrans.DefaultDimension     = RetailChannelTable::findByRecId(_mcrCustPaymTable.Channel).DefaultDimension;
        }
        else
        {
            ledgerJournalTrans.DefaultDimension     = _ledgerJournalTable.DefaultDimension;
        }

        ledgerJournalTrans.initFromCustTable(CustTable::find(_salesTable.InvoiceAccount), false);
        ledgerJournalTrans.CurrencyCode         = _currencyCode;
        ledgerJournalTrans.ExchRate             = ExchangeRateHelper::exchRate(ledgerJournalTrans.CurrencyCode);
        ledgerJournalTrans.PaymReference        = _salesTable.SalesId;
        ledgerJournalTrans.Voucher              = _voucher;
        ledgerJournalTrans.Prepayment           = _prePayment;
        ledgerJournalTrans.TransactionType      = LedgerTransType::Payment;
        ledgerJournalTrans.SalesOrderId         = _salesTable.SalesId;

        // If the sales order is from a store.
        if (_salesTable.RetailChannelTable)
        {
            if (RetailLedgerJournalTransDateUpdateFlight::instance().isEnabled() && _transDate != dateNull())
            {
                ledgerJournalTrans.TransDate = _transDate;
            }
            else
            {
                // Convert the TransDate based on the retail store time zone.
                RetailChannelTable retailChannelTable = RetailChannelTable::findByRecId(_salesTable.RetailChannelTable);
                ledgerJournalTrans.TransDate = DateTimeUtil::getSystemDate(retailChannelTable.ChannelTimeZone);
            }

            ledgerJournalTrans.Approved = NoYes::Yes;

            // Since this transaction originated in a service and not in AX,
            // allow the service to specify a GL account where the transaction should be posted.
            ledgerJournalTrans.SkipBlockedForManualEntryCheck = NoYes::Yes;
        }
        else
        {
            ledgerJournalTrans.TransDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }

        // Set the Customer Posting Profile to the Prepayment Posting Profile in case the payment is marked as Prepayment
        // This is necessary because the logic which sets this field in AX when creating the journal interactively is executed in the UI
        // Since we are dynamically generating the Prepayment journal via code, we have to set it when setting Prepayment to true.
        if (_prePayment)
        {
            ledgerJournalTrans.PostingProfile = CustParameters::find().PrepaymentPostingProfile;
        }

        if (_mcrCustPaymTable)
        {
            ledgerJournalTrans.MCRPaymOrderID = _salesTable.SalesId;
            ledgerJournalTrans.MCRRefPaymID = _mcrCustPaymTable.RecId;
        }

        RetailCreateLedgerJournalTransForPaymentParameters parameters = RetailCreateLedgerJournalTransForPaymentParameters::construct();
        parameters.LedgerJournalTrans = ledgerJournalTrans;

        RetailTransactionPaymentsHelperExtensions::updateLedgerJournalTransForPayment(parameters);

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateReasonCodeLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates reason code lines given the sales record ID and parent record ID.
    /// </summary>
    /// <param name = "_transRecId">The sales table record ID.</param>
    /// <param name = "_parentRecId">The parent record ID.</param>
    /// <param name = "_reasonCodeInfoCollection">The collection of reason codes to be updated and/or created.</param>
    /// <param name = "_tableType">The info code line table type.</param>
    /// <remarks>
    /// The parent record ID can be either the sales record ID, for the header; the sales line record ID, for the sales line;
    /// or the ledger journal transaction, for payment lines.
    /// </remarks>
    internal static server void createOrUpdateReasonCodeLines(
        RecId _transRecId,
        RecId _parentRecId,
        System.Object _reasonCodeInfoCollection,
        RetailInfoCodeLineRelatedTableType _tableType)
    {
        if (_reasonCodeInfoCollection == null)
        {
            return;
        }

        System.Type reasonCodeInfoCollectionType = _reasonCodeInfoCollection.GetType();
        System.Reflection.MethodInfo getItemMethod = reasonCodeInfoCollectionType.GetMethod('get_Item');

        RetailInfocodeLine infoCodeLine;
        RetailInfocodeLineV2 infoCodeLineV2;

        int collectionCount = reasonCodeInfoCollectionType.GetMethod('get_Count').Invoke(_reasonCodeInfoCollection, null);

        for (int i = 0; i < collectionCount; i++)
        {
            System.Object reasonCodeInfo = getItemMethod.Invoke(_reasonCodeInfoCollection, [i]);

            if (RetailInfoCodeLineTableV2Feature::isEnabled())
            {
                infoCodeLineV2 = RetailInfocodeLineV2::findByLineNum(
                _transRecId,
                _parentRecId,
                _tableType,
                ReflectionHelper::getObjectProperty(reasonCodeInfo, 'LineTypeValue'),
                ReflectionHelper::getObjectProperty(reasonCodeInfo, 'LineNumber'),
                true);

                infoCodeLineV2.Amount = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'Amount');
                infoCodeLineV2.InfocodeId = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'ReasonCodeId');
                infoCodeLineV2.Information = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'Information');
                infoCodeLineV2.InformationAmount = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'InformationAmount');
                infoCodeLineV2.InputType = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'InputTypeValue');
                infoCodeLineV2.ItemTender = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'ItemTender');
                infoCodeLineV2.LineNum = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'LineNumber');
                infoCodeLineV2.ParentRecId = _parentRecId;
                infoCodeLineV2.SalesTable = _transRecId;
                infoCodeLineV2.SourceCode = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'SourceCode');
                infoCodeLineV2.SourceCode2 = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'SourceCode2');
                infoCodeLineV2.SourceCode3 = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'SourceCode3');
                infoCodeLineV2.StatementCode = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'StatementCode');
                infoCodeLineV2.SubInfocodeId = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'SubReasonCodeId');
                infoCodeLineV2.Type = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'LineTypeValue');
                infoCodeLineV2.TableType = _tableType;
                infoCodeLineV2.validateWrite();

                if (infoCodeLineV2)
                {
                    infoCodeLineV2.update();
                }
                else
                {
                    infoCodeLineV2.insert();
                }
            }
            else
            {
                infoCodeLine = RetailInfocodeLine::findByLineNum(
                _transRecId,
                _parentRecId,
                ReflectionHelper::getObjectProperty(reasonCodeInfo, 'LineTypeValue'),
                ReflectionHelper::getObjectProperty(reasonCodeInfo, 'LineNumber'),
                true);

                infoCodeLine.Amount = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'Amount');
                infoCodeLine.InfocodeId = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'ReasonCodeId');
                infoCodeLine.Information = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'Information');
                infoCodeLine.InformationAmount = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'InformationAmount');
                infoCodeLine.InputType = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'InputTypeValue');
                infoCodeLine.ItemTender = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'ItemTender');
                infoCodeLine.LineNum = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'LineNumber');
                infoCodeLine.ParentRecId = _parentRecId;
                infoCodeLine.SalesTable = _transRecId;
                infoCodeLine.SourceCode = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'SourceCode');
                infoCodeLine.SourceCode2 = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'SourceCode2');
                infoCodeLine.SourceCode3 = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'SourceCode3');
                infoCodeLine.StatementCode = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'StatementCode');
                infoCodeLine.SubInfocodeId = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'SubReasonCodeId');
                infoCodeLine.Type = ReflectionHelper::getObjectProperty(reasonCodeInfo, 'LineTypeValue');

                infoCodeLine.validateWrite();

                if (infoCodeLine)
                {
                    infoCodeLine.update();
                }
                else
                {
                    infoCodeLine.insert();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPaymentJournalForStore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post a payment journal for the store.
    /// </summary>
    /// <param name = "_ledgerJournalTable">The <c>LedgerJournalTable</c> buffer.</param>
    /// <param name = "_custOrderInfo">The customerOrderInfo instance.</param>
    internal static void postPaymentJournalForStore(LedgerJournalTable _ledgerJournalTable, CustomerOrderInfo _custOrderInfo)
    {
        LedgerJournalCheckPost ledgerJournalCheckPost = LedgerJournalCheckPostRetail::newRBOLedgerJournalTable(_ledgerJournalTable,
                                                                                                                NoYes::Yes,
                                                                                                                NoYes::No,
                                                                                                                _custOrderInfo.TransactionId,
                                                                                                                _custOrderInfo.StoreId,
                                                                                                                _custOrderInfo.TerminalId);
        ledgerJournalCheckPost.parmMCRProgressBarHide(true);
        ledgerJournalCheckPost.progressHide();
        ledgerJournalCheckPost.parmBeQuiet(true);

        LedgerJournalCheckPost::processOperation(ledgerJournalCheckPost);
    }

]]></Source>
			</Method>
			<Method>
				<Name>savePrepaymentsForSalesOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Save all prepayments into RetailPrepaymentTrans table.
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c> buffer.</param>
    internal static void savePrepaymentsForSalesOrder(SalesTable _salesTable)
    {
        CustTrans          custTrans;
        LedgerJournalTrans ledgerJournalTrans;

        while select PaymReference, Voucher, CurrencyCode, RecId from custTrans
                        where custTrans.PaymReference == _salesTable.SalesId
                    join Prepayment from ledgerJournalTrans
                        where custTrans.Voucher == ledgerJournalTrans.Voucher
        {
            if (ledgerJournalTrans.Prepayment && !RetailPrePaymentTrans::find(_salesTable.SalesId, custTrans.RecId))
            {
                RetailPrePaymentTrans           prepaymentTrans;
                prepaymentTrans.clear();
                prepaymentTrans.SalesId         = _salesTable.SalesId;
                prepaymentTrans.CustTransRecId  = custTrans.RecId;
                prepaymentTrans.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustomerOrderJournalForTender</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set LedgerJournalTrans properties based on the given tender type
    /// </summary>
    /// <param name="storeId">
    /// Retail Store
    /// </param>
    /// <param name="tenderTypeId">
    /// Retail Tender Type
    /// </param>
    /// <param name="ledgerJournalTrans">
    /// Journal to be updated
    /// </param>
    /// <param name="cardTypeId">
    /// Retail Tender Card Type. Default to empty.
    /// </param>
    /// <remarks>
    /// Updates the Journal based on the store and tender type.
    /// </remarks>
    internal static void setCustomerOrderJournalForTender(RetailStoreId storeId, RetailTenderTypeId tenderTypeId, LedgerJournalTrans ledgerJournalTrans, RetailCardTypeId cardTypeId = '')
    {
        RecId   storeRecId;

        storeRecId = RetailStoreTable::find(storeId).RecId;

        RetailTransactionServiceOrders::setCustomerOrderJournal(storeRecId, tenderTypeId, ledgerJournalTrans, cardTypeId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerJournalTable_RU</Name>
				<Source><![CDATA[
    // Localization Helper methods

    /// <summary>
    /// Method creates and initializes new <c>LedgerJournalTable</c> record.
    /// </summary>
    /// <param name="_ledgerJournalNameId">
    /// The ledger Journal Name identifier.
    /// </param>
    /// <param name="_journalType">
    /// The ledger journal type.
    /// </param>
    /// <param name="_salesId">
    /// The sales order ID.
    /// </param>
    /// <param name="_defaultDimension">
    /// The default dimension.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code.
    /// </param>
    /// <returns>
    /// New <c>LedgerJournalTable</c> record created.
    /// </returns>
    internal static LedgerJournalTable createLedgerJournalTable_RU(LedgerJournalNameId _ledgerJournalNameId,
                                                                  LedgerJournalType   _journalType,
                                                                  SalesId             _salesId,
                                                                  DimensionDefault    _defaultDimension,
                                                                  CurrencyCode        _currencyCode)
    {
        LedgerJournalTable  ledgerJournalTable;
        LedgerJournalName   ledgerJournalName;
        str                 errorMsg;

        ledgerJournalName = LedgerJournalName::find(_ledgerJournalNameId);

        if (!ledgerJournalName)
        {
            switch (_journalType)
            {
                case LedgerJournalType::RCash:
                    errorMsg = "@SYS4002022";
                    break;
                case LedgerJournalType::CustPayment:
                    errorMsg = "@SYS4002020";
                    break;
                default:
                    errorMsg = "@SYS25908";
            }

            throw error(strFmt("@SYS4002028", errorMsg));
        }

        ttsbegin;
        ledgerJournalTable.clear();
        ledgerJournalTable.JournalName = ledgerJournalName.JournalName;
        ledgerJournalTable.initFromLedgerJournalName(ledgerJournalName.JournalName);
        ledgerJournalTable.JournalNum            = JournalTableData::newTable(ledgerJournalTable).nextJournalId();
        ledgerJournalTable.Name                  = strFmt("@RET4505", _salesId);
        ledgerJournalTable.OffsetLedgerDimension = ledgerJournalName.OffsetLedgerDimension;
        ledgerJournalTable.OffsetAccountType     = ledgerJournalName.OffsetAccountType;
        ledgerJournalTable.CurrencyCode          = _currencyCode;
        ledgerJournalTable.insert();
        ledgerJournalTable.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(_defaultDimension, ledgerJournalTable.DefaultDimension);
        ledgerJournalTable.update();
        ttscommit;

        return ledgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createVoucherForLedgerJournalTrans_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create Voucher numbers for Russian transactions.
    /// </summary>
    /// <param name = "isRCash">Is RCash payment journal? (Y/N).</param>
    /// <param name = "ledgerJournalTable">The <c>LedgerJournalTable</c> buffer.</param>
    /// <param name = "voucher">The global voucher id (not localized).</param>
    /// <param name = "rCashVoucher">The RCash vooucher id. (localized).</param>
    /// <param name = "custPaymVoucher">The customer payment voucher id (localized).</param>
    /// <returns>A container with the voucher ids.</returns>
    private static container createVoucherForLedgerJournalTrans_RU(boolean isRCash, LedgerJournalTable ledgerJournalTable, Voucher voucher, Voucher rCashVoucher, Voucher custPaymVoucher)
    {
        voucher = isRCash ? rCashVoucher : custPaymVoucher;

        if (!voucher || ledgerJournalTable.ledgerJournalName().NewVoucher == NewVoucher::BalanceSheet)
        {
            voucher = NumberSeq::newGetVoucherFromId(ledgerJournalTable.NumberSequenceTable).voucher();
            if (isRCash)
            {
                rCashVoucher = voucher;
            }
            else
            {
                custPaymVoucher = voucher;
            }
        }

        return [voucher, rCashVoucher, custPaymVoucher];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerJournalTransRCash</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method creates <c>ledgerJournalTrans_RCash</c> record and initializes RCash voucher.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    internal static void createLedgerJournalTransRCash(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTrans_RCash ledgerJournalTrans_RCash;
        RCashTrans               rCashTrans;
        RCashVoucher             rCashVoucher;

        ttsbegin;
        ledgerJournalTrans_RCash.RefRecId    = _ledgerJournalTrans.RecId;
        ledgerJournalTrans_RCash.TransStatus = RCashTransStatus::Approved;

        if (_ledgerJournalTrans.AmountCurDebit > 0)
        {
            ledgerJournalTrans_RCash.DocType = RCashDocType::ReimbursementSlip;
        }
        else
        {
            ledgerJournalTrans_RCash.DocType = RCashDocType::DisbursementSlip;
        }

        ledgerJournalTrans_RCash.insert();

        rCashVoucher = new RCashVoucher(_ledgerJournalTrans, ledgerJournalTrans_RCash);
        rCashTrans   = rCashVoucher.createOrUpdateTrans(RCashTransStatus::Approved);

        ledgerJournalTrans_RCash.selectForUpdate(true);
        ledgerJournalTrans_RCash.CashDocId = rCashTrans.DocId;
        ledgerJournalTrans_RCash.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postLedgerJournalTable_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method posts ledger journal.
    /// </summary>
    /// <param name="_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> record.
    /// </param>
    internal static void postLedgerJournalTable_RU(LedgerJournalTable _ledgerJournalTable)
    {
        LedgerJournalCheckPost ledgerJournalCheckPost;

        if (_ledgerJournalTable)
        {
            ledgerJournalCheckPost = LedgerJournalCheckPostRetail::newRBOLedgerJournalTable(_ledgerJournalTable, NoYes::Yes, NoYes::No);
            LedgerJournalCheckPost::processOperation(ledgerJournalCheckPost);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelCustomerOrderPayments_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates refund payments for canceled order.
    /// </summary>
    /// <param name="_custOrderXml">XML string having the header, line details and charges, refund payments.</param>
    /// <param name="_salesTable">The canceled sales order.</param>
    /// <returns>A list with the voucher ids.</returns>
    internal static List cancelCustomerOrderPayments_W(XmlDocument _custOrderXml, SalesTable _salesTable)
    {
        #Define.StoreAttribute('StoreId')
        #Define.CurrencyAttribute('CurrencyCode')
        #Define.Charges('Charges')

        XmlElement  xmlRoot;
        XmlElement  xmlRecord;
        XmlNodeList xmlRecordList;

        int                     i;
        MarkupCode              chargeCode;
        Amount                  chargeAmount;
        boolean                 isRCash;
        LedgerJournalTable      ledgerJournalTable;
        LedgerJournalTrans      ledgerJournalTrans;
        LedgerJournalTable      rCashJournalTable;
        LedgerJournalTable      custPaymJournalTable;
        LedgerJournalTable      chargeJournalTable;
        RCashPostingProfile     rCashPostingProfile;
        MarkupTable             markupTable;
        MarkupCustPosting_RU    markupCustPosting;
        Voucher                 voucher;
        TransDate               transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        Voucher                 rCashVoucher;
        Voucher                 custPaymVoucher;
        Voucher                 chargeVoucher;
        CurrencyCode            currencyCode;
        RetailStoreId           storeId;
        RetailStoreTable        retailStoreTable;
        CustTable               custTable;
        CustPostingProfile      prepaymentPostingProfile;
        RetailParameters        retailParameters = RetailParameters::find();
        Set                     refundPaymentsSet = new Set(Types::String);
        boolean                 countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        boolean                 countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);
        CustomerOrderInfo       custOrderInfo  = CustomerOrderInfo::FromXml(_custOrderXml.toString());
        PaymentInfoCollection   payments = custOrderInfo.Payments;
        boolean                 isCommercePaymentsOrder = RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName());

        xmlRoot = _custOrderXml.documentElement().getNamedElement(#storeAttribute);
        storeId = xmlRoot.text();
        retailStoreTable = RetailStoreTable::find(storeId);

        prepaymentPostingProfile = CustParameters::find().PrepaymentPostingProfile;
        rCashPostingProfile = RCashParameters::find().PostingProfile;

        xmlRoot = _custOrderXml.documentElement().getNamedElement(#CurrencyAttribute);
        if (xmlRoot.text())
        {
            currencyCode = xmlRoot.text();
        }
        else
        {
            currencyCode = CompanyInfoHelper::standardCurrency();
        }

        if (!payments || payments.get_Count() == 0)
        {
            return null;
        }

        custTable = _salesTable.custTable_InvoiceAccount();

        for (i = 0; i < payments.get_Count(); i++)
        {
            PaymentInfo paymentInfo = payments.get_Item(i) as PaymentInfo;

            RetailTenderLineStatus paymentStatus = paymentInfo.PaymentStatusValue;
            boolean paymentCaptured = paymentInfo.PaymentCaptured;
            CreditCardProcessorStatus creditCardProcessStatus = paymentInfo.CreditCardProcessorStatusValue;
            CreditCardAuthTransRefRecId linkedPaymentRefRecId = paymentInfo.LinkedPaymentRefRecId;

            // Only create ledger journal payment trans for successfully captured payments. This check needs to be done because with the new
            // omni-channel payments feature, the _custOrderXml can contain pre-existing authorized payments or card tokens that
            // were sent to POS, but were not captured there. If a ledger journal trans is created for such payments it will result
            // in posting errors.
            // Note: Checking for paymentCaptured here for backward compatibility.
            if (paymentStatus != RetailTenderLineStatus::Committed && !paymentCaptured &&
                    (creditCardProcessStatus != CreditCardProcessorStatus::Approved || creditCardProcessStatus != CreditCardProcessorStatus::NA))
            {
                continue;
            }

            AmountCur amount = paymentInfo.Amount;
            str paymentMode = paymentInfo.PaymentType;
            str cardType = paymentInfo.CardType;

            // If the payment returned is a linked refund, create records in the CreditCardAuthTrans and MCRCustPaymTable; when required.
            boolean isOmniChannelPaymentsEnabled = RetailSharedParameters::find().EnableOmniChannelPayments;
            CreditCardAuthTransRefRecId creditCardAuthTransRefId;
            if (amount < 0 && linkedPaymentRefRecId && isOmniChannelPaymentsEnabled)
            {
                RetailMCRChannelTable callCenterUsedForOrderCreation =  RetailMCRChannelTable::findChannelBySalesTable(_salesTable);
                boolean isCallCenterOrder = callCenterUsedForOrderCreation && _salesTable.mcrIsCallCenter() && callCenterUsedForOrderCreation.MCREnableOrderCompletion;

                boolean prePayment = paymentInfo.Prepayment;
                AmountCur authorizedAmount = paymentInfo.AuthorizedAmount;
                str creditCardAuthorization = paymentInfo.CreditCardAuthorization;
                str creditCardCaptureToken = paymentInfo.CreditCardCaptureToken;
                str paymentSdkXml = creditCardCaptureToken ? creditCardCaptureToken : creditCardAuthorization;

                RetailChannelRecId channel = paymentInfo.ChannelRecordId;

                creditCardAuthTransRefId = RetailTransactionPaymentsHelper::handleLinkedRefund(
                        isCallCenterOrder || isCommercePaymentsOrder,
                        _salesTable,
                        paymentStatus,
                        currencyCode,
                        paymentMode,
                        cardType,
                        prePayment,
                        linkedPaymentRefRecId,
                        paymentCaptured,
                        amount,
                        authorizedAmount,
                        channel,
                        false,
                        paymentSdkXml,
                        MCRCustPaymStatus::Paid);
            }
            else if (isCommercePaymentsOrder)
            {
                McrCustPaymTable mcrCustPaymTable;
                container _existingDeclinedPayments = conNull();
                container _newPayments = conNull();

                // Record credit card auth trans for credit card capture
                // Create MCR CustPaymTable corresponding to the refunds for Commerce Payments Order
                [mcrCustPaymTable, _existingDeclinedPayments, _newPayments] =
                        RetailTransactionPaymentsHelper::createCallCenterPayment(
                                _salesTable,
                                paymentInfo,
                                false,
                                MCRCustPaymStatus::Paid);

                // Record the credit card CAPTURE transaction details in CreditCardAuthTrans if payment Info contains Card Authorization XML.
                RetailTransactionPaymentsHelper::recordCreditCardAuthorizationCapture(_salesTable, paymentInfo, mcrCustPaymTable, CreditCardOperation::AuthorizeAndCapture);

                eventSource.EventWritePaymentsRefundedPaymentOnCustomerOrderPaymentCancellationForCommerceEnabledOrder(_salesTable.RecId, mcrCustPaymTable.RecId);
            }

            isRCash = RetailStoreTenderTypeTable::find(retailStoreTable.RecId, paymentMode).accountType == RetailLedgerBank::RCash;

            ledgerJournalTable = isRCash ? rCashJournalTable : custPaymJournalTable;

            if (!ledgerJournalTable)
            {
                ledgerJournalTable.data(
                    RetailTransactionPaymentsHelper::createLedgerJournalTable_RU(
                        isRCash ? retailParameters.DefaultRCashJournalName : retailParameters.DefaultCustPaymentJournalName_RU,
                        isRCash ? LedgerJournalType::RCash : LedgerJournalType::CustPayment,
                        _salesTable.SalesId,
                        retailStoreTable.DefaultDimension,
                        currencyCode));
            }

            voucher = isRCash ? rCashVoucher : custPaymVoucher;

            if (!voucher || ledgerJournalTable.ledgerJournalName().NewVoucher == NewVoucher::BalanceSheet)
            {
                voucher = NumberSeq::newGetVoucherFromId(ledgerJournalTable.NumberSequenceTable).voucher();
                refundPaymentsSet.add(voucher);
                if (isRCash)
                {
                    rCashVoucher = voucher;
                }
                else
                {
                    custPaymVoucher = voucher;
                }
            }

            ledgerJournalTrans.clear();
            ledgerJournalTrans.initValue();
            ledgerJournalTrans.JournalNum = ledgerJournalTable.JournalNum;
            ledgerJournalTrans.LineNum = LedgerJournalTrans::lastLineNum(ledgerJournalTrans.JournalNum) + 1;
            ledgerJournalTrans.AccountType = LedgerJournalACType::Cust;
            ledgerJournalTrans.parmAccount(_salesTable.InvoiceAccount);
            ledgerJournalTrans.DefaultDimension     = ledgerJournalTable.DefaultDimension;
            ledgerJournalTrans.initFromCustTable(custTable);
            ledgerJournalTrans.CurrencyCode = currencyCode;
            ledgerJournalTrans.ExchRate = ExchangeRateHelper::exchRate(ledgerJournalTrans.CurrencyCode);
            ledgerJournalTrans.JournalNum = ledgerJournalTable.JournalNum;
            ledgerJournalTrans.TransDate = transDate;
            ledgerJournalTrans.PaymReference = _salesTable.SalesId;
            ledgerJournalTrans.Prepayment = NoYes::No;
            ledgerJournalTrans.Voucher = voucher;
            ledgerJournalTrans.CreditCardAuthTransRefId = creditCardAuthTransRefId;
            ledgerJournalTrans.SalesOrderId = _salesTable.SalesId;

            if (isRCash)
            {
                ledgerJournalTrans.PostingProfile   = rCashPostingProfile;
                ledgerJournalTrans.OffsetPostingProfile_RU = prepaymentPostingProfile;
            }
            else
            {
                ledgerJournalTrans.PostingProfile   = prepaymentPostingProfile;
            }

            if (countryRegion_W)
            {
                ledgerJournalTrans.Prepayment = NoYes::Yes;

                if (countryRegion_RU)
                {
                    ledgerJournalTrans.CustFactureAutoCreate_RU = CustParameters::find().PrepaymentFactureAutoCreate_RU;
                    ledgerJournalTrans.UseOriginalDocumentAsFacture_RU = custTable.UseOriginalDocumentAsFacture_RU;
                }
                ledgerJournalTrans.TaxGroup = CustParameters::find().TaxGroup_RU;
                ledgerJournalTrans.TaxItemGroup = CustParameters::find().TaxItemGroup_RU;
            }

            amount = isRCash ? - amount : amount;
            if (amount >= 0)
            {
                ledgerJournalTrans.AmountCurCredit  =  abs(amount);
            }
            else
            {
                ledgerJournalTrans.AmountCurDebit   =  abs(amount);
            }

            ledgerJournalTrans.TransactionType      = LedgerTransType::Sales;
            ledgerJournalTrans.Txt                  = strFmt("@RET4506",_salesTable.SalesId);
            RetailTransactionPaymentsHelper::setCustomerOrderJournalForTender(storeId, paymentMode, ledgerJournalTrans, cardType);
            ledgerJournalTrans.insert();
            if (isRCash)
            {
                RetailTransactionPaymentsHelper::createLedgerJournalTransRCash(ledgerJournalTrans);
            }
        }

        RetailTransactionPaymentsHelper::postLedgerJournalTable_RU(rCashJournalTable);
        RetailTransactionPaymentsHelper::postLedgerJournalTable_RU(custPaymJournalTable);

        xmlRoot = _custOrderXml.documentElement().getNamedElement(#Charges);
        xmlRecordList = xmlRoot.childNodes();
        if (xmlRecordList)
        {
            for (i = 0; i < xmlRecordList.length(); i++)
            {
                xmlRecord = xmlRecordList.item(i);
                chargeCode = xmlRecord.getAttribute(CodeStr);
                chargeAmount = str2num(xmlRecord.getAttribute(AmountStr));

                markupTable = markupTable::find(MarkupModuleType::Cust, chargeCode);

                if (!markupTable ||
                     markupTable.CustType != MarkupType::CustVend ||
                     markupTable.VendType != MarkupType::LedgerAccount)
                    throw error(Error::wrongUseOfFunction(funcname()));

                if (!chargeJournalTable)
                {
                    chargeJournalTable = RetailTransactionPaymentsHelper::createLedgerJournalTable_RU(
                        retailParameters.DefaultLedgerJournalName_RU,
                        LedgerJournalType::Daily,
                        _salesTable.SalesId,
                        retailStoreTable.DefaultDimension,
                        currencyCode);
                }

                if (!chargeVoucher || chargeJournalTable.ledgerJournalName().NewVoucher == NewVoucher::BalanceSheet)
                {
                    chargeVoucher = NumberSeq::newGetVoucherFromId(chargeJournalTable.NumberSequenceTable).voucher();
                    refundPaymentsSet.add(chargeVoucher);
                }

                ledgerJournalTrans.clear();
                ledgerJournalTrans.initValue();
                ledgerJournalTrans.JournalNum           = chargeJournalTable.JournalNum;
                ledgerJournalTrans.LineNum              = LedgerJournalTrans::lastLineNum(ledgerJournalTrans.JournalNum) + 1;
                ledgerJournalTrans.AccountType          = LedgerJournalACType::Cust;
                ledgerJournalTrans.parmAccount(_salesTable.InvoiceAccount);
                ledgerJournalTrans.DefaultDimension     = chargeJournalTable.DefaultDimension;
                ledgerJournalTrans.initFromCustTable(custTable);
                ledgerJournalTrans.CurrencyCode         = currencyCode;
                ledgerJournalTrans.ExchRate             = ExchangeRateHelper::exchRate(ledgerJournalTrans.CurrencyCode);
                ledgerJournalTrans.JournalNum           = chargeJournalTable.JournalNum;
                ledgerJournalTrans.TransDate            = transDate;
                ledgerJournalTrans.PaymReference        = _salesTable.SalesId;
                ledgerJournalTrans.Prepayment           = NoYes::No;
                ledgerJournalTrans.Voucher              = chargeVoucher;
                if (chargeAmount >= 0)
                {
                    ledgerJournalTrans.AmountCurDebit   =  abs(chargeAmount);
                }
                else
                {
                    ledgerJournalTrans.AmountCurCredit  =  abs(chargeAmount);
                }
                ledgerJournalTrans.TransactionType      = LedgerTransType::Sales;
                ledgerJournalTrans.Txt                  = strFmt("@RET260962",_salesTable.SalesId);

                if (countryRegion_RU)
                {
                    markupCustPosting = MarkupCustPosting_RU::findLedger(MarkupCustPostingType_RU::SalesRevenue, _salesTable.InvoiceAccount, chargeCode);

                    if (! markupCustPosting.LedgerDimension)
                        throw error(strFmt("@GLS114840", chargeCode));

                    ledgerJournalTrans.OffsetAccountType     = LedgerJournalACType::Ledger;
                    ledgerJournalTrans.OffsetLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(markupCustPosting.LedgerDimension, ledgerJournalTrans.DefaultDimension);
                    ledgerJournalTrans.insert();

                    markupCustPosting = MarkupCustPosting_RU::findLedger(MarkupCustPostingType_RU::SalesConsumption, _salesTable.InvoiceAccount, chargeCode);

                    if (! markupCustPosting.LedgerDimension)
                        throw error(strFmt("@GLS114839", chargeCode));

                    if (!chargeVoucher || chargeJournalTable.ledgerJournalName().NewVoucher == NewVoucher::BalanceSheet)
                    {
                        chargeVoucher = NumberSeq::newGetVoucherFromId(chargeJournalTable.NumberSequenceTable).voucher();
                    }

                    ledgerJournalTrans.LineNum++;
                    ledgerJournalTrans.Voucher               = chargeVoucher;
                    ledgerJournalTrans.AccountType           = LedgerJournalACType::Ledger;
                    ledgerJournalTrans.LedgerDimension       = LedgerDimensionFacade::serviceCreateLedgerDimension(markupCustPosting.LedgerDimension, ledgerJournalTrans.DefaultDimension);
                    ledgerJournalTrans.OffsetAccountType     = LedgerJournalACType::Ledger;
                    ledgerJournalTrans.OffsetLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(markupTable.VendorLedgerDimension, ledgerJournalTrans.DefaultDimension);
                    ledgerJournalTrans.insert();
                }
                else
                {
                    ledgerJournalTrans.OffsetAccountType     = LedgerJournalACType::Ledger;
                    ledgerJournalTrans.OffsetLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(markupTable.VendorLedgerDimension, ledgerJournalTrans.DefaultDimension);
                    ledgerJournalTrans.insert();
                }
            }
        }

        RetailTransactionPaymentsHelper::postLedgerJournalTable_RU(chargeJournalTable);

        List refundPaymentsList = RetailTransactionPaymentsHelper::set2list(refundPaymentsSet);

        return refundPaymentsList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLedgerJournalPaymentTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the LedgerJournalPayment lines for the payment
    /// </summary>
    /// <param name = "_custOrderXml">XML string having the header, line details and charges.</param>
    /// <param name = "_defaultCurrencyCode">Currency code.</param>
    /// <param name = "_ledgerJournalTable">Parent Ledger Journal for the payment.</param>
    /// <param name = "_voucher">Voucher of the journal (Obsolete).</param>
    /// <param name = "_storeId">Retail store ID.</param>
    /// <param name = "_salesId">Sales order id the payments are for.</param>
    /// <remarks>
    /// This method also adds a record to <c>CreditCardAuthTrans</c> table and <c>MCRCustPaymTable</c> (if applicable) for linked refunds.
    /// The parameter "_voucher" is depracated and is not being used by this method. It is being left here for compatibility purposes.
    /// </remarks>
    public static void insertLedgerJournalPaymentTrans(XmlDocument _custOrderXml, CurrencyCode _defaultCurrencyCode, LedgerJournalTable _ledgerJournalTable, Voucher _voucher, RetailStoreId _storeId, SalesId _salesId)
    {
        CurrencyCode currencyCode;
        SalesTable salesTable = SalesTable::find(_salesId);
        LedgerJournalTrans ledgerJournalTrans;
        boolean     isIndia = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        RetailMCRChannelTable callCenterUsedForOrderCreation =  RetailMCRChannelTable::findChannelBySalesTable(salesTable);
        boolean isCallCenterOrder = callCenterUsedForOrderCreation && salesTable.mcrIsCallCenter() && callCenterUsedForOrderCreation.MCREnableOrderCompletion;
        boolean isCommercePaymentsOrder = RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(salesTable, funcName());

        CustomerOrderInfo custOrderInfo  = CustomerOrderInfo::FromXml(_custOrderXml.toString());
        PaymentInfoCollection payments = custOrderInfo.Payments;

        if (payments)
        {
            // create entry for each payment
            for (int i = 0; i < payments.get_Count(); i++)
            {
                PaymentInfo paymentInfo = payments.get_Item(i) as PaymentInfo;

                RetailTenderLineStatus paymentStatus = paymentInfo.PaymentStatusValue;
                boolean paymentCaptured = paymentInfo.PaymentCaptured;
                RefRecId linkedPaymentRefRecId = paymentInfo.LinkedPaymentRefRecId;
                CreditCardProcessorStatus creditCardProcessStatus = paymentInfo.CreditCardProcessorStatusValue;


                // Only create ledger journal payment trans for successfully captured payments. This check needs to be done because with the new
                // omni-channel payments feature, the _custOrderXml can contain pre-existing authorized payments or card tokens that
                // were sent to POS, but were not captured there. If a ledger journal trans is created for such payments it will result
                // in posting errors.
                // Note: Checking for paymentCaptured here for backward compatibility.
                if (isCommercePaymentsOrder)
                {
                    if (paymentStatus != RetailTenderLineStatus::Committed && !paymentCaptured &&
                    (creditCardProcessStatus != CreditCardProcessorStatus::Approved || creditCardProcessStatus != CreditCardProcessorStatus::NA))
                    {
                        eventSource.EventWritePaymentsSkippedLedgerJournalCreationForNonCapturedPayment(salesTable.RecId, enum2Str(paymentStatus), isCommercePaymentsOrder);
                        continue;
                    }
                }
                else if (paymentStatus != RetailTenderLineStatus::Committed && !paymentCaptured)
                {
                    eventSource.EventWritePaymentsSkippedLedgerJournalCreationForNonCapturedPayment(salesTable.RecId, enum2Str(paymentStatus), isCommercePaymentsOrder);
                    continue;
                }

                currencyCode = paymentInfo.Currency;

                // if currency code was not provided, use default
                if (!currencyCode)
                {
                    currencyCode = _defaultCurrencyCode;
                }

                AmountCur paymentAmount = paymentInfo.Amount;
                AmountCur paymentAmountCurrency = CurrencyExchangeHelper::amount(abs(paymentAmount), currencyCode);
                str paymentMode = paymentInfo.PaymentType;
                str cardType = paymentInfo.CardType;
                boolean prePayment = paymentInfo.Prepayment;
                AmountCur authorizedAmount = paymentInfo.AuthorizedAmount;
                RetailChannelRecId channel = paymentInfo.ChannelRecordId;

                // If the payment returned is a linked refund, create records in the CreditCardAuthTrans and MCRCustPaymTable; when required.
                boolean isOmniChannelPaymentsEnabled = RetailSharedParameters::find().EnableOmniChannelPayments;
                CreditCardAuthTransRefRecId creditCardAuthTransRefId;
                if (paymentAmount < 0 && linkedPaymentRefRecId && isOmniChannelPaymentsEnabled)
                {
                    str creditCardAuthorization = paymentInfo.CreditCardAuthorization;
                    str creditCardCaptureToken = paymentInfo.CreditCardCaptureToken;

                    str paymentSdkXml = creditCardCaptureToken ? creditCardCaptureToken : creditCardAuthorization;

                    creditCardAuthTransRefId = RetailTransactionPaymentsHelper::handleLinkedRefund(
                        isCallCenterOrder || isCommercePaymentsOrder,
                        salesTable,
                        paymentStatus,
                        currencyCode,
                        paymentMode,
                        cardType,
                        prePayment,
                        linkedPaymentRefRecId,
                        paymentCaptured,
                        paymentAmount,
                        authorizedAmount,
                        channel,
                        false,
                        paymentSdkXml,
                        MCRCustPaymStatus::Paid);
                }
                else if (isCommercePaymentsOrder)
                {
                    McrCustPaymTable mcrCustPaymTable;
                    container _existingDeclinedPayments = conNull();
                    container _newPayments = conNull();

                    // Create MCR CustPaymTable corresponding to the refunds or captured payments made towards Commerce Payments Order
                    [mcrCustPaymTable, _existingDeclinedPayments, _newPayments] =
                        RetailTransactionPaymentsHelper::createCallCenterPayment(
                                salesTable,
                                paymentInfo,
                                false,
                                MCRCustPaymStatus::Paid);

                    // Record the credit card CAPTURE transaction details in CreditCardAuthTrans if payment Info contains Card Authorization XML.
                    RetailTransactionPaymentsHelper::recordCreditCardAuthorizationCapture(salesTable, paymentInfo, mcrCustPaymTable, CreditCardOperation::AuthorizeAndCapture);

                    eventSource.EventWritePaymentsRefundedPaymentOnCustomerOrderPaymentCancellationForCommerceEnabledOrder(salesTable.RecId, mcrCustPaymTable.RecId);
                }

                // Set individual voucher for each payment
                if (RetailCancelCustomerOrderMultipleVouchersSettlementFlight::instance().isEnabled())
                {
                    _voucher = NumberSeq::newGetNum(CustParameters::numRefCustPaymVoucher()).num();
                }
                else
                {
                    if (!_voucher)
                    {
                        _voucher = NumberSeq::newGetNum(CustParameters::numRefCustPaymVoucher()).num();
                    }
                }

                // Refund for the order %1
                ledgerJournalTrans = RetailTransactionPaymentsHelper::CreateLedgerJournalTransForPayment(_ledgerJournalTable, salesTable, currencyCode, _voucher, prePayment);
                RetailTransactionPaymentsHelper::setCustomerOrderJournalForTender(_storeId, paymentMode, ledgerJournalTrans, cardType);
                ledgerJournalTrans.Txt = strFmt("@RET260964", salesTable.SalesId);

                if (paymentAmount < 0)
                {
                    // refund the customer
                    ledgerJournalTrans.AmountCurDebit = paymentAmountCurrency;
                }
                else
                {
                    // customer needs to pay (charge amount was greater than deposit)
                    ledgerJournalTrans.AmountCurCredit = paymentAmountCurrency;
                }

                // Populate fields that link <c>LedgerJournalTrans</c> to <c>SalesTable</c> and <c>CreditCardAuthTrans</c>.
                ledgerJournalTrans.SalesOrderId = _salesId;
                ledgerJournalTrans.CreditCardAuthTransRefId = creditCardAuthTransRefId;

                // If the payment is a prepayment and tax on prepayment property is set to true, set the tax group and item tax group.
                if (prePayment && CustParameters::find().TaxOnPrepayment)
                {
                    // We cannot guarantee that a Tax grpup was specified in the header, but the first line of the order
                    // is sufficient to infere the Tax group that "should" be in the header.
                    SalesLine salesLine = SalesLine::findLineCreationSequence(_salesId, 1);

                    //If Tax Group is not found on first sales lines, leave it empty
                    ledgerJournalTrans.TaxGroup = salesLine ? salesLine.TaxGroup : '';

                    // default ITG value for the company.
                    ledgerJournalTrans.TaxItemGroup = TaxParameters::find().TaxItemGroup;
                }

                ledgerJournalTrans.insert();

                if (isIndia)
                {
                    RetailTransactionService::setTaxInformationForJournalLine_IN(ledgerJournalTrans, _storeId);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitCallCenterPayment</Name>
				<Source><![CDATA[
    internal static MCRCustPaymTable splitCallCenterPayment(
        SalesTable _salesTable,
        MCRCustPaymTable _originalMCRCustPaymTable,
        MCRCustPaymStatus _newPaymentStatus = MCRCustPaymStatus::NotSubmitted)
    {
        MCRCustPaymTable newMCRCustPaymTable;
        Amount unpostedAmount = _originalMCRCustPaymTable.getUnpostedAmount();

        try
        {
            if (! _originalMCRCustPaymTable || ! _salesTable)
            {
                // Log error
                eventSource.EventWritePaymentsIncorrectSplitPayment(_originalMCRCustPaymTable.RecId, _salesTable.RecId);
                return newMCRCustPaymTable;
            }

            if (unpostedAmount > 0 && _originalMCRCustPaymTable.PostedAmount > 0)
            {
                ttsbegin;
                // Create new MCRCustPaymTable with originalMCRCustPaymTable's residual unposted amount
                newMCRCustPaymTable = _originalMCRCustPaymTable.data();
                newMCRCustPaymTable.Status = _newPaymentStatus;
                newMCRCustPaymTable.Amount = unpostedAmount;
                newMCRCustPaymTable.PostedAmount = 0.00;
                newMCRCustPaymTable.LineNum = MCRCustPaymTable::getNextLineNum(_salesTable.RecId, _salesTable.TableId);
                newMCRCustPaymTable.OrigRefundRecID = 0;
                // Credit Card payments with status above NotSubmitted are all "credit card processed"...
                newMCRCustPaymTable.IsCreditCardProcessed = NoYes::Yes;
                newMCRCustPaymTable.insert();
                ttscommit;

                switch(_newPaymentStatus)
                {
                    case MCRCustPaymStatus::Authorized:
                    if (newMCRCustPaymTable.getUnpostedAmount() > 0.00)
                        {
                            if (CreditCardProcess::mcrDoPreAuth(newMCRCustPaymTable))
                            {
                                // Log MCRCustPaymTable authorization SUCCESS
                                eventSource.EventWritePaymentsReAuthUnpostedAmountForNonDeclinedPaymentSuccess_V2(_salesTable.RecId, newMCRCustPaymTable.RecId);
                            }
                            else
                            {
                                ttsbegin;
                                newMCRCustPaymTable.reread();
                                newMCRCustPaymTable.selectForUpdate();
                                newMCRCustPaymTable.IsCreditCardProcessed = NoYes::No;
                                newMCRCustPaymTable.update();
                                ttscommit;

                                // Log MCRCustPaymTable authorization Failure
                                eventSource.EventWritePaymentsReAuthUnpostedAmountForNonDeclinedPaymentFailed_V2(_salesTable.RecId, newMCRCustPaymTable.RecId);
                            }
                        }
                        break;
                    // Add implementation for other McrCustPaymStatus based of need.
                    case MCRCustPaymStatus::Declined:
                    default:
                }
            }
        }
        catch
        {
            eventSource.EventWritePaymentsCrditCardSplitFailed(_originalMCRCustPaymTable.RecId, newMCRCustPaymTable.RecId, _salesTable.RecId);
        }

        return newMCRCustPaymTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCallCenterPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a <C>MCRCustPaymTable</C> record (call center sales payment).
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c>table buffer.</param>
    /// <param name = "_paymentInfo">The PaymentInfo object with the payment details.</param>
    /// <param name = "_isReturnOrder">Is this a return order? (Y/N).</param>
    /// <param name = "_mcrCustPaymStatus">The status of the new payment.</param>
    /// <param name = "_existingDeclinedPayments">A container to include declined payments on the sales order. Optional.(optional)</param>
    /// <param name = "_newPayments">A container with new payments for the sales order. Optional.</param>
    /// <returns>a container with the <C>MCRCustPaymTable</C> buffer, the _existingDeclinePayments and _newPayments containers.</returns>
    internal static container createCallCenterPayment(
        SalesTable _salesTable,
        PaymentInfo _paymentInfo,
        boolean _isReturnOrder,
        MCRCustPaymStatus _mcrCustPaymStatus = MCRCustPaymStatus::NotSubmitted,
        container _existingDeclinedPayments = conNull(),
        container _newPayments = conNull())
    {
        return RetailTransactionPaymentsHelper::createCallCenterPaymentRecord(
            _salesTable,
            _paymentInfo.PaymentStatusValue, // Implict marshaling from System.Int32 to native X++ Int
            _paymentInfo.Currency,
            _paymentInfo.PaymentType,
            _paymentInfo.CardType,
            _paymentInfo.Prepayment,
            _paymentInfo.LinkedPaymentRefRecId,
            _paymentInfo.PaymentCaptured,
            _paymentInfo.Amount,
            _paymentInfo.AuthorizedAmount,
            _paymentInfo.ChannelRecordId,
            _isReturnOrder,
            _mcrCustPaymStatus,
            _existingDeclinedPayments,
            _newPayments,
            _paymentInfo.RoundingDifference);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCallCenterPaymentRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a <C>MCRCustPaymTable</C> record (call center sales payment).
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c>table buffer.</param>
    /// <param name = "_paymentStatus">The payment status.</param>
    /// <param name = "_currency">The currency.</param>
    /// <param name = "_paymentType">The payment type.</param>
    /// <param name = "_cardType">The card type.</param>
    /// <param name = "_isPrepayment">Indicates whether the payment is a prepayment.</param>
    /// <param name = "_linkedPaymentRefRecId">The linked payment reference record identifier.</param>
    /// <param name = "_isPaymentCaptured">Indicates whether the payment is captured.</param>
    /// <param name = "_amount">The payment amount.</param>
    /// <param name = "_authorizedAmount">The payment authorized amount.</param>
    /// <param name = "_authorizationChannel">The channel where the payment was authorized.</param>
    /// <param name = "_isReturnOrder">Is this a return order? (Y/N).</param>
    /// <param name = "_mcrCustPaymStatus">The status of the new payment.</param>
    /// <param name = "_existingDeclinedPayments">A container to include declined payments on the sales order. Optional.(optional)</param>
    /// <param name = "_newPayments">A container with new payments for the sales order. Optional.</param>
    /// <param name = "_paymentRoundingDifference">The payment rounding difference. Optional.</param>
    /// <returns>a container with the <C>MCRCustPaymTable</C> buffer, the _existingDeclinePayments and _newPayments containers.</returns>
    internal static container createCallCenterPaymentRecord(
        SalesTable _salesTable,
        RetailTenderLineStatus _paymentStatus,
        str _currency,
        str _paymentType,
        str _cardType,
        boolean _isPrepayment,
        int64 _linkedPaymentRefRecId,
        boolean _isPaymentCaptured,
        real _amount,
        real _authorizedAmount,
        RetailChannelRecId _authorizationChannel,
        boolean _isReturnOrder,
        MCRCustPaymStatus _mcrCustPaymStatus = MCRCustPaymStatus::NotSubmitted,
        container _existingDeclinedPayments = conNull(),
        container _newPayments = conNull(),
        real _paymentRoundingDifference = 0)
    {
        MCRCustPaymTable mcrCustPaymTable;
        boolean isCommercePaymentsOrder = RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName());

        // Only Authorizations and captures are allowed for Call center payment creation (Both authorized/declined)
        if (_paymentStatus != RetailTenderLineStatus::PendingCommit && _paymentStatus != RetailTenderLineStatus::Committed)
        {
            eventSource.EventWritePaymentsCallCenterPaymentCreationFailureWithWrongStatus(_salesTable.RecId, enum2Str(_paymentStatus));
            return  [mcrCustPaymTable, _existingDeclinedPayments, _newPayments];
        }

        try
        {
            ttsbegin;
            mcrCustPaymTable.clear();
            mcrCustPaymTable.Channel        = isCommercePaymentsOrder && _authorizationChannel ? _authorizationChannel : _salesTable.retailSalesTable().RetailChannel;
            mcrCustPaymTable.CurrencyCode   = _currency;
            mcrCustPaymTable.TenderTypeId   = _paymentType;
            mcrCustPaymTable.RefTableId     = _salesTable.TableId;
            mcrCustPaymTable.RefRecId       = _salesTable.RecId;
            mcrCustPaymTable.IsPrepay       = _isPrepayment && !_isReturnOrder;
            mcrCustPaymTable.CardTypeId     = isCommercePaymentsOrder ? RetailTransactionPaymentsHelper::determineCardTypeFromTender(mcrCustPaymTable.TenderTypeId,
                                                                                                            mcrCustPaymTable.Channel,
                                                                                                            _cardType)
                                                                                                : _cardType;
            mcrCustPaymTable.Status         = _mcrCustPaymStatus;
            mcrCustPaymTable.CustPaymType   = MCRCustPaymTable::getMCRTypeFromTender( mcrCustPaymTable.TenderTypeId,
                                                                                      mcrCustPaymTable.Channel,
                                                                                      mcrCustPaymTable.CardTypeId);

            mcrCustPaymTable.CustAccount    =  RetailTransactionPaymentsHelper::findCustAccountForPaymentRecord(_salesTable);

            // Set linked refund related fields if LinkedPaymentRefRecId is set.
            if (_linkedPaymentRefRecId)
            {
                CreditCardAuthTrans creditCardAuthTrans = CreditCardAuthTrans::find(_linkedPaymentRefRecId);
                MCRCustPaymTable linkedMCRPaymTable = MCRCustPaymTable::findByRecID(creditCardAuthTrans.MCRPaymRecId);
                mcrCustPaymTable.OrigRefundRecID = linkedMCRPaymTable.RecId;
                mcrCustPaymTable.PaymInfoRecId = linkedMCRPaymTable.PaymInfoRecId;
                mcrCustPaymTable.PaymInfoTableId = linkedMCRPaymTable.PaymInfoTableId;
            }

            switch (_mcrCustPaymStatus)
            {
                case MCRCustPaymStatus::NotSubmitted:
                case MCRCustPaymStatus::Authorized:

                    mcrCustPaymTable.Amount = CurrencyExchange::round(_authorizedAmount, _currency);
                    break;

                case MCRCustPaymStatus::Declined:

                        mcrCustPaymTable.Amount = CurrencyExchange::round(
                        (_authorizedAmount == RetailTenderLineStatus::PendingCommit ? _authorizedAmount : _amount), _currency);

                    // Add new call center payment to declined payemnts list
                    _existingDeclinedPayments = conIns(_existingDeclinedPayments, conLen(_existingDeclinedPayments) + 1, mcrCustPaymTable.RecId);
                    break;

                case MCRCustPaymStatus::Paid:
                case MCRCustPaymStatus::Posted:

                    mcrCustPaymTable.Amount = CurrencyExchange::round(_amount, _currency);

                    if (_amount >= 0)
                    {
                        // Add new call center payment to New payments list
                        _newPayments = conIns(_newPayments, conLen(_newPayments) + 1, mcrCustPaymTable.RecId);
                    }

                    // Set posted Amount for paid and posted payments. On Account payments should not have a posted amount.
                    if (RetailPaymentsCustomerAccountPaymentBalanceToggle::instance().isEnabled() && mcrCustPaymTable.CustPaymType == MCRCustPaymType::OnAccount)
                    {
                        mcrCustPaymTable.PostedAmount = 0;
                    }
                    else
                    {
                        mcrCustPaymTable.PostedAmount = mcrCustPaymTable.Amount;
                    }

                    // Prevent overriding the status field after it has been already set.
                    if (!RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName()))
                    {
                        mcrCustPaymTable.Status = MCRCustPaymStatus::Posted;
                    }

                    break;
            }


            if (mcrCustPaymTable.CustPaymType == MCRCustPaymType::Check)
            {
                // if the payment type is check, check numer is mandatory.
                mcrCustPaymTable.CheckNumber = '999';
            }

            if (_isPaymentCaptured)
            {
                mcrCustPaymTable.IsCreditCardProcessed = NoYes::Yes;
            }

            mcrCustPaymTable.RoundingDifference = _paymentRoundingDifference;

            mcrCustPaymTable.insert();

            ttscommit;
        }
        catch
        {
            eventSource.EventWritePaymentsCallCenterPaymentCreationError(_salesTable.RecId);
        }

        return [mcrCustPaymTable, _existingDeclinedPayments, _newPayments];
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustAccountForPaymentRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine customer account to use for MCRCustPaymTable payment record
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c>table buffer.</param>
    /// <returns>Customer account to use in MCRCustPaymTable payment record</returns>
    internal static CustAccount findCustAccountForPaymentRecord(SalesTable _salesTable)
    {

        if( FeatureStateProvider::isFeatureEnabled(RetailPaymentsCreatePaymentOnInvoiceAccountFlight::instance())
                && RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName())
                && _salesTable
                && _salesTable.InvoiceAccount
                && _salesTable.InvoiceAccount != _salesTable.CustAccount)
        {
            return _salesTable.InvoiceAccount;
        }

        return _salesTable ? _salesTable.CustAccount : null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineCardTypeFromTender</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines card type from tendertypeid and channel when card type is empty.
    /// </summary>
    /// <param name = "_tenderTypeId">The tender type id.</param>
    /// <param name = "_channel">The channel where the payment originated.</param>
    /// <param name = "_cardType">The card type id.</param>
    /// <returns>The retail card type.</returns>
    internal static RetailCardTypeId determineCardTypeFromTender(RetailTenderTypeId _tenderTypeId,
                                                                RetailChannelRecId _channel,
                                                               RetailCardTypeId _cardType = '')
    {
        RetailCardTypeId retailCardTypeId = _cardType;

        if(retailCardTypeId == '')
        {
            RetailStoreTenderTypeTable      retailStoreTenderTypeTable;
            RetailStoreTenderTypeCardTable  retailStoreTenderTypeCardTable;

            if(_tenderTypeId && _channel)
            {
                // determine cardtype based on tendertype
                select firstonly RecId from retailStoreTenderTypeTable
                    where retailStoreTenderTypeTable.Function == RetailTenderFunction::Card
                       && retailStoreTenderTypeTable.Channel == _channel
                       && retailStoreTenderTypeTable.TenderTypeId == _tenderTypeId
                    join cardTypeId from retailStoreTenderTypeCardTable
                        where retailStoreTenderTypeCardTable.TenderTypeId == retailStoreTenderTypeTable.TenderTypeId
                           && retailStoreTenderTypeCardTable.Channel == retailStoreTenderTypeTable.Channel;

                retailCardTypeId = retailStoreTenderTypeCardTable.cardTypeId;

                eventSource.EventWritePaymentsDeterminedCardTypeForChannelTenderType(_channel, _tenderTypeId, retailCardTypeId);
            }
        }

        return retailCardTypeId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalNewPayments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the total of New payments
    /// </summary>
    /// <param name = "_newPayments">A container with <c>MCRCustPaymTable</c> RecIds for New payments.</param>
    /// <returns>The total amount of New payments.</returns>
    internal static Amount getTotalNewPayments(container _newPayments)
    {
        MCRCustPaymTable mcrCustPaymTableLocal;
        Amount totalNewPayments = 0;
        RefRecId currRecId;

        for (int counter = 1 ; counter <= conLen(_newPayments); counter++)
        {
            currRecId = conPeek(_newPayments, counter);
            select Amount from mcrCustPaymTableLocal
                where mcrCustPaymTableLocal.RecId == currRecId;

            if (mcrCustPaymTableLocal)
            {
                totalNewPayments += mcrCustPaymTableLocal.Amount;
            }
        }

        return totalNewPayments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalExistingDeclinedPayments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the total of Declined payments
    /// </summary>
    /// <param name = "_existingDeclinedPayments">A container with <c>MCRCustPaymTable</c> RecIds for declined payments.</param>
    /// <returns>The total amount of declined payments.</returns>
    internal static Amount getTotalExistingDeclinedPayments(container _existingDeclinedPayments)
    {
        MCRCustPaymTable mcrCustPaymTableLocal;
        Amount totalExistingDeclinedPayments = 0;
        RefRecId currRecId;

        for (int counter = 1 ; counter <= conLen(_existingDeclinedPayments); counter++)
        {
            currRecId = conPeek(_existingDeclinedPayments, counter);
            select Amount from mcrCustPaymTableLocal
                where mcrCustPaymTableLocal.RecId == currRecId;

            if (mcrCustPaymTableLocal)
            {
                totalExistingDeclinedPayments += mcrCustPaymTableLocal.Amount;
            }
        }

        return totalexistingDeclinedPayments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustCallCenterPayments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes final adjustments related to call center payments.
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c> buffer.</param>
    /// <param name = "_isReturnOrder">is this a return order? (Y/N).</param>
    /// <param name = "_existingDeclinedPayments">A container with all declined payments.</param>
    /// <param name = "_newPayments">A container with all new payments.</param>
    /// <param name = "_isCommercePaymentsOrder">Whether the payment is for a customer order from POS or e-commerce.</param>
    internal static void adjustCallCenterPayments(
        SalesTable _salesTable,
        boolean    _isReturnOrder,
        container  _existingDeclinedPayments,
        container  _newPayments,
        boolean    _isCommercePaymentsOrder
        )
    {
        MCRCustPaymTable localMCRCustPaymTable;

        // Find a call center channel, in case this is a call center order
        RetailMCRChannelTable callCenterUsedForOrderCreation =  RetailMCRChannelTable::findChannelBySalesTable(_salesTable);

        // Create a container to store eventual declined residual amount payments.
        container remainingBalanceDeclinedPayments;
        if ((callCenterUsedForOrderCreation &&
            _salesTable.mcrIsCallCenter() &&
            callCenterUsedForOrderCreation.MCREnableOrderCompletion) ||
            _isCommercePaymentsOrder)
        {
            ttsbegin;

            // Calculate the Remaining Balance for the Sales Order, if any...
            // The Remaining Balance is the (Total of existing declined/error payments - New payments created in the channel)
            Amount remainingBalance =
                RetailTransactionPaymentsHelper::getTotalExistingDeclinedPayments(_existingDeclinedPayments) -
                RetailTransactionPaymentsHelper::getTotalNewPayments(_newPayments);

            // Process residual un-authorized amounts using different tokens
            // The strategy is to retry authorize cards in descending order of LineNum to get tokens from the newer payments first
            if (remainingBalance > 0.00)
            {
                // Create a PaymentInfo to record the call center payment details
                PaymentInfo paymentInfo = new PaymentInfo();
                paymentInfo.PaymentStatusValue = RetailtenderLineStatus::PendingCommit;
                paymentInfo.CreditCardProcessorStatusValue = CreditCardProcessorStatus::Approved;
                paymentInfo.PaymentType = int2Str(MCRCustPaymType::CreditCard);
                paymentInfo.Currency =  Ledger::accountingCurrency(CompanyInfo::current());
                paymentInfo.Prepayment = NoYes::No;
                paymentInfo.PaymentCaptured = NoYes::No;
                paymentInfo.PaymentRefRecId = 0;

                // Loop over all declined MCRCustPaymTable in LineNum descending order,
                // creating new payments and authorizing them up to the limit of the original declined payments
                // and no more than the remaining balance.
                while select localMCRCustPaymTable
                    order by localMCRCustPaymTable.LineNum desc
                    where localMCRCustPaymTable.RefRecId == _salesTable.RecId                &&
                          localMCRCustPaymTable.CustPaymType == MCRCustPaymType::CreditCard &&
                          localMCRCustPaymTable.CurrencyCode == paymentInfo.Currency        &&
                          localMCRCustPaymTable.Status == MCRCustPaymStatus::Declined
                {
                    // Consider only call center payments listed on the existingDeclinedPayments
                    if (conFind(_existingDeclinedPayments, localMCRCustPaymTable.RecId) != 0)
                    {
                        // Allocate amount up to the limit of original authorization
                        paymentInfo.Amount = min(remainingBalance, localMCRCustPaymTable.Amount);

                        // create Call center payment for remaining balance...
                        MCRCustPaymTable newCallCenterPayment;
                        [newCallCenterPayment] = RetailTransactionPaymentsHelper::createCallCenterPayment(
                                _salesTable,
                                paymentInfo,
                                _isReturnOrder,
                                MCRCustPaymStatus::NotSubmitted);

                        newCallCenterPayment.reread();
                        newCallCenterPayment.selectForUpdate();

                        // Link token from the current declined payment to the newly created call center payment
                        newCallCenterPayment.PaymInfoTableId = localMCRCustPaymTable.PaymInfoTableId;
                        newCallCenterPayment.PaymInfoRecId = localMCRCustPaymTable.PaymInfoRecId;

                        // Try to authorize new call center payment with card token from the current record
                        // on the query of previous declined credit card payments
                        if ( newCallCenterPayment.getUnpostedAmount() > 0.00)
                        {
                            if (!CreditCardProcess::mcrDoPreAuth(newCallCenterPayment))
                            {
                                // Add payments that failed to authorize into remainingBalanceDeclinedPayments container
                                remainingBalanceDeclinedPayments = conIns(remainingBalanceDeclinedPayments, conLen(remainingBalanceDeclinedPayments) + 1, newCallCenterPayment.RecId);

                                // Log authorization failure
                                eventSource.EventWritePaymentsRemainingBalanceAuthFailure(newCallCenterPayment.RecId);
                            }
                        }

                        //update remaining balance
                        remainingBalance -= paymentInfo.Amount;

                        // Store new call center payment with link to successful (or last card token) authorized.
                        newCallCenterPayment.update();

                        // If all remaining balance is authorized, stop re-auth loop
                        if ( remainingBalance <= 0.00)
                        {
                            break;
                        }
                    }
                }
            }

            // delete all declined call center payments from existingDeclinedPayments
            while select forupdate localMCRCustPaymTable
                    order by localMCRCustPaymTable.LineNum desc
                    where localMCRCustPaymTable.RefRecId == _salesTable.RecId               &&
                          localMCRCustPaymTable.CustPaymType == MCRCustPaymType::CreditCard &&
                          localMCRCustPaymTable.Status == MCRCustPaymStatus::Declined
            {
                // Consider only call center payments listed on the existingDeclinedPayments
                if ( (conFind(_existingDeclinedPayments, localMCRCustPaymTable.RecId) != 0))
                {
                    localMCRCustPaymTable.delete();

                    // Log deletion
                    eventSource.EventWritePaymentsCallCenterDeclinedPaymentDeleted(localMCRCustPaymTable.RecId);
                }
            }

            // Delete all call center payments with ZERO amount and posted amount
            delete_from localMCRCustPaymTable
                where localMCRCustPaymTable.RefRecId == _salesTable.RecId &&
                      localMCRCustPaymTable.Amount == 0.00 &&
                      localMCRCustPaymTable.PostedAmount == 0.00;

            // Adjust Call center payments Line numbers to remove eventual gaps in numbering
            // and set posted status for fully posted payments.
            RetailTransactionPaymentsHelper::adjustCallCenterPaymentLines(_salesTable, _isCommercePaymentsOrder);

            // If the remaining unauthorized balance is still greater than 0,
            // or if any remaningBalance payment failed to authorize, put the order ON-HOLD
            if (remainingBalance > 0.00 || conLen(remainingBalanceDeclinedPayments) != 0)
            {
                ttsbegin;
                _salesTable.reread();
                _salesTable.selectForUpdate();
                _salesTable.MCROrderStopped = true;
                _salesTable.update();
                ttscommit;

                eventSource.EventWritePaymentsSetMCROrderStoppedToTrue(_salesTable.RecId);
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustCallCenterPaymentLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjust individual call center order payments, removing eventual gaps in numbers and setting correct status.
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c> table buffer.</param>
    /// <param name = "_isCommercePaymentsOrder">The <c>SalesTable</c> table buffer.</param>
    internal static void adjustCallCenterPaymentLines(SalesTable _salesTable, boolean _isCommercePaymentsOrder)
    {
        MCRCustPaymTable mcrCustPaymTable;

        select count(RecId) from mcrCustPaymTable
            where mcrCustPaymTable.RefRecId == _salesTable.RecId;

        // Set total payments counter
        int64 paymentCounter = mcrCustPaymTable.RecId;

        // Loop over all payments in descendin order of Line number
        ttsbegin;
        while select forupdate mcrCustPaymTable
            order by mcrCustPaymTable.LineNum desc
            where mcrCustPaymTable.RefRecId == _salesTable.RecId
        {
            // Set the Line number to the value on payment counter
            mcrCustPaymTable.LineNum = paymentCounter;

            // Set The posted status for fully posted payments
            if (mcrCustPaymTable.Amount == mcrCustPaymTable.PostedAmount)
            {
                if (_isCommercePaymentsOrder && mcrCustPaymTable.CustPaymType != MCRCustPaymType::OnAccount)
                {
                    mcrCustPaymTable.Status = MCRCustPaymStatus::Paid;
                    eventSource.EventWritePaymentsUpdatedPaymentLineStatusWhenAdjustingCallCenterPayment(_salesTable.RecId, _isCommercePaymentsOrder, mcrCustPaymTable.RecId, enum2Str(MCRCustPaymStatus::Paid));
                }
                else if (mcrCustPaymTable.CustPaymType == MCRCustPaymType::Check)
                {
                    mcrCustPaymTable.Status = MCRCustPaymStatus::Paid;
                    eventSource.EventWritePaymentsUpdatedPaymentLineStatusWhenAdjustingCallCenterPayment(_salesTable.RecId, _isCommercePaymentsOrder, mcrCustPaymTable.RecId, enum2Str(MCRCustPaymStatus::Paid));
                }
                else
                {
                    mcrCustPaymTable.Status = MCRCustPaymStatus::Posted;
                    eventSource.EventWritePaymentsUpdatedPaymentLineStatusWhenAdjustingCallCenterPayment(_salesTable.RecId, _isCommercePaymentsOrder, mcrCustPaymTable.RecId, enum2Str(MCRCustPaymStatus::Posted));
                }
            }

            // Update database
            mcrCustPaymTable.update();

            // Decrement payment counter
            paymentCounter--;
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPaymentLinks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create Payment Links.
    /// </summary>
    /// <param name = "_salesId">The sales id.</param>
    /// <param name = "_cardTypeId">The card type.</param>
    /// <param name = "_tenderTypeId">The tender type.</param>
    /// <param name = "_ledgerJournalTransRecId">The recId for <c>LedgerJournalTrans</c> table buffer.</param>
    /// <param name = "_creditCardAuthTrans">The <c>CreditCardAuthTrans</c> for the  charge.</param>
    internal static void createPaymentLinks(
        SalesId             _salesId,
        RetailCardTypeId    _cardTypeId,
        RetailTenderTypeId  _tenderTypeId,
        RefRecId            _ledgerJournalTransRecId,
        CreditCardAuthTrans _creditCardAuthTrans)
    {
        ttsbegin;

        // Insert/Update RetailCreditCardAuthTrans with card type and tender type for the payment
        RetailCreditCardAuthTrans retailCreditCardAuthTrans = RetailCreditCardAuthTrans::findOrCreate(_creditCardAuthTrans, _cardTypeId, _tenderTypeId);

        // Update LedgerJournalTrans.Retail with Sales Id and  link to Capture charge (CreditCardAuthTrans)
        LedgerJournalTrans  ledgerJournalTrans = LedgerJournalTrans::findRecId(_ledgerJournalTransRecId, true);

        if (ledgerJournalTrans)
        {
            ledgerJournalTrans.CreditCardAuthTransRefId = _creditCardAuthTrans.RecId;
            ledgerJournalTrans.SalesOrderId = _salesId;
            ledgerJournalTrans.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the payment references on the MCRCustPaymTable record as per the payment operation type.
    /// </summary>
    /// <param name = "_paymentOperationId">The payment operation identifier.</param>
    /// <param name = "_mcrCustPaymTable">The MCRCustPaymTable record.</param>
    /// <param name = "_paymentInfo">The object containing the payment details.</param>
    internal static void setPaymReference(int _paymentOperationId, MCRCustpaymTable _mcrCustPaymTable, PaymentInfo _paymentInfo)
    {
        ttsbegin;
        _mcrCustPaymTable.reread();
        _mcrCustPaymTable.selectForUpdate();

        // Link McrCustPaymTable with different tables based on tenderType.
        switch(_paymentOperationId)
        {
            case RetailPosOperationHelper::payGiftCardOperation():
                // Set the payment reference for only internal gift cards.
                boolean isExternalGiftCardTenderType = RetailTransactionPaymentsHelper::isExternalGiftCardTenderType(_paymentInfo.ChannelRecordId, _paymentInfo.PaymentType);
                if (!isExternalGiftCardTenderType)
                {
                    _mcrCustPaymTable.PaymInfoTableId = tableNum(RetailGiftCardTable);
                    _mcrCustPaymTable.PaymInfoRecId = RetailGiftCardTable::find(_paymentInfo.GiftCardId).RecId;
                    _mcrCustPaymTable.update();
                }

                break;
            case RetailPosOperationHelper::payCreditMemoOperation():
                _mcrCustPaymTable.PaymInfoTableId = tableNum(RetailCreditVoucherTable);
                _mcrCustPaymTable.PaymInfoRecId = RetailCreditVoucherTable::find(_paymentInfo.CreditMemoId).RecId;
                _mcrCustPaymTable.update();
                break;
            case RetailPosOperationHelper::payLoyaltyCardOperation():
                _mcrCustPaymTable.PaymInfoTableId = tableNum(RetailLoyaltyCard);
                _mcrCustPaymTable.PaymInfoRecId = RetailLoyaltyCard::findByCardNumber(_paymentInfo.LoyaltyCardId).RecId;
                _mcrCustPaymTable.update();
                break;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCallCenterOrCommercePaymentsEnabledOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the sales order originated in a Call Center or has a Commerce payment.
    /// </summary>
    /// <param name = "_salesTable">The sales order.</param>
    /// <returns>True if either the sales order originated in a Call Center or has a Commerce payment. Otherwise, false.</returns>
    [Replaceable(false)]
    public static boolean isCallCenterOrCommercePaymentsEnabledOrder(SalesTable _salesTable)
    {
        boolean mcrIsCallCenter = _salesTable.mcrIsCallCenter();

        // Commerce payment is a payment that is associated with a customer order that was generated at the POS or in the e-commerce storefront.
        boolean isCommercePaymentsEnabledForOrder = RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName());
        eventSource.EventWritePaymentsIsCallCenterOrCommercePaymentsEnabledOrder(_salesTable.RecId, mcrIsCallCenter, isCommercePaymentsEnabledForOrder);

        return  mcrIsCallCenter|| isCommercePaymentsEnabledForOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>str2boolean</Name>
				<Source><![CDATA[
    /// <summary>
    /// Helper method to convert string to boolean value.
    /// </summary>
    /// <param name = "_value">The string value.</param>
    /// <returns>The boolean value.</returns>
    private static boolean str2boolean(str _value)
    {
        boolean boolValue = false;
        _value = strrtrim(strltrim(strlwr(_value)));

        if (_value == 'true')
        {
            boolValue = true;
        }
        else if(_value == 'false')
        {
            boolValue = false;
        }
        else if(_value == '1')
        {
            boolValue = true;
        }
        else if(_value == '0')
        {
            boolValue = false;
        }
        else if(_value == 'yes')
        {
            boolValue = true;
        }
        else if(_value == 'no')
        {
            boolValue = false;
        }

        return boolValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleLinkedRefund</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates records in the the <c>CreditCardAuthTrans</c> and <c>MCRCustPaymTable</c> (for call center orders) for linked refunds.
    /// </summary>
    /// <param name = "_isCallCenterOrCommercePaymentOrder">Indicates whether the sales order is a call center order or commerce payment order.</param>
    /// <param name = "_salesTable">The sales table.</param>
    /// <param name = "_paymentStatus">The payment status.</param>
    /// <param name = "_currency">The currency.</param>
    /// <param name = "_paymentType">The payment type.</param>
    /// <param name = "_cardType">The card type.</param>
    /// <param name = "_isPrepayment">Indicates whether the payment is a prepayment.</param>
    /// <param name = "_linkedPaymentRefRecId">The linked payment reference record identifier.</param>
    /// <param name = "_isPaymentCaptured">Indicates whether the payment is captured.</param>
    /// <param name = "_amount">The payment amount.</param>
    /// <param name = "_authorizedAmount">The payment authorized amount.</param>
    /// <param name = "_channel">The channel of the payment.</param>
    /// <param name = "_isReturnOrder">Indicates whether the order is a return order.</param>
    /// <param name = "_paymentSdkXml">The payment SDK XML.</param>
    /// <param name = "_mcrCustPaymStatus">The payment status.</param>
    /// <returns>The <c>CreditCardAuthTrans</c> record identifier.</returns>
    private static RefRecId handleLinkedRefund(
        boolean _isCallCenterOrCommercePaymentOrder,
        SalesTable _salesTable,
        RetailTenderLineStatus _paymentStatus,
        str _currency,
        str _paymentType,
        str _cardType,
        boolean _isPrepayment,
        RefRecId _linkedPaymentRefRecId,
        boolean _isPaymentCaptured,
        AmountCur _amount,
        AmountCur _authorizedAmount,
        RetailChannelRecId _channel,
        boolean _isReturnOrder,
        str _paymentSdkXml,
        McrCustPaymStatus _mcrCustPaymStatus = MCRCustPaymStatus::NotSubmitted)
    {
        MCRCustPaymTable newCallCenterPayment;
        CreditCardAuthTrans refundTrans;

        if (_isCallCenterOrCommercePaymentOrder)
        {
            // Create a MCRCustPaymTable record if the order is a call center order.
            container result = RetailTransactionPaymentsHelper::createCallCenterPaymentRecord(
                _salesTable,
                _paymentStatus,
                _currency,
                _paymentType,
                _cardType,
                _isPrepayment,
                _linkedPaymentRefRecId,
                _isPaymentCaptured,
                _amount,
                _authorizedAmount,
                _channel,
                _isReturnOrder,
                _mcrCustPaymStatus);

            newCallCenterPayment = conPeek(result, 1);
        }

        // Record the refund.
        CreditCardPaymentProperties properties = CreditCardPaymentProperties::fromXmlString(_paymentSdkXml);
        CreditCard_ExtendedParameters creditCard_ExtendedParameters = CreditCard::extendedParameters;
        creditCard_ExtendedParameters.parmRecordRefund_OrigAuthTransId(_linkedPaymentRefRecId);

        // POS and E-Commerce card payments are not linked to the CreditCardProcessor, so we should clear this field.
        RecId bestMatchForCreditCardProcessor =  RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName())
                                     ? 0
                                     : CreditCard::FindBestMatchCreditCardProcessorId(properties);
        CreditCard::recordRefund(
            CreditCardProviderRefundResult::constructFromXmlString(_paymentSdkXml, abs(_amount)),
            _salesTable,
            bestMatchForCreditCardProcessor,
            true,
            strFmt("@SYS327114", _salesTable.SalesId),
            _paymentSdkXml,
            false,
            newCallCenterPayment);

        // Reset the OrigAuthTransId parameter so that it's not set incorrectly for another code path that might call recordRefund without setting the parameter.
        creditCard_ExtendedParameters.parmRecordRefund_OrigAuthTransId(0);

        // Mark the original payment as processed after the refund completes.
        CreditCardAuthTrans origCreditCardAuthTrans = CreditCardAuthTrans::find(_linkedPaymentRefRecId, true);

        if (_isCallCenterOrCommercePaymentOrder)
        {
            refundTrans = CreditCardAuthTrans::mcrFindLatest(newCallCenterPayment.RecId, true);
        }
        else
        {
            refundTrans = CreditCardAuthTrans::findLatest(_salesTable.SalesId, true);
        }

        eventSource.EventWritePaymentsLinkedRefundRecordedSuccessfully(_salesTable.RecId, refundTrans.RecId, newCallCenterPayment.RecId, _linkedPaymentRefRecId);

        return refundTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymentsMade</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines prepayment total made towards the salesId based on Cust Trans and ledger journals.
    /// </summary>
    /// <param name="_salesId">
    /// Sales order id the payment total is being retreived for.
    /// </param>
    /// <returns>
    /// The total of payments made for the sales order.
    /// </returns>
    internal static AmountCur paymentsMade(SalesId _salesId)
    {
        AmountCur paymentsMade;

        if(RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(SalesTable::find(_salesId), funcName()))
        {
            LedgerJournalTrans ledgerJournalTrans;
            LedgerJournalTable ledgerJournalTable;

            while select
            CustTransId
            from ledgerJournalTrans
            where ledgerJournalTrans.PaymReference == _salesId
                && ledgerJournalTrans.Prepayment == NoYes::Yes
            exists join ledgerJournalTable
                where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
                && ledgerJournalTable.Posted ==  NoYes::Yes
            {
                paymentsMade += -(CustTrans::find(ledgerJournalTrans.CustTransId).AmountCur);
            }
        }
        else
        {
            paymentsMade = RetailPrePaymentTrans::paymentsMade(_salesId);
        }

        return paymentsMade;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProviderTransactionIdFromAuthToken</Name>
				<Source><![CDATA[
    internal static str getProviderTransactionIdFromAuthToken(str _originalAuthTokenXmlString)
    {
        CreditCardPaymentProperty property;
        if(_originalAuthTokenXmlString)
        {
            CreditCardPaymentProperties properties = CreditCardPaymentProperties::fromXmlString(_originalAuthTokenXmlString);
            property = properties.find(
                Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_AuthorizationResponse(),
                Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.AuthorizationResponseProperties::get_ProviderTransactionId());
        }

        return property ? property.parmStringValue() : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordCreditCardAuthorizationCapture</Name>
				<Source><![CDATA[
    private static void recordCreditCardAuthorizationCapture(SalesTable _salesTable, PaymentInfo _paymentInfo, McrCustPaymTable _mcrCustPaymTable, CreditCardOperation _creditCardOperation, LedgerJournalTrans _ledgerJournalTrans = null)
    {
        boolean isCommercePaymentsOrder = RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName());

        // IF payment Info contains Card Authorization XML
        // Record the credit card CAPTURE transaction details in CreditCardAuthTrans
        if (_paymentInfo.CreditCardAuthorization || _paymentInfo.CreditCardCaptureToken)
        {
            // For backwards compatibility, use CreditCardAuthorization if CreditCardCaptureToken is not set.
            str paymentSdkXml = '';
            CreditCardProviderResult creditCardProviderCaptureResult;
            if (_paymentInfo.CreditCardCaptureToken)
            {
                paymentSdkXml = _paymentInfo.CreditCardCaptureToken;

                creditCardProviderCaptureResult = CreditCardProviderCaptureResult::constructFromXmlString(
                    _paymentInfo.CreditCardCaptureToken,
                    _paymentInfo.Amount,
                    RetailTransactionPaymentsHelper::getProviderTransactionIdFromAuthToken(_paymentInfo.CreditCardAuthorization));
            }
            else
            {
                paymentSdkXml = _paymentInfo.CreditCardAuthorization;
                creditCardProviderCaptureResult = CreditCardProviderAuthorizationResult::constructFromXmlString(_paymentInfo.CreditCardAuthorization);
            }

            CreditCardAuthTrans captureTrans, refundTrans;
            CreditCardPaymentProperties properties = CreditCardPaymentProperties::fromXmlString(_paymentInfo.CreditCardAuthorization);
            CreditCard_ExtendedParameters creditCard_ExtendedParameters = CreditCard::extendedParameters;
            // POS and E-Commerce card payments are not linked to the CreditCardProcessor, so we should clear this field.
            RecId bestMatchForCreditCardProcessor = isCommercePaymentsOrder
                                     ? 0
                                     : CreditCard::FindBestMatchCreditCardProcessorId(properties);

            // If the unique card id is not set then attempt to retrieve it from the payment card namespace.
            if (isCommercePaymentsOrder && !creditCardProviderCaptureResult.parmCreditCardUniqueCardId())
            {
                creditCardProviderCaptureResult = RetailTransactionPaymentsHelper::setUniqueCardIdFromPaymentCardNamespace(creditCardProviderCaptureResult, properties);
            }

            // If payment amount is greater than zero, record capture, else record a refund.
            if (_paymentInfo.Amount >= 0)
            {
                creditCard_ExtendedParameters.parmInitFromCreditCardProviderResult_ApprovedAmount(_paymentInfo.Amount);

                if (isCommercePaymentsOrder && _mcrCustPaymTable)
                {
                    boolean isExternalGiftCardTenderType = RetailTransactionPaymentsHelper::isExternalGiftCardTenderType(_paymentInfo.ChannelRecordId, _paymentInfo.PaymentType);
                    int paymInfoTableId = isExternalGiftCardTenderType ? tableNum(RetailExternalGiftCardTable) : tableNum(CreditCardCust);
                    int64 paymInfoRecId;

                    if (isExternalGiftCardTenderType)
                    {
                        RetailExternalGiftCardTable retailExternalGiftCardTable = RetailExternalGiftCardTable::createNew(MCRGiftCard::maskCardNum(_paymentInfo.GiftCardId), _paymentInfo.Amount, 0);
                        paymInfoRecId = retailExternalGiftCardTable.RecId;
                    }
                    else
                    {
                        // Persist token if present.
                        if (_paymentInfo.CreditCardToken)
                        {
                            CreditCardCust creditCardCust = RetailTransactionPaymentsHelper::createCreditCardForCustomer(_salesTable.InvoiceAccount, _salesTable, _paymentInfo.CreditCardToken);
                            paymInfoRecId = creditCardCust.RecId;
                        }
                    }

                    ttsbegin;
                    _mcrCustPaymTable.reread();
                    _mcrCustPaymTable.selectForUpdate();

                    _mcrCustPaymTable.PaymInfoTableId = paymInfoTableId;
                    _mcrCustPaymTable.PaymInfoRecId = paymInfoRecId;
                    _mcrCustPaymTable.update();

                    ttscommit;

                    eventSource.EventWritePaymentsLinkedNewPaymentAuthorizationCaptureForCommerceEnabledOrder(
                        _salesTable.RecId,
                        _mcrCustPaymTable.RecId,
                        paymInfoTableId,
                        paymInfoRecId,
                        isExternalGiftCardTenderType);
                }

                CreditCard::recordCapture(
                            creditCardProviderCaptureResult,
                            _salesTable,
                            '',
                            bestMatchForCreditCardProcessor,
                            _creditCardOperation == CreditCardOperation::AuthorizeAndCapture ? true : false,
                            true,
                            strFmt("@SYS327114", _salesTable.SalesId),
                            paymentSdkXml,
                            false,
                            _mcrCustPaymTable);

                // Reset the ApprovedAmount parameter so that it's not set incorrectly for another code path that might call recordCapture without setting the parameter.
                creditCard_ExtendedParameters.parmInitFromCreditCardProviderResult_ApprovedAmount(0);

                // Log record Capture
                eventSource.EventWritePaymentsRecordCaptureSuccessful(_paymentInfo.PaymentRefRecId, _salesTable.RecId);

                // Retrieve the capture record
                RetailMCRChannelTable callCenterUsedForOrderCreation = RetailMCRChannelTable::findChannelBySalesTable(_salesTable);
                if ((callCenterUsedForOrderCreation && _salesTable.mcrIsCallCenter()) || isCommercePaymentsOrder)
                {
                    captureTrans = CreditCardAuthTrans::mcrFindLatest(_mcrCustPaymTable.RecId, true);
                }
                else
                {
                    captureTrans = CreditCardAuthTrans::findLatest(_salesTable.SalesId, true);
                }

                // Create Retail Payment Links
                RetailTransactionPaymentsHelper::createPaymentLinks(
                        _salesTable.SalesId,
                        _paymentInfo.CardType,
                        _paymentInfo.PaymentType,
                        _ledgerJournalTrans.RecId,
                        captureTrans);
            }
            else
            {
                creditCard_ExtendedParameters.parmRecordRefund_OrigAuthTransId(_paymentInfo.LinkedPaymentRefRecId);

                CreditCard::recordRefund(
                        CreditCardProviderRefundResult::constructFromXmlString(paymentSdkXml, abs(_paymentInfo.Amount)),
                        _salesTable,
                        bestMatchForCreditCardProcessor,
                        true,
                        strFmt("@SYS327114", _salesTable.SalesId),
                        paymentSdkXml,
                        false,
                        _mcrCustPaymTable);

                // Reset the OrigAuthTransId parameter so that it's not set incorrectly for another code path that might call recordRefund without setting the parameter.
                creditCard_ExtendedParameters.parmRecordRefund_OrigAuthTransId(0);

                if (_mcrCustPaymTable)
                {
                    refundTrans = CreditCardAuthTrans::mcrFindLatest(_mcrCustPaymTable.RecId, true);
                    captureTrans = CreditCardAuthTrans::mcrFindRefundCharge(_mcrCustPaymTable.RecId);
                }
                else
                {
                    refundTrans = CreditCardAuthTrans::findLatest(_salesTable.SalesId, true);
                    captureTrans = CreditCardAuthTrans::findRefundCharge(_salesTable.SalesId);
                }

                // Create Retail Payment Links
                RetailTransactionPaymentsHelper::createPaymentLinks(
                        _salesTable.SalesId,
                        _paymentInfo.CardType,
                        _paymentInfo.PaymentType,
                        _ledgerJournalTrans.RecId,
                        refundTrans);

                // Log linked refund success
                eventSource.EventWritePaymentsLinkedRefundRecordSuccessful(_paymentInfo.PaymentRefRecId, _salesTable.RecId,  refundTrans.RecId, captureTrans.RecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processExistingCallCenterPaymentAuthorizationDecline</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes and records declined authorization that is tied to <c> McrCustPaymTable </c> buffer.
    /// </summary>
    /// <param name = "_salesTable">The <c>SalesTable</c> buffer.</param>
    /// <param name = "_creditCardAuthTrans">The <c>CreditCardAuthTrans</c> buffer.</param>
    /// <param name = "_paymentInfo">The payment Info instance with details of the declined authorization.</param>
    /// <param name = "_existingDeclinedPayments">The declined payments list.</param>
    /// <param name = "_mcrCustPaymTable">The <c>MCRCustPaymTable</c> buffer.</param>
    /// <returns>The updated declined payments list.</returns>
    private static container processExistingCallCenterPaymentAuthorizationDecline(SalesTable _salesTable, CreditCardAuthTrans _creditCardAuthTrans, PaymentInfo _paymentInfo, container _existingDeclinedPayments, McrCustPaymTable _mcrCustPaymTable)
    {
        MCRCustPaymTable declinedMCRCustPaymTable =
                                    RetailTransactionPaymentsHelper::updateCallCenterPaymentCapture(
                                        _salesTable,
                                        _creditCardAuthTrans,
                                        _paymentInfo,
                                        false,
                                        _mcrCustPaymTable);

        // Note: When a split happens, the original MCRCustPaymTable stores the Paid/Posted amount
        // The splitMCRCustPaymTable is going to record the declined payment.
        if (declinedMCRCustPaymTable)
        {
            // record CAPTURE DECLINED in creditCardAuthTrans
            // IF payment Info contains Card Authorization XML
            // Record the credit card CAPTURE transaction details in CreditCardAuthTrans
            if (_paymentInfo.CreditCardAuthorization)
            {
                CreditCardPaymentProperties properties = CreditCardPaymentProperties::fromXmlString(_paymentInfo.CreditCardAuthorization);

                // POS and E-Commerce card payments are not linked to the CreditCardProcessor, so we should clear this field.
                RecId bestMatchForCreditCardProcessor =  RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName())
                                     ? 0
                                     : CreditCard::FindBestMatchCreditCardProcessorId(properties);

                CreditCard::recordCapture( CreditCardProviderAuthorizationResult::constructFromXmlString(_paymentInfo.CreditCardAuthorization),
                                            _salesTable,
                                            '',
                                            bestMatchForCreditCardProcessor,
                                            false,
                                            false,
                                            strFmt("@SYS327114", _salesTable.SalesId),
                                            _paymentInfo.CreditCardAuthorization,
                                            false,
                                            declinedMCRCustPaymTable);

                eventSource.EventWritePaymentsRecordCaptureSuccessful(declinedMCRCustPaymTable.RecId, _salesTable.RecId);
            }

            // Add split payment into declined payments list
            _existingDeclinedPayments = conIns(_existingDeclinedPayments, conLen(_existingDeclinedPayments) + 1, declinedMCRCustPaymTable.RecId);
        }

        // If the capture is declined, mark the original authorization as EXPIRED
        if (!CreditCardAuthTrans::setAuthorizationExpired(_creditCardAuthTrans.RecId))
        {
            eventSource.EventWritePaymentsExpireAuthFailed(_creditCardAuthTrans.RecId);
        }

        return _existingDeclinedPayments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isExternalGiftCardTenderType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if a channel tender type is associated to an external gift card.
    /// </summary>
    /// <param name = "_channelRecId">The record identifier for the channel.</param>
    /// <param name = "_storeTenderTypeId">The channel tender type identifier to check.</param>
    /// <returns>True if the channel tender type is associated to an external gift card; otherwise false.</returns>
    internal static boolean isExternalGiftCardTenderType(int64 _channelRecId, str _storeTenderTypeId)
    {
        RetailStoreTenderTypeTable rsttt = RetailStoreTenderTypeTable::find(_channelRecId, _storeTenderTypeId);
        boolean result = false;

        if (rsttt && rsttt.posOperation == RetailPosOperationHelper::payGiftCardOperation() && rsttt.ConnectorName)
        {
            result = true;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRefundsOverMultipleCapturesEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns if Retail payments refund can be captured over multiple refunds is set on RetailSharedConfiguration or RetailConfiguration.
    /// </summary>
    /// <returns>True if Retail payments refund can be captured over multiple refunds; otherwise, false.</returns>
    internal static boolean isRefundsOverMultipleCapturesEnabled()
    {
        return FeatureStateProvider::isFeatureEnabled(RetailPaymentsRefundOverMultipleCapturesFeature::instance()) || RetailConfigurationParameters::getRefundsOverMultipleCaptureFlag();
    }

]]></Source>
			</Method>
			<Method>
				<Name>set2list</Name>
				<Source><![CDATA[
    /// <summary>
    /// Helper method to convert Set to List.
    /// </summary>
    /// <param name = "_inputSet">The set.</param>
    /// <returns>The list.</returns>
    private static List set2list(Set _inputSet)
    {
        List outputList = new List(Types::String);

        if (_inputSet)
        {
            SetEnumerator inputSetEnumerator = _inputSet.getEnumerator();
            while(inputSetEnumerator.moveNext())
            {
                outputList.addEnd(inputSetEnumerator.current());
            }
        }

        return outputList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>upsertPrepaymentsForSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines amount to be settled along with upserting CustTransOpen in SpecTrans.
    /// </summary>
    /// <param name = "custTransForPrepayment">The <c>CustTrans</c> buffer to be processed.</param>
    /// <param name = "custTransOpenForPrepayment">The <c>CustTransOpen</c> buffer to be processed.</param>
    /// <param name = "specTransManagerForPrepayment"> An instance of <c>SpecTransManager</c> class.</param>
    /// <param name = "currencyExchangeHelper"> An instance of <c>CurrencyExchangeHelper</c> class.</param>
    /// <param name = "totalMarkedPrepayments">The total amount of prepayments that have already been settled.</param>
    /// <param name = "amountAvailableToSettle">The total amount of prepayments that can be settled.</param>
    /// <returns> The amount of prepayment settled.</returns>
    internal static Amount upsertPrepaymentsForSettlement(CustTrans custTransForPrepayment, CustTransOpen custTransOpenForPrepayment, SpecTransManager specTransManagerForPrepayment, CurrencyExchangeHelper currencyExchangeHelper, Amount totalMarkedPrepayments, Amount amountAvailableToSettle)
    {
        Amount transAmountInCompanyCur, transAmountToSettle;
        boolean isUseCompanyCurrencyToTotalizeSettlementAmount = RetailOrdersFeatureControl::isUseCompanyCurrencyToTotalizeSettlementAmount();

        // Convert transaction amount to company currency
        transAmountInCompanyCur = currencyExchangeHelper.calculateTransactionToAccounting(custTransForPrepayment.CurrencyCode, custTransForPrepayment.AmountCur - custTransForPrepayment.SettleAmountCur, false);

        if (abs(transAmountInCompanyCur) > amountAvailableToSettle)
        {
            transAmountToSettle = currencyExchangeHelper.calculateAccountingToTransaction(custTransForPrepayment.CurrencyCode, amountAvailableToSettle * (custTransForPrepayment.AmountCur > 0 ? 1 : -1), false);
        }
        else
        {
            transAmountToSettle = currencyExchangeHelper.calculateAccountingToTransaction(custTransForPrepayment.CurrencyCode, transAmountInCompanyCur, false);
        }

        if (specTransManagerForPrepayment.exist(custTransOpenForPrepayment.company(), custTransOpenForPrepayment.TableId, custTransOpenForPrepayment.RecId))
        {
            specTransManagerForPrepayment.updateSettleAmount(
                            custTransOpenForPrepayment.company(),
                            custTransOpenForPrepayment.TableId,
                            custTransOpenForPrepayment.RecId,
                            transAmountToSettle);
        }
        else
        {
            specTransManagerForPrepayment.insert(
                            custTransOpenForPrepayment.company(),
                            custTransOpenForPrepayment.TableId,
                            custTransOpenForPrepayment.RecId,
                            transAmountToSettle,
                            custTransForPrepayment.CurrencyCode);
        }

        return isUseCompanyCurrencyToTotalizeSettlementAmount ? transAmountInCompanyCur : transAmountToSettle;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateIfCommercePaymentsOrderWithCurrencyPayments</Name>
				<Source><![CDATA[
    internal static void validateIfCommercePaymentsOrderWithCurrencyPayments(SalesTable _salesTable)
    {
        boolean isCommercePaymentsOrder = RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName());

        if (isCommercePaymentsOrder)
        {
            MCRCustPaymTable mcrCustPaymTable;
            RetailStoreTenderTypeTable retailStoreTenderTypeTable;

            // validate if any mcrcustpaymtable is tied to currency tendertype with posOperation currency.
            while select mcrCustPaymTable
                    where mcrCustPaymTable.RefRecId == _salesTable.RecId &&
                    mcrCustPaymTable.RefTableId == _salesTable.TableId
                join retailStoreTenderTypeTable
                    where retailStoreTenderTypeTable.Channel == mcrCustPaymTable.Channel &&
                    retailStoreTenderTypeTable.tenderTypeId == mcrCustPaymTable.TenderTypeId &&
                    retailStoreTenderTypeTable.posOperation == RetailPosOperationHelper::payCurrencyOperation()
            {
                // Abort the cancellation for Commerce Orders with Currency payments.
                eventSource.EventWritePaymentsWithCurrencyPayment(_salesTable.RecId, isCommercePaymentsOrder);
                throw error("@Retail:RetailCommercePaymentOrderWithCurrencyCancellationError");
            }
        }

        eventSource.EventWritePaymentsCommerceEnabledOrderWithoutCurrencyPayment(_salesTable.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSettlementTypeUpdateRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the settlement type of the sales order needs to be corrected.
    /// </summary>
    /// <param name = "_salesTable">The sales order.</param>
    /// <param name = "_prepayAmount">The prepayment amount.</param>
    /// <returns>True if the settlement type needs to be updated. Otherwise, false.</returns>
    internal static boolean isSettlementTypeUpdateRequired(SalesTable _salesTable, Amount _prepayAmount)
    {
        return _prepayAmount != 0.0
            && _salesTable.SettleVoucher == SettlementType::None
            && !CustParameters::find().AutoSettle;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSettlementType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the settlement type of the sales order.
    /// </summary>
    /// <param name = "_salesTable">The sales order.</param>
    /// <param name = "_settlementType">The settlement type. Optional.</param>
    internal static void setSettlementType(SalesTable _salesTable, SettlementType _settlementType = SettlementType::SelectedTransact)
    {
        SalesTable salesTableLocal = SalesTable::find(_salesTable.SalesId, true);

        if (salesTableLocal.RecId != 0)
        {
            salesTableLocal.SettleVoucher = _settlementType;

            ttsbegin;
            salesTableLocal.update();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChannel</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method finds and returns Record ID of the store for which selected payment method is configured.
    ///     If payment record is not empty then we will try to find if selected payment method is configured for the call center.
    ///     If payment method doesn't exists for call center then we will try to find if selected payment method is configured for the store.
    /// </summary>
    /// <param name="_custOrderInfo">
    ///     The customerOrderInfo object instance.
    /// </param>
    /// <param name="_mcrCustPaymTable">
    ///     <c>MCRCustPaymTable</c> record which contains payment information.
    /// </param>
    /// <param name="_tenderTypeId">
    ///     Retail Tender Type.
    /// <param name="_cardTypeId">
    ///     Retail Tender Card Type. Default to empty.
    /// </param>
    /// <return>
    ///     Record ID of the store for which selected payment method is configured if exists.
    /// </return>
    internal static RetailChannelRecId getChannel(CustomerOrderInfo _custOrderInfo, MCRCustPaymTable _mcrCustPaymTable, RetailTenderTypeId _tenderTypeId, RetailCardTypeId _cardTypeId)
    {
        RetailChannelRecId channel;

        if (_mcrCustPaymTable.RecId)
        {
            channel = RetailTransactionPaymentsHelper::getChannelForTenderType(_mcrCustPaymTable.Channel, _tenderTypeId, _cardTypeId);
        }

        if (!channel)
        {
            channel = RetailTransactionPaymentsHelper::getChannelForTenderType(str2Int64(_custOrderInfo.ChannelRecordId), _tenderTypeId, _cardTypeId);
        }

        return channel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChannelForTenderType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method finds and returns Record ID of the store for which selected payment method is configured.
    /// </summary>
    /// <param name="_storeRecId">
    ///     Store recid to lookup store.
    /// </param>
    /// <param name="_tenderTypeId">
    ///     Retail Tender Type.
    /// <param name="_cardTypeId">
    ///     Retail Tender Card Type.
    /// </param>
    /// <return>
    ///     Record ID of the store for which selected payment method is configured if exists.
    /// </return>
    private static RetailChannelRecId getChannelForTenderType(RecId _storeRecId, RetailTenderTypeId _tenderTypeId, RetailCardTypeId _cardTypeId)
    {
        RetailChannelRecId channel;

        if (_storeRecId)
        {
            RetailStoreTenderTypeCardTable storeTenderCardTable = RetailStoreTenderTypeCardTable::find(_storeRecId, _tenderTypeId, _cardTypeId);

            if (storeTenderCardTable.RecId)
            {
                channel = storeTenderCardTable.Channel;
            }

            if (!channel || (channel && !storeTenderCardTable.LedgerDimension))
            {
                RetailStoreTenderTypeTable storeTenderTable = RetailStoreTenderTypeTable::find(_storeRecId, _tenderTypeId);

                if (storeTenderTable.RecId)
                {
                    channel = storeTenderTable.Channel;
                }
            }
        }

        return channel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostToLedgerJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the payment is valid to post to ledger.
    /// </summary>
    /// <param name = "_paymentInfo">The payment information.</param>
    /// <returns>True if the payment is valid to post; otherwise, false.</returns>
    internal static boolean canPostToLedgerJournal(PaymentInfo _paymentInfo)
    {
        boolean canPost = true;
        boolean isZeroAmount = _paymentInfo && _paymentInfo.Amount == 0;

        if (isZeroAmount && RetailPaymentsSkipZeroAmountJournalLineFlight::instance().isEnabled())
        {
            // Payment should not be posted if the skip posting zero amount flight is enabled.
            canPost = false;
        }

        return canPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareJsonForLedgerJournalTransactionData</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method creates serialized json string of ledger journal transaction data for event logging.
    /// </summary>
    /// <param name = "_journalTrans">
    /// Buffer of <c>LedgerJournalTrans</c> table.
    /// </param>
    /// <returns>
    /// Serialized json string.
    /// </returns>
    internal static str prepareJsonForLedgerJournalTransactionData(LedgerJournalTrans _journalTrans)
    {
        Map ledgerJournalTransactionMap = new Map(Types::String, Types::String);
        ledgerJournalTransactionMap.insert(fieldStr(LedgerJournalTrans,AccountType), any2Str(_journalTrans.AccountType));
        ledgerJournalTransactionMap.insert(fieldStr(LedgerJournalTrans,LedgerDimension), any2Str(_journalTrans.LedgerDimension));
        ledgerJournalTransactionMap.insert(fieldStr(LedgerJournalTrans,DefaultDimension), any2Str(_journalTrans.DefaultDimension));
        ledgerJournalTransactionMap.insert(fieldStr(LedgerJournalTrans,OffsetAccountType), any2Str(_journalTrans.OffsetAccountType));
        ledgerJournalTransactionMap.insert(fieldStr(LedgerJournalTrans,OffsetLedgerDimension), any2Str(_journalTrans.OffsetLedgerDimension));
        ledgerJournalTransactionMap.insert(fieldStr(LedgerJournalTrans,OffsetDefaultDimension), any2Str(_journalTrans.OffsetDefaultDimension));
        ledgerJournalTransactionMap.insert(fieldStr(LedgerJournalTrans,PaymMode), _journalTrans.PaymMode);
        ledgerJournalTransactionMap.insert(fieldStr(LedgerJournalTrans,Voucher), _journalTrans.Voucher);
        ledgerJournalTransactionMap.insert(fieldStr(LedgerJournalTrans,CurrencyCode), _journalTrans.CurrencyCode);
        ledgerJournalTransactionMap.insert(fieldStr(LedgerJournalTrans,TransDate), any2Str(_journalTrans.TransDate));
        ledgerJournalTransactionMap.insert(fieldStr(LedgerJournalTrans,ExchRate), any2Str(_journalTrans.ExchRate));
        ledgerJournalTransactionMap.insert(fieldStr(LedgerJournalTrans,ReportingCurrencyExchRate), any2Str(_journalTrans.ReportingCurrencyExchRate));
        
        return JSONSerializerExtension::serializeClass(ledgerJournalTransactionMap);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>