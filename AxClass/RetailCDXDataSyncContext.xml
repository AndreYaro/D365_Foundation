<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailCDXDataSyncContext</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The class <c>RetailCDXDataSyncContext</c> contains information and logic required for running a download job related sync operations.
/// </summary>
/// <remarks>
/// This preexisting class would be the equivalent of RetailCDXJobDownloadSourceContext following the new naming convention.
///</remarks>
class RetailCDXDataSyncContext
{
    RetailConnJobID         jobID;
    RefRecId                channelSchemaRecID;
    boolean                 effectiveDataOnly;
    RetailCDXRowVersion     lastSyncVer;
    RetailCDXRowVersion     currentSyncVer;
    RetailCDXSessionNumber  session; // not used anymore.

    private Map sessions;
    private Set currentSessions;

    RefRecId        scheduleRecID;
    RefRecId        dataGroupRecID;

    container       targetDataStore;
    container       leContainer;

    private boolean             readingOnly;
    private boolean             deleteExistingData;
    private boolean             runUpdateStatistics;
    private boolean             isInitSync;
    private boolean             allowSkipDataSync;
    private boolean             hasSubjobToBeSkipped;
    private boolean             hasDataFilteringEntityEnabled;
    private int64               minCTValidVer;
    private container           errors;

    RetailCdxIsScheduledFullPackage scheduledAsFullSync;
    RetailCdxIsScheduledFullPackage switchedToFullSync;

    Map tempDBTables;
    private Map fullSyncFilteredRecordsTempTableMap;
    private Map deltaSyncFilteredRecordsTempTableMap;

    private Set fullSyncProcessedTableNodeKeys;
    private Set deltaSyncProcessedTableNodeKeys;
    private Set processedChangeTrackingTableKeys;
    private Set executedCTQueriesTracker;

    private boolean isCacheBasedQueryEnabled;
    private boolean initializationResult;
    private boolean isPackageGenerationOrderByUniqueClusteredIndexEnabled;
    private boolean isSortCdxPackageByPrimaryIndexEnabled;
    private boolean isDateFilterEnabled;
    private boolean shouldUpdateRowVersion;

    RetailCDXChangeRefTable1 ref1;
    RetailCDXChangeRefTable2 ref2;
    RetailCDXChangeRefTable2 ref2_base;
    RetailCDXChangeRefTable3 ref3;
    RetailCDXTargetChannel   targetChannel;
    private RetailTmpCDXTargetLegalEntity targetLegalEntityTempTable;
    private RetailTmpCDXTargetLegalEntity targetLegalEntityTempTable_newLEs;

    private Set newChannelSet;
    private RetailCDXTargetChannel targetChannel_baseline;
    private container leContainerBaseline;
    private Set newLESet;

    boolean refTableInitialized;
    boolean useLegacyTransport; // not used anymore
    guid correlationId;
    private RefRecId batchJobId;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>cleanUp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleans up the data in <c>RetailConnSCChangeRefTable</c> table.
    /// </summary>
    public void cleanUp()
    {
        this.cleanData();

        MapEnumerator enumerator;
        RetailCDXTempDBTableWrapper tempDBTable;

        ref1.dispose();
        ref2.dispose();
        ref2_base.dispose();
        ref3.dispose();
        targetChannel.dispose();
        targetLegalEntityTempTable.dispose();
        targetLegalEntityTempTable_newLEs.dispose();

        enumerator = tempDBTables.getEnumerator();

        while (enumerator.moveNext())
        {
            tempDBTable = enumerator.currentValue();
            tempDBTable.cleanUp();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChannelSchema</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns channel schema rec id.
    /// </summary>
    /// <returns>
    /// Rec Id of channel schema.
    /// </returns>
    public RefRecId getChannelSchema()
    {
        return channelSchemaRecID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPhysicalNameChangeRefTable1</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the staging table name for the physical table.
    /// </summary>
    /// <returns>
    /// Staging table name.
    /// </returns>
    public str getPhysicalNameChangeRefTable1()
    {
        str tableName;
        tableName = ref1.getPhysicalTableName();
        return tableName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPhysicalNameChangeRefTable2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the staging table name for the physical table.
    /// </summary>
    /// <returns>
    /// Staging table name.
    /// </returns>
    public str getPhysicalNameChangeRefTable2()
    {
        str tableName;
        tableName = ref2.getPhysicalTableName();
        return tableName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPhysicalNameChangeRefTable2Base</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the staging table name for the physical table storing baseline full sync data.
    /// </summary>
    /// <returns>
    /// Staging table name.
    /// </returns>
    public str getPhysicalNameChangeRefTable2Base()
    {
        str tableName;
        tableName = ref2_base.getPhysicalTableName();
        return tableName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPhysicalNameChangeRefTable3</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the staging table name for the physical table.
    /// </summary>
    /// <returns>
    /// Staging table name.
    /// </returns>
    public str getPhysicalNameChangeRefTable3()
    {
        str tableName;
        tableName = ref3.getPhysicalTableName();
        return tableName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeRefTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize change reference table
    /// </summary>
    public void initializeRefTable()
    {
        if (!refTableInitialized)
        {
            select ref1;
            select ref3;
            select targetChannel;
            select targetLegalEntityTempTable;
            select targetLegalEntityTempTable_newLEs;

            // these temp tables are only required for the legacy approach so skip creating the if we are using cache based query approach.
            if (!this.paramIsCacheBasedQueryEnabled())
            {
                select ref2;
                select ref2_base;
            }

            refTableInitialized = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSessionNumbers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current context session numbers.
    /// </summary>
    public Set getSessionNumbers()
    {
        Set sessionNumbers = new Set(Types::Int64);
        
        MapEnumerator sessionsEnumerator = sessions.getEnumerator();

        RetailCDXDataSyncContextSession currentSession;

        while (sessionsEnumerator.moveNext())
        {
            currentSession = sessionsEnumerator.currentValue();

            sessionNumbers.add(currentSession.parmSessionNumber());
        }

        return sessionNumbers;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentSessions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current selected sessions.
    /// </summary>
    /// <returns>The current selected sessions.</returns>
    public Set getCurrentSessions()
    {
        return currentSessions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInitialize</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal void postInitialize()
    {
        // This method is empty on purpose in order to enable extensibility.
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the new mapping of schedule provided.
    /// </summary>
    /// <param name="_scheduleRecID">
    /// Schedule rec id.
    /// </param>
    /// <param name="_dataGroupRecID">
    /// Data group rec id.
    /// </param>
    /// <param name="_jobID">
    /// Job id.
    /// </param>
    /// <param name="_lastSyncVer">
    /// Last sync version.
    /// </param>
    public void new(RefRecID _scheduleRecID, RefRecID _dataGroupRecID, RetailConnJobID _jobID, RetailCDXRowVersion _lastSyncVer)
    {
        if (!_dataGroupRecID)
        {
            // Data group is not specified
            throw error("@REX1579");
        }

        if (!_jobID)
        {
            // Job ID is not specified
            throw error("@REX1580");
        }

        sessions = new Map(Types::Enum, Types::Class);
        newLESet = new Set(Types::String);
        newChannelSet = new Set(Types::Int64);

        this.paramScheduleRecID(_scheduleRecID);
        this.paramDataGroupRecID(_dataGroupRecID);
        this.paramJobID(_jobID);
        this.paramLastSyncVer(_lastSyncVer);

        effectiveDataOnly = false;
        this.paramRunUpdateStatistics(true);

        // Map does not work
        tempDBTables = new Map(Types::String, Types::Class);
        refTableInitialized = false;

        this.paramScheduledAsFullSync(_lastSyncVer < 0);
        this.paramIsInitSync(_lastSyncVer < 0);

        // key is table Id, value is <c>RetailCDXTempDBTableWrapper</c> class instance which stores <c>RetailTmpCDXDataDistributionFilteredRecords</c> table instance.
        fullSyncFilteredRecordsTempTableMap = new Map(Types::String, Types::Class);
        deltaSyncFilteredRecordsTempTableMap = new Map(Types::String, Types::Class);

        // key is "NodeId_IsBaseLineSuffix"
        fullSyncProcessedTableNodeKeys = new Set(Types::String);
        deltaSyncProcessedTableNodeKeys = new Set(Types::String);

        executedCTQueriesTracker = new Set(Types::String);
        this.paramIsCacheBasedQueryEnabled(RetailCdxFeatureControl::isCacheBasedQueryEnabledPerChannelSchema(channelSchemaRecID));
        this.paramIsPackageGenerationOrderByUniqueClusteredIndexEnabled(RetailCdxFeatureControl::isPackageGenerationOrderByUniqueClusteredIndexEnabled());
        this.paramIsSortCdxPackageByPrimaryIndexEnabled(FeatureStateProvider::isFeatureEnabled(RetailCDXSortPackageByPrimaryIndexFeature::instance()));
        this.paramIsDateFilterEnabled(RetailCdxFeatureControl::isDateFilterEnabled());
        this.paramAllowSkipDataSync(RetailCDXDataSyncContext::shouldAllowSkipDataSync(_jobID));
        
        hasSubjobToBeSkipped = RetailConnSchedulerJobTable::hasAllowDataSyncSkipSubjobs(_jobID);
        hasDataFilteringEntityEnabled = RetailConnSchedulerJobTable::shouldFilterCdxEntityData(_jobID);

        this.postInitialize();
    }

]]></Source>
			</Method>
			<Method>
				<Name>openChangeRefTable1</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the change reference table cursor
    /// </summary>
    /// <returns>
    /// Change reference table cursor
    /// </returns>
    public RetailCDXChangeRefTable1 openChangeRefTable1()
    {
        return ref1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openChangeRefTable2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the change reference table cursor
    /// </summary>
    /// <returns>
    /// Change reference table cursor
    /// </returns>
    public RetailCDXChangeRefTable2 openChangeRefTable2()
    {
        return ref2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openChangeRefTable2Base</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the change reference table cursor for baseline full data sync.
    /// </summary>
    /// <returns>
    /// Change reference table cursor for baseline full data sync.
    /// </returns>
    public RetailCDXChangeRefTable2 openChangeRefTable2Base()
    {
        return ref2_base;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openChangeRefTable3</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the change reference table cursor
    /// </summary>
    /// <returns>
    /// Change reference table cursor
    /// </returns>
    public RetailCDXChangeRefTable3 openChangeRefTable3()
    {
        return ref3;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openTargetChannelTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the target channel table cursor
    /// </summary>
    /// <returns>
    /// Target channel table cursor
    /// </returns>
    public RetailCDXTargetChannel openTargetChannelTable()
    {
        return targetChannel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openTargetChannelTableBaseline</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the target channel table cursor containing the baseline channels excluding channels newly mapped to the datastore.
    /// </summary>
    /// <returns>
    /// Target channel table cursor
    /// </returns>
    internal RetailCDXTargetChannel openTargetChannelTableBaseline()
    {
        return targetChannel_baseline;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openTargetLegalEntityTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the target legal entity temp table cursor
    /// </summary>
    /// <returns>
    /// Target target legal entity temp table cursor
    /// </returns>
    internal RetailTmpCDXTargetLegalEntity openTargetLegalEntityTempTable()
    {
        return targetLegalEntityTempTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openTargetLegalEntityTempTableNewLEs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the target legal entity temp table cursor containing the new LEs.
    /// </summary>
    /// <returns>
    /// The target legal entity temp table cursor containing the new LEs.
    /// </returns>
    internal RetailTmpCDXTargetLegalEntity openTargetLegalEntityTempTableNewLEs()
    {
        return targetLegalEntityTempTable_newLEs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openTempDBTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or get the TempDB table cursor by table name.
    /// </summary>
    /// <param name="_tableName">
    /// Name of the TempDB table.
    /// </param>
    /// <returns>
    /// TempDB table cursor.
    /// </returns>
    public Common openTempDBTable(TableName _tableName)
    {
        RetailCDXTempDBTableWrapper tempTableWrapper;

        if (tempDBTables.exists(_tableName))
        {
            tempTableWrapper = tempDBTables.lookup(_tableName);
            return tempTableWrapper.getInstance();
        }
        else
        {
            tempTableWrapper = new RetailCDXTempDBTableWrapper(_tableName);

            tempDBTables.insert(_tableName, tempTableWrapper);

            return tempTableWrapper.getInstance();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramDataGroupRecID</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value of data group rec id.
    /// </summary>
    /// <param name="_dataGroupRecID">
    /// The value of <c>DataGroupRecId</c>; optional.
    /// </param>
    /// <returns>
    /// Data group rec id.
    /// </returns>
    public RefRecId paramDataGroupRecID(RefRecId _dataGroupRecID = dataGroupRecID)
    {
        dataGroupRecID = _dataGroupRecID;

        return dataGroupRecID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramDeleteExistingData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value of delete existing data.
    /// </summary>
    /// <param name="_deleteExistingData">
    /// The value of <c>_deleteExistingData</c>; optional.
    /// </param>
    /// <returns>
    /// Delete existing data.
    /// </returns>
    public boolean paramDeleteExistingData(boolean _deleteExistingData = deleteExistingData)
    {
        deleteExistingData = _deleteExistingData;

        return deleteExistingData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramNewLESet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the collection of new legal entities used by stores that are newly mapped to a target datastore after completion of the last data sync operation.
    /// </summary>
    /// <returns>
    /// The collection of new legal entities.
    /// </returns>
    /// <remarks>If the newly mapped store uses a legal entity which is used by another store which is already mapped to the target datastore then the legal entity will not be included in this list.</remarks>
    internal Set paramNewLESet(Set _newLESet = newLESet)
    {
        newLESet = _newLESet;

        return newLESet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramEffectiveDataOnly</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value for effective data in <c>RetailConnJobID</c>.
    /// </summary>
    /// <param name="_effectiveDataOnly">
    /// Value of effective data only;optinal.
    /// </param>
    /// <returns>
    /// Boolean value, true if effective data value exists; otherwise false.
    /// </returns>
    public boolean paramEffectiveDataOnly(boolean _effectiveDataOnly = effectiveDataOnly)
    {
        effectiveDataOnly = _effectiveDataOnly;

        return effectiveDataOnly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramNewChannelSet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the the collection of new store mapped to any target datastore in the current datagroup.
    /// </summary>
    /// <param name="_newChannelSet">
    /// The collection of new store mapped to any target datastore in the current datagroup.
    /// </param>
    /// <returns>
    /// The collection of new store mapped to any target datastore in the current datagroup.
    /// </returns>
    internal Set paramNewChannelSet(Set _newChannelSet = newChannelSet)
    {
        newChannelSet = _newChannelSet;

        return newChannelSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramJobID</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value for job ID in <c>RetailConnJobID</c>.
    /// </summary>
    /// <param name="_jobID">
    /// The value of <c>RetailConnJobID</c>; optional.
    /// </param>
    /// <returns>
    /// Job ID.
    /// </returns>
    public RetailConnJobID paramJobID(RetailConnJobID _jobID = jobID)
    {
        RetailConnSchedulerJobTable job;
        RetailConnChannelSchema channelSchema;

        jobID = _jobID;

        select RetailConnChannelSchema from job
        where job.jobId == jobID;

        channelSchemaRecID = job.RetailConnChannelSchema;

        return jobID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramLastSyncVer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value of last sync version.
    /// </summary>
    /// <param name="_lastSyncVer">
    /// The value of <c>lastSyncVer</c>; optional.
    /// </param>
    /// <returns>
    /// Last sync version
    /// </returns>
    public RetailCDXRowVersion paramLastSyncVer(RetailCDXRowVersion _lastSyncVer = lastSyncVer)
    {
        lastSyncVer = _lastSyncVer;

        if (_lastSyncVer < 0)
        {
            this.deleteExistingData = true;
        }

        return lastSyncVer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramScheduleRecID</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value of schedule rec id
    /// </summary>
    /// <param name="_scheduleRecID">
    /// The value of <c>RetailScheduleRecID</c>; optional.
    /// </param>
    /// <returns>
    /// Schedule rec id.
    /// </returns>
    public RefRecId paramScheduleRecID(RefRecId _scheduleRecID = scheduleRecID)
    {
        scheduleRecID = _scheduleRecID;

        return scheduleRecID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramRunUpdateStatistics</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value of Update Statistics.
    /// </summary>
    /// <param name="_runUpdateStatistics">
    /// The value of Update Statistics boolean; optional.
    /// </param>
    /// <returns>
    /// true if Run Update Statistics control is toggled on; false otherwise.
    /// </returns>
    public boolean paramRunUpdateStatistics(boolean _runUpdateStatistics = runUpdateStatistics)
    {
        runUpdateStatistics = _runUpdateStatistics;

        return runUpdateStatistics;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSessions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the related sessions for this context.
    /// </summary>
    /// <returns>The related sessions for this context.</returns>
    public Map getSessions()
    {
        return sessions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeSessions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the sessions based on the list of the target data stores.
    /// </summary>
    /// <param name = "_targetDataStore">The list of the target data stores.</param>
    /// <remarks>Although this is a container, real scenarios are either a single datastore or none (which uses the datagroup).</remarks>
    internal void initializeSessions(container _targetDataStore = targetDataStore)
    {
        if (conLen(_targetDataStore) > 0)
        {
            for (int i = 1; i <= conLen(_targetDataStore); ++i)
            {
                RefRecId dataStoreRecId = conPeek(_targetDataStore, i);

                if (dataStoreRecId)
                {
                    RetailConnDatabaseProfile databaseProfile = RetailConnDatabaseProfile::findByRecId(dataStoreRecId);

                    this.addDataStore(databaseProfile);
                }
            }
        }
        else
        {
            RetailConnDatabaseProfile dataStore;

            while select dataStore where dataStore.DataGroup == this.paramDataGroupRecID()
            {
                this.addDataStore(dataStore);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>beginSessions</Name>
				<Source><![CDATA[
    internal void beginSessions(str workDir)
    {
        MapEnumerator sessionsEnumerator = sessions.getEnumerator();

        RetailCDXDataSyncContextSession currentSession;

        while (sessionsEnumerator.moveNext())
        {
            currentSession = sessionsEnumerator.currentValue();

            Microsoft.Dynamics.Retail.CommerceDataExchange.DataPackage dataPackage;

            dataPackage = new Microsoft.Dynamics.Retail.CommerceDataExchange.DataPackage(workDir);
            dataPackage.SessionId = currentSession.parmSessionNumber();
            dataPackage.JobId = this.paramJobID();

            dataPackage.FinOpsBuildVersion = Microsoft.Dynamics.BusinessPlatform.ProductInformation.Provider.ProductInfoProvider::get_Provider().get_ApplicationBuildVersion();

            dataPackage.RunUpdateStatistics = this.paramRunUpdateStatistics();

            currentSession.parmDataPackage(dataPackage);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endSessions</Name>
				<Source><![CDATA[
    internal void endSessions(str _workDir, RetailCdxSessionLogger _logger)
    {
        MapEnumerator sessionsEnumerator = sessions.getEnumerator();

        while (sessionsEnumerator.moveNext())
        {
            RetailCDXDataSyncContextSession currentSession = sessionsEnumerator.currentValue();

            _logger.setSession(currentSession.parmSessionNumber());

            if (currentSession.parmTotalRowsAffected() > 0 || this.paramDeleteExistingData())
            {
                Microsoft.Dynamics.Retail.CommerceDataExchange.DataPackage dataPackage;
                dataPackage = currentSession.parmDataPackage();

                _logger.logDataPackageGenerationComplete(dataPackage.PackageId);

                Filename stagingFileName = strFmt('%1-R.zip', currentSession.parmSessionNumber());
                str stagingFilePath = System.IO.Path::Combine(_workDir, stagingFileName);

                _logger.logDataOutputStartCompressing();

                dataPackage.CompressDataPackage(stagingFilePath);

                // update file size
                System.IO.FileInfo sessionFileInfo = new System.IO.FileInfo(stagingFilePath);

                if (sessionFileInfo != null)
                {
                    RetailCDXFileSize fileSize = sessionFileInfo.Length;
                    currentSession.parmFileSize(fileSize);
                }

                _logger.logDataOutputFinishCompressing(currentSession.parmFileSize());

                // update file checksum
                RetailCDXCheckSum checkSum = Microsoft.Dynamics.Retail.SynchLibrary.Utility.FileCheck::GetChecksum(stagingFilePath);

                Filename targetFileName = RetailCDXDataSyncContext::generateDataFileName(this.paramDataGroupRecID(), currentSession.parmSessionNumber());

                _logger.logDataOutputStartUploading();

                RetailCDXFilePathOrGuid targetStorage = RetailCDXPackageStore::writePackage(this.paramDataGroupRecID(),
                                                                                            RetailCDXDownloadUpload::Download,
                                                                                            stagingFilePath,
                                                                                            targetFileName,
                                                                                            3);

                currentSession.parmTargetStorage(targetStorage);
                currentSession.parmCheckSum(checkSum);

                _logger.logDataOutputFinishUploading();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDeleteDataFileToSessions</Name>
				<Source><![CDATA[
    internal void addDeleteDataFileToSessions(str _axSourceTableName, str _deleteTargetTableName, str _dataFileName_delete, Set _extensionTableNames, int _rowsAffected)
    {
        SetEnumerator sessionsEnumerator = currentSessions.getEnumerator();

        while (sessionsEnumerator.moveNext())
        {
            RetailCDXDataSyncContextSession currentSession = sessionsEnumerator.current();

            currentSession.parmTotalRowsAffected(currentSession.parmTotalRowsAffected() + _rowsAffected);

            Microsoft.Dynamics.Retail.CommerceDataExchange.DataPackage dataPackage;
            Microsoft.Dynamics.Retail.CommerceDataExchange.DataFile deleteDataFile;

            dataPackage = currentSession.parmDataPackage();

            RetailConnSchedulerSubjobTable subjobTable;
            select  firstonly subJobId from subjobTable
                where subjobTable.RetailConnChannelSchema == channelSchemaRecID &&
                      subjobTable.AXTableName == _axSourceTableName;

            deleteDataFile = dataPackage.AddDeleteDataFile(_deleteTargetTableName, _dataFileName_delete, _axSourceTableName, subjobTable.subJobId);

            this.AddColumnInfoToDataFile(deleteDataFile);

            this.AddPrimaryIndexColumnsToDataFile(deleteDataFile);

            SetEnumerator setEnumerator = _extensionTableNames.getEnumerator();

            while (setEnumerator.moveNext())
            {
                RetailConnTableName currentTableName = setEnumerator.current();

                deleteDataFile.AddExtensionTable(currentTableName);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDataFileToSessions</Name>
				<Source><![CDATA[
    internal void addDataFileToSessions(Map _dataFileContextMap, str _axSourceTableName, str _targetTableName,  Set _extensionTableNames)
    {
        SetEnumerator sessionsEnumerator = currentSessions.getEnumerator();

        while (sessionsEnumerator.moveNext())
        {
            RetailCDXDataSyncContextSession currentSession = sessionsEnumerator.current();

            if (_dataFileContextMap.exists(currentSession.parmSessionType()))
            {
                RetailCDXDownloadSessionDataFileContext dataFileCtx = _dataFileContextMap.lookup(currentSession.parmSessionType());
                str dataFileName = System.IO.Path::GetFileName(dataFileCtx.parmDataFilePath());
                int rowsAffected = dataFileCtx.parmChannelSpecificRows();

                currentSession.parmTotalRowsAffected(currentSession.parmTotalRowsAffected() + rowsAffected);

                if (this.paramIsInitSync() || rowsAffected > 0)
                {
                    Microsoft.Dynamics.Retail.CommerceDataExchange.DataPackage dataPackage;
                    Microsoft.Dynamics.Retail.CommerceDataExchange.DataFile dataFile;

                    dataPackage = currentSession.parmDataPackage();

                    RetailConnSchedulerSubjobTable subjobTable;
                    select firstonly subJobId from subjobTable
                        where subjobTable.RetailConnChannelSchema == channelSchemaRecID &&
                              subjobTable.AXTableName == _axSourceTableName;

                    dataFile = dataPackage.AddDataFile(_targetTableName, dataFileName, this.paramDeleteExistingData(), _axSourceTableName, subjobTable.subJobId, rowsAffected);

                    this.AddColumnInfoToDataFile(dataFile);

                    this.AddPrimaryIndexColumnsToDataFile(dataFile);

                    SetEnumerator extensionTableNameSetEnumerator = _extensionTableNames.getEnumerator();

                    while (extensionTableNameSetEnumerator.moveNext())
                    {
                        RetailConnTableName currentExtensionTableName = extensionTableNameSetEnumerator.current();

                        dataFile.AddExtensionTable(currentExtensionTableName);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>AddPrimaryIndexColumnsToDataFile</Name>
				<Source><![CDATA[
    private void AddPrimaryIndexColumnsToDataFile(Microsoft.Dynamics.Retail.CommerceDataExchange.DataFile dataFile)
    {
        container pkAxFields = RetailConnReplicationUtilities::getAXPrimaryIndexColumnNames(dataFile.AXTableName);
        for (int i = 1; i <= conLen(pkAxFields); i++)
        {
            str toFieldName;
            str axFieldName = conPeek(pkAxFields, i);

            if (axFieldName == 'RecId')
            {
                toFieldName = 'RECID';
            }
            else if (axFieldName == 'DataAreaId')
            {
                toFieldName = 'DATAAREAID';
            }
            else
            {
                RetailConnSchedulerSubjobFieldList fieldMapping;
                select firstOnly toFieldName from fieldMapping
                    where fieldMapping.subjobId == dataFile.SubJobId && fieldMapping.fromFieldName == axFieldName;

                toFieldName = fieldMapping.toFieldName;
            }

            dataFile.AddPrimaryIndexColumnName(toFieldName);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>AddColumnInfoToDataFile</Name>
				<Source><![CDATA[
    private void AddColumnInfoToDataFile(Microsoft.Dynamics.Retail.CommerceDataExchange.DataFile dataFile)
    {
        RetailConnLocationDesignTableField designTableField;

        while select designTableField
                        where designTableField.locationTableName == dataFile.TargetTableName &&
                              designTableField.RetailConnChannelSchema == this.channelSchemaRecID
        {
            dataFile.AddColumnInfo(designTableField.fieldName, enum2Symbol(enumNum(RetailConnFieldTypeEnum), designTableField.fieldType), designTableField.fieldLength);
        }

        if (!RetailConnReplicationUtilities::isGlobalTable(dataFile.AXTableName))
        {
            DictType dataAreaIdEDT = new Dictionary().typeObject(extendedTypeNum(DataAreaId));
            dataFile.AddColumnInfo(RetailCDXConstants::DataAreaIdChannelSideName, enum2Symbol(enumNum(RetailConnFieldTypeEnum), RetailConnFieldTypeEnum::Text), dataAreaIdEDT.stringLen());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramExecutedCTQueriesTracker</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the Set obect which keeps track of executed change tracking queries.
    /// </summary>
    /// <param name="_executedCTQueriesTracker">The Set obect which keeps track of executed change tracking queries. </param>
    /// <returns>The Set obect which keeps track of executed change tracking queries. /returns>
    internal Set paramExecutedCTQueriesTracker(Set _executedCTQueriesTracker = executedCTQueriesTracker)
    {
        executedCTQueriesTracker = _executedCTQueriesTracker;

        return executedCTQueriesTracker;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeDownloadSessions</Name>
				<Source><![CDATA[
    internal void initializeDownloadSessions()
    {
        int dataStoresCount;
        RetailConnDatabaseProfile dataStore;

        select count(RecId)
            from dataStore
            where dataStore.DataGroup == this.paramDataGroupRecID();

        MapEnumerator sessionsEnumerator = sessions.getEnumerator();

        while (sessionsEnumerator.moveNext())
        {
            RetailCDXDownloadSessionType sessionType = sessionsEnumerator.currentKey();
            RetailCDXDataSyncContextSession currentSession = sessionsEnumerator.currentValue();
            RetailCDXDownloadSession sessionTable;

            dataStoresCount += currentSession.getDataStores().elements();

            ttsbegin;

            sessionTable.initValue();
            sessionTable.Session = currentSession.parmSessionNumber();
            sessionTable.DataGroup = this.paramDataGroupRecID();
            sessionTable.JobID = this.paramJobID();
            sessionTable.SyncRowVersion = this.paramLastSyncVer();
            sessionTable.CurrentRowVersion = this.paramCurrentSyncVer();
            sessionTable.Schedule = this.paramScheduleRecID();
            sessionTable.Status = RetailCDXDownloadSessionStatus::Started;
            sessionTable.SessionType = sessionType;
            sessionTable.BatchJobId = this.paramBatchJobId();

            if (this.paramIsInitSync())
            {
                sessionTable.IsScheduledFullPackage = NoYes::Yes;
            }

            sessionTable.insert();

            ttscommit;
        }

        // the overridden target data stores cannot represent the entire data group
        // do not update row version
        if (dataStoresCount == dataStore.RecId)
        {
            shouldUpdateRowVersion = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDownloadSessionsAsCreateFailed</Name>
				<Source><![CDATA[
    internal void setDownloadSessionsAsCreateFailed()
    {
        MapEnumerator sessionsEnumerator = sessions.getEnumerator();

        while (sessionsEnumerator.moveNext())
        {
            RetailCDXDataSyncContextSession currentSession = sessionsEnumerator.currentValue();

            if (!currentSession.parmSkipJobSync() && currentSession.parmSessionNumber())
            {
                RetailCDXDownloadSession sessionTable;
                ttsbegin;

                // update session info
                select forupdate sessionTable
                where sessionTable.Session == currentSession.parmSessionNumber();

                if (sessionTable)
                {
                    sessionTable.Status = RetailCDXDownloadSessionStatus::CreateFailed;
                    sessionTable.Message = this.getErrorMessages();
                    sessionTable.update();
                }

                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDownloadSessions</Name>
				<Source><![CDATA[
    internal void updateDownloadSessions()
    {
        this.updateRowVersion();

        this.setDownloadSessionsAsAvailable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDownloadSessionsAsAvailable</Name>
				<Source><![CDATA[
    internal void setDownloadSessionsAsAvailable()
    {
        MapEnumerator sessionsEnumerator = sessions.getEnumerator();

        while (sessionsEnumerator.moveNext())
        {
            RetailCDXDataSyncContextSession currentSession = sessionsEnumerator.currentValue();

            // update session info
            RetailCDXDownloadSession sessionTable;

            select forupdate sessionTable
                where sessionTable.Session == currentSession.parmSessionNumber();

            if (!sessionTable)
            {
                // The download session %1 was deleted and cannot be updated.
                throw error(strFmt("@Retail:UpdateDownloadSessionNotFoundMsg", currentSession.parmSessionNumber()));
            }

            int64 totalReplacedSessionCount = 0;
            RetailCDXRowsAffected rowsAffected = currentSession.parmTotalRowsAffected();

            if (rowsAffected > 0 || this.paramDeleteExistingData())
            {
                RefRecId sessionRecId = sessionTable.RecId;

                sessionTable.DataFileOutputPath = currentSession.parmTargetStorage();
                sessionTable.FileSize = currentSession.parmFileSize();
                sessionTable.CheckSum = currentSession.parmCheckSum();

                RetailCDXDownloadSessionStatus availableStatus = RetailCDXDownloadSessionStatus::Available;

                // insert DownloadSDataStore, only when this session is not reading only
                if (!this.paramReadingOnly())
                {
                    RetailCDXDownloadSessionDataStore sessionDataStoreTable;
                    RetailConnDatabaseProfile         datastore;

                    Set sessionDataStores = currentSession.getDataStores();

                    if (sessionDataStores.elements() > 0)
                    {
                        SetEnumerator sessionDataStoresEnumerator = sessionDataStores.getEnumerator();

                        while (sessionDataStoresEnumerator.moveNext())
                        {
                            RefRecId dataStoreRecId = sessionDataStoresEnumerator.current();

                            select RecId from dataStore
                            where dataStore.RecId == dataStoreRecId
                                && dataStore.DataGroup == this.paramDataGroupRecID();
   
                            // Only add new download sessions if the device was ever activated and if it had the initial download sessions created. If feature is disabled revert to old behavior
                            if ((datastore && !RetailCdxFeatureControl::isDelayedOfflineDownloadSessionCreationEnabled())
                                || (dataStore && dataStore.DataStoreType == RetailCDXDataStoreType::ChannelDatabase)
                                || (dataStore && dataStore.DataStoreType == RetailCDXDataStoreType::OfflineDatabase && dataStore.isActivatedOrWasActivated() && dataStore.hasAnyDownloadSession()))
                            {
                                sessionDataStoreTable.initValue();
                                sessionDataStoreTable.Session = sessionRecId;
                                sessionDataStoreTable.DataStore = dataStoreRecId;
                                sessionDataStoreTable.Status = availableStatus;
                                sessionDataStoreTable.insert();

                                // After the new sessionDataStores are created, if the download session dependency enforcement feature is enabled then find all pre-existing
                                // sessionDataStores whose content is now a subset of the newly created session and cancel them as they can be replaced by the new sessionDataStore.
                                //
                                // This scenario occurs when
                                //    1- Rerunning a failed session - which results in a package that contains all changes starting from the lastSyncRowVersion of the rerun session upto current changes.
                                //    2- Running a full sync which also results in a package that basically contains all changes contained in preexisting available/failed sessions.
                                //
                                //  In both the above cases the preexisting sessions which have a subset of the content of the new session need to be canceled and marked as replaced by the new session.
                                // (i.e. this can be thought of as Canceling the sessions that are REPLACED by a new session which has a superset of the required data.
                                if (RetailCdxFeatureControl::isDownloadSessionDependencyEnforcementEnabled())
                                {
                                    int64 replacedSessionCount = RetailCDXDataSync::cancelReplacedDownloadSessionDataStores(sessionTable, sessionDataStoreTable.DataStore);
                                    totalReplacedSessionCount += replacedSessionCount;
                                }
                            }
                        }
                    }
                    else
                    {
                        RetailTerminalTable retailTerminalTable;
                        RetailDevice retailDevice;
                        RetailCDXDownloadSessionDataStore existsSessionDataStore;
                        
                        if (RetailCdxFeatureControl::isDelayedOfflineDownloadSessionCreationEnabled())
                        {
                            insert_recordset sessionDataStoreTable(@Session, @DataStore, @Status)
                            select sessionRecId, RecId, availableStatus
                                from dataStore
                                    where dataStore.DataGroup == this.paramDataGroupRecID()
                                          && dataStore.DataStoreType == RetailCDXDataStoreType::ChannelDatabase;

                            // Join to find out active data stores only and only add sessions for active data stores or data stores which have been active before.
                            insert_recordset sessionDataStoreTable(@Session, @DataStore, @Status)
                            select sessionRecId, RecId, availableStatus
                                from dataStore
                                join retailTerminalTable
                                join retailDevice
                                exists join existsSessionDataStore
                                    where dataStore.DataGroup == this.paramDataGroupRecID()
                                          && retailDevice.Terminal == retailTerminalTable.terminalId
                                          && retailTerminalTable.OfflineDatabaseProfile == dataStore.RecId
                                          && (retailDevice.ActivationStatus == RetailDeviceActivationStatusBase::Activated
                                              | (retailDevice.DeactivatedDateTime != DateTimeUtil::minValue()))
                                          && existsSessionDataStore.DataStore == datastore.RecId
                                          && dataStore.DataStoreType == RetailCDXDataStoreType::OfflineDatabase;
                        }
                        else
                        {
                            insert_recordset sessionDataStoreTable(@Session, @DataStore, @Status)
                            select sessionRecId, RecId, availableStatus
                                from dataStore
                                where dataStore.DataGroup == this.paramDataGroupRecID();
                        }

                        if (RetailCdxFeatureControl::isDownloadSessionDependencyEnforcementEnabled())
                        {
                            totalReplacedSessionCount = RetailCDXDataSync::cancelReplacedDownloadSessionDataStores(sessionTable, 0);
                        }
                    }
                }

                sessionTable.RowsAffected = rowsAffected;
                sessionTable.Status = RetailCDXDownloadSessionStatus::Available;
                sessionTable.update();
            }
            else
            {
                sessionTable.DataFileOutputPath = '';
                sessionTable.RowsAffected = rowsAffected;
                sessionTable.Status = RetailCDXDownloadSessionStatus::NoData;
                sessionTable.update();
            }

            currentSession.parmReplacedSessionDataStoreCount(totalReplacedSessionCount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSessionsDataFiles</Name>
				<Source><![CDATA[
    internal void deleteSessionsDataFiles()
    {
        MapEnumerator sessionsEnumerator = sessions.getEnumerator();

        while (sessionsEnumerator.moveNext())
        {
            RetailCDXDataSyncContextSession currentSession = sessionsEnumerator.currentValue();

            RetailCDXPackageStore::deletePackage(this.paramDataGroupRecID(), RetailCDXDownloadUpload::Download, currentSession.parmTargetStorage());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ParamCurrentSyncVer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the current sync version.
    /// </summary>
    /// <param name = "_currentSyncVer">The current sync version.</param>
    /// <returns>The current sync version.</returns>
    internal RetailCDXRowVersion ParamCurrentSyncVer(RetailCDXRowVersion _currentSyncVer = currentSyncVer)
    {
        currentSyncVer = _currentSyncVer;

        return currentSyncVer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramLEContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the list of legal entities involved in the data sync.
    /// </summary>
    /// <param name = "_leContainer">The list of legal entities.</param>
    /// <returns>The list of legal entities.</returns>
    internal container paramLEContainer(container _leContainer = leContainer)
    {
        leContainer = _leContainer;

        return leContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramLEContainerBaseline</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the list of baseline legal entities involved in the data sync.
    /// </summary>
    /// <param name = "_leContainerBaseline">The list of baseline legal entities.</param>
    /// <returns>The list of baseline legal entities.</returns>
    /// <remarks>
    /// A baseline legal entity list contains all legal entities used by stores that were already mapped when the previous data sync operation occured.
    /// Any legal entity that is used by a store which is mapped to the datastore after the last data sync operation is completed is not part of the baseline.
    /// </remarks>
    internal container paramLEContainerBaseline(container _leContainerBaseline = leContainerBaseline)
    {
        leContainerBaseline = _leContainerBaseline;

        return leContainerBaseline;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramReadingOnly</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the flag indicating whether the session is for reading only.
    /// </summary>
    /// <param name = "_readingOnly">The reading only flag.</param>
    /// <returns>True if the sesison is for reading only; false otherwose. </returns>
    internal boolean paramReadingOnly(boolean _readingOnly = readingOnly)
    {
        readingOnly = _readingOnly;

        return readingOnly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramIsInitSync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value for the flag which indicates if the job is full or incremental sync.
    /// </summary>
    /// <param name="_isInitSync">
    /// Flag indicating whether the current job is running full sync or incremental sync.
    /// </param>
    /// <returns>
    /// Boolean value, true if job is a full sync; otherwise false.
    /// </returns>
    internal boolean paramIsInitSync(boolean _isInitSync = isInitSync)
    {
        isInitSync = _isInitSync;

        return isInitSync;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramScheduledAsFullSync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the falg which indicates if the download job is scheduled as full sync or not.
    /// </summary>
    /// <param name = "_scheduledAsFullSync">A flag indicating if the download sync is scheduled as full sync or not.</param>
    /// <returns>True if the download job is scheduled as a full sync download; false otherwise.</returns>
    internal RetailCdxIsScheduledFullPackage paramScheduledAsFullSync(RetailCdxIsScheduledFullPackage _scheduledAsFullSync = scheduledAsFullSync)
    {
        scheduledAsFullSync = _scheduledAsFullSync;

        return scheduledAsFullSync;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramSwitchedToFullSync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the flag which indicates whether the schedule is switched to full sync or not.
    /// </summary>
    /// <param name = "_switchedToFullSync">The flag indicating if the schedule is switched to a full sync.</param>
    /// <returns>True if the schedule is switched to full sync; false otherwise.</returns>
    internal RetailCdxIsScheduledFullPackage paramSwitchedToFullSync(RetailCdxIsScheduledFullPackage _switchedToFullSync = switchedToFullSync)
    {
        switchedToFullSync = _switchedToFullSync;

        return switchedToFullSync;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramCorrelationId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the correlation Id.
    /// </summary>
    /// <param name="_correlationId">The correlation Id.</param>
    /// <returns>The correlation Id.</returns>
    internal guid paramCorrelationId(guid _correlationId = correlationId)
    {
        correlationId = _correlationId;

        return correlationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramAllowSkipDataSync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value for the flag which indicates if the job should be skipped for certain datastores.
    /// </summary>
    /// <param name="_excludeFromOffline">
    /// Flag indicating whether the current job is skipped for certain datastores.
    /// </param>
    /// <returns>
    /// Boolean value, true if job is skipped for certain datastores; false otherwise.
    /// </returns>
    internal boolean paramAllowSkipDataSync(boolean _allowSkipDataSync = allowSkipDataSync)
    {
        allowSkipDataSync = _allowSkipDataSync;

        return allowSkipDataSync;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFullSyncFilteredRecordsTempTableInstance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the filtered records temp table instance for a full sync.
    /// </summary>
    /// <param name = "sourceTableId">The source table identifier</param>
    /// <param name = "isBaselineSync">Flag indicating whether the operation is performed to calculate
    /// the baseline change during when syncing to a data group containing a newly mapped store.
    /// </param>
    /// <returns>
    /// Filtered records temp table instance.
    /// </returns>
    internal RetailTmpCDXDataDistributionFilteredRecords getFullSyncFilteredRecordsTempTableInstance(TableId sourceTableId, boolean isBaselineSync = false)
    {
        str filterRecordsCacheKey = this.getFilterRecordsCacheKey(sourceTableId, isBaselineSync);

        RetailTmpCDXDataDistributionFilteredRecords filteredRecordsTempTable;

        if (fullSyncFilteredRecordsTempTableMap.exists(filterRecordsCacheKey))
        {
            filteredRecordsTempTable = (this.fullSyncFilteredRecordsTempTableMap.lookup(filterRecordsCacheKey) as RetailCDXTempDBTableWrapper).getInstance();
        }
        else
        {
            RetailCDXTempDBTableWrapper filteredRecordsTempTableClass = new RetailCDXTempDBTableWrapper(tableStr(RetailTmpCDXDataDistributionFilteredRecords));
            fullSyncFilteredRecordsTempTableMap.insert(filterRecordsCacheKey, filteredRecordsTempTableClass);
            filteredRecordsTempTable = filteredRecordsTempTableClass.getInstance();
        }

        return filteredRecordsTempTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDeltaSyncFilteredRecordsTempTableInstance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the delta sync filtered records temp table instance.
    /// </summary>
    /// <param name = "sourceTableId">The source table identifier</param>
    /// <param name = "isBaselineSync">Flag indicating whether the operation is performed to calculate
    /// the baseline change during when syncing to a data group containing a newly mapped store.
    /// </param>
    /// <returns>
    /// The delta sync filtered records temp table instance.
    /// </returns>
    internal RetailTmpCDXDataDistributionDeltaSyncFilteredRecords getDeltaSyncFilteredRecordsTempTableInstance(TableId sourceTableId, boolean isBaselineSync = false)
    {
        str filterRecordsCacheKey = this.getFilterRecordsCacheKey(sourceTableId, isBaselineSync);

        RetailTmpCDXDataDistributionDeltaSyncFilteredRecords deltaSyncFilteredRecordsTempTable;

        if (deltaSyncFilteredRecordsTempTableMap.exists(filterRecordsCacheKey))
        {
            deltaSyncFilteredRecordsTempTable = (this.deltaSyncFilteredRecordsTempTableMap.lookup(filterRecordsCacheKey) as RetailCDXTempDBTableWrapper).getInstance();
        }
        else
        {
            RetailCDXTempDBTableWrapper deltaSyncFilteredRecordsTempTableClass = new RetailCDXTempDBTableWrapper(tableStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords));
            deltaSyncFilteredRecordsTempTableMap.insert(filterRecordsCacheKey, deltaSyncFilteredRecordsTempTableClass);
            deltaSyncFilteredRecordsTempTable = deltaSyncFilteredRecordsTempTableClass.getInstance();
        }

        return deltaSyncFilteredRecordsTempTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markTableNodeAsProcessedForFullSync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks the table's node as already processed for a full sync.
    /// </summary>
    /// <param name = "nodeId">The table's node identifier in the table distribution.</param>
    /// <param name = "isBaselineSync">Flag indicating whether the operation is performed in the context of calculating
    /// the baseline full sync when syncing to a data group containing a newly mapped store.
    /// </param>
    internal void markTableNodeAsProcessedForFullSync(RetailCDXSqlQueryID nodeId, boolean isBaselineSync)
    {
        fullSyncProcessedTableNodeKeys.add(this.getTableNodeKey(nodeId, isBaselineSync));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFullSyncProcessedForTableNode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks the table's node as already processed for a full sync.
    /// </summary>
    /// <param name = "nodeId">The table's node identifier in the table distribution.</param>
    /// <param name = "isBaselineSync">Flag indicating whether the operation is performed in the context of calculating
    /// the baseline full sync when syncing to a data group containing a newly mapped store.
    /// </param>
    /// <remarks>A baseline sync operation is used to figure out what the full sync records
    /// would be without including the newly mapped stores.</remarks>
    internal boolean isFullSyncProcessedForTableNode(RetailCDXSqlQueryID nodeId, boolean isBaselineSync)
    {
        return fullSyncProcessedTableNodeKeys.in(this.getTableNodeKey(nodeId, isBaselineSync));
    }

]]></Source>
			</Method>
			<Method>
				<Name>markTableNodeAsProcessedForDeltaSync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks the table's node as already processed for a delta sync.
    /// </summary>
    /// <param name = "nodeId">The table's node identifier in the table distribution.</param>
    /// <param name = "isBaselineSync">Flag indicating whether the operation is performed in the context of calculating
    /// the baseline delta sync when syncing to a data group containing a newly mapped store.
    /// </param>
    internal void markTableNodeAsProcessedForDeltaSync(RetailCDXSqlQueryID nodeId, boolean isBaselineSync)
    {
        deltaSyncProcessedTableNodeKeys.add(this.getTableNodeKey(nodeId, isBaselineSync));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDeltaSyncProcessedForTableNode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks the table's node as already processed for a delta sync.
    /// </summary>
    /// <param name = "nodeId">The table's node identifier in the table distribution.</param>
    /// <param name = "isBaselineSync">Flag indicating whether the operation is performed in the context of calculating
    /// the baseline delta sync when syncing to a data group containing a newly mapped store.
    /// </param>
    /// <remarks>A baseline sync operation is used to figure out what the delta sync records
    /// would be without including the newly mapped stores.</remarks>
    internal boolean isDeltaSyncProcessedForTableNode(RetailCDXSqlQueryID nodeId, boolean isBaselineSync)
    {
        return deltaSyncProcessedTableNodeKeys.in(this.getTableNodeKey(nodeId, isBaselineSync));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTableNodeKey</Name>
				<Source><![CDATA[
    private str getTableNodeKey(RetailCDXSqlQueryID nodeId, boolean isBaselineSync)
    {
        str isBaselineSuffix = isBaselineSync ? '_Baseline' : '';
        str tableNodeKey = strFmt('%1%2', nodeId, isBaselineSuffix);
        return tableNodeKey;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFilterRecordsCacheKey</Name>
				<Source><![CDATA[
    private str getFilterRecordsCacheKey(TableId tableId, boolean isBaselineSync = false)
    {
        str tableIdLookupKey = !isBaselineSync ? int2Str(tableId) : strFmt('%1_Baseline', tableId);
        return tableIdLookupKey;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramIsCacheBasedQueryEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value for the flag which indicates if cache based query is enabled.
    /// </summary>
    /// <param name="_isCacheBasedQueryEnabled">
    /// Flag indicating whether cache based query is enabled.
    /// </param>
    /// <returns>
    /// True if cache based query is enabled; otherwise false.
    /// </returns>
    internal boolean paramIsCacheBasedQueryEnabled(boolean _isCacheBasedQueryEnabled = isCacheBasedQueryEnabled)
    {
        isCacheBasedQueryEnabled = _isCacheBasedQueryEnabled;

        return isCacheBasedQueryEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramInitializationResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value for the flag which indicates the initialization method result.
    /// </summary>
    /// <param name="_initializationResult">
    /// Flag indicating the initialization method Result.
    /// </param>
    /// <returns>
    /// True if initializationResult set to true; otherwise false.
    /// </returns>
    internal boolean paramInitializationResult(boolean _initializationResult = initializationResult)
    {
        initializationResult = _initializationResult;

        return initializationResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramIsPackageGenerationOrderByUniqueClusteredIndexEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value for the flag which indicates if order by unique clustered index is enabled when writing to csv files.
    /// </summary>
    /// <param name="_isPackageGenerationOrderByUniqueClusteredIndexEnabled">
    /// Flag indicating whether order by unique clustered index is enabled.
    /// </param>
    /// <returns>
    /// True if order by unique clustered index is enabled; otherwise false.
    /// </returns>
    internal boolean paramIsPackageGenerationOrderByUniqueClusteredIndexEnabled(boolean _isPackageGenerationOrderByUniqueClusteredIndexEnabled = isPackageGenerationOrderByUniqueClusteredIndexEnabled)
    {
        isPackageGenerationOrderByUniqueClusteredIndexEnabled = _isPackageGenerationOrderByUniqueClusteredIndexEnabled;

        return isPackageGenerationOrderByUniqueClusteredIndexEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramIsSortCdxPackageByPrimaryIndexEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value for the flag which indicates if order by primary index is enabled when writing to csv files.
    /// </summary>
    /// <param name="_isSortCdxPackageByPrimaryIndexEnabled">
    /// Flag indicating whether order by primary index is enabled.
    /// </param>
    /// <returns>
    /// True if order by primary index is enabled; otherwise false.
    /// </returns>
    internal boolean paramIsSortCdxPackageByPrimaryIndexEnabled(boolean _isSortCdxPackageByPrimaryIndexEnabled = isSortCdxPackageByPrimaryIndexEnabled)
    {
        isSortCdxPackageByPrimaryIndexEnabled = _isSortCdxPackageByPrimaryIndexEnabled;

        return isSortCdxPackageByPrimaryIndexEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramIsDateFilterEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value for the flag which indicates if date filter is enabled.
    /// </summary>
    /// <param name="_isDateFilterEnabled">
    /// Flag indicating whether date filter is enabled.
    /// </param>
    /// <returns>
    /// True if date filter is enabled; otherwise false.
    /// </returns>
    internal boolean paramIsDateFilterEnabled(boolean _isDateFilterEnabled = isDateFilterEnabled)
    {
        isDateFilterEnabled = _isDateFilterEnabled;

        return isDateFilterEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clean up tempDB resources used in the data sync operation.
    /// </summary>
    internal void cleanData()
    {
        // truncate the table as there is no need for delete which takes more time.
        this.truncateTable(ref1);
        this.truncateTable(ref3);

        // these temp tables are only required for the legacy (non cache based query) data sync approach, so skip cleaning up stage if we are using cache based query approach.
        if (!this.paramIsCacheBasedQueryEnabled())
        {
            this.truncateTable(ref2);
            this.truncateTable(ref2_base);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeSessionNumbers</Name>
				<Source><![CDATA[
    internal void initializeSessionNumbers()
    {
        MapEnumerator sessionsEnumerator = sessions.getEnumerator();

        while (sessionsEnumerator.moveNext())
        {
            RetailCDXDataSyncContextSession currentSession = sessionsEnumerator.currentValue();

            int64 nextSession = RetailCDXSessionIDGenerator::getNextSession();

            if (nextSession <= 0)
            {
                throw error(strFmt("@REX1575", nextSession));
            }

            currentSession.parmSessionNumber(nextSession);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDataFilteredSessionsAsCurrent</Name>
				<Source><![CDATA[
    internal int setDataFilteredSessionsAsCurrent()
    {
        int totalCurrentSessionsSelected;

        currentSessions = new Set(Types::Class);

        MapEnumerator sessionsEnumerator = sessions.getEnumerator();

        while (sessionsEnumerator.moveNext())
        {
            if (sessionsEnumerator.currentKey() == RetailCDXDownloadSessionType::DataFiltered)
            {
                currentSessions.add(sessionsEnumerator.currentValue());
                totalCurrentSessionsSelected++;
            }
        }

        return totalCurrentSessionsSelected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDefaultSessionsAsCurrent</Name>
				<Source><![CDATA[
    internal int setDefaultSessionsAsCurrent()
    {
        int totalCurrentSessionsSelected;

        currentSessions = new Set(Types::Class);

        MapEnumerator sessionsEnumerator = sessions.getEnumerator();

        while (sessionsEnumerator.moveNext())
        {
            if (sessionsEnumerator.currentKey() == RetailCDXDownloadSessionType::Default)
            {
                currentSessions.add(sessionsEnumerator.currentValue());
                totalCurrentSessionsSelected++;
            }
        }

        return totalCurrentSessionsSelected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAllSessionsAsCurrent</Name>
				<Source><![CDATA[
    internal int setAllSessionsAsCurrent()
    {
        int totalCurrentSessionsSelected;

        currentSessions = new Set(Types::Class);

        MapEnumerator sessionsEnumerator = sessions.getEnumerator();

        while (sessionsEnumerator.moveNext())
        {
            currentSessions.add(sessionsEnumerator.currentValue());
            totalCurrentSessionsSelected++;
        }

        return totalCurrentSessionsSelected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDataStore</Name>
				<Source><![CDATA[
    private void addDataStore(RetailConnDatabaseProfile _databaseProfile)
    {
        if (_databaseProfile)
        {
            if (_databaseProfile.DataStoreType == RetailCDXDataStoreType::OfflineDatabase && this.shouldFilterOfflineData())
            {
                this.addDataStoreToSession(_databaseProfile.RecId, RetailCDXDownloadSessionType::DataFiltered, this.paramAllowSkipDataSync());
            }
            else
            {
                this.addDataStoreToSession(_databaseProfile.RecId, RetailCDXDownloadSessionType::Default);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldFilterOfflineData</Name>
				<Source><![CDATA[
    private boolean shouldFilterOfflineData()
    {
        return this.paramAllowSkipDataSync() || hasSubjobToBeSkipped || hasDataFilteringEntityEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDataStoreToSession</Name>
				<Source><![CDATA[
    private void addDataStoreToSession(RefRecId _dataStoreRecId, RetailCDXDownloadSessionType _sessionType, boolean _skipJobSync = false)
    {
        RetailCDXDataSyncContextSession contextSession;

        if (sessions.exists(_sessionType))
        {
            contextSession = sessions.lookup(_sessionType);
        }
        else
        {
            contextSession = new RetailCDXDataSyncContextSession(_sessionType, _skipJobSync);
        }

        contextSession.addDataStore(_dataStoreRecId);

        sessions.insert(_sessionType, contextSession);
    }

]]></Source>
			</Method>
			<Method>
				<Name>truncateTable</Name>
				<Source><![CDATA[
    private void truncateTable(Common _table)
    {
        str tableName = _table.getPhysicalTableName();
        str sql = strFmt(@"TRUNCATE TABLE %1", tableName);

        Statement stmt = new Connection().createStatement();
        new SqlStatementExecutePermission(sql).assert();
        try
        {
            stmt.executeUpdateWithParameters(sql, null);
        }
        finally
        {
            CodeAccessPermission::revertAssert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRowVersion</Name>
				<Source><![CDATA[
    private void updateRowVersion()
    {
        if (shouldUpdateRowVersion)
        {
            RetailCDXDataSyncRowVersion::updateRowVersion(
                this.paramDataGroupRecID(),
                this.paramJobID(),
                this.ParamCurrentSyncVer());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addException</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the exception message to the data sync context error list.
    /// </summary>
    /// <param name = "exception">The exception object.</param>
    internal void addException(System.Exception exception)
    {
        str errorMessage = exception != null ? exception.ToString() : '';
        if (errorMessage != '')
        {
            errors += errorMessage;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getErrorMessages</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a string containing all errors that occured while executing the data sync.
    /// </summary>
    /// <param name = "errorMessage">The error message.</param>
    internal str getErrorMessages()
    {
        return con2Str(conReverse(errors), '\n');
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldAllowSkipDataSync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a boolean indicating whether download session creation should be skipped for a given job for certain datastores.
    /// </summary>
    /// <param name="_jobId">The job identifier.</param>
    /// <returns>True if data sync should be skipped; false otherwise.</returns>
    internal static boolean shouldAllowSkipDataSync(RetailConnJobId _jobId)
    {
        RetailConnSchedulerJobTable job;
        RetailConnChannelSchema channelSchema;

        select firstonly AllowSkipDataSync from job
            join channelSchema
            where job.RetailConnChannelSchema == channelSchema.RecId
                && job.jobId == _jobId;

        return job.AllowSkipDataSync;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllDataStores</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the list of all data store record Ids.
    /// </summary>
    /// <returns>The list of all data store record Ids (union of all the sessions).</returns>
    internal Set getAllDataStores()
    {
        Set allDataStores = new Set(Types::Int64);

        MapEnumerator sessionsEnumerator = sessions.getEnumerator();
        while (sessionsEnumerator.moveNext())
        {
            allDataStores = Set::union(allDataStores, sessionsEnumerator.currentValue().getDataStores());
        }
        
        return allDataStores;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramBatchJobId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value of Batch job Id.
    /// </summary>
    /// <param name="_batchJobId">
    /// The value of <c>_batchJobId</c>; optional.
    /// </param>
    /// <returns>
    /// Batch job Id.
    /// </returns>
    internal RefRecId paramBatchJobId(RefRecId _batchJobId = batchJobId)
    {
        batchJobId = _batchJobId;

        return batchJobId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateDataFileName</Name>
				<Source><![CDATA[
    private static Filename generateDataFileName(RetailCDXDataGroupRefRecId _recId, RetailCDXSessionNumber _sessionNumber)
    {
        // DataGroupRecID-SessionID-R.zip
        Filename name = strFmt('%1-%2-R.zip', _recId, _sessionNumber);
        return name;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>